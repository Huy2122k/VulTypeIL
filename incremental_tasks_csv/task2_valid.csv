cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2017-1000424,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,electron,add some minor fixes,8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda,https://github.com/electron/electron/commit/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda,atom/browser/atom_web_ui_controller_factory.cc,AtomWebUIControllerFactory::CreateWebUIControllerForURL,"content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* web_ui,
const GURL& url) const {
if (url.host() == kPdfViewerUIHost) {
base::StringPairs toplevel_params;
base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);
std::string stream_id, src;
const net::UnescapeRule::Type unescape_rules =
net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;
for (const auto& param : toplevel_params) {
if (param.first == kPdfPluginSrc) {
src = net::UnescapeURLComponent(param.second, unescape_rules);
}
}
if (url.has_ref()) {
src = src + '#' + url.ref();
}
auto browser_context = web_ui->GetWebContents()->GetBrowserContext();
return new PdfViewerUI(browser_context, web_ui, src);
}
return nullptr;
}","content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* VAR_0,
const GURL& VAR_1) const {
if (VAR_1.host() == VAR_2) {
base::StringPairs VAR_3;
base::SplitStringIntoKeyValuePairs(VAR_1.query(), '=', '&', &VAR_3);
std::string VAR_4, VAR_5;
const net::UnescapeRule::Type VAR_6 =
net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;
for (const auto& VAR_7 : VAR_3) {
if (VAR_7.first == VAR_8) {
VAR_5 = net::UnescapeURLComponent(VAR_7.second, VAR_6);
}
}
if (VAR_1.has_ref()) {
VAR_5 = VAR_5 + '#' + VAR_1.ref();
}
auto VAR_9 = VAR_0->GetWebContents()->GetBrowserContext();
return new PdfViewerUI(VAR_9, VAR_0, VAR_5);
}
return nullptr;
}",electron/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda/atom_web_ui_controller_factory.cc/vul/before/0.json,"content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* web_ui,
                                                        const GURL& url) const {
  if (url.host() == kPdfViewerUIHost) {
    base::StringPairs toplevel_params;
    base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);
    std::string stream_id, src;

    const net::UnescapeRule::Type unescape_rules =
      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;

    for (const auto& param : toplevel_params) {
      if (param.first == kPdfPluginSrc) {
        src = net::UnescapeURLComponent(param.second, unescape_rules);
      }
    }
    if (url.has_ref()) {
      src = src + '#' + url.ref();
    }
    auto browser_context = web_ui->GetWebContents()->GetBrowserContext();
    return new PdfViewerUI(browser_context, web_ui, src);
  }
  return nullptr;
}","content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* VAR_0,
                                                        const GURL& VAR_1) const {
  if (VAR_1.host() == VAR_2) {
    base::StringPairs VAR_3;
    base::SplitStringIntoKeyValuePairs(VAR_1.query(), '=', '&', &VAR_3);
    std::string VAR_4, VAR_5;

    const net::UnescapeRule::Type VAR_6 =
      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;

    for (const auto& VAR_7 : VAR_3) {
      if (VAR_7.first == VAR_8) {
        VAR_5 = net::UnescapeURLComponent(VAR_7.second, VAR_6);
      }
    }
    if (VAR_1.has_ref()) {
      VAR_5 = VAR_5 + '#' + VAR_1.ref();
    }
    auto VAR_9 = VAR_0->GetWebContents()->GetBrowserContext();
    return new PdfViewerUI(VAR_9, VAR_0, VAR_5);
  }
  return nullptr;
}",electron/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda/atom_web_ui_controller_factory.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,10 +7,9 @@
     std::string stream_id, src;
 
     const net::UnescapeRule::Type unescape_rules =
-      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
       net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
       net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
-      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;
+      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;
 
     for (const auto& param : toplevel_params) {
       if (param.first == kPdfPluginSrc) {","{'deleted_lines': ['      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |', '      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;'], 'added_lines': ['      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;']}",True,Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.,4.3,MEDIUM,1,valid,2017-07-15T02:32:46Z,2
CVE-2017-1000424,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,electron,add some minor fixes,8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda,https://github.com/electron/electron/commit/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda,atom/browser/atom_resource_dispatcher_host_delegate.cc,OnPdfResourceIntercepted,"void OnPdfResourceIntercepted(
const GURL& original_url,
const content::ResourceRequestInfo::WebContentsGetter&
web_contents_getter) {
content::WebContents* web_contents = web_contents_getter.Run();
if (!web_contents)
return;
if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
auto browser_context = web_contents->GetBrowserContext();
auto download_manager =
content::BrowserContext::GetDownloadManager(browser_context);
download_manager->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
web_contents, original_url));
return;
}
GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));
content::NavigationController::LoadURLParams params(
GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,
kPdfPluginSrc, escaped_url.spec().c_str())));
web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
const GURL& VAR_0,
const content::ResourceRequestInfo::WebContentsGetter&
VAR_1) {
content::WebContents* VAR_2 = VAR_1.Run();
if (!VAR_2)
return;
if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
auto VAR_3 = VAR_2->GetBrowserContext();
auto VAR_4 =
content::BrowserContext::GetDownloadManager(VAR_3);
VAR_4->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
VAR_2, VAR_0));
return;
}
GURL VAR_5(net::EscapeUrlEncodedData(VAR_0.spec(), true));
content::NavigationController::LoadURLParams VAR_6(
GURL(base::StringPrintf(""%sindex.html?%s=%s"", VAR_7,
VAR_8, VAR_5.spec().c_str())));
VAR_2->GetController().LoadURLWithParams(VAR_6);
}",electron/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda/atom_resource_dispatcher_host_delegate.cc/vul/before/0.json,"void OnPdfResourceIntercepted(
    const GURL& original_url,
    const content::ResourceRequestInfo::WebContentsGetter&
        web_contents_getter) {
  content::WebContents* web_contents = web_contents_getter.Run();
  if (!web_contents)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
    auto browser_context = web_contents->GetBrowserContext();
    auto download_manager =
      content::BrowserContext::GetDownloadManager(browser_context);

    download_manager->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            web_contents, original_url));
    return;
  }

  // The URL passes the original pdf resource url, that will be requested
  // by the webui page.
  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
  content::NavigationController::LoadURLParams params(
      GURL(base::StringPrintf(""%sindex.html?%s=%s"",
                              kPdfViewerUIOrigin,
                              kPdfPluginSrc,
                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
  web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
    const GURL& VAR_0,
    const content::ResourceRequestInfo::WebContentsGetter&
        VAR_1) {
  content::WebContents* VAR_2 = VAR_1.Run();
  if (!VAR_2)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
    auto VAR_3 = VAR_2->GetBrowserContext();
    auto VAR_4 =
      content::BrowserContext::GetDownloadManager(VAR_3);

    VAR_4->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            VAR_2, VAR_0));
    return;
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  content::NavigationController::LoadURLParams VAR_5(
      GURL(base::StringPrintf(""%sindex.html?%s=%s"",
                              VAR_6,
                              VAR_7,
                              net::EscapeUrlEncodedData(VAR_0.spec(), false).c_str())));
  VAR_2->GetController().LoadURLWithParams(VAR_5);
}",electron/8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda/atom_resource_dispatcher_host_delegate.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,9 +20,10 @@
   // The URL passes the original pdf resource url, that will be requested
   // by the webui page.
   // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
-  GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));
   content::NavigationController::LoadURLParams params(
-      GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,
-                              kPdfPluginSrc, escaped_url.spec().c_str())));
+      GURL(base::StringPrintf(""%sindex.html?%s=%s"",
+                              kPdfViewerUIOrigin,
+                              kPdfPluginSrc,
+                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
   web_contents->GetController().LoadURLWithParams(params);
 }","{'deleted_lines': ['  GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));', '      GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,', '                              kPdfPluginSrc, escaped_url.spec().c_str())));'], 'added_lines': ['      GURL(base::StringPrintf(""%sindex.html?%s=%s"",', '                              kPdfViewerUIOrigin,', '                              kPdfPluginSrc,', '                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));']}",True,Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.,4.3,MEDIUM,1,valid,2017-07-15T02:32:46Z,2
CVE-2017-1000424,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,electron,fix lint,4fb1fffe44e7ffdb5d701a90fefc1b6e71ff1b3c,https://github.com/electron/electron/commit/4fb1fffe44e7ffdb5d701a90fefc1b6e71ff1b3c,atom/browser/atom_resource_dispatcher_host_delegate.cc,OnPdfResourceIntercepted,"void OnPdfResourceIntercepted(
const GURL& original_url,
const content::ResourceRequestInfo::WebContentsGetter&
web_contents_getter) {
content::WebContents* web_contents = web_contents_getter.Run();
if (!web_contents)
return;
if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
auto browser_context = web_contents->GetBrowserContext();
auto download_manager =
content::BrowserContext::GetDownloadManager(browser_context);
download_manager->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
web_contents, original_url));
return;
}
content::NavigationController::LoadURLParams params(
GURL(base::StringPrintf(""%sindex.html?%s=%s"",
kPdfViewerUIOrigin,
kPdfPluginSrc,
net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
const GURL& VAR_0,
const content::ResourceRequestInfo::WebContentsGetter&
VAR_1) {
content::WebContents* VAR_2 = VAR_1.Run();
if (!VAR_2)
return;
if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
auto VAR_3 = VAR_2->GetBrowserContext();
auto VAR_4 =
content::BrowserContext::GetDownloadManager(VAR_3);
VAR_4->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
VAR_2, VAR_0));
return;
}
content::NavigationController::LoadURLParams VAR_5(
GURL(base::StringPrintf(""%sindex.html?%s=%s"",
VAR_6,
VAR_7,
net::EscapeUrlEncodedData(VAR_0.spec(), false).c_str())));
VAR_2->GetController().LoadURLWithParams(VAR_5);
}",electron/4fb1fffe44e7ffdb5d701a90fefc1b6e71ff1b3c/atom_resource_dispatcher_host_delegate.cc/vul/before/0.json,"void OnPdfResourceIntercepted(
    const GURL& original_url,
    const content::ResourceRequestInfo::WebContentsGetter&
        web_contents_getter) {
  content::WebContents* web_contents = web_contents_getter.Run();
  if (!web_contents)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
    auto browser_context = web_contents->GetBrowserContext();
    auto download_manager =
      content::BrowserContext::GetDownloadManager(browser_context);

    download_manager->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            web_contents, original_url));
    return;
  }

  // The URL passes the original pdf resource url, that will be requested
  // by the webui page.
  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
  content::NavigationController::LoadURLParams params(
      GURL(base::StringPrintf(
          ""%sindex.html?%s=%s"",
          kPdfViewerUIOrigin,
          kPdfPluginSrc,
          net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
  web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
    const GURL& VAR_0,
    const content::ResourceRequestInfo::WebContentsGetter&
        VAR_1) {
  content::WebContents* VAR_2 = VAR_1.Run();
  if (!VAR_2)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
    auto VAR_3 = VAR_2->GetBrowserContext();
    auto VAR_4 =
      content::BrowserContext::GetDownloadManager(VAR_3);

    VAR_4->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            VAR_2, VAR_0));
    return;
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  content::NavigationController::LoadURLParams VAR_5(
      GURL(base::StringPrintf(
          ""%sindex.html?%s=%s"",
          VAR_6,
          VAR_7,
          net::EscapeUrlEncodedData(VAR_0.spec(), false).c_str())));
  VAR_2->GetController().LoadURLWithParams(VAR_5);
}",electron/4fb1fffe44e7ffdb5d701a90fefc1b6e71ff1b3c/atom_resource_dispatcher_host_delegate.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,9 +21,10 @@
   // by the webui page.
   // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
   content::NavigationController::LoadURLParams params(
-      GURL(base::StringPrintf(""%sindex.html?%s=%s"",
-                              kPdfViewerUIOrigin,
-                              kPdfPluginSrc,
-                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
+      GURL(base::StringPrintf(
+          ""%sindex.html?%s=%s"",
+          kPdfViewerUIOrigin,
+          kPdfPluginSrc,
+          net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
   web_contents->GetController().LoadURLWithParams(params);
 }","{'deleted_lines': ['      GURL(base::StringPrintf(""%sindex.html?%s=%s"",', '                              kPdfViewerUIOrigin,', '                              kPdfPluginSrc,', '                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));'], 'added_lines': ['      GURL(base::StringPrintf(', '          ""%sindex.html?%s=%s"",', '          kPdfViewerUIOrigin,', '          kPdfPluginSrc,', '          net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));']}",True,Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.,4.3,MEDIUM,1,valid,2017-07-15T02:57:16Z,2
CVE-2017-11536,['CWE-772'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/567,167e1538ae9818d46c9462a4273082871e35a480,https://github.com/ImageMagick/ImageMagick/commit/167e1538ae9818d46c9462a4273082871e35a480,coders/jp2.c,WriteJP2Image,"static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
const char
*option,
*property;
int
jp2_status;
MagickBooleanType
status;
opj_codec_t
*jp2_codec;
OPJ_COLOR_SPACE
jp2_colorspace;
opj_cparameters_t
parameters;
opj_image_cmptparm_t
jp2_info[5];
opj_image_t
*jp2_image;
opj_stream_t
*jp2_stream;
register ssize_t
i;
ssize_t
y;
unsigned int
channels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
opj_set_default_encoder_parameters(&parameters);
for (i=1; i < 6; i++)
if (((size_t) (1UL << (i+2)) > image->columns) &&
((size_t) (1UL << (i+2)) > image->rows))
break;
parameters.numresolution=i;
option=GetImageOption(image_info,""jp2:number-resolutions"");
if (option != (const char *) NULL)
parameters.numresolution=StringToInteger(option);
parameters.tcp_numlayers=1;
parameters.tcp_rates[0]=0;  
parameters.cp_disto_alloc=1;
if ((image_info->quality != 0) && (image_info->quality != 100))
{
parameters.tcp_distoratio[0]=(double) image_info->quality;
parameters.cp_fixed_quality=OPJ_TRUE;
}
if (image_info->extract != (char *) NULL)
{
RectangleInfo
geometry;
int
flags;
flags=ParseAbsoluteGeometry(image_info->extract,&geometry);
parameters.cp_tdx=(int) geometry.width;
parameters.cp_tdy=(int) geometry.width;
if ((flags & HeightValue) != 0)
parameters.cp_tdy=(int) geometry.height;
if ((flags & XValue) != 0)
parameters.cp_tx0=geometry.x;
if ((flags & YValue) != 0)
parameters.cp_ty0=geometry.y;
parameters.tile_size_on=OPJ_TRUE;
}
option=GetImageOption(image_info,""jp2:quality"");
if (option != (const char *) NULL)
{
register const char
*p;
p=option;
for (i=0; sscanf(p,""%f"",&parameters.tcp_distoratio[i]) == 1; i++)
{
if (i > 100)
break;
while ((*p != '\0') && (*p != ','))
p++;
if (*p == '\0')
break;
p++;
}
parameters.tcp_numlayers=i+1;
parameters.cp_fixed_quality=OPJ_TRUE;
}
option=GetImageOption(image_info,""jp2:progression-order"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""LRCP"") == 0)
parameters.prog_order=OPJ_LRCP;
if (LocaleCompare(option,""RLCP"") == 0)
parameters.prog_order=OPJ_RLCP;
if (LocaleCompare(option,""RPCL"") == 0)
parameters.prog_order=OPJ_RPCL;
if (LocaleCompare(option,""PCRL"") == 0)
parameters.prog_order=OPJ_PCRL;
if (LocaleCompare(option,""CPRL"") == 0)
parameters.prog_order=OPJ_CPRL;
}
option=GetImageOption(image_info,""jp2:rate"");
if (option != (const char *) NULL)
{
register const char
*p;
p=option;
for (i=0; sscanf(p,""%f"",&parameters.tcp_rates[i]) == 1; i++)
{
if (i >= 100)
break;
while ((*p != '\0') && (*p != ','))
p++;
if (*p == '\0')
break;
p++;
}
parameters.tcp_numlayers=i+1;
parameters.cp_disto_alloc=OPJ_TRUE;
}
if (image_info->sampling_factor != (const char *) NULL)
(void) sscanf(image_info->sampling_factor,""%d,%d"",
&parameters.subsampling_dx,&parameters.subsampling_dy);
property=GetImageProperty(image,""comment"",exception);
if (property != (const char *) NULL)
parameters.cp_comment=ConstantString(property);
channels=3;
jp2_colorspace=OPJ_CLRSPC_SRGB;
if (image->colorspace == YUVColorspace)
{
jp2_colorspace=OPJ_CLRSPC_SYCC;
parameters.subsampling_dx=2;
}
else
{
if (IsGrayColorspace(image->colorspace) != MagickFalse)
{
channels=1;
jp2_colorspace=OPJ_CLRSPC_GRAY;
}
else
(void) TransformImageColorspace(image,sRGBColorspace,exception);
if (image->alpha_trait != UndefinedPixelTrait)
channels++;
}
parameters.tcp_mct=channels == 3 ? 1 : 0;
ResetMagickMemory(jp2_info,0,sizeof(jp2_info));
for (i=0; i < (ssize_t) channels; i++)
{
jp2_info[i].prec=(OPJ_UINT32) image->depth;
jp2_info[i].bpp=(OPJ_UINT32) image->depth;
if ((image->depth == 1) &&
((LocaleCompare(image_info->magick,""JPT"") == 0) ||
(LocaleCompare(image_info->magick,""JP2"") == 0)))
{
jp2_info[i].prec++;  
jp2_info[i].bpp++;
}
jp2_info[i].sgnd=0;
jp2_info[i].dx=parameters.subsampling_dx;
jp2_info[i].dy=parameters.subsampling_dy;
jp2_info[i].w=(OPJ_UINT32) image->columns;
jp2_info[i].h=(OPJ_UINT32) image->rows;
}
jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);
if (jp2_image == (opj_image_t *) NULL)
ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
jp2_image->x0=parameters.image_offset_x0;
jp2_image->y0=parameters.image_offset_y0;
jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*
parameters.subsampling_dx+1);
jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*
parameters.subsampling_dx+1);
if ((image->depth == 12) &&
((image->columns == 2048) || (image->rows == 1080) ||
(image->columns == 4096) || (image->rows == 2160)))
CinemaProfileCompliance(jp2_image,&parameters);
if (channels == 4)
jp2_image->comps[3].alpha=1;
else
if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))
jp2_image->comps[1].alpha=1;
for (y=0; y < (ssize_t) image->rows; y++)
{
register const Quantum
*p;
ssize_t
x;
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
for (i=0; i < (ssize_t) channels; i++)
{
double
scale;
register int
*q;
scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;
q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*
image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);
switch (i)
{
case 0:
{
if (jp2_colorspace == OPJ_CLRSPC_GRAY)
{
*q=(int) (scale*GetPixelLuma(image,p));
break;
}
*q=(int) (scale*GetPixelRed(image,p));
break;
}
case 1:
{
if (jp2_colorspace == OPJ_CLRSPC_GRAY)
{
*q=(int) (scale*GetPixelAlpha(image,p));
break;
}
*q=(int) (scale*GetPixelGreen(image,p));
break;
}
case 2:
{
*q=(int) (scale*GetPixelBlue(image,p));
break;
}
case 3:
{
*q=(int) (scale*GetPixelAlpha(image,p));
break;
}
}
}
p+=GetPixelChannels(image);
}
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
if (LocaleCompare(image_info->magick,""JPT"") == 0)
jp2_codec=opj_create_compress(OPJ_CODEC_JPT);
else
if (LocaleCompare(image_info->magick,""J2K"") == 0)
jp2_codec=opj_create_compress(OPJ_CODEC_J2K);
else
jp2_codec=opj_create_compress(OPJ_CODEC_JP2);
opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);
opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);
opj_setup_encoder(jp2_codec,&parameters,jp2_image);
jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);
opj_stream_set_read_function(jp2_stream,JP2ReadHandler);
opj_stream_set_write_function(jp2_stream,JP2WriteHandler);
opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);
opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);
opj_stream_set_user_data(jp2_stream,image,NULL);
if (jp2_stream == (opj_stream_t *) NULL)
ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);
if (jp2_status == 0)
ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
if ((opj_encode(jp2_codec,jp2_stream) == 0) ||
(opj_end_compress(jp2_codec,jp2_stream) == 0))
{
opj_stream_destroy(jp2_stream);
opj_destroy_codec(jp2_codec);
opj_image_destroy(jp2_image);
ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
}
opj_stream_destroy(jp2_stream);
opj_destroy_codec(jp2_codec);
opj_image_destroy(jp2_image);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteJP2Image(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
const char
*VAR_3,
*VAR_4;
int
VAR_5;
MagickBooleanType
VAR_6;
opj_codec_t
*VAR_7;
OPJ_COLOR_SPACE
VAR_8;
opj_cparameters_t
VAR_9;
opj_image_cmptparm_t
VAR_10[5];
opj_image_t
*VAR_11;
opj_stream_t
*VAR_12;
register ssize_t
VAR_13;
ssize_t
VAR_14;
unsigned int
VAR_15;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_16);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_16);
if (VAR_1->debug != VAR_17)
(void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_16);
VAR_6=OpenBlob(VAR_0,VAR_1,VAR_19,VAR_2);
if (VAR_6 == VAR_17)
return(VAR_6);
opj_set_default_encoder_parameters(&VAR_9);
for (VAR_13=1; VAR_13 < 6; VAR_13++)
if (((size_t) (1UL << (VAR_13+2)) > VAR_1->columns) &&
((size_t) (1UL << (VAR_13+2)) > VAR_1->rows))
break;
VAR_9.numresolution=VAR_13;
VAR_3=GetImageOption(VAR_0,""jp2:number-resolutions"");
if (VAR_3 != (const char *) NULL)
VAR_9.numresolution=StringToInteger(VAR_3);
VAR_9.tcp_numlayers=1;
VAR_9.tcp_rates[0]=0;  
VAR_9.cp_disto_alloc=1;
if ((VAR_0->quality != 0) && (VAR_0->quality != 100))
{
VAR_9.tcp_distoratio[0]=(double) VAR_0->quality;
VAR_9.cp_fixed_quality=VAR_20;
}
if (VAR_0->extract != (char *) NULL)
{
RectangleInfo
VAR_21;
int
VAR_22;
VAR_22=ParseAbsoluteGeometry(VAR_0->extract,&VAR_21);
VAR_9.cp_tdx=(int) VAR_21.width;
VAR_9.cp_tdy=(int) VAR_21.width;
if ((VAR_22 & VAR_23) != 0)
VAR_9.cp_tdy=(int) VAR_21.height;
if ((VAR_22 & VAR_24) != 0)
VAR_9.cp_tx0=VAR_21.x;
if ((VAR_22 & VAR_25) != 0)
VAR_9.cp_ty0=VAR_21.y;
VAR_9.tile_size_on=VAR_20;
}
VAR_3=GetImageOption(VAR_0,""jp2:quality"");
if (VAR_3 != (const char *) NULL)
{
register const char
*VAR_26;
VAR_26=VAR_3;
for (VAR_13=0; sscanf(VAR_26,""%f"",&VAR_9.tcp_distoratio[VAR_13]) == 1; VAR_13++)
{
if (VAR_13 > 100)
break;
while ((*VAR_26 != '\0') && (*VAR_26 != ','))
VAR_26++;
if (*VAR_26 == '\0')
break;
VAR_26++;
}
VAR_9.tcp_numlayers=VAR_13+1;
VAR_9.cp_fixed_quality=VAR_20;
}
VAR_3=GetImageOption(VAR_0,""jp2:progression-order"");
if (VAR_3 != (const char *) NULL)
{
if (LocaleCompare(VAR_3,""LRCP"") == 0)
VAR_9.prog_order=VAR_27;
if (LocaleCompare(VAR_3,""RLCP"") == 0)
VAR_9.prog_order=VAR_28;
if (LocaleCompare(VAR_3,""RPCL"") == 0)
VAR_9.prog_order=VAR_29;
if (LocaleCompare(VAR_3,""PCRL"") == 0)
VAR_9.prog_order=VAR_30;
if (LocaleCompare(VAR_3,""CPRL"") == 0)
VAR_9.prog_order=VAR_31;
}
VAR_3=GetImageOption(VAR_0,""jp2:rate"");
if (VAR_3 != (const char *) NULL)
{
register const char
*VAR_26;
VAR_26=VAR_3;
for (VAR_13=0; sscanf(VAR_26,""%f"",&VAR_9.tcp_rates[VAR_13]) == 1; VAR_13++)
{
if (VAR_13 >= 100)
break;
while ((*VAR_26 != '\0') && (*VAR_26 != ','))
VAR_26++;
if (*VAR_26 == '\0')
break;
VAR_26++;
}
VAR_9.tcp_numlayers=VAR_13+1;
VAR_9.cp_disto_alloc=VAR_20;
}
if (VAR_0->sampling_factor != (const char *) NULL)
(void) sscanf(VAR_0->sampling_factor,""%d,%d"",
&VAR_9.subsampling_dx,&VAR_9.subsampling_dy);
VAR_4=GetImageProperty(VAR_1,""comment"",VAR_2);
if (VAR_4 != (const char *) NULL)
VAR_9.cp_comment=ConstantString(VAR_4);
VAR_15=3;
VAR_8=VAR_32;
if (VAR_1->colorspace == VAR_33)
{
VAR_8=VAR_34;
VAR_9.subsampling_dx=2;
}
else
{
if (IsGrayColorspace(VAR_1->colorspace) != VAR_17)
{
VAR_15=1;
VAR_8=VAR_35;
}
else
(void) TransformImageColorspace(VAR_1,VAR_36,VAR_2);
if (VAR_1->alpha_trait != VAR_37)
VAR_15++;
}
VAR_9.tcp_mct=VAR_15 == 3 ? 1 : 0;
ResetMagickMemory(VAR_10,0,sizeof(VAR_10));
for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
{
VAR_10[VAR_13].prec=(OPJ_UINT32) VAR_1->depth;
VAR_10[VAR_13].bpp=(OPJ_UINT32) VAR_1->depth;
if ((VAR_1->depth == 1) &&
((LocaleCompare(VAR_0->magick,""JPT"") == 0) ||
(LocaleCompare(VAR_0->magick,""JP2"") == 0)))
{
VAR_10[VAR_13].prec++;  
VAR_10[VAR_13].bpp++;
}
VAR_10[VAR_13].sgnd=0;
VAR_10[VAR_13].dx=VAR_9.subsampling_dx;
VAR_10[VAR_13].dy=VAR_9.subsampling_dy;
VAR_10[VAR_13].w=(OPJ_UINT32) VAR_1->columns;
VAR_10[VAR_13].h=(OPJ_UINT32) VAR_1->rows;
}
VAR_11=opj_image_create((OPJ_UINT32) VAR_15,VAR_10,VAR_8);
if (VAR_11 == (opj_image_t *) NULL)
ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
VAR_11->x0=VAR_9.image_offset_x0;
VAR_11->y0=VAR_9.image_offset_y0;
VAR_11->x1=(unsigned int) (2*VAR_9.image_offset_x0+(VAR_1->columns-1)*
VAR_9.subsampling_dx+1);
VAR_11->y1=(unsigned int) (2*VAR_9.image_offset_y0+(VAR_1->rows-1)*
VAR_9.subsampling_dx+1);
if ((VAR_1->depth == 12) &&
((VAR_1->columns == 2048) || (VAR_1->rows == 1080) ||
(VAR_1->columns == 4096) || (VAR_1->rows == 2160)))
CinemaProfileCompliance(VAR_11,&VAR_9);
if (VAR_15 == 4)
VAR_11->comps[3].alpha=1;
else
if ((VAR_15 == 2) && (VAR_8 == VAR_35))
VAR_11->comps[1].alpha=1;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
register const Quantum
*VAR_26;
ssize_t
VAR_39;
VAR_26=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_26 == (const Quantum *) NULL)
break;
for (VAR_39=0; VAR_39 < (ssize_t) VAR_1->columns; VAR_39++)
{
for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
{
double
VAR_40;
register int
*VAR_41;
VAR_40=(double) ((1UL << VAR_11->comps[VAR_13].prec)-1)/VAR_42;
VAR_41=VAR_11->comps[VAR_13].data+(VAR_14/VAR_11->comps[VAR_13].dy*
VAR_1->columns/VAR_11->comps[VAR_13].dx+VAR_39/VAR_11->comps[VAR_13].dx);
switch (VAR_13)
{
case 0:
{
if (VAR_8 == VAR_35)
{
*VAR_41=(int) (VAR_40*GetPixelLuma(VAR_1,VAR_26));
break;
}
*VAR_41=(int) (VAR_40*GetPixelRed(VAR_1,VAR_26));
break;
}
case 1:
{
if (VAR_8 == VAR_35)
{
*VAR_41=(int) (VAR_40*GetPixelAlpha(VAR_1,VAR_26));
break;
}
*VAR_41=(int) (VAR_40*GetPixelGreen(VAR_1,VAR_26));
break;
}
case 2:
{
*VAR_41=(int) (VAR_40*GetPixelBlue(VAR_1,VAR_26));
break;
}
case 3:
{
*VAR_41=(int) (VAR_40*GetPixelAlpha(VAR_1,VAR_26));
break;
}
}
}
VAR_26+=GetPixelChannels(VAR_1);
}
VAR_6=SetImageProgress(VAR_1,VAR_43,(MagickOffsetType) VAR_14,
VAR_1->rows);
if (VAR_6 == VAR_17)
break;
}
if (LocaleCompare(VAR_0->magick,""JPT"") == 0)
VAR_7=opj_create_compress(VAR_44);
else
if (LocaleCompare(VAR_0->magick,""J2K"") == 0)
VAR_7=opj_create_compress(VAR_45);
else
VAR_7=opj_create_compress(VAR_46);
opj_set_warning_handler(VAR_7,VAR_47,VAR_2);
opj_set_error_handler(VAR_7,VAR_48,VAR_2);
opj_setup_encoder(VAR_7,&VAR_9,VAR_11);
VAR_12=opj_stream_create(VAR_49,VAR_50);
opj_stream_set_read_function(VAR_12,VAR_51);
opj_stream_set_write_function(VAR_12,VAR_52);
opj_stream_set_seek_function(VAR_12,VAR_53);
opj_stream_set_skip_function(VAR_12,VAR_54);
opj_stream_set_user_data(VAR_12,VAR_1,NULL);
if (VAR_12 == (opj_stream_t *) NULL)
ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
VAR_5=opj_start_compress(VAR_7,VAR_11,VAR_12);
if (VAR_5 == 0)
ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
if ((opj_encode(VAR_7,VAR_12) == 0) ||
(opj_end_compress(VAR_7,VAR_12) == 0))
{
opj_stream_destroy(VAR_12);
opj_destroy_codec(VAR_7);
opj_image_destroy(VAR_11);
ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
}
opj_stream_destroy(VAR_12);
opj_destroy_codec(VAR_7);
opj_image_destroy(VAR_11);
(void) CloseBlob(VAR_1);
return(VAR_55);
}",ImageMagick/167e1538ae9818d46c9462a4273082871e35a480/jp2.c/vul/before/0.json,"static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  const char
    *option,
    *property;

  int
    jp2_status;

  MagickBooleanType
    status;

  opj_codec_t
    *jp2_codec;

  OPJ_COLOR_SPACE
    jp2_colorspace;

  opj_cparameters_t
    parameters;

  opj_image_cmptparm_t
    jp2_info[5];

  opj_image_t
    *jp2_image;

  opj_stream_t
    *jp2_stream;

  register ssize_t
    i;

  ssize_t
    y;

  unsigned int
    channels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  /*
    Initialize JPEG 2000 API.
  */
  opj_set_default_encoder_parameters(&parameters);
  for (i=1; i < 6; i++)
    if (((size_t) (1UL << (i+2)) > image->columns) &&
        ((size_t) (1UL << (i+2)) > image->rows))
      break;
  parameters.numresolution=i;
  option=GetImageOption(image_info,""jp2:number-resolutions"");
  if (option != (const char *) NULL)
    parameters.numresolution=StringToInteger(option);
  parameters.tcp_numlayers=1;
  parameters.tcp_rates[0]=0;  /* lossless */
  parameters.cp_disto_alloc=1;
  if ((image_info->quality != 0) && (image_info->quality != 100))
    {
      parameters.tcp_distoratio[0]=(double) image_info->quality;
      parameters.cp_fixed_quality=OPJ_TRUE;
    }
  if (image_info->extract != (char *) NULL)
    {
      RectangleInfo
        geometry;

      int
        flags;

      /*
        Set tile size.
      */
      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);
      parameters.cp_tdx=(int) geometry.width;
      parameters.cp_tdy=(int) geometry.width;
      if ((flags & HeightValue) != 0)
        parameters.cp_tdy=(int) geometry.height;
      if ((flags & XValue) != 0)
        parameters.cp_tx0=geometry.x;
      if ((flags & YValue) != 0)
        parameters.cp_ty0=geometry.y;
      parameters.tile_size_on=OPJ_TRUE;
    }
  option=GetImageOption(image_info,""jp2:quality"");
  if (option != (const char *) NULL)
    {
      register const char
        *p;

      /*
        Set quality PSNR.
      */
      p=option;
      for (i=0; sscanf(p,""%f"",&parameters.tcp_distoratio[i]) == 1; i++)
      {
        if (i > 100)
          break;
        while ((*p != '\0') && (*p != ','))
          p++;
        if (*p == '\0')
          break;
        p++;
      }
      parameters.tcp_numlayers=i+1;
      parameters.cp_fixed_quality=OPJ_TRUE;
    }
  option=GetImageOption(image_info,""jp2:progression-order"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""LRCP"") == 0)
        parameters.prog_order=OPJ_LRCP;
      if (LocaleCompare(option,""RLCP"") == 0)
        parameters.prog_order=OPJ_RLCP;
      if (LocaleCompare(option,""RPCL"") == 0)
        parameters.prog_order=OPJ_RPCL;
      if (LocaleCompare(option,""PCRL"") == 0)
        parameters.prog_order=OPJ_PCRL;
      if (LocaleCompare(option,""CPRL"") == 0)
        parameters.prog_order=OPJ_CPRL;
    }
  option=GetImageOption(image_info,""jp2:rate"");
  if (option != (const char *) NULL)
    {
      register const char
        *p;

      /*
        Set compression rate.
      */
      p=option;
      for (i=0; sscanf(p,""%f"",&parameters.tcp_rates[i]) == 1; i++)
      {
        if (i >= 100)
          break;
        while ((*p != '\0') && (*p != ','))
          p++;
        if (*p == '\0')
          break;
        p++;
      }
      parameters.tcp_numlayers=i+1;
      parameters.cp_disto_alloc=OPJ_TRUE;
    }
  if (image_info->sampling_factor != (const char *) NULL)
    (void) sscanf(image_info->sampling_factor,""%d,%d"",
      &parameters.subsampling_dx,&parameters.subsampling_dy);
  property=GetImageProperty(image,""comment"",exception);
  if (property != (const char *) NULL)
    parameters.cp_comment=property;
  channels=3;
  jp2_colorspace=OPJ_CLRSPC_SRGB;
  if (image->colorspace == YUVColorspace)
    {
      jp2_colorspace=OPJ_CLRSPC_SYCC;
      parameters.subsampling_dx=2;
    }
  else
    {
      if (IsGrayColorspace(image->colorspace) != MagickFalse)
        {
          channels=1;
          jp2_colorspace=OPJ_CLRSPC_GRAY;
        }
      else
        (void) TransformImageColorspace(image,sRGBColorspace,exception);
      if (image->alpha_trait != UndefinedPixelTrait)
        channels++;
    }
  parameters.tcp_mct=channels == 3 ? 1 : 0;
  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));
  for (i=0; i < (ssize_t) channels; i++)
  {
    jp2_info[i].prec=(OPJ_UINT32) image->depth;
    jp2_info[i].bpp=(OPJ_UINT32) image->depth;
    if ((image->depth == 1) &&
        ((LocaleCompare(image_info->magick,""JPT"") == 0) ||
         (LocaleCompare(image_info->magick,""JP2"") == 0)))
      {
        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */
        jp2_info[i].bpp++;
      }
    jp2_info[i].sgnd=0;
    jp2_info[i].dx=parameters.subsampling_dx;
    jp2_info[i].dy=parameters.subsampling_dy;
    jp2_info[i].w=(OPJ_UINT32) image->columns;
    jp2_info[i].h=(OPJ_UINT32) image->rows;
  }
  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);
  if (jp2_image == (opj_image_t *) NULL)
    ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
  jp2_image->x0=parameters.image_offset_x0;
  jp2_image->y0=parameters.image_offset_y0;
  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*
    parameters.subsampling_dx+1);
  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*
    parameters.subsampling_dx+1);
  if ((image->depth == 12) &&
      ((image->columns == 2048) || (image->rows == 1080) ||
       (image->columns == 4096) || (image->rows == 2160)))
    CinemaProfileCompliance(jp2_image,&parameters);
  if (channels == 4)
    jp2_image->comps[3].alpha=1;
  else
   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))
     jp2_image->comps[1].alpha=1;
  /*
    Convert to JP2 pixels.
  */
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register const Quantum
      *p;

    ssize_t
      x;

    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      for (i=0; i < (ssize_t) channels; i++)
      {
        double
          scale;

        register int
          *q;

        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;
        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*
          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);
        switch (i)
        {
          case 0:
          {
            if (jp2_colorspace == OPJ_CLRSPC_GRAY)
              {
                *q=(int) (scale*GetPixelLuma(image,p));
                break;
              }
            *q=(int) (scale*GetPixelRed(image,p));
            break;
          }
          case 1:
          {
            if (jp2_colorspace == OPJ_CLRSPC_GRAY)
              {
                *q=(int) (scale*GetPixelAlpha(image,p));
                break;
              }
            *q=(int) (scale*GetPixelGreen(image,p));
            break;
          }
          case 2:
          {
            *q=(int) (scale*GetPixelBlue(image,p));
            break;
          }
          case 3:
          {
            *q=(int) (scale*GetPixelAlpha(image,p));
            break;
          }
        }
      }
      p+=GetPixelChannels(image);
    }
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  if (LocaleCompare(image_info->magick,""JPT"") == 0)
    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);
  else
    if (LocaleCompare(image_info->magick,""J2K"") == 0)
      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);
    else
      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);
  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);
  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);
  opj_setup_encoder(jp2_codec,&parameters,jp2_image);
  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);
  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);
  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);
  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);
  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);
  opj_stream_set_user_data(jp2_stream,image,NULL);
  if (jp2_stream == (opj_stream_t *) NULL)
    ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);
  if (jp2_status == 0)
    ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||
      (opj_end_compress(jp2_codec,jp2_stream) == 0))
    {
      opj_stream_destroy(jp2_stream);
      opj_destroy_codec(jp2_codec);
      opj_image_destroy(jp2_image);
      ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
    }
  /*
    Free resources.
  */
  opj_stream_destroy(jp2_stream);
  opj_destroy_codec(jp2_codec);
  opj_image_destroy(jp2_image);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteJP2Image(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  const char
    *VAR_3,
    *VAR_4;

  int
    VAR_5;

  MagickBooleanType
    VAR_6;

  opj_codec_t
    *VAR_7;

  OPJ_COLOR_SPACE
    VAR_8;

  opj_cparameters_t
    VAR_9;

  opj_image_cmptparm_t
    VAR_10[5];

  opj_image_t
    *VAR_11;

  opj_stream_t
    *VAR_12;

  register ssize_t
    VAR_13;

  ssize_t
    VAR_14;

  unsigned int
    VAR_15;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_16);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_16);
  if (VAR_1->debug != VAR_17)
    (void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_16);
  VAR_6=OpenBlob(VAR_0,VAR_1,VAR_19,VAR_2);
  if (VAR_6 == VAR_17)
    return(VAR_6);
  /* COMMENT_3 */
                             
    
  opj_set_default_encoder_parameters(&VAR_9);
  for (VAR_13=1; VAR_13 < 6; VAR_13++)
    if (((size_t) (1UL << (VAR_13+2)) > VAR_1->columns) &&
        ((size_t) (1UL << (VAR_13+2)) > VAR_1->rows))
      break;
  VAR_9.numresolution=VAR_13;
  VAR_3=GetImageOption(VAR_0,""jp2:number-resolutions"");
  if (VAR_3 != (const char *) NULL)
    VAR_9.numresolution=StringToInteger(VAR_3);
  VAR_9.tcp_numlayers=1;
  VAR_9.tcp_rates[0]=0;  /* COMMENT_6 */
  VAR_9.cp_disto_alloc=1;
  if ((VAR_0->quality != 0) && (VAR_0->quality != 100))
    {
      VAR_9.tcp_distoratio[0]=(double) VAR_0->quality;
      VAR_9.cp_fixed_quality=VAR_20;
    }
  if (VAR_0->extract != (char *) NULL)
    {
      RectangleInfo
        VAR_21;

      int
        VAR_22;

      /* COMMENT_7 */
                      
        
      VAR_22=ParseAbsoluteGeometry(VAR_0->extract,&VAR_21);
      VAR_9.cp_tdx=(int) VAR_21.width;
      VAR_9.cp_tdy=(int) VAR_21.width;
      if ((VAR_22 & VAR_23) != 0)
        VAR_9.cp_tdy=(int) VAR_21.height;
      if ((VAR_22 & VAR_24) != 0)
        VAR_9.cp_tx0=VAR_21.x;
      if ((VAR_22 & VAR_25) != 0)
        VAR_9.cp_ty0=VAR_21.y;
      VAR_9.tile_size_on=VAR_20;
    }
  VAR_3=GetImageOption(VAR_0,""jp2:quality"");
  if (VAR_3 != (const char *) NULL)
    {
      register const char
        *VAR_26;

      /* COMMENT_10 */
                         
        
      VAR_26=VAR_3;
      for (VAR_13=0; sscanf(VAR_26,""%f"",&VAR_9.tcp_distoratio[VAR_13]) == 1; VAR_13++)
      {
        if (VAR_13 > 100)
          break;
        while ((*VAR_26 != '\0') && (*VAR_26 != ','))
          VAR_26++;
        if (*VAR_26 == '\0')
          break;
        VAR_26++;
      }
      VAR_9.tcp_numlayers=VAR_13+1;
      VAR_9.cp_fixed_quality=VAR_20;
    }
  VAR_3=GetImageOption(VAR_0,""jp2:progression-order"");
  if (VAR_3 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_3,""LRCP"") == 0)
        VAR_9.prog_order=VAR_27;
      if (LocaleCompare(VAR_3,""RLCP"") == 0)
        VAR_9.prog_order=VAR_28;
      if (LocaleCompare(VAR_3,""RPCL"") == 0)
        VAR_9.prog_order=VAR_29;
      if (LocaleCompare(VAR_3,""PCRL"") == 0)
        VAR_9.prog_order=VAR_30;
      if (LocaleCompare(VAR_3,""CPRL"") == 0)
        VAR_9.prog_order=VAR_31;
    }
  VAR_3=GetImageOption(VAR_0,""jp2:rate"");
  if (VAR_3 != (const char *) NULL)
    {
      register const char
        *VAR_26;

      /* COMMENT_13 */
                             
        
      VAR_26=VAR_3;
      for (VAR_13=0; sscanf(VAR_26,""%f"",&VAR_9.tcp_rates[VAR_13]) == 1; VAR_13++)
      {
        if (VAR_13 >= 100)
          break;
        while ((*VAR_26 != '\0') && (*VAR_26 != ','))
          VAR_26++;
        if (*VAR_26 == '\0')
          break;
        VAR_26++;
      }
      VAR_9.tcp_numlayers=VAR_13+1;
      VAR_9.cp_disto_alloc=VAR_20;
    }
  if (VAR_0->sampling_factor != (const char *) NULL)
    (void) sscanf(VAR_0->sampling_factor,""%d,%d"",
      &VAR_9.subsampling_dx,&VAR_9.subsampling_dy);
  VAR_4=GetImageProperty(VAR_1,""comment"",VAR_2);
  if (VAR_4 != (const char *) NULL)
    VAR_9.cp_comment=VAR_4;
  VAR_15=3;
  VAR_8=VAR_32;
  if (VAR_1->colorspace == VAR_33)
    {
      VAR_8=VAR_34;
      VAR_9.subsampling_dx=2;
    }
  else
    {
      if (IsGrayColorspace(VAR_1->colorspace) != VAR_17)
        {
          VAR_15=1;
          VAR_8=VAR_35;
        }
      else
        (void) TransformImageColorspace(VAR_1,VAR_36,VAR_2);
      if (VAR_1->alpha_trait != VAR_37)
        VAR_15++;
    }
  VAR_9.tcp_mct=VAR_15 == 3 ? 1 : 0;
  ResetMagickMemory(VAR_10,0,sizeof(VAR_10));
  for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
  {
    VAR_10[VAR_13].prec=(OPJ_UINT32) VAR_1->depth;
    VAR_10[VAR_13].bpp=(OPJ_UINT32) VAR_1->depth;
    if ((VAR_1->depth == 1) &&
        ((LocaleCompare(VAR_0->magick,""JPT"") == 0) ||
         (LocaleCompare(VAR_0->magick,""JP2"") == 0)))
      {
        VAR_10[VAR_13].prec++;  /* COMMENT_16 */
        VAR_10[VAR_13].bpp++;
      }
    VAR_10[VAR_13].sgnd=0;
    VAR_10[VAR_13].dx=VAR_9.subsampling_dx;
    VAR_10[VAR_13].dy=VAR_9.subsampling_dy;
    VAR_10[VAR_13].w=(OPJ_UINT32) VAR_1->columns;
    VAR_10[VAR_13].h=(OPJ_UINT32) VAR_1->rows;
  }
  VAR_11=opj_image_create((OPJ_UINT32) VAR_15,VAR_10,VAR_8);
  if (VAR_11 == (opj_image_t *) NULL)
    ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
  VAR_11->x0=VAR_9.image_offset_x0;
  VAR_11->y0=VAR_9.image_offset_y0;
  VAR_11->x1=(unsigned int) (2*VAR_9.image_offset_x0+(VAR_1->columns-1)*
    VAR_9.subsampling_dx+1);
  VAR_11->y1=(unsigned int) (2*VAR_9.image_offset_y0+(VAR_1->rows-1)*
    VAR_9.subsampling_dx+1);
  if ((VAR_1->depth == 12) &&
      ((VAR_1->columns == 2048) || (VAR_1->rows == 1080) ||
       (VAR_1->columns == 4096) || (VAR_1->rows == 2160)))
    CinemaProfileCompliance(VAR_11,&VAR_9);
  if (VAR_15 == 4)
    VAR_11->comps[3].alpha=1;
  else
   if ((VAR_15 == 2) && (VAR_8 == VAR_35))
     VAR_11->comps[1].alpha=1;
  /* COMMENT_17 */
                          
    
  for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
  {
    register const Quantum
      *VAR_26;

    ssize_t
      VAR_39;

    VAR_26=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
    if (VAR_26 == (const Quantum *) NULL)
      break;
    for (VAR_39=0; VAR_39 < (ssize_t) VAR_1->columns; VAR_39++)
    {
      for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
      {
        double
          VAR_40;

        register int
          *VAR_41;

        VAR_40=(double) ((1UL << VAR_11->comps[VAR_13].prec)-1)/VAR_42;
        VAR_41=VAR_11->comps[VAR_13].data+(VAR_14/VAR_11->comps[VAR_13].dy*
          VAR_1->columns/VAR_11->comps[VAR_13].dx+VAR_39/VAR_11->comps[VAR_13].dx);
        switch (VAR_13)
        {
          case 0:
          {
            if (VAR_8 == VAR_35)
              {
                *VAR_41=(int) (VAR_40*GetPixelLuma(VAR_1,VAR_26));
                break;
              }
            *VAR_41=(int) (VAR_40*GetPixelRed(VAR_1,VAR_26));
            break;
          }
          case 1:
          {
            if (VAR_8 == VAR_35)
              {
                *VAR_41=(int) (VAR_40*GetPixelAlpha(VAR_1,VAR_26));
                break;
              }
            *VAR_41=(int) (VAR_40*GetPixelGreen(VAR_1,VAR_26));
            break;
          }
          case 2:
          {
            *VAR_41=(int) (VAR_40*GetPixelBlue(VAR_1,VAR_26));
            break;
          }
          case 3:
          {
            *VAR_41=(int) (VAR_40*GetPixelAlpha(VAR_1,VAR_26));
            break;
          }
        }
      }
      VAR_26+=GetPixelChannels(VAR_1);
    }
    VAR_6=SetImageProgress(VAR_1,VAR_43,(MagickOffsetType) VAR_14,
      VAR_1->rows);
    if (VAR_6 == VAR_17)
      break;
  }
  if (LocaleCompare(VAR_0->magick,""JPT"") == 0)
    VAR_7=opj_create_compress(VAR_44);
  else
    if (LocaleCompare(VAR_0->magick,""J2K"") == 0)
      VAR_7=opj_create_compress(VAR_45);
    else
      VAR_7=opj_create_compress(VAR_46);
  opj_set_warning_handler(VAR_7,VAR_47,VAR_2);
  opj_set_error_handler(VAR_7,VAR_48,VAR_2);
  opj_setup_encoder(VAR_7,&VAR_9,VAR_11);
  VAR_12=opj_stream_create(VAR_49,VAR_50);
  opj_stream_set_read_function(VAR_12,VAR_51);
  opj_stream_set_write_function(VAR_12,VAR_52);
  opj_stream_set_seek_function(VAR_12,VAR_53);
  opj_stream_set_skip_function(VAR_12,VAR_54);
  opj_stream_set_user_data(VAR_12,VAR_1,NULL);
  if (VAR_12 == (opj_stream_t *) NULL)
    ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
  VAR_5=opj_start_compress(VAR_7,VAR_11,VAR_12);
  if (VAR_5 == 0)
    ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
  if ((opj_encode(VAR_7,VAR_12) == 0) ||
      (opj_end_compress(VAR_7,VAR_12) == 0))
    {
      opj_stream_destroy(VAR_12);
      opj_destroy_codec(VAR_7);
      opj_image_destroy(VAR_11);
      ThrowWriterException(VAR_38,""UnableToEncodeImageFile"");
    }
  /* COMMENT_20 */
                   
    
  opj_stream_destroy(VAR_12);
  opj_destroy_codec(VAR_7);
  opj_image_destroy(VAR_11);
  (void) CloseBlob(VAR_1);
  return(VAR_55);
}",ImageMagick/167e1538ae9818d46c9462a4273082871e35a480/jp2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -159,7 +159,7 @@
       &parameters.subsampling_dx,&parameters.subsampling_dy);
   property=GetImageProperty(image,""comment"",exception);
   if (property != (const char *) NULL)
-    parameters.cp_comment=ConstantString(property);
+    parameters.cp_comment=property;
   channels=3;
   jp2_colorspace=OPJ_CLRSPC_SRGB;
   if (image->colorspace == YUVColorspace)","{'deleted_lines': ['    parameters.cp_comment=ConstantString(property);'], 'added_lines': ['    parameters.cp_comment=property;']}",True,"When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the WriteJP2Image() function in coders/jp2.c.",6.5,MEDIUM,1,valid,2017-07-16T18:42:49Z,2
CVE-2017-12668,['CWE-772'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/575,2ba8f335fa06daf1165e0878462686028e633a74,https://github.com/ImageMagick/ImageMagick/commit/2ba8f335fa06daf1165e0878462686028e633a74,coders/pcx.c,WritePCXImage,"static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
MagickBooleanType
status;
MagickOffsetType
offset,
*page_table,
scene;
MemoryInfo
*pixel_info;
PCXInfo
pcx_info;
register const Quantum
*p;
register ssize_t
i,
x;
register unsigned char
*q;
size_t
length;
ssize_t
y;
unsigned char
*pcx_colormap,
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) TransformImageColorspace(image,sRGBColorspace,exception);
page_table=(MagickOffsetType *) NULL;
if ((LocaleCompare(image_info->magick,""DCX"") == 0) ||
((GetNextImageInList(image) != (Image *) NULL) &&
(image_info->adjoin != MagickFalse)))
{
(void) WriteBlobLSBLong(image,0x3ADE68B1L);
page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
sizeof(*page_table));
if (page_table == (MagickOffsetType *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
for (scene=0; scene < 1024; scene++)
(void) WriteBlobLSBLong(image,0x00000000L);
}
scene=0;
do
{
if (page_table != (MagickOffsetType *) NULL)
page_table[scene]=TellBlob(image);
pcx_info.identifier=0x0a;
pcx_info.version=5;
pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;
pcx_info.bits_per_pixel=8;
if ((image->storage_class == PseudoClass) &&
(SetImageMonochrome(image,exception) != MagickFalse))
pcx_info.bits_per_pixel=1;
pcx_info.left=0;
pcx_info.top=0;
pcx_info.right=(unsigned short) (image->columns-1);
pcx_info.bottom=(unsigned short) (image->rows-1);
switch (image->units)
{
case UndefinedResolution:
case PixelsPerInchResolution:
default:
{
pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;
pcx_info.vertical_resolution=(unsigned short) image->resolution.y;
break;
}
case PixelsPerCentimeterResolution:
{
pcx_info.horizontal_resolution=(unsigned short)
(2.54*image->resolution.x+0.5);
pcx_info.vertical_resolution=(unsigned short)
(2.54*image->resolution.y+0.5);
break;
}
}
pcx_info.reserved=0;
pcx_info.planes=1;
if ((image->storage_class == DirectClass) || (image->colors > 256))
{
pcx_info.planes=3;
if (image->alpha_trait != UndefinedPixelTrait)
pcx_info.planes++;
}
pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*
pcx_info.bits_per_pixel+7)/8);
pcx_info.palette_info=1;
pcx_info.colormap_signature=0x0c;
(void) WriteBlobByte(image,pcx_info.identifier);
(void) WriteBlobByte(image,pcx_info.version);
(void) WriteBlobByte(image,pcx_info.encoding);
(void) WriteBlobByte(image,pcx_info.bits_per_pixel);
(void) WriteBlobLSBShort(image,pcx_info.left);
(void) WriteBlobLSBShort(image,pcx_info.top);
(void) WriteBlobLSBShort(image,pcx_info.right);
(void) WriteBlobLSBShort(image,pcx_info.bottom);
(void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);
(void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);
pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,
3*sizeof(*pcx_colormap));
if (pcx_colormap == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
(void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));
q=pcx_colormap;
if ((image->storage_class == PseudoClass) && (image->colors <= 256))
for (i=0; i < (ssize_t) image->colors; i++)
{
*q++=ScaleQuantumToChar(image->colormap[i].red);
*q++=ScaleQuantumToChar(image->colormap[i].green);
*q++=ScaleQuantumToChar(image->colormap[i].blue);
}
(void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);
(void) WriteBlobByte(image,pcx_info.reserved);
(void) WriteBlobByte(image,pcx_info.planes);
(void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);
(void) WriteBlobLSBShort(image,pcx_info.palette_info);
for (i=0; i < 58; i++)
(void) WriteBlobByte(image,'\0');
length=(size_t) pcx_info.bytes_per_line;
pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
q=pixels;
if ((image->storage_class == DirectClass) || (image->colors > 256))
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=pixels;
for (i=0; i < pcx_info.planes; i++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
switch ((int) i)
{
case 0:
{
for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
{
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
p+=GetPixelChannels(image);
}
break;
}
case 1:
{
for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
{
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
p+=GetPixelChannels(image);
}
break;
}
case 2:
{
for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
p+=GetPixelChannels(image);
}
break;
}
case 3:
default:
{
for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)
{
*q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));
p+=GetPixelChannels(image);
}
break;
}
}
}
if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
if (pcx_info.bits_per_pixel > 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=(unsigned char) GetPixelIndex(image,p);
p+=GetPixelChannels(image);
}
if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
{
register unsigned char
bit,
byte;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
bit=0;
byte=0;
q=pixels;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=1;
if (GetPixelLuma(image,p) >= (QuantumRange/2.0))
byte|=0x01;
bit++;
if (bit == 8)
{
*q++=byte;
bit=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (bit != 0)
*q++=byte << (8-bit);
if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)
y,image->rows);
if (status == MagickFalse)
break;
}
}
}
(void) WriteBlobByte(image,pcx_info.colormap_signature);
(void) WriteBlob(image,3*256,pcx_colormap);
}
pixel_info=RelinquishVirtualMemory(pixel_info);
pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
if (page_table == (MagickOffsetType *) NULL)
break;
if (scene >= 1023)
break;
if (GetNextImageInList(image) == (Image *) NULL)
break;
image=SyncNextImageInList(image);
status=SetImageProgress(image,SaveImagesTag,scene++,
GetImageListLength(image));
if (status == MagickFalse)
break;
} while (image_info->adjoin != MagickFalse);
if (page_table != (MagickOffsetType *) NULL)
{
page_table[scene+1]=0;
offset=SeekBlob(image,0L,SEEK_SET);
if (offset < 0)
ThrowWriterException(CorruptImageError,""ImproperImageHeader"");
(void) WriteBlobLSBLong(image,0x3ADE68B1L);
for (i=0; i <= (ssize_t) scene; i++)
(void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);
page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);
}
if (status == MagickFalse)
{
char
*message;
message=GetExceptionMessage(errno);
(void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,
""UnableToWriteFile"",""`%s': %s"",image->filename,message);
message=DestroyString(message);
}
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WritePCXImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
MagickBooleanType
VAR_3;
MagickOffsetType
VAR_4,
*VAR_5,
VAR_6;
MemoryInfo
*VAR_7;
PCXInfo
VAR_8;
register const Quantum
*VAR_9;
register ssize_t
VAR_10,
VAR_11;
register unsigned char
*VAR_12;
size_t
VAR_13;
ssize_t
VAR_14;
unsigned char
*VAR_15,
*VAR_16;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_17);
if (VAR_1->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_17);
VAR_3=OpenBlob(VAR_0,VAR_1,VAR_20,VAR_2);
if (VAR_3 == VAR_18)
return(VAR_3);
(void) TransformImageColorspace(VAR_1,VAR_21,VAR_2);
VAR_5=(MagickOffsetType *) NULL;
if ((LocaleCompare(VAR_0->magick,""DCX"") == 0) ||
((GetNextImageInList(VAR_1) != (Image *) NULL) &&
(VAR_0->adjoin != VAR_18)))
{
(void) WriteBlobLSBLong(VAR_1,0x3ADE68B1L);
VAR_5=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
sizeof(*VAR_5));
if (VAR_5 == (MagickOffsetType *) NULL)
ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
for (VAR_6=0; VAR_6 < 1024; VAR_6++)
(void) WriteBlobLSBLong(VAR_1,0x00000000L);
}
VAR_6=0;
do
{
if (VAR_5 != (MagickOffsetType *) NULL)
VAR_5[VAR_6]=TellBlob(VAR_1);
VAR_8.identifier=0x0a;
VAR_8.version=5;
VAR_8.encoding=VAR_0->compression == VAR_23 ? 0 : 1;
VAR_8.bits_per_pixel=8;
if ((VAR_1->storage_class == VAR_24) &&
(SetImageMonochrome(VAR_1,VAR_2) != VAR_18))
VAR_8.bits_per_pixel=1;
VAR_8.left=0;
VAR_8.top=0;
VAR_8.right=(unsigned short) (VAR_1->columns-1);
VAR_8.bottom=(unsigned short) (VAR_1->rows-1);
switch (VAR_1->units)
{
case VAR_25:
case VAR_26:
default:
{
VAR_8.horizontal_resolution=(unsigned short) VAR_1->resolution.x;
VAR_8.vertical_resolution=(unsigned short) VAR_1->resolution.y;
break;
}
case VAR_27:
{
VAR_8.horizontal_resolution=(unsigned short)
(2.54*VAR_1->resolution.x+0.5);
VAR_8.vertical_resolution=(unsigned short)
(2.54*VAR_1->resolution.y+0.5);
break;
}
}
VAR_8.reserved=0;
VAR_8.planes=1;
if ((VAR_1->storage_class == VAR_28) || (VAR_1->colors > 256))
{
VAR_8.planes=3;
if (VAR_1->alpha_trait != VAR_29)
VAR_8.planes++;
}
VAR_8.bytes_per_line=(unsigned short) (((size_t) VAR_1->columns*
VAR_8.bits_per_pixel+7)/8);
VAR_8.palette_info=1;
VAR_8.colormap_signature=0x0c;
(void) WriteBlobByte(VAR_1,VAR_8.identifier);
(void) WriteBlobByte(VAR_1,VAR_8.version);
(void) WriteBlobByte(VAR_1,VAR_8.encoding);
(void) WriteBlobByte(VAR_1,VAR_8.bits_per_pixel);
(void) WriteBlobLSBShort(VAR_1,VAR_8.left);
(void) WriteBlobLSBShort(VAR_1,VAR_8.top);
(void) WriteBlobLSBShort(VAR_1,VAR_8.right);
(void) WriteBlobLSBShort(VAR_1,VAR_8.bottom);
(void) WriteBlobLSBShort(VAR_1,VAR_8.horizontal_resolution);
(void) WriteBlobLSBShort(VAR_1,VAR_8.vertical_resolution);
VAR_15=(unsigned char *) AcquireQuantumMemory(256UL,
3*sizeof(*VAR_15));
if (VAR_15 == (unsigned char *) NULL)
ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
(void) memset(VAR_15,0,3*256*sizeof(*VAR_15));
VAR_12=VAR_15;
if ((VAR_1->storage_class == VAR_24) && (VAR_1->colors <= 256))
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->colors; VAR_10++)
{
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].red);
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].green);
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].blue);
}
(void) WriteBlob(VAR_1,3*16,(const unsigned char *) VAR_15);
(void) WriteBlobByte(VAR_1,VAR_8.reserved);
(void) WriteBlobByte(VAR_1,VAR_8.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_8.bytes_per_line);
(void) WriteBlobLSBShort(VAR_1,VAR_8.palette_info);
for (VAR_10=0; VAR_10 < 58; VAR_10++)
(void) WriteBlobByte(VAR_1,'\0');
VAR_13=(size_t) VAR_8.bytes_per_line;
VAR_7=AcquireVirtualMemory(VAR_13,VAR_8.planes*sizeof(*VAR_16));
if (VAR_7 == (MemoryInfo *) NULL)
ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_7);
VAR_12=VAR_16;
if ((VAR_1->storage_class == VAR_28) || (VAR_1->colors > 256))
{
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
VAR_12=VAR_16;
for (VAR_10=0; VAR_10 < VAR_8.planes; VAR_10++)
{
VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_9 == (const Quantum *) NULL)
break;
switch ((int) VAR_10)
{
case 0:
{
for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
{
*VAR_12++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_9));
VAR_9+=GetPixelChannels(VAR_1);
}
break;
}
case 1:
{
for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
{
*VAR_12++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_9));
VAR_9+=GetPixelChannels(VAR_1);
}
break;
}
case 2:
{
for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
{
*VAR_12++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_9));
VAR_9+=GetPixelChannels(VAR_1);
}
break;
}
case 3:
default:
{
for (VAR_11=(ssize_t) VAR_8.bytes_per_line; VAR_11 != 0; VAR_11--)
{
*VAR_12++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(VAR_1,VAR_9)));
VAR_9+=GetPixelChannels(VAR_1);
}
break;
}
}
}
if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
break;
if (VAR_1->previous == (Image *) NULL)
{
VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
VAR_1->rows);
if (VAR_3 == VAR_18)
break;
}
}
}
else
{
if (VAR_8.bits_per_pixel > 1)
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_9 == (const Quantum *) NULL)
break;
VAR_12=VAR_16;
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->columns; VAR_11++)
{
*VAR_12++=(unsigned char) GetPixelIndex(VAR_1,VAR_9);
VAR_9+=GetPixelChannels(VAR_1);
}
if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
break;
if (VAR_1->previous == (Image *) NULL)
{
VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
VAR_1->rows);
if (VAR_3 == VAR_18)
break;
}
}
else
{
register unsigned char
VAR_31,
VAR_32;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_9 == (const Quantum *) NULL)
break;
VAR_31=0;
VAR_32=0;
VAR_12=VAR_16;
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->columns; VAR_11++)
{
VAR_32<<=1;
if (GetPixelLuma(VAR_1,VAR_9) >= (VAR_33/2.0))
VAR_32|=0x01;
VAR_31++;
if (VAR_31 == 8)
{
*VAR_12++=VAR_32;
VAR_31=0;
VAR_32=0;
}
VAR_9+=GetPixelChannels(VAR_1);
}
if (VAR_31 != 0)
*VAR_12++=VAR_32 << (8-VAR_31);
if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
break;
if (VAR_1->previous == (Image *) NULL)
{
VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType)
VAR_14,VAR_1->rows);
if (VAR_3 == VAR_18)
break;
}
}
}
(void) WriteBlobByte(VAR_1,VAR_8.colormap_signature);
(void) WriteBlob(VAR_1,3*256,VAR_15);
}
VAR_7=RelinquishVirtualMemory(VAR_7);
VAR_15=(unsigned char *) RelinquishMagickMemory(VAR_15);
if (VAR_5 == (MagickOffsetType *) NULL)
break;
if (VAR_6 >= 1023)
break;
if (GetNextImageInList(VAR_1) == (Image *) NULL)
break;
VAR_1=SyncNextImageInList(VAR_1);
VAR_3=SetImageProgress(VAR_1,VAR_34,VAR_6++,
GetImageListLength(VAR_1));
if (VAR_3 == VAR_18)
break;
} while (VAR_0->adjoin != VAR_18);
if (VAR_5 != (MagickOffsetType *) NULL)
{
VAR_5[VAR_6+1]=0;
VAR_4=SeekBlob(VAR_1,0L,VAR_35);
if (VAR_4 < 0)
ThrowWriterException(VAR_36,""ImproperImageHeader"");
(void) WriteBlobLSBLong(VAR_1,0x3ADE68B1L);
for (VAR_10=0; VAR_10 <= (ssize_t) VAR_6; VAR_10++)
(void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_5[VAR_10]);
VAR_5=(MagickOffsetType *) RelinquishMagickMemory(VAR_5);
}
if (VAR_3 == VAR_18)
{
char
*VAR_37;
VAR_37=GetExceptionMessage(VAR_38);
(void) ThrowMagickException(VAR_2,GetMagickModule(),VAR_39,
""UnableToWriteFile"",""`%s': %s"",VAR_1->filename,VAR_37);
VAR_37=DestroyString(VAR_37);
}
(void) CloseBlob(VAR_1);
return(VAR_40);
}",ImageMagick/2ba8f335fa06daf1165e0878462686028e633a74/pcx.c/vul/before/0.json,"static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    *page_table,
    scene;

  MemoryInfo
    *pixel_info;

  PCXInfo
    pcx_info;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register unsigned char
    *q;

  size_t
    length;

  ssize_t
    y;

  unsigned char
    *pcx_colormap,
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  (void) TransformImageColorspace(image,sRGBColorspace,exception);
  page_table=(MagickOffsetType *) NULL;
  if ((LocaleCompare(image_info->magick,""DCX"") == 0) ||
      ((GetNextImageInList(image) != (Image *) NULL) &&
       (image_info->adjoin != MagickFalse)))
    {
      /*
        Write the DCX page table.
      */
      (void) WriteBlobLSBLong(image,0x3ADE68B1L);
      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
        sizeof(*page_table));
      if (page_table == (MagickOffsetType *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      for (scene=0; scene < 1024; scene++)
        (void) WriteBlobLSBLong(image,0x00000000L);
    }
  scene=0;
  do
  {
    if (page_table != (MagickOffsetType *) NULL)
      page_table[scene]=TellBlob(image);
    /*
      Initialize PCX raster file header.
    */
    pcx_info.identifier=0x0a;
    pcx_info.version=5;
    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;
    pcx_info.bits_per_pixel=8;
    if ((image->storage_class == PseudoClass) &&
        (SetImageMonochrome(image,exception) != MagickFalse))
      pcx_info.bits_per_pixel=1;
    pcx_info.left=0;
    pcx_info.top=0;
    pcx_info.right=(unsigned short) (image->columns-1);
    pcx_info.bottom=(unsigned short) (image->rows-1);
    switch (image->units)
    {
      case UndefinedResolution:
      case PixelsPerInchResolution:
      default:
      {
        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;
        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;
        break;
      }
      case PixelsPerCentimeterResolution:
      {
        pcx_info.horizontal_resolution=(unsigned short)
          (2.54*image->resolution.x+0.5);
        pcx_info.vertical_resolution=(unsigned short)
          (2.54*image->resolution.y+0.5);
        break;
      }
    }
    pcx_info.reserved=0;
    pcx_info.planes=1;
    if ((image->storage_class == DirectClass) || (image->colors > 256))
      {
        pcx_info.planes=3;
        if (image->alpha_trait != UndefinedPixelTrait)
          pcx_info.planes++;
      }
    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*
      pcx_info.bits_per_pixel+7)/8);
    pcx_info.palette_info=1;
    pcx_info.colormap_signature=0x0c;
    /*
      Write PCX header.
    */
    (void) WriteBlobByte(image,pcx_info.identifier);
    (void) WriteBlobByte(image,pcx_info.version);
    (void) WriteBlobByte(image,pcx_info.encoding);
    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);
    (void) WriteBlobLSBShort(image,pcx_info.left);
    (void) WriteBlobLSBShort(image,pcx_info.top);
    (void) WriteBlobLSBShort(image,pcx_info.right);
    (void) WriteBlobLSBShort(image,pcx_info.bottom);
    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);
    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);
    /*
      Dump colormap to file.
    */
    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,
      3*sizeof(*pcx_colormap));
    if (pcx_colormap == (unsigned char *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));
    q=pcx_colormap;
    if ((image->storage_class == PseudoClass) && (image->colors <= 256))
      for (i=0; i < (ssize_t) image->colors; i++)
      {
        *q++=ScaleQuantumToChar(image->colormap[i].red);
        *q++=ScaleQuantumToChar(image->colormap[i].green);
        *q++=ScaleQuantumToChar(image->colormap[i].blue);
      }
    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);
    (void) WriteBlobByte(image,pcx_info.reserved);
    (void) WriteBlobByte(image,pcx_info.planes);
    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);
    (void) WriteBlobLSBShort(image,pcx_info.palette_info);
    for (i=0; i < 58; i++)
      (void) WriteBlobByte(image,'\0');
    length=(size_t) pcx_info.bytes_per_line;
    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      {
        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    q=pixels;
    if ((image->storage_class == DirectClass) || (image->colors > 256))
      {
        /*
          Convert DirectClass image to PCX raster pixels.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=pixels;
          for (i=0; i < pcx_info.planes; i++)
          {
            p=GetVirtualPixels(image,0,y,image->columns,1,exception);
            if (p == (const Quantum *) NULL)
              break;
            switch ((int) i)
            {
              case 0:
              {
                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                {
                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));
                  p+=GetPixelChannels(image);
                }
                break;
              }
              case 1:
              {
                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                {
                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
                  p+=GetPixelChannels(image);
                }
                break;
              }
              case 2:
              {
                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                {
                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
                  p+=GetPixelChannels(image);
                }
                break;
              }
              case 3:
              default:
              {
                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)
                {
                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));
                  p+=GetPixelChannels(image);
                }
                break;
              }
            }
          }
          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        if (pcx_info.bits_per_pixel > 1)
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=GetVirtualPixels(image,0,y,image->columns,1,exception);
            if (p == (const Quantum *) NULL)
              break;
            q=pixels;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              *q++=(unsigned char) GetPixelIndex(image,p);
              p+=GetPixelChannels(image);
            }
            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        else
          {
            register unsigned char
              bit,
              byte;

            /*
              Convert PseudoClass image to a PCX monochrome image.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              p=GetVirtualPixels(image,0,y,image->columns,1,exception);
              if (p == (const Quantum *) NULL)
                break;
              bit=0;
              byte=0;
              q=pixels;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                byte<<=1;
                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))
                  byte|=0x01;
                bit++;
                if (bit == 8)
                  {
                    *q++=byte;
                    bit=0;
                    byte=0;
                  }
                p+=GetPixelChannels(image);
              }
              if (bit != 0)
                *q++=byte << (8-bit);
              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        (void) WriteBlobByte(image,pcx_info.colormap_signature);
        (void) WriteBlob(image,3*256,pcx_colormap);
      }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
    if (page_table == (MagickOffsetType *) NULL)
      break;
    if (scene >= 1023)
      break;
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  if (page_table != (MagickOffsetType *) NULL)
    {
      /*
        Write the DCX page table.
      */
      page_table[scene+1]=0;
      offset=SeekBlob(image,0L,SEEK_SET);
      if (offset < 0)
        ThrowWriterException(CorruptImageError,""ImproperImageHeader"");
      (void) WriteBlobLSBLong(image,0x3ADE68B1L);
      for (i=0; i <= (ssize_t) scene; i++)
        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);
      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);
    }
  if (status == MagickFalse)
    {
      char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,
        ""UnableToWriteFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WritePCXImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  MagickBooleanType
    VAR_3;

  MagickOffsetType
    VAR_4,
    *VAR_5,
    VAR_6;

  MemoryInfo
    *VAR_7;

  PCXInfo
    VAR_8;

  register const Quantum
    *VAR_9;

  register ssize_t
    VAR_10,
    VAR_11;

  register unsigned char
    *VAR_12;

  size_t
    VAR_13;

  ssize_t
    VAR_14;

  unsigned char
    *VAR_15,
    *VAR_16;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_17);
  if (VAR_1->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_17);
  VAR_3=OpenBlob(VAR_0,VAR_1,VAR_20,VAR_2);
  if (VAR_3 == VAR_18)
    return(VAR_3);
  (void) TransformImageColorspace(VAR_1,VAR_21,VAR_2);
  VAR_5=(MagickOffsetType *) NULL;
  if ((LocaleCompare(VAR_0->magick,""DCX"") == 0) ||
      ((GetNextImageInList(VAR_1) != (Image *) NULL) &&
       (VAR_0->adjoin != VAR_18)))
    {
      /* COMMENT_3 */
                                 
        
      (void) WriteBlobLSBLong(VAR_1,0x3ADE68B1L);
      VAR_5=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
        sizeof(*VAR_5));
      if (VAR_5 == (MagickOffsetType *) NULL)
        ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
      for (VAR_6=0; VAR_6 < 1024; VAR_6++)
        (void) WriteBlobLSBLong(VAR_1,0x00000000L);
    }
  VAR_6=0;
  do
  {
    if (VAR_5 != (MagickOffsetType *) NULL)
      VAR_5[VAR_6]=TellBlob(VAR_1);
    /* COMMENT_6 */
                                        
      
    VAR_8.identifier=0x0a;
    VAR_8.version=5;
    VAR_8.encoding=VAR_0->compression == VAR_23 ? 0 : 1;
    VAR_8.bits_per_pixel=8;
    if ((VAR_1->storage_class == VAR_24) &&
        (SetImageMonochrome(VAR_1,VAR_2) != VAR_18))
      VAR_8.bits_per_pixel=1;
    VAR_8.left=0;
    VAR_8.top=0;
    VAR_8.right=(unsigned short) (VAR_1->columns-1);
    VAR_8.bottom=(unsigned short) (VAR_1->rows-1);
    switch (VAR_1->units)
    {
      case VAR_25:
      case VAR_26:
      default:
      {
        VAR_8.horizontal_resolution=(unsigned short) VAR_1->resolution.x;
        VAR_8.vertical_resolution=(unsigned short) VAR_1->resolution.y;
        break;
      }
      case VAR_27:
      {
        VAR_8.horizontal_resolution=(unsigned short)
          (2.54*VAR_1->resolution.x+0.5);
        VAR_8.vertical_resolution=(unsigned short)
          (2.54*VAR_1->resolution.y+0.5);
        break;
      }
    }
    VAR_8.reserved=0;
    VAR_8.planes=1;
    if ((VAR_1->storage_class == VAR_28) || (VAR_1->colors > 256))
      {
        VAR_8.planes=3;
        if (VAR_1->alpha_trait != VAR_29)
          VAR_8.planes++;
      }
    VAR_8.bytes_per_line=(unsigned short) (((size_t) VAR_1->columns*
      VAR_8.bits_per_pixel+7)/8);
    VAR_8.palette_info=1;
    VAR_8.colormap_signature=0x0c;
    /* COMMENT_9 */
                       
      
    (void) WriteBlobByte(VAR_1,VAR_8.identifier);
    (void) WriteBlobByte(VAR_1,VAR_8.version);
    (void) WriteBlobByte(VAR_1,VAR_8.encoding);
    (void) WriteBlobByte(VAR_1,VAR_8.bits_per_pixel);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.left);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.top);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.right);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.bottom);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.horizontal_resolution);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.vertical_resolution);
    /* COMMENT_12 */
                            
      
    VAR_15=(unsigned char *) AcquireQuantumMemory(256UL,
      3*sizeof(*VAR_15));
    if (VAR_15 == (unsigned char *) NULL)
      ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
    (void) memset(VAR_15,0,3*256*sizeof(*VAR_15));
    VAR_12=VAR_15;
    if ((VAR_1->storage_class == VAR_24) && (VAR_1->colors <= 256))
      for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->colors; VAR_10++)
      {
        *VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].red);
        *VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].green);
        *VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_10].blue);
      }
    (void) WriteBlob(VAR_1,3*16,(const unsigned char *) VAR_15);
    (void) WriteBlobByte(VAR_1,VAR_8.reserved);
    (void) WriteBlobByte(VAR_1,VAR_8.planes);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.bytes_per_line);
    (void) WriteBlobLSBShort(VAR_1,VAR_8.palette_info);
    for (VAR_10=0; VAR_10 < 58; VAR_10++)
      (void) WriteBlobByte(VAR_1,'\0');
    VAR_13=(size_t) VAR_8.bytes_per_line;
    VAR_7=AcquireVirtualMemory(VAR_13,VAR_8.planes*sizeof(*VAR_16));
    if (VAR_7 == (MemoryInfo *) NULL)
      {
        VAR_15=(unsigned char *) RelinquishMagickMemory(VAR_15);
        ThrowWriterException(VAR_22,""MemoryAllocationFailed"");
      }
    VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_7);
    VAR_12=VAR_16;
    if ((VAR_1->storage_class == VAR_28) || (VAR_1->colors > 256))
      {
        /* COMMENT_15 */
                                                         
          
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
        {
          VAR_12=VAR_16;
          for (VAR_10=0; VAR_10 < VAR_8.planes; VAR_10++)
          {
            VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
            if (VAR_9 == (const Quantum *) NULL)
              break;
            switch ((int) VAR_10)
            {
              case 0:
              {
                for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
                {
                  *VAR_12++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_9));
                  VAR_9+=GetPixelChannels(VAR_1);
                }
                break;
              }
              case 1:
              {
                for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
                {
                  *VAR_12++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_9));
                  VAR_9+=GetPixelChannels(VAR_1);
                }
                break;
              }
              case 2:
              {
                for (VAR_11=0; VAR_11 < (ssize_t) VAR_8.bytes_per_line; VAR_11++)
                {
                  *VAR_12++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_9));
                  VAR_9+=GetPixelChannels(VAR_1);
                }
                break;
              }
              case 3:
              default:
              {
                for (VAR_11=(ssize_t) VAR_8.bytes_per_line; VAR_11 != 0; VAR_11--)
                {
                  *VAR_12++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(VAR_1,VAR_9)));
                  VAR_9+=GetPixelChannels(VAR_1);
                }
                break;
              }
            }
          }
          if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
            break;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
                VAR_1->rows);
              if (VAR_3 == VAR_18)
                break;
            }
        }
      }
    else
      {
        if (VAR_8.bits_per_pixel > 1)
          for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
          {
            VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
            if (VAR_9 == (const Quantum *) NULL)
              break;
            VAR_12=VAR_16;
            for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->columns; VAR_11++)
            {
              *VAR_12++=(unsigned char) GetPixelIndex(VAR_1,VAR_9);
              VAR_9+=GetPixelChannels(VAR_1);
            }
            if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
              break;
            if (VAR_1->previous == (Image *) NULL)
              {
                VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
                VAR_1->rows);
                if (VAR_3 == VAR_18)
                  break;
              }
          }
        else
          {
            register unsigned char
              VAR_31,
              VAR_32;

            /* COMMENT_18 */
                                                                  
              
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
            {
              VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
              if (VAR_9 == (const Quantum *) NULL)
                break;
              VAR_31=0;
              VAR_32=0;
              VAR_12=VAR_16;
              for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->columns; VAR_11++)
              {
                VAR_32<<=1;
                if (GetPixelLuma(VAR_1,VAR_9) >= (VAR_33/2.0))
                  VAR_32|=0x01;
                VAR_31++;
                if (VAR_31 == 8)
                  {
                    *VAR_12++=VAR_32;
                    VAR_31=0;
                    VAR_32=0;
                  }
                VAR_9+=GetPixelChannels(VAR_1);
              }
              if (VAR_31 != 0)
                *VAR_12++=VAR_32 << (8-VAR_31);
              if (PCXWritePixels(&VAR_8,VAR_16,VAR_1) == VAR_18)
                break;
              if (VAR_1->previous == (Image *) NULL)
                {
                  VAR_3=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType)
                    VAR_14,VAR_1->rows);
                  if (VAR_3 == VAR_18)
                    break;
                }
            }
          }
        (void) WriteBlobByte(VAR_1,VAR_8.colormap_signature);
        (void) WriteBlob(VAR_1,3*256,VAR_15);
      }
    VAR_7=RelinquishVirtualMemory(VAR_7);
    VAR_15=(unsigned char *) RelinquishMagickMemory(VAR_15);
    if (VAR_5 == (MagickOffsetType *) NULL)
      break;
    if (VAR_6 >= 1023)
      break;
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      break;
    VAR_1=SyncNextImageInList(VAR_1);
    VAR_3=SetImageProgress(VAR_1,VAR_34,VAR_6++,
      GetImageListLength(VAR_1));
    if (VAR_3 == VAR_18)
      break;
  } while (VAR_0->adjoin != VAR_18);
  if (VAR_5 != (MagickOffsetType *) NULL)
    {
      /* COMMENT_21 */
                                 
        
      VAR_5[VAR_6+1]=0;
      VAR_4=SeekBlob(VAR_1,0L,VAR_35);
      if (VAR_4 < 0)
        ThrowWriterException(VAR_36,""ImproperImageHeader"");
      (void) WriteBlobLSBLong(VAR_1,0x3ADE68B1L);
      for (VAR_10=0; VAR_10 <= (ssize_t) VAR_6; VAR_10++)
        (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_5[VAR_10]);
      VAR_5=(MagickOffsetType *) RelinquishMagickMemory(VAR_5);
    }
  if (VAR_3 == VAR_18)
    {
      char
        *VAR_37;

      VAR_37=GetExceptionMessage(VAR_38);
      (void) ThrowMagickException(VAR_2,GetMagickModule(),VAR_39,
        ""UnableToWriteFile"",""`%s': %s"",VAR_1->filename,VAR_37);
      VAR_37=DestroyString(VAR_37);
    }
  (void) CloseBlob(VAR_1);
  return(VAR_40);
}",ImageMagick/2ba8f335fa06daf1165e0878462686028e633a74/pcx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -155,7 +155,10 @@
     length=(size_t) pcx_info.bytes_per_line;
     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
-      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
+      {
+        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
+        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
+      }
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     q=pixels;
     if ((image->storage_class == DirectClass) || (image->colors > 256))","{'deleted_lines': ['      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");'], 'added_lines': ['      {', '        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);', '        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");', '      }']}",True,ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.,8.8,HIGH,2,valid,2017-07-17T23:09:14Z,2
CVE-2017-11540,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/581,20635b9b859fc649f7682ab08a4c58c644a94bf5,https://github.com/ImageMagick/ImageMagick/commit/20635b9b859fc649f7682ab08a4c58c644a94bf5,coders/xpm.c,WritePICONImage,"static MagickBooleanType WritePICONImage(const ImageInfo *image_info,
Image *image,ExceptionInfo *exception)
{
#define ColormapExtent  155
#define GraymapExtent  95
#define PiconGeometry  ""48x48>""
static unsigned char
Colormap[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
},
Graymap[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
};
#define MaxCixels  92
static const char
Cixel[MaxCixels+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";
char
buffer[MagickPathExtent],
basename[MagickPathExtent],
name[MagickPathExtent],
symbol[MagickPathExtent];
Image
*affinity_image,
*picon;
ImageInfo
*blob_info;
MagickBooleanType
status,
transparent;
PixelInfo
pixel;
QuantizeInfo
*quantize_info;
RectangleInfo
geometry;
register const Quantum
*p;
register ssize_t
i,
x;
register Quantum
*q;
size_t
characters_per_pixel,
colors;
ssize_t
j,
k,
y;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) TransformImageColorspace(image,sRGBColorspace,exception);
SetGeometry(image,&geometry);
(void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,
&geometry.width,&geometry.height);
picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,
exception);
blob_info=CloneImageInfo(image_info);
(void) AcquireUniqueFilename(blob_info->filename);
if ((image_info->type != TrueColorType) &&
(SetImageGray(image,exception) != MagickFalse))
affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,exception);
else
affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,exception);
(void) RelinquishUniqueFileResource(blob_info->filename);
blob_info=DestroyImageInfo(blob_info);
if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))
return(MagickFalse);
quantize_info=AcquireQuantizeInfo(image_info);
status=RemapImage(quantize_info,picon,affinity_image,exception);
quantize_info=DestroyQuantizeInfo(quantize_info);
affinity_image=DestroyImage(affinity_image);
transparent=MagickFalse;
if (picon->storage_class == PseudoClass)
{
(void) CompressImageColormap(picon,exception);
if (picon->alpha_trait != UndefinedPixelTrait)
transparent=MagickTrue;
}
else
{
if (picon->alpha_trait != UndefinedPixelTrait)
{
for (y=0; y < (ssize_t) picon->rows; y++)
{
q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) picon->columns; x++)
{
if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)
transparent=MagickTrue;
else
SetPixelAlpha(picon,OpaqueAlpha,q);
q+=GetPixelChannels(picon);
}
if (SyncAuthenticPixels(picon,exception) == MagickFalse)
break;
}
}
(void) SetImageType(picon,PaletteType,exception);
}
colors=picon->colors;
if (transparent != MagickFalse)
{
colors++;
picon->colormap=(PixelInfo *) ResizeQuantumMemory((void **)
picon->colormap,(size_t) colors,sizeof(*picon->colormap));
if (picon->colormap == (PixelInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationError"");
for (y=0; y < (ssize_t) picon->rows; y++)
{
q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) picon->columns; x++)
{
if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)
SetPixelIndex(picon,(Quantum) picon->colors,q);
q+=GetPixelChannels(picon);
}
if (SyncAuthenticPixels(picon,exception) == MagickFalse)
break;
}
}
characters_per_pixel=1;
for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)
characters_per_pixel++;
(void) WriteBlobString(image,""\n"");
GetPathComponent(picon->filename,BasePath,basename);
(void) FormatLocaleString(buffer,MagickPathExtent,
""static char *%s[] = {\n"",basename);
(void) WriteBlobString(image,buffer);
(void) WriteBlobString(image,""\n"");
(void) FormatLocaleString(buffer,MagickPathExtent,
""\""%.20g %.20g %.20g %.20g\"",\n"",(double) picon->columns,(double)
picon->rows,(double) colors,(double) characters_per_pixel);
(void) WriteBlobString(image,buffer);
GetPixelInfo(image,&pixel);
for (i=0; i < (ssize_t) colors; i++)
{
pixel=picon->colormap[i];
pixel.colorspace=sRGBColorspace;
pixel.depth=8;
pixel.alpha=(double) OpaqueAlpha;
(void) QueryColorname(image,&pixel,XPMCompliance,name,exception);
if (transparent != MagickFalse)
{
if (i == (ssize_t) (colors-1))
(void) CopyMagickString(name,""grey75"",MagickPathExtent);
}
k=i % MaxCixels;
symbol[0]=Cixel[k];
for (j=1; j < (ssize_t) characters_per_pixel; j++)
{
k=((i-k)/MaxCixels) % MaxCixels;
symbol[j]=Cixel[k];
}
symbol[j]='\0';
(void) FormatLocaleString(buffer,MagickPathExtent,""\""%s c %s\"",\n"",
symbol,name);
(void) WriteBlobString(image,buffer);
}
(void) WriteBlobString(image,""\n"");
for (y=0; y < (ssize_t) picon->rows; y++)
{
p=GetVirtualPixels(picon,0,y,picon->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
(void) WriteBlobString(image,""\"""");
for (x=0; x < (ssize_t) picon->columns; x++)
{
k=((ssize_t) GetPixelIndex(picon,p) % MaxCixels);
symbol[0]=Cixel[k];
for (j=1; j < (ssize_t) characters_per_pixel; j++)
{
k=(((int) GetPixelIndex(picon,p)-k)/MaxCixels) % MaxCixels;
symbol[j]=Cixel[k];
}
symbol[j]='\0';
(void) CopyMagickString(buffer,symbol,MagickPathExtent);
(void) WriteBlobString(image,buffer);
p+=GetPixelChannels(image);
}
(void) FormatLocaleString(buffer,MagickPathExtent,""\""%s\n"",
y == (ssize_t) (picon->rows-1) ? """" : "","");
(void) WriteBlobString(image,buffer);
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
picon->rows);
if (status == MagickFalse)
break;
}
picon=DestroyImage(picon);
(void) WriteBlobString(image,""};\n"");
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WritePICONImage(const ImageInfo *VAR_0,
Image *VAR_1,ExceptionInfo *VAR_2)
{
#define VAR_3  155
#define VAR_4  95
#define VAR_5  ""48x48>""
static unsigned char
VAR_6[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
},
VAR_7[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
};
#define VAR_8  92
static const char
VAR_9[VAR_8+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";
char
VAR_10[VAR_11],
VAR_12[VAR_11],
VAR_13[VAR_11],
VAR_14[VAR_11];
Image
*VAR_15,
*VAR_16;
ImageInfo
*VAR_17;
MagickBooleanType
VAR_18,
VAR_19;
PixelInfo
VAR_20;
QuantizeInfo
*VAR_21;
RectangleInfo
VAR_22;
register const Quantum
*VAR_23;
register ssize_t
VAR_24,
VAR_25;
register Quantum
*VAR_26;
size_t
VAR_27,
VAR_28;
ssize_t
VAR_29,
VAR_30,
VAR_31;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_32);
if (VAR_1->debug != VAR_33)
(void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_32);
VAR_18=OpenBlob(VAR_0,VAR_1,VAR_35,VAR_2);
if (VAR_18 == VAR_33)
return(VAR_18);
(void) TransformImageColorspace(VAR_1,VAR_36,VAR_2);
SetGeometry(VAR_1,&VAR_22);
(void) ParseMetaGeometry(VAR_5,&VAR_22.x,&VAR_22.y,
&VAR_22.width,&VAR_22.height);
VAR_16=ResizeImage(VAR_1,VAR_22.width,VAR_22.height,VAR_37,
VAR_2);
VAR_17=CloneImageInfo(VAR_0);
(void) AcquireUniqueFilename(VAR_17->filename);
if ((VAR_0->type != VAR_38) &&
(SetImageGray(VAR_1,VAR_2) != VAR_33))
VAR_15=BlobToImage(VAR_17,VAR_7,VAR_4,VAR_2);
else
VAR_15=BlobToImage(VAR_17,VAR_6,VAR_3,VAR_2);
(void) RelinquishUniqueFileResource(VAR_17->filename);
VAR_17=DestroyImageInfo(VAR_17);
if ((VAR_16 == (Image *) NULL) || (VAR_15 == (Image *) NULL))
return(VAR_33);
VAR_21=AcquireQuantizeInfo(VAR_0);
VAR_18=RemapImage(VAR_21,VAR_16,VAR_15,VAR_2);
VAR_21=DestroyQuantizeInfo(VAR_21);
VAR_15=DestroyImage(VAR_15);
VAR_19=VAR_33;
if (VAR_16->storage_class == VAR_39)
{
(void) CompressImageColormap(VAR_16,VAR_2);
if (VAR_16->alpha_trait != VAR_40)
VAR_19=VAR_41;
}
else
{
if (VAR_16->alpha_trait != VAR_40)
{
for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
{
VAR_26=GetAuthenticPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
if (VAR_26 == (Quantum *) NULL)
break;
for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
{
if (GetPixelAlpha(VAR_1,VAR_26) == (Quantum) VAR_42)
VAR_19=VAR_41;
else
SetPixelAlpha(VAR_16,VAR_43,VAR_26);
VAR_26+=GetPixelChannels(VAR_16);
}
if (SyncAuthenticPixels(VAR_16,VAR_2) == VAR_33)
break;
}
}
(void) SetImageType(VAR_16,VAR_44,VAR_2);
}
VAR_28=VAR_16->colors;
if (VAR_19 != VAR_33)
{
VAR_28++;
VAR_16->colormap=(PixelInfo *) ResizeQuantumMemory((void **)
VAR_16->colormap,(size_t) VAR_28,sizeof(*VAR_16->colormap));
if (VAR_16->colormap == (PixelInfo *) NULL)
ThrowWriterException(VAR_45,""MemoryAllocationError"");
for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
{
VAR_26=GetAuthenticPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
if (VAR_26 == (Quantum *) NULL)
break;
for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
{
if (GetPixelAlpha(VAR_1,VAR_26) == (Quantum) VAR_42)
SetPixelIndex(VAR_16,(Quantum) VAR_16->colors,VAR_26);
VAR_26+=GetPixelChannels(VAR_16);
}
if (SyncAuthenticPixels(VAR_16,VAR_2) == VAR_33)
break;
}
}
VAR_27=1;
for (VAR_30=VAR_8; (ssize_t) VAR_28 > VAR_30; VAR_30*=VAR_8)
VAR_27++;
(void) WriteBlobString(VAR_1,""\n"");
GetPathComponent(VAR_16->filename,VAR_46,VAR_12);
(void) FormatLocaleString(VAR_10,VAR_11,
""static char *%s[] = {\n"",VAR_12);
(void) WriteBlobString(VAR_1,VAR_10);
(void) WriteBlobString(VAR_1,""\n"");
(void) FormatLocaleString(VAR_10,VAR_11,
""\""%.20g %.20g %.20g %.20g\"",\n"",(double) VAR_16->columns,(double)
VAR_16->rows,(double) VAR_28,(double) VAR_27);
(void) WriteBlobString(VAR_1,VAR_10);
GetPixelInfo(VAR_1,&VAR_20);
for (VAR_24=0; VAR_24 < (ssize_t) VAR_28; VAR_24++)
{
VAR_20=VAR_16->colormap[VAR_24];
VAR_20.colorspace=VAR_36;
VAR_20.depth=8;
VAR_20.alpha=(double) VAR_43;
(void) QueryColorname(VAR_1,&VAR_20,VAR_47,VAR_13,VAR_2);
if (VAR_19 != VAR_33)
{
if (VAR_24 == (ssize_t) (VAR_28-1))
(void) CopyMagickString(VAR_13,""grey75"",VAR_11);
}
VAR_30=VAR_24 % VAR_8;
VAR_14[0]=VAR_9[VAR_30];
for (VAR_29=1; VAR_29 < (ssize_t) VAR_27; VAR_29++)
{
VAR_30=((VAR_24-VAR_30)/VAR_8) % VAR_8;
VAR_14[VAR_29]=VAR_9[VAR_30];
}
VAR_14[VAR_29]='\0';
(void) FormatLocaleString(VAR_10,VAR_11,""\""%s c %s\"",\n"",
VAR_14,VAR_13);
(void) WriteBlobString(VAR_1,VAR_10);
}
(void) WriteBlobString(VAR_1,""\n"");
for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
{
VAR_23=GetVirtualPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
if (VAR_23 == (const Quantum *) NULL)
break;
(void) WriteBlobString(VAR_1,""\"""");
for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
{
VAR_30=((ssize_t) GetPixelIndex(VAR_16,VAR_23) % VAR_8);
VAR_14[0]=VAR_9[VAR_30];
for (VAR_29=1; VAR_29 < (ssize_t) VAR_27; VAR_29++)
{
VAR_30=(((int) GetPixelIndex(VAR_16,VAR_23)-VAR_30)/VAR_8) % VAR_8;
VAR_14[VAR_29]=VAR_9[VAR_30];
}
VAR_14[VAR_29]='\0';
(void) CopyMagickString(VAR_10,VAR_14,VAR_11);
(void) WriteBlobString(VAR_1,VAR_10);
VAR_23+=GetPixelChannels(VAR_1);
}
(void) FormatLocaleString(VAR_10,VAR_11,""\""%s\n"",
VAR_31 == (ssize_t) (VAR_16->rows-1) ? """" : "","");
(void) WriteBlobString(VAR_1,VAR_10);
VAR_18=SetImageProgress(VAR_1,VAR_48,(MagickOffsetType) VAR_31,
VAR_16->rows);
if (VAR_18 == VAR_33)
break;
}
VAR_16=DestroyImage(VAR_16);
(void) WriteBlobString(VAR_1,""};\n"");
(void) CloseBlob(VAR_1);
return(VAR_41);
}",ImageMagick/20635b9b859fc649f7682ab08a4c58c644a94bf5/xpm.c/vul/before/0.json,"static MagickBooleanType WritePICONImage(const ImageInfo *image_info,
  Image *image,ExceptionInfo *exception)
{
#define ColormapExtent  155
#define GraymapExtent  95
#define PiconGeometry  ""48x48>""

  static unsigned char
    Colormap[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
    },
    Graymap[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
    };

#define MaxCixels  92

  static const char
    Cixel[MaxCixels+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
                         ""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";

  char
    buffer[MagickPathExtent],
    basename[MagickPathExtent],
    name[MagickPathExtent],
    symbol[MagickPathExtent];

  Image
    *affinity_image,
    *picon;

  ImageInfo
    *blob_info;

  MagickBooleanType
    status,
    transparent;

  PixelInfo
    pixel;

  QuantizeInfo
    *quantize_info;

  RectangleInfo
    geometry;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register Quantum
    *q;

  size_t
    characters_per_pixel,
    colors;

  ssize_t
    j,
    k,
    y;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  (void) TransformImageColorspace(image,sRGBColorspace,exception);
  SetGeometry(image,&geometry);
  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,
    &geometry.width,&geometry.height);
  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,
    exception);
  blob_info=CloneImageInfo(image_info);
  (void) AcquireUniqueFilename(blob_info->filename);
  if ((image_info->type != TrueColorType) &&
      (SetImageGray(image,exception) != MagickFalse))
    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,exception);
  else
    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,exception);
  (void) RelinquishUniqueFileResource(blob_info->filename);
  blob_info=DestroyImageInfo(blob_info);
  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))
    return(MagickFalse);
  quantize_info=AcquireQuantizeInfo(image_info);
  status=RemapImage(quantize_info,picon,affinity_image,exception);
  quantize_info=DestroyQuantizeInfo(quantize_info);
  affinity_image=DestroyImage(affinity_image);
  transparent=MagickFalse;
  if (picon->storage_class == PseudoClass)
    {
      (void) CompressImageColormap(picon,exception);
      if (picon->alpha_trait != UndefinedPixelTrait)
        transparent=MagickTrue;
    }
  else
    {
      /*
        Convert DirectClass to PseudoClass picon.
      */
      if (picon->alpha_trait != UndefinedPixelTrait)
        {
          /*
            Map all the transparent pixels.
          */
          for (y=0; y < (ssize_t) picon->rows; y++)
          {
            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) picon->columns; x++)
            {
              if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)
                transparent=MagickTrue;
              else
                SetPixelAlpha(picon,OpaqueAlpha,q);
              q+=GetPixelChannels(picon);
            }
            if (SyncAuthenticPixels(picon,exception) == MagickFalse)
              break;
          }
        }
      (void) SetImageType(picon,PaletteType,exception);
    }
  colors=picon->colors;
  if (transparent != MagickFalse)
    {
      colors++;
      picon->colormap=(PixelInfo *) ResizeQuantumMemory((void **)
        picon->colormap,(size_t) colors,sizeof(*picon->colormap));
      if (picon->colormap == (PixelInfo *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationError"");
      for (y=0; y < (ssize_t) picon->rows; y++)
      {
        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) picon->columns; x++)
        {
          if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)
            SetPixelIndex(picon,(Quantum) picon->colors,q);
          q+=GetPixelChannels(picon);
        }
        if (SyncAuthenticPixels(picon,exception) == MagickFalse)
          break;
      }
    }
  /*
    Compute the character per pixel.
  */
  characters_per_pixel=1;
  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)
    characters_per_pixel++;
  /*
    XPM header.
  */
  (void) WriteBlobString(image,""/* XPM */\n"");
  GetPathComponent(picon->filename,BasePath,basename);
  (void) FormatLocaleString(buffer,MagickPathExtent,
    ""static char *%s[] = {\n"",basename);
  (void) WriteBlobString(image,buffer);
  (void) WriteBlobString(image,""/* columns rows colors chars-per-pixel */\n"");
  (void) FormatLocaleString(buffer,MagickPathExtent,
    ""\""%.20g %.20g %.20g %.20g\"",\n"",(double) picon->columns,(double)
    picon->rows,(double) colors,(double) characters_per_pixel);
  (void) WriteBlobString(image,buffer);
  GetPixelInfo(image,&pixel);
  for (i=0; i < (ssize_t) colors; i++)
  {
    /*
      Define XPM color.
    */
    pixel=picon->colormap[i];
    pixel.colorspace=sRGBColorspace;
    pixel.depth=8;
    pixel.alpha=(double) OpaqueAlpha;
    (void) QueryColorname(image,&pixel,XPMCompliance,name,exception);
    if (transparent != MagickFalse)
      {
        if (i == (ssize_t) (colors-1))
          (void) CopyMagickString(name,""grey75"",MagickPathExtent);
      }
    /*
      Write XPM color.
    */
    k=i % MaxCixels;
    symbol[0]=Cixel[k];
    for (j=1; j < (ssize_t) characters_per_pixel; j++)
    {
      k=((i-k)/MaxCixels) % MaxCixels;
      symbol[j]=Cixel[k];
    }
    symbol[j]='\0';
    (void) FormatLocaleString(buffer,MagickPathExtent,""\""%s c %s\"",\n"",
       symbol,name);
    (void) WriteBlobString(image,buffer);
  }
  /*
    Define XPM pixels.
  */
  (void) WriteBlobString(image,""/* pixels */\n"");
  for (y=0; y < (ssize_t) picon->rows; y++)
  {
    p=GetVirtualPixels(picon,0,y,picon->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    (void) WriteBlobString(image,""\"""");
    for (x=0; x < (ssize_t) picon->columns; x++)
    {
      k=((ssize_t) GetPixelIndex(picon,p) % MaxCixels);
      symbol[0]=Cixel[k];
      for (j=1; j < (ssize_t) characters_per_pixel; j++)
      {
        k=(((int) GetPixelIndex(picon,p)-k)/MaxCixels) % MaxCixels;
        symbol[j]=Cixel[k];
      }
      symbol[j]='\0';
      (void) CopyMagickString(buffer,symbol,MagickPathExtent);
      (void) WriteBlobString(image,buffer);
      p+=GetPixelChannels(picon);
    }
    (void) FormatLocaleString(buffer,MagickPathExtent,""\""%s\n"",
      y == (ssize_t) (picon->rows-1) ? """" : "","");
    (void) WriteBlobString(image,buffer);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      picon->rows);
    if (status == MagickFalse)
      break;
  }
  picon=DestroyImage(picon);
  (void) WriteBlobString(image,""};\n"");
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WritePICONImage(const ImageInfo *VAR_0,
  Image *VAR_1,ExceptionInfo *VAR_2)
{
#define VAR_3  155
#define VAR_4  95
#define VAR_5  ""48x48>""

  static unsigned char
    VAR_6[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
    },
    VAR_7[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
    };

#define VAR_8  92

  static const char
    VAR_9[VAR_8+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
                         ""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";

  char
    VAR_10[VAR_11],
    VAR_12[VAR_11],
    VAR_13[VAR_11],
    VAR_14[VAR_11];

  Image
    *VAR_15,
    *VAR_16;

  ImageInfo
    *VAR_17;

  MagickBooleanType
    VAR_18,
    VAR_19;

  PixelInfo
    VAR_20;

  QuantizeInfo
    *VAR_21;

  RectangleInfo
    VAR_22;

  register const Quantum
    *VAR_23;

  register ssize_t
    VAR_24,
    VAR_25;

  register Quantum
    *VAR_26;

  size_t
    VAR_27,
    VAR_28;

  ssize_t
    VAR_29,
    VAR_30,
    VAR_31;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_32);
  if (VAR_1->debug != VAR_33)
    (void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_32);
  VAR_18=OpenBlob(VAR_0,VAR_1,VAR_35,VAR_2);
  if (VAR_18 == VAR_33)
    return(VAR_18);
  (void) TransformImageColorspace(VAR_1,VAR_36,VAR_2);
  SetGeometry(VAR_1,&VAR_22);
  (void) ParseMetaGeometry(VAR_5,&VAR_22.x,&VAR_22.y,
    &VAR_22.width,&VAR_22.height);
  VAR_16=ResizeImage(VAR_1,VAR_22.width,VAR_22.height,VAR_37,
    VAR_2);
  VAR_17=CloneImageInfo(VAR_0);
  (void) AcquireUniqueFilename(VAR_17->filename);
  if ((VAR_0->type != VAR_38) &&
      (SetImageGray(VAR_1,VAR_2) != VAR_33))
    VAR_15=BlobToImage(VAR_17,VAR_7,VAR_4,VAR_2);
  else
    VAR_15=BlobToImage(VAR_17,VAR_6,VAR_3,VAR_2);
  (void) RelinquishUniqueFileResource(VAR_17->filename);
  VAR_17=DestroyImageInfo(VAR_17);
  if ((VAR_16 == (Image *) NULL) || (VAR_15 == (Image *) NULL))
    return(VAR_33);
  VAR_21=AcquireQuantizeInfo(VAR_0);
  VAR_18=RemapImage(VAR_21,VAR_16,VAR_15,VAR_2);
  VAR_21=DestroyQuantizeInfo(VAR_21);
  VAR_15=DestroyImage(VAR_15);
  VAR_19=VAR_33;
  if (VAR_16->storage_class == VAR_39)
    {
      (void) CompressImageColormap(VAR_16,VAR_2);
      if (VAR_16->alpha_trait != VAR_40)
        VAR_19=VAR_41;
    }
  else
    {
      /* COMMENT_3 */
                                                 
        
      if (VAR_16->alpha_trait != VAR_40)
        {
          /* COMMENT_6 */
                                           
            
          for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
          {
            VAR_26=GetAuthenticPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
            if (VAR_26 == (Quantum *) NULL)
              break;
            for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
            {
              if (GetPixelAlpha(VAR_1,VAR_26) == (Quantum) VAR_42)
                VAR_19=VAR_41;
              else
                SetPixelAlpha(VAR_16,VAR_43,VAR_26);
              VAR_26+=GetPixelChannels(VAR_16);
            }
            if (SyncAuthenticPixels(VAR_16,VAR_2) == VAR_33)
              break;
          }
        }
      (void) SetImageType(VAR_16,VAR_44,VAR_2);
    }
  VAR_28=VAR_16->colors;
  if (VAR_19 != VAR_33)
    {
      VAR_28++;
      VAR_16->colormap=(PixelInfo *) ResizeQuantumMemory((void **)
        VAR_16->colormap,(size_t) VAR_28,sizeof(*VAR_16->colormap));
      if (VAR_16->colormap == (PixelInfo *) NULL)
        ThrowWriterException(VAR_45,""MemoryAllocationError"");
      for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
      {
        VAR_26=GetAuthenticPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
        if (VAR_26 == (Quantum *) NULL)
          break;
        for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
        {
          if (GetPixelAlpha(VAR_1,VAR_26) == (Quantum) VAR_42)
            SetPixelIndex(VAR_16,(Quantum) VAR_16->colors,VAR_26);
          VAR_26+=GetPixelChannels(VAR_16);
        }
        if (SyncAuthenticPixels(VAR_16,VAR_2) == VAR_33)
          break;
      }
    }
  /* COMMENT_9 */
                                    
    
  VAR_27=1;
  for (VAR_30=VAR_8; (ssize_t) VAR_28 > VAR_30; VAR_30*=VAR_8)
    VAR_27++;
  /* COMMENT_12 */
               
    
  (void) WriteBlobString(VAR_1,""/* XPM */\n"");
  GetPathComponent(VAR_16->filename,VAR_46,VAR_12);
  (void) FormatLocaleString(VAR_10,VAR_11,
    ""static char *%s[] = {\n"",VAR_12);
  (void) WriteBlobString(VAR_1,VAR_10);
  (void) WriteBlobString(VAR_1,""/* columns rows colors chars-per-pixel */\n"");
  (void) FormatLocaleString(VAR_10,VAR_11,
    ""\""%.20g %.20g %.20g %.20g\"",\n"",(double) VAR_16->columns,(double)
    VAR_16->rows,(double) VAR_28,(double) VAR_27);
  (void) WriteBlobString(VAR_1,VAR_10);
  GetPixelInfo(VAR_1,&VAR_20);
  for (VAR_24=0; VAR_24 < (ssize_t) VAR_28; VAR_24++)
  {
    /* COMMENT_15 */
                       
      
    VAR_20=VAR_16->colormap[VAR_24];
    VAR_20.colorspace=VAR_36;
    VAR_20.depth=8;
    VAR_20.alpha=(double) VAR_43;
    (void) QueryColorname(VAR_1,&VAR_20,VAR_47,VAR_13,VAR_2);
    if (VAR_19 != VAR_33)
      {
        if (VAR_24 == (ssize_t) (VAR_28-1))
          (void) CopyMagickString(VAR_13,""grey75"",VAR_11);
      }
    /* COMMENT_18 */
                      
      
    VAR_30=VAR_24 % VAR_8;
    VAR_14[0]=VAR_9[VAR_30];
    for (VAR_29=1; VAR_29 < (ssize_t) VAR_27; VAR_29++)
    {
      VAR_30=((VAR_24-VAR_30)/VAR_8) % VAR_8;
      VAR_14[VAR_29]=VAR_9[VAR_30];
    }
    VAR_14[VAR_29]='\0';
    (void) FormatLocaleString(VAR_10,VAR_11,""\""%s c %s\"",\n"",
       VAR_14,VAR_13);
    (void) WriteBlobString(VAR_1,VAR_10);
  }
  /* COMMENT_21 */
                      
    
  (void) WriteBlobString(VAR_1,""/* pixels */\n"");
  for (VAR_31=0; VAR_31 < (ssize_t) VAR_16->rows; VAR_31++)
  {
    VAR_23=GetVirtualPixels(VAR_16,0,VAR_31,VAR_16->columns,1,VAR_2);
    if (VAR_23 == (const Quantum *) NULL)
      break;
    (void) WriteBlobString(VAR_1,""\"""");
    for (VAR_25=0; VAR_25 < (ssize_t) VAR_16->columns; VAR_25++)
    {
      VAR_30=((ssize_t) GetPixelIndex(VAR_16,VAR_23) % VAR_8);
      VAR_14[0]=VAR_9[VAR_30];
      for (VAR_29=1; VAR_29 < (ssize_t) VAR_27; VAR_29++)
      {
        VAR_30=(((int) GetPixelIndex(VAR_16,VAR_23)-VAR_30)/VAR_8) % VAR_8;
        VAR_14[VAR_29]=VAR_9[VAR_30];
      }
      VAR_14[VAR_29]='\0';
      (void) CopyMagickString(VAR_10,VAR_14,VAR_11);
      (void) WriteBlobString(VAR_1,VAR_10);
      VAR_23+=GetPixelChannels(VAR_16);
    }
    (void) FormatLocaleString(VAR_10,VAR_11,""\""%s\n"",
      VAR_31 == (ssize_t) (VAR_16->rows-1) ? """" : "","");
    (void) WriteBlobString(VAR_1,VAR_10);
    VAR_18=SetImageProgress(VAR_1,VAR_48,(MagickOffsetType) VAR_31,
      VAR_16->rows);
    if (VAR_18 == VAR_33)
      break;
  }
  VAR_16=DestroyImage(VAR_16);
  (void) WriteBlobString(VAR_1,""};\n"");
  (void) CloseBlob(VAR_1);
  return(VAR_41);
}",ImageMagick/20635b9b859fc649f7682ab08a4c58c644a94bf5/xpm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -251,7 +251,7 @@
       symbol[j]='\0';
       (void) CopyMagickString(buffer,symbol,MagickPathExtent);
       (void) WriteBlobString(image,buffer);
-      p+=GetPixelChannels(image);
+      p+=GetPixelChannels(picon);
     }
     (void) FormatLocaleString(buffer,MagickPathExtent,""\""%s\n"",
       y == (ssize_t) (picon->rows-1) ? """" : "","");","{'deleted_lines': ['      p+=GetPixelChannels(image);'], 'added_lines': ['      p+=GetPixelChannels(picon);']}",True,"When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a heap-based buffer over-read in the GetPixelIndex() function, called from the WritePICONImage function in coders/xpm.c.",6.5,MEDIUM,1,valid,2017-07-18T11:31:54Z,2
CVE-2017-11523,['CWE-835'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/591,a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,coders/txt.c,ReadTXTImage,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
char
colorspace[MaxTextExtent],
text[MaxTextExtent];
Image
*image;
IndexPacket
*indexes;
long
x_offset,
y_offset;
MagickBooleanType
status;
MagickPixelPacket
pixel;
QuantumAny
range;
register ssize_t
i,
x;
register PixelPacket
*q;
ssize_t
count,
type,
y;
unsigned long
depth,
height,
max_value,
width;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(text,0,sizeof(text));
(void) ReadBlobString(image,text);
if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
do
{
width=0;
height=0;
max_value=0;
*colorspace='\0';
count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
colorspace);
if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
image->columns=width;
image->rows=height;
for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
image->depth=depth;
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
LocaleLower(colorspace);
i=(ssize_t) strlen(colorspace)-1;
image->matte=MagickFalse;
if ((i > 0) && (colorspace[i] == 'a'))
{
colorspace[i]='\0';
image->matte=MagickTrue;
}
type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
if (type < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
image->colorspace=(ColorspaceType) type;
(void) ResetMagickMemory(&pixel,0,sizeof(pixel));
(void) SetImageBackgroundColor(image);
range=GetQuantumRange(image->depth);
for (y=0; y < (ssize_t) image->rows; y++)
{
double
blue,
green,
index,
opacity,
red;
red=0.0;
green=0.0;
blue=0.0;
index=0.0;
opacity=0.0;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (ReadBlobString(image,text) == (char *) NULL)
break;
switch (image->colorspace)
{
case GRAYColorspace:
{
if (image->matte != MagickFalse)
{
(void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&x_offset,
&y_offset,&red,&opacity);
green=red;
blue=red;
break;
}
(void) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,&y_offset,&red);
green=red;
blue=red;
break;
}
case CMYKColorspace:
{
if (image->matte != MagickFalse)
{
(void) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&green,&blue,&index,&opacity);
break;
}
(void) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
&y_offset,&red,&green,&blue,&index);
break;
}
default:
{
if (image->matte != MagickFalse)
{
(void) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&green,&blue,&opacity);
break;
}
(void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&green,&blue);
break;
}
}
if (strchr(text,'%') != (char *) NULL)
{
red*=0.01*range;
green*=0.01*range;
blue*=0.01*range;
index*=0.01*range;
opacity*=0.01*range;
}
if (image->colorspace == LabColorspace)
{
green+=(range+1)/2.0;
blue+=(range+1)/2.0;
}
pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
range);
pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
range);
pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
range);
pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),
range);
pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+
0.5),range);
q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
exception);
if (q == (PixelPacket *) NULL)
continue;
SetPixelRed(q,pixel.red);
SetPixelGreen(q,pixel.green);
SetPixelBlue(q,pixel.blue);
if (image->colorspace == CMYKColorspace)
{
indexes=GetAuthenticIndexQueue(image);
SetPixelIndex(indexes,pixel.index);
}
if (image->matte != MagickFalse)
SetPixelAlpha(q,pixel.opacity);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
}
(void) ReadBlobString(image,text);
if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
{
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadTXTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3],
VAR_4[VAR_3];
Image
*VAR_5;
IndexPacket
*VAR_6;
long
VAR_7,
VAR_8;
MagickBooleanType
VAR_9;
MagickPixelPacket
VAR_10;
QuantumAny
VAR_11;
register ssize_t
VAR_12,
VAR_13;
register PixelPacket
*VAR_14;
ssize_t
VAR_15,
VAR_16,
VAR_17;
unsigned long
VAR_18,
VAR_19,
VAR_20,
VAR_21;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_22);
if (VAR_0->debug != VAR_23)
(void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_22);
VAR_5=AcquireImage(VAR_0);
VAR_9=OpenBlob(VAR_0,VAR_5,VAR_25,VAR_1);
if (VAR_9 == VAR_23)
{
VAR_5=DestroyImageList(VAR_5);
return((Image *) NULL);
}
(void) ResetMagickMemory(VAR_4,0,sizeof(VAR_4));
(void) ReadBlobString(VAR_5,VAR_4);
if (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) != 0)
ThrowReaderException(VAR_27,""ImproperImageHeader"");
do
{
VAR_21=0;
VAR_19=0;
VAR_20=0;
*VAR_2='\0';
VAR_15=(ssize_t) sscanf(VAR_4+32,""%lu,%lu,%lu,%s"",&VAR_21,&VAR_19,&VAR_20,
VAR_2);
if ((VAR_15 != 4) || (VAR_21 == 0) || (VAR_19 == 0) || (VAR_20 == 0))
ThrowReaderException(VAR_27,""ImproperImageHeader"");
VAR_5->columns=VAR_21;
VAR_5->rows=VAR_19;
for (VAR_18=1; (GetQuantumRange(VAR_18)+1) < VAR_20; VAR_18++) ;
VAR_5->depth=VAR_18;
VAR_9=SetImageExtent(VAR_5,VAR_5->columns,VAR_5->rows);
if (VAR_9 == VAR_23)
{
InheritException(VAR_1,&VAR_5->exception);
return(DestroyImageList(VAR_5));
}
LocaleLower(VAR_2);
VAR_12=(ssize_t) strlen(VAR_2)-1;
VAR_5->matte=VAR_23;
if ((VAR_12 > 0) && (VAR_2[VAR_12] == 'a'))
{
VAR_2[VAR_12]='\0';
VAR_5->matte=VAR_28;
}
VAR_16=ParseCommandOption(VAR_29,VAR_23,VAR_2);
if (VAR_16 < 0)
ThrowReaderException(VAR_27,""ImproperImageHeader"");
VAR_5->colorspace=(ColorspaceType) VAR_16;
(void) ResetMagickMemory(&VAR_10,0,sizeof(VAR_10));
(void) SetImageBackgroundColor(VAR_5);
VAR_11=GetQuantumRange(VAR_5->depth);
for (VAR_17=0; VAR_17 < (ssize_t) VAR_5->rows; VAR_17++)
{
double
VAR_30,
VAR_31,
VAR_32,
VAR_33,
VAR_34;
VAR_34=0.0;
VAR_31=0.0;
VAR_30=0.0;
VAR_32=0.0;
VAR_33=0.0;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_5->columns; VAR_13++)
{
if (ReadBlobString(VAR_5,VAR_4) == (char *) NULL)
break;
switch (VAR_5->colorspace)
{
case VAR_35:
{
if (VAR_5->matte != VAR_23)
{
(void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&VAR_7,
&VAR_8,&VAR_34,&VAR_33);
VAR_31=VAR_34;
VAR_30=VAR_34;
break;
}
(void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]"",&VAR_7,&VAR_8,&VAR_34);
VAR_31=VAR_34;
VAR_30=VAR_34;
break;
}
case VAR_36:
{
if (VAR_5->matte != VAR_23)
{
(void) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_32,&VAR_33);
break;
}
(void) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_7,
&VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_32);
break;
}
default:
{
if (VAR_5->matte != VAR_23)
{
(void) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_33);
break;
}
(void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30);
break;
}
}
if (strchr(VAR_4,'%') != (char *) NULL)
{
VAR_34*=0.01*VAR_11;
VAR_31*=0.01*VAR_11;
VAR_30*=0.01*VAR_11;
VAR_32*=0.01*VAR_11;
VAR_33*=0.01*VAR_11;
}
if (VAR_5->colorspace == VAR_37)
{
VAR_31+=(VAR_11+1)/2.0;
VAR_30+=(VAR_11+1)/2.0;
}
VAR_10.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_34+0.5),
VAR_11);
VAR_10.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_31+0.5),
VAR_11);
VAR_10.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_30+0.5),
VAR_11);
VAR_10.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_32+0.5),
VAR_11);
VAR_10.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_33+
0.5),VAR_11);
VAR_14=GetAuthenticPixels(VAR_5,(ssize_t) VAR_7,(ssize_t) VAR_8,1,1,
VAR_1);
if (VAR_14 == (PixelPacket *) NULL)
continue;
SetPixelRed(VAR_14,VAR_10.red);
SetPixelGreen(VAR_14,VAR_10.green);
SetPixelBlue(VAR_14,VAR_10.blue);
if (VAR_5->colorspace == VAR_36)
{
VAR_6=GetAuthenticIndexQueue(VAR_5);
SetPixelIndex(VAR_6,VAR_10.index);
}
if (VAR_5->matte != VAR_23)
SetPixelAlpha(VAR_14,VAR_10.opacity);
if (SyncAuthenticPixels(VAR_5,VAR_1) == VAR_23)
break;
}
}
(void) ReadBlobString(VAR_5,VAR_4);
if (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) == 0)
{
AcquireNextImage(VAR_0,VAR_5);
if (GetNextImageInList(VAR_5) == (Image *) NULL)
{
VAR_5=DestroyImageList(VAR_5);
return((Image *) NULL);
}
VAR_5=SyncNextImageInList(VAR_5);
VAR_9=SetImageProgress(VAR_5,VAR_38,TellBlob(VAR_5),
GetBlobSize(VAR_5));
if (VAR_9 == VAR_23)
break;
}
} while (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) == 0);
(void) CloseBlob(VAR_5);
return(GetFirstImageInList(VAR_5));
}",ImageMagick/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78/txt.c/vul/before/0.json,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MaxTextExtent],
    text[MaxTextExtent];

  Image
    *image;

  IndexPacket
    *indexes;

  long
    x_offset,
    y_offset;

  MagickBooleanType
    status;

  MagickPixelPacket
    pixel;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->matte=MagickFalse;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->matte=MagickTrue;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->colorspace=(ColorspaceType) type;
    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
    (void) SetImageBackgroundColor(image);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        blue,
        green,
        index,
        opacity,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      index=0.0;
      opacity=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&x_offset,
                  &y_offset,&red,&opacity);
                green=red;
                blue=red;
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,&y_offset,&red);
            green=red;
            blue=red;
            break;
          }
          case CMYKColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);
                break;
              }
            (void) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&index);
            break;
          }
          default:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&opacity);
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
              &x_offset,&y_offset,&red,&green,&blue);
            break;
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            index*=0.01*range;
            opacity*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),
          range);
        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+
          0.5),range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (PixelPacket *) NULL)
          continue;
        SetPixelRed(q,pixel.red);
        SetPixelGreen(q,pixel.green);
        SetPixelBlue(q,pixel.blue);
        if (image->colorspace == CMYKColorspace)
          {
            indexes=GetAuthenticIndexQueue(image);
            SetPixelIndex(indexes,pixel.index);
          }
        if (image->matte != MagickFalse)
          SetPixelAlpha(q,pixel.opacity);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    (void) ReadBlobString(image,text);
    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadTXTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3],
    VAR_4[VAR_3];

  Image
    *VAR_5;

  IndexPacket
    *VAR_6;

  long
    VAR_7,
    VAR_8;

  MagickBooleanType
    VAR_9;

  MagickPixelPacket
    VAR_10;

  QuantumAny
    VAR_11;

  register ssize_t
    VAR_12,
    VAR_13;

  register PixelPacket
    *VAR_14;

  ssize_t
    VAR_15,
    VAR_16,
    VAR_17;

  unsigned long
    VAR_18,
    VAR_19,
    VAR_20,
    VAR_21;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_22);
  if (VAR_0->debug != VAR_23)
    (void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_22);
  VAR_5=AcquireImage(VAR_0);
  VAR_9=OpenBlob(VAR_0,VAR_5,VAR_25,VAR_1);
  if (VAR_9 == VAR_23)
    {
      VAR_5=DestroyImageList(VAR_5);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(VAR_4,0,sizeof(VAR_4));
  (void) ReadBlobString(VAR_5,VAR_4);
  if (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) != 0)
    ThrowReaderException(VAR_27,""ImproperImageHeader"");
  do
  {
    VAR_21=0;
    VAR_19=0;
    VAR_20=0;
    *VAR_2='\0';
    VAR_15=(ssize_t) sscanf(VAR_4+32,""%lu,%lu,%lu,%s"",&VAR_21,&VAR_19,&VAR_20,
      VAR_2);
    if ((VAR_15 != 4) || (VAR_21 == 0) || (VAR_19 == 0) || (VAR_20 == 0))
      ThrowReaderException(VAR_27,""ImproperImageHeader"");
    VAR_5->columns=VAR_21;
    VAR_5->rows=VAR_19;
    for (VAR_18=1; (GetQuantumRange(VAR_18)+1) < VAR_20; VAR_18++) ;
    VAR_5->depth=VAR_18;
    VAR_9=SetImageExtent(VAR_5,VAR_5->columns,VAR_5->rows);
    if (VAR_9 == VAR_23)
      {
        InheritException(VAR_1,&VAR_5->exception);
        return(DestroyImageList(VAR_5));
      }
    LocaleLower(VAR_2);
    VAR_12=(ssize_t) strlen(VAR_2)-1;
    VAR_5->matte=VAR_23;
    if ((VAR_12 > 0) && (VAR_2[VAR_12] == 'a'))
      {
        VAR_2[VAR_12]='\0';
        VAR_5->matte=VAR_28;
      }
    VAR_16=ParseCommandOption(VAR_29,VAR_23,VAR_2);
    if (VAR_16 < 0)
      ThrowReaderException(VAR_27,""ImproperImageHeader"");
    VAR_5->colorspace=(ColorspaceType) VAR_16;
    (void) ResetMagickMemory(&VAR_10,0,sizeof(VAR_10));
    (void) SetImageBackgroundColor(VAR_5);
    VAR_11=GetQuantumRange(VAR_5->depth);
    for (VAR_17=0; VAR_17 < (ssize_t) VAR_5->rows; VAR_17++)
    {
      double
        VAR_30,
        VAR_31,
        VAR_32,
        VAR_33,
        VAR_34;

      VAR_34=0.0;
      VAR_31=0.0;
      VAR_30=0.0;
      VAR_32=0.0;
      VAR_33=0.0;
      for (VAR_13=0; VAR_13 < (ssize_t) VAR_5->columns; VAR_13++)
      {
        if (ReadBlobString(VAR_5,VAR_4) == (char *) NULL)
          break;
        switch (VAR_5->colorspace)
        {
          case VAR_35:
          {
            if (VAR_5->matte != VAR_23)
              {
                (void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&VAR_7,
                  &VAR_8,&VAR_34,&VAR_33);
                VAR_31=VAR_34;
                VAR_30=VAR_34;
                break;
              }
            (void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]"",&VAR_7,&VAR_8,&VAR_34);
            VAR_31=VAR_34;
            VAR_30=VAR_34;
            break;
          }
          case VAR_36:
          {
            if (VAR_5->matte != VAR_23)
              {
                (void) sscanf(VAR_4,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_32,&VAR_33);
                break;
              }
            (void) sscanf(VAR_4,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_7,
              &VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_32);
            break;
          }
          default:
          {
            if (VAR_5->matte != VAR_23)
              {
                (void) sscanf(VAR_4,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30,&VAR_33);
                break;
              }
            (void) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
              &VAR_7,&VAR_8,&VAR_34,&VAR_31,&VAR_30);
            break;
          }
        }
        if (strchr(VAR_4,'%') != (char *) NULL)
          {
            VAR_34*=0.01*VAR_11;
            VAR_31*=0.01*VAR_11;
            VAR_30*=0.01*VAR_11;
            VAR_32*=0.01*VAR_11;
            VAR_33*=0.01*VAR_11;
          }
        if (VAR_5->colorspace == VAR_37)
          {
            VAR_31+=(VAR_11+1)/2.0;
            VAR_30+=(VAR_11+1)/2.0;
          }
        VAR_10.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_34+0.5),
          VAR_11);
        VAR_10.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_31+0.5),
          VAR_11);
        VAR_10.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_30+0.5),
          VAR_11);
        VAR_10.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_32+0.5),
          VAR_11);
        VAR_10.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_33+
          0.5),VAR_11);
        VAR_14=GetAuthenticPixels(VAR_5,(ssize_t) VAR_7,(ssize_t) VAR_8,1,1,
          VAR_1);
        if (VAR_14 == (PixelPacket *) NULL)
          continue;
        SetPixelRed(VAR_14,VAR_10.red);
        SetPixelGreen(VAR_14,VAR_10.green);
        SetPixelBlue(VAR_14,VAR_10.blue);
        if (VAR_5->colorspace == VAR_36)
          {
            VAR_6=GetAuthenticIndexQueue(VAR_5);
            SetPixelIndex(VAR_6,VAR_10.index);
          }
        if (VAR_5->matte != VAR_23)
          SetPixelAlpha(VAR_14,VAR_10.opacity);
        if (SyncAuthenticPixels(VAR_5,VAR_1) == VAR_23)
          break;
      }
    }
    if (EOFBlob(VAR_5) != VAR_23)
      {
        ThrowFileException(VAR_1,VAR_27,""UnexpectedEndOfFile"",
          VAR_5->filename);
        break;
      }
    (void) ReadBlobString(VAR_5,VAR_4);
    if (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) == 0)
      {
        /* COMMENT_3 */
                                        
          
        AcquireNextImage(VAR_0,VAR_5);
        if (GetNextImageInList(VAR_5) == (Image *) NULL)
          {
            VAR_5=DestroyImageList(VAR_5);
            return((Image *) NULL);
          }
        VAR_5=SyncNextImageInList(VAR_5);
        VAR_9=SetImageProgress(VAR_5,VAR_38,TellBlob(VAR_5),
          GetBlobSize(VAR_5));
        if (VAR_9 == VAR_23)
          break;
      }
  } while (LocaleNCompare((char *) VAR_4,VAR_26,strlen(VAR_26)) == 0);
  (void) CloseBlob(VAR_5);
  return(GetFirstImageInList(VAR_5));
}",ImageMagick/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78/txt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -201,6 +201,12 @@
           break;
       }
     }
+    if (EOFBlob(image) != MagickFalse)
+      {
+        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
+          image->filename);
+        break;
+      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {","{'deleted_lines': [], 'added_lines': ['    if (EOFBlob(image) != MagickFalse)', '      {', '        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",', '          image->filename);', '        break;', '      }']}",True,"The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered.",6.5,MEDIUM,1,valid,2017-07-19T17:15:21Z,2
CVE-2017-16932,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,GNOME/libxml2,"Detect infinite recursion in parameter entities

When expanding a parameter entity in a DTD, infinite recursion could
lead to an infinite loop or memory exhaustion.

Thanks to Wei Lei for the first of many reports.

Fixes bug 759579.",899a5d9f0ed13b8e32449a08a361e0de127dd961,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,parser.c,xmlPushInput,"int
xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
int ret;
if (input == NULL) return(-1);
if (xmlParserDebugEntities) {
if ((ctxt->input != NULL) && (ctxt->input->filename))
xmlGenericError(xmlGenericErrorContext,
""%s(%d): "", ctxt->input->filename,
ctxt->input->line);
xmlGenericError(xmlGenericErrorContext,
""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
}
ret = inputPush(ctxt, input);
if (ctxt->instate == XML_PARSER_EOF)
return(-1);
GROW;
return(ret);
}","int
xmlPushInput(xmlParserCtxtPtr VAR_0, xmlParserInputPtr VAR_1) {
int VAR_2;
if (VAR_1 == NULL) return(-1);
if (VAR_3) {
if ((VAR_0->input != NULL) && (VAR_0->input->filename))
xmlGenericError(VAR_4,
""%s(%d): "", VAR_0->input->filename,
VAR_0->input->line);
xmlGenericError(VAR_4,
""Pushing input %d : %.30s\n"", VAR_0->inputNr+1, VAR_1->cur);
}
VAR_2 = inputPush(VAR_0, VAR_1);
if (VAR_0->instate == VAR_5)
return(-1);
VAR_6;
return(VAR_2);
}",GNOME/libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c/vul/before/1.json,"int
xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
    int ret;
    if (input == NULL) return(-1);

    if (xmlParserDebugEntities) {
	if ((ctxt->input != NULL) && (ctxt->input->filename))
	    xmlGenericError(xmlGenericErrorContext,
		    ""%s(%d): "", ctxt->input->filename,
		    ctxt->input->line);
	xmlGenericError(xmlGenericErrorContext,
		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
    }
    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
        (ctxt->inputNr > 1024)) {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
        while (ctxt->inputNr > 1)
            xmlFreeInputStream(inputPop(ctxt));
	return(-1);
    }
    ret = inputPush(ctxt, input);
    if (ctxt->instate == XML_PARSER_EOF)
        return(-1);
    GROW;
    return(ret);
}","int
xmlPushInput(xmlParserCtxtPtr VAR_0, xmlParserInputPtr VAR_1) {
    int VAR_2;
    if (VAR_1 == NULL) return(-1);

    if (VAR_3) {
	if ((VAR_0->input != NULL) && (VAR_0->input->filename))
	    xmlGenericError(VAR_4,
		    ""%s(%d): "", VAR_0->input->filename,
		    VAR_0->input->line);
	xmlGenericError(VAR_4,
		""Pushing input %d : %.30s\n"", VAR_0->inputNr+1, VAR_1->cur);
    }
    if (((VAR_0->inputNr > 40) && ((VAR_0->options & VAR_5) == 0)) ||
        (VAR_0->inputNr > 1024)) {
        xmlFatalErr(VAR_0, VAR_6, NULL);
        while (VAR_0->inputNr > 1)
            xmlFreeInputStream(inputPop(VAR_0));
	return(-1);
    }
    VAR_2 = inputPush(VAR_0, VAR_1);
    if (VAR_0->instate == VAR_7)
        return(-1);
    VAR_8;
    return(VAR_2);
}",GNOME/libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,6 +11,13 @@
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
+        (ctxt->inputNr > 1024)) {
+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
+        while (ctxt->inputNr > 1)
+            xmlFreeInputStream(inputPop(ctxt));
+	return(-1);
+    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);","{'deleted_lines': [], 'added_lines': ['    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||', '        (ctxt->inputNr > 1024)) {', '        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);', '        while (ctxt->inputNr > 1)', '            xmlFreeInputStream(inputPop(ctxt));', '\treturn(-1);', '    }']}",True,parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,7.5,HIGH,2,valid,2017-07-25T12:59:49Z,2
CVE-2017-16932,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,GNOME/libxml2,"Detect infinite recursion in parameter entities

When expanding a parameter entity in a DTD, infinite recursion could
lead to an infinite loop or memory exhaustion.

Thanks to Wei Lei for the first of many reports.

Fixes bug 759579.",899a5d9f0ed13b8e32449a08a361e0de127dd961,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,parser.c,xmlParsePEReference,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
const xmlChar *name;
xmlEntityPtr entity = NULL;
xmlParserInputPtr input;
if (RAW != '%')
return;
NEXT;
name = xmlParseName(ctxt);
if (name == NULL) {
xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
return;
}
if (xmlParserDebugEntities)
xmlGenericError(xmlGenericErrorContext,
""PEReference: %s\n"", name);
if (RAW != ';') {
xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
return;
}
NEXT;
ctxt->nbentities++;
if ((ctxt->sax != NULL) &&
(ctxt->sax->getParameterEntity != NULL))
entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
if (ctxt->instate == XML_PARSER_EOF)
return;
if (entity == NULL) {
if ((ctxt->standalone == 1) ||
((ctxt->hasExternalSubset == 0) &&
(ctxt->hasPErefs == 0))) {
xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name);
} else {
if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name, NULL);
} else
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name, NULL);
ctxt->valid = 0;
}
xmlParserEntityCheck(ctxt, 0, NULL, 0);
} else {
if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
(entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""Internal: %%%s; is not a parameter entity\n"",
name, NULL);
} else {
xmlChar start[4];
xmlCharEncoding enc;
if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
((ctxt->options & XML_PARSE_NOENT) == 0) &&
((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
(ctxt->replaceEntities == 0) &&
(ctxt->validate == 0))
return;
input = xmlNewEntityInputStream(ctxt, entity);
if (xmlPushInput(ctxt, input) < 0)
return;
if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
GROW
if (ctxt->instate == XML_PARSER_EOF)
return;
if ((ctxt->input->end - ctxt->input->cur)>=4) {
start[0] = RAW;
start[1] = NXT(1);
start[2] = NXT(2);
start[3] = NXT(3);
enc = xmlDetectCharEncoding(start, 4);
if (enc != XML_CHAR_ENCODING_NONE) {
xmlSwitchEncoding(ctxt, enc);
}
}
if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(ctxt);
}
}
}
}
ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
const xmlChar *VAR_1;
xmlEntityPtr VAR_2 = NULL;
xmlParserInputPtr VAR_3;
if (VAR_4 != '%')
return;
VAR_5;
VAR_1 = xmlParseName(VAR_0);
if (VAR_1 == NULL) {
xmlFatalErrMsg(VAR_0, VAR_6, ""PEReference: no name\n"");
return;
}
if (VAR_7)
xmlGenericError(VAR_8,
""PEReference: %s\n"", VAR_1);
if (VAR_4 != ';') {
xmlFatalErr(VAR_0, VAR_9, NULL);
return;
}
VAR_5;
VAR_0->nbentities++;
if ((VAR_0->sax != NULL) &&
(VAR_0->sax->getParameterEntity != NULL))
VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
if (VAR_0->instate == VAR_10)
return;
if (VAR_2 == NULL) {
if ((VAR_0->standalone == 1) ||
((VAR_0->hasExternalSubset == 0) &&
(VAR_0->hasPErefs == 0))) {
xmlFatalErrMsgStr(VAR_0, VAR_11,
""PEReference: %%%s; not found\n"",
VAR_1);
} else {
if ((VAR_0->validate) && (VAR_0->vctxt.error != NULL)) {
xmlValidityError(VAR_0, VAR_12,
""PEReference: %%%s; not found\n"",
VAR_1, NULL);
} else
xmlWarningMsg(VAR_0, VAR_12,
""PEReference: %%%s; not found\n"",
VAR_1, NULL);
VAR_0->valid = 0;
}
xmlParserEntityCheck(VAR_0, 0, NULL, 0);
} else {
if ((VAR_2->etype != VAR_13) &&
(VAR_2->etype != VAR_14)) {
xmlWarningMsg(VAR_0, VAR_12,
""Internal: %%%s; is not a parameter entity\n"",
VAR_1, NULL);
} else {
xmlChar VAR_15[4];
xmlCharEncoding VAR_16;
if ((VAR_2->etype == VAR_14) &&
((VAR_0->options & VAR_17) == 0) &&
((VAR_0->options & VAR_18) == 0) &&
((VAR_0->options & VAR_19) == 0) &&
((VAR_0->options & VAR_20) == 0) &&
(VAR_0->replaceEntities == 0) &&
(VAR_0->validate == 0))
return;
VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
if (xmlPushInput(VAR_0, VAR_3) < 0)
return;
if (VAR_2->etype == VAR_14) {
GROW
if (ctxt->VAR_21 == VAR_10)
return;
if ((ctxt->input->end - ctxt->input->cur)>=4) {
VAR_15[0] = VAR_4;
VAR_15[1] = NXT(1);
VAR_15[2] = NXT(2);
VAR_15[3] = NXT(3);
VAR_16 = xmlDetectCharEncoding(VAR_15, 4);
if (VAR_16 != VAR_22) {
xmlSwitchEncoding(ctxt, VAR_16);
}
}
if ((CMP5(VAR_23, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(ctxt);
}
}
}
}
ctxt->hasPErefs = 1;
}",GNOME/libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c/vul/before/0.json,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
	return;
    }
    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		""PEReference: %s\n"", name);
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                 ""PEReference: %%%s; not found\n"",
                                 name, NULL);
            } else
                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                              ""PEReference: %%%s; not found\n"",
                              name, NULL);
            ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else {
            xmlChar start[4];
            xmlCharEncoding enc;

	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
		(ctxt->replaceEntities == 0) &&
		(ctxt->validate == 0))
		return;

	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0) {
                xmlFreeInputStream(input);
		return;
            }

	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines.
                 * Note that, since we may have some non-UTF8
                 * encoding (like UTF16, bug 135229), the 'length'
                 * is not known, but we can calculate based upon
                 * the amount of data in the buffer.
                 */
                GROW
                if (ctxt->instate == XML_PARSER_EOF)
                    return;
                if ((ctxt->input->end - ctxt->input->cur)>=4) {
                    start[0] = RAW;
                    start[1] = NXT(1);
                    start[2] = NXT(2);
                    start[3] = NXT(3);
                    enc = xmlDetectCharEncoding(start, 4);
                    if (enc != XML_CHAR_ENCODING_NONE) {
                        xmlSwitchEncoding(ctxt, enc);
                    }
                }

                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
                    (IS_BLANK_CH(NXT(5)))) {
                    xmlParseTextDecl(ctxt);
                }
            }
	}
    }
    ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
    const xmlChar *VAR_1;
    xmlEntityPtr VAR_2 = NULL;
    xmlParserInputPtr VAR_3;

    if (VAR_4 != '%')
        return;
    VAR_5;
    VAR_1 = xmlParseName(VAR_0);
    if (VAR_1 == NULL) {
	xmlFatalErrMsg(VAR_0, VAR_6, ""PEReference: no name\n"");
	return;
    }
    if (VAR_7)
	xmlGenericError(VAR_8,
		""PEReference: %s\n"", VAR_1);
    if (VAR_4 != ';') {
	xmlFatalErr(VAR_0, VAR_9, NULL);
        return;
    }

    VAR_5;

    /* COMMENT_0 */
                                                      
       
    VAR_0->nbentities++;

    /* COMMENT_3 */
                                  
       
    if ((VAR_0->sax != NULL) &&
	(VAR_0->sax->getParameterEntity != NULL))
	VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
    if (VAR_0->instate == VAR_10)
	return;
    if (VAR_2 == NULL) {
	/* COMMENT_6 */
                            
                                                          
                                                          
                                                          
                                                          
                          
    
	if ((VAR_0->standalone == 1) ||
	    ((VAR_0->hasExternalSubset == 0) &&
	     (VAR_0->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(VAR_0, VAR_11,
			      ""PEReference: %%%s; not found\n"",
			      VAR_1);
	} else {
	    /* COMMENT_14 */
                               
                                                         
                                                      
                                                      
                                      
        
            if ((VAR_0->validate) && (VAR_0->vctxt.error != NULL)) {
                xmlValidityError(VAR_0, VAR_12,
                                 ""PEReference: %%%s; not found\n"",
                                 VAR_1, NULL);
            } else
                xmlWarningMsg(VAR_0, VAR_12,
                              ""PEReference: %%%s; not found\n"",
                              VAR_1, NULL);
            VAR_0->valid = 0;
	}
	xmlParserEntityCheck(VAR_0, 0, NULL, 0);
    } else {
	/* COMMENT_21 */
                                                     
    
	if ((VAR_2->etype != VAR_13) &&
	    (VAR_2->etype != VAR_14)) {
	    xmlWarningMsg(VAR_0, VAR_12,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  VAR_1, NULL);
	} else {
            xmlChar VAR_15[4];
            xmlCharEncoding VAR_16;

	    if ((VAR_2->etype == VAR_14) &&
	        ((VAR_0->options & VAR_17) == 0) &&
		((VAR_0->options & VAR_18) == 0) &&
		((VAR_0->options & VAR_19) == 0) &&
		((VAR_0->options & VAR_20) == 0) &&
		(VAR_0->replaceEntities == 0) &&
		(VAR_0->validate == 0))
		return;

	    VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
	    if (xmlPushInput(VAR_0, VAR_3) < 0) {
                xmlFreeInputStream(VAR_3);
		return;
            }

	    if (VAR_2->etype == VAR_14) {
                /* COMMENT_24 */
                                                               
                                                   
                                                          
                                                             
                                                                  
                                                                
                                                    
                   
                GROW
                if (ctxt->VAR_21 == VAR_10)
                    return;
                if ((ctxt->input->end - ctxt->input->cur)>=4) {
                    VAR_15[0] = VAR_4;
                    VAR_15[1] = NXT(1);
                    VAR_15[2] = NXT(2);
                    VAR_15[3] = NXT(3);
                    VAR_16 = xmlDetectCharEncoding(VAR_15, 4);
                    if (VAR_16 != VAR_22) {
                        xmlSwitchEncoding(ctxt, VAR_16);
                    }
                }

                if ((CMP5(VAR_23, '<', '?', 'x', 'm', 'l')) &&
                    (IS_BLANK_CH(NXT(5)))) {
                    xmlParseTextDecl(ctxt);
                }
            }
	}
    }
    ctxt->hasPErefs = 1;
}",GNOME/libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -93,8 +93,10 @@
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
-	    if (xmlPushInput(ctxt, input) < 0)
+	    if (xmlPushInput(ctxt, input) < 0) {
+                xmlFreeInputStream(input);
 		return;
+            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*","{'deleted_lines': ['\t    if (xmlPushInput(ctxt, input) < 0)'], 'added_lines': ['\t    if (xmlPushInput(ctxt, input) < 0) {', '                xmlFreeInputStream(input);', '            }']}",True,parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,7.5,HIGH,2,valid,2017-07-25T12:59:49Z,2
CVE-2017-14156,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Update atyfb_base.c

Structure atyclk is copied to userland with padding bytes after
""vclk_post_div"" field unitialized.  It leads to leaking of
contents of kernel stack memory.  We have to initialize them to zero. or it will allows local users to obtain potentially sensitive information from kernel stack memory by reading a copy of this structure",4523622d274e0bf0b2b054445d570a3215c3c250,https://github.com/torvalds/linux/commit/4523622d274e0bf0b2b054445d570a3215c3c250,drivers/video/fbdev/aty/atyfb_base.c,atyfb_ioctl,"static int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)
{
struct atyfb_par *par = (struct atyfb_par *) info->par;
#ifdef __sparc__
struct fbtype fbtyp;
#endif
switch (cmd) {
#ifdef __sparc__
case FBIOGTYPE:
fbtyp.fb_type = FBTYPE_PCI_GENERIC;
fbtyp.fb_width = par->crtc.vxres;
fbtyp.fb_height = par->crtc.vyres;
fbtyp.fb_depth = info->var.bits_per_pixel;
fbtyp.fb_cmsize = info->cmap.len;
fbtyp.fb_size = info->fix.smem_len;
if (copy_to_user((struct fbtype __user *) arg, &fbtyp,
sizeof(fbtyp)))
return -EFAULT;
break;
#endif 
case FBIO_WAITFORVSYNC:
{
u32 crtc;
if (get_user(crtc, (__u32 __user *) arg))
return -EFAULT;
return aty_waitforvblank(par, crtc);
}
#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)
case ATYIO_CLKR:
if (M64_HAS(INTEGRATED)) {
struct atyclk clk;
union aty_pll *pll = &par->pll;
u32 dsp_config = pll->ct.dsp_config;
u32 dsp_on_off = pll->ct.dsp_on_off;
clk.ref_clk_per = par->ref_clk_per;
clk.pll_ref_div = pll->ct.pll_ref_div;
clk.mclk_fb_div = pll->ct.mclk_fb_div;
clk.mclk_post_div = pll->ct.mclk_post_div_real;
clk.mclk_fb_mult = pll->ct.mclk_fb_mult;
clk.xclk_post_div = pll->ct.xclk_post_div_real;
clk.vclk_fb_div = pll->ct.vclk_fb_div;
clk.vclk_post_div = pll->ct.vclk_post_div_real;
clk.dsp_xclks_per_row = dsp_config & 0x3fff;
clk.dsp_loop_latency = (dsp_config >> 16) & 0xf;
clk.dsp_precision = (dsp_config >> 20) & 7;
clk.dsp_off = dsp_on_off & 0x7ff;
clk.dsp_on = (dsp_on_off >> 16) & 0x7ff;
if (copy_to_user((struct atyclk __user *) arg, &clk,
sizeof(clk)))
return -EFAULT;
} else
return -EINVAL;
break;
case ATYIO_CLKW:
if (M64_HAS(INTEGRATED)) {
struct atyclk clk;
union aty_pll *pll = &par->pll;
if (copy_from_user(&clk, (struct atyclk __user *) arg,
sizeof(clk)))
return -EFAULT;
par->ref_clk_per = clk.ref_clk_per;
pll->ct.pll_ref_div = clk.pll_ref_div;
pll->ct.mclk_fb_div = clk.mclk_fb_div;
pll->ct.mclk_post_div_real = clk.mclk_post_div;
pll->ct.mclk_fb_mult = clk.mclk_fb_mult;
pll->ct.xclk_post_div_real = clk.xclk_post_div;
pll->ct.vclk_fb_div = clk.vclk_fb_div;
pll->ct.vclk_post_div_real = clk.vclk_post_div;
pll->ct.dsp_config = (clk.dsp_xclks_per_row & 0x3fff) |
((clk.dsp_loop_latency & 0xf) << 16) |
((clk.dsp_precision & 7) << 20);
pll->ct.dsp_on_off = (clk.dsp_off & 0x7ff) |
((clk.dsp_on & 0x7ff) << 16);
aty_set_pll_ct(info, pll);
} else
return -EINVAL;
break;
case ATYIO_FEATR:
if (get_user(par->features, (u32 __user *) arg))
return -EFAULT;
break;
case ATYIO_FEATW:
if (put_user(par->features, (u32 __user *) arg))
return -EFAULT;
break;
#endif 
default:
return -EINVAL;
}
return 0;
}","static int atyfb_ioctl(struct fb_info *VAR_0, u_int VAR_1, u_long VAR_2)
{
struct atyfb_par *VAR_3 = (struct atyfb_par *) VAR_0->par;
#ifdef VAR_4
struct fbtype VAR_5;
#endif
switch (VAR_1) {
#ifdef VAR_4
case VAR_6:
VAR_5.fb_type = VAR_7;
VAR_5.fb_width = VAR_3->crtc.vxres;
VAR_5.fb_height = VAR_3->crtc.vyres;
VAR_5.fb_depth = VAR_0->var.bits_per_pixel;
VAR_5.fb_cmsize = VAR_0->cmap.len;
VAR_5.fb_size = VAR_0->fix.smem_len;
if (copy_to_user((struct fbtype __user *) VAR_2, &VAR_5,
sizeof(VAR_5)))
return -VAR_8;
break;
#endif 
case VAR_9:
{
u32 VAR_10;
if (get_user(VAR_10, (VAR_11 __user *) VAR_2))
return -VAR_8;
return aty_waitforvblank(VAR_3, VAR_10);
}
#if defined(VAR_12) && defined(VAR_13)
case VAR_14:
if (M64_HAS(VAR_15)) {
struct atyclk VAR_16;
union aty_pll *VAR_17 = &VAR_3->pll;
u32 VAR_18 = VAR_17->ct.dsp_config;
u32 VAR_19 = VAR_17->ct.dsp_on_off;
VAR_16.ref_clk_per = VAR_3->ref_clk_per;
VAR_16.pll_ref_div = VAR_17->ct.pll_ref_div;
VAR_16.mclk_fb_div = VAR_17->ct.mclk_fb_div;
VAR_16.mclk_post_div = VAR_17->ct.mclk_post_div_real;
VAR_16.mclk_fb_mult = VAR_17->ct.mclk_fb_mult;
VAR_16.xclk_post_div = VAR_17->ct.xclk_post_div_real;
VAR_16.vclk_fb_div = VAR_17->ct.vclk_fb_div;
VAR_16.vclk_post_div = VAR_17->ct.vclk_post_div_real;
VAR_16.dsp_xclks_per_row = VAR_18 & 0x3fff;
VAR_16.dsp_loop_latency = (VAR_18 >> 16) & 0xf;
VAR_16.dsp_precision = (VAR_18 >> 20) & 7;
VAR_16.dsp_off = VAR_19 & 0x7ff;
VAR_16.dsp_on = (VAR_19 >> 16) & 0x7ff;
if (copy_to_user((struct atyclk __user *) VAR_2, &VAR_16,
sizeof(VAR_16)))
return -VAR_8;
} else
return -VAR_20;
break;
case VAR_21:
if (M64_HAS(VAR_15)) {
struct atyclk VAR_16;
union aty_pll *VAR_17 = &VAR_3->pll;
if (copy_from_user(&VAR_16, (struct atyclk __user *) VAR_2,
sizeof(VAR_16)))
return -VAR_8;
VAR_3->ref_clk_per = VAR_16.ref_clk_per;
VAR_17->ct.pll_ref_div = VAR_16.pll_ref_div;
VAR_17->ct.mclk_fb_div = VAR_16.mclk_fb_div;
VAR_17->ct.mclk_post_div_real = VAR_16.mclk_post_div;
VAR_17->ct.mclk_fb_mult = VAR_16.mclk_fb_mult;
VAR_17->ct.xclk_post_div_real = VAR_16.xclk_post_div;
VAR_17->ct.vclk_fb_div = VAR_16.vclk_fb_div;
VAR_17->ct.vclk_post_div_real = VAR_16.vclk_post_div;
VAR_17->ct.dsp_config = (VAR_16.dsp_xclks_per_row & 0x3fff) |
((VAR_16.dsp_loop_latency & 0xf) << 16) |
((VAR_16.dsp_precision & 7) << 20);
VAR_17->ct.dsp_on_off = (VAR_16.dsp_off & 0x7ff) |
((VAR_16.dsp_on & 0x7ff) << 16);
aty_set_pll_ct(VAR_0, VAR_17);
} else
return -VAR_20;
break;
case VAR_22:
if (get_user(VAR_3->features, (u32 __user *) VAR_2))
return -VAR_8;
break;
case VAR_23:
if (put_user(VAR_3->features, (u32 __user *) VAR_2))
return -VAR_8;
break;
#endif 
default:
return -VAR_20;
}
return 0;
}",torvalds/linux/4523622d274e0bf0b2b054445d570a3215c3c250/atyfb_base.c/vul/before/0.json,"static int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)
{
	struct atyfb_par *par = (struct atyfb_par *) info->par;
#ifdef __sparc__
	struct fbtype fbtyp;
#endif

	switch (cmd) {
#ifdef __sparc__
	case FBIOGTYPE:
		fbtyp.fb_type = FBTYPE_PCI_GENERIC;
		fbtyp.fb_width = par->crtc.vxres;
		fbtyp.fb_height = par->crtc.vyres;
		fbtyp.fb_depth = info->var.bits_per_pixel;
		fbtyp.fb_cmsize = info->cmap.len;
		fbtyp.fb_size = info->fix.smem_len;
		if (copy_to_user((struct fbtype __user *) arg, &fbtyp,
				 sizeof(fbtyp)))
			return -EFAULT;
		break;
#endif /* __sparc__ */

	case FBIO_WAITFORVSYNC:
		{
			u32 crtc;

			if (get_user(crtc, (__u32 __user *) arg))
				return -EFAULT;

			return aty_waitforvblank(par, crtc);
		}

#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)
	case ATYIO_CLKR:
		if (M64_HAS(INTEGRATED)) {
			struct atyclk clk;
			union aty_pll *pll = &par->pll;
			
			memset( &clk, 0, sizeof(struct atyclk) );
			
			u32 dsp_config = pll->ct.dsp_config;
			u32 dsp_on_off = pll->ct.dsp_on_off;
			clk.ref_clk_per = par->ref_clk_per;
			clk.pll_ref_div = pll->ct.pll_ref_div;
			clk.mclk_fb_div = pll->ct.mclk_fb_div;
			clk.mclk_post_div = pll->ct.mclk_post_div_real;
			clk.mclk_fb_mult = pll->ct.mclk_fb_mult;
			clk.xclk_post_div = pll->ct.xclk_post_div_real;
			clk.vclk_fb_div = pll->ct.vclk_fb_div;
			clk.vclk_post_div = pll->ct.vclk_post_div_real;
			clk.dsp_xclks_per_row = dsp_config & 0x3fff;
			clk.dsp_loop_latency = (dsp_config >> 16) & 0xf;
			clk.dsp_precision = (dsp_config >> 20) & 7;
			clk.dsp_off = dsp_on_off & 0x7ff;
			clk.dsp_on = (dsp_on_off >> 16) & 0x7ff;
			if (copy_to_user((struct atyclk __user *) arg, &clk,
					 sizeof(clk)))
				return -EFAULT;
		} else
			return -EINVAL;
		break;
	case ATYIO_CLKW:
		if (M64_HAS(INTEGRATED)) {
			struct atyclk clk;
			union aty_pll *pll = &par->pll;
			if (copy_from_user(&clk, (struct atyclk __user *) arg,
					   sizeof(clk)))
				return -EFAULT;
			par->ref_clk_per = clk.ref_clk_per;
			pll->ct.pll_ref_div = clk.pll_ref_div;
			pll->ct.mclk_fb_div = clk.mclk_fb_div;
			pll->ct.mclk_post_div_real = clk.mclk_post_div;
			pll->ct.mclk_fb_mult = clk.mclk_fb_mult;
			pll->ct.xclk_post_div_real = clk.xclk_post_div;
			pll->ct.vclk_fb_div = clk.vclk_fb_div;
			pll->ct.vclk_post_div_real = clk.vclk_post_div;
			pll->ct.dsp_config = (clk.dsp_xclks_per_row & 0x3fff) |
				((clk.dsp_loop_latency & 0xf) << 16) |
				((clk.dsp_precision & 7) << 20);
			pll->ct.dsp_on_off = (clk.dsp_off & 0x7ff) |
				((clk.dsp_on & 0x7ff) << 16);
			/*aty_calc_pll_ct(info, &pll->ct);*/
			aty_set_pll_ct(info, pll);
		} else
			return -EINVAL;
		break;
	case ATYIO_FEATR:
		if (get_user(par->features, (u32 __user *) arg))
			return -EFAULT;
		break;
	case ATYIO_FEATW:
		if (put_user(par->features, (u32 __user *) arg))
			return -EFAULT;
		break;
#endif /* DEBUG && CONFIG_FB_ATY_CT */
	default:
		return -EINVAL;
	}
	return 0;
}","static int atyfb_ioctl(struct fb_info *VAR_0, u_int VAR_1, u_long VAR_2)
{
	struct atyfb_par *VAR_3 = (struct atyfb_par *) VAR_0->par;
#ifdef VAR_4
	struct fbtype VAR_5;
#endif

	switch (VAR_1) {
#ifdef VAR_4
	case VAR_6:
		VAR_5.fb_type = VAR_7;
		VAR_5.fb_width = VAR_3->crtc.vxres;
		VAR_5.fb_height = VAR_3->crtc.vyres;
		VAR_5.fb_depth = VAR_0->var.bits_per_pixel;
		VAR_5.fb_cmsize = VAR_0->cmap.len;
		VAR_5.fb_size = VAR_0->fix.smem_len;
		if (copy_to_user((struct fbtype __user *) VAR_2, &VAR_5,
				 sizeof(VAR_5)))
			return -VAR_8;
		break;
#endif /* COMMENT_0 */

	case VAR_9:
		{
			u32 VAR_10;

			if (get_user(VAR_10, (VAR_11 __user *) VAR_2))
				return -VAR_8;

			return aty_waitforvblank(VAR_3, VAR_10);
		}

#if defined(VAR_12) && defined(VAR_13)
	case VAR_14:
		if (M64_HAS(VAR_15)) {
			struct atyclk VAR_16;
			union aty_pll *VAR_17 = &VAR_3->pll;
			
			memset( &VAR_16, 0, sizeof(struct atyclk) );
			
			u32 VAR_18 = VAR_17->ct.dsp_config;
			u32 VAR_19 = VAR_17->ct.dsp_on_off;
			VAR_16.ref_clk_per = VAR_3->ref_clk_per;
			VAR_16.pll_ref_div = VAR_17->ct.pll_ref_div;
			VAR_16.mclk_fb_div = VAR_17->ct.mclk_fb_div;
			VAR_16.mclk_post_div = VAR_17->ct.mclk_post_div_real;
			VAR_16.mclk_fb_mult = VAR_17->ct.mclk_fb_mult;
			VAR_16.xclk_post_div = VAR_17->ct.xclk_post_div_real;
			VAR_16.vclk_fb_div = VAR_17->ct.vclk_fb_div;
			VAR_16.vclk_post_div = VAR_17->ct.vclk_post_div_real;
			VAR_16.dsp_xclks_per_row = VAR_18 & 0x3fff;
			VAR_16.dsp_loop_latency = (VAR_18 >> 16) & 0xf;
			VAR_16.dsp_precision = (VAR_18 >> 20) & 7;
			VAR_16.dsp_off = VAR_19 & 0x7ff;
			VAR_16.dsp_on = (VAR_19 >> 16) & 0x7ff;
			if (copy_to_user((struct atyclk __user *) VAR_2, &VAR_16,
					 sizeof(VAR_16)))
				return -VAR_8;
		} else
			return -VAR_20;
		break;
	case VAR_21:
		if (M64_HAS(VAR_15)) {
			struct atyclk VAR_16;
			union aty_pll *VAR_17 = &VAR_3->pll;
			if (copy_from_user(&VAR_16, (struct atyclk __user *) VAR_2,
					   sizeof(VAR_16)))
				return -VAR_8;
			VAR_3->ref_clk_per = VAR_16.ref_clk_per;
			VAR_17->ct.pll_ref_div = VAR_16.pll_ref_div;
			VAR_17->ct.mclk_fb_div = VAR_16.mclk_fb_div;
			VAR_17->ct.mclk_post_div_real = VAR_16.mclk_post_div;
			VAR_17->ct.mclk_fb_mult = VAR_16.mclk_fb_mult;
			VAR_17->ct.xclk_post_div_real = VAR_16.xclk_post_div;
			VAR_17->ct.vclk_fb_div = VAR_16.vclk_fb_div;
			VAR_17->ct.vclk_post_div_real = VAR_16.vclk_post_div;
			VAR_17->ct.dsp_config = (VAR_16.dsp_xclks_per_row & 0x3fff) |
				((VAR_16.dsp_loop_latency & 0xf) << 16) |
				((VAR_16.dsp_precision & 7) << 20);
			VAR_17->ct.dsp_on_off = (VAR_16.dsp_off & 0x7ff) |
				((VAR_16.dsp_on & 0x7ff) << 16);
			/* COMMENT_1 */
			aty_set_pll_ct(VAR_0, VAR_17);
		} else
			return -VAR_20;
		break;
	case VAR_22:
		if (get_user(VAR_3->features, (u32 __user *) VAR_2))
			return -VAR_8;
		break;
	case VAR_23:
		if (put_user(VAR_3->features, (u32 __user *) VAR_2))
			return -VAR_8;
		break;
#endif /* COMMENT_2 */
	default:
		return -VAR_20;
	}
	return 0;
}",torvalds/linux/4523622d274e0bf0b2b054445d570a3215c3c250/atyfb_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,9 @@
 		if (M64_HAS(INTEGRATED)) {
 			struct atyclk clk;
 			union aty_pll *pll = &par->pll;
+			
+			memset( &clk, 0, sizeof(struct atyclk) );
+			
 			u32 dsp_config = pll->ct.dsp_config;
 			u32 dsp_on_off = pll->ct.dsp_on_off;
 			clk.ref_clk_per = par->ref_clk_per;","{'deleted_lines': [], 'added_lines': ['\t\t\t', '\t\t\tmemset( &clk, 0, sizeof(struct atyclk) );', '\t\t\t']}",True,"The atyfb_ioctl function in drivers/video/fbdev/aty/atyfb_base.c in the Linux kernel through 4.12.10 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory by reading locations associated with padding bytes.",5.5,MEDIUM,1,valid,2017-07-30T04:05:46Z,2
CVE-2017-12418,['CWE-772'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/643,46382526a3f09cebf9f2af680fc55b2a668fcbef,https://github.com/ImageMagick/ImageMagick/commit/46382526a3f09cebf9f2af680fc55b2a668fcbef,coders/meta.c,format8BIM,"static int format8BIM(Image *ifile, Image *ofile)
{
char
temp[MagickPathExtent];
unsigned int
foundOSType;
int
ID,
resCount,
i,
c;
ssize_t
count;
unsigned char
*PString,
*str;
resCount=0;
foundOSType=0; 
(void) foundOSType;
c=ReadBlobByte(ifile);
while (c != EOF)
{
if (c == '8')
{
unsigned char
buffer[5];
buffer[0]=(unsigned char) c;
for (i=1; i<4; i++)
{
c=ReadBlobByte(ifile);
if (c == EOF)
return(-1);
buffer[i] = (unsigned char) c;
}
buffer[4]=0;
if (strcmp((const char *)buffer, ""8BIM"") == 0)
foundOSType=1;
else
continue;
}
else
{
c=ReadBlobByte(ifile);
continue;
}
ID=ReadBlobMSBSignedShort(ifile);
if (ID < 0)
return(-1);
{
unsigned char
plen;
c=ReadBlobByte(ifile);
if (c == EOF)
return(-1);
plen = (unsigned char) c;
PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+
MagickPathExtent),sizeof(*PString));
if (PString == (unsigned char *) NULL)
{
printf(""MemoryAllocationFailed"");
return 0;
}
for (i=0; i<plen; i++)
{
c=ReadBlobByte(ifile);
if (c == EOF) return -1;
PString[i] = (unsigned char) c;
}
PString[ plen ] = 0;
if ((plen & 0x01) == 0)
{
c=ReadBlobByte(ifile);
if (c == EOF)
return(-1);
}
}
count=ReadBlobMSBSignedLong(ifile);
if (count < 0) return -1;
str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));
if (str == (unsigned char *) NULL)
{
printf(""MemoryAllocationFailed"");
return 0;
}
for (i=0; i < (ssize_t) count; i++)
{
c=ReadBlobByte(ifile);
if (c == EOF)
return(-1);
str[i]=(unsigned char) c;
}
if (ID != THUMBNAIL_ID)
{
if (strlen((const char *)PString) > 0)
(void) FormatLocaleString(temp,MagickPathExtent,""8BIM#%d#%s="",ID,
PString);
else
(void) FormatLocaleString(temp,MagickPathExtent,""8BIM#%d="",ID);
(void) WriteBlobString(ofile,temp);
if (ID == IPTC_ID)
{
formatString(ofile, ""IPTC"", 4);
formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);
}
else
formatString(ofile, (char *)str, (ssize_t) count);
}
str=(unsigned char *) RelinquishMagickMemory(str);
PString=(unsigned char *) RelinquishMagickMemory(PString);
resCount++;
c=ReadBlobByte(ifile);
}
return resCount;
}","static int format8BIM(Image *VAR_0, Image *VAR_1)
{
char
VAR_2[VAR_3];
unsigned int
VAR_4;
int
VAR_5,
VAR_6,
VAR_7,
VAR_8;
ssize_t
VAR_9;
unsigned char
*VAR_10,
*VAR_11;
VAR_6=0;
VAR_4=0; 
(void) VAR_4;
VAR_8=ReadBlobByte(VAR_0);
while (VAR_8 != VAR_12)
{
if (VAR_8 == '8')
{
unsigned char
VAR_13[5];
VAR_13[0]=(unsigned char) VAR_8;
for (VAR_7=1; VAR_7<4; VAR_7++)
{
VAR_8=ReadBlobByte(VAR_0);
if (VAR_8 == VAR_12)
return(-1);
VAR_13[VAR_7] = (unsigned char) VAR_8;
}
VAR_13[4]=0;
if (strcmp((const char *)VAR_13, ""8BIM"") == 0)
VAR_4=1;
else
continue;
}
else
{
VAR_8=ReadBlobByte(VAR_0);
continue;
}
VAR_5=ReadBlobMSBSignedShort(VAR_0);
if (VAR_5 < 0)
return(-1);
{
unsigned char
VAR_14;
VAR_8=ReadBlobByte(VAR_0);
if (VAR_8 == VAR_12)
return(-1);
VAR_14 = (unsigned char) VAR_8;
VAR_10=(unsigned char *) AcquireQuantumMemory((size_t) (VAR_14+
VAR_3),sizeof(*VAR_10));
if (VAR_10 == (unsigned char *) NULL)
{
printf(""MemoryAllocationFailed"");
return 0;
}
for (VAR_7=0; VAR_7<VAR_14; VAR_7++)
{
VAR_8=ReadBlobByte(VAR_0);
if (VAR_8 == VAR_12) return -1;
VAR_10[VAR_7] = (unsigned char) VAR_8;
}
VAR_10[ VAR_14 ] = 0;
if ((VAR_14 & 0x01) == 0)
{
VAR_8=ReadBlobByte(VAR_0);
if (VAR_8 == VAR_12)
return(-1);
}
}
VAR_9=ReadBlobMSBSignedLong(VAR_0);
if (VAR_9 < 0) return -1;
VAR_11=(unsigned char *) AcquireQuantumMemory((size_t) VAR_9,sizeof(*VAR_11));
if (VAR_11 == (unsigned char *) NULL)
{
printf(""MemoryAllocationFailed"");
return 0;
}
for (VAR_7=0; VAR_7 < (ssize_t) VAR_9; VAR_7++)
{
VAR_8=ReadBlobByte(VAR_0);
if (VAR_8 == VAR_12)
return(-1);
VAR_11[VAR_7]=(unsigned char) VAR_8;
}
if (VAR_5 != VAR_15)
{
if (strlen((const char *)VAR_10) > 0)
(void) FormatLocaleString(VAR_2,VAR_3,""8BIM#%d#%s="",VAR_5,
VAR_10);
else
(void) FormatLocaleString(VAR_2,VAR_3,""8BIM#%d="",VAR_5);
(void) WriteBlobString(VAR_1,VAR_2);
if (VAR_5 == VAR_16)
{
formatString(VAR_1, ""IPTC"", 4);
formatIPTCfromBuffer(VAR_1, (char *)VAR_11, (ssize_t) VAR_9);
}
else
formatString(VAR_1, (char *)VAR_11, (ssize_t) VAR_9);
}
VAR_11=(unsigned char *) RelinquishMagickMemory(VAR_11);
VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
VAR_6++;
VAR_8=ReadBlobByte(VAR_0);
}
return VAR_6;
}",ImageMagick/46382526a3f09cebf9f2af680fc55b2a668fcbef/meta.c/vul/before/0.json,"static int format8BIM(Image *ifile, Image *ofile)
{
  char
    temp[MagickPathExtent];

  unsigned int
    foundOSType;

  int
    ID,
    resCount,
    i,
    c;

  ssize_t
    count;

  unsigned char
    *PString,
    *str;

  resCount=0;
  foundOSType=0; /* found the OSType */
  (void) foundOSType;
  c=ReadBlobByte(ifile);
  while (c != EOF)
  {
    if (c == '8')
      {
        unsigned char
          buffer[5];

        buffer[0]=(unsigned char) c;
        for (i=1; i<4; i++)
        {
          c=ReadBlobByte(ifile);
          if (c == EOF)
            return(-1);
          buffer[i] = (unsigned char) c;
        }
        buffer[4]=0;
        if (strcmp((const char *)buffer, ""8BIM"") == 0)
          foundOSType=1;
        else
          continue;
      }
    else
      {
        c=ReadBlobByte(ifile);
        continue;
      }
    /*
      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.
    */
    ID=ReadBlobMSBSignedShort(ifile);
    if (ID < 0)
      return(-1);
    {
      unsigned char
        plen;

      c=ReadBlobByte(ifile);
      if (c == EOF)
        return(-1);
      plen = (unsigned char) c;
      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+
        MagickPathExtent),sizeof(*PString));
      if (PString == (unsigned char *) NULL)
        {
          printf(""MemoryAllocationFailed"");
          return 0;
        }
      for (i=0; i<plen; i++)
      {
        c=ReadBlobByte(ifile);
        if (c == EOF)
          {
            PString=(unsigned char *) RelinquishMagickMemory(PString);
            return -1;
          }
        PString[i] = (unsigned char) c;
      }
      PString[ plen ] = 0;
      if ((plen & 0x01) == 0)
      {
        c=ReadBlobByte(ifile);
        if (c == EOF)
          {
            PString=(unsigned char *) RelinquishMagickMemory(PString);
            return -1;
          }
      }
    }
    count=ReadBlobMSBSignedLong(ifile);
    if (count < 0)
      {
        PString=(unsigned char *) RelinquishMagickMemory(PString);
        return -1;
      }
    /* make a buffer to hold the datand snag it from the input stream */
    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));
    if (str == (unsigned char *) NULL)
      {
        PString=(unsigned char *) RelinquishMagickMemory(PString);
        printf(""MemoryAllocationFailed"");
        return 0;
      }
    for (i=0; i < (ssize_t) count; i++)
    {
      c=ReadBlobByte(ifile);
      if (c == EOF)
        {
          PString=(unsigned char *) RelinquishMagickMemory(PString);
          return -1;
        }
      str[i]=(unsigned char) c;
    }

    /* we currently skip thumbnails, since it does not make
     * any sense preserving them in a real world application
     */
    if (ID != THUMBNAIL_ID)
      {
        /* now finish up by formatting this binary data into
         * ASCII equivalent
         */
        if (strlen((const char *)PString) > 0)
          (void) FormatLocaleString(temp,MagickPathExtent,""8BIM#%d#%s="",ID,
            PString);
        else
          (void) FormatLocaleString(temp,MagickPathExtent,""8BIM#%d="",ID);
        (void) WriteBlobString(ofile,temp);
        if (ID == IPTC_ID)
          {
            formatString(ofile, ""IPTC"", 4);
            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);
          }
        else
          formatString(ofile, (char *)str, (ssize_t) count);
      }
    str=(unsigned char *) RelinquishMagickMemory(str);
    PString=(unsigned char *) RelinquishMagickMemory(PString);
    resCount++;
    c=ReadBlobByte(ifile);
  }
  return resCount;
}","static int format8BIM(Image *VAR_0, Image *VAR_1)
{
  char
    VAR_2[VAR_3];

  unsigned int
    VAR_4;

  int
    VAR_5,
    VAR_6,
    VAR_7,
    VAR_8;

  ssize_t
    VAR_9;

  unsigned char
    *VAR_10,
    *VAR_11;

  VAR_6=0;
  VAR_4=0; /* COMMENT_0 */
  (void) VAR_4;
  VAR_8=ReadBlobByte(VAR_0);
  while (VAR_8 != VAR_12)
  {
    if (VAR_8 == '8')
      {
        unsigned char
          VAR_13[5];

        VAR_13[0]=(unsigned char) VAR_8;
        for (VAR_7=1; VAR_7<4; VAR_7++)
        {
          VAR_8=ReadBlobByte(VAR_0);
          if (VAR_8 == VAR_12)
            return(-1);
          VAR_13[VAR_7] = (unsigned char) VAR_8;
        }
        VAR_13[4]=0;
        if (strcmp((const char *)VAR_13, ""8BIM"") == 0)
          VAR_4=1;
        else
          continue;
      }
    else
      {
        VAR_8=ReadBlobByte(VAR_0);
        continue;
      }
    /* COMMENT_1 */
                                                                               
      
    VAR_5=ReadBlobMSBSignedShort(VAR_0);
    if (VAR_5 < 0)
      return(-1);
    {
      unsigned char
        VAR_14;

      VAR_8=ReadBlobByte(VAR_0);
      if (VAR_8 == VAR_12)
        return(-1);
      VAR_14 = (unsigned char) VAR_8;
      VAR_10=(unsigned char *) AcquireQuantumMemory((size_t) (VAR_14+
        VAR_3),sizeof(*VAR_10));
      if (VAR_10 == (unsigned char *) NULL)
        {
          printf(""MemoryAllocationFailed"");
          return 0;
        }
      for (VAR_7=0; VAR_7<VAR_14; VAR_7++)
      {
        VAR_8=ReadBlobByte(VAR_0);
        if (VAR_8 == VAR_12)
          {
            VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
            return -1;
          }
        VAR_10[VAR_7] = (unsigned char) VAR_8;
      }
      VAR_10[ VAR_14 ] = 0;
      if ((VAR_14 & 0x01) == 0)
      {
        VAR_8=ReadBlobByte(VAR_0);
        if (VAR_8 == VAR_12)
          {
            VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
            return -1;
          }
      }
    }
    VAR_9=ReadBlobMSBSignedLong(VAR_0);
    if (VAR_9 < 0)
      {
        VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
        return -1;
      }
    /* COMMENT_4 */
    VAR_11=(unsigned char *) AcquireQuantumMemory((size_t) VAR_9,sizeof(*VAR_11));
    if (VAR_11 == (unsigned char *) NULL)
      {
        VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
        printf(""MemoryAllocationFailed"");
        return 0;
      }
    for (VAR_7=0; VAR_7 < (ssize_t) VAR_9; VAR_7++)
    {
      VAR_8=ReadBlobByte(VAR_0);
      if (VAR_8 == VAR_12)
        {
          VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
          return -1;
        }
      VAR_11[VAR_7]=(unsigned char) VAR_8;
    }

    /* COMMENT_5 */
                                                            
       
    if (VAR_5 != VAR_15)
      {
        /* COMMENT_8 */
                           
           
        if (strlen((const char *)VAR_10) > 0)
          (void) FormatLocaleString(VAR_2,VAR_3,""8BIM#%d#%s="",VAR_5,
            VAR_10);
        else
          (void) FormatLocaleString(VAR_2,VAR_3,""8BIM#%d="",VAR_5);
        (void) WriteBlobString(VAR_1,VAR_2);
        if (VAR_5 == VAR_16)
          {
            formatString(VAR_1, ""IPTC"", 4);
            formatIPTCfromBuffer(VAR_1, (char *)VAR_11, (ssize_t) VAR_9);
          }
        else
          formatString(VAR_1, (char *)VAR_11, (ssize_t) VAR_9);
      }
    VAR_11=(unsigned char *) RelinquishMagickMemory(VAR_11);
    VAR_10=(unsigned char *) RelinquishMagickMemory(VAR_10);
    VAR_6++;
    VAR_8=ReadBlobByte(VAR_0);
  }
  return VAR_6;
}",ImageMagick/46382526a3f09cebf9f2af680fc55b2a668fcbef/meta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,7 +73,11 @@
       for (i=0; i<plen; i++)
       {
         c=ReadBlobByte(ifile);
-        if (c == EOF) return -1;
+        if (c == EOF)
+          {
+            PString=(unsigned char *) RelinquishMagickMemory(PString);
+            return -1;
+          }
         PString[i] = (unsigned char) c;
       }
       PString[ plen ] = 0;
@@ -81,15 +85,23 @@
       {
         c=ReadBlobByte(ifile);
         if (c == EOF)
-          return(-1);
+          {
+            PString=(unsigned char *) RelinquishMagickMemory(PString);
+            return -1;
+          }
       }
     }
     count=ReadBlobMSBSignedLong(ifile);
-    if (count < 0) return -1;
+    if (count < 0)
+      {
+        PString=(unsigned char *) RelinquishMagickMemory(PString);
+        return -1;
+      }
     /* make a buffer to hold the datand snag it from the input stream */
     str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));
     if (str == (unsigned char *) NULL)
       {
+        PString=(unsigned char *) RelinquishMagickMemory(PString);
         printf(""MemoryAllocationFailed"");
         return 0;
       }
@@ -97,7 +109,10 @@
     {
       c=ReadBlobByte(ifile);
       if (c == EOF)
-        return(-1);
+        {
+          PString=(unsigned char *) RelinquishMagickMemory(PString);
+          return -1;
+        }
       str[i]=(unsigned char) c;
     }
 ","{'deleted_lines': ['        if (c == EOF) return -1;', '          return(-1);', '    if (count < 0) return -1;', '        return(-1);'], 'added_lines': ['        if (c == EOF)', '          {', '            PString=(unsigned char *) RelinquishMagickMemory(PString);', '            return -1;', '          }', '          {', '            PString=(unsigned char *) RelinquishMagickMemory(PString);', '            return -1;', '          }', '    if (count < 0)', '      {', '        PString=(unsigned char *) RelinquishMagickMemory(PString);', '        return -1;', '      }', '        PString=(unsigned char *) RelinquishMagickMemory(PString);', '        {', '          PString=(unsigned char *) RelinquishMagickMemory(PString);', '          return -1;', '        }']}",True,"ImageMagick 7.0.6-5 has memory leaks in the parse8BIMW and format8BIM functions in coders/meta.c, related to the WriteImage function in MagickCore/constitute.c.",7.5,HIGH,2,valid,2017-08-02T13:51:09Z,2
CVE-2017-7555,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,hercules-team/augeas,"* src/pathx.c (parse_name): correctly handle trailing whitespace in names

When a name ended in whitespace, we incorrectly assumed it was always ok to
trim that whitespace. That is not true if that whitespace is escaped,
i.e. if the path expression is something like '/x\ '. In that case, the
name really needs to be literally 'x ', i.e., we can not trim that
whitespace.

The incorrect behavior led to turning '/x\ ' first into 'x\' and then,
because we assume that '\' is always followed by a character inside the
string, when we removed the escaping '\', we would read beyond the end of
the intermediate string result; if we were lucky, that would lead to a
crash, otherwise we'd continue with junk.

We now make sure that escaped whitespace at the end of a string does not
get stripped, avoiding all these headaches.

Fixes RHBZ https://bugzilla.redhat.com/show_bug.cgi?id=1475621",4cca923b732990bec0c699b2e69911c2221b2498,https://github.com/hercules-team/augeas/commit/4cca923b732990bec0c699b2e69911c2221b2498,src/pathx.c,parse_name,"static char *parse_name(struct state *state) {
const char *s = state->pos;
char *result;
while (*state->pos != '\0' && strchr(name_follow, *state->pos) == NULL) {
if (STREQLEN(state->pos, "" or "", strlen("" or "")) ||
STREQLEN(state->pos, "" and "", strlen("" and "")))
break;
if (*state->pos == '\\') {
state->pos += 1;
if (*state->pos == '\0') {
STATE_ERROR(state, PATHX_ENAME);
return NULL;
}
}
state->pos += 1;
}
if (state->pos > s) {
state->pos -= 1;
while (isspace(*state->pos) && state->pos >= s)
state->pos -= 1;
state->pos += 1;
}
if (state->pos == s) {
STATE_ERROR(state, PATHX_ENAME);
return NULL;
}
result = strndup(s, state->pos - s);
if (result == NULL) {
STATE_ENOMEM;
return NULL;
}
char *p = result;
for (char *t = result; *t != '\0'; t++, p++) {
if (*t == '\\')
t += 1;
*p = *t;
}
*p = '\0';
return result;
}","static char *parse_name(struct state *state) {
const char *VAR_0 = state->pos;
char *VAR_1;
while (*state->pos != '\0' && strchr(VAR_2, *state->pos) == NULL) {
if (STREQLEN(state->pos, "" or "", strlen("" or "")) ||
STREQLEN(state->pos, "" and "", strlen("" and "")))
break;
if (*state->pos == '\\') {
state->pos += 1;
if (*state->pos == '\0') {
STATE_ERROR(state, VAR_3);
return NULL;
}
}
state->pos += 1;
}
if (state->pos > VAR_0) {
state->pos -= 1;
while (isspace(*state->pos) && state->pos >= VAR_0)
state->pos -= 1;
state->pos += 1;
}
if (state->pos == VAR_0) {
STATE_ERROR(state, VAR_3);
return NULL;
}
VAR_1 = strndup(VAR_0, state->pos - VAR_0);
if (VAR_1 == NULL) {
VAR_4;
return NULL;
}
char *VAR_5 = VAR_1;
for (char *VAR_6 = VAR_1; *VAR_6 != '\0'; VAR_6++, VAR_5++) {
if (*VAR_6 == '\\')
VAR_6 += 1;
*VAR_5 = *VAR_6;
}
*VAR_5 = '\0';
return VAR_1;
}",hercules-team/augeas/4cca923b732990bec0c699b2e69911c2221b2498/pathx.c/vul/before/0.json,"static char *parse_name(struct state *state) {
    const char *s = state->pos;
    char *result;

    /* Advance state->pos until it points to the first character that is
     * not part of a name. */
    while (*state->pos != '\0' && strchr(name_follow, *state->pos) == NULL) {
        /* Since we allow spaces in names, we need to avoid gobbling up
         * stuff that is in follow(Name), e.g. 'or' so that things like
         * [name1 or name2] still work. In other words, we'll parse 'x frob
         * y' as one name, but for 'x or y', we consider 'x' a name in its
         * own right. */
        if (STREQLEN(state->pos, "" or "", strlen("" or "")) ||
            STREQLEN(state->pos, "" and "", strlen("" and "")))
            break;

        if (*state->pos == '\\') {
            state->pos += 1;
            if (*state->pos == '\0') {
                STATE_ERROR(state, PATHX_ENAME);
                return NULL;
            }
        }
        state->pos += 1;
    }

    /* Strip trailing white space. Make sure we respect escaped whitespace
     * and don't strip it as in ""x\\ "" */
    if (state->pos > s) {
        state->pos -= 1;
        while (isspace(*state->pos) && state->pos > s
               && !backslash_escaped(state->pos, s))
            state->pos -= 1;
        state->pos += 1;
    }

    if (state->pos == s) {
        STATE_ERROR(state, PATHX_ENAME);
        return NULL;
    }

    result = strndup(s, state->pos - s);
    if (result == NULL) {
        STATE_ENOMEM;
        return NULL;
    }

    char *p = result;
    for (char *t = result; *t != '\0'; t++, p++) {
        if (*t == '\\')
            t += 1;
        *p = *t;
    }
    *p = '\0';

    return result;
}","static char *parse_name(struct state *state) {
    const char *VAR_0 = state->pos;
    char *VAR_1;

    /* COMMENT_0 */
                             
    while (*state->pos != '\0' && strchr(VAR_2, *state->pos) == NULL) {
        /* COMMENT_2 */
                                                                       
                                                                           
                                                                          
                        
        if (STREQLEN(state->pos, "" or "", strlen("" or "")) ||
            STREQLEN(state->pos, "" and "", strlen("" and "")))
            break;

        if (*state->pos == '\\') {
            state->pos += 1;
            if (*state->pos == '\0') {
                STATE_ERROR(state, VAR_3);
                return NULL;
            }
        }
        state->pos += 1;
    }

    /* COMMENT_7 */
                                         
    if (state->pos > VAR_0) {
        state->pos -= 1;
        while (isspace(*state->pos) && state->pos > VAR_0
               && !backslash_escaped(state->pos, VAR_0))
            state->pos -= 1;
        state->pos += 1;
    }

    if (state->pos == VAR_0) {
        STATE_ERROR(state, VAR_3);
        return NULL;
    }

    VAR_1 = strndup(VAR_0, state->pos - VAR_0);
    if (VAR_1 == NULL) {
        VAR_4;
        return NULL;
    }

    char *VAR_5 = VAR_1;
    for (char *VAR_6 = VAR_1; *VAR_6 != '\0'; VAR_6++, VAR_5++) {
        if (*VAR_6 == '\\')
            VAR_6 += 1;
        *VAR_5 = *VAR_6;
    }
    *VAR_5 = '\0';

    return VAR_1;
}",hercules-team/augeas/4cca923b732990bec0c699b2e69911c2221b2498/pathx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,11 +2,14 @@
     const char *s = state->pos;
     char *result;
 
+    /* Advance state->pos until it points to the first character that is
+     * not part of a name. */
     while (*state->pos != '\0' && strchr(name_follow, *state->pos) == NULL) {
-        /* This is a hack: since we allow spaces in names, we need to avoid
-         * gobbling up stuff that is in follow(Name), e.g. 'or' so that
-         * things like [name1 or name2] still work.
-         */
+        /* Since we allow spaces in names, we need to avoid gobbling up
+         * stuff that is in follow(Name), e.g. 'or' so that things like
+         * [name1 or name2] still work. In other words, we'll parse 'x frob
+         * y' as one name, but for 'x or y', we consider 'x' a name in its
+         * own right. */
         if (STREQLEN(state->pos, "" or "", strlen("" or "")) ||
             STREQLEN(state->pos, "" and "", strlen("" and "")))
             break;
@@ -21,10 +24,12 @@
         state->pos += 1;
     }
 
-    /* Strip trailing white space */
+    /* Strip trailing white space. Make sure we respect escaped whitespace
+     * and don't strip it as in ""x\\ "" */
     if (state->pos > s) {
         state->pos -= 1;
-        while (isspace(*state->pos) && state->pos >= s)
+        while (isspace(*state->pos) && state->pos > s
+               && !backslash_escaped(state->pos, s))
             state->pos -= 1;
         state->pos += 1;
     }","{'deleted_lines': ['        /* This is a hack: since we allow spaces in names, we need to avoid', ""         * gobbling up stuff that is in follow(Name), e.g. 'or' so that"", '         * things like [name1 or name2] still work.', '         */', '    /* Strip trailing white space */', '        while (isspace(*state->pos) && state->pos >= s)'], 'added_lines': ['    /* Advance state->pos until it points to the first character that is', '     * not part of a name. */', '        /* Since we allow spaces in names, we need to avoid gobbling up', ""         * stuff that is in follow(Name), e.g. 'or' so that things like"", ""         * [name1 or name2] still work. In other words, we'll parse 'x frob"", ""         * y' as one name, but for 'x or y', we consider 'x' a name in its"", '         * own right. */', '    /* Strip trailing white space. Make sure we respect escaped whitespace', '     * and don\'t strip it as in ""x\\\\ "" */', '        while (isspace(*state->pos) && state->pos > s', '               && !backslash_escaped(state->pos, s))']}",True,"Augeas versions up to and including 1.8.0 are vulnerable to heap-based buffer overflow due to improper handling of escaped strings. Attacker could send crafted strings that would cause the application using augeas to copy past the end of a buffer, leading to a crash or possible code execution.",9.8,CRITICAL,3,valid,2017-08-05T00:13:52Z,2
CVE-2017-12843,['CWE-20'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,cyrusimap/cyrus-imapd,dlist: don't allow overwrite of arbitrary files,5edadcfb83bf27107578830801817f9e6d0ad941,https://github.com/cyrusimap/cyrus-imapd/commit/5edadcfb83bf27107578830801817f9e6d0ad941,imap/dlist.c,dlist_reserve_path,"EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,
const struct message_guid *guid)
{
static char buf[MAX_MAILBOX_PATH];
const char *base;
if (strchr(part, '/')) {
base = part;
}
else {
base = isarchive ? config_archivepartitiondir(part)
: config_partitiondir(part);
}
assert(base != NULL);
snprintf(buf, MAX_MAILBOX_PATH, ""%s/sync./%lu/%s"",
base, (unsigned long)getpid(),
message_guid_encode(guid));
if (cyrus_mkdir(buf, 0755)) {
syslog(LOG_ERR, ""IOERROR: failed to create %s/sync./%lu/ for reserve: %m"",
base, (unsigned long)getpid());
}
return buf;
}","EXPORTED const VAR_0 *dlist_reserve_path(const char *VAR_1, int VAR_2,
const struct message_guid *VAR_3)
{
static char VAR_4[VAR_5];
const char *VAR_6;
if (strchr(VAR_1, '/')) {
VAR_6 = VAR_1;
}
else {
VAR_6 = VAR_2 ? config_archivepartitiondir(VAR_1)
: config_partitiondir(VAR_1);
}
assert(VAR_6 != NULL);
snprintf(VAR_4, VAR_5, ""%s/sync./%lu/%s"",
VAR_6, (unsigned long)getpid(),
message_guid_encode(VAR_3));
if (cyrus_mkdir(VAR_4, 0755)) {
syslog(VAR_7, ""IOERROR: failed to create %s/sync./%lu/ for reserve: %m"",
VAR_6, (unsigned long)getpid());
}
return VAR_4;
}",,"EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,
                                        const struct message_guid *guid)
{
    static char buf[MAX_MAILBOX_PATH];

    /* part must be a configured partition name on this server */
    const char *base = isarchive ? config_archivepartitiondir(part)
                                 : config_partitiondir(part);

    /* we expect to have a base at this point, so let's assert that */
    assert(base != NULL);

    snprintf(buf, MAX_MAILBOX_PATH, ""%s/sync./%lu/%s"",
                  base, (unsigned long)getpid(),
                  message_guid_encode(guid));

    /* gotta make sure we can create files */
    if (cyrus_mkdir(buf, 0755)) {
        /* it's going to fail later, but at least this will help */
        syslog(LOG_ERR, ""IOERROR: failed to create %s/sync./%lu/ for reserve: %m"",
                        base, (unsigned long)getpid());
    }
    return buf;
}","EXPORTED const VAR_0 *dlist_reserve_path(const char *VAR_1, int VAR_2,
                                        const struct message_guid *VAR_3)
{
    static char VAR_4[VAR_5];

    /* COMMENT_0 */
    const char *VAR_6 = VAR_2 ? config_archivepartitiondir(VAR_1)
                                 : config_partitiondir(VAR_1);

    /* COMMENT_1 */
    assert(VAR_6 != NULL);

    snprintf(VAR_4, VAR_5, ""%s/sync./%lu/%s"",
                  VAR_6, (unsigned long)getpid(),
                  message_guid_encode(VAR_3));

    /* COMMENT_2 */
    if (cyrus_mkdir(VAR_4, 0755)) {
        /* COMMENT_3 */
        syslog(VAR_7, ""IOERROR: failed to create %s/sync./%lu/ for reserve: %m"",
                        VAR_6, (unsigned long)getpid());
    }
    return VAR_4;
}",,"--- func_before
+++ func_after
@@ -2,16 +2,10 @@
                                         const struct message_guid *guid)
 {
     static char buf[MAX_MAILBOX_PATH];
-    const char *base;
 
-    /* part can be either a configured partition name, or a path */
-    if (strchr(part, '/')) {
-        base = part;
-    }
-    else {
-        base = isarchive ? config_archivepartitiondir(part)
-                         : config_partitiondir(part);
-    }
+    /* part must be a configured partition name on this server */
+    const char *base = isarchive ? config_archivepartitiondir(part)
+                                 : config_partitiondir(part);
 
     /* we expect to have a base at this point, so let's assert that */
     assert(base != NULL);","{'deleted_lines': ['    const char *base;', '    /* part can be either a configured partition name, or a path */', ""    if (strchr(part, '/')) {"", '        base = part;', '    }', '    else {', '        base = isarchive ? config_archivepartitiondir(part)', '                         : config_partitiondir(part);', '    }'], 'added_lines': ['    /* part must be a configured partition name on this server */', '    const char *base = isarchive ? config_archivepartitiondir(part)', '                                 : config_partitiondir(part);']}",True,"Cyrus IMAP before 3.0.3 allows remote authenticated users to write to arbitrary files via a crafted (1) SYNCAPPLY, (2) SYNCGET or (3) SYNCRESTORE command.",6.5,MEDIUM,1,valid,2017-08-11T01:58:24Z,2
CVE-2017-12136,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"gnttab: split maptrack lock to make it fulfill its purpose again

The way the lock is currently being used in get_maptrack_handle(), it
protects only the maptrack limit: The function acts on current's list
only, so races on list accesses are impossible even without the lock.

Otoh list access races are possible between __get_maptrack_handle() and
put_maptrack_handle(), due to the invocation of the former for other
than current from steal_maptrack_handle(). Introduce a per-vCPU lock
for list accesses to become race free again. This lock will be
uncontended except when it becomes necessary to take the steal path,
i.e. in the common case there should be no meaningful performance
impact.

When in get_maptrack_handle adds a stolen entry to a fresh, empty,
freelist, we think that there is probably no concurrency.  However,
this is not a fast path and adding the locking there makes the code
clearly correct.

Also, while we are here: the stolen maptrack_entry's tail pointer was
not properly set.  Set it.

This is CVE-2017-12136 / XSA-228.

Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>",02cbeeb6207508b0f04a2c6181445c8eb3f1e117,https://github.com/xen-project/xen/commit/02cbeeb6207508b0f04a2c6181445c8eb3f1e117,xen/common/grant_table.c,__get_maptrack_handle,"static inline int
__get_maptrack_handle(
struct grant_table *t,
struct vcpu *v)
{
unsigned int head, next, prev_head;
do {
head = read_atomic(&v->maptrack_head);
if ( unlikely(head == MAPTRACK_TAIL) )
return -1;
next = read_atomic(&maptrack_entry(t, head).ref);
if ( unlikely(next == MAPTRACK_TAIL) )
return -1;
prev_head = head;
head = cmpxchg(&v->maptrack_head, prev_head, next);
} while ( head != prev_head );
return head;
}","static inline int
__get_maptrack_handle(
struct grant_table *VAR_0,
struct vcpu *VAR_1)
{
unsigned int VAR_2, VAR_3, VAR_4;
do {
VAR_2 = read_atomic(&VAR_1->maptrack_head);
if ( unlikely(VAR_2 == VAR_5) )
return -1;
VAR_3 = read_atomic(&maptrack_entry(VAR_0, VAR_2).ref);
if ( unlikely(VAR_3 == VAR_5) )
return -1;
VAR_4 = VAR_2;
VAR_2 = cmpxchg(&VAR_1->maptrack_head, VAR_4, VAR_3);
} while ( VAR_2 != VAR_4 );
return VAR_2;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/before/0.json,"static inline int
__get_maptrack_handle(
    struct grant_table *t,
    struct vcpu *v)
{
    unsigned int head, next, prev_head;

    spin_lock(&v->maptrack_freelist_lock);

    do {
        /* No maptrack pages allocated for this VCPU yet? */
        head = read_atomic(&v->maptrack_head);
        if ( unlikely(head == MAPTRACK_TAIL) )
        {
            spin_unlock(&v->maptrack_freelist_lock);
            return -1;
        }

        /*
         * Always keep one entry in the free list to make it easier to
         * add free entries to the tail.
         */
        next = read_atomic(&maptrack_entry(t, head).ref);
        if ( unlikely(next == MAPTRACK_TAIL) )
        {
            spin_unlock(&v->maptrack_freelist_lock);
            return -1;
        }

        prev_head = head;
        head = cmpxchg(&v->maptrack_head, prev_head, next);
    } while ( head != prev_head );

    spin_unlock(&v->maptrack_freelist_lock);

    return head;
}","static inline int
__get_maptrack_handle(
    struct grant_table *VAR_0,
    struct vcpu *VAR_1)
{
    unsigned int VAR_2, VAR_3, VAR_4;

    spin_lock(&VAR_1->maptrack_freelist_lock);

    do {
        /* COMMENT_0 */
        VAR_2 = read_atomic(&VAR_1->maptrack_head);
        if ( unlikely(VAR_2 == VAR_5) )
        {
            spin_unlock(&VAR_1->maptrack_freelist_lock);
            return -1;
        }

        /* COMMENT_1 */
                                                                      
                                        
           
        VAR_3 = read_atomic(&maptrack_entry(VAR_0, VAR_2).ref);
        if ( unlikely(VAR_3 == VAR_5) )
        {
            spin_unlock(&VAR_1->maptrack_freelist_lock);
            return -1;
        }

        VAR_4 = VAR_2;
        VAR_2 = cmpxchg(&VAR_1->maptrack_head, VAR_4, VAR_3);
    } while ( VAR_2 != VAR_4 );

    spin_unlock(&VAR_1->maptrack_freelist_lock);

    return VAR_2;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,11 +5,16 @@
 {
     unsigned int head, next, prev_head;
 
+    spin_lock(&v->maptrack_freelist_lock);
+
     do {
         /* No maptrack pages allocated for this VCPU yet? */
         head = read_atomic(&v->maptrack_head);
         if ( unlikely(head == MAPTRACK_TAIL) )
+        {
+            spin_unlock(&v->maptrack_freelist_lock);
             return -1;
+        }
 
         /*
          * Always keep one entry in the free list to make it easier to
@@ -17,11 +22,16 @@
          */
         next = read_atomic(&maptrack_entry(t, head).ref);
         if ( unlikely(next == MAPTRACK_TAIL) )
+        {
+            spin_unlock(&v->maptrack_freelist_lock);
             return -1;
+        }
 
         prev_head = head;
         head = cmpxchg(&v->maptrack_head, prev_head, next);
     } while ( head != prev_head );
 
+    spin_unlock(&v->maptrack_freelist_lock);
+
     return head;
 }","{'deleted_lines': [], 'added_lines': ['    spin_lock(&v->maptrack_freelist_lock);', '', '        {', '            spin_unlock(&v->maptrack_freelist_lock);', '        }', '        {', '            spin_unlock(&v->maptrack_freelist_lock);', '        }', '    spin_unlock(&v->maptrack_freelist_lock);', '']}",True,Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.,7.8,HIGH,2,valid,2017-08-15T13:07:25Z,2
CVE-2017-12136,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"gnttab: split maptrack lock to make it fulfill its purpose again

The way the lock is currently being used in get_maptrack_handle(), it
protects only the maptrack limit: The function acts on current's list
only, so races on list accesses are impossible even without the lock.

Otoh list access races are possible between __get_maptrack_handle() and
put_maptrack_handle(), due to the invocation of the former for other
than current from steal_maptrack_handle(). Introduce a per-vCPU lock
for list accesses to become race free again. This lock will be
uncontended except when it becomes necessary to take the steal path,
i.e. in the common case there should be no meaningful performance
impact.

When in get_maptrack_handle adds a stolen entry to a fresh, empty,
freelist, we think that there is probably no concurrency.  However,
this is not a fast path and adding the locking there makes the code
clearly correct.

Also, while we are here: the stolen maptrack_entry's tail pointer was
not properly set.  Set it.

This is CVE-2017-12136 / XSA-228.

Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>",02cbeeb6207508b0f04a2c6181445c8eb3f1e117,https://github.com/xen-project/xen/commit/02cbeeb6207508b0f04a2c6181445c8eb3f1e117,xen/common/grant_table.c,get_maptrack_handle,"static inline int
get_maptrack_handle(
struct grant_table *lgt)
{
struct vcpu          *curr = current;
unsigned int          i, head;
grant_handle_t        handle;
struct grant_mapping *new_mt;
handle = __get_maptrack_handle(lgt, curr);
if ( likely(handle != -1) )
return handle;
spin_lock(&lgt->maptrack_lock);
if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )
{
spin_unlock(&lgt->maptrack_lock);
if ( curr->maptrack_tail == MAPTRACK_TAIL )
{
handle = steal_maptrack_handle(lgt, curr);
if ( handle == -1 )
return -1;
curr->maptrack_tail = handle;
write_atomic(&curr->maptrack_head, handle);
}
return steal_maptrack_handle(lgt, curr);
}
new_mt = alloc_xenheap_page();
if ( !new_mt )
{
spin_unlock(&lgt->maptrack_lock);
return -1;
}
clear_page(new_mt);
handle = lgt->maptrack_limit;
for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )
{
new_mt[i].ref = handle + i + 1;
new_mt[i].vcpu = curr->vcpu_id;
}
if ( curr->maptrack_tail == MAPTRACK_TAIL )
curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;
lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;
smp_wmb();
lgt->maptrack_limit += MAPTRACK_PER_PAGE;
do {
new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);
head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);
} while ( head != new_mt[i - 1].ref );
spin_unlock(&lgt->maptrack_lock);
return handle;
}","static inline int
get_maptrack_handle(
struct grant_table *VAR_0)
{
struct vcpu          *VAR_1 = VAR_2;
unsigned int          VAR_3, VAR_4;
grant_handle_t        VAR_5;
struct grant_mapping *VAR_6;
VAR_5 = __get_maptrack_handle(VAR_0, VAR_1);
if ( likely(VAR_5 != -1) )
return VAR_5;
spin_lock(&VAR_0->maptrack_lock);
if ( nr_maptrack_frames(VAR_0) >= VAR_7 )
{
spin_unlock(&VAR_0->maptrack_lock);
if ( VAR_1->maptrack_tail == VAR_8 )
{
VAR_5 = steal_maptrack_handle(VAR_0, VAR_1);
if ( VAR_5 == -1 )
return -1;
VAR_1->maptrack_tail = VAR_5;
write_atomic(&VAR_1->maptrack_head, VAR_5);
}
return steal_maptrack_handle(VAR_0, VAR_1);
}
VAR_6 = alloc_xenheap_page();
if ( !VAR_6 )
{
spin_unlock(&VAR_0->maptrack_lock);
return -1;
}
clear_page(VAR_6);
VAR_5 = VAR_0->maptrack_limit;
for ( VAR_3 = 0; VAR_3 < VAR_9; VAR_3++ )
{
VAR_6[VAR_3].ref = VAR_5 + VAR_3 + 1;
VAR_6[VAR_3].vcpu = VAR_1->vcpu_id;
}
if ( VAR_1->maptrack_tail == VAR_8 )
VAR_1->maptrack_tail = VAR_5 + VAR_9 - 1;
VAR_0->maptrack[nr_maptrack_frames(VAR_0)] = VAR_6;
smp_wmb();
VAR_0->maptrack_limit += VAR_9;
do {
VAR_6[VAR_3 - 1].ref = read_atomic(&VAR_1->maptrack_head);
VAR_4 = cmpxchg(&VAR_1->maptrack_head, VAR_6[VAR_3 - 1].ref, VAR_5 + 1);
} while ( VAR_4 != VAR_6[VAR_3 - 1].ref );
spin_unlock(&VAR_0->maptrack_lock);
return VAR_5;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/before/3.json,"static inline int
get_maptrack_handle(
    struct grant_table *lgt)
{
    struct vcpu          *curr = current;
    unsigned int          i, head;
    grant_handle_t        handle;
    struct grant_mapping *new_mt;

    handle = __get_maptrack_handle(lgt, curr);
    if ( likely(handle != -1) )
        return handle;

    spin_lock(&lgt->maptrack_lock);

    /*
     * If we've run out of frames, try stealing an entry from another
     * VCPU (in case the guest isn't mapping across its VCPUs evenly).
     */
    if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )
    {
        spin_unlock(&lgt->maptrack_lock);

        /*
         * Uninitialized free list? Steal an extra entry for the tail
         * sentinel.
         */
        if ( curr->maptrack_tail == MAPTRACK_TAIL )
        {
            handle = steal_maptrack_handle(lgt, curr);
            if ( handle == -1 )
                return -1;
            spin_lock(&curr->maptrack_freelist_lock);
            maptrack_entry(lgt, handle).ref = MAPTRACK_TAIL;
            curr->maptrack_tail = handle;
            if ( curr->maptrack_head == MAPTRACK_TAIL )
                write_atomic(&curr->maptrack_head, handle);
            spin_unlock(&curr->maptrack_freelist_lock);
        }
        return steal_maptrack_handle(lgt, curr);
    }

    new_mt = alloc_xenheap_page();
    if ( !new_mt )
    {
        spin_unlock(&lgt->maptrack_lock);
        return -1;
    }
    clear_page(new_mt);

    /*
     * Use the first new entry and add the remaining entries to the
     * head of the free list.
     */
    handle = lgt->maptrack_limit;

    for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )
    {
        new_mt[i].ref = handle + i + 1;
        new_mt[i].vcpu = curr->vcpu_id;
    }

    /* Set tail directly if this is the first page for this VCPU. */
    if ( curr->maptrack_tail == MAPTRACK_TAIL )
        curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;

    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;
    smp_wmb();
    lgt->maptrack_limit += MAPTRACK_PER_PAGE;

    spin_unlock(&lgt->maptrack_lock);
    spin_lock(&curr->maptrack_freelist_lock);

    do {
        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);
        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);
    } while ( head != new_mt[i - 1].ref );

    spin_unlock(&curr->maptrack_freelist_lock);

    return handle;
}","static inline int
get_maptrack_handle(
    struct grant_table *VAR_0)
{
    struct vcpu          *VAR_1 = VAR_2;
    unsigned int          VAR_3, VAR_4;
    grant_handle_t        VAR_5;
    struct grant_mapping *VAR_6;

    VAR_5 = __get_maptrack_handle(VAR_0, VAR_1);
    if ( likely(VAR_5 != -1) )
        return VAR_5;

    spin_lock(&VAR_0->maptrack_lock);

    /* COMMENT_0 */
                                                                     
                                                                      
       
    if ( nr_maptrack_frames(VAR_0) >= VAR_7 )
    {
        spin_unlock(&VAR_0->maptrack_lock);

        /* COMMENT_4 */
                                                                     
                    
           
        if ( VAR_1->maptrack_tail == VAR_8 )
        {
            VAR_5 = steal_maptrack_handle(VAR_0, VAR_1);
            if ( VAR_5 == -1 )
                return -1;
            spin_lock(&VAR_1->maptrack_freelist_lock);
            maptrack_entry(VAR_0, VAR_5).ref = VAR_8;
            VAR_1->maptrack_tail = VAR_5;
            if ( VAR_1->maptrack_head == VAR_8 )
                write_atomic(&VAR_1->maptrack_head, VAR_5);
            spin_unlock(&VAR_1->maptrack_freelist_lock);
        }
        return steal_maptrack_handle(VAR_0, VAR_1);
    }

    VAR_6 = alloc_xenheap_page();
    if ( !VAR_6 )
    {
        spin_unlock(&VAR_0->maptrack_lock);
        return -1;
    }
    clear_page(VAR_6);

    /* COMMENT_8 */
                                                                   
                             
       
    VAR_5 = VAR_0->maptrack_limit;

    for ( VAR_3 = 0; VAR_3 < VAR_9; VAR_3++ )
    {
        VAR_6[VAR_3].ref = VAR_5 + VAR_3 + 1;
        VAR_6[VAR_3].vcpu = VAR_1->vcpu_id;
    }

    /* COMMENT_12 */
    if ( VAR_1->maptrack_tail == VAR_8 )
        VAR_1->maptrack_tail = VAR_5 + VAR_9 - 1;

    VAR_0->maptrack[nr_maptrack_frames(VAR_0)] = VAR_6;
    smp_wmb();
    VAR_0->maptrack_limit += VAR_9;

    spin_unlock(&VAR_0->maptrack_lock);
    spin_lock(&VAR_1->maptrack_freelist_lock);

    do {
        VAR_6[VAR_3 - 1].ref = read_atomic(&VAR_1->maptrack_head);
        VAR_4 = cmpxchg(&VAR_1->maptrack_head, VAR_6[VAR_3 - 1].ref, VAR_5 + 1);
    } while ( VAR_4 != VAR_6[VAR_3 - 1].ref );

    spin_unlock(&VAR_1->maptrack_freelist_lock);

    return VAR_5;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -19,10 +19,6 @@
      */
     if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )
     {
-        /*
-         * Can drop the lock since no other VCPU can be adding a new
-         * frame once they've run out.
-         */
         spin_unlock(&lgt->maptrack_lock);
 
         /*
@@ -34,8 +30,12 @@
             handle = steal_maptrack_handle(lgt, curr);
             if ( handle == -1 )
                 return -1;
+            spin_lock(&curr->maptrack_freelist_lock);
+            maptrack_entry(lgt, handle).ref = MAPTRACK_TAIL;
             curr->maptrack_tail = handle;
-            write_atomic(&curr->maptrack_head, handle);
+            if ( curr->maptrack_head == MAPTRACK_TAIL )
+                write_atomic(&curr->maptrack_head, handle);
+            spin_unlock(&curr->maptrack_freelist_lock);
         }
         return steal_maptrack_handle(lgt, curr);
     }
@@ -68,12 +68,15 @@
     smp_wmb();
     lgt->maptrack_limit += MAPTRACK_PER_PAGE;
 
+    spin_unlock(&lgt->maptrack_lock);
+    spin_lock(&curr->maptrack_freelist_lock);
+
     do {
         new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);
         head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);
     } while ( head != new_mt[i - 1].ref );
 
-    spin_unlock(&lgt->maptrack_lock);
+    spin_unlock(&curr->maptrack_freelist_lock);
 
     return handle;
 }","{'deleted_lines': ['        /*', '         * Can drop the lock since no other VCPU can be adding a new', ""         * frame once they've run out."", '         */', '            write_atomic(&curr->maptrack_head, handle);', '    spin_unlock(&lgt->maptrack_lock);'], 'added_lines': ['            spin_lock(&curr->maptrack_freelist_lock);', '            maptrack_entry(lgt, handle).ref = MAPTRACK_TAIL;', '            if ( curr->maptrack_head == MAPTRACK_TAIL )', '                write_atomic(&curr->maptrack_head, handle);', '            spin_unlock(&curr->maptrack_freelist_lock);', '    spin_unlock(&lgt->maptrack_lock);', '    spin_lock(&curr->maptrack_freelist_lock);', '', '    spin_unlock(&curr->maptrack_freelist_lock);']}",True,Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.,7.8,HIGH,2,valid,2017-08-15T13:07:25Z,2
CVE-2017-12136,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"gnttab: split maptrack lock to make it fulfill its purpose again

The way the lock is currently being used in get_maptrack_handle(), it
protects only the maptrack limit: The function acts on current's list
only, so races on list accesses are impossible even without the lock.

Otoh list access races are possible between __get_maptrack_handle() and
put_maptrack_handle(), due to the invocation of the former for other
than current from steal_maptrack_handle(). Introduce a per-vCPU lock
for list accesses to become race free again. This lock will be
uncontended except when it becomes necessary to take the steal path,
i.e. in the common case there should be no meaningful performance
impact.

When in get_maptrack_handle adds a stolen entry to a fresh, empty,
freelist, we think that there is probably no concurrency.  However,
this is not a fast path and adding the locking there makes the code
clearly correct.

Also, while we are here: the stolen maptrack_entry's tail pointer was
not properly set.  Set it.

This is CVE-2017-12136 / XSA-228.

Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>",02cbeeb6207508b0f04a2c6181445c8eb3f1e117,https://github.com/xen-project/xen/commit/02cbeeb6207508b0f04a2c6181445c8eb3f1e117,xen/common/grant_table.c,put_maptrack_handle,"static inline void
put_maptrack_handle(
struct grant_table *t, int handle)
{
struct domain *currd = current->domain;
struct vcpu *v;
unsigned int prev_tail, cur_tail;
maptrack_entry(t, handle).ref = MAPTRACK_TAIL;
v = currd->vcpu[maptrack_entry(t, handle).vcpu];
cur_tail = read_atomic(&v->maptrack_tail);
do {
prev_tail = cur_tail;
cur_tail = cmpxchg(&v->maptrack_tail, prev_tail, handle);
} while ( cur_tail != prev_tail );
write_atomic(&maptrack_entry(t, prev_tail).ref, handle);
}","static inline void
put_maptrack_handle(
struct grant_table *VAR_0, int VAR_1)
{
struct domain *VAR_2 = VAR_3->domain;
struct vcpu *VAR_4;
unsigned int VAR_5, VAR_6;
maptrack_entry(VAR_0, VAR_1).ref = VAR_7;
VAR_4 = VAR_2->vcpu[maptrack_entry(VAR_0, VAR_1).vcpu];
VAR_6 = read_atomic(&VAR_4->maptrack_tail);
do {
VAR_5 = VAR_6;
VAR_6 = cmpxchg(&VAR_4->maptrack_tail, VAR_5, VAR_1);
} while ( VAR_6 != VAR_5 );
write_atomic(&maptrack_entry(VAR_0, VAR_5).ref, VAR_1);
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/before/2.json,"static inline void
put_maptrack_handle(
    struct grant_table *t, int handle)
{
    struct domain *currd = current->domain;
    struct vcpu *v;
    unsigned int prev_tail, cur_tail;

    /* 1. Set entry to be a tail. */
    maptrack_entry(t, handle).ref = MAPTRACK_TAIL;

    /* 2. Add entry to the tail of the list on the original VCPU. */
    v = currd->vcpu[maptrack_entry(t, handle).vcpu];

    spin_lock(&v->maptrack_freelist_lock);

    cur_tail = read_atomic(&v->maptrack_tail);
    do {
        prev_tail = cur_tail;
        cur_tail = cmpxchg(&v->maptrack_tail, prev_tail, handle);
    } while ( cur_tail != prev_tail );

    /* 3. Update the old tail entry to point to the new entry. */
    write_atomic(&maptrack_entry(t, prev_tail).ref, handle);

    spin_unlock(&v->maptrack_freelist_lock);
}","static inline void
put_maptrack_handle(
    struct grant_table *VAR_0, int VAR_1)
{
    struct domain *VAR_2 = VAR_3->domain;
    struct vcpu *VAR_4;
    unsigned int VAR_5, VAR_6;

    /* COMMENT_0 */
    maptrack_entry(VAR_0, VAR_1).ref = VAR_7;

    /* COMMENT_1 */
    VAR_4 = VAR_2->vcpu[maptrack_entry(VAR_0, VAR_1).vcpu];

    spin_lock(&VAR_4->maptrack_freelist_lock);

    VAR_6 = read_atomic(&VAR_4->maptrack_tail);
    do {
        VAR_5 = VAR_6;
        VAR_6 = cmpxchg(&VAR_4->maptrack_tail, VAR_5, VAR_1);
    } while ( VAR_6 != VAR_5 );

    /* COMMENT_2 */
    write_atomic(&maptrack_entry(VAR_0, VAR_5).ref, VAR_1);

    spin_unlock(&VAR_4->maptrack_freelist_lock);
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -12,6 +12,8 @@
     /* 2. Add entry to the tail of the list on the original VCPU. */
     v = currd->vcpu[maptrack_entry(t, handle).vcpu];
 
+    spin_lock(&v->maptrack_freelist_lock);
+
     cur_tail = read_atomic(&v->maptrack_tail);
     do {
         prev_tail = cur_tail;
@@ -20,4 +22,6 @@
 
     /* 3. Update the old tail entry to point to the new entry. */
     write_atomic(&maptrack_entry(t, prev_tail).ref, handle);
+
+    spin_unlock(&v->maptrack_freelist_lock);
 }","{'deleted_lines': [], 'added_lines': ['    spin_lock(&v->maptrack_freelist_lock);', '', '', '    spin_unlock(&v->maptrack_freelist_lock);']}",True,Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.,7.8,HIGH,2,valid,2017-08-15T13:07:25Z,2
CVE-2017-12136,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"gnttab: split maptrack lock to make it fulfill its purpose again

The way the lock is currently being used in get_maptrack_handle(), it
protects only the maptrack limit: The function acts on current's list
only, so races on list accesses are impossible even without the lock.

Otoh list access races are possible between __get_maptrack_handle() and
put_maptrack_handle(), due to the invocation of the former for other
than current from steal_maptrack_handle(). Introduce a per-vCPU lock
for list accesses to become race free again. This lock will be
uncontended except when it becomes necessary to take the steal path,
i.e. in the common case there should be no meaningful performance
impact.

When in get_maptrack_handle adds a stolen entry to a fresh, empty,
freelist, we think that there is probably no concurrency.  However,
this is not a fast path and adding the locking there makes the code
clearly correct.

Also, while we are here: the stolen maptrack_entry's tail pointer was
not properly set.  Set it.

This is CVE-2017-12136 / XSA-228.

Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>",02cbeeb6207508b0f04a2c6181445c8eb3f1e117,https://github.com/xen-project/xen/commit/02cbeeb6207508b0f04a2c6181445c8eb3f1e117,xen/common/grant_table.c,grant_table_init_vcpu,"void grant_table_init_vcpu(struct vcpu *v)
{
v->maptrack_head = MAPTRACK_TAIL;
v->maptrack_tail = MAPTRACK_TAIL;
}","void grant_table_init_vcpu(struct vcpu *VAR_0)
{
VAR_0->maptrack_head = VAR_1;
VAR_0->maptrack_tail = VAR_1;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/before/1.json,"void grant_table_init_vcpu(struct vcpu *v)
{
    spin_lock_init(&v->maptrack_freelist_lock);
    v->maptrack_head = MAPTRACK_TAIL;
    v->maptrack_tail = MAPTRACK_TAIL;
}","void grant_table_init_vcpu(struct vcpu *VAR_0)
{
    spin_lock_init(&VAR_0->maptrack_freelist_lock);
    VAR_0->maptrack_head = VAR_1;
    VAR_0->maptrack_tail = VAR_1;
}",xen-project/xen/02cbeeb6207508b0f04a2c6181445c8eb3f1e117/grant_table.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 void grant_table_init_vcpu(struct vcpu *v)
 {
+    spin_lock_init(&v->maptrack_freelist_lock);
     v->maptrack_head = MAPTRACK_TAIL;
     v->maptrack_tail = MAPTRACK_TAIL;
 }","{'deleted_lines': [], 'added_lines': ['    spin_lock_init(&v->maptrack_freelist_lock);']}",True,Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.,7.8,HIGH,2,valid,2017-08-15T13:07:25Z,2
CVE-2017-14041,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,uclouvain/openjpeg,pgxtoimage(): fix write stack buffer overflow (#997),e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,src/bin/jp2/convert.c,pgxtoimage,"opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
FILE *f = NULL;
int w, h, prec;
int i, numcomps, max;
OPJ_COLOR_SPACE color_space;
opj_image_cmptparm_t cmptparm;  
opj_image_t * image = NULL;
int adjustS, ushift, dshift, force8;
char endian1, endian2, sign;
char signtmp[32];
char temp[32];
int bigendian;
opj_image_comp_t *comp = NULL;
numcomps = 1;
color_space = OPJ_CLRSPC_GRAY;
memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));
max = 0;
f = fopen(filename, ""rb"");
if (!f) {
fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
return NULL;
}
fseek(f, 0, SEEK_SET);
if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
&endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
fclose(f);
fprintf(stderr,
""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
return NULL;
}
i = 0;
sign = '+';
while (signtmp[i] != '\0') {
if (signtmp[i] == '-') {
sign = '-';
}
i++;
}
fgetc(f);
if (endian1 == 'M' && endian2 == 'L') {
bigendian = 1;
} else if (endian2 == 'M' && endian1 == 'L') {
bigendian = 0;
} else {
fclose(f);
fprintf(stderr, ""Bad pgx header, please check input file\n"");
return NULL;
}
cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
+ 1;
cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
+ 1;
if (sign == '-') {
cmptparm.sgnd = 1;
} else {
cmptparm.sgnd = 0;
}
if (prec < 8) {
force8 = 1;
ushift = 8 - prec;
dshift = prec - ushift;
if (cmptparm.sgnd) {
adjustS = (1 << (prec - 1));
} else {
adjustS = 0;
}
cmptparm.sgnd = 0;
prec = 8;
} else {
ushift = dshift = force8 = adjustS = 0;
}
cmptparm.prec = (OPJ_UINT32)prec;
cmptparm.bpp = (OPJ_UINT32)prec;
cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;
image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
if (!image) {
fclose(f);
return NULL;
}
image->x0 = cmptparm.x0;
image->y0 = cmptparm.x0;
image->x1 = cmptparm.w;
image->y1 = cmptparm.h;
comp = &image->comps[0];
for (i = 0; i < w * h; i++) {
int v;
if (force8) {
v = readuchar(f) + adjustS;
v = (v << ushift) + (v >> dshift);
comp->data[i] = (unsigned char)v;
if (v > max) {
max = v;
}
continue;
}
if (comp->prec == 8) {
if (!comp->sgnd) {
v = readuchar(f);
} else {
v = (char) readuchar(f);
}
} else if (comp->prec <= 16) {
if (!comp->sgnd) {
v = readushort(f, bigendian);
} else {
v = (short) readushort(f, bigendian);
}
} else {
if (!comp->sgnd) {
v = (int)readuint(f, bigendian);
} else {
v = (int) readuint(f, bigendian);
}
}
if (v > max) {
max = v;
}
comp->data[i] = v;
}
fclose(f);
comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;
return image;
}","opj_image_t* pgxtoimage(const char *VAR_0, opj_cparameters_t *VAR_1)
{
FILE *VAR_2 = NULL;
int VAR_3, VAR_4, VAR_5;
int VAR_6, VAR_7, VAR_8;
OPJ_COLOR_SPACE VAR_9;
opj_image_cmptparm_t VAR_10;  
opj_image_t * VAR_11 = NULL;
int VAR_12, VAR_13, VAR_14, VAR_15;
char VAR_16, VAR_17, VAR_18;
char VAR_19[32];
char VAR_20[32];
int VAR_21;
opj_image_comp_t *VAR_22 = NULL;
VAR_7 = 1;
VAR_9 = VAR_23;
memset(&VAR_10, 0, sizeof(opj_image_cmptparm_t));
VAR_8 = 0;
VAR_2 = fopen(VAR_0, ""rb"");
if (!VAR_2) {
fprintf(VAR_24, ""Failed to open %s for reading !\n"", VAR_0);
return NULL;
}
fseek(VAR_2, 0, VAR_25);
if (fscanf(VAR_2, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", VAR_20, &VAR_16,
&VAR_17, VAR_19, &VAR_5, VAR_20, &VAR_3, VAR_20, &VAR_4) != 9) {
fclose(VAR_2);
fprintf(VAR_24,
""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
return NULL;
}
VAR_6 = 0;
VAR_18 = '+';
while (VAR_19[VAR_6] != '\0') {
if (VAR_19[VAR_6] == '-') {
VAR_18 = '-';
}
VAR_6++;
}
fgetc(VAR_2);
if (VAR_16 == 'M' && VAR_17 == 'L') {
VAR_21 = 1;
} else if (VAR_17 == 'M' && VAR_16 == 'L') {
VAR_21 = 0;
} else {
fclose(VAR_2);
fprintf(VAR_24, ""Bad pgx header, please check input file\n"");
return NULL;
}
VAR_10.x0 = (OPJ_UINT32)VAR_1->image_offset_x0;
VAR_10.y0 = (OPJ_UINT32)VAR_1->image_offset_y0;
VAR_10.w = !VAR_10.x0 ? (OPJ_UINT32)((VAR_3 - 1) * VAR_1->subsampling_dx +
1) : VAR_10.x0 + (OPJ_UINT32)(VAR_3 - 1) * (OPJ_UINT32)VAR_1->subsampling_dx
+ 1;
VAR_10.h = !VAR_10.y0 ? (OPJ_UINT32)((VAR_4 - 1) * VAR_1->subsampling_dy +
1) : VAR_10.y0 + (OPJ_UINT32)(VAR_4 - 1) * (OPJ_UINT32)VAR_1->subsampling_dy
+ 1;
if (VAR_18 == '-') {
VAR_10.sgnd = 1;
} else {
VAR_10.sgnd = 0;
}
if (VAR_5 < 8) {
VAR_15 = 1;
VAR_13 = 8 - VAR_5;
VAR_14 = VAR_5 - VAR_13;
if (VAR_10.sgnd) {
VAR_12 = (1 << (VAR_5 - 1));
} else {
VAR_12 = 0;
}
VAR_10.sgnd = 0;
VAR_5 = 8;
} else {
VAR_13 = VAR_14 = VAR_15 = VAR_12 = 0;
}
VAR_10.prec = (OPJ_UINT32)VAR_5;
VAR_10.bpp = (OPJ_UINT32)VAR_5;
VAR_10.dx = (OPJ_UINT32)VAR_1->subsampling_dx;
VAR_10.dy = (OPJ_UINT32)VAR_1->subsampling_dy;
VAR_11 = opj_image_create((OPJ_UINT32)VAR_7, &VAR_10, VAR_9);
if (!VAR_11) {
fclose(VAR_2);
return NULL;
}
VAR_11->x0 = VAR_10.x0;
VAR_11->y0 = VAR_10.x0;
VAR_11->x1 = VAR_10.w;
VAR_11->y1 = VAR_10.h;
VAR_22 = &VAR_11->comps[0];
for (VAR_6 = 0; VAR_6 < VAR_3 * VAR_4; VAR_6++) {
int VAR_26;
if (VAR_15) {
VAR_26 = readuchar(VAR_2) + VAR_12;
VAR_26 = (VAR_26 << VAR_13) + (VAR_26 >> VAR_14);
VAR_22->data[VAR_6] = (unsigned char)VAR_26;
if (VAR_26 > VAR_8) {
VAR_8 = VAR_26;
}
continue;
}
if (VAR_22->prec == 8) {
if (!VAR_22->sgnd) {
VAR_26 = readuchar(VAR_2);
} else {
VAR_26 = (char) readuchar(VAR_2);
}
} else if (VAR_22->prec <= 16) {
if (!VAR_22->sgnd) {
VAR_26 = readushort(VAR_2, VAR_21);
} else {
VAR_26 = (short) readushort(VAR_2, VAR_21);
}
} else {
if (!VAR_22->sgnd) {
VAR_26 = (int)readuint(VAR_2, VAR_21);
} else {
VAR_26 = (int) readuint(VAR_2, VAR_21);
}
}
if (VAR_26 > VAR_8) {
VAR_8 = VAR_26;
}
VAR_22->data[VAR_6] = VAR_26;
}
fclose(VAR_2);
VAR_22->bpp = (OPJ_UINT32)int_floorlog2(VAR_8) + 1;
return VAR_11;
}",uclouvain/openjpeg/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9/convert.c/vul/before/0.json,"opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
    }

    fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
               &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
        fclose(f);
        fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}","opj_image_t* pgxtoimage(const char *VAR_0, opj_cparameters_t *VAR_1)
{
    FILE *VAR_2 = NULL;
    int VAR_3, VAR_4, VAR_5;
    int VAR_6, VAR_7, VAR_8;
    OPJ_COLOR_SPACE VAR_9;
    opj_image_cmptparm_t VAR_10;  /* COMMENT_0 */
    opj_image_t * VAR_11 = NULL;
    int VAR_12, VAR_13, VAR_14, VAR_15;

    char VAR_16, VAR_17, VAR_18;
    char VAR_19[32];

    char VAR_20[32];
    int VAR_21;
    opj_image_comp_t *VAR_22 = NULL;

    VAR_7 = 1;
    VAR_9 = VAR_23;

    memset(&VAR_10, 0, sizeof(opj_image_cmptparm_t));

    VAR_8 = 0;

    VAR_2 = fopen(VAR_0, ""rb"");
    if (!VAR_2) {
        fprintf(VAR_24, ""Failed to open %s for reading !\n"", VAR_0);
        return NULL;
    }

    fseek(VAR_2, 0, VAR_25);
    if (fscanf(VAR_2, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", VAR_20, &VAR_16,
               &VAR_17, VAR_19, &VAR_5, VAR_20, &VAR_3, VAR_20, &VAR_4) != 9) {
        fclose(VAR_2);
        fprintf(VAR_24,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    VAR_6 = 0;
    VAR_18 = '+';
    while (VAR_19[VAR_6] != '\0') {
        if (VAR_19[VAR_6] == '-') {
            VAR_18 = '-';
        }
        VAR_6++;
    }

    fgetc(VAR_2);
    if (VAR_16 == 'M' && VAR_17 == 'L') {
        VAR_21 = 1;
    } else if (VAR_17 == 'M' && VAR_16 == 'L') {
        VAR_21 = 0;
    } else {
        fclose(VAR_2);
        fprintf(VAR_24, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* COMMENT_1 */

    VAR_10.x0 = (OPJ_UINT32)VAR_1->image_offset_x0;
    VAR_10.y0 = (OPJ_UINT32)VAR_1->image_offset_y0;
    VAR_10.w = !VAR_10.x0 ? (OPJ_UINT32)((VAR_3 - 1) * VAR_1->subsampling_dx +
                 1) : VAR_10.x0 + (OPJ_UINT32)(VAR_3 - 1) * (OPJ_UINT32)VAR_1->subsampling_dx
                 + 1;
    VAR_10.h = !VAR_10.y0 ? (OPJ_UINT32)((VAR_4 - 1) * VAR_1->subsampling_dy +
                 1) : VAR_10.y0 + (OPJ_UINT32)(VAR_4 - 1) * (OPJ_UINT32)VAR_1->subsampling_dy
                 + 1;

    if (VAR_18 == '-') {
        VAR_10.sgnd = 1;
    } else {
        VAR_10.sgnd = 0;
    }
    if (VAR_5 < 8) {
        VAR_15 = 1;
        VAR_13 = 8 - VAR_5;
        VAR_14 = VAR_5 - VAR_13;
        if (VAR_10.sgnd) {
            VAR_12 = (1 << (VAR_5 - 1));
        } else {
            VAR_12 = 0;
        }
        VAR_10.sgnd = 0;
        VAR_5 = 8;
    } else {
        VAR_13 = VAR_14 = VAR_15 = VAR_12 = 0;
    }

    VAR_10.prec = (OPJ_UINT32)VAR_5;
    VAR_10.bpp = (OPJ_UINT32)VAR_5;
    VAR_10.dx = (OPJ_UINT32)VAR_1->subsampling_dx;
    VAR_10.dy = (OPJ_UINT32)VAR_1->subsampling_dy;

    /* COMMENT_2 */
    VAR_11 = opj_image_create((OPJ_UINT32)VAR_7, &VAR_10, VAR_9);
    if (!VAR_11) {
        fclose(VAR_2);
        return NULL;
    }
    /* COMMENT_3 */
    VAR_11->x0 = VAR_10.x0;
    VAR_11->y0 = VAR_10.x0;
    VAR_11->x1 = VAR_10.w;
    VAR_11->y1 = VAR_10.h;

    /* COMMENT_4 */

    VAR_22 = &VAR_11->comps[0];

    for (VAR_6 = 0; VAR_6 < VAR_3 * VAR_4; VAR_6++) {
        int VAR_26;
        if (VAR_15) {
            VAR_26 = readuchar(VAR_2) + VAR_12;
            VAR_26 = (VAR_26 << VAR_13) + (VAR_26 >> VAR_14);
            VAR_22->data[VAR_6] = (unsigned char)VAR_26;

            if (VAR_26 > VAR_8) {
                VAR_8 = VAR_26;
            }

            continue;
        }
        if (VAR_22->prec == 8) {
            if (!VAR_22->sgnd) {
                VAR_26 = readuchar(VAR_2);
            } else {
                VAR_26 = (char) readuchar(VAR_2);
            }
        } else if (VAR_22->prec <= 16) {
            if (!VAR_22->sgnd) {
                VAR_26 = readushort(VAR_2, VAR_21);
            } else {
                VAR_26 = (short) readushort(VAR_2, VAR_21);
            }
        } else {
            if (!VAR_22->sgnd) {
                VAR_26 = (int)readuint(VAR_2, VAR_21);
            } else {
                VAR_26 = (int) readuint(VAR_2, VAR_21);
            }
        }
        if (VAR_26 > VAR_8) {
            VAR_8 = VAR_26;
        }
        VAR_22->data[VAR_6] = VAR_26;
    }
    fclose(VAR_2);
    VAR_22->bpp = (OPJ_UINT32)int_floorlog2(VAR_8) + 1;

    return VAR_11;
}",uclouvain/openjpeg/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9/convert.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,7 +29,7 @@
     }
 
     fseek(f, 0, SEEK_SET);
-    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
+    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,","{'deleted_lines': ['    if (fscanf(f, ""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d"", temp, &endian1,'], 'added_lines': ['    if (fscanf(f, ""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d"", temp, &endian1,']}",True,"A stack-based buffer overflow was discovered in the pgxtoimage function in bin/jp2/convert.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.",8.8,HIGH,2,valid,2017-08-18T11:39:20Z,2
CVE-2017-14056,['CWE-834'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ffmpeg,"avformat/rl2: Fix DoS due to lack of eof check

Fixes: loop.rl2

Found-by: Xiaohei and Wangchu from Alibaba Security Team
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de,https://github.com/FFmpeg/FFmpeg/commit/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de,libavformat/rl2.c,rl2_read_header,"static av_cold int rl2_read_header(AVFormatContext *s)
{
AVIOContext *pb = s->pb;
AVStream *st;
unsigned int frame_count;
unsigned int audio_frame_counter = 0;
unsigned int video_frame_counter = 0;
unsigned int back_size;
unsigned short sound_rate;
unsigned short rate;
unsigned short channels;
unsigned short def_sound_size;
unsigned int signature;
unsigned int pts_den = 11025; 
unsigned int pts_num = 1103;
unsigned int* chunk_offset = NULL;
int* chunk_size = NULL;
int* audio_size = NULL;
int i;
int ret = 0;
avio_skip(pb,4);          
back_size = avio_rl32(pb); 
signature = avio_rb32(pb);
avio_skip(pb, 4);         
frame_count = avio_rl32(pb);
if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))
return AVERROR_INVALIDDATA;
avio_skip(pb, 2);         
sound_rate = avio_rl16(pb);
rate = avio_rl16(pb);
channels = avio_rl16(pb);
def_sound_size = avio_rl16(pb);
st = avformat_new_stream(s, NULL);
if(!st)
return AVERROR(ENOMEM);
st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
st->codecpar->codec_id = AV_CODEC_ID_RL2;
st->codecpar->codec_tag = 0;  
st->codecpar->width = 320;
st->codecpar->height = 200;
st->codecpar->extradata_size = EXTRADATA1_SIZE;
if(signature == RLV3_TAG && back_size > 0)
st->codecpar->extradata_size += back_size;
if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)
return AVERROR(ENOMEM);
if(sound_rate){
if (!channels || channels > 42) {
av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels);
return AVERROR_INVALIDDATA;
}
pts_num = def_sound_size;
pts_den = rate;
st = avformat_new_stream(s, NULL);
if (!st)
return AVERROR(ENOMEM);
st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
st->codecpar->codec_tag = 1;
st->codecpar->channels = channels;
st->codecpar->bits_per_coded_sample = 8;
st->codecpar->sample_rate = rate;
st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *
st->codecpar->bits_per_coded_sample;
st->codecpar->block_align = st->codecpar->channels *
st->codecpar->bits_per_coded_sample / 8;
avpriv_set_pts_info(st,32,1,rate);
}
avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);
chunk_size =   av_malloc(frame_count * sizeof(uint32_t));
audio_size =   av_malloc(frame_count * sizeof(uint32_t));
chunk_offset = av_malloc(frame_count * sizeof(uint32_t));
if(!chunk_size || !audio_size || !chunk_offset){
av_free(chunk_size);
av_free(audio_size);
av_free(chunk_offset);
return AVERROR(ENOMEM);
}
for(i=0; i < frame_count;i++)
chunk_size[i] = avio_rl32(pb);
for(i=0; i < frame_count;i++)
chunk_offset[i] = avio_rl32(pb);
for(i=0; i < frame_count;i++)
audio_size[i] = avio_rl32(pb) & 0xFFFF;
for(i=0;i<frame_count;i++){
if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){
ret = AVERROR_INVALIDDATA;
break;
}
if(sound_rate && audio_size[i]){
av_add_index_entry(s->streams[1], chunk_offset[i],
audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);
audio_frame_counter += audio_size[i] / channels;
}
av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],
video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);
++video_frame_counter;
}
av_free(chunk_size);
av_free(audio_size);
av_free(chunk_offset);
return ret;
}","static av_cold VAR_0 rl2_read_header(AVFormatContext *VAR_1)
{
AVIOContext *VAR_2 = VAR_1->pb;
AVStream *VAR_3;
unsigned int VAR_4;
unsigned int VAR_5 = 0;
unsigned int VAR_6 = 0;
unsigned int VAR_7;
unsigned short VAR_8;
unsigned short VAR_9;
unsigned short VAR_10;
unsigned short VAR_11;
unsigned int VAR_12;
unsigned int VAR_13 = 11025; 
unsigned int VAR_14 = 1103;
unsigned int* VAR_15 = NULL;
int* VAR_16 = NULL;
int* VAR_17 = NULL;
int VAR_18;
int VAR_19 = 0;
avio_skip(VAR_2,4);          
VAR_7 = avio_rl32(VAR_2); 
VAR_12 = avio_rb32(VAR_2);
avio_skip(VAR_2, 4);         
VAR_4 = avio_rl32(VAR_2);
if(VAR_7 > VAR_20/2  || VAR_4 > VAR_20 / sizeof(uint32_t))
return VAR_21;
avio_skip(VAR_2, 2);         
VAR_8 = avio_rl16(VAR_2);
VAR_9 = avio_rl16(VAR_2);
VAR_10 = avio_rl16(VAR_2);
VAR_11 = avio_rl16(VAR_2);
VAR_3 = avformat_new_stream(VAR_1, NULL);
if(!VAR_3)
return AVERROR(VAR_22);
VAR_3->codecpar->codec_type = VAR_23;
VAR_3->codecpar->codec_id = VAR_24;
VAR_3->codecpar->codec_tag = 0;  
VAR_3->codecpar->width = 320;
VAR_3->codecpar->height = 200;
VAR_3->codecpar->extradata_size = VAR_25;
if(VAR_12 == VAR_26 && VAR_7 > 0)
VAR_3->codecpar->extradata_size += VAR_7;
if(ff_get_extradata(VAR_1, VAR_3->codecpar, VAR_2, VAR_3->codecpar->extradata_size) < 0)
return AVERROR(VAR_22);
if(VAR_8){
if (!VAR_10 || VAR_10 > 42) {
av_log(VAR_1, VAR_27, ""Invalid number of channels: %d\n"", VAR_10);
return VAR_21;
}
VAR_14 = VAR_11;
VAR_13 = VAR_9;
VAR_3 = avformat_new_stream(VAR_1, NULL);
if (!VAR_3)
return AVERROR(VAR_22);
VAR_3->codecpar->codec_type = VAR_28;
VAR_3->codecpar->codec_id = VAR_29;
VAR_3->codecpar->codec_tag = 1;
VAR_3->codecpar->channels = VAR_10;
VAR_3->codecpar->bits_per_coded_sample = 8;
VAR_3->codecpar->sample_rate = VAR_9;
VAR_3->codecpar->bit_rate = VAR_3->codecpar->channels * VAR_3->codecpar->sample_rate *
VAR_3->codecpar->bits_per_coded_sample;
VAR_3->codecpar->block_align = VAR_3->codecpar->channels *
VAR_3->codecpar->bits_per_coded_sample / 8;
avpriv_set_pts_info(VAR_3,32,1,VAR_9);
}
avpriv_set_pts_info(VAR_1->streams[0], 32, VAR_14, VAR_13);
VAR_16 =   av_malloc(VAR_4 * sizeof(uint32_t));
VAR_17 =   av_malloc(VAR_4 * sizeof(uint32_t));
VAR_15 = av_malloc(VAR_4 * sizeof(uint32_t));
if(!VAR_16 || !VAR_17 || !VAR_15){
av_free(VAR_16);
av_free(VAR_17);
av_free(VAR_15);
return AVERROR(VAR_22);
}
for(VAR_18=0; VAR_18 < VAR_4;VAR_18++)
VAR_16[VAR_18] = avio_rl32(VAR_2);
for(VAR_18=0; VAR_18 < VAR_4;VAR_18++)
VAR_15[VAR_18] = avio_rl32(VAR_2);
for(VAR_18=0; VAR_18 < VAR_4;VAR_18++)
VAR_17[VAR_18] = avio_rl32(VAR_2) & 0xFFFF;
for(VAR_18=0;VAR_18<VAR_4;VAR_18++){
if(VAR_16[VAR_18] < 0 || VAR_17[VAR_18] > VAR_16[VAR_18]){
VAR_19 = VAR_21;
break;
}
if(VAR_8 && VAR_17[VAR_18]){
av_add_index_entry(VAR_1->streams[1], VAR_15[VAR_18],
VAR_5,VAR_17[VAR_18], 0, VAR_30);
VAR_5 += VAR_17[VAR_18] / VAR_10;
}
av_add_index_entry(VAR_1->streams[0], VAR_15[VAR_18] + VAR_17[VAR_18],
VAR_6,VAR_16[VAR_18]-VAR_17[VAR_18],0,VAR_30);
++VAR_6;
}
av_free(VAR_16);
av_free(VAR_17);
av_free(VAR_15);
return VAR_19;
}",,"static av_cold int rl2_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    AVStream *st;
    unsigned int frame_count;
    unsigned int audio_frame_counter = 0;
    unsigned int video_frame_counter = 0;
    unsigned int back_size;
    unsigned short sound_rate;
    unsigned short rate;
    unsigned short channels;
    unsigned short def_sound_size;
    unsigned int signature;
    unsigned int pts_den = 11025; /* video only case */
    unsigned int pts_num = 1103;
    unsigned int* chunk_offset = NULL;
    int* chunk_size = NULL;
    int* audio_size = NULL;
    int i;
    int ret = 0;

    avio_skip(pb,4);          /* skip FORM tag */
    back_size = avio_rl32(pb); /**< get size of the background frame */
    signature = avio_rb32(pb);
    avio_skip(pb, 4);         /* data size */
    frame_count = avio_rl32(pb);

    /* disallow back_sizes and frame_counts that may lead to overflows later */
    if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))
        return AVERROR_INVALIDDATA;

    avio_skip(pb, 2);         /* encoding method */
    sound_rate = avio_rl16(pb);
    rate = avio_rl16(pb);
    channels = avio_rl16(pb);
    def_sound_size = avio_rl16(pb);

    /** setup video stream */
    st = avformat_new_stream(s, NULL);
    if(!st)
         return AVERROR(ENOMEM);

    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codecpar->codec_id = AV_CODEC_ID_RL2;
    st->codecpar->codec_tag = 0;  /* no fourcc */
    st->codecpar->width = 320;
    st->codecpar->height = 200;

    /** allocate and fill extradata */
    st->codecpar->extradata_size = EXTRADATA1_SIZE;

    if(signature == RLV3_TAG && back_size > 0)
        st->codecpar->extradata_size += back_size;

    if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)
        return AVERROR(ENOMEM);

    /** setup audio stream if present */
    if(sound_rate){
        if (!channels || channels > 42) {
            av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels);
            return AVERROR_INVALIDDATA;
        }

        pts_num = def_sound_size;
        pts_den = rate;

        st = avformat_new_stream(s, NULL);
        if (!st)
            return AVERROR(ENOMEM);
        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
        st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
        st->codecpar->codec_tag = 1;
        st->codecpar->channels = channels;
        st->codecpar->bits_per_coded_sample = 8;
        st->codecpar->sample_rate = rate;
        st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *
            st->codecpar->bits_per_coded_sample;
        st->codecpar->block_align = st->codecpar->channels *
            st->codecpar->bits_per_coded_sample / 8;
        avpriv_set_pts_info(st,32,1,rate);
    }

    avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);

    chunk_size =   av_malloc(frame_count * sizeof(uint32_t));
    audio_size =   av_malloc(frame_count * sizeof(uint32_t));
    chunk_offset = av_malloc(frame_count * sizeof(uint32_t));

    if(!chunk_size || !audio_size || !chunk_offset){
        av_free(chunk_size);
        av_free(audio_size);
        av_free(chunk_offset);
        return AVERROR(ENOMEM);
    }

    /** read offset and size tables */
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
        chunk_size[i] = avio_rl32(pb);
    }
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
        chunk_offset[i] = avio_rl32(pb);
    }
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
        audio_size[i] = avio_rl32(pb) & 0xFFFF;
    }

    /** build the sample index */
    for(i=0;i<frame_count;i++){
        if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){
            ret = AVERROR_INVALIDDATA;
            break;
        }

        if(sound_rate && audio_size[i]){
            av_add_index_entry(s->streams[1], chunk_offset[i],
                audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);
            audio_frame_counter += audio_size[i] / channels;
        }
        av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],
            video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);
        ++video_frame_counter;
    }


    av_free(chunk_size);
    av_free(audio_size);
    av_free(chunk_offset);

    return ret;
}","static av_cold VAR_0 rl2_read_header(AVFormatContext *VAR_1)
{
    AVIOContext *VAR_2 = VAR_1->pb;
    AVStream *VAR_3;
    unsigned int VAR_4;
    unsigned int VAR_5 = 0;
    unsigned int VAR_6 = 0;
    unsigned int VAR_7;
    unsigned short VAR_8;
    unsigned short VAR_9;
    unsigned short VAR_10;
    unsigned short VAR_11;
    unsigned int VAR_12;
    unsigned int VAR_13 = 11025; /* COMMENT_0 */
    unsigned int VAR_14 = 1103;
    unsigned int* VAR_15 = NULL;
    int* VAR_16 = NULL;
    int* VAR_17 = NULL;
    int VAR_18;
    int VAR_19 = 0;

    avio_skip(VAR_2,4);          /* COMMENT_1 */
    VAR_7 = avio_rl32(VAR_2); /* COMMENT_2 */
    VAR_12 = avio_rb32(VAR_2);
    avio_skip(VAR_2, 4);         /* COMMENT_3 */
    VAR_4 = avio_rl32(VAR_2);

    /* COMMENT_4 */
    if(VAR_7 > VAR_20/2  || VAR_4 > VAR_20 / sizeof(uint32_t))
        return VAR_21;

    avio_skip(VAR_2, 2);         /* COMMENT_5 */
    VAR_8 = avio_rl16(VAR_2);
    VAR_9 = avio_rl16(VAR_2);
    VAR_10 = avio_rl16(VAR_2);
    VAR_11 = avio_rl16(VAR_2);

    /* COMMENT_6 */
    VAR_3 = avformat_new_stream(VAR_1, NULL);
    if(!VAR_3)
         return AVERROR(VAR_22);

    VAR_3->codecpar->codec_type = VAR_23;
    VAR_3->codecpar->codec_id = VAR_24;
    VAR_3->codecpar->codec_tag = 0;  /* COMMENT_7 */
    VAR_3->codecpar->width = 320;
    VAR_3->codecpar->height = 200;

    /* COMMENT_8 */
    VAR_3->codecpar->extradata_size = VAR_25;

    if(VAR_12 == VAR_26 && VAR_7 > 0)
        VAR_3->codecpar->extradata_size += VAR_7;

    if(ff_get_extradata(VAR_1, VAR_3->codecpar, VAR_2, VAR_3->codecpar->extradata_size) < 0)
        return AVERROR(VAR_22);

    /* COMMENT_9 */
    if(VAR_8){
        if (!VAR_10 || VAR_10 > 42) {
            av_log(VAR_1, VAR_27, ""Invalid number of channels: %d\n"", VAR_10);
            return VAR_21;
        }

        VAR_14 = VAR_11;
        VAR_13 = VAR_9;

        VAR_3 = avformat_new_stream(VAR_1, NULL);
        if (!VAR_3)
            return AVERROR(VAR_22);
        VAR_3->codecpar->codec_type = VAR_28;
        VAR_3->codecpar->codec_id = VAR_29;
        VAR_3->codecpar->codec_tag = 1;
        VAR_3->codecpar->channels = VAR_10;
        VAR_3->codecpar->bits_per_coded_sample = 8;
        VAR_3->codecpar->sample_rate = VAR_9;
        VAR_3->codecpar->bit_rate = VAR_3->codecpar->channels * VAR_3->codecpar->sample_rate *
            VAR_3->codecpar->bits_per_coded_sample;
        VAR_3->codecpar->block_align = VAR_3->codecpar->channels *
            VAR_3->codecpar->bits_per_coded_sample / 8;
        avpriv_set_pts_info(VAR_3,32,1,VAR_9);
    }

    avpriv_set_pts_info(VAR_1->streams[0], 32, VAR_14, VAR_13);

    VAR_16 =   av_malloc(VAR_4 * sizeof(uint32_t));
    VAR_17 =   av_malloc(VAR_4 * sizeof(uint32_t));
    VAR_15 = av_malloc(VAR_4 * sizeof(uint32_t));

    if(!VAR_16 || !VAR_17 || !VAR_15){
        av_free(VAR_16);
        av_free(VAR_17);
        av_free(VAR_15);
        return AVERROR(VAR_22);
    }

    /* COMMENT_10 */
    for(VAR_18=0; VAR_18 < VAR_4;VAR_18++) {
        if (avio_feof(VAR_2))
            return VAR_21;
        VAR_16[VAR_18] = avio_rl32(VAR_2);
    }
    for(VAR_18=0; VAR_18 < VAR_4;VAR_18++) {
        if (avio_feof(VAR_2))
            return VAR_21;
        VAR_15[VAR_18] = avio_rl32(VAR_2);
    }
    for(VAR_18=0; VAR_18 < VAR_4;VAR_18++) {
        if (avio_feof(VAR_2))
            return VAR_21;
        VAR_17[VAR_18] = avio_rl32(VAR_2) & 0xFFFF;
    }

    /* COMMENT_11 */
    for(VAR_18=0;VAR_18<VAR_4;VAR_18++){
        if(VAR_16[VAR_18] < 0 || VAR_17[VAR_18] > VAR_16[VAR_18]){
            VAR_19 = VAR_21;
            break;
        }

        if(VAR_8 && VAR_17[VAR_18]){
            av_add_index_entry(VAR_1->streams[1], VAR_15[VAR_18],
                VAR_5,VAR_17[VAR_18], 0, VAR_30);
            VAR_5 += VAR_17[VAR_18] / VAR_10;
        }
        av_add_index_entry(VAR_1->streams[0], VAR_15[VAR_18] + VAR_17[VAR_18],
            VAR_6,VAR_16[VAR_18]-VAR_17[VAR_18],0,VAR_30);
        ++VAR_6;
    }


    av_free(VAR_16);
    av_free(VAR_17);
    av_free(VAR_15);

    return VAR_19;
}",,"--- func_before
+++ func_after
@@ -95,12 +95,21 @@
     }
 
     /** read offset and size tables */
-    for(i=0; i < frame_count;i++)
+    for(i=0; i < frame_count;i++) {
+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;
         chunk_size[i] = avio_rl32(pb);
-    for(i=0; i < frame_count;i++)
+    }
+    for(i=0; i < frame_count;i++) {
+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;
         chunk_offset[i] = avio_rl32(pb);
-    for(i=0; i < frame_count;i++)
+    }
+    for(i=0; i < frame_count;i++) {
+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;
         audio_size[i] = avio_rl32(pb) & 0xFFFF;
+    }
 
     /** build the sample index */
     for(i=0;i<frame_count;i++){","{'deleted_lines': ['    for(i=0; i < frame_count;i++)', '    for(i=0; i < frame_count;i++)', '    for(i=0; i < frame_count;i++)'], 'added_lines': ['    for(i=0; i < frame_count;i++) {', '        if (avio_feof(pb))', '            return AVERROR_INVALIDDATA;', '    }', '    for(i=0; i < frame_count;i++) {', '        if (avio_feof(pb))', '            return AVERROR_INVALIDDATA;', '    }', '    for(i=0; i < frame_count;i++) {', '        if (avio_feof(pb))', '            return AVERROR_INVALIDDATA;', '    }']}",True,"In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.",6.5,MEDIUM,1,valid,2017-08-24T23:15:29Z,2
CVE-2017-14230,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,cyrusimap/cyrus-imapd,"mboxlist: fix uninitialised memory use where pattern is ""Other Users""",6bd33275368edfa71ae117de895488584678ac79,https://github.com/cyrusimap/cyrus-imapd/commit/6bd33275368edfa71ae117de895488584678ac79,imap/mboxlist.c,mboxlist_do_find,"static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)
{
const char *userid = rock->userid;
int isadmin = rock->isadmin;
int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);
char inbox[MAX_MAILBOX_BUFFER];
size_t inboxlen = 0;
size_t prefixlen, len;
size_t domainlen = 0;
size_t userlen = userid ? strlen(userid) : 0;
char domainpat[MAX_MAILBOX_BUFFER]; 
char commonpat[MAX_MAILBOX_BUFFER];
int r = 0;
int i;
const char *p;
if (patterns->count < 1) return 0; 
for (i = 0; i < patterns->count; i++) {
glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);
ptrarray_append(&rock->globs, g);
}
if (config_virtdomains && userid && (p = strchr(userid, '@'))) {
userlen = p - userid;
domainlen = strlen(p); 
snprintf(domainpat, sizeof(domainpat), ""%s!"", p+1);
}
else
domainpat[0] = '\0';
if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||
((p - userid) > (int)userlen)) &&
strlen(userid)+7 < MAX_MAILBOX_BUFFER) {
char *t, *tmpuser = NULL;
const char *inboxuser;
if (domainlen)
snprintf(inbox, sizeof(inbox), ""%s!"", userid+userlen+1);
if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {
tmpuser = xmalloc(userlen);
memcpy(tmpuser, userid, userlen);
t = tmpuser + (p - userid);
while(t < (tmpuser + userlen)) {
if (*t == '.')
*t = '^';
t++;
}
inboxuser = tmpuser;
} else
inboxuser = userid;
snprintf(inbox+domainlen, sizeof(inbox)-domainlen,
""user.%.*s.INBOX."", (int)userlen, inboxuser);
free(tmpuser);
inboxlen = strlen(inbox) - 7;
}
else {
userid = 0;
}
const char *firstpat = strarray_nth(patterns, 0);
for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {
if (prefixlen >= MAX_MAILBOX_NAME) {
r = IMAP_MAILBOX_BADNAME;
goto done;
}
char c = firstpat[prefixlen];
for (i = 1; i < patterns->count; i++) {
const char *pat = strarray_nth(patterns, i);
if (pat[prefixlen] != c) break;
}
if (i < patterns->count) break;
if (c == '*' || c == '%' || c == '?') break;
commonpat[prefixlen] = c;
}
commonpat[prefixlen] = '\0';
if (patterns->count == 1) {
if (!strcmp(firstpat+prefixlen, ""%""))
rock->singlepercent = 2;
if (!strcmp(firstpat+prefixlen, ""*%""))
rock->singlepercent = 1;
}
if (userid && !isadmin) {
rock->mb_category = MBNAME_INBOX;
r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);
if (r == CYRUSDB_DONE) r = 0;
if (r) goto done;
if (rock->namespace->isalt) {
rock->mb_category = MBNAME_INBOXSUB;
r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);
if (r == CYRUSDB_DONE) r = 0;
if (r) goto done;
r = (*rock->proc)(NULL, rock->procrock);
if (r) goto done;
}
rock->mb_category = MBNAME_OWNER;
r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);
if (r == CYRUSDB_DONE) r = 0;
if (r) goto done;
if (rock->namespace->isalt) {
r = (*rock->proc)(NULL, rock->procrock);
if (r) goto done;
rock->mb_category = MBNAME_ALTINBOX;
r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);
if (r == CYRUSDB_DONE) goto skipalt;
if (r) goto done;
rock->mb_category = MBNAME_ALTPREFIX;
r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);
skipalt: 
if (r == CYRUSDB_DONE) r = 0;
if (r) goto done;
}
}
if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {
len = strlen(rock->namespace->prefix[NAMESPACE_USER]);
if (len) len--; 
if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {
if (prefixlen < len) {
strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
}
else {
strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);
}
rock->mb_category = MBNAME_OTHERUSER;
size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);
r = (*rock->proc)(NULL, rock->procrock);
if (r) goto done;
r = mboxlist_find_category(rock, domainpat, thislen);
if (r) goto done;
}
}
if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {
len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);
if (len) len--; 
if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {
rock->mb_category = MBNAME_SHARED;
r = (*rock->proc)(NULL, rock->procrock);
if (r) goto done;
r = mboxlist_find_category(rock, domainpat, domainlen);
if (r) goto done;
}
}
r = (*rock->proc)(NULL, rock->procrock);
done:
for (i = 0; i < rock->globs.count; i++) {
glob *g = ptrarray_nth(&rock->globs, i);
glob_free(&g);
}
ptrarray_fini(&rock->globs);
return r;
}","static int mboxlist_do_find(struct find_rock *VAR_0, const strarray_t *VAR_1)
{
const char *VAR_2 = VAR_0->userid;
int VAR_3 = VAR_0->isadmin;
int VAR_4 = config_getswitch(VAR_5);
char VAR_6[VAR_7];
size_t VAR_8 = 0;
size_t VAR_9, VAR_10;
size_t VAR_11 = 0;
size_t VAR_12 = VAR_2 ? strlen(VAR_2) : 0;
char VAR_13[VAR_7]; 
char VAR_14[VAR_7];
int VAR_15 = 0;
int VAR_16;
const char *VAR_17;
if (VAR_1->count < 1) return 0; 
for (VAR_16 = 0; VAR_16 < VAR_1->count; VAR_16++) {
glob *VAR_18 = glob_init(strarray_nth(VAR_1, VAR_16), VAR_0->namespace->hier_sep);
ptrarray_append(&VAR_0->globs, VAR_18);
}
if (VAR_19 && VAR_2 && (VAR_17 = strchr(VAR_2, '@'))) {
VAR_12 = VAR_17 - VAR_2;
VAR_11 = strlen(VAR_17); 
snprintf(VAR_13, sizeof(VAR_13), ""%s!"", VAR_17+1);
}
else
VAR_13[0] = '\0';
if (VAR_2 && (!(VAR_17 = strchr(VAR_2, VAR_0->namespace->hier_sep)) ||
((VAR_17 - VAR_2) > (int)VAR_12)) &&
strlen(VAR_2)+7 < VAR_7) {
char *VAR_20, *VAR_21 = NULL;
const char *VAR_22;
if (VAR_11)
snprintf(VAR_6, sizeof(VAR_6), ""%s!"", VAR_2+VAR_12+1);
if (VAR_0->namespace->hier_sep == '/' && (VAR_17 = strchr(VAR_2, '.'))) {
VAR_21 = xmalloc(VAR_12);
memcpy(VAR_21, VAR_2, VAR_12);
VAR_20 = VAR_21 + (VAR_17 - VAR_2);
while(VAR_20 < (VAR_21 + VAR_12)) {
if (*VAR_20 == '.')
*VAR_20 = '^';
VAR_20++;
}
VAR_22 = VAR_21;
} else
VAR_22 = VAR_2;
snprintf(VAR_6+VAR_11, sizeof(VAR_6)-VAR_11,
""user.%.*s.INBOX."", (int)VAR_12, VAR_22);
free(VAR_21);
VAR_8 = strlen(VAR_6) - 7;
}
else {
VAR_2 = 0;
}
const char *VAR_23 = strarray_nth(VAR_1, 0);
for (VAR_9 = 0; VAR_23[VAR_9]; VAR_9++) {
if (VAR_9 >= VAR_24) {
VAR_15 = VAR_25;
goto done;
}
char VAR_26 = VAR_23[VAR_9];
for (VAR_16 = 1; VAR_16 < VAR_1->count; VAR_16++) {
const char *VAR_27 = strarray_nth(VAR_1, VAR_16);
if (VAR_27[VAR_9] != VAR_26) break;
}
if (VAR_16 < VAR_1->count) break;
if (VAR_26 == '*' || VAR_26 == '%' || VAR_26 == '?') break;
VAR_14[VAR_9] = VAR_26;
}
VAR_14[VAR_9] = '\0';
if (VAR_1->count == 1) {
if (!strcmp(VAR_23+VAR_9, ""%""))
VAR_0->singlepercent = 2;
if (!strcmp(VAR_23+VAR_9, ""*%""))
VAR_0->singlepercent = 1;
}
if (VAR_2 && !VAR_3) {
VAR_0->mb_category = VAR_28;
VAR_15 = cyrusdb_forone(VAR_0->db, VAR_6, VAR_8, &VAR_29, &VAR_30, VAR_0, NULL);
if (VAR_15 == VAR_31) VAR_15 = 0;
if (VAR_15) goto done;
if (VAR_0->namespace->isalt) {
VAR_0->mb_category = VAR_32;
VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+7, &VAR_29, &VAR_30, VAR_0, NULL);
if (VAR_15 == VAR_31) VAR_15 = 0;
if (VAR_15) goto done;
VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
if (VAR_15) goto done;
}
VAR_0->mb_category = VAR_33;
VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+1, &VAR_29, &VAR_30, VAR_0, NULL);
if (VAR_15 == VAR_31) VAR_15 = 0;
if (VAR_15) goto done;
if (VAR_0->namespace->isalt) {
VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
if (VAR_15) goto done;
VAR_0->mb_category = VAR_34;
VAR_15 = cyrusdb_forone(VAR_0->db, VAR_6, VAR_8+6, &VAR_29, &VAR_30, VAR_0, NULL);
if (VAR_15 == VAR_31) goto skipalt;
if (VAR_15) goto done;
VAR_0->mb_category = VAR_35;
VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+1, &VAR_29, &VAR_30, VAR_0, NULL);
skipalt: 
if (VAR_15 == VAR_31) VAR_15 = 0;
if (VAR_15) goto done;
}
}
if (VAR_3 || VAR_0->namespace->accessible[VAR_36]) {
VAR_10 = strlen(VAR_0->namespace->prefix[VAR_36]);
if (VAR_10) VAR_10--; 
if (!strncmp(VAR_0->namespace->prefix[VAR_36], VAR_14, MIN(VAR_10, VAR_9))) {
if (VAR_9 < VAR_10) {
strlcpy(VAR_13+VAR_11, ""user."", sizeof(VAR_13)-VAR_11);
}
else {
strlcpy(VAR_13+VAR_11, ""user."", sizeof(VAR_13)-VAR_11);
strlcpy(VAR_13+VAR_11+5, VAR_14+VAR_10+1, sizeof(VAR_13)-VAR_11-5);
}
VAR_0->mb_category = VAR_37;
size_t VAR_38 = (VAR_3 || VAR_4) ? 0 : strlen(VAR_13);
VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
if (VAR_15) goto done;
VAR_15 = mboxlist_find_category(VAR_0, VAR_13, VAR_38);
if (VAR_15) goto done;
}
}
if (VAR_3 || VAR_0->namespace->accessible[VAR_39]) {
VAR_10 = strlen(VAR_0->namespace->prefix[VAR_39]);
if (VAR_10) VAR_10--; 
if (!strncmp(VAR_0->namespace->prefix[VAR_39], VAR_14, MIN(VAR_10, VAR_9))) {
VAR_0->mb_category = VAR_40;
VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
if (VAR_15) goto done;
VAR_15 = mboxlist_find_category(VAR_0, VAR_13, VAR_11);
if (VAR_15) goto done;
}
}
VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
done:
for (VAR_16 = 0; VAR_16 < VAR_0->globs.count; VAR_16++) {
glob *VAR_18 = ptrarray_nth(&VAR_0->globs, VAR_16);
glob_free(&VAR_18);
}
ptrarray_fini(&VAR_0->globs);
return VAR_15;
}",cyrusimap/cyrus-imapd/6bd33275368edfa71ae117de895488584678ac79/mboxlist.c/vul/before/0.json,"static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)
{
    const char *userid = rock->userid;
    int isadmin = rock->isadmin;

    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);
    char inbox[MAX_MAILBOX_BUFFER];
    size_t inboxlen = 0;
    size_t prefixlen, len;
    size_t domainlen = 0;
    size_t userlen = userid ? strlen(userid) : 0;
    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */
    char commonpat[MAX_MAILBOX_BUFFER];
    int r = 0;
    int i;
    const char *p;

    if (patterns->count < 1) return 0; /* nothing to do */

    for (i = 0; i < patterns->count; i++) {
        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);
        ptrarray_append(&rock->globs, g);
    }

    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {
        userlen = p - userid;
        domainlen = strlen(p); /* includes separator */
        snprintf(domainpat, sizeof(domainpat), ""%s!"", p+1);
    }
    else
        domainpat[0] = '\0';

    /* calculate the inbox (with trailing .INBOX. for later use) */
    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||
        ((p - userid) > (int)userlen)) &&
        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {
        char *t, *tmpuser = NULL;
        const char *inboxuser;

        if (domainlen)
            snprintf(inbox, sizeof(inbox), ""%s!"", userid+userlen+1);
        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {
            tmpuser = xmalloc(userlen);
            memcpy(tmpuser, userid, userlen);
            t = tmpuser + (p - userid);
            while(t < (tmpuser + userlen)) {
                if (*t == '.')
                    *t = '^';
                t++;
            }
            inboxuser = tmpuser;
        } else
            inboxuser = userid;
        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,
                 ""user.%.*s.INBOX."", (int)userlen, inboxuser);
        free(tmpuser);
        inboxlen = strlen(inbox) - 7;
    }
    else {
        userid = 0;
    }

    /* Find the common search prefix of all patterns */
    const char *firstpat = strarray_nth(patterns, 0);
    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {
        if (prefixlen >= MAX_MAILBOX_NAME) {
            r = IMAP_MAILBOX_BADNAME;
            goto done;
        }
        char c = firstpat[prefixlen];
        for (i = 1; i < patterns->count; i++) {
            const char *pat = strarray_nth(patterns, i);
            if (pat[prefixlen] != c) break;
        }
        if (i < patterns->count) break;
        if (c == '*' || c == '%' || c == '?') break;
        commonpat[prefixlen] = c;
    }
    commonpat[prefixlen] = '\0';

    if (patterns->count == 1) {
        /* Skip pattern which matches shared namespace prefix */
        if (!strcmp(firstpat+prefixlen, ""%""))
            rock->singlepercent = 2;
        /* output prefix regardless */
        if (!strcmp(firstpat+prefixlen, ""*%""))
            rock->singlepercent = 1;
    }

    /*
     * Personal (INBOX) namespace (only if not admin)
     */
    if (userid && !isadmin) {
        /* first the INBOX */
        rock->mb_category = MBNAME_INBOX;
        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);
        if (r == CYRUSDB_DONE) r = 0;
        if (r) goto done;

        if (rock->namespace->isalt) {
            /* do exact INBOX subs before resetting the namebuffer */
            rock->mb_category = MBNAME_INBOXSUB;
            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);
            if (r == CYRUSDB_DONE) r = 0;
            if (r) goto done;

            /* reset the the namebuffer */
            r = (*rock->proc)(NULL, rock->procrock);
            if (r) goto done;
        }

        /* iterate through all the mailboxes under the user's inbox */
        rock->mb_category = MBNAME_OWNER;
        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);
        if (r == CYRUSDB_DONE) r = 0;
        if (r) goto done;

        /* ""Alt Prefix"" folders */
        if (rock->namespace->isalt) {
            /* reset the the namebuffer */
            r = (*rock->proc)(NULL, rock->procrock);
            if (r) goto done;

            rock->mb_category = MBNAME_ALTINBOX;

            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could
             return DONE, in which case we don't need to foreach the rest of the
             altprefix space */
            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);
            if (r == CYRUSDB_DONE) goto skipalt;
            if (r) goto done;

            /* special case any other altprefix stuff */
            rock->mb_category = MBNAME_ALTPREFIX;
            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);
        skipalt: /* we got a done, so skip out of the foreach early */
            if (r == CYRUSDB_DONE) r = 0;
            if (r) goto done;
        }
    }

    /*
     * Other Users namespace
     *
     * If ""Other Users*"" can match pattern, search for those mailboxes next
     */
    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {
        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);
        if (len) len--; // trailing separator

        if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {
            if (prefixlen <= len) {
                /* we match all users */
                strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
            }
            else {
                /* just those in this prefix */
                strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);
            }

            rock->mb_category = MBNAME_OTHERUSER;

            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */
            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);

            /* reset the the namebuffer */
            r = (*rock->proc)(NULL, rock->procrock);
            if (r) goto done;

            r = mboxlist_find_category(rock, domainpat, thislen);
            if (r) goto done;
        }
    }

    /*
     * Shared namespace
     *
     * search for all remaining mailboxes.
     * just bother looking at the ones that have the same pattern prefix.
     */
    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {
        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);
        if (len) len--; // trailing separator

        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {
            rock->mb_category = MBNAME_SHARED;

            /* reset the the namebuffer */
            r = (*rock->proc)(NULL, rock->procrock);
            if (r) goto done;

            /* iterate through all the non-user folders on the server */
            r = mboxlist_find_category(rock, domainpat, domainlen);
            if (r) goto done;
        }
    }

    /* finish with a reset call always */
    r = (*rock->proc)(NULL, rock->procrock);

 done:
    for (i = 0; i < rock->globs.count; i++) {
        glob *g = ptrarray_nth(&rock->globs, i);
        glob_free(&g);
    }
    ptrarray_fini(&rock->globs);

    return r;
}","static int mboxlist_do_find(struct find_rock *VAR_0, const strarray_t *VAR_1)
{
    const char *VAR_2 = VAR_0->userid;
    int VAR_3 = VAR_0->isadmin;

    int VAR_4 = config_getswitch(VAR_5);
    char VAR_6[VAR_7];
    size_t VAR_8 = 0;
    size_t VAR_9, VAR_10;
    size_t VAR_11 = 0;
    size_t VAR_12 = VAR_2 ? strlen(VAR_2) : 0;
    char VAR_13[VAR_7]; /* COMMENT_0 */
    char VAR_14[VAR_7];
    int VAR_15 = 0;
    int VAR_16;
    const char *VAR_17;

    if (VAR_1->count < 1) return 0; /* COMMENT_1 */

    for (VAR_16 = 0; VAR_16 < VAR_1->count; VAR_16++) {
        glob *VAR_18 = glob_init(strarray_nth(VAR_1, VAR_16), VAR_0->namespace->hier_sep);
        ptrarray_append(&VAR_0->globs, VAR_18);
    }

    if (VAR_19 && VAR_2 && (VAR_17 = strchr(VAR_2, '@'))) {
        VAR_12 = VAR_17 - VAR_2;
        VAR_11 = strlen(VAR_17); /* COMMENT_2 */
        snprintf(VAR_13, sizeof(VAR_13), ""%s!"", VAR_17+1);
    }
    else
        VAR_13[0] = '\0';

    /* COMMENT_3 */
    if (VAR_2 && (!(VAR_17 = strchr(VAR_2, VAR_0->namespace->hier_sep)) ||
        ((VAR_17 - VAR_2) > (int)VAR_12)) &&
        strlen(VAR_2)+7 < VAR_7) {
        char *VAR_20, *VAR_21 = NULL;
        const char *VAR_22;

        if (VAR_11)
            snprintf(VAR_6, sizeof(VAR_6), ""%s!"", VAR_2+VAR_12+1);
        if (VAR_0->namespace->hier_sep == '/' && (VAR_17 = strchr(VAR_2, '.'))) {
            VAR_21 = xmalloc(VAR_12);
            memcpy(VAR_21, VAR_2, VAR_12);
            VAR_20 = VAR_21 + (VAR_17 - VAR_2);
            while(VAR_20 < (VAR_21 + VAR_12)) {
                if (*VAR_20 == '.')
                    *VAR_20 = '^';
                VAR_20++;
            }
            VAR_22 = VAR_21;
        } else
            VAR_22 = VAR_2;
        snprintf(VAR_6+VAR_11, sizeof(VAR_6)-VAR_11,
                 ""user.%.*s.INBOX."", (int)VAR_12, VAR_22);
        free(VAR_21);
        VAR_8 = strlen(VAR_6) - 7;
    }
    else {
        VAR_2 = 0;
    }

    /* COMMENT_4 */
    const char *VAR_23 = strarray_nth(VAR_1, 0);
    for (VAR_9 = 0; VAR_23[VAR_9]; VAR_9++) {
        if (VAR_9 >= VAR_24) {
            VAR_15 = VAR_25;
            goto done;
        }
        char VAR_26 = VAR_23[VAR_9];
        for (VAR_16 = 1; VAR_16 < VAR_1->count; VAR_16++) {
            const char *VAR_27 = strarray_nth(VAR_1, VAR_16);
            if (VAR_27[VAR_9] != VAR_26) break;
        }
        if (VAR_16 < VAR_1->count) break;
        if (VAR_26 == '*' || VAR_26 == '%' || VAR_26 == '?') break;
        VAR_14[VAR_9] = VAR_26;
    }
    VAR_14[VAR_9] = '\0';

    if (VAR_1->count == 1) {
        /* COMMENT_5 */
        if (!strcmp(VAR_23+VAR_9, ""%""))
            VAR_0->singlepercent = 2;
        /* COMMENT_6 */
        if (!strcmp(VAR_23+VAR_9, ""*%""))
            VAR_0->singlepercent = 1;
    }

    /* COMMENT_7 */
                                                     
       
    if (VAR_2 && !VAR_3) {
        /* COMMENT_10 */
        VAR_0->mb_category = VAR_28;
        VAR_15 = cyrusdb_forone(VAR_0->db, VAR_6, VAR_8, &VAR_29, &VAR_30, VAR_0, NULL);
        if (VAR_15 == VAR_31) VAR_15 = 0;
        if (VAR_15) goto done;

        if (VAR_0->namespace->isalt) {
            /* COMMENT_11 */
            VAR_0->mb_category = VAR_32;
            VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+7, &VAR_29, &VAR_30, VAR_0, NULL);
            if (VAR_15 == VAR_31) VAR_15 = 0;
            if (VAR_15) goto done;

            /* COMMENT_12 */
            VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
            if (VAR_15) goto done;
        }

        /* COMMENT_13 */
        VAR_0->mb_category = VAR_33;
        VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+1, &VAR_29, &VAR_30, VAR_0, NULL);
        if (VAR_15 == VAR_31) VAR_15 = 0;
        if (VAR_15) goto done;

        /* COMMENT_14 */
        if (VAR_0->namespace->isalt) {
            /* COMMENT_12 */
            VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
            if (VAR_15) goto done;

            VAR_0->mb_category = VAR_34;

            /* COMMENT_15 */
                                                                                
                               
            VAR_15 = cyrusdb_forone(VAR_0->db, VAR_6, VAR_8+6, &VAR_29, &VAR_30, VAR_0, NULL);
            if (VAR_15 == VAR_31) goto skipalt;
            if (VAR_15) goto done;

            /* COMMENT_18 */
            VAR_0->mb_category = VAR_35;
            VAR_15 = cyrusdb_foreach(VAR_0->db, VAR_6, VAR_8+1, &VAR_29, &VAR_30, VAR_0, NULL);
        skipalt: /* COMMENT_19 */
            if (VAR_15 == VAR_31) VAR_15 = 0;
            if (VAR_15) goto done;
        }
    }

    /* COMMENT_20 */
                            
      
                                                                           
       
    if (VAR_3 || VAR_0->namespace->accessible[VAR_36]) {
        VAR_10 = strlen(VAR_0->namespace->prefix[VAR_36]);
        if (VAR_10) VAR_10--; /* COMMENT_25 */

        if (!strncmp(VAR_0->namespace->prefix[VAR_36], VAR_14, MIN(VAR_10, VAR_9))) {
            if (VAR_9 <= VAR_10) {
                /* COMMENT_26 */
                strlcpy(VAR_13+VAR_11, ""user."", sizeof(VAR_13)-VAR_11);
            }
            else {
                /* COMMENT_27 */
                strlcpy(VAR_13+VAR_11, ""user."", sizeof(VAR_13)-VAR_11);
                strlcpy(VAR_13+VAR_11+5, VAR_14+VAR_10+1, sizeof(VAR_13)-VAR_11-5);
            }

            VAR_0->mb_category = VAR_37;

            /* COMMENT_28 */
            size_t VAR_38 = (VAR_3 || VAR_4) ? 0 : strlen(VAR_13);

            /* COMMENT_12 */
            VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
            if (VAR_15) goto done;

            VAR_15 = mboxlist_find_category(VAR_0, VAR_13, VAR_38);
            if (VAR_15) goto done;
        }
    }

    /* COMMENT_29 */
                       
      
                                          
                                                                         
       
    if (VAR_3 || VAR_0->namespace->accessible[VAR_39]) {
        VAR_10 = strlen(VAR_0->namespace->prefix[VAR_39]);
        if (VAR_10) VAR_10--; /* COMMENT_25 */

        if (!strncmp(VAR_0->namespace->prefix[VAR_39], VAR_14, MIN(VAR_10, VAR_9))) {
            VAR_0->mb_category = VAR_40;

            /* COMMENT_12 */
            VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);
            if (VAR_15) goto done;

            /* COMMENT_35 */
            VAR_15 = mboxlist_find_category(VAR_0, VAR_13, VAR_11);
            if (VAR_15) goto done;
        }
    }

    /* COMMENT_36 */
    VAR_15 = (*VAR_0->proc)(NULL, VAR_0->procrock);

 done:
    for (VAR_16 = 0; VAR_16 < VAR_0->globs.count; VAR_16++) {
        glob *VAR_18 = ptrarray_nth(&VAR_0->globs, VAR_16);
        glob_free(&VAR_18);
    }
    ptrarray_fini(&VAR_0->globs);

    return VAR_15;
}",cyrusimap/cyrus-imapd/6bd33275368edfa71ae117de895488584678ac79/mboxlist.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -149,7 +149,7 @@
         if (len) len--; // trailing separator
 
         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {
-            if (prefixlen < len) {
+            if (prefixlen <= len) {
                 /* we match all users */
                 strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
             }","{'deleted_lines': ['            if (prefixlen < len) {'], 'added_lines': ['            if (prefixlen <= len) {']}",True,"In the mboxlist_do_find function in imap/mboxlist.c in Cyrus IMAP before 3.0.4, an off-by-one error in prefix calculation for the LIST command caused use of uninitialized memory, which might allow remote attackers to obtain sensitive information or cause a denial of service (daemon crash) via a 'LIST """" ""Other Users""' command.",9.1,CRITICAL,3,valid,2017-08-31T02:43:09Z,2
CVE-2018-14468,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,the-tcpdump-group/tcpdump,"(for 4.9.3) CVE-2018-14468/FRF.16: Add a missing length check.

The specification says in a well-formed Magic Number information element
the data is exactly 4 bytes long. In mfr_print() check this before trying
to read those 4 bytes.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",aa3e54f594385ce7e1e319b0c84999e51192578b,https://github.com/the-tcpdump-group/tcpdump/commit/aa3e54f594385ce7e1e319b0c84999e51192578b,print-fr.c,mfr_print,"u_int
mfr_print(netdissect_options *ndo,
register const u_char *p, u_int length)
{
u_int tlen,idx,hdr_len = 0;
uint16_t sequence_num;
uint8_t ie_type,ie_len;
const uint8_t *tptr;
ND_TCHECK2(*p, 4); 
if ((p[0] & MFR_BEC_MASK) == MFR_CTRL_FRAME && p[1] == 0) {
ND_PRINT((ndo, ""FRF.16 Control, Flags [%s], %s, length %u"",
bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK)),
tok2str(mfr_ctrl_msg_values,""Unknown Message (0x%02x)"",p[2]),
length));
tptr = p + 3;
tlen = length -3;
hdr_len = 3;
if (!ndo->ndo_vflag)
return hdr_len;
while (tlen>sizeof(struct ie_tlv_header_t)) {
ND_TCHECK2(*tptr, sizeof(struct ie_tlv_header_t));
ie_type=tptr[0];
ie_len=tptr[1];
ND_PRINT((ndo, ""\n\tIE %s (%u), length %u: "",
tok2str(mfr_ctrl_ie_values,""Unknown"",ie_type),
ie_type,
ie_len));
if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))
return hdr_len;
ND_TCHECK2(*tptr, ie_len);
tptr+=sizeof(struct ie_tlv_header_t);
ie_len-=sizeof(struct ie_tlv_header_t);
tlen-=sizeof(struct ie_tlv_header_t);
switch (ie_type) {
case MFR_CTRL_IE_MAGIC_NUM:
ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));
break;
case MFR_CTRL_IE_BUNDLE_ID: 
case MFR_CTRL_IE_LINK_ID:
for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {
if (*(tptr+idx) != 0) 
safeputchar(ndo, *(tptr + idx));
else
break;
}
break;
case MFR_CTRL_IE_TIMESTAMP:
if (ie_len == sizeof(struct timeval)) {
ts_print(ndo, (const struct timeval *)tptr);
break;
}
case MFR_CTRL_IE_VENDOR_EXT:
case MFR_CTRL_IE_CAUSE:
default:
if (ndo->ndo_vflag <= 1)
print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);
break;
}
if (ndo->ndo_vflag > 1 )
print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);
tlen-=ie_len;
tptr+=ie_len;
}
return hdr_len;
}
sequence_num = (p[0]&0x1e)<<7 | p[1];
if ((p[0] & MFR_BEC_MASK) == MFR_FRAG_FRAME ||
(p[0] & MFR_BEC_MASK) == MFR_B_BIT) {
ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s], "",
sequence_num,
bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
hdr_len = 2;
fr_print(ndo, p+hdr_len,length-hdr_len);
return hdr_len;
}
ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s]"",
sequence_num,
bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
print_unknown_data(ndo, p, ""\n\t"", length);
return hdr_len;
trunc:
ND_PRINT((ndo, ""[|mfr]""));
return length;
}","u_int
mfr_print(netdissect_options *VAR_0,
register const u_char *VAR_1, u_int VAR_2)
{
u_int VAR_3,VAR_4,VAR_5 = 0;
uint16_t VAR_6;
uint8_t VAR_7,VAR_8;
const uint8_t *VAR_9;
ND_TCHECK2(*VAR_1, 4); 
if ((VAR_1[0] & VAR_10) == VAR_11 && VAR_1[1] == 0) {
ND_PRINT((VAR_0, ""FRF.16 Control, Flags [%s], %s, length %u"",
bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10)),
tok2str(VAR_13,""Unknown Message (0x%02x)"",VAR_1[2]),
VAR_2));
VAR_9 = VAR_1 + 3;
VAR_3 = VAR_2 -3;
VAR_5 = 3;
if (!VAR_0->ndo_vflag)
return VAR_5;
while (VAR_3>sizeof(struct ie_tlv_header_t)) {
ND_TCHECK2(*VAR_9, sizeof(struct ie_tlv_header_t));
VAR_7=VAR_9[0];
VAR_8=VAR_9[1];
ND_PRINT((VAR_0, ""\n\tIE %s (%u), length %u: "",
tok2str(VAR_14,""Unknown"",VAR_7),
VAR_7,
VAR_8));
if (VAR_7 == 0 || VAR_8 <= sizeof(struct ie_tlv_header_t))
return VAR_5;
ND_TCHECK2(*VAR_9, VAR_8);
VAR_9+=sizeof(struct ie_tlv_header_t);
VAR_8-=sizeof(struct ie_tlv_header_t);
VAR_3-=sizeof(struct ie_tlv_header_t);
switch (VAR_7) {
case VAR_15:
ND_PRINT((VAR_0, ""0x%08x"", EXTRACT_32BITS(VAR_9)));
break;
case VAR_16: 
case VAR_17:
for (VAR_4 = 0; VAR_4 < VAR_8 && VAR_4 < VAR_18; VAR_4++) {
if (*(VAR_9+VAR_4) != 0) 
safeputchar(VAR_0, *(VAR_9 + VAR_4));
else
break;
}
break;
case VAR_19:
if (VAR_8 == sizeof(struct timeval)) {
ts_print(VAR_0, (const struct timeval *)VAR_9);
break;
}
case VAR_20:
case VAR_21:
default:
if (VAR_0->ndo_vflag <= 1)
print_unknown_data(VAR_0, VAR_9, ""\n\t  "", VAR_8);
break;
}
if (VAR_0->ndo_vflag > 1 )
print_unknown_data(VAR_0, VAR_9, ""\n\t  "", VAR_8);
VAR_3-=VAR_8;
VAR_9+=VAR_8;
}
return VAR_5;
}
VAR_6 = (VAR_1[0]&0x1e)<<7 | VAR_1[1];
if ((VAR_1[0] & VAR_10) == VAR_22 ||
(VAR_1[0] & VAR_10) == VAR_23) {
ND_PRINT((VAR_0, ""FRF.16 Frag, seq %u, Flags [%s], "",
VAR_6,
bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10))));
VAR_5 = 2;
fr_print(VAR_0, VAR_1+VAR_5,VAR_2-VAR_5);
return VAR_5;
}
ND_PRINT((VAR_0, ""FRF.16 Frag, seq %u, Flags [%s]"",
VAR_6,
bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10))));
print_unknown_data(VAR_0, VAR_1, ""\n\t"", VAR_2);
return VAR_5;
trunc:
ND_PRINT((VAR_0, ""[|mfr]""));
return VAR_2;
}",the-tcpdump-group/tcpdump/aa3e54f594385ce7e1e319b0c84999e51192578b/print-fr.c/vul/before/0.json,"u_int
mfr_print(netdissect_options *ndo,
          register const u_char *p, u_int length)
{
    u_int tlen,idx,hdr_len = 0;
    uint16_t sequence_num;
    uint8_t ie_type,ie_len;
    const uint8_t *tptr;


/*
 * FRF.16 Link Integrity Control Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=1| 0    0    0    0  | EA |
 *    +----+----+----+----+----+----+----+----+
 *    | 0    0    0    0    0    0    0    0  |
 *    +----+----+----+----+----+----+----+----+
 *    |              message type             |
 *    +----+----+----+----+----+----+----+----+
 */

    ND_TCHECK2(*p, 4); /* minimum frame header length */

    if ((p[0] & MFR_BEC_MASK) == MFR_CTRL_FRAME && p[1] == 0) {
        ND_PRINT((ndo, ""FRF.16 Control, Flags [%s], %s, length %u"",
               bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK)),
               tok2str(mfr_ctrl_msg_values,""Unknown Message (0x%02x)"",p[2]),
               length));
        tptr = p + 3;
        tlen = length -3;
        hdr_len = 3;

        if (!ndo->ndo_vflag)
            return hdr_len;

        while (tlen>sizeof(struct ie_tlv_header_t)) {
            ND_TCHECK2(*tptr, sizeof(struct ie_tlv_header_t));
            ie_type=tptr[0];
            ie_len=tptr[1];

            ND_PRINT((ndo, ""\n\tIE %s (%u), length %u: "",
                   tok2str(mfr_ctrl_ie_values,""Unknown"",ie_type),
                   ie_type,
                   ie_len));

            /* infinite loop check */
            if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))
                return hdr_len;

            ND_TCHECK2(*tptr, ie_len);
            tptr+=sizeof(struct ie_tlv_header_t);
            /* tlv len includes header */
            ie_len-=sizeof(struct ie_tlv_header_t);
            tlen-=sizeof(struct ie_tlv_header_t);

            switch (ie_type) {

            case MFR_CTRL_IE_MAGIC_NUM:
                /* FRF.16.1 Section 3.4.3 Magic Number Information Element */
                if (ie_len != 4) {
                    ND_PRINT((ndo, ""(invalid length)""));
                    break;
                }
                ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));
                break;

            case MFR_CTRL_IE_BUNDLE_ID: /* same message format */
            case MFR_CTRL_IE_LINK_ID:
                for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {
                    if (*(tptr+idx) != 0) /* don't print null termination */
                        safeputchar(ndo, *(tptr + idx));
                    else
                        break;
                }
                break;

            case MFR_CTRL_IE_TIMESTAMP:
                if (ie_len == sizeof(struct timeval)) {
                    ts_print(ndo, (const struct timeval *)tptr);
                    break;
                }
                /* fall through and hexdump if no unix timestamp */

                /*
                 * FIXME those are the defined IEs that lack a decoder
                 * you are welcome to contribute code ;-)
                 */

            case MFR_CTRL_IE_VENDOR_EXT:
            case MFR_CTRL_IE_CAUSE:

            default:
                if (ndo->ndo_vflag <= 1)
                    print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);
                break;
            }

            /* do we want to see a hexdump of the IE ? */
            if (ndo->ndo_vflag > 1 )
                print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);

            tlen-=ie_len;
            tptr+=ie_len;
        }
        return hdr_len;
    }
/*
 * FRF.16 Fragmentation Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=0|seq. (high 4 bits) | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 */

    sequence_num = (p[0]&0x1e)<<7 | p[1];
    /* whole packet or first fragment ? */
    if ((p[0] & MFR_BEC_MASK) == MFR_FRAG_FRAME ||
        (p[0] & MFR_BEC_MASK) == MFR_B_BIT) {
        ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s], "",
               sequence_num,
               bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
        hdr_len = 2;
        fr_print(ndo, p+hdr_len,length-hdr_len);
        return hdr_len;
    }

    /* must be a middle or the last fragment */
    ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s]"",
           sequence_num,
           bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
    print_unknown_data(ndo, p, ""\n\t"", length);

    return hdr_len;

 trunc:
    ND_PRINT((ndo, ""[|mfr]""));
    return length;
}","u_int
mfr_print(netdissect_options *VAR_0,
          register const u_char *VAR_1, u_int VAR_2)
{
    u_int VAR_3,VAR_4,VAR_5 = 0;
    uint16_t VAR_6;
    uint8_t VAR_7,VAR_8;
    const uint8_t *VAR_9;


/* COMMENT_0 */
                                      
  
                                            
                                               
                                               
                                               
                                               
                                               
                                               
                                               
   

    ND_TCHECK2(*VAR_1, 4); /* COMMENT_9 */

    if ((VAR_1[0] & VAR_10) == VAR_11 && VAR_1[1] == 0) {
        ND_PRINT((VAR_0, ""FRF.16 Control, Flags [%s], %s, length %u"",
               bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10)),
               tok2str(VAR_13,""Unknown Message (0x%02x)"",VAR_1[2]),
               VAR_2));
        VAR_9 = VAR_1 + 3;
        VAR_3 = VAR_2 -3;
        VAR_5 = 3;

        if (!VAR_0->ndo_vflag)
            return VAR_5;

        while (VAR_3>sizeof(struct ie_tlv_header_t)) {
            ND_TCHECK2(*VAR_9, sizeof(struct ie_tlv_header_t));
            VAR_7=VAR_9[0];
            VAR_8=VAR_9[1];

            ND_PRINT((VAR_0, ""\n\tIE %s (%u), length %u: "",
                   tok2str(VAR_14,""Unknown"",VAR_7),
                   VAR_7,
                   VAR_8));

            /* COMMENT_10 */
            if (VAR_7 == 0 || VAR_8 <= sizeof(struct ie_tlv_header_t))
                return VAR_5;

            ND_TCHECK2(*VAR_9, VAR_8);
            VAR_9+=sizeof(struct ie_tlv_header_t);
            /* COMMENT_11 */
            VAR_8-=sizeof(struct ie_tlv_header_t);
            VAR_3-=sizeof(struct ie_tlv_header_t);

            switch (VAR_7) {

            case VAR_15:
                /* COMMENT_12 */
                if (VAR_8 != 4) {
                    ND_PRINT((VAR_0, ""(invalid length)""));
                    break;
                }
                ND_PRINT((VAR_0, ""0x%08x"", EXTRACT_32BITS(VAR_9)));
                break;

            case VAR_16: /* COMMENT_13 */
            case VAR_17:
                for (VAR_4 = 0; VAR_4 < VAR_8 && VAR_4 < VAR_18; VAR_4++) {
                    if (*(VAR_9+VAR_4) != 0) /* COMMENT_14 */
                        safeputchar(VAR_0, *(VAR_9 + VAR_4));
                    else
                        break;
                }
                break;

            case VAR_19:
                if (VAR_8 == sizeof(struct timeval)) {
                    ts_print(VAR_0, (const struct timeval *)VAR_9);
                    break;
                }
                /* COMMENT_15 */

                /* COMMENT_16 */
                                                                      
                                                         
                   

            case VAR_20:
            case VAR_21:

            default:
                if (VAR_0->ndo_vflag <= 1)
                    print_unknown_data(VAR_0, VAR_9, ""\n\t  "", VAR_8);
                break;
            }

            /* COMMENT_20 */
            if (VAR_0->ndo_vflag > 1 )
                print_unknown_data(VAR_0, VAR_9, ""\n\t  "", VAR_8);

            VAR_3-=VAR_8;
            VAR_9+=VAR_8;
        }
        return VAR_5;
    }
/* COMMENT_21 */
                             
  
                                            
                                               
                                                
                                               
                                               
                                               
                                                
                                               
                                               
                                               
   

    VAR_6 = (VAR_1[0]&0x1e)<<7 | VAR_1[1];
    /* COMMENT_31 */
    if ((VAR_1[0] & VAR_10) == VAR_22 ||
        (VAR_1[0] & VAR_10) == VAR_23) {
        ND_PRINT((VAR_0, ""FRF.16 Frag, seq %u, Flags [%s], "",
               VAR_6,
               bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10))));
        VAR_5 = 2;
        fr_print(VAR_0, VAR_1+VAR_5,VAR_2-VAR_5);
        return VAR_5;
    }

    /* COMMENT_32 */
    ND_PRINT((VAR_0, ""FRF.16 Frag, seq %u, Flags [%s]"",
           VAR_6,
           bittok2str(VAR_12,""none"",(VAR_1[0] & VAR_10))));
    print_unknown_data(VAR_0, VAR_1, ""\n\t"", VAR_2);

    return VAR_5;

 trunc:
    ND_PRINT((VAR_0, ""[|mfr]""));
    return VAR_2;
}",the-tcpdump-group/tcpdump/aa3e54f594385ce7e1e319b0c84999e51192578b/print-fr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,6 +58,11 @@
             switch (ie_type) {
 
             case MFR_CTRL_IE_MAGIC_NUM:
+                /* FRF.16.1 Section 3.4.3 Magic Number Information Element */
+                if (ie_len != 4) {
+                    ND_PRINT((ndo, ""(invalid length)""));
+                    break;
+                }
                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));
                 break;
 ","{'deleted_lines': [], 'added_lines': ['                /* FRF.16.1 Section 3.4.3 Magic Number Information Element */', '                if (ie_len != 4) {', '                    ND_PRINT((ndo, ""(invalid length)""));', '                    break;', '                }']}",True,The FRF.16 parser in tcpdump before 4.9.3 has a buffer over-read in print-fr.c:mfr_print().,7.5,HIGH,2,valid,2017-09-01T16:55:39Z,2
CVE-2017-14502,"['CWE-193', 'CWE-125']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,libarchive,"Avoid a read off-by-one error for UTF16 names in RAR archives.

Reported-By: OSS-Fuzz issue 573",5562545b5562f6d12a4ef991fae158bf4ccf92b6,https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6,libarchive/archive_read_support_format_rar.c,read_header,"static int
read_header(struct archive_read *a, struct archive_entry *entry,
char head_type)
{
const void *h;
const char *p, *endp;
struct rar *rar;
struct rar_header rar_header;
struct rar_file_header file_header;
int64_t header_size;
unsigned filename_size, end;
char *filename;
char *strp;
char packed_size[8];
char unp_size[8];
int ttime;
struct archive_string_conv *sconv, *fn_sconv;
unsigned long crc32_val;
int ret = (ARCHIVE_OK), ret2;
rar = (struct rar *)(a->format->data);
sconv = rar->opt_sconv;
if (sconv == NULL) {
if (!rar->init_default_conversion) {
rar->sconv_default =
archive_string_default_conversion_for_read(
&(a->archive));
rar->init_default_conversion = 1;
}
sconv = rar->sconv_default;
}
if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
p = h;
memcpy(&rar_header, p, sizeof(rar_header));
rar->file_flags = archive_le16dec(rar_header.flags);
header_size = archive_le16dec(rar_header.size);
if (header_size < (int64_t)sizeof(file_header) + 7) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
__archive_read_consume(a, 7);
if (!(rar->file_flags & FHD_SOLID))
{
rar->compression_method = 0;
rar->packed_size = 0;
rar->unp_size = 0;
rar->mtime = 0;
rar->ctime = 0;
rar->atime = 0;
rar->arctime = 0;
rar->mode = 0;
memset(&rar->salt, 0, sizeof(rar->salt));
rar->atime = 0;
rar->ansec = 0;
rar->ctime = 0;
rar->cnsec = 0;
rar->mtime = 0;
rar->mnsec = 0;
rar->arctime = 0;
rar->arcnsec = 0;
}
else
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""RAR solid archive support unavailable."");
return (ARCHIVE_FATAL);
}
if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Header CRC error"");
return (ARCHIVE_FATAL);
}
p = h;
endp = p + header_size - 7;
memcpy(&file_header, p, sizeof(file_header));
p += sizeof(file_header);
rar->compression_method = file_header.method;
ttime = archive_le32dec(file_header.file_time);
rar->mtime = get_time(ttime);
rar->file_crc = archive_le32dec(file_header.file_crc);
if (rar->file_flags & FHD_PASSWORD)
{
archive_entry_set_is_data_encrypted(entry, 1);
rar->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""RAR encryption support unavailable."");
}
if (rar->file_flags & FHD_LARGE)
{
memcpy(packed_size, file_header.pack_size, 4);
memcpy(packed_size + 4, p, 4); 
p += 4;
memcpy(unp_size, file_header.unp_size, 4);
memcpy(unp_size + 4, p, 4); 
p += 4;
rar->packed_size = archive_le64dec(&packed_size);
rar->unp_size = archive_le64dec(&unp_size);
}
else
{
rar->packed_size = archive_le32dec(file_header.pack_size);
rar->unp_size = archive_le32dec(file_header.unp_size);
}
if (rar->packed_size < 0 || rar->unp_size < 0)
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid sizes specified."");
return (ARCHIVE_FATAL);
}
rar->bytes_remaining = rar->packed_size;
if (head_type == NEWSUB_HEAD) {
size_t distance = p - (const char *)h;
header_size += rar->packed_size;
if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
p = h;
endp = p + header_size - 7;
p += distance;
}
filename_size = archive_le16dec(file_header.name_size);
if (p + filename_size > endp) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid filename size"");
return (ARCHIVE_FATAL);
}
if (rar->filename_allocated < filename_size * 2 + 2) {
char *newptr;
size_t newsize = filename_size * 2 + 2;
newptr = realloc(rar->filename, newsize);
if (newptr == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->filename = newptr;
rar->filename_allocated = newsize;
}
filename = rar->filename;
memcpy(filename, p, filename_size);
filename[filename_size] = '\0';
if (rar->file_flags & FHD_UNICODE)
{
if (filename_size != strlen(filename))
{
unsigned char highbyte, flagbits, flagbyte;
unsigned fn_end, offset;
end = filename_size;
fn_end = filename_size * 2;
filename_size = 0;
offset = (unsigned)strlen(filename) + 1;
highbyte = *(p + offset++);
flagbits = 0;
flagbyte = 0;
while (offset < end && filename_size < fn_end)
{
if (!flagbits)
{
flagbyte = *(p + offset++);
flagbits = 8;
}
flagbits -= 2;
switch((flagbyte >> flagbits) & 3)
{
case 0:
filename[filename_size++] = '\0';
filename[filename_size++] = *(p + offset++);
break;
case 1:
filename[filename_size++] = highbyte;
filename[filename_size++] = *(p + offset++);
break;
case 2:
filename[filename_size++] = *(p + offset + 1);
filename[filename_size++] = *(p + offset);
offset += 2;
break;
case 3:
{
char extra, high;
uint8_t length = *(p + offset++);
if (length & 0x80) {
extra = *(p + offset++);
high = (char)highbyte;
} else
extra = high = 0;
length = (length & 0x7f) + 2;
while (length && filename_size < fn_end) {
unsigned cp = filename_size >> 1;
filename[filename_size++] = high;
filename[filename_size++] = p[cp] + extra;
length--;
}
}
break;
}
}
if (filename_size > fn_end) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid filename"");
return (ARCHIVE_FATAL);
}
filename[filename_size++] = '\0';
filename[filename_size++] = '\0';
if (rar->sconv_utf16be == NULL) {
rar->sconv_utf16be = archive_string_conversion_from_charset(
&a->archive, ""UTF-16BE"", 1);
if (rar->sconv_utf16be == NULL)
return (ARCHIVE_FATAL);
}
fn_sconv = rar->sconv_utf16be;
strp = filename;
while (memcmp(strp, ""\x00\x00"", 2))
{
if (!memcmp(strp, ""\x00\\"", 2))
*(strp + 1) = '/';
strp += 2;
}
p += offset;
} else {
if (rar->sconv_utf8 == NULL) {
rar->sconv_utf8 = archive_string_conversion_from_charset(
&a->archive, ""UTF-8"", 1);
if (rar->sconv_utf8 == NULL)
return (ARCHIVE_FATAL);
}
fn_sconv = rar->sconv_utf8;
while ((strp = strchr(filename, '\\')) != NULL)
*strp = '/';
p += filename_size;
}
}
else
{
fn_sconv = sconv;
while ((strp = strchr(filename, '\\')) != NULL)
*strp = '/';
p += filename_size;
}
if (rar->filename_save &&
filename_size == rar->filename_save_size &&
!memcmp(rar->filename, rar->filename_save, filename_size + 1))
{
__archive_read_consume(a, header_size - 7);
rar->cursor++;
if (rar->cursor >= rar->nodes)
{
rar->nodes++;
if ((rar->dbo =
realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
{
archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->dbo[rar->cursor].header_size = header_size;
rar->dbo[rar->cursor].start_offset = -1;
rar->dbo[rar->cursor].end_offset = -1;
}
if (rar->dbo[rar->cursor].start_offset < 0)
{
rar->dbo[rar->cursor].start_offset = a->filter->position;
rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
rar->packed_size;
}
return ret;
}
rar->filename_save = (char*)realloc(rar->filename_save,
filename_size + 1);
memcpy(rar->filename_save, rar->filename, filename_size + 1);
rar->filename_save_size = filename_size;
free(rar->dbo);
if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
{
archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->dbo[0].header_size = header_size;
rar->dbo[0].start_offset = -1;
rar->dbo[0].end_offset = -1;
rar->cursor = 0;
rar->nodes = 1;
if (rar->file_flags & FHD_SALT)
{
if (p + 8 > endp) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
memcpy(rar->salt, p, 8);
p += 8;
}
if (rar->file_flags & FHD_EXTTIME) {
if (read_exttime(p, rar, endp) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
}
__archive_read_consume(a, header_size - 7);
rar->dbo[0].start_offset = a->filter->position;
rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
switch(file_header.host_os)
{
case OS_MSDOS:
case OS_OS2:
case OS_WIN32:
rar->mode = archive_le32dec(file_header.file_attr);
if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
else
rar->mode = AE_IFREG;
rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
break;
case OS_UNIX:
case OS_MAC_OS:
case OS_BEOS:
rar->mode = archive_le32dec(file_header.file_attr);
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unknown file attributes from RAR file's host OS"");
return (ARCHIVE_FATAL);
}
rar->bytes_uncopied = rar->bytes_unconsumed = 0;
rar->lzss.position = rar->offset = 0;
rar->offset_seek = 0;
rar->dictionary_size = 0;
rar->offset_outgoing = 0;
rar->br.cache_avail = 0;
rar->br.avail_in = 0;
rar->crc_calculated = 0;
rar->entry_eof = 0;
rar->valid = 1;
rar->is_ppmd_block = 0;
rar->start_new_table = 1;
free(rar->unp_buffer);
rar->unp_buffer = NULL;
rar->unp_offset = 0;
rar->unp_buffer_size = UNP_BUFFER_SIZE;
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);
rar->ppmd_valid = rar->ppmd_eod = 0;
if (head_type == NEWSUB_HEAD)
return ret;
archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
archive_entry_set_atime(entry, rar->atime, rar->ansec);
archive_entry_set_size(entry, rar->unp_size);
archive_entry_set_mode(entry, rar->mode);
if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
{
if (errno == ENOMEM)
{
archive_set_error(&a->archive, ENOMEM,
""Can't allocate memory for Pathname"");
return (ARCHIVE_FATAL);
}
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Pathname cannot be converted from %s to current locale."",
archive_string_conversion_charset_name(fn_sconv));
ret = (ARCHIVE_WARN);
}
if (((rar->mode) & AE_IFMT) == AE_IFLNK)
{
rar->bytes_remaining = 0;
archive_entry_set_size(entry, 0);
if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
return ret2;
if (ret > ret2)
ret = ret2;
}
if (rar->bytes_remaining == 0)
rar->entry_eof = 1;
return ret;
}","static int
read_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,
char VAR_2)
{
const void *VAR_3;
const char *VAR_4, *VAR_5;
struct rar *rar;
struct rar_header rar_header;
struct rar_file_header VAR_6;
int64_t VAR_7;
unsigned VAR_8, VAR_9;
char *VAR_10;
char *VAR_11;
char VAR_12[8];
char VAR_13[8];
int VAR_14;
struct archive_string_conv *VAR_15, *VAR_16;
unsigned long VAR_17;
int VAR_18 = (VAR_19), VAR_20;
rar = (struct rar *)(VAR_0->format->data);
VAR_15 = rar->opt_sconv;
if (VAR_15 == NULL) {
if (!rar->init_default_conversion) {
rar->sconv_default =
archive_string_default_conversion_for_read(
&(VAR_0->archive));
rar->init_default_conversion = 1;
}
VAR_15 = rar->sconv_default;
}
if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)
return (VAR_21);
VAR_4 = VAR_3;
memcpy(&rar_header, VAR_4, sizeof(rar_header));
rar->file_flags = archive_le16dec(rar_header.flags);
VAR_7 = archive_le16dec(rar_header.size);
if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);
__archive_read_consume(VAR_0, 7);
if (!(rar->file_flags & VAR_23))
{
rar->compression_method = 0;
rar->packed_size = 0;
rar->unp_size = 0;
rar->mtime = 0;
rar->ctime = 0;
rar->atime = 0;
rar->arctime = 0;
rar->mode = 0;
memset(&rar->salt, 0, sizeof(rar->salt));
rar->atime = 0;
rar->ansec = 0;
rar->ctime = 0;
rar->cnsec = 0;
rar->mtime = 0;
rar->mnsec = 0;
rar->arctime = 0;
rar->arcnsec = 0;
}
else
{
archive_set_error(&VAR_0->archive, VAR_22,
""RAR solid archive support unavailable."");
return (VAR_21);
}
if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
return (VAR_21);
VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));
if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {
archive_set_error(&VAR_0->archive, VAR_22,
""Header CRC error"");
return (VAR_21);
}
VAR_4 = VAR_3;
VAR_5 = VAR_4 + VAR_7 - 7;
memcpy(&VAR_6, VAR_4, sizeof(VAR_6));
VAR_4 += sizeof(VAR_6);
rar->compression_method = VAR_6.method;
VAR_14 = archive_le32dec(VAR_6.file_time);
rar->mtime = get_time(VAR_14);
rar->file_crc = archive_le32dec(VAR_6.file_crc);
if (rar->file_flags & VAR_24)
{
archive_entry_set_is_data_encrypted(VAR_1, 1);
rar->has_encrypted_entries = 1;
archive_set_error(&VAR_0->archive, VAR_22,
""RAR encryption support unavailable."");
}
if (rar->file_flags & VAR_25)
{
memcpy(VAR_12, VAR_6.pack_size, 4);
memcpy(VAR_12 + 4, VAR_4, 4); 
VAR_4 += 4;
memcpy(VAR_13, VAR_6.unp_size, 4);
memcpy(VAR_13 + 4, VAR_4, 4); 
VAR_4 += 4;
rar->packed_size = archive_le64dec(&VAR_12);
rar->unp_size = archive_le64dec(&VAR_13);
}
else
{
rar->packed_size = archive_le32dec(VAR_6.pack_size);
rar->unp_size = archive_le32dec(VAR_6.unp_size);
}
if (rar->packed_size < 0 || rar->unp_size < 0)
{
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid sizes specified."");
return (VAR_21);
}
rar->bytes_remaining = rar->packed_size;
if (VAR_2 == VAR_26) {
size_t VAR_27 = VAR_4 - (const char *)VAR_3;
VAR_7 += rar->packed_size;
if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
return (VAR_21);
VAR_4 = VAR_3;
VAR_5 = VAR_4 + VAR_7 - 7;
VAR_4 += VAR_27;
}
VAR_8 = archive_le16dec(VAR_6.name_size);
if (VAR_4 + VAR_8 > VAR_5) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid filename size"");
return (VAR_21);
}
if (rar->filename_allocated < VAR_8 * 2 + 2) {
char *VAR_28;
size_t VAR_29 = VAR_8 * 2 + 2;
VAR_28 = realloc(rar->filename, VAR_29);
if (VAR_28 == NULL) {
archive_set_error(&VAR_0->archive, VAR_30,
""Couldn't allocate memory."");
return (VAR_21);
}
rar->filename = VAR_28;
rar->filename_allocated = VAR_29;
}
VAR_10 = rar->filename;
memcpy(VAR_10, VAR_4, VAR_8);
VAR_10[VAR_8] = '\0';
if (rar->file_flags & VAR_31)
{
if (VAR_8 != strlen(VAR_10))
{
unsigned char VAR_32, VAR_33, VAR_34;
unsigned VAR_35, VAR_36;
VAR_9 = VAR_8;
VAR_35 = VAR_8 * 2;
VAR_8 = 0;
VAR_36 = (unsigned)strlen(VAR_10) + 1;
VAR_32 = *(VAR_4 + VAR_36++);
VAR_33 = 0;
VAR_34 = 0;
while (VAR_36 < VAR_9 && VAR_8 < VAR_35)
{
if (!VAR_33)
{
VAR_34 = *(VAR_4 + VAR_36++);
VAR_33 = 8;
}
VAR_33 -= 2;
switch((VAR_34 >> VAR_33) & 3)
{
case 0:
VAR_10[VAR_8++] = '\0';
VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
break;
case 1:
VAR_10[VAR_8++] = VAR_32;
VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
break;
case 2:
VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);
VAR_10[VAR_8++] = *(VAR_4 + VAR_36);
VAR_36 += 2;
break;
case 3:
{
char VAR_37, VAR_38;
uint8_t VAR_39 = *(VAR_4 + VAR_36++);
if (VAR_39 & 0x80) {
VAR_37 = *(VAR_4 + VAR_36++);
VAR_38 = (char)VAR_32;
} else
VAR_37 = VAR_38 = 0;
VAR_39 = (VAR_39 & 0x7f) + 2;
while (VAR_39 && VAR_8 < VAR_35) {
unsigned VAR_40 = VAR_8 >> 1;
VAR_10[VAR_8++] = VAR_38;
VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;
VAR_39--;
}
}
break;
}
}
if (VAR_8 > VAR_35) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid filename"");
return (VAR_21);
}
VAR_10[VAR_8++] = '\0';
VAR_10[VAR_8++] = '\0';
if (rar->sconv_utf16be == NULL) {
rar->sconv_utf16be = archive_string_conversion_from_charset(
&VAR_0->archive, ""UTF-16BE"", 1);
if (rar->sconv_utf16be == NULL)
return (VAR_21);
}
VAR_16 = rar->sconv_utf16be;
VAR_11 = VAR_10;
while (memcmp(VAR_11, ""\x00\x00"", 2))
{
if (!memcmp(VAR_11, ""\x00\\"", 2))
*(VAR_11 + 1) = '/';
VAR_11 += 2;
}
VAR_4 += VAR_36;
} else {
if (rar->sconv_utf8 == NULL) {
rar->sconv_utf8 = archive_string_conversion_from_charset(
&VAR_0->archive, ""UTF-8"", 1);
if (rar->sconv_utf8 == NULL)
return (VAR_21);
}
VAR_16 = rar->sconv_utf8;
while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
*VAR_11 = '/';
VAR_4 += VAR_8;
}
}
else
{
VAR_16 = VAR_15;
while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
*VAR_11 = '/';
VAR_4 += VAR_8;
}
if (rar->filename_save &&
VAR_8 == rar->filename_save_size &&
!memcmp(rar->filename, rar->filename_save, VAR_8 + 1))
{
__archive_read_consume(VAR_0, VAR_7 - 7);
rar->cursor++;
if (rar->cursor >= rar->nodes)
{
rar->nodes++;
if ((rar->dbo =
realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
{
archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
return (VAR_21);
}
rar->dbo[rar->cursor].header_size = VAR_7;
rar->dbo[rar->cursor].start_offset = -1;
rar->dbo[rar->cursor].end_offset = -1;
}
if (rar->dbo[rar->cursor].start_offset < 0)
{
rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;
rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
rar->packed_size;
}
return VAR_18;
}
rar->filename_save = (char*)realloc(rar->filename_save,
VAR_8 + 1);
memcpy(rar->filename_save, rar->filename, VAR_8 + 1);
rar->filename_save_size = VAR_8;
free(rar->dbo);
if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
{
archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
return (VAR_21);
}
rar->dbo[0].header_size = VAR_7;
rar->dbo[0].start_offset = -1;
rar->dbo[0].end_offset = -1;
rar->cursor = 0;
rar->nodes = 1;
if (rar->file_flags & VAR_41)
{
if (VAR_4 + 8 > VAR_5) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
memcpy(rar->salt, VAR_4, 8);
VAR_4 += 8;
}
if (rar->file_flags & VAR_42) {
if (read_exttime(VAR_4, rar, VAR_5) < 0) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
}
__archive_read_consume(VAR_0, VAR_7 - 7);
rar->dbo[0].start_offset = VAR_0->filter->position;
rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
switch(VAR_6.host_os)
{
case VAR_43:
case VAR_44:
case VAR_45:
rar->mode = archive_le32dec(VAR_6.file_attr);
if (rar->mode & VAR_46)
rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;
else
rar->mode = VAR_51;
rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;
break;
case VAR_56:
case VAR_57:
case VAR_58:
rar->mode = archive_le32dec(VAR_6.file_attr);
break;
default:
archive_set_error(&VAR_0->archive, VAR_22,
""Unknown file attributes from RAR file's host OS"");
return (VAR_21);
}
rar->bytes_uncopied = rar->bytes_unconsumed = 0;
rar->lzss.position = rar->offset = 0;
rar->offset_seek = 0;
rar->dictionary_size = 0;
rar->offset_outgoing = 0;
rar->br.cache_avail = 0;
rar->br.avail_in = 0;
rar->crc_calculated = 0;
rar->entry_eof = 0;
rar->valid = 1;
rar->is_ppmd_block = 0;
rar->start_new_table = 1;
free(rar->unp_buffer);
rar->unp_buffer = NULL;
rar->unp_offset = 0;
rar->unp_buffer_size = VAR_59;
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
VAR_60.Ppmd7_Free(&rar->ppmd7_context, &VAR_61);
rar->ppmd_valid = rar->ppmd_eod = 0;
if (VAR_2 == VAR_26)
return VAR_18;
archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);
archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);
archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);
archive_entry_set_size(VAR_1, rar->unp_size);
archive_entry_set_mode(VAR_1, rar->mode);
if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))
{
if (VAR_62 == VAR_30)
{
archive_set_error(&VAR_0->archive, VAR_30,
""Can't allocate memory for Pathname"");
return (VAR_21);
}
archive_set_error(&VAR_0->archive, VAR_22,
""Pathname cannot be converted from %s to current locale."",
archive_string_conversion_charset_name(VAR_16));
VAR_18 = (VAR_63);
}
if (((rar->mode) & VAR_64) == VAR_65)
{
rar->bytes_remaining = 0;
archive_entry_set_size(VAR_1, 0);
if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_63))
return VAR_20;
if (VAR_18 > VAR_20)
VAR_18 = VAR_20;
}
if (rar->bytes_remaining == 0)
rar->entry_eof = 1;
return VAR_18;
}",libarchive/5562545b5562f6d12a4ef991fae158bf4ccf92b6/archive_read_support_format_rar.c/vul/before/0.json,"static int
read_header(struct archive_read *a, struct archive_entry *entry,
            char head_type)
{
  const void *h;
  const char *p, *endp;
  struct rar *rar;
  struct rar_header rar_header;
  struct rar_file_header file_header;
  int64_t header_size;
  unsigned filename_size, end;
  char *filename;
  char *strp;
  char packed_size[8];
  char unp_size[8];
  int ttime;
  struct archive_string_conv *sconv, *fn_sconv;
  unsigned long crc32_val;
  int ret = (ARCHIVE_OK), ret2;

  rar = (struct rar *)(a->format->data);

  /* Setup a string conversion object for non-rar-unicode filenames. */
  sconv = rar->opt_sconv;
  if (sconv == NULL) {
    if (!rar->init_default_conversion) {
      rar->sconv_default =
          archive_string_default_conversion_for_read(
            &(a->archive));
      rar->init_default_conversion = 1;
    }
    sconv = rar->sconv_default;
  }


  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
    return (ARCHIVE_FATAL);
  p = h;
  memcpy(&rar_header, p, sizeof(rar_header));
  rar->file_flags = archive_le16dec(rar_header.flags);
  header_size = archive_le16dec(rar_header.size);
  if (header_size < (int64_t)sizeof(file_header) + 7) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Invalid header size"");
    return (ARCHIVE_FATAL);
  }
  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
  __archive_read_consume(a, 7);

  if (!(rar->file_flags & FHD_SOLID))
  {
    rar->compression_method = 0;
    rar->packed_size = 0;
    rar->unp_size = 0;
    rar->mtime = 0;
    rar->ctime = 0;
    rar->atime = 0;
    rar->arctime = 0;
    rar->mode = 0;
    memset(&rar->salt, 0, sizeof(rar->salt));
    rar->atime = 0;
    rar->ansec = 0;
    rar->ctime = 0;
    rar->cnsec = 0;
    rar->mtime = 0;
    rar->mnsec = 0;
    rar->arctime = 0;
    rar->arcnsec = 0;
  }
  else
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""RAR solid archive support unavailable."");
    return (ARCHIVE_FATAL);
  }

  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
    return (ARCHIVE_FATAL);

  /* File Header CRC check. */
  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Header CRC error"");
    return (ARCHIVE_FATAL);
  }
  /* If no CRC error, Go on parsing File Header. */
  p = h;
  endp = p + header_size - 7;
  memcpy(&file_header, p, sizeof(file_header));
  p += sizeof(file_header);

  rar->compression_method = file_header.method;

  ttime = archive_le32dec(file_header.file_time);
  rar->mtime = get_time(ttime);

  rar->file_crc = archive_le32dec(file_header.file_crc);

  if (rar->file_flags & FHD_PASSWORD)
  {
	archive_entry_set_is_data_encrypted(entry, 1);
	rar->has_encrypted_entries = 1;
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""RAR encryption support unavailable."");
    /* Since it is only the data part itself that is encrypted we can at least
       extract information about the currently processed entry and don't need
       to return ARCHIVE_FATAL here. */
    /*return (ARCHIVE_FATAL);*/
  }

  if (rar->file_flags & FHD_LARGE)
  {
    memcpy(packed_size, file_header.pack_size, 4);
    memcpy(packed_size + 4, p, 4); /* High pack size */
    p += 4;
    memcpy(unp_size, file_header.unp_size, 4);
    memcpy(unp_size + 4, p, 4); /* High unpack size */
    p += 4;
    rar->packed_size = archive_le64dec(&packed_size);
    rar->unp_size = archive_le64dec(&unp_size);
  }
  else
  {
    rar->packed_size = archive_le32dec(file_header.pack_size);
    rar->unp_size = archive_le32dec(file_header.unp_size);
  }

  if (rar->packed_size < 0 || rar->unp_size < 0)
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Invalid sizes specified."");
    return (ARCHIVE_FATAL);
  }

  rar->bytes_remaining = rar->packed_size;

  /* TODO: RARv3 subblocks contain comments. For now the complete block is
   * consumed at the end.
   */
  if (head_type == NEWSUB_HEAD) {
    size_t distance = p - (const char *)h;
    header_size += rar->packed_size;
    /* Make sure we have the extended data. */
    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
        return (ARCHIVE_FATAL);
    p = h;
    endp = p + header_size - 7;
    p += distance;
  }

  filename_size = archive_le16dec(file_header.name_size);
  if (p + filename_size > endp) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Invalid filename size"");
    return (ARCHIVE_FATAL);
  }
  if (rar->filename_allocated < filename_size * 2 + 2) {
    char *newptr;
    size_t newsize = filename_size * 2 + 2;
    newptr = realloc(rar->filename, newsize);
    if (newptr == NULL) {
      archive_set_error(&a->archive, ENOMEM,
                        ""Couldn't allocate memory."");
      return (ARCHIVE_FATAL);
    }
    rar->filename = newptr;
    rar->filename_allocated = newsize;
  }
  filename = rar->filename;
  memcpy(filename, p, filename_size);
  filename[filename_size] = '\0';
  if (rar->file_flags & FHD_UNICODE)
  {
    if (filename_size != strlen(filename))
    {
      unsigned char highbyte, flagbits, flagbyte;
      unsigned fn_end, offset;

      end = filename_size;
      fn_end = filename_size * 2;
      filename_size = 0;
      offset = (unsigned)strlen(filename) + 1;
      highbyte = *(p + offset++);
      flagbits = 0;
      flagbyte = 0;
      while (offset < end && filename_size < fn_end)
      {
        if (!flagbits)
        {
          flagbyte = *(p + offset++);
          flagbits = 8;
        }

        flagbits -= 2;
        switch((flagbyte >> flagbits) & 3)
        {
          case 0:
            filename[filename_size++] = '\0';
            filename[filename_size++] = *(p + offset++);
            break;
          case 1:
            filename[filename_size++] = highbyte;
            filename[filename_size++] = *(p + offset++);
            break;
          case 2:
            filename[filename_size++] = *(p + offset + 1);
            filename[filename_size++] = *(p + offset);
            offset += 2;
            break;
          case 3:
          {
            char extra, high;
            uint8_t length = *(p + offset++);

            if (length & 0x80) {
              extra = *(p + offset++);
              high = (char)highbyte;
            } else
              extra = high = 0;
            length = (length & 0x7f) + 2;
            while (length && filename_size < fn_end) {
              unsigned cp = filename_size >> 1;
              filename[filename_size++] = high;
              filename[filename_size++] = p[cp] + extra;
              length--;
            }
          }
          break;
        }
      }
      if (filename_size > fn_end) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
          ""Invalid filename"");
        return (ARCHIVE_FATAL);
      }
      filename[filename_size++] = '\0';
      /*
       * Do not increment filename_size here as the computations below
       * add the space for the terminating NUL explicitly.
       */
      filename[filename_size] = '\0';

      /* Decoded unicode form is UTF-16BE, so we have to update a string
       * conversion object for it. */
      if (rar->sconv_utf16be == NULL) {
        rar->sconv_utf16be = archive_string_conversion_from_charset(
           &a->archive, ""UTF-16BE"", 1);
        if (rar->sconv_utf16be == NULL)
          return (ARCHIVE_FATAL);
      }
      fn_sconv = rar->sconv_utf16be;

      strp = filename;
      while (memcmp(strp, ""\x00\x00"", 2))
      {
        if (!memcmp(strp, ""\x00\\"", 2))
          *(strp + 1) = '/';
        strp += 2;
      }
      p += offset;
    } else {
      /*
       * If FHD_UNICODE is set but no unicode data, this file name form
       * is UTF-8, so we have to update a string conversion object for
       * it accordingly.
       */
      if (rar->sconv_utf8 == NULL) {
        rar->sconv_utf8 = archive_string_conversion_from_charset(
           &a->archive, ""UTF-8"", 1);
        if (rar->sconv_utf8 == NULL)
          return (ARCHIVE_FATAL);
      }
      fn_sconv = rar->sconv_utf8;
      while ((strp = strchr(filename, '\\')) != NULL)
        *strp = '/';
      p += filename_size;
    }
  }
  else
  {
    fn_sconv = sconv;
    while ((strp = strchr(filename, '\\')) != NULL)
      *strp = '/';
    p += filename_size;
  }

  /* Split file in multivolume RAR. No more need to process header. */
  if (rar->filename_save &&
    filename_size == rar->filename_save_size &&
    !memcmp(rar->filename, rar->filename_save, filename_size + 1))
  {
    __archive_read_consume(a, header_size - 7);
    rar->cursor++;
    if (rar->cursor >= rar->nodes)
    {
      rar->nodes++;
      if ((rar->dbo =
        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
      {
        archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
        return (ARCHIVE_FATAL);
      }
      rar->dbo[rar->cursor].header_size = header_size;
      rar->dbo[rar->cursor].start_offset = -1;
      rar->dbo[rar->cursor].end_offset = -1;
    }
    if (rar->dbo[rar->cursor].start_offset < 0)
    {
      rar->dbo[rar->cursor].start_offset = a->filter->position;
      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
        rar->packed_size;
    }
    return ret;
  }

  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);
  memcpy(rar->filename_save, rar->filename, filename_size + 1);
  rar->filename_save_size = filename_size;

  /* Set info for seeking */
  free(rar->dbo);
  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
    return (ARCHIVE_FATAL);
  }
  rar->dbo[0].header_size = header_size;
  rar->dbo[0].start_offset = -1;
  rar->dbo[0].end_offset = -1;
  rar->cursor = 0;
  rar->nodes = 1;

  if (rar->file_flags & FHD_SALT)
  {
    if (p + 8 > endp) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
        ""Invalid header size"");
      return (ARCHIVE_FATAL);
    }
    memcpy(rar->salt, p, 8);
    p += 8;
  }

  if (rar->file_flags & FHD_EXTTIME) {
    if (read_exttime(p, rar, endp) < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
        ""Invalid header size"");
      return (ARCHIVE_FATAL);
    }
  }

  __archive_read_consume(a, header_size - 7);
  rar->dbo[0].start_offset = a->filter->position;
  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;

  switch(file_header.host_os)
  {
  case OS_MSDOS:
  case OS_OS2:
  case OS_WIN32:
    rar->mode = archive_le32dec(file_header.file_attr);
    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
    else
      rar->mode = AE_IFREG;
    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
    break;

  case OS_UNIX:
  case OS_MAC_OS:
  case OS_BEOS:
    rar->mode = archive_le32dec(file_header.file_attr);
    break;

  default:
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Unknown file attributes from RAR file's host OS"");
    return (ARCHIVE_FATAL);
  }

  rar->bytes_uncopied = rar->bytes_unconsumed = 0;
  rar->lzss.position = rar->offset = 0;
  rar->offset_seek = 0;
  rar->dictionary_size = 0;
  rar->offset_outgoing = 0;
  rar->br.cache_avail = 0;
  rar->br.avail_in = 0;
  rar->crc_calculated = 0;
  rar->entry_eof = 0;
  rar->valid = 1;
  rar->is_ppmd_block = 0;
  rar->start_new_table = 1;
  free(rar->unp_buffer);
  rar->unp_buffer = NULL;
  rar->unp_offset = 0;
  rar->unp_buffer_size = UNP_BUFFER_SIZE;
  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);
  rar->ppmd_valid = rar->ppmd_eod = 0;

  /* Don't set any archive entries for non-file header types */
  if (head_type == NEWSUB_HEAD)
    return ret;

  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
  archive_entry_set_atime(entry, rar->atime, rar->ansec);
  archive_entry_set_size(entry, rar->unp_size);
  archive_entry_set_mode(entry, rar->mode);

  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
  {
    if (errno == ENOMEM)
    {
      archive_set_error(&a->archive, ENOMEM,
                        ""Can't allocate memory for Pathname"");
      return (ARCHIVE_FATAL);
    }
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Pathname cannot be converted from %s to current locale."",
                      archive_string_conversion_charset_name(fn_sconv));
    ret = (ARCHIVE_WARN);
  }

  if (((rar->mode) & AE_IFMT) == AE_IFLNK)
  {
    /* Make sure a symbolic-link file does not have its body. */
    rar->bytes_remaining = 0;
    archive_entry_set_size(entry, 0);

    /* Read a symbolic-link name. */
    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
      return ret2;
    if (ret > ret2)
      ret = ret2;
  }

  if (rar->bytes_remaining == 0)
    rar->entry_eof = 1;

  return ret;
}","static int
read_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,
            char VAR_2)
{
  const void *VAR_3;
  const char *VAR_4, *VAR_5;
  struct rar *rar;
  struct rar_header rar_header;
  struct rar_file_header VAR_6;
  int64_t VAR_7;
  unsigned VAR_8, VAR_9;
  char *VAR_10;
  char *VAR_11;
  char VAR_12[8];
  char VAR_13[8];
  int VAR_14;
  struct archive_string_conv *VAR_15, *VAR_16;
  unsigned long VAR_17;
  int VAR_18 = (VAR_19), VAR_20;

  rar = (struct rar *)(VAR_0->format->data);

  /* COMMENT_0 */
  VAR_15 = rar->opt_sconv;
  if (VAR_15 == NULL) {
    if (!rar->init_default_conversion) {
      rar->sconv_default =
          archive_string_default_conversion_for_read(
            &(VAR_0->archive));
      rar->init_default_conversion = 1;
    }
    VAR_15 = rar->sconv_default;
  }


  if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)
    return (VAR_21);
  VAR_4 = VAR_3;
  memcpy(&rar_header, VAR_4, sizeof(rar_header));
  rar->file_flags = archive_le16dec(rar_header.flags);
  VAR_7 = archive_le16dec(rar_header.size);
  if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Invalid header size"");
    return (VAR_21);
  }
  VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);
  __archive_read_consume(VAR_0, 7);

  if (!(rar->file_flags & VAR_23))
  {
    rar->compression_method = 0;
    rar->packed_size = 0;
    rar->unp_size = 0;
    rar->mtime = 0;
    rar->ctime = 0;
    rar->atime = 0;
    rar->arctime = 0;
    rar->mode = 0;
    memset(&rar->salt, 0, sizeof(rar->salt));
    rar->atime = 0;
    rar->ansec = 0;
    rar->ctime = 0;
    rar->cnsec = 0;
    rar->mtime = 0;
    rar->mnsec = 0;
    rar->arctime = 0;
    rar->arcnsec = 0;
  }
  else
  {
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""RAR solid archive support unavailable."");
    return (VAR_21);
  }

  if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
    return (VAR_21);

  /* COMMENT_1 */
  VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));
  if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Header CRC error"");
    return (VAR_21);
  }
  /* COMMENT_2 */
  VAR_4 = VAR_3;
  VAR_5 = VAR_4 + VAR_7 - 7;
  memcpy(&VAR_6, VAR_4, sizeof(VAR_6));
  VAR_4 += sizeof(VAR_6);

  rar->compression_method = VAR_6.method;

  VAR_14 = archive_le32dec(VAR_6.file_time);
  rar->mtime = get_time(VAR_14);

  rar->file_crc = archive_le32dec(VAR_6.file_crc);

  if (rar->file_flags & VAR_24)
  {
	archive_entry_set_is_data_encrypted(VAR_1, 1);
	rar->has_encrypted_entries = 1;
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""RAR encryption support unavailable."");
    /* COMMENT_3 */
                                                                             
                                       
    /* COMMENT_6 */
  }

  if (rar->file_flags & VAR_25)
  {
    memcpy(VAR_12, VAR_6.pack_size, 4);
    memcpy(VAR_12 + 4, VAR_4, 4); /* COMMENT_7 */
    VAR_4 += 4;
    memcpy(VAR_13, VAR_6.unp_size, 4);
    memcpy(VAR_13 + 4, VAR_4, 4); /* COMMENT_8 */
    VAR_4 += 4;
    rar->packed_size = archive_le64dec(&VAR_12);
    rar->unp_size = archive_le64dec(&VAR_13);
  }
  else
  {
    rar->packed_size = archive_le32dec(VAR_6.pack_size);
    rar->unp_size = archive_le32dec(VAR_6.unp_size);
  }

  if (rar->packed_size < 0 || rar->unp_size < 0)
  {
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Invalid sizes specified."");
    return (VAR_21);
  }

  rar->bytes_remaining = rar->packed_size;

  /* COMMENT_9 */
                         
     
  if (VAR_2 == VAR_26) {
    size_t VAR_27 = VAR_4 - (const char *)VAR_3;
    VAR_7 += rar->packed_size;
    /* COMMENT_12 */
    if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
        return (VAR_21);
    VAR_4 = VAR_3;
    VAR_5 = VAR_4 + VAR_7 - 7;
    VAR_4 += VAR_27;
  }

  VAR_8 = archive_le16dec(VAR_6.name_size);
  if (VAR_4 + VAR_8 > VAR_5) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Invalid filename size"");
    return (VAR_21);
  }
  if (rar->filename_allocated < VAR_8 * 2 + 2) {
    char *VAR_28;
    size_t VAR_29 = VAR_8 * 2 + 2;
    VAR_28 = realloc(rar->filename, VAR_29);
    if (VAR_28 == NULL) {
      archive_set_error(&VAR_0->archive, VAR_30,
                        ""Couldn't allocate memory."");
      return (VAR_21);
    }
    rar->filename = VAR_28;
    rar->filename_allocated = VAR_29;
  }
  VAR_10 = rar->filename;
  memcpy(VAR_10, VAR_4, VAR_8);
  VAR_10[VAR_8] = '\0';
  if (rar->file_flags & VAR_31)
  {
    if (VAR_8 != strlen(VAR_10))
    {
      unsigned char VAR_32, VAR_33, VAR_34;
      unsigned VAR_35, VAR_36;

      VAR_9 = VAR_8;
      VAR_35 = VAR_8 * 2;
      VAR_8 = 0;
      VAR_36 = (unsigned)strlen(VAR_10) + 1;
      VAR_32 = *(VAR_4 + VAR_36++);
      VAR_33 = 0;
      VAR_34 = 0;
      while (VAR_36 < VAR_9 && VAR_8 < VAR_35)
      {
        if (!VAR_33)
        {
          VAR_34 = *(VAR_4 + VAR_36++);
          VAR_33 = 8;
        }

        VAR_33 -= 2;
        switch((VAR_34 >> VAR_33) & 3)
        {
          case 0:
            VAR_10[VAR_8++] = '\0';
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
            break;
          case 1:
            VAR_10[VAR_8++] = VAR_32;
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
            break;
          case 2:
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36);
            VAR_36 += 2;
            break;
          case 3:
          {
            char VAR_37, VAR_38;
            uint8_t VAR_39 = *(VAR_4 + VAR_36++);

            if (VAR_39 & 0x80) {
              VAR_37 = *(VAR_4 + VAR_36++);
              VAR_38 = (char)VAR_32;
            } else
              VAR_37 = VAR_38 = 0;
            VAR_39 = (VAR_39 & 0x7f) + 2;
            while (VAR_39 && VAR_8 < VAR_35) {
              unsigned VAR_40 = VAR_8 >> 1;
              VAR_10[VAR_8++] = VAR_38;
              VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;
              VAR_39--;
            }
          }
          break;
        }
      }
      if (VAR_8 > VAR_35) {
        archive_set_error(&VAR_0->archive, VAR_22,
          ""Invalid filename"");
        return (VAR_21);
      }
      VAR_10[VAR_8++] = '\0';
      /* COMMENT_13 */
                                                                      
                                                          
         
      VAR_10[VAR_8] = '\0';

      /* COMMENT_17 */
                                     
      if (rar->sconv_utf16be == NULL) {
        rar->sconv_utf16be = archive_string_conversion_from_charset(
           &VAR_0->archive, ""UTF-16BE"", 1);
        if (rar->sconv_utf16be == NULL)
          return (VAR_21);
      }
      VAR_16 = rar->sconv_utf16be;

      VAR_11 = VAR_10;
      while (memcmp(VAR_11, ""\x00\x00"", 2))
      {
        if (!memcmp(VAR_11, ""\x00\\"", 2))
          *(VAR_11 + 1) = '/';
        VAR_11 += 2;
      }
      VAR_4 += VAR_36;
    } else {
      /* COMMENT_19 */
                                                                       
                                                                      
                        
         
      if (rar->sconv_utf8 == NULL) {
        rar->sconv_utf8 = archive_string_conversion_from_charset(
           &VAR_0->archive, ""UTF-8"", 1);
        if (rar->sconv_utf8 == NULL)
          return (VAR_21);
      }
      VAR_16 = rar->sconv_utf8;
      while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
        *VAR_11 = '/';
      VAR_4 += VAR_8;
    }
  }
  else
  {
    VAR_16 = VAR_15;
    while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
      *VAR_11 = '/';
    VAR_4 += VAR_8;
  }

  /* COMMENT_24 */
  if (rar->filename_save &&
    VAR_8 == rar->filename_save_size &&
    !memcmp(rar->filename, rar->filename_save, VAR_8 + 1))
  {
    __archive_read_consume(VAR_0, VAR_7 - 7);
    rar->cursor++;
    if (rar->cursor >= rar->nodes)
    {
      rar->nodes++;
      if ((rar->dbo =
        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
      {
        archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
        return (VAR_21);
      }
      rar->dbo[rar->cursor].header_size = VAR_7;
      rar->dbo[rar->cursor].start_offset = -1;
      rar->dbo[rar->cursor].end_offset = -1;
    }
    if (rar->dbo[rar->cursor].start_offset < 0)
    {
      rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;
      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
        rar->packed_size;
    }
    return VAR_18;
  }

  rar->filename_save = (char*)realloc(rar->filename_save,
                                      VAR_8 + 1);
  memcpy(rar->filename_save, rar->filename, VAR_8 + 1);
  rar->filename_save_size = VAR_8;

  /* COMMENT_25 */
  free(rar->dbo);
  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
  {
    archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
    return (VAR_21);
  }
  rar->dbo[0].header_size = VAR_7;
  rar->dbo[0].start_offset = -1;
  rar->dbo[0].end_offset = -1;
  rar->cursor = 0;
  rar->nodes = 1;

  if (rar->file_flags & VAR_41)
  {
    if (VAR_4 + 8 > VAR_5) {
      archive_set_error(&VAR_0->archive, VAR_22,
        ""Invalid header size"");
      return (VAR_21);
    }
    memcpy(rar->salt, VAR_4, 8);
    VAR_4 += 8;
  }

  if (rar->file_flags & VAR_42) {
    if (read_exttime(VAR_4, rar, VAR_5) < 0) {
      archive_set_error(&VAR_0->archive, VAR_22,
        ""Invalid header size"");
      return (VAR_21);
    }
  }

  __archive_read_consume(VAR_0, VAR_7 - 7);
  rar->dbo[0].start_offset = VAR_0->filter->position;
  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;

  switch(VAR_6.host_os)
  {
  case VAR_43:
  case VAR_44:
  case VAR_45:
    rar->mode = archive_le32dec(VAR_6.file_attr);
    if (rar->mode & VAR_46)
      rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;
    else
      rar->mode = VAR_51;
    rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;
    break;

  case VAR_56:
  case VAR_57:
  case VAR_58:
    rar->mode = archive_le32dec(VAR_6.file_attr);
    break;

  default:
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Unknown file attributes from RAR file's host OS"");
    return (VAR_21);
  }

  rar->bytes_uncopied = rar->bytes_unconsumed = 0;
  rar->lzss.position = rar->offset = 0;
  rar->offset_seek = 0;
  rar->dictionary_size = 0;
  rar->offset_outgoing = 0;
  rar->br.cache_avail = 0;
  rar->br.avail_in = 0;
  rar->crc_calculated = 0;
  rar->entry_eof = 0;
  rar->valid = 1;
  rar->is_ppmd_block = 0;
  rar->start_new_table = 1;
  free(rar->unp_buffer);
  rar->unp_buffer = NULL;
  rar->unp_offset = 0;
  rar->unp_buffer_size = VAR_59;
  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
  VAR_60.Ppmd7_Free(&rar->ppmd7_context, &VAR_61);
  rar->ppmd_valid = rar->ppmd_eod = 0;

  /* COMMENT_26 */
  if (VAR_2 == VAR_26)
    return VAR_18;

  archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);
  archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);
  archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);
  archive_entry_set_size(VAR_1, rar->unp_size);
  archive_entry_set_mode(VAR_1, rar->mode);

  if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))
  {
    if (VAR_62 == VAR_30)
    {
      archive_set_error(&VAR_0->archive, VAR_30,
                        ""Can't allocate memory for Pathname"");
      return (VAR_21);
    }
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Pathname cannot be converted from %s to current locale."",
                      archive_string_conversion_charset_name(VAR_16));
    VAR_18 = (VAR_63);
  }

  if (((rar->mode) & VAR_64) == VAR_65)
  {
    /* COMMENT_27 */
    rar->bytes_remaining = 0;
    archive_entry_set_size(VAR_1, 0);

    /* COMMENT_28 */
    if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_63))
      return VAR_20;
    if (VAR_18 > VAR_20)
      VAR_18 = VAR_20;
  }

  if (rar->bytes_remaining == 0)
    rar->entry_eof = 1;

  return VAR_18;
}",libarchive/5562545b5562f6d12a4ef991fae158bf4ccf92b6/archive_read_support_format_rar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -235,7 +235,11 @@
         return (ARCHIVE_FATAL);
       }
       filename[filename_size++] = '\0';
-      filename[filename_size++] = '\0';
+      /*
+       * Do not increment filename_size here as the computations below
+       * add the space for the terminating NUL explicitly.
+       */
+      filename[filename_size] = '\0';
 
       /* Decoded unicode form is UTF-16BE, so we have to update a string
        * conversion object for it. */","{'deleted_lines': [""      filename[filename_size++] = '\\0';""], 'added_lines': ['      /*', '       * Do not increment filename_size here as the computations below', '       * add the space for the terminating NUL explicitly.', '       */', ""      filename[filename_size] = '\\0';""]}",True,"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",7.5,HIGH,2,valid,2017-09-09T15:47:32Z,2
CVE-2017-12154,['CWE-Other'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"kvm: nVMX: Don't allow L2 to access the hardware CR8

If L1 does not specify the ""use TPR shadow"" VM-execution control in
vmcs12, then L0 must specify the ""CR8-load exiting"" and ""CR8-store
exiting"" VM-execution controls in vmcs02. Failure to do so will give
the L2 VM unrestricted read/write access to the hardware CR8.

This fixes CVE-2017-12154.

Signed-off-by: Jim Mattson <jmattson@google.com>
Reviewed-by: David Hildenbrand <david@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",51aa68e7d57e3217192d88ce90fd5b8ef29ec94f,https://github.com/torvalds/linux/commit/51aa68e7d57e3217192d88ce90fd5b8ef29ec94f,arch/x86/kvm/vmx.c,prepare_vmcs02,"static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
bool from_vmentry, u32 *entry_failure_code)
{
struct vcpu_vmx *vmx = to_vmx(vcpu);
u32 exec_control, vmcs12_exec_ctrl;
vmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);
vmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);
vmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);
vmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);
vmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);
vmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);
vmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);
vmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);
vmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);
vmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);
vmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);
vmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);
vmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);
vmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);
vmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);
vmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);
vmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);
vmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);
vmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);
vmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);
vmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);
vmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);
vmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);
vmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);
vmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);
vmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);
vmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);
vmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);
vmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);
vmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);
vmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);
vmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);
vmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);
vmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);
vmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);
vmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);
if (from_vmentry &&
(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS)) {
kvm_set_dr(vcpu, 7, vmcs12->guest_dr7);
vmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);
} else {
kvm_set_dr(vcpu, 7, vcpu->arch.dr7);
vmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);
}
if (from_vmentry) {
vmcs_write32(VM_ENTRY_INTR_INFO_FIELD,
vmcs12->vm_entry_intr_info_field);
vmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,
vmcs12->vm_entry_exception_error_code);
vmcs_write32(VM_ENTRY_INSTRUCTION_LEN,
vmcs12->vm_entry_instruction_len);
vmcs_write32(GUEST_INTERRUPTIBILITY_INFO,
vmcs12->guest_interruptibility_info);
vmx->loaded_vmcs->nmi_known_unmasked =
!(vmcs12->guest_interruptibility_info & GUEST_INTR_STATE_NMI);
} else {
vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);
}
vmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);
vmx_set_rflags(vcpu, vmcs12->guest_rflags);
vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,
vmcs12->guest_pending_dbg_exceptions);
vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);
vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);
if (nested_cpu_has_xsaves(vmcs12))
vmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);
vmcs_write64(VMCS_LINK_POINTER, -1ull);
exec_control = vmcs12->pin_based_vm_exec_control;
exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
exec_control |= vmcs_config.pin_based_exec_ctrl;
if (vmx->hv_deadline_tsc == -1)
exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
if (nested_cpu_has_posted_intr(vmcs12)) {
vmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;
vmx->nested.pi_pending = false;
vmcs_write16(POSTED_INTR_NV, POSTED_INTR_NESTED_VECTOR);
} else {
exec_control &= ~PIN_BASED_POSTED_INTR;
}
vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);
vmx->nested.preemption_timer_expired = false;
if (nested_cpu_has_preemption_timer(vmcs12))
vmx_start_preemption_timer(vcpu);
vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,
enable_ept ? vmcs12->page_fault_error_code_mask : 0);
vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,
enable_ept ? vmcs12->page_fault_error_code_match : 0);
if (cpu_has_secondary_exec_ctrls()) {
exec_control = vmx->secondary_exec_control;
exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
SECONDARY_EXEC_ENABLE_INVPCID |
SECONDARY_EXEC_RDTSCP |
SECONDARY_EXEC_XSAVES |
SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
SECONDARY_EXEC_APIC_REGISTER_VIRT |
SECONDARY_EXEC_ENABLE_VMFUNC);
if (nested_cpu_has(vmcs12,
CPU_BASED_ACTIVATE_SECONDARY_CONTROLS)) {
vmcs12_exec_ctrl = vmcs12->secondary_vm_exec_control &
~SECONDARY_EXEC_ENABLE_PML;
exec_control |= vmcs12_exec_ctrl;
}
if (exec_control & SECONDARY_EXEC_ENABLE_VMFUNC)
vmcs_write64(VM_FUNCTION_CONTROL, 0);
if (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {
vmcs_write64(EOI_EXIT_BITMAP0,
vmcs12->eoi_exit_bitmap0);
vmcs_write64(EOI_EXIT_BITMAP1,
vmcs12->eoi_exit_bitmap1);
vmcs_write64(EOI_EXIT_BITMAP2,
vmcs12->eoi_exit_bitmap2);
vmcs_write64(EOI_EXIT_BITMAP3,
vmcs12->eoi_exit_bitmap3);
vmcs_write16(GUEST_INTR_STATUS,
vmcs12->guest_intr_status);
}
if (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)
vmcs_write64(APIC_ACCESS_ADDR, -1ull);
vmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);
}
vmx_set_constant_host_state(vmx);
vmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);
vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);
vmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));
vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);
vmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));
vmx->host_rsp = 0;
exec_control = vmx_exec_control(vmx); 
exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
exec_control &= ~CPU_BASED_TPR_SHADOW;
exec_control |= vmcs12->cpu_based_vm_exec_control;
if (exec_control & CPU_BASED_TPR_SHADOW) {
vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, -1ull);
vmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);
}
exec_control &= ~CPU_BASED_USE_IO_BITMAPS;
exec_control |= CPU_BASED_UNCOND_IO_EXITING;
vmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);
update_exception_bitmap(vcpu);
vcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;
vmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);
vmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);
vm_entry_controls_init(vmx, 
(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &
~VM_ENTRY_IA32E_MODE) |
(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));
if (from_vmentry &&
(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT)) {
vmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);
vcpu->arch.pat = vmcs12->guest_ia32_pat;
} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {
vmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);
}
set_cr4_guest_host_mask(vmx);
if (from_vmentry &&
vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)
vmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);
if (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)
vmcs_write64(TSC_OFFSET,
vcpu->arch.tsc_offset + vmcs12->tsc_offset);
else
vmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);
if (kvm_has_tsc_control)
decache_tsc_multiplier(vmx);
if (enable_vpid) {
if (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {
vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);
if (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {
vmx->nested.last_vpid = vmcs12->virtual_processor_id;
__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);
}
} else {
vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);
vmx_flush_tlb(vcpu);
}
}
if (enable_pml) {
ASSERT(vmx->pml_pg);
vmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));
vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);
}
if (nested_cpu_has_ept(vmcs12)) {
if (nested_ept_init_mmu_context(vcpu)) {
*entry_failure_code = ENTRY_FAIL_DEFAULT;
return 1;
}
} else if (nested_cpu_has2(vmcs12,
SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {
vmx_flush_tlb_ept_only(vcpu);
}
vmx_set_cr0(vcpu, vmcs12->guest_cr0);
vmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));
vmx_set_cr4(vcpu, vmcs12->guest_cr4);
vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));
if (from_vmentry &&
(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))
vcpu->arch.efer = vmcs12->guest_ia32_efer;
else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
vcpu->arch.efer |= (EFER_LMA | EFER_LME);
else
vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
vmx_set_efer(vcpu, vcpu->arch.efer);
if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),
entry_failure_code))
return 1;
if (!enable_ept)
vcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;
if (enable_ept) {
vmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);
vmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);
vmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);
vmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);
}
kvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);
kvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);
return 0;
}","static int prepare_vmcs02(struct kvm_vcpu *VAR_0, struct vmcs12 *vmcs12,
bool VAR_1, u32 *VAR_2)
{
struct vcpu_vmx *VAR_3 = to_vmx(VAR_0);
u32 VAR_4, VAR_5;
vmcs_write16(VAR_6, vmcs12->guest_es_selector);
vmcs_write16(VAR_7, vmcs12->guest_cs_selector);
vmcs_write16(VAR_8, vmcs12->guest_ss_selector);
vmcs_write16(VAR_9, vmcs12->guest_ds_selector);
vmcs_write16(VAR_10, vmcs12->guest_fs_selector);
vmcs_write16(VAR_11, vmcs12->guest_gs_selector);
vmcs_write16(VAR_12, vmcs12->guest_ldtr_selector);
vmcs_write16(VAR_13, vmcs12->guest_tr_selector);
vmcs_write32(VAR_14, vmcs12->guest_es_limit);
vmcs_write32(VAR_15, vmcs12->guest_cs_limit);
vmcs_write32(VAR_16, vmcs12->guest_ss_limit);
vmcs_write32(VAR_17, vmcs12->guest_ds_limit);
vmcs_write32(VAR_18, vmcs12->guest_fs_limit);
vmcs_write32(VAR_19, vmcs12->guest_gs_limit);
vmcs_write32(VAR_20, vmcs12->guest_ldtr_limit);
vmcs_write32(VAR_21, vmcs12->guest_tr_limit);
vmcs_write32(VAR_22, vmcs12->guest_gdtr_limit);
vmcs_write32(VAR_23, vmcs12->guest_idtr_limit);
vmcs_write32(VAR_24, vmcs12->guest_es_ar_bytes);
vmcs_write32(VAR_25, vmcs12->guest_cs_ar_bytes);
vmcs_write32(VAR_26, vmcs12->guest_ss_ar_bytes);
vmcs_write32(VAR_27, vmcs12->guest_ds_ar_bytes);
vmcs_write32(VAR_28, vmcs12->guest_fs_ar_bytes);
vmcs_write32(VAR_29, vmcs12->guest_gs_ar_bytes);
vmcs_write32(VAR_30, vmcs12->guest_ldtr_ar_bytes);
vmcs_write32(VAR_31, vmcs12->guest_tr_ar_bytes);
vmcs_writel(VAR_32, vmcs12->guest_es_base);
vmcs_writel(VAR_33, vmcs12->guest_cs_base);
vmcs_writel(VAR_34, vmcs12->guest_ss_base);
vmcs_writel(VAR_35, vmcs12->guest_ds_base);
vmcs_writel(VAR_36, vmcs12->guest_fs_base);
vmcs_writel(VAR_37, vmcs12->guest_gs_base);
vmcs_writel(VAR_38, vmcs12->guest_ldtr_base);
vmcs_writel(VAR_39, vmcs12->guest_tr_base);
vmcs_writel(VAR_40, vmcs12->guest_gdtr_base);
vmcs_writel(VAR_41, vmcs12->guest_idtr_base);
if (VAR_1 &&
(vmcs12->vm_entry_controls & VAR_42)) {
kvm_set_dr(VAR_0, 7, vmcs12->guest_dr7);
vmcs_write64(VAR_43, vmcs12->guest_ia32_debugctl);
} else {
kvm_set_dr(VAR_0, 7, VAR_0->arch.dr7);
vmcs_write64(VAR_43, VAR_3->nested.vmcs01_debugctl);
}
if (VAR_1) {
vmcs_write32(VAR_44,
vmcs12->vm_entry_intr_info_field);
vmcs_write32(VAR_45,
vmcs12->vm_entry_exception_error_code);
vmcs_write32(VAR_46,
vmcs12->vm_entry_instruction_len);
vmcs_write32(VAR_47,
vmcs12->guest_interruptibility_info);
VAR_3->loaded_vmcs->nmi_known_unmasked =
!(vmcs12->guest_interruptibility_info & VAR_48);
} else {
vmcs_write32(VAR_44, 0);
}
vmcs_write32(VAR_49, vmcs12->guest_sysenter_cs);
vmx_set_rflags(VAR_0, vmcs12->guest_rflags);
vmcs_writel(VAR_50,
vmcs12->guest_pending_dbg_exceptions);
vmcs_writel(VAR_51, vmcs12->guest_sysenter_esp);
vmcs_writel(VAR_52, vmcs12->guest_sysenter_eip);
if (nested_cpu_has_xsaves(vmcs12))
vmcs_write64(VAR_53, vmcs12->xss_exit_bitmap);
vmcs_write64(VAR_54, -1ull);
VAR_4 = vmcs12->pin_based_vm_exec_control;
VAR_4 &= ~VAR_55;
VAR_4 |= VAR_56.pin_based_exec_ctrl;
if (VAR_3->hv_deadline_tsc == -1)
VAR_4 &= ~VAR_55;
if (nested_cpu_has_posted_intr(vmcs12)) {
VAR_3->nested.posted_intr_nv = vmcs12->posted_intr_nv;
VAR_3->nested.pi_pending = false;
vmcs_write16(VAR_57, VAR_58);
} else {
VAR_4 &= ~VAR_59;
}
vmcs_write32(VAR_60, VAR_4);
VAR_3->nested.preemption_timer_expired = false;
if (nested_cpu_has_preemption_timer(vmcs12))
vmx_start_preemption_timer(VAR_0);
vmcs_write32(VAR_61,
VAR_62 ? vmcs12->page_fault_error_code_mask : 0);
vmcs_write32(VAR_63,
VAR_62 ? vmcs12->page_fault_error_code_match : 0);
if (cpu_has_secondary_exec_ctrls()) {
VAR_4 = VAR_3->secondary_exec_control;
VAR_4 &= ~(VAR_64 |
VAR_65 |
VAR_66 |
VAR_67 |
VAR_68 |
VAR_69 |
VAR_70);
if (nested_cpu_has(vmcs12,
VAR_71)) {
VAR_5 = vmcs12->secondary_vm_exec_control &
~VAR_72;
VAR_4 |= VAR_5;
}
if (VAR_4 & VAR_70)
vmcs_write64(VAR_73, 0);
if (VAR_4 & VAR_68) {
vmcs_write64(VAR_74,
vmcs12->eoi_exit_bitmap0);
vmcs_write64(VAR_75,
vmcs12->eoi_exit_bitmap1);
vmcs_write64(VAR_76,
vmcs12->eoi_exit_bitmap2);
vmcs_write64(VAR_77,
vmcs12->eoi_exit_bitmap3);
vmcs_write16(VAR_78,
vmcs12->guest_intr_status);
}
if (VAR_4 & VAR_64)
vmcs_write64(VAR_79, -1ull);
vmcs_write32(VAR_80, VAR_4);
}
vmx_set_constant_host_state(VAR_3);
vmcs_write32(VAR_81, 0);
vmcs_write32(VAR_82, VAR_3->msr_autoload.nr);
vmcs_write64(VAR_83, __pa(VAR_3->msr_autoload.host));
vmcs_write32(VAR_84, VAR_3->msr_autoload.nr);
vmcs_write64(VAR_85, __pa(VAR_3->msr_autoload.guest));
VAR_3->host_rsp = 0;
VAR_4 = vmx_exec_control(VAR_3); 
VAR_4 &= ~VAR_86;
VAR_4 &= ~VAR_87;
VAR_4 &= ~VAR_88;
VAR_4 |= vmcs12->cpu_based_vm_exec_control;
if (VAR_4 & VAR_88) {
vmcs_write64(VAR_89, -1ull);
vmcs_write32(VAR_90, vmcs12->tpr_threshold);
}
VAR_4 &= ~VAR_91;
VAR_4 |= VAR_92;
vmcs_write32(VAR_93, VAR_4);
update_exception_bitmap(VAR_0);
VAR_0->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;
vmcs_writel(VAR_94, ~VAR_0->arch.cr0_guest_owned_bits);
vmcs_write32(VAR_95, VAR_56.vmexit_ctrl);
vm_entry_controls_init(VAR_3, 
(vmcs12->vm_entry_controls & ~VAR_96 &
~VAR_97) |
(VAR_56.vmentry_ctrl & ~VAR_97));
if (VAR_1 &&
(vmcs12->vm_entry_controls & VAR_98)) {
vmcs_write64(VAR_99, vmcs12->guest_ia32_pat);
VAR_0->arch.pat = vmcs12->guest_ia32_pat;
} else if (VAR_56.vmentry_ctrl & VAR_98) {
vmcs_write64(VAR_99, VAR_3->vcpu.arch.pat);
}
set_cr4_guest_host_mask(VAR_3);
if (VAR_1 &&
vmcs12->vm_entry_controls & VAR_100)
vmcs_write64(VAR_101, vmcs12->guest_bndcfgs);
if (vmcs12->cpu_based_vm_exec_control & VAR_102)
vmcs_write64(VAR_103,
VAR_0->arch.tsc_offset + vmcs12->tsc_offset);
else
vmcs_write64(VAR_103, VAR_0->arch.tsc_offset);
if (VAR_104)
decache_tsc_multiplier(VAR_3);
if (VAR_105) {
if (nested_cpu_has_vpid(vmcs12) && VAR_3->nested.vpid02) {
vmcs_write16(VAR_106, VAR_3->nested.vpid02);
if (vmcs12->virtual_processor_id != VAR_3->nested.last_vpid) {
VAR_3->nested.last_vpid = vmcs12->virtual_processor_id;
__vmx_flush_tlb(VAR_0, to_vmx(VAR_0)->nested.vpid02);
}
} else {
vmcs_write16(VAR_106, VAR_3->vpid);
vmx_flush_tlb(VAR_0);
}
}
if (VAR_107) {
ASSERT(VAR_3->pml_pg);
vmcs_write64(VAR_108, page_to_phys(VAR_3->pml_pg));
vmcs_write16(VAR_109, VAR_110 - 1);
}
if (nested_cpu_has_ept(vmcs12)) {
if (nested_ept_init_mmu_context(VAR_0)) {
*VAR_2 = VAR_111;
return 1;
}
} else if (nested_cpu_has2(vmcs12,
VAR_64)) {
vmx_flush_tlb_ept_only(VAR_0);
}
vmx_set_cr0(VAR_0, vmcs12->guest_cr0);
vmcs_writel(VAR_112, nested_read_cr0(vmcs12));
vmx_set_cr4(VAR_0, vmcs12->guest_cr4);
vmcs_writel(VAR_113, nested_read_cr4(vmcs12));
if (VAR_1 &&
(vmcs12->vm_entry_controls & VAR_96))
VAR_0->arch.efer = vmcs12->guest_ia32_efer;
else if (vmcs12->vm_entry_controls & VAR_97)
VAR_0->arch.efer |= (VAR_114 | VAR_115);
else
VAR_0->arch.efer &= ~(VAR_114 | VAR_115);
vmx_set_efer(VAR_0, VAR_0->arch.efer);
if (nested_vmx_load_cr3(VAR_0, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),
VAR_2))
return 1;
if (!VAR_62)
VAR_0->arch.walk_mmu->inject_page_fault = VAR_116;
if (VAR_62) {
vmcs_write64(VAR_117, vmcs12->guest_pdptr0);
vmcs_write64(VAR_118, vmcs12->guest_pdptr1);
vmcs_write64(VAR_119, vmcs12->guest_pdptr2);
vmcs_write64(VAR_120, vmcs12->guest_pdptr3);
}
kvm_register_write(VAR_0, VAR_121, vmcs12->guest_rsp);
kvm_register_write(VAR_0, VAR_122, vmcs12->guest_rip);
return 0;
}",torvalds/linux/51aa68e7d57e3217192d88ce90fd5b8ef29ec94f/vmx.c/vul/before/0.json,"static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
			  bool from_vmentry, u32 *entry_failure_code)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 exec_control, vmcs12_exec_ctrl;

	vmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);
	vmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);
	vmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);
	vmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);
	vmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);
	vmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);
	vmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);
	vmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);
	vmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);
	vmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);
	vmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);
	vmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);
	vmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);
	vmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);
	vmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);
	vmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);
	vmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);
	vmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);
	vmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);
	vmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);
	vmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);
	vmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);
	vmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);
	vmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);
	vmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);
	vmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);
	vmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);
	vmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);
	vmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);
	vmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);
	vmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);
	vmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);
	vmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);
	vmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);
	vmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);
	vmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);

	if (from_vmentry &&
	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS)) {
		kvm_set_dr(vcpu, 7, vmcs12->guest_dr7);
		vmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);
	} else {
		kvm_set_dr(vcpu, 7, vcpu->arch.dr7);
		vmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);
	}
	if (from_vmentry) {
		vmcs_write32(VM_ENTRY_INTR_INFO_FIELD,
			     vmcs12->vm_entry_intr_info_field);
		vmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,
			     vmcs12->vm_entry_exception_error_code);
		vmcs_write32(VM_ENTRY_INSTRUCTION_LEN,
			     vmcs12->vm_entry_instruction_len);
		vmcs_write32(GUEST_INTERRUPTIBILITY_INFO,
			     vmcs12->guest_interruptibility_info);
		vmx->loaded_vmcs->nmi_known_unmasked =
			!(vmcs12->guest_interruptibility_info & GUEST_INTR_STATE_NMI);
	} else {
		vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);
	}
	vmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);
	vmx_set_rflags(vcpu, vmcs12->guest_rflags);
	vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,
		vmcs12->guest_pending_dbg_exceptions);
	vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);
	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);

	if (nested_cpu_has_xsaves(vmcs12))
		vmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);
	vmcs_write64(VMCS_LINK_POINTER, -1ull);

	exec_control = vmcs12->pin_based_vm_exec_control;

	/* Preemption timer setting is only taken from vmcs01.  */
	exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
	exec_control |= vmcs_config.pin_based_exec_ctrl;
	if (vmx->hv_deadline_tsc == -1)
		exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;

	/* Posted interrupts setting is only taken from vmcs12.  */
	if (nested_cpu_has_posted_intr(vmcs12)) {
		vmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;
		vmx->nested.pi_pending = false;
		vmcs_write16(POSTED_INTR_NV, POSTED_INTR_NESTED_VECTOR);
	} else {
		exec_control &= ~PIN_BASED_POSTED_INTR;
	}

	vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);

	vmx->nested.preemption_timer_expired = false;
	if (nested_cpu_has_preemption_timer(vmcs12))
		vmx_start_preemption_timer(vcpu);

	/*
	 * Whether page-faults are trapped is determined by a combination of
	 * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.
	 * If enable_ept, L0 doesn't care about page faults and we should
	 * set all of these to L1's desires. However, if !enable_ept, L0 does
	 * care about (at least some) page faults, and because it is not easy
	 * (if at all possible?) to merge L0 and L1's desires, we simply ask
	 * to exit on each and every L2 page fault. This is done by setting
	 * MASK=MATCH=0 and (see below) EB.PF=1.
	 * Note that below we don't need special code to set EB.PF beyond the
	 * ""or""ing of the EB of vmcs01 and vmcs12, because when enable_ept,
	 * vmcs01's EB.PF is 0 so the ""or"" will take vmcs12's value, and when
	 * !enable_ept, EB.PF is 1, so the ""or"" will always be 1.
	 */
	vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,
		enable_ept ? vmcs12->page_fault_error_code_mask : 0);
	vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,
		enable_ept ? vmcs12->page_fault_error_code_match : 0);

	if (cpu_has_secondary_exec_ctrls()) {
		exec_control = vmx->secondary_exec_control;

		/* Take the following fields only from vmcs12 */
		exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
				  SECONDARY_EXEC_ENABLE_INVPCID |
				  SECONDARY_EXEC_RDTSCP |
				  SECONDARY_EXEC_XSAVES |
				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
				  SECONDARY_EXEC_APIC_REGISTER_VIRT |
				  SECONDARY_EXEC_ENABLE_VMFUNC);
		if (nested_cpu_has(vmcs12,
				   CPU_BASED_ACTIVATE_SECONDARY_CONTROLS)) {
			vmcs12_exec_ctrl = vmcs12->secondary_vm_exec_control &
				~SECONDARY_EXEC_ENABLE_PML;
			exec_control |= vmcs12_exec_ctrl;
		}

		/* All VMFUNCs are currently emulated through L0 vmexits.  */
		if (exec_control & SECONDARY_EXEC_ENABLE_VMFUNC)
			vmcs_write64(VM_FUNCTION_CONTROL, 0);

		if (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {
			vmcs_write64(EOI_EXIT_BITMAP0,
				vmcs12->eoi_exit_bitmap0);
			vmcs_write64(EOI_EXIT_BITMAP1,
				vmcs12->eoi_exit_bitmap1);
			vmcs_write64(EOI_EXIT_BITMAP2,
				vmcs12->eoi_exit_bitmap2);
			vmcs_write64(EOI_EXIT_BITMAP3,
				vmcs12->eoi_exit_bitmap3);
			vmcs_write16(GUEST_INTR_STATUS,
				vmcs12->guest_intr_status);
		}

		/*
		 * Write an illegal value to APIC_ACCESS_ADDR. Later,
		 * nested_get_vmcs12_pages will either fix it up or
		 * remove the VM execution control.
		 */
		if (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)
			vmcs_write64(APIC_ACCESS_ADDR, -1ull);

		vmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);
	}


	/*
	 * Set host-state according to L0's settings (vmcs12 is irrelevant here)
	 * Some constant fields are set here by vmx_set_constant_host_state().
	 * Other fields are different per CPU, and will be set later when
	 * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.
	 */
	vmx_set_constant_host_state(vmx);

	/*
	 * Set the MSR load/store lists to match L0's settings.
	 */
	vmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);
	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);
	vmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));
	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);
	vmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));

	/*
	 * HOST_RSP is normally set correctly in vmx_vcpu_run() just before
	 * entry, but only if the current (host) sp changed from the value
	 * we wrote last (vmx->host_rsp). This cache is no longer relevant
	 * if we switch vmcs, and rather than hold a separate cache per vmcs,
	 * here we just force the write to happen on entry.
	 */
	vmx->host_rsp = 0;

	exec_control = vmx_exec_control(vmx); /* L0's desires */
	exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
	exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
	exec_control &= ~CPU_BASED_TPR_SHADOW;
	exec_control |= vmcs12->cpu_based_vm_exec_control;

	/*
	 * Write an illegal value to VIRTUAL_APIC_PAGE_ADDR. Later, if
	 * nested_get_vmcs12_pages can't fix it up, the illegal value
	 * will result in a VM entry failure.
	 */
	if (exec_control & CPU_BASED_TPR_SHADOW) {
		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, -1ull);
		vmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);
	} else {
#ifdef CONFIG_X86_64
		exec_control |= CPU_BASED_CR8_LOAD_EXITING |
				CPU_BASED_CR8_STORE_EXITING;
#endif
	}

	/*
	 * Merging of IO bitmap not currently supported.
	 * Rather, exit every time.
	 */
	exec_control &= ~CPU_BASED_USE_IO_BITMAPS;
	exec_control |= CPU_BASED_UNCOND_IO_EXITING;

	vmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);

	/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the
	 * bitwise-or of what L1 wants to trap for L2, and what we want to
	 * trap. Note that CR0.TS also needs updating - we do this later.
	 */
	update_exception_bitmap(vcpu);
	vcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;
	vmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);

	/* L2->L1 exit controls are emulated - the hardware exit is to L0 so
	 * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER
	 * bits are further modified by vmx_set_efer() below.
	 */
	vmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);

	/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are
	 * emulated by vmx_set_efer(), below.
	 */
	vm_entry_controls_init(vmx, 
		(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &
			~VM_ENTRY_IA32E_MODE) |
		(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));

	if (from_vmentry &&
	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT)) {
		vmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);
		vcpu->arch.pat = vmcs12->guest_ia32_pat;
	} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {
		vmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);
	}

	set_cr4_guest_host_mask(vmx);

	if (from_vmentry &&
	    vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)
		vmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);

	if (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)
		vmcs_write64(TSC_OFFSET,
			vcpu->arch.tsc_offset + vmcs12->tsc_offset);
	else
		vmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);
	if (kvm_has_tsc_control)
		decache_tsc_multiplier(vmx);

	if (enable_vpid) {
		/*
		 * There is no direct mapping between vpid02 and vpid12, the
		 * vpid02 is per-vCPU for L0 and reused while the value of
		 * vpid12 is changed w/ one invvpid during nested vmentry.
		 * The vpid12 is allocated by L1 for L2, so it will not
		 * influence global bitmap(for vpid01 and vpid02 allocation)
		 * even if spawn a lot of nested vCPUs.
		 */
		if (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {
			vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);
			if (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {
				vmx->nested.last_vpid = vmcs12->virtual_processor_id;
				__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);
			}
		} else {
			vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);
			vmx_flush_tlb(vcpu);
		}

	}

	if (enable_pml) {
		/*
		 * Conceptually we want to copy the PML address and index from
		 * vmcs01 here, and then back to vmcs01 on nested vmexit. But,
		 * since we always flush the log on each vmexit, this happens
		 * to be equivalent to simply resetting the fields in vmcs02.
		 */
		ASSERT(vmx->pml_pg);
		vmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));
		vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);
	}

	if (nested_cpu_has_ept(vmcs12)) {
		if (nested_ept_init_mmu_context(vcpu)) {
			*entry_failure_code = ENTRY_FAIL_DEFAULT;
			return 1;
		}
	} else if (nested_cpu_has2(vmcs12,
				   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {
		vmx_flush_tlb_ept_only(vcpu);
	}

	/*
	 * This sets GUEST_CR0 to vmcs12->guest_cr0, possibly modifying those
	 * bits which we consider mandatory enabled.
	 * The CR0_READ_SHADOW is what L2 should have expected to read given
	 * the specifications by L1; It's not enough to take
	 * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we
	 * have more bits than L1 expected.
	 */
	vmx_set_cr0(vcpu, vmcs12->guest_cr0);
	vmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));

	vmx_set_cr4(vcpu, vmcs12->guest_cr4);
	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));

	if (from_vmentry &&
	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))
		vcpu->arch.efer = vmcs12->guest_ia32_efer;
	else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
		vcpu->arch.efer |= (EFER_LMA | EFER_LME);
	else
		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
	/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
	vmx_set_efer(vcpu, vcpu->arch.efer);

	/* Shadow page tables on either EPT or shadow page tables. */
	if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),
				entry_failure_code))
		return 1;

	if (!enable_ept)
		vcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;

	/*
	 * L1 may access the L2's PDPTR, so save them to construct vmcs12
	 */
	if (enable_ept) {
		vmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);
		vmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);
		vmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);
		vmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);
	}

	kvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);
	kvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);
	return 0;
}","static int prepare_vmcs02(struct kvm_vcpu *VAR_0, struct vmcs12 *vmcs12,
			  bool VAR_1, u32 *VAR_2)
{
	struct vcpu_vmx *VAR_3 = to_vmx(VAR_0);
	u32 VAR_4, VAR_5;

	vmcs_write16(VAR_6, vmcs12->guest_es_selector);
	vmcs_write16(VAR_7, vmcs12->guest_cs_selector);
	vmcs_write16(VAR_8, vmcs12->guest_ss_selector);
	vmcs_write16(VAR_9, vmcs12->guest_ds_selector);
	vmcs_write16(VAR_10, vmcs12->guest_fs_selector);
	vmcs_write16(VAR_11, vmcs12->guest_gs_selector);
	vmcs_write16(VAR_12, vmcs12->guest_ldtr_selector);
	vmcs_write16(VAR_13, vmcs12->guest_tr_selector);
	vmcs_write32(VAR_14, vmcs12->guest_es_limit);
	vmcs_write32(VAR_15, vmcs12->guest_cs_limit);
	vmcs_write32(VAR_16, vmcs12->guest_ss_limit);
	vmcs_write32(VAR_17, vmcs12->guest_ds_limit);
	vmcs_write32(VAR_18, vmcs12->guest_fs_limit);
	vmcs_write32(VAR_19, vmcs12->guest_gs_limit);
	vmcs_write32(VAR_20, vmcs12->guest_ldtr_limit);
	vmcs_write32(VAR_21, vmcs12->guest_tr_limit);
	vmcs_write32(VAR_22, vmcs12->guest_gdtr_limit);
	vmcs_write32(VAR_23, vmcs12->guest_idtr_limit);
	vmcs_write32(VAR_24, vmcs12->guest_es_ar_bytes);
	vmcs_write32(VAR_25, vmcs12->guest_cs_ar_bytes);
	vmcs_write32(VAR_26, vmcs12->guest_ss_ar_bytes);
	vmcs_write32(VAR_27, vmcs12->guest_ds_ar_bytes);
	vmcs_write32(VAR_28, vmcs12->guest_fs_ar_bytes);
	vmcs_write32(VAR_29, vmcs12->guest_gs_ar_bytes);
	vmcs_write32(VAR_30, vmcs12->guest_ldtr_ar_bytes);
	vmcs_write32(VAR_31, vmcs12->guest_tr_ar_bytes);
	vmcs_writel(VAR_32, vmcs12->guest_es_base);
	vmcs_writel(VAR_33, vmcs12->guest_cs_base);
	vmcs_writel(VAR_34, vmcs12->guest_ss_base);
	vmcs_writel(VAR_35, vmcs12->guest_ds_base);
	vmcs_writel(VAR_36, vmcs12->guest_fs_base);
	vmcs_writel(VAR_37, vmcs12->guest_gs_base);
	vmcs_writel(VAR_38, vmcs12->guest_ldtr_base);
	vmcs_writel(VAR_39, vmcs12->guest_tr_base);
	vmcs_writel(VAR_40, vmcs12->guest_gdtr_base);
	vmcs_writel(VAR_41, vmcs12->guest_idtr_base);

	if (VAR_1 &&
	    (vmcs12->vm_entry_controls & VAR_42)) {
		kvm_set_dr(VAR_0, 7, vmcs12->guest_dr7);
		vmcs_write64(VAR_43, vmcs12->guest_ia32_debugctl);
	} else {
		kvm_set_dr(VAR_0, 7, VAR_0->arch.dr7);
		vmcs_write64(VAR_43, VAR_3->nested.vmcs01_debugctl);
	}
	if (VAR_1) {
		vmcs_write32(VAR_44,
			     vmcs12->vm_entry_intr_info_field);
		vmcs_write32(VAR_45,
			     vmcs12->vm_entry_exception_error_code);
		vmcs_write32(VAR_46,
			     vmcs12->vm_entry_instruction_len);
		vmcs_write32(VAR_47,
			     vmcs12->guest_interruptibility_info);
		VAR_3->loaded_vmcs->nmi_known_unmasked =
			!(vmcs12->guest_interruptibility_info & VAR_48);
	} else {
		vmcs_write32(VAR_44, 0);
	}
	vmcs_write32(VAR_49, vmcs12->guest_sysenter_cs);
	vmx_set_rflags(VAR_0, vmcs12->guest_rflags);
	vmcs_writel(VAR_50,
		vmcs12->guest_pending_dbg_exceptions);
	vmcs_writel(VAR_51, vmcs12->guest_sysenter_esp);
	vmcs_writel(VAR_52, vmcs12->guest_sysenter_eip);

	if (nested_cpu_has_xsaves(vmcs12))
		vmcs_write64(VAR_53, vmcs12->xss_exit_bitmap);
	vmcs_write64(VAR_54, -1ull);

	VAR_4 = vmcs12->pin_based_vm_exec_control;

	/* COMMENT_0 */
	VAR_4 &= ~VAR_55;
	VAR_4 |= VAR_56.pin_based_exec_ctrl;
	if (VAR_3->hv_deadline_tsc == -1)
		VAR_4 &= ~VAR_55;

	/* COMMENT_1 */
	if (nested_cpu_has_posted_intr(vmcs12)) {
		VAR_3->nested.posted_intr_nv = vmcs12->posted_intr_nv;
		VAR_3->nested.pi_pending = false;
		vmcs_write16(VAR_57, VAR_58);
	} else {
		VAR_4 &= ~VAR_59;
	}

	vmcs_write32(VAR_60, VAR_4);

	VAR_3->nested.preemption_timer_expired = false;
	if (nested_cpu_has_preemption_timer(vmcs12))
		vmx_start_preemption_timer(VAR_0);

	/* COMMENT_2 */
                                                                     
                                                              
                                                                  
                                                                      
                                                                      
                                                                     
                                                                    
                                         
                                                                      
                                                                    
                                                                      
                                                          
    
	vmcs_write32(VAR_61,
		VAR_62 ? vmcs12->page_fault_error_code_mask : 0);
	vmcs_write32(VAR_63,
		VAR_62 ? vmcs12->page_fault_error_code_match : 0);

	if (cpu_has_secondary_exec_ctrls()) {
		VAR_4 = VAR_3->secondary_exec_control;

		/* COMMENT_16 */
		VAR_4 &= ~(VAR_64 |
				  VAR_65 |
				  VAR_66 |
				  VAR_67 |
				  VAR_68 |
				  VAR_69 |
				  VAR_70);
		if (nested_cpu_has(vmcs12,
				   VAR_71)) {
			VAR_5 = vmcs12->secondary_vm_exec_control &
				~VAR_72;
			VAR_4 |= VAR_5;
		}

		/* COMMENT_17 */
		if (VAR_4 & VAR_70)
			vmcs_write64(VAR_73, 0);

		if (VAR_4 & VAR_68) {
			vmcs_write64(VAR_74,
				vmcs12->eoi_exit_bitmap0);
			vmcs_write64(VAR_75,
				vmcs12->eoi_exit_bitmap1);
			vmcs_write64(VAR_76,
				vmcs12->eoi_exit_bitmap2);
			vmcs_write64(VAR_77,
				vmcs12->eoi_exit_bitmap3);
			vmcs_write16(VAR_78,
				vmcs12->guest_intr_status);
		}

		/* COMMENT_18 */
                                                       
                                                     
                                     
     
		if (VAR_4 & VAR_64)
			vmcs_write64(VAR_79, -1ull);

		vmcs_write32(VAR_80, VAR_4);
	}


	/* COMMENT_23 */
                                                                         
                                                                       
                                                                  
                                                                        
    
	vmx_set_constant_host_state(VAR_3);

	/* COMMENT_29 */
                                                        
    
	vmcs_write32(VAR_81, 0);
	vmcs_write32(VAR_82, VAR_3->msr_autoload.nr);
	vmcs_write64(VAR_83, __pa(VAR_3->msr_autoload.host));
	vmcs_write32(VAR_84, VAR_3->msr_autoload.nr);
	vmcs_write64(VAR_85, __pa(VAR_3->msr_autoload.guest));

	/* COMMENT_32 */
                                                                    
                                                                   
                                                                   
                                                                      
                                                    
    
	VAR_3->host_rsp = 0;

	VAR_4 = vmx_exec_control(VAR_3); /* COMMENT_39 */
	VAR_4 &= ~VAR_86;
	VAR_4 &= ~VAR_87;
	VAR_4 &= ~VAR_88;
	VAR_4 |= vmcs12->cpu_based_vm_exec_control;

	/* COMMENT_40 */
                                                               
                                                              
                                      
    
	if (VAR_4 & VAR_88) {
		vmcs_write64(VAR_89, -1ull);
		vmcs_write32(VAR_90, vmcs12->tpr_threshold);
	} else {
#ifdef VAR_91
		VAR_4 |= VAR_92 |
				VAR_93;
#endif
	}

	/* COMMENT_45 */
                                                 
                            
    
	VAR_4 &= ~VAR_94;
	VAR_4 |= VAR_95;

	vmcs_write32(VAR_96, VAR_4);

	/* COMMENT_49 */
                                                                   
                                                                  
    
	update_exception_bitmap(VAR_0);
	VAR_0->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;
	vmcs_writel(VAR_97, ~VAR_0->arch.cr0_guest_owned_bits);

	/* COMMENT_53 */
                                                                     
                                                      
    
	vmcs_write32(VAR_98, VAR_56.vmexit_ctrl);

	/* COMMENT_57 */
                                      
    
	vm_entry_controls_init(VAR_3, 
		(vmcs12->vm_entry_controls & ~VAR_99 &
			~VAR_100) |
		(VAR_56.vmentry_ctrl & ~VAR_100));

	if (VAR_1 &&
	    (vmcs12->vm_entry_controls & VAR_101)) {
		vmcs_write64(VAR_102, vmcs12->guest_ia32_pat);
		VAR_0->arch.pat = vmcs12->guest_ia32_pat;
	} else if (VAR_56.vmentry_ctrl & VAR_101) {
		vmcs_write64(VAR_102, VAR_3->vcpu.arch.pat);
	}

	set_cr4_guest_host_mask(VAR_3);

	if (VAR_1 &&
	    vmcs12->vm_entry_controls & VAR_103)
		vmcs_write64(VAR_104, vmcs12->guest_bndcfgs);

	if (vmcs12->cpu_based_vm_exec_control & VAR_105)
		vmcs_write64(VAR_106,
			VAR_0->arch.tsc_offset + vmcs12->tsc_offset);
	else
		vmcs_write64(VAR_106, VAR_0->arch.tsc_offset);
	if (VAR_107)
		decache_tsc_multiplier(VAR_3);

	if (VAR_108) {
		/* COMMENT_60 */
                                                              
                                                            
                                                            
                                                         
                                                              
                                         
     
		if (nested_cpu_has_vpid(vmcs12) && VAR_3->nested.vpid02) {
			vmcs_write16(VAR_109, VAR_3->nested.vpid02);
			if (vmcs12->virtual_processor_id != VAR_3->nested.last_vpid) {
				VAR_3->nested.last_vpid = vmcs12->virtual_processor_id;
				__vmx_flush_tlb(VAR_0, to_vmx(VAR_0)->nested.vpid02);
			}
		} else {
			vmcs_write16(VAR_109, VAR_3->vpid);
			vmx_flush_tlb(VAR_0);
		}

	}

	if (VAR_110) {
		/* COMMENT_68 */
                                                                
                                                                
                                                               
                                                               
     
		ASSERT(VAR_3->pml_pg);
		vmcs_write64(VAR_111, page_to_phys(VAR_3->pml_pg));
		vmcs_write16(VAR_112, VAR_113 - 1);
	}

	if (nested_cpu_has_ept(vmcs12)) {
		if (nested_ept_init_mmu_context(VAR_0)) {
			*VAR_2 = VAR_114;
			return 1;
		}
	} else if (nested_cpu_has2(vmcs12,
				   VAR_64)) {
		vmx_flush_tlb_ept_only(VAR_0);
	}

	/* COMMENT_74 */
                                                                      
                                             
                                                                     
                                                     
                                                                    
                                    
    
	vmx_set_cr0(VAR_0, vmcs12->guest_cr0);
	vmcs_writel(VAR_115, nested_read_cr0(vmcs12));

	vmx_set_cr4(VAR_0, vmcs12->guest_cr4);
	vmcs_writel(VAR_116, nested_read_cr4(vmcs12));

	if (VAR_1 &&
	    (vmcs12->vm_entry_controls & VAR_99))
		VAR_0->arch.efer = vmcs12->guest_ia32_efer;
	else if (vmcs12->vm_entry_controls & VAR_100)
		VAR_0->arch.efer |= (VAR_117 | VAR_118);
	else
		VAR_0->arch.efer &= ~(VAR_117 | VAR_118);
	/* COMMENT_82 */
	vmx_set_efer(VAR_0, VAR_0->arch.efer);

	/* COMMENT_83 */
	if (nested_vmx_load_cr3(VAR_0, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),
				VAR_2))
		return 1;

	if (!VAR_62)
		VAR_0->arch.walk_mmu->inject_page_fault = VAR_119;

	/* COMMENT_84 */
                                                                  
    
	if (VAR_62) {
		vmcs_write64(VAR_120, vmcs12->guest_pdptr0);
		vmcs_write64(VAR_121, vmcs12->guest_pdptr1);
		vmcs_write64(VAR_122, vmcs12->guest_pdptr2);
		vmcs_write64(VAR_123, vmcs12->guest_pdptr3);
	}

	kvm_register_write(VAR_0, VAR_124, vmcs12->guest_rsp);
	kvm_register_write(VAR_0, VAR_125, vmcs12->guest_rip);
	return 0;
}",torvalds/linux/51aa68e7d57e3217192d88ce90fd5b8ef29ec94f/vmx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -203,6 +203,11 @@
 	if (exec_control & CPU_BASED_TPR_SHADOW) {
 		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, -1ull);
 		vmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);
+	} else {
+#ifdef CONFIG_X86_64
+		exec_control |= CPU_BASED_CR8_LOAD_EXITING |
+				CPU_BASED_CR8_STORE_EXITING;
+#endif
 	}
 
 	/*","{'deleted_lines': [], 'added_lines': ['\t} else {', '#ifdef CONFIG_X86_64', '\t\texec_control |= CPU_BASED_CR8_LOAD_EXITING |', '\t\t\t\tCPU_BASED_CR8_STORE_EXITING;', '#endif']}",True,"The prepare_vmcs02 function in arch/x86/kvm/vmx.c in the Linux kernel through 4.13.3 does not ensure that the ""CR8-load exiting"" and ""CR8-store exiting"" L0 vmcs02 controls exist in cases where L1 omits the ""use TPR shadow"" vmcs12 control, which allows KVM L2 guest OS users to obtain read and write access to the hardware CR8 register.",7.1,HIGH,2,valid,2017-09-12T20:02:54Z,2
CVE-2018-14466,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,the-tcpdump-group/tcpdump,"(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug

In rx_cache_insert() and rx_cache_find() properly read the serviceId
field of the rx_header structure as a 16-bit integer. When those
functions tried to read 32 bits the extra 16 bits could be outside of
the bounds checked in rx_print() for the rx_header structure, as
serviceId is the last field in that structure.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",c24922e692a52121e853a84ead6b9337f4c08a94,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,print-rx.c,rx_cache_find,"static int
rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,
int32_t *opcode)
{
int i;
struct rx_cache_entry *rxent;
uint32_t clip;
uint32_t sip;
UNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));
UNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));
i = rx_cache_hint;
do {
rxent = &rx_cache[i];
if (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&
rxent->client.s_addr == clip &&
rxent->server.s_addr == sip &&
rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
rxent->dport == sport) {
rx_cache_hint = i;
*opcode = rxent->opcode;
return(1);
}
if (++i >= RX_CACHE_SIZE)
i = 0;
} while (i != rx_cache_hint);
return(0);
}","static int
rx_cache_find(const struct rx_header *VAR_0, const struct ip *ip, int VAR_1,
int32_t *VAR_2)
{
int VAR_3;
struct rx_cache_entry *VAR_4;
uint32_t VAR_5;
uint32_t VAR_6;
UNALIGNED_MEMCPY(&VAR_5, &ip->ip_dst, sizeof(uint32_t));
UNALIGNED_MEMCPY(&VAR_6, &ip->ip_src, sizeof(uint32_t));
VAR_3 = VAR_7;
do {
VAR_4 = &VAR_8[VAR_3];
if (VAR_4->callnum == EXTRACT_32BITS(&VAR_0->callNumber) &&
VAR_4->client.s_addr == VAR_5 &&
VAR_4->server.s_addr == VAR_6 &&
VAR_4->serviceId == EXTRACT_32BITS(&VAR_0->serviceId) &&
VAR_4->dport == VAR_1) {
VAR_7 = VAR_3;
*VAR_2 = VAR_4->opcode;
return(1);
}
if (++VAR_3 >= VAR_9)
VAR_3 = 0;
} while (VAR_3 != VAR_7);
return(0);
}",the-tcpdump-group/tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94/print-rx.c/vul/before/0.json,"static int
rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,
	      int32_t *opcode)
{
	int i;
	struct rx_cache_entry *rxent;
	uint32_t clip;
	uint32_t sip;

	UNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));
	UNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));

	/* Start the search where we last left off */

	i = rx_cache_hint;
	do {
		rxent = &rx_cache[i];
		if (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&
		    rxent->client.s_addr == clip &&
		    rxent->server.s_addr == sip &&
		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
		    rxent->dport == sport) {

			/* We got a match! */

			rx_cache_hint = i;
			*opcode = rxent->opcode;
			return(1);
		}
		if (++i >= RX_CACHE_SIZE)
			i = 0;
	} while (i != rx_cache_hint);

	/* Our search failed */
	return(0);
}","static int
rx_cache_find(const struct rx_header *VAR_0, const struct ip *ip, int VAR_1,
	      int32_t *VAR_2)
{
	int VAR_3;
	struct rx_cache_entry *VAR_4;
	uint32_t VAR_5;
	uint32_t VAR_6;

	UNALIGNED_MEMCPY(&VAR_5, &ip->ip_dst, sizeof(uint32_t));
	UNALIGNED_MEMCPY(&VAR_6, &ip->ip_src, sizeof(uint32_t));

	/* COMMENT_0 */

	VAR_3 = VAR_7;
	do {
		VAR_4 = &VAR_8[VAR_3];
		if (VAR_4->callnum == EXTRACT_32BITS(&VAR_0->callNumber) &&
		    VAR_4->client.s_addr == VAR_5 &&
		    VAR_4->server.s_addr == VAR_6 &&
		    VAR_4->serviceId == EXTRACT_16BITS(&VAR_0->serviceId) &&
		    VAR_4->dport == VAR_1) {

			/* COMMENT_1 */

			VAR_7 = VAR_3;
			*VAR_2 = VAR_4->opcode;
			return(1);
		}
		if (++VAR_3 >= VAR_9)
			VAR_3 = 0;
	} while (VAR_3 != VAR_7);

	/* COMMENT_2 */
	return(0);
}",the-tcpdump-group/tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94/print-rx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
 		if (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&
 		    rxent->client.s_addr == clip &&
 		    rxent->server.s_addr == sip &&
-		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
+		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
 		    rxent->dport == sport) {
 
 			/* We got a match! */","{'deleted_lines': ['\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&'], 'added_lines': ['\t\t    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&']}",True,The Rx parser in tcpdump before 4.9.3 has a buffer over-read in print-rx.c:rx_cache_find() and rx_cache_insert().,7.5,HIGH,2,valid,2017-09-19T12:33:55Z,2
CVE-2018-14466,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,the-tcpdump-group/tcpdump,"(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug

In rx_cache_insert() and rx_cache_find() properly read the serviceId
field of the rx_header structure as a 16-bit integer. When those
functions tried to read 32 bits the extra 16 bits could be outside of
the bounds checked in rx_print() for the rx_header structure, as
serviceId is the last field in that structure.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",c24922e692a52121e853a84ead6b9337f4c08a94,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,print-rx.c,rx_cache_insert,"static void
rx_cache_insert(netdissect_options *ndo,
const u_char *bp, const struct ip *ip, int dport)
{
struct rx_cache_entry *rxent;
const struct rx_header *rxh = (const struct rx_header *) bp;
if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
return;
rxent = &rx_cache[rx_cache_next];
if (++rx_cache_next >= RX_CACHE_SIZE)
rx_cache_next = 0;
rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
rxent->dport = dport;
rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
}","static void
rx_cache_insert(netdissect_options *VAR_0,
const u_char *VAR_1, const struct ip *ip, int VAR_2)
{
struct rx_cache_entry *VAR_3;
const struct rx_header *VAR_4 = (const struct rx_header *) VAR_1;
if (VAR_0->ndo_snapend - VAR_1 + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
return;
VAR_3 = &VAR_5[VAR_6];
if (++VAR_6 >= VAR_7)
VAR_6 = 0;
VAR_3->callnum = EXTRACT_32BITS(&VAR_4->callNumber);
UNALIGNED_MEMCPY(&VAR_3->client, &ip->ip_src, sizeof(uint32_t));
UNALIGNED_MEMCPY(&VAR_3->server, &ip->ip_dst, sizeof(uint32_t));
VAR_3->dport = VAR_2;
VAR_3->serviceId = EXTRACT_32BITS(&VAR_4->serviceId);
VAR_3->opcode = EXTRACT_32BITS(VAR_1 + sizeof(struct rx_header));
}",the-tcpdump-group/tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94/print-rx.c/vul/before/1.json,"static void
rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
	rxent->dport = dport;
	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
}","static void
rx_cache_insert(netdissect_options *VAR_0,
                const u_char *VAR_1, const struct ip *ip, int VAR_2)
{
	struct rx_cache_entry *VAR_3;
	const struct rx_header *VAR_4 = (const struct rx_header *) VAR_1;

	if (VAR_0->ndo_snapend - VAR_1 + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	VAR_3 = &VAR_5[VAR_6];

	if (++VAR_6 >= VAR_7)
		VAR_6 = 0;

	VAR_3->callnum = EXTRACT_32BITS(&VAR_4->callNumber);
	UNALIGNED_MEMCPY(&VAR_3->client, &ip->ip_src, sizeof(uint32_t));
	UNALIGNED_MEMCPY(&VAR_3->server, &ip->ip_dst, sizeof(uint32_t));
	VAR_3->dport = VAR_2;
	VAR_3->serviceId = EXTRACT_16BITS(&VAR_4->serviceId);
	VAR_3->opcode = EXTRACT_32BITS(VAR_1 + sizeof(struct rx_header));
}",the-tcpdump-group/tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94/print-rx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,6 +17,6 @@
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
+	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }","{'deleted_lines': ['\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);'], 'added_lines': ['\trxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);']}",True,The Rx parser in tcpdump before 4.9.3 has a buffer over-read in print-rx.c:rx_cache_find() and rx_cache_insert().,7.5,HIGH,2,valid,2017-09-19T12:33:55Z,2
CVE-2017-15189,['CWE-772'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Docsis: fix an infinite loop

Add missing decrement of concatlen based on master-2.2 version.

Bug: 14080
Change-Id: I00f7e34f8e599718316a4ce8916d91b780ec7c14
Reviewed-on: https://code.wireshark.org/review/23663
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",625bab309d9dd21db2d8ae2aa3511810d32842a8,https://github.com/wireshark/wireshark/commit/625bab309d9dd21db2d8ae2aa3511810d32842a8,plugins/docsis/packet-docsis.c,dissect_docsis,"static int
dissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)
{
guint8 fc = 0;
guint8 fctype = 0;
guint8 fcparm = 0;
guint8 exthdr = 0;
guint16 mac_parm = 0;
guint8 hdrlen = DOCSIS_MIN_HEADER_LEN;
guint16 len_sid = 0;
tvbuff_t *next_tvb = NULL;
tvbuff_t *mgt_tvb = NULL;
gint pdulen = 0;
guint16 payload_length = 0;
guint16 framelen = 0;
gboolean save_fragmented;
proto_item *ti;
proto_tree *docsis_tree;
static guint16 concatlen;
static guint16 concatpos;
fc = tvb_get_guint8 (tvb, 0); 
fctype = (fc >> 6) & 0x03;    
fcparm = (fc >> 1) & 0x1F;    
exthdr = (fc & 0x01);         
if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) {
mac_parm = tvb_get_ntohs (tvb, 1);
len_sid = tvb_get_ntohs (tvb, 3);
hdrlen = DOCSIS_MIN_HEADER_LEN + 1;   } else {
mac_parm = tvb_get_guint8 (tvb, 1);
len_sid = tvb_get_ntohs (tvb, 2);
}
if (exthdr == EXT_HDR_ON) {
hdrlen += mac_parm;
}
payload_length = tvb_captured_length_remaining (tvb, hdrlen);
if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM))
{
pdulen = 0;
if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)
framelen = DOCSIS_MIN_HEADER_LEN + 1;
else
framelen = DOCSIS_MIN_HEADER_LEN;
} else {
framelen = DOCSIS_MIN_HEADER_LEN + len_sid;
pdulen = len_sid - (mac_parm + 2);
}
col_set_str (pinfo->cinfo, COL_PROTOCOL, ""DOCSIS"");
switch (fctype)
{
case FCTYPE_PACKET:
col_set_str (pinfo->cinfo, COL_INFO, ""Packet PDU"");
break;
case FCTYPE_RESERVED:
col_set_str (pinfo->cinfo, COL_INFO, ""Reserved PDU"");
break;
case FCTYPE_ISOLAT:
col_set_str (pinfo->cinfo, COL_INFO, ""Isolation PDU"");
break;
case FCTYPE_MACSPC:
if (fcparm == FCPARM_RQST_FRM)
col_add_fstr (pinfo->cinfo, COL_INFO,
""Request Frame SID = %u Mini Slots = %u"", len_sid,
mac_parm);
else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)
col_add_fstr (pinfo->cinfo, COL_INFO,
""Request Frame SID = %u Bytes Requested = %u"", len_sid,
mac_parm);
else if (fcparm == FCPARM_FRAG_HDR)
col_set_str (pinfo->cinfo, COL_INFO, ""Fragmented Frame"");
else
col_set_str (pinfo->cinfo, COL_INFO, ""Mac Specific"");
break;
}  
ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA);
docsis_tree = proto_item_add_subtree (ti, ett_docsis);
proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);
switch (fctype)
{
case FCTYPE_PACKET:
{
proto_item_append_text (ti, "" Packet PDU"");
proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
if (pdulen > 0)
{
next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
}
if (concatlen > 0)
{
concatlen = concatlen - framelen;
concatpos += framelen;
}
break;
}
case FCTYPE_RESERVED:
{
proto_item_append_text (ti, "" Reserved PDU"");
proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
if (concatlen > 0)
{
concatlen = concatlen - framelen;
concatpos += framelen;
}
next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
call_data_dissector(next_tvb, pinfo, tree);
break;
}
case FCTYPE_ISOLAT:
{
proto_item_append_text (ti, "" Isolation PDU"");
proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
if (pdulen > 0)
{
next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
}
if (concatlen > 0)
{
concatlen = concatlen - framelen;
concatpos += framelen;
}
break;
}
case FCTYPE_MACSPC:
{
proto_item_append_text (ti, "" MAC-Specific PDU"");
proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
switch(fcparm)
{
case FCPARM_TIMING_HDR:
case FCPARM_MAC_MGMT_HDR:
{
dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);
call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);
break;
}
case FCPARM_RQST_FRM:
{
proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm);
proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
if (concatlen > 0)
{
concatlen = concatlen - framelen;
concatpos += framelen;
}
break;
}
case FCPARM_FRAG_HDR:
{
save_fragmented = pinfo->fragmented;
pinfo->fragmented = TRUE;
dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4));
guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4);
if (sent_fcs == fcs)
{
fragment_item *frag_msg = NULL;
frag_msg = fragment_add_seq_check(&docsis_reassembly_table,
tvb, hdrlen, pinfo,
frag_sid, NULL, 
frag_seq, 
(len_sid - 4), 
!(frag_flags & FRAG_LAST)); 
next_tvb = process_reassembled_data(tvb, hdrlen, pinfo,
""Reassembled Message"", frag_msg, &docsis_frag_items,
NULL, docsis_tree);
if (frag_flags == FRAG_LAST)
pinfo->fragmented = FALSE;
else
pinfo->fragmented = TRUE;
if (frag_msg) { 
proto_item_append_text (ti, "" (Message Reassembled)"");
} else { 
proto_item_append_text (ti, "" (Message fragment %u)"", frag_seq);
}
if(next_tvb)
{
call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
} else {
tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1);
call_data_dissector(payload_tvb, pinfo, docsis_tree);
}
} else {
expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad);
}
proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);
pinfo->fragmented = save_fragmented;
break;
}
case FCPARM_QUEUE_DEPTH_REQ_FRM:
{
proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm);
proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
if (concatlen > 0)
{
concatlen = concatlen - framelen;
concatpos += framelen;
}
break;
}
case FCPARM_CONCAT_HDR:
{
proto_item_append_text (ti, "" (Concatenated Header)"");
proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN);
proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN);
dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
concatlen = len_sid;
concatpos = DOCSIS_MIN_HEADER_LEN;
while (concatlen > 0)
{
next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen);
call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree);
}
concatlen = 0;
concatpos = 0;
break;
}
default:
concatlen = 0;
break;
} 
break;
}
} 
return tvb_captured_length(tvb);
}","static int
dissect_docsis (tvbuff_t * VAR_0, packet_info * VAR_1, proto_tree * VAR_2, void* VAR_3 _U_)
{
guint8 VAR_4 = 0;
guint8 VAR_5 = 0;
guint8 VAR_6 = 0;
guint8 VAR_7 = 0;
guint16 VAR_8 = 0;
guint8 VAR_9 = VAR_10;
guint16 VAR_11 = 0;
tvbuff_t *VAR_12 = NULL;
tvbuff_t *VAR_13 = NULL;
gint VAR_14 = 0;
guint16 VAR_15 = 0;
guint16 VAR_16 = 0;
gboolean VAR_17;
proto_item *VAR_18;
proto_tree *VAR_19;
static guint16 VAR_20;
static guint16 VAR_21;
VAR_4 = tvb_get_guint8 (VAR_0, 0); 
VAR_5 = (VAR_4 >> 6) & 0x03;    
VAR_6 = (VAR_4 >> 1) & 0x1F;    
VAR_7 = (VAR_4 & 0x01);         
if (VAR_6 == VAR_22) {
VAR_8 = tvb_get_ntohs (VAR_0, 1);
VAR_11 = tvb_get_ntohs (VAR_0, 3);
VAR_9 = VAR_10 + 1; 
} else {
VAR_8 = tvb_get_guint8 (VAR_0, 1);
VAR_11 = tvb_get_ntohs (VAR_0, 2);
}
if (VAR_7 == VAR_23) {
VAR_9 += VAR_8;
}
VAR_15 = tvb_captured_length_remaining (VAR_0, VAR_9);
if ((VAR_5 == VAR_24) && (VAR_6 == VAR_25 || VAR_6 == VAR_22))
{
VAR_14 = 0;
if (VAR_6 == VAR_22)
VAR_16 = VAR_10 + 1;
else
VAR_16 = VAR_10;
} else {
VAR_16 = VAR_10 + VAR_11;
VAR_14 = VAR_11 - (VAR_8 + 2);
}
col_set_str (VAR_1->cinfo, VAR_26, ""DOCSIS"");
switch (VAR_5)
{
case VAR_27:
col_set_str (VAR_1->cinfo, VAR_28, ""Packet PDU"");
break;
case VAR_29:
col_set_str (VAR_1->cinfo, VAR_28, ""Reserved PDU"");
break;
case VAR_30:
col_set_str (VAR_1->cinfo, VAR_28, ""Isolation PDU"");
break;
case VAR_24:
if (VAR_6 == VAR_25)
col_add_fstr (VAR_1->cinfo, VAR_28,
""Request Frame SID = %u Mini Slots = %u"", VAR_11,
VAR_8);
else if (VAR_6 == VAR_22)
col_add_fstr (VAR_1->cinfo, VAR_28,
""Request Frame SID = %u Bytes Requested = %u"", VAR_11,
VAR_8);
else if (VAR_6 == VAR_31)
col_set_str (VAR_1->cinfo, VAR_28, ""Fragmented Frame"");
else
col_set_str (VAR_1->cinfo, VAR_28, ""Mac Specific"");
break;
}  
VAR_18 = proto_tree_add_item(VAR_2, VAR_32, VAR_0, 0, VAR_9, VAR_33);
VAR_19 = proto_item_add_subtree (VAR_18, VAR_34);
proto_tree_add_item (VAR_19, VAR_35, VAR_0, 0, 1, VAR_36);
switch (VAR_5)
{
case VAR_27:
{
proto_item_append_text (VAR_18, "" Packet PDU"");
proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
if (VAR_14 > 0)
{
VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
}
if (VAR_20 > 0)
{
VAR_20 = VAR_20 - VAR_16;
VAR_21 += VAR_16;
}
break;
}
case VAR_29:
{
proto_item_append_text (VAR_18, "" Reserved PDU"");
proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
if (VAR_20 > 0)
{
VAR_20 = VAR_20 - VAR_16;
VAR_21 += VAR_16;
}
VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
call_data_dissector(VAR_12, VAR_1, VAR_2);
break;
}
case VAR_30:
{
proto_item_append_text (VAR_18, "" Isolation PDU"");
proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
if (VAR_14 > 0)
{
VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
}
if (VAR_20 > 0)
{
VAR_20 = VAR_20 - VAR_16;
VAR_21 += VAR_16;
}
break;
}
case VAR_24:
{
proto_item_append_text (VAR_18, "" MAC-Specific PDU"");
proto_tree_add_item (VAR_19, VAR_40, VAR_0, 0, 1, VAR_36);
proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
switch(VAR_6)
{
case VAR_41:
case VAR_42:
{
dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
VAR_13 = tvb_new_subset_remaining(VAR_0, VAR_9);
call_dissector (VAR_43, VAR_13, VAR_1, VAR_19);
break;
}
case VAR_25:
{
proto_tree_add_uint (VAR_19, VAR_44, VAR_0, 1, 1, VAR_8);
proto_tree_add_uint (VAR_19, VAR_45, VAR_0, 2, 2, VAR_11);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
if (VAR_20 > 0)
{
VAR_20 = VAR_20 - VAR_16;
VAR_21 += VAR_16;
}
break;
}
case VAR_31:
{
VAR_17 = VAR_1->fragmented;
VAR_1->fragmented = TRUE;
dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
guint32 VAR_46 = tvb_get_ntohl(VAR_0, (VAR_9 + VAR_11 - 4));
guint32 VAR_47 = crc32_802_tvb(VAR_0, tvb_captured_length(VAR_0) - 4);
if (VAR_46 == VAR_47)
{
fragment_item *VAR_48 = NULL;
VAR_48 = fragment_add_seq_check(&VAR_49,
VAR_0, VAR_9, VAR_1,
VAR_50, NULL, 
VAR_51, 
(VAR_11 - 4), 
!(VAR_52 & VAR_53)); 
VAR_12 = process_reassembled_data(VAR_0, VAR_9, VAR_1,
""Reassembled Message"", VAR_48, &VAR_54,
NULL, VAR_19);
if (VAR_52 == VAR_53)
VAR_1->fragmented = FALSE;
else
VAR_1->fragmented = TRUE;
if (VAR_48) { 
proto_item_append_text (VAR_18, "" (Message Reassembled)"");
} else { 
proto_item_append_text (VAR_18, "" (Message fragment %u)"", VAR_51);
}
if(VAR_12)
{
call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
} else {
tvbuff_t *VAR_55 = tvb_new_subset_length_caplen(VAR_0, VAR_9, (VAR_11 - 4), -1);
call_data_dissector(VAR_55, VAR_1, VAR_19);
}
} else {
expert_add_info(VAR_1, VAR_18, &VAR_56);
}
proto_tree_add_checksum(VAR_19, VAR_0, (VAR_9 + VAR_11 - 4), VAR_57, VAR_58, &VAR_56, VAR_1, VAR_47, VAR_36, VAR_59);
VAR_1->fragmented = VAR_17;
break;
}
case VAR_22:
{
proto_tree_add_uint (VAR_19, VAR_60, VAR_0, 1, 2, VAR_8);
proto_tree_add_uint (VAR_19, VAR_45, VAR_0, 3, 2, VAR_11);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
if (VAR_20 > 0)
{
VAR_20 = VAR_20 - VAR_16;
VAR_21 += VAR_16;
}
break;
}
case VAR_61:
{
proto_item_append_text (VAR_18, "" (Concatenated Header)"");
proto_tree_add_item (VAR_19, VAR_62, VAR_0, 1, 1, VAR_36);
proto_tree_add_item (VAR_19, VAR_63, VAR_0, 2, 2, VAR_36);
dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
VAR_20 = VAR_11;
VAR_21 = VAR_10;
while (VAR_20 > 0)
{
VAR_12 = tvb_new_subset_length_caplen (VAR_0, VAR_21, -1, VAR_20);
call_dissector (VAR_64, VAR_12, VAR_1, VAR_19);
}
VAR_20 = 0;
VAR_21 = 0;
break;
}
default:
VAR_20 = 0;
break;
} 
break;
}
} 
return tvb_captured_length(VAR_0);
}",,"static int
dissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)
{
  guint8 fc = 0;
  guint8 fctype = 0;
  guint8 fcparm = 0;
  guint8 exthdr = 0;
  guint16 mac_parm = 0;
  guint8 hdrlen = DOCSIS_MIN_HEADER_LEN;
  guint16 len_sid = 0;
  tvbuff_t *next_tvb = NULL;
  tvbuff_t *mgt_tvb = NULL;
  gint pdulen = 0;
  guint16 payload_length = 0;
  guint16 framelen = 0;
  gboolean save_fragmented;

  proto_item *ti;
  proto_tree *docsis_tree;

  /* concatlen and concatpos are declared static to allow for recursive calls to
   * the dissect_docsis routine when dissecting Concatenated frames
   */
  static guint16 concatlen;
  static guint16 concatpos;

  /* Extract Frame Control parts */
  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */
  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */
  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */
  exthdr = (fc & 0x01);         /* Extended Header Bit: LSB */

  /* Extract the MAC Parm; MAC Parm and SID offsets; change for a Queue Depth Request */
  if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) {
    mac_parm = tvb_get_ntohs (tvb, 1);
    len_sid = tvb_get_ntohs (tvb, 3);
    hdrlen = DOCSIS_MIN_HEADER_LEN + 1; // 7-byte header for this message type
  } else {
    mac_parm = tvb_get_guint8 (tvb, 1);
    len_sid = tvb_get_ntohs (tvb, 2);
  }

  /* Set Header Length based on presence of Extended header */
  if (exthdr == EXT_HDR_ON) {
    hdrlen += mac_parm;
  }

  /* Captured Payload Length is based on the length of the header */
  payload_length = tvb_captured_length_remaining (tvb, hdrlen);

  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */
  if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM))
  {
    pdulen = 0;
    if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)
      framelen = DOCSIS_MIN_HEADER_LEN + 1;
    else
      framelen = DOCSIS_MIN_HEADER_LEN;
  } else {
    framelen = DOCSIS_MIN_HEADER_LEN + len_sid;
    pdulen = len_sid - (mac_parm + 2);
  }

  /* Make entries in Protocol column and Info column on summary display */
  col_set_str (pinfo->cinfo, COL_PROTOCOL, ""DOCSIS"");

  switch (fctype)
  {
    case FCTYPE_PACKET:
      col_set_str (pinfo->cinfo, COL_INFO, ""Packet PDU"");
      break;
    case FCTYPE_RESERVED:
      col_set_str (pinfo->cinfo, COL_INFO, ""Reserved PDU"");
      break;
    case FCTYPE_ISOLAT:
      col_set_str (pinfo->cinfo, COL_INFO, ""Isolation PDU"");
      break;
    case FCTYPE_MACSPC:
      if (fcparm == FCPARM_RQST_FRM)
        col_add_fstr (pinfo->cinfo, COL_INFO,
                      ""Request Frame SID = %u Mini Slots = %u"", len_sid,
                      mac_parm);
      else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)
        col_add_fstr (pinfo->cinfo, COL_INFO,
                      ""Request Frame SID = %u Bytes Requested = %u"", len_sid,
                      mac_parm);
      else if (fcparm == FCPARM_FRAG_HDR)
        col_set_str (pinfo->cinfo, COL_INFO, ""Fragmented Frame"");
      else
        col_set_str (pinfo->cinfo, COL_INFO, ""Mac Specific"");
      break;
  }  /* switch fctype */

  ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA);
  docsis_tree = proto_item_add_subtree (ti, ett_docsis);

  /* add an item to the subtree, see section 1.6 for more information */

  /* Add in FC Byte fields */
  proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);

  switch (fctype)
  {
    case FCTYPE_PACKET:
    {
      proto_item_append_text (ti, "" Packet PDU"");
      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
      /* Dissect Length field for a PDU */
      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
      /* Dissect Header Check Sequence field for a PDU */
      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
      if (pdulen > 0)
      {
        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
      }
      if (concatlen > 0)
      {
        concatlen = concatlen - framelen;
        concatpos += framelen;
      }
      break;
    }
    case FCTYPE_RESERVED:
    {
      proto_item_append_text (ti, "" Reserved PDU"");
      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
      /* Dissect Length field for a PDU */
      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
      /* Dissect Header Check Sequence field for a PDU */
      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

      if (concatlen > 0)
      {
        concatlen = concatlen - framelen;
        concatpos += framelen;
      }

      /* Don't do anything for a Reserved Frame */
      next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
      call_data_dissector(next_tvb, pinfo, tree);
      break;
    }
    case FCTYPE_ISOLAT:
    {
      proto_item_append_text (ti, "" Isolation PDU"");
      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
      /* Dissect Length field for a PDU */
      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
      /* Dissect Header Check Sequence field for a PDU */
      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);
      if (pdulen > 0)
      {
        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);
        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
      }
      if (concatlen > 0)
      {
        concatlen = concatlen - framelen;
        concatpos += framelen;
      }
      break;
    }
    case FCTYPE_MACSPC:
    {
      proto_item_append_text (ti, "" MAC-Specific PDU"");
      proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);
      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);
      switch(fcparm)
      {
        case FCPARM_TIMING_HDR:
          // no break
        case FCPARM_MAC_MGMT_HDR:
        {
          /* Dissect Length field for a PDU */
          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
          /* Dissect Header Check Sequence field for a PDU */
          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

          /* Pass off to the DOCSIS Management dissector/s */
          mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);
          call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);

          if (concatlen > 0)
          {
            concatlen = concatlen - framelen;
            concatpos += framelen;
          }

          break;
        }
        case FCPARM_RQST_FRM:
        {
          /* Decode for a Request Frame.  No extended header */
          proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm);
          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid);
          /* Dissect Header Check Sequence field for a PDU */
          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

          if (concatlen > 0)
          {
            concatlen = concatlen - framelen;
            concatpos += framelen;
          }

          /* Don't do anything for a Request Frame, there is no data following it*/
          break;
        }
        case FCPARM_FRAG_HDR:
        {
          /* Check if this is a fragmentation header */
          save_fragmented = pinfo->fragmented;
          pinfo->fragmented = TRUE;

          /* Dissect Length field for a PDU */
          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);
          /* Dissect Header Check Sequence field for a PDU */
          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

          /* Grab the Fragment FCS */
          guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4));
          guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4);

          /* Only defragment valid frames with a good FCS */
          if (sent_fcs == fcs)
          {
            fragment_item *frag_msg = NULL;
            frag_msg = fragment_add_seq_check(&docsis_reassembly_table,
                                              tvb, hdrlen, pinfo,
                                              frag_sid, NULL, /* ID for fragments belonging together */
                                              frag_seq, /* Fragment Sequence Number */
                                              (len_sid - 4), /* fragment length - to the end */
                                              !(frag_flags & FRAG_LAST)); /* More fragments? */

            next_tvb = process_reassembled_data(tvb, hdrlen, pinfo,
                                                ""Reassembled Message"", frag_msg, &docsis_frag_items,
                                                NULL, docsis_tree);

            if (frag_flags == FRAG_LAST)
              pinfo->fragmented = FALSE;
            else
              pinfo->fragmented = TRUE;

            if (frag_msg) { /* Reassembled */
              proto_item_append_text (ti, "" (Message Reassembled)"");
            } else { /* Not last packet of reassembled Short Message */
              proto_item_append_text (ti, "" (Message fragment %u)"", frag_seq);

            }

            if(next_tvb)
            {
              /* By default assume an Ethernet payload */
              call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);
            } else {
              /* Otherwise treat as Data */
              tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1);
              call_data_dissector(payload_tvb, pinfo, docsis_tree);
            }
          } else {
            /* Report frames with a bad FCS */
            expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad);
          }

          /* Add the Fragment FCS to the end of the parent tree */
          proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);

          pinfo->fragmented = save_fragmented;

          if (concatlen > 0)
          {
            concatlen = concatlen - framelen;
            concatpos += framelen;
          }

          break;
        }
        case FCPARM_QUEUE_DEPTH_REQ_FRM:
        {
          /* Decode for a Queue-depth Based Request */
          proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm);
          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid);
          /* Dissect Header Check Sequence field for a PDU */
          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

          if (concatlen > 0)
          {
            concatlen = concatlen - framelen;
            concatpos += framelen;
          }

          /* No PDU Payload for this frame */
          break;
        }
        case FCPARM_CONCAT_HDR:
        {
          /* Decode for a Concatenated Header; ONLY for DOCSIS versions < 3.1.  No Extended Header */
          proto_item_append_text (ti, "" (Concatenated Header)"");
          proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN);
          proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN);
          /* Dissect Header Check Sequence field for a PDU */
          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);

          /* If this is a concatenated frame setup the length of the concatenated
           * frame and set the position to the first byte of the first frame
           */
          concatlen = len_sid;
          concatpos = DOCSIS_MIN_HEADER_LEN;

          /* Call the docsis dissector on the same frame
           * to dissect DOCSIS frames within the concatenated
           * frame.  concatpos and concatlen are declared
           * static and are decremented and incremented
           * respectively when the inner
           * docsis frames are dissected. */
          while (concatlen > 0)
          {
            next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen);
            call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree);
          }
          concatlen = 0;
          concatpos = 0;
          break;
        }
        default:
            /* Unknown parameter, stop dissection */
          concatlen = 0;
          break;
      } /* switch fcparm */
      break;
    }
  } /* switch fctype*/

  return tvb_captured_length(tvb);
}","static int
dissect_docsis (tvbuff_t * VAR_0, packet_info * VAR_1, proto_tree * VAR_2, void* VAR_3 _U_)
{
  guint8 VAR_4 = 0;
  guint8 VAR_5 = 0;
  guint8 VAR_6 = 0;
  guint8 VAR_7 = 0;
  guint16 VAR_8 = 0;
  guint8 VAR_9 = VAR_10;
  guint16 VAR_11 = 0;
  tvbuff_t *VAR_12 = NULL;
  tvbuff_t *VAR_13 = NULL;
  gint VAR_14 = 0;
  guint16 VAR_15 = 0;
  guint16 VAR_16 = 0;
  gboolean VAR_17;

  proto_item *VAR_18;
  proto_tree *VAR_19;

  /* COMMENT_0 */
                                                                   
     
  static guint16 VAR_20;
  static guint16 VAR_21;

  /* COMMENT_3 */
  VAR_4 = tvb_get_guint8 (VAR_0, 0); /* COMMENT_4 */
  VAR_5 = (VAR_4 >> 6) & 0x03;    /* COMMENT_5 */
  VAR_6 = (VAR_4 >> 1) & 0x1F;    /* COMMENT_6 */
  VAR_7 = (VAR_4 & 0x01);         /* COMMENT_7 */

  /* COMMENT_8 */
  if (VAR_6 == VAR_22) {
    VAR_8 = tvb_get_ntohs (VAR_0, 1);
    VAR_11 = tvb_get_ntohs (VAR_0, 3);
    VAR_9 = VAR_10 + 1; /* COMMENT_9 */
  } else {
    VAR_8 = tvb_get_guint8 (VAR_0, 1);
    VAR_11 = tvb_get_ntohs (VAR_0, 2);
  }

  /* COMMENT_10 */
  if (VAR_7 == VAR_23) {
    VAR_9 += VAR_8;
  }

  /* COMMENT_11 */
  VAR_15 = tvb_captured_length_remaining (VAR_0, VAR_9);

  /* COMMENT_12 */
  if ((VAR_5 == VAR_24) && (VAR_6 == VAR_25 || VAR_6 == VAR_22))
  {
    VAR_14 = 0;
    if (VAR_6 == VAR_22)
      VAR_16 = VAR_10 + 1;
    else
      VAR_16 = VAR_10;
  } else {
    VAR_16 = VAR_10 + VAR_11;
    VAR_14 = VAR_11 - (VAR_8 + 2);
  }

  /* COMMENT_13 */
  col_set_str (VAR_1->cinfo, VAR_26, ""DOCSIS"");

  switch (VAR_5)
  {
    case VAR_27:
      col_set_str (VAR_1->cinfo, VAR_28, ""Packet PDU"");
      break;
    case VAR_29:
      col_set_str (VAR_1->cinfo, VAR_28, ""Reserved PDU"");
      break;
    case VAR_30:
      col_set_str (VAR_1->cinfo, VAR_28, ""Isolation PDU"");
      break;
    case VAR_24:
      if (VAR_6 == VAR_25)
        col_add_fstr (VAR_1->cinfo, VAR_28,
                      ""Request Frame SID = %u Mini Slots = %u"", VAR_11,
                      VAR_8);
      else if (VAR_6 == VAR_22)
        col_add_fstr (VAR_1->cinfo, VAR_28,
                      ""Request Frame SID = %u Bytes Requested = %u"", VAR_11,
                      VAR_8);
      else if (VAR_6 == VAR_31)
        col_set_str (VAR_1->cinfo, VAR_28, ""Fragmented Frame"");
      else
        col_set_str (VAR_1->cinfo, VAR_28, ""Mac Specific"");
      break;
  }  /* COMMENT_14 */

  VAR_18 = proto_tree_add_item(VAR_2, VAR_32, VAR_0, 0, VAR_9, VAR_33);
  VAR_19 = proto_item_add_subtree (VAR_18, VAR_34);

  /* COMMENT_15 */

  /* COMMENT_16 */
  proto_tree_add_item (VAR_19, VAR_35, VAR_0, 0, 1, VAR_36);

  switch (VAR_5)
  {
    case VAR_27:
    {
      proto_item_append_text (VAR_18, "" Packet PDU"");
      proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
      proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
      /* COMMENT_17 */
      dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
      /* COMMENT_18 */
      dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
      if (VAR_14 > 0)
      {
        VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
        call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
      }
      if (VAR_20 > 0)
      {
        VAR_20 = VAR_20 - VAR_16;
        VAR_21 += VAR_16;
      }
      break;
    }
    case VAR_29:
    {
      proto_item_append_text (VAR_18, "" Reserved PDU"");
      proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
      proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
      /* COMMENT_17 */
      dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
      /* COMMENT_18 */
      dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

      if (VAR_20 > 0)
      {
        VAR_20 = VAR_20 - VAR_16;
        VAR_21 += VAR_16;
      }

      /* COMMENT_19 */
      VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
      call_data_dissector(VAR_12, VAR_1, VAR_2);
      break;
    }
    case VAR_30:
    {
      proto_item_append_text (VAR_18, "" Isolation PDU"");
      proto_tree_add_item (VAR_19, VAR_37, VAR_0, 0, 1, VAR_36);
      proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
      /* COMMENT_17 */
      dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
      /* COMMENT_18 */
      dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);
      if (VAR_14 > 0)
      {
        VAR_12 =  tvb_new_subset_remaining(VAR_0, VAR_9);
        call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
      }
      if (VAR_20 > 0)
      {
        VAR_20 = VAR_20 - VAR_16;
        VAR_21 += VAR_16;
      }
      break;
    }
    case VAR_24:
    {
      proto_item_append_text (VAR_18, "" MAC-Specific PDU"");
      proto_tree_add_item (VAR_19, VAR_40, VAR_0, 0, 1, VAR_36);
      proto_tree_add_item (VAR_19, VAR_38, VAR_0, 0, 1, VAR_36);
      switch(VAR_6)
      {
        case VAR_41:
          /* COMMENT_20 */
        case VAR_42:
        {
          /* COMMENT_17 */
          dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
          /* COMMENT_18 */
          dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

          /* COMMENT_21 */
          VAR_13 = tvb_new_subset_remaining(VAR_0, VAR_9);
          call_dissector (VAR_43, VAR_13, VAR_1, VAR_19);

          if (VAR_20 > 0)
          {
            VAR_20 = VAR_20 - VAR_16;
            VAR_21 += VAR_16;
          }

          break;
        }
        case VAR_25:
        {
          /* COMMENT_22 */
          proto_tree_add_uint (VAR_19, VAR_44, VAR_0, 1, 1, VAR_8);
          proto_tree_add_uint (VAR_19, VAR_45, VAR_0, 2, 2, VAR_11);
          /* COMMENT_18 */
          dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

          if (VAR_20 > 0)
          {
            VAR_20 = VAR_20 - VAR_16;
            VAR_21 += VAR_16;
          }

          /* COMMENT_23 */
          break;
        }
        case VAR_31:
        {
          /* COMMENT_24 */
          VAR_17 = VAR_1->fragmented;
          VAR_1->fragmented = TRUE;

          /* COMMENT_17 */
          dissect_exthdr_length_field (VAR_0, VAR_1, VAR_19, VAR_7, VAR_8, VAR_11, &VAR_15);
          /* COMMENT_18 */
          dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

          /* COMMENT_25 */
          guint32 VAR_46 = tvb_get_ntohl(VAR_0, (VAR_9 + VAR_11 - 4));
          guint32 VAR_47 = crc32_802_tvb(VAR_0, tvb_captured_length(VAR_0) - 4);

          /* COMMENT_26 */
          if (VAR_46 == VAR_47)
          {
            fragment_item *VAR_48 = NULL;
            VAR_48 = fragment_add_seq_check(&VAR_49,
                                              VAR_0, VAR_9, VAR_1,
                                              VAR_50, NULL, /* COMMENT_27 */
                                              VAR_51, /* COMMENT_28 */
                                              (VAR_11 - 4), /* COMMENT_29 */
                                              !(VAR_52 & VAR_53)); /* COMMENT_30 */

            VAR_12 = process_reassembled_data(VAR_0, VAR_9, VAR_1,
                                                ""Reassembled Message"", VAR_48, &VAR_54,
                                                NULL, VAR_19);

            if (VAR_52 == VAR_53)
              VAR_1->fragmented = FALSE;
            else
              VAR_1->fragmented = TRUE;

            if (VAR_48) { /* COMMENT_31 */
              proto_item_append_text (VAR_18, "" (Message Reassembled)"");
            } else { /* COMMENT_32 */
              proto_item_append_text (VAR_18, "" (Message fragment %u)"", VAR_51);

            }

            if(VAR_12)
            {
              /* COMMENT_33 */
              call_dissector (VAR_39, VAR_12, VAR_1, VAR_19);
            } else {
              /* COMMENT_34 */
              tvbuff_t *VAR_55 = tvb_new_subset_length_caplen(VAR_0, VAR_9, (VAR_11 - 4), -1);
              call_data_dissector(VAR_55, VAR_1, VAR_19);
            }
          } else {
            /* COMMENT_35 */
            expert_add_info(VAR_1, VAR_18, &VAR_56);
          }

          /* COMMENT_36 */
          proto_tree_add_checksum(VAR_19, VAR_0, (VAR_9 + VAR_11 - 4), VAR_57, VAR_58, &VAR_56, VAR_1, VAR_47, VAR_36, VAR_59);

          VAR_1->fragmented = VAR_17;

          if (VAR_20 > 0)
          {
            VAR_20 = VAR_20 - VAR_16;
            VAR_21 += VAR_16;
          }

          break;
        }
        case VAR_22:
        {
          /* COMMENT_37 */
          proto_tree_add_uint (VAR_19, VAR_60, VAR_0, 1, 2, VAR_8);
          proto_tree_add_uint (VAR_19, VAR_45, VAR_0, 3, 2, VAR_11);
          /* COMMENT_18 */
          dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

          if (VAR_20 > 0)
          {
            VAR_20 = VAR_20 - VAR_16;
            VAR_21 += VAR_16;
          }

          /* COMMENT_38 */
          break;
        }
        case VAR_61:
        {
          /* COMMENT_39 */
          proto_item_append_text (VAR_18, "" (Concatenated Header)"");
          proto_tree_add_item (VAR_19, VAR_62, VAR_0, 1, 1, VAR_36);
          proto_tree_add_item (VAR_19, VAR_63, VAR_0, 2, 2, VAR_36);
          /* COMMENT_18 */
          dissect_hcs_field (VAR_0, VAR_1, VAR_19, VAR_9);

          /* COMMENT_40 */
                                                                            
             
          VAR_20 = VAR_11;
          VAR_21 = VAR_10;

          /* COMMENT_43 */
                                                             
                                                         
                                                       
                                        
                                            
          while (VAR_20 > 0)
          {
            VAR_12 = tvb_new_subset_length_caplen (VAR_0, VAR_21, -1, VAR_20);
            call_dissector (VAR_64, VAR_12, VAR_1, VAR_19);
          }
          VAR_20 = 0;
          VAR_21 = 0;
          break;
        }
        default:
            /* COMMENT_49 */
          VAR_20 = 0;
          break;
      } /* COMMENT_50 */
      break;
    }
  } /* COMMENT_51 */

  return tvb_captured_length(VAR_0);
}",,"--- func_before
+++ func_after
@@ -183,6 +183,13 @@
           /* Pass off to the DOCSIS Management dissector/s */
           mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);
           call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);
+
+          if (concatlen > 0)
+          {
+            concatlen = concatlen - framelen;
+            concatpos += framelen;
+          }
+
           break;
         }
         case FCPARM_RQST_FRM:
@@ -262,6 +269,13 @@
           proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);
 
           pinfo->fragmented = save_fragmented;
+
+          if (concatlen > 0)
+          {
+            concatlen = concatlen - framelen;
+            concatpos += framelen;
+          }
+
           break;
         }
         case FCPARM_QUEUE_DEPTH_REQ_FRM:","{'deleted_lines': [], 'added_lines': ['', '          if (concatlen > 0)', '          {', '            concatlen = concatlen - framelen;', '            concatpos += framelen;', '          }', '', '', '          if (concatlen > 0)', '          {', '            concatlen = concatlen - framelen;', '            concatpos += framelen;', '          }', '']}",True,"In Wireshark 2.4.0 to 2.4.1, the DOCSIS dissector could go into an infinite loop. This was addressed in plugins/docsis/packet-docsis.c by adding decrements.",7.5,HIGH,2,valid,2017-09-23T20:22:28Z,2
CVE-2017-14245,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,libsndfile,"sfe_copy_data_fp: check value of ""max"" variable for being normal

and check elements of the data[] array for being finite.

Both checks use functions provided by the <math.h> header as declared
by the C99 standard.

Fixes #317
CVE-2017-14245
CVE-2017-14246",00a25b9469f825a57dc3558ce10561ef38a3405e,https://github.com/libsndfile/libsndfile/commit/00a25b9469f825a57dc3558ce10561ef38a3405e,programs/common.c,sfe_copy_data_fp,"void
sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize)
{static doubledata [BUFFER_LEN], max ;
sf_count_tframes, readcount, k ;
frames = BUFFER_LEN / channels ;
readcount = frames ;
sf_command (infile, SFC_CALC_SIGNAL_MAX, &max, sizeof (max)) ;
if (!normalize && max < 1.0)
{while (readcount > 0)
{readcount = sf_readf_double (infile, data, frames) ;
sf_writef_double (outfile, data, readcount) ;
} ;
}
else
{sf_command (infile, SFC_SET_NORM_DOUBLE, NULL, SF_FALSE) ;
while (readcount > 0)
{readcount = sf_readf_double (infile, data, frames) ;
for (k = 0 ; k < readcount * channels ; k++)
data [k] /= max ;
sf_writef_double (outfile, data, readcount) ;
} ;
} ;
return ;
}","void
sfe_copy_data_fp (SNDFILE *VAR_0, SNDFILE *VAR_1, int VAR_2, int VAR_3)
{static doubleVAR_4 [VAR_5], VAR_6 ;
sf_count_tVAR_7, VAR_8, VAR_9 ;
VAR_7 = VAR_5 / VAR_2 ;
VAR_8 = VAR_7 ;
sf_command (VAR_1, VAR_10, &VAR_6, sizeof (VAR_6)) ;
if (!VAR_3 && VAR_6 < 1.0)
{while (VAR_8 > 0)
{VAR_8 = sf_readf_double (VAR_1, VAR_4, VAR_7) ;
sf_writef_double (VAR_0, VAR_4, VAR_8) ;
} ;
}
else
{sf_command (VAR_1, VAR_11, NULL, VAR_12) ;
while (VAR_8 > 0)
{VAR_8 = sf_readf_double (VAR_1, VAR_4, VAR_7) ;
for (VAR_9 = 0 ; VAR_9 < VAR_8 * VAR_2 ; VAR_9++)
VAR_4 [VAR_9] /= VAR_6 ;
sf_writef_double (VAR_0, VAR_4, VAR_8) ;
} ;
} ;
return ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/common.c/vul/before/1.json,"int
sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize)
{	static double	data [BUFFER_LEN], max ;
	sf_count_t		frames, readcount, k ;

	frames = BUFFER_LEN / channels ;
	readcount = frames ;

	sf_command (infile, SFC_CALC_SIGNAL_MAX, &max, sizeof (max)) ;
	if (!isnormal (max)) /* neither zero, subnormal, infinite, nor NaN */
		return 1 ;

	if (!normalize && max < 1.0)
	{	while (readcount > 0)
		{	readcount = sf_readf_double (infile, data, frames) ;
			sf_writef_double (outfile, data, readcount) ;
			} ;
		}
	else
	{	sf_command (infile, SFC_SET_NORM_DOUBLE, NULL, SF_FALSE) ;

		while (readcount > 0)
		{	readcount = sf_readf_double (infile, data, frames) ;
			for (k = 0 ; k < readcount * channels ; k++)
			{	data [k] /= max ;

				if (!isfinite (data [k])) /* infinite or NaN */
					return 1;
				}
			sf_writef_double (outfile, data, readcount) ;
			} ;
		} ;

	return 0 ;
}","int
sfe_copy_data_fp (SNDFILE *VAR_0, SNDFILE *VAR_1, int VAR_2, int VAR_3)
{	static double	VAR_4 [VAR_5], VAR_6 ;
	sf_count_t		VAR_7, VAR_8, VAR_9 ;

	VAR_7 = VAR_5 / VAR_2 ;
	VAR_8 = VAR_7 ;

	sf_command (VAR_1, VAR_10, &VAR_6, sizeof (VAR_6)) ;
	if (!isnormal (VAR_6)) /* COMMENT_0 */
		return 1 ;

	if (!VAR_3 && VAR_6 < 1.0)
	{	while (VAR_8 > 0)
		{	VAR_8 = sf_readf_double (VAR_1, VAR_4, VAR_7) ;
			sf_writef_double (VAR_0, VAR_4, VAR_8) ;
			} ;
		}
	else
	{	sf_command (VAR_1, VAR_11, NULL, VAR_12) ;

		while (VAR_8 > 0)
		{	VAR_8 = sf_readf_double (VAR_1, VAR_4, VAR_7) ;
			for (VAR_9 = 0 ; VAR_9 < VAR_8 * VAR_2 ; VAR_9++)
			{	VAR_4 [VAR_9] /= VAR_6 ;

				if (!isfinite (VAR_4 [VAR_9])) /* COMMENT_1 */
					return 1;
				}
			sf_writef_double (VAR_0, VAR_4, VAR_8) ;
			} ;
		} ;

	return 0 ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/common.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void
+int
 sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize)
 {	static double	data [BUFFER_LEN], max ;
 	sf_count_t		frames, readcount, k ;
@@ -7,6 +7,8 @@
 	readcount = frames ;
 
 	sf_command (infile, SFC_CALC_SIGNAL_MAX, &max, sizeof (max)) ;
+	if (!isnormal (max)) /* neither zero, subnormal, infinite, nor NaN */
+		return 1 ;
 
 	if (!normalize && max < 1.0)
 	{	while (readcount > 0)
@@ -20,10 +22,14 @@
 		while (readcount > 0)
 		{	readcount = sf_readf_double (infile, data, frames) ;
 			for (k = 0 ; k < readcount * channels ; k++)
-				data [k] /= max ;
+			{	data [k] /= max ;
+
+				if (!isfinite (data [k])) /* infinite or NaN */
+					return 1;
+				}
 			sf_writef_double (outfile, data, readcount) ;
 			} ;
 		} ;
 
-	return ;
+	return 0 ;
 }","{'deleted_lines': ['void', '\t\t\t\tdata [k] /= max ;', '\treturn ;'], 'added_lines': ['int', '\tif (!isnormal (max)) /* neither zero, subnormal, infinite, nor NaN */', '\t\treturn 1 ;', '\t\t\t{\tdata [k] /= max ;', '', '\t\t\t\tif (!isfinite (data [k])) /* infinite or NaN */', '\t\t\t\t\treturn 1;', '\t\t\t\t}', '\treturn 0 ;']}",True,"An out of bounds read in the function d2alaw_array() in alaw.c of libsndfile 1.0.28 may lead to a remote DoS attack or information disclosure, related to mishandling of the NAN and INFINITY floating-point values.",8.1,HIGH,2,valid,2017-09-27T12:46:17Z,2
CVE-2017-14245,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,libsndfile,"sfe_copy_data_fp: check value of ""max"" variable for being normal

and check elements of the data[] array for being finite.

Both checks use functions provided by the <math.h> header as declared
by the C99 standard.

Fixes #317
CVE-2017-14245
CVE-2017-14246",00a25b9469f825a57dc3558ce10561ef38a3405e,https://github.com/libsndfile/libsndfile/commit/00a25b9469f825a57dc3558ce10561ef38a3405e,programs/common.c,sfe_apply_metadata_changes,"void
sfe_apply_metadata_changes (const char * filenames [2], const METADATA_INFO * info)
{SNDFILE *infile = NULL, *outfile = NULL ;
SF_INFO sfinfo ;
METADATA_INFO tmpinfo ;
int error_code = 0 ;
memset (&sfinfo, 0, sizeof (sfinfo)) ;
memset (&tmpinfo, 0, sizeof (tmpinfo)) ;
if (filenames [1] == NULL)
infile = outfile = sf_open (filenames [0], SFM_RDWR, &sfinfo) ;
else
{infile = sf_open (filenames [0], SFM_READ, &sfinfo) ;
sfinfo.format = SF_FORMAT_WAV | (SF_FORMAT_SUBMASK & sfinfo.format) ;
outfile = sf_open (filenames [1], SFM_WRITE, &sfinfo) ;
} ;
if (infile == NULL)
{printf (""Error : Not able to open input file '%s' : %s\n"", filenames [0], sf_strerror (infile)) ;
error_code = 1 ;
goto cleanup_exit ;
} ;
if (outfile == NULL)
{printf (""Error : Not able to open output file '%s' : %s\n"", filenames [1], sf_strerror (outfile)) ;
error_code = 1 ;
goto cleanup_exit ;
} ;
if (info->has_bext_fields && merge_broadcast_info (infile, outfile, sfinfo.format, info))
{error_code = 1 ;
goto cleanup_exit ;
} ;
if (infile != outfile)
{int infileminor = SF_FORMAT_SUBMASK & sfinfo.format ;
if ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT))
sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) ;
else
sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
} ;
update_strings (outfile, info) ;
cleanup_exit :
if (outfile != NULL && outfile != infile)
sf_close (outfile) ;
if (infile != NULL)
sf_close (infile) ;
if (error_code)
exit (error_code) ;
return ;
}","void
sfe_apply_metadata_changes (const char * VAR_0 [2], const METADATA_INFO * VAR_1)
{SNDFILE *VAR_2 = NULL, *VAR_3 = NULL ;
SF_INFO VAR_4 ;
METADATA_INFO VAR_5 ;
int VAR_6 = 0 ;
memset (&VAR_4, 0, sizeof (VAR_4)) ;
memset (&VAR_5, 0, sizeof (VAR_5)) ;
if (VAR_0 [1] == NULL)
VAR_2 = VAR_3 = sf_open (VAR_0 [0], VAR_7, &VAR_4) ;
else
{VAR_2 = sf_open (VAR_0 [0], VAR_8, &VAR_4) ;
VAR_4.format = VAR_9 | (VAR_10 & VAR_4.format) ;
VAR_3 = sf_open (VAR_0 [1], VAR_11, &VAR_4) ;
} ;
if (VAR_2 == NULL)
{printf (""Error : Not able to open input file '%s' : %s\n"", VAR_0 [0], sf_strerror (VAR_2)) ;
VAR_6 = 1 ;
goto cleanup_exit ;
} ;
if (VAR_3 == NULL)
{printf (""Error : Not able to open output file '%s' : %s\n"", VAR_0 [1], sf_strerror (VAR_3)) ;
VAR_6 = 1 ;
goto cleanup_exit ;
} ;
if (VAR_1->has_bext_fields && merge_broadcast_info (VAR_2, VAR_3, VAR_4.format, VAR_1))
{VAR_6 = 1 ;
goto cleanup_exit ;
} ;
if (VAR_2 != VAR_3)
{int VAR_12 = VAR_10 & VAR_4.format ;
if ((VAR_12 == VAR_13) || (VAR_12 == VAR_14))
sfe_copy_data_fp (VAR_3, VAR_2, VAR_4.channels, VAR_15) ;
else
sfe_copy_data_int (VAR_3, VAR_2, VAR_4.channels) ;
} ;
update_strings (VAR_3, VAR_1) ;
cleanup_exit :
if (VAR_3 != NULL && VAR_3 != VAR_2)
sf_close (VAR_3) ;
if (VAR_2 != NULL)
sf_close (VAR_2) ;
if (VAR_6)
exit (VAR_6) ;
return ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/common.c/vul/before/0.json,"void
sfe_apply_metadata_changes (const char * filenames [2], const METADATA_INFO * info)
{	SNDFILE *infile = NULL, *outfile = NULL ;
	SF_INFO sfinfo ;
	METADATA_INFO tmpinfo ;
	int error_code = 0 ;

	memset (&sfinfo, 0, sizeof (sfinfo)) ;
	memset (&tmpinfo, 0, sizeof (tmpinfo)) ;

	if (filenames [1] == NULL)
		infile = outfile = sf_open (filenames [0], SFM_RDWR, &sfinfo) ;
	else
	{	infile = sf_open (filenames [0], SFM_READ, &sfinfo) ;

		/* Output must be WAV. */
		sfinfo.format = SF_FORMAT_WAV | (SF_FORMAT_SUBMASK & sfinfo.format) ;
		outfile = sf_open (filenames [1], SFM_WRITE, &sfinfo) ;
		} ;

	if (infile == NULL)
	{	printf (""Error : Not able to open input file '%s' : %s\n"", filenames [0], sf_strerror (infile)) ;
		error_code = 1 ;
		goto cleanup_exit ;
		} ;

	if (outfile == NULL)
	{	printf (""Error : Not able to open output file '%s' : %s\n"", filenames [1], sf_strerror (outfile)) ;
		error_code = 1 ;
		goto cleanup_exit ;
		} ;

	if (info->has_bext_fields && merge_broadcast_info (infile, outfile, sfinfo.format, info))
	{	error_code = 1 ;
		goto cleanup_exit ;
		} ;

	if (infile != outfile)
	{	int infileminor = SF_FORMAT_SUBMASK & sfinfo.format ;

		/* If the input file is not the same as the output file, copy the data. */
		if ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT))
		{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) != 0)
			{	printf (""Error : Not able to decode input file '%s'\n"", filenames [0]) ;
				error_code = 1 ;
				goto cleanup_exit ;
				} ;
			}
		else
			sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
		} ;

	update_strings (outfile, info) ;

cleanup_exit :

	if (outfile != NULL && outfile != infile)
		sf_close (outfile) ;

	if (infile != NULL)
		sf_close (infile) ;

	if (error_code)
		exit (error_code) ;

	return ;
}","void
sfe_apply_metadata_changes (const char * VAR_0 [2], const METADATA_INFO * VAR_1)
{	SNDFILE *VAR_2 = NULL, *VAR_3 = NULL ;
	SF_INFO VAR_4 ;
	METADATA_INFO VAR_5 ;
	int VAR_6 = 0 ;

	memset (&VAR_4, 0, sizeof (VAR_4)) ;
	memset (&VAR_5, 0, sizeof (VAR_5)) ;

	if (VAR_0 [1] == NULL)
		VAR_2 = VAR_3 = sf_open (VAR_0 [0], VAR_7, &VAR_4) ;
	else
	{	VAR_2 = sf_open (VAR_0 [0], VAR_8, &VAR_4) ;

		/* COMMENT_0 */
		VAR_4.format = VAR_9 | (VAR_10 & VAR_4.format) ;
		VAR_3 = sf_open (VAR_0 [1], VAR_11, &VAR_4) ;
		} ;

	if (VAR_2 == NULL)
	{	printf (""Error : Not able to open input file '%s' : %s\n"", VAR_0 [0], sf_strerror (VAR_2)) ;
		VAR_6 = 1 ;
		goto cleanup_exit ;
		} ;

	if (VAR_3 == NULL)
	{	printf (""Error : Not able to open output file '%s' : %s\n"", VAR_0 [1], sf_strerror (VAR_3)) ;
		VAR_6 = 1 ;
		goto cleanup_exit ;
		} ;

	if (VAR_1->has_bext_fields && merge_broadcast_info (VAR_2, VAR_3, VAR_4.format, VAR_1))
	{	VAR_6 = 1 ;
		goto cleanup_exit ;
		} ;

	if (VAR_2 != VAR_3)
	{	int VAR_12 = VAR_10 & VAR_4.format ;

		/* COMMENT_1 */
		if ((VAR_12 == VAR_13) || (VAR_12 == VAR_14))
		{	if (sfe_copy_data_fp (VAR_3, VAR_2, VAR_4.channels, VAR_15) != 0)
			{	printf (""Error : Not able to decode input file '%s'\n"", VAR_0 [0]) ;
				VAR_6 = 1 ;
				goto cleanup_exit ;
				} ;
			}
		else
			sfe_copy_data_int (VAR_3, VAR_2, VAR_4.channels) ;
		} ;

	update_strings (VAR_3, VAR_1) ;

cleanup_exit :

	if (VAR_3 != NULL && VAR_3 != VAR_2)
		sf_close (VAR_3) ;

	if (VAR_2 != NULL)
		sf_close (VAR_2) ;

	if (VAR_6)
		exit (VAR_6) ;

	return ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,7 +40,12 @@
 
 		/* If the input file is not the same as the output file, copy the data. */
 		if ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT))
-			sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) ;
+		{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) != 0)
+			{	printf (""Error : Not able to decode input file '%s'\n"", filenames [0]) ;
+				error_code = 1 ;
+				goto cleanup_exit ;
+				} ;
+			}
 		else
 			sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
 		} ;","{'deleted_lines': ['\t\t\tsfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) ;'], 'added_lines': ['\t\t{\tif (sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) != 0)', '\t\t\t{\tprintf (""Error : Not able to decode input file \'%s\'\\n"", filenames [0]) ;', '\t\t\t\terror_code = 1 ;', '\t\t\t\tgoto cleanup_exit ;', '\t\t\t\t} ;', '\t\t\t}']}",True,"An out of bounds read in the function d2alaw_array() in alaw.c of libsndfile 1.0.28 may lead to a remote DoS attack or information disclosure, related to mishandling of the NAN and INFINITY floating-point values.",8.1,HIGH,2,valid,2017-09-27T12:46:17Z,2
CVE-2017-14245,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,libsndfile,"sfe_copy_data_fp: check value of ""max"" variable for being normal

and check elements of the data[] array for being finite.

Both checks use functions provided by the <math.h> header as declared
by the C99 standard.

Fixes #317
CVE-2017-14245
CVE-2017-14246",00a25b9469f825a57dc3558ce10561ef38a3405e,https://github.com/libsndfile/libsndfile/commit/00a25b9469f825a57dc3558ce10561ef38a3405e,programs/sndfile-convert.c,main,"int
main (int argc, char * argv [])
{const char*progname, *infilename, *outfilename ;
SNDFILE*infile = NULL, *outfile = NULL ;
SF_INFOsfinfo ;
intk, outfilemajor, outfileminor = 0, infileminor ;
intoverride_sample_rate = 0 ; 
intendian = SF_ENDIAN_FILE, normalize = SF_FALSE ;
progname = program_name (argv [0]) ;
if (argc < 3 || argc > 5)
usage_exit (progname) ;
infilename = argv [argc-2] ;
outfilename = argv [argc-1] ;
if (strcmp (infilename, outfilename) == 0)
{printf (""Error : Input and output filenames are the same.\n\n"") ;
usage_exit (progname) ;
} ;
if (strlen (infilename) > 1 && infilename [0] == '-')
{printf (""Error : Input filename (%s) looks like an option.\n\n"", infilename) ;
usage_exit (progname) ;
} ;
if (outfilename [0] == '-')
{printf (""Error : Output filename (%s) looks like an option.\n\n"", outfilename) ;
usage_exit (progname) ;
} ;
for (k = 1 ; k < argc - 2 ; k++)
{if (! strcmp (argv [k], ""-pcms8""))
{outfileminor = SF_FORMAT_PCM_S8 ;
continue ;
} ;
if (! strcmp (argv [k], ""-pcmu8""))
{outfileminor = SF_FORMAT_PCM_U8 ;
continue ;
} ;
if (! strcmp (argv [k], ""-pcm16""))
{outfileminor = SF_FORMAT_PCM_16 ;
continue ;
} ;
if (! strcmp (argv [k], ""-pcm24""))
{outfileminor = SF_FORMAT_PCM_24 ;
continue ;
} ;
if (! strcmp (argv [k], ""-pcm32""))
{outfileminor = SF_FORMAT_PCM_32 ;
continue ;
} ;
if (! strcmp (argv [k], ""-float32""))
{outfileminor = SF_FORMAT_FLOAT ;
continue ;
} ;
if (! strcmp (argv [k], ""-float64""))
{outfileminor = SF_FORMAT_DOUBLE ;
continue ;
} ;
if (! strcmp (argv [k], ""-ulaw""))
{outfileminor = SF_FORMAT_ULAW ;
continue ;
} ;
if (! strcmp (argv [k], ""-alaw""))
{outfileminor = SF_FORMAT_ALAW ;
continue ;
} ;
if (! strcmp (argv [k], ""-alac16""))
{outfileminor = SF_FORMAT_ALAC_16 ;
continue ;
} ;
if (! strcmp (argv [k], ""-alac20""))
{outfileminor = SF_FORMAT_ALAC_20 ;
continue ;
} ;
if (! strcmp (argv [k], ""-alac24""))
{outfileminor = SF_FORMAT_ALAC_24 ;
continue ;
} ;
if (! strcmp (argv [k], ""-alac32""))
{outfileminor = SF_FORMAT_ALAC_32 ;
continue ;
} ;
if (! strcmp (argv [k], ""-ima-adpcm""))
{outfileminor = SF_FORMAT_IMA_ADPCM ;
continue ;
} ;
if (! strcmp (argv [k], ""-ms-adpcm""))
{outfileminor = SF_FORMAT_MS_ADPCM ;
continue ;
} ;
if (! strcmp (argv [k], ""-gsm610""))
{outfileminor = SF_FORMAT_GSM610 ;
continue ;
} ;
if (! strcmp (argv [k], ""-dwvw12""))
{outfileminor = SF_FORMAT_DWVW_12 ;
continue ;
} ;
if (! strcmp (argv [k], ""-dwvw16""))
{outfileminor = SF_FORMAT_DWVW_16 ;
continue ;
} ;
if (! strcmp (argv [k], ""-dwvw24""))
{outfileminor = SF_FORMAT_DWVW_24 ;
continue ;
} ;
if (! strcmp (argv [k], ""-vorbis""))
{outfileminor = SF_FORMAT_VORBIS ;
continue ;
} ;
if (! strcmp (argv [k], ""-opus""))
{outfileminor = SF_FORMAT_OPUS ;
continue ;
} ;
if (strstr (argv [k], ""-override-sample-rate="") == argv [k])
{const char *ptr ;
ptr = argv [k] + strlen (""-override-sample-rate="") ;
override_sample_rate = atoi (ptr) ;
continue ;
} ;
if (! strcmp (argv [k], ""-endian=little""))
{endian = SF_ENDIAN_LITTLE ;
continue ;
} ;
if (! strcmp (argv [k], ""-endian=big""))
{endian = SF_ENDIAN_BIG ;
continue ;
} ;
if (! strcmp (argv [k], ""-endian=cpu""))
{endian = SF_ENDIAN_CPU ;
continue ;
} ;
if (! strcmp (argv [k], ""-endian=file""))
{endian = SF_ENDIAN_FILE ;
continue ;
} ;
if (! strcmp (argv [k], ""-normalize""))
{normalize = SF_TRUE ;
continue ;
} ;
printf (""Error : Not able to decode argunment '%s'.\n"", argv [k]) ;
exit (1) ;
} ;
memset (&sfinfo, 0, sizeof (sfinfo)) ;
if ((infile = sf_open (infilename, SFM_READ, &sfinfo)) == NULL)
{printf (""Not able to open input file %s.\n"", infilename) ;
puts (sf_strerror (NULL)) ;
return 1 ;
} ;
if (override_sample_rate)
sfinfo.samplerate = override_sample_rate ;
infileminor = sfinfo.format & SF_FORMAT_SUBMASK ;
if ((sfinfo.format = sfe_file_type_of_ext (outfilename, sfinfo.format)) == 0)
{printf (""Error : Not able to determine output file type for %s.\n"", outfilename) ;
return 1 ;
} ;
outfilemajor = sfinfo.format & (SF_FORMAT_TYPEMASK | SF_FORMAT_ENDMASK) ;
if (outfileminor == 0)
outfileminor = sfinfo.format & SF_FORMAT_SUBMASK ;
if (outfileminor != 0)
sfinfo.format = outfilemajor | outfileminor ;
else
sfinfo.format = outfilemajor | (sfinfo.format & SF_FORMAT_SUBMASK) ;
sfinfo.format |= endian ;
if ((sfinfo.format & SF_FORMAT_TYPEMASK) == SF_FORMAT_XI)
switch (sfinfo.format & SF_FORMAT_SUBMASK)
{case SF_FORMAT_PCM_16 :
sfinfo.format = outfilemajor | SF_FORMAT_DPCM_16 ;
break ;
case SF_FORMAT_PCM_S8 :
case SF_FORMAT_PCM_U8 :
sfinfo.format = outfilemajor | SF_FORMAT_DPCM_8 ;
break ;
} ;
if (sf_format_check (&sfinfo) == 0)
{sf_close (infile) ;
report_format_error_exit (argv [0], &sfinfo) ;
} ;
if ((sfinfo.format & SF_FORMAT_SUBMASK) == SF_FORMAT_GSM610 && sfinfo.samplerate != 8000)
{printf (
""WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\n""
""ouput file will contain the input data converted to the GSM 6.10 data format\n""
""but not re-sampled.\n""
) ;
} ;
if ((outfile = sf_open (outfilename, SFM_WRITE, &sfinfo)) == NULL)
{printf (""Not able to open output file %s : %s\n"", outfilename, sf_strerror (NULL)) ;
return 1 ;
} ;
copy_metadata (outfile, infile, sfinfo.channels) ;
if (normalize
|| (outfileminor == SF_FORMAT_DOUBLE) || (outfileminor == SF_FORMAT_FLOAT)
|| (infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT)
|| (infileminor == SF_FORMAT_OPUS) || (outfileminor == SF_FORMAT_OPUS)
|| (infileminor == SF_FORMAT_VORBIS) || (outfileminor == SF_FORMAT_VORBIS))
sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) ;
else
sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
sf_close (infile) ;
sf_close (outfile) ;
return 0 ;
}","int
main (int VAR_0, char * VAR_1 [])
{const char*VAR_2, *VAR_3, *VAR_4 ;
SNDFILE*VAR_5 = NULL, *VAR_6 = NULL ;
SF_INFOVAR_7 ;
intVAR_8, VAR_9, VAR_10 = 0, VAR_11 ;
intVAR_12 = 0 ; 
intVAR_13 = VAR_14, VAR_15 = VAR_16 ;
VAR_2 = program_name (VAR_1 [0]) ;
if (VAR_0 < 3 || VAR_0 > 5)
usage_exit (VAR_2) ;
VAR_3 = VAR_1 [VAR_0-2] ;
VAR_4 = VAR_1 [VAR_0-1] ;
if (strcmp (VAR_3, VAR_4) == 0)
{printf (""Error : Input and output filenames are the same.\n\n"") ;
usage_exit (VAR_2) ;
} ;
if (strlen (VAR_3) > 1 && VAR_3 [0] == '-')
{printf (""Error : Input filename (%s) looks like an option.\n\n"", VAR_3) ;
usage_exit (VAR_2) ;
} ;
if (VAR_4 [0] == '-')
{printf (""Error : Output filename (%s) looks like an option.\n\n"", VAR_4) ;
usage_exit (VAR_2) ;
} ;
for (VAR_8 = 1 ; VAR_8 < VAR_0 - 2 ; VAR_8++)
{if (! strcmp (VAR_1 [VAR_8], ""-pcms8""))
{VAR_10 = VAR_17 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-pcmu8""))
{VAR_10 = VAR_18 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-pcm16""))
{VAR_10 = VAR_19 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-pcm24""))
{VAR_10 = VAR_20 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-pcm32""))
{VAR_10 = VAR_21 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-float32""))
{VAR_10 = VAR_22 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-float64""))
{VAR_10 = VAR_23 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-ulaw""))
{VAR_10 = VAR_24 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-alaw""))
{VAR_10 = VAR_25 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-alac16""))
{VAR_10 = VAR_26 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-alac20""))
{VAR_10 = VAR_27 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-alac24""))
{VAR_10 = VAR_28 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-alac32""))
{VAR_10 = VAR_29 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-ima-adpcm""))
{VAR_10 = VAR_30 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-ms-adpcm""))
{VAR_10 = VAR_31 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-gsm610""))
{VAR_10 = VAR_32 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-dwvw12""))
{VAR_10 = VAR_33 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-dwvw16""))
{VAR_10 = VAR_34 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-dwvw24""))
{VAR_10 = VAR_35 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-vorbis""))
{VAR_10 = VAR_36 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-opus""))
{VAR_10 = VAR_37 ;
continue ;
} ;
if (strstr (VAR_1 [VAR_8], ""-override-sample-rate="") == VAR_1 [VAR_8])
{const char *VAR_38 ;
VAR_38 = VAR_1 [VAR_8] + strlen (""-override-sample-rate="") ;
VAR_12 = atoi (VAR_38) ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-endian=little""))
{VAR_13 = VAR_39 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-endian=big""))
{VAR_13 = VAR_40 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-endian=cpu""))
{VAR_13 = VAR_41 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-endian=file""))
{VAR_13 = VAR_14 ;
continue ;
} ;
if (! strcmp (VAR_1 [VAR_8], ""-normalize""))
{VAR_15 = VAR_42 ;
continue ;
} ;
printf (""Error : Not able to decode argunment '%s'.\n"", VAR_1 [VAR_8]) ;
exit (1) ;
} ;
memset (&VAR_7, 0, sizeof (VAR_7)) ;
if ((VAR_5 = sf_open (VAR_3, VAR_43, &VAR_7)) == NULL)
{printf (""Not able to open input file %s.\n"", VAR_3) ;
puts (sf_strerror (NULL)) ;
return 1 ;
} ;
if (VAR_12)
VAR_7.samplerate = VAR_12 ;
VAR_11 = VAR_7.format & VAR_44 ;
if ((VAR_7.format = sfe_file_type_of_ext (VAR_4, VAR_7.format)) == 0)
{printf (""Error : Not able to determine output file type for %s.\n"", VAR_4) ;
return 1 ;
} ;
VAR_9 = VAR_7.format & (VAR_45 | VAR_46) ;
if (VAR_10 == 0)
VAR_10 = VAR_7.format & VAR_44 ;
if (VAR_10 != 0)
VAR_7.format = VAR_9 | VAR_10 ;
else
VAR_7.format = VAR_9 | (VAR_7.format & VAR_44) ;
VAR_7.format |= VAR_13 ;
if ((VAR_7.format & VAR_45) == VAR_47)
switch (VAR_7.format & VAR_44)
{case VAR_19 :
VAR_7.format = VAR_9 | VAR_48 ;
break ;
case VAR_17 :
case VAR_18 :
VAR_7.format = VAR_9 | VAR_49 ;
break ;
} ;
if (sf_format_check (&VAR_7) == 0)
{sf_close (VAR_5) ;
report_format_error_exit (VAR_1 [0], &VAR_7) ;
} ;
if ((VAR_7.format & VAR_44) == VAR_32 && VAR_7.samplerate != 8000)
{printf (
""WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\n""
""ouput file will contain the input data converted to the GSM 6.10 data format\n""
""but not re-sampled.\n""
) ;
} ;
if ((VAR_6 = sf_open (VAR_4, VAR_50, &VAR_7)) == NULL)
{printf (""Not able to open output file %s : %s\n"", VAR_4, sf_strerror (NULL)) ;
return 1 ;
} ;
copy_metadata (VAR_6, VAR_5, VAR_7.channels) ;
if (VAR_15
|| (VAR_10 == VAR_23) || (VAR_10 == VAR_22)
|| (VAR_11 == VAR_23) || (VAR_11 == VAR_22)
|| (VAR_11 == VAR_37) || (VAR_10 == VAR_37)
|| (VAR_11 == VAR_36) || (VAR_10 == VAR_36))
sfe_copy_data_fp (VAR_6, VAR_5, VAR_7.channels, VAR_15) ;
else
sfe_copy_data_int (VAR_6, VAR_5, VAR_7.channels) ;
sf_close (VAR_5) ;
sf_close (VAR_6) ;
return 0 ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/sndfile-convert.c/vul/before/0.json,"int
main (int argc, char * argv [])
{	const char	*progname, *infilename, *outfilename ;
	SNDFILE		*infile = NULL, *outfile = NULL ;
	SF_INFO		sfinfo ;
	int			k, outfilemajor, outfileminor = 0, infileminor ;
	int			override_sample_rate = 0 ; /* assume no sample rate override. */
	int			endian = SF_ENDIAN_FILE, normalize = SF_FALSE ;

	progname = program_name (argv [0]) ;

	if (argc < 3 || argc > 5)
		usage_exit (progname) ;

	infilename = argv [argc-2] ;
	outfilename = argv [argc-1] ;

	if (strcmp (infilename, outfilename) == 0)
	{	printf (""Error : Input and output filenames are the same.\n\n"") ;
		usage_exit (progname) ;
		} ;

	if (strlen (infilename) > 1 && infilename [0] == '-')
	{	printf (""Error : Input filename (%s) looks like an option.\n\n"", infilename) ;
		usage_exit (progname) ;
		} ;

	if (outfilename [0] == '-')
	{	printf (""Error : Output filename (%s) looks like an option.\n\n"", outfilename) ;
		usage_exit (progname) ;
		} ;

	for (k = 1 ; k < argc - 2 ; k++)
	{	if (! strcmp (argv [k], ""-pcms8""))
		{	outfileminor = SF_FORMAT_PCM_S8 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-pcmu8""))
		{	outfileminor = SF_FORMAT_PCM_U8 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-pcm16""))
		{	outfileminor = SF_FORMAT_PCM_16 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-pcm24""))
		{	outfileminor = SF_FORMAT_PCM_24 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-pcm32""))
		{	outfileminor = SF_FORMAT_PCM_32 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-float32""))
		{	outfileminor = SF_FORMAT_FLOAT ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-float64""))
		{	outfileminor = SF_FORMAT_DOUBLE ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-ulaw""))
		{	outfileminor = SF_FORMAT_ULAW ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-alaw""))
		{	outfileminor = SF_FORMAT_ALAW ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-alac16""))
		{	outfileminor = SF_FORMAT_ALAC_16 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-alac20""))
		{	outfileminor = SF_FORMAT_ALAC_20 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-alac24""))
		{	outfileminor = SF_FORMAT_ALAC_24 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-alac32""))
		{	outfileminor = SF_FORMAT_ALAC_32 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-ima-adpcm""))
		{	outfileminor = SF_FORMAT_IMA_ADPCM ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-ms-adpcm""))
		{	outfileminor = SF_FORMAT_MS_ADPCM ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-gsm610""))
		{	outfileminor = SF_FORMAT_GSM610 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-dwvw12""))
		{	outfileminor = SF_FORMAT_DWVW_12 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-dwvw16""))
		{	outfileminor = SF_FORMAT_DWVW_16 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-dwvw24""))
		{	outfileminor = SF_FORMAT_DWVW_24 ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-vorbis""))
		{	outfileminor = SF_FORMAT_VORBIS ;
			continue ;
			} ;
		if (! strcmp (argv [k], ""-opus""))
		{	outfileminor = SF_FORMAT_OPUS ;
			continue ;
			} ;

		if (strstr (argv [k], ""-override-sample-rate="") == argv [k])
		{	const char *ptr ;

			ptr = argv [k] + strlen (""-override-sample-rate="") ;
			override_sample_rate = atoi (ptr) ;
			continue ;
			} ;

		if (! strcmp (argv [k], ""-endian=little""))
		{	endian = SF_ENDIAN_LITTLE ;
			continue ;
			} ;

		if (! strcmp (argv [k], ""-endian=big""))
		{	endian = SF_ENDIAN_BIG ;
			continue ;
			} ;

		if (! strcmp (argv [k], ""-endian=cpu""))
		{	endian = SF_ENDIAN_CPU ;
			continue ;
			} ;

		if (! strcmp (argv [k], ""-endian=file""))
		{	endian = SF_ENDIAN_FILE ;
			continue ;
			} ;

		if (! strcmp (argv [k], ""-normalize""))
		{	normalize = SF_TRUE ;
			continue ;
			} ;

		printf (""Error : Not able to decode argunment '%s'.\n"", argv [k]) ;
		exit (1) ;
		} ;

	memset (&sfinfo, 0, sizeof (sfinfo)) ;

	if ((infile = sf_open (infilename, SFM_READ, &sfinfo)) == NULL)
	{	printf (""Not able to open input file %s.\n"", infilename) ;
		puts (sf_strerror (NULL)) ;
		return 1 ;
		} ;

	/* Update sample rate if forced to something else. */
	if (override_sample_rate)
		sfinfo.samplerate = override_sample_rate ;

	infileminor = sfinfo.format & SF_FORMAT_SUBMASK ;

	if ((sfinfo.format = sfe_file_type_of_ext (outfilename, sfinfo.format)) == 0)
	{	printf (""Error : Not able to determine output file type for %s.\n"", outfilename) ;
		return 1 ;
		} ;

	outfilemajor = sfinfo.format & (SF_FORMAT_TYPEMASK | SF_FORMAT_ENDMASK) ;

	if (outfileminor == 0)
		outfileminor = sfinfo.format & SF_FORMAT_SUBMASK ;

	if (outfileminor != 0)
		sfinfo.format = outfilemajor | outfileminor ;
	else
		sfinfo.format = outfilemajor | (sfinfo.format & SF_FORMAT_SUBMASK) ;

	sfinfo.format |= endian ;

	if ((sfinfo.format & SF_FORMAT_TYPEMASK) == SF_FORMAT_XI)
		switch (sfinfo.format & SF_FORMAT_SUBMASK)
		{	case SF_FORMAT_PCM_16 :
					sfinfo.format = outfilemajor | SF_FORMAT_DPCM_16 ;
					break ;

			case SF_FORMAT_PCM_S8 :
			case SF_FORMAT_PCM_U8 :
					sfinfo.format = outfilemajor | SF_FORMAT_DPCM_8 ;
					break ;
			} ;

	if (sf_format_check (&sfinfo) == 0)
	{	sf_close (infile) ;
		report_format_error_exit (argv [0], &sfinfo) ;
		} ;

	if ((sfinfo.format & SF_FORMAT_SUBMASK) == SF_FORMAT_GSM610 && sfinfo.samplerate != 8000)
	{	printf (
			""WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\n""
			""ouput file will contain the input data converted to the GSM 6.10 data format\n""
			""but not re-sampled.\n""
			) ;
		} ;

	/* Open the output file. */
	if ((outfile = sf_open (outfilename, SFM_WRITE, &sfinfo)) == NULL)
	{	printf (""Not able to open output file %s : %s\n"", outfilename, sf_strerror (NULL)) ;
		return 1 ;
		} ;

	/* Copy the metadata */
	copy_metadata (outfile, infile, sfinfo.channels) ;

	if (normalize
			|| (outfileminor == SF_FORMAT_DOUBLE) || (outfileminor == SF_FORMAT_FLOAT)
			|| (infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT)
			|| (infileminor == SF_FORMAT_OPUS) || (outfileminor == SF_FORMAT_OPUS)
			|| (infileminor == SF_FORMAT_VORBIS) || (outfileminor == SF_FORMAT_VORBIS))
	{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) != 0)
		{	printf (""Error : Not able to decode input file %s.\n"", infilename) ;
			return 1 ;
			} ;
		}
	else
		sfe_copy_data_int (outfile, infile, sfinfo.channels) ;

	sf_close (infile) ;
	sf_close (outfile) ;

	return 0 ;
}","int
main (int VAR_0, char * VAR_1 [])
{	const char	*VAR_2, *VAR_3, *VAR_4 ;
	SNDFILE		*VAR_5 = NULL, *VAR_6 = NULL ;
	SF_INFO		VAR_7 ;
	int			VAR_8, VAR_9, VAR_10 = 0, VAR_11 ;
	int			VAR_12 = 0 ; /* COMMENT_0 */
	int			VAR_13 = VAR_14, VAR_15 = VAR_16 ;

	VAR_2 = program_name (VAR_1 [0]) ;

	if (VAR_0 < 3 || VAR_0 > 5)
		usage_exit (VAR_2) ;

	VAR_3 = VAR_1 [VAR_0-2] ;
	VAR_4 = VAR_1 [VAR_0-1] ;

	if (strcmp (VAR_3, VAR_4) == 0)
	{	printf (""Error : Input and output filenames are the same.\n\n"") ;
		usage_exit (VAR_2) ;
		} ;

	if (strlen (VAR_3) > 1 && VAR_3 [0] == '-')
	{	printf (""Error : Input filename (%s) looks like an option.\n\n"", VAR_3) ;
		usage_exit (VAR_2) ;
		} ;

	if (VAR_4 [0] == '-')
	{	printf (""Error : Output filename (%s) looks like an option.\n\n"", VAR_4) ;
		usage_exit (VAR_2) ;
		} ;

	for (VAR_8 = 1 ; VAR_8 < VAR_0 - 2 ; VAR_8++)
	{	if (! strcmp (VAR_1 [VAR_8], ""-pcms8""))
		{	VAR_10 = VAR_17 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-pcmu8""))
		{	VAR_10 = VAR_18 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-pcm16""))
		{	VAR_10 = VAR_19 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-pcm24""))
		{	VAR_10 = VAR_20 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-pcm32""))
		{	VAR_10 = VAR_21 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-float32""))
		{	VAR_10 = VAR_22 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-float64""))
		{	VAR_10 = VAR_23 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-ulaw""))
		{	VAR_10 = VAR_24 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-alaw""))
		{	VAR_10 = VAR_25 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-alac16""))
		{	VAR_10 = VAR_26 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-alac20""))
		{	VAR_10 = VAR_27 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-alac24""))
		{	VAR_10 = VAR_28 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-alac32""))
		{	VAR_10 = VAR_29 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-ima-adpcm""))
		{	VAR_10 = VAR_30 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-ms-adpcm""))
		{	VAR_10 = VAR_31 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-gsm610""))
		{	VAR_10 = VAR_32 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-dwvw12""))
		{	VAR_10 = VAR_33 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-dwvw16""))
		{	VAR_10 = VAR_34 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-dwvw24""))
		{	VAR_10 = VAR_35 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-vorbis""))
		{	VAR_10 = VAR_36 ;
			continue ;
			} ;
		if (! strcmp (VAR_1 [VAR_8], ""-opus""))
		{	VAR_10 = VAR_37 ;
			continue ;
			} ;

		if (strstr (VAR_1 [VAR_8], ""-override-sample-rate="") == VAR_1 [VAR_8])
		{	const char *VAR_38 ;

			VAR_38 = VAR_1 [VAR_8] + strlen (""-override-sample-rate="") ;
			VAR_12 = atoi (VAR_38) ;
			continue ;
			} ;

		if (! strcmp (VAR_1 [VAR_8], ""-endian=little""))
		{	VAR_13 = VAR_39 ;
			continue ;
			} ;

		if (! strcmp (VAR_1 [VAR_8], ""-endian=big""))
		{	VAR_13 = VAR_40 ;
			continue ;
			} ;

		if (! strcmp (VAR_1 [VAR_8], ""-endian=cpu""))
		{	VAR_13 = VAR_41 ;
			continue ;
			} ;

		if (! strcmp (VAR_1 [VAR_8], ""-endian=file""))
		{	VAR_13 = VAR_14 ;
			continue ;
			} ;

		if (! strcmp (VAR_1 [VAR_8], ""-normalize""))
		{	VAR_15 = VAR_42 ;
			continue ;
			} ;

		printf (""Error : Not able to decode argunment '%s'.\n"", VAR_1 [VAR_8]) ;
		exit (1) ;
		} ;

	memset (&VAR_7, 0, sizeof (VAR_7)) ;

	if ((VAR_5 = sf_open (VAR_3, VAR_43, &VAR_7)) == NULL)
	{	printf (""Not able to open input file %s.\n"", VAR_3) ;
		puts (sf_strerror (NULL)) ;
		return 1 ;
		} ;

	/* COMMENT_1 */
	if (VAR_12)
		VAR_7.samplerate = VAR_12 ;

	VAR_11 = VAR_7.format & VAR_44 ;

	if ((VAR_7.format = sfe_file_type_of_ext (VAR_4, VAR_7.format)) == 0)
	{	printf (""Error : Not able to determine output file type for %s.\n"", VAR_4) ;
		return 1 ;
		} ;

	VAR_9 = VAR_7.format & (VAR_45 | VAR_46) ;

	if (VAR_10 == 0)
		VAR_10 = VAR_7.format & VAR_44 ;

	if (VAR_10 != 0)
		VAR_7.format = VAR_9 | VAR_10 ;
	else
		VAR_7.format = VAR_9 | (VAR_7.format & VAR_44) ;

	VAR_7.format |= VAR_13 ;

	if ((VAR_7.format & VAR_45) == VAR_47)
		switch (VAR_7.format & VAR_44)
		{	case VAR_19 :
					VAR_7.format = VAR_9 | VAR_48 ;
					break ;

			case VAR_17 :
			case VAR_18 :
					VAR_7.format = VAR_9 | VAR_49 ;
					break ;
			} ;

	if (sf_format_check (&VAR_7) == 0)
	{	sf_close (VAR_5) ;
		report_format_error_exit (VAR_1 [0], &VAR_7) ;
		} ;

	if ((VAR_7.format & VAR_44) == VAR_32 && VAR_7.samplerate != 8000)
	{	printf (
			""WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\n""
			""ouput file will contain the input data converted to the GSM 6.10 data format\n""
			""but not re-sampled.\n""
			) ;
		} ;

	/* COMMENT_2 */
	if ((VAR_6 = sf_open (VAR_4, VAR_50, &VAR_7)) == NULL)
	{	printf (""Not able to open output file %s : %s\n"", VAR_4, sf_strerror (NULL)) ;
		return 1 ;
		} ;

	/* COMMENT_3 */
	copy_metadata (VAR_6, VAR_5, VAR_7.channels) ;

	if (VAR_15
			|| (VAR_10 == VAR_23) || (VAR_10 == VAR_22)
			|| (VAR_11 == VAR_23) || (VAR_11 == VAR_22)
			|| (VAR_11 == VAR_37) || (VAR_10 == VAR_37)
			|| (VAR_11 == VAR_36) || (VAR_10 == VAR_36))
	{	if (sfe_copy_data_fp (VAR_6, VAR_5, VAR_7.channels, VAR_15) != 0)
		{	printf (""Error : Not able to decode input file %s.\n"", VAR_3) ;
			return 1 ;
			} ;
		}
	else
		sfe_copy_data_int (VAR_6, VAR_5, VAR_7.channels) ;

	sf_close (VAR_5) ;
	sf_close (VAR_6) ;

	return 0 ;
}",libsndfile/00a25b9469f825a57dc3558ce10561ef38a3405e/sndfile-convert.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -223,7 +223,11 @@
 			|| (infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT)
 			|| (infileminor == SF_FORMAT_OPUS) || (outfileminor == SF_FORMAT_OPUS)
 			|| (infileminor == SF_FORMAT_VORBIS) || (outfileminor == SF_FORMAT_VORBIS))
-		sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) ;
+	{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) != 0)
+		{	printf (""Error : Not able to decode input file %s.\n"", infilename) ;
+			return 1 ;
+			} ;
+		}
 	else
 		sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
 ","{'deleted_lines': ['\t\tsfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) ;'], 'added_lines': ['\t{\tif (sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) != 0)', '\t\t{\tprintf (""Error : Not able to decode input file %s.\\n"", infilename) ;', '\t\t\treturn 1 ;', '\t\t\t} ;', '\t\t}']}",True,"An out of bounds read in the function d2alaw_array() in alaw.c of libsndfile 1.0.28 may lead to a remote DoS attack or information disclosure, related to mishandling of the NAN and INFINITY floating-point values.",8.1,HIGH,2,valid,2017-09-27T12:46:17Z,2
CVE-2017-17046,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,xen-project/xen,"xen/page_alloc: Cover memory unreserved after boot in first_valid_mfn

On Arm, some regions (e.g Initramfs, Dom0 Kernel...) are marked as
reserved until the hardware domain is built and they are copied into its
memory. Therefore, they will not be added in the boot allocator via
init_boot_pages.

Instead, init_xenheap_pages will be called once the region are not used
anymore.

Update first_valid_mfn in both init_heap_pages and init_boot_pages
(already exist) to cover all the cases.

This is XSA-245.

Signed-off-by: Julien Grall <julien.grall@arm.com>
[Adjust comment, added locking around first_valid_mfn update]
Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Acked-by: Stefano Stabellini <sstabellini@kernel.org>
Reported-and-Tested-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>",ec6d9023e1f54cdccbf2e4c63cf947f1be2b1e8e,https://github.com/xen-project/xen/commit/ec6d9023e1f54cdccbf2e4c63cf947f1be2b1e8e,xen/common/page_alloc.c,init_heap_pages,"static void init_heap_pages(
struct page_info *pg, unsigned long nr_pages)
{
unsigned long i;
for ( i = 0; i < nr_pages; i++ )
{
unsigned int nid = phys_to_nid(page_to_maddr(pg+i));
if ( unlikely(!avail[nid]) )
{
unsigned long s = page_to_mfn(pg + i);
unsigned long e = page_to_mfn(pg + nr_pages - 1) + 1;
bool_t use_tail = (nid == phys_to_nid(pfn_to_paddr(e - 1))) &&
!(s & ((1UL << MAX_ORDER) - 1)) &&
(find_first_set_bit(e) <= find_first_set_bit(s));
unsigned long n;
n = init_node_heap(nid, page_to_mfn(pg+i), nr_pages - i,
&use_tail);
BUG_ON(i + n > nr_pages);
if ( n && !use_tail )
{
i += n - 1;
continue;
}
if ( i + n == nr_pages )
break;
nr_pages -= n;
}
free_heap_pages(pg + i, 0, scrub_debug);
}
}","static void init_heap_pages(
struct page_info *VAR_0, unsigned long VAR_1)
{
unsigned long VAR_2;
for ( VAR_2 = 0; VAR_2 < VAR_1; VAR_2++ )
{
unsigned int VAR_3 = phys_to_nid(page_to_maddr(VAR_0+VAR_2));
if ( unlikely(!VAR_4[VAR_3]) )
{
unsigned long VAR_5 = page_to_mfn(VAR_0 + VAR_2);
unsigned long VAR_6 = page_to_mfn(VAR_0 + VAR_1 - 1) + 1;
bool_t VAR_7 = (VAR_3 == phys_to_nid(pfn_to_paddr(VAR_6 - 1))) &&
!(VAR_5 & ((1UL << VAR_8) - 1)) &&
(find_first_set_bit(VAR_6) <= find_first_set_bit(VAR_5));
unsigned long VAR_9;
VAR_9 = init_node_heap(VAR_3, page_to_mfn(VAR_0+VAR_2), VAR_1 - VAR_2,
&VAR_7);
BUG_ON(VAR_2 + VAR_9 > VAR_1);
if ( VAR_9 && !VAR_7 )
{
VAR_2 += VAR_9 - 1;
continue;
}
if ( VAR_2 + VAR_9 == VAR_1 )
break;
VAR_1 -= VAR_9;
}
free_heap_pages(VAR_0 + VAR_2, 0, VAR_10);
}
}",xen-project/xen/ec6d9023e1f54cdccbf2e4c63cf947f1be2b1e8e/page_alloc.c/vul/before/0.json,"static void init_heap_pages(
    struct page_info *pg, unsigned long nr_pages)
{
    unsigned long i;

    /*
     * Some pages may not go through the boot allocator (e.g reserved
     * memory at boot but released just after --- kernel, initramfs,
     * etc.).
     * Update first_valid_mfn to ensure those regions are covered.
     */
    spin_lock(&heap_lock);
    first_valid_mfn = min_t(unsigned long, page_to_mfn(pg), first_valid_mfn);
    spin_unlock(&heap_lock);

    for ( i = 0; i < nr_pages; i++ )
    {
        unsigned int nid = phys_to_nid(page_to_maddr(pg+i));

        if ( unlikely(!avail[nid]) )
        {
            unsigned long s = page_to_mfn(pg + i);
            unsigned long e = page_to_mfn(pg + nr_pages - 1) + 1;
            bool_t use_tail = (nid == phys_to_nid(pfn_to_paddr(e - 1))) &&
                              !(s & ((1UL << MAX_ORDER) - 1)) &&
                              (find_first_set_bit(e) <= find_first_set_bit(s));
            unsigned long n;

            n = init_node_heap(nid, page_to_mfn(pg+i), nr_pages - i,
                               &use_tail);
            BUG_ON(i + n > nr_pages);
            if ( n && !use_tail )
            {
                i += n - 1;
                continue;
            }
            if ( i + n == nr_pages )
                break;
            nr_pages -= n;
        }

        free_heap_pages(pg + i, 0, scrub_debug);
    }
}","static void init_heap_pages(
    struct page_info *VAR_0, unsigned long VAR_1)
{
    unsigned long VAR_2;

    /* COMMENT_0 */
                                                                     
                                                                    
             
                                                                  
       
    spin_lock(&VAR_3);
    VAR_4 = min_t(unsigned VAR_5, page_to_mfn(VAR_0), VAR_4);
    spin_unlock(&VAR_3);

    for ( VAR_2 = 0; VAR_2 < VAR_1; VAR_2++ )
    {
        unsigned int VAR_6 = phys_to_nid(page_to_maddr(VAR_0+VAR_2));

        if ( unlikely(!VAR_7[VAR_6]) )
        {
            unsigned long VAR_8 = page_to_mfn(VAR_0 + VAR_2);
            unsigned long VAR_9 = page_to_mfn(VAR_0 + VAR_1 - 1) + 1;
            bool_t VAR_10 = (VAR_6 == phys_to_nid(pfn_to_paddr(VAR_9 - 1))) &&
                              !(VAR_8 & ((1UL << VAR_11) - 1)) &&
                              (find_first_set_bit(VAR_9) <= find_first_set_bit(VAR_8));
            unsigned long VAR_12;

            VAR_12 = init_node_heap(VAR_6, page_to_mfn(VAR_0+VAR_2), VAR_1 - VAR_2,
                               &VAR_10);
            BUG_ON(VAR_2 + VAR_12 > VAR_1);
            if ( VAR_12 && !VAR_10 )
            {
                VAR_2 += VAR_12 - 1;
                continue;
            }
            if ( VAR_2 + VAR_12 == VAR_1 )
                break;
            VAR_1 -= VAR_12;
        }

        free_heap_pages(VAR_0 + VAR_2, 0, VAR_13);
    }
}",xen-project/xen/ec6d9023e1f54cdccbf2e4c63cf947f1be2b1e8e/page_alloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,16 @@
     struct page_info *pg, unsigned long nr_pages)
 {
     unsigned long i;
+
+    /*
+     * Some pages may not go through the boot allocator (e.g reserved
+     * memory at boot but released just after --- kernel, initramfs,
+     * etc.).
+     * Update first_valid_mfn to ensure those regions are covered.
+     */
+    spin_lock(&heap_lock);
+    first_valid_mfn = min_t(unsigned long, page_to_mfn(pg), first_valid_mfn);
+    spin_unlock(&heap_lock);
 
     for ( i = 0; i < nr_pages; i++ )
     {","{'deleted_lines': [], 'added_lines': ['', '    /*', '     * Some pages may not go through the boot allocator (e.g reserved', '     * memory at boot but released just after --- kernel, initramfs,', '     * etc.).', '     * Update first_valid_mfn to ensure those regions are covered.', '     */', '    spin_lock(&heap_lock);', '    first_valid_mfn = min_t(unsigned long, page_to_mfn(pg), first_valid_mfn);', '    spin_unlock(&heap_lock);']}",True,"An issue was discovered in Xen through 4.9.x on the ARM platform allowing guest OS users to obtain sensitive information from DRAM after a reboot, because disjoint blocks, and physical addresses that do not start at zero, are mishandled.",6.5,MEDIUM,1,valid,2017-09-29T20:16:21Z,2
CVE-2017-11704,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libming,"Fix various overflows in util/ (CVE-2017-11704)

* Add a check in decompileIF to avoid overflows.

    Avoid processing block when sact->numActions is 0, as
    sact->numActions - 1 may be used as index when accessing
    sact->Actions array.

* Fix overflow in readUInt32.

    o Fix declaration of readUInt32 and readSInt32 in util/read.h:
      return types should be unsigned long and long.
    o readUInt32: Avoid calling all readUInt8(f) in one line, order of
      evaluation is not guaranteed in the C standard.
    o readUInt32: Cast result of readUInt8(f) before << 24 to avoid
      overflow.

* Fix overflow in readMovie.

    length has int type but according to the specification it should be able
    to store unsigned 32bit numbers. Instead of changing the type of
    length, which would be a major refactoring, we verify that the value
    returned by readUInt32 is smaller than INT_MAX and update length if
    it's the case. Otherwise we print a warning and ignore the block.

This commit fixes CVE-2017-11704.",7fed314748be817c7ded84854acb649786625cb6,https://github.com/libming/libming/commit/7fed314748be817c7ded84854acb649786625cb6,util/main.c,readMovie,"static void readMovie(FILE *f)
{
int block, type, blockstart, blockoffset, length, nextFrame=0;
SWF_Parserstruct *blockp;
for (;;)
{
blockoffset = fileOffset;
if(filelen_check_fails(2))
break;
block = readUInt16 (f);
type = block >> 6;
length = block & ((1 << 6) - 1);
if (length == 63) 
{
if(filelen_check_fails(4))
break;
length = readUInt32 (f);
}
blockstart = fileOffset;
nextFrame = fileOffset+length;
if(filelen_check_fails(length))
break;
blockp= blockParse(f, length, type);
if( ftell(f) != nextFrame ) 
{
SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
"" %ld but expecting %d.\n"", type, blockName(type),
ftell(f),nextFrame);
}
if( blockp ) 
{
outputBlock( type, blockp, f);
free(blockp);
} else {
SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
type, length);
}
if (type == 0 || fileOffset >= m.size)
break;
fseek(f, nextFrame, SEEK_SET);
fileOffset = ftell(f);
}
putchar ('\n');
if (fileOffset < m.size)
{
SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
dumpBytes (f, m.size - fileOffset);
printf (""\n\n"");
}
outputTrailer(&m);
}","static void readMovie(FILE *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6=0;
SWF_Parserstruct *VAR_7;
for (;;)
{
VAR_4 = VAR_8;
if(filelen_check_fails(2))
break;
VAR_1 = readUInt16 (VAR_0);
VAR_2 = VAR_1 >> 6;
VAR_5 = VAR_1 & ((1 << 6) - 1);
if (VAR_5 == 63) 
{
if(filelen_check_fails(4))
break;
VAR_5 = readUInt32 (VAR_0);
}
VAR_3 = VAR_8;
VAR_6 = VAR_8+VAR_5;
if(filelen_check_fails(VAR_5))
break;
VAR_7= blockParse(VAR_0, VAR_5, VAR_2);
if( ftell(VAR_0) != VAR_6 ) 
{
SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
"" %ld but expecting %d.\n"", VAR_2, blockName(VAR_2),
ftell(VAR_0),VAR_6);
}
if( VAR_7 ) 
{
outputBlock( VAR_2, VAR_7, VAR_0);
free(VAR_7);
} else {
SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
VAR_2, VAR_5);
}
if (VAR_2 == 0 || VAR_8 >= VAR_9.size)
break;
fseek(VAR_0, VAR_6, VAR_10);
VAR_8 = ftell(VAR_0);
}
putchar ('\n');
if (VAR_8 < VAR_9.size)
{
SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
dumpBytes (VAR_0, VAR_9.size - VAR_8);
printf (""\n\n"");
}
outputTrailer(&VAR_9);
}",libming/7fed314748be817c7ded84854acb649786625cb6/main.c/vul/before/0.json,"static void readMovie(FILE *f)
{
	int block, type, blockstart, blockoffset, length, nextFrame=0;
	SWF_Parserstruct *blockp;
	for (;;)
	{
		blockoffset = fileOffset;

		// printf (""Block offset: %d %d\n"", fileOffset, m.size);

		if(filelen_check_fails(2))
			break;
		block = readUInt16 (f);
		type = block >> 6;

		length = block & ((1 << 6) - 1);

		if (length == 63)		/* it's a long block. */ 
		{
			if(filelen_check_fails(4))
				break;
			unsigned long real_length = readUInt32 (f);

                        if (real_length > INT_MAX) {
		            SWF_warn("" Could not process long block with length %lu:""
                                     "" blocks with length > %d not supported on this system\n"",
                                     real_length, INT_MAX);
                            continue;
                        } else {
                            length = (int) real_length;
                        }
		}
		
		//      printf (""Found Block: %s (%i), %i bytes\n"", blockName (type), type, length);
		blockstart = fileOffset;
		nextFrame = fileOffset+length;
		
		if(filelen_check_fails(length))
			break;
		blockp= blockParse(f, length, type);

		if( ftell(f) != nextFrame ) 
		{
			// will SEEK_SET later, so this is not a critical error
		        SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
				"" %ld but expecting %d.\n"", type, blockName(type),
				ftell(f),nextFrame);
		}

		if( blockp ) 
		{
			outputBlock( type, blockp, f);
			free(blockp);	
		} else {
			SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
				type, length);
		}

		if (type == 0 || fileOffset >= m.size)
			break;
	
		fseek(f, nextFrame, SEEK_SET);
		fileOffset = ftell(f);
	}
	putchar ('\n');

	if (fileOffset < m.size)
	{
		SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
		dumpBytes (f, m.size - fileOffset);
		printf (""\n\n"");
	}
	outputTrailer(&m);
}","static void readMovie(FILE *VAR_0)
{
	int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6=0;
	SWF_Parserstruct *VAR_7;
	for (;;)
	{
		VAR_4 = VAR_8;

		/* COMMENT_0 */

		if(filelen_check_fails(2))
			break;
		VAR_1 = readUInt16 (VAR_0);
		VAR_2 = VAR_1 >> 6;

		VAR_5 = VAR_1 & ((1 << 6) - 1);

		if (VAR_5 == 63)		/* COMMENT_1 */ 
		{
			if(filelen_check_fails(4))
				break;
			unsigned long VAR_9 = readUInt32 (VAR_0);

                        if (VAR_9 > VAR_10) {
		            SWF_warn("" Could not process long block with length %lu:""
                                     "" blocks with length > %d not supported on this system\n"",
                                     VAR_9, VAR_10);
                            continue;
                        } else {
                            VAR_5 = (int) VAR_9;
                        }
		}
		
		/* COMMENT_2 */
		VAR_3 = VAR_8;
		VAR_6 = VAR_8+VAR_5;
		
		if(filelen_check_fails(VAR_5))
			break;
		VAR_7= blockParse(VAR_0, VAR_5, VAR_2);

		if( ftell(VAR_0) != VAR_6 ) 
		{
			/* COMMENT_3 */
		        SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
				"" %ld but expecting %d.\n"", VAR_2, blockName(VAR_2),
				ftell(VAR_0),VAR_6);
		}

		if( VAR_7 ) 
		{
			outputBlock( VAR_2, VAR_7, VAR_0);
			free(VAR_7);	
		} else {
			SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
				VAR_2, VAR_5);
		}

		if (VAR_2 == 0 || VAR_8 >= VAR_11.size)
			break;
	
		fseek(VAR_0, VAR_6, VAR_12);
		VAR_8 = ftell(VAR_0);
	}
	putchar ('\n');

	if (VAR_8 < VAR_11.size)
	{
		SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
		dumpBytes (VAR_0, VAR_11.size - VAR_8);
		printf (""\n\n"");
	}
	outputTrailer(&VAR_11);
}",libming/7fed314748be817c7ded84854acb649786625cb6/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,7 +19,16 @@
 		{
 			if(filelen_check_fails(4))
 				break;
-			length = readUInt32 (f);
+			unsigned long real_length = readUInt32 (f);
+
+                        if (real_length > INT_MAX) {
+		            SWF_warn("" Could not process long block with length %lu:""
+                                     "" blocks with length > %d not supported on this system\n"",
+                                     real_length, INT_MAX);
+                            continue;
+                        } else {
+                            length = (int) real_length;
+                        }
 		}
 		
 		//      printf (""Found Block: %s (%i), %i bytes\n"", blockName (type), type, length);","{'deleted_lines': ['\t\t\tlength = readUInt32 (f);'], 'added_lines': ['\t\t\tunsigned long real_length = readUInt32 (f);', '', '                        if (real_length > INT_MAX) {', '\t\t            SWF_warn("" Could not process long block with length %lu:""', '                                     "" blocks with length > %d not supported on this system\\n"",', '                                     real_length, INT_MAX);', '                            continue;', '                        } else {', '                            length = (int) real_length;', '                        }']}",True,"A heap-based buffer over-read was found in the function decompileIF in util/decompile.c in Ming 0.4.8, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,valid,2017-10-01T15:09:45Z,2
CVE-2017-11704,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libming,"Fix various overflows in util/ (CVE-2017-11704)

* Add a check in decompileIF to avoid overflows.

    Avoid processing block when sact->numActions is 0, as
    sact->numActions - 1 may be used as index when accessing
    sact->Actions array.

* Fix overflow in readUInt32.

    o Fix declaration of readUInt32 and readSInt32 in util/read.h:
      return types should be unsigned long and long.
    o readUInt32: Avoid calling all readUInt8(f) in one line, order of
      evaluation is not guaranteed in the C standard.
    o readUInt32: Cast result of readUInt8(f) before << 24 to avoid
      overflow.

* Fix overflow in readMovie.

    length has int type but according to the specification it should be able
    to store unsigned 32bit numbers. Instead of changing the type of
    length, which would be a major refactoring, we verify that the value
    returned by readUInt32 is smaller than INT_MAX and update length if
    it's the case. Otherwise we print a warning and ignore the block.

This commit fixes CVE-2017-11704.",7fed314748be817c7ded84854acb649786625cb6,https://github.com/libming/libming/commit/7fed314748be817c7ded84854acb649786625cb6,util/read.c,readUInt32,"unsigned long readUInt32(FILE *f)
{
return (unsigned long)(readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24));
}","unsigned long readUInt32(FILE *VAR_0)
{
return (unsigned long)(readUInt8(VAR_0) + (readUInt8(VAR_0)<<8) + (readUInt8(VAR_0)<<16) + (readUInt8(VAR_0)<<24));
}",libming/7fed314748be817c7ded84854acb649786625cb6/read.c/vul/before/0.json,"unsigned long readUInt32(FILE *f)
{
  int part1 = readUInt8(f);
  int part2 = readUInt8(f) << 8;
  int part3 = readUInt8(f) << 16;
  unsigned long part4 = ((unsigned long)readUInt8(f)) << 24;
  return part1 + part2 + part3 + part4;
}","unsigned long readUInt32(FILE *VAR_0)
{
  int VAR_1 = readUInt8(VAR_0);
  int VAR_2 = readUInt8(VAR_0) << 8;
  int VAR_3 = readUInt8(VAR_0) << 16;
  unsigned long VAR_4 = ((unsigned long)readUInt8(VAR_0)) << 24;
  return VAR_1 + VAR_2 + VAR_3 + VAR_4;
}",libming/7fed314748be817c7ded84854acb649786625cb6/read.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,8 @@
 unsigned long readUInt32(FILE *f)
 {
-  return (unsigned long)(readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24));
+  int part1 = readUInt8(f);
+  int part2 = readUInt8(f) << 8;
+  int part3 = readUInt8(f) << 16;
+  unsigned long part4 = ((unsigned long)readUInt8(f)) << 24;
+  return part1 + part2 + part3 + part4;
 }","{'deleted_lines': ['  return (unsigned long)(readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24));'], 'added_lines': ['  int part1 = readUInt8(f);', '  int part2 = readUInt8(f) << 8;', '  int part3 = readUInt8(f) << 16;', '  unsigned long part4 = ((unsigned long)readUInt8(f)) << 24;', '  return part1 + part2 + part3 + part4;']}",True,"A heap-based buffer over-read was found in the function decompileIF in util/decompile.c in Ming 0.4.8, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,valid,2017-10-01T15:09:45Z,2
CVE-2017-15056,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,upx,"Protect against bad crafted input.

https://github.com/upx/upx/issues/128
	modified:   p_lx_elf.cpp",ef336dbcc6dc8344482f8cf6c909ae96c3286317,https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,src/p_lx_elf.cpp,PackLinuxElf64::unpack,"void PackLinuxElf64::unpack(OutputFile *fo)
{
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
upx_uint64_t old_data_off = 0;
upx_uint64_t old_data_len = 0;
upx_uint64_t old_dtinit = 0;
unsigned szb_info = sizeof(b_info);
{
upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
if (e_entry < 0x401180
&&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { 
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if (file_size > (off_t)orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
#define MAX_ELF_HDR 1024
union {
unsigned char buf[MAX_ELF_HDR];
} u;
Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;
Elf64_Phdr const *phdr = 0;
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > sizeof(u))
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)
throwCompressedDataViolation();
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  !( ehdr->e_flags==ehdri.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);
overlay_offset -= sizeof(linfo);
if (fo) {
fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te64(&phdr->p_offset);
old_data_len = get_te64(&phdr->p_filesz);
break;
}
}
total_in  = overlay_offset;
total_out = overlay_offset;
ph.u_len = 0;
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te64(&phdr->p_filesz);
unsigned const offset = get_te64(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
load_va = get_te64(&phdr->p_vaddr);
break;
}
}
if (is_shlib
||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = d_info[2 + (0==d_info[0])];
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
upx_uint64_t hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD64==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te64(&phdr[j].p_offset) +
get_te64(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {          int n_ptload = 0;
unsigned load_off = 0;
phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te64(&phdr->p_offset);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
if (fo) {
fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {
unsigned const dyn_off = get_te64(&phdr->p_offset);
unsigned const dyn_len = get_te64(&phdr->p_filesz);
Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {
if (fo) {
fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);
fo->rewrite(&old_dtinit, sizeof(old_dtinit));
fo->seek(0, SEEK_END);
}
break;
}
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
#undef MAX_ELF_HDR
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
unsigned const VAR_1 = get_te16(&VAR_2.e_phnum);
upx_uint64_t VAR_3 = 0;
upx_uint64_t VAR_4 = 0;
upx_uint64_t VAR_5 = 0;
unsigned VAR_6 = sizeof(VAR_7);
{
upx_uint64_t const VAR_8 = get_te64(&VAR_2.e_entry);
if (VAR_8 < 0x401180
&&  get_te16(&VAR_2.e_machine)==Elf64_Ehdr::EM_386) { 
VAR_6 = 2*sizeof(unsigned);
}
}
VAR_9->seek(VAR_10 - sizeof(VAR_11), VAR_12);
VAR_9->readx(&VAR_13, sizeof(VAR_13));
VAR_14 = get_te16(&VAR_13.l_lsize);
p_info VAR_15;  VAR_9->readx(&VAR_15, sizeof(VAR_15));
unsigned VAR_16 = get_te32(&VAR_15.p_filesize);
VAR_17 = get_te32(&VAR_15.p_blocksize);
if (VAR_18 > (off_t)VAR_16 || VAR_17 > VAR_16
|| !mem_size_valid(1, VAR_17, VAR_19))
throwCantUnpack(""p_info corrupted"");
#define VAR_20 1024
union {
unsigned char buf[VAR_20];
} VAR_21;
Elf64_Ehdr *const VAR_22 = (Elf64_Ehdr *) VAR_21.buf;
Elf64_Phdr const *VAR_23 = 0;
VAR_24.alloc(VAR_17 + VAR_19);
b_info VAR_25; memset(&VAR_25, 0, sizeof(VAR_25));
VAR_9->readx(&VAR_25, VAR_6);
VAR_26.u_len = get_te32(&VAR_25.sz_unc);
VAR_26.c_len = get_te32(&VAR_25.sz_cpr);
if (VAR_26.c_len > (unsigned)VAR_18 || VAR_26.c_len == 0 || VAR_26.u_len == 0
||  VAR_26.u_len > sizeof(VAR_21))
throwCantUnpack(""b_info corrupted"");
VAR_26.filter_cto = VAR_25.b_cto8;
if (VAR_24.getSize() < VAR_26.c_len  ||  sizeof(VAR_21) < VAR_26.u_len)
throwCompressedDataViolation();
VAR_9->readx(VAR_24, VAR_26.c_len);
decompress(VAR_24, (upx_byte *)VAR_22, false);
if (VAR_22->e_type   !=VAR_2.e_type
||  VAR_22->e_machine!=VAR_2.e_machine
||  VAR_22->e_version!=VAR_2.e_version
||  !( VAR_22->e_flags==VAR_2.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_2.e_machine))
||  VAR_22->e_ehsize !=VAR_2.e_ehsize
||  memcmp(VAR_22->e_ident, VAR_2.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
VAR_9->seek(- (off_t) (VAR_6 + VAR_26.c_len), VAR_27);
unsigned const VAR_28 = get_te16(&VAR_22->e_phnum);
unsigned VAR_29 = 0;
unsigned VAR_30 = 0;
unsigned VAR_31 = upx_adler32(NULL, 0);
unsigned VAR_32 = upx_adler32(NULL, 0);
bool const VAR_33 = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_34, VAR_1);
if (VAR_33) {
unpackExtent(VAR_26.u_len, VAR_0, VAR_29, VAR_30,
VAR_31, VAR_32, false, VAR_6);
VAR_9->seek(0, VAR_12);
VAR_9->readx(VAR_24, VAR_10 + sizeof(VAR_15) + VAR_6 + VAR_26.c_len);
VAR_10 -= sizeof(VAR_13);
if (VAR_0) {
VAR_0->write(VAR_24 + VAR_26.u_len, VAR_10 - VAR_26.u_len);
}
int VAR_35 = 0;
VAR_23 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_24);
for (unsigned VAR_36=0; VAR_36 < VAR_28; ++VAR_23, ++VAR_36) {
if (VAR_37==get_te32(&VAR_23->p_type) && 0!=VAR_35++) {
VAR_3 = get_te64(&VAR_23->p_offset);
VAR_4 = get_te64(&VAR_23->p_filesz);
break;
}
}
VAR_29  = VAR_10;
VAR_30 = VAR_10;
VAR_26.u_len = 0;
VAR_23 = (Elf64_Phdr *) (void *) (1+ VAR_22);
for (unsigned VAR_36=0; VAR_36 < VAR_28; ++VAR_23, ++VAR_36) {
if (VAR_37==get_te32(&VAR_23->p_type)) {
VAR_26.u_len = get_te64(&VAR_23->p_filesz) - VAR_10;
break;
}
}
unpackExtent(VAR_26.u_len, VAR_0, VAR_29, VAR_30,
VAR_31, VAR_32, false, VAR_6);
}
else {  
bool VAR_38 = true;
VAR_23 = (Elf64_Phdr *) (void *) (1+ VAR_22);  
for (unsigned VAR_36=0; VAR_36 < VAR_28; ++VAR_23, ++VAR_36) {
if (VAR_37==get_te32(&VAR_23->p_type)) {
unsigned const VAR_39 = get_te64(&VAR_23->p_filesz);
unsigned const VAR_40 = get_te64(&VAR_23->p_offset);
if (VAR_0)
VAR_0->seek(VAR_40, VAR_12);
if (Elf64_Phdr::PF_X & get_te32(&VAR_23->p_flags)) {
unpackExtent(VAR_39, VAR_0, VAR_29, VAR_30,
VAR_31, VAR_32, VAR_38, VAR_6);
VAR_38 = false;
}
else {
unpackExtent(VAR_39, VAR_0, VAR_29, VAR_30,
VAR_31, VAR_32, false, VAR_6);
}
}
}
}
VAR_23 = VAR_34;
VAR_41 = 0;
for (unsigned VAR_36=0; VAR_36 < VAR_1; ++VAR_36) {
if (VAR_37==get_te32(&VAR_23->p_type)) {
VAR_41 = get_te64(&VAR_23->p_vaddr);
break;
}
}
if (VAR_33
||  ((unsigned)(get_te64(&VAR_2.e_entry) - VAR_41) + up4(VAR_14) +
VAR_26.getPackHeaderSize() + sizeof(VAR_10))
< up4(VAR_18)) {
funpad4(VAR_9);  
unsigned VAR_42[6]; VAR_9->readx(VAR_42, sizeof(VAR_42));
if (0==VAR_5) {
VAR_5 = VAR_42[2 + (0==VAR_42[0])];
}
VAR_9->seek(VAR_14 - sizeof(VAR_42), VAR_27);
}
VAR_23 = (Elf64_Phdr *) (VAR_21.buf + sizeof(*VAR_22));
upx_uint64_t VAR_43(0);
for (unsigned VAR_36 = 0; VAR_36 < VAR_28; ++VAR_36) {
if (VAR_37==VAR_23[VAR_36].p_type
&&  VAR_43 < VAR_23[VAR_36].p_offset)
VAR_43 = VAR_23[VAR_36].p_offset;
}
for (unsigned VAR_36 = 0; VAR_36 < VAR_28; ++VAR_36) {
unsigned const VAR_44 = find_LOAD_gap(VAR_23, VAR_36, VAR_28);
if (VAR_44) {
unsigned const VAR_45 = get_te64(&VAR_23[VAR_36].p_offset) +
get_te64(&VAR_23[VAR_36].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_45, VAR_12);
unpackExtent(VAR_44, VAR_0, VAR_29, VAR_30,
VAR_31, VAR_32, false, VAR_6,
(VAR_23[VAR_36].p_offset != VAR_43));
}
}
VAR_9->readx(&VAR_25, VAR_6);
unsigned const VAR_46 = VAR_26.u_len = get_te32(&VAR_25.sz_unc);
if (VAR_46 == 0) { 
unsigned const VAR_47 = get_le32(&VAR_25.sz_cpr);
if (VAR_47 != VAR_48)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_33) {  
int VAR_35 = 0;
unsigned VAR_49 = 0;
VAR_23 = (Elf64_Phdr *) (VAR_21.buf + sizeof(*VAR_22));
for (unsigned VAR_36= 0; VAR_36 < VAR_28; ++VAR_36, ++VAR_23) {
if (VAR_37==get_te32(&VAR_23->p_type) && 0!=VAR_35++) {
VAR_49 = get_te64(&VAR_23->p_offset);
VAR_9->seek(VAR_3, VAR_12);
VAR_9->readx(VAR_24, VAR_4);
VAR_29  += VAR_4;
VAR_30 += VAR_4;
if (VAR_0) {
VAR_0->seek(get_te64(&VAR_23->p_offset), VAR_12);
VAR_0->rewrite(VAR_24, VAR_4);
}
}
}
VAR_23 = (Elf64_Phdr *) (VAR_21.buf + sizeof(*VAR_22));
for (unsigned VAR_36= 0; VAR_36 < VAR_28; ++VAR_36, ++VAR_23) {
if (VAR_23->PT_DYNAMIC==get_te32(&VAR_23->p_type)) {
unsigned const VAR_50 = get_te64(&VAR_23->p_offset);
unsigned const VAR_51 = get_te64(&VAR_23->p_filesz);
Elf64_Dyn *VAR_52 = (Elf64_Dyn *)((unsigned char *)VAR_24 +
(VAR_50 - VAR_49));
for (unsigned VAR_53= 0; VAR_53 < VAR_51; ++VAR_52, VAR_53 += sizeof(*VAR_52)) {
if (VAR_52->DT_INIT==get_te32(&VAR_52->d_tag)) {
if (VAR_0) {
VAR_0->seek(sizeof(upx_uint64_t) + VAR_53 + VAR_50, VAR_12);
VAR_0->rewrite(&VAR_5, sizeof(VAR_5));
VAR_0->seek(0, VAR_54);
}
break;
}
}
}
}
}
VAR_26.c_len = VAR_29;
VAR_26.u_len = VAR_30;
if (VAR_30 != VAR_16)
throwEOFException();
if (VAR_26.c_adler != VAR_31 || VAR_26.u_adler != VAR_32)
throwChecksumError();
#undef MAX_ELF_HDR
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/before/0.json,"void PackLinuxElf64::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    upx_uint64_t old_data_off = 0;
    upx_uint64_t old_data_len = 0;
    upx_uint64_t old_dtinit = 0;

    unsigned szb_info = sizeof(b_info);
    {
        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
        if (e_entry < 0x401180
        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

#define MAX_ELF_HDR 1024
    union {
        unsigned char buf[MAX_ELF_HDR];
        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;
    } u;
    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;
    Elf64_Phdr const *phdr = 0;

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > sizeof(u))
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    // Uncompress Ehdr and Phdrs.
    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)
        throwCompressedDataViolation();
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
        // less strict for EM_PPC64 to workaround earlier bug
    ||  !( ehdr->e_flags==ehdri.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        // Read enough to position the input for next unpackExtent.
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);
        overlay_offset -= sizeof(linfo);
        if (fo) {
            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te64(&phdr->p_offset);
                old_data_len = get_te64(&phdr->p_filesz);
                break;
            }
        }

        total_in  = overlay_offset;
        total_out = overlay_offset;
        ph.u_len = 0;

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te64(&phdr->p_filesz);
                unsigned const offset = get_te64(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD64==get_te32(&phdr->p_type)) {
            load_va = get_te64(&phdr->p_vaddr);
            break;
        }
    }
    if (is_shlib
    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = d_info[2 + (0==d_info[0])];
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
    upx_uint64_t hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD64==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te64(&phdr[j].p_offset) +
                                   get_te64(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {  // the non-first PT_LOAD
        int n_ptload = 0;
        unsigned load_off = 0;
        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te64(&phdr->p_offset);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;
                if (fo) {
                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
        // Restore DT_INIT.d_val
        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {
                unsigned const dyn_off = get_te64(&phdr->p_offset);
                unsigned const dyn_len = get_te64(&phdr->p_filesz);
                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
                    (dyn_off - load_off));
                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {
                        if (fo) {
                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);
                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));
                            fo->seek(0, SEEK_END);
                        }
                        break;
                    }
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
#undef MAX_ELF_HDR
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    upx_uint64_t VAR_5 = 0;
    upx_uint64_t VAR_6 = 0;
    upx_uint64_t VAR_7 = 0;

    unsigned VAR_8 = sizeof(VAR_9);
    {
        upx_uint64_t const VAR_10 = get_te64(&VAR_4.e_entry);
        if (VAR_10 < 0x401180
        &&  get_te16(&VAR_4.e_machine)==Elf64_Ehdr::EM_386) { /* COMMENT_1 */
            VAR_8 = 2*sizeof(unsigned);
        }
    }

    VAR_11->seek(VAR_12 - sizeof(VAR_13), VAR_14);
    VAR_11->readx(&VAR_15, sizeof(VAR_15));
    VAR_16 = get_te16(&VAR_15.l_lsize);
    p_info VAR_17;  VAR_11->readx(&VAR_17, sizeof(VAR_17));
    unsigned VAR_18 = get_te32(&VAR_17.p_filesize);
    VAR_19 = get_te32(&VAR_17.p_blocksize);
    if (VAR_20 > (off_t)VAR_18 || VAR_19 > VAR_18
        || !mem_size_valid(1, VAR_19, VAR_21))
        throwCantUnpack(""p_info corrupted"");

#define VAR_22 1024
    union {
        unsigned char buf[VAR_22];
        /* COMMENT_2 */
    } VAR_23;
    Elf64_Ehdr *const VAR_24 = (Elf64_Ehdr *) VAR_23.buf;
    Elf64_Phdr const *VAR_25 = 0;

    VAR_26.alloc(VAR_19 + VAR_21);
    b_info VAR_27; memset(&VAR_27, 0, sizeof(VAR_27));
    VAR_11->readx(&VAR_27, VAR_8);
    VAR_28.u_len = get_te32(&VAR_27.sz_unc);
    VAR_28.c_len = get_te32(&VAR_27.sz_cpr);
    if (VAR_28.c_len > (unsigned)VAR_20 || VAR_28.c_len == 0 || VAR_28.u_len == 0
    ||  VAR_28.u_len > sizeof(VAR_23))
        throwCantUnpack(""b_info corrupted"");
    VAR_28.filter_cto = VAR_27.b_cto8;

    /* COMMENT_3 */
    if (VAR_26.getSize() < VAR_28.c_len  ||  sizeof(VAR_23) < VAR_28.u_len)
        throwCompressedDataViolation();
    VAR_11->readx(VAR_26, VAR_28.c_len);
    decompress(VAR_26, (upx_byte *)VAR_24, false);
    if (VAR_24->e_type   !=VAR_4.e_type
    ||  VAR_24->e_machine!=VAR_4.e_machine
    ||  VAR_24->e_version!=VAR_4.e_version
        /* COMMENT_4 */
    ||  !( VAR_24->e_flags==VAR_4.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_4.e_machine))
    ||  VAR_24->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_24->e_ident, VAR_4.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    VAR_11->seek(- (off_t) (VAR_8 + VAR_28.c_len), VAR_29);

    unsigned const VAR_30 = get_te16(&VAR_24->e_phnum);
    unsigned VAR_31 = 0;
    unsigned VAR_32 = 0;
    unsigned VAR_33 = upx_adler32(NULL, 0);
    unsigned VAR_34 = upx_adler32(NULL, 0);

    /* COMMENT_6 */
    /* COMMENT_7 */
    bool const VAR_35 = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_36, VAR_3);
    if (VAR_35) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_28.u_len, VAR_0, VAR_31, VAR_32,
            VAR_33, VAR_34, false, VAR_8);

        /* COMMENT_10 */
        /* COMMENT_11 */
        VAR_11->seek(0, VAR_14);
        VAR_11->readx(VAR_26, VAR_12 + sizeof(VAR_17) + VAR_8 + VAR_28.c_len);
        VAR_12 -= sizeof(VAR_15);
        if (VAR_0) {
            VAR_0->write(VAR_26 + VAR_28.u_len, VAR_12 - VAR_28.u_len);
        }
        /* COMMENT_12 */
        int VAR_37 = 0;
        VAR_25 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_26);
        for (unsigned VAR_38=0; VAR_38 < VAR_30; ++VAR_25, ++VAR_38) {
            if (VAR_39==get_te32(&VAR_25->p_type) && 0!=VAR_37++) {
                VAR_5 = get_te64(&VAR_25->p_offset);
                VAR_6 = get_te64(&VAR_25->p_filesz);
                break;
            }
        }

        VAR_31  = VAR_12;
        VAR_32 = VAR_12;
        VAR_28.u_len = 0;

        /* COMMENT_13 */
        VAR_25 = (Elf64_Phdr *) (void *) (1+ VAR_24);
        for (unsigned VAR_38=0; VAR_38 < VAR_30; ++VAR_25, ++VAR_38) {
            if (VAR_39==get_te32(&VAR_25->p_type)) {
                VAR_28.u_len = get_te64(&VAR_25->p_filesz) - VAR_12;
                break;
            }
        }
        unpackExtent(VAR_28.u_len, VAR_0, VAR_31, VAR_32,
            VAR_33, VAR_34, false, VAR_8);
    }
    else {  /* COMMENT_14 */
        /* COMMENT_15 */
        bool VAR_40 = true;
        VAR_25 = (Elf64_Phdr *) (void *) (1+ VAR_24);  /* COMMENT_16 */
        for (unsigned VAR_38=0; VAR_38 < VAR_30; ++VAR_25, ++VAR_38) {
            if (VAR_39==get_te32(&VAR_25->p_type)) {
                unsigned const VAR_41 = get_te64(&VAR_25->p_filesz);
                unsigned const VAR_42 = get_te64(&VAR_25->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_42, VAR_14);
                if (Elf64_Phdr::PF_X & get_te32(&VAR_25->p_flags)) {
                    unpackExtent(VAR_41, VAR_0, VAR_31, VAR_32,
                        VAR_33, VAR_34, VAR_40, VAR_8);
                    VAR_40 = false;
                }
                else {
                    unpackExtent(VAR_41, VAR_0, VAR_31, VAR_32,
                        VAR_33, VAR_34, false, VAR_8);
                }
            }
        }
    }
    VAR_25 = VAR_36;
    VAR_43 = 0;
    for (unsigned VAR_38=0; VAR_38 < VAR_3; ++VAR_38) {
        if (VAR_39==get_te32(&VAR_25->p_type)) {
            VAR_43 = get_te64(&VAR_25->p_vaddr);
            break;
        }
    }
    if (VAR_35
    ||  ((unsigned)(get_te64(&VAR_4.e_entry) - VAR_43) + up4(VAR_16) +
                VAR_28.getPackHeaderSize() + sizeof(VAR_12))
            < up4(VAR_20)) {
        /* COMMENT_17 */
        funpad4(VAR_11);  /* COMMENT_18 */
        unsigned VAR_44[6]; VAR_11->readx(VAR_44, sizeof(VAR_44));
        if (0==VAR_7) {
            VAR_7 = VAR_44[2 + (0==VAR_44[0])];
        }
        VAR_11->seek(VAR_16 - sizeof(VAR_44), VAR_29);
    }

    /* COMMENT_19 */
    VAR_25 = (Elf64_Phdr *) (VAR_23.buf + sizeof(*VAR_24));
    upx_uint64_t VAR_45(0);
    for (unsigned VAR_38 = 0; VAR_38 < VAR_30; ++VAR_38) {
        if (VAR_39==VAR_25[VAR_38].p_type
        &&  VAR_45 < VAR_25[VAR_38].p_offset)
            VAR_45 = VAR_25[VAR_38].p_offset;
    }
    for (unsigned VAR_38 = 0; VAR_38 < VAR_30; ++VAR_38) {
        unsigned const VAR_46 = find_LOAD_gap(VAR_25, VAR_38, VAR_30);
        if (VAR_46) {
            unsigned const VAR_47 = get_te64(&VAR_25[VAR_38].p_offset) +
                                   get_te64(&VAR_25[VAR_38].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_47, VAR_14);
            unpackExtent(VAR_46, VAR_0, VAR_31, VAR_32,
                VAR_33, VAR_34, false, VAR_8,
                (VAR_25[VAR_38].p_offset != VAR_45));
        }
    }

    /* COMMENT_20 */
    VAR_11->readx(&VAR_27, VAR_8);
    unsigned const VAR_48 = VAR_28.u_len = get_te32(&VAR_27.sz_unc);

    if (VAR_48 == 0) { /* COMMENT_21 */
        /* COMMENT_22 */
        unsigned const VAR_49 = get_le32(&VAR_27.sz_cpr);
        if (VAR_49 != VAR_50)  /* COMMENT_23 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_24 */
        throwCompressedDataViolation();
    }

    if (VAR_35) {  /* COMMENT_25 */
        int VAR_37 = 0;
        unsigned VAR_51 = 0;
        VAR_25 = (Elf64_Phdr *) (VAR_23.buf + sizeof(*VAR_24));
        for (unsigned VAR_38= 0; VAR_38 < VAR_30; ++VAR_38, ++VAR_25) {
            if (VAR_39==get_te32(&VAR_25->p_type) && 0!=VAR_37++) {
                VAR_51 = get_te64(&VAR_25->p_offset);
                VAR_11->seek(VAR_5, VAR_14);
                VAR_11->readx(VAR_26, VAR_6);
                VAR_31  += VAR_6;
                VAR_32 += VAR_6;
                if (VAR_0) {
                    VAR_0->seek(get_te64(&VAR_25->p_offset), VAR_14);
                    VAR_0->rewrite(VAR_26, VAR_6);
                }
            }
        }
        /* COMMENT_26 */
        VAR_25 = (Elf64_Phdr *) (VAR_23.buf + sizeof(*VAR_24));
        for (unsigned VAR_38= 0; VAR_38 < VAR_30; ++VAR_38, ++VAR_25) {
            if (VAR_25->PT_DYNAMIC==get_te32(&VAR_25->p_type)) {
                unsigned const VAR_52 = get_te64(&VAR_25->p_offset);
                unsigned const VAR_53 = get_te64(&VAR_25->p_filesz);
                Elf64_Dyn *VAR_54 = (Elf64_Dyn *)((unsigned char *)VAR_26 +
                    (VAR_52 - VAR_51));
                for (unsigned VAR_55= 0; VAR_55 < VAR_53; ++VAR_54, VAR_55 += sizeof(*VAR_54)) {
                    if (VAR_54->DT_INIT==get_te32(&VAR_54->d_tag)) {
                        if (VAR_0) {
                            VAR_0->seek(sizeof(upx_uint64_t) + VAR_55 + VAR_52, VAR_14);
                            VAR_0->rewrite(&VAR_7, sizeof(VAR_7));
                            VAR_0->seek(0, VAR_56);
                        }
                        break;
                    }
                }
            }
        }
    }

    /* COMMENT_27 */
    VAR_28.c_len = VAR_31;
    VAR_28.u_len = VAR_32;

    /* COMMENT_28 */
    if (VAR_32 != VAR_18)
        throwEOFException();

    /* COMMENT_29 */
    if (VAR_28.c_adler != VAR_33 || VAR_28.u_adler != VAR_34)
        throwChecksumError();
#undef MAX_ELF_HDR
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 void PackLinuxElf64::unpack(OutputFile *fo)
 {
+    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr
+        throwCantUnpack(""bad e_phoff"");
+    }
     unsigned const c_phnum = get_te16(&ehdri.e_phnum);
     upx_uint64_t old_data_off = 0;
     upx_uint64_t old_data_len = 0;","{'deleted_lines': [], 'added_lines': ['    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr', '        throwCantUnpack(""bad e_phoff"");', '    }']}",True,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",7.8,HIGH,2,valid,2017-10-03T04:47:40Z,2
CVE-2017-15056,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,upx,"Protect against bad crafted input.

https://github.com/upx/upx/issues/128
	modified:   p_lx_elf.cpp",ef336dbcc6dc8344482f8cf6c909ae96c3286317,https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,src/p_lx_elf.cpp,PackLinuxElf64::PackLinuxElf64help1,"void
PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
{
e_type  = get_te16(&ehdri.e_type);
e_phnum = get_te16(&ehdri.e_phnum);
e_shnum = get_te16(&ehdri.e_shnum);
unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);
if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64
|| sizeof(Elf64_Phdr) != e_phentsize
|| (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]
&& &N_BELE_RTP::be_policy != bele)
|| (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]
&& &N_BELE_RTP::le_policy != bele)) {
e_phoff = 0;
e_shoff = 0;
sz_phdrs = 0;
return;
}
e_phoff = get_te64(&ehdri.e_phoff);
e_shoff = get_te64(&ehdri.e_shoff);
sz_phdrs = e_phnum * e_phentsize;
if (f && Elf64_Ehdr::ET_DYN!=e_type) {
unsigned const len = sz_phdrs + e_phoff;
alloc_file_image(file_image, len);
f->seek(0, SEEK_SET);
f->readx(file_image, len);
phdri= (Elf64_Phdr       *)(e_phoff + file_image);      }
if (f && Elf64_Ehdr::ET_DYN==e_type) {
alloc_file_image(file_image, file_size);
f->seek(0, SEEK_SET);
f->readx(file_image, file_size);
phdri= (Elf64_Phdr       *)(e_phoff + file_image);          shdri= (Elf64_Shdr const *)(e_shoff + file_image);          sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (sec_dynsym)
sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;
Elf64_Phdr const *phdr= phdri;
for (int j = e_phnum; --j>=0; ++phdr)
if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {
dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);
break;
}
dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);
gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
jni_onload_sym = elf_lookup(""JNI_OnLoad"");
if (jni_onload_sym) {
jni_onload_va = get_te64(&jni_onload_sym->st_value);
jni_onload_va = 0;
}
}
}","void
PackLinuxElf64::PackLinuxElf64help1(InputFile *VAR_0)
{
VAR_1  = get_te16(&VAR_2.e_type);
VAR_3 = get_te16(&VAR_2.e_phnum);
VAR_4 = get_te16(&VAR_2.e_shnum);
unsigned const VAR_5 = get_te16(&VAR_2.e_phentsize);
if (VAR_2.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64
|| sizeof(VAR_6) != VAR_5
|| (Elf64_Ehdr::ELFDATA2MSB == VAR_2.e_ident[Elf64_Ehdr::EI_DATA]
&& &N_BELE_RTP::be_policy != VAR_7)
|| (Elf64_Ehdr::ELFDATA2LSB == VAR_2.e_ident[Elf64_Ehdr::EI_DATA]
&& &N_BELE_RTP::le_policy != VAR_7)) {
VAR_8 = 0;
VAR_9 = 0;
VAR_10 = 0;
return;
}
VAR_8 = get_te64(&VAR_2.e_phoff);
VAR_9 = get_te64(&VAR_2.e_shoff);
VAR_10 = VAR_3 * VAR_5;
if (VAR_0 && Elf64_Ehdr::ET_DYN!=VAR_1) {
unsigned const VAR_11 = VAR_10 + VAR_8;
alloc_file_image(VAR_12, VAR_11);
VAR_0->seek(0, VAR_13);
VAR_0->readx(VAR_12, VAR_11);
VAR_14= (Elf64_Phdr       *)(VAR_8 + VAR_12);  
}
if (VAR_0 && Elf64_Ehdr::ET_DYN==VAR_1) {
alloc_file_image(VAR_12, VAR_15);
VAR_0->seek(0, VAR_13);
VAR_0->readx(VAR_12, VAR_15);
VAR_14= (Elf64_Phdr       *)(VAR_8 + VAR_12);  
VAR_16= (Elf64_Shdr const *)(VAR_9 + VAR_12);  
VAR_17 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (VAR_17)
VAR_18 = get_te64(&VAR_17->sh_link) + VAR_16;
Elf64_Phdr const *VAR_19= VAR_14;
for (int VAR_20 = VAR_3; --VAR_20>=0; ++VAR_19)
if (Elf64_Phdr::PT_DYNAMIC==get_te64(&VAR_19->p_type)) {
VAR_21= (Elf64_Dyn const *)(get_te64(&VAR_19->p_offset) + VAR_12);
break;
}
VAR_22 =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
VAR_23 = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);
VAR_24 = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
VAR_25 = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
VAR_26 = elf_lookup(""JNI_OnLoad"");
if (VAR_26) {
VAR_27 = get_te64(&VAR_26->st_value);
VAR_27 = 0;
}
}
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/before/1.json,"void
PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
{
    e_type  = get_te16(&ehdri.e_type);
    e_phnum = get_te16(&ehdri.e_phnum);
    e_shnum = get_te16(&ehdri.e_shnum);
    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);
    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64
    || sizeof(Elf64_Phdr) != e_phentsize
    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]
            && &N_BELE_RTP::be_policy != bele)
    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]
            && &N_BELE_RTP::le_policy != bele)) {
        e_phoff = 0;
        e_shoff = 0;
        sz_phdrs = 0;
        return;
    }
    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");
    e_phoff = get_te64(&ehdri.e_phoff);
    if ((unsigned long)file_size < (e_phoff + e_phnum * sizeof(Elf64_Phdr))) {
        throwCantUnpack(""bad e_phoff"");
    }
    e_shoff = get_te64(&ehdri.e_shoff);
    if ((unsigned long)file_size < (e_shoff + e_shnum * sizeof(Elf64_Shdr))) {
        throwCantUnpack(""bad e_shoff"");
    }
    sz_phdrs = e_phnum * e_phentsize;

    if (f && Elf64_Ehdr::ET_DYN!=e_type) {
        unsigned const len = sz_phdrs + e_phoff;
        alloc_file_image(file_image, len);
        f->seek(0, SEEK_SET);
        f->readx(file_image, len);
        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!
    }
    if (f && Elf64_Ehdr::ET_DYN==e_type) {
        // The DT_SYMTAB has no designated length.  Read the whole file.
        alloc_file_image(file_image, file_size);
        f->seek(0, SEEK_SET);
        f->readx(file_image, file_size);
        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!
        shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!
        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
        if (sec_dynsym)
            sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;

        Elf64_Phdr const *phdr= phdri;
        for (int j = e_phnum; --j>=0; ++phdr)
        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {
            dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);
            break;
        }
        // elf_find_dynamic() returns 0 if 0==dynseg.
        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);
        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
        jni_onload_sym = elf_lookup(""JNI_OnLoad"");
        if (jni_onload_sym) {
            jni_onload_va = get_te64(&jni_onload_sym->st_value);
            jni_onload_va = 0;
        }
    }
}","void
PackLinuxElf64::PackLinuxElf64help1(InputFile *VAR_0)
{
    VAR_1  = get_te16(&VAR_2.e_type);
    VAR_3 = get_te16(&VAR_2.e_phnum);
    VAR_4 = get_te16(&VAR_2.e_shnum);
    unsigned const VAR_5 = get_te16(&VAR_2.e_phentsize);
    if (VAR_2.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64
    || sizeof(VAR_6) != VAR_5
    || (Elf64_Ehdr::ELFDATA2MSB == VAR_2.e_ident[Elf64_Ehdr::EI_DATA]
            && &N_BELE_RTP::be_policy != VAR_7)
    || (Elf64_Ehdr::ELFDATA2LSB == VAR_2.e_ident[Elf64_Ehdr::EI_DATA]
            && &N_BELE_RTP::le_policy != VAR_7)) {
        VAR_8 = 0;
        VAR_9 = 0;
        VAR_10 = 0;
        return;
    }
    if (0==VAR_3) throwCantUnpack(""0==e_phnum"");
    VAR_8 = get_te64(&VAR_2.e_phoff);
    if ((unsigned long)VAR_11 < (VAR_8 + VAR_3 * sizeof(VAR_6))) {
        throwCantUnpack(""bad e_phoff"");
    }
    VAR_9 = get_te64(&VAR_2.e_shoff);
    if ((unsigned long)VAR_11 < (VAR_9 + VAR_4 * sizeof(VAR_12))) {
        throwCantUnpack(""bad e_shoff"");
    }
    VAR_10 = VAR_3 * VAR_5;

    if (VAR_0 && Elf64_Ehdr::ET_DYN!=VAR_1) {
        unsigned const VAR_13 = VAR_10 + VAR_8;
        alloc_file_image(VAR_14, VAR_13);
        VAR_0->seek(0, VAR_15);
        VAR_0->readx(VAR_14, VAR_13);
        VAR_16= (Elf64_Phdr       *)(VAR_8 + VAR_14);  /* COMMENT_0 */
    }
    if (VAR_0 && Elf64_Ehdr::ET_DYN==VAR_1) {
        /* COMMENT_1 */
        alloc_file_image(VAR_14, VAR_11);
        VAR_0->seek(0, VAR_15);
        VAR_0->readx(VAR_14, VAR_11);
        VAR_16= (Elf64_Phdr       *)(VAR_8 + VAR_14);  /* COMMENT_0 */
        VAR_17= (Elf64_Shdr const *)(VAR_9 + VAR_14);  /* COMMENT_0 */
        VAR_18 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
        if (VAR_18)
            VAR_19 = get_te64(&VAR_18->sh_link) + VAR_17;

        Elf64_Phdr const *VAR_20= VAR_16;
        for (int VAR_21 = VAR_3; --VAR_21>=0; ++VAR_20)
        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&VAR_20->p_type)) {
            VAR_22= (Elf64_Dyn const *)(get_te64(&VAR_20->p_offset) + VAR_14);
            break;
        }
        /* COMMENT_2 */
        VAR_23 =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
        VAR_24 = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);
        VAR_25 = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
        VAR_26 = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
        VAR_27 = elf_lookup(""JNI_OnLoad"");
        if (VAR_27) {
            VAR_28 = get_te64(&VAR_27->st_value);
            VAR_28 = 0;
        }
    }
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,8 +16,15 @@
         sz_phdrs = 0;
         return;
     }
+    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");
     e_phoff = get_te64(&ehdri.e_phoff);
+    if ((unsigned long)file_size < (e_phoff + e_phnum * sizeof(Elf64_Phdr))) {
+        throwCantUnpack(""bad e_phoff"");
+    }
     e_shoff = get_te64(&ehdri.e_shoff);
+    if ((unsigned long)file_size < (e_shoff + e_shnum * sizeof(Elf64_Shdr))) {
+        throwCantUnpack(""bad e_shoff"");
+    }
     sz_phdrs = e_phnum * e_phentsize;
 
     if (f && Elf64_Ehdr::ET_DYN!=e_type) {","{'deleted_lines': [], 'added_lines': ['    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");', '    if ((unsigned long)file_size < (e_phoff + e_phnum * sizeof(Elf64_Phdr))) {', '        throwCantUnpack(""bad e_phoff"");', '    }', '    if ((unsigned long)file_size < (e_shoff + e_shnum * sizeof(Elf64_Shdr))) {', '        throwCantUnpack(""bad e_shoff"");', '    }']}",True,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",7.8,HIGH,2,valid,2017-10-03T04:47:40Z,2
CVE-2017-15056,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,upx,"Protect against bad crafted input.

https://github.com/upx/upx/issues/128
	modified:   p_lx_elf.cpp",ef336dbcc6dc8344482f8cf6c909ae96c3286317,https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,src/p_lx_elf.cpp,PackLinuxElf32::unpack,"void PackLinuxElf32::unpack(OutputFile *fo)
{
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
unsigned old_data_off = 0;
unsigned old_data_len = 0;
unsigned old_dtinit = 0;
unsigned szb_info = sizeof(b_info);
{
if (get_te32(&ehdri.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if (file_size > (off_t)orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
#define MAX_ELF_HDR 512
union {
unsigned char buf[MAX_ELF_HDR];
struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;
} u;
COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)
Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;
Elf32_Phdr const *phdr = 0;
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > sizeof(u))
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)
throwCompressedDataViolation();
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  ehdr->e_flags  !=ehdri.e_flags
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))
throwCantUnpack(""ElfXX_Ehdr corrupted"");
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);
overlay_offset -= sizeof(linfo);
if (fo) {
fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te32(&phdr->p_offset);
old_data_len = get_te32(&phdr->p_filesz);
break;
}
}
total_in  = overlay_offset;
total_out = overlay_offset;
ph.u_len = 0;
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te32(&phdr->p_filesz);
unsigned const offset = get_te32(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
load_va = get_te32(&phdr->p_vaddr);
break;
}
}
if (is_shlib
||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = d_info[2 + (0==d_info[0])];
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
unsigned hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD32==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te32(&phdr[j].p_offset) +
get_te32(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {          int n_ptload = 0;
unsigned load_off = 0;
phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te32(&phdr->p_offset);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
if (fo) {
fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {
unsigned const dyn_off = get_te32(&phdr->p_offset);
unsigned const dyn_len = get_te32(&phdr->p_filesz);
Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {
if (fo) {
fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);
fo->rewrite(&old_dtinit, sizeof(old_dtinit));
fo->seek(0, SEEK_END);
}
break;
}
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
#undef MAX_ELF_HDR
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
unsigned const VAR_1 = get_te16(&VAR_2.e_phnum);
unsigned VAR_3 = 0;
unsigned VAR_4 = 0;
unsigned VAR_5 = 0;
unsigned VAR_6 = sizeof(VAR_7);
{
if (get_te32(&VAR_2.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_2.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_2.e_type)) {
VAR_6 = 2*sizeof(unsigned);
}
}
VAR_8->seek(VAR_9 - sizeof(VAR_10), VAR_11);
VAR_8->readx(&VAR_12, sizeof(VAR_12));
VAR_13 = get_te16(&VAR_12.l_lsize);
p_info VAR_14;  VAR_8->readx(&VAR_14, sizeof(VAR_14));
unsigned VAR_15 = get_te32(&VAR_14.p_filesize);
VAR_16 = get_te32(&VAR_14.p_blocksize);
if (VAR_17 > (off_t)VAR_15 || VAR_16 > VAR_15
|| !mem_size_valid(1, VAR_16, VAR_18))
throwCantUnpack(""p_info corrupted"");
#define VAR_19 512
union {
unsigned char buf[VAR_19];
struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;
} VAR_20;
COMPILE_TIME_ASSERT(sizeof(VAR_20) == VAR_19)
Elf32_Ehdr *const VAR_21 = (Elf32_Ehdr *) VAR_20.buf;
Elf32_Phdr const *VAR_22 = 0;
VAR_23.alloc(VAR_16 + VAR_18);
b_info VAR_24; memset(&VAR_24, 0, sizeof(VAR_24));
VAR_8->readx(&VAR_24, VAR_6);
VAR_25.u_len = get_te32(&VAR_24.sz_unc);
VAR_25.c_len = get_te32(&VAR_24.sz_cpr);
if (VAR_25.c_len > (unsigned)VAR_17 || VAR_25.c_len == 0 || VAR_25.u_len == 0
||  VAR_25.u_len > sizeof(VAR_20))
throwCantUnpack(""b_info corrupted"");
VAR_25.filter_cto = VAR_24.b_cto8;
if (VAR_23.getSize() < VAR_25.c_len  ||  sizeof(VAR_20) < VAR_25.u_len)
throwCompressedDataViolation();
VAR_8->readx(VAR_23, VAR_25.c_len);
decompress(VAR_23, (upx_byte *)VAR_21, false);
if (VAR_21->e_type   !=VAR_2.e_type
||  VAR_21->e_machine!=VAR_2.e_machine
||  VAR_21->e_version!=VAR_2.e_version
||  VAR_21->e_flags  !=VAR_2.e_flags
||  VAR_21->e_ehsize !=VAR_2.e_ehsize
||  memcmp(VAR_21->e_ident, VAR_2.e_ident, Elf32_Ehdr::EI_OSABI))
throwCantUnpack(""ElfXX_Ehdr corrupted"");
VAR_8->seek(- (off_t) (VAR_6 + VAR_25.c_len), VAR_26);
unsigned const VAR_27 = get_te16(&VAR_21->e_phnum);
unsigned VAR_28 = 0;
unsigned VAR_29 = 0;
unsigned VAR_30 = upx_adler32(NULL, 0);
unsigned VAR_31 = upx_adler32(NULL, 0);
bool const VAR_32 = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_33, VAR_1);
if (VAR_32) {
unpackExtent(VAR_25.u_len, VAR_0, VAR_28, VAR_29,
VAR_30, VAR_31, false, VAR_6);
VAR_8->seek(0, VAR_11);
VAR_8->readx(VAR_23, VAR_9 + sizeof(VAR_14) + VAR_6 + VAR_25.c_len);
VAR_9 -= sizeof(VAR_12);
if (VAR_0) {
VAR_0->write(VAR_23 + VAR_25.u_len, VAR_9 - VAR_25.u_len);
}
int VAR_34 = 0;
VAR_22 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_23);
for (unsigned VAR_35=0; VAR_35 < VAR_27; ++VAR_22, ++VAR_35) {
if (VAR_36==get_te32(&VAR_22->p_type) && 0!=VAR_34++) {
VAR_3 = get_te32(&VAR_22->p_offset);
VAR_4 = get_te32(&VAR_22->p_filesz);
break;
}
}
VAR_28  = VAR_9;
VAR_29 = VAR_9;
VAR_25.u_len = 0;
VAR_22 = (Elf32_Phdr *) (void *) (1+ VAR_21);
for (unsigned VAR_35=0; VAR_35 < VAR_27; ++VAR_22, ++VAR_35) {
if (VAR_36==get_te32(&VAR_22->p_type)) {
VAR_25.u_len = get_te32(&VAR_22->p_filesz) - VAR_9;
break;
}
}
unpackExtent(VAR_25.u_len, VAR_0, VAR_28, VAR_29,
VAR_30, VAR_31, false, VAR_6);
}
else {  
bool VAR_37 = true;
VAR_22 = (Elf32_Phdr *) (void *) (1+ VAR_21);  
for (unsigned VAR_35=0; VAR_35 < VAR_27; ++VAR_22, ++VAR_35) {
if (VAR_36==get_te32(&VAR_22->p_type)) {
unsigned const VAR_38 = get_te32(&VAR_22->p_filesz);
unsigned const VAR_39 = get_te32(&VAR_22->p_offset);
if (VAR_0)
VAR_0->seek(VAR_39, VAR_11);
if (Elf32_Phdr::PF_X & get_te32(&VAR_22->p_flags)) {
unpackExtent(VAR_38, VAR_0, VAR_28, VAR_29,
VAR_30, VAR_31, VAR_37, VAR_6);
VAR_37 = false;
}
else {
unpackExtent(VAR_38, VAR_0, VAR_28, VAR_29,
VAR_30, VAR_31, false, VAR_6);
}
}
}
}
VAR_22 = VAR_33;
VAR_40 = 0;
for (unsigned VAR_35=0; VAR_35 < VAR_1; ++VAR_35) {
if (VAR_36==get_te32(&VAR_22->p_type)) {
VAR_40 = get_te32(&VAR_22->p_vaddr);
break;
}
}
if (VAR_32
||  ((unsigned)(get_te32(&VAR_2.e_entry) - VAR_40) + up4(VAR_13) +
VAR_25.getPackHeaderSize() + sizeof(VAR_9))
< up4(VAR_17)) {
funpad4(VAR_8);  
unsigned VAR_41[4]; VAR_8->readx(VAR_41, sizeof(VAR_41));
if (0==VAR_5) {
VAR_5 = VAR_41[2 + (0==VAR_41[0])];
}
VAR_8->seek(VAR_13 - sizeof(VAR_41), VAR_26);
}
VAR_22 = (Elf32_Phdr *) (VAR_20.buf + sizeof(*VAR_21));
unsigned VAR_42(0);
for (unsigned VAR_35 = 0; VAR_35 < VAR_27; ++VAR_35) {
if (VAR_36==VAR_22[VAR_35].p_type
&&  VAR_42 < VAR_22[VAR_35].p_offset)
VAR_42 = VAR_22[VAR_35].p_offset;
}
for (unsigned VAR_35 = 0; VAR_35 < VAR_27; ++VAR_35) {
unsigned const VAR_43 = find_LOAD_gap(VAR_22, VAR_35, VAR_27);
if (VAR_43) {
unsigned const VAR_44 = get_te32(&VAR_22[VAR_35].p_offset) +
get_te32(&VAR_22[VAR_35].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_44, VAR_11);
unpackExtent(VAR_43, VAR_0, VAR_28, VAR_29,
VAR_30, VAR_31, false, VAR_6,
(VAR_22[VAR_35].p_offset != VAR_42));
}
}
VAR_8->readx(&VAR_24, VAR_6);
unsigned const VAR_45 = VAR_25.u_len = get_te32(&VAR_24.sz_unc);
if (VAR_45 == 0) { 
unsigned const VAR_46 = get_le32(&VAR_24.sz_cpr);
if (VAR_46 != VAR_47)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_32) {  
int VAR_34 = 0;
unsigned VAR_48 = 0;
VAR_22 = (Elf32_Phdr *) (VAR_20.buf + sizeof(*VAR_21));
for (unsigned VAR_35= 0; VAR_35 < VAR_27; ++VAR_35, ++VAR_22) {
if (VAR_36==get_te32(&VAR_22->p_type) && 0!=VAR_34++) {
VAR_48 = get_te32(&VAR_22->p_offset);
VAR_8->seek(VAR_3, VAR_11);
VAR_8->readx(VAR_23, VAR_4);
VAR_28  += VAR_4;
VAR_29 += VAR_4;
if (VAR_0) {
VAR_0->seek(get_te32(&VAR_22->p_offset), VAR_11);
VAR_0->rewrite(VAR_23, VAR_4);
}
}
}
VAR_22 = (Elf32_Phdr *) (VAR_20.buf + sizeof(*VAR_21));
for (unsigned VAR_35= 0; VAR_35 < VAR_27; ++VAR_35, ++VAR_22) {
if (VAR_22->PT_DYNAMIC==get_te32(&VAR_22->p_type)) {
unsigned const VAR_49 = get_te32(&VAR_22->p_offset);
unsigned const VAR_50 = get_te32(&VAR_22->p_filesz);
Elf32_Dyn *VAR_51 = (Elf32_Dyn *)((unsigned char *)VAR_23 +
(VAR_49 - VAR_48));
for (unsigned VAR_52= 0; VAR_52 < VAR_50; ++VAR_51, VAR_52 += sizeof(*VAR_51)) {
if (VAR_51->DT_INIT==get_te32(&VAR_51->d_tag)) {
if (VAR_0) {
VAR_0->seek(sizeof(unsigned) + VAR_52 + VAR_49, VAR_11);
VAR_0->rewrite(&VAR_5, sizeof(VAR_5));
VAR_0->seek(0, VAR_53);
}
break;
}
}
}
}
}
VAR_25.c_len = VAR_28;
VAR_25.u_len = VAR_29;
if (VAR_29 != VAR_15)
throwEOFException();
if (VAR_25.c_adler != VAR_30 || VAR_25.u_adler != VAR_31)
throwChecksumError();
#undef MAX_ELF_HDR
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/before/2.json,"void PackLinuxElf32::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    unsigned old_data_off = 0;
    unsigned old_data_len = 0;
    unsigned old_dtinit = 0;

    unsigned szb_info = sizeof(b_info);
    {
        if (get_te32(&ehdri.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.
            /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

#define MAX_ELF_HDR 512
    union {
        unsigned char buf[MAX_ELF_HDR];
        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;
    } u;
    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)
    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;
    Elf32_Phdr const *phdr = 0;

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > sizeof(u))
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.
    // Uncompress an extra time, and don't verify or update checksums.
    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)
        throwCompressedDataViolation();
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
    ||  ehdr->e_flags  !=ehdri.e_flags
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        // Read enough to position the input for next unpackExtent.
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);
        overlay_offset -= sizeof(linfo);
        if (fo) {
            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te32(&phdr->p_offset);
                old_data_len = get_te32(&phdr->p_filesz);
                break;
            }
        }

        total_in  = overlay_offset;
        total_out = overlay_offset;
        ph.u_len = 0;

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te32(&phdr->p_filesz);
                unsigned const offset = get_te32(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD32==get_te32(&phdr->p_type)) {
            load_va = get_te32(&phdr->p_vaddr);
            break;
        }
    }
    if (is_shlib
    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = d_info[2 + (0==d_info[0])];
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
    unsigned hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD32==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te32(&phdr[j].p_offset) +
                                   get_te32(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {  // the non-first PT_LOAD
        int n_ptload = 0;
        unsigned load_off = 0;
        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te32(&phdr->p_offset);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;
                if (fo) {
                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
        // Restore DT_INIT.d_val
        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {
                unsigned const dyn_off = get_te32(&phdr->p_offset);
                unsigned const dyn_len = get_te32(&phdr->p_filesz);
                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
                    (dyn_off - load_off));
                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {
                        if (fo) {
                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);
                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));
                            fo->seek(0, SEEK_END);
                        }
                        break;
                    }
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
#undef MAX_ELF_HDR
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    unsigned VAR_5 = 0;
    unsigned VAR_6 = 0;
    unsigned VAR_7 = 0;

    unsigned VAR_8 = sizeof(VAR_9);
    {
        if (get_te32(&VAR_4.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_4.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_4.e_type)) {
            /* COMMENT_1 */
            /* COMMENT_2 */
            VAR_8 = 2*sizeof(unsigned);
        }
    }

    VAR_10->seek(VAR_11 - sizeof(VAR_12), VAR_13);
    VAR_10->readx(&VAR_14, sizeof(VAR_14));
    VAR_15 = get_te16(&VAR_14.l_lsize);
    p_info VAR_16;  VAR_10->readx(&VAR_16, sizeof(VAR_16));
    unsigned VAR_17 = get_te32(&VAR_16.p_filesize);
    VAR_18 = get_te32(&VAR_16.p_blocksize);
    if (VAR_19 > (off_t)VAR_17 || VAR_18 > VAR_17
        || !mem_size_valid(1, VAR_18, VAR_20))
        throwCantUnpack(""p_info corrupted"");

#define VAR_21 512
    union {
        unsigned char buf[VAR_21];
        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;
    } VAR_22;
    COMPILE_TIME_ASSERT(sizeof(VAR_22) == VAR_21)
    Elf32_Ehdr *const VAR_23 = (Elf32_Ehdr *) VAR_22.buf;
    Elf32_Phdr const *VAR_24 = 0;

    VAR_25.alloc(VAR_18 + VAR_20);
    b_info VAR_26; memset(&VAR_26, 0, sizeof(VAR_26));
    VAR_10->readx(&VAR_26, VAR_8);
    VAR_27.u_len = get_te32(&VAR_26.sz_unc);
    VAR_27.c_len = get_te32(&VAR_26.sz_cpr);
    if (VAR_27.c_len > (unsigned)VAR_19 || VAR_27.c_len == 0 || VAR_27.u_len == 0
    ||  VAR_27.u_len > sizeof(VAR_22))
        throwCantUnpack(""b_info corrupted"");
    VAR_27.filter_cto = VAR_26.b_cto8;

    /* COMMENT_3 */
    /* COMMENT_4 */
    if (VAR_25.getSize() < VAR_27.c_len  ||  sizeof(VAR_22) < VAR_27.u_len)
        throwCompressedDataViolation();
    VAR_10->readx(VAR_25, VAR_27.c_len);
    decompress(VAR_25, (upx_byte *)VAR_23, false);
    if (VAR_23->e_type   !=VAR_4.e_type
    ||  VAR_23->e_machine!=VAR_4.e_machine
    ||  VAR_23->e_version!=VAR_4.e_version
    ||  VAR_23->e_flags  !=VAR_4.e_flags
    ||  VAR_23->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_23->e_ident, VAR_4.e_ident, Elf32_Ehdr::EI_OSABI))
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    VAR_10->seek(- (off_t) (VAR_8 + VAR_27.c_len), VAR_28);

    unsigned const VAR_29 = get_te16(&VAR_23->e_phnum);
    unsigned VAR_30 = 0;
    unsigned VAR_31 = 0;
    unsigned VAR_32 = upx_adler32(NULL, 0);
    unsigned VAR_33 = upx_adler32(NULL, 0);

    /* COMMENT_6 */
    /* COMMENT_7 */
    bool const VAR_34 = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_35, VAR_3);
    if (VAR_34) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_27.u_len, VAR_0, VAR_30, VAR_31,
            VAR_32, VAR_33, false, VAR_8);

        /* COMMENT_10 */
        /* COMMENT_11 */
        VAR_10->seek(0, VAR_13);
        VAR_10->readx(VAR_25, VAR_11 + sizeof(VAR_16) + VAR_8 + VAR_27.c_len);
        VAR_11 -= sizeof(VAR_14);
        if (VAR_0) {
            VAR_0->write(VAR_25 + VAR_27.u_len, VAR_11 - VAR_27.u_len);
        }
        /* COMMENT_12 */
        int VAR_36 = 0;
        VAR_24 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_25);
        for (unsigned VAR_37=0; VAR_37 < VAR_29; ++VAR_24, ++VAR_37) {
            if (VAR_38==get_te32(&VAR_24->p_type) && 0!=VAR_36++) {
                VAR_5 = get_te32(&VAR_24->p_offset);
                VAR_6 = get_te32(&VAR_24->p_filesz);
                break;
            }
        }

        VAR_30  = VAR_11;
        VAR_31 = VAR_11;
        VAR_27.u_len = 0;

        /* COMMENT_13 */
        VAR_24 = (Elf32_Phdr *) (void *) (1+ VAR_23);
        for (unsigned VAR_37=0; VAR_37 < VAR_29; ++VAR_24, ++VAR_37) {
            if (VAR_38==get_te32(&VAR_24->p_type)) {
                VAR_27.u_len = get_te32(&VAR_24->p_filesz) - VAR_11;
                break;
            }
        }
        unpackExtent(VAR_27.u_len, VAR_0, VAR_30, VAR_31,
            VAR_32, VAR_33, false, VAR_8);
    }
    else {  /* COMMENT_14 */
        /* COMMENT_15 */
        bool VAR_39 = true;
        VAR_24 = (Elf32_Phdr *) (void *) (1+ VAR_23);  /* COMMENT_16 */
        for (unsigned VAR_37=0; VAR_37 < VAR_29; ++VAR_24, ++VAR_37) {
            if (VAR_38==get_te32(&VAR_24->p_type)) {
                unsigned const VAR_40 = get_te32(&VAR_24->p_filesz);
                unsigned const VAR_41 = get_te32(&VAR_24->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_41, VAR_13);
                if (Elf32_Phdr::PF_X & get_te32(&VAR_24->p_flags)) {
                    unpackExtent(VAR_40, VAR_0, VAR_30, VAR_31,
                        VAR_32, VAR_33, VAR_39, VAR_8);
                    VAR_39 = false;
                }
                else {
                    unpackExtent(VAR_40, VAR_0, VAR_30, VAR_31,
                        VAR_32, VAR_33, false, VAR_8);
                }
            }
        }
    }
    VAR_24 = VAR_35;
    VAR_42 = 0;
    for (unsigned VAR_37=0; VAR_37 < VAR_3; ++VAR_37) {
        if (VAR_38==get_te32(&VAR_24->p_type)) {
            VAR_42 = get_te32(&VAR_24->p_vaddr);
            break;
        }
    }
    if (VAR_34
    ||  ((unsigned)(get_te32(&VAR_4.e_entry) - VAR_42) + up4(VAR_15) +
                VAR_27.getPackHeaderSize() + sizeof(VAR_11))
            < up4(VAR_19)) {
        /* COMMENT_17 */
        funpad4(VAR_10);  /* COMMENT_18 */
        unsigned VAR_43[4]; VAR_10->readx(VAR_43, sizeof(VAR_43));
        if (0==VAR_7) {
            VAR_7 = VAR_43[2 + (0==VAR_43[0])];
        }
        VAR_10->seek(VAR_15 - sizeof(VAR_43), VAR_28);
    }

    /* COMMENT_19 */
    VAR_24 = (Elf32_Phdr *) (VAR_22.buf + sizeof(*VAR_23));
    unsigned VAR_44(0);
    for (unsigned VAR_37 = 0; VAR_37 < VAR_29; ++VAR_37) {
        if (VAR_38==VAR_24[VAR_37].p_type
        &&  VAR_44 < VAR_24[VAR_37].p_offset)
            VAR_44 = VAR_24[VAR_37].p_offset;
    }
    for (unsigned VAR_37 = 0; VAR_37 < VAR_29; ++VAR_37) {
        unsigned const VAR_45 = find_LOAD_gap(VAR_24, VAR_37, VAR_29);
        if (VAR_45) {
            unsigned const VAR_46 = get_te32(&VAR_24[VAR_37].p_offset) +
                                   get_te32(&VAR_24[VAR_37].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_46, VAR_13);
            unpackExtent(VAR_45, VAR_0, VAR_30, VAR_31,
                VAR_32, VAR_33, false, VAR_8,
                (VAR_24[VAR_37].p_offset != VAR_44));
        }
    }

    /* COMMENT_20 */
    VAR_10->readx(&VAR_26, VAR_8);
    unsigned const VAR_47 = VAR_27.u_len = get_te32(&VAR_26.sz_unc);

    if (VAR_47 == 0) { /* COMMENT_21 */
        /* COMMENT_22 */
        unsigned const VAR_48 = get_le32(&VAR_26.sz_cpr);
        if (VAR_48 != VAR_49)  /* COMMENT_23 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_24 */
        throwCompressedDataViolation();
    }

    if (VAR_34) {  /* COMMENT_25 */
        int VAR_36 = 0;
        unsigned VAR_50 = 0;
        VAR_24 = (Elf32_Phdr *) (VAR_22.buf + sizeof(*VAR_23));
        for (unsigned VAR_37= 0; VAR_37 < VAR_29; ++VAR_37, ++VAR_24) {
            if (VAR_38==get_te32(&VAR_24->p_type) && 0!=VAR_36++) {
                VAR_50 = get_te32(&VAR_24->p_offset);
                VAR_10->seek(VAR_5, VAR_13);
                VAR_10->readx(VAR_25, VAR_6);
                VAR_30  += VAR_6;
                VAR_31 += VAR_6;
                if (VAR_0) {
                    VAR_0->seek(get_te32(&VAR_24->p_offset), VAR_13);
                    VAR_0->rewrite(VAR_25, VAR_6);
                }
            }
        }
        /* COMMENT_26 */
        VAR_24 = (Elf32_Phdr *) (VAR_22.buf + sizeof(*VAR_23));
        for (unsigned VAR_37= 0; VAR_37 < VAR_29; ++VAR_37, ++VAR_24) {
            if (VAR_24->PT_DYNAMIC==get_te32(&VAR_24->p_type)) {
                unsigned const VAR_51 = get_te32(&VAR_24->p_offset);
                unsigned const VAR_52 = get_te32(&VAR_24->p_filesz);
                Elf32_Dyn *VAR_53 = (Elf32_Dyn *)((unsigned char *)VAR_25 +
                    (VAR_51 - VAR_50));
                for (unsigned VAR_54= 0; VAR_54 < VAR_52; ++VAR_53, VAR_54 += sizeof(*VAR_53)) {
                    if (VAR_53->DT_INIT==get_te32(&VAR_53->d_tag)) {
                        if (VAR_0) {
                            VAR_0->seek(sizeof(unsigned) + VAR_54 + VAR_51, VAR_13);
                            VAR_0->rewrite(&VAR_7, sizeof(VAR_7));
                            VAR_0->seek(0, VAR_55);
                        }
                        break;
                    }
                }
            }
        }
    }

    /* COMMENT_27 */
    VAR_27.c_len = VAR_30;
    VAR_27.u_len = VAR_31;

    /* COMMENT_28 */
    if (VAR_31 != VAR_17)
        throwEOFException();

    /* COMMENT_29 */
    if (VAR_27.c_adler != VAR_32 || VAR_27.u_adler != VAR_33)
        throwChecksumError();
#undef MAX_ELF_HDR
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 void PackLinuxElf32::unpack(OutputFile *fo)
 {
+    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr
+        throwCantUnpack(""bad e_phoff"");
+    }
     unsigned const c_phnum = get_te16(&ehdri.e_phnum);
     unsigned old_data_off = 0;
     unsigned old_data_len = 0;","{'deleted_lines': [], 'added_lines': ['    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr', '        throwCantUnpack(""bad e_phoff"");', '    }']}",True,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",7.8,HIGH,2,valid,2017-10-03T04:47:40Z,2
CVE-2017-15056,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,upx,"Protect against bad crafted input.

https://github.com/upx/upx/issues/128
	modified:   p_lx_elf.cpp",ef336dbcc6dc8344482f8cf6c909ae96c3286317,https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,src/p_lx_elf.cpp,PackLinuxElf32::PackLinuxElf32help1,"void
PackLinuxElf32::PackLinuxElf32help1(InputFile *f)
{
e_type  = get_te16(&ehdri.e_type);
e_phnum = get_te16(&ehdri.e_phnum);
e_shnum = get_te16(&ehdri.e_shnum);
unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);
if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32
|| sizeof(Elf32_Phdr) != e_phentsize
|| (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]
&& &N_BELE_RTP::be_policy != bele)
|| (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]
&& &N_BELE_RTP::le_policy != bele)) {
e_phoff = 0;
e_shoff = 0;
sz_phdrs = 0;
return;
}
e_phoff = get_te32(&ehdri.e_phoff);
e_shoff = get_te32(&ehdri.e_shoff);
sz_phdrs = e_phnum * e_phentsize;
if (f && Elf32_Ehdr::ET_DYN!=e_type) {
unsigned const len = sz_phdrs + e_phoff;
alloc_file_image(file_image, len);
f->seek(0, SEEK_SET);
f->readx(file_image, len);
phdri= (Elf32_Phdr       *)(e_phoff + file_image);      }
if (f && Elf32_Ehdr::ET_DYN==e_type) {
alloc_file_image(file_image, file_size);
f->seek(0, SEEK_SET);
f->readx(file_image, file_size);
phdri= (Elf32_Phdr       *)(e_phoff + file_image);          shdri= (Elf32_Shdr const *)(e_shoff + file_image);          sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (sec_dynsym)
sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;
Elf32_Phdr const *phdr= phdri;
for (int j = e_phnum; --j>=0; ++phdr)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);
break;
}
dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);
gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
jni_onload_sym = elf_lookup(""JNI_OnLoad"");
if (jni_onload_sym) {
jni_onload_va = get_te32(&jni_onload_sym->st_value);
jni_onload_va = 0;
}
}
}","void
PackLinuxElf32::PackLinuxElf32help1(InputFile *VAR_0)
{
VAR_1  = get_te16(&VAR_2.e_type);
VAR_3 = get_te16(&VAR_2.e_phnum);
VAR_4 = get_te16(&VAR_2.e_shnum);
unsigned const VAR_5 = get_te16(&VAR_2.e_phentsize);
if (VAR_2.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32
|| sizeof(VAR_6) != VAR_5
|| (Elf32_Ehdr::ELFDATA2MSB == VAR_2.e_ident[Elf32_Ehdr::EI_DATA]
&& &N_BELE_RTP::be_policy != VAR_7)
|| (Elf32_Ehdr::ELFDATA2LSB == VAR_2.e_ident[Elf32_Ehdr::EI_DATA]
&& &N_BELE_RTP::le_policy != VAR_7)) {
VAR_8 = 0;
VAR_9 = 0;
VAR_10 = 0;
return;
}
VAR_8 = get_te32(&VAR_2.e_phoff);
VAR_9 = get_te32(&VAR_2.e_shoff);
VAR_10 = VAR_3 * VAR_5;
if (VAR_0 && Elf32_Ehdr::ET_DYN!=VAR_1) {
unsigned const VAR_11 = VAR_10 + VAR_8;
alloc_file_image(VAR_12, VAR_11);
VAR_0->seek(0, VAR_13);
VAR_0->readx(VAR_12, VAR_11);
VAR_14= (Elf32_Phdr       *)(VAR_8 + VAR_12);  
}
if (VAR_0 && Elf32_Ehdr::ET_DYN==VAR_1) {
alloc_file_image(VAR_12, VAR_15);
VAR_0->seek(0, VAR_13);
VAR_0->readx(VAR_12, VAR_15);
VAR_14= (Elf32_Phdr       *)(VAR_8 + VAR_12);  
VAR_16= (Elf32_Shdr const *)(VAR_9 + VAR_12);  
VAR_17 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (VAR_17)
VAR_18 = get_te32(&VAR_17->sh_link) + VAR_16;
Elf32_Phdr const *VAR_19= VAR_14;
for (int VAR_20 = VAR_3; --VAR_20>=0; ++VAR_19)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_19->p_type)) {
VAR_21= (Elf32_Dyn const *)(get_te32(&VAR_19->p_offset) + VAR_12);
break;
}
VAR_22 =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
VAR_23 = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);
VAR_24 = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
VAR_25 = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
VAR_26 = elf_lookup(""JNI_OnLoad"");
if (VAR_26) {
VAR_27 = get_te32(&VAR_26->st_value);
VAR_27 = 0;
}
}
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/before/3.json,"void
PackLinuxElf32::PackLinuxElf32help1(InputFile *f)
{
    e_type  = get_te16(&ehdri.e_type);
    e_phnum = get_te16(&ehdri.e_phnum);
    e_shnum = get_te16(&ehdri.e_shnum);
    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);
    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32
    || sizeof(Elf32_Phdr) != e_phentsize
    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]
            && &N_BELE_RTP::be_policy != bele)
    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]
            && &N_BELE_RTP::le_policy != bele)) {
        e_phoff = 0;
        e_shoff = 0;
        sz_phdrs = 0;
        return;
    }
    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");
    e_phoff = get_te32(&ehdri.e_phoff);
    if ((unsigned long)file_size < ((unsigned long)e_phoff + e_phnum * sizeof(Elf32_Phdr))) {
        throwCantUnpack(""bad e_phoff"");
    }
    e_shoff = get_te32(&ehdri.e_shoff);
    if ((unsigned long)file_size < ((unsigned long)e_shoff + e_shnum * sizeof(Elf32_Shdr))) {
        throwCantUnpack(""bad e_shoff"");
    }
    sz_phdrs = e_phnum * e_phentsize;

    if (f && Elf32_Ehdr::ET_DYN!=e_type) {
        unsigned const len = sz_phdrs + e_phoff;
        alloc_file_image(file_image, len);
        f->seek(0, SEEK_SET);
        f->readx(file_image, len);
        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!
    }
    if (f && Elf32_Ehdr::ET_DYN==e_type) {
        // The DT_SYMTAB has no designated length.  Read the whole file.
        alloc_file_image(file_image, file_size);
        f->seek(0, SEEK_SET);
        f->readx(file_image, file_size);
        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!
        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!
        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
        if (sec_dynsym)
            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;

        Elf32_Phdr const *phdr= phdri;
        for (int j = e_phnum; --j>=0; ++phdr)
        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);
            break;
        }
        // elf_find_dynamic() returns 0 if 0==dynseg.
        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);
        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
        jni_onload_sym = elf_lookup(""JNI_OnLoad"");
        if (jni_onload_sym) {
            jni_onload_va = get_te32(&jni_onload_sym->st_value);
            jni_onload_va = 0;
        }
    }
}","void
PackLinuxElf32::PackLinuxElf32help1(InputFile *VAR_0)
{
    VAR_1  = get_te16(&VAR_2.e_type);
    VAR_3 = get_te16(&VAR_2.e_phnum);
    VAR_4 = get_te16(&VAR_2.e_shnum);
    unsigned const VAR_5 = get_te16(&VAR_2.e_phentsize);
    if (VAR_2.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32
    || sizeof(VAR_6) != VAR_5
    || (Elf32_Ehdr::ELFDATA2MSB == VAR_2.e_ident[Elf32_Ehdr::EI_DATA]
            && &N_BELE_RTP::be_policy != VAR_7)
    || (Elf32_Ehdr::ELFDATA2LSB == VAR_2.e_ident[Elf32_Ehdr::EI_DATA]
            && &N_BELE_RTP::le_policy != VAR_7)) {
        VAR_8 = 0;
        VAR_9 = 0;
        VAR_10 = 0;
        return;
    }
    if (0==VAR_3) throwCantUnpack(""0==e_phnum"");
    VAR_8 = get_te32(&VAR_2.e_phoff);
    if ((unsigned long)VAR_11 < ((unsigned long)VAR_8 + VAR_3 * sizeof(VAR_6))) {
        throwCantUnpack(""bad e_phoff"");
    }
    VAR_9 = get_te32(&VAR_2.e_shoff);
    if ((unsigned long)VAR_11 < ((unsigned long)VAR_9 + VAR_4 * sizeof(VAR_12))) {
        throwCantUnpack(""bad e_shoff"");
    }
    VAR_10 = VAR_3 * VAR_5;

    if (VAR_0 && Elf32_Ehdr::ET_DYN!=VAR_1) {
        unsigned const VAR_13 = VAR_10 + VAR_8;
        alloc_file_image(VAR_14, VAR_13);
        VAR_0->seek(0, VAR_15);
        VAR_0->readx(VAR_14, VAR_13);
        VAR_16= (Elf32_Phdr       *)(VAR_8 + VAR_14);  /* COMMENT_0 */
    }
    if (VAR_0 && Elf32_Ehdr::ET_DYN==VAR_1) {
        /* COMMENT_1 */
        alloc_file_image(VAR_14, VAR_11);
        VAR_0->seek(0, VAR_15);
        VAR_0->readx(VAR_14, VAR_11);
        VAR_16= (Elf32_Phdr       *)(VAR_8 + VAR_14);  /* COMMENT_0 */
        VAR_17= (Elf32_Shdr const *)(VAR_9 + VAR_14);  /* COMMENT_0 */
        VAR_18 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
        if (VAR_18)
            VAR_19 = get_te32(&VAR_18->sh_link) + VAR_17;

        Elf32_Phdr const *VAR_20= VAR_16;
        for (int VAR_21 = VAR_3; --VAR_21>=0; ++VAR_20)
        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_20->p_type)) {
            VAR_22= (Elf32_Dyn const *)(get_te32(&VAR_20->p_offset) + VAR_14);
            break;
        }
        /* COMMENT_2 */
        VAR_23 =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
        VAR_24 = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);
        VAR_25 = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
        VAR_26 = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
        VAR_27 = elf_lookup(""JNI_OnLoad"");
        if (VAR_27) {
            VAR_28 = get_te32(&VAR_27->st_value);
            VAR_28 = 0;
        }
    }
}",upx/ef336dbcc6dc8344482f8cf6c909ae96c3286317/p_lx_elf.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -16,8 +16,15 @@
         sz_phdrs = 0;
         return;
     }
+    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");
     e_phoff = get_te32(&ehdri.e_phoff);
+    if ((unsigned long)file_size < ((unsigned long)e_phoff + e_phnum * sizeof(Elf32_Phdr))) {
+        throwCantUnpack(""bad e_phoff"");
+    }
     e_shoff = get_te32(&ehdri.e_shoff);
+    if ((unsigned long)file_size < ((unsigned long)e_shoff + e_shnum * sizeof(Elf32_Shdr))) {
+        throwCantUnpack(""bad e_shoff"");
+    }
     sz_phdrs = e_phnum * e_phentsize;
 
     if (f && Elf32_Ehdr::ET_DYN!=e_type) {","{'deleted_lines': [], 'added_lines': ['    if (0==e_phnum) throwCantUnpack(""0==e_phnum"");', '    if ((unsigned long)file_size < ((unsigned long)e_phoff + e_phnum * sizeof(Elf32_Phdr))) {', '        throwCantUnpack(""bad e_phoff"");', '    }', '    if ((unsigned long)file_size < ((unsigned long)e_shoff + e_shnum * sizeof(Elf32_Shdr))) {', '        throwCantUnpack(""bad e_shoff"");', '    }']}",True,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",7.8,HIGH,2,valid,2017-10-03T04:47:40Z,2
CVE-2017-15365,['CWE-Other'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,MariaDB/server,"MW-416 DDL replication moved after acl checking

galera_events test shows a regression with the original fix for MW-416
Reason was that Events::drop_event() can be called also from inside event
execution, and there we have a speacial treatment for event, which executes
""DROP EVENT"" statement, and runs TOI replication inside the event processing body.
This resulted in executing WSREP_TO_ISOLATION two times for such DROP EVENT statement.
Fix is to call WSREP_TO_ISOLATION_BEGIN only in Events::drop_event()",0b5a5258abbeaf8a0c3a18c7e753699787fdf46e,https://github.com/MariaDB/server/commit/0b5a5258abbeaf8a0c3a18c7e753699787fdf46e,sql/event_data_objects.cc,Event_job_data::execute,"bool
Event_job_data::execute(THD *thd, bool drop)
{
String sp_sql;
#ifndef NO_EMBEDDED_ACCESS_CHECKS
Security_context event_sctx, *save_sctx= NULL;
#endif
List<Item> empty_item_list;
bool ret= TRUE;
DBUG_ENTER(""Event_job_data::execute"");
thd->reset_for_next_command();
thd->set_db(dbname.str, dbname.length);
lex_start(thd);
#ifndef NO_EMBEDDED_ACCESS_CHECKS
if (event_sctx.change_security_context(thd,
&definer_user, &definer_host,
&dbname, &save_sctx))
{
sql_print_error(""Event Scheduler: ""
""[%s].[%s.%s] execution failed, ""
""failed to authenticate the user."",
definer.str, dbname.str, name.str);
goto end;
}
#endif
if (check_access(thd, EVENT_ACL, dbname.str, NULL, NULL, 0, 0))
{
sql_print_error(""Event Scheduler: ""
""[%s].[%s.%s] execution failed, ""
""user no longer has EVENT privilege."",
definer.str, dbname.str, name.str);
goto end;
}
if (construct_sp_sql(thd, &sp_sql))
goto end;
thd->variables.sql_mode= sql_mode;
thd->variables.time_zone= time_zone;
thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());
{
Parser_state parser_state;
if (parser_state.init(thd, thd->query(), thd->query_length()))
goto end;
if (parse_sql(thd, & parser_state, creation_ctx))
{
sql_print_error(""Event Scheduler: ""
""%serror during compilation of %s.%s"",
thd->is_fatal_error ? ""fatal "" : """",
(const char *) dbname.str, (const char *) name.str);
goto end;
}
}
{
sp_head *sphead= thd->lex->sphead;
DBUG_ASSERT(sphead);
sphead->m_flags|= sp_head::LOG_SLOW_STATEMENTS;
sphead->m_flags|= sp_head::LOG_GENERAL_LOG;
sphead->set_info(0, 0, &thd->lex->sp_chistics, sql_mode);
sphead->set_creation_ctx(creation_ctx);
sphead->optimize();
ret= sphead->execute_procedure(thd, &empty_item_list);
}
end:
if (drop && !thd->is_fatal_error)
{
sql_print_information(""Event Scheduler: Dropping %s.%s"",
(const char *) dbname.str, (const char *) name.str);
if (construct_drop_event_sql(thd, &sp_sql))
ret= 1;
else
{
ulong saved_master_access;
thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());
saved_master_access= thd->security_ctx->master_access;
thd->security_ctx->master_access |= SUPER_ACL;
bool save_tx_read_only= thd->tx_read_only;
thd->tx_read_only= false;
if (WSREP(thd))
{
thd->lex->sql_command = SQLCOM_DROP_EVENT;
WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);
}
ret= Events::drop_event(thd, dbname, name, FALSE);
WSREP_TO_ISOLATION_END;
#ifdef WITH_WSREP
error:
#endif
thd->tx_read_only= save_tx_read_only;
thd->security_ctx->master_access= saved_master_access;
}
}
#ifndef NO_EMBEDDED_ACCESS_CHECKS
if (save_sctx)
event_sctx.restore_security_context(thd, save_sctx);
#endif
thd->lex->unit.cleanup();
thd->end_statement();
thd->cleanup_after_query();
thd->reset_query();
DBUG_PRINT(""info"", (""EXECUTED %s.%s  ret: %d"", dbname.str, name.str, ret));
DBUG_RETURN(ret);
}","bool
Event_job_data::execute(THD *VAR_0, bool VAR_1)
{
String VAR_2;
#ifndef VAR_3
Security_context VAR_4, *VAR_5= NULL;
#endif
List<Item> VAR_6;
bool VAR_7= TRUE;
DBUG_ENTER(""Event_job_data::execute"");
VAR_0->reset_for_next_command();
VAR_0->set_db(VAR_8.str, VAR_8.length);
lex_start(VAR_0);
#ifndef VAR_3
if (VAR_4.change_security_context(VAR_0,
&VAR_9, &VAR_10,
&VAR_8, &VAR_5))
{
sql_print_error(""Event Scheduler: ""
""[%s].[%s.%s] execution failed, ""
""failed to authenticate the user."",
VAR_11.str, VAR_8.str, VAR_12.str);
goto end;
}
#endif
if (check_access(VAR_0, VAR_13, VAR_8.str, NULL, NULL, 0, 0))
{
sql_print_error(""Event Scheduler: ""
""[%s].[%s.%s] execution failed, ""
""user no longer has EVENT privilege."",
VAR_11.str, VAR_8.str, VAR_12.str);
goto end;
}
if (construct_sp_sql(VAR_0, &VAR_2))
goto end;
VAR_0->variables.sql_mode= VAR_14;
VAR_0->variables.time_zone= VAR_15;
VAR_0->set_query(VAR_2.c_ptr_safe(), VAR_2.length());
{
Parser_state VAR_16;
if (VAR_16.init(VAR_0, VAR_0->query(), VAR_0->query_length()))
goto end;
if (parse_sql(VAR_0, & VAR_16, VAR_17))
{
sql_print_error(""Event Scheduler: ""
""%serror during compilation of %s.%s"",
VAR_0->is_fatal_error ? ""fatal "" : """",
(const char *) VAR_8.str, (const char *) VAR_12.str);
goto end;
}
}
{
sp_head *VAR_18= VAR_0->lex->sphead;
DBUG_ASSERT(VAR_18);
VAR_18->m_flags|= sp_head::LOG_SLOW_STATEMENTS;
VAR_18->m_flags|= sp_head::LOG_GENERAL_LOG;
VAR_18->set_info(0, 0, &VAR_0->lex->sp_chistics, VAR_14);
VAR_18->set_creation_ctx(VAR_17);
VAR_18->optimize();
VAR_7= VAR_18->execute_procedure(VAR_0, &VAR_6);
}
end:
if (VAR_1 && !VAR_0->is_fatal_error)
{
sql_print_information(""Event Scheduler: Dropping %s.%s"",
(const char *) VAR_8.str, (const char *) VAR_12.str);
if (construct_drop_event_sql(VAR_0, &VAR_2))
VAR_7= 1;
else
{
ulong VAR_19;
VAR_0->set_query(VAR_2.c_ptr_safe(), VAR_2.length());
VAR_19= VAR_0->security_ctx->master_access;
VAR_0->security_ctx->master_access |= VAR_20;
bool VAR_21= VAR_0->tx_read_only;
VAR_0->tx_read_only= false;
if (WSREP(VAR_0))
{
VAR_0->lex->sql_command = VAR_22;
WSREP_TO_ISOLATION_BEGIN(VAR_23, NULL, NULL);
}
VAR_7= Events::drop_event(VAR_0, VAR_8, VAR_12, FALSE);
VAR_24;
#ifdef VAR_25
error:
#endif
VAR_0->tx_read_only= VAR_21;
VAR_0->security_ctx->master_access= VAR_19;
}
}
#ifndef VAR_3
if (VAR_5)
VAR_4.restore_security_context(VAR_0, VAR_5);
#endif
VAR_0->lex->unit.cleanup();
VAR_0->end_statement();
VAR_0->cleanup_after_query();
VAR_0->reset_query();
DBUG_PRINT(""info"", (""EXECUTED %s.%s  ret: %d"", VAR_8.str, VAR_12.str, VAR_7));
DBUG_RETURN(VAR_7);
}",MariaDB/server/0b5a5258abbeaf8a0c3a18c7e753699787fdf46e/event_data_objects.cc/vul/before/0.json,"bool
Event_job_data::execute(THD *thd, bool drop)
{
  String sp_sql;
#ifndef NO_EMBEDDED_ACCESS_CHECKS
  Security_context event_sctx, *save_sctx= NULL;
#endif
  List<Item> empty_item_list;
  bool ret= TRUE;

  DBUG_ENTER(""Event_job_data::execute"");

  thd->reset_for_next_command();

  /*
    MySQL parser currently assumes that current database is either
    present in THD or all names in all statements are fully specified.
    And yet not fully specified names inside stored programs must be 
    be supported, even if the current database is not set:
    CREATE PROCEDURE db1.p1() BEGIN CREATE TABLE t1; END//
    -- in this example t1 should be always created in db1 and the statement
    must parse even if there is no current database.

    To support this feature and still address the parser limitation,
    we need to set the current database here.
    We don't have to call mysql_change_db, since the checks performed
    in it are unnecessary for the purpose of parsing, and
    mysql_change_db will be invoked anyway later, to activate the
    procedure database before it's executed.
  */
  thd->set_db(dbname.str, dbname.length);

  lex_start(thd);

#ifndef NO_EMBEDDED_ACCESS_CHECKS
  if (event_sctx.change_security_context(thd,
                                         &definer_user, &definer_host,
                                         &dbname, &save_sctx))
  {
    sql_print_error(""Event Scheduler: ""
                    ""[%s].[%s.%s] execution failed, ""
                    ""failed to authenticate the user."",
                    definer.str, dbname.str, name.str);
    goto end;
  }
#endif

  if (check_access(thd, EVENT_ACL, dbname.str, NULL, NULL, 0, 0))
  {
    /*
      This aspect of behavior is defined in the worklog,
      and this is how triggers work too: if TRIGGER
      privilege is revoked from trigger definer,
      triggers are not executed.
    */
    sql_print_error(""Event Scheduler: ""
                    ""[%s].[%s.%s] execution failed, ""
                    ""user no longer has EVENT privilege."",
                    definer.str, dbname.str, name.str);
    goto end;
  }

  if (construct_sp_sql(thd, &sp_sql))
    goto end;

  /*
    Set up global thread attributes to reflect the properties of
    this Event. We can simply reset these instead of usual
    backup/restore employed in stored programs since we know that
    this is a top level statement and the worker thread is
    allocated exclusively to execute this event.
  */

  thd->variables.sql_mode= sql_mode;
  thd->variables.time_zone= time_zone;

  thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());

  {
    Parser_state parser_state;
    if (parser_state.init(thd, thd->query(), thd->query_length()))
      goto end;

    if (parse_sql(thd, & parser_state, creation_ctx))
    {
      sql_print_error(""Event Scheduler: ""
                      ""%serror during compilation of %s.%s"",
                      thd->is_fatal_error ? ""fatal "" : """",
                      (const char *) dbname.str, (const char *) name.str);
      goto end;
    }
  }

  {
    sp_head *sphead= thd->lex->sphead;

    DBUG_ASSERT(sphead);

    sphead->m_flags|= sp_head::LOG_SLOW_STATEMENTS;
    sphead->m_flags|= sp_head::LOG_GENERAL_LOG;

    sphead->set_info(0, 0, &thd->lex->sp_chistics, sql_mode);
    sphead->set_creation_ctx(creation_ctx);
    sphead->optimize();

    ret= sphead->execute_procedure(thd, &empty_item_list);
    /*
      There is no pre-locking and therefore there should be no
      tables open and locked left after execute_procedure.
    */
  }

end:
  if (drop && !thd->is_fatal_error)
  {
    /*
      We must do it here since here we're under the right authentication
      ID of the event definer.
    */
    sql_print_information(""Event Scheduler: Dropping %s.%s"",
                          (const char *) dbname.str, (const char *) name.str);
    /*
      Construct a query for the binary log, to ensure the event is dropped
      on the slave
    */
    if (construct_drop_event_sql(thd, &sp_sql))
      ret= 1;
    else
    {
      ulong saved_master_access;

      thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());

      /*
        NOTE: even if we run in read-only mode, we should be able to lock
        the mysql.event table for writing. In order to achieve this, we
        should call mysql_lock_tables() under the super-user.

        Same goes for transaction access mode.
        Temporarily reset it to read-write.
      */

      saved_master_access= thd->security_ctx->master_access;
      thd->security_ctx->master_access |= SUPER_ACL;
      bool save_tx_read_only= thd->tx_read_only;
      thd->tx_read_only= false;

      /*
         This code is processing event execution and does not have client
         connection. Here, event execution will now execute a prepared
         DROP EVENT statement, but thd->lex->sql_command is set to
         SQLCOM_CREATE_PROCEDURE
         DROP EVENT will be logged in binlog, and we have to
         replicate it to make all nodes have consistent event definitions
         Wsrep DDL replication is triggered inside Events::drop_event(),
         and here we need to prepare the THD so that DDL replication is
         possible, essentially it requires setting sql_command to
         SQLCOMM_DROP_EVENT, we will switch sql_command for the duration
         of DDL replication only.
      */
      const enum_sql_command sql_command_save= thd->lex->sql_command;
      const bool sql_command_set= WSREP(thd);

      if (sql_command_set)
        thd->lex->sql_command = SQLCOM_DROP_EVENT;

      ret= Events::drop_event(thd, dbname, name, FALSE);

      if (sql_command_set)
      {
        WSREP_TO_ISOLATION_END;
        thd->lex->sql_command = sql_command_save;
      }

      thd->tx_read_only= save_tx_read_only;
      thd->security_ctx->master_access= saved_master_access;
    }
  }
#ifndef NO_EMBEDDED_ACCESS_CHECKS
  if (save_sctx)
    event_sctx.restore_security_context(thd, save_sctx);
#endif
  thd->lex->unit.cleanup();
  thd->end_statement();
  thd->cleanup_after_query();
  /* Avoid races with SHOW PROCESSLIST */
  thd->reset_query();

  DBUG_PRINT(""info"", (""EXECUTED %s.%s  ret: %d"", dbname.str, name.str, ret));

  DBUG_RETURN(ret);
}","bool
Event_job_data::execute(THD *VAR_0, bool VAR_1)
{
  String VAR_2;
#ifndef VAR_3
  Security_context VAR_4, *VAR_5= NULL;
#endif
  List<Item> VAR_6;
  bool VAR_7= TRUE;

  DBUG_ENTER(""Event_job_data::execute"");

  VAR_0->reset_for_next_command();

  /* COMMENT_0 */
                                                                  
                                                                      
                                                                     
                                                          
                                                          
                                                                           
                                                    

                                                                    
                                             
                                                                     
                                                         
                                                                 
                                            
    
  VAR_0->set_db(VAR_8.str, VAR_8.length);

  lex_start(VAR_0);

#ifndef VAR_3
  if (VAR_4.change_security_context(VAR_0,
                                         &VAR_9, &VAR_10,
                                         &VAR_8, &VAR_5))
  {
    sql_print_error(""Event Scheduler: ""
                    ""[%s].[%s.%s] execution failed, ""
                    ""failed to authenticate the user."",
                    VAR_11.str, VAR_8.str, VAR_12.str);
    goto end;
  }
#endif

  if (check_access(VAR_0, VAR_13, VAR_8.str, NULL, NULL, 0, 0))
  {
    /* COMMENT_16 */
                                                        
                                                   
                                                
                                
      
    sql_print_error(""Event Scheduler: ""
                    ""[%s].[%s.%s] execution failed, ""
                    ""user no longer has EVENT privilege."",
                    VAR_11.str, VAR_8.str, VAR_12.str);
    goto end;
  }

  if (construct_sp_sql(VAR_0, &VAR_2))
    goto end;

  /* COMMENT_22 */
                                                                
                                                          
                                                                 
                                                          
                                                
    

  VAR_0->variables.sql_mode= VAR_14;
  VAR_0->variables.time_zone= VAR_15;

  VAR_0->set_query(VAR_2.c_ptr_safe(), VAR_2.length());

  {
    Parser_state VAR_16;
    if (VAR_16.init(VAR_0, VAR_0->query(), VAR_0->query_length()))
      goto end;

    if (parse_sql(VAR_0, & VAR_16, VAR_17))
    {
      sql_print_error(""Event Scheduler: ""
                      ""%serror during compilation of %s.%s"",
                      VAR_0->is_fatal_error ? ""fatal "" : """",
                      (const char *) VAR_8.str, (const char *) VAR_12.str);
      goto end;
    }
  }

  {
    sp_head *VAR_18= VAR_0->lex->sphead;

    DBUG_ASSERT(VAR_18);

    VAR_18->m_flags|= sp_head::LOG_SLOW_STATEMENTS;
    VAR_18->m_flags|= sp_head::LOG_GENERAL_LOG;

    VAR_18->set_info(0, 0, &VAR_0->lex->sp_chistics, VAR_14);
    VAR_18->set_creation_ctx(VAR_17);
    VAR_18->optimize();

    VAR_7= VAR_18->execute_procedure(VAR_0, &VAR_6);
    /* COMMENT_29 */
                                                              
                                                          
      
  }

end:
  if (VAR_1 && !VAR_0->is_fatal_error)
  {
    /* COMMENT_33 */
                                                                        
                              
      
    sql_print_information(""Event Scheduler: Dropping %s.%s"",
                          (const char *) VAR_8.str, (const char *) VAR_12.str);
    /* COMMENT_37 */
                                                                          
                  
      
    if (construct_drop_event_sql(VAR_0, &VAR_2))
      VAR_7= 1;
    else
    {
      ulong VAR_19;

      VAR_0->set_query(VAR_2.c_ptr_safe(), VAR_2.length());

      /* COMMENT_41 */
                                                                         
                                                                       
                                                             

                                              
                                           
        

      VAR_19= VAR_0->security_ctx->master_access;
      VAR_0->security_ctx->master_access |= VAR_20;
      bool VAR_21= VAR_0->tx_read_only;
      VAR_0->tx_read_only= false;

      /* COMMENT_49 */
                                                                         
                                                                      
                                                                  
                                
                                                            
                                                                         
                                                                        
                                                                       
                                                                 
                                                                        
                                 
        
      const enum_sql_command VAR_22= VAR_0->lex->sql_command;
      const bool VAR_23= WSREP(VAR_0);

      if (VAR_23)
        VAR_0->lex->sql_command = VAR_24;

      VAR_7= Events::drop_event(VAR_0, VAR_8, VAR_12, FALSE);

      if (VAR_23)
      {
        VAR_25;
        VAR_0->lex->sql_command = VAR_22;
      }

      VAR_0->tx_read_only= VAR_21;
      VAR_0->security_ctx->master_access= VAR_19;
    }
  }
#ifndef VAR_3
  if (VAR_5)
    VAR_4.restore_security_context(VAR_0, VAR_5);
#endif
  VAR_0->lex->unit.cleanup();
  VAR_0->end_statement();
  VAR_0->cleanup_after_query();
  /* COMMENT_62 */
  VAR_0->reset_query();

  DBUG_PRINT(""info"", (""EXECUTED %s.%s  ret: %d"", VAR_8.str, VAR_12.str, VAR_7));

  DBUG_RETURN(VAR_7);
}",MariaDB/server/0b5a5258abbeaf8a0c3a18c7e753699787fdf46e/event_data_objects.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -145,19 +145,33 @@
       bool save_tx_read_only= thd->tx_read_only;
       thd->tx_read_only= false;
 
-      if (WSREP(thd))
-      {
+      /*
+         This code is processing event execution and does not have client
+         connection. Here, event execution will now execute a prepared
+         DROP EVENT statement, but thd->lex->sql_command is set to
+         SQLCOM_CREATE_PROCEDURE
+         DROP EVENT will be logged in binlog, and we have to
+         replicate it to make all nodes have consistent event definitions
+         Wsrep DDL replication is triggered inside Events::drop_event(),
+         and here we need to prepare the THD so that DDL replication is
+         possible, essentially it requires setting sql_command to
+         SQLCOMM_DROP_EVENT, we will switch sql_command for the duration
+         of DDL replication only.
+      */
+      const enum_sql_command sql_command_save= thd->lex->sql_command;
+      const bool sql_command_set= WSREP(thd);
+
+      if (sql_command_set)
         thd->lex->sql_command = SQLCOM_DROP_EVENT;
-        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);
-      }
 
       ret= Events::drop_event(thd, dbname, name, FALSE);
 
-      WSREP_TO_ISOLATION_END;
+      if (sql_command_set)
+      {
+        WSREP_TO_ISOLATION_END;
+        thd->lex->sql_command = sql_command_save;
+      }
 
-#ifdef WITH_WSREP
-  error:
-#endif
       thd->tx_read_only= save_tx_read_only;
       thd->security_ctx->master_access= saved_master_access;
     }","{'deleted_lines': ['      if (WSREP(thd))', '      {', '        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);', '      }', '      WSREP_TO_ISOLATION_END;', '#ifdef WITH_WSREP', '  error:', '#endif'], 'added_lines': ['      /*', '         This code is processing event execution and does not have client', '         connection. Here, event execution will now execute a prepared', '         DROP EVENT statement, but thd->lex->sql_command is set to', '         SQLCOM_CREATE_PROCEDURE', '         DROP EVENT will be logged in binlog, and we have to', '         replicate it to make all nodes have consistent event definitions', '         Wsrep DDL replication is triggered inside Events::drop_event(),', '         and here we need to prepare the THD so that DDL replication is', '         possible, essentially it requires setting sql_command to', '         SQLCOMM_DROP_EVENT, we will switch sql_command for the duration', '         of DDL replication only.', '      */', '      const enum_sql_command sql_command_save= thd->lex->sql_command;', '      const bool sql_command_set= WSREP(thd);', '', '      if (sql_command_set)', '      if (sql_command_set)', '      {', '        WSREP_TO_ISOLATION_END;', '        thd->lex->sql_command = sql_command_save;', '      }']}",True,sql/event_data_objects.cc in MariaDB before 10.1.30 and 10.2.x before 10.2.10 and Percona XtraDB Cluster before 5.6.37-26.21-3 and 5.7.x before 5.7.19-29.22-3 allows remote authenticated users with SQL access to bypass intended access restrictions and replicate data definition language (DDL) statements to cluster nodes by leveraging incorrect ordering of DDL replication and ACL checking.,8.8,HIGH,2,valid,2017-10-06T06:49:42Z,2
CVE-2017-15672,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/ffv1dec: Fix out of array read in slice counting

Fixes: test-201710.mp4

Found-by:  <lianyihan@360.cn> and Zhibin Hu
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit c20f4fcb74da2d0432c7b54499bb98f48236b904)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",d893253fcd93d11258e98857175e93be7d158708,https://github.com/FFmpeg/FFmpeg/commit/d893253fcd93d11258e98857175e93be7d158708,libavcodec/ffv1dec.c,read_header,"static int read_header(FFV1Context *f)
{
uint8_t state[CONTEXT_SIZE];
int i, j, context_count = -1;     RangeCoder *const c = &f->slice_context[0]->c;
memset(state, 128, sizeof(state));
if (f->version < 2) {
int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
unsigned v= get_symbol(c, state, 0);
if (v >= 2) {
av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
return AVERROR_INVALIDDATA;
}
f->version = v;
f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
if (f->ac > 1) {
for (i = 1; i < 256; i++)
f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
}
colorspace          = get_symbol(c, state, 0);         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
chroma_planes       = get_rac(c, state);
chroma_h_shift      = get_symbol(c, state, 0);
chroma_v_shift      = get_symbol(c, state, 0);
transparency        = get_rac(c, state);
if (f->plane_count) {
if (colorspace          != f->colorspace                 ||
bits_per_raw_sample != f->avctx->bits_per_raw_sample ||
chroma_planes       != f->chroma_planes              ||
chroma_h_shift      != f->chroma_h_shift             ||
chroma_v_shift      != f->chroma_v_shift             ||
transparency        != f->transparency) {
av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
return AVERROR_INVALIDDATA;
}
}
if (chroma_h_shift > 4U || chroma_v_shift > 4U) {
av_log(f->avctx, AV_LOG_ERROR, ""chroma shift parameters %d %d are invalid\n"",
chroma_h_shift, chroma_v_shift);
return AVERROR_INVALIDDATA;
}
f->colorspace                 = colorspace;
f->avctx->bits_per_raw_sample = bits_per_raw_sample;
f->chroma_planes              = chroma_planes;
f->chroma_h_shift             = chroma_h_shift;
f->chroma_v_shift             = chroma_v_shift;
f->transparency               = transparency;
f->plane_count    = 2 + f->transparency;
}
if (f->colorspace == 0) {
if (f->avctx->skip_alpha) f->transparency = 0;
if (!f->transparency && !f->chroma_planes) {
if (f->avctx->bits_per_raw_sample <= 8)
f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
else
f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
}
} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
switch(16*f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;
}
}
} else if (f->colorspace == 1) {
if (f->chroma_h_shift || f->chroma_v_shift) {
av_log(f->avctx, AV_LOG_ERROR,
""chroma subsampling not supported in this colorspace\n"");
return AVERROR(ENOSYS);
}
if (     f->avctx->bits_per_raw_sample ==  9)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
else if (f->avctx->bits_per_raw_sample == 10)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
else if (f->avctx->bits_per_raw_sample == 12)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
else if (f->avctx->bits_per_raw_sample == 14)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
else
if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
} else {
av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
return AVERROR(ENOSYS);
}
if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {
av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
return AVERROR(ENOSYS);
}
av_dlog(f->avctx, ""%d %d %d\n"",
f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
if (f->version < 2) {
context_count = read_quant_tables(c, f->quant_table);
if (context_count < 0) {
av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
return AVERROR_INVALIDDATA;
}
f->slice_count = f->max_slice_count;
} else if (f->version < 3) {
f->slice_count = get_symbol(c, state, 0);
} else {
const uint8_t *p = c->bytestream_end;
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) {
int trailer = 3 + 5*!!f->ec;
int size = AV_RB24(p-trailer);
if (size + trailer > p - c->bytestream_start)
break;
p -= size + trailer;
}
}
if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {
av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid (max=%d)\n"", f->slice_count, f->max_slice_count);
return AVERROR_INVALIDDATA;
}
for (j = 0; j < f->slice_count; j++) {
FFV1Context *fs = f->slice_context[j];
fs->ac            = f->ac;
fs->packed_at_lsb = f->packed_at_lsb;
fs->slice_damaged = 0;
if (f->version == 2) {
fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
fs->slice_x     /= f->num_h_slices;
fs->slice_y     /= f->num_v_slices;
fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
if ((unsigned)fs->slice_width  > f->width ||
(unsigned)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
}
for (i = 0; i < f->plane_count; i++) {
PlaneContext *const p = &fs->plane[i];
if (f->version == 2) {
int idx = get_symbol(c, state, 0);
if (idx > (unsigned)f->quant_table_count) {
av_log(f->avctx, AV_LOG_ERROR,
""quant_table_index out of range\n"");
return AVERROR_INVALIDDATA;
}
p->quant_table_index = idx;
memcpy(p->quant_table, f->quant_tables[idx],
sizeof(p->quant_table));
context_count = f->context_count[idx];
} else {
memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
}
if (f->version <= 2) {
av_assert0(context_count >= 0);
if (p->context_count < context_count) {
av_freep(&p->state);
av_freep(&p->vlc_state);
}
p->context_count = context_count;
}
}
}
return 0;
}","static int read_header(FFV1Context *VAR_0)
{
uint8_t VAR_1[VAR_2];
int VAR_3, VAR_4, VAR_5 = -1; 
RangeCoder *const VAR_6 = &VAR_0->slice_context[0]->c;
memset(VAR_1, 128, sizeof(VAR_1));
if (VAR_0->version < 2) {
int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
unsigned VAR_13= get_symbol(VAR_6, VAR_1, 0);
if (VAR_13 >= 2) {
av_log(VAR_0->avctx, VAR_14, ""invalid version %d in ver01 header\n"", VAR_13);
return VAR_15;
}
VAR_0->version = VAR_13;
VAR_0->ac      = VAR_0->avctx->coder_type = get_symbol(VAR_6, VAR_1, 0);
if (VAR_0->ac > 1) {
for (VAR_3 = 1; VAR_3 < 256; VAR_3++)
VAR_0->state_transition[VAR_3] = get_symbol(VAR_6, VAR_1, 1) + VAR_6->one_state[VAR_3];
}
VAR_11          = get_symbol(VAR_6, VAR_1, 0); 
VAR_12 = VAR_0->version > 0 ? get_symbol(VAR_6, VAR_1, 0) : VAR_0->avctx->bits_per_raw_sample;
VAR_7       = get_rac(VAR_6, VAR_1);
VAR_8      = get_symbol(VAR_6, VAR_1, 0);
VAR_9      = get_symbol(VAR_6, VAR_1, 0);
VAR_10        = get_rac(VAR_6, VAR_1);
if (VAR_0->plane_count) {
if (VAR_11          != VAR_0->colorspace                 ||
VAR_12 != VAR_0->avctx->bits_per_raw_sample ||
VAR_7       != VAR_0->chroma_planes              ||
VAR_8      != VAR_0->chroma_h_shift             ||
VAR_9      != VAR_0->chroma_v_shift             ||
VAR_10        != VAR_0->transparency) {
av_log(VAR_0->avctx, VAR_14, ""Invalid change of global parameters\n"");
return VAR_15;
}
}
if (VAR_8 > 4U || VAR_9 > 4U) {
av_log(VAR_0->avctx, VAR_14, ""chroma shift parameters %d %d are invalid\n"",
VAR_8, VAR_9);
return VAR_15;
}
VAR_0->colorspace                 = VAR_11;
VAR_0->avctx->bits_per_raw_sample = VAR_12;
VAR_0->chroma_planes              = VAR_7;
VAR_0->chroma_h_shift             = VAR_8;
VAR_0->chroma_v_shift             = VAR_9;
VAR_0->transparency               = VAR_10;
VAR_0->plane_count    = 2 + VAR_0->transparency;
}
if (VAR_0->colorspace == 0) {
if (VAR_0->avctx->skip_alpha) VAR_0->transparency = 0;
if (!VAR_0->transparency && !VAR_0->chroma_planes) {
if (VAR_0->avctx->bits_per_raw_sample <= 8)
VAR_0->avctx->pix_fmt = VAR_16;
else
VAR_0->avctx->pix_fmt = VAR_17;
} else if (VAR_0->avctx->bits_per_raw_sample<=8 && !VAR_0->transparency) {
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_18; break;
case 0x01: VAR_0->avctx->pix_fmt = VAR_19; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_20; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_21; break;
case 0x20: VAR_0->avctx->pix_fmt = VAR_22; break;
case 0x22: VAR_0->avctx->pix_fmt = VAR_23; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample <= 8 && VAR_0->transparency) {
switch(16*VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_24; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_25; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_26; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 9 && !VAR_0->transparency) {
VAR_0->packed_at_lsb = 1;
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_27; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_28; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_29; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 9 && VAR_0->transparency) {
VAR_0->packed_at_lsb = 1;
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_30; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_31; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_32; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 10 && !VAR_0->transparency) {
VAR_0->packed_at_lsb = 1;
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_33; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_34; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_35; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 10 && VAR_0->transparency) {
VAR_0->packed_at_lsb = 1;
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_36; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_37; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_38; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 16 && !VAR_0->transparency){
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_39; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_40; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_41; break;
}
} else if (VAR_0->avctx->bits_per_raw_sample == 16 && VAR_0->transparency){
switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
case 0x00: VAR_0->avctx->pix_fmt = VAR_42; break;
case 0x10: VAR_0->avctx->pix_fmt = VAR_43; break;
case 0x11: VAR_0->avctx->pix_fmt = VAR_44; break;
}
}
} else if (VAR_0->colorspace == 1) {
if (VAR_0->chroma_h_shift || VAR_0->chroma_v_shift) {
av_log(VAR_0->avctx, VAR_14,
""chroma subsampling not supported in this colorspace\n"");
return AVERROR(VAR_45);
}
if (     VAR_0->avctx->bits_per_raw_sample ==  9)
VAR_0->avctx->pix_fmt = VAR_46;
else if (VAR_0->avctx->bits_per_raw_sample == 10)
VAR_0->avctx->pix_fmt = VAR_47;
else if (VAR_0->avctx->bits_per_raw_sample == 12)
VAR_0->avctx->pix_fmt = VAR_48;
else if (VAR_0->avctx->bits_per_raw_sample == 14)
VAR_0->avctx->pix_fmt = VAR_49;
else
if (VAR_0->transparency) VAR_0->avctx->pix_fmt = VAR_50;
else                 VAR_0->avctx->pix_fmt = VAR_51;
} else {
av_log(VAR_0->avctx, VAR_14, ""colorspace not supported\n"");
return AVERROR(VAR_45);
}
if (VAR_0->avctx->pix_fmt == VAR_52) {
av_log(VAR_0->avctx, VAR_14, ""format not supported\n"");
return AVERROR(VAR_45);
}
av_dlog(VAR_0->avctx, ""%d %d %d\n"",
VAR_0->chroma_h_shift, VAR_0->chroma_v_shift, VAR_0->avctx->pix_fmt);
if (VAR_0->version < 2) {
VAR_5 = read_quant_tables(VAR_6, VAR_0->quant_table);
if (VAR_5 < 0) {
av_log(VAR_0->avctx, VAR_14, ""read_quant_table error\n"");
return VAR_15;
}
VAR_0->slice_count = VAR_0->max_slice_count;
} else if (VAR_0->version < 3) {
VAR_0->slice_count = get_symbol(VAR_6, VAR_1, 0);
} else {
const uint8_t *VAR_53 = VAR_6->bytestream_end;
for (VAR_0->slice_count = 0;
VAR_0->slice_count < VAR_54 && 3 < VAR_53 - VAR_6->bytestream_start;
VAR_0->slice_count++) {
int VAR_55 = 3 + 5*!!VAR_0->ec;
int VAR_56 = AV_RB24(VAR_53-VAR_55);
if (VAR_56 + VAR_55 > VAR_53 - VAR_6->bytestream_start)
break;
VAR_53 -= VAR_56 + VAR_55;
}
}
if (VAR_0->slice_count > (unsigned)VAR_54 || VAR_0->slice_count <= 0 || VAR_0->slice_count > VAR_0->max_slice_count) {
av_log(VAR_0->avctx, VAR_14, ""slice count %d is invalid (max=%d)\n"", VAR_0->slice_count, VAR_0->max_slice_count);
return VAR_15;
}
for (VAR_4 = 0; VAR_4 < VAR_0->slice_count; VAR_4++) {
FFV1Context *VAR_57 = VAR_0->slice_context[VAR_4];
VAR_57->ac            = VAR_0->ac;
VAR_57->packed_at_lsb = VAR_0->packed_at_lsb;
VAR_57->slice_damaged = 0;
if (VAR_0->version == 2) {
VAR_57->slice_x      =  get_symbol(VAR_6, VAR_1, 0)      * VAR_0->width ;
VAR_57->slice_y      =  get_symbol(VAR_6, VAR_1, 0)      * VAR_0->height;
VAR_57->slice_width  = (get_symbol(VAR_6, VAR_1, 0) + 1) * VAR_0->width  + VAR_57->slice_x;
VAR_57->slice_height = (get_symbol(VAR_6, VAR_1, 0) + 1) * VAR_0->height + VAR_57->slice_y;
VAR_57->slice_x     /= VAR_0->num_h_slices;
VAR_57->slice_y     /= VAR_0->num_v_slices;
VAR_57->slice_width  = VAR_57->slice_width  / VAR_0->num_h_slices - VAR_57->slice_x;
VAR_57->slice_height = VAR_57->slice_height / VAR_0->num_v_slices - VAR_57->slice_y;
if ((unsigned)VAR_57->slice_width  > VAR_0->width ||
(unsigned)VAR_57->slice_height > VAR_0->height)
return VAR_15;
if (   (unsigned)VAR_57->slice_x + (uint64_t)VAR_57->slice_width  > VAR_0->width
|| (unsigned)VAR_57->slice_y + (uint64_t)VAR_57->slice_height > VAR_0->height)
return VAR_15;
}
for (VAR_3 = 0; VAR_3 < VAR_0->plane_count; VAR_3++) {
PlaneContext *const VAR_53 = &VAR_57->plane[VAR_3];
if (VAR_0->version == 2) {
int VAR_58 = get_symbol(VAR_6, VAR_1, 0);
if (VAR_58 > (unsigned)VAR_0->quant_table_count) {
av_log(VAR_0->avctx, VAR_14,
""quant_table_index out of range\n"");
return VAR_15;
}
VAR_53->quant_table_index = VAR_58;
memcpy(VAR_53->quant_table, VAR_0->quant_tables[VAR_58],
sizeof(VAR_53->quant_table));
VAR_5 = VAR_0->context_count[VAR_58];
} else {
memcpy(VAR_53->quant_table, VAR_0->quant_table, sizeof(VAR_53->quant_table));
}
if (VAR_0->version <= 2) {
av_assert0(VAR_5 >= 0);
if (VAR_53->context_count < VAR_5) {
av_freep(&VAR_53->state);
av_freep(&VAR_53->vlc_state);
}
VAR_53->context_count = VAR_5;
}
}
}
return 0;
}",ffmpeg/d893253fcd93d11258e98857175e93be7d158708/ffv1dec.c/vul/before/0.json,"static int read_header(FFV1Context *f)
{
    uint8_t state[CONTEXT_SIZE];
    int i, j, context_count = -1; //-1 to avoid warning
    RangeCoder *const c = &f->slice_context[0]->c;

    memset(state, 128, sizeof(state));

    if (f->version < 2) {
        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
        unsigned v= get_symbol(c, state, 0);
        if (v >= 2) {
            av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
            return AVERROR_INVALIDDATA;
        }
        f->version = v;
        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
        if (f->ac > 1) {
            for (i = 1; i < 256; i++)
                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
        }

        colorspace          = get_symbol(c, state, 0); //YUV cs type
        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
        chroma_planes       = get_rac(c, state);
        chroma_h_shift      = get_symbol(c, state, 0);
        chroma_v_shift      = get_symbol(c, state, 0);
        transparency        = get_rac(c, state);

        if (f->plane_count) {
            if (colorspace          != f->colorspace                 ||
                bits_per_raw_sample != f->avctx->bits_per_raw_sample ||
                chroma_planes       != f->chroma_planes              ||
                chroma_h_shift      != f->chroma_h_shift             ||
                chroma_v_shift      != f->chroma_v_shift             ||
                transparency        != f->transparency) {
                av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
                return AVERROR_INVALIDDATA;
            }
        }

        if (chroma_h_shift > 4U || chroma_v_shift > 4U) {
            av_log(f->avctx, AV_LOG_ERROR, ""chroma shift parameters %d %d are invalid\n"",
                   chroma_h_shift, chroma_v_shift);
            return AVERROR_INVALIDDATA;
        }

        f->colorspace                 = colorspace;
        f->avctx->bits_per_raw_sample = bits_per_raw_sample;
        f->chroma_planes              = chroma_planes;
        f->chroma_h_shift             = chroma_h_shift;
        f->chroma_v_shift             = chroma_v_shift;
        f->transparency               = transparency;

        f->plane_count    = 2 + f->transparency;
    }

    if (f->colorspace == 0) {
        if (f->avctx->skip_alpha) f->transparency = 0;
        if (!f->transparency && !f->chroma_planes) {
            if (f->avctx->bits_per_raw_sample <= 8)
                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
            else
                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
            }
        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
            switch(16*f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {
            f->packed_at_lsb = 1;
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {
            f->packed_at_lsb = 1;
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {
            f->packed_at_lsb = 1;
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {
            f->packed_at_lsb = 1;
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
            }
        } else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){
            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;
            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;
            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;
            }
        }
    } else if (f->colorspace == 1) {
        if (f->chroma_h_shift || f->chroma_v_shift) {
            av_log(f->avctx, AV_LOG_ERROR,
                   ""chroma subsampling not supported in this colorspace\n"");
            return AVERROR(ENOSYS);
        }
        if (     f->avctx->bits_per_raw_sample ==  9)
            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
        else if (f->avctx->bits_per_raw_sample == 10)
            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
        else if (f->avctx->bits_per_raw_sample == 12)
            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
        else if (f->avctx->bits_per_raw_sample == 14)
            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
        else
        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
    } else {
        av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
        return AVERROR(ENOSYS);
    }
    if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {
        av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
        return AVERROR(ENOSYS);
    }

    av_dlog(f->avctx, ""%d %d %d\n"",
            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
    if (f->version < 2) {
        context_count = read_quant_tables(c, f->quant_table);
        if (context_count < 0) {
            av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
            return AVERROR_INVALIDDATA;
        }
        f->slice_count = f->max_slice_count;
    } else if (f->version < 3) {
        f->slice_count = get_symbol(c, state, 0);
    } else {
        const uint8_t *p = c->bytestream_end;
        for (f->slice_count = 0;
             f->slice_count < MAX_SLICES && 3 + 5*!!f->ec < p - c->bytestream_start;
             f->slice_count++) {
            int trailer = 3 + 5*!!f->ec;
            int size = AV_RB24(p-trailer);
            if (size + trailer > p - c->bytestream_start)
                break;
            p -= size + trailer;
        }
    }
    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {
        av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid (max=%d)\n"", f->slice_count, f->max_slice_count);
        return AVERROR_INVALIDDATA;
    }

    for (j = 0; j < f->slice_count; j++) {
        FFV1Context *fs = f->slice_context[j];
        fs->ac            = f->ac;
        fs->packed_at_lsb = f->packed_at_lsb;

        fs->slice_damaged = 0;

        if (f->version == 2) {
            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;

            fs->slice_x     /= f->num_h_slices;
            fs->slice_y     /= f->num_v_slices;
            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
            if ((unsigned)fs->slice_width  > f->width ||
                (unsigned)fs->slice_height > f->height)
                return AVERROR_INVALIDDATA;
            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
                return AVERROR_INVALIDDATA;
        }

        for (i = 0; i < f->plane_count; i++) {
            PlaneContext *const p = &fs->plane[i];

            if (f->version == 2) {
                int idx = get_symbol(c, state, 0);
                if (idx > (unsigned)f->quant_table_count) {
                    av_log(f->avctx, AV_LOG_ERROR,
                           ""quant_table_index out of range\n"");
                    return AVERROR_INVALIDDATA;
                }
                p->quant_table_index = idx;
                memcpy(p->quant_table, f->quant_tables[idx],
                       sizeof(p->quant_table));
                context_count = f->context_count[idx];
            } else {
                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
            }

            if (f->version <= 2) {
                av_assert0(context_count >= 0);
                if (p->context_count < context_count) {
                    av_freep(&p->state);
                    av_freep(&p->vlc_state);
                }
                p->context_count = context_count;
            }
        }
    }
    return 0;
}","static int read_header(FFV1Context *VAR_0)
{
    uint8_t VAR_1[VAR_2];
    int VAR_3, VAR_4, VAR_5 = -1; /* COMMENT_0 */
    RangeCoder *const VAR_6 = &VAR_0->slice_context[0]->c;

    memset(VAR_1, 128, sizeof(VAR_1));

    if (VAR_0->version < 2) {
        int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
        unsigned VAR_13= get_symbol(VAR_6, VAR_1, 0);
        if (VAR_13 >= 2) {
            av_log(VAR_0->avctx, VAR_14, ""invalid version %d in ver01 header\n"", VAR_13);
            return VAR_15;
        }
        VAR_0->version = VAR_13;
        VAR_0->ac      = VAR_0->avctx->coder_type = get_symbol(VAR_6, VAR_1, 0);
        if (VAR_0->ac > 1) {
            for (VAR_3 = 1; VAR_3 < 256; VAR_3++)
                VAR_0->state_transition[VAR_3] = get_symbol(VAR_6, VAR_1, 1) + VAR_6->one_state[VAR_3];
        }

        VAR_11          = get_symbol(VAR_6, VAR_1, 0); /* COMMENT_1 */
        VAR_12 = VAR_0->version > 0 ? get_symbol(VAR_6, VAR_1, 0) : VAR_0->avctx->bits_per_raw_sample;
        VAR_7       = get_rac(VAR_6, VAR_1);
        VAR_8      = get_symbol(VAR_6, VAR_1, 0);
        VAR_9      = get_symbol(VAR_6, VAR_1, 0);
        VAR_10        = get_rac(VAR_6, VAR_1);

        if (VAR_0->plane_count) {
            if (VAR_11          != VAR_0->colorspace                 ||
                VAR_12 != VAR_0->avctx->bits_per_raw_sample ||
                VAR_7       != VAR_0->chroma_planes              ||
                VAR_8      != VAR_0->chroma_h_shift             ||
                VAR_9      != VAR_0->chroma_v_shift             ||
                VAR_10        != VAR_0->transparency) {
                av_log(VAR_0->avctx, VAR_14, ""Invalid change of global parameters\n"");
                return VAR_15;
            }
        }

        if (VAR_8 > 4U || VAR_9 > 4U) {
            av_log(VAR_0->avctx, VAR_14, ""chroma shift parameters %d %d are invalid\n"",
                   VAR_8, VAR_9);
            return VAR_15;
        }

        VAR_0->colorspace                 = VAR_11;
        VAR_0->avctx->bits_per_raw_sample = VAR_12;
        VAR_0->chroma_planes              = VAR_7;
        VAR_0->chroma_h_shift             = VAR_8;
        VAR_0->chroma_v_shift             = VAR_9;
        VAR_0->transparency               = VAR_10;

        VAR_0->plane_count    = 2 + VAR_0->transparency;
    }

    if (VAR_0->colorspace == 0) {
        if (VAR_0->avctx->skip_alpha) VAR_0->transparency = 0;
        if (!VAR_0->transparency && !VAR_0->chroma_planes) {
            if (VAR_0->avctx->bits_per_raw_sample <= 8)
                VAR_0->avctx->pix_fmt = VAR_16;
            else
                VAR_0->avctx->pix_fmt = VAR_17;
        } else if (VAR_0->avctx->bits_per_raw_sample<=8 && !VAR_0->transparency) {
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_18; break;
            case 0x01: VAR_0->avctx->pix_fmt = VAR_19; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_20; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_21; break;
            case 0x20: VAR_0->avctx->pix_fmt = VAR_22; break;
            case 0x22: VAR_0->avctx->pix_fmt = VAR_23; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample <= 8 && VAR_0->transparency) {
            switch(16*VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_24; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_25; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_26; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 9 && !VAR_0->transparency) {
            VAR_0->packed_at_lsb = 1;
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_27; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_28; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_29; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 9 && VAR_0->transparency) {
            VAR_0->packed_at_lsb = 1;
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_30; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_31; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_32; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 10 && !VAR_0->transparency) {
            VAR_0->packed_at_lsb = 1;
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_33; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_34; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_35; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 10 && VAR_0->transparency) {
            VAR_0->packed_at_lsb = 1;
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_36; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_37; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_38; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 16 && !VAR_0->transparency){
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_39; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_40; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_41; break;
            }
        } else if (VAR_0->avctx->bits_per_raw_sample == 16 && VAR_0->transparency){
            switch(16 * VAR_0->chroma_h_shift + VAR_0->chroma_v_shift) {
            case 0x00: VAR_0->avctx->pix_fmt = VAR_42; break;
            case 0x10: VAR_0->avctx->pix_fmt = VAR_43; break;
            case 0x11: VAR_0->avctx->pix_fmt = VAR_44; break;
            }
        }
    } else if (VAR_0->colorspace == 1) {
        if (VAR_0->chroma_h_shift || VAR_0->chroma_v_shift) {
            av_log(VAR_0->avctx, VAR_14,
                   ""chroma subsampling not supported in this colorspace\n"");
            return AVERROR(VAR_45);
        }
        if (     VAR_0->avctx->bits_per_raw_sample ==  9)
            VAR_0->avctx->pix_fmt = VAR_46;
        else if (VAR_0->avctx->bits_per_raw_sample == 10)
            VAR_0->avctx->pix_fmt = VAR_47;
        else if (VAR_0->avctx->bits_per_raw_sample == 12)
            VAR_0->avctx->pix_fmt = VAR_48;
        else if (VAR_0->avctx->bits_per_raw_sample == 14)
            VAR_0->avctx->pix_fmt = VAR_49;
        else
        if (VAR_0->transparency) VAR_0->avctx->pix_fmt = VAR_50;
        else                 VAR_0->avctx->pix_fmt = VAR_51;
    } else {
        av_log(VAR_0->avctx, VAR_14, ""colorspace not supported\n"");
        return AVERROR(VAR_45);
    }
    if (VAR_0->avctx->pix_fmt == VAR_52) {
        av_log(VAR_0->avctx, VAR_14, ""format not supported\n"");
        return AVERROR(VAR_45);
    }

    av_dlog(VAR_0->avctx, ""%d %d %d\n"",
            VAR_0->chroma_h_shift, VAR_0->chroma_v_shift, VAR_0->avctx->pix_fmt);
    if (VAR_0->version < 2) {
        VAR_5 = read_quant_tables(VAR_6, VAR_0->quant_table);
        if (VAR_5 < 0) {
            av_log(VAR_0->avctx, VAR_14, ""read_quant_table error\n"");
            return VAR_15;
        }
        VAR_0->slice_count = VAR_0->max_slice_count;
    } else if (VAR_0->version < 3) {
        VAR_0->slice_count = get_symbol(VAR_6, VAR_1, 0);
    } else {
        const uint8_t *VAR_53 = VAR_6->bytestream_end;
        for (VAR_0->slice_count = 0;
             VAR_0->slice_count < VAR_54 && 3 + 5*!!VAR_0->ec < VAR_53 - VAR_6->bytestream_start;
             VAR_0->slice_count++) {
            int VAR_55 = 3 + 5*!!VAR_0->ec;
            int VAR_56 = AV_RB24(VAR_53-VAR_55);
            if (VAR_56 + VAR_55 > VAR_53 - VAR_6->bytestream_start)
                break;
            VAR_53 -= VAR_56 + VAR_55;
        }
    }
    if (VAR_0->slice_count > (unsigned)VAR_54 || VAR_0->slice_count <= 0 || VAR_0->slice_count > VAR_0->max_slice_count) {
        av_log(VAR_0->avctx, VAR_14, ""slice count %d is invalid (max=%d)\n"", VAR_0->slice_count, VAR_0->max_slice_count);
        return VAR_15;
    }

    for (VAR_4 = 0; VAR_4 < VAR_0->slice_count; VAR_4++) {
        FFV1Context *VAR_57 = VAR_0->slice_context[VAR_4];
        VAR_57->ac            = VAR_0->ac;
        VAR_57->packed_at_lsb = VAR_0->packed_at_lsb;

        VAR_57->slice_damaged = 0;

        if (VAR_0->version == 2) {
            VAR_57->slice_x      =  get_symbol(VAR_6, VAR_1, 0)      * VAR_0->width ;
            VAR_57->slice_y      =  get_symbol(VAR_6, VAR_1, 0)      * VAR_0->height;
            VAR_57->slice_width  = (get_symbol(VAR_6, VAR_1, 0) + 1) * VAR_0->width  + VAR_57->slice_x;
            VAR_57->slice_height = (get_symbol(VAR_6, VAR_1, 0) + 1) * VAR_0->height + VAR_57->slice_y;

            VAR_57->slice_x     /= VAR_0->num_h_slices;
            VAR_57->slice_y     /= VAR_0->num_v_slices;
            VAR_57->slice_width  = VAR_57->slice_width  / VAR_0->num_h_slices - VAR_57->slice_x;
            VAR_57->slice_height = VAR_57->slice_height / VAR_0->num_v_slices - VAR_57->slice_y;
            if ((unsigned)VAR_57->slice_width  > VAR_0->width ||
                (unsigned)VAR_57->slice_height > VAR_0->height)
                return VAR_15;
            if (   (unsigned)VAR_57->slice_x + (uint64_t)VAR_57->slice_width  > VAR_0->width
                || (unsigned)VAR_57->slice_y + (uint64_t)VAR_57->slice_height > VAR_0->height)
                return VAR_15;
        }

        for (VAR_3 = 0; VAR_3 < VAR_0->plane_count; VAR_3++) {
            PlaneContext *const VAR_53 = &VAR_57->plane[VAR_3];

            if (VAR_0->version == 2) {
                int VAR_58 = get_symbol(VAR_6, VAR_1, 0);
                if (VAR_58 > (unsigned)VAR_0->quant_table_count) {
                    av_log(VAR_0->avctx, VAR_14,
                           ""quant_table_index out of range\n"");
                    return VAR_15;
                }
                VAR_53->quant_table_index = VAR_58;
                memcpy(VAR_53->quant_table, VAR_0->quant_tables[VAR_58],
                       sizeof(VAR_53->quant_table));
                VAR_5 = VAR_0->context_count[VAR_58];
            } else {
                memcpy(VAR_53->quant_table, VAR_0->quant_table, sizeof(VAR_53->quant_table));
            }

            if (VAR_0->version <= 2) {
                av_assert0(VAR_5 >= 0);
                if (VAR_53->context_count < VAR_5) {
                    av_freep(&VAR_53->state);
                    av_freep(&VAR_53->vlc_state);
                }
                VAR_53->context_count = VAR_5;
            }
        }
    }
    return 0;
}",ffmpeg/d893253fcd93d11258e98857175e93be7d158708/ffv1dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -158,7 +158,7 @@
     } else {
         const uint8_t *p = c->bytestream_end;
         for (f->slice_count = 0;
-             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
+             f->slice_count < MAX_SLICES && 3 + 5*!!f->ec < p - c->bytestream_start;
              f->slice_count++) {
             int trailer = 3 + 5*!!f->ec;
             int size = AV_RB24(p-trailer);","{'deleted_lines': ['             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;'], 'added_lines': ['             f->slice_count < MAX_SLICES && 3 + 5*!!f->ec < p - c->bytestream_start;']}",True,"The read_header function in libavcodec/ffv1dec.c in FFmpeg 2.4 and 3.3.4 and possibly earlier allows remote attackers to have unspecified impact via a crafted MP4 file, which triggers an out-of-bounds read.",8.8,HIGH,2,valid,2017-10-09T09:49:28Z,2
CVE-2017-15592,['CWE-668'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: Don't create self-linear shadow mappings for 4-level translated guests

When initially creating a monitor table for 4-level translated guests, don't
install a shadow-linear mapping.  This mapping is actually self-linear, and
trips up the writeable heuristic logic into following Xen's mappings, not the
guests' shadows it was expecting to follow.

A consequence of this is that sh_guess_wrmap() needs to cope with there being
no shadow-linear mapping present, which in practice occurs once each time a
vcpu switches to 4-level paging from a different paging mode.

An appropriate shadow-linear slot will be inserted into the monitor table
either while constructing lower level monitor tables, or by sh_update_cr3().

While fixing this, clarify the safety of the other mappings.  Despite
appearing unsafe, it is correct to create a guest-linear mapping for
translated domains; this is self-linear and doesn't point into the translated
domain.  Drop a dead clause for translate != external guests.

This is XSA-243.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Tim Deegan <tim@xen.org>",bf2b4eadcf379d0361b38de9725ea5f7a18a5205,https://github.com/xen-project/xen/commit/bf2b4eadcf379d0361b38de9725ea5f7a18a5205,xen/arch/x86/mm/shadow/multi.c,sh_guess_wrmap,"static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)
{
struct domain *d = v->domain;
shadow_l1e_t sl1e, *sl1p;
shadow_l2e_t *sl2p;
shadow_l3e_t *sl3p;
#if SHADOW_PAGING_LEVELS >= 4
shadow_l4e_t *sl4p;
#endif
mfn_t sl1mfn;
int r;
#if SHADOW_PAGING_LEVELS >= 4
sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
return 0;
sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);
if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
return 0;
#else 
sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)
+ shadow_l3_linear_offset(vaddr);
if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
return 0;
#endif
sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);
if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )
return 0;
sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);
sl1e = *sl1p;
if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
!= (_PAGE_PRESENT|_PAGE_RW))
|| (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )
return 0;
sl1mfn = shadow_l2e_get_mfn(*sl2p);
sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);
if ( r & SHADOW_SET_ERROR ) {
return 0;
}
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);
return 1;
}","static int sh_guess_wrmap(struct vcpu *VAR_0, unsigned long VAR_1, mfn_t VAR_2)
{
struct domain *VAR_3 = VAR_0->domain;
shadow_l1e_t VAR_4, *VAR_5;
shadow_l2e_t *VAR_6;
shadow_l3e_t *VAR_7;
#if VAR_8 >= 4
shadow_l4e_t *VAR_9;
#endif
mfn_t VAR_10;
int VAR_11;
#if VAR_8 >= 4
VAR_9 = sh_linear_l4_table(VAR_0) + shadow_l4_linear_offset(VAR_1);
if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_12) )
return 0;
VAR_7 = sh_linear_l3_table(VAR_0) + shadow_l3_linear_offset(VAR_1);
if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_12) )
return 0;
#else 
VAR_7 = ((shadow_l3e_t *) VAR_0->arch.paging.shadow.l3table)
+ shadow_l3_linear_offset(VAR_1);
if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_12) )
return 0;
#endif
VAR_6 = sh_linear_l2_table(VAR_0) + shadow_l2_linear_offset(VAR_1);
if ( !(shadow_l2e_get_flags(*VAR_6) & VAR_12) )
return 0;
VAR_5 = sh_linear_l1_table(VAR_0) + shadow_l1_linear_offset(VAR_1);
VAR_4 = *VAR_5;
if ( ((shadow_l1e_get_flags(VAR_4) & (VAR_12|VAR_13))
!= (VAR_12|VAR_13))
|| (mfn_x(shadow_l1e_get_mfn(VAR_4)) != mfn_x(VAR_2)) )
return 0;
VAR_10 = shadow_l2e_get_mfn(*VAR_6);
VAR_4 = shadow_l1e_remove_flags(VAR_4, VAR_13);
VAR_11 = shadow_set_l1e(VAR_3, VAR_5, VAR_4, VAR_14, VAR_10);
if ( VAR_11 & VAR_15 ) {
return 0;
}
TRACE_SHADOW_PATH_FLAG(VAR_16);
return 1;
}",xen-project/xen/bf2b4eadcf379d0361b38de9725ea5f7a18a5205/multi.c/vul/before/0.json,"static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)
/* Look up this vaddr in the current shadow and see if it's a writeable
 * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */
{
    struct domain *d = v->domain;
    shadow_l1e_t sl1e, *sl1p;
    shadow_l2e_t *sl2p;
    shadow_l3e_t *sl3p;
#if SHADOW_PAGING_LEVELS >= 4
    shadow_l4e_t *sl4p;
#endif
    mfn_t sl1mfn;
    int r;

    /* Carefully look in the shadow linear map for the l1e we expect */
#if SHADOW_PAGING_LEVELS >= 4
    /* Is a shadow linear map is installed in the first place? */
    sl4p  = v->arch.paging.shadow.guest_vtable;
    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);
    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
        return 0;
    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
        return 0;
    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);
    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
        return 0;
#else /* SHADOW_PAGING_LEVELS == 3 */
    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)
        + shadow_l3_linear_offset(vaddr);
    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
        return 0;
#endif
    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);
    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )
        return 0;
    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);
    sl1e = *sl1p;
    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
          != (_PAGE_PRESENT|_PAGE_RW))
         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )
        return 0;

    /* Found it!  Need to remove its write permissions. */
    sl1mfn = shadow_l2e_get_mfn(*sl2p);
    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);
    if ( r & SHADOW_SET_ERROR ) {
        /* Can only currently happen if we found a grant-mapped
         * page.  Just make the guess fail. */
        return 0;
    }
    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);
    return 1;
}","static int sh_guess_wrmap(struct vcpu *VAR_0, unsigned long VAR_1, mfn_t VAR_2)
/* COMMENT_0 */
                                                                       
{
    struct domain *VAR_3 = VAR_0->domain;
    shadow_l1e_t VAR_4, *VAR_5;
    shadow_l2e_t *VAR_6;
    shadow_l3e_t *VAR_7;
#if VAR_8 >= 4
    shadow_l4e_t *VAR_9;
#endif
    mfn_t VAR_10;
    int VAR_11;

    /* COMMENT_2 */
#if VAR_8 >= 4
    /* COMMENT_3 */
    VAR_9  = VAR_0->arch.paging.shadow.guest_vtable;
    VAR_9 += shadow_l4_table_offset(VAR_12);
    if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_13) )
        return 0;
    VAR_9 = sh_linear_l4_table(VAR_0) + shadow_l4_linear_offset(VAR_1);
    if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_13) )
        return 0;
    VAR_7 = sh_linear_l3_table(VAR_0) + shadow_l3_linear_offset(VAR_1);
    if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_13) )
        return 0;
#else /* COMMENT_4 */
    VAR_7 = ((shadow_l3e_t *) VAR_0->arch.paging.shadow.l3table)
        + shadow_l3_linear_offset(VAR_1);
    if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_13) )
        return 0;
#endif
    VAR_6 = sh_linear_l2_table(VAR_0) + shadow_l2_linear_offset(VAR_1);
    if ( !(shadow_l2e_get_flags(*VAR_6) & VAR_13) )
        return 0;
    VAR_5 = sh_linear_l1_table(VAR_0) + shadow_l1_linear_offset(VAR_1);
    VAR_4 = *VAR_5;
    if ( ((shadow_l1e_get_flags(VAR_4) & (VAR_13|VAR_14))
          != (VAR_13|VAR_14))
         || (mfn_x(shadow_l1e_get_mfn(VAR_4)) != mfn_x(VAR_2)) )
        return 0;

    /* COMMENT_5 */
    VAR_10 = shadow_l2e_get_mfn(*VAR_6);
    VAR_4 = shadow_l1e_remove_flags(VAR_4, VAR_14);
    VAR_11 = shadow_set_l1e(VAR_3, VAR_5, VAR_4, VAR_15, VAR_10);
    if ( VAR_11 & VAR_16 ) {
        /* COMMENT_6 */
                                              
        return 0;
    }
    TRACE_SHADOW_PATH_FLAG(VAR_17);
    return 1;
}",xen-project/xen/bf2b4eadcf379d0361b38de9725ea5f7a18a5205/multi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,11 @@
 
     /* Carefully look in the shadow linear map for the l1e we expect */
 #if SHADOW_PAGING_LEVELS >= 4
+    /* Is a shadow linear map is installed in the first place? */
+    sl4p  = v->arch.paging.shadow.guest_vtable;
+    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);
+    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
+        return 0;
     sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
     if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
         return 0;","{'deleted_lines': [], 'added_lines': ['    /* Is a shadow linear map is installed in the first place? */', '    sl4p  = v->arch.paging.shadow.guest_vtable;', '    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);', '    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )', '        return 0;']}",True,An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.,8.8,HIGH,2,valid,2017-10-12T12:50:07Z,2
CVE-2017-15592,['CWE-668'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: Don't create self-linear shadow mappings for 4-level translated guests

When initially creating a monitor table for 4-level translated guests, don't
install a shadow-linear mapping.  This mapping is actually self-linear, and
trips up the writeable heuristic logic into following Xen's mappings, not the
guests' shadows it was expecting to follow.

A consequence of this is that sh_guess_wrmap() needs to cope with there being
no shadow-linear mapping present, which in practice occurs once each time a
vcpu switches to 4-level paging from a different paging mode.

An appropriate shadow-linear slot will be inserted into the monitor table
either while constructing lower level monitor tables, or by sh_update_cr3().

While fixing this, clarify the safety of the other mappings.  Despite
appearing unsafe, it is correct to create a guest-linear mapping for
translated domains; this is self-linear and doesn't point into the translated
domain.  Drop a dead clause for translate != external guests.

This is XSA-243.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Tim Deegan <tim@xen.org>",bf2b4eadcf379d0361b38de9725ea5f7a18a5205,https://github.com/xen-project/xen/commit/bf2b4eadcf379d0361b38de9725ea5f7a18a5205,xen/arch/x86/mm/shadow/multi.c,sh_install_xen_entries_in_l4,"void sh_install_xen_entries_in_l4(struct domain *d, mfn_t gl4mfn, mfn_t sl4mfn)
{
shadow_l4e_t *sl4e;
unsigned int slots;
sl4e = map_domain_page(sl4mfn);
BUILD_BUG_ON(sizeof (l4_pgentry_t) != sizeof (shadow_l4e_t));
slots = (shadow_mode_external(d)
? ROOT_PAGETABLE_XEN_SLOTS
: ROOT_PAGETABLE_PV_XEN_SLOTS);
memcpy(&sl4e[ROOT_PAGETABLE_FIRST_XEN_SLOT],
&idle_pg_table[ROOT_PAGETABLE_FIRST_XEN_SLOT],
slots * sizeof(l4_pgentry_t));
sl4e[shadow_l4_table_offset(PERDOMAIN_VIRT_START)] =
shadow_l4e_from_mfn(page_to_mfn(d->arch.perdomain_l3_pg),
__PAGE_HYPERVISOR_RW);
if ( !shadow_mode_external(d) && !is_pv_32bit_domain(d) &&
!VM_ASSIST(d, m2p_strict) )
{
sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();
}
sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);
if ( shadow_mode_translate(d) && !shadow_mode_external(d) )
{
sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
shadow_l4e_empty();
}
else
{
sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);
}
unmap_domain_page(sl4e);
}","void sh_install_xen_entries_in_l4(struct domain *VAR_0, mfn_t VAR_1, mfn_t VAR_2)
{
shadow_l4e_t *VAR_3;
unsigned int VAR_4;
VAR_3 = map_domain_page(VAR_2);
BUILD_BUG_ON(sizeof (VAR_5) != sizeof (shadow_l4e_t));
VAR_4 = (shadow_mode_external(VAR_0)
? VAR_6
: VAR_7);
memcpy(&VAR_3[VAR_8],
&VAR_9[VAR_8],
VAR_4 * sizeof(VAR_5));
VAR_3[shadow_l4_table_offset(VAR_10)] =
shadow_l4e_from_mfn(page_to_mfn(VAR_0->arch.perdomain_l3_pg),
VAR_11);
if ( !shadow_mode_external(VAR_0) && !is_pv_32bit_domain(VAR_0) &&
!VM_ASSIST(VAR_0, VAR_12) )
{
VAR_3[shadow_l4_table_offset(VAR_13)] = shadow_l4e_empty();
}
VAR_3[shadow_l4_table_offset(VAR_14)] =
shadow_l4e_from_mfn(VAR_2, VAR_11);
if ( shadow_mode_translate(VAR_0) && !shadow_mode_external(VAR_0) )
{
VAR_3[shadow_l4_table_offset(VAR_15)] =
shadow_l4e_empty();
}
else
{
VAR_3[shadow_l4_table_offset(VAR_15)] =
shadow_l4e_from_mfn(VAR_1, VAR_11);
}
unmap_domain_page(VAR_3);
}",xen-project/xen/bf2b4eadcf379d0361b38de9725ea5f7a18a5205/multi.c/vul/before/1.json,"void sh_install_xen_entries_in_l4(struct domain *d, mfn_t gl4mfn, mfn_t sl4mfn)
{
    shadow_l4e_t *sl4e;
    unsigned int slots;

    sl4e = map_domain_page(sl4mfn);
    BUILD_BUG_ON(sizeof (l4_pgentry_t) != sizeof (shadow_l4e_t));

    /* Copy the common Xen mappings from the idle domain */
    slots = (shadow_mode_external(d)
             ? ROOT_PAGETABLE_XEN_SLOTS
             : ROOT_PAGETABLE_PV_XEN_SLOTS);
    memcpy(&sl4e[ROOT_PAGETABLE_FIRST_XEN_SLOT],
           &idle_pg_table[ROOT_PAGETABLE_FIRST_XEN_SLOT],
           slots * sizeof(l4_pgentry_t));

    /* Install the per-domain mappings for this domain */
    sl4e[shadow_l4_table_offset(PERDOMAIN_VIRT_START)] =
        shadow_l4e_from_mfn(page_to_mfn(d->arch.perdomain_l3_pg),
                            __PAGE_HYPERVISOR_RW);

    if ( !shadow_mode_external(d) && !is_pv_32bit_domain(d) &&
         !VM_ASSIST(d, m2p_strict) )
    {
        /* open coded zap_ro_mpt(mfn_x(sl4mfn)): */
        sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();
    }

    /*
     * Linear mapping slots:
     *
     * Calling this function with gl4mfn == sl4mfn is used to construct a
     * monitor table for translated domains.  In this case, gl4mfn forms the
     * self-linear mapping (i.e. not pointing into the translated domain), and
     * the shadow-linear slot is skipped.  The shadow-linear slot is either
     * filled when constructing lower level monitor tables, or via
     * sh_update_cr3() for 4-level guests.
     *
     * Calling this function with gl4mfn != sl4mfn is used for non-translated
     * guests, where the shadow-linear slot is actually self-linear, and the
     * guest-linear slot points into the guests view of its pagetables.
     */
    if ( shadow_mode_translate(d) )
    {
        ASSERT(mfn_eq(gl4mfn, sl4mfn));

        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
            shadow_l4e_empty();
    }
    else
    {
        ASSERT(!mfn_eq(gl4mfn, sl4mfn));

        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);
    }

    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);

    unmap_domain_page(sl4e);
}","void sh_install_xen_entries_in_l4(struct domain *VAR_0, mfn_t VAR_1, mfn_t VAR_2)
{
    shadow_l4e_t *VAR_3;
    unsigned int VAR_4;

    VAR_3 = map_domain_page(VAR_2);
    BUILD_BUG_ON(sizeof (VAR_5) != sizeof (shadow_l4e_t));

    /* COMMENT_0 */
    VAR_4 = (shadow_mode_external(VAR_0)
             ? VAR_6
             : VAR_7);
    memcpy(&VAR_3[VAR_8],
           &VAR_9[VAR_8],
           VAR_4 * sizeof(VAR_5));

    /* COMMENT_1 */
    VAR_3[shadow_l4_table_offset(VAR_10)] =
        shadow_l4e_from_mfn(page_to_mfn(VAR_0->arch.perdomain_l3_pg),
                            VAR_11);

    if ( !shadow_mode_external(VAR_0) && !is_pv_32bit_domain(VAR_0) &&
         !VM_ASSIST(VAR_0, VAR_12) )
    {
        /* COMMENT_2 */
        VAR_3[shadow_l4_table_offset(VAR_13)] = shadow_l4e_empty();
    }

    /* COMMENT_3 */
                            
      
                                                                         
                                                                            
                                                                              
                                                                           
                                                                  
                                          
      
                                                                             
                                                                            
                                                                       
       
    if ( shadow_mode_translate(VAR_0) )
    {
        ASSERT(mfn_eq(VAR_1, VAR_2));

        VAR_3[shadow_l4_table_offset(VAR_14)] =
            shadow_l4e_empty();
    }
    else
    {
        ASSERT(!mfn_eq(VAR_1, VAR_2));

        VAR_3[shadow_l4_table_offset(VAR_14)] =
            shadow_l4e_from_mfn(VAR_2, VAR_11);
    }

    VAR_3[shadow_l4_table_offset(VAR_15)] =
        shadow_l4e_from_mfn(VAR_1, VAR_11);

    unmap_domain_page(VAR_3);
}",xen-project/xen/bf2b4eadcf379d0361b38de9725ea5f7a18a5205/multi.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -26,25 +26,37 @@
         sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();
     }
 
-    /* Shadow linear mapping for 4-level shadows.  N.B. for 3-level
-     * shadows on 64-bit xen, this linear mapping is later replaced by the
-     * monitor pagetable structure, which is built in make_monitor_table
-     * and maintained by sh_update_linear_entries. */
-    sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
-        shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);
+    /*
+     * Linear mapping slots:
+     *
+     * Calling this function with gl4mfn == sl4mfn is used to construct a
+     * monitor table for translated domains.  In this case, gl4mfn forms the
+     * self-linear mapping (i.e. not pointing into the translated domain), and
+     * the shadow-linear slot is skipped.  The shadow-linear slot is either
+     * filled when constructing lower level monitor tables, or via
+     * sh_update_cr3() for 4-level guests.
+     *
+     * Calling this function with gl4mfn != sl4mfn is used for non-translated
+     * guests, where the shadow-linear slot is actually self-linear, and the
+     * guest-linear slot points into the guests view of its pagetables.
+     */
+    if ( shadow_mode_translate(d) )
+    {
+        ASSERT(mfn_eq(gl4mfn, sl4mfn));
 
-    /* Self linear mapping.  */
-    if ( shadow_mode_translate(d) && !shadow_mode_external(d) )
-    {
-        // linear tables may not be used with translated PV guests
-        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
+        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
             shadow_l4e_empty();
     }
     else
     {
-        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
-            shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);
+        ASSERT(!mfn_eq(gl4mfn, sl4mfn));
+
+        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =
+            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);
     }
+
+    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =
+        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);
 
     unmap_domain_page(sl4e);
 }","{'deleted_lines': ['    /* Shadow linear mapping for 4-level shadows.  N.B. for 3-level', '     * shadows on 64-bit xen, this linear mapping is later replaced by the', '     * monitor pagetable structure, which is built in make_monitor_table', '     * and maintained by sh_update_linear_entries. */', '    sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =', '        shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);', '    /* Self linear mapping.  */', '    if ( shadow_mode_translate(d) && !shadow_mode_external(d) )', '    {', '        // linear tables may not be used with translated PV guests', '        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =', '        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =', '            shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);'], 'added_lines': ['    /*', '     * Linear mapping slots:', '     *', '     * Calling this function with gl4mfn == sl4mfn is used to construct a', '     * monitor table for translated domains.  In this case, gl4mfn forms the', '     * self-linear mapping (i.e. not pointing into the translated domain), and', '     * the shadow-linear slot is skipped.  The shadow-linear slot is either', '     * filled when constructing lower level monitor tables, or via', '     * sh_update_cr3() for 4-level guests.', '     *', '     * Calling this function with gl4mfn != sl4mfn is used for non-translated', '     * guests, where the shadow-linear slot is actually self-linear, and the', '     * guest-linear slot points into the guests view of its pagetables.', '     */', '    if ( shadow_mode_translate(d) )', '    {', '        ASSERT(mfn_eq(gl4mfn, sl4mfn));', '        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =', '        ASSERT(!mfn_eq(gl4mfn, sl4mfn));', '', '        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =', '            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);', '', '    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =', '        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);']}",True,An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.,8.8,HIGH,2,valid,2017-10-12T12:50:07Z,2
CVE-2017-15364,['CWE-415'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,evan/ccsv,proposed non elegant fix for double free vulnerability,24e0b9b94c44a15b23475e821366239d53764dbd,https://github.com/evan/ccsv/commit/24e0b9b94c44a15b23475e821366239d53764dbd,ext/ccsv.c,foreach,"static VALUE foreach(int argc, VALUE* argv, VALUE self) {
char *DELIM=DEF_DELIM;
char *line = NULL;
char *line2 =NULL, *new_line=NULL;
size_t len = 0, len2=0, i, pairs_count;
char *token,*start,*nobackslash,*t2;
size_t idx,count,searchfield,flag,array_length,range_i;
long check;
int  was_read;
FILE *file;
ID min_method, max_method;
VALUE min_val, max_val;
VALUE tmp_value, rest_args, filename;
ID    array_length_method; 
struct pair_st pairs[MAX_INTERVALS];
VALUE ary;
rb_scan_args(argc,argv,""1*"", &filename, &rest_args);
file = fopen(StringValueCStr(filename), ""r"");
if(file==NULL){
rb_raise(rb_eRuntimeError, ""File not found"");
}
if (argc >1 ) { 
tmp_value=rb_ary_entry(rest_args,0);
DELIM=StringValueCStr(tmp_value);;
}
if (argc >2 ) { 
tmp_value=rb_ary_entry(rest_args,1);
searchfield=NUM2INT(tmp_value);
}
else{
searchfield=-1;
}
array_length_method=rb_funcall(rest_args,rb_intern(""length""), 0);
array_length=NUM2INT(array_length_method);
min_method = rb_intern(""first"");
max_method = rb_intern(""last"");
range_i=0;
for(idx=2;idx<array_length;++idx){
min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(""length""), 0);
len2=NUM2INT(min_val);
for(i=0;i<len2;++i){
VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);
if(range_i>MAX_INTERVALS)
rb_raise(rb_eRuntimeError, ""Too much ranges passed"");
if(TYPE(e) == T_NIL){
pairs[range_i].low=LONG_MIN;
pairs[range_i].high=LONG_MAX;
continue; 
}
if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))
rb_raise(rb_eRuntimeError, ""Not range passed to Ccsv.foreach"");
min_val=rb_funcall(e, min_method, 0);
max_val=rb_funcall(e, max_method, 0);
pairs[range_i].low=NUM2LONG(min_val);
pairs[range_i].high=NUM2LONG(max_val);
range_i++;
}
}
pairs_count=range_i;
while ((was_read=getline(&line, &len, file)) != -1) {
if(was_read<1)
continue;
len=was_read-1;
for(;;) {
if(line[len]!=EOL)
break;
if(line[len]==CR){
len-=1;
}
count=0;
t2=line+len-1;
while((t2>=line) && (*t2=='\\'))
{++count;--t2;}
if(count%2 ==1){ 
line2=NULL;
len2=0;
if((was_read=getline(&line2, &len2, file)) != -1) {
len2=was_read;
if(new_line)
free(new_line);           new_line=malloc(len+len2+1);
strcpy(new_line,line);
new_line[len-1]='\n';
strcpy(new_line+len,line2);
line=new_line;
start=new_line;
len+=len2-1;
nobackslash=start;
free(line);
free(line2);
continue;
}
}
break;
}
if(line[len]==EOL){
if(line[len-1]==CR)
len-=1;
line[len]='\0';
}
if(len<2)
continue;
ary = rb_ary_new();
start=line;
nobackslash=line;
idx = 0;
flag=1;
while (nobackslash != NULL) {
while(token=strstr(nobackslash, DELIM)){
count=0;
t2=token-1;
while((t2>=line) && (*t2=='\\'))
{++count;--t2;}
if(count%2 ==1){ 
nobackslash=token;
continue;
}
break;
}
if(token)
*token='\0';
else
token=start+strlen(start);
if(searchfield==idx){
flag=0;
sscanf(start,""%ld"",&check);
for(i=0;i<pairs_count;++i){
if(pairs[i].low<check && pairs[i].high>check){
flag=1; 
break;
}
}
}
if(flag==0)
break;
rb_ary_store(ary, idx, rb_str_new(start, token-start));
idx++;
nobackslash=start=token+strlen(DELIM);
while(token=strstr(nobackslash, DELIM)){
count=0;
t2=token-1;
while((t2>=line) && (*t2=='\\'))
{++count;--t2;}
if(count%2 ==1){ 
nobackslash=token+strlen(DELIM);
continue;
}
break;
}
nobackslash=token;
}
if(flag==0)
continue;
rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));
rb_yield(ary);
}
fclose(file);
free(line);
return Qnil;
}","static VALUE foreach(int VAR_0, VALUE* VAR_1, VALUE VAR_2) {
char *VAR_3=VAR_4;
char *VAR_5 = NULL;
char *VAR_6 =NULL, *VAR_7=NULL;
size_t VAR_8 = 0, VAR_9=0, VAR_10, VAR_11;
char *VAR_12,*VAR_13,*VAR_14,*VAR_15;
size_t VAR_16,VAR_17,VAR_18,VAR_19,VAR_20,VAR_21;
long VAR_22;
int  VAR_23;
FILE *VAR_24;
ID VAR_25, VAR_26;
VALUE VAR_27, VAR_28;
VALUE VAR_29, VAR_30, VAR_31;
ID    VAR_32; 
struct pair_st VAR_33[VAR_34];
VALUE VAR_35;
rb_scan_args(VAR_0,VAR_1,""1*"", &VAR_31, &VAR_30);
VAR_24 = fopen(StringValueCStr(VAR_31), ""r"");
if(VAR_24==NULL){
rb_raise(VAR_36, ""File not found"");
}
if (VAR_0 >1 ) { 
VAR_29=rb_ary_entry(VAR_30,0);
VAR_3=StringValueCStr(VAR_29);;
}
if (VAR_0 >2 ) { 
VAR_29=rb_ary_entry(VAR_30,1);
VAR_18=NUM2INT(VAR_29);
}
else{
VAR_18=-1;
}
VAR_32=rb_funcall(VAR_30,rb_intern(""length""), 0);
VAR_20=NUM2INT(VAR_32);
VAR_25 = rb_intern(""first"");
VAR_26 = rb_intern(""last"");
VAR_21=0;
for(VAR_16=2;VAR_16<VAR_20;++VAR_16){
VAR_27=rb_funcall(rb_ary_entry(VAR_30,VAR_16),rb_intern(""length""), 0);
VAR_9=NUM2INT(VAR_27);
for(VAR_10=0;VAR_10<VAR_9;++VAR_10){
VALUE VAR_37=rb_ary_entry(rb_ary_entry(VAR_30,VAR_16),VAR_10);
if(VAR_21>VAR_34)
rb_raise(VAR_36, ""Too much ranges passed"");
if(TYPE(VAR_37) == VAR_38){
VAR_33[VAR_21].low=VAR_39;
VAR_33[VAR_21].high=VAR_40;
continue; 
}
if (! (rb_respond_to(VAR_37, VAR_25) & rb_respond_to(VAR_37, VAR_26)))
rb_raise(VAR_36, ""Not range passed to Ccsv.foreach"");
VAR_27=rb_funcall(VAR_37, VAR_25, 0);
VAR_28=rb_funcall(VAR_37, VAR_26, 0);
VAR_33[VAR_21].low=NUM2LONG(VAR_27);
VAR_33[VAR_21].high=NUM2LONG(VAR_28);
VAR_21++;
}
}
VAR_11=VAR_21;
while ((VAR_23=getline(&VAR_5, &VAR_8, VAR_24)) != -1) {
if(VAR_23<1)
continue;
VAR_8=VAR_23-1;
for(;;) {
if(VAR_5[VAR_8]!=VAR_41)
break;
if(VAR_5[VAR_8]==VAR_42){
VAR_8-=1;
}
VAR_17=0;
VAR_15=VAR_5+VAR_8-1;
while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
{++VAR_17;--VAR_15;}
if(VAR_17%2 ==1){ 
VAR_6=NULL;
VAR_9=0;
if((VAR_23=getline(&VAR_6, &VAR_9, VAR_24)) != -1) {
VAR_9=VAR_23;
if(VAR_7)
free(VAR_7); 
VAR_7=malloc(VAR_8+VAR_9+1);
strcpy(VAR_7,VAR_5);
VAR_7[VAR_8-1]='\n';
strcpy(VAR_7+VAR_8,VAR_6);
VAR_5=VAR_7;
VAR_13=VAR_7;
VAR_8+=VAR_9-1;
VAR_14=VAR_13;
free(VAR_5);
free(VAR_6);
continue;
}
}
break;
}
if(VAR_5[VAR_8]==VAR_41){
if(VAR_5[VAR_8-1]==VAR_42)
VAR_8-=1;
VAR_5[VAR_8]='\0';
}
if(VAR_8<2)
continue;
VAR_35 = rb_ary_new();
VAR_13=VAR_5;
VAR_14=VAR_5;
VAR_16 = 0;
VAR_19=1;
while (VAR_14 != NULL) {
while(VAR_12=strstr(VAR_14, VAR_3)){
VAR_17=0;
VAR_15=VAR_12-1;
while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
{++VAR_17;--VAR_15;}
if(VAR_17%2 ==1){ 
VAR_14=VAR_12;
continue;
}
break;
}
if(VAR_12)
*VAR_12='\0';
else
VAR_12=VAR_13+strlen(VAR_13);
if(VAR_18==VAR_16){
VAR_19=0;
sscanf(VAR_13,""%ld"",&VAR_22);
for(VAR_10=0;VAR_10<VAR_11;++VAR_10){
if(VAR_33[VAR_10].low<VAR_22 && VAR_33[VAR_10].high>VAR_22){
VAR_19=1; 
break;
}
}
}
if(VAR_19==0)
break;
rb_ary_store(VAR_35, VAR_16, rb_str_new(VAR_13, VAR_12-VAR_13));
VAR_16++;
VAR_14=VAR_13=VAR_12+strlen(VAR_3);
while(VAR_12=strstr(VAR_14, VAR_3)){
VAR_17=0;
VAR_15=VAR_12-1;
while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
{++VAR_17;--VAR_15;}
if(VAR_17%2 ==1){ 
VAR_14=VAR_12+strlen(VAR_3);
continue;
}
break;
}
VAR_14=VAR_12;
}
if(VAR_19==0)
continue;
rb_ary_store(VAR_35, VAR_16, rb_str_new(VAR_13, strlen(VAR_13)));
rb_yield(VAR_35);
}
fclose(VAR_24);
free(VAR_5);
return VAR_43;
}",evan/ccsv/24e0b9b94c44a15b23475e821366239d53764dbd/ccsv.c/vul/before/0.json,"static VALUE foreach(int argc, VALUE* argv, VALUE self) {
  char *DELIM=DEF_DELIM;
  char *line = NULL;
  char *line2 =NULL, *new_line=NULL;
  size_t len = 0, len2=0, i, pairs_count;
  char *token,*start,*nobackslash,*t2;
  size_t idx,count,searchfield,flag,array_length,range_i;
  long check;
  int  was_read, backslashed;
  FILE *file;
  ID min_method, max_method;
  VALUE min_val, max_val;
  VALUE tmp_value, rest_args, filename;
  ID    array_length_method; /*----------------------------------------*/
  struct pair_st pairs[MAX_INTERVALS];

  VALUE ary;

  rb_scan_args(argc,argv,""1*"", &filename, &rest_args);

/*  if (argc == 0) {  // there should only be 1 or 2 arguments
    rb_raise(rb_eArgError, ""wrong number of arguments"");
  }

  file = fopen(StringValueCStr(argv[0]), ""r"");
  if (file == NULL)
    rb_raise(rb_eRuntimeError, ""File not found"");
*/
  file = fopen(StringValueCStr(filename), ""r"");
  if(file==NULL){
    rb_raise(rb_eRuntimeError, ""File not found"");
  }

  if (argc >1 ) { /* delimiter */
    tmp_value=rb_ary_entry(rest_args,0);
    DELIM=StringValueCStr(tmp_value);;
  }

  if (argc >2 ) { /* search index */
    tmp_value=rb_ary_entry(rest_args,1);
    searchfield=NUM2INT(tmp_value);
  }
  else{
    searchfield=-1;
  }

  array_length_method=rb_funcall(rest_args,rb_intern(""length""), 0);
  array_length=NUM2INT(array_length_method);

  min_method = rb_intern(""first"");
  max_method = rb_intern(""last"");
  /*------------test_id    = rb_intern(""class"");*/
  range_i=0;
  for(idx=2;idx<array_length;++idx){
    min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(""length""), 0);
    len2=NUM2INT(min_val);
    for(i=0;i<len2;++i){
      VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);
      if(range_i>MAX_INTERVALS)
        rb_raise(rb_eRuntimeError, ""Too much ranges passed"");
      if(TYPE(e) == T_NIL){
        pairs[range_i].low=LONG_MIN;
        pairs[range_i].high=LONG_MAX;

        continue; /* just skip nil */
      }
      if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))
        rb_raise(rb_eRuntimeError, ""Not range passed to Ccsv.foreach"");

      min_val=rb_funcall(e, min_method, 0);
      max_val=rb_funcall(e, max_method, 0);
      pairs[range_i].low=NUM2LONG(min_val);
      pairs[range_i].high=NUM2LONG(max_val);
      range_i++;
    }
  }
  pairs_count=range_i;

  /* main loop lines reading */

  while ((was_read=getline(&line, &len, file)) != -1) {

    if(was_read<1)
      continue;

    backslashed = 0;
    len=was_read-1;
    /* try to join escaped lines */
    for(;;) {
      /* check for backslashed newline */
      if(line[len]!=EOL)
        break;
      if(line[len]==CR){
        len-=1;
      }
      //rb_warn(""NONLAST (%c,%c)"",line[len],line[len]);
      count=0;
      t2=line+len-1;
      while((t2>=line) && (*t2=='\\'))
        {++count;--t2;}
      if(count%2 ==1){ /* backslashed! skip */
        /* get another line... */
        line2=NULL;
        len2=0;
        if((was_read=getline(&line2, &len2, file)) != -1) {
          len2=was_read;
          if(new_line)
            free(new_line); //!!!!
          new_line=malloc(len+len2+1);
          strcpy(new_line,line);
          new_line[len-1]='\n';
          strcpy(new_line+len,line2);
          line=new_line;
          //nobackslash=len+1;
          start=new_line;
          len+=len2-1;
          nobackslash=start;
          backslashed = 1;
          free(line);
          free(line2);
          continue;
        }
      }
      break;
    }
    /* chomp! */
    if(line[len]==EOL){
      if(line[len-1]==CR)
        len-=1;
      line[len]='\0';
    }
    /* skip empty line */
    if(len<2)
      continue;

    ary = rb_ary_new();
    start=line;
    nobackslash=line;

    idx = 0;
    flag=1;

    while (nobackslash != NULL) {

      /* get full field */
      while(token=strstr(nobackslash, DELIM)){
        count=0;
        t2=token-1;
        while((t2>=line) && (*t2=='\\'))
          {++count;--t2;}
        if(count%2 ==1){ /* backslashed! skip */
          nobackslash=token;
          continue;
        }
        break;
      }

      if(token)
        *token='\0';
      else
        token=start+strlen(start);

      if(searchfield==idx){
        flag=0;
        /* do check! */
        sscanf(start,""%ld"",&check);
        for(i=0;i<pairs_count;++i){
          /*rb_warn(""check %ld: [%ld .. %ld]"",check,pairs[i].low,pairs[i].high);*/
          if(pairs[i].low<check && pairs[i].high>check){
            /*rb_warn(""check passed"");*/
            flag=1; /* yahooo! */
            break;
          }
        }
      }

      /* not in ranges! */
      if(flag==0)
        break;

      rb_ary_store(ary, idx, rb_str_new(start, token-start));
      idx++;
      nobackslash=start=token+strlen(DELIM);
      while(token=strstr(nobackslash, DELIM)){
        count=0;
        t2=token-1;
        while((t2>=line) && (*t2=='\\'))
          {++count;--t2;}
        if(count%2 ==1){ /* backslashed! skip */
          nobackslash=token+strlen(DELIM);
          continue;
        }
        break;
      }
      nobackslash=token;
    }
    if(flag==0)
      continue;

    /* last item */
    rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));
    /* OBJ_FREEZE(ary); */

    rb_yield(ary);
    /* FL_UNSET((ary), FL_FREEZE); */

    /* for(idx = 0; idx < RARRAY_LEN(ary); idx ++) {
      rb_ary_store(ary, idx, Qnil);
    } */

  }
  fclose(file);
  if(!backslashed)
    free(line);

  return Qnil;
}","static VALUE foreach(int VAR_0, VALUE* VAR_1, VALUE VAR_2) {
  char *VAR_3=VAR_4;
  char *VAR_5 = NULL;
  char *VAR_6 =NULL, *VAR_7=NULL;
  size_t VAR_8 = 0, VAR_9=0, VAR_10, VAR_11;
  char *VAR_12,*VAR_13,*VAR_14,*VAR_15;
  size_t VAR_16,VAR_17,VAR_18,VAR_19,VAR_20,VAR_21;
  long VAR_22;
  int  VAR_23, VAR_24;
  FILE *VAR_25;
  ID VAR_26, VAR_27;
  VALUE VAR_28, VAR_29;
  VALUE VAR_30, VAR_31, VAR_32;
  ID    VAR_33; /* COMMENT_0 */
  struct pair_st VAR_34[VAR_35];

  VALUE VAR_36;

  rb_scan_args(VAR_0,VAR_1,""1*"", &VAR_32, &VAR_31);

/* COMMENT_1 */
                                                        
   

                                              
                   
                                                 
  
  VAR_25 = fopen(StringValueCStr(VAR_32), ""r"");
  if(VAR_25==NULL){
    rb_raise(VAR_37, ""File not found"");
  }

  if (VAR_0 >1 ) { /* COMMENT_9 */
    VAR_30=rb_ary_entry(VAR_31,0);
    VAR_3=StringValueCStr(VAR_30);;
  }

  if (VAR_0 >2 ) { /* COMMENT_10 */
    VAR_30=rb_ary_entry(VAR_31,1);
    VAR_18=NUM2INT(VAR_30);
  }
  else{
    VAR_18=-1;
  }

  VAR_33=rb_funcall(VAR_31,rb_intern(""length""), 0);
  VAR_20=NUM2INT(VAR_33);

  VAR_26 = rb_intern(""first"");
  VAR_27 = rb_intern(""last"");
  /* COMMENT_11 */
  VAR_21=0;
  for(VAR_16=2;VAR_16<VAR_20;++VAR_16){
    VAR_28=rb_funcall(rb_ary_entry(VAR_31,VAR_16),rb_intern(""length""), 0);
    VAR_9=NUM2INT(VAR_28);
    for(VAR_10=0;VAR_10<VAR_9;++VAR_10){
      VALUE VAR_38=rb_ary_entry(rb_ary_entry(VAR_31,VAR_16),VAR_10);
      if(VAR_21>VAR_35)
        rb_raise(VAR_37, ""Too much ranges passed"");
      if(TYPE(VAR_38) == VAR_39){
        VAR_34[VAR_21].low=VAR_40;
        VAR_34[VAR_21].high=VAR_41;

        continue; /* COMMENT_12 */
      }
      if (! (rb_respond_to(VAR_38, VAR_26) & rb_respond_to(VAR_38, VAR_27)))
        rb_raise(VAR_37, ""Not range passed to Ccsv.foreach"");

      VAR_28=rb_funcall(VAR_38, VAR_26, 0);
      VAR_29=rb_funcall(VAR_38, VAR_27, 0);
      VAR_34[VAR_21].low=NUM2LONG(VAR_28);
      VAR_34[VAR_21].high=NUM2LONG(VAR_29);
      VAR_21++;
    }
  }
  VAR_11=VAR_21;

  /* COMMENT_13 */

  while ((VAR_23=getline(&VAR_5, &VAR_8, VAR_25)) != -1) {

    if(VAR_23<1)
      continue;

    VAR_24 = 0;
    VAR_8=VAR_23-1;
    /* COMMENT_14 */
    for(;;) {
      /* COMMENT_15 */
      if(VAR_5[VAR_8]!=VAR_42)
        break;
      if(VAR_5[VAR_8]==VAR_43){
        VAR_8-=1;
      }
      /* COMMENT_16 */
      VAR_17=0;
      VAR_15=VAR_5+VAR_8-1;
      while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
        {++VAR_17;--VAR_15;}
      if(VAR_17%2 ==1){ /* COMMENT_17 */
        /* COMMENT_18 */
        VAR_6=NULL;
        VAR_9=0;
        if((VAR_23=getline(&VAR_6, &VAR_9, VAR_25)) != -1) {
          VAR_9=VAR_23;
          if(VAR_7)
            free(VAR_7); /* COMMENT_19 */
          VAR_7=malloc(VAR_8+VAR_9+1);
          strcpy(VAR_7,VAR_5);
          VAR_7[VAR_8-1]='\n';
          strcpy(VAR_7+VAR_8,VAR_6);
          VAR_5=VAR_7;
          /* COMMENT_20 */
          VAR_13=VAR_7;
          VAR_8+=VAR_9-1;
          VAR_14=VAR_13;
          VAR_24 = 1;
          free(VAR_5);
          free(VAR_6);
          continue;
        }
      }
      break;
    }
    /* COMMENT_21 */
    if(VAR_5[VAR_8]==VAR_42){
      if(VAR_5[VAR_8-1]==VAR_43)
        VAR_8-=1;
      VAR_5[VAR_8]='\0';
    }
    /* COMMENT_22 */
    if(VAR_8<2)
      continue;

    VAR_36 = rb_ary_new();
    VAR_13=VAR_5;
    VAR_14=VAR_5;

    VAR_16 = 0;
    VAR_19=1;

    while (VAR_14 != NULL) {

      /* COMMENT_23 */
      while(VAR_12=strstr(VAR_14, VAR_3)){
        VAR_17=0;
        VAR_15=VAR_12-1;
        while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
          {++VAR_17;--VAR_15;}
        if(VAR_17%2 ==1){ /* COMMENT_17 */
          VAR_14=VAR_12;
          continue;
        }
        break;
      }

      if(VAR_12)
        *VAR_12='\0';
      else
        VAR_12=VAR_13+strlen(VAR_13);

      if(VAR_18==VAR_16){
        VAR_19=0;
        /* COMMENT_24 */
        sscanf(VAR_13,""%ld"",&VAR_22);
        for(VAR_10=0;VAR_10<VAR_11;++VAR_10){
          /* COMMENT_25 */
          if(VAR_34[VAR_10].low<VAR_22 && VAR_34[VAR_10].high>VAR_22){
            /* COMMENT_26 */
            VAR_19=1; /* COMMENT_27 */
            break;
          }
        }
      }

      /* COMMENT_28 */
      if(VAR_19==0)
        break;

      rb_ary_store(VAR_36, VAR_16, rb_str_new(VAR_13, VAR_12-VAR_13));
      VAR_16++;
      VAR_14=VAR_13=VAR_12+strlen(VAR_3);
      while(VAR_12=strstr(VAR_14, VAR_3)){
        VAR_17=0;
        VAR_15=VAR_12-1;
        while((VAR_15>=VAR_5) && (*VAR_15=='\\'))
          {++VAR_17;--VAR_15;}
        if(VAR_17%2 ==1){ /* COMMENT_17 */
          VAR_14=VAR_12+strlen(VAR_3);
          continue;
        }
        break;
      }
      VAR_14=VAR_12;
    }
    if(VAR_19==0)
      continue;

    /* COMMENT_29 */
    rb_ary_store(VAR_36, VAR_16, rb_str_new(VAR_13, strlen(VAR_13)));
    /* COMMENT_30 */

    rb_yield(VAR_36);
    /* COMMENT_31 */

    /* COMMENT_32 */
                                   
        

  }
  fclose(VAR_25);
  if(!VAR_24)
    free(VAR_5);

  return VAR_44;
}",evan/ccsv/24e0b9b94c44a15b23475e821366239d53764dbd/ccsv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
   char *token,*start,*nobackslash,*t2;
   size_t idx,count,searchfield,flag,array_length,range_i;
   long check;
-  int  was_read;
+  int  was_read, backslashed;
   FILE *file;
   ID min_method, max_method;
   VALUE min_val, max_val;
@@ -83,6 +83,7 @@
     if(was_read<1)
       continue;
 
+    backslashed = 0;
     len=was_read-1;
     /* try to join escaped lines */
     for(;;) {
@@ -114,6 +115,7 @@
           start=new_line;
           len+=len2-1;
           nobackslash=start;
+          backslashed = 1;
           free(line);
           free(line2);
           continue;
@@ -134,7 +136,7 @@
     ary = rb_ary_new();
     start=line;
     nobackslash=line;
-    
+
     idx = 0;
     flag=1;
 
@@ -208,7 +210,8 @@
 
   }
   fclose(file);
-  free(line);
+  if(!backslashed)
+    free(line);
 
   return Qnil;
 }","{'deleted_lines': ['  int  was_read;', '    ', '  free(line);'], 'added_lines': ['  int  was_read, backslashed;', '    backslashed = 0;', '          backslashed = 1;', '', '  if(!backslashed)', '    free(line);']}",True,The foreach function in ext/ccsv.c in Ccsv 1.1.0 allows remote attackers to cause a denial of service (double free and application crash) or possibly have unspecified other impact via a crafted file.,5.5,MEDIUM,1,valid,2017-10-13T00:21:34Z,2
CVE-2017-16358,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,radareorg/radare2,Fix #8748 - Fix oobread on string search,d31c4d3cbdbe01ea3ded16a584de94149ecd31d9,https://github.com/radareorg/radare2/commit/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9,libr/bin/bin.c,string_scan_range,"static int string_scan_range(RList *list, const ut8 *buf, int min,
const ut64 from, const ut64 to, int type) {
ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
ut64 str_start, needle = from;
int count = 0, i, rc, runes;
int str_type = R_STRING_TYPE_DETECT;
if (type == -1) {
type = R_STRING_TYPE_DETECT;
}
if (!buf || !min) {
return -1;
}
while (needle < to) {
rc = r_utf8_decode (buf + needle, to - needle, NULL);
if (!rc) {
needle++;
continue;
}
if (type == R_STRING_TYPE_DETECT) {
char *w = (char *)buf + needle + rc;
if ((to - needle) > 4) {
bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
if (is_wide32) {
str_type = R_STRING_TYPE_WIDE32;
} else {
bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
}
} else {
str_type = R_STRING_TYPE_ASCII;
}
} else {
str_type = type;
}
runes = 0;
str_start = needle;
for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
RRune r = {0};
if (str_type == R_STRING_TYPE_WIDE32) {
rc = r_utf32le_decode (buf + needle, to - needle, &r);
if (rc) {
rc = 4;
}
} else if (str_type == R_STRING_TYPE_WIDE) {
rc = r_utf16le_decode (buf + needle, to - needle, &r);
if (rc == 1) {
rc = 2;
}
} else {
rc = r_utf8_decode (buf + needle, to - needle, &r);
if (rc > 1) {
str_type = R_STRING_TYPE_UTF8;
}
}
if (!rc) {
needle++;
break;
}
needle += rc;
if (r_isprint (r)) {
if (str_type == R_STRING_TYPE_WIDE32) {
if (r == 0xff) {
r = 0;
}
}
rc = r_utf8_encode (&tmp[i], r);
runes++;
} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\e"", (char)r)) {
if ((i + 32) < sizeof (tmp) && r < 28) {
tmp[i + 0] = '\\';
tmp[i + 1] = ""       abtnvfr             e""[r];
} else {
break;
}
rc = 2;
runes++;
} else {
break;
}
}
tmp[i++] = '\0';
if (runes >= min) {
if (str_type == R_STRING_TYPE_ASCII) {
int j;
for (j = 0; j < i; j++) {
char ch = tmp[j];
if (ch != '\n' && ch != '\r' && ch != '\t') {
if (!IS_PRINTABLE (tmp[j])) {
continue;
}
}
}
}
if (list) {
RBinString *new = R_NEW0 (RBinString);
if (!new) {
break;
}
new->type = str_type;
new->length = runes;
new->size = needle - str_start;
new->ordinal = count++;
switch (str_type) {
case R_STRING_TYPE_WIDE:
{
const ut8 *p = buf  + str_start - 2;
if (p[0] == 0xff && p[1] == 0xfe) {
str_start -= 2; }
}
break;
case R_STRING_TYPE_WIDE32:
{
const ut8 *p = buf  + str_start - 4;
if (p[0] == 0xff && p[1] == 0xfe) {
str_start -= 4; }
}
break;
}
new->paddr = new->vaddr = str_start;
new->string = r_str_ndup ((const char *)tmp, i);
r_list_append (list, new);
} else {
printf (""0x%08"" PFMT64x "" %s\n"", str_start, tmp);
}
}
}
return count;
}","static int string_scan_range(RList *VAR_0, const ut8 *VAR_1, int VAR_2,
const ut64 VAR_3, const ut64 VAR_4, int VAR_5) {
ut8 VAR_6[VAR_7];
ut64 VAR_8, VAR_9 = VAR_3;
int VAR_10 = 0, VAR_11, VAR_12, VAR_13;
int VAR_14 = VAR_15;
if (VAR_5 == -1) {
VAR_5 = VAR_15;
}
if (!VAR_1 || !VAR_2) {
return -1;
}
while (VAR_9 < VAR_4) {
VAR_12 = r_utf8_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, NULL);
if (!VAR_12) {
VAR_9++;
continue;
}
if (VAR_5 == VAR_15) {
char *VAR_16 = (char *)VAR_1 + VAR_9 + VAR_12;
if ((VAR_4 - VAR_9) > 4) {
bool VAR_17 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_16[0] && !VAR_16[1] && !VAR_16[2] && VAR_16[3] && !VAR_16[4];
if (VAR_17) {
VAR_14 = VAR_18;
} else {
bool VAR_19 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_16[0] && VAR_16[1] && !VAR_16[2];
VAR_14 = VAR_19? VAR_20: VAR_21;
}
} else {
VAR_14 = VAR_21;
}
} else {
VAR_14 = VAR_5;
}
VAR_13 = 0;
VAR_8 = VAR_9;
for (VAR_12 = VAR_11 = 0; VAR_11 < sizeof (VAR_6) - 3 && VAR_9 < VAR_4; VAR_11 += VAR_12) {
RRune VAR_22 = {0};
if (VAR_14 == VAR_18) {
VAR_12 = r_utf32le_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
if (VAR_12) {
VAR_12 = 4;
}
} else if (VAR_14 == VAR_20) {
VAR_12 = r_utf16le_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
if (VAR_12 == 1) {
VAR_12 = 2;
}
} else {
VAR_12 = r_utf8_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
if (VAR_12 > 1) {
VAR_14 = VAR_23;
}
}
if (!VAR_12) {
VAR_9++;
break;
}
VAR_9 += VAR_12;
if (r_isprint (VAR_22)) {
if (VAR_14 == VAR_18) {
if (VAR_22 == 0xff) {
VAR_22 = 0;
}
}
VAR_12 = r_utf8_encode (&VAR_6[VAR_11], VAR_22);
VAR_13++;
} else if (VAR_22 && VAR_22 < 0x100 && strchr (""\b\v\f\n\r\t\a\e"", (char)VAR_22)) {
if ((VAR_11 + 32) < sizeof (VAR_6) && VAR_22 < 28) {
VAR_6[VAR_11 + 0] = '\\';
VAR_6[VAR_11 + 1] = ""       abtnvfr             e""[VAR_22];
} else {
break;
}
VAR_12 = 2;
VAR_13++;
} else {
break;
}
}
VAR_6[VAR_11++] = '\0';
if (VAR_13 >= VAR_2) {
if (VAR_14 == VAR_21) {
int VAR_24;
for (VAR_24 = 0; VAR_24 < VAR_11; VAR_24++) {
char VAR_25 = VAR_6[VAR_24];
if (VAR_25 != '\n' && VAR_25 != '\r' && VAR_25 != '\t') {
if (!IS_PRINTABLE (VAR_6[VAR_24])) {
continue;
}
}
}
}
if (VAR_0) {
RBinString *VAR_26 = R_NEW0 (RBinString);
if (!VAR_26) {
break;
}
VAR_26->type = VAR_14;
VAR_26->length = VAR_13;
VAR_26->size = VAR_9 - VAR_8;
VAR_26->ordinal = VAR_10++;
switch (VAR_14) {
case VAR_20:
{
const ut8 *VAR_27 = VAR_1  + VAR_8 - 2;
if (VAR_27[0] == 0xff && VAR_27[1] == 0xfe) {
VAR_8 -= 2; 
}
}
break;
case VAR_18:
{
const ut8 *VAR_27 = VAR_1  + VAR_8 - 4;
if (VAR_27[0] == 0xff && VAR_27[1] == 0xfe) {
VAR_8 -= 4; 
}
}
break;
}
VAR_26->paddr = VAR_26->vaddr = VAR_8;
VAR_26->string = r_str_ndup ((const char *)VAR_6, VAR_11);
r_list_append (VAR_0, VAR_26);
} else {
printf (""0x%08"" VAR_28 "" %s\n"", VAR_8, VAR_6);
}
}
}
return VAR_10;
}",radareorg/radare2/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9/bin.c/vul/before/0.json,"static int string_scan_range(RList *list, const ut8 *buf, int min,
			      const ut64 from, const ut64 to, int type) {
	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
	ut64 str_start, needle = from;
	int count = 0, i, rc, runes;
	int str_type = R_STRING_TYPE_DETECT;

	if (type == -1) {
		type = R_STRING_TYPE_DETECT;
	}
	if (!buf || !min) {
		return -1;
	}
	while (needle < to) {
		rc = r_utf8_decode (buf + needle, to - needle, NULL);
		if (!rc) {
			needle++;
			continue;
		}

		if (type == R_STRING_TYPE_DETECT) {
			char *w = (char *)buf + needle + rc;
			if ((to - needle) > 4) {
				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
				if (is_wide32) {
					str_type = R_STRING_TYPE_WIDE32;
				} else {
					bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} else {
				str_type = R_STRING_TYPE_ASCII;
			}
		} else {
			str_type = type;
		}


		runes = 0;
		str_start = needle;

		/* Eat a whole C string */
		for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
			RRune r = {0};

			if (str_type == R_STRING_TYPE_WIDE32) {
				rc = r_utf32le_decode (buf + needle, to - needle, &r);
				if (rc) {
					rc = 4;
				}
			} else if (str_type == R_STRING_TYPE_WIDE) {
				rc = r_utf16le_decode (buf + needle, to - needle, &r);
				if (rc == 1) {
					rc = 2;
				}
			} else {
				rc = r_utf8_decode (buf + needle, to - needle, &r);
				if (rc > 1) {
					str_type = R_STRING_TYPE_UTF8;
				}
			}

			/* Invalid sequence detected */
			if (!rc) {
				needle++;
				break;
			}

			needle += rc;

			if (r_isprint (r)) {
				if (str_type == R_STRING_TYPE_WIDE32) {
					if (r == 0xff) {
						r = 0;
					}
				}
				rc = r_utf8_encode (&tmp[i], r);
				runes++;
				/* Print the escape code */
			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\e"", (char)r)) {
				if ((i + 32) < sizeof (tmp) && r < 28) {
					tmp[i + 0] = '\\';
					tmp[i + 1] = ""       abtnvfr             e""[r];
				} else {
					// string too long
					break;
				}
				rc = 2;
				runes++;
			} else {
				/* \0 marks the end of C-strings */
				break;
			}
		}

		tmp[i++] = '\0';

		if (runes >= min) {
			if (str_type == R_STRING_TYPE_ASCII) {
				// reduce false positives
				int j;
				for (j = 0; j < i; j++) {
					char ch = tmp[j];
					if (ch != '\n' && ch != '\r' && ch != '\t') {
						if (!IS_PRINTABLE (tmp[j])) {
							continue;
						}
					}
				}
			}
			if (list) {
				RBinString *new = R_NEW0 (RBinString);
				if (!new) {
					break;
				}
				new->type = str_type;
				new->length = runes;
				new->size = needle - str_start;
				new->ordinal = count++;
				// TODO: move into adjust_offset
				switch (str_type) {
				case R_STRING_TYPE_WIDE:
					if (str_start > 1) {
						const ut8 *p = buf + str_start - 2;
						if (p[0] == 0xff && p[1] == 0xfe) {
							str_start -= 2; // \xff\xfe
						}
					}
					break;
				case R_STRING_TYPE_WIDE32:
					if (str_start > 3) {
						const ut8 *p = buf + str_start - 4;
						if (p[0] == 0xff && p[1] == 0xfe) {
							str_start -= 4; // \xff\xfe\x00\x00
						}
					}
					break;
				}
				new->paddr = new->vaddr = str_start;
				new->string = r_str_ndup ((const char *)tmp, i);
				r_list_append (list, new);
			} else {
				// DUMP TO STDOUT. raw dumping for rabin2 -zzz
				printf (""0x%08"" PFMT64x "" %s\n"", str_start, tmp);
			}
		}
	}
	return count;
}","static int string_scan_range(RList *VAR_0, const ut8 *VAR_1, int VAR_2,
			      const ut64 VAR_3, const ut64 VAR_4, int VAR_5) {
	ut8 VAR_6[VAR_7];
	ut64 VAR_8, VAR_9 = VAR_3;
	int VAR_10 = 0, VAR_11, VAR_12, VAR_13;
	int VAR_14 = VAR_15;

	if (VAR_5 == -1) {
		VAR_5 = VAR_15;
	}
	if (!VAR_1 || !VAR_2) {
		return -1;
	}
	while (VAR_9 < VAR_4) {
		VAR_12 = r_utf8_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, NULL);
		if (!VAR_12) {
			VAR_9++;
			continue;
		}

		if (VAR_5 == VAR_15) {
			char *VAR_16 = (char *)VAR_1 + VAR_9 + VAR_12;
			if ((VAR_4 - VAR_9) > 4) {
				bool VAR_17 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_16[0] && !VAR_16[1] && !VAR_16[2] && VAR_16[3] && !VAR_16[4];
				if (VAR_17) {
					VAR_14 = VAR_18;
				} else {
					bool VAR_19 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_16[0] && VAR_16[1] && !VAR_16[2];
					VAR_14 = VAR_19? VAR_20: VAR_21;
				}
			} else {
				VAR_14 = VAR_21;
			}
		} else {
			VAR_14 = VAR_5;
		}


		VAR_13 = 0;
		VAR_8 = VAR_9;

		/* COMMENT_0 */
		for (VAR_12 = VAR_11 = 0; VAR_11 < sizeof (VAR_6) - 3 && VAR_9 < VAR_4; VAR_11 += VAR_12) {
			RRune VAR_22 = {0};

			if (VAR_14 == VAR_18) {
				VAR_12 = r_utf32le_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
				if (VAR_12) {
					VAR_12 = 4;
				}
			} else if (VAR_14 == VAR_20) {
				VAR_12 = r_utf16le_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
				if (VAR_12 == 1) {
					VAR_12 = 2;
				}
			} else {
				VAR_12 = r_utf8_decode (VAR_1 + VAR_9, VAR_4 - VAR_9, &VAR_22);
				if (VAR_12 > 1) {
					VAR_14 = VAR_23;
				}
			}

			/* COMMENT_1 */
			if (!VAR_12) {
				VAR_9++;
				break;
			}

			VAR_9 += VAR_12;

			if (r_isprint (VAR_22)) {
				if (VAR_14 == VAR_18) {
					if (VAR_22 == 0xff) {
						VAR_22 = 0;
					}
				}
				VAR_12 = r_utf8_encode (&VAR_6[VAR_11], VAR_22);
				VAR_13++;
				/* COMMENT_2 */
			} else if (VAR_22 && VAR_22 < 0x100 && strchr (""\b\v\f\n\r\t\a\e"", (char)VAR_22)) {
				if ((VAR_11 + 32) < sizeof (VAR_6) && VAR_22 < 28) {
					VAR_6[VAR_11 + 0] = '\\';
					VAR_6[VAR_11 + 1] = ""       abtnvfr             e""[VAR_22];
				} else {
					/* COMMENT_3 */
					break;
				}
				VAR_12 = 2;
				VAR_13++;
			} else {
				/* COMMENT_4 */
				break;
			}
		}

		VAR_6[VAR_11++] = '\0';

		if (VAR_13 >= VAR_2) {
			if (VAR_14 == VAR_21) {
				/* COMMENT_5 */
				int VAR_24;
				for (VAR_24 = 0; VAR_24 < VAR_11; VAR_24++) {
					char VAR_25 = VAR_6[VAR_24];
					if (VAR_25 != '\n' && VAR_25 != '\r' && VAR_25 != '\t') {
						if (!IS_PRINTABLE (VAR_6[VAR_24])) {
							continue;
						}
					}
				}
			}
			if (VAR_0) {
				RBinString *VAR_26 = R_NEW0 (RBinString);
				if (!VAR_26) {
					break;
				}
				VAR_26->type = VAR_14;
				VAR_26->length = VAR_13;
				VAR_26->size = VAR_9 - VAR_8;
				VAR_26->ordinal = VAR_10++;
				/* COMMENT_6 */
				switch (VAR_14) {
				case VAR_20:
					if (VAR_8 > 1) {
						const ut8 *VAR_27 = VAR_1 + VAR_8 - 2;
						if (VAR_27[0] == 0xff && VAR_27[1] == 0xfe) {
							VAR_8 -= 2; /* COMMENT_7 */
						}
					}
					break;
				case VAR_18:
					if (VAR_8 > 3) {
						const ut8 *VAR_27 = VAR_1 + VAR_8 - 4;
						if (VAR_27[0] == 0xff && VAR_27[1] == 0xfe) {
							VAR_8 -= 4; /* COMMENT_8 */
						}
					}
					break;
				}
				VAR_26->paddr = VAR_26->vaddr = VAR_8;
				VAR_26->string = r_str_ndup ((const char *)VAR_6, VAR_11);
				r_list_append (VAR_0, VAR_26);
			} else {
				/* COMMENT_9 */
				printf (""0x%08"" VAR_28 "" %s\n"", VAR_8, VAR_6);
			}
		}
	}
	return VAR_10;
}",radareorg/radare2/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9/bin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,16 +120,16 @@
 				// TODO: move into adjust_offset
 				switch (str_type) {
 				case R_STRING_TYPE_WIDE:
-					{
-						const ut8 *p = buf  + str_start - 2;
+					if (str_start > 1) {
+						const ut8 *p = buf + str_start - 2;
 						if (p[0] == 0xff && p[1] == 0xfe) {
 							str_start -= 2; // \xff\xfe
 						}
 					}
 					break;
 				case R_STRING_TYPE_WIDE32:
-					{
-						const ut8 *p = buf  + str_start - 4;
+					if (str_start > 3) {
+						const ut8 *p = buf + str_start - 4;
 						if (p[0] == 0xff && p[1] == 0xfe) {
 							str_start -= 4; // \xff\xfe\x00\x00
 						}","{'deleted_lines': ['\t\t\t\t\t{', '\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;', '\t\t\t\t\t{', '\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;'], 'added_lines': ['\t\t\t\t\tif (str_start > 1) {', '\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;', '\t\t\t\t\tif (str_start > 3) {', '\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;']}",True,"In radare 2.0.1, an out-of-bounds read vulnerability exists in string_scan_range() in libr/bin/bin.c when doing a string search.",7.8,HIGH,2,valid,2017-10-31T12:08:52Z,2
CVE-2017-1000472,['CWE-22'],AV:N/AC:M/Au:N/C:N/I:P/A:P,0,pocoproject/poco,"- fix Zip Decompress Parent Path Injection #1968 bug
- add valid patch check test
- add vulnearbility triggering zip archive and test
- remove temporary test output files
- if possible, redirect temporary file generation to temp directory or
- delete temporary files after tests",f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d,https://github.com/pocoproject/poco/commit/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d,Zip/src/ZipCommon.cpp,ZipCommon::isValidPath,"bool ZipCommon::isValidPath(const std::string& path)
{
if (path == "".."")
return false;
if (path.compare(0, 3, ""../"") == 0)
return false;
if (path.compare(0, 3, ""..\\"") == 0)
return false;
if (path.find(""/.."") != std::string::npos)
return false;
if (path.find(""\\.."") != std::string::npos)
return false;
return true;
}","bool ZipCommon::isValidPath(const std::string& VAR_0)
{
if (VAR_0 == "".."")
return false;
if (VAR_0.compare(0, 3, ""../"") == 0)
return false;
if (VAR_0.compare(0, 3, ""..\\"") == 0)
return false;
if (VAR_0.find(""/.."") != std::string::npos)
return false;
if (VAR_0.find(""\\.."") != std::string::npos)
return false;
return true;
}",pocoproject/poco/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d/ZipCommon.cpp/vul/before/0.json,"bool ZipCommon::isValidPath(const std::string& path)
{

	if (!Path(path).isRelative())
		return false;
	if (path == "".."")
		return false;
	if ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)
		return false;
	if ((path.size() >= 3) && path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/../"") != std::string::npos)
		return false;
	if (path.find(""\\..\\"") != std::string::npos)
		return false;
	if (path.find(""/..\\"") != std::string::npos)
		return false;
	if (path.find(""\\../"") != std::string::npos)
		return false;
	if ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)
		return false;
	if (path.size() > 0 && (path[0] == '/' || path[0] == '\\'))
		return false;
	return true;
}","bool ZipCommon::isValidPath(const std::string& VAR_0)
{

	if (!Path(VAR_0).isRelative())
		return false;
	if (VAR_0 == "".."")
		return false;
	if ((VAR_0.size() >= 3) && VAR_0.compare(0, 3, ""../"") == 0)
		return false;
	if ((VAR_0.size() >= 3) && VAR_0.compare(0, 3, ""..\\"") == 0)
		return false;
	if (VAR_0.find(""/../"") != std::string::npos)
		return false;
	if (VAR_0.find(""\\..\\"") != std::string::npos)
		return false;
	if (VAR_0.find(""/..\\"") != std::string::npos)
		return false;
	if (VAR_0.find(""\\../"") != std::string::npos)
		return false;
	if ((VAR_0.size() >= 2) && VAR_0.compare(0, 2, ""~/"") == 0)
		return false;
	if (VAR_0.size() > 0 && (VAR_0[0] == '/' || VAR_0[0] == '\\'))
		return false;
	return true;
}",pocoproject/poco/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d/ZipCommon.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,14 +1,25 @@
 bool ZipCommon::isValidPath(const std::string& path)
 {
+
+	if (!Path(path).isRelative())
+		return false;
 	if (path == "".."")
 		return false;
-	if (path.compare(0, 3, ""../"") == 0)
+	if ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)
 		return false;
-	if (path.compare(0, 3, ""..\\"") == 0)
+	if ((path.size() >= 3) && path.compare(0, 3, ""..\\"") == 0)
 		return false;
-	if (path.find(""/.."") != std::string::npos)
+	if (path.find(""/../"") != std::string::npos)
 		return false;
-	if (path.find(""\\.."") != std::string::npos)
+	if (path.find(""\\..\\"") != std::string::npos)
+		return false;
+	if (path.find(""/..\\"") != std::string::npos)
+		return false;
+	if (path.find(""\\../"") != std::string::npos)
+		return false;
+	if ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)
+		return false;
+	if (path.size() > 0 && (path[0] == '/' || path[0] == '\\'))
 		return false;
 	return true;
 }","{'deleted_lines': ['\tif (path.compare(0, 3, ""../"") == 0)', '\tif (path.compare(0, 3, ""..\\\\"") == 0)', '\tif (path.find(""/.."") != std::string::npos)', '\tif (path.find(""\\\\.."") != std::string::npos)'], 'added_lines': ['', '\tif (!Path(path).isRelative())', '\t\treturn false;', '\tif ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)', '\tif ((path.size() >= 3) && path.compare(0, 3, ""..\\\\"") == 0)', '\tif (path.find(""/../"") != std::string::npos)', '\tif (path.find(""\\\\..\\\\"") != std::string::npos)', '\t\treturn false;', '\tif (path.find(""/..\\\\"") != std::string::npos)', '\t\treturn false;', '\tif (path.find(""\\\\../"") != std::string::npos)', '\t\treturn false;', '\tif ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)', '\t\treturn false;', ""\tif (path.size() > 0 && (path[0] == '/' || path[0] == '\\\\'))""]}",True,"The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".",6.5,MEDIUM,1,valid,2017-11-02T00:25:24Z,2
CVE-2017-1000472,['CWE-22'],AV:N/AC:M/Au:N/C:N/I:P/A:P,0,pocoproject/poco,"- fix Zip Decompress Parent Path Injection #1968 bug
- add valid patch check test
- add vulnearbility triggering zip archive and test
- remove temporary test output files
- if possible, redirect temporary file generation to temp directory or
- delete temporary files after tests",f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d,https://github.com/pocoproject/poco/commit/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d,Zip/src/Decompress.cpp,Decompress::handleZipEntry,"bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)
{
if (hdr.isDirectory())
{
if (!_flattenDirs)
{
std::string dirName = hdr.getFileName();
if (!ZipCommon::isValidPath(dirName))
throw ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");
Poco::Path dir(_outDir, dirName);
dir.makeDirectory();
Poco::File aFile(dir);
aFile.createDirectories();
}
return true;
}
try
{
std::string fileName = hdr.getFileName();
if (_flattenDirs)
{
Poco::Path p(fileName);
p.makeFile();
fileName = p.getFileName();
}
if (!ZipCommon::isValidPath(fileName))
throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
Poco::Path file(fileName);
file.makeFile();
Poco::Path dest(_outDir, file);
dest.makeFile();
if (dest.depth() > 0)
{
Poco::File aFile(dest.parent());
aFile.createDirectories();
}
Poco::FileOutputStream out(dest.toString());
ZipInputStream inp(zipStream, hdr, false);
Poco::StreamCopier::copyStream(inp, out);
out.close();
Poco::File aFile(dest.toString());
if (!aFile.exists() || !aFile.isFile())
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Failed to create output stream "" + dest.toString());
EError.notify(this, tmp);
return false;
}
if (!inp.crcValid())
{
if (!_keepIncompleteFiles)
aFile.remove();
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + dest.toString());
EError.notify(this, tmp);
return false;
}
if (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
{
if (!_keepIncompleteFiles)
aFile.remove();
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + dest.toString());
EError.notify(this, tmp);
return false;
}
std::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);
EOk.notify(this, tmp);
}
catch (Poco::Exception& e)
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Exception: "" + e.displayText()));
EError.notify(this, tmp);
return false;
}
catch (...)
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Unknown Exception""));
EError.notify(this, tmp);
return false;
}
return true;
}","bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)
{
if (VAR_1.isDirectory())
{
if (!VAR_2)
{
std::string VAR_3 = VAR_1.getFileName();
if (!ZipCommon::isValidPath(VAR_3))
throw ZipException(""Illegal entry name "" + VAR_3 + "" containing parent directory reference"");
Poco::Path dir(_outDir, dirName);
VAR_4.makeDirectory();
Poco::File aFile(dir);
VAR_5.createDirectories();
}
return true;
}
try
{
std::string VAR_6 = VAR_1.getFileName();
if (VAR_2)
{
Poco::Path p(fileName);
VAR_7.makeFile();
fileName = VAR_7.getFileName();
}
if (!ZipCommon::isValidPath(fileName))
throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
Poco::Path file(fileName);
VAR_8.makeFile();
Poco::Path dest(_outDir, file);
VAR_9.makeFile();
if (VAR_9.depth() > 0)
{
Poco::File VAR_5(VAR_9.parent());
VAR_5.createDirectories();
}
Poco::FileOutputStream VAR_10(VAR_9.toString());
ZipInputStream inp(zipStream, hdr, false);
Poco::StreamCopier::copyStream(VAR_11, VAR_10);
VAR_10.close();
Poco::File VAR_5(VAR_9.toString());
if (!VAR_5.exists() || !VAR_5.isFile())
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Failed to create output stream "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
if (!VAR_11.crcValid())
{
if (!VAR_14)
VAR_5.remove();
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
if (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
{
if (!VAR_14)
VAR_5.remove();
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
std::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);
VAR_15.notify(this, VAR_12);
}
catch (Poco::Exception& VAR_16)
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Exception: "" + VAR_16.displayText()));
VAR_13.notify(this, VAR_12);
return false;
}
catch (...)
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Unknown Exception""));
VAR_13.notify(this, VAR_12);
return false;
}
return true;
}",,"bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)
{
	if (hdr.isDirectory())
	{
		// directory have 0 size, nth to read
		if (!_flattenDirs)
		{
			std::string dirName = hdr.getFileName();
			if (!ZipCommon::isValidPath(dirName))
				throw ZipException(""Illegal entry name "" + dirName);
			Poco::Path dir(_outDir, dirName);
			dir.makeDirectory();
			Poco::File aFile(dir);
			aFile.createDirectories();
		}
		return true;
	}
	try
	{
		std::string fileName = hdr.getFileName();
		if (_flattenDirs)
		{
			// remove path info
			Poco::Path p(fileName);
			p.makeFile();
			fileName = p.getFileName();
		}

		if (!ZipCommon::isValidPath(fileName))
			throw ZipException(""Illegal entry name "" + fileName);

		Poco::Path file(fileName);
		file.makeFile();
		Poco::Path dest(_outDir, file);
		dest.makeFile();
		if (dest.depth() > 0)
		{
			Poco::File aFile(dest.parent());
			aFile.createDirectories();
		}
		Poco::FileOutputStream out(dest.toString());
		ZipInputStream inp(zipStream, hdr, false);
		Poco::StreamCopier::copyStream(inp, out);
		out.close();
		Poco::File aFile(dest.toString());
		if (!aFile.exists() || !aFile.isFile())
		{
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Failed to create output stream "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		if (!inp.crcValid())
		{
			if (!_keepIncompleteFiles)
				aFile.remove();
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo
		// crc is typically enough to detect errors
		if (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
		{
			if (!_keepIncompleteFiles)
				aFile.remove();
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		std::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);
		EOk.notify(this, tmp);
	}
	catch (Poco::Exception& e)
	{
		std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Exception: "" + e.displayText()));
		EError.notify(this, tmp);
		return false;
	}
	catch (...)
	{
		std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Unknown Exception""));
		EError.notify(this, tmp);
		return false;
	}

	return true;
}","bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)
{
	if (VAR_1.isDirectory())
	{
		/* COMMENT_0 */
		if (!VAR_2)
		{
			std::string VAR_3 = VAR_1.getFileName();
			if (!ZipCommon::isValidPath(VAR_3))
				throw ZipException(""Illegal entry name "" + VAR_3);
			Poco::Path dir(_outDir, dirName);
			VAR_4.makeDirectory();
			Poco::File aFile(dir);
			VAR_5.createDirectories();
		}
		return true;
	}
	try
	{
		std::string VAR_6 = VAR_1.getFileName();
		if (VAR_2)
		{
			/* COMMENT_1 */
			Poco::Path p(fileName);
			VAR_7.makeFile();
			fileName = VAR_7.getFileName();
		}

		if (!ZipCommon::isValidPath(fileName))
			throw ZipException(""Illegal entry name "" + fileName);

		Poco::Path file(fileName);
		VAR_8.makeFile();
		Poco::Path dest(_outDir, file);
		VAR_9.makeFile();
		if (VAR_9.depth() > 0)
		{
			Poco::File VAR_5(VAR_9.parent());
			VAR_5.createDirectories();
		}
		Poco::FileOutputStream VAR_10(VAR_9.toString());
		ZipInputStream inp(zipStream, hdr, false);
		Poco::StreamCopier::copyStream(VAR_11, VAR_10);
		VAR_10.close();
		Poco::File VAR_5(VAR_9.toString());
		if (!VAR_5.exists() || !VAR_5.isFile())
		{
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Failed to create output stream "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		if (!VAR_11.crcValid())
		{
			if (!VAR_14)
				VAR_5.remove();
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		/* COMMENT_2 */
		/* COMMENT_3 */
		if (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
		{
			if (!VAR_14)
				VAR_5.remove();
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		std::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);
		VAR_15.notify(this, VAR_12);
	}
	catch (Poco::Exception& VAR_16)
	{
		std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Exception: "" + VAR_16.displayText()));
		VAR_13.notify(this, VAR_12);
		return false;
	}
	catch (...)
	{
		std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Unknown Exception""));
		VAR_13.notify(this, VAR_12);
		return false;
	}

	return true;
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 		{
 			std::string dirName = hdr.getFileName();
 			if (!ZipCommon::isValidPath(dirName))
-				throw ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");
+				throw ZipException(""Illegal entry name "" + dirName);
 			Poco::Path dir(_outDir, dirName);
 			dir.makeDirectory();
 			Poco::File aFile(dir);
@@ -27,7 +27,7 @@
 		}
 
 		if (!ZipCommon::isValidPath(fileName))
-			throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
+			throw ZipException(""Illegal entry name "" + fileName);
 
 		Poco::Path file(fileName);
 		file.makeFile();","{'deleted_lines': ['\t\t\t\tthrow ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");', '\t\t\tthrow ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");'], 'added_lines': ['\t\t\t\tthrow ZipException(""Illegal entry name "" + dirName);', '\t\t\tthrow ZipException(""Illegal entry name "" + fileName);']}",True,"The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".",6.5,MEDIUM,1,valid,2017-11-02T00:25:24Z,2
CVE-2017-1000472,['CWE-22'],AV:N/AC:M/Au:N/C:N/I:P/A:P,0,pocoproject/poco,merge zip entry absolute path vulnerability fix (#1968) from develop,bb7e5feece68ccfd8660caee93da25c5c39a4707,https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707,Zip/src/ZipStream.cpp,ZipStreamBuf::readFromDevice,"int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length)
{
if (!_ptrBuf) return 0; _ptrBuf->read(buffer, length);
int cnt = static_cast<int>(_ptrBuf->gcount());
if (cnt > 0)
{
_crc32.update(buffer, cnt);
}
else
{
if (_crc32.checksum() != _expectedCrc32)
{
if (_checkCRC)
throw ZipException(""CRC failure"");
else
{
ZipDataInfo nfo(*_pIstr, false);
Poco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());
_expectedCrc32 = nfo.getCRC32();
const char* rawHeader = nfo.getRawHeader();
_pIstr->seekg(-size, std::ios::cur);
if (!_pIstr->good()) throw Poco::IOException(""Failed to seek on input stream"");
if (!crcValid())
throw ZipException(""CRC failure"");
}
}
}
return cnt;
}","int ZipStreamBuf::readFromDevice(char* VAR_0, std::streamsize VAR_1)
{
if (!VAR_2) return 0; 
VAR_2->read(VAR_0, VAR_1);
int VAR_3 = VAR_4<int>(VAR_2->gcount());
if (VAR_3 > 0)
{
VAR_5.update(VAR_0, VAR_3);
}
else
{
if (VAR_5.checksum() != VAR_6)
{
if (VAR_7)
throw ZipException(""CRC failure"");
else
{
ZipDataInfo VAR_8(*VAR_9, false);
Poco::Int32 VAR_10 = VAR_4<Poco::Int32>(VAR_8.getFullHeaderSize());
VAR_6 = VAR_8.getCRC32();
const char* VAR_11 = VAR_8.getRawHeader();
VAR_9->seekg(-VAR_10, std::ios::cur);
if (!VAR_9->good()) throw Poco::IOException(""Failed to seek on input stream"");
if (!crcValid())
throw ZipException(""CRC failure"");
}
}
}
return VAR_3;
}",pocoproject/poco/bb7e5feece68ccfd8660caee93da25c5c39a4707/ZipStream.cpp/vul/before/0.json,"int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length)
{
	if (!_ptrBuf) return 0; // directory entry
	_ptrBuf->read(buffer, length);
	int cnt = static_cast<int>(_ptrBuf->gcount());
	if (cnt > 0)
	{
		_crc32.update(buffer, cnt);
	}
	else
	{
		if (_crc32.checksum() != _expectedCrc32)
		{
			if (_checkCRC)
				throw ZipException(""CRC failure"");
			else
			{
				// the CRC value is written directly after the data block
				// parse it directly from the input stream
				ZipDataInfo nfo(*_pIstr, false);
				// now push back the header to the stream, so that the ZipLocalFileHeader can read it
				Poco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());
				_expectedCrc32 = nfo.getCRC32();
				_pIstr->seekg(-size, std::ios::cur);
				if (!_pIstr->good()) throw Poco::IOException(""Failed to seek on input stream"");
				if (!crcValid())
					throw ZipException(""CRC failure"");
			}
		}
	}
	return cnt;
}","int ZipStreamBuf::readFromDevice(char* VAR_0, std::streamsize VAR_1)
{
	if (!VAR_2) return 0; /* COMMENT_0 */
	VAR_2->read(VAR_0, VAR_1);
	int VAR_3 = VAR_4<int>(VAR_2->gcount());
	if (VAR_3 > 0)
	{
		VAR_5.update(VAR_0, VAR_3);
	}
	else
	{
		if (VAR_5.checksum() != VAR_6)
		{
			if (VAR_7)
				throw ZipException(""CRC failure"");
			else
			{
				/* COMMENT_1 */
				/* COMMENT_2 */
				ZipDataInfo VAR_8(*VAR_9, false);
				/* COMMENT_3 */
				Poco::Int32 VAR_10 = VAR_4<Poco::Int32>(VAR_8.getFullHeaderSize());
				VAR_6 = VAR_8.getCRC32();
				VAR_9->seekg(-VAR_10, std::ios::cur);
				if (!VAR_9->good()) throw Poco::IOException(""Failed to seek on input stream"");
				if (!crcValid())
					throw ZipException(""CRC failure"");
			}
		}
	}
	return VAR_3;
}",pocoproject/poco/bb7e5feece68ccfd8660caee93da25c5c39a4707/ZipStream.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,6 @@
 				// now push back the header to the stream, so that the ZipLocalFileHeader can read it
 				Poco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());
 				_expectedCrc32 = nfo.getCRC32();
-				const char* rawHeader = nfo.getRawHeader();
 				_pIstr->seekg(-size, std::ios::cur);
 				if (!_pIstr->good()) throw Poco::IOException(""Failed to seek on input stream"");
 				if (!crcValid())","{'deleted_lines': ['\t\t\t\tconst char* rawHeader = nfo.getRawHeader();'], 'added_lines': []}",True,"The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".",6.5,MEDIUM,1,valid,2017-11-02T08:30:27Z,2
CVE-2017-1000472,['CWE-22'],AV:N/AC:M/Au:N/C:N/I:P/A:P,0,pocoproject/poco,merge zip entry absolute path vulnerability fix (#1968) from develop,bb7e5feece68ccfd8660caee93da25c5c39a4707,https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707,Zip/src/ZipCommon.cpp,ZipCommon::isValidPath,"bool ZipCommon::isValidPath(const std::string& path)
{
if (path == "".."")
return false;
if (path.compare(0, 3, ""../"") == 0)
return false;
if (path.compare(0, 3, ""..\\"") == 0)
return false;
if (path.find(""/.."") != std::string::npos)
return false;
if (path.find(""\\.."") != std::string::npos)
return false;
return true;
}","bool ZipCommon::isValidPath(const std::string& VAR_0)
{
if (VAR_0 == "".."")
return false;
if (VAR_0.compare(0, 3, ""../"") == 0)
return false;
if (VAR_0.compare(0, 3, ""..\\"") == 0)
return false;
if (VAR_0.find(""/.."") != std::string::npos)
return false;
if (VAR_0.find(""\\.."") != std::string::npos)
return false;
return true;
}",,"bool ZipCommon::isValidPath(const std::string& path)
{
	try
	{
		if (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())
			return false;
	}
	catch (...)
	{
		return false;
	}

	if (path == "".."")
		return false;
	if ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)
		return false;
	if ((path.size() >= 3) && path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/../"") != std::string::npos)
		return false;
	if (path.find(""\\..\\"") != std::string::npos)
		return false;
	if (path.find(""/..\\"") != std::string::npos)
		return false;
	if (path.find(""\\../"") != std::string::npos)
		return false;
	if ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)
		return false;

	return true;
}","bool ZipCommon::isValidPath(const std::string& VAR_0)
{
	try
	{
		if (Path(VAR_0, Path::PATH_UNIX).isAbsolute() || Path(VAR_0, Path::PATH_WINDOWS).isAbsolute())
			return false;
	}
	catch (...)
	{
		return false;
	}

	if (VAR_0 == "".."")
		return false;
	if ((VAR_0.size() >= 3) && VAR_0.compare(0, 3, ""../"") == 0)
		return false;
	if ((VAR_0.size() >= 3) && VAR_0.compare(0, 3, ""..\\"") == 0)
		return false;
	if (VAR_0.find(""/../"") != std::string::npos)
		return false;
	if (VAR_0.find(""\\..\\"") != std::string::npos)
		return false;
	if (VAR_0.find(""/..\\"") != std::string::npos)
		return false;
	if (VAR_0.find(""\\../"") != std::string::npos)
		return false;
	if ((VAR_0.size() >= 2) && VAR_0.compare(0, 2, ""~/"") == 0)
		return false;

	return true;
}",,"--- func_before
+++ func_after
@@ -1,14 +1,31 @@
 bool ZipCommon::isValidPath(const std::string& path)
 {
+	try
+	{
+		if (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())
+			return false;
+	}
+	catch (...)
+	{
+		return false;
+	}
+
 	if (path == "".."")
 		return false;
-	if (path.compare(0, 3, ""../"") == 0)
+	if ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)
 		return false;
-	if (path.compare(0, 3, ""..\\"") == 0)
+	if ((path.size() >= 3) && path.compare(0, 3, ""..\\"") == 0)
 		return false;
-	if (path.find(""/.."") != std::string::npos)
+	if (path.find(""/../"") != std::string::npos)
 		return false;
-	if (path.find(""\\.."") != std::string::npos)
+	if (path.find(""\\..\\"") != std::string::npos)
 		return false;
+	if (path.find(""/..\\"") != std::string::npos)
+		return false;
+	if (path.find(""\\../"") != std::string::npos)
+		return false;
+	if ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)
+		return false;
+
 	return true;
 }","{'deleted_lines': ['\tif (path.compare(0, 3, ""../"") == 0)', '\tif (path.compare(0, 3, ""..\\\\"") == 0)', '\tif (path.find(""/.."") != std::string::npos)', '\tif (path.find(""\\\\.."") != std::string::npos)'], 'added_lines': ['\ttry', '\t{', '\t\tif (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())', '\t\t\treturn false;', '\t}', '\tcatch (...)', '\t{', '\t\treturn false;', '\t}', '', '\tif ((path.size() >= 3) && path.compare(0, 3, ""../"") == 0)', '\tif ((path.size() >= 3) && path.compare(0, 3, ""..\\\\"") == 0)', '\tif (path.find(""/../"") != std::string::npos)', '\tif (path.find(""\\\\..\\\\"") != std::string::npos)', '\tif (path.find(""/..\\\\"") != std::string::npos)', '\t\treturn false;', '\tif (path.find(""\\\\../"") != std::string::npos)', '\t\treturn false;', '\tif ((path.size() >= 2) && path.compare(0, 2, ""~/"") == 0)', '\t\treturn false;', '']}",True,"The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".",6.5,MEDIUM,1,valid,2017-11-02T08:30:27Z,2
CVE-2017-1000472,['CWE-22'],AV:N/AC:M/Au:N/C:N/I:P/A:P,0,pocoproject/poco,merge zip entry absolute path vulnerability fix (#1968) from develop,bb7e5feece68ccfd8660caee93da25c5c39a4707,https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707,Zip/src/Decompress.cpp,Decompress::handleZipEntry,"bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)
{
if (hdr.isDirectory())
{
if (!_flattenDirs)
{
std::string dirName = hdr.getFileName();
if (!ZipCommon::isValidPath(dirName))
throw ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");
Poco::Path dir(_outDir, dirName);
dir.makeDirectory();
Poco::File aFile(dir);
aFile.createDirectories();
}
return true;
}
try
{
std::string fileName = hdr.getFileName();
if (_flattenDirs)
{
Poco::Path p(fileName);
p.makeFile();
fileName = p.getFileName();
}
if (!ZipCommon::isValidPath(fileName))
throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
Poco::Path file(fileName);
file.makeFile();
Poco::Path dest(_outDir, file);
dest.makeFile();
if (dest.depth() > 0)
{
Poco::File aFile(dest.parent());
aFile.createDirectories();
}
Poco::FileOutputStream out(dest.toString());
ZipInputStream inp(zipStream, hdr, false);
Poco::StreamCopier::copyStream(inp, out);
out.close();
Poco::File aFile(dest.toString());
if (!aFile.exists() || !aFile.isFile())
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Failed to create output stream "" + dest.toString());
EError.notify(this, tmp);
return false;
}
if (!inp.crcValid())
{
if (!_keepIncompleteFiles)
aFile.remove();
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + dest.toString());
EError.notify(this, tmp);
return false;
}
if (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
{
if (!_keepIncompleteFiles)
aFile.remove();
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + dest.toString());
EError.notify(this, tmp);
return false;
}
std::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);
EOk.notify(this, tmp);
}
catch (Poco::Exception& e)
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Exception: "" + e.displayText()));
EError.notify(this, tmp);
return false;
}
catch (...)
{
std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Unknown Exception""));
EError.notify(this, tmp);
return false;
}
return true;
}","bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)
{
if (VAR_1.isDirectory())
{
if (!VAR_2)
{
std::string VAR_3 = VAR_1.getFileName();
if (!ZipCommon::isValidPath(VAR_3))
throw ZipException(""Illegal entry name "" + VAR_3 + "" containing parent directory reference"");
Poco::Path dir(_outDir, dirName);
VAR_4.makeDirectory();
Poco::File aFile(dir);
VAR_5.createDirectories();
}
return true;
}
try
{
std::string VAR_6 = VAR_1.getFileName();
if (VAR_2)
{
Poco::Path p(fileName);
VAR_7.makeFile();
fileName = VAR_7.getFileName();
}
if (!ZipCommon::isValidPath(fileName))
throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
Poco::Path file(fileName);
VAR_8.makeFile();
Poco::Path dest(_outDir, file);
VAR_9.makeFile();
if (VAR_9.depth() > 0)
{
Poco::File VAR_5(VAR_9.parent());
VAR_5.createDirectories();
}
Poco::FileOutputStream VAR_10(VAR_9.toString());
ZipInputStream inp(zipStream, hdr, false);
Poco::StreamCopier::copyStream(VAR_11, VAR_10);
VAR_10.close();
Poco::File VAR_5(VAR_9.toString());
if (!VAR_5.exists() || !VAR_5.isFile())
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Failed to create output stream "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
if (!VAR_11.crcValid())
{
if (!VAR_14)
VAR_5.remove();
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
if (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
{
if (!VAR_14)
VAR_5.remove();
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + VAR_9.toString());
VAR_13.notify(this, VAR_12);
return false;
}
std::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);
VAR_15.notify(this, VAR_12);
}
catch (Poco::Exception& VAR_16)
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Exception: "" + VAR_16.displayText()));
VAR_13.notify(this, VAR_12);
return false;
}
catch (...)
{
std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Unknown Exception""));
VAR_13.notify(this, VAR_12);
return false;
}
return true;
}",,"bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)
{
	if (hdr.isDirectory())
	{
		// directory have 0 size, nth to read
		if (!_flattenDirs)
		{
			std::string dirName = hdr.getFileName();
			if (!ZipCommon::isValidPath(dirName))
				throw ZipException(""Illegal entry name"", dirName);
			Poco::Path dir(_outDir, dirName);
			dir.makeDirectory();
			Poco::File aFile(dir);
			aFile.createDirectories();
		}
		return true;
	}
	try
	{
		std::string fileName = hdr.getFileName();
		if (_flattenDirs)
		{
			// remove path info
			Poco::Path p(fileName);
			p.makeFile();
			fileName = p.getFileName();
		}

		if (!ZipCommon::isValidPath(fileName))
			throw ZipException(""Illegal entry name"", fileName);

		Poco::Path file(fileName);
		file.makeFile();
		Poco::Path dest(_outDir, file);
		dest.makeFile();
		if (dest.depth() > 0)
		{
			Poco::File aFile(dest.parent());
			aFile.createDirectories();
		}
		Poco::FileOutputStream out(dest.toString());
		ZipInputStream inp(zipStream, hdr, false);
		Poco::StreamCopier::copyStream(inp, out);
		out.close();
		Poco::File aFile(dest.toString());
		if (!aFile.exists() || !aFile.isFile())
		{
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Failed to create output stream "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		if (!inp.crcValid())
		{
			if (!_keepIncompleteFiles)
				aFile.remove();
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo
		// crc is typically enough to detect errors
		if (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
		{
			if (!_keepIncompleteFiles)
				aFile.remove();
			std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + dest.toString());
			EError.notify(this, tmp);
			return false;
		}

		std::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);
		EOk.notify(this, tmp);
	}
	catch (Poco::Exception& e)
	{
		std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Exception: "" + e.displayText()));
		EError.notify(this, tmp);
		return false;
	}
	catch (...)
	{
		std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Unknown Exception""));
		EError.notify(this, tmp);
		return false;
	}

	return true;
}","bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)
{
	if (VAR_1.isDirectory())
	{
		/* COMMENT_0 */
		if (!VAR_2)
		{
			std::string VAR_3 = VAR_1.getFileName();
			if (!ZipCommon::isValidPath(VAR_3))
				throw ZipException(""Illegal entry name"", VAR_3);
			Poco::Path dir(_outDir, dirName);
			VAR_4.makeDirectory();
			Poco::File aFile(dir);
			VAR_5.createDirectories();
		}
		return true;
	}
	try
	{
		std::string VAR_6 = VAR_1.getFileName();
		if (VAR_2)
		{
			/* COMMENT_1 */
			Poco::Path p(fileName);
			VAR_7.makeFile();
			fileName = VAR_7.getFileName();
		}

		if (!ZipCommon::isValidPath(fileName))
			throw ZipException(""Illegal entry name"", fileName);

		Poco::Path file(fileName);
		VAR_8.makeFile();
		Poco::Path dest(_outDir, file);
		VAR_9.makeFile();
		if (VAR_9.depth() > 0)
		{
			Poco::File VAR_5(VAR_9.parent());
			VAR_5.createDirectories();
		}
		Poco::FileOutputStream VAR_10(VAR_9.toString());
		ZipInputStream inp(zipStream, hdr, false);
		Poco::StreamCopier::copyStream(VAR_11, VAR_10);
		VAR_10.close();
		Poco::File VAR_5(VAR_9.toString());
		if (!VAR_5.exists() || !VAR_5.isFile())
		{
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Failed to create output stream "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		if (!VAR_11.crcValid())
		{
			if (!VAR_14)
				VAR_5.remove();
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		/* COMMENT_2 */
		/* COMMENT_3 */
		if (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())
		{
			if (!VAR_14)
				VAR_5.remove();
			std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + VAR_9.toString());
			VAR_13.notify(this, VAR_12);
			return false;
		}

		std::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);
		VAR_15.notify(this, VAR_12);
	}
	catch (Poco::Exception& VAR_16)
	{
		std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Exception: "" + VAR_16.displayText()));
		VAR_13.notify(this, VAR_12);
		return false;
	}
	catch (...)
	{
		std::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(""Unknown Exception""));
		VAR_13.notify(this, VAR_12);
		return false;
	}

	return true;
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 		{
 			std::string dirName = hdr.getFileName();
 			if (!ZipCommon::isValidPath(dirName))
-				throw ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");
+				throw ZipException(""Illegal entry name"", dirName);
 			Poco::Path dir(_outDir, dirName);
 			dir.makeDirectory();
 			Poco::File aFile(dir);
@@ -27,7 +27,7 @@
 		}
 
 		if (!ZipCommon::isValidPath(fileName))
-			throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");
+			throw ZipException(""Illegal entry name"", fileName);
 
 		Poco::Path file(fileName);
 		file.makeFile();","{'deleted_lines': ['\t\t\t\tthrow ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference"");', '\t\t\tthrow ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference"");'], 'added_lines': ['\t\t\t\tthrow ZipException(""Illegal entry name"", dirName);', '\t\t\tthrow ZipException(""Illegal entry name"", fileName);']}",True,"The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".",6.5,MEDIUM,1,valid,2017-11-02T08:30:27Z,2
CVE-2017-15128,['CWE-119'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"userfaultfd: hugetlbfs: prevent UFFDIO_COPY to fill beyond the end of i_size

This oops:

  kernel BUG at fs/hugetlbfs/inode.c:484!
  RIP: remove_inode_hugepages+0x3d0/0x410
  Call Trace:
    hugetlbfs_setattr+0xd9/0x130
    notify_change+0x292/0x410
    do_truncate+0x65/0xa0
    do_sys_ftruncate.constprop.3+0x11a/0x180
    SyS_ftruncate+0xe/0x10
    tracesys+0xd9/0xde

was caused by the lack of i_size check in hugetlb_mcopy_atomic_pte.

mmap() can still succeed beyond the end of the i_size after vmtruncate
zapped vmas in those ranges, but the faults must not succeed, and that
includes UFFDIO_COPY.

We could differentiate the retval to userland to represent a SIGBUS like
a page fault would do (vs SIGSEGV), but it doesn't seem very useful and
we'd need to pick a random retval as there's no meaningful syscall
retval that would differentiate from SIGSEGV and SIGBUS, there's just
-EFAULT.

Link: http://lkml.kernel.org/r/20171016223914.2421-2-aarcange@redhat.com
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1e3921471354244f70fe268586ff94a97a6dd4df,https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df,mm/hugetlb.c,hugetlb_mcopy_atomic_pte,"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
pte_t *dst_pte,
struct vm_area_struct *dst_vma,
unsigned long dst_addr,
unsigned long src_addr,
struct page **pagep)
{
int vm_shared = dst_vma->vm_flags & VM_SHARED;
struct hstate *h = hstate_vma(dst_vma);
pte_t _dst_pte;
spinlock_t *ptl;
int ret;
struct page *page;
if (!*pagep) {
ret = -ENOMEM;
page = alloc_huge_page(dst_vma, dst_addr, 0);
if (IS_ERR(page))
goto out;
ret = copy_huge_page_from_user(page,
(const void __user *) src_addr,
pages_per_huge_page(h), false);
if (unlikely(ret)) {
ret = -EFAULT;
*pagep = page;
goto out;
}
} else {
page = *pagep;
*pagep = NULL;
}
__SetPageUptodate(page);
set_page_huge_active(page);
if (vm_shared) {
struct address_space *mapping = dst_vma->vm_file->f_mapping;
pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);
ret = huge_add_to_page_cache(page, mapping, idx);
if (ret)
goto out_release_nounlock;
}
ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
spin_lock(ptl);
ret = -EEXIST;
if (!huge_pte_none(huge_ptep_get(dst_pte)))
goto out_release_unlock;
if (vm_shared) {
page_dup_rmap(page, true);
} else {
ClearPagePrivate(page);
hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
}
_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
if (dst_vma->vm_flags & VM_WRITE)
_dst_pte = huge_pte_mkdirty(_dst_pte);
_dst_pte = pte_mkyoung(_dst_pte);
set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);
(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
dst_vma->vm_flags & VM_WRITE);
hugetlb_count_add(pages_per_huge_page(h), dst_mm);
update_mmu_cache(dst_vma, dst_addr, dst_pte);
spin_unlock(ptl);
if (vm_shared)
unlock_page(page);
ret = 0;
out:
return ret;
out_release_unlock:
spin_unlock(ptl);
if (vm_shared)
unlock_page(page);
out_release_nounlock:
put_page(page);
goto out;
}","int hugetlb_mcopy_atomic_pte(struct mm_struct *VAR_0,
pte_t *VAR_1,
struct vm_area_struct *VAR_2,
unsigned long VAR_3,
unsigned long VAR_4,
struct page **VAR_5)
{
int VAR_6 = VAR_2->vm_flags & VAR_7;
struct hstate *VAR_8 = hstate_vma(VAR_2);
pte_t VAR_9;
spinlock_t *VAR_10;
int VAR_11;
struct page *page;
if (!*VAR_5) {
VAR_11 = -VAR_12;
page = alloc_huge_page(VAR_2, VAR_3, 0);
if (IS_ERR(page))
goto out;
VAR_11 = copy_huge_page_from_user(page,
(const void __user *) VAR_4,
pages_per_huge_page(VAR_8), false);
if (unlikely(VAR_11)) {
VAR_11 = -VAR_13;
*VAR_5 = page;
goto out;
}
} else {
page = *VAR_5;
*VAR_5 = NULL;
}
__SetPageUptodate(page);
set_page_huge_active(page);
if (VAR_6) {
struct address_space *VAR_14 = VAR_2->vm_file->f_mapping;
pgoff_t VAR_15 = vma_hugecache_offset(VAR_8, VAR_2, VAR_3);
VAR_11 = huge_add_to_page_cache(page, VAR_14, VAR_15);
if (VAR_11)
goto out_release_nounlock;
}
VAR_10 = huge_pte_lockptr(VAR_8, VAR_0, VAR_1);
spin_lock(VAR_10);
VAR_11 = -VAR_16;
if (!huge_pte_none(huge_ptep_get(VAR_1)))
goto out_release_unlock;
if (VAR_6) {
page_dup_rmap(page, true);
} else {
ClearPagePrivate(page);
hugepage_add_new_anon_rmap(page, VAR_2, VAR_3);
}
VAR_9 = make_huge_pte(VAR_2, page, VAR_2->vm_flags & VAR_17);
if (VAR_2->vm_flags & VAR_17)
VAR_9 = huge_pte_mkdirty(VAR_9);
VAR_9 = pte_mkyoung(VAR_9);
set_huge_pte_at(VAR_0, VAR_3, VAR_1, VAR_9);
(void)huge_ptep_set_access_flags(VAR_2, VAR_3, VAR_1, VAR_9,
VAR_2->vm_flags & VAR_17);
hugetlb_count_add(pages_per_huge_page(VAR_8), VAR_0);
update_mmu_cache(VAR_2, VAR_3, VAR_1);
spin_unlock(VAR_10);
if (VAR_6)
unlock_page(page);
VAR_11 = 0;
out:
return VAR_11;
out_release_unlock:
spin_unlock(VAR_10);
if (VAR_6)
unlock_page(page);
out_release_nounlock:
put_page(page);
goto out;
}",torvalds/linux/1e3921471354244f70fe268586ff94a97a6dd4df/hugetlb.c/vul/before/0.json,"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
			    pte_t *dst_pte,
			    struct vm_area_struct *dst_vma,
			    unsigned long dst_addr,
			    unsigned long src_addr,
			    struct page **pagep)
{
	struct address_space *mapping;
	pgoff_t idx;
	unsigned long size;
	int vm_shared = dst_vma->vm_flags & VM_SHARED;
	struct hstate *h = hstate_vma(dst_vma);
	pte_t _dst_pte;
	spinlock_t *ptl;
	int ret;
	struct page *page;

	if (!*pagep) {
		ret = -ENOMEM;
		page = alloc_huge_page(dst_vma, dst_addr, 0);
		if (IS_ERR(page))
			goto out;

		ret = copy_huge_page_from_user(page,
						(const void __user *) src_addr,
						pages_per_huge_page(h), false);

		/* fallback to copy_from_user outside mmap_sem */
		if (unlikely(ret)) {
			ret = -EFAULT;
			*pagep = page;
			/* don't free the page */
			goto out;
		}
	} else {
		page = *pagep;
		*pagep = NULL;
	}

	/*
	 * The memory barrier inside __SetPageUptodate makes sure that
	 * preceding stores to the page contents become visible before
	 * the set_pte_at() write.
	 */
	__SetPageUptodate(page);
	set_page_huge_active(page);

	mapping = dst_vma->vm_file->f_mapping;
	idx = vma_hugecache_offset(h, dst_vma, dst_addr);

	/*
	 * If shared, add to page cache
	 */
	if (vm_shared) {
		size = i_size_read(mapping->host) >> huge_page_shift(h);
		ret = -EFAULT;
		if (idx >= size)
			goto out_release_nounlock;

		/*
		 * Serialization between remove_inode_hugepages() and
		 * huge_add_to_page_cache() below happens through the
		 * hugetlb_fault_mutex_table that here must be hold by
		 * the caller.
		 */
		ret = huge_add_to_page_cache(page, mapping, idx);
		if (ret)
			goto out_release_nounlock;
	}

	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
	spin_lock(ptl);

	/*
	 * Recheck the i_size after holding PT lock to make sure not
	 * to leave any page mapped (as page_mapped()) beyond the end
	 * of the i_size (remove_inode_hugepages() is strict about
	 * enforcing that). If we bail out here, we'll also leave a
	 * page in the radix tree in the vm_shared case beyond the end
	 * of the i_size, but remove_inode_hugepages() will take care
	 * of it as soon as we drop the hugetlb_fault_mutex_table.
	 */
	size = i_size_read(mapping->host) >> huge_page_shift(h);
	ret = -EFAULT;
	if (idx >= size)
		goto out_release_unlock;

	ret = -EEXIST;
	if (!huge_pte_none(huge_ptep_get(dst_pte)))
		goto out_release_unlock;

	if (vm_shared) {
		page_dup_rmap(page, true);
	} else {
		ClearPagePrivate(page);
		hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
	}

	_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
	if (dst_vma->vm_flags & VM_WRITE)
		_dst_pte = huge_pte_mkdirty(_dst_pte);
	_dst_pte = pte_mkyoung(_dst_pte);

	set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);

	(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
					dst_vma->vm_flags & VM_WRITE);
	hugetlb_count_add(pages_per_huge_page(h), dst_mm);

	/* No need to invalidate - it was non-present before */
	update_mmu_cache(dst_vma, dst_addr, dst_pte);

	spin_unlock(ptl);
	if (vm_shared)
		unlock_page(page);
	ret = 0;
out:
	return ret;
out_release_unlock:
	spin_unlock(ptl);
	if (vm_shared)
		unlock_page(page);
out_release_nounlock:
	put_page(page);
	goto out;
}","int hugetlb_mcopy_atomic_pte(struct mm_struct *VAR_0,
			    pte_t *VAR_1,
			    struct vm_area_struct *VAR_2,
			    unsigned long VAR_3,
			    unsigned long VAR_4,
			    struct page **VAR_5)
{
	struct address_space *VAR_6;
	pgoff_t VAR_7;
	unsigned long VAR_8;
	int VAR_9 = VAR_2->vm_flags & VAR_10;
	struct hstate *VAR_11 = hstate_vma(VAR_2);
	pte_t VAR_12;
	spinlock_t *VAR_13;
	int VAR_14;
	struct page *page;

	if (!*VAR_5) {
		VAR_14 = -VAR_15;
		page = alloc_huge_page(VAR_2, VAR_3, 0);
		if (IS_ERR(page))
			goto out;

		VAR_14 = copy_huge_page_from_user(page,
						(const void __user *) VAR_4,
						pages_per_huge_page(VAR_11), false);

		/* COMMENT_0 */
		if (unlikely(VAR_14)) {
			VAR_14 = -VAR_16;
			*VAR_5 = page;
			/* COMMENT_1 */
			goto out;
		}
	} else {
		page = *VAR_5;
		*VAR_5 = NULL;
	}

	/* COMMENT_2 */
                                                               
                                                               
                           
    
	__SetPageUptodate(page);
	set_page_huge_active(page);

	VAR_6 = VAR_2->vm_file->f_mapping;
	VAR_7 = vma_hugecache_offset(VAR_11, VAR_2, VAR_3);

	/* COMMENT_7 */
                                
    
	if (VAR_9) {
		VAR_8 = i_size_read(VAR_6->host) >> huge_page_shift(VAR_11);
		VAR_14 = -VAR_16;
		if (VAR_7 >= VAR_8)
			goto out_release_nounlock;

		/* COMMENT_10 */
                                                       
                                                       
                                                        
                
     
		VAR_14 = huge_add_to_page_cache(page, VAR_6, VAR_7);
		if (VAR_14)
			goto out_release_nounlock;
	}

	VAR_13 = huge_pte_lockptr(VAR_11, VAR_0, VAR_1);
	spin_lock(VAR_13);

	/* COMMENT_16 */
                                                             
                                                              
                                                           
                                                            
                                                               
                                                              
                                                           
    
	VAR_8 = i_size_read(VAR_6->host) >> huge_page_shift(VAR_11);
	VAR_14 = -VAR_16;
	if (VAR_7 >= VAR_8)
		goto out_release_unlock;

	VAR_14 = -VAR_17;
	if (!huge_pte_none(huge_ptep_get(VAR_1)))
		goto out_release_unlock;

	if (VAR_9) {
		page_dup_rmap(page, true);
	} else {
		ClearPagePrivate(page);
		hugepage_add_new_anon_rmap(page, VAR_2, VAR_3);
	}

	VAR_12 = make_huge_pte(VAR_2, page, VAR_2->vm_flags & VAR_18);
	if (VAR_2->vm_flags & VAR_18)
		VAR_12 = huge_pte_mkdirty(VAR_12);
	VAR_12 = pte_mkyoung(VAR_12);

	set_huge_pte_at(VAR_0, VAR_3, VAR_1, VAR_12);

	(void)huge_ptep_set_access_flags(VAR_2, VAR_3, VAR_1, VAR_12,
					VAR_2->vm_flags & VAR_18);
	hugetlb_count_add(pages_per_huge_page(VAR_11), VAR_0);

	/* COMMENT_25 */
	update_mmu_cache(VAR_2, VAR_3, VAR_1);

	spin_unlock(VAR_13);
	if (VAR_9)
		unlock_page(page);
	VAR_14 = 0;
out:
	return VAR_14;
out_release_unlock:
	spin_unlock(VAR_13);
	if (VAR_9)
		unlock_page(page);
out_release_nounlock:
	put_page(page);
	goto out;
}",torvalds/linux/1e3921471354244f70fe268586ff94a97a6dd4df/hugetlb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
 			    unsigned long src_addr,
 			    struct page **pagep)
 {
+	struct address_space *mapping;
+	pgoff_t idx;
+	unsigned long size;
 	int vm_shared = dst_vma->vm_flags & VM_SHARED;
 	struct hstate *h = hstate_vma(dst_vma);
 	pte_t _dst_pte;
@@ -42,13 +45,24 @@
 	__SetPageUptodate(page);
 	set_page_huge_active(page);
 
+	mapping = dst_vma->vm_file->f_mapping;
+	idx = vma_hugecache_offset(h, dst_vma, dst_addr);
+
 	/*
 	 * If shared, add to page cache
 	 */
 	if (vm_shared) {
-		struct address_space *mapping = dst_vma->vm_file->f_mapping;
-		pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);
+		size = i_size_read(mapping->host) >> huge_page_shift(h);
+		ret = -EFAULT;
+		if (idx >= size)
+			goto out_release_nounlock;
 
+		/*
+		 * Serialization between remove_inode_hugepages() and
+		 * huge_add_to_page_cache() below happens through the
+		 * hugetlb_fault_mutex_table that here must be hold by
+		 * the caller.
+		 */
 		ret = huge_add_to_page_cache(page, mapping, idx);
 		if (ret)
 			goto out_release_nounlock;
@@ -56,6 +70,20 @@
 
 	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
 	spin_lock(ptl);
+
+	/*
+	 * Recheck the i_size after holding PT lock to make sure not
+	 * to leave any page mapped (as page_mapped()) beyond the end
+	 * of the i_size (remove_inode_hugepages() is strict about
+	 * enforcing that). If we bail out here, we'll also leave a
+	 * page in the radix tree in the vm_shared case beyond the end
+	 * of the i_size, but remove_inode_hugepages() will take care
+	 * of it as soon as we drop the hugetlb_fault_mutex_table.
+	 */
+	size = i_size_read(mapping->host) >> huge_page_shift(h);
+	ret = -EFAULT;
+	if (idx >= size)
+		goto out_release_unlock;
 
 	ret = -EEXIST;
 	if (!huge_pte_none(huge_ptep_get(dst_pte)))","{'deleted_lines': ['\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;', '\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);'], 'added_lines': ['\tstruct address_space *mapping;', '\tpgoff_t idx;', '\tunsigned long size;', '\tmapping = dst_vma->vm_file->f_mapping;', '\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);', '', '\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);', '\t\tret = -EFAULT;', '\t\tif (idx >= size)', '\t\t\tgoto out_release_nounlock;', '\t\t/*', '\t\t * Serialization between remove_inode_hugepages() and', '\t\t * huge_add_to_page_cache() below happens through the', '\t\t * hugetlb_fault_mutex_table that here must be hold by', '\t\t * the caller.', '\t\t */', '', '\t/*', '\t * Recheck the i_size after holding PT lock to make sure not', '\t * to leave any page mapped (as page_mapped()) beyond the end', '\t * of the i_size (remove_inode_hugepages() is strict about', ""\t * enforcing that). If we bail out here, we'll also leave a"", '\t * page in the radix tree in the vm_shared case beyond the end', '\t * of the i_size, but remove_inode_hugepages() will take care', '\t * of it as soon as we drop the hugetlb_fault_mutex_table.', '\t */', '\tsize = i_size_read(mapping->host) >> huge_page_shift(h);', '\tret = -EFAULT;', '\tif (idx >= size)', '\t\tgoto out_release_unlock;']}",True,A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13.12. A lack of size check could cause a denial of service (BUG).,5.5,MEDIUM,1,valid,2017-11-02T22:59:29Z,2
CVE-2017-18224,['CWE-362'],AV:L/AC:M/Au:N/C:N/I:N/A:P,0,torvalds/linux,"ocfs2: ip_alloc_sem should be taken in ocfs2_get_block()

ip_alloc_sem should be taken in ocfs2_get_block() when reading file in
DIRECT mode to prevent concurrent access to extent tree with
ocfs2_dio_end_io_write(), which may cause BUGON in the following
situation:

read file 'A'                                  end_io of writing file 'A'
vfs_read
 __vfs_read
  ocfs2_file_read_iter
   generic_file_read_iter
    ocfs2_direct_IO
     __blockdev_direct_IO
      do_blockdev_direct_IO
       do_direct_IO
        get_more_blocks
         ocfs2_get_block
          ocfs2_extent_map_get_blocks
           ocfs2_get_clusters
            ocfs2_get_clusters_nocache()
             ocfs2_search_extent_list
              return the index of record which
              contains the v_cluster, that is
              v_cluster > rec[i]->e_cpos.
                                                ocfs2_dio_end_io
                                                 ocfs2_dio_end_io_write
                                                  down_write(&oi->ip_alloc_sem);
                                                  ocfs2_mark_extent_written
                                                   ocfs2_change_extent_flag
                                                    ocfs2_split_extent
                                                     ...
                                                 --> modify the rec[i]->e_cpos, resulting
                                                     in v_cluster < rec[i]->e_cpos.
             BUG_ON(v_cluster < le32_to_cpu(rec->e_cpos))

[alex.chen@huawei.com: v3]
  Link: http://lkml.kernel.org/r/59EF3614.6050008@huawei.com
Link: http://lkml.kernel.org/r/59EF3614.6050008@huawei.com
Fixes: c15471f79506 (""ocfs2: fix sparse file & data ordering issue in direct io"")
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Reviewed-by: Gang He <ghe@suse.com>
Acked-by: Changwei Ge <ge.changwei@h3c.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3e4c56d41eef5595035872a2ec5a483f42e8917f,https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f,fs/ocfs2/aops.c,ocfs2_direct_IO,"static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
{
struct file *file = iocb->ki_filp;
struct inode *inode = file->f_mapping->host;
struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
get_block_t *get_block;
if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)
return 0;
if (iocb->ki_pos + iter->count > i_size_read(inode) &&
!ocfs2_supports_append_dio(osb))
return 0;
if (iov_iter_rw(iter) == READ)
get_block = ocfs2_get_block;
else
get_block = ocfs2_dio_get_block;
return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,
iter, get_block,
ocfs2_dio_end_io, NULL, 0);
}","static ssize_t ocfs2_direct_IO(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
struct file *file = VAR_0->ki_filp;
struct inode *inode = file->f_mapping->host;
struct ocfs2_super *VAR_2 = OCFS2_SB(inode->i_sb);
get_block_t *VAR_3;
if (OCFS2_I(inode)->ip_dyn_features & VAR_4)
return 0;
if (VAR_0->ki_pos + VAR_1->count > i_size_read(inode) &&
!ocfs2_supports_append_dio(VAR_2))
return 0;
if (iov_iter_rw(VAR_1) == VAR_5)
VAR_3 = VAR_6;
else
VAR_3 = VAR_7;
return __blockdev_direct_IO(VAR_0, inode, inode->i_sb->s_bdev,
VAR_1, VAR_3,
VAR_8, NULL, 0);
}",torvalds/linux/3e4c56d41eef5595035872a2ec5a483f42e8917f/aops.c/vul/before/0.json,"static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
{
	struct file *file = iocb->ki_filp;
	struct inode *inode = file->f_mapping->host;
	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
	get_block_t *get_block;

	/*
	 * Fallback to buffered I/O if we see an inode without
	 * extents.
	 */
	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)
		return 0;

	/* Fallback to buffered I/O if we do not support append dio. */
	if (iocb->ki_pos + iter->count > i_size_read(inode) &&
	    !ocfs2_supports_append_dio(osb))
		return 0;

	if (iov_iter_rw(iter) == READ)
		get_block = ocfs2_lock_get_block;
	else
		get_block = ocfs2_dio_wr_get_block;

	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,
				    iter, get_block,
				    ocfs2_dio_end_io, NULL, 0);
}","static ssize_t ocfs2_direct_IO(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
	struct file *file = VAR_0->ki_filp;
	struct inode *inode = file->f_mapping->host;
	struct ocfs2_super *VAR_2 = OCFS2_SB(inode->i_sb);
	get_block_t *VAR_3;

	/* COMMENT_0 */
                                                       
            
    
	if (OCFS2_I(inode)->ip_dyn_features & VAR_4)
		return 0;

	/* COMMENT_4 */
	if (VAR_0->ki_pos + VAR_1->count > i_size_read(inode) &&
	    !ocfs2_supports_append_dio(VAR_2))
		return 0;

	if (iov_iter_rw(VAR_1) == VAR_5)
		VAR_3 = VAR_6;
	else
		VAR_3 = VAR_7;

	return __blockdev_direct_IO(VAR_0, inode, inode->i_sb->s_bdev,
				    VAR_1, VAR_3,
				    VAR_8, NULL, 0);
}",torvalds/linux/3e4c56d41eef5595035872a2ec5a483f42e8917f/aops.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,9 +18,9 @@
 		return 0;
 
 	if (iov_iter_rw(iter) == READ)
-		get_block = ocfs2_get_block;
+		get_block = ocfs2_lock_get_block;
 	else
-		get_block = ocfs2_dio_get_block;
+		get_block = ocfs2_dio_wr_get_block;
 
 	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,
 				    iter, get_block,","{'deleted_lines': ['\t\tget_block = ocfs2_get_block;', '\t\tget_block = ocfs2_dio_get_block;'], 'added_lines': ['\t\tget_block = ocfs2_lock_get_block;', '\t\tget_block = ocfs2_dio_wr_get_block;']}",True,"In the Linux kernel before 4.15, fs/ocfs2/aops.c omits use of a semaphore and consequently has a race condition for access to the extent tree during read operations in DIRECT mode, which allows local users to cause a denial of service (BUG) by modifying a certain e_cpos field.",4.7,MEDIUM,1,valid,2017-11-16T01:31:44Z,2
CVE-2017-15592,['CWE-668'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: correct SH_LINEAR mapping detection in sh_guess_wrmap()

The fix for XSA-243 / CVE-2017-15592 (c/s bf2b4eadcf379) introduced a change
in behaviour for sh_guest_wrmap(), where it had to cope with no shadow linear
mapping being present.

As the name suggests, guest_vtable is a mapping of the guests pagetable, not
Xen's pagetable, meaning that it isn't the pagetable we need to check for the
shadow linear slot in.

The practical upshot is that a shadow HVM vcpu which switches into 4-level
paging mode, with an L4 pagetable that contains a mapping which aliases Xen's
SH_LINEAR_PT_VIRT_START will fool the safety check for whether a SHADOW_LINEAR
mapping is present.  As the check passes (when it should have failed), Xen
subsequently falls over the missing mapping with a pagefault such as:

    (XEN) Pagetable walk from ffff8140a0503880:
    (XEN)  L4[0x102] = 000000046c218063 ffffffffffffffff
    (XEN)  L3[0x102] = 000000046c218063 ffffffffffffffff
    (XEN)  L2[0x102] = 000000046c218063 ffffffffffffffff
    (XEN)  L1[0x103] = 0000000000000000 ffffffffffffffff

This is part of XSA-243.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Tim Deegan <tim@xen.org>",d20daf4294adbdb9316850566013edb98db7bfbc,https://github.com/xen-project/xen/commit/d20daf4294adbdb9316850566013edb98db7bfbc,xen/arch/x86/mm/shadow/multi.c,sh_guess_wrmap,"static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)
{
struct domain *d = v->domain;
shadow_l1e_t sl1e, *sl1p;
shadow_l2e_t *sl2p;
shadow_l3e_t *sl3p;
#if SHADOW_PAGING_LEVELS >= 4
shadow_l4e_t *sl4p;
#endif
mfn_t sl1mfn;
int r;
#if SHADOW_PAGING_LEVELS >= 4
sl4p  = v->arch.paging.shadow.guest_vtable;
sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);
if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
return 0;
sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
return 0;
sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);
if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
return 0;
#else 
sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)
+ shadow_l3_linear_offset(vaddr);
if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
return 0;
#endif
sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);
if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )
return 0;
sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);
sl1e = *sl1p;
if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
!= (_PAGE_PRESENT|_PAGE_RW))
|| (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )
return 0;
sl1mfn = shadow_l2e_get_mfn(*sl2p);
sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);
if ( r & SHADOW_SET_ERROR ) {
return 0;
}
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);
return 1;
}","static int sh_guess_wrmap(struct vcpu *VAR_0, unsigned long VAR_1, mfn_t VAR_2)
{
struct domain *VAR_3 = VAR_0->domain;
shadow_l1e_t VAR_4, *VAR_5;
shadow_l2e_t *VAR_6;
shadow_l3e_t *VAR_7;
#if VAR_8 >= 4
shadow_l4e_t *VAR_9;
#endif
mfn_t VAR_10;
int VAR_11;
#if VAR_8 >= 4
VAR_9  = VAR_0->arch.paging.shadow.guest_vtable;
VAR_9 += shadow_l4_table_offset(VAR_12);
if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_13) )
return 0;
VAR_9 = sh_linear_l4_table(VAR_0) + shadow_l4_linear_offset(VAR_1);
if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_13) )
return 0;
VAR_7 = sh_linear_l3_table(VAR_0) + shadow_l3_linear_offset(VAR_1);
if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_13) )
return 0;
#else 
VAR_7 = ((shadow_l3e_t *) VAR_0->arch.paging.shadow.l3table)
+ shadow_l3_linear_offset(VAR_1);
if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_13) )
return 0;
#endif
VAR_6 = sh_linear_l2_table(VAR_0) + shadow_l2_linear_offset(VAR_1);
if ( !(shadow_l2e_get_flags(*VAR_6) & VAR_13) )
return 0;
VAR_5 = sh_linear_l1_table(VAR_0) + shadow_l1_linear_offset(VAR_1);
VAR_4 = *VAR_5;
if ( ((shadow_l1e_get_flags(VAR_4) & (VAR_13|VAR_14))
!= (VAR_13|VAR_14))
|| (mfn_x(shadow_l1e_get_mfn(VAR_4)) != mfn_x(VAR_2)) )
return 0;
VAR_10 = shadow_l2e_get_mfn(*VAR_6);
VAR_4 = shadow_l1e_remove_flags(VAR_4, VAR_14);
VAR_11 = shadow_set_l1e(VAR_3, VAR_5, VAR_4, VAR_15, VAR_10);
if ( VAR_11 & VAR_16 ) {
return 0;
}
TRACE_SHADOW_PATH_FLAG(VAR_17);
return 1;
}",xen-project/xen/d20daf4294adbdb9316850566013edb98db7bfbc/multi.c/vul/before/0.json,"static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)
/* Look up this vaddr in the current shadow and see if it's a writeable
 * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */
{
    struct domain *d = v->domain;
    shadow_l1e_t sl1e, *sl1p;
    shadow_l2e_t *sl2p;
    shadow_l3e_t *sl3p;
#if SHADOW_PAGING_LEVELS >= 4
    shadow_l4e_t *sl4p;
#endif
    mfn_t sl1mfn;
    int r;

    /* Carefully look in the shadow linear map for the l1e we expect */
#if SHADOW_PAGING_LEVELS >= 4
    /*
     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the
     * moment their shadows are created.  External guests (i.e. HVM) may not,
     * but always have a regular linear mapping, which we can use to observe
     * whether a SHADOW_LINEAR mapping is present.
     */
    if ( paging_mode_external(d) )
    {
        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);
        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
            return 0;
    }
    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
        return 0;
    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);
    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
        return 0;
#else /* SHADOW_PAGING_LEVELS == 3 */
    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)
        + shadow_l3_linear_offset(vaddr);
    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )
        return 0;
#endif
    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);
    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )
        return 0;
    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);
    sl1e = *sl1p;
    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
          != (_PAGE_PRESENT|_PAGE_RW))
         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )
        return 0;

    /* Found it!  Need to remove its write permissions. */
    sl1mfn = shadow_l2e_get_mfn(*sl2p);
    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);
    if ( r & SHADOW_SET_ERROR ) {
        /* Can only currently happen if we found a grant-mapped
         * page.  Just make the guess fail. */
        return 0;
    }
    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);
    return 1;
}","static int sh_guess_wrmap(struct vcpu *VAR_0, unsigned long VAR_1, mfn_t VAR_2)
/* COMMENT_0 */
                                                                       
{
    struct domain *VAR_3 = VAR_0->domain;
    shadow_l1e_t VAR_4, *VAR_5;
    shadow_l2e_t *VAR_6;
    shadow_l3e_t *VAR_7;
#if VAR_8 >= 4
    shadow_l4e_t *VAR_9;
#endif
    mfn_t VAR_10;
    int VAR_11;

    /* COMMENT_2 */
#if VAR_8 >= 4
    /* COMMENT_3 */
                                                                          
                                                                             
                                                                            
                                                  
       
    if ( paging_mode_external(VAR_3) )
    {
        VAR_9 =  VAR_12 + l4_linear_offset(VAR_13);
        if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_14) )
            return 0;
    }
    VAR_9 = sh_linear_l4_table(VAR_0) + shadow_l4_linear_offset(VAR_1);
    if ( !(shadow_l4e_get_flags(*VAR_9) & VAR_14) )
        return 0;
    VAR_7 = sh_linear_l3_table(VAR_0) + shadow_l3_linear_offset(VAR_1);
    if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_14) )
        return 0;
#else /* COMMENT_9 */
    VAR_7 = ((shadow_l3e_t *) VAR_0->arch.paging.shadow.l3table)
        + shadow_l3_linear_offset(VAR_1);
    if ( !(shadow_l3e_get_flags(*VAR_7) & VAR_14) )
        return 0;
#endif
    VAR_6 = sh_linear_l2_table(VAR_0) + shadow_l2_linear_offset(VAR_1);
    if ( !(shadow_l2e_get_flags(*VAR_6) & VAR_14) )
        return 0;
    VAR_5 = sh_linear_l1_table(VAR_0) + shadow_l1_linear_offset(VAR_1);
    VAR_4 = *VAR_5;
    if ( ((shadow_l1e_get_flags(VAR_4) & (VAR_14|VAR_15))
          != (VAR_14|VAR_15))
         || (mfn_x(shadow_l1e_get_mfn(VAR_4)) != mfn_x(VAR_2)) )
        return 0;

    /* COMMENT_10 */
    VAR_10 = shadow_l2e_get_mfn(*VAR_6);
    VAR_4 = shadow_l1e_remove_flags(VAR_4, VAR_15);
    VAR_11 = shadow_set_l1e(VAR_3, VAR_5, VAR_4, VAR_16, VAR_10);
    if ( VAR_11 & VAR_17 ) {
        /* COMMENT_11 */
                                              
        return 0;
    }
    TRACE_SHADOW_PATH_FLAG(VAR_18);
    return 1;
}",xen-project/xen/d20daf4294adbdb9316850566013edb98db7bfbc/multi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,11 +14,18 @@
 
     /* Carefully look in the shadow linear map for the l1e we expect */
 #if SHADOW_PAGING_LEVELS >= 4
-    /* Is a shadow linear map is installed in the first place? */
-    sl4p  = v->arch.paging.shadow.guest_vtable;
-    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);
-    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
-        return 0;
+    /*
+     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the
+     * moment their shadows are created.  External guests (i.e. HVM) may not,
+     * but always have a regular linear mapping, which we can use to observe
+     * whether a SHADOW_LINEAR mapping is present.
+     */
+    if ( paging_mode_external(d) )
+    {
+        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);
+        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
+            return 0;
+    }
     sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);
     if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )
         return 0;","{'deleted_lines': ['    /* Is a shadow linear map is installed in the first place? */', '    sl4p  = v->arch.paging.shadow.guest_vtable;', '    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);', '    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )', '        return 0;'], 'added_lines': ['    /*', '     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the', '     * moment their shadows are created.  External guests (i.e. HVM) may not,', '     * but always have a regular linear mapping, which we can use to observe', '     * whether a SHADOW_LINEAR mapping is present.', '     */', '    if ( paging_mode_external(d) )', '    {', '        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);', '        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )', '            return 0;', '    }']}",True,An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.,8.8,HIGH,2,valid,2017-11-16T09:38:14Z,2
CVE-2017-16883,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libming,"Fix NULL pointer deref in outputSWF_TEXT_RECORD

fip and fip_current are static pointers to a linked list containing
fonts information. This list and the two pointers are initialized and
filled by saveFontInfo() (called by the outputSWF_DEFINEFONTxxxx()
functions when defining new fonts).

In the case where no font is defined, saveFontInfo() is never called
and the two list pointers are NULL.

This situation may trigger a NULL pointer dereference in
outputSWF_TEXT_RECORD. In this patch, we check for !fip_current
before dereferencing it. In the == NULL case, we print a warning and
continue.

This commit addresses CVE-2017-16883 (fixes #77).",f3a66c6479d1191734b5ab57d5d7e0bd7525b1a7,https://github.com/libming/libming/commit/f3a66c6479d1191734b5ab57d5d7e0bd7525b1a7,util/outputscript.c,outputSWF_TEXT_RECORD,"static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)
{
int i=0;
struct FONTINFO *fi=fip;
if ( trec->TextRecordType == 0 )
return;
if (trec->StyleFlagHasFont)
{
printf(""%s("" VAR ""f%d);\n"", methodcall (tname, ""setFont""), trec->FontID);
printf(""%s(%d);\n"",methodcall(tname,""setHeight""),trec->TextHeight);
}
if( trec->StyleFlagHasColor )
{
if (level==2)
printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);
else
printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);
}
if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) 
{
printf (""%s(%d, %d);\n"", methodcall (tname, ""moveTo""),trec->XOffset,trec->YOffset);
}
if (trec->FontID) 
{
id=trec->FontID;
}
if (!trec->StyleFlagHasFont)
{
fi = fip_current;
id = fi->fontcodeID;
}
while (fi)
{
if (fi->fontcodeID==id)
{
fip_current=fi;
for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)
{
int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
if (off<fi->fontcodearrsize)
buffer[i]=fi->fontcodeptr[off];
else
buffer[i]='?';
} 
buffer[i]='\0'; 
return;
}
else
fi=fi->next;
}
buffer[0]='X';
buffer[1]='\0'; 
}","static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *VAR_0, int VAR_1,char *VAR_2,char *VAR_3,int VAR_4,int VAR_5)
{
int VAR_6=0;
struct FONTINFO *VAR_7=VAR_8;
if ( VAR_0->TextRecordType == 0 )
return;
if (VAR_0->StyleFlagHasFont)
{
printf(""%s("" VAR_9 ""f%d);\n"", methodcall (VAR_2, ""setFont""), VAR_0->FontID);
printf(""%s(%d);\n"",methodcall(VAR_2,""setHeight""),VAR_0->TextHeight);
}
if( VAR_0->StyleFlagHasColor )
{
if (VAR_1==2)
printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue, VAR_0->TextColor.alpha);
else
printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue);
}
if( VAR_0->StyleFlagHasYOffset || VAR_0->StyleFlagHasXOffset ) 
{
printf (""%s(%d, %d);\n"", methodcall (VAR_2, ""moveTo""),VAR_0->XOffset,VAR_0->YOffset);
}
if (VAR_0->FontID) 
{
VAR_5=VAR_0->FontID;
}
if (!VAR_0->StyleFlagHasFont)
{
VAR_7 = VAR_10;
VAR_5 = VAR_7->fontcodeID;
}
while (VAR_7)
{
if (VAR_7->fontcodeID==VAR_5)
{
VAR_10=VAR_7;
for(VAR_6=0;VAR_6<VAR_0->GlyphCount && VAR_6<VAR_4-1 ;VAR_6++)
{
int VAR_11=(&(VAR_0->GlyphEntries[VAR_6]))->GlyphIndex[0];
if (VAR_11<VAR_7->fontcodearrsize)
VAR_3[VAR_6]=VAR_7->fontcodeptr[VAR_11];
else
VAR_3[VAR_6]='?';
} 
VAR_3[VAR_6]='\0'; 
return;
}
else
VAR_7=VAR_7->next;
}
VAR_3[0]='X';
VAR_3[1]='\0'; 
}",libming/f3a66c6479d1191734b5ab57d5d7e0bd7525b1a7/outputscript.c/vul/before/0.json,"static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)
{
  int i=0;
  struct FONTINFO *fi=fip;
  if ( trec->TextRecordType == 0 )
    return;
  if (trec->StyleFlagHasFont)
  {
   printf(""%s("" VAR ""f%d);\n"", methodcall (tname, ""setFont""), trec->FontID);
   printf(""%s(%d);\n"",methodcall(tname,""setHeight""),trec->TextHeight);
  }
  if( trec->StyleFlagHasColor )
  {
   if (level==2)
    printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);
   else
    printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);
  }
  if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) 
  {
    printf (""%s(%d, %d);\n"", methodcall (tname, ""moveTo""),trec->XOffset,trec->YOffset);
  }
  if (trec->FontID) 
  {
    id=trec->FontID;
  }
  if (!trec->StyleFlagHasFont)				/* always check flag before use data */
  {
   fi = fip_current;					/* so cont w current font */

   if (!fi)
      SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
   else
      id = fi->fontcodeID;					/* trigger next if */
  }
  while (fi)
  {
   if (fi->fontcodeID==id)
   {
    fip_current=fi;					/* set current font */
    for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)	/* byte n-1 will be terminator '\0' */
    {
     int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
     if (off<fi->fontcodearrsize)
      buffer[i]=fi->fontcodeptr[off];
     else
      buffer[i]='?';		/* fallback to dummy A */
     /* printf ( COMMSTART ""GlyphIndex[0] = %d  char = %d "" COMMEND""\n"",off,fi->fontcodeptr[off] ); */
    } 
    buffer[i]='\0'; 
    return;
   }
   else
    fi=fi->next;
  }
  buffer[0]='X';		/* fallback to dummy B */
  buffer[1]='\0'; 
}","static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *VAR_0, int VAR_1,char *VAR_2,char *VAR_3,int VAR_4,int VAR_5)
{
  int VAR_6=0;
  struct FONTINFO *VAR_7=VAR_8;
  if ( VAR_0->TextRecordType == 0 )
    return;
  if (VAR_0->StyleFlagHasFont)
  {
   printf(""%s("" VAR_9 ""f%d);\n"", methodcall (VAR_2, ""setFont""), VAR_0->FontID);
   printf(""%s(%d);\n"",methodcall(VAR_2,""setHeight""),VAR_0->TextHeight);
  }
  if( VAR_0->StyleFlagHasColor )
  {
   if (VAR_1==2)
    printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
      VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue, VAR_0->TextColor.alpha);
   else
    printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
      VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue);
  }
  if( VAR_0->StyleFlagHasYOffset || VAR_0->StyleFlagHasXOffset ) 
  {
    printf (""%s(%d, %d);\n"", methodcall (VAR_2, ""moveTo""),VAR_0->XOffset,VAR_0->YOffset);
  }
  if (VAR_0->FontID) 
  {
    VAR_5=VAR_0->FontID;
  }
  if (!VAR_0->StyleFlagHasFont)				/* COMMENT_0 */
  {
   VAR_7 = VAR_10;					/* COMMENT_1 */

   if (!VAR_7)
      SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
   else
      VAR_5 = VAR_7->fontcodeID;					/* COMMENT_2 */
  }
  while (VAR_7)
  {
   if (VAR_7->fontcodeID==VAR_5)
   {
    VAR_10=VAR_7;					/* COMMENT_3 */
    for(VAR_6=0;VAR_6<VAR_0->GlyphCount && VAR_6<VAR_4-1 ;VAR_6++)	/* COMMENT_4 */
    {
     int VAR_11=(&(VAR_0->GlyphEntries[VAR_6]))->GlyphIndex[0];
     if (VAR_11<VAR_7->fontcodearrsize)
      VAR_3[VAR_6]=VAR_7->fontcodeptr[VAR_11];
     else
      VAR_3[VAR_6]='?';		/* COMMENT_5 */
     /* COMMENT_6 */
    } 
    VAR_3[VAR_6]='\0'; 
    return;
   }
   else
    VAR_7=VAR_7->next;
  }
  VAR_3[0]='X';		/* COMMENT_7 */
  VAR_3[1]='\0'; 
}",libming/f3a66c6479d1191734b5ab57d5d7e0bd7525b1a7/outputscript.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,7 +30,11 @@
   if (!trec->StyleFlagHasFont)				/* always check flag before use data */
   {
    fi = fip_current;					/* so cont w current font */
-   id = fi->fontcodeID;					/* trigger next if */
+
+   if (!fi)
+      SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
+   else
+      id = fi->fontcodeID;					/* trigger next if */
   }
   while (fi)
   {","{'deleted_lines': ['   id = fi->fontcodeID;\t\t\t\t\t/* trigger next if */'], 'added_lines': ['', '   if (!fi)', '      SWF_warn(""outputSWF_TEXT_RECORD: can\'t process text record: fonts information list is NULL\\n"");', '   else', '      id = fi->fontcodeID;\t\t\t\t\t/* trigger next if */']}",True,"The outputSWF_TEXT_RECORD function in util/outputscript.c in libming <= 0.4.8 is vulnerable to a NULL pointer dereference, which may allow attackers to cause a denial of service via a crafted swf file.",6.5,MEDIUM,1,valid,2017-11-20T09:48:36Z,2
CVE-2017-17881,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/878,aa601d79a630f6de0694fadbeee31456a357fa73,https://github.com/ImageMagick/ImageMagick/commit/aa601d79a630f6de0694fadbeee31456a357fa73,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
PixelPacket *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
size_t Unknown6;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
BlobInfo *blob;
size_t one;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
quantum_info=(QuantumInfo *) NULL;
image = AcquireImage(image_info);
image2 = (Image *) NULL;
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
clone_info=(ImageInfo *) NULL;
if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image2=ReadMATImageV4(image_info,image,exception);
if (image2  == NULL)
goto MATLAB_KO;
image=image2;
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
goto MATLAB_KO;    
if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
{
MATLAB_KO:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
(void) SeekBlob(image,filepos,SEEK_SET);
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
goto MATLAB_KO;
filepos += MATLAB_HDR.ObjectSize + 4 + 4;
clone_info=CloneImageInfo(image_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if (MATLAB_HDR.DataType!=miMATRIX)
{
clone_info=DestroyImageInfo(clone_info);
continue;  
}
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
Unknown6 = ReadBlobXXXLong(image2);
(void) Unknown6;
if(z!=3)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError,
""MultidimensionalMatricesAreNotSupported"");
}
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError,
""MultidimensionalMatricesAreNotSupported"");
}
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
break;
default:
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (ssize_t) ((size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
(void) ReadBlob(image2, 4, (unsigned char *) &size);     
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
one=1;
image->colors = one << image->depth;
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
SetImageColorspace(image,GRAYColorspace);
image->type=GrayscaleType;
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
blob = rotated_image->blob;
rotated_image->blob = image->blob;
rotated_image->colors = image->colors;
image->blob = blob;
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
AcquireNextImage(image_info,image);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
goto NEXT_FRAME;
}
if(image2!=NULL)
if(image2!=image)   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) unlink(clone_info->filename);
}
}
}
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
}
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
if (tmp == image2)
image2=(Image *) NULL;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (image == (Image *) NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
return(image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
PixelPacket *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
size_t VAR_17;
unsigned VAR_18, VAR_19;
unsigned VAR_20;
int VAR_21;
int VAR_22;
MagickOffsetType VAR_23=0x80;
BlobInfo *VAR_24;
size_t VAR_25;
unsigned int (*VAR_26)(Image *VAR_2);
unsigned short (*VAR_27)(Image *VAR_2);
void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_32);
VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");
VAR_10=(QuantumInfo *) NULL;
VAR_2 = AcquireImage(VAR_0);
VAR_3 = (Image *) NULL;
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
if (VAR_6 == VAR_35)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_11=(ImageInfo *) NULL;
if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_3  == NULL)
goto MATLAB_KO;
VAR_2=VAR_3;
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_26 = VAR_37;
VAR_27 = VAR_38;
VAR_28 = VAR_39;
VAR_31 = VAR_40;
VAR_2->endian = VAR_41;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_26 = VAR_42;
VAR_27 = VAR_43;
VAR_28 = VAR_44;
VAR_31 = VAR_45;
VAR_2->endian = VAR_46;
}
else
goto MATLAB_KO;    
if (strncmp(VAR_7.identific, ""MATLAB"", 6))
{
MATLAB_KO:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_36,""ImproperImageHeader"");
}
VAR_23 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_20 = 1;
(void) SeekBlob(VAR_2,VAR_23,VAR_47);
VAR_7.DataType = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
goto MATLAB_KO;
VAR_23 += VAR_7.ObjectSize + 4 + 4;
VAR_11=CloneImageInfo(VAR_0);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
VAR_3 = VAR_2;
#if defined(VAR_49)
if(VAR_7.DataType == VAR_50)
{
VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_26(VAR_3); 
}
#endif
if (VAR_7.DataType!=VAR_51)
{
VAR_11=DestroyImageInfo(VAR_11);
continue;  
}
VAR_7.unknown1 = VAR_26(VAR_3);
VAR_7.unknown2 = VAR_26(VAR_3);
VAR_7.unknown5 = VAR_26(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_26(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_26(VAR_3);  
VAR_7.unknown4 = VAR_26(VAR_3);
VAR_7.DimFlag = VAR_26(VAR_3);
VAR_7.SizeX = VAR_26(VAR_3);
VAR_7.SizeY = VAR_26(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_19=VAR_18=1; break;      
case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  
VAR_17 = VAR_26(VAR_3);
(void) VAR_17;
if(VAR_18!=3)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_52,
""MultidimensionalMatricesAreNotSupported"");
}
break;
case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  
if(VAR_18!=3 && VAR_18!=1)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_52,
""MultidimensionalMatricesAreNotSupported"");
}
VAR_20 = VAR_26(VAR_3);
if (VAR_20 == 0)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_36,""ImproperImageHeader"");
}
break;
default:
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_27(VAR_3);
VAR_7.NameFlag = VAR_27(VAR_3);
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_53 &&
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&    
VAR_7.StructureClass != VAR_56 &&
VAR_7.StructureClass != VAR_57 &&    
VAR_7.StructureClass != VAR_58 &&
VAR_7.StructureClass != VAR_59 &&    
VAR_7.StructureClass != VAR_60 &&
VAR_7.StructureClass != VAR_61 &&    
VAR_7.StructureClass != VAR_62 &&
VAR_7.StructureClass != VAR_63)    
ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_26(VAR_3);  
VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_64);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_26(VAR_3);    
if (VAR_21)
(void) LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     
NEXT_FRAME:
switch (VAR_9)
{
case VAR_65:
case VAR_66:
VAR_22 = 8;
if(VAR_7.StructureFlag & VAR_67)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_68:
case VAR_69:
VAR_22 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_70:
case VAR_71:
VAR_22 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_72:
case VAR_73:
VAR_22 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_74:
VAR_22 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_75)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_76:
VAR_22 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_77
ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
if (VAR_7.StructureFlag & VAR_75)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_22;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_25=1;
VAR_2->colors = VAR_25 << VAR_2->depth;
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
{
SetImageColorspace(VAR_2,VAR_78);
VAR_2->type=VAR_79;
}
if (VAR_0->ping)
{
size_t VAR_80 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_80;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_6 == VAR_35)
{
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_76 || VAR_9==VAR_74)        
{
CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
}
if(VAR_18==1) VAR_18=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (PixelPacket *) NULL)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_18<=1 &&       
(VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
FixSignedValues(VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_18-- >= 2);
ExitLoop:
if (VAR_7.StructureFlag & VAR_75)
{        
VAR_9 = VAR_26(VAR_3);    
VAR_12 = VAR_26(VAR_3);           
if (VAR_9==VAR_76 || VAR_9==VAR_74)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_76)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (double *)VAR_14);
InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
if (VAR_9==VAR_74)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_31(VAR_3, VAR_13, (float *)VAR_14);
InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
VAR_2->type=VAR_79;
if (VAR_2->depth == 1)
VAR_2->type=VAR_83;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_24 = VAR_4->blob;
VAR_4->blob = VAR_2->blob;
VAR_4->colors = VAR_2->colors;
VAR_2->blob = VAR_24;
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
AcquireNextImage(VAR_0,VAR_2);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if(--VAR_20>0)
{
VAR_18 = VAR_19;
if(VAR_3==NULL) VAR_3 = VAR_2;
goto NEXT_FRAME;
}
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) unlink(VAR_11->filename);
}
}
}
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
}
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
CloseBlob(VAR_2);
{
Image *VAR_84;
ssize_t VAR_85=0;
VAR_84=VAR_2;
VAR_2=NULL;
while (VAR_84 != (Image *) NULL)
{
Image *VAR_86=VAR_84;
if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
VAR_84=VAR_84->previous;
if (VAR_86 == VAR_3)
VAR_3=(Image *) NULL;
DeleteImageFromList(&VAR_86);
} else {
VAR_2=VAR_84;
VAR_84=VAR_84->previous;
}
}
for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
VAR_84->scene=VAR_85++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_2 == (Image *) NULL)
ThrowReaderException(VAR_36,""ImproperImageHeader"")
return(VAR_2);
}",ImageMagick/aa601d79a630f6de0694fadbeee31456a357fa73/mat.c/vul/before/0.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);
  image2 = (Image *) NULL;

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3)
           {
             if (clone_info != (ImageInfo *) NULL)
               clone_info=DestroyImageInfo(clone_info);
             if ((image != image2) && (image2 != (Image *) NULL))
               image2=DestroyImage(image2);
             ThrowReaderException(CoderError,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           {
             if (clone_info != (ImageInfo *) NULL)
               clone_info=DestroyImageInfo(clone_info);
             if ((image != image2) && (image2 != (Image *) NULL))
               image2=DestroyImage(image2);
             ThrowReaderException(CoderError,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           {
             if (clone_info != (ImageInfo *) NULL)
               clone_info=DestroyImageInfo(clone_info);
             if ((image != image2) && (image2 != (Image *) NULL))
               image2=DestroyImage(image2);
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           }
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      {
        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))
          {
            CloseBlob(image2);
            DeleteImageFromList(&image2);
          }
        if (clone_info != (ImageInfo *) NULL)
          DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
      }

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if ((image != image2) && (image2 != (Image *) NULL))
    image2=DestroyImage(image2);
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  return(image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  PixelPacket *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  size_t VAR_17;
  unsigned VAR_18, VAR_19;
  unsigned VAR_20;
  int VAR_21;
  int VAR_22;
  MagickOffsetType VAR_23=0x80;
  BlobInfo *VAR_24;
  size_t VAR_25;

  unsigned int (*VAR_26)(Image *VAR_2);
  unsigned short (*VAR_27)(Image *VAR_2);
  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_32);
  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_2 = AcquireImage(VAR_0);
  VAR_3 = (Image *) NULL;

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
  if (VAR_6 == VAR_35)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_11=(ImageInfo *) NULL;
  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_3  == NULL)
        goto MATLAB_KO;
      VAR_2=VAR_3;
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");

  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_26 = VAR_37;
    VAR_27 = VAR_38;
    VAR_28 = VAR_39;
    VAR_31 = VAR_40;
    VAR_2->endian = VAR_41;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_26 = VAR_42;
    VAR_27 = VAR_43;
    VAR_28 = VAR_44;
    VAR_31 = VAR_45;
    VAR_2->endian = VAR_46;
  }
  else
    goto MATLAB_KO;    /* COMMENT_6 */

  if (strncmp(VAR_7.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
        VAR_3=DestroyImage(VAR_3);
      if (VAR_11 != (ImageInfo *) NULL)
        VAR_11=DestroyImageInfo(VAR_11);
      ThrowReaderException(VAR_36,""ImproperImageHeader"");
    }

  VAR_23 = TellBlob(VAR_2);
  while(!EOFBlob(VAR_2)) /* COMMENT_7 */
  {
    VAR_20 = 1;
    (void) SeekBlob(VAR_2,VAR_23,VAR_47);
    /* COMMENT_8 */

    VAR_7.DataType = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
      goto MATLAB_KO;
    VAR_23 += VAR_7.ObjectSize + 4 + 4;

    VAR_11=CloneImageInfo(VAR_0);
    if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
      VAR_3=DestroyImage(VAR_3);
    VAR_3 = VAR_2;
#if defined(VAR_49)
    if(VAR_7.DataType == VAR_50)
    {
      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */
    }
#endif

    if (VAR_7.DataType!=VAR_51)
      {
        VAR_11=DestroyImageInfo(VAR_11);
        continue;  /* COMMENT_10 */
      }

    VAR_7.unknown1 = VAR_26(VAR_3);
    VAR_7.unknown2 = VAR_26(VAR_3);

    VAR_7.unknown5 = VAR_26(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_26(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */
    VAR_7.unknown4 = VAR_26(VAR_3);
    VAR_7.DimFlag = VAR_26(VAR_3);
    VAR_7.SizeX = VAR_26(VAR_3);
    VAR_7.SizeY = VAR_26(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */
      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */
           VAR_17 = VAR_26(VAR_3);
           (void) VAR_17;
         if(VAR_18!=3)
           {
             if (VAR_11 != (ImageInfo *) NULL)
               VAR_11=DestroyImageInfo(VAR_11);
             if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
               VAR_3=DestroyImage(VAR_3);
             ThrowReaderException(VAR_52,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         break;
      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */
         if(VAR_18!=3 && VAR_18!=1)
           {
             if (VAR_11 != (ImageInfo *) NULL)
               VAR_11=DestroyImageInfo(VAR_11);
             if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
               VAR_3=DestroyImage(VAR_3);
             ThrowReaderException(VAR_52,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         VAR_20 = VAR_26(VAR_3);
         if (VAR_20 == 0)
           {
             if (VAR_11 != (ImageInfo *) NULL)
               VAR_11=DestroyImageInfo(VAR_11);
             if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
               VAR_3=DestroyImage(VAR_3);
             ThrowReaderException(VAR_36,""ImproperImageHeader"");
           }
         break;
      default:
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_27(VAR_3);
    VAR_7.NameFlag = VAR_27(VAR_3);

    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_53 &&
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_55 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_56 &&
        VAR_7.StructureClass != VAR_57 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_58 &&
        VAR_7.StructureClass != VAR_59 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_60 &&
        VAR_7.StructureClass != VAR_61 &&    /* COMMENT_19 */
        VAR_7.StructureClass != VAR_62 &&
        VAR_7.StructureClass != VAR_63)    /* COMMENT_20 */
      {
        if ((VAR_3 != (Image*) NULL) && (VAR_3 != (Image *) VAR_2))
          {
            CloseBlob(VAR_3);
            DeleteImageFromList(&VAR_3);
          }
        if (VAR_11 != (ImageInfo *) NULL)
          DestroyImageInfo(VAR_11);
        ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");
      }

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */
        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_64);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
    if (VAR_21)
      (void) LogMagickEvent(VAR_33,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */

NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_65:
      case VAR_66:
        VAR_22 = 8;
        if(VAR_7.StructureFlag & VAR_67)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_25 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_68:
      case VAR_69:
        VAR_22 = 16;
        VAR_2->depth = 16;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_70:
      case VAR_71:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_72:
      case VAR_73:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_74:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_75)
  {              /* COMMENT_30 */
  }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_76:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_77
          ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
        if (VAR_7.StructureFlag & VAR_75)
  {                         /* COMMENT_31 */
  }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        if (VAR_11)
          VAR_11=DestroyImageInfo(VAR_11);
        ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_22;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_25=1;
    VAR_2->colors = VAR_25 << VAR_2->depth;
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
      goto MATLAB_KO;
      /* COMMENT_32 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      {
        SetImageColorspace(VAR_2,VAR_78);
        VAR_2->type=VAR_79;
      }


    /* COMMENT_33 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_80 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_80;
      goto done_reading; /* COMMENT_37 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
    if (VAR_6 == VAR_35)
      {
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        InheritException(VAR_1,&VAR_2->exception);
        return(DestroyImageList(VAR_2));
      }
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");

  /* COMMENT_38 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */
    if (VAR_14 == NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_76 || VAR_9==VAR_74)        /* COMMENT_40 */
    {
      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
    }

    /* COMMENT_41 */
    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */
    /* COMMENT_43 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (PixelPacket *) NULL)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto done_reading;    /* COMMENT_44 */
  }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
        if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
    {
ImportQuantumPixelsFailed:
      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
      goto ImportQuantumPixelsFailed;


          if (VAR_18<=1 &&       /* COMMENT_45 */
          (VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
      FixSignedValues(VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
      }
    } while(VAR_18-- >= 2);
ExitLoop:


    /* COMMENT_46 */
    if (VAR_7.StructureFlag & VAR_75)
    {        /* COMMENT_47 */
      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */

      if (VAR_9==VAR_76 || VAR_9==VAR_74)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_76)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_28(VAR_3, VAR_13, (double *)VAR_14);
          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }

      if (VAR_9==VAR_74)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_31(VAR_3, VAR_13, (float *)VAR_14);
          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }
    }

      /* COMMENT_49 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      VAR_2->type=VAR_79;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_83;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_50 */

      /* COMMENT_51 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_52 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;

      VAR_24 = VAR_4->blob;
      VAR_4->blob = VAR_2->blob;
      VAR_4->colors = VAR_2->colors;
      VAR_2->blob = VAR_24;
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
  if(VAR_11)
  {
          if(VAR_11->file)
    {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
    }
        }
      }

      /* COMMENT_53 */
    AcquireNextImage(VAR_0,VAR_2);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_54 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;

    if(--VAR_20>0)
    {
      VAR_18 = VAR_19;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      goto NEXT_FRAME;
    }

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)   /* COMMENT_55 */
      {
/* COMMENT_56 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) unlink(VAR_11->filename);
          }
         }
       }
    if (VAR_10 != (QuantumInfo *) NULL)
      VAR_10=DestroyQuantumInfo(VAR_10);
    if (VAR_11)
      VAR_11=DestroyImageInfo(VAR_11);
  }

  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
  CloseBlob(VAR_2);


  {
    Image *VAR_84;
    ssize_t VAR_85=0;

    /* COMMENT_57 */
                                                             
      
    VAR_84=VAR_2;
    VAR_2=NULL;
    while (VAR_84 != (Image *) NULL)
      {
        Image *VAR_86=VAR_84;
        if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
          VAR_84=VAR_84->previous;
          if (VAR_86 == VAR_3)
            VAR_3=(Image *) NULL;
          DeleteImageFromList(&VAR_86);
        } else {
          VAR_2=VAR_84;
          VAR_84=VAR_84->previous;
        }
      }

    /* COMMENT_60 */
                       
      
    for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
      VAR_84->scene=VAR_85++;
  }

  if(VAR_11 != NULL)  /* COMMENT_63 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
  if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
    VAR_3=DestroyImage(VAR_3);
  if (VAR_2 == (Image *) NULL)
    ThrowReaderException(VAR_36,""ImproperImageHeader"")
  return(VAR_2);
}",ImageMagick/aa601d79a630f6de0694fadbeee31456a357fa73/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -207,7 +207,16 @@
         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
         MATLAB_HDR.StructureClass != mxINT64_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
-      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
+      {
+        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))
+          {
+            CloseBlob(image2);
+            DeleteImageFromList(&image2);
+          }
+        if (clone_info != (ImageInfo *) NULL)
+          DestroyImageInfo(clone_info);
+        ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
+      }
 
     switch (MATLAB_HDR.NameFlag)
     {","{'deleted_lines': ['      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");'], 'added_lines': ['      {', '        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))', '          {', '            CloseBlob(image2);', '            DeleteImageFromList(&image2);', '          }', '        if (clone_info != (ImageInfo *) NULL)', '          DestroyImageInfo(clone_info);', '        ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");', '      }']}",True,"In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service via a crafted MAT image file.",6.5,MEDIUM,1,valid,2017-11-24T14:22:34Z,2
CVE-2017-17883,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/877,b0a7241df0f889cc3158ba82774ff21fa1da87ec,https://github.com/ImageMagick/ImageMagick/commit/b0a7241df0f889cc3158ba82774ff21fa1da87ec,coders/pgx.c,ReadPGXImage,"static Image *ReadPGXImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
char
buffer[MagickPathExtent],
endian[MagickPathExtent],
sans[MagickPathExtent],
sign[MagickPathExtent];
const unsigned char
*pixels;
Image
*image;
int
height,
precision,
width;
QuantumInfo
*quantum_info;
MagickBooleanType
status;
size_t
length;
ssize_t
count,
y;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
if (ReadBlobString(image,buffer) == (char *) NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
count=(ssize_t) sscanf(buffer,""PG%[ \t]%2s%[ \t+-]%d%[ \t]%d%[ \t]%d"",sans,
endian,sign,&precision,sans,&width,sans,&height);
image->depth=(size_t) precision;
if (LocaleCompare(endian,""ML"") == 0)
image->endian=MSBEndian;
image->columns=(size_t) width;
image->rows=(size_t) height;
if ((image->columns == 0) || (image->rows == 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
(void) SetImageColorspace(image,GRAYColorspace,exception);
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
length=GetQuantumExtent(image,quantum_info,GrayQuantum);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
pixels=(const unsigned char *) ReadBlobStream(image,length,
GetQuantumPixels(quantum_info),&count);
if (count != (ssize_t) length)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
(void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
GrayQuantum,pixels,exception);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)
break;
}
SetQuantumImageType(image,GrayQuantum);
quantum_info=DestroyQuantumInfo(quantum_info);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadPGXImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3],
VAR_4[VAR_3],
VAR_5[VAR_3],
VAR_6[VAR_3];
const unsigned char
*VAR_7;
Image
*VAR_8;
int
VAR_9,
VAR_10,
VAR_11;
QuantumInfo
*VAR_12;
MagickBooleanType
VAR_13;
size_t
VAR_14;
ssize_t
VAR_15,
VAR_16;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_13=OpenBlob(VAR_0,VAR_8,VAR_20,VAR_1);
if (VAR_13 == VAR_18)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
if (ReadBlobString(VAR_8,VAR_2) == (char *) NULL)
ThrowReaderException(VAR_21,""ImproperImageHeader"");
VAR_15=(ssize_t) sscanf(VAR_2,""PG%[ \t]%2s%[ \t+-]%d%[ \t]%d%[ \t]%d"",VAR_5,
VAR_4,VAR_6,&VAR_10,VAR_5,&VAR_11,VAR_5,&VAR_9);
VAR_8->depth=(size_t) VAR_10;
if (LocaleCompare(VAR_4,""ML"") == 0)
VAR_8->endian=VAR_22;
VAR_8->columns=(size_t) VAR_11;
VAR_8->rows=(size_t) VAR_9;
if ((VAR_8->columns == 0) || (VAR_8->rows == 0))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
if (VAR_0->ping != VAR_18)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_13=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_13 == VAR_18)
return(DestroyImageList(VAR_8));
(void) SetImageColorspace(VAR_8,VAR_23,VAR_1);
VAR_12=AcquireQuantumInfo(VAR_0,VAR_8);
if (VAR_12 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_24,""MemoryAllocationFailed"");
VAR_14=GetQuantumExtent(VAR_8,VAR_12,VAR_25);
for (VAR_16=0; VAR_16 < (ssize_t) VAR_8->rows; VAR_16++)
{
register Quantum
*magick_restrict VAR_26;
VAR_26=QueueAuthenticPixels(VAR_8,0,VAR_16,VAR_8->columns,1,VAR_1);
if (VAR_26 == (Quantum *) NULL)
break;
VAR_7=(const unsigned char *) ReadBlobStream(VAR_8,VAR_14,
GetQuantumPixels(VAR_12),&VAR_15);
if (VAR_15 != (ssize_t) VAR_14)
ThrowReaderException(VAR_21,""UnableToReadImageData"");
(void) ImportQuantumPixels(VAR_8,(CacheView *) NULL,VAR_12,
VAR_25,VAR_7,VAR_1);
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_18)
break;
if (SetImageProgress(VAR_8,VAR_27,(MagickOffsetType) VAR_16,VAR_8->rows) == VAR_18)
break;
}
SetQuantumImageType(VAR_8,VAR_25);
VAR_12=DestroyQuantumInfo(VAR_12);
if (EOFBlob(VAR_8) != VAR_18)
ThrowFileException(VAR_1,VAR_21,""UnexpectedEndOfFile"",
VAR_8->filename);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/b0a7241df0f889cc3158ba82774ff21fa1da87ec/pgx.c/vul/before/0.json,"static Image *ReadPGXImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    buffer[MagickPathExtent],
    endian[MagickPathExtent],
    sans[MagickPathExtent],
    sign[MagickPathExtent];

  const unsigned char
    *pixels;

  Image
    *image;

  int
    height,
    precision,
    width;

  QuantumInfo
    *quantum_info;

  MagickBooleanType
    status;

  size_t
    length;

  ssize_t
    count,
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  if (ReadBlobString(image,buffer) == (char *) NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  count=(ssize_t) sscanf(buffer,""PG%[ \t]%2s%[ \t+-]%d%[ \t]%d%[ \t]%d"",sans,
    endian,sign,&precision,sans,&width,sans,&height);
  image->depth=(size_t) precision;
  if (LocaleCompare(endian,""ML"") == 0)
    image->endian=MSBEndian;
  image->columns=(size_t) width;
  image->rows=(size_t) height;
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Convert PGX image.
  */
  (void) SetImageColorspace(image,GRAYColorspace,exception);
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  length=GetQuantumExtent(image,quantum_info,GrayQuantum);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    pixels=(const unsigned char *) ReadBlobStream(image,length,
      GetQuantumPixels(quantum_info),&count);
    if (count != (ssize_t) length)
      break;
    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      GrayQuantum,pixels,exception);
    if (status == MagickFalse)
      break;
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)
      break;
  }
  SetQuantumImageType(image,GrayQuantum);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadPGXImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3],
    VAR_4[VAR_3],
    VAR_5[VAR_3],
    VAR_6[VAR_3];

  const unsigned char
    *VAR_7;

  Image
    *VAR_8;

  int
    VAR_9,
    VAR_10,
    VAR_11;

  QuantumInfo
    *VAR_12;

  MagickBooleanType
    VAR_13;

  size_t
    VAR_14;

  ssize_t
    VAR_15,
    VAR_16;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_13=OpenBlob(VAR_0,VAR_8,VAR_20,VAR_1);
  if (VAR_13 == VAR_18)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  if (ReadBlobString(VAR_8,VAR_2) == (char *) NULL)
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  VAR_15=(ssize_t) sscanf(VAR_2,""PG%[ \t]%2s%[ \t+-]%d%[ \t]%d%[ \t]%d"",VAR_5,
    VAR_4,VAR_6,&VAR_10,VAR_5,&VAR_11,VAR_5,&VAR_9);
  VAR_8->depth=(size_t) VAR_10;
  if (LocaleCompare(VAR_4,""ML"") == 0)
    VAR_8->endian=VAR_22;
  VAR_8->columns=(size_t) VAR_11;
  VAR_8->rows=(size_t) VAR_9;
  if ((VAR_8->columns == 0) || (VAR_8->rows == 0))
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  if (VAR_0->ping != VAR_18)
    {
      (void) CloseBlob(VAR_8);
      return(GetFirstImageInList(VAR_8));
    }
  VAR_13=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
  if (VAR_13 == VAR_18)
    return(DestroyImageList(VAR_8));
  /* COMMENT_3 */
                      
    
  (void) SetImageColorspace(VAR_8,VAR_23,VAR_1);
  VAR_12=AcquireQuantumInfo(VAR_0,VAR_8);
  if (VAR_12 == (QuantumInfo *) NULL)
    ThrowReaderException(VAR_24,""MemoryAllocationFailed"");
  VAR_14=GetQuantumExtent(VAR_8,VAR_12,VAR_25);
  for (VAR_16=0; VAR_16 < (ssize_t) VAR_8->rows; VAR_16++)
  {
    register Quantum
      *magick_restrict VAR_26;

    VAR_26=QueueAuthenticPixels(VAR_8,0,VAR_16,VAR_8->columns,1,VAR_1);
    if (VAR_26 == (Quantum *) NULL)
      break;
    VAR_7=(const unsigned char *) ReadBlobStream(VAR_8,VAR_14,
      GetQuantumPixels(VAR_12),&VAR_15);
    if (VAR_15 != (ssize_t) VAR_14)
      break;
    VAR_13=ImportQuantumPixels(VAR_8,(CacheView *) NULL,VAR_12,
      VAR_25,VAR_7,VAR_1);
    if (VAR_13 == VAR_18)
      break;
    if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_18)
      break;
    if (SetImageProgress(VAR_8,VAR_27,(MagickOffsetType) VAR_16,VAR_8->rows) == VAR_18)
      break;
  }
  SetQuantumImageType(VAR_8,VAR_25);
  VAR_12=DestroyQuantumInfo(VAR_12);
  if (EOFBlob(VAR_8) != VAR_18)
    ThrowFileException(VAR_1,VAR_21,""UnexpectedEndOfFile"",
      VAR_8->filename);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/b0a7241df0f889cc3158ba82774ff21fa1da87ec/pgx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -85,9 +85,11 @@
     pixels=(const unsigned char *) ReadBlobStream(image,length,
       GetQuantumPixels(quantum_info),&count);
     if (count != (ssize_t) length)
-      ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
-    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+      break;
+    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
       GrayQuantum,pixels,exception);
+    if (status == MagickFalse)
+      break;
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)","{'deleted_lines': ['      ThrowReaderException(CorruptImageError,""UnableToReadImageData"");', '    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,'], 'added_lines': ['      break;', '    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,', '    if (status == MagickFalse)', '      break;']}",True,"In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadPGXImage in coders/pgx.c, which allows attackers to cause a denial of service via a crafted PGX image file.",6.5,MEDIUM,1,valid,2017-11-24T14:36:24Z,2
CVE-2017-18208,['CWE-835'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"mm/madvise.c: fix madvise() infinite loop under special circumstances

MADVISE_WILLNEED has always been a noop for DAX (formerly XIP) mappings.
Unfortunately madvise_willneed() doesn't communicate this information
properly to the generic madvise syscall implementation.  The calling
convention is quite subtle there.  madvise_vma() is supposed to either
return an error or update &prev otherwise the main loop will never
advance to the next vma and it will keep looping for ever without a way
to get out of the kernel.

It seems this has been broken since introduction.  Nobody has noticed
because nobody seems to be using MADVISE_WILLNEED on these DAX mappings.

[mhocko@suse.com: rewrite changelog]
Link: http://lkml.kernel.org/r/20171127115318.911-1-guoxuenan@huawei.com
Fixes: fe77ba6f4f97 (""[PATCH] xip: madvice/fadvice: execute in place"")
Signed-off-by: chenjie <chenjie6@huawei.com>
Signed-off-by: guoxuenan <guoxuenan@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: zhangyi (F) <yi.zhang@huawei.com>
Cc: Miao Xie <miaoxie@huawei.com>
Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
Cc: Shaohua Li <shli@fb.com>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: Mel Gorman <mgorman@techsingularity.net>
Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Anshuman Khandual <khandual@linux.vnet.ibm.com>
Cc: Rik van Riel <riel@redhat.com>
Cc: Carsten Otte <cotte@de.ibm.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,mm/madvise.c,madvise_willneed,"static long madvise_willneed(struct vm_area_struct *vma,
struct vm_area_struct **prev,
unsigned long start, unsigned long end)
{
struct file *file = vma->vm_file;
#ifdef CONFIG_SWAP
if (!file) {
*prev = vma;
force_swapin_readahead(vma, start, end);
return 0;
}
if (shmem_mapping(file->f_mapping)) {
*prev = vma;
force_shm_swapin_readahead(vma, start, end,
file->f_mapping);
return 0;
}
#else
if (!file)
return -EBADF;
#endif
if (IS_DAX(file_inode(file))) {
return 0;
}
*prev = vma;
start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
if (end > vma->vm_end)
end = vma->vm_end;
end = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
force_page_cache_readahead(file->f_mapping, file, start, end - start);
return 0;
}","static long madvise_willneed(struct vm_area_struct *VAR_0,
struct vm_area_struct **VAR_1,
unsigned long VAR_2, unsigned long VAR_3)
{
struct file *file = VAR_0->vm_file;
#ifdef VAR_4
if (!file) {
*VAR_1 = VAR_0;
force_swapin_readahead(VAR_0, VAR_2, VAR_3);
return 0;
}
if (shmem_mapping(file->f_mapping)) {
*VAR_1 = VAR_0;
force_shm_swapin_readahead(VAR_0, VAR_2, VAR_3,
file->f_mapping);
return 0;
}
#else
if (!file)
return -VAR_5;
#endif
if (IS_DAX(file_inode(file))) {
return 0;
}
*VAR_1 = VAR_0;
VAR_2 = ((VAR_2 - VAR_0->vm_start) >> VAR_6) + VAR_0->vm_pgoff;
if (VAR_3 > VAR_0->vm_end)
VAR_3 = VAR_0->vm_end;
VAR_3 = ((VAR_3 - VAR_0->vm_start) >> VAR_6) + VAR_0->vm_pgoff;
force_page_cache_readahead(file->f_mapping, file, VAR_2, VAR_3 - VAR_2);
return 0;
}",torvalds/linux/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91/madvise.c/vul/before/0.json,"static long madvise_willneed(struct vm_area_struct *vma,
			     struct vm_area_struct **prev,
			     unsigned long start, unsigned long end)
{
	struct file *file = vma->vm_file;

	*prev = vma;
#ifdef CONFIG_SWAP
	if (!file) {
		force_swapin_readahead(vma, start, end);
		return 0;
	}

	if (shmem_mapping(file->f_mapping)) {
		force_shm_swapin_readahead(vma, start, end,
					file->f_mapping);
		return 0;
	}
#else
	if (!file)
		return -EBADF;
#endif

	if (IS_DAX(file_inode(file))) {
		/* no bad return value, but ignore advice */
		return 0;
	}

	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
	if (end > vma->vm_end)
		end = vma->vm_end;
	end = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	force_page_cache_readahead(file->f_mapping, file, start, end - start);
	return 0;
}","static long madvise_willneed(struct vm_area_struct *VAR_0,
			     struct vm_area_struct **VAR_1,
			     unsigned long VAR_2, unsigned long VAR_3)
{
	struct file *file = VAR_0->vm_file;

	*VAR_1 = VAR_0;
#ifdef VAR_4
	if (!file) {
		force_swapin_readahead(VAR_0, VAR_2, VAR_3);
		return 0;
	}

	if (shmem_mapping(file->f_mapping)) {
		force_shm_swapin_readahead(VAR_0, VAR_2, VAR_3,
					file->f_mapping);
		return 0;
	}
#else
	if (!file)
		return -VAR_5;
#endif

	if (IS_DAX(file_inode(file))) {
		/* COMMENT_0 */
		return 0;
	}

	VAR_2 = ((VAR_2 - VAR_0->vm_start) >> VAR_6) + VAR_0->vm_pgoff;
	if (VAR_3 > VAR_0->vm_end)
		VAR_3 = VAR_0->vm_end;
	VAR_3 = ((VAR_3 - VAR_0->vm_start) >> VAR_6) + VAR_0->vm_pgoff;

	force_page_cache_readahead(file->f_mapping, file, VAR_2, VAR_3 - VAR_2);
	return 0;
}",torvalds/linux/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91/madvise.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,15 +4,14 @@
 {
 	struct file *file = vma->vm_file;
 
+	*prev = vma;
 #ifdef CONFIG_SWAP
 	if (!file) {
-		*prev = vma;
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
-		*prev = vma;
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
@@ -27,7 +26,6 @@
 		return 0;
 	}
 
-	*prev = vma;
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;","{'deleted_lines': ['\t\t*prev = vma;', '\t\t*prev = vma;', '\t*prev = vma;'], 'added_lines': ['\t*prev = vma;']}",True,The madvise_willneed function in mm/madvise.c in the Linux kernel before 4.14.4 allows local users to cause a denial of service (infinite loop) by triggering use of MADVISE_WILLNEED for a DAX mapping.,5.5,MEDIUM,1,valid,2017-11-30T00:10:54Z,2
CVE-2017-17439,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,heimdal,"Security: Avoid NULL structure pointer member dereference

This can happen in the error path when processing malformed AS
requests with a NULL client name.  Bug originally introduced on
Fri Feb 13 09:26:01 2015 +0100 in commit:

    a873e21d7c06f22943a90a41dc733ae76799390d

    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()

Original patch by Jeffrey Altman <jaltman@secure-endpoints.com>",1a6a6e462dc2ac6111f9e02c6852ddec4849b887,https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,kdc/kerberos5.c,_kdc_as_rep,"krb5_error_code
_kdc_as_rep(kdc_request_t r,
krb5_data *reply,
const char *from,
struct sockaddr *from_addr,
int datagram_reply)
{
krb5_context context = r->context;
krb5_kdc_configuration *config = r->config;
KDC_REQ *req = &r->req;
KDC_REQ_BODY *b = NULL;
AS_REP rep;
KDCOptions f;
krb5_enctype setype;
krb5_error_code ret = 0;
Key *skey;
int found_pa = 0;
int i, flags = HDB_F_FOR_AS_REQ;
METHOD_DATA error_method;
const PA_DATA *pa;
memset(&rep, 0, sizeof(rep));
error_method.len = 0;
error_method.val = NULL;
ret = _kdc_fast_unwrap_request(r);
if (ret) {
_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
goto out;
}
b = &req->req_body;
f = b->kdc_options;
if (f.canonicalize)
flags |= HDB_F_CANON;
if(b->sname == NULL){
ret = KRB5KRB_ERR_GENERIC;
_kdc_set_e_text(r, ""No server in request"");
} else{
ret = _krb5_principalname2krb5_principal (context,
&r->server_princ,
*(b->sname),
b->realm);
if (ret == 0)
ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
}
if (ret) {
kdc_log(context, config, 0,
""AS-REQ malformed server name from %s"", from);
goto out;
}
if(b->cname == NULL){
ret = KRB5KRB_ERR_GENERIC;
_kdc_set_e_text(r, ""No client in request"");
} else {
ret = _krb5_principalname2krb5_principal (context,
&r->client_princ,
*(b->cname),
b->realm);
if (ret)
goto out;
ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
}
if (ret) {
kdc_log(context, config, 0,
""AS-REQ malformed client name from %s"", from);
goto out;
}
kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
r->client_name, from, r->server_name);
if (_kdc_is_anonymous(context, r->client_princ)) {
if (!_kdc_is_anon_request(b)) {
kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
goto out;
}
} else if (_kdc_is_anon_request(b)) {
kdc_log(context, config, 0,
""Request for a anonymous ticket with non ""
""anonymous client name: %s"", r->client_name);
ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
goto out;
}
ret = _kdc_db_fetch(context, config, r->client_princ,
HDB_F_GET_CLIENT | flags, NULL,
&r->clientdb, &r->client);
if(ret == HDB_ERR_NOT_FOUND_HERE) {
kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
r->client_name);
goto out;
} else if (ret == HDB_ERR_WRONG_REALM) {
char *fixed_client_name = NULL;
ret = krb5_unparse_name(context, r->client->entry.principal,
&fixed_client_name);
if (ret) {
goto out;
}
kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
r->client_name, fixed_client_name);
free(fixed_client_name);
ret = _kdc_fast_mk_error(context, r,
&error_method,
r->armor_crypto,
&req->req_body,
KRB5_KDC_ERR_WRONG_REALM,
NULL,
r->server_princ,
NULL,
&r->client->entry.principal->realm,
NULL, NULL,
reply);
goto out;
} else if(ret){
const char *msg = krb5_get_error_message(context, ret);
kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
krb5_free_error_message(context, msg);
ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
goto out;
}
ret = _kdc_db_fetch(context, config, r->server_princ,
HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
NULL, NULL, &r->server);
if(ret == HDB_ERR_NOT_FOUND_HERE) {
kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
r->server_name);
goto out;
} else if(ret){
const char *msg = krb5_get_error_message(context, ret);
kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
krb5_free_error_message(context, msg);
ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
goto out;
}
ret = _kdc_find_etype(context,
krb5_principal_is_krbtgt(context, r->server_princ) ?
config->tgt_use_strongest_session_key :
config->svc_use_strongest_session_key, FALSE,
r->client, b->etype.val, b->etype.len, &r->sessionetype,
NULL);
if (ret) {
kdc_log(context, config, 0,
""Client (%s) from %s has no common enctypes with KDC ""
""to use for the session key"",
r->client_name, from);
goto out;
}
if(req->padata){
unsigned int n;
log_patypes(context, config, req->padata);
for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
if (pat[n].validate == NULL)
continue;
if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
continue;
kdc_log(context, config, 5,
""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
i = 0;
pa = _kdc_find_padata(req, &i, pat[n].type);
if (pa) {
ret = pat[n].validate(r, pa);
if (ret != 0) {
goto out;
}
kdc_log(context, config, 0,
""%s pre-authentication succeeded -- %s"",
pat[n].name, r->client_name);
found_pa = 1;
r->et.flags.pre_authent = 1;
}
}
}
if (found_pa == 0) {
Key *ckey = NULL;
size_t n;
for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
if ((pat[n].flags & PA_ANNOUNCE) == 0)
continue;
ret = krb5_padata_add(context, &error_method,
pat[n].type, NULL, 0);
if (ret)
goto out;
}
ret = _kdc_find_etype(context,
config->preauth_use_strongest_session_key, TRUE,
r->client, b->etype.val, b->etype.len, NULL, &ckey);
if (ret == 0) {
if (older_enctype(ckey->key.keytype)) {
ret = get_pa_etype_info(context, config,
&error_method, ckey);
if (ret)
goto out;
}
ret = get_pa_etype_info2(context, config,
&error_method, ckey);
if (ret)
goto out;
}
if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
_kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
goto out;
}
if (ckey == NULL) {
ret = KRB5KDC_ERR_CLIENT_NOTYET;
_kdc_set_e_text(r, ""Doesn't have a client key available"");
goto out;
}
krb5_free_keyblock_contents(r->context,  &r->reply_key);
ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
if (ret)
goto out;
}
if (r->clientdb->hdb_auth_status) {
r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
HDB_AUTH_SUCCESS);
}
ret = _kdc_check_access(context, config, r->client, r->client_name,
r->server, r->server_name,
req, &error_method);
if(ret)
goto out;
ret = _kdc_get_preferred_key(context, config,
r->server, r->server_name,
&setype, &skey);
if(ret)
goto out;
if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
|| (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
ret = KRB5KDC_ERR_BADOPTION;
_kdc_set_e_text(r, ""Bad KDC options"");
goto out;
}
rep.pvno = 5;
rep.msg_type = krb_as_rep;
if (_kdc_is_anonymous(context, r->client_princ)) {
Realm anon_realm=KRB5_ANON_REALM;
ret = copy_Realm(&anon_realm, &rep.crealm);
} else
ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
if (ret)
goto out;
ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
if (ret)
goto out;
rep.ticket.tkt_vno = 5;
ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
if (ret)
goto out;
_krb5_principal2principalname(&rep.ticket.sname,
r->server->entry.principal);
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT
r->et.flags.initial = 1;
if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
r->et.flags.forwardable = f.forwardable;
else if (f.forwardable) {
_kdc_set_e_text(r, ""Ticket may not be forwardable"");
ret = KRB5KDC_ERR_POLICY;
goto out;
}
if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
r->et.flags.proxiable = f.proxiable;
else if (f.proxiable) {
_kdc_set_e_text(r, ""Ticket may not be proxiable"");
ret = KRB5KDC_ERR_POLICY;
goto out;
}
if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
r->et.flags.may_postdate = f.allow_postdate;
else if (f.allow_postdate){
_kdc_set_e_text(r, ""Ticket may not be postdate"");
ret = KRB5KDC_ERR_POLICY;
goto out;
}
if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
_kdc_set_e_text(r, ""Bad address list in requested"");
ret = KRB5KRB_AP_ERR_BADADDR;
goto out;
}
ret = copy_PrincipalName(&rep.cname, &r->et.cname);
if (ret)
goto out;
ret = copy_Realm(&rep.crealm, &r->et.crealm);
if (ret)
goto out;
{
time_t start;
time_t t;
start = r->et.authtime = kdc_time;
if(f.postdated && req->req_body.from){
ALLOC(r->et.starttime);
start = *r->et.starttime = *req->req_body.from;
r->et.flags.invalid = 1;
r->et.flags.postdated = 1; 
}
_kdc_fix_time(&b->till);
t = *b->till;
if(r->client->entry.max_life)
t = start + min(t - start, *r->client->entry.max_life);
if(r->server->entry.max_life)
t = start + min(t - start, *r->server->entry.max_life);
#if 0
t = min(t, start + realm->max_life);
#endif
r->et.endtime = t;
if(f.renewable_ok && r->et.endtime < *b->till){
f.renewable = 1;
if(b->rtime == NULL){
ALLOC(b->rtime);
*b->rtime = 0;
}
if(*b->rtime < *b->till)
*b->rtime = *b->till;
}
if(f.renewable && b->rtime){
t = *b->rtime;
if(t == 0)
t = MAX_TIME;
if(r->client->entry.max_renew)
t = start + min(t - start, *r->client->entry.max_renew);
if(r->server->entry.max_renew)
t = start + min(t - start, *r->server->entry.max_renew);
#if 0
t = min(t, start + realm->max_renew);
#endif
ALLOC(r->et.renew_till);
*r->et.renew_till = t;
r->et.flags.renewable = 1;
}
}
if (_kdc_is_anon_request(b))
r->et.flags.anonymous = 1;
if(b->addresses){
ALLOC(r->et.caddr);
copy_HostAddresses(b->addresses, r->et.caddr);
}
r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
krb5_data_zero(&r->et.transited.contents);
r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
if (r->ek.last_req.val == NULL) {
ret = ENOMEM;
goto out;
}
r->ek.last_req.len = 0;
if (r->client->entry.pw_end
&& (config->kdc_warn_pwexpire == 0
|| kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
++r->ek.last_req.len;
}
if (r->client->entry.valid_end) {
r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
++r->ek.last_req.len;
}
if (r->ek.last_req.len == 0) {
r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
++r->ek.last_req.len;
}
r->ek.nonce = b->nonce;
if (r->client->entry.valid_end || r->client->entry.pw_end) {
ALLOC(r->ek.key_expiration);
if (r->client->entry.valid_end) {
if (r->client->entry.pw_end)
*r->ek.key_expiration = min(*r->client->entry.valid_end,
*r->client->entry.pw_end);
else
*r->ek.key_expiration = *r->client->entry.valid_end;
} else
*r->ek.key_expiration = *r->client->entry.pw_end;
} else
r->ek.key_expiration = NULL;
r->ek.flags = r->et.flags;
r->ek.authtime = r->et.authtime;
if (r->et.starttime) {
ALLOC(r->ek.starttime);
*r->ek.starttime = *r->et.starttime;
}
r->ek.endtime = r->et.endtime;
if (r->et.renew_till) {
ALLOC(r->ek.renew_till);
*r->ek.renew_till = *r->et.renew_till;
}
ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
if (ret)
goto out;
ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
if (ret)
goto out;
if(r->et.caddr){
ALLOC(r->ek.caddr);
copy_HostAddresses(r->et.caddr, r->ek.caddr);
}
if (r->session_key.keytype == ETYPE_NULL) {
ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
if (ret)
goto out;
}
if (r->reply_key.keytype == ETYPE_NULL) {
_kdc_set_e_text(r, ""Client have no reply key"");
ret = KRB5KDC_ERR_CLIENT_NOTYET;
goto out;
}
ret = copy_EncryptionKey(&r->session_key, &r->et.key);
if (ret)
goto out;
ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
if (ret)
goto out;
if (r->outpadata.len) {
ALLOC(rep.padata);
if (rep.padata == NULL) {
ret = ENOMEM;
goto out;
}
ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
if (ret)
goto out;
}
if (send_pac_p(context, req)) {
generate_pac(r, skey);
}
_kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
r->et.endtime, r->et.renew_till);
ret = _kdc_add_KRB5SignedPath(context,
config,
r->server,
setype,
r->client->entry.principal,
NULL,
NULL,
&r->et);
if (ret)
goto out;
log_as_req(context, config, r->reply_key.keytype, setype, b);
r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;
i = 0;
pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
if (pa) {
ret = add_enc_pa_rep(r);
if (ret) {
const char *msg = krb5_get_error_message(r->context, ret);
_kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
krb5_free_error_message(r->context, msg);
goto out;
}
}
ret = _kdc_encode_reply(context, config,
r->armor_crypto, req->req_body.nonce,
&rep, &r->et, &r->ek, setype, r->server->entry.kvno,
&skey->key, r->client->entry.kvno,
&r->reply_key, 0, &r->e_text, reply);
if (ret)
goto out;
if (datagram_reply && reply->length > config->max_datagram_reply_length) {
krb5_data_free(reply);
ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
_kdc_set_e_text(r, ""Reply packet too large"");
}
out:
free_AS_REP(&rep);
if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
ret = _kdc_fast_mk_error(context, r,
&error_method,
r->armor_crypto,
&req->req_body,
ret, r->e_text,
r->server_princ,
&r->client_princ->name,
&r->client_princ->realm,
NULL, NULL,
reply);
if (ret)
goto out2;
}
out2:
free_EncTicketPart(&r->et);
free_EncKDCRepPart(&r->ek);
free_KDCFastState(&r->fast);
if (error_method.len)
free_METHOD_DATA(&error_method);
if (r->outpadata.len)
free_METHOD_DATA(&r->outpadata);
if (r->client_princ) {
krb5_free_principal(context, r->client_princ);
r->client_princ = NULL;
}
if (r->client_name) {
free(r->client_name);
r->client_name = NULL;
}
if (r->server_princ){
krb5_free_principal(context, r->server_princ);
r->server_princ = NULL;
}
if (r->server_name) {
free(r->server_name);
r->server_name = NULL;
}
if (r->client)
_kdc_free_ent(context, r->client);
if (r->server)
_kdc_free_ent(context, r->server);
if (r->armor_crypto) {
krb5_crypto_destroy(r->context, r->armor_crypto);
r->armor_crypto = NULL;
}
krb5_free_keyblock_contents(r->context, &r->reply_key);
krb5_free_keyblock_contents(r->context, &r->session_key);
return ret;
}","krb5_error_code
_kdc_as_rep(kdc_request_t VAR_0,
krb5_data *VAR_1,
const char *VAR_2,
struct sockaddr *VAR_3,
int VAR_4)
{
krb5_context VAR_5 = VAR_0->context;
krb5_kdc_configuration *VAR_6 = VAR_0->config;
KDC_REQ *VAR_7 = &VAR_0->req;
KDC_REQ_BODY *VAR_8 = NULL;
AS_REP VAR_9;
KDCOptions VAR_10;
krb5_enctype VAR_11;
krb5_error_code VAR_12 = 0;
Key *VAR_13;
int VAR_14 = 0;
int VAR_15, VAR_16 = VAR_17;
METHOD_DATA VAR_18;
const PA_DATA *VAR_19;
memset(&VAR_9, 0, sizeof(VAR_9));
VAR_18.len = 0;
VAR_18.val = NULL;
VAR_12 = _kdc_fast_unwrap_request(VAR_0);
if (VAR_12) {
_kdc_r_log(VAR_0, 0, ""FAST unwrap request from %s failed: %d"", VAR_2, VAR_12);
goto out;
}
VAR_8 = &VAR_7->req_body;
VAR_10 = VAR_8->kdc_options;
if (VAR_10.canonicalize)
VAR_16 |= VAR_20;
if(VAR_8->sname == NULL){
VAR_12 = VAR_21;
_kdc_set_e_text(VAR_0, ""No server in request"");
} else{
VAR_12 = _krb5_principalname2krb5_principal (VAR_5,
&VAR_0->server_princ,
*(VAR_8->sname),
VAR_8->realm);
if (VAR_12 == 0)
VAR_12 = krb5_unparse_name(VAR_5, VAR_0->server_princ, &VAR_0->server_name);
}
if (VAR_12) {
kdc_log(VAR_5, VAR_6, 0,
""AS-REQ malformed server name from %s"", VAR_2);
goto out;
}
if(VAR_8->cname == NULL){
VAR_12 = VAR_21;
_kdc_set_e_text(VAR_0, ""No client in request"");
} else {
VAR_12 = _krb5_principalname2krb5_principal (VAR_5,
&VAR_0->client_princ,
*(VAR_8->cname),
VAR_8->realm);
if (VAR_12)
goto out;
VAR_12 = krb5_unparse_name(VAR_5, VAR_0->client_princ, &VAR_0->client_name);
}
if (VAR_12) {
kdc_log(VAR_5, VAR_6, 0,
""AS-REQ malformed client name from %s"", VAR_2);
goto out;
}
kdc_log(VAR_5, VAR_6, 0, ""AS-REQ %s from %s for %s"",
VAR_0->client_name, VAR_2, VAR_0->server_name);
if (_kdc_is_anonymous(VAR_5, VAR_0->client_princ)) {
if (!_kdc_is_anon_request(VAR_8)) {
kdc_log(VAR_5, VAR_6, 0, ""Anonymous ticket w/o anonymous flag"");
VAR_12 = VAR_22;
goto out;
}
} else if (_kdc_is_anon_request(VAR_8)) {
kdc_log(VAR_5, VAR_6, 0,
""Request for a anonymous ticket with non ""
""anonymous client name: %s"", VAR_0->client_name);
VAR_12 = VAR_22;
goto out;
}
VAR_12 = _kdc_db_fetch(VAR_5, VAR_6, VAR_0->client_princ,
VAR_23 | VAR_16, NULL,
&VAR_0->clientdb, &VAR_0->client);
if(VAR_12 == VAR_24) {
kdc_log(VAR_5, VAR_6, 5, ""client %s does not have secrets at this KDC, need to proxy"",
VAR_0->client_name);
goto out;
} else if (VAR_12 == VAR_25) {
char *VAR_26 = NULL;
VAR_12 = krb5_unparse_name(VAR_5, VAR_0->client->entry.principal,
&VAR_26);
if (VAR_12) {
goto out;
}
kdc_log(VAR_5, VAR_6, 0, ""WRONG_REALM - %s -> %s"",
VAR_0->client_name, VAR_26);
free(VAR_26);
VAR_12 = _kdc_fast_mk_error(VAR_5, VAR_0,
&VAR_18,
VAR_0->armor_crypto,
&VAR_7->req_body,
VAR_27,
NULL,
VAR_0->server_princ,
NULL,
&VAR_0->client->entry.principal->realm,
NULL, NULL,
VAR_1);
goto out;
} else if(VAR_12){
const char *VAR_28 = krb5_get_error_message(VAR_5, VAR_12);
kdc_log(VAR_5, VAR_6, 0, ""UNKNOWN -- %s: %s"", VAR_0->client_name, VAR_28);
krb5_free_error_message(VAR_5, VAR_28);
VAR_12 = VAR_22;
goto out;
}
VAR_12 = _kdc_db_fetch(VAR_5, VAR_6, VAR_0->server_princ,
VAR_29|VAR_30 | VAR_16,
NULL, NULL, &VAR_0->server);
if(VAR_12 == VAR_24) {
kdc_log(VAR_5, VAR_6, 5, ""target %s does not have secrets at this KDC, need to proxy"",
VAR_0->server_name);
goto out;
} else if(VAR_12){
const char *VAR_28 = krb5_get_error_message(VAR_5, VAR_12);
kdc_log(VAR_5, VAR_6, 0, ""UNKNOWN -- %s: %s"", VAR_0->server_name, VAR_28);
krb5_free_error_message(VAR_5, VAR_28);
VAR_12 = VAR_31;
goto out;
}
VAR_12 = _kdc_find_etype(VAR_5,
krb5_principal_is_krbtgt(VAR_5, VAR_0->server_princ) ?
VAR_6->tgt_use_strongest_session_key :
VAR_6->svc_use_strongest_session_key, FALSE,
VAR_0->client, VAR_8->etype.val, VAR_8->etype.len, &VAR_0->sessionetype,
NULL);
if (VAR_12) {
kdc_log(VAR_5, VAR_6, 0,
""Client (%s) from %s has no common enctypes with KDC ""
""to use for the session key"",
VAR_0->client_name, VAR_2);
goto out;
}
if(VAR_7->padata){
unsigned int VAR_32;
log_patypes(VAR_5, VAR_6, VAR_7->padata);
for (VAR_32 = 0; !VAR_14 && VAR_32 < sizeof(pat) / sizeof(pat[0]); VAR_32++) {
if (pat[VAR_32].validate == NULL)
continue;
if (VAR_0->armor_crypto == NULL && (pat[VAR_32].flags & VAR_33))
continue;
kdc_log(VAR_5, VAR_6, 5,
""Looking for %s pa-data -- %s"", pat[VAR_32].name, VAR_0->client_name);
VAR_15 = 0;
VAR_19 = _kdc_find_padata(VAR_7, &VAR_15, pat[VAR_32].type);
if (VAR_19) {
VAR_12 = pat[VAR_32].validate(VAR_0, VAR_19);
if (VAR_12 != 0) {
goto out;
}
kdc_log(VAR_5, VAR_6, 0,
""%s pre-authentication succeeded -- %s"",
pat[VAR_32].name, VAR_0->client_name);
VAR_14 = 1;
VAR_0->et.flags.pre_authent = 1;
}
}
}
if (VAR_14 == 0) {
Key *VAR_34 = NULL;
size_t VAR_32;
for (VAR_32 = 0; VAR_32 < sizeof(pat) / sizeof(pat[0]); VAR_32++) {
if ((pat[VAR_32].flags & VAR_35) == 0)
continue;
VAR_12 = krb5_padata_add(VAR_5, &VAR_18,
pat[VAR_32].type, NULL, 0);
if (VAR_12)
goto out;
}
VAR_12 = _kdc_find_etype(VAR_5,
VAR_6->preauth_use_strongest_session_key, TRUE,
VAR_0->client, VAR_8->etype.val, VAR_8->etype.len, NULL, &VAR_34);
if (VAR_12 == 0) {
if (older_enctype(VAR_34->key.keytype)) {
VAR_12 = get_pa_etype_info(VAR_5, VAR_6,
&VAR_18, VAR_34);
if (VAR_12)
goto out;
}
VAR_12 = get_pa_etype_info2(VAR_5, VAR_6,
&VAR_18, VAR_34);
if (VAR_12)
goto out;
}
if (require_preauth_p(VAR_0) || _kdc_is_anon_request(VAR_8)) {
VAR_12 = VAR_36;
_kdc_set_e_text(VAR_0, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
goto out;
}
if (VAR_34 == NULL) {
VAR_12 = VAR_37;
_kdc_set_e_text(VAR_0, ""Doesn't have a client key available"");
goto out;
}
krb5_free_keyblock_contents(VAR_0->context,  &VAR_0->reply_key);
VAR_12 = krb5_copy_keyblock_contents(VAR_0->context, &VAR_34->key, &VAR_0->reply_key);
if (VAR_12)
goto out;
}
if (VAR_0->clientdb->hdb_auth_status) {
VAR_0->clientdb->hdb_auth_status(VAR_5, VAR_0->clientdb, VAR_0->client, 
VAR_38);
}
VAR_12 = _kdc_check_access(VAR_5, VAR_6, VAR_0->client, VAR_0->client_name,
VAR_0->server, VAR_0->server_name,
VAR_7, &VAR_18);
if(VAR_12)
goto out;
VAR_12 = _kdc_get_preferred_key(VAR_5, VAR_6,
VAR_0->server, VAR_0->server_name,
&VAR_11, &VAR_13);
if(VAR_12)
goto out;
if(VAR_10.renew || VAR_10.validate || VAR_10.proxy || VAR_10.forwarded || VAR_10.enc_tkt_in_skey
|| (_kdc_is_anon_request(VAR_8) && !VAR_6->allow_anonymous)) {
VAR_12 = VAR_39;
_kdc_set_e_text(VAR_0, ""Bad KDC options"");
goto out;
}
VAR_9.pvno = 5;
VAR_9.msg_type = VAR_40;
if (_kdc_is_anonymous(VAR_5, VAR_0->client_princ)) {
Realm VAR_41=VAR_42;
VAR_12 = copy_Realm(&VAR_41, &VAR_9.crealm);
} else
VAR_12 = copy_Realm(&VAR_0->client->entry.principal->realm, &VAR_9.crealm);
if (VAR_12)
goto out;
VAR_12 = _krb5_principal2principalname(&VAR_9.cname, VAR_0->client->entry.principal);
if (VAR_12)
goto out;
VAR_9.ticket.tkt_vno = 5;
VAR_12 = copy_Realm(&VAR_0->server->entry.principal->realm, &VAR_9.ticket.realm);
if (VAR_12)
goto out;
_krb5_principal2principalname(&VAR_9.ticket.sname,
VAR_0->server->entry.principal);
#define CNT(VAR_43,VAR_44) (((sp)->sname->name_type) == KRB5_NT_##t)
if (CNT(VAR_8, VAR_45) || CNT(VAR_8, VAR_46) || CNT(VAR_8, VAR_47) || CNT(VAR_8, VAR_48) || CNT(VAR_8, VAR_49))
VAR_9.ticket.sname.name_type = VAR_8->sname->name_type;
#undef CNT
VAR_0->et.flags.initial = 1;
if(VAR_0->client->entry.flags.forwardable && VAR_0->server->entry.flags.forwardable)
VAR_0->et.flags.forwardable = VAR_10.forwardable;
else if (VAR_10.forwardable) {
_kdc_set_e_text(VAR_0, ""Ticket may not be forwardable"");
VAR_12 = VAR_50;
goto out;
}
if(VAR_0->client->entry.flags.proxiable && VAR_0->server->entry.flags.proxiable)
VAR_0->et.flags.proxiable = VAR_10.proxiable;
else if (VAR_10.proxiable) {
_kdc_set_e_text(VAR_0, ""Ticket may not be proxiable"");
VAR_12 = VAR_50;
goto out;
}
if(VAR_0->client->entry.flags.postdate && VAR_0->server->entry.flags.postdate)
VAR_0->et.flags.may_postdate = VAR_10.allow_postdate;
else if (VAR_10.allow_postdate){
_kdc_set_e_text(VAR_0, ""Ticket may not be postdate"");
VAR_12 = VAR_50;
goto out;
}
if(!_kdc_check_addresses(VAR_5, VAR_6, VAR_8->addresses, VAR_3)) {
_kdc_set_e_text(VAR_0, ""Bad address list in requested"");
VAR_12 = VAR_51;
goto out;
}
VAR_12 = copy_PrincipalName(&VAR_9.cname, &VAR_0->et.cname);
if (VAR_12)
goto out;
VAR_12 = copy_Realm(&VAR_9.crealm, &VAR_0->et.crealm);
if (VAR_12)
goto out;
{
time_t VAR_52;
time_t VAR_44;
VAR_52 = VAR_0->et.authtime = VAR_53;
if(VAR_10.postdated && VAR_7->req_body.from){
ALLOC(VAR_0->et.starttime);
VAR_52 = *VAR_0->et.starttime = *VAR_7->req_body.from;
VAR_0->et.flags.invalid = 1;
VAR_0->et.flags.postdated = 1; 
}
_kdc_fix_time(&VAR_8->till);
VAR_44 = *VAR_8->till;
if(VAR_0->client->entry.max_life)
VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->client->entry.max_life);
if(VAR_0->server->entry.max_life)
VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->server->entry.max_life);
#if 0
VAR_44 = min(VAR_44, VAR_52 + VAR_54->max_life);
#endif
VAR_0->et.endtime = VAR_44;
if(VAR_10.renewable_ok && VAR_0->et.endtime < *VAR_8->till){
VAR_10.renewable = 1;
if(VAR_8->rtime == NULL){
ALLOC(VAR_8->rtime);
*VAR_8->rtime = 0;
}
if(*VAR_8->rtime < *VAR_8->till)
*VAR_8->rtime = *VAR_8->till;
}
if(VAR_10.renewable && VAR_8->rtime){
VAR_44 = *VAR_8->rtime;
if(VAR_44 == 0)
VAR_44 = VAR_55;
if(VAR_0->client->entry.max_renew)
VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->client->entry.max_renew);
if(VAR_0->server->entry.max_renew)
VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->server->entry.max_renew);
#if 0
VAR_44 = min(VAR_44, VAR_52 + VAR_54->max_renew);
#endif
ALLOC(VAR_0->et.renew_till);
*VAR_0->et.renew_till = VAR_44;
VAR_0->et.flags.renewable = 1;
}
}
if (_kdc_is_anon_request(VAR_8))
VAR_0->et.flags.anonymous = 1;
if(VAR_8->addresses){
ALLOC(VAR_0->et.caddr);
copy_HostAddresses(VAR_8->addresses, VAR_0->et.caddr);
}
VAR_0->et.transited.tr_type = VAR_56;
krb5_data_zero(&VAR_0->et.transited.contents);
VAR_0->ek.last_req.val = malloc(2 * sizeof(*VAR_0->ek.last_req.val));
if (VAR_0->ek.last_req.val == NULL) {
VAR_12 = VAR_57;
goto out;
}
VAR_0->ek.last_req.len = 0;
if (VAR_0->client->entry.pw_end
&& (VAR_6->kdc_warn_pwexpire == 0
|| VAR_53 + VAR_6->kdc_warn_pwexpire >= *VAR_0->client->entry.pw_end)) {
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_58;
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = *VAR_0->client->entry.pw_end;
++VAR_0->ek.last_req.len;
}
if (VAR_0->client->entry.valid_end) {
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_59;
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = *VAR_0->client->entry.valid_end;
++VAR_0->ek.last_req.len;
}
if (VAR_0->ek.last_req.len == 0) {
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_60;
VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = 0;
++VAR_0->ek.last_req.len;
}
VAR_0->ek.nonce = VAR_8->nonce;
if (VAR_0->client->entry.valid_end || VAR_0->client->entry.pw_end) {
ALLOC(VAR_0->ek.key_expiration);
if (VAR_0->client->entry.valid_end) {
if (VAR_0->client->entry.pw_end)
*VAR_0->ek.key_expiration = min(*VAR_0->client->entry.valid_end,
*VAR_0->client->entry.pw_end);
else
*VAR_0->ek.key_expiration = *VAR_0->client->entry.valid_end;
} else
*VAR_0->ek.key_expiration = *VAR_0->client->entry.pw_end;
} else
VAR_0->ek.key_expiration = NULL;
VAR_0->ek.flags = VAR_0->et.flags;
VAR_0->ek.authtime = VAR_0->et.authtime;
if (VAR_0->et.starttime) {
ALLOC(VAR_0->ek.starttime);
*VAR_0->ek.starttime = *VAR_0->et.starttime;
}
VAR_0->ek.endtime = VAR_0->et.endtime;
if (VAR_0->et.renew_till) {
ALLOC(VAR_0->ek.renew_till);
*VAR_0->ek.renew_till = *VAR_0->et.renew_till;
}
VAR_12 = copy_Realm(&VAR_9.ticket.realm, &VAR_0->ek.srealm);
if (VAR_12)
goto out;
VAR_12 = copy_PrincipalName(&VAR_9.ticket.sname, &VAR_0->ek.sname);
if (VAR_12)
goto out;
if(VAR_0->et.caddr){
ALLOC(VAR_0->ek.caddr);
copy_HostAddresses(VAR_0->et.caddr, VAR_0->ek.caddr);
}
if (VAR_0->session_key.keytype == VAR_61) {
VAR_12 = krb5_generate_random_keyblock(VAR_5, VAR_0->sessionetype, &VAR_0->session_key);
if (VAR_12)
goto out;
}
if (VAR_0->reply_key.keytype == VAR_61) {
_kdc_set_e_text(VAR_0, ""Client have no reply key"");
VAR_12 = VAR_37;
goto out;
}
VAR_12 = copy_EncryptionKey(&VAR_0->session_key, &VAR_0->et.key);
if (VAR_12)
goto out;
VAR_12 = copy_EncryptionKey(&VAR_0->session_key, &VAR_0->ek.key);
if (VAR_12)
goto out;
if (VAR_0->outpadata.len) {
ALLOC(VAR_9.padata);
if (VAR_9.padata == NULL) {
VAR_12 = VAR_57;
goto out;
}
VAR_12 = copy_METHOD_DATA(&VAR_0->outpadata, VAR_9.padata);
if (VAR_12)
goto out;
}
if (send_pac_p(VAR_5, VAR_7)) {
generate_pac(VAR_0, VAR_13);
}
_kdc_log_timestamp(VAR_5, VAR_6, ""AS-REQ"", VAR_0->et.authtime, VAR_0->et.starttime,
VAR_0->et.endtime, VAR_0->et.renew_till);
VAR_12 = _kdc_add_KRB5SignedPath(VAR_5,
VAR_6,
VAR_0->server,
VAR_11,
VAR_0->client->entry.principal,
NULL,
NULL,
&VAR_0->et);
if (VAR_12)
goto out;
log_as_req(VAR_5, VAR_6, VAR_0->reply_key.keytype, VAR_11, VAR_8);
VAR_0->et.flags.enc_pa_rep = VAR_0->ek.flags.enc_pa_rep = 1;
VAR_15 = 0;
VAR_19 = _kdc_find_padata(VAR_7, &VAR_15, VAR_62);
if (VAR_19) {
VAR_12 = add_enc_pa_rep(VAR_0);
if (VAR_12) {
const char *VAR_28 = krb5_get_error_message(VAR_0->context, VAR_12);
_kdc_r_log(VAR_0, 0, ""add_enc_pa_rep failed: %s: %d"", VAR_28, VAR_12);
krb5_free_error_message(VAR_0->context, VAR_28);
goto out;
}
}
VAR_12 = _kdc_encode_reply(VAR_5, VAR_6,
VAR_0->armor_crypto, VAR_7->req_body.nonce,
&VAR_9, &VAR_0->et, &VAR_0->ek, VAR_11, VAR_0->server->entry.kvno,
&VAR_13->key, VAR_0->client->entry.kvno,
&VAR_0->reply_key, 0, &VAR_0->e_text, VAR_1);
if (VAR_12)
goto out;
if (VAR_4 && VAR_1->length > VAR_6->max_datagram_reply_length) {
krb5_data_free(VAR_1);
VAR_12 = VAR_63;
_kdc_set_e_text(VAR_0, ""Reply packet too large"");
}
out:
free_AS_REP(&VAR_9);
if(VAR_12 != 0 && VAR_12 != VAR_24 && VAR_1->length == 0) {
VAR_12 = _kdc_fast_mk_error(VAR_5, VAR_0,
&VAR_18,
VAR_0->armor_crypto,
&VAR_7->req_body,
VAR_12, VAR_0->e_text,
VAR_0->server_princ,
&VAR_0->client_princ->name,
&VAR_0->client_princ->realm,
NULL, NULL,
VAR_1);
if (VAR_12)
goto out2;
}
out2:
free_EncTicketPart(&VAR_0->et);
free_EncKDCRepPart(&VAR_0->ek);
free_KDCFastState(&VAR_0->fast);
if (VAR_18.len)
free_METHOD_DATA(&VAR_18);
if (VAR_0->outpadata.len)
free_METHOD_DATA(&VAR_0->outpadata);
if (VAR_0->client_princ) {
krb5_free_principal(VAR_5, VAR_0->client_princ);
VAR_0->client_princ = NULL;
}
if (VAR_0->client_name) {
free(VAR_0->client_name);
VAR_0->client_name = NULL;
}
if (VAR_0->server_princ){
krb5_free_principal(VAR_5, VAR_0->server_princ);
VAR_0->server_princ = NULL;
}
if (VAR_0->server_name) {
free(VAR_0->server_name);
VAR_0->server_name = NULL;
}
if (VAR_0->client)
_kdc_free_ent(VAR_5, VAR_0->client);
if (VAR_0->server)
_kdc_free_ent(VAR_5, VAR_0->server);
if (VAR_0->armor_crypto) {
krb5_crypto_destroy(VAR_0->context, VAR_0->armor_crypto);
VAR_0->armor_crypto = NULL;
}
krb5_free_keyblock_contents(VAR_0->context, &VAR_0->reply_key);
krb5_free_keyblock_contents(VAR_0->context, &VAR_0->session_key);
return VAR_12;
}",heimdal/1a6a6e462dc2ac6111f9e02c6852ddec4849b887/kerberos5.c/vul/before/0.json,"krb5_error_code
_kdc_as_rep(kdc_request_t r,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr *from_addr,
	    int datagram_reply)
{
    krb5_context context = r->context;
    krb5_kdc_configuration *config = r->config;
    KDC_REQ *req = &r->req;
    KDC_REQ_BODY *b = NULL;
    AS_REP rep;
    KDCOptions f;
    krb5_enctype setype;
    krb5_error_code ret = 0;
    Key *skey;
    int found_pa = 0;
    int i, flags = HDB_F_FOR_AS_REQ;
    METHOD_DATA error_method;
    const PA_DATA *pa;

    memset(&rep, 0, sizeof(rep));
    error_method.len = 0;
    error_method.val = NULL;

    /*
     * Look for FAST armor and unwrap
     */
    ret = _kdc_fast_unwrap_request(r);
    if (ret) {
	_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
	goto out;
    }

    b = &req->req_body;
    f = b->kdc_options;

    if (f.canonicalize)
	flags |= HDB_F_CANON;

    if(b->sname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No server in request"");
    } else{
	ret = _krb5_principalname2krb5_principal (context,
						  &r->server_princ,
						  *(b->sname),
						  b->realm);
	if (ret == 0)
	    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed server name from %s"", from);
	goto out;
    }
    if(b->cname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No client in request"");
    } else {
	ret = _krb5_principalname2krb5_principal (context,
						  &r->client_princ,
						  *(b->cname),
						  b->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed client name from %s"", from);
	goto out;
    }

    kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
	    r->client_name, from, r->server_name);

    /*
     *
     */

    if (_kdc_is_anonymous(context, r->client_princ)) {
	if (!_kdc_is_anon_request(b)) {
	    kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
    } else if (_kdc_is_anon_request(b)) {
	kdc_log(context, config, 0,
		""Request for a anonymous ticket with non ""
		""anonymous client name: %s"", r->client_name);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     *
     */

    ret = _kdc_db_fetch(context, config, r->client_princ,
			HDB_F_GET_CLIENT | flags, NULL,
			&r->clientdb, &r->client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
		r->client_name);
	goto out;
    } else if (ret == HDB_ERR_WRONG_REALM) {
	char *fixed_client_name = NULL;

	ret = krb5_unparse_name(context, r->client->entry.principal,
				&fixed_client_name);
	if (ret) {
	    goto out;
	}

	kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
		r->client_name, fixed_client_name);
	free(fixed_client_name);

	ret = _kdc_fast_mk_error(context, r,
				 &error_method,
				 r->armor_crypto,
				 &req->req_body,
				 KRB5_KDC_ERR_WRONG_REALM,
				 NULL,
				 r->server_princ,
				 NULL,
				 &r->client->entry.principal->realm,
				 NULL, NULL,
				 reply);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }
    ret = _kdc_db_fetch(context, config, r->server_princ,
			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
			NULL, NULL, &r->server);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
		r->server_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     * Select a session enctype from the list of the crypto system
     * supported enctypes that is supported by the client and is one of
     * the enctype of the enctype of the service (likely krbtgt).
     *
     * The latter is used as a hint of what enctypes all KDC support,
     * to make sure a newer version of KDC won't generate a session
     * enctype that an older version of a KDC in the same realm can't
     * decrypt.
     */

    ret = _kdc_find_etype(context,
			  krb5_principal_is_krbtgt(context, r->server_princ) ?
			  config->tgt_use_strongest_session_key :
			  config->svc_use_strongest_session_key, FALSE,
			  r->client, b->etype.val, b->etype.len, &r->sessionetype,
			  NULL);
    if (ret) {
	kdc_log(context, config, 0,
		""Client (%s) from %s has no common enctypes with KDC ""
		""to use for the session key"",
		r->client_name, from);
	goto out;
    }

    /*
     * Pre-auth processing
     */

    if(req->padata){
	unsigned int n;

	log_patypes(context, config, req->padata);

	/* Check if preauth matching */

	for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if (pat[n].validate == NULL)
		continue;
	    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
		continue;

	    kdc_log(context, config, 5,
		    ""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
	    i = 0;
	    pa = _kdc_find_padata(req, &i, pat[n].type);
	    if (pa) {
		ret = pat[n].validate(r, pa);
		if (ret != 0) {
		    goto out;
		}
		kdc_log(context, config, 0,
			""%s pre-authentication succeeded -- %s"",
			pat[n].name, r->client_name);
		found_pa = 1;
		r->et.flags.pre_authent = 1;
	    }
	}
    }

    if (found_pa == 0) {
	Key *ckey = NULL;
	size_t n;

	for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if ((pat[n].flags & PA_ANNOUNCE) == 0)
		continue;
	    ret = krb5_padata_add(context, &error_method,
				  pat[n].type, NULL, 0);
	    if (ret)
		goto out;
	}

	/*
	 * If there is a client key, send ETYPE_INFO{,2}
	 */
	ret = _kdc_find_etype(context,
			      config->preauth_use_strongest_session_key, TRUE,
			      r->client, b->etype.val, b->etype.len, NULL, &ckey);
	if (ret == 0) {

	    /*
	     * RFC4120 requires:
	     * - If the client only knows about old enctypes, then send
	     *   both info replies (we send 'info' first in the list).
	     * - If the client is 'modern', because it knows about 'new'
	     *   enctype types, then only send the 'info2' reply.
	     *
	     * Before we send the full list of etype-info data, we pick
	     * the client key we would have used anyway below, just pick
	     * that instead.
	     */

	    if (older_enctype(ckey->key.keytype)) {
		ret = get_pa_etype_info(context, config,
					&error_method, ckey);
		if (ret)
		    goto out;
	    }
	    ret = get_pa_etype_info2(context, config,
				     &error_method, ckey);
	    if (ret)
		goto out;
	}

	/* 
	 * send requre preauth is its required or anon is requested,
	 * anon is today only allowed via preauth mechanisms.
	 */
	if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
	    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
	    _kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
	    goto out;
	}

	if (ckey == NULL) {
	    ret = KRB5KDC_ERR_CLIENT_NOTYET;
	    _kdc_set_e_text(r, ""Doesn't have a client key available"");
	    goto out;
	}
	krb5_free_keyblock_contents(r->context,  &r->reply_key);
	ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
	if (ret)
	    goto out;
    }

    if (r->clientdb->hdb_auth_status) {
	r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
				     HDB_AUTH_SUCCESS);
    }

    /*
     * Verify flags after the user been required to prove its identity
     * with in a preauth mech.
     */

    ret = _kdc_check_access(context, config, r->client, r->client_name,
			    r->server, r->server_name,
			    req, &error_method);
    if(ret)
	goto out;

    /*
     * Select the best encryption type for the KDC with out regard to
     * the client since the client never needs to read that data.
     */

    ret = _kdc_get_preferred_key(context, config,
				 r->server, r->server_name,
				 &setype, &skey);
    if(ret)
	goto out;

    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
	ret = KRB5KDC_ERR_BADOPTION;
	_kdc_set_e_text(r, ""Bad KDC options"");
	goto out;
    }

    /*
     * Build reply
     */

    rep.pvno = 5;
    rep.msg_type = krb_as_rep;

    if (_kdc_is_anonymous(context, r->client_princ)) {
	Realm anon_realm=KRB5_ANON_REALM;
	ret = copy_Realm(&anon_realm, &rep.crealm);
    } else
	ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
    if (ret)
	goto out;
    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
    if (ret)
	goto out;

    rep.ticket.tkt_vno = 5;
    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
    if (ret)
	goto out;
    _krb5_principal2principalname(&rep.ticket.sname,
				  r->server->entry.principal);
    /* java 1.6 expects the name to be the same type, lets allow that
     * uncomplicated name-types. */
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
	rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT

    r->et.flags.initial = 1;
    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
	r->et.flags.forwardable = f.forwardable;
    else if (f.forwardable) {
	_kdc_set_e_text(r, ""Ticket may not be forwardable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
	r->et.flags.proxiable = f.proxiable;
    else if (f.proxiable) {
	_kdc_set_e_text(r, ""Ticket may not be proxiable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
	r->et.flags.may_postdate = f.allow_postdate;
    else if (f.allow_postdate){
	_kdc_set_e_text(r, ""Ticket may not be postdate"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }

    /* check for valid set of addresses */
    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
	_kdc_set_e_text(r, ""Bad address list in requested"");
	ret = KRB5KRB_AP_ERR_BADADDR;
	goto out;
    }

    ret = copy_PrincipalName(&rep.cname, &r->et.cname);
    if (ret)
	goto out;
    ret = copy_Realm(&rep.crealm, &r->et.crealm);
    if (ret)
	goto out;

    {
	time_t start;
	time_t t;
	
	start = r->et.authtime = kdc_time;

	if(f.postdated && req->req_body.from){
	    ALLOC(r->et.starttime);
	    start = *r->et.starttime = *req->req_body.from;
	    r->et.flags.invalid = 1;
	    r->et.flags.postdated = 1; /* XXX ??? */
	}
	_kdc_fix_time(&b->till);
	t = *b->till;

	/* be careful not overflowing */

	if(r->client->entry.max_life)
	    t = start + min(t - start, *r->client->entry.max_life);
	if(r->server->entry.max_life)
	    t = start + min(t - start, *r->server->entry.max_life);
#if 0
	t = min(t, start + realm->max_life);
#endif
	r->et.endtime = t;
	if(f.renewable_ok && r->et.endtime < *b->till){
	    f.renewable = 1;
	    if(b->rtime == NULL){
		ALLOC(b->rtime);
		*b->rtime = 0;
	    }
	    if(*b->rtime < *b->till)
		*b->rtime = *b->till;
	}
	if(f.renewable && b->rtime){
	    t = *b->rtime;
	    if(t == 0)
		t = MAX_TIME;
	    if(r->client->entry.max_renew)
		t = start + min(t - start, *r->client->entry.max_renew);
	    if(r->server->entry.max_renew)
		t = start + min(t - start, *r->server->entry.max_renew);
#if 0
	    t = min(t, start + realm->max_renew);
#endif
	    ALLOC(r->et.renew_till);
	    *r->et.renew_till = t;
	    r->et.flags.renewable = 1;
	}
    }

    if (_kdc_is_anon_request(b))
	r->et.flags.anonymous = 1;

    if(b->addresses){
	ALLOC(r->et.caddr);
	copy_HostAddresses(b->addresses, r->et.caddr);
    }

    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&r->et.transited.contents);

    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded
     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus
     * incapable of correctly decoding SEQUENCE OF's of zero length.
     *
     * To fix this, always send at least one no-op last_req
     *
     * If there's a pw_end or valid_end we will use that,
     * otherwise just a dummy lr.
     */
    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
    if (r->ek.last_req.val == NULL) {
	ret = ENOMEM;
	goto out;
    }
    r->ek.last_req.len = 0;
    if (r->client->entry.pw_end
	&& (config->kdc_warn_pwexpire == 0
	    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
	++r->ek.last_req.len;
    }
    if (r->client->entry.valid_end) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
	++r->ek.last_req.len;
    }
    if (r->ek.last_req.len == 0) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
	++r->ek.last_req.len;
    }
    r->ek.nonce = b->nonce;
    if (r->client->entry.valid_end || r->client->entry.pw_end) {
	ALLOC(r->ek.key_expiration);
	if (r->client->entry.valid_end) {
	    if (r->client->entry.pw_end)
		*r->ek.key_expiration = min(*r->client->entry.valid_end,
					 *r->client->entry.pw_end);
	    else
		*r->ek.key_expiration = *r->client->entry.valid_end;
	} else
	    *r->ek.key_expiration = *r->client->entry.pw_end;
    } else
	r->ek.key_expiration = NULL;
    r->ek.flags = r->et.flags;
    r->ek.authtime = r->et.authtime;
    if (r->et.starttime) {
	ALLOC(r->ek.starttime);
	*r->ek.starttime = *r->et.starttime;
    }
    r->ek.endtime = r->et.endtime;
    if (r->et.renew_till) {
	ALLOC(r->ek.renew_till);
	*r->ek.renew_till = *r->et.renew_till;
    }
    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
    if (ret)
	goto out;
    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
    if (ret)
	goto out;
    if(r->et.caddr){
	ALLOC(r->ek.caddr);
	copy_HostAddresses(r->et.caddr, r->ek.caddr);
    }

    /*
     * Check and session and reply keys
     */

    if (r->session_key.keytype == ETYPE_NULL) {
	ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
	if (ret)
	    goto out;
    }

    if (r->reply_key.keytype == ETYPE_NULL) {
	_kdc_set_e_text(r, ""Client have no reply key"");
	ret = KRB5KDC_ERR_CLIENT_NOTYET;
	goto out;
    }

    ret = copy_EncryptionKey(&r->session_key, &r->et.key);
    if (ret)
	goto out;

    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
    if (ret)
	goto out;

    if (r->outpadata.len) {

	ALLOC(rep.padata);
	if (rep.padata == NULL) {
	    ret = ENOMEM;
	    goto out;
	}
	ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
	if (ret)
	    goto out;
    }

    /* Add the PAC */
    if (send_pac_p(context, req)) {
	generate_pac(r, skey);
    }

    _kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
		       r->et.endtime, r->et.renew_till);

    /* do this as the last thing since this signs the EncTicketPart */
    ret = _kdc_add_KRB5SignedPath(context,
				  config,
				  r->server,
				  setype,
				  r->client->entry.principal,
				  NULL,
				  NULL,
				  &r->et);
    if (ret)
	goto out;

    log_as_req(context, config, r->reply_key.keytype, setype, b);

    /*
     * We always say we support FAST/enc-pa-rep
     */

    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;

    /*
     * Add REQ_ENC_PA_REP if client supports it
     */

    i = 0;
    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
    if (pa) {

	ret = add_enc_pa_rep(r);
	if (ret) {
	    const char *msg = krb5_get_error_message(r->context, ret);
	    _kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
	    krb5_free_error_message(r->context, msg);
	    goto out;
	}
    }

    /*
     *
     */

    ret = _kdc_encode_reply(context, config,
			    r->armor_crypto, req->req_body.nonce,
			    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,
			    &skey->key, r->client->entry.kvno,
			    &r->reply_key, 0, &r->e_text, reply);
    if (ret)
	goto out;

    /*
     * Check if message too large
     */
    if (datagram_reply && reply->length > config->max_datagram_reply_length) {
	krb5_data_free(reply);
	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
	_kdc_set_e_text(r, ""Reply packet too large"");
    }

out:
    free_AS_REP(&rep);

    /*
     * In case of a non proxy error, build an error message.
     */
    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
	ret = _kdc_fast_mk_error(context, r,
				 &error_method,
				 r->armor_crypto,
				 &req->req_body,
				 ret, r->e_text,
				 r->server_princ,
				 r->client_princ ?
                                     &r->client_princ->name : NULL,
				 r->client_princ ?
                                     &r->client_princ->realm : NULL,
				 NULL, NULL,
				 reply);
	if (ret)
	    goto out2;
    }
out2:
    free_EncTicketPart(&r->et);
    free_EncKDCRepPart(&r->ek);
    free_KDCFastState(&r->fast);

    if (error_method.len)
	free_METHOD_DATA(&error_method);
    if (r->outpadata.len)
	free_METHOD_DATA(&r->outpadata);
    if (r->client_princ) {
	krb5_free_principal(context, r->client_princ);
	r->client_princ = NULL;
    }
    if (r->client_name) {
	free(r->client_name);
	r->client_name = NULL;
    }
    if (r->server_princ){
	krb5_free_principal(context, r->server_princ);
	r->server_princ = NULL;
    }
    if (r->server_name) {
	free(r->server_name);
	r->server_name = NULL;
    }
    if (r->client)
	_kdc_free_ent(context, r->client);
    if (r->server)
	_kdc_free_ent(context, r->server);
    if (r->armor_crypto) {
	krb5_crypto_destroy(r->context, r->armor_crypto);
	r->armor_crypto = NULL;
    }
    krb5_free_keyblock_contents(r->context, &r->reply_key);
    krb5_free_keyblock_contents(r->context, &r->session_key);
    return ret;
}","krb5_error_code
_kdc_as_rep(kdc_request_t VAR_0,
	    krb5_data *VAR_1,
	    const char *VAR_2,
	    struct sockaddr *VAR_3,
	    int VAR_4)
{
    krb5_context VAR_5 = VAR_0->context;
    krb5_kdc_configuration *VAR_6 = VAR_0->config;
    KDC_REQ *VAR_7 = &VAR_0->req;
    KDC_REQ_BODY *VAR_8 = NULL;
    AS_REP VAR_9;
    KDCOptions VAR_10;
    krb5_enctype VAR_11;
    krb5_error_code VAR_12 = 0;
    Key *VAR_13;
    int VAR_14 = 0;
    int VAR_15, VAR_16 = VAR_17;
    METHOD_DATA VAR_18;
    const PA_DATA *VAR_19;

    memset(&VAR_9, 0, sizeof(VAR_9));
    VAR_18.len = 0;
    VAR_18.val = NULL;

    /* COMMENT_0 */
                                     
       
    VAR_12 = _kdc_fast_unwrap_request(VAR_0);
    if (VAR_12) {
	_kdc_r_log(VAR_0, 0, ""FAST unwrap request from %s failed: %d"", VAR_2, VAR_12);
	goto out;
    }

    VAR_8 = &VAR_7->req_body;
    VAR_10 = VAR_8->kdc_options;

    if (VAR_10.canonicalize)
	VAR_16 |= VAR_20;

    if(VAR_8->sname == NULL){
	VAR_12 = VAR_21;
	_kdc_set_e_text(VAR_0, ""No server in request"");
    } else{
	VAR_12 = _krb5_principalname2krb5_principal (VAR_5,
						  &VAR_0->server_princ,
						  *(VAR_8->sname),
						  VAR_8->realm);
	if (VAR_12 == 0)
	    VAR_12 = krb5_unparse_name(VAR_5, VAR_0->server_princ, &VAR_0->server_name);
    }
    if (VAR_12) {
	kdc_log(VAR_5, VAR_6, 0,
		""AS-REQ malformed server name from %s"", VAR_2);
	goto out;
    }
    if(VAR_8->cname == NULL){
	VAR_12 = VAR_21;
	_kdc_set_e_text(VAR_0, ""No client in request"");
    } else {
	VAR_12 = _krb5_principalname2krb5_principal (VAR_5,
						  &VAR_0->client_princ,
						  *(VAR_8->cname),
						  VAR_8->realm);
	if (VAR_12)
	    goto out;

	VAR_12 = krb5_unparse_name(VAR_5, VAR_0->client_princ, &VAR_0->client_name);
    }
    if (VAR_12) {
	kdc_log(VAR_5, VAR_6, 0,
		""AS-REQ malformed client name from %s"", VAR_2);
	goto out;
    }

    kdc_log(VAR_5, VAR_6, 0, ""AS-REQ %s from %s for %s"",
	    VAR_0->client_name, VAR_2, VAR_0->server_name);

    /* COMMENT_3 */
      
       

    if (_kdc_is_anonymous(VAR_5, VAR_0->client_princ)) {
	if (!_kdc_is_anon_request(VAR_8)) {
	    kdc_log(VAR_5, VAR_6, 0, ""Anonymous ticket w/o anonymous flag"");
	    VAR_12 = VAR_22;
	    goto out;
	}
    } else if (_kdc_is_anon_request(VAR_8)) {
	kdc_log(VAR_5, VAR_6, 0,
		""Request for a anonymous ticket with non ""
		""anonymous client name: %s"", VAR_0->client_name);
	VAR_12 = VAR_22;
	goto out;
    }

    /* COMMENT_6 */
      
       

    VAR_12 = _kdc_db_fetch(VAR_5, VAR_6, VAR_0->client_princ,
			VAR_23 | VAR_16, NULL,
			&VAR_0->clientdb, &VAR_0->client);
    if(VAR_12 == VAR_24) {
	kdc_log(VAR_5, VAR_6, 5, ""client %s does not have secrets at this KDC, need to proxy"",
		VAR_0->client_name);
	goto out;
    } else if (VAR_12 == VAR_25) {
	char *VAR_26 = NULL;

	VAR_12 = krb5_unparse_name(VAR_5, VAR_0->client->entry.principal,
				&VAR_26);
	if (VAR_12) {
	    goto out;
	}

	kdc_log(VAR_5, VAR_6, 0, ""WRONG_REALM - %s -> %s"",
		VAR_0->client_name, VAR_26);
	free(VAR_26);

	VAR_12 = _kdc_fast_mk_error(VAR_5, VAR_0,
				 &VAR_18,
				 VAR_0->armor_crypto,
				 &VAR_7->req_body,
				 VAR_27,
				 NULL,
				 VAR_0->server_princ,
				 NULL,
				 &VAR_0->client->entry.principal->realm,
				 NULL, NULL,
				 VAR_1);
	goto out;
    } else if(VAR_12){
	const char *VAR_28 = krb5_get_error_message(VAR_5, VAR_12);
	kdc_log(VAR_5, VAR_6, 0, ""UNKNOWN -- %s: %s"", VAR_0->client_name, VAR_28);
	krb5_free_error_message(VAR_5, VAR_28);
	VAR_12 = VAR_22;
	goto out;
    }
    VAR_12 = _kdc_db_fetch(VAR_5, VAR_6, VAR_0->server_princ,
			VAR_29|VAR_30 | VAR_16,
			NULL, NULL, &VAR_0->server);
    if(VAR_12 == VAR_24) {
	kdc_log(VAR_5, VAR_6, 5, ""target %s does not have secrets at this KDC, need to proxy"",
		VAR_0->server_name);
	goto out;
    } else if(VAR_12){
	const char *VAR_28 = krb5_get_error_message(VAR_5, VAR_12);
	kdc_log(VAR_5, VAR_6, 0, ""UNKNOWN -- %s: %s"", VAR_0->server_name, VAR_28);
	krb5_free_error_message(VAR_5, VAR_28);
	VAR_12 = VAR_31;
	goto out;
    }

    /* COMMENT_9 */
                                                                  
                                                                       
                                                                 
      
                                                                     
                                                                   
                                                                     
               
       

    VAR_12 = _kdc_find_etype(VAR_5,
			  krb5_principal_is_krbtgt(VAR_5, VAR_0->server_princ) ?
			  VAR_6->tgt_use_strongest_session_key :
			  VAR_6->svc_use_strongest_session_key, FALSE,
			  VAR_0->client, VAR_8->etype.val, VAR_8->etype.len, &VAR_0->sessionetype,
			  NULL);
    if (VAR_12) {
	kdc_log(VAR_5, VAR_6, 0,
		""Client (%s) from %s has no common enctypes with KDC ""
		""to use for the session key"",
		VAR_0->client_name, VAR_2);
	goto out;
    }

    /* COMMENT_19 */
                          
       

    if(VAR_7->padata){
	unsigned int VAR_32;

	log_patypes(VAR_5, VAR_6, VAR_7->padata);

	/* COMMENT_22 */

	for (VAR_32 = 0; !VAR_14 && VAR_32 < sizeof(pat) / sizeof(pat[0]); VAR_32++) {
	    if (pat[VAR_32].validate == NULL)
		continue;
	    if (VAR_0->armor_crypto == NULL && (pat[VAR_32].flags & VAR_33))
		continue;

	    kdc_log(VAR_5, VAR_6, 5,
		    ""Looking for %s pa-data -- %s"", pat[VAR_32].name, VAR_0->client_name);
	    VAR_15 = 0;
	    VAR_19 = _kdc_find_padata(VAR_7, &VAR_15, pat[VAR_32].type);
	    if (VAR_19) {
		VAR_12 = pat[VAR_32].validate(VAR_0, VAR_19);
		if (VAR_12 != 0) {
		    goto out;
		}
		kdc_log(VAR_5, VAR_6, 0,
			""%s pre-authentication succeeded -- %s"",
			pat[VAR_32].name, VAR_0->client_name);
		VAR_14 = 1;
		VAR_0->et.flags.pre_authent = 1;
	    }
	}
    }

    if (VAR_14 == 0) {
	Key *VAR_34 = NULL;
	size_t VAR_32;

	for (VAR_32 = 0; VAR_32 < sizeof(pat) / sizeof(pat[0]); VAR_32++) {
	    if ((pat[VAR_32].flags & VAR_35) == 0)
		continue;
	    VAR_12 = krb5_padata_add(VAR_5, &VAR_18,
				  pat[VAR_32].type, NULL, 0);
	    if (VAR_12)
		goto out;
	}

	/* COMMENT_23 */
                                                 
    
	VAR_12 = _kdc_find_etype(VAR_5,
			      VAR_6->preauth_use_strongest_session_key, TRUE,
			      VAR_0->client, VAR_8->etype.val, VAR_8->etype.len, NULL, &VAR_34);
	if (VAR_12 == 0) {

	    /* COMMENT_26 */
                         
                                                                
                                                               
                                                                 
                                                          
       
                                                                
                                                                 
                     
        

	    if (older_enctype(VAR_34->key.keytype)) {
		VAR_12 = get_pa_etype_info(VAR_5, VAR_6,
					&VAR_18, VAR_34);
		if (VAR_12)
		    goto out;
	    }
	    VAR_12 = get_pa_etype_info2(VAR_5, VAR_6,
				     &VAR_18, VAR_34);
	    if (VAR_12)
		goto out;
	}

	/* COMMENT_37 */
                                                             
                                                      
    
	if (require_preauth_p(VAR_0) || _kdc_is_anon_request(VAR_8)) {
	    VAR_12 = VAR_36;
	    _kdc_set_e_text(VAR_0, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
	    goto out;
	}

	if (VAR_34 == NULL) {
	    VAR_12 = VAR_37;
	    _kdc_set_e_text(VAR_0, ""Doesn't have a client key available"");
	    goto out;
	}
	krb5_free_keyblock_contents(VAR_0->context,  &VAR_0->reply_key);
	VAR_12 = krb5_copy_keyblock_contents(VAR_0->context, &VAR_34->key, &VAR_0->reply_key);
	if (VAR_12)
	    goto out;
    }

    if (VAR_0->clientdb->hdb_auth_status) {
	VAR_0->clientdb->hdb_auth_status(VAR_5, VAR_0->clientdb, VAR_0->client, 
				     VAR_38);
    }

    /* COMMENT_41 */
                                                                      
                              
       

    VAR_12 = _kdc_check_access(VAR_5, VAR_6, VAR_0->client, VAR_0->client_name,
			    VAR_0->server, VAR_0->server_name,
			    VAR_7, &VAR_18);
    if(VAR_12)
	goto out;

    /* COMMENT_45 */
                                                                     
                                                                 
       

    VAR_12 = _kdc_get_preferred_key(VAR_5, VAR_6,
				 VAR_0->server, VAR_0->server_name,
				 &VAR_11, &VAR_13);
    if(VAR_12)
	goto out;

    if(VAR_10.renew || VAR_10.validate || VAR_10.proxy || VAR_10.forwarded || VAR_10.enc_tkt_in_skey
       || (_kdc_is_anon_request(VAR_8) && !VAR_6->allow_anonymous)) {
	VAR_12 = VAR_39;
	_kdc_set_e_text(VAR_0, ""Bad KDC options"");
	goto out;
    }

    /* COMMENT_49 */
                  
       

    VAR_9.pvno = 5;
    VAR_9.msg_type = VAR_40;

    if (_kdc_is_anonymous(VAR_5, VAR_0->client_princ)) {
	Realm VAR_41=VAR_42;
	VAR_12 = copy_Realm(&VAR_41, &VAR_9.crealm);
    } else
	VAR_12 = copy_Realm(&VAR_0->client->entry.principal->realm, &VAR_9.crealm);
    if (VAR_12)
	goto out;
    VAR_12 = _krb5_principal2principalname(&VAR_9.cname, VAR_0->client->entry.principal);
    if (VAR_12)
	goto out;

    VAR_9.ticket.tkt_vno = 5;
    VAR_12 = copy_Realm(&VAR_0->server->entry.principal->realm, &VAR_9.ticket.realm);
    if (VAR_12)
	goto out;
    _krb5_principal2principalname(&VAR_9.ticket.sname,
				  VAR_0->server->entry.principal);
    /* COMMENT_52 */
                                   
#define CNT(VAR_43,VAR_44) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(VAR_8, VAR_45) || CNT(VAR_8, VAR_46) || CNT(VAR_8, VAR_47) || CNT(VAR_8, VAR_48) || CNT(VAR_8, VAR_49))
	VAR_9.ticket.sname.name_type = VAR_8->sname->name_type;
#undef CNT

    VAR_0->et.flags.initial = 1;
    if(VAR_0->client->entry.flags.forwardable && VAR_0->server->entry.flags.forwardable)
	VAR_0->et.flags.forwardable = VAR_10.forwardable;
    else if (VAR_10.forwardable) {
	_kdc_set_e_text(VAR_0, ""Ticket may not be forwardable"");
	VAR_12 = VAR_50;
	goto out;
    }
    if(VAR_0->client->entry.flags.proxiable && VAR_0->server->entry.flags.proxiable)
	VAR_0->et.flags.proxiable = VAR_10.proxiable;
    else if (VAR_10.proxiable) {
	_kdc_set_e_text(VAR_0, ""Ticket may not be proxiable"");
	VAR_12 = VAR_50;
	goto out;
    }
    if(VAR_0->client->entry.flags.postdate && VAR_0->server->entry.flags.postdate)
	VAR_0->et.flags.may_postdate = VAR_10.allow_postdate;
    else if (VAR_10.allow_postdate){
	_kdc_set_e_text(VAR_0, ""Ticket may not be postdate"");
	VAR_12 = VAR_50;
	goto out;
    }

    /* COMMENT_54 */
    if(!_kdc_check_addresses(VAR_5, VAR_6, VAR_8->addresses, VAR_3)) {
	_kdc_set_e_text(VAR_0, ""Bad address list in requested"");
	VAR_12 = VAR_51;
	goto out;
    }

    VAR_12 = copy_PrincipalName(&VAR_9.cname, &VAR_0->et.cname);
    if (VAR_12)
	goto out;
    VAR_12 = copy_Realm(&VAR_9.crealm, &VAR_0->et.crealm);
    if (VAR_12)
	goto out;

    {
	time_t VAR_52;
	time_t VAR_44;
	
	VAR_52 = VAR_0->et.authtime = VAR_53;

	if(VAR_10.postdated && VAR_7->req_body.from){
	    ALLOC(VAR_0->et.starttime);
	    VAR_52 = *VAR_0->et.starttime = *VAR_7->req_body.from;
	    VAR_0->et.flags.invalid = 1;
	    VAR_0->et.flags.postdated = 1; /* COMMENT_55 */
	}
	_kdc_fix_time(&VAR_8->till);
	VAR_44 = *VAR_8->till;

	/* COMMENT_56 */

	if(VAR_0->client->entry.max_life)
	    VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->client->entry.max_life);
	if(VAR_0->server->entry.max_life)
	    VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->server->entry.max_life);
#if 0
	VAR_44 = min(VAR_44, VAR_52 + VAR_54->max_life);
#endif
	VAR_0->et.endtime = VAR_44;
	if(VAR_10.renewable_ok && VAR_0->et.endtime < *VAR_8->till){
	    VAR_10.renewable = 1;
	    if(VAR_8->rtime == NULL){
		ALLOC(VAR_8->rtime);
		*VAR_8->rtime = 0;
	    }
	    if(*VAR_8->rtime < *VAR_8->till)
		*VAR_8->rtime = *VAR_8->till;
	}
	if(VAR_10.renewable && VAR_8->rtime){
	    VAR_44 = *VAR_8->rtime;
	    if(VAR_44 == 0)
		VAR_44 = VAR_55;
	    if(VAR_0->client->entry.max_renew)
		VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->client->entry.max_renew);
	    if(VAR_0->server->entry.max_renew)
		VAR_44 = VAR_52 + min(VAR_44 - VAR_52, *VAR_0->server->entry.max_renew);
#if 0
	    VAR_44 = min(VAR_44, VAR_52 + VAR_54->max_renew);
#endif
	    ALLOC(VAR_0->et.renew_till);
	    *VAR_0->et.renew_till = VAR_44;
	    VAR_0->et.flags.renewable = 1;
	}
    }

    if (_kdc_is_anon_request(VAR_8))
	VAR_0->et.flags.anonymous = 1;

    if(VAR_8->addresses){
	ALLOC(VAR_0->et.caddr);
	copy_HostAddresses(VAR_8->addresses, VAR_0->et.caddr);
    }

    VAR_0->et.transited.tr_type = VAR_56;
    krb5_data_zero(&VAR_0->et.transited.contents);

    /* COMMENT_57 */
                                                                      
                                                                    
      
                                                           
      
                                                         
                                 
       
    VAR_0->ek.last_req.val = malloc(2 * sizeof(*VAR_0->ek.last_req.val));
    if (VAR_0->ek.last_req.val == NULL) {
	VAR_12 = VAR_57;
	goto out;
    }
    VAR_0->ek.last_req.len = 0;
    if (VAR_0->client->entry.pw_end
	&& (VAR_6->kdc_warn_pwexpire == 0
	    || VAR_53 + VAR_6->kdc_warn_pwexpire >= *VAR_0->client->entry.pw_end)) {
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_58;
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = *VAR_0->client->entry.pw_end;
	++VAR_0->ek.last_req.len;
    }
    if (VAR_0->client->entry.valid_end) {
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_59;
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = *VAR_0->client->entry.valid_end;
	++VAR_0->ek.last_req.len;
    }
    if (VAR_0->ek.last_req.len == 0) {
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_type  = VAR_60;
	VAR_0->ek.last_req.val[VAR_0->ek.last_req.len].lr_value = 0;
	++VAR_0->ek.last_req.len;
    }
    VAR_0->ek.nonce = VAR_8->nonce;
    if (VAR_0->client->entry.valid_end || VAR_0->client->entry.pw_end) {
	ALLOC(VAR_0->ek.key_expiration);
	if (VAR_0->client->entry.valid_end) {
	    if (VAR_0->client->entry.pw_end)
		*VAR_0->ek.key_expiration = min(*VAR_0->client->entry.valid_end,
					 *VAR_0->client->entry.pw_end);
	    else
		*VAR_0->ek.key_expiration = *VAR_0->client->entry.valid_end;
	} else
	    *VAR_0->ek.key_expiration = *VAR_0->client->entry.pw_end;
    } else
	VAR_0->ek.key_expiration = NULL;
    VAR_0->ek.flags = VAR_0->et.flags;
    VAR_0->ek.authtime = VAR_0->et.authtime;
    if (VAR_0->et.starttime) {
	ALLOC(VAR_0->ek.starttime);
	*VAR_0->ek.starttime = *VAR_0->et.starttime;
    }
    VAR_0->ek.endtime = VAR_0->et.endtime;
    if (VAR_0->et.renew_till) {
	ALLOC(VAR_0->ek.renew_till);
	*VAR_0->ek.renew_till = *VAR_0->et.renew_till;
    }
    VAR_12 = copy_Realm(&VAR_9.ticket.realm, &VAR_0->ek.srealm);
    if (VAR_12)
	goto out;
    VAR_12 = copy_PrincipalName(&VAR_9.ticket.sname, &VAR_0->ek.sname);
    if (VAR_12)
	goto out;
    if(VAR_0->et.caddr){
	ALLOC(VAR_0->ek.caddr);
	copy_HostAddresses(VAR_0->et.caddr, VAR_0->ek.caddr);
    }

    /* COMMENT_65 */
                                       
       

    if (VAR_0->session_key.keytype == VAR_61) {
	VAR_12 = krb5_generate_random_keyblock(VAR_5, VAR_0->sessionetype, &VAR_0->session_key);
	if (VAR_12)
	    goto out;
    }

    if (VAR_0->reply_key.keytype == VAR_61) {
	_kdc_set_e_text(VAR_0, ""Client have no reply key"");
	VAR_12 = VAR_37;
	goto out;
    }

    VAR_12 = copy_EncryptionKey(&VAR_0->session_key, &VAR_0->et.key);
    if (VAR_12)
	goto out;

    VAR_12 = copy_EncryptionKey(&VAR_0->session_key, &VAR_0->ek.key);
    if (VAR_12)
	goto out;

    if (VAR_0->outpadata.len) {

	ALLOC(VAR_9.padata);
	if (VAR_9.padata == NULL) {
	    VAR_12 = VAR_57;
	    goto out;
	}
	VAR_12 = copy_METHOD_DATA(&VAR_0->outpadata, VAR_9.padata);
	if (VAR_12)
	    goto out;
    }

    /* COMMENT_68 */
    if (send_pac_p(VAR_5, VAR_7)) {
	generate_pac(VAR_0, VAR_13);
    }

    _kdc_log_timestamp(VAR_5, VAR_6, ""AS-REQ"", VAR_0->et.authtime, VAR_0->et.starttime,
		       VAR_0->et.endtime, VAR_0->et.renew_till);

    /* COMMENT_69 */
    VAR_12 = _kdc_add_KRB5SignedPath(VAR_5,
				  VAR_6,
				  VAR_0->server,
				  VAR_11,
				  VAR_0->client->entry.principal,
				  NULL,
				  NULL,
				  &VAR_0->et);
    if (VAR_12)
	goto out;

    log_as_req(VAR_5, VAR_6, VAR_0->reply_key.keytype, VAR_11, VAR_8);

    /* COMMENT_70 */
                                               
       

    VAR_0->et.flags.enc_pa_rep = VAR_0->ek.flags.enc_pa_rep = 1;

    /* COMMENT_73 */
                                               
       

    VAR_15 = 0;
    VAR_19 = _kdc_find_padata(VAR_7, &VAR_15, VAR_62);
    if (VAR_19) {

	VAR_12 = add_enc_pa_rep(VAR_0);
	if (VAR_12) {
	    const char *VAR_28 = krb5_get_error_message(VAR_0->context, VAR_12);
	    _kdc_r_log(VAR_0, 0, ""add_enc_pa_rep failed: %s: %d"", VAR_28, VAR_12);
	    krb5_free_error_message(VAR_0->context, VAR_28);
	    goto out;
	}
    }

    /* COMMENT_76 */
      
       

    VAR_12 = _kdc_encode_reply(VAR_5, VAR_6,
			    VAR_0->armor_crypto, VAR_7->req_body.nonce,
			    &VAR_9, &VAR_0->et, &VAR_0->ek, VAR_11, VAR_0->server->entry.kvno,
			    &VAR_13->key, VAR_0->client->entry.kvno,
			    &VAR_0->reply_key, 0, &VAR_0->e_text, VAR_1);
    if (VAR_12)
	goto out;

    /* COMMENT_79 */
                                 
       
    if (VAR_4 && VAR_1->length > VAR_6->max_datagram_reply_length) {
	krb5_data_free(VAR_1);
	VAR_12 = VAR_63;
	_kdc_set_e_text(VAR_0, ""Reply packet too large"");
    }

out:
    free_AS_REP(&VAR_9);

    /* COMMENT_82 */
                                                            
       
    if (VAR_12 != 0 && VAR_12 != VAR_24 && VAR_1->length == 0) {
	VAR_12 = _kdc_fast_mk_error(VAR_5, VAR_0,
				 &VAR_18,
				 VAR_0->armor_crypto,
				 &VAR_7->req_body,
				 VAR_12, VAR_0->e_text,
				 VAR_0->server_princ,
				 VAR_0->client_princ ?
                                     &VAR_0->client_princ->name : NULL,
				 VAR_0->client_princ ?
                                     &VAR_0->client_princ->realm : NULL,
				 NULL, NULL,
				 VAR_1);
	if (VAR_12)
	    goto out2;
    }
out2:
    free_EncTicketPart(&VAR_0->et);
    free_EncKDCRepPart(&VAR_0->ek);
    free_KDCFastState(&VAR_0->fast);

    if (VAR_18.len)
	free_METHOD_DATA(&VAR_18);
    if (VAR_0->outpadata.len)
	free_METHOD_DATA(&VAR_0->outpadata);
    if (VAR_0->client_princ) {
	krb5_free_principal(VAR_5, VAR_0->client_princ);
	VAR_0->client_princ = NULL;
    }
    if (VAR_0->client_name) {
	free(VAR_0->client_name);
	VAR_0->client_name = NULL;
    }
    if (VAR_0->server_princ){
	krb5_free_principal(VAR_5, VAR_0->server_princ);
	VAR_0->server_princ = NULL;
    }
    if (VAR_0->server_name) {
	free(VAR_0->server_name);
	VAR_0->server_name = NULL;
    }
    if (VAR_0->client)
	_kdc_free_ent(VAR_5, VAR_0->client);
    if (VAR_0->server)
	_kdc_free_ent(VAR_5, VAR_0->server);
    if (VAR_0->armor_crypto) {
	krb5_crypto_destroy(VAR_0->context, VAR_0->armor_crypto);
	VAR_0->armor_crypto = NULL;
    }
    krb5_free_keyblock_contents(VAR_0->context, &VAR_0->reply_key);
    krb5_free_keyblock_contents(VAR_0->context, &VAR_0->session_key);
    return VAR_12;
}",heimdal/1a6a6e462dc2ac6111f9e02c6852ddec4849b887/kerberos5.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -617,15 +617,17 @@
     /*
      * In case of a non proxy error, build an error message.
      */
-    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
+    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
-				 &r->client_princ->name,
-				 &r->client_princ->realm,
+				 r->client_princ ?
+                                     &r->client_princ->name : NULL,
+				 r->client_princ ?
+                                     &r->client_princ->realm : NULL,
 				 NULL, NULL,
 				 reply);
 	if (ret)","{'deleted_lines': ['    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {', '\t\t\t\t &r->client_princ->name,', '\t\t\t\t &r->client_princ->realm,'], 'added_lines': ['    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {', '\t\t\t\t r->client_princ ?', '                                     &r->client_princ->name : NULL,', '\t\t\t\t r->client_princ ?', '                                     &r->client_princ->realm : NULL,']}",True,"In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c.",7.5,HIGH,2,valid,2017-12-05T23:49:50Z,2
CVE-2017-17856,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: force strict alignment checks for stack pointers

Force strict alignment checks for stack pointers because the tracking of
stack spills relies on it; unaligned stack accesses can lead to corruption
of spilled registers, which is exploitable.

Fixes: f1174f77b50c (""bpf/verifier: rework value tracking"")
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>",a5ec6ae161d72f01411169a938fa5f8baea16e8f,https://github.com/torvalds/linux/commit/a5ec6ae161d72f01411169a938fa5f8baea16e8f,kernel/bpf/verifier.c,check_ptr_alignment,"static int check_ptr_alignment(struct bpf_verifier_env *env,
const struct bpf_reg_state *reg,
int off, int size)
{
bool strict = env->strict_alignment;
const char *pointer_desc = """";
switch (reg->type) {
case PTR_TO_PACKET:
case PTR_TO_PACKET_META:
return check_pkt_ptr_alignment(env, reg, off, size, strict);
case PTR_TO_MAP_VALUE:
pointer_desc = ""value "";
break;
case PTR_TO_CTX:
pointer_desc = ""context "";
break;
case PTR_TO_STACK:
pointer_desc = ""stack "";
break;
default:
break;
}
return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,
strict);
}","static int check_ptr_alignment(struct bpf_verifier_env *VAR_0,
const struct bpf_reg_state *VAR_1,
int VAR_2, int VAR_3)
{
bool VAR_4 = VAR_0->strict_alignment;
const char *VAR_5 = """";
switch (VAR_1->type) {
case VAR_6:
case VAR_7:
return check_pkt_ptr_alignment(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);
case VAR_8:
VAR_5 = ""value "";
break;
case VAR_9:
VAR_5 = ""context "";
break;
case VAR_10:
VAR_5 = ""stack "";
break;
default:
break;
}
return check_generic_ptr_alignment(VAR_0, VAR_1, VAR_5, VAR_2, VAR_3,
VAR_4);
}",torvalds/linux/a5ec6ae161d72f01411169a938fa5f8baea16e8f/verifier.c/vul/before/0.json,"static int check_ptr_alignment(struct bpf_verifier_env *env,
			       const struct bpf_reg_state *reg,
			       int off, int size)
{
	bool strict = env->strict_alignment;
	const char *pointer_desc = """";

	switch (reg->type) {
	case PTR_TO_PACKET:
	case PTR_TO_PACKET_META:
		/* Special case, because of NET_IP_ALIGN. Given metadata sits
		 * right in front, treat it the very same way.
		 */
		return check_pkt_ptr_alignment(env, reg, off, size, strict);
	case PTR_TO_MAP_VALUE:
		pointer_desc = ""value "";
		break;
	case PTR_TO_CTX:
		pointer_desc = ""context "";
		break;
	case PTR_TO_STACK:
		pointer_desc = ""stack "";
		/* The stack spill tracking logic in check_stack_write()
		 * and check_stack_read() relies on stack accesses being
		 * aligned.
		 */
		strict = true;
		break;
	default:
		break;
	}
	return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,
					   strict);
}","static int check_ptr_alignment(struct bpf_verifier_env *VAR_0,
			       const struct bpf_reg_state *VAR_1,
			       int VAR_2, int VAR_3)
{
	bool VAR_4 = VAR_0->strict_alignment;
	const char *VAR_5 = """";

	switch (VAR_1->type) {
	case VAR_6:
	case VAR_7:
		/* COMMENT_0 */
                                                
     
		return check_pkt_ptr_alignment(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);
	case VAR_8:
		VAR_5 = ""value "";
		break;
	case VAR_9:
		VAR_5 = ""context "";
		break;
	case VAR_10:
		VAR_5 = ""stack "";
		/* COMMENT_3 */
                                                          
             
     
		VAR_4 = true;
		break;
	default:
		break;
	}
	return check_generic_ptr_alignment(VAR_0, VAR_1, VAR_5, VAR_2, VAR_3,
					   VAR_4);
}",torvalds/linux/a5ec6ae161d72f01411169a938fa5f8baea16e8f/verifier.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,6 +20,11 @@
 		break;
 	case PTR_TO_STACK:
 		pointer_desc = ""stack "";
+		/* The stack spill tracking logic in check_stack_write()
+		 * and check_stack_read() relies on stack accesses being
+		 * aligned.
+		 */
+		strict = true;
 		break;
 	default:
 		break;","{'deleted_lines': [], 'added_lines': ['\t\t/* The stack spill tracking logic in check_stack_write()', '\t\t * and check_stack_read() relies on stack accesses being', '\t\t * aligned.', '\t\t */', '\t\tstrict = true;']}",True,kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging the lack of stack-pointer alignment enforcement.,7.8,HIGH,2,valid,2017-12-19T04:11:58Z,2
CVE-2017-15129,['CWE-362'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"net: Fix double free and memory corruption in get_net_ns_by_id()

(I can trivially verify that that idr_remove in cleanup_net happens
 after the network namespace count has dropped to zero --EWB)

Function get_net_ns_by_id() does not check for net::count
after it has found a peer in netns_ids idr.

It may dereference a peer, after its count has already been
finaly decremented. This leads to double free and memory
corruption:

put_net(peer)                                   rtnl_lock()
atomic_dec_and_test(&peer->count) [count=0]     ...
__put_net(peer)                                 get_net_ns_by_id(net, id)
  spin_lock(&cleanup_list_lock)
  list_add(&net->cleanup_list, &cleanup_list)
  spin_unlock(&cleanup_list_lock)
queue_work()                                      peer = idr_find(&net->netns_ids, id)
  |                                               get_net(peer) [count=1]
  |                                               ...
  |                                               (use after final put)
  v                                               ...
  cleanup_net()                                   ...
    spin_lock(&cleanup_list_lock)                 ...
    list_replace_init(&cleanup_list, ..)          ...
    spin_unlock(&cleanup_list_lock)               ...
    ...                                           ...
    ...                                           put_net(peer)
    ...                                             atomic_dec_and_test(&peer->count) [count=0]
    ...                                               spin_lock(&cleanup_list_lock)
    ...                                               list_add(&net->cleanup_list, &cleanup_list)
    ...                                               spin_unlock(&cleanup_list_lock)
    ...                                             queue_work()
    ...                                           rtnl_unlock()
    rtnl_lock()                                   ...
    for_each_net(tmp) {                           ...
      id = __peernet2id(tmp, peer)                ...
      spin_lock_irq(&tmp->nsid_lock)              ...
      idr_remove(&tmp->netns_ids, id)             ...
      ...                                         ...
      net_drop_ns()                               ...
	net_free(peer)                            ...
    }                                             ...
  |
  v
  cleanup_net()
    ...
    (Second free of peer)

Also, put_net() on the right cpu may reorder with left's cpu
list_replace_init(&cleanup_list, ..), and then cleanup_list
will be corrupted.

Since cleanup_net() is executed in worker thread, while
put_net(peer) can happen everywhere, there should be
enough time for concurrent get_net_ns_by_id() to pick
the peer up, and the race does not seem to be unlikely.
The patch fixes the problem in standard way.

(Also, there is possible problem in peernet2id_alloc(), which requires
check for net::count under nsid_lock and maybe_get_net(peer), but
in current stable kernel it's used under rtnl_lock() and it has to be
safe. Openswitch begun to use peernet2id_alloc(), and possibly it should
be fixed too. While this is not in stable kernel yet, so I'll send
a separate message to netdev@ later).

Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
Fixes: 0c7aecd4bde4 ""netns: add rtnl cmd to add and get peer netns ids""
Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",21b5944350052d2583e82dd59b19a9ba94a007f0,https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0,net/core/net_namespace.c,get_net_ns_by_id,"struct net *get_net_ns_by_id(struct net *net, int id)
{
struct net *peer;
if (id < 0)
return NULL;
rcu_read_lock();
spin_lock_bh(&net->nsid_lock);
peer = idr_find(&net->netns_ids, id);
if (peer)
get_net(peer);
spin_unlock_bh(&net->nsid_lock);
rcu_read_unlock();
return peer;
}","struct net *get_net_ns_by_id(struct net *net, int VAR_0)
{
struct net *VAR_1;
if (VAR_0 < 0)
return NULL;
rcu_read_lock();
spin_lock_bh(&net->nsid_lock);
VAR_1 = idr_find(&net->netns_ids, VAR_0);
if (VAR_1)
get_net(VAR_1);
spin_unlock_bh(&net->nsid_lock);
rcu_read_unlock();
return VAR_1;
}",torvalds/linux/21b5944350052d2583e82dd59b19a9ba94a007f0/net_namespace.c/vul/before/0.json,"struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
	spin_lock_bh(&net->nsid_lock);
	peer = idr_find(&net->netns_ids, id);
	if (peer)
		peer = maybe_get_net(peer);
	spin_unlock_bh(&net->nsid_lock);
	rcu_read_unlock();

	return peer;
}","struct net *get_net_ns_by_id(struct net *net, int VAR_0)
{
	struct net *VAR_1;

	if (VAR_0 < 0)
		return NULL;

	rcu_read_lock();
	spin_lock_bh(&net->nsid_lock);
	VAR_1 = idr_find(&net->netns_ids, VAR_0);
	if (VAR_1)
		VAR_1 = maybe_get_net(VAR_1);
	spin_unlock_bh(&net->nsid_lock);
	rcu_read_unlock();

	return VAR_1;
}",torvalds/linux/21b5944350052d2583e82dd59b19a9ba94a007f0/net_namespace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
-		get_net(peer);
+		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 ","{'deleted_lines': ['\t\tget_net(peer);'], 'added_lines': ['\t\tpeer = maybe_get_net(peer);']}",True,"A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely.",4.7,MEDIUM,1,valid,2017-12-19T17:27:56Z,2
CVE-2018-1000051,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/mupdf,"Bug 698825: Do not drop borrowed colorspaces.

Previously the borrowed colorspace was dropped when updating annotation
appearances, leading to use after free warnings from valgrind/ASAN.",321ba1de287016b0036bf4a56ce774ad11763384,https://github.com/ArtifexSoftware/mupdf/commit/321ba1de287016b0036bf4a56ce774ad11763384,source/pdf/pdf-appearance.c,pdf_update_free_text_annot_appearance,"void pdf_update_free_text_annot_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot)
{
pdf_obj *obj = annot->obj;
pdf_obj *dr = pdf_dict_get(ctx, annot->page->obj, PDF_NAME_Resources);
fz_display_list *dlist = NULL;
fz_device *dev = NULL;
font_info font_rec;
fz_text *text = NULL;
fz_colorspace *cs = NULL;
fz_matrix page_ctm;
pdf_page_transform(ctx, annot->page, NULL, &page_ctm);
memset(&font_rec, 0, sizeof(font_rec));
font_rec.da_rec.col_size = 1; 
font_rec.da_rec.font_size = 12; 
fz_var(dlist);
fz_var(dev);
fz_var(text);
fz_var(cs);
fz_try(ctx)
{
char *contents = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_Contents));
char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));
fz_point pos;
fz_rect rect;
pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &rect);
get_font_info(ctx, doc, dr, da, &font_rec);
switch (font_rec.da_rec.col_size)
{
default: cs = fz_device_gray(ctx); break;
case 3: cs = fz_device_rgb(ctx); break;
case 4: cs = fz_device_cmyk(ctx); break;
}
pos.x = rect.x0;
pos.y = rect.y0 - font_rec.font->descent * font_rec.da_rec.font_size / 1000.0f;
text = layout_text(ctx, &font_rec, contents, pos.x, pos.y);
dlist = fz_new_display_list(ctx, NULL);
dev = fz_new_list_device(ctx, dlist);
fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);
fz_close_device(ctx, dev);
fz_transform_rect(&rect, &page_ctm);
pdf_set_annot_appearance(ctx, doc, annot, &rect, dlist);
}
fz_always(ctx)
{
fz_drop_device(ctx, dev);
fz_drop_display_list(ctx, dlist);
font_info_fin(ctx, &font_rec);
fz_drop_text(ctx, text);
fz_drop_colorspace(ctx, cs);
}
fz_catch(ctx)
{
fz_rethrow(ctx);
}
}","void pdf_update_free_text_annot_appearance(fz_context *VAR_0, pdf_document *VAR_1, pdf_annot *VAR_2)
{
pdf_obj *VAR_3 = VAR_2->obj;
pdf_obj *VAR_4 = pdf_dict_get(VAR_0, VAR_2->page->obj, VAR_5);
fz_display_list *VAR_6 = NULL;
fz_device *VAR_7 = NULL;
font_info VAR_8;
fz_text *VAR_9 = NULL;
fz_colorspace *VAR_10 = NULL;
fz_matrix VAR_11;
pdf_page_transform(VAR_0, VAR_2->page, NULL, &VAR_11);
memset(&VAR_8, 0, sizeof(VAR_8));
VAR_8.da_rec.col_size = 1; 
VAR_8.da_rec.font_size = 12; 
fz_var(VAR_6);
fz_var(VAR_7);
fz_var(VAR_9);
fz_var(VAR_10);
fz_try(VAR_0)
{
char *VAR_12 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_3, VAR_13));
char *VAR_14 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_3, VAR_15));
fz_point VAR_16;
fz_rect VAR_17;
pdf_to_rect(VAR_0, pdf_dict_get(VAR_0, VAR_2->obj, VAR_18), &VAR_17);
get_font_info(VAR_0, VAR_1, VAR_4, VAR_14, &VAR_8);
switch (VAR_8.da_rec.col_size)
{
default: VAR_10 = fz_device_gray(VAR_0); break;
case 3: VAR_10 = fz_device_rgb(VAR_0); break;
case 4: VAR_10 = fz_device_cmyk(VAR_0); break;
}
VAR_16.x = VAR_17.x0;
VAR_16.y = VAR_17.y0 - VAR_8.font->descent * VAR_8.da_rec.font_size / 1000.0f;
VAR_9 = layout_text(VAR_0, &VAR_8, VAR_12, VAR_16.x, VAR_16.y);
VAR_6 = fz_new_display_list(VAR_0, NULL);
VAR_7 = fz_new_list_device(VAR_0, VAR_6);
fz_fill_text(VAR_0, VAR_7, VAR_9, &VAR_11, VAR_10, VAR_8.da_rec.col, 1.0f, NULL);
fz_close_device(VAR_0, VAR_7);
fz_transform_rect(&VAR_17, &VAR_11);
pdf_set_annot_appearance(VAR_0, VAR_1, VAR_2, &VAR_17, VAR_6);
}
fz_always(VAR_0)
{
fz_drop_device(VAR_0, VAR_7);
fz_drop_display_list(VAR_0, VAR_6);
font_info_fin(VAR_0, &VAR_8);
fz_drop_text(VAR_0, VAR_9);
fz_drop_colorspace(VAR_0, VAR_10);
}
fz_catch(VAR_0)
{
fz_rethrow(VAR_0);
}
}",ArtifexSoftware/mupdf/321ba1de287016b0036bf4a56ce774ad11763384/pdf-appearance.c/vul/before/1.json,"void pdf_update_free_text_annot_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot)
{
	pdf_obj *obj = annot->obj;
	pdf_obj *dr = pdf_dict_get(ctx, annot->page->obj, PDF_NAME_Resources);
	fz_display_list *dlist = NULL;
	fz_device *dev = NULL;
	font_info font_rec;
	fz_text *text = NULL;
	fz_matrix page_ctm;

	pdf_page_transform(ctx, annot->page, NULL, &page_ctm);

	memset(&font_rec, 0, sizeof(font_rec));

	/* Set some sane defaults in case the parsing of the font_rec fails */
	font_rec.da_rec.col_size = 1; /* Default to greyscale */
	font_rec.da_rec.font_size = 12; /* Default to 12 point */

	fz_var(dlist);
	fz_var(dev);
	fz_var(text);
	fz_try(ctx)
	{
		char *contents = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_Contents));
		char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));
		fz_colorspace *cs;
		fz_point pos;
		fz_rect rect;

		pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &rect);

		get_font_info(ctx, doc, dr, da, &font_rec);

		switch (font_rec.da_rec.col_size)
		{
		default: cs = fz_device_gray(ctx); break;
		case 3: cs = fz_device_rgb(ctx); break;
		case 4: cs = fz_device_cmyk(ctx); break;
		}

		/* Adjust for the descender */
		pos.x = rect.x0;
		pos.y = rect.y0 - font_rec.font->descent * font_rec.da_rec.font_size / 1000.0f;

		text = layout_text(ctx, &font_rec, contents, pos.x, pos.y);

		dlist = fz_new_display_list(ctx, NULL);
		dev = fz_new_list_device(ctx, dlist);
		fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);
		fz_close_device(ctx, dev);

		fz_transform_rect(&rect, &page_ctm);
		pdf_set_annot_appearance(ctx, doc, annot, &rect, dlist);
	}
	fz_always(ctx)
	{
		fz_drop_device(ctx, dev);
		fz_drop_display_list(ctx, dlist);
		font_info_fin(ctx, &font_rec);
		fz_drop_text(ctx, text);
	}
	fz_catch(ctx)
	{
		fz_rethrow(ctx);
	}
}","void pdf_update_free_text_annot_appearance(fz_context *VAR_0, pdf_document *VAR_1, pdf_annot *VAR_2)
{
	pdf_obj *VAR_3 = VAR_2->obj;
	pdf_obj *VAR_4 = pdf_dict_get(VAR_0, VAR_2->page->obj, VAR_5);
	fz_display_list *VAR_6 = NULL;
	fz_device *VAR_7 = NULL;
	font_info VAR_8;
	fz_text *VAR_9 = NULL;
	fz_matrix VAR_10;

	pdf_page_transform(VAR_0, VAR_2->page, NULL, &VAR_10);

	memset(&VAR_8, 0, sizeof(VAR_8));

	/* COMMENT_0 */
	VAR_8.da_rec.col_size = 1; /* COMMENT_1 */
	VAR_8.da_rec.font_size = 12; /* COMMENT_2 */

	fz_var(VAR_6);
	fz_var(VAR_7);
	fz_var(VAR_9);
	fz_try(VAR_0)
	{
		char *VAR_11 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_3, VAR_12));
		char *VAR_13 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_3, VAR_14));
		fz_colorspace *VAR_15;
		fz_point VAR_16;
		fz_rect VAR_17;

		pdf_to_rect(VAR_0, pdf_dict_get(VAR_0, VAR_2->obj, VAR_18), &VAR_17);

		get_font_info(VAR_0, VAR_1, VAR_4, VAR_13, &VAR_8);

		switch (VAR_8.da_rec.col_size)
		{
		default: VAR_15 = fz_device_gray(VAR_0); break;
		case 3: VAR_15 = fz_device_rgb(VAR_0); break;
		case 4: VAR_15 = fz_device_cmyk(VAR_0); break;
		}

		/* COMMENT_3 */
		VAR_16.x = VAR_17.x0;
		VAR_16.y = VAR_17.y0 - VAR_8.font->descent * VAR_8.da_rec.font_size / 1000.0f;

		VAR_9 = layout_text(VAR_0, &VAR_8, VAR_11, VAR_16.x, VAR_16.y);

		VAR_6 = fz_new_display_list(VAR_0, NULL);
		VAR_7 = fz_new_list_device(VAR_0, VAR_6);
		fz_fill_text(VAR_0, VAR_7, VAR_9, &VAR_10, VAR_15, VAR_8.da_rec.col, 1.0f, NULL);
		fz_close_device(VAR_0, VAR_7);

		fz_transform_rect(&VAR_17, &VAR_10);
		pdf_set_annot_appearance(VAR_0, VAR_1, VAR_2, &VAR_17, VAR_6);
	}
	fz_always(VAR_0)
	{
		fz_drop_device(VAR_0, VAR_7);
		fz_drop_display_list(VAR_0, VAR_6);
		font_info_fin(VAR_0, &VAR_8);
		fz_drop_text(VAR_0, VAR_9);
	}
	fz_catch(VAR_0)
	{
		fz_rethrow(VAR_0);
	}
}",ArtifexSoftware/mupdf/321ba1de287016b0036bf4a56ce774ad11763384/pdf-appearance.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,7 +6,6 @@
 	fz_device *dev = NULL;
 	font_info font_rec;
 	fz_text *text = NULL;
-	fz_colorspace *cs = NULL;
 	fz_matrix page_ctm;
 
 	pdf_page_transform(ctx, annot->page, NULL, &page_ctm);
@@ -20,11 +19,11 @@
 	fz_var(dlist);
 	fz_var(dev);
 	fz_var(text);
-	fz_var(cs);
 	fz_try(ctx)
 	{
 		char *contents = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_Contents));
 		char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));
+		fz_colorspace *cs;
 		fz_point pos;
 		fz_rect rect;
 
@@ -59,7 +58,6 @@
 		fz_drop_display_list(ctx, dlist);
 		font_info_fin(ctx, &font_rec);
 		fz_drop_text(ctx, text);
-		fz_drop_colorspace(ctx, cs);
 	}
 	fz_catch(ctx)
 	{","{'deleted_lines': ['\tfz_colorspace *cs = NULL;', '\tfz_var(cs);', '\t\tfz_drop_colorspace(ctx, cs);'], 'added_lines': ['\t\tfz_colorspace *cs;']}",True,Artifex Mupdf version 1.12.0 contains a Use After Free vulnerability in fz_keep_key_storable that can result in DOS / Possible code execution. This attack appear to be exploitable via Victim opens a specially crafted PDF.,7.8,HIGH,2,valid,2017-12-19T22:47:47Z,2
CVE-2018-1000051,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/mupdf,"Bug 698825: Do not drop borrowed colorspaces.

Previously the borrowed colorspace was dropped when updating annotation
appearances, leading to use after free warnings from valgrind/ASAN.",321ba1de287016b0036bf4a56ce774ad11763384,https://github.com/ArtifexSoftware/mupdf/commit/321ba1de287016b0036bf4a56ce774ad11763384,source/pdf/pdf-appearance.c,pdf_set_signature_appearance,"void pdf_set_signature_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot, char *name, const char *dn, char *date)
{
pdf_obj *obj = annot->obj;
pdf_obj *dr = pdf_dict_getl(ctx, pdf_trailer(ctx, doc), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);
fz_display_list *dlist = NULL;
fz_device *dev = NULL;
font_info font_rec;
fz_text *text = NULL;
fz_colorspace *cs = NULL;
fz_path *path = NULL;
fz_buffer *fzbuf = NULL;
fz_matrix page_ctm;
pdf_page_transform(ctx, annot->page, NULL, &page_ctm);
if (!dr)
pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_dict(ctx, doc, 1), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);
memset(&font_rec, 0, sizeof(font_rec));
fz_var(path);
fz_var(dlist);
fz_var(dev);
fz_var(text);
fz_var(cs);
fz_var(fzbuf);
fz_try(ctx)
{
char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));
fz_rect annot_rect;
fz_rect logo_bounds;
fz_matrix logo_tm;
fz_rect rect;
pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &annot_rect);
rect = annot_rect;
dlist = fz_new_display_list(ctx, NULL);
dev = fz_new_list_device(ctx, dlist);
path = fz_new_path(ctx);
draw_logo(ctx, path);
fz_bound_path(ctx, path, NULL, &fz_identity, &logo_bounds);
center_rect_within_rect(&logo_bounds, &rect, &logo_tm);
fz_concat(&logo_tm, &logo_tm, &page_ctm);
cs = fz_device_rgb(ctx); 
fz_fill_path(ctx, dev, path, 0, &logo_tm, cs, logo_color, 1.0f, NULL);
get_font_info(ctx, doc, dr, da, &font_rec);
switch (font_rec.da_rec.col_size)
{
case 1: cs = fz_device_gray(ctx); break;
case 3: cs = fz_device_rgb(ctx); break;
case 4: cs = fz_device_cmyk(ctx); break;
}
rect.x1 = (rect.x0 + rect.x1)/2.0f;
text = fit_text(ctx, &font_rec, name, &rect);
fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);
fz_drop_text(ctx, text);
text = NULL;
fzbuf = fz_new_buffer(ctx, 256);
fz_append_printf(ctx, fzbuf, ""Digitally signed by %s"", name);
fz_append_printf(ctx, fzbuf, ""\nDN: %s"", dn);
if (date)
fz_append_printf(ctx, fzbuf, ""\nDate: %s"", date);
rect = annot_rect;
rect.x0 = (rect.x0 + rect.x1)/2.0f;
text = fit_text(ctx, &font_rec, fz_string_from_buffer(ctx, fzbuf), &rect);
fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);
fz_close_device(ctx, dev);
rect = annot_rect;
fz_transform_rect(&rect, &page_ctm);
pdf_set_annot_appearance(ctx, doc, annot, &rect, dlist);
pdf_drop_xobject(ctx, annot->ap);
annot->ap = NULL;
insert_signature_appearance_layers(ctx, doc, annot);
}
fz_always(ctx)
{
fz_drop_device(ctx, dev);
fz_drop_display_list(ctx, dlist);
font_info_fin(ctx, &font_rec);
fz_drop_path(ctx, path);
fz_drop_text(ctx, text);
fz_drop_buffer(ctx, fzbuf);
}
fz_catch(ctx)
{
fz_rethrow(ctx);
}
}","void pdf_set_signature_appearance(fz_context *VAR_0, pdf_document *VAR_1, pdf_annot *VAR_2, char *VAR_3, const char *VAR_4, char *VAR_5)
{
pdf_obj *VAR_6 = VAR_2->obj;
pdf_obj *VAR_7 = pdf_dict_getl(VAR_0, pdf_trailer(VAR_0, VAR_1), VAR_8, VAR_9, VAR_10, NULL);
fz_display_list *VAR_11 = NULL;
fz_device *VAR_12 = NULL;
font_info VAR_13;
fz_text *VAR_14 = NULL;
fz_colorspace *VAR_15 = NULL;
fz_path *VAR_16 = NULL;
fz_buffer *VAR_17 = NULL;
fz_matrix VAR_18;
pdf_page_transform(VAR_0, VAR_2->page, NULL, &VAR_18);
if (!VAR_7)
pdf_dict_putl_drop(VAR_0, pdf_trailer(VAR_0, VAR_1), pdf_new_dict(VAR_0, VAR_1, 1), VAR_8, VAR_9, VAR_10, NULL);
memset(&VAR_13, 0, sizeof(VAR_13));
fz_var(VAR_16);
fz_var(VAR_11);
fz_var(VAR_12);
fz_var(VAR_14);
fz_var(VAR_15);
fz_var(VAR_17);
fz_try(VAR_0)
{
char *VAR_19 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_6, VAR_20));
fz_rect VAR_21;
fz_rect VAR_22;
fz_matrix VAR_23;
fz_rect VAR_24;
pdf_to_rect(VAR_0, pdf_dict_get(VAR_0, VAR_2->obj, VAR_25), &VAR_21);
VAR_24 = VAR_21;
VAR_11 = fz_new_display_list(VAR_0, NULL);
VAR_12 = fz_new_list_device(VAR_0, VAR_11);
VAR_16 = fz_new_path(VAR_0);
draw_logo(VAR_0, VAR_16);
fz_bound_path(VAR_0, VAR_16, NULL, &VAR_26, &VAR_22);
center_rect_within_rect(&VAR_22, &VAR_24, &VAR_23);
fz_concat(&VAR_23, &VAR_23, &VAR_18);
VAR_15 = fz_device_rgb(VAR_0); 
fz_fill_path(VAR_0, VAR_12, VAR_16, 0, &VAR_23, VAR_15, VAR_27, 1.0f, NULL);
get_font_info(VAR_0, VAR_1, VAR_7, VAR_19, &VAR_13);
switch (VAR_13.da_rec.col_size)
{
case 1: VAR_15 = fz_device_gray(VAR_0); break;
case 3: VAR_15 = fz_device_rgb(VAR_0); break;
case 4: VAR_15 = fz_device_cmyk(VAR_0); break;
}
VAR_24.x1 = (VAR_24.x0 + VAR_24.x1)/2.0f;
VAR_14 = fit_text(VAR_0, &VAR_13, VAR_3, &VAR_24);
fz_fill_text(VAR_0, VAR_12, VAR_14, &VAR_18, VAR_15, VAR_13.da_rec.col, 1.0f, NULL);
fz_drop_text(VAR_0, VAR_14);
VAR_14 = NULL;
VAR_17 = fz_new_buffer(VAR_0, 256);
fz_append_printf(VAR_0, VAR_17, ""Digitally signed by %s"", VAR_3);
fz_append_printf(VAR_0, VAR_17, ""\nDN: %s"", VAR_4);
if (VAR_5)
fz_append_printf(VAR_0, VAR_17, ""\nDate: %s"", VAR_5);
VAR_24 = VAR_21;
VAR_24.x0 = (VAR_24.x0 + VAR_24.x1)/2.0f;
VAR_14 = fit_text(VAR_0, &VAR_13, fz_string_from_buffer(VAR_0, VAR_17), &VAR_24);
fz_fill_text(VAR_0, VAR_12, VAR_14, &VAR_18, VAR_15, VAR_13.da_rec.col, 1.0f, NULL);
fz_close_device(VAR_0, VAR_12);
VAR_24 = VAR_21;
fz_transform_rect(&VAR_24, &VAR_18);
pdf_set_annot_appearance(VAR_0, VAR_1, VAR_2, &VAR_24, VAR_11);
pdf_drop_xobject(VAR_0, VAR_2->ap);
VAR_2->ap = NULL;
insert_signature_appearance_layers(VAR_0, VAR_1, VAR_2);
}
fz_always(VAR_0)
{
fz_drop_device(VAR_0, VAR_12);
fz_drop_display_list(VAR_0, VAR_11);
font_info_fin(VAR_0, &VAR_13);
fz_drop_path(VAR_0, VAR_16);
fz_drop_text(VAR_0, VAR_14);
fz_drop_buffer(VAR_0, VAR_17);
}
fz_catch(VAR_0)
{
fz_rethrow(VAR_0);
}
}",ArtifexSoftware/mupdf/321ba1de287016b0036bf4a56ce774ad11763384/pdf-appearance.c/vul/before/0.json,"void pdf_set_signature_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot, char *name, const char *dn, char *date)
{
	pdf_obj *obj = annot->obj;
	pdf_obj *dr = pdf_dict_getl(ctx, pdf_trailer(ctx, doc), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);
	fz_display_list *dlist = NULL;
	fz_device *dev = NULL;
	font_info font_rec;
	fz_text *text = NULL;
	fz_path *path = NULL;
	fz_buffer *fzbuf = NULL;
	fz_matrix page_ctm;

	pdf_page_transform(ctx, annot->page, NULL, &page_ctm);

	if (!dr)
		pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_dict(ctx, doc, 1), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);

	memset(&font_rec, 0, sizeof(font_rec));

	fz_var(path);
	fz_var(dlist);
	fz_var(dev);
	fz_var(text);
	fz_var(fzbuf);
	fz_try(ctx)
	{
		char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));
		fz_rect annot_rect;
		fz_rect logo_bounds;
		fz_matrix logo_tm;
		fz_rect rect;
		fz_colorspace *cs = fz_device_rgb(ctx); /* Borrowed reference */

		pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &annot_rect);
		rect = annot_rect;

		dlist = fz_new_display_list(ctx, NULL);
		dev = fz_new_list_device(ctx, dlist);

		path = fz_new_path(ctx);
		draw_logo(ctx, path);
		fz_bound_path(ctx, path, NULL, &fz_identity, &logo_bounds);
		center_rect_within_rect(&logo_bounds, &rect, &logo_tm);
		fz_concat(&logo_tm, &logo_tm, &page_ctm);
		fz_fill_path(ctx, dev, path, 0, &logo_tm, cs, logo_color, 1.0f, NULL);

		get_font_info(ctx, doc, dr, da, &font_rec);

		switch (font_rec.da_rec.col_size)
		{
		case 1: cs = fz_device_gray(ctx); break;
		case 3: cs = fz_device_rgb(ctx); break;
		case 4: cs = fz_device_cmyk(ctx); break;
		}

		/* Display the name in the left-hand half of the form field */
		rect.x1 = (rect.x0 + rect.x1)/2.0f;
		text = fit_text(ctx, &font_rec, name, &rect);
		fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);
		fz_drop_text(ctx, text);
		text = NULL;

		/* Display the distinguished name in the right-hand half */
		fzbuf = fz_new_buffer(ctx, 256);
		fz_append_printf(ctx, fzbuf, ""Digitally signed by %s"", name);
		fz_append_printf(ctx, fzbuf, ""\nDN: %s"", dn);
		if (date)
			fz_append_printf(ctx, fzbuf, ""\nDate: %s"", date);
		rect = annot_rect;
		rect.x0 = (rect.x0 + rect.x1)/2.0f;
		text = fit_text(ctx, &font_rec, fz_string_from_buffer(ctx, fzbuf), &rect);
		fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);

		fz_close_device(ctx, dev);

		rect = annot_rect;
		fz_transform_rect(&rect, &page_ctm);
		pdf_set_annot_appearance(ctx, doc, annot, &rect, dlist);

		/* Drop the cached xobject from the annotation structure to
		 * force a redraw on next pdf_update_page call */
		pdf_drop_xobject(ctx, annot->ap);
		annot->ap = NULL;

		insert_signature_appearance_layers(ctx, doc, annot);
	}
	fz_always(ctx)
	{
		fz_drop_device(ctx, dev);
		fz_drop_display_list(ctx, dlist);
		font_info_fin(ctx, &font_rec);
		fz_drop_path(ctx, path);
		fz_drop_text(ctx, text);
		fz_drop_buffer(ctx, fzbuf);
	}
	fz_catch(ctx)
	{
		fz_rethrow(ctx);
	}
}","void pdf_set_signature_appearance(fz_context *VAR_0, pdf_document *VAR_1, pdf_annot *VAR_2, char *VAR_3, const char *VAR_4, char *VAR_5)
{
	pdf_obj *VAR_6 = VAR_2->obj;
	pdf_obj *VAR_7 = pdf_dict_getl(VAR_0, pdf_trailer(VAR_0, VAR_1), VAR_8, VAR_9, VAR_10, NULL);
	fz_display_list *VAR_11 = NULL;
	fz_device *VAR_12 = NULL;
	font_info VAR_13;
	fz_text *VAR_14 = NULL;
	fz_path *VAR_15 = NULL;
	fz_buffer *VAR_16 = NULL;
	fz_matrix VAR_17;

	pdf_page_transform(VAR_0, VAR_2->page, NULL, &VAR_17);

	if (!VAR_7)
		pdf_dict_putl_drop(VAR_0, pdf_trailer(VAR_0, VAR_1), pdf_new_dict(VAR_0, VAR_1, 1), VAR_8, VAR_9, VAR_10, NULL);

	memset(&VAR_13, 0, sizeof(VAR_13));

	fz_var(VAR_15);
	fz_var(VAR_11);
	fz_var(VAR_12);
	fz_var(VAR_14);
	fz_var(VAR_16);
	fz_try(VAR_0)
	{
		char *VAR_18 = pdf_to_str_buf(VAR_0, pdf_dict_get(VAR_0, VAR_6, VAR_19));
		fz_rect VAR_20;
		fz_rect VAR_21;
		fz_matrix VAR_22;
		fz_rect VAR_23;
		fz_colorspace *VAR_24 = fz_device_rgb(VAR_0); /* COMMENT_0 */

		pdf_to_rect(VAR_0, pdf_dict_get(VAR_0, VAR_2->obj, VAR_25), &VAR_20);
		VAR_23 = VAR_20;

		VAR_11 = fz_new_display_list(VAR_0, NULL);
		VAR_12 = fz_new_list_device(VAR_0, VAR_11);

		VAR_15 = fz_new_path(VAR_0);
		draw_logo(VAR_0, VAR_15);
		fz_bound_path(VAR_0, VAR_15, NULL, &VAR_26, &VAR_21);
		center_rect_within_rect(&VAR_21, &VAR_23, &VAR_22);
		fz_concat(&VAR_22, &VAR_22, &VAR_17);
		fz_fill_path(VAR_0, VAR_12, VAR_15, 0, &VAR_22, VAR_24, VAR_27, 1.0f, NULL);

		get_font_info(VAR_0, VAR_1, VAR_7, VAR_18, &VAR_13);

		switch (VAR_13.da_rec.col_size)
		{
		case 1: VAR_24 = fz_device_gray(VAR_0); break;
		case 3: VAR_24 = fz_device_rgb(VAR_0); break;
		case 4: VAR_24 = fz_device_cmyk(VAR_0); break;
		}

		/* COMMENT_1 */
		VAR_23.x1 = (VAR_23.x0 + VAR_23.x1)/2.0f;
		VAR_14 = fit_text(VAR_0, &VAR_13, VAR_3, &VAR_23);
		fz_fill_text(VAR_0, VAR_12, VAR_14, &VAR_17, VAR_24, VAR_13.da_rec.col, 1.0f, NULL);
		fz_drop_text(VAR_0, VAR_14);
		VAR_14 = NULL;

		/* COMMENT_2 */
		VAR_16 = fz_new_buffer(VAR_0, 256);
		fz_append_printf(VAR_0, VAR_16, ""Digitally signed by %s"", VAR_3);
		fz_append_printf(VAR_0, VAR_16, ""\nDN: %s"", VAR_4);
		if (VAR_5)
			fz_append_printf(VAR_0, VAR_16, ""\nDate: %s"", VAR_5);
		VAR_23 = VAR_20;
		VAR_23.x0 = (VAR_23.x0 + VAR_23.x1)/2.0f;
		VAR_14 = fit_text(VAR_0, &VAR_13, fz_string_from_buffer(VAR_0, VAR_16), &VAR_23);
		fz_fill_text(VAR_0, VAR_12, VAR_14, &VAR_17, VAR_24, VAR_13.da_rec.col, 1.0f, NULL);

		fz_close_device(VAR_0, VAR_12);

		VAR_23 = VAR_20;
		fz_transform_rect(&VAR_23, &VAR_17);
		pdf_set_annot_appearance(VAR_0, VAR_1, VAR_2, &VAR_23, VAR_11);

		/* COMMENT_3 */
                                                   
		pdf_drop_xobject(VAR_0, VAR_2->ap);
		VAR_2->ap = NULL;

		insert_signature_appearance_layers(VAR_0, VAR_1, VAR_2);
	}
	fz_always(VAR_0)
	{
		fz_drop_device(VAR_0, VAR_12);
		fz_drop_display_list(VAR_0, VAR_11);
		font_info_fin(VAR_0, &VAR_13);
		fz_drop_path(VAR_0, VAR_15);
		fz_drop_text(VAR_0, VAR_14);
		fz_drop_buffer(VAR_0, VAR_16);
	}
	fz_catch(VAR_0)
	{
		fz_rethrow(VAR_0);
	}
}",ArtifexSoftware/mupdf/321ba1de287016b0036bf4a56ce774ad11763384/pdf-appearance.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,6 @@
 	fz_device *dev = NULL;
 	font_info font_rec;
 	fz_text *text = NULL;
-	fz_colorspace *cs = NULL;
 	fz_path *path = NULL;
 	fz_buffer *fzbuf = NULL;
 	fz_matrix page_ctm;
@@ -22,7 +21,6 @@
 	fz_var(dlist);
 	fz_var(dev);
 	fz_var(text);
-	fz_var(cs);
 	fz_var(fzbuf);
 	fz_try(ctx)
 	{
@@ -31,6 +29,7 @@
 		fz_rect logo_bounds;
 		fz_matrix logo_tm;
 		fz_rect rect;
+		fz_colorspace *cs = fz_device_rgb(ctx); /* Borrowed reference */
 
 		pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &annot_rect);
 		rect = annot_rect;
@@ -43,7 +42,6 @@
 		fz_bound_path(ctx, path, NULL, &fz_identity, &logo_bounds);
 		center_rect_within_rect(&logo_bounds, &rect, &logo_tm);
 		fz_concat(&logo_tm, &logo_tm, &page_ctm);
-		cs = fz_device_rgb(ctx); /* Borrowed reference */
 		fz_fill_path(ctx, dev, path, 0, &logo_tm, cs, logo_color, 1.0f, NULL);
 
 		get_font_info(ctx, doc, dr, da, &font_rec);","{'deleted_lines': ['\tfz_colorspace *cs = NULL;', '\tfz_var(cs);', '\t\tcs = fz_device_rgb(ctx); /* Borrowed reference */'], 'added_lines': ['\t\tfz_colorspace *cs = fz_device_rgb(ctx); /* Borrowed reference */']}",True,Artifex Mupdf version 1.12.0 contains a Use After Free vulnerability in fz_keep_key_storable that can result in DOS / Possible code execution. This attack appear to be exploitable via Victim opens a specially crafted PDF.,7.8,HIGH,2,valid,2017-12-19T22:47:47Z,2
CVE-2017-17784,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,GNOME/gimp,"Bug 790784 - (CVE-2017-17784) heap overread in gbr parser / load_image.

We were assuming the input name was well formed, hence was
nul-terminated. As any data coming from external input, this has to be
thorougly checked.
Similar to commit 06d24a79af94837d615d0024916bb95a01bf3c59 but adapted
to older gimp-2-8 code.",c57f9dcf1934a9ab0cd67650f2dea18cb0902270,https://github.com/GNOME/gimp/commit/c57f9dcf1934a9ab0cd67650f2dea18cb0902270,plug-ins/common/file-gbr.c,load_image,"static gint32
load_image (const gchar  *filename,
GError      **error)
{
gchar             *name;
gint               fd;
BrushHeader        bh;
guchar            *brush_buf = NULL;
gint32             image_ID;
gint32             layer_ID;
GimpParasite      *parasite;
GimpDrawable      *drawable;
GimpPixelRgn       pixel_rgn;
gint               bn_size;
GimpImageBaseType  base_type;
GimpImageType      image_type;
gsize              size;
fd = g_open (filename, O_RDONLY | _O_BINARY, 0);
if (fd == -1)
{
g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),
_(""Could not open '%s' for reading: %s""),
gimp_filename_to_utf8 (filename), g_strerror (errno));
return -1;
}
gimp_progress_init_printf (_(""Opening '%s'""),
gimp_filename_to_utf8 (filename));
if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))
{
close (fd);
return -1;
}
bh.header_size  = g_ntohl (bh.header_size);
bh.version      = g_ntohl (bh.version);
bh.width        = g_ntohl (bh.width);
bh.height       = g_ntohl (bh.height);
bh.bytes        = g_ntohl (bh.bytes);
bh.magic_number = g_ntohl (bh.magic_number);
bh.spacing      = g_ntohl (bh.spacing);
if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||
(bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||
((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&
(bh.bytes != 18)) ||
(G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))
{
g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
_(""Invalid header data in '%s': width=%lu, height=%lu, ""
""bytes=%lu""), gimp_filename_to_utf8 (filename),
(unsigned long int)bh.width, (unsigned long int)bh.height,
(unsigned long int)bh.bytes);
return -1;
}
switch (bh.version)
{
case 1:
bh.spacing = 25;
lseek (fd, -8, SEEK_CUR);
bh.header_size += 8;
break;
case 3: 
if (bh.bytes == 18 )
{
bh.bytes = 2;
}
else
{
g_message (_(""Unsupported brush format""));
close (fd);
return -1;
}
case 2:
if (bh.magic_number == GBRUSH_MAGIC &&
bh.header_size  >  sizeof (BrushHeader))
break;
default:
g_message (_(""Unsupported brush format""));
close (fd);
return -1;
}
if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)
{
gchar *temp = g_new (gchar, bn_size);
if ((read (fd, temp, bn_size)) < bn_size)
{
g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
_(""Error in GIMP brush file '%s'""),
gimp_filename_to_utf8 (filename));
close (fd);
g_free (temp);
return -1;
}
name = gimp_any_to_utf8 (temp, -1,
_(""Invalid UTF-8 string in brush file '%s'.""),
gimp_filename_to_utf8 (filename));
g_free (temp);
}
else
{
name = g_strdup (_(""Unnamed""));
}
size = bh.width * bh.height * bh.bytes;
brush_buf = g_malloc (size);
if (read (fd, brush_buf, size) != size)
{
close (fd);
g_free (brush_buf);
g_free (name);
return -1;
}
switch (bh.bytes)
{
case 1:
{
PatternHeader ph;
if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))
{
ph.header_size  = g_ntohl (ph.header_size);
ph.version      = g_ntohl (ph.version);
ph.width        = g_ntohl (ph.width);
ph.height       = g_ntohl (ph.height);
ph.bytes        = g_ntohl (ph.bytes);
ph.magic_number = g_ntohl (ph.magic_number);
if (ph.magic_number == GPATTERN_MAGIC        &&
ph.version      == 1                     &&
ph.header_size  > sizeof (PatternHeader) &&
ph.bytes        == 3                     &&
ph.width        == bh.width              &&
ph.height       == bh.height             &&
lseek (fd, ph.header_size - sizeof (PatternHeader),
SEEK_CUR) > 0)
{
guchar *plain_brush = brush_buf;
gint    i;
bh.bytes = 4;
brush_buf = g_malloc (4 * bh.width * bh.height);
for (i = 0; i < ph.width * ph.height; i++)
{
if (read (fd, brush_buf + i * 4, 3) != 3)
{
close (fd);
g_free (name);
g_free (plain_brush);
g_free (brush_buf);
return -1;
}
brush_buf[i * 4 + 3] = plain_brush[i];
}
g_free (plain_brush);
}
}
}
break;
case 2:
{
guint16 *buf = (guint16 *) brush_buf;
gint     i;
for (i = 0; i < bh.width * bh.height; i++, buf++)
{
union
{
guint16 u[2];
gfloat  f;
} short_float;
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
short_float.u[0] = 0;
short_float.u[1] = GUINT16_FROM_BE (*buf);
#else
short_float.u[0] = GUINT16_FROM_BE (*buf);
short_float.u[1] = 0;
#endif
brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);
}
bh.bytes = 1;
}
break;
default:
break;
}
switch (bh.bytes)
{
case 1:
base_type = GIMP_GRAY;
image_type = GIMP_GRAY_IMAGE;
break;
case 4:
base_type = GIMP_RGB;
image_type = GIMP_RGBA_IMAGE;
break;
default:
g_message (""Unsupported brush depth: %d\n""
""GIMP Brushes must be GRAY or RGBA\n"",
bh.bytes);
g_free (name);
return -1;
}
image_ID = gimp_image_new (bh.width, bh.height, base_type);
gimp_image_set_filename (image_ID, filename);
parasite = gimp_parasite_new (""gimp-brush-name"",
GIMP_PARASITE_PERSISTENT,
strlen (name) + 1, name);
gimp_image_attach_parasite (image_ID, parasite);
gimp_parasite_free (parasite);
layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,
image_type, 100, GIMP_NORMAL_MODE);
gimp_image_insert_layer (image_ID, layer_ID, -1, 0);
g_free (name);
drawable = gimp_drawable_get (layer_ID);
gimp_pixel_rgn_init (&pixel_rgn, drawable,
0, 0, drawable->width, drawable->height,
TRUE, FALSE);
gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,
0, 0, bh.width, bh.height);
g_free (brush_buf);
if (image_type == GIMP_GRAY_IMAGE)
gimp_invert (layer_ID);
close (fd);
gimp_drawable_flush (drawable);
gimp_progress_update (1.0);
return image_ID;
}","static gint32
load_image (const gchar  *VAR_0,
GError      **VAR_1)
{
gchar             *VAR_2;
gint               VAR_3;
BrushHeader        VAR_4;
guchar            *VAR_5 = NULL;
gint32             VAR_6;
gint32             VAR_7;
GimpParasite      *VAR_8;
GimpDrawable      *VAR_9;
GimpPixelRgn       VAR_10;
gint               VAR_11;
GimpImageBaseType  VAR_12;
GimpImageType      VAR_13;
gsize              VAR_14;
VAR_3 = g_open (VAR_0, VAR_15 | VAR_16, 0);
if (VAR_3 == -1)
{
g_set_error (VAR_1, VAR_17, g_file_error_from_errno (VAR_18),
_(""Could not open '%s' for reading: %s""),
gimp_filename_to_utf8 (VAR_0), g_strerror (VAR_18));
return -1;
}
gimp_progress_init_printf (_(""Opening '%s'""),
gimp_filename_to_utf8 (VAR_0));
if (read (VAR_3, &VAR_4, sizeof (BrushHeader)) != sizeof (BrushHeader))
{
close (VAR_3);
return -1;
}
VAR_4.header_size  = g_ntohl (VAR_4.header_size);
VAR_4.version      = g_ntohl (VAR_4.version);
VAR_4.width        = g_ntohl (VAR_4.width);
VAR_4.height       = g_ntohl (VAR_4.height);
VAR_4.bytes        = g_ntohl (VAR_4.bytes);
VAR_4.magic_number = g_ntohl (VAR_4.magic_number);
VAR_4.spacing      = g_ntohl (VAR_4.spacing);
if ((VAR_4.width == 0) || (VAR_4.width > VAR_19) ||
(VAR_4.height == 0) || (VAR_4.height > VAR_19) ||
((VAR_4.bytes != 1) && (VAR_4.bytes != 2) && (VAR_4.bytes != 4) &&
(VAR_4.bytes != 18)) ||
(VAR_20 / VAR_4.width / VAR_4.height / VAR_4.bytes < 1))
{
g_set_error (VAR_1, VAR_17, VAR_21,
_(""Invalid header data in '%s': width=%lu, height=%lu, ""
""bytes=%lu""), gimp_filename_to_utf8 (VAR_0),
(unsigned long int)VAR_4.width, (unsigned long int)VAR_4.height,
(unsigned long int)VAR_4.bytes);
return -1;
}
switch (VAR_4.version)
{
case 1:
VAR_4.spacing = 25;
lseek (VAR_3, -8, VAR_22);
VAR_4.header_size += 8;
break;
case 3: 
if (VAR_4.bytes == 18 )
{
VAR_4.bytes = 2;
}
else
{
g_message (_(""Unsupported brush format""));
close (VAR_3);
return -1;
}
case 2:
if (VAR_4.magic_number == VAR_23 &&
VAR_4.header_size  >  sizeof (BrushHeader))
break;
default:
g_message (_(""Unsupported brush format""));
close (VAR_3);
return -1;
}
if ((VAR_11 = (VAR_4.header_size - sizeof (BrushHeader))) > 0)
{
gchar *VAR_24 = g_new (gchar, VAR_11);
if ((read (VAR_3, VAR_24, VAR_11)) < VAR_11)
{
g_set_error (VAR_1, VAR_17, VAR_21,
_(""Error in GIMP brush file '%s'""),
gimp_filename_to_utf8 (VAR_0));
close (VAR_3);
g_free (VAR_24);
return -1;
}
VAR_2 = gimp_any_to_utf8 (VAR_24, -1,
_(""Invalid UTF-8 string in brush file '%s'.""),
gimp_filename_to_utf8 (VAR_0));
g_free (VAR_24);
}
else
{
VAR_2 = g_strdup (_(""Unnamed""));
}
VAR_14 = VAR_4.width * VAR_4.height * VAR_4.bytes;
VAR_5 = g_malloc (VAR_14);
if (read (VAR_3, VAR_5, VAR_14) != VAR_14)
{
close (VAR_3);
g_free (VAR_5);
g_free (VAR_2);
return -1;
}
switch (VAR_4.bytes)
{
case 1:
{
PatternHeader VAR_25;
if (read (VAR_3, &VAR_25, sizeof (PatternHeader)) == sizeof(PatternHeader))
{
VAR_25.header_size  = g_ntohl (VAR_25.header_size);
VAR_25.version      = g_ntohl (VAR_25.version);
VAR_25.width        = g_ntohl (VAR_25.width);
VAR_25.height       = g_ntohl (VAR_25.height);
VAR_25.bytes        = g_ntohl (VAR_25.bytes);
VAR_25.magic_number = g_ntohl (VAR_25.magic_number);
if (VAR_25.magic_number == VAR_26        &&
VAR_25.version      == 1                     &&
VAR_25.header_size  > sizeof (PatternHeader) &&
VAR_25.bytes        == 3                     &&
VAR_25.width        == VAR_4.width              &&
VAR_25.height       == VAR_4.height             &&
lseek (VAR_3, VAR_25.header_size - sizeof (PatternHeader),
VAR_22) > 0)
{
guchar *VAR_27 = VAR_5;
gint    VAR_28;
VAR_4.bytes = 4;
VAR_5 = g_malloc (4 * VAR_4.width * VAR_4.height);
for (VAR_28 = 0; VAR_28 < VAR_25.width * VAR_25.height; VAR_28++)
{
if (read (VAR_3, VAR_5 + VAR_28 * 4, 3) != 3)
{
close (VAR_3);
g_free (VAR_2);
g_free (VAR_27);
g_free (VAR_5);
return -1;
}
VAR_5[VAR_28 * 4 + 3] = VAR_27[VAR_28];
}
g_free (VAR_27);
}
}
}
break;
case 2:
{
guint16 *VAR_29 = (guint16 *) VAR_5;
gint     VAR_28;
for (VAR_28 = 0; VAR_28 < VAR_4.width * VAR_4.height; VAR_28++, VAR_29++)
{
union
{
guint16 u[2];
gfloat  f;
} VAR_30;
#if VAR_31 == VAR_32
VAR_30.u[0] = 0;
VAR_30.u[1] = GUINT16_FROM_BE (*VAR_29);
#else
VAR_30.u[0] = GUINT16_FROM_BE (*VAR_29);
VAR_30.u[1] = 0;
#endif
VAR_5[VAR_28] = (guchar) (VAR_30.f * 255.0 + 0.5);
}
VAR_4.bytes = 1;
}
break;
default:
break;
}
switch (VAR_4.bytes)
{
case 1:
VAR_12 = VAR_33;
VAR_13 = VAR_34;
break;
case 4:
VAR_12 = VAR_35;
VAR_13 = VAR_36;
break;
default:
g_message (""Unsupported brush depth: %d\n""
""GIMP Brushes must be GRAY or RGBA\n"",
VAR_4.bytes);
g_free (VAR_2);
return -1;
}
VAR_6 = gimp_image_new (VAR_4.width, VAR_4.height, VAR_12);
gimp_image_set_filename (VAR_6, VAR_0);
VAR_8 = gimp_parasite_new (""gimp-brush-name"",
VAR_37,
strlen (VAR_2) + 1, VAR_2);
gimp_image_attach_parasite (VAR_6, VAR_8);
gimp_parasite_free (VAR_8);
VAR_7 = gimp_layer_new (VAR_6, VAR_2, VAR_4.width, VAR_4.height,
VAR_13, 100, VAR_38);
gimp_image_insert_layer (VAR_6, VAR_7, -1, 0);
g_free (VAR_2);
VAR_9 = gimp_drawable_get (VAR_7);
gimp_pixel_rgn_init (&VAR_10, VAR_9,
0, 0, VAR_9->width, VAR_9->height,
TRUE, FALSE);
gimp_pixel_rgn_set_rect (&VAR_10, VAR_5,
0, 0, VAR_4.width, VAR_4.height);
g_free (VAR_5);
if (VAR_13 == VAR_34)
gimp_invert (VAR_7);
close (VAR_3);
gimp_drawable_flush (VAR_9);
gimp_progress_update (1.0);
return VAR_6;
}",GNOME/gimp/c57f9dcf1934a9ab0cd67650f2dea18cb0902270/file-gbr.c/vul/before/0.json,"static gint32
load_image (const gchar  *filename,
            GError      **error)
{
  gchar             *name;
  gint               fd;
  BrushHeader        bh;
  guchar            *brush_buf = NULL;
  gint32             image_ID;
  gint32             layer_ID;
  GimpParasite      *parasite;
  GimpDrawable      *drawable;
  GimpPixelRgn       pixel_rgn;
  gint               bn_size;
  GimpImageBaseType  base_type;
  GimpImageType      image_type;
  gsize              size;

  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);

  if (fd == -1)
    {
      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),
                   _(""Could not open '%s' for reading: %s""),
                   gimp_filename_to_utf8 (filename), g_strerror (errno));
      return -1;
    }

  gimp_progress_init_printf (_(""Opening '%s'""),
                             gimp_filename_to_utf8 (filename));

  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))
    {
      close (fd);
      return -1;
    }

  /*  rearrange the bytes in each unsigned int  */
  bh.header_size  = g_ntohl (bh.header_size);
  bh.version      = g_ntohl (bh.version);
  bh.width        = g_ntohl (bh.width);
  bh.height       = g_ntohl (bh.height);
  bh.bytes        = g_ntohl (bh.bytes);
  bh.magic_number = g_ntohl (bh.magic_number);
  bh.spacing      = g_ntohl (bh.spacing);

  /* Sanitize values */
  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||
      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||
      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&
       (bh.bytes != 18)) ||
      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))
    {
      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _(""Invalid header data in '%s': width=%lu, height=%lu, ""
                     ""bytes=%lu""), gimp_filename_to_utf8 (filename),
                   (unsigned long int)bh.width, (unsigned long int)bh.height,
                   (unsigned long int)bh.bytes);
      return -1;
    }

  switch (bh.version)
    {
    case 1:
      /* Version 1 didn't have a magic number and had no spacing  */
      bh.spacing = 25;
      /* And we need to rewind the handle, 4 due spacing and 4 due magic */
      lseek (fd, -8, SEEK_CUR);
      bh.header_size += 8;
      break;

    case 3: /*  cinepaint brush  */
      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)
        {
          bh.bytes = 2;
        }
      else
        {
          g_message (_(""Unsupported brush format""));
          close (fd);
          return -1;
        }
      /*  fallthrough  */

    case 2:
      if (bh.magic_number == GBRUSH_MAGIC &&
          bh.header_size  >  sizeof (BrushHeader))
        break;

    default:
      g_message (_(""Unsupported brush format""));
      close (fd);
      return -1;
    }

  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)
    {
      gchar *temp = g_new (gchar, bn_size);

      if ((read (fd, temp, bn_size)) < bn_size ||
          temp[bn_size - 1] != '\0')
        {
          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                       _(""Error in GIMP brush file '%s'""),
                       gimp_filename_to_utf8 (filename));
          close (fd);
          g_free (temp);
          return -1;
        }

      name = gimp_any_to_utf8 (temp, -1,
                               _(""Invalid UTF-8 string in brush file '%s'.""),
                               gimp_filename_to_utf8 (filename));
      g_free (temp);
    }
  else
    {
      name = g_strdup (_(""Unnamed""));
    }

  /* Now there's just raw data left. */

  size = bh.width * bh.height * bh.bytes;
  brush_buf = g_malloc (size);

  if (read (fd, brush_buf, size) != size)
    {
      close (fd);
      g_free (brush_buf);
      g_free (name);
      return -1;
    }

  switch (bh.bytes)
    {
    case 1:
      {
        PatternHeader ph;

        /*  For backwards-compatibility, check if a pattern follows.
            The obsolete .gpb format did it this way.  */

        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))
          {
            /*  rearrange the bytes in each unsigned int  */
            ph.header_size  = g_ntohl (ph.header_size);
            ph.version      = g_ntohl (ph.version);
            ph.width        = g_ntohl (ph.width);
            ph.height       = g_ntohl (ph.height);
            ph.bytes        = g_ntohl (ph.bytes);
            ph.magic_number = g_ntohl (ph.magic_number);

            if (ph.magic_number == GPATTERN_MAGIC        &&
                ph.version      == 1                     &&
                ph.header_size  > sizeof (PatternHeader) &&
                ph.bytes        == 3                     &&
                ph.width        == bh.width              &&
                ph.height       == bh.height             &&
                lseek (fd, ph.header_size - sizeof (PatternHeader),
                       SEEK_CUR) > 0)
              {
                guchar *plain_brush = brush_buf;
                gint    i;

                bh.bytes = 4;
                brush_buf = g_malloc (4 * bh.width * bh.height);

                for (i = 0; i < ph.width * ph.height; i++)
                  {
                    if (read (fd, brush_buf + i * 4, 3) != 3)
                      {
                        close (fd);
                        g_free (name);
                        g_free (plain_brush);
                        g_free (brush_buf);
                        return -1;
                      }
                    brush_buf[i * 4 + 3] = plain_brush[i];
                  }
                g_free (plain_brush);
              }
          }
      }
      break;

    case 2:
      {
        guint16 *buf = (guint16 *) brush_buf;
        gint     i;

        for (i = 0; i < bh.width * bh.height; i++, buf++)
          {
            union
            {
              guint16 u[2];
              gfloat  f;
            } short_float;

#if G_BYTE_ORDER == G_LITTLE_ENDIAN
            short_float.u[0] = 0;
            short_float.u[1] = GUINT16_FROM_BE (*buf);
#else
            short_float.u[0] = GUINT16_FROM_BE (*buf);
            short_float.u[1] = 0;
#endif

            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);
          }

        bh.bytes = 1;
      }
      break;

    default:
      break;
    }

  /*
   * Create a new image of the proper size and
   * associate the filename with it.
   */

  switch (bh.bytes)
    {
    case 1:
      base_type = GIMP_GRAY;
      image_type = GIMP_GRAY_IMAGE;
      break;

    case 4:
      base_type = GIMP_RGB;
      image_type = GIMP_RGBA_IMAGE;
      break;

    default:
      g_message (""Unsupported brush depth: %d\n""
                 ""GIMP Brushes must be GRAY or RGBA\n"",
                 bh.bytes);
      g_free (name);
      return -1;
    }

  image_ID = gimp_image_new (bh.width, bh.height, base_type);
  gimp_image_set_filename (image_ID, filename);

  parasite = gimp_parasite_new (""gimp-brush-name"",
                                GIMP_PARASITE_PERSISTENT,
                                strlen (name) + 1, name);
  gimp_image_attach_parasite (image_ID, parasite);
  gimp_parasite_free (parasite);

  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,
                             image_type, 100, GIMP_NORMAL_MODE);
  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);

  g_free (name);

  drawable = gimp_drawable_get (layer_ID);
  gimp_pixel_rgn_init (&pixel_rgn, drawable,
                       0, 0, drawable->width, drawable->height,
                       TRUE, FALSE);

  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,
                           0, 0, bh.width, bh.height);
  g_free (brush_buf);

  if (image_type == GIMP_GRAY_IMAGE)
    gimp_invert (layer_ID);

  close (fd);

  gimp_drawable_flush (drawable);
  gimp_progress_update (1.0);

  return image_ID;
}","static gint32
load_image (const gchar  *VAR_0,
            GError      **VAR_1)
{
  gchar             *VAR_2;
  gint               VAR_3;
  BrushHeader        VAR_4;
  guchar            *VAR_5 = NULL;
  gint32             VAR_6;
  gint32             VAR_7;
  GimpParasite      *VAR_8;
  GimpDrawable      *VAR_9;
  GimpPixelRgn       VAR_10;
  gint               VAR_11;
  GimpImageBaseType  VAR_12;
  GimpImageType      VAR_13;
  gsize              VAR_14;

  VAR_3 = g_open (VAR_0, VAR_15 | VAR_16, 0);

  if (VAR_3 == -1)
    {
      g_set_error (VAR_1, VAR_17, g_file_error_from_errno (VAR_18),
                   _(""Could not open '%s' for reading: %s""),
                   gimp_filename_to_utf8 (VAR_0), g_strerror (VAR_18));
      return -1;
    }

  gimp_progress_init_printf (_(""Opening '%s'""),
                             gimp_filename_to_utf8 (VAR_0));

  if (read (VAR_3, &VAR_4, sizeof (BrushHeader)) != sizeof (BrushHeader))
    {
      close (VAR_3);
      return -1;
    }

  /* COMMENT_0 */
  VAR_4.header_size  = g_ntohl (VAR_4.header_size);
  VAR_4.version      = g_ntohl (VAR_4.version);
  VAR_4.width        = g_ntohl (VAR_4.width);
  VAR_4.height       = g_ntohl (VAR_4.height);
  VAR_4.bytes        = g_ntohl (VAR_4.bytes);
  VAR_4.magic_number = g_ntohl (VAR_4.magic_number);
  VAR_4.spacing      = g_ntohl (VAR_4.spacing);

  /* COMMENT_1 */
  if ((VAR_4.width == 0) || (VAR_4.width > VAR_19) ||
      (VAR_4.height == 0) || (VAR_4.height > VAR_19) ||
      ((VAR_4.bytes != 1) && (VAR_4.bytes != 2) && (VAR_4.bytes != 4) &&
       (VAR_4.bytes != 18)) ||
      (VAR_20 / VAR_4.width / VAR_4.height / VAR_4.bytes < 1))
    {
      g_set_error (VAR_1, VAR_17, VAR_21,
                   _(""Invalid header data in '%s': width=%lu, height=%lu, ""
                     ""bytes=%lu""), gimp_filename_to_utf8 (VAR_0),
                   (unsigned long int)VAR_4.width, (unsigned long int)VAR_4.height,
                   (unsigned long int)VAR_4.bytes);
      return -1;
    }

  switch (VAR_4.version)
    {
    case 1:
      /* COMMENT_2 */
      VAR_4.spacing = 25;
      /* COMMENT_3 */
      lseek (VAR_3, -8, VAR_22);
      VAR_4.header_size += 8;
      break;

    case 3: /* COMMENT_4 */
      if (VAR_4.bytes == 18 /* COMMENT_5 */)
        {
          VAR_4.bytes = 2;
        }
      else
        {
          g_message (_(""Unsupported brush format""));
          close (VAR_3);
          return -1;
        }
      /* COMMENT_6 */

    case 2:
      if (VAR_4.magic_number == VAR_23 &&
          VAR_4.header_size  >  sizeof (BrushHeader))
        break;

    default:
      g_message (_(""Unsupported brush format""));
      close (VAR_3);
      return -1;
    }

  if ((VAR_11 = (VAR_4.header_size - sizeof (BrushHeader))) > 0)
    {
      gchar *VAR_24 = g_new (gchar, VAR_11);

      if ((read (VAR_3, VAR_24, VAR_11)) < VAR_11 ||
          VAR_24[VAR_11 - 1] != '\0')
        {
          g_set_error (VAR_1, VAR_17, VAR_21,
                       _(""Error in GIMP brush file '%s'""),
                       gimp_filename_to_utf8 (VAR_0));
          close (VAR_3);
          g_free (VAR_24);
          return -1;
        }

      VAR_2 = gimp_any_to_utf8 (VAR_24, -1,
                               _(""Invalid UTF-8 string in brush file '%s'.""),
                               gimp_filename_to_utf8 (VAR_0));
      g_free (VAR_24);
    }
  else
    {
      VAR_2 = g_strdup (_(""Unnamed""));
    }

  /* COMMENT_7 */

  VAR_14 = VAR_4.width * VAR_4.height * VAR_4.bytes;
  VAR_5 = g_malloc (VAR_14);

  if (read (VAR_3, VAR_5, VAR_14) != VAR_14)
    {
      close (VAR_3);
      g_free (VAR_5);
      g_free (VAR_2);
      return -1;
    }

  switch (VAR_4.bytes)
    {
    case 1:
      {
        PatternHeader VAR_25;

        /* COMMENT_8 */
                                                         

        if (read (VAR_3, &VAR_25, sizeof (PatternHeader)) == sizeof(PatternHeader))
          {
            /* COMMENT_0 */
            VAR_25.header_size  = g_ntohl (VAR_25.header_size);
            VAR_25.version      = g_ntohl (VAR_25.version);
            VAR_25.width        = g_ntohl (VAR_25.width);
            VAR_25.height       = g_ntohl (VAR_25.height);
            VAR_25.bytes        = g_ntohl (VAR_25.bytes);
            VAR_25.magic_number = g_ntohl (VAR_25.magic_number);

            if (VAR_25.magic_number == VAR_26        &&
                VAR_25.version      == 1                     &&
                VAR_25.header_size  > sizeof (PatternHeader) &&
                VAR_25.bytes        == 3                     &&
                VAR_25.width        == VAR_4.width              &&
                VAR_25.height       == VAR_4.height             &&
                lseek (VAR_3, VAR_25.header_size - sizeof (PatternHeader),
                       VAR_22) > 0)
              {
                guchar *VAR_27 = VAR_5;
                gint    VAR_28;

                VAR_4.bytes = 4;
                VAR_5 = g_malloc (4 * VAR_4.width * VAR_4.height);

                for (VAR_28 = 0; VAR_28 < VAR_25.width * VAR_25.height; VAR_28++)
                  {
                    if (read (VAR_3, VAR_5 + VAR_28 * 4, 3) != 3)
                      {
                        close (VAR_3);
                        g_free (VAR_2);
                        g_free (VAR_27);
                        g_free (VAR_5);
                        return -1;
                      }
                    VAR_5[VAR_28 * 4 + 3] = VAR_27[VAR_28];
                  }
                g_free (VAR_27);
              }
          }
      }
      break;

    case 2:
      {
        guint16 *VAR_29 = (guint16 *) VAR_5;
        gint     VAR_28;

        for (VAR_28 = 0; VAR_28 < VAR_4.width * VAR_4.height; VAR_28++, VAR_29++)
          {
            union
            {
              guint16 u[2];
              gfloat  f;
            } VAR_30;

#if VAR_31 == VAR_32
            VAR_30.u[0] = 0;
            VAR_30.u[1] = GUINT16_FROM_BE (*VAR_29);
#else
            VAR_30.u[0] = GUINT16_FROM_BE (*VAR_29);
            VAR_30.u[1] = 0;
#endif

            VAR_5[VAR_28] = (guchar) (VAR_30.f * 255.0 + 0.5);
          }

        VAR_4.bytes = 1;
      }
      break;

    default:
      break;
    }

  /* COMMENT_10 */
                                              
                                    
     

  switch (VAR_4.bytes)
    {
    case 1:
      VAR_12 = VAR_33;
      VAR_13 = VAR_34;
      break;

    case 4:
      VAR_12 = VAR_35;
      VAR_13 = VAR_36;
      break;

    default:
      g_message (""Unsupported brush depth: %d\n""
                 ""GIMP Brushes must be GRAY or RGBA\n"",
                 VAR_4.bytes);
      g_free (VAR_2);
      return -1;
    }

  VAR_6 = gimp_image_new (VAR_4.width, VAR_4.height, VAR_12);
  gimp_image_set_filename (VAR_6, VAR_0);

  VAR_8 = gimp_parasite_new (""gimp-brush-name"",
                                VAR_37,
                                strlen (VAR_2) + 1, VAR_2);
  gimp_image_attach_parasite (VAR_6, VAR_8);
  gimp_parasite_free (VAR_8);

  VAR_7 = gimp_layer_new (VAR_6, VAR_2, VAR_4.width, VAR_4.height,
                             VAR_13, 100, VAR_38);
  gimp_image_insert_layer (VAR_6, VAR_7, -1, 0);

  g_free (VAR_2);

  VAR_9 = gimp_drawable_get (VAR_7);
  gimp_pixel_rgn_init (&VAR_10, VAR_9,
                       0, 0, VAR_9->width, VAR_9->height,
                       TRUE, FALSE);

  gimp_pixel_rgn_set_rect (&VAR_10, VAR_5,
                           0, 0, VAR_4.width, VAR_4.height);
  g_free (VAR_5);

  if (VAR_13 == VAR_34)
    gimp_invert (VAR_7);

  close (VAR_3);

  gimp_drawable_flush (VAR_9);
  gimp_progress_update (1.0);

  return VAR_6;
}",GNOME/gimp/c57f9dcf1934a9ab0cd67650f2dea18cb0902270/file-gbr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -97,7 +97,8 @@
     {
       gchar *temp = g_new (gchar, bn_size);
 
-      if ((read (fd, temp, bn_size)) < bn_size)
+      if ((read (fd, temp, bn_size)) < bn_size ||
+          temp[bn_size - 1] != '\0')
         {
           g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                        _(""Error in GIMP brush file '%s'""),","{'deleted_lines': ['      if ((read (fd, temp, bn_size)) < bn_size)'], 'added_lines': ['      if ((read (fd, temp, bn_size)) < bn_size ||', ""          temp[bn_size - 1] != '\\0')""]}",True,"In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.",7.8,HIGH,2,valid,2017-12-21T11:25:32Z,2
CVE-2017-18008,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/921,1a5f95fc018a5667de5a9448aee9d7251b2eb952,https://github.com/ImageMagick/ImageMagick/commit/1a5f95fc018a5667de5a9448aee9d7251b2eb952,coders/pwp.c,ReadPWPImage,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
FILE
*file;
Image
*image,
*next_image,
*pwp_image;
ImageInfo
*read_info;
int
c,
unique_file;
MagickBooleanType
status;
register Image
*p;
register ssize_t
i;
size_t
filesize,
length;
ssize_t
count;
unsigned char
magick[MaxTextExtent];
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
pwp_image=AcquireImage(image_info);
image=pwp_image;
status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
return((Image *) NULL);
ResetMagickMemory(magick,0,sizeof(magick));
count=ReadBlob(pwp_image,5,magick);
if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
read_info=CloneImageInfo(image_info);
(void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
(void *) NULL);
SetImageInfoBlob(read_info,(void *) NULL,0);
unique_file=AcquireUniqueFileResource(read_info->filename);
for ( ; ; )
{
(void) memset(magick,0,sizeof(magick));
for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
{
for (i=0; i < 17; i++)
magick[i]=magick[i+1];
magick[17]=(unsigned char) c;
if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
break;
}
if (c == EOF)
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
file=(FILE *) NULL;
if (unique_file != -1)
file=fdopen(unique_file,""wb"");
if ((unique_file == -1) || (file == (FILE *) NULL))
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
image->filename);
image=DestroyImageList(image);
return((Image *) NULL);
}
length=fwrite(""SFW94A"",1,6,file);
(void) length;
filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
for (i=0; i < (ssize_t) filesize; i++)
{
c=ReadBlobByte(pwp_image);
if (c == EOF)
break;
(void) fputc(c,file);
}
(void) fclose(file);
if (c == EOF)
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
next_image=ReadImage(read_info,exception);
if (next_image == (Image *) NULL)
break;
(void) FormatLocaleString(next_image->filename,MaxTextExtent,
""slide_%02ld.sfw"",(long) next_image->scene);
if (image == (Image *) NULL)
image=next_image;
else
{
for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
next_image->previous=p;
next_image->scene=p->scene+1;
p->next=next_image;
}
if (image_info->number_scenes != 0)
if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
GetBlobSize(pwp_image));
if (status == MagickFalse)
break;
}
if (unique_file != -1)
(void) close(unique_file);
(void) RelinquishUniqueFileResource(read_info->filename);
read_info=DestroyImageInfo(read_info);
if (image != (Image *) NULL)
{
if (EOFBlob(image) != MagickFalse)
{
char
*message;
message=GetExceptionMessage(errno);
(void) ThrowMagickException(exception,GetMagickModule(),
CorruptImageError,""UnexpectedEndOfFile"",""`%s': %s"",image->filename,
message);
message=DestroyString(message);
}
(void) CloseBlob(image);
}
return(GetFirstImageInList(image));
}","static Image *ReadPWPImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
FILE
*VAR_2;
Image
*VAR_3,
*VAR_4,
*VAR_5;
ImageInfo
*VAR_6;
int
VAR_7,
VAR_8;
MagickBooleanType
VAR_9;
register Image
*VAR_10;
register ssize_t
VAR_11;
size_t
VAR_12,
VAR_13;
ssize_t
VAR_14;
unsigned char
VAR_15[VAR_16];
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
VAR_5=AcquireImage(VAR_0);
VAR_3=VAR_5;
VAR_9=OpenBlob(VAR_0,VAR_5,VAR_20,VAR_1);
if (VAR_9 == VAR_18)
return((Image *) NULL);
ResetMagickMemory(VAR_15,0,sizeof(VAR_15));
VAR_14=ReadBlob(VAR_5,5,VAR_15);
if ((VAR_14 != 5) || (LocaleNCompare((char *) VAR_15,""SFW95"",5) != 0))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
VAR_6=CloneImageInfo(VAR_0);
(void) SetImageInfoProgressMonitor(VAR_6,(MagickProgressMonitor) NULL,
(void *) NULL);
SetImageInfoBlob(VAR_6,(void *) NULL,0);
VAR_8=AcquireUniqueFileResource(VAR_6->filename);
for ( ; ; )
{
(void) memset(VAR_15,0,sizeof(VAR_15));
for (VAR_7=ReadBlobByte(VAR_5); VAR_7 != VAR_22; VAR_7=ReadBlobByte(VAR_5))
{
for (VAR_11=0; VAR_11 < 17; VAR_11++)
VAR_15[VAR_11]=VAR_15[VAR_11+1];
VAR_15[17]=(unsigned char) VAR_7;
if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) == 0)
break;
}
if (VAR_7 == VAR_22)
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
}
if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) != 0)
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowReaderException(VAR_21,""ImproperImageHeader"");
}
VAR_2=(FILE *) NULL;
if (VAR_8 != -1)
VAR_2=fdopen(VAR_8,""wb"");
if ((VAR_8 == -1) || (VAR_2 == (FILE *) NULL))
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowFileException(VAR_1,VAR_23,""UnableToWriteFile"",
VAR_3->filename);
VAR_3=DestroyImageList(VAR_3);
return((Image *) NULL);
}
VAR_13=fwrite(""SFW94A"",1,6,VAR_2);
(void) VAR_13;
VAR_12=65535UL*VAR_15[2]+256L*VAR_15[1]+VAR_15[0];
for (VAR_11=0; VAR_11 < (ssize_t) VAR_12; VAR_11++)
{
VAR_7=ReadBlobByte(VAR_5);
if (VAR_7 == VAR_22)
break;
(void) fputc(VAR_7,VAR_2);
}
(void) fclose(VAR_2);
if (VAR_7 == VAR_22)
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
}
VAR_4=ReadImage(VAR_6,VAR_1);
if (VAR_4 == (Image *) NULL)
break;
(void) FormatLocaleString(VAR_4->filename,VAR_16,
""slide_%02ld.sfw"",(long) VAR_4->scene);
if (VAR_3 == (Image *) NULL)
VAR_3=VAR_4;
else
{
for (VAR_10=VAR_3; VAR_10->next != (Image *) NULL; VAR_10=GetNextImageInList(VAR_10)) ;
VAR_4->previous=VAR_10;
VAR_4->scene=VAR_10->scene+1;
VAR_10->next=VAR_4;
}
if (VAR_0->number_scenes != 0)
if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_9=SetImageProgress(VAR_3,VAR_24,TellBlob(VAR_5),
GetBlobSize(VAR_5));
if (VAR_9 == VAR_18)
break;
}
if (VAR_8 != -1)
(void) close(VAR_8);
(void) RelinquishUniqueFileResource(VAR_6->filename);
VAR_6=DestroyImageInfo(VAR_6);
if (VAR_3 != (Image *) NULL)
{
if (EOFBlob(VAR_3) != VAR_18)
{
char
*VAR_25;
VAR_25=GetExceptionMessage(VAR_26);
(void) ThrowMagickException(VAR_1,GetMagickModule(),
VAR_21,""UnexpectedEndOfFile"",""`%s': %s"",VAR_3->filename,
VAR_25);
VAR_25=DestroyString(VAR_25);
}
(void) CloseBlob(VAR_3);
}
return(GetFirstImageInList(VAR_3));
}",ImageMagick/1a5f95fc018a5667de5a9448aee9d7251b2eb952/pwp.c/vul/before/0.json,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  ResetMagickMemory(magick,0,sizeof(magick));
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    (void) memset(magick,0,sizeof(magick));
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        read_info=DestroyImageInfo(read_info);
        ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
      }
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        read_info=DestroyImageInfo(read_info);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        read_info=DestroyImageInfo(read_info);
        image=DestroyImageList(image);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      if (c == EOF)
        break;
      (void) fputc(c,file);
    }
    (void) fclose(file);
    if (c == EOF)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        read_info=DestroyImageInfo(read_info);
        ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
      }
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
    (void) close(unique_file);
  (void) RelinquishUniqueFileResource(read_info->filename);
  read_info=DestroyImageInfo(read_info);
  if (image != (Image *) NULL)
    {
      if (EOFBlob(image) != MagickFalse)
        {
          char
            *message;

          message=GetExceptionMessage(errno);
          (void) ThrowMagickException(exception,GetMagickModule(),
            CorruptImageError,""UnexpectedEndOfFile"",""`%s': %s"",image->filename,
            message);
          message=DestroyString(message);
        }
      (void) CloseBlob(image);
    }
  return(GetFirstImageInList(image));
}","static Image *ReadPWPImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  FILE
    *VAR_2;

  Image
    *VAR_3,
    *VAR_4,
    *VAR_5;

  ImageInfo
    *VAR_6;

  int
    VAR_7,
    VAR_8;

  MagickBooleanType
    VAR_9;

  register Image
    *VAR_10;

  register ssize_t
    VAR_11;

  size_t
    VAR_12,
    VAR_13;

  ssize_t
    VAR_14;

  unsigned char
    VAR_15[VAR_16];

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  VAR_5=AcquireImage(VAR_0);
  VAR_3=VAR_5;
  VAR_9=OpenBlob(VAR_0,VAR_5,VAR_20,VAR_1);
  if (VAR_9 == VAR_18)
    return((Image *) NULL);
  ResetMagickMemory(VAR_15,0,sizeof(VAR_15));
  VAR_14=ReadBlob(VAR_5,5,VAR_15);
  if ((VAR_14 != 5) || (LocaleNCompare((char *) VAR_15,""SFW95"",5) != 0))
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  VAR_6=CloneImageInfo(VAR_0);
  (void) SetImageInfoProgressMonitor(VAR_6,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(VAR_6,(void *) NULL,0);
  VAR_8=AcquireUniqueFileResource(VAR_6->filename);
  for ( ; ; )
  {
    (void) memset(VAR_15,0,sizeof(VAR_15));
    for (VAR_7=ReadBlobByte(VAR_5); VAR_7 != VAR_22; VAR_7=ReadBlobByte(VAR_5))
    {
      for (VAR_11=0; VAR_11 < 17; VAR_11++)
        VAR_15[VAR_11]=VAR_15[VAR_11+1];
      VAR_15[17]=(unsigned char) VAR_7;
      if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) == 0)
        break;
    }
    if (VAR_7 == VAR_22)
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        VAR_6=DestroyImageInfo(VAR_6);
        ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
      }
    if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        VAR_6=DestroyImageInfo(VAR_6);
        ThrowReaderException(VAR_21,""ImproperImageHeader"");
      }
    /* COMMENT_3 */
                                         
      
    VAR_2=(FILE *) NULL;
    if (VAR_8 != -1)
      VAR_2=fdopen(VAR_8,""wb"");
    if ((VAR_8 == -1) || (VAR_2 == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        VAR_6=DestroyImageInfo(VAR_6);
        VAR_3=DestroyImageList(VAR_3);
        ThrowFileException(VAR_1,VAR_23,""UnableToWriteFile"",
          VAR_3->filename);
        return((Image *) NULL);
      }
    VAR_13=fwrite(""SFW94A"",1,6,VAR_2);
    (void) VAR_13;
    VAR_12=65535UL*VAR_15[2]+256L*VAR_15[1]+VAR_15[0];
    for (VAR_11=0; VAR_11 < (ssize_t) VAR_12; VAR_11++)
    {
      VAR_7=ReadBlobByte(VAR_5);
      if (VAR_7 == VAR_22)
        break;
      (void) fputc(VAR_7,VAR_2);
    }
    (void) fclose(VAR_2);
    if (VAR_7 == VAR_22)
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        VAR_6=DestroyImageInfo(VAR_6);
        ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
      }
    VAR_4=ReadImage(VAR_6,VAR_1);
    if (VAR_4 == (Image *) NULL)
      break;
    (void) FormatLocaleString(VAR_4->filename,VAR_16,
      ""slide_%02ld.sfw"",(long) VAR_4->scene);
    if (VAR_3 == (Image *) NULL)
      VAR_3=VAR_4;
    else
      {
        /* COMMENT_6 */
                                     
          
        for (VAR_10=VAR_3; VAR_10->next != (Image *) NULL; VAR_10=GetNextImageInList(VAR_10)) ;
        VAR_4->previous=VAR_10;
        VAR_4->scene=VAR_10->scene+1;
        VAR_10->next=VAR_4;
      }
    if (VAR_0->number_scenes != 0)
      if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_9=SetImageProgress(VAR_3,VAR_24,TellBlob(VAR_5),
      GetBlobSize(VAR_5));
    if (VAR_9 == VAR_18)
      break;
  }
  if (VAR_8 != -1)
    (void) close(VAR_8);
  (void) RelinquishUniqueFileResource(VAR_6->filename);
  VAR_6=DestroyImageInfo(VAR_6);
  if (VAR_3 != (Image *) NULL)
    {
      if (EOFBlob(VAR_3) != VAR_18)
        {
          char
            *VAR_25;

          VAR_25=GetExceptionMessage(VAR_26);
          (void) ThrowMagickException(VAR_1,GetMagickModule(),
            VAR_21,""UnexpectedEndOfFile"",""`%s': %s"",VAR_3->filename,
            VAR_25);
          VAR_25=DestroyString(VAR_25);
        }
      (void) CloseBlob(VAR_3);
    }
  return(GetFirstImageInList(VAR_3));
}",ImageMagick/1a5f95fc018a5667de5a9448aee9d7251b2eb952/pwp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,11 +72,13 @@
     if (c == EOF)
       {
         (void) RelinquishUniqueFileResource(read_info->filename);
+        read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
       }
     if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
       {
         (void) RelinquishUniqueFileResource(read_info->filename);
+        read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       }
     /*
@@ -88,9 +90,10 @@
     if ((unique_file == -1) || (file == (FILE *) NULL))
       {
         (void) RelinquishUniqueFileResource(read_info->filename);
+        read_info=DestroyImageInfo(read_info);
+        image=DestroyImageList(image);
         ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
           image->filename);
-        image=DestroyImageList(image);
         return((Image *) NULL);
       }
     length=fwrite(""SFW94A"",1,6,file);
@@ -107,6 +110,7 @@
     if (c == EOF)
       {
         (void) RelinquishUniqueFileResource(read_info->filename);
+        read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
       }
     next_image=ReadImage(read_info,exception);","{'deleted_lines': ['        image=DestroyImageList(image);'], 'added_lines': ['        read_info=DestroyImageInfo(read_info);', '        read_info=DestroyImageInfo(read_info);', '        read_info=DestroyImageInfo(read_info);', '        image=DestroyImageList(image);', '        read_info=DestroyImageInfo(read_info);']}",True,"In ImageMagick 7.0.7-17 Q16, there is a Memory Leak in ReadPWPImage in coders/pwp.c.",6.5,MEDIUM,1,valid,2017-12-27T02:35:58Z,2
CVE-2018-8087,['CWE-772'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"mac80211_hwsim: fix possible memory leak in hwsim_new_radio_nl()

'hwname' is malloced in hwsim_new_radio_nl() and should be freed
before leaving from the error handling cases, otherwise it will cause
memory leak.

Fixes: ff4dd73dd2b4 (""mac80211_hwsim: check HWSIM_ATTR_RADIO_NAME length"")
Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
Signed-off-by: Johannes Berg <johannes.berg@intel.com>",0ddcff49b672239dda94d70d0fcf50317a9f4b51,https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51,drivers/net/wireless/mac80211_hwsim.c,hwsim_new_radio_nl,"static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)
{
struct hwsim_new_radio_params param = { 0 };
const char *hwname = NULL;
int ret;
param.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];
param.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];
param.channels = channels;
param.destroy_on_close =
info->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];
if (info->attrs[HWSIM_ATTR_CHANNELS])
param.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);
if (info->attrs[HWSIM_ATTR_NO_VIF])
param.no_vif = true;
if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {
hwname = kasprintf(GFP_KERNEL, ""%.*s"",
nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),
(char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));
if (!hwname)
return -ENOMEM;
param.hwname = hwname;
}
if (info->attrs[HWSIM_ATTR_USE_CHANCTX])
param.use_chanctx = true;
else
param.use_chanctx = (param.channels > 1);
if (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])
param.reg_alpha2 =
nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);
if (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {
u32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);
if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))
return -EINVAL;
param.regd = hwsim_world_regdom_custom[idx];
}
ret = mac80211_hwsim_new_radio(info, &param);
kfree(hwname);
return ret;
}","static int hwsim_new_radio_nl(struct sk_buff *VAR_0, struct genl_info *VAR_1)
{
struct hwsim_new_radio_params VAR_2 = { 0 };
const char *VAR_3 = NULL;
int VAR_4;
VAR_2.reg_strict = VAR_1->attrs[VAR_5];
VAR_2.p2p_device = VAR_1->attrs[VAR_6];
VAR_2.channels = VAR_7;
VAR_2.destroy_on_close =
VAR_1->attrs[VAR_8];
if (VAR_1->attrs[VAR_9])
VAR_2.channels = nla_get_u32(VAR_1->attrs[VAR_9]);
if (VAR_1->attrs[VAR_10])
VAR_2.no_vif = true;
if (VAR_1->attrs[VAR_11]) {
VAR_3 = kasprintf(VAR_12, ""%.*s"",
nla_len(VAR_1->attrs[VAR_11]),
(char *)nla_data(VAR_1->attrs[VAR_11]));
if (!VAR_3)
return -VAR_13;
VAR_2.hwname = VAR_3;
}
if (VAR_1->attrs[VAR_14])
VAR_2.use_chanctx = true;
else
VAR_2.use_chanctx = (VAR_2.channels > 1);
if (VAR_1->attrs[VAR_15])
VAR_2.reg_alpha2 =
nla_data(VAR_1->attrs[VAR_15]);
if (VAR_1->attrs[VAR_16]) {
u32 VAR_17 = nla_get_u32(VAR_1->attrs[VAR_16]);
if (VAR_17 >= ARRAY_SIZE(VAR_18))
return -VAR_19;
VAR_2.regd = VAR_18[VAR_17];
}
VAR_4 = mac80211_hwsim_new_radio(VAR_1, &VAR_2);
kfree(VAR_3);
return VAR_4;
}",torvalds/linux/0ddcff49b672239dda94d70d0fcf50317a9f4b51/mac80211_hwsim.c/vul/before/0.json,"static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)
{
	struct hwsim_new_radio_params param = { 0 };
	const char *hwname = NULL;
	int ret;

	param.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];
	param.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];
	param.channels = channels;
	param.destroy_on_close =
		info->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];

	if (info->attrs[HWSIM_ATTR_CHANNELS])
		param.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);

	if (info->attrs[HWSIM_ATTR_NO_VIF])
		param.no_vif = true;

	if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {
		hwname = kasprintf(GFP_KERNEL, ""%.*s"",
				   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),
				   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));
		if (!hwname)
			return -ENOMEM;
		param.hwname = hwname;
	}

	if (info->attrs[HWSIM_ATTR_USE_CHANCTX])
		param.use_chanctx = true;
	else
		param.use_chanctx = (param.channels > 1);

	if (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])
		param.reg_alpha2 =
			nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);

	if (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {
		u32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);

		if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {
			kfree(hwname);
			return -EINVAL;
		}
		param.regd = hwsim_world_regdom_custom[idx];
	}

	ret = mac80211_hwsim_new_radio(info, &param);
	kfree(hwname);
	return ret;
}","static int hwsim_new_radio_nl(struct sk_buff *VAR_0, struct genl_info *VAR_1)
{
	struct hwsim_new_radio_params VAR_2 = { 0 };
	const char *VAR_3 = NULL;
	int VAR_4;

	VAR_2.reg_strict = VAR_1->attrs[VAR_5];
	VAR_2.p2p_device = VAR_1->attrs[VAR_6];
	VAR_2.channels = VAR_7;
	VAR_2.destroy_on_close =
		VAR_1->attrs[VAR_8];

	if (VAR_1->attrs[VAR_9])
		VAR_2.channels = nla_get_u32(VAR_1->attrs[VAR_9]);

	if (VAR_1->attrs[VAR_10])
		VAR_2.no_vif = true;

	if (VAR_1->attrs[VAR_11]) {
		VAR_3 = kasprintf(VAR_12, ""%.*s"",
				   nla_len(VAR_1->attrs[VAR_11]),
				   (char *)nla_data(VAR_1->attrs[VAR_11]));
		if (!VAR_3)
			return -VAR_13;
		VAR_2.hwname = VAR_3;
	}

	if (VAR_1->attrs[VAR_14])
		VAR_2.use_chanctx = true;
	else
		VAR_2.use_chanctx = (VAR_2.channels > 1);

	if (VAR_1->attrs[VAR_15])
		VAR_2.reg_alpha2 =
			nla_data(VAR_1->attrs[VAR_15]);

	if (VAR_1->attrs[VAR_16]) {
		u32 VAR_17 = nla_get_u32(VAR_1->attrs[VAR_16]);

		if (VAR_17 >= ARRAY_SIZE(VAR_18)) {
			kfree(VAR_3);
			return -VAR_19;
		}
		VAR_2.regd = VAR_18[VAR_17];
	}

	VAR_4 = mac80211_hwsim_new_radio(VAR_1, &VAR_2);
	kfree(VAR_3);
	return VAR_4;
}",torvalds/linux/0ddcff49b672239dda94d70d0fcf50317a9f4b51/mac80211_hwsim.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,8 +37,10 @@
 	if (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {
 		u32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);
 
-		if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))
+		if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {
+			kfree(hwname);
 			return -EINVAL;
+		}
 		param.regd = hwsim_world_regdom_custom[idx];
 	}
 ","{'deleted_lines': ['\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))'], 'added_lines': ['\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {', '\t\t\tkfree(hwname);', '\t\t}']}",True,Memory leak in the hwsim_new_radio_nl function in drivers/net/wireless/mac80211_hwsim.c in the Linux kernel through 4.15.9 allows local users to cause a denial of service (memory consumption) by triggering an out-of-array error case.,5.5,MEDIUM,1,valid,2018-01-18T02:23:34Z,2
CVE-2018-6315,"['CWE-190', 'CWE-125']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libming,"Fix NULL pointer deref in outputSWF_TEXT_RECORD

In outputSWF_TEXT_RECORD, the array offset is stored in a
signed int, while (&(trec->GlyphEntries[i]))->GlyphIndex[0]
returns an unsigned 32 bit number.

This may lead to an integer overflow when reading the offset
from the GlyphIndex array, and further to a buffer overflow
when doing buffer[i]=fi->fontcodeptr[off] with negative off.

In this commit, we change the type of off to unsigned long so
we are guaranteed to be able to store 32 unsigned integers.

This commit fixes CVE-2018-6315 (fixes #101).",3120f1cdae0c5232a4fb15e5ce42b8c455b43379,https://github.com/libming/libming/commit/3120f1cdae0c5232a4fb15e5ce42b8c455b43379,util/outputscript.c,outputSWF_TEXT_RECORD,"static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)
{
int i=0;
struct FONTINFO *fi=fip;
if ( trec->TextRecordType == 0 )
return;
if (trec->StyleFlagHasFont)
{
printf(""%s("" VAR ""f%d);\n"", methodcall (tname, ""setFont""), trec->FontID);
printf(""%s(%d);\n"",methodcall(tname,""setHeight""),trec->TextHeight);
}
if( trec->StyleFlagHasColor )
{
if (level==2)
printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);
else
printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);
}
if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) 
{
printf (""%s(%d, %d);\n"", methodcall (tname, ""moveTo""),trec->XOffset,trec->YOffset);
}
if (trec->FontID) 
{
id=trec->FontID;
}
if (!trec->StyleFlagHasFont)
{
fi = fip_current;
if (!fi)
SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
else
id = fi->fontcodeID;
}
while (fi)
{
if (fi->fontcodeID==id)
{
fip_current=fi;
for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)
{
int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
if (off<fi->fontcodearrsize)
buffer[i]=fi->fontcodeptr[off];
else
buffer[i]='?';
} 
buffer[i]='\0'; 
return;
}
else
fi=fi->next;
}
buffer[0]='X';
buffer[1]='\0'; 
}","static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *VAR_0, int VAR_1,char *VAR_2,char *VAR_3,int VAR_4,int VAR_5)
{
int VAR_6=0;
struct FONTINFO *VAR_7=VAR_8;
if ( VAR_0->TextRecordType == 0 )
return;
if (VAR_0->StyleFlagHasFont)
{
printf(""%s("" VAR_9 ""f%d);\n"", methodcall (VAR_2, ""setFont""), VAR_0->FontID);
printf(""%s(%d);\n"",methodcall(VAR_2,""setHeight""),VAR_0->TextHeight);
}
if( VAR_0->StyleFlagHasColor )
{
if (VAR_1==2)
printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue, VAR_0->TextColor.alpha);
else
printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue);
}
if( VAR_0->StyleFlagHasYOffset || VAR_0->StyleFlagHasXOffset ) 
{
printf (""%s(%d, %d);\n"", methodcall (VAR_2, ""moveTo""),VAR_0->XOffset,VAR_0->YOffset);
}
if (VAR_0->FontID) 
{
VAR_5=VAR_0->FontID;
}
if (!VAR_0->StyleFlagHasFont)
{
VAR_7 = VAR_10;
if (!VAR_7)
SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
else
VAR_5 = VAR_7->fontcodeID;
}
while (VAR_7)
{
if (VAR_7->fontcodeID==VAR_5)
{
VAR_10=VAR_7;
for(VAR_6=0;VAR_6<VAR_0->GlyphCount && VAR_6<VAR_4-1 ;VAR_6++)
{
int VAR_11=(&(VAR_0->GlyphEntries[VAR_6]))->GlyphIndex[0];
if (VAR_11<VAR_7->fontcodearrsize)
VAR_3[VAR_6]=VAR_7->fontcodeptr[VAR_11];
else
VAR_3[VAR_6]='?';
} 
VAR_3[VAR_6]='\0'; 
return;
}
else
VAR_7=VAR_7->next;
}
VAR_3[0]='X';
VAR_3[1]='\0'; 
}",libming/3120f1cdae0c5232a4fb15e5ce42b8c455b43379/outputscript.c/vul/before/0.json,"static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)
{
  int i=0;
  struct FONTINFO *fi=fip;
  if ( trec->TextRecordType == 0 )
    return;
  if (trec->StyleFlagHasFont)
  {
   printf(""%s("" VAR ""f%d);\n"", methodcall (tname, ""setFont""), trec->FontID);
   printf(""%s(%d);\n"",methodcall(tname,""setHeight""),trec->TextHeight);
  }
  if( trec->StyleFlagHasColor )
  {
   if (level==2)
    printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);
   else
    printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (tname, ""setColor""),
      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);
  }
  if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) 
  {
    printf (""%s(%d, %d);\n"", methodcall (tname, ""moveTo""),trec->XOffset,trec->YOffset);
  }
  if (trec->FontID) 
  {
    id=trec->FontID;
  }
  if (!trec->StyleFlagHasFont)				/* always check flag before use data */
  {
   fi = fip_current;					/* so cont w current font */

   if (!fi)
      SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
   else
      id = fi->fontcodeID;					/* trigger next if */
  }
  while (fi)
  {
   if (fi->fontcodeID==id)
   {
    fip_current=fi;					/* set current font */
    for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)	/* byte n-1 will be terminator '\0' */
    {
     unsigned long off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
     if (off<fi->fontcodearrsize)
      buffer[i]=fi->fontcodeptr[off];
     else
      buffer[i]='?';		/* fallback to dummy A */
     /* printf ( COMMSTART ""GlyphIndex[0] = %d  char = %d "" COMMEND""\n"",off,fi->fontcodeptr[off] ); */
    } 
    buffer[i]='\0'; 
    return;
   }
   else
    fi=fi->next;
  }
  buffer[0]='X';		/* fallback to dummy B */
  buffer[1]='\0'; 
}","static void
outputSWF_TEXT_RECORD (SWF_TEXTRECORD *VAR_0, int VAR_1,char *VAR_2,char *VAR_3,int VAR_4,int VAR_5)
{
  int VAR_6=0;
  struct FONTINFO *VAR_7=VAR_8;
  if ( VAR_0->TextRecordType == 0 )
    return;
  if (VAR_0->StyleFlagHasFont)
  {
   printf(""%s("" VAR_9 ""f%d);\n"", methodcall (VAR_2, ""setFont""), VAR_0->FontID);
   printf(""%s(%d);\n"",methodcall(VAR_2,""setHeight""),VAR_0->TextHeight);
  }
  if( VAR_0->StyleFlagHasColor )
  {
   if (VAR_1==2)
    printf (""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
      VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue, VAR_0->TextColor.alpha);
   else
    printf (""%s(0x%02x, 0x%02x, 0x%02x);\n"",methodcall (VAR_2, ""setColor""),
      VAR_0->TextColor.red,VAR_0->TextColor.green,VAR_0->TextColor.blue);
  }
  if( VAR_0->StyleFlagHasYOffset || VAR_0->StyleFlagHasXOffset ) 
  {
    printf (""%s(%d, %d);\n"", methodcall (VAR_2, ""moveTo""),VAR_0->XOffset,VAR_0->YOffset);
  }
  if (VAR_0->FontID) 
  {
    VAR_5=VAR_0->FontID;
  }
  if (!VAR_0->StyleFlagHasFont)				/* COMMENT_0 */
  {
   VAR_7 = VAR_10;					/* COMMENT_1 */

   if (!VAR_7)
      SWF_warn(""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\n"");
   else
      VAR_5 = VAR_7->fontcodeID;					/* COMMENT_2 */
  }
  while (VAR_7)
  {
   if (VAR_7->fontcodeID==VAR_5)
   {
    VAR_10=VAR_7;					/* COMMENT_3 */
    for(VAR_6=0;VAR_6<VAR_0->GlyphCount && VAR_6<VAR_4-1 ;VAR_6++)	/* COMMENT_4 */
    {
     unsigned long VAR_11=(&(VAR_0->GlyphEntries[VAR_6]))->GlyphIndex[0];
     if (VAR_11<VAR_7->fontcodearrsize)
      VAR_3[VAR_6]=VAR_7->fontcodeptr[VAR_11];
     else
      VAR_3[VAR_6]='?';		/* COMMENT_5 */
     /* COMMENT_6 */
    } 
    VAR_3[VAR_6]='\0'; 
    return;
   }
   else
    VAR_7=VAR_7->next;
  }
  VAR_3[0]='X';		/* COMMENT_7 */
  VAR_3[1]='\0'; 
}",libming/3120f1cdae0c5232a4fb15e5ce42b8c455b43379/outputscript.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,7 +43,7 @@
     fip_current=fi;					/* set current font */
     for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)	/* byte n-1 will be terminator '\0' */
     {
-     int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
+     unsigned long off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];
      if (off<fi->fontcodearrsize)
       buffer[i]=fi->fontcodeptr[off];
      else","{'deleted_lines': ['     int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];'], 'added_lines': ['     unsigned long off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];']}",True,"The outputSWF_TEXT_RECORD function (util/outputscript.c) in libming through 0.4.8 is vulnerable to an integer overflow and resultant out-of-bounds read, which may allow attackers to cause a denial of service or unspecified other impact via a crafted SWF file.",8.8,HIGH,2,valid,2018-01-25T09:33:06Z,2
CVE-2018-1000039,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/mupdf,"Bug 698891: Keep colorspace for luminosity transparency group.

This was forgotten when a gray colorspace was used as a fallback
in case a colorspace was never set. Thanks to oss-fuzz for reporting.",4dcc6affe04368461310a21238f7e1871a752a05,https://github.com/ArtifexSoftware/mupdf/commit/4dcc6affe04368461310a21238f7e1871a752a05,source/pdf/pdf-op-run.c,begin_softmask,"static pdf_gstate *
begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)
{
pdf_gstate *gstate = pr->gstate + pr->gtop;
pdf_xobject *softmask = gstate->softmask;
fz_rect mask_bbox;
fz_matrix tos_save[2], save_ctm;
fz_matrix mask_matrix;
fz_colorspace *mask_colorspace;
save->softmask = softmask;
if (softmask == NULL)
return gstate;
save->page_resources = gstate->softmask_resources;
save->ctm = gstate->softmask_ctm;
save_ctm = gstate->ctm;
pdf_xobject_bbox(ctx, softmask, &mask_bbox);
pdf_xobject_matrix(ctx, softmask, &mask_matrix);
pdf_tos_save(ctx, &pr->tos, tos_save);
if (gstate->luminosity)
mask_bbox = fz_infinite_rect;
else
{
fz_transform_rect(&mask_bbox, &mask_matrix);
fz_transform_rect(&mask_bbox, &gstate->softmask_ctm);
}
gstate->softmask = NULL;
gstate->softmask_resources = NULL;
gstate->ctm = gstate->softmask_ctm;
mask_colorspace = pdf_xobject_colorspace(ctx, softmask);
if (gstate->luminosity && !mask_colorspace)
mask_colorspace = fz_device_gray(ctx);
fz_try(ctx)
{
fz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);
pdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);
}
fz_always(ctx)
fz_drop_colorspace(ctx, mask_colorspace);
fz_catch(ctx)
{
fz_rethrow_if(ctx, FZ_ERROR_TRYLATER);
}
fz_end_mask(ctx, pr->dev);
pdf_tos_restore(ctx, &pr->tos, tos_save);
gstate = pr->gstate + pr->gtop;
gstate->ctm = save_ctm;
return gstate;
}","static pdf_gstate *
begin_softmask(fz_context *VAR_0, pdf_run_processor *VAR_1, softmask_save *VAR_2)
{
pdf_gstate *VAR_3 = VAR_1->gstate + VAR_1->gtop;
pdf_xobject *VAR_4 = VAR_3->softmask;
fz_rect VAR_5;
fz_matrix VAR_6[2], VAR_7;
fz_matrix VAR_8;
fz_colorspace *VAR_9;
VAR_2->softmask = VAR_4;
if (VAR_4 == NULL)
return VAR_3;
VAR_2->page_resources = VAR_3->softmask_resources;
VAR_2->ctm = VAR_3->softmask_ctm;
VAR_7 = VAR_3->ctm;
pdf_xobject_bbox(VAR_0, VAR_4, &VAR_5);
pdf_xobject_matrix(VAR_0, VAR_4, &VAR_8);
pdf_tos_save(VAR_0, &VAR_1->tos, VAR_6);
if (VAR_3->luminosity)
VAR_5 = VAR_10;
else
{
fz_transform_rect(&VAR_5, &VAR_8);
fz_transform_rect(&VAR_5, &VAR_3->softmask_ctm);
}
VAR_3->softmask = NULL;
VAR_3->softmask_resources = NULL;
VAR_3->ctm = VAR_3->softmask_ctm;
VAR_9 = pdf_xobject_colorspace(VAR_0, VAR_4);
if (VAR_3->luminosity && !VAR_9)
VAR_9 = fz_device_gray(VAR_0);
fz_try(VAR_0)
{
fz_begin_mask(VAR_0, VAR_1->dev, &VAR_5, VAR_3->luminosity, VAR_9, VAR_3->softmask_bc, &VAR_3->fill.color_params);
pdf_run_xobject(VAR_0, VAR_1, VAR_4, VAR_2->page_resources, &VAR_11, 1);
}
VAR_12(ctx)
fz_drop_colorspace(ctx, mask_colorspace);
fz_catch(ctx)
{
fz_rethrow_if(ctx, VAR_13);
}
fz_end_mask(ctx, VAR_1->dev);
pdf_tos_restore(ctx, &VAR_1->tos, VAR_6);
VAR_3 = VAR_1->gstate + VAR_1->gtop;
VAR_3->ctm = VAR_7;
return VAR_3;
}",ArtifexSoftware/mupdf/4dcc6affe04368461310a21238f7e1871a752a05/pdf-op-run.c/vul/before/0.json,"static pdf_gstate *
begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)
{
	pdf_gstate *gstate = pr->gstate + pr->gtop;
	pdf_xobject *softmask = gstate->softmask;
	fz_rect mask_bbox;
	fz_matrix tos_save[2], save_ctm;
	fz_matrix mask_matrix;
	fz_colorspace *mask_colorspace;

	save->softmask = softmask;
	if (softmask == NULL)
		return gstate;
	save->page_resources = gstate->softmask_resources;
	save->ctm = gstate->softmask_ctm;
	save_ctm = gstate->ctm;

	pdf_xobject_bbox(ctx, softmask, &mask_bbox);
	pdf_xobject_matrix(ctx, softmask, &mask_matrix);

	pdf_tos_save(ctx, &pr->tos, tos_save);

	if (gstate->luminosity)
		mask_bbox = fz_infinite_rect;
	else
	{
		fz_transform_rect(&mask_bbox, &mask_matrix);
		fz_transform_rect(&mask_bbox, &gstate->softmask_ctm);
	}
	gstate->softmask = NULL;
	gstate->softmask_resources = NULL;
	gstate->ctm = gstate->softmask_ctm;

	mask_colorspace = pdf_xobject_colorspace(ctx, softmask);

	if (gstate->luminosity && !mask_colorspace)
		mask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));

	fz_try(ctx)
	{
		fz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);
		pdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);
	}
	fz_always(ctx)
		fz_drop_colorspace(ctx, mask_colorspace);
	fz_catch(ctx)
	{
		fz_rethrow_if(ctx, FZ_ERROR_TRYLATER);
		/* FIXME: Ignore error - nasty, but if we throw from
		 * here the clip stack would be messed up. */
		/* TODO: pass cookie here to increase the cookie error count */
	}

	fz_end_mask(ctx, pr->dev);

	pdf_tos_restore(ctx, &pr->tos, tos_save);

	gstate = pr->gstate + pr->gtop;
	gstate->ctm = save_ctm;

	return gstate;
}","static pdf_gstate *
begin_softmask(fz_context *VAR_0, pdf_run_processor *VAR_1, softmask_save *VAR_2)
{
	pdf_gstate *VAR_3 = VAR_1->gstate + VAR_1->gtop;
	pdf_xobject *VAR_4 = VAR_3->softmask;
	fz_rect VAR_5;
	fz_matrix VAR_6[2], VAR_7;
	fz_matrix VAR_8;
	fz_colorspace *VAR_9;

	VAR_2->softmask = VAR_4;
	if (VAR_4 == NULL)
		return VAR_3;
	VAR_2->page_resources = VAR_3->softmask_resources;
	VAR_2->ctm = VAR_3->softmask_ctm;
	VAR_7 = VAR_3->ctm;

	pdf_xobject_bbox(VAR_0, VAR_4, &VAR_5);
	pdf_xobject_matrix(VAR_0, VAR_4, &VAR_8);

	pdf_tos_save(VAR_0, &VAR_1->tos, VAR_6);

	if (VAR_3->luminosity)
		VAR_5 = VAR_10;
	else
	{
		fz_transform_rect(&VAR_5, &VAR_8);
		fz_transform_rect(&VAR_5, &VAR_3->softmask_ctm);
	}
	VAR_3->softmask = NULL;
	VAR_3->softmask_resources = NULL;
	VAR_3->ctm = VAR_3->softmask_ctm;

	VAR_9 = pdf_xobject_colorspace(VAR_0, VAR_4);

	if (VAR_3->luminosity && !VAR_9)
		VAR_9 = fz_keep_colorspace(VAR_0, fz_device_gray(VAR_0));

	fz_try(VAR_0)
	{
		fz_begin_mask(VAR_0, VAR_1->dev, &VAR_5, VAR_3->luminosity, VAR_9, VAR_3->softmask_bc, &VAR_3->fill.color_params);
		pdf_run_xobject(VAR_0, VAR_1, VAR_4, VAR_2->page_resources, &VAR_11, 1);
	}
	VAR_12(ctx)
		fz_drop_colorspace(ctx, mask_colorspace);
	fz_catch(ctx)
	{
		fz_rethrow_if(ctx, VAR_13);
		/* COMMENT_0 */
                                               
		/* COMMENT_2 */
	}

	fz_end_mask(ctx, VAR_1->dev);

	pdf_tos_restore(ctx, &VAR_1->tos, VAR_6);

	VAR_3 = VAR_1->gstate + VAR_1->gtop;
	VAR_3->ctm = VAR_7;

	return VAR_3;
}",ArtifexSoftware/mupdf/4dcc6affe04368461310a21238f7e1871a752a05/pdf-op-run.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
 	mask_colorspace = pdf_xobject_colorspace(ctx, softmask);
 
 	if (gstate->luminosity && !mask_colorspace)
-		mask_colorspace = fz_device_gray(ctx);
+		mask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));
 
 	fz_try(ctx)
 	{","{'deleted_lines': ['\t\tmask_colorspace = fz_device_gray(ctx);'], 'added_lines': ['\t\tmask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));']}",True,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",7.8,HIGH,2,valid,2018-02-01T23:37:51Z,2
CVE-2018-6540,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,need to check on endbuf for stored files #15,72ec933663f738d8e166979aa7fd5590b2104a07,https://github.com/gdraheim/zziplib/commit/72ec933663f738d8e166979aa7fd5590b2104a07,zzip/mmapped.c,zzip_disk_fread,"zzip_size_t
zzip_disk_fread(void *ptr, zzip_size_t sized, zzip_size_t nmemb,
ZZIP_DISK_FILE * file)
{
zzip_size_t size = sized * nmemb;
if (! ptr || ! sized || ! file)
return 0;
if (size > file->avail)
size = file->avail;
if (file->stored)
{
memcpy(ptr, file->stored, size);
file->stored += size;
file->avail -= size;
return size;
}
file->zlib.avail_out = sized * nmemb;
file->zlib.next_out = ptr;
___ zzip_size_t total_old = file->zlib.total_out;
___ int err = inflate(&file->zlib, Z_NO_FLUSH);
if (err == Z_STREAM_END)
file->avail = 0;
else if (err == Z_OK)
file->avail -= file->zlib.total_out - total_old;
else
return 0;
return file->zlib.total_out - total_old;
____;
____;
}","zzip_size_t
zzip_disk_fread(void *VAR_0, zzip_size_t VAR_1, zzip_size_t VAR_2,
ZZIP_DISK_FILE * VAR_3)
{
zzip_size_t VAR_4 = VAR_1 * VAR_2;
if (! VAR_0 || ! VAR_1 || ! VAR_3)
return 0;
if (VAR_4 > VAR_3->avail)
VAR_4 = VAR_3->avail;
if (VAR_3->stored)
{
memcpy(VAR_0, VAR_3->stored, VAR_4);
VAR_3->stored += VAR_4;
VAR_3->avail -= VAR_4;
return VAR_4;
}
VAR_3->zlib.avail_out = VAR_1 * VAR_2;
VAR_3->zlib.next_out = VAR_0;
___ zzip_size_t VAR_5 = VAR_3->zlib.total_out;
___ VAR_6 VAR_7 = inflate(&VAR_3->zlib, VAR_8);
if (VAR_7 == VAR_9)
VAR_3->avail = 0;
else if (VAR_7 == VAR_10)
VAR_3->avail -= VAR_3->zlib.total_out - VAR_5;
else
return 0;
return VAR_3->zlib.total_out - VAR_5;
VAR_11;
VAR_11;
}",gdraheim/zziplib/72ec933663f738d8e166979aa7fd5590b2104a07/mmapped.c/vul/before/1.json,"zzip_size_t
zzip_disk_fread(void *ptr, zzip_size_t sized, zzip_size_t nmemb,
                ZZIP_DISK_FILE * file)
{
    zzip_size_t size = sized * nmemb;
    if (! ptr || ! sized || ! file)
        return 0;
    if (size > file->avail)
        size = file->avail;
    if (file->stored)
    {
        if (file->stored + size >= file->endbuf)
        {
            DBG1(""try to read beyond end of file"");
            return 0; /* ESPIPE */
        }
        DBG3(""copy stored %p %i"", file->stored, (int)size);
        memcpy(ptr, file->stored, size);
        file->stored += size;
        file->avail -= size;
        return size;
    }

    file->zlib.avail_out = sized * nmemb;
    file->zlib.next_out = ptr;
    ___ zzip_size_t total_old = file->zlib.total_out;
    ___ int err = inflate(&file->zlib, Z_NO_FLUSH);
    if (err == Z_STREAM_END)
        file->avail = 0;
    else if (err == Z_OK)
        file->avail -= file->zlib.total_out - total_old;
    else
        return 0;
    return file->zlib.total_out - total_old;
    ____;
    ____;
}","zzip_size_t
zzip_disk_fread(void *VAR_0, zzip_size_t VAR_1, zzip_size_t VAR_2,
                ZZIP_DISK_FILE * VAR_3)
{
    zzip_size_t VAR_4 = VAR_1 * VAR_2;
    if (! VAR_0 || ! VAR_1 || ! VAR_3)
        return 0;
    if (VAR_4 > VAR_3->avail)
        VAR_4 = VAR_3->avail;
    if (VAR_3->stored)
    {
        if (VAR_3->stored + VAR_4 >= VAR_3->endbuf)
        {
            DBG1(""try to read beyond end of file"");
            return 0; /* COMMENT_0 */
        }
        DBG3(""copy stored %p %i"", VAR_3->stored, (int)VAR_4);
        memcpy(VAR_0, VAR_3->stored, VAR_4);
        VAR_3->stored += VAR_4;
        VAR_3->avail -= VAR_4;
        return VAR_4;
    }

    VAR_3->zlib.avail_out = VAR_1 * VAR_2;
    VAR_3->zlib.next_out = VAR_0;
    ___ zzip_size_t VAR_5 = VAR_3->zlib.total_out;
    ___ int VAR_6 = inflate(&VAR_3->zlib, VAR_7);
    if (VAR_6 == VAR_8)
        VAR_3->avail = 0;
    else if (VAR_6 == VAR_9)
        VAR_3->avail -= VAR_3->zlib.total_out - VAR_5;
    else
        return 0;
    return VAR_3->zlib.total_out - VAR_5;
    VAR_10;
    VAR_10;
}",gdraheim/zziplib/72ec933663f738d8e166979aa7fd5590b2104a07/mmapped.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,6 +9,12 @@
         size = file->avail;
     if (file->stored)
     {
+        if (file->stored + size >= file->endbuf)
+        {
+            DBG1(""try to read beyond end of file"");
+            return 0; /* ESPIPE */
+        }
+        DBG3(""copy stored %p %i"", file->stored, (int)size);
         memcpy(ptr, file->stored, size);
         file->stored += size;
         file->avail -= size;","{'deleted_lines': [], 'added_lines': ['        if (file->stored + size >= file->endbuf)', '        {', '            DBG1(""try to read beyond end of file"");', '            return 0; /* ESPIPE */', '        }', '        DBG3(""copy stored %p %i"", file->stored, (int)size);']}",True,"In ZZIPlib 0.13.67, there is a bus error caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted zip file.",6.5,MEDIUM,1,valid,2018-02-05T12:57:49Z,2
CVE-2018-6540,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,need to check on endbuf for stored files #15,72ec933663f738d8e166979aa7fd5590b2104a07,https://github.com/gdraheim/zziplib/commit/72ec933663f738d8e166979aa7fd5590b2104a07,zzip/mmapped.c,zzip_disk_entry_fopen,"zzip__new__ ZZIP_DISK_FILE *
zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
{
struct zzip_file_header *header =
zzip_disk_entry_to_file_header(disk, entry);
if (! header)
return 0; 
___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));
if (! file)
return 0; 
file->buffer = disk->buffer;
file->endbuf = disk->endbuf;
file->avail = zzip_file_header_usize(header);
if (! file->avail || zzip_file_header_data_stored(header))
{ file->stored = zzip_file_header_to_data (header); return file; }
file->stored = 0;
file->zlib.opaque = 0;
file->zlib.zalloc = Z_NULL;
file->zlib.zfree = Z_NULL;
file->zlib.avail_in = zzip_file_header_csize(header);
file->zlib.next_in = zzip_file_header_to_data(header);
if (! zzip_file_header_data_deflated(header) ||
inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
{
free (file);
errno = EBADMSG;
return 0; 
}
return file;
____;
}","zzip__new__ VAR_0 *
zzip_disk_entry_fopen(ZZIP_DISK * VAR_1, ZZIP_DISK_ENTRY * VAR_2)
{
struct zzip_file_header *VAR_3 =
zzip_disk_entry_to_file_header(VAR_1, VAR_2);
if (! VAR_3)
return 0; 
___ VAR_0 *VAR_4 = malloc(sizeof(VAR_0));
if (! VAR_4)
return 0; 
VAR_4->buffer = VAR_1->buffer;
VAR_4->endbuf = VAR_1->endbuf;
VAR_4->avail = zzip_file_header_usize(VAR_3);
if (! VAR_4->avail || zzip_file_header_data_stored(VAR_3))
{ VAR_4->stored = zzip_file_header_to_data (VAR_3); return VAR_4; }
VAR_4->stored = 0;
VAR_4->zlib.opaque = 0;
VAR_4->zlib.zalloc = VAR_5;
VAR_4->zlib.zfree = VAR_5;
VAR_4->zlib.avail_in = zzip_file_header_csize(VAR_3);
VAR_4->zlib.next_in = zzip_file_header_to_data(VAR_3);
if (! zzip_file_header_data_deflated(VAR_3) ||
inflateInit2(&VAR_4->zlib, -VAR_6) != VAR_7)
{
free (VAR_4);
VAR_8 = VAR_9;
return 0; 
}
return VAR_4;
VAR_10;
}",,"zzip__new__ ZZIP_DISK_FILE *
zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
{
    /* keep this in sync with zzip_mem_entry_fopen */
    struct zzip_file_header *header =
        zzip_disk_entry_to_file_header(disk, entry);
    if (! header)
        return 0; /* EBADMSG */
    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));
    if (! file)
        return 0; /* ENOMEM */
    file->buffer = disk->buffer;
    file->endbuf = disk->endbuf;
    file->avail = zzip_file_header_usize(header);

    if (! file->avail || zzip_file_header_data_stored(header))
    { 
         file->stored = zzip_file_header_to_data (header);
         DBG2(""stored size %i"", (int) file->avail);
         if (file->stored + file->avail >= disk->endbuf)
             goto error;
         return file; 
    }

    file->stored = 0;
    file->zlib.opaque = 0;
    file->zlib.zalloc = Z_NULL;
    file->zlib.zfree = Z_NULL;
    file->zlib.avail_in = zzip_file_header_csize(header);
    file->zlib.next_in = zzip_file_header_to_data(header);

    DBG2(""compressed size %i"", (int) file->zlib.avail_in);
    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)
         goto error;

    if (! zzip_file_header_data_deflated(header))
        goto error;
    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
        goto error;

    return file;
error:
    free (file);
    errno = EBADMSG;
    return 0; 
    ____;
}","zzip__new__ VAR_0 *
zzip_disk_entry_fopen(ZZIP_DISK * VAR_1, ZZIP_DISK_ENTRY * VAR_2)
{
    /* COMMENT_0 */
    struct zzip_file_header *VAR_3 =
        zzip_disk_entry_to_file_header(VAR_1, VAR_2);
    if (! VAR_3)
        return 0; /* COMMENT_1 */
    ___ VAR_0 *VAR_4 = malloc(sizeof(VAR_0));
    if (! VAR_4)
        return 0; /* COMMENT_2 */
    VAR_4->buffer = VAR_1->buffer;
    VAR_4->endbuf = VAR_1->endbuf;
    VAR_4->avail = zzip_file_header_usize(VAR_3);

    if (! VAR_4->avail || zzip_file_header_data_stored(VAR_3))
    { 
         VAR_4->stored = zzip_file_header_to_data (VAR_3);
         DBG2(""stored size %i"", (int) VAR_4->avail);
         if (VAR_4->stored + VAR_4->avail >= VAR_1->endbuf)
             goto error;
         return VAR_4; 
    }

    VAR_4->stored = 0;
    VAR_4->zlib.opaque = 0;
    VAR_4->zlib.zalloc = VAR_5;
    VAR_4->zlib.zfree = VAR_5;
    VAR_4->zlib.avail_in = zzip_file_header_csize(VAR_3);
    VAR_4->zlib.next_in = zzip_file_header_to_data(VAR_3);

    DBG2(""compressed size %i"", (int) VAR_4->zlib.avail_in);
    if (VAR_4->zlib.next_in + VAR_4->zlib.avail_in >= VAR_1->endbuf)
         goto error;

    if (! zzip_file_header_data_deflated(VAR_3))
        goto error;
    if (inflateInit2(&VAR_4->zlib, -VAR_6) != VAR_7)
        goto error;

    return VAR_4;
error:
    free (VAR_4);
    VAR_8 = VAR_9;
    return 0; 
    VAR_10;
}",,"--- func_before
+++ func_after
@@ -14,7 +14,13 @@
     file->avail = zzip_file_header_usize(header);
 
     if (! file->avail || zzip_file_header_data_stored(header))
-        { file->stored = zzip_file_header_to_data (header); return file; }
+    { 
+         file->stored = zzip_file_header_to_data (header);
+         DBG2(""stored size %i"", (int) file->avail);
+         if (file->stored + file->avail >= disk->endbuf)
+             goto error;
+         return file; 
+    }
 
     file->stored = 0;
     file->zlib.opaque = 0;
@@ -23,14 +29,19 @@
     file->zlib.avail_in = zzip_file_header_csize(header);
     file->zlib.next_in = zzip_file_header_to_data(header);
 
-    if (! zzip_file_header_data_deflated(header) ||
-        inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
-    {
-        free (file);
-        errno = EBADMSG;
-        return 0; 
-    }
+    DBG2(""compressed size %i"", (int) file->zlib.avail_in);
+    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)
+         goto error;
+
+    if (! zzip_file_header_data_deflated(header))
+        goto error;
+    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
+        goto error;
 
     return file;
+error:
+    free (file);
+    errno = EBADMSG;
+    return 0; 
     ____;
 }","{'deleted_lines': ['        { file->stored = zzip_file_header_to_data (header); return file; }', '    if (! zzip_file_header_data_deflated(header) ||', '        inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)', '    {', '        free (file);', '        errno = EBADMSG;', '        return 0; ', '    }'], 'added_lines': ['    { ', '         file->stored = zzip_file_header_to_data (header);', '         DBG2(""stored size %i"", (int) file->avail);', '         if (file->stored + file->avail >= disk->endbuf)', '             goto error;', '         return file; ', '    }', '    DBG2(""compressed size %i"", (int) file->zlib.avail_in);', '    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)', '         goto error;', '', '    if (! zzip_file_header_data_deflated(header))', '        goto error;', '    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)', '        goto error;', 'error:', '    free (file);', '    errno = EBADMSG;', '    return 0; ']}",True,"In ZZIPlib 0.13.67, there is a bus error caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted zip file.",6.5,MEDIUM,1,valid,2018-02-05T12:57:49Z,2
CVE-2018-6540,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,need to check on endbuf for stored files #15,72ec933663f738d8e166979aa7fd5590b2104a07,https://github.com/gdraheim/zziplib/commit/72ec933663f738d8e166979aa7fd5590b2104a07,zzip/memdisk.c,zzip_mem_disk_buffer,"zzip__new__ ZZIP_MEM_DISK *
zzip_mem_disk_buffer(char *buffer, size_t buflen)
{
ZZIP_DISK *disk = zzip_disk_buffer(buffer, buflen);
if (! disk)
{ 
debug2(""can not open disk buf %p"", buffer);
return 0;
}
___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
zzip_mem_disk_load(dir, disk);
return dir;
____;
}","zzip__new__ VAR_0 *
zzip_mem_disk_buffer(char *VAR_1, size_t VAR_2)
{
ZZIP_DISK *VAR_3 = zzip_disk_buffer(VAR_1, VAR_2);
if (! VAR_3)
{ 
debug2(""can not open disk buf %p"", VAR_1);
return 0;
}
___ VAR_0 *VAR_4 = zzip_mem_disk_new();
zzip_mem_disk_load(VAR_4, VAR_3);
return VAR_4;
VAR_5;
}",,"zzip__new__ ZZIP_MEM_DISK *
zzip_mem_disk_buffer(char *buffer, size_t buflen)
{
    ZZIP_DISK *disk = zzip_disk_buffer(buffer, buflen);
    if (! disk)
    { 
       debug2(""can not open disk buf %p"", buffer);
       return 0;
    }
    ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
    if (zzip_mem_disk_load(dir, disk) == -1)
    {
       debug2(""unable to load disk buf %p"", buffer);
    }
    return dir;
    ____;
}","zzip__new__ VAR_0 *
zzip_mem_disk_buffer(char *VAR_1, size_t VAR_2)
{
    ZZIP_DISK *VAR_3 = zzip_disk_buffer(VAR_1, VAR_2);
    if (! VAR_3)
    { 
       debug2(""can not open disk buf %p"", VAR_1);
       return 0;
    }
    ___ VAR_0 *VAR_4 = zzip_mem_disk_new();
    if (zzip_mem_disk_load(VAR_4, VAR_3) == -1)
    {
       debug2(""unable to load disk buf %p"", VAR_1);
    }
    return VAR_4;
    VAR_5;
}",,"--- func_before
+++ func_after
@@ -8,7 +8,10 @@
        return 0;
     }
     ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
-    zzip_mem_disk_load(dir, disk);
+    if (zzip_mem_disk_load(dir, disk) == -1)
+    {
+       debug2(""unable to load disk buf %p"", buffer);
+    }
     return dir;
     ____;
 }","{'deleted_lines': ['    zzip_mem_disk_load(dir, disk);'], 'added_lines': ['    if (zzip_mem_disk_load(dir, disk) == -1)', '    {', '       debug2(""unable to load disk buf %p"", buffer);', '    }']}",True,"In ZZIPlib 0.13.67, there is a bus error caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted zip file.",6.5,MEDIUM,1,valid,2018-02-05T12:57:49Z,2
CVE-2018-6540,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,need to check on endbuf for stored files #15,72ec933663f738d8e166979aa7fd5590b2104a07,https://github.com/gdraheim/zziplib/commit/72ec933663f738d8e166979aa7fd5590b2104a07,zzip/memdisk.c,zzip_mem_disk_fdopen,"zzip__new__ ZZIP_MEM_DISK *
zzip_mem_disk_fdopen(int fd)
{
ZZIP_DISK *disk = zzip_disk_mmap(fd);
if (! disk)
{ 
debug2(""can not open disk fd %i"", fd);
return 0;
}
___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
zzip_mem_disk_load(dir, disk);
return dir;
____;
}","zzip__new__ VAR_0 *
zzip_mem_disk_fdopen(int VAR_1)
{
ZZIP_DISK *VAR_2 = zzip_disk_mmap(VAR_1);
if (! VAR_2)
{ 
debug2(""can not open disk fd %i"", VAR_1);
return 0;
}
___ VAR_0 *VAR_3 = zzip_mem_disk_new();
zzip_mem_disk_load(VAR_3, VAR_2);
return VAR_3;
VAR_4;
}",,"zzip__new__ ZZIP_MEM_DISK *
zzip_mem_disk_fdopen(int fd)
{
    ZZIP_DISK *disk = zzip_disk_mmap(fd);
    if (! disk)
    { 
       debug2(""can not open disk fd %i"", fd);
       return 0;
    }
    ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
    if (zzip_mem_disk_load(dir, disk) == -1)
    {
       debug2(""unable to load disk fd %s"", fd);
    }
    return dir;
    ____;
}","zzip__new__ VAR_0 *
zzip_mem_disk_fdopen(int VAR_1)
{
    ZZIP_DISK *VAR_2 = zzip_disk_mmap(VAR_1);
    if (! VAR_2)
    { 
       debug2(""can not open disk fd %i"", VAR_1);
       return 0;
    }
    ___ VAR_0 *VAR_3 = zzip_mem_disk_new();
    if (zzip_mem_disk_load(VAR_3, VAR_2) == -1)
    {
       debug2(""unable to load disk fd %s"", VAR_1);
    }
    return VAR_3;
    VAR_4;
}",,"--- func_before
+++ func_after
@@ -8,7 +8,10 @@
        return 0;
     }
     ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
-    zzip_mem_disk_load(dir, disk);
+    if (zzip_mem_disk_load(dir, disk) == -1)
+    {
+       debug2(""unable to load disk fd %s"", fd);
+    }
     return dir;
     ____;
 }","{'deleted_lines': ['    zzip_mem_disk_load(dir, disk);'], 'added_lines': ['    if (zzip_mem_disk_load(dir, disk) == -1)', '    {', '       debug2(""unable to load disk fd %s"", fd);', '    }']}",True,"In ZZIPlib 0.13.67, there is a bus error caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted zip file.",6.5,MEDIUM,1,valid,2018-02-05T12:57:49Z,2
CVE-2018-6542,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,fopen may fail for a bad name -> EXIT_ERRORS in that case #17,931f962ddfec0e00d6f486df2c56d9857b55944e,https://github.com/gdraheim/zziplib/commit/931f962ddfec0e00d6f486df2c56d9857b55944e,bins/unzzipcat-mem.c,unzzip_cat,"static int unzzip_cat (int argc, char ** argv, int extract)
{
int argn;
ZZIP_MEM_DISK* disk;
if (argc == 1)
{
printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return EXIT_OK; 
}
disk = zzip_mem_disk_open (argv[1]);
if (! disk) {
DBG3(""disk_open failed [%i] %s"", errno, strerror(errno));
perror(argv[1]);
return exitcode(errno);
}
if (argc == 2)
{  
ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);
DBG2(""findfirst %p\n"", entry);
for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))
{
char* name = zzip_mem_entry_to_name (entry);
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
unzzip_mem_disk_cat_file (disk, name, out);
if (extract) fclose(out);
}
return 0;
}
if (argc == 3 && !extract)
{  
ZZIP_MEM_ENTRY* entry = 0;
while ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))
{
unzzip_mem_entry_fprint (disk, entry, stdout);
}
return 0;
}
for (argn=1; argn < argc; argn++)
{   
ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);
for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))
{
char* name = zzip_mem_entry_to_name (entry);
if (! _zzip_fnmatch (argv[argn], name, 
FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
{
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
unzzip_mem_disk_cat_file (disk, name, out);
if (extract) fclose(out);
break; 
}
}
}
return 0;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
int VAR_3;
ZZIP_MEM_DISK* VAR_4;
if (VAR_0 == 1)
{
VAR_5 (VAR_6"" VAR_7 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return VAR_8; 
}
VAR_4 = zzip_mem_disk_open (VAR_1[1]);
if (! VAR_4) {
DBG3(""disk_open failed [%i] %s"", VAR_9, strerror(VAR_9));
perror(VAR_1[1]);
return exitcode(VAR_9);
}
if (VAR_0 == 2)
{  
ZZIP_MEM_ENTRY* VAR_10 = zzip_mem_disk_findfirst(VAR_4);
DBG2(""findfirst %p\n"", VAR_10);
for (; VAR_10 ; VAR_10 = zzip_mem_disk_findnext(VAR_4, VAR_10))
{
char* VAR_11 = zzip_mem_entry_to_name (VAR_10);
FILE* VAR_12 = VAR_13;
if (VAR_2) VAR_12 = create_fopen(VAR_11, ""w"", 1);
unzzip_mem_disk_cat_file (VAR_4, VAR_11, VAR_12);
if (VAR_2) fclose(VAR_12);
}
return 0;
}
if (VAR_0 == 3 && !VAR_2)
{  
ZZIP_MEM_ENTRY* VAR_10 = 0;
while ((VAR_10 = zzip_mem_disk_findmatch(VAR_4, VAR_1[2], VAR_10, 0, 0)))
{
unzzip_mem_entry_fprint (VAR_4, VAR_10, VAR_13);
}
return 0;
}
for (VAR_3=1; VAR_3 < VAR_0; VAR_3++)
{   
ZZIP_MEM_ENTRY* VAR_10 = zzip_mem_disk_findfirst(VAR_4);
for (; VAR_10 ; VAR_10 = zzip_mem_disk_findnext(VAR_4, VAR_10))
{
char* VAR_11 = zzip_mem_entry_to_name (VAR_10);
if (! _zzip_fnmatch (VAR_1[VAR_3], VAR_11, 
VAR_14|VAR_15|VAR_16))
{
FILE* VAR_12 = VAR_13;
if (VAR_2) VAR_12 = create_fopen(VAR_11, ""w"", 1);
unzzip_mem_disk_cat_file (VAR_4, VAR_11, VAR_12);
if (VAR_2) fclose(VAR_12);
break; 
}
}
}
return 0;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mem.c/vul/before/1.json,"static int unzzip_cat (int argc, char ** argv, int extract)
{
    int done;
    int argn;
    ZZIP_MEM_DISK* disk;

    if (argc == 1)
    {
	printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
	return EXIT_OK; /* better provide an archive argument */
    }

    disk = zzip_mem_disk_open (argv[1]);
    if (! disk) {
        DBG3(""disk_open failed [%i] %s"", errno, strerror(errno));
	perror(argv[1]);
	return exitcode(errno);
    }

    if (argc == 2)
    {  /* print directory list */
	ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);
	DBG2(""findfirst %p\n"", entry);
	for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))
	{
	    char* name = zzip_mem_entry_to_name (entry);
	    FILE* out = stdout;
	    if (extract) out = create_fopen(name, ""w"", 1);
	    if (! out) {
	        done = EXIT_ERRORS;
	        continue;
	    }
	    unzzip_mem_disk_cat_file (disk, name, out);
	    if (extract) fclose(out);
	}
	return done;
    }

    if (argc == 3 && !extract)
    {  /* list from one spec */
	ZZIP_MEM_ENTRY* entry = 0;
	while ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))
	{
	     unzzip_mem_entry_fprint (disk, entry, stdout);
	}

	return 0;
    }

    for (argn=1; argn < argc; argn++)
    {   /* list only the matching entries - each in order of commandline */
	ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);
	for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))
	{
	    char* name = zzip_mem_entry_to_name (entry);
	    if (! _zzip_fnmatch (argv[argn], name, 
		FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
	    {
	        FILE* out = stdout;
	        if (extract) out = create_fopen(name, ""w"", 1);
	        if (! out) {
	            done = EXIT_ERRORS;
	            continue;
	        }
		unzzip_mem_disk_cat_file (disk, name, out);
		if (extract) fclose(out);
		break; /* match loop */
	    }
	}
    }
    return done;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
    int VAR_3;
    int VAR_4;
    ZZIP_MEM_DISK* VAR_5;

    if (VAR_0 == 1)
    {
	VAR_6 (VAR_7"" VAR_8 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
	return VAR_9; /* COMMENT_0 */
    }

    VAR_5 = zzip_mem_disk_open (VAR_1[1]);
    if (! VAR_5) {
        DBG3(""disk_open failed [%i] %s"", VAR_10, strerror(VAR_10));
	perror(VAR_1[1]);
	return exitcode(VAR_10);
    }

    if (VAR_0 == 2)
    {  /* COMMENT_1 */
	ZZIP_MEM_ENTRY* VAR_11 = zzip_mem_disk_findfirst(VAR_5);
	DBG2(""findfirst %p\n"", VAR_11);
	for (; VAR_11 ; VAR_11 = zzip_mem_disk_findnext(VAR_5, VAR_11))
	{
	    char* VAR_12 = zzip_mem_entry_to_name (VAR_11);
	    FILE* VAR_13 = VAR_14;
	    if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
	    if (! VAR_13) {
	        VAR_3 = VAR_15;
	        continue;
	    }
	    unzzip_mem_disk_cat_file (VAR_5, VAR_12, VAR_13);
	    if (VAR_2) fclose(VAR_13);
	}
	return VAR_3;
    }

    if (VAR_0 == 3 && !VAR_2)
    {  /* COMMENT_2 */
	ZZIP_MEM_ENTRY* VAR_11 = 0;
	while ((VAR_11 = zzip_mem_disk_findmatch(VAR_5, VAR_1[2], VAR_11, 0, 0)))
	{
	     unzzip_mem_entry_fprint (VAR_5, VAR_11, VAR_14);
	}

	return 0;
    }

    for (VAR_4=1; VAR_4 < VAR_0; VAR_4++)
    {   /* COMMENT_3 */
	ZZIP_MEM_ENTRY* VAR_11 = zzip_mem_disk_findfirst(VAR_5);
	for (; VAR_11 ; VAR_11 = zzip_mem_disk_findnext(VAR_5, VAR_11))
	{
	    char* VAR_12 = zzip_mem_entry_to_name (VAR_11);
	    if (! _zzip_fnmatch (VAR_1[VAR_4], VAR_12, 
		VAR_16|VAR_17|VAR_18))
	    {
	        FILE* VAR_13 = VAR_14;
	        if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
	        if (! VAR_13) {
	            VAR_3 = VAR_15;
	            continue;
	        }
		unzzip_mem_disk_cat_file (VAR_5, VAR_12, VAR_13);
		if (VAR_2) fclose(VAR_13);
		break; /* COMMENT_4 */
	    }
	}
    }
    return VAR_3;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mem.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static int unzzip_cat (int argc, char ** argv, int extract)
 {
+    int done;
     int argn;
     ZZIP_MEM_DISK* disk;
 
@@ -25,10 +26,14 @@
 	    char* name = zzip_mem_entry_to_name (entry);
 	    FILE* out = stdout;
 	    if (extract) out = create_fopen(name, ""w"", 1);
+	    if (! out) {
+	        done = EXIT_ERRORS;
+	        continue;
+	    }
 	    unzzip_mem_disk_cat_file (disk, name, out);
 	    if (extract) fclose(out);
 	}
-	return 0;
+	return done;
     }
 
     if (argc == 3 && !extract)
@@ -53,11 +58,15 @@
 	    {
 	        FILE* out = stdout;
 	        if (extract) out = create_fopen(name, ""w"", 1);
+	        if (! out) {
+	            done = EXIT_ERRORS;
+	            continue;
+	        }
 		unzzip_mem_disk_cat_file (disk, name, out);
 		if (extract) fclose(out);
 		break; /* match loop */
 	    }
 	}
     }
-    return 0;
+    return done;
 }","{'deleted_lines': ['\treturn 0;', '    return 0;'], 'added_lines': ['    int done;', '\t    if (! out) {', '\t        done = EXIT_ERRORS;', '\t        continue;', '\t    }', '\treturn done;', '\t        if (! out) {', '\t            done = EXIT_ERRORS;', '\t            continue;', '\t        }', '    return done;']}",True,"In ZZIPlib 0.13.67, there is a bus error (when handling a disk64_trailer seek value) caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c.",6.5,MEDIUM,1,valid,2018-02-05T13:37:13Z,2
CVE-2018-6542,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,fopen may fail for a bad name -> EXIT_ERRORS in that case #17,931f962ddfec0e00d6f486df2c56d9857b55944e,https://github.com/gdraheim/zziplib/commit/931f962ddfec0e00d6f486df2c56d9857b55944e,bins/unzzipcat-mem.c,unzzip_mem_disk_cat_file,"static void unzzip_mem_disk_cat_file(ZZIP_MEM_DISK* disk, char* name, FILE* out)
{
ZZIP_DISK_FILE* file = zzip_mem_disk_fopen (disk, name);
if (file) 
{
char buffer[1024]; int len;
while ((len = zzip_mem_disk_fread (buffer, 1, 1024, file))) 
{
fwrite (buffer, 1, len, out);
}
zzip_mem_disk_fclose (file);
}
}","static void unzzip_mem_disk_cat_file(ZZIP_MEM_DISK* VAR_0, char* VAR_1, FILE* VAR_2)
{
ZZIP_DISK_FILE* VAR_3 = zzip_mem_disk_fopen (VAR_0, VAR_1);
if (VAR_3) 
{
char VAR_4[1024]; int VAR_5;
while ((VAR_5 = zzip_mem_disk_fread (VAR_4, 1, 1024, VAR_3))) 
{
fwrite (VAR_4, 1, VAR_5, VAR_2);
}
zzip_mem_disk_fclose (VAR_3);
}
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mem.c/vul/before/0.json,"static void unzzip_mem_disk_cat_file(ZZIP_MEM_DISK* disk, char* name, FILE* out)
{
    ZZIP_DISK_FILE* file = zzip_mem_disk_fopen (disk, name);
    if (file) 
    {
	char buffer[1025]; int len;
	while ((len = zzip_mem_disk_fread (buffer, 1, 1024, file))) 
	{
	    fwrite (buffer, 1, len, out);
	}
	
	zzip_mem_disk_fclose (file);
    }
}","static void unzzip_mem_disk_cat_file(ZZIP_MEM_DISK* VAR_0, char* VAR_1, FILE* VAR_2)
{
    ZZIP_DISK_FILE* VAR_3 = zzip_mem_disk_fopen (VAR_0, VAR_1);
    if (VAR_3) 
    {
	char VAR_4[1025]; int VAR_5;
	while ((VAR_5 = zzip_mem_disk_fread (VAR_4, 1, 1024, VAR_3))) 
	{
	    fwrite (VAR_4, 1, VAR_5, VAR_2);
	}
	
	zzip_mem_disk_fclose (VAR_3);
    }
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
     ZZIP_DISK_FILE* file = zzip_mem_disk_fopen (disk, name);
     if (file) 
     {
-	char buffer[1024]; int len;
+	char buffer[1025]; int len;
 	while ((len = zzip_mem_disk_fread (buffer, 1, 1024, file))) 
 	{
 	    fwrite (buffer, 1, len, out);","{'deleted_lines': ['\tchar buffer[1024]; int len;'], 'added_lines': ['\tchar buffer[1025]; int len;']}",True,"In ZZIPlib 0.13.67, there is a bus error (when handling a disk64_trailer seek value) caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c.",6.5,MEDIUM,1,valid,2018-02-05T13:37:13Z,2
CVE-2018-6542,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,fopen may fail for a bad name -> EXIT_ERRORS in that case #17,931f962ddfec0e00d6f486df2c56d9857b55944e,https://github.com/gdraheim/zziplib/commit/931f962ddfec0e00d6f486df2c56d9857b55944e,bins/unzzipcat-mix.c,unzzip_cat,"static int unzzip_cat (int argc, char ** argv, int extract)
{
int argn;
ZZIP_DIR* disk;
if (argc == 1)
{
printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return EXIT_OK; 
}
disk = zzip_opendir (argv[1]);
if (! disk) {
DBG3(""opendir failed [%i] %s"", errno, strerror(errno));
perror(argv[1]);
return exitcode(errno);
}
if (argc == 2)
{  
ZZIP_DIRENT* entry = 0;
while((entry = zzip_readdir(disk)))
{
char* name = entry->d_name;
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
unzzip_cat_file (disk, name, out);
if (extract) fclose(out);
}
DBG2(""readdir done %s"", strerror(errno));
}
else
{   
ZZIP_DIRENT* entry = 0;
while((entry = zzip_readdir(disk)))
{
char* name = entry->d_name;
for (argn=1; argn < argc; argn++)
{
if (! _zzip_fnmatch (argv[argn], name, 
FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
{
FILE* out = stdout;
char* zip_name = argv[1];
int zip_name_len = strlen(zip_name);
int name_len = strlen(name);
char* mix_name = malloc(zip_name_len + 2 + name_len);
if (zip_name_len > 4 && !strcmp(zip_name+zip_name_len-4, "".zip""))
zip_name_len -= 4;
memcpy(mix_name, zip_name, zip_name_len);
mix_name[zip_name_len] = '/';
strcpy(mix_name + zip_name_len + 1, name);
if (extract) out = create_fopen(name, ""w"", 1);
fprintf(stderr, ""%s %s -> %s\n"", zip_name, name, mix_name);
unzzip_cat_file (disk, mix_name, out);
if (extract) fclose(out);
break; 
}
}
}
}
zzip_closedir(disk);
return 0;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
int VAR_3;
ZZIP_DIR* VAR_4;
if (VAR_0 == 1)
{
VAR_5 (VAR_6"" VAR_7 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return VAR_8; 
}
VAR_4 = zzip_opendir (VAR_1[1]);
if (! VAR_4) {
DBG3(""opendir failed [%i] %s"", VAR_9, strerror(VAR_9));
perror(VAR_1[1]);
return exitcode(VAR_9);
}
if (VAR_0 == 2)
{  
ZZIP_DIRENT* VAR_10 = 0;
while((VAR_10 = zzip_readdir(VAR_4)))
{
char* VAR_11 = VAR_10->d_name;
FILE* VAR_12 = VAR_13;
if (VAR_2) VAR_12 = create_fopen(VAR_11, ""w"", 1);
unzzip_cat_file (VAR_4, VAR_11, VAR_12);
if (VAR_2) fclose(VAR_12);
}
DBG2(""readdir done %s"", strerror(VAR_9));
}
else
{   
ZZIP_DIRENT* VAR_10 = 0;
while((VAR_10 = zzip_readdir(VAR_4)))
{
char* VAR_11 = VAR_10->d_name;
for (VAR_3=1; VAR_3 < VAR_0; VAR_3++)
{
if (! _zzip_fnmatch (VAR_1[VAR_3], VAR_11, 
VAR_14|VAR_15|VAR_16))
{
FILE* VAR_12 = VAR_13;
char* VAR_17 = VAR_1[1];
int VAR_18 = strlen(VAR_17);
int VAR_19 = strlen(VAR_11);
char* VAR_20 = malloc(VAR_18 + 2 + VAR_19);
if (VAR_18 > 4 && !strcmp(VAR_17+VAR_18-4, "".zip""))
VAR_18 -= 4;
memcpy(VAR_20, VAR_17, VAR_18);
VAR_20[VAR_18] = '/';
strcpy(VAR_20 + VAR_18 + 1, VAR_11);
if (VAR_2) VAR_12 = create_fopen(VAR_11, ""w"", 1);
fprintf(VAR_21, ""%s %s -> %s\n"", VAR_17, VAR_11, VAR_20);
unzzip_cat_file (VAR_4, VAR_20, VAR_12);
if (VAR_2) fclose(VAR_12);
break; 
}
}
}
}
zzip_closedir(VAR_4);
return 0;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mix.c/vul/before/0.json,"static int unzzip_cat (int argc, char ** argv, int extract)
{
    int done = 0;
    int argn;
    ZZIP_DIR* disk;
    
    if (argc == 1)
    {
        printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
        return EXIT_OK; /* better provide an archive argument */
    }
    
    disk = zzip_opendir (argv[1]);
    if (! disk) {
        DBG3(""opendir failed [%i] %s"", errno, strerror(errno));
	perror(argv[1]);
	return exitcode(errno);
    }

    if (argc == 2)
    {  /* list all */
	ZZIP_DIRENT* entry = 0;
	while((entry = zzip_readdir(disk)))
	{
	    char* name = entry->d_name;
	    FILE* out = stdout;
	    if (extract) out = create_fopen(name, ""w"", 1);
	    if (! out) {
	        done = EXIT_ERRORS;
	        continue;
	    }
	    unzzip_cat_file (disk, name, out);
	    if (extract) fclose(out);
	}
	DBG2(""readdir done %s"", strerror(errno));
    }
    else
    {   /* list only the matching entries - in order of zip directory */
	ZZIP_DIRENT* entry = 0;
	while((entry = zzip_readdir(disk)))
	{
	    char* name = entry->d_name;
	    for (argn=1; argn < argc; argn++)
	    {
		if (! _zzip_fnmatch (argv[argn], name, 
		    FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
	        {
	             FILE* out = stdout;
	             char* zip_name = argv[1];
	             int zip_name_len = strlen(zip_name);
	             int name_len = strlen(name);
	             char* mix_name = malloc(zip_name_len + 2 + name_len);
	             if (zip_name_len > 4 && !strcmp(zip_name+zip_name_len-4, "".zip""))
	                 zip_name_len -= 4;
	             memcpy(mix_name, zip_name, zip_name_len);
	             mix_name[zip_name_len] = '/';
	             strcpy(mix_name + zip_name_len + 1, name);
	             if (extract) out = create_fopen(name, ""w"", 1);
	             if (! out) {
	                 done = EXIT_ERRORS;
	                 continue;
	             }
		     fprintf(stderr, ""%s %s -> %s\n"", zip_name, name, mix_name);
		     /* 'test1.zip' 'README' -> 'test1/README' */
		     unzzip_cat_file (disk, mix_name, out);
		     if (extract) fclose(out);
		     break; /* match loop */
	        }
	    }
	}
    }
    zzip_closedir(disk);
    return done;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
    int VAR_3 = 0;
    int VAR_4;
    ZZIP_DIR* VAR_5;
    
    if (VAR_0 == 1)
    {
        VAR_6 (VAR_7"" VAR_8 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
        return VAR_9; /* COMMENT_0 */
    }
    
    VAR_5 = zzip_opendir (VAR_1[1]);
    if (! VAR_5) {
        DBG3(""opendir failed [%i] %s"", VAR_10, strerror(VAR_10));
	perror(VAR_1[1]);
	return exitcode(VAR_10);
    }

    if (VAR_0 == 2)
    {  /* COMMENT_1 */
	ZZIP_DIRENT* VAR_11 = 0;
	while((VAR_11 = zzip_readdir(VAR_5)))
	{
	    char* VAR_12 = VAR_11->d_name;
	    FILE* VAR_13 = VAR_14;
	    if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
	    if (! VAR_13) {
	        VAR_3 = VAR_15;
	        continue;
	    }
	    unzzip_cat_file (VAR_5, VAR_12, VAR_13);
	    if (VAR_2) fclose(VAR_13);
	}
	DBG2(""readdir done %s"", strerror(VAR_10));
    }
    else
    {   /* COMMENT_2 */
	ZZIP_DIRENT* VAR_11 = 0;
	while((VAR_11 = zzip_readdir(VAR_5)))
	{
	    char* VAR_12 = VAR_11->d_name;
	    for (VAR_4=1; VAR_4 < VAR_0; VAR_4++)
	    {
		if (! _zzip_fnmatch (VAR_1[VAR_4], VAR_12, 
		    VAR_16|VAR_17|VAR_18))
	        {
	             FILE* VAR_13 = VAR_14;
	             char* VAR_19 = VAR_1[1];
	             int VAR_20 = strlen(VAR_19);
	             int VAR_21 = strlen(VAR_12);
	             char* VAR_22 = malloc(VAR_20 + 2 + VAR_21);
	             if (VAR_20 > 4 && !strcmp(VAR_19+VAR_20-4, "".zip""))
	                 VAR_20 -= 4;
	             memcpy(VAR_22, VAR_19, VAR_20);
	             VAR_22[VAR_20] = '/';
	             strcpy(VAR_22 + VAR_20 + 1, VAR_12);
	             if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
	             if (! VAR_13) {
	                 VAR_3 = VAR_15;
	                 continue;
	             }
		     fprintf(VAR_23, ""%s %s -> %s\n"", VAR_19, VAR_12, VAR_22);
		     /* COMMENT_3 */
		     unzzip_cat_file (VAR_5, VAR_22, VAR_13);
		     if (VAR_2) fclose(VAR_13);
		     break; /* COMMENT_4 */
	        }
	    }
	}
    }
    zzip_closedir(VAR_5);
    return VAR_3;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-mix.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static int unzzip_cat (int argc, char ** argv, int extract)
 {
+    int done = 0;
     int argn;
     ZZIP_DIR* disk;
     
@@ -24,6 +25,10 @@
 	    char* name = entry->d_name;
 	    FILE* out = stdout;
 	    if (extract) out = create_fopen(name, ""w"", 1);
+	    if (! out) {
+	        done = EXIT_ERRORS;
+	        continue;
+	    }
 	    unzzip_cat_file (disk, name, out);
 	    if (extract) fclose(out);
 	}
@@ -51,6 +56,10 @@
 	             mix_name[zip_name_len] = '/';
 	             strcpy(mix_name + zip_name_len + 1, name);
 	             if (extract) out = create_fopen(name, ""w"", 1);
+	             if (! out) {
+	                 done = EXIT_ERRORS;
+	                 continue;
+	             }
 		     fprintf(stderr, ""%s %s -> %s\n"", zip_name, name, mix_name);
 		     /* 'test1.zip' 'README' -> 'test1/README' */
 		     unzzip_cat_file (disk, mix_name, out);
@@ -61,5 +70,5 @@
 	}
     }
     zzip_closedir(disk);
-    return 0;
+    return done;
 }","{'deleted_lines': ['    return 0;'], 'added_lines': ['    int done = 0;', '\t    if (! out) {', '\t        done = EXIT_ERRORS;', '\t        continue;', '\t    }', '\t             if (! out) {', '\t                 done = EXIT_ERRORS;', '\t                 continue;', '\t             }', '    return done;']}",True,"In ZZIPlib 0.13.67, there is a bus error (when handling a disk64_trailer seek value) caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c.",6.5,MEDIUM,1,valid,2018-02-05T13:37:13Z,2
CVE-2018-6542,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,fopen may fail for a bad name -> EXIT_ERRORS in that case #17,931f962ddfec0e00d6f486df2c56d9857b55944e,https://github.com/gdraheim/zziplib/commit/931f962ddfec0e00d6f486df2c56d9857b55944e,bins/unzzipcat-zip.c,unzzip_cat,"static int unzzip_cat (int argc, char ** argv, int extract)
{
int argn;
ZZIP_DIR* disk;
zzip_error_t error;
if (argc == 1)
{
printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return EXIT_OK; 
}
disk = zzip_dir_open (argv[1], &error);
if (! disk) {
fprintf(stderr, ""%s: %s\n"", argv[1], zzip_strerror(error));
return exitcode(error);
}
if (argc == 2)
{  
ZZIP_DIRENT entry;
while(zzip_dir_read(disk, &entry))
{
char* name = entry.d_name;
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
if (out) {
unzzip_cat_file (disk, name, out);
if (extract) fclose(out);
}
}
}
else
{   
ZZIP_DIRENT entry;
while(zzip_dir_read(disk, &entry))
{
char* name = entry.d_name;
for (argn=1; argn < argc; argn++)
{
if (! _zzip_fnmatch (argv[argn], name, 
FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
{
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
if (out) {
unzzip_cat_file (disk, name, out);
if (extract) fclose(out);
}
break; 
}
}
}
}
zzip_dir_close(disk);
return 0;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
int VAR_3;
ZZIP_DIR* VAR_4;
zzip_error_t VAR_5;
if (VAR_0 == 1)
{
VAR_6 (VAR_7"" VAR_8 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
return VAR_9; 
}
VAR_4 = zzip_dir_open (VAR_1[1], &VAR_5);
if (! VAR_4) {
fprintf(VAR_10, ""%s: %s\n"", VAR_1[1], zzip_strerror(VAR_5));
return exitcode(VAR_5);
}
if (VAR_0 == 2)
{  
ZZIP_DIRENT VAR_11;
while(zzip_dir_read(VAR_4, &VAR_11))
{
char* VAR_12 = VAR_11.d_name;
FILE* VAR_13 = VAR_14;
if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
if (VAR_13) {
unzzip_cat_file (VAR_4, VAR_12, VAR_13);
if (VAR_2) fclose(VAR_13);
}
}
}
else
{   
ZZIP_DIRENT VAR_11;
while(zzip_dir_read(VAR_4, &VAR_11))
{
char* VAR_12 = VAR_11.d_name;
for (VAR_3=1; VAR_3 < VAR_0; VAR_3++)
{
if (! _zzip_fnmatch (VAR_1[VAR_3], VAR_12, 
VAR_15|VAR_16|VAR_17))
{
FILE* VAR_13 = VAR_14;
if (VAR_2) VAR_13 = create_fopen(VAR_12, ""w"", 1);
if (VAR_13) {
unzzip_cat_file (VAR_4, VAR_12, VAR_13);
if (VAR_2) fclose(VAR_13);
}
break; 
}
}
}
}
zzip_dir_close(VAR_4);
return 0;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-zip.c/vul/before/0.json,"static int unzzip_cat (int argc, char ** argv, int extract)
{
    int done = 0;
    int argn;
    ZZIP_DIR* disk;
    zzip_error_t error;
    
    if (argc == 1)
    {
        printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
        return EXIT_OK; /* better provide an archive argument */
    }
    
    disk = zzip_dir_open (argv[1], &error);
    if (! disk) {
	fprintf(stderr, ""%s: %s\n"", argv[1], zzip_strerror(error));
	return exitcode(error);
    }

    if (argc == 2)
    {  /* list all */
	ZZIP_DIRENT entry;
	while(zzip_dir_read(disk, &entry))
	{
	    char* name = entry.d_name;
	    FILE* out = stdout;
	    if (extract) out = create_fopen(name, ""w"", 1);
	    if (! out) {
	        done = EXIT_ERRORS;
	        continue;
	    }
	    unzzip_cat_file (disk, name, out);
	    if (extract) fclose(out);
	}
    }
    else
    {   /* list only the matching entries - in order of zip directory */
	ZZIP_DIRENT entry;
	while(zzip_dir_read(disk, &entry))
	{
	    char* name = entry.d_name;
	    for (argn=1; argn < argc; argn++)
	    {
		if (! _zzip_fnmatch (argv[argn], name, 
		    FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
	        {
	            FILE* out = stdout;
	            if (extract) out = create_fopen(name, ""w"", 1);
		    if (! out) {
		        done = EXIT_ERRORS;
		        continue;
		    }
	            unzzip_cat_file (disk, name, out);
	            if (extract) fclose(out);
		    break; /* match loop */
	        }
	    }
	}
    }
    zzip_dir_close(disk);
    return done;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
    int VAR_3 = 0;
    int VAR_4;
    ZZIP_DIR* VAR_5;
    zzip_error_t VAR_6;
    
    if (VAR_0 == 1)
    {
        VAR_7 (VAR_8"" VAR_9 ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n"");
        return VAR_10; /* COMMENT_0 */
    }
    
    VAR_5 = zzip_dir_open (VAR_1[1], &VAR_6);
    if (! VAR_5) {
	fprintf(VAR_11, ""%s: %s\n"", VAR_1[1], zzip_strerror(VAR_6));
	return exitcode(VAR_6);
    }

    if (VAR_0 == 2)
    {  /* COMMENT_1 */
	ZZIP_DIRENT VAR_12;
	while(zzip_dir_read(VAR_5, &VAR_12))
	{
	    char* VAR_13 = VAR_12.d_name;
	    FILE* VAR_14 = VAR_15;
	    if (VAR_2) VAR_14 = create_fopen(VAR_13, ""w"", 1);
	    if (! VAR_14) {
	        VAR_3 = VAR_16;
	        continue;
	    }
	    unzzip_cat_file (VAR_5, VAR_13, VAR_14);
	    if (VAR_2) fclose(VAR_14);
	}
    }
    else
    {   /* COMMENT_2 */
	ZZIP_DIRENT VAR_12;
	while(zzip_dir_read(VAR_5, &VAR_12))
	{
	    char* VAR_13 = VAR_12.d_name;
	    for (VAR_4=1; VAR_4 < VAR_0; VAR_4++)
	    {
		if (! _zzip_fnmatch (VAR_1[VAR_4], VAR_13, 
		    VAR_17|VAR_18|VAR_19))
	        {
	            FILE* VAR_14 = VAR_15;
	            if (VAR_2) VAR_14 = create_fopen(VAR_13, ""w"", 1);
		    if (! VAR_14) {
		        VAR_3 = VAR_16;
		        continue;
		    }
	            unzzip_cat_file (VAR_5, VAR_13, VAR_14);
	            if (VAR_2) fclose(VAR_14);
		    break; /* COMMENT_3 */
	        }
	    }
	}
    }
    zzip_dir_close(VAR_5);
    return VAR_3;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-zip.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static int unzzip_cat (int argc, char ** argv, int extract)
 {
+    int done = 0;
     int argn;
     ZZIP_DIR* disk;
     zzip_error_t error;
@@ -24,10 +25,12 @@
 	    char* name = entry.d_name;
 	    FILE* out = stdout;
 	    if (extract) out = create_fopen(name, ""w"", 1);
-	    if (out) {
-	        unzzip_cat_file (disk, name, out);
-	        if (extract) fclose(out);
+	    if (! out) {
+	        done = EXIT_ERRORS;
+	        continue;
 	    }
+	    unzzip_cat_file (disk, name, out);
+	    if (extract) fclose(out);
 	}
     }
     else
@@ -43,15 +46,17 @@
 	        {
 	            FILE* out = stdout;
 	            if (extract) out = create_fopen(name, ""w"", 1);
-	            if (out) {
-		        unzzip_cat_file (disk, name, out);
-		        if (extract) fclose(out);
+		    if (! out) {
+		        done = EXIT_ERRORS;
+		        continue;
 		    }
+	            unzzip_cat_file (disk, name, out);
+	            if (extract) fclose(out);
 		    break; /* match loop */
 	        }
 	    }
 	}
     }
     zzip_dir_close(disk);
-    return 0;
+    return done;
 }","{'deleted_lines': ['\t    if (out) {', '\t        unzzip_cat_file (disk, name, out);', '\t        if (extract) fclose(out);', '\t            if (out) {', '\t\t        unzzip_cat_file (disk, name, out);', '\t\t        if (extract) fclose(out);', '    return 0;'], 'added_lines': ['    int done = 0;', '\t    if (! out) {', '\t        done = EXIT_ERRORS;', '\t        continue;', '\t    unzzip_cat_file (disk, name, out);', '\t    if (extract) fclose(out);', '\t\t    if (! out) {', '\t\t        done = EXIT_ERRORS;', '\t\t        continue;', '\t            unzzip_cat_file (disk, name, out);', '\t            if (extract) fclose(out);', '    return done;']}",True,"In ZZIPlib 0.13.67, there is a bus error (when handling a disk64_trailer seek value) caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c.",6.5,MEDIUM,1,valid,2018-02-05T13:37:13Z,2
CVE-2018-6542,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gdraheim/zziplib,fopen may fail for a bad name -> EXIT_ERRORS in that case #17,931f962ddfec0e00d6f486df2c56d9857b55944e,https://github.com/gdraheim/zziplib/commit/931f962ddfec0e00d6f486df2c56d9857b55944e,bins/unzzipcat-big.c,unzzip_cat,"static int unzzip_cat (int argc, char ** argv, int extract)
{
int argn;
FILE* disk;
disk = fopen (argv[1], ""r"");
if (! disk) {
perror(argv[1]);
return exitcode(errno);
}
if (argc == 2)
{  
int warnings = 0;
ZZIP_ENTRY* entry = zzip_entry_findfirst(disk);
for (; entry ; entry = zzip_entry_findnext(entry))
{
char* name = zzip_entry_strdup_name (entry);
FILE* out = stdout;
if (! name) {
warnings += 1;
continue;
}
if (extract) out = create_fopen(name, ""w"", 1);
unzzip_cat_file (disk, name, out);
if (extract) fclose(out);
free (name);
}
if (warnings) {
return EXIT_WARNINGS;
}
return 0;
}
if (argc == 3 && !extract)
{  
ZZIP_ENTRY* entry = 0;
while ((entry = zzip_entry_findmatch(disk, argv[2], entry, 0, 0)))
{
unzzip_big_entry_fprint (entry, stdout);
}
return 0;
}
for (argn=1; argn < argc; argn++)
{   
ZZIP_ENTRY* entry = zzip_entry_findfirst(disk);
for (; entry ; entry = zzip_entry_findnext(entry))
{
char* name = zzip_entry_strdup_name (entry);
DBG3("".. check '%s' to zip '%s'"", argv[argn], name);
if (! _zzip_fnmatch (argv[argn], name, 
FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
{
FILE* out = stdout;
if (extract) out = create_fopen(name, ""w"", 1);
unzzip_cat_file (disk, name, out);
if (extract) fclose(out);
break; 
}
free (name);
}
}
return 0;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
int VAR_3;
FILE* VAR_4;
VAR_4 = fopen (VAR_1[1], ""r"");
if (! VAR_4) {
perror(VAR_1[1]);
return exitcode(VAR_5);
}
if (VAR_0 == 2)
{  
int VAR_6 = 0;
ZZIP_ENTRY* VAR_7 = zzip_entry_findfirst(VAR_4);
for (; VAR_7 ; VAR_7 = zzip_entry_findnext(VAR_7))
{
char* VAR_8 = zzip_entry_strdup_name (VAR_7);
FILE* VAR_9 = VAR_10;
if (! VAR_8) {
VAR_6 += 1;
continue;
}
if (VAR_2) VAR_9 = create_fopen(VAR_8, ""w"", 1);
unzzip_cat_file (VAR_4, VAR_8, VAR_9);
if (VAR_2) fclose(VAR_9);
free (VAR_8);
}
if (VAR_6) {
return VAR_11;
}
return 0;
}
if (VAR_0 == 3 && !VAR_2)
{  
ZZIP_ENTRY* VAR_7 = 0;
while ((VAR_7 = zzip_entry_findmatch(VAR_4, VAR_1[2], VAR_7, 0, 0)))
{
unzzip_big_entry_fprint (VAR_7, VAR_10);
}
return 0;
}
for (VAR_3=1; VAR_3 < VAR_0; VAR_3++)
{   
ZZIP_ENTRY* VAR_7 = zzip_entry_findfirst(VAR_4);
for (; VAR_7 ; VAR_7 = zzip_entry_findnext(VAR_7))
{
char* VAR_8 = zzip_entry_strdup_name (VAR_7);
DBG3("".. check '%s' to zip '%s'"", VAR_1[VAR_3], VAR_8);
if (! _zzip_fnmatch (VAR_1[VAR_3], VAR_8, 
VAR_12|VAR_13|VAR_14))
{
FILE* VAR_9 = VAR_10;
if (VAR_2) VAR_9 = create_fopen(VAR_8, ""w"", 1);
unzzip_cat_file (VAR_4, VAR_8, VAR_9);
if (VAR_2) fclose(VAR_9);
break; 
}
free (VAR_8);
}
}
return 0;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-big.c/vul/before/0.json,"static int unzzip_cat (int argc, char ** argv, int extract)
{
    int done = 0;
    int argn;
    FILE* disk;

    disk = fopen (argv[1], ""r"");
    if (! disk) {
	perror(argv[1]);
	return exitcode(errno);
    }

    if (argc == 2)
    {  /* print directory list */
	ZZIP_ENTRY* entry = zzip_entry_findfirst(disk);
	for (; entry ; entry = zzip_entry_findnext(entry))
	{
	    char* name = zzip_entry_strdup_name (entry);
	    FILE* out = stdout;
	    if (! name) {
	        done = EXIT_WARNINGS;
	        continue;
	    }
	    if (extract) out = create_fopen(name, ""w"", 1);
	    if (! out) {
	        done = EXIT_ERRORS;
	        continue;
	    }
	    unzzip_cat_file (disk, name, out);
	    if (extract) fclose(out);
	    free (name);
	}
	return done;
    }

    if (argc == 3 && !extract)
    {  /* list from one spec */
	ZZIP_ENTRY* entry = 0;
	while ((entry = zzip_entry_findmatch(disk, argv[2], entry, 0, 0)))
	{
	     unzzip_big_entry_fprint (entry, stdout);
	}
	return 0;
    }

    for (argn=1; argn < argc; argn++)
    {   /* list only the matching entries - each in order of commandline */
	ZZIP_ENTRY* entry = zzip_entry_findfirst(disk);
	for (; entry ; entry = zzip_entry_findnext(entry))
	{
	    char* name = zzip_entry_strdup_name (entry);
	    DBG3("".. check '%s' to zip '%s'"", argv[argn], name);
	    if (! _zzip_fnmatch (argv[argn], name, 
		FNM_NOESCAPE|FNM_PATHNAME|FNM_PERIOD))
	    {
	        FILE* out = stdout;
	        if (extract) out = create_fopen(name, ""w"", 1);
		if (! out) {
		    done = EXIT_ERRORS;
		    continue;
		}
		unzzip_cat_file (disk, name, out);
		if (extract) fclose(out);
		break; /* match loop */
	    }
	    free (name);
	}
    }
    return done;
}","static int unzzip_cat (int VAR_0, char ** VAR_1, int VAR_2)
{
    int VAR_3 = 0;
    int VAR_4;
    FILE* VAR_5;

    VAR_5 = fopen (VAR_1[1], ""r"");
    if (! VAR_5) {
	perror(VAR_1[1]);
	return exitcode(VAR_6);
    }

    if (VAR_0 == 2)
    {  /* COMMENT_0 */
	ZZIP_ENTRY* VAR_7 = zzip_entry_findfirst(VAR_5);
	for (; VAR_7 ; VAR_7 = zzip_entry_findnext(VAR_7))
	{
	    char* VAR_8 = zzip_entry_strdup_name (VAR_7);
	    FILE* VAR_9 = VAR_10;
	    if (! VAR_8) {
	        VAR_3 = VAR_11;
	        continue;
	    }
	    if (VAR_2) VAR_9 = create_fopen(VAR_8, ""w"", 1);
	    if (! VAR_9) {
	        VAR_3 = VAR_12;
	        continue;
	    }
	    unzzip_cat_file (VAR_5, VAR_8, VAR_9);
	    if (VAR_2) fclose(VAR_9);
	    free (VAR_8);
	}
	return VAR_3;
    }

    if (VAR_0 == 3 && !VAR_2)
    {  /* COMMENT_1 */
	ZZIP_ENTRY* VAR_7 = 0;
	while ((VAR_7 = zzip_entry_findmatch(VAR_5, VAR_1[2], VAR_7, 0, 0)))
	{
	     unzzip_big_entry_fprint (VAR_7, VAR_10);
	}
	return 0;
    }

    for (VAR_4=1; VAR_4 < VAR_0; VAR_4++)
    {   /* COMMENT_2 */
	ZZIP_ENTRY* VAR_7 = zzip_entry_findfirst(VAR_5);
	for (; VAR_7 ; VAR_7 = zzip_entry_findnext(VAR_7))
	{
	    char* VAR_8 = zzip_entry_strdup_name (VAR_7);
	    DBG3("".. check '%s' to zip '%s'"", VAR_1[VAR_4], VAR_8);
	    if (! _zzip_fnmatch (VAR_1[VAR_4], VAR_8, 
		VAR_13|VAR_14|VAR_15))
	    {
	        FILE* VAR_9 = VAR_10;
	        if (VAR_2) VAR_9 = create_fopen(VAR_8, ""w"", 1);
		if (! VAR_9) {
		    VAR_3 = VAR_12;
		    continue;
		}
		unzzip_cat_file (VAR_5, VAR_8, VAR_9);
		if (VAR_2) fclose(VAR_9);
		break; /* COMMENT_3 */
	    }
	    free (VAR_8);
	}
    }
    return VAR_3;
}",gdraheim/zziplib/931f962ddfec0e00d6f486df2c56d9857b55944e/unzzipcat-big.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static int unzzip_cat (int argc, char ** argv, int extract)
 {
+    int done = 0;
     int argn;
     FILE* disk;
 
@@ -11,25 +12,25 @@
 
     if (argc == 2)
     {  /* print directory list */
-	int warnings = 0;
 	ZZIP_ENTRY* entry = zzip_entry_findfirst(disk);
 	for (; entry ; entry = zzip_entry_findnext(entry))
 	{
 	    char* name = zzip_entry_strdup_name (entry);
 	    FILE* out = stdout;
 	    if (! name) {
-	        warnings += 1;
+	        done = EXIT_WARNINGS;
 	        continue;
 	    }
 	    if (extract) out = create_fopen(name, ""w"", 1);
+	    if (! out) {
+	        done = EXIT_ERRORS;
+	        continue;
+	    }
 	    unzzip_cat_file (disk, name, out);
 	    if (extract) fclose(out);
 	    free (name);
 	}
-	if (warnings) {
-	   return EXIT_WARNINGS;
-	}
-	return 0;
+	return done;
     }
 
     if (argc == 3 && !extract)
@@ -54,6 +55,10 @@
 	    {
 	        FILE* out = stdout;
 	        if (extract) out = create_fopen(name, ""w"", 1);
+		if (! out) {
+		    done = EXIT_ERRORS;
+		    continue;
+		}
 		unzzip_cat_file (disk, name, out);
 		if (extract) fclose(out);
 		break; /* match loop */
@@ -61,5 +66,5 @@
 	    free (name);
 	}
     }
-    return 0;
+    return done;
 }","{'deleted_lines': ['\tint warnings = 0;', '\t        warnings += 1;', '\tif (warnings) {', '\t   return EXIT_WARNINGS;', '\t}', '\treturn 0;', '    return 0;'], 'added_lines': ['    int done = 0;', '\t        done = EXIT_WARNINGS;', '\t    if (! out) {', '\t        done = EXIT_ERRORS;', '\t        continue;', '\t    }', '\treturn done;', '\t\tif (! out) {', '\t\t    done = EXIT_ERRORS;', '\t\t    continue;', '\t\t}', '    return done;']}",True,"In ZZIPlib 0.13.67, there is a bus error (when handling a disk64_trailer seek value) caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c.",6.5,MEDIUM,1,valid,2018-02-05T13:37:13Z,2
CVE-2018-7418,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"SIGCOMP: use correct message length

Since g2a80fe283c (2005-10-06!) length initialization was moved, and
the message length is no more correct (previously tvb_length_remaining()
was called with offset equal to 0, which is no more the case after the
change).

Bug: 14410
Change-Id: I2f00be83fa17ad7344d0d75f4a899f169d7a622b
Reviewed-on: https://code.wireshark.org/review/25735
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Reviewed-by: Anders Broman <a.broman58@gmail.com>
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 32ab83436d29754479e584c9a2c6a322cce794cd)
Reviewed-on: https://code.wireshark.org/review/25739
Petri-Dish: Michael Mann <mmann78@netscape.net>",29d920b8309905dda11ad397596fe8aafc9b4bf7,https://github.com/wireshark/wireshark/commit/29d920b8309905dda11ad397596fe8aafc9b4bf7,epan/dissectors/packet-sigcomp.c,dissect_sigcomp_tcp,"static int
dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_data _U_)
{
proto_item *ti;
proto_tree *sigcomp_tree;
tvbuff_t   *unescaped_tvb;
guint8     *buff;
int         offset = 0;
int         length;
guint8      octet;
guint16     data;
int         i;
int         n;
gboolean    end_off_message;
top_tree = tree;
data = tvb_get_ntohs(tvb, offset);
if (data == 0xffff) {
offset = offset + 2;
octet = tvb_get_guint8(tvb,offset);
} else {
octet = tvb_get_guint8(tvb,offset);
}
if ((octet  & 0xf8) != 0xf8)
return offset;
length = tvb_reported_length_remaining(tvb, offset);
for (i=0; i<(length-1); ++i) {
data = tvb_get_ntohs(tvb, offset+i);
if (0xffff == data) break;
}
if (i >= (length-1)) {
if (pinfo->can_desegment || pinfo->saved_can_desegment) {
pinfo->desegment_offset = offset;
pinfo->desegment_len=DESEGMENT_ONE_MORE_SEGMENT;
return -1;
}
}
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""SIGCOMP"");
col_clear(pinfo->cinfo, COL_INFO);
length = tvb_captured_length_remaining(tvb,offset);
try_again:
ti = proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);
sigcomp_tree = proto_item_add_subtree(ti, ett_sigcomp);
i=0;
end_off_message = FALSE;
buff = (guint8 *)wmem_alloc(pinfo->pool, length-offset);
if (udvm_print_detail_level>2)
proto_tree_add_item(sigcomp_tree, hf_sigcomp_starting_to_remove_escape_digits, tvb, offset, -1, ENC_NA);
while ((offset < length) && (end_off_message == FALSE)) {
octet = tvb_get_guint8(tvb,offset);
if ( octet == 0xff ) {
if ( offset +1 >= length ) {
offset++;
continue;
}
if (udvm_print_detail_level>2)
proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_escape_digit_found, tvb, offset, 2,
""              Escape digit found (0xFF)"");
octet = tvb_get_guint8(tvb, offset+1);
if ( octet == 0) {
buff[i] = 0xff;
offset = offset +2;
i++;
continue;
}
if ((octet > 0x7f) && (octet < 0xff )) {
if (udvm_print_detail_level>2)
proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_illegal_escape_code, tvb, offset, 2,
""              Illegal escape code"");
offset += tvb_captured_length_remaining(tvb,offset);
return offset;
}
if ( octet == 0xff) {
if (udvm_print_detail_level>2)
proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_end_of_sigcomp_message_indication_found, tvb, offset, 2,
""              End of SigComp message indication found (0xFFFF)"");
end_off_message = TRUE;
offset = offset+2;
continue;
}
buff[i] = 0xff;
if (udvm_print_detail_level>2)
proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
""              Addr: %u tvb value(0x%0x) "", i, buff[i]);
i++;
offset = offset+2;
if (udvm_print_detail_level>2)
proto_tree_add_bytes_format(sigcomp_tree, hf_sigcomp_copying_bytes_literally, tvb, offset, octet,
NULL, ""              Copying %u bytes literally"",octet);
if ( offset+octet >= length)
octet = length - offset;
for ( n=0; n < octet; n++ ) {
buff[i] = tvb_get_guint8(tvb, offset);
if (udvm_print_detail_level>2)
proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
""                  Addr: %u tvb value(0x%0x) "", i, buff[i]);
i++;
offset++;
}
continue;
}
buff[i] = octet;
if (udvm_print_detail_level>2)
proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
""              Addr: %u tvb value(0x%0x) "", i, buff[i]);
i++;
offset++;
}
unescaped_tvb = tvb_new_child_real_data(tvb, buff,i,i);
add_new_data_source(pinfo, unescaped_tvb, ""Unescaped Data handed to the SigComp dissector"");
proto_tree_add_item(sigcomp_tree, hf_sigcomp_data_for_sigcomp_dissector, unescaped_tvb, 0, -1, ENC_NA);
if (end_off_message == TRUE) {
dissect_sigcomp_common(unescaped_tvb, pinfo, sigcomp_tree);
} else {
proto_tree_add_expert(sigcomp_tree, pinfo, &ei_sigcomp_tcp_fragment, unescaped_tvb, 0, -1);
}
if ( offset < length) {
goto try_again;
}
return offset;
}","static int
dissect_sigcomp_tcp(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)
{
proto_item *VAR_4;
proto_tree *VAR_5;
tvbuff_t   *VAR_6;
guint8     *VAR_7;
int         VAR_8 = 0;
int         VAR_9;
guint8      VAR_10;
guint16     VAR_11;
int         VAR_12;
int         VAR_13;
gboolean    VAR_14;
VAR_15 = VAR_2;
VAR_11 = tvb_get_ntohs(VAR_0, VAR_8);
if (VAR_11 == 0xffff) {
VAR_8 = VAR_8 + 2;
VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
} else {
VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
}
if ((VAR_10  & 0xf8) != 0xf8)
return VAR_8;
VAR_9 = tvb_reported_length_remaining(VAR_0, VAR_8);
for (VAR_12=0; VAR_12<(VAR_9-1); ++VAR_12) {
VAR_11 = tvb_get_ntohs(VAR_0, VAR_8+VAR_12);
if (0xffff == VAR_11) break;
}
if (VAR_12 >= (VAR_9-1)) {
if (VAR_1->can_desegment || VAR_1->saved_can_desegment) {
VAR_1->desegment_offset = VAR_8;
VAR_1->desegment_len=VAR_16;
return -1;
}
}
col_set_str(VAR_1->cinfo, VAR_17, ""SIGCOMP"");
col_clear(VAR_1->cinfo, VAR_18);
VAR_9 = tvb_captured_length_remaining(VAR_0,VAR_8);
try_again:
VAR_4 = proto_tree_add_item(VAR_2, VAR_19, VAR_0, 0, -1, VAR_20);
VAR_5 = proto_item_add_subtree(VAR_4, VAR_21);
VAR_12=0;
VAR_14 = FALSE;
VAR_7 = (guint8 *)wmem_alloc(VAR_1->pool, VAR_9-VAR_8);
if (VAR_22>2)
proto_tree_add_item(VAR_5, VAR_23, VAR_0, VAR_8, -1, VAR_20);
while ((VAR_8 < VAR_9) && (VAR_14 == FALSE)) {
VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
if ( VAR_10 == 0xff ) {
if ( VAR_8 +1 >= VAR_9 ) {
VAR_8++;
continue;
}
if (VAR_22>2)
proto_tree_add_none_format(VAR_5, VAR_24, VAR_0, VAR_8, 2,
""              Escape digit found (0xFF)"");
VAR_10 = tvb_get_guint8(VAR_0, VAR_8+1);
if ( VAR_10 == 0) {
VAR_7[VAR_12] = 0xff;
VAR_8 = VAR_8 +2;
VAR_12++;
continue;
}
if ((VAR_10 > 0x7f) && (VAR_10 < 0xff )) {
if (VAR_22>2)
proto_tree_add_none_format(VAR_5, VAR_25, VAR_0, VAR_8, 2,
""              Illegal escape code"");
VAR_8 += tvb_captured_length_remaining(VAR_0,VAR_8);
return VAR_8;
}
if ( VAR_10 == 0xff) {
if (VAR_22>2)
proto_tree_add_none_format(VAR_5, VAR_26, VAR_0, VAR_8, 2,
""              End of SigComp message indication found (0xFFFF)"");
VAR_14 = TRUE;
VAR_8 = VAR_8+2;
continue;
}
VAR_7[VAR_12] = 0xff;
if (VAR_22>2)
proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
""              Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);
VAR_12++;
VAR_8 = VAR_8+2;
if (VAR_22>2)
proto_tree_add_bytes_format(VAR_5, VAR_28, VAR_0, VAR_8, VAR_10,
NULL, ""              Copying %u bytes literally"",VAR_10);
if ( VAR_8+VAR_10 >= VAR_9)
VAR_10 = VAR_9 - VAR_8;
for ( VAR_13=0; VAR_13 < VAR_10; VAR_13++ ) {
VAR_7[VAR_12] = tvb_get_guint8(VAR_0, VAR_8);
if (VAR_22>2)
proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
""                  Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);
VAR_12++;
VAR_8++;
}
continue;
}
VAR_7[VAR_12] = VAR_10;
if (VAR_22>2)
proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
""              Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);
VAR_12++;
VAR_8++;
}
VAR_6 = tvb_new_child_real_data(VAR_0, VAR_7,VAR_12,VAR_12);
add_new_data_source(VAR_1, VAR_6, ""Unescaped Data handed to the SigComp dissector"");
proto_tree_add_item(VAR_5, VAR_29, VAR_6, 0, -1, VAR_20);
if (VAR_14 == TRUE) {
dissect_sigcomp_common(VAR_6, VAR_1, VAR_5);
} else {
proto_tree_add_expert(VAR_5, VAR_1, &VAR_30, VAR_6, 0, -1);
}
if ( VAR_8 < VAR_9) {
goto try_again;
}
return VAR_8;
}",,"static int
dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_data _U_)
{
    proto_item *ti;
    proto_tree *sigcomp_tree;
    tvbuff_t   *unescaped_tvb;

    guint8     *buff;
    int         offset = 0;
    int         length;
    guint8      octet;
    guint16     data;
    int         i;
    int         n;
    gboolean    end_off_message;

    top_tree = tree;

    /* Is this SIGCOMP ? */
    data = tvb_get_ntohs(tvb, offset);
    if (data == 0xffff) {
        /* delimiter */
        offset = offset + 2;
        octet = tvb_get_guint8(tvb,offset);
    } else {
        octet = tvb_get_guint8(tvb,offset);
    }
    if ((octet  & 0xf8) != 0xf8)
     return offset;

    /* Search for delimiter 0xffff in the remain tvb buffer */
    length = tvb_reported_length_remaining(tvb, offset);
    for (i=0; i<(length-1); ++i) {
        /* Loop end criteria is (length-1) because we take 2 bytes each loop */
        data = tvb_get_ntohs(tvb, offset+i);
        if (0xffff == data) break;
    }
    if (i >= (length-1)) {
        /* SIGCOMP may be subdissector of SIP, so we use
         * pinfo->saved_can_desegment to determine whether do desegment
         * as well as pinfo->can_desegment */
        if (pinfo->can_desegment || pinfo->saved_can_desegment) {
            /* Delimiter oxffff was not found, not a complete SIGCOMP PDU */
            pinfo->desegment_offset = offset;
            pinfo->desegment_len=DESEGMENT_ONE_MORE_SEGMENT;
            return -1;
        }
    }

    /* Make entries in Protocol column and Info column on summary display */
    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""SIGCOMP"");

    col_clear(pinfo->cinfo, COL_INFO);

    length = tvb_reported_length(tvb);

try_again:
    /* create display subtree for the protocol */
    ti = proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);
    sigcomp_tree = proto_item_add_subtree(ti, ett_sigcomp);
    i=0;
    end_off_message = FALSE;
    buff = (guint8 *)wmem_alloc(pinfo->pool, length-offset);
    if (udvm_print_detail_level>2)
        proto_tree_add_item(sigcomp_tree, hf_sigcomp_starting_to_remove_escape_digits, tvb, offset, -1, ENC_NA);
    while ((offset < length) && (end_off_message == FALSE)) {
        octet = tvb_get_guint8(tvb,offset);
        if ( octet == 0xff ) {
            if ( offset +1 >= length ) {
                /* if the tvb is short don't check for the second escape digit */
                offset++;
                continue;
            }
            if (udvm_print_detail_level>2)
                proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_escape_digit_found, tvb, offset, 2,
                    ""              Escape digit found (0xFF)"");
            octet = tvb_get_guint8(tvb, offset+1);
            if ( octet == 0) {
                buff[i] = 0xff;
                offset = offset +2;
                i++;
                continue;
            }
            if ((octet > 0x7f) && (octet < 0xff )) {
                if (udvm_print_detail_level>2)
                    proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_illegal_escape_code, tvb, offset, 2,
                        ""              Illegal escape code"");
                offset += tvb_captured_length_remaining(tvb,offset);
                return offset;
            }
            if ( octet == 0xff) {
                if (udvm_print_detail_level>2)
                    proto_tree_add_none_format(sigcomp_tree, hf_sigcomp_end_of_sigcomp_message_indication_found, tvb, offset, 2,
                        ""              End of SigComp message indication found (0xFFFF)"");
                end_off_message = TRUE;
                offset = offset+2;
                continue;
            }
            buff[i] = 0xff;
            if (udvm_print_detail_level>2)
                proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
                            ""              Addr: %u tvb value(0x%0x) "", i, buff[i]);
            i++;
            offset = offset+2;
            if (udvm_print_detail_level>2)
            proto_tree_add_bytes_format(sigcomp_tree, hf_sigcomp_copying_bytes_literally, tvb, offset, octet,
                        NULL, ""              Copying %u bytes literally"",octet);
            if ( offset+octet >= length)
                /* if the tvb is short don't copy further than the end */
                octet = length - offset;
            for ( n=0; n < octet; n++ ) {
                buff[i] = tvb_get_guint8(tvb, offset);
                if (udvm_print_detail_level>2)
                    proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
                                ""                  Addr: %u tvb value(0x%0x) "", i, buff[i]);
                i++;
                offset++;
            }
            continue;
        }
        buff[i] = octet;
        if (udvm_print_detail_level>2)
            proto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],
                        ""              Addr: %u tvb value(0x%0x) "", i, buff[i]);

        i++;
        offset++;
    }
    unescaped_tvb = tvb_new_child_real_data(tvb, buff,i,i);

    add_new_data_source(pinfo, unescaped_tvb, ""Unescaped Data handed to the SigComp dissector"");

    proto_tree_add_item(sigcomp_tree, hf_sigcomp_data_for_sigcomp_dissector, unescaped_tvb, 0, -1, ENC_NA);
    if (end_off_message == TRUE) {
        dissect_sigcomp_common(unescaped_tvb, pinfo, sigcomp_tree);
    } else {
        proto_tree_add_expert(sigcomp_tree, pinfo, &ei_sigcomp_tcp_fragment, unescaped_tvb, 0, -1);
    }
    if ( offset < length) {
        goto try_again;
    }

    return offset;
}","static int
dissect_sigcomp_tcp(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)
{
    proto_item *VAR_4;
    proto_tree *VAR_5;
    tvbuff_t   *VAR_6;

    guint8     *VAR_7;
    int         VAR_8 = 0;
    int         VAR_9;
    guint8      VAR_10;
    guint16     VAR_11;
    int         VAR_12;
    int         VAR_13;
    gboolean    VAR_14;

    VAR_15 = VAR_2;

    /* COMMENT_0 */
    VAR_11 = tvb_get_ntohs(VAR_0, VAR_8);
    if (VAR_11 == 0xffff) {
        /* COMMENT_1 */
        VAR_8 = VAR_8 + 2;
        VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
    } else {
        VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
    }
    if ((VAR_10  & 0xf8) != 0xf8)
     return VAR_8;

    /* COMMENT_2 */
    VAR_9 = tvb_reported_length_remaining(VAR_0, VAR_8);
    for (VAR_12=0; VAR_12<(VAR_9-1); ++VAR_12) {
        /* COMMENT_3 */
        VAR_11 = tvb_get_ntohs(VAR_0, VAR_8+VAR_12);
        if (0xffff == VAR_11) break;
    }
    if (VAR_12 >= (VAR_9-1)) {
        /* COMMENT_4 */
                                                                       
                                             
        if (VAR_1->can_desegment || VAR_1->saved_can_desegment) {
            /* COMMENT_7 */
            VAR_1->desegment_offset = VAR_8;
            VAR_1->desegment_len=VAR_16;
            return -1;
        }
    }

    /* COMMENT_8 */
    col_set_str(VAR_1->cinfo, VAR_17, ""SIGCOMP"");

    col_clear(VAR_1->cinfo, VAR_18);

    VAR_9 = tvb_reported_length(VAR_0);

try_again:
    /* COMMENT_9 */
    VAR_4 = proto_tree_add_item(VAR_2, VAR_19, VAR_0, 0, -1, VAR_20);
    VAR_5 = proto_item_add_subtree(VAR_4, VAR_21);
    VAR_12=0;
    VAR_14 = FALSE;
    VAR_7 = (guint8 *)wmem_alloc(VAR_1->pool, VAR_9-VAR_8);
    if (VAR_22>2)
        proto_tree_add_item(VAR_5, VAR_23, VAR_0, VAR_8, -1, VAR_20);
    while ((VAR_8 < VAR_9) && (VAR_14 == FALSE)) {
        VAR_10 = tvb_get_guint8(VAR_0,VAR_8);
        if ( VAR_10 == 0xff ) {
            if ( VAR_8 +1 >= VAR_9 ) {
                /* COMMENT_10 */
                VAR_8++;
                continue;
            }
            if (VAR_22>2)
                proto_tree_add_none_format(VAR_5, VAR_24, VAR_0, VAR_8, 2,
                    ""              Escape digit found (0xFF)"");
            VAR_10 = tvb_get_guint8(VAR_0, VAR_8+1);
            if ( VAR_10 == 0) {
                VAR_7[VAR_12] = 0xff;
                VAR_8 = VAR_8 +2;
                VAR_12++;
                continue;
            }
            if ((VAR_10 > 0x7f) && (VAR_10 < 0xff )) {
                if (VAR_22>2)
                    proto_tree_add_none_format(VAR_5, VAR_25, VAR_0, VAR_8, 2,
                        ""              Illegal escape code"");
                VAR_8 += tvb_captured_length_remaining(VAR_0,VAR_8);
                return VAR_8;
            }
            if ( VAR_10 == 0xff) {
                if (VAR_22>2)
                    proto_tree_add_none_format(VAR_5, VAR_26, VAR_0, VAR_8, 2,
                        ""              End of SigComp message indication found (0xFFFF)"");
                VAR_14 = TRUE;
                VAR_8 = VAR_8+2;
                continue;
            }
            VAR_7[VAR_12] = 0xff;
            if (VAR_22>2)
                proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
                            ""              Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);
            VAR_12++;
            VAR_8 = VAR_8+2;
            if (VAR_22>2)
            proto_tree_add_bytes_format(VAR_5, VAR_28, VAR_0, VAR_8, VAR_10,
                        NULL, ""              Copying %u bytes literally"",VAR_10);
            if ( VAR_8+VAR_10 >= VAR_9)
                /* COMMENT_11 */
                VAR_10 = VAR_9 - VAR_8;
            for ( VAR_13=0; VAR_13 < VAR_10; VAR_13++ ) {
                VAR_7[VAR_12] = tvb_get_guint8(VAR_0, VAR_8);
                if (VAR_22>2)
                    proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
                                ""                  Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);
                VAR_12++;
                VAR_8++;
            }
            continue;
        }
        VAR_7[VAR_12] = VAR_10;
        if (VAR_22>2)
            proto_tree_add_uint_format(VAR_5, VAR_27, VAR_0, VAR_8, 1, VAR_7[VAR_12],
                        ""              Addr: %u tvb value(0x%0x) "", VAR_12, VAR_7[VAR_12]);

        VAR_12++;
        VAR_8++;
    }
    VAR_6 = tvb_new_child_real_data(VAR_0, VAR_7,VAR_12,VAR_12);

    add_new_data_source(VAR_1, VAR_6, ""Unescaped Data handed to the SigComp dissector"");

    proto_tree_add_item(VAR_5, VAR_29, VAR_6, 0, -1, VAR_20);
    if (VAR_14 == TRUE) {
        dissect_sigcomp_common(VAR_6, VAR_1, VAR_5);
    } else {
        proto_tree_add_expert(VAR_5, VAR_1, &VAR_30, VAR_6, 0, -1);
    }
    if ( VAR_8 < VAR_9) {
        goto try_again;
    }

    return VAR_8;
}",,"--- func_before
+++ func_after
@@ -52,7 +52,7 @@
 
     col_clear(pinfo->cinfo, COL_INFO);
 
-    length = tvb_captured_length_remaining(tvb,offset);
+    length = tvb_reported_length(tvb);
 
 try_again:
     /* create display subtree for the protocol */","{'deleted_lines': ['    length = tvb_captured_length_remaining(tvb,offset);'], 'added_lines': ['    length = tvb_reported_length(tvb);']}",True,"In Wireshark 2.2.0 to 2.2.12 and 2.4.0 to 2.4.4, the SIGCOMP dissector could crash. This was addressed in epan/dissectors/packet-sigcomp.c by correcting the extraction of the length value.",7.5,HIGH,2,valid,2018-02-11T19:52:42Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_asio_client.cc,ClientIO::init_env,"void ClientIO::init_env(CephContext *cct)
{
env.init(cct);
const auto& request = parser.get();
const auto& headers = request;
for (auto header = headers.begin(); header != headers.end(); ++header) {
const auto& field = header->name();     const auto& name = header->name_string();
const auto& value = header->value();
if (field == beast::http::field::content_length) {
env.set(""CONTENT_LENGTH"", value.to_string());
continue;
}
if (field == beast::http::field::content_type) {
env.set(""CONTENT_TYPE"", value.to_string());
continue;
}
static const boost::string_ref HTTP_{""HTTP_""};
char buf[name.size() + HTTP_.size() + 1];
auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);
for (auto src = name.begin(); src != name.end(); ++src, ++dest) {
if (*src == '-') {
*dest = '_';
} else {
*dest = std::toupper(*src);
}
}
*dest = '\0';
env.set(buf, value.to_string());
}
int major = request.version() / 10;
int minor = request.version() % 10;
env.set(""HTTP_VERSION"", std::to_string(major) + '.' + std::to_string(minor));
env.set(""REQUEST_METHOD"", request.method_string().to_string());
auto url = request.target();
auto pos = url.find('?');
if (pos != url.npos) {
auto query = url.substr(pos + 1);
env.set(""QUERY_STRING"", query.to_string());
url = url.substr(0, pos);
}
env.set(""REQUEST_URI"", url.to_string());
env.set(""SCRIPT_URI"", url.to_string()); 
char port_buf[16];
snprintf(port_buf, sizeof(port_buf), ""%d"", socket.local_endpoint().port());
env.set(""SERVER_PORT"", port_buf);
env.set(""REMOTE_ADDR"", socket.remote_endpoint().address().to_string());
}","void ClientIO::init_env(CephContext *VAR_0)
{
VAR_1.init(VAR_0);
const auto& VAR_2 = VAR_3.get();
const auto& VAR_4 = VAR_2;
for (auto VAR_5 = VAR_4.begin(); VAR_5 != VAR_4.end(); ++VAR_5) {
const auto& VAR_6 = VAR_5->name(); 
const auto& VAR_7 = VAR_5->name_string();
const auto& VAR_8 = VAR_5->value();
if (VAR_6 == beast::http::field::content_length) {
VAR_1.set(""CONTENT_LENGTH"", VAR_8.to_string());
continue;
}
if (VAR_6 == beast::http::field::content_type) {
VAR_1.set(""CONTENT_TYPE"", VAR_8.to_string());
continue;
}
static const boost::string_ref VAR_9{""HTTP_""};
char VAR_10[VAR_7.size() + VAR_9.size() + 1];
auto VAR_11 = std::copy(std::begin(VAR_9), std::end(VAR_9), VAR_10);
for (auto VAR_12 = VAR_7.begin(); VAR_12 != VAR_7.end(); ++VAR_12, ++VAR_11) {
if (*VAR_12 == '-') {
*VAR_11 = '_';
} else {
*VAR_11 = std::toupper(*VAR_12);
}
}
*VAR_11 = '\0';
VAR_1.set(VAR_10, VAR_8.to_string());
}
int VAR_13 = VAR_2.version() / 10;
int VAR_14 = VAR_2.version() % 10;
VAR_1.set(""HTTP_VERSION"", std::to_string(VAR_13) + '.' + std::to_string(VAR_14));
VAR_1.set(""REQUEST_METHOD"", VAR_2.method_string().to_string());
auto VAR_15 = VAR_2.target();
auto VAR_16 = VAR_15.find('?');
if (VAR_16 != VAR_15.npos) {
auto VAR_17 = VAR_15.substr(VAR_16 + 1);
VAR_1.set(""QUERY_STRING"", VAR_17.to_string());
VAR_15 = VAR_15.substr(0, VAR_16);
}
VAR_1.set(""REQUEST_URI"", VAR_15.to_string());
VAR_1.set(""SCRIPT_URI"", VAR_15.to_string()); 
char VAR_18[16];
snprintf(VAR_18, sizeof(VAR_18), ""%d"", VAR_19.local_endpoint().port());
VAR_1.set(""SERVER_PORT"", VAR_18);
VAR_1.set(""REMOTE_ADDR"", VAR_19.remote_endpoint().address().to_string());
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_asio_client.cc/vul/before/0.json,"int ClientIO::init_env(CephContext *cct)
{
  env.init(cct);

  const auto& request = parser.get();
  const auto& headers = request;
  for (auto header = headers.begin(); header != headers.end(); ++header) {
    const auto& field = header->name(); // enum type for known headers
    const auto& name = header->name_string();
    const auto& value = header->value();

    if (field == beast::http::field::content_length) {
      env.set(""CONTENT_LENGTH"", value.to_string());
      continue;
    }
    if (field == beast::http::field::content_type) {
      env.set(""CONTENT_TYPE"", value.to_string());
      continue;
    }

    static const boost::string_ref HTTP_{""HTTP_""};

    char buf[name.size() + HTTP_.size() + 1];
    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);
    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {
      if (*src == '-') {
        *dest = '_';
      } else {
        *dest = std::toupper(*src);
      }
    }
    *dest = '\0';

    env.set(buf, value.to_string());
  }

  int major = request.version() / 10;
  int minor = request.version() % 10;
  env.set(""HTTP_VERSION"", std::to_string(major) + '.' + std::to_string(minor));

  env.set(""REQUEST_METHOD"", request.method_string().to_string());

  // split uri from query
  auto url = request.target();
  auto pos = url.find('?');
  if (pos != url.npos) {
    auto query = url.substr(pos + 1);
    env.set(""QUERY_STRING"", query.to_string());
    url = url.substr(0, pos);
  }
  env.set(""REQUEST_URI"", url.to_string());
  env.set(""SCRIPT_URI"", url.to_string()); /* FIXME */

  char port_buf[16];
  snprintf(port_buf, sizeof(port_buf), ""%d"", socket.local_endpoint().port());
  env.set(""SERVER_PORT"", port_buf);
  env.set(""REMOTE_ADDR"", socket.remote_endpoint().address().to_string());
  // TODO: set SERVER_PORT_SECURE if using ssl
  // TODO: set REMOTE_USER if authenticated
  return 0;
}","int ClientIO::init_env(CephContext *VAR_0)
{
  VAR_1.init(VAR_0);

  const auto& VAR_2 = VAR_3.get();
  const auto& VAR_4 = VAR_2;
  for (auto VAR_5 = VAR_4.begin(); VAR_5 != VAR_4.end(); ++VAR_5) {
    const auto& VAR_6 = VAR_5->name(); /* COMMENT_0 */
    const auto& VAR_7 = VAR_5->name_string();
    const auto& VAR_8 = VAR_5->value();

    if (VAR_6 == beast::http::field::content_length) {
      VAR_1.set(""CONTENT_LENGTH"", VAR_8.to_string());
      continue;
    }
    if (VAR_6 == beast::http::field::content_type) {
      VAR_1.set(""CONTENT_TYPE"", VAR_8.to_string());
      continue;
    }

    static const boost::string_ref VAR_9{""HTTP_""};

    char VAR_10[VAR_7.size() + VAR_9.size() + 1];
    auto VAR_11 = std::copy(std::begin(VAR_9), std::end(VAR_9), VAR_10);
    for (auto VAR_12 = VAR_7.begin(); VAR_12 != VAR_7.end(); ++VAR_12, ++VAR_11) {
      if (*VAR_12 == '-') {
        *VAR_11 = '_';
      } else {
        *VAR_11 = std::toupper(*VAR_12);
      }
    }
    *VAR_11 = '\0';

    VAR_1.set(VAR_10, VAR_8.to_string());
  }

  int VAR_13 = VAR_2.version() / 10;
  int VAR_14 = VAR_2.version() % 10;
  VAR_1.set(""HTTP_VERSION"", std::to_string(VAR_13) + '.' + std::to_string(VAR_14));

  VAR_1.set(""REQUEST_METHOD"", VAR_2.method_string().to_string());

  /* COMMENT_1 */
  auto VAR_15 = VAR_2.target();
  auto VAR_16 = VAR_15.find('?');
  if (VAR_16 != VAR_15.npos) {
    auto VAR_17 = VAR_15.substr(VAR_16 + 1);
    VAR_1.set(""QUERY_STRING"", VAR_17.to_string());
    VAR_15 = VAR_15.substr(0, VAR_16);
  }
  VAR_1.set(""REQUEST_URI"", VAR_15.to_string());
  VAR_1.set(""SCRIPT_URI"", VAR_15.to_string()); /* COMMENT_2 */

  char VAR_18[16];
  snprintf(VAR_18, sizeof(VAR_18), ""%d"", VAR_19.local_endpoint().port());
  VAR_1.set(""SERVER_PORT"", VAR_18);
  VAR_1.set(""REMOTE_ADDR"", VAR_19.remote_endpoint().address().to_string());
  /* COMMENT_3 */
  /* COMMENT_4 */
  return 0;
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_asio_client.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void ClientIO::init_env(CephContext *cct)
+int ClientIO::init_env(CephContext *cct)
 {
   env.init(cct);
 
@@ -57,4 +57,5 @@
   env.set(""REMOTE_ADDR"", socket.remote_endpoint().address().to_string());
   // TODO: set SERVER_PORT_SECURE if using ssl
   // TODO: set REMOTE_USER if authenticated
+  return 0;
 }","{'deleted_lines': ['void ClientIO::init_env(CephContext *cct)'], 'added_lines': ['int ClientIO::init_env(CephContext *cct)', '  return 0;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_fcgi.cc,RGWFCGX::init_env,"void RGWFCGX::init_env(CephContext* const cct)
{
env.init(cct, (char **)fcgx->envp);
}","void RGWFCGX::init_env(CephContext* const VAR_0)
{
VAR_1.init(VAR_0, (char **)VAR_2->envp);
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_fcgi.cc/vul/before/0.json,"int RGWFCGX::init_env(CephContext* const cct)
{
  env.init(cct, (char **)fcgx->envp);
  return 0;
}","int RGWFCGX::init_env(CephContext* const VAR_0)
{
  VAR_1.init(VAR_0, (char **)VAR_2->envp);
  return 0;
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_fcgi.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
-void RGWFCGX::init_env(CephContext* const cct)
+int RGWFCGX::init_env(CephContext* const cct)
 {
   env.init(cct, (char **)fcgx->envp);
+  return 0;
 }","{'deleted_lines': ['void RGWFCGX::init_env(CephContext* const cct)'], 'added_lines': ['int RGWFCGX::init_env(CephContext* const cct)', '  return 0;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_process.cc,process_request,"int process_request(RGWRados* const store,
RGWREST* const rest,
RGWRequest* const req,
const std::string& frontend_prefix,
const rgw_auth_registry_t& auth_registry,
RGWRestfulIO* const client_io,
OpsLogSocket* const olog,
int* http_ret)
{
int ret = 0;
client_io->init(g_ceph_context);
req->log_init();
dout(1) << ""====== starting new request req="" << hex << req << dec
<< "" ====="" << dendl;
perfcounter->inc(l_rgw_req);
RGWEnv& rgw_env = client_io->get_env();
RGWUserInfo userinfo;
struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);
struct req_state *s = &rstate;
RGWObjectCtx rados_ctx(store, s);
s->obj_ctx = &rados_ctx;
s->req_id = store->unique_id(req->id);
s->trans_id = store->unique_trans_id(req->id);
s->host_id = store->host_id;
req->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str());
RGWOp* op = NULL;
int init_error = 0;
bool should_log = false;
RGWRESTMgr *mgr;
RGWHandler_REST *handler = rest->get_handler(store, s,
auth_registry,
frontend_prefix,
client_io, &mgr, &init_error);
if (init_error != 0) {
abort_early(s, NULL, init_error, NULL);
goto done;
}
dout(10) << ""handler="" << typeid(*handler).name() << dendl;
should_log = mgr->get_logging();
req->log_format(s, ""getting op %d"", s->op);
op = handler->get_op(store);
if (!op) {
abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler);
goto done;
}
req->op = op;
dout(10) << ""op="" << typeid(*op).name() << dendl;
s->op_type = op->get_type();
req->log(s, ""verifying requester"");
ret = op->verify_requester(auth_registry);
if (ret < 0) {
dout(10) << ""failed to authorize request"" << dendl;
abort_early(s, NULL, ret, handler);
goto done;
}
if (nullptr == s->auth.identity) {
s->auth.identity = rgw::auth::transform_old_authinfo(s);
}
req->log(s, ""normalizing buckets and tenants"");
ret = handler->postauth_init();
if (ret < 0) {
dout(10) << ""failed to run post-auth init"" << dendl;
abort_early(s, op, ret, handler);
goto done;
}
if (s->user->suspended) {
dout(10) << ""user is suspended, uid="" << s->user->user_id << dendl;
abort_early(s, op, -ERR_USER_SUSPENDED, handler);
goto done;
}
ret = rgw_process_authenticated(handler, op, req, s);
if (ret < 0) {
abort_early(s, op, ret, handler);
goto done;
}
done:
try {
client_io->complete_request();
} catch (rgw::io::Exception& e) {
dout(0) << ""ERROR: client_io->complete_request() returned ""
<< e.what() << dendl;
}
if (should_log) {
rgw_log_op(store, rest, s, (op ? op->name() : ""unknown""), olog);
}
if (http_ret != nullptr) {
*http_ret = s->err.http_ret;
}
int op_ret = 0;
if (op) {
op_ret = op->get_ret();
}
req->log_format(s, ""op status=%d"", op_ret);
req->log_format(s, ""http status=%d"", s->err.http_ret);
if (handler)
handler->put_op(op);
rest->put_handler(handler);
dout(1) << ""====== req done req="" << hex << req << dec
<< "" op status="" << op_ret
<< "" http_status="" << s->err.http_ret
<< "" ======""
<< dendl;
return (ret < 0 ? ret : s->err.ret);
}","int process_request(RGWRados* const VAR_0,
RGWREST* const VAR_1,
RGWRequest* const VAR_2,
const std::string& VAR_3,
const rgw_auth_registry_t& VAR_4,
RGWRestfulIO* const VAR_5,
OpsLogSocket* const VAR_6,
int* VAR_7)
{
int VAR_8 = 0;
VAR_5->init(VAR_9);
VAR_2->log_init();
dout(1) << ""====== starting new request req="" << VAR_10 << VAR_2 << VAR_11
<< "" ====="" << VAR_12;
VAR_13->inc(VAR_14);
RGWEnv& VAR_15 = VAR_5->get_env();
RGWUserInfo VAR_16;
struct req_state VAR_17(VAR_9, &VAR_15, &VAR_16);
struct req_state *VAR_18 = &VAR_17;
RGWObjectCtx rados_ctx(store, s);
s->obj_ctx = &VAR_19;
s->req_id = store->unique_id(VAR_2->id);
s->trans_id = store->unique_trans_id(VAR_2->id);
s->host_id = store->host_id;
VAR_2->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str());
RGWOp* VAR_20 = NULL;
int VAR_21 = 0;
bool VAR_22 = false;
RGWRESTMgr *VAR_23;
RGWHandler_REST *VAR_24 = VAR_1->get_handler(store, s,
VAR_4,
VAR_3,
VAR_5, &VAR_23, &VAR_21);
if (VAR_21 != 0) {
abort_early(s, NULL, VAR_21, NULL);
goto done;
}
dout(10) << ""handler="" << typeid(*VAR_24).name() << VAR_12;
VAR_22 = VAR_23->get_logging();
VAR_2->log_format(s, ""getting op %d"", s->op);
VAR_20 = VAR_24->get_op(store);
if (!VAR_20) {
abort_early(s, NULL, -VAR_25, VAR_24);
goto done;
}
VAR_2->op = VAR_20;
dout(10) << ""op="" << typeid(*VAR_20).name() << VAR_12;
s->op_type = VAR_20->get_type();
VAR_2->log(s, ""verifying requester"");
VAR_8 = VAR_20->verify_requester(VAR_4);
if (VAR_8 < 0) {
dout(10) << ""failed to authorize request"" << VAR_12;
abort_early(s, NULL, VAR_8, VAR_24);
goto done;
}
if (nullptr == s->auth.identity) {
s->auth.identity = rgw::auth::transform_old_authinfo(s);
}
VAR_2->log(s, ""normalizing buckets and tenants"");
VAR_8 = VAR_24->postauth_init();
if (VAR_8 < 0) {
dout(10) << ""failed to run post-auth init"" << VAR_12;
abort_early(s, VAR_20, VAR_8, VAR_24);
goto done;
}
if (s->user->suspended) {
dout(10) << ""user is suspended, uid="" << s->user->user_id << VAR_12;
abort_early(s, VAR_20, -VAR_26, VAR_24);
goto done;
}
VAR_8 = rgw_process_authenticated(VAR_24, VAR_20, VAR_2, s);
if (VAR_8 < 0) {
abort_early(s, VAR_20, VAR_8, VAR_24);
goto done;
}
done:
try {
VAR_5->complete_request();
} catch (rgw::io::Exception& VAR_27) {
dout(0) << ""ERROR: client_io->complete_request() returned ""
<< VAR_27.what() << VAR_12;
}
if (VAR_22) {
rgw_log_op(store, VAR_1, s, (VAR_20 ? VAR_20->name() : ""unknown""), VAR_6);
}
if (VAR_7 != nullptr) {
*VAR_7 = s->err.http_ret;
}
int VAR_28 = 0;
if (VAR_20) {
VAR_28 = VAR_20->get_ret();
}
VAR_2->log_format(s, ""op status=%d"", VAR_28);
VAR_2->log_format(s, ""http status=%d"", s->err.http_ret);
if (VAR_24)
VAR_24->put_op(VAR_20);
VAR_1->put_handler(VAR_24);
dout(1) << ""====== req done req="" << VAR_10 << VAR_2 << VAR_11
<< "" op status="" << VAR_28
<< "" http_status="" << s->err.http_ret
<< "" ======""
<< VAR_12;
return (VAR_8 < 0 ? VAR_8 : s->err.ret);
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_process.cc/vul/before/0.json,"int process_request(RGWRados* const store,
                    RGWREST* const rest,
                    RGWRequest* const req,
                    const std::string& frontend_prefix,
                    const rgw_auth_registry_t& auth_registry,
                    RGWRestfulIO* const client_io,
                    OpsLogSocket* const olog,
                    int* http_ret)
{
  int ret = client_io->init(g_ceph_context);

  req->log_init();

  dout(1) << ""====== starting new request req="" << hex << req << dec
	  << "" ====="" << dendl;
  perfcounter->inc(l_rgw_req);

  RGWEnv& rgw_env = client_io->get_env();

  RGWUserInfo userinfo;

  struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);
  struct req_state *s = &rstate;

  RGWObjectCtx rados_ctx(store, s);
  s->obj_ctx = &rados_ctx;

  if (ret < 0) {
    s->cio = client_io;
    abort_early(s, nullptr, ret, nullptr);
    return ret;
  }

  s->req_id = store->unique_id(req->id);
  s->trans_id = store->unique_trans_id(req->id);
  s->host_id = store->host_id;

  req->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str());

  RGWOp* op = nullptr;
  int init_error = 0;
  bool should_log = false;
  RGWRESTMgr *mgr;
  RGWHandler_REST *handler = rest->get_handler(store, s,
                                               auth_registry,
                                               frontend_prefix,
                                               client_io, &mgr, &init_error);
  if (init_error != 0) {
    abort_early(s, nullptr, init_error, nullptr);
    goto done;
  }
  dout(10) << ""handler="" << typeid(*handler).name() << dendl;

  should_log = mgr->get_logging();

  req->log_format(s, ""getting op %d"", s->op);
  op = handler->get_op(store);
  if (!op) {
    abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler);
    goto done;
  }

  req->op = op;
  dout(10) << ""op="" << typeid(*op).name() << dendl;

  s->op_type = op->get_type();

  req->log(s, ""verifying requester"");
  ret = op->verify_requester(auth_registry);
  if (ret < 0) {
    dout(10) << ""failed to authorize request"" << dendl;
    abort_early(s, NULL, ret, handler);
    goto done;
  }

  /* FIXME: remove this after switching all handlers to the new authentication
   * infrastructure. */
  if (nullptr == s->auth.identity) {
    s->auth.identity = rgw::auth::transform_old_authinfo(s);
  }

  req->log(s, ""normalizing buckets and tenants"");
  ret = handler->postauth_init();
  if (ret < 0) {
    dout(10) << ""failed to run post-auth init"" << dendl;
    abort_early(s, op, ret, handler);
    goto done;
  }

  if (s->user->suspended) {
    dout(10) << ""user is suspended, uid="" << s->user->user_id << dendl;
    abort_early(s, op, -ERR_USER_SUSPENDED, handler);
    goto done;
  }

  ret = rgw_process_authenticated(handler, op, req, s);
  if (ret < 0) {
    abort_early(s, op, ret, handler);
    goto done;
  }
done:
  try {
    client_io->complete_request();
  } catch (rgw::io::Exception& e) {
    dout(0) << ""ERROR: client_io->complete_request() returned ""
            << e.what() << dendl;
  }

  if (should_log) {
    rgw_log_op(store, rest, s, (op ? op->name() : ""unknown""), olog);
  }

  if (http_ret != nullptr) {
    *http_ret = s->err.http_ret;
  }
  int op_ret = 0;
  if (op) {
    op_ret = op->get_ret();
  }

  req->log_format(s, ""op status=%d"", op_ret);
  req->log_format(s, ""http status=%d"", s->err.http_ret);

  if (handler)
    handler->put_op(op);
  rest->put_handler(handler);

  dout(1) << ""====== req done req="" << hex << req << dec
	  << "" op status="" << op_ret
	  << "" http_status="" << s->err.http_ret
	  << "" ======""
	  << dendl;

  return (ret < 0 ? ret : s->err.ret);
}","int process_request(RGWRados* const VAR_0,
                    RGWREST* const VAR_1,
                    RGWRequest* const VAR_2,
                    const std::string& VAR_3,
                    const rgw_auth_registry_t& VAR_4,
                    RGWRestfulIO* const VAR_5,
                    OpsLogSocket* const VAR_6,
                    int* VAR_7)
{
  int VAR_8 = VAR_5->init(VAR_9);

  VAR_2->log_init();

  dout(1) << ""====== starting new request req="" << VAR_10 << VAR_2 << VAR_11
	  << "" ====="" << VAR_12;
  VAR_13->inc(VAR_14);

  RGWEnv& VAR_15 = VAR_5->get_env();

  RGWUserInfo VAR_16;

  struct req_state VAR_17(VAR_9, &VAR_15, &VAR_16);
  struct req_state *VAR_18 = &VAR_17;

  RGWObjectCtx rados_ctx(store, s);
  s->obj_ctx = &VAR_19;

  if (VAR_8 < 0) {
    s->cio = VAR_5;
    abort_early(s, nullptr, VAR_8, nullptr);
    return VAR_8;
  }

  s->req_id = store->unique_id(VAR_2->id);
  s->trans_id = store->unique_trans_id(VAR_2->id);
  s->host_id = store->host_id;

  VAR_2->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str());

  RGWOp* VAR_20 = nullptr;
  int VAR_21 = 0;
  bool VAR_22 = false;
  RGWRESTMgr *VAR_23;
  RGWHandler_REST *VAR_24 = VAR_1->get_handler(store, s,
                                               VAR_4,
                                               VAR_3,
                                               VAR_5, &VAR_23, &VAR_21);
  if (VAR_21 != 0) {
    abort_early(s, nullptr, VAR_21, nullptr);
    goto done;
  }
  dout(10) << ""handler="" << typeid(*VAR_24).name() << VAR_12;

  VAR_22 = VAR_23->get_logging();

  VAR_2->log_format(s, ""getting op %d"", s->op);
  VAR_20 = VAR_24->get_op(store);
  if (!VAR_20) {
    abort_early(s, NULL, -VAR_25, VAR_24);
    goto done;
  }

  VAR_2->op = VAR_20;
  dout(10) << ""op="" << typeid(*VAR_20).name() << VAR_12;

  s->op_type = VAR_20->get_type();

  VAR_2->log(s, ""verifying requester"");
  VAR_8 = VAR_20->verify_requester(VAR_4);
  if (VAR_8 < 0) {
    dout(10) << ""failed to authorize request"" << VAR_12;
    abort_early(s, NULL, VAR_8, VAR_24);
    goto done;
  }

  /* COMMENT_0 */
                       
  if (nullptr == s->auth.identity) {
    s->auth.identity = rgw::auth::transform_old_authinfo(s);
  }

  VAR_2->log(s, ""normalizing buckets and tenants"");
  VAR_8 = VAR_24->postauth_init();
  if (VAR_8 < 0) {
    dout(10) << ""failed to run post-auth init"" << VAR_12;
    abort_early(s, VAR_20, VAR_8, VAR_24);
    goto done;
  }

  if (s->user->suspended) {
    dout(10) << ""user is suspended, uid="" << s->user->user_id << VAR_12;
    abort_early(s, VAR_20, -VAR_26, VAR_24);
    goto done;
  }

  VAR_8 = rgw_process_authenticated(VAR_24, VAR_20, VAR_2, s);
  if (VAR_8 < 0) {
    abort_early(s, VAR_20, VAR_8, VAR_24);
    goto done;
  }
done:
  try {
    VAR_5->complete_request();
  } catch (rgw::io::Exception& VAR_27) {
    dout(0) << ""ERROR: client_io->complete_request() returned ""
            << VAR_27.what() << VAR_12;
  }

  if (VAR_22) {
    rgw_log_op(store, VAR_1, s, (VAR_20 ? VAR_20->name() : ""unknown""), VAR_6);
  }

  if (VAR_7 != nullptr) {
    *VAR_7 = s->err.http_ret;
  }
  int VAR_28 = 0;
  if (VAR_20) {
    VAR_28 = VAR_20->get_ret();
  }

  VAR_2->log_format(s, ""op status=%d"", VAR_28);
  VAR_2->log_format(s, ""http status=%d"", s->err.http_ret);

  if (VAR_24)
    VAR_24->put_op(VAR_20);
  VAR_1->put_handler(VAR_24);

  dout(1) << ""====== req done req="" << VAR_10 << VAR_2 << VAR_11
	  << "" op status="" << VAR_28
	  << "" http_status="" << s->err.http_ret
	  << "" ======""
	  << VAR_12;

  return (VAR_8 < 0 ? VAR_8 : s->err.ret);
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_process.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,9 +7,7 @@
                     OpsLogSocket* const olog,
                     int* http_ret)
 {
-  int ret = 0;
-
-  client_io->init(g_ceph_context);
+  int ret = client_io->init(g_ceph_context);
 
   req->log_init();
 
@@ -27,13 +25,19 @@
   RGWObjectCtx rados_ctx(store, s);
   s->obj_ctx = &rados_ctx;
 
+  if (ret < 0) {
+    s->cio = client_io;
+    abort_early(s, nullptr, ret, nullptr);
+    return ret;
+  }
+
   s->req_id = store->unique_id(req->id);
   s->trans_id = store->unique_trans_id(req->id);
   s->host_id = store->host_id;
 
   req->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str());
 
-  RGWOp* op = NULL;
+  RGWOp* op = nullptr;
   int init_error = 0;
   bool should_log = false;
   RGWRESTMgr *mgr;
@@ -42,7 +46,7 @@
                                                frontend_prefix,
                                                client_io, &mgr, &init_error);
   if (init_error != 0) {
-    abort_early(s, NULL, init_error, NULL);
+    abort_early(s, nullptr, init_error, nullptr);
     goto done;
   }
   dout(10) << ""handler="" << typeid(*handler).name() << dendl;","{'deleted_lines': ['  int ret = 0;', '', '  client_io->init(g_ceph_context);', '  RGWOp* op = NULL;', '    abort_early(s, NULL, init_error, NULL);'], 'added_lines': ['  int ret = client_io->init(g_ceph_context);', '  if (ret < 0) {', '    s->cio = client_io;', '    abort_early(s, nullptr, ret, nullptr);', '    return ret;', '  }', '', '  RGWOp* op = nullptr;', '    abort_early(s, nullptr, init_error, nullptr);']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_client_io.cc,BasicClient::init,"void BasicClient::init(CephContext *cct) {
init_env(cct);
if (cct->_conf->subsys.should_gather(ceph_subsys_rgw, 20)) {
const auto& env_map = get_env().get_map();
for (const auto& iter: env_map) {
rgw::crypt_sanitize::env x{iter.first, iter.second};
ldout(cct, 20) << iter.first << ""="" << (x) << dendl;
}
}
}","void BasicClient::init(CephContext *VAR_0) {
init_env(VAR_0);
if (VAR_0->_conf->subsys.should_gather(VAR_1, 20)) {
const auto& VAR_2 = get_env().get_map();
for (const auto& VAR_3: VAR_2) {
rgw::crypt_sanitize::env VAR_4{VAR_3.first, VAR_3.second};
ldout(VAR_0, 20) << VAR_3.first << ""="" << (VAR_4) << VAR_5;
}
}
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_client_io.cc/vul/before/0.json,"[[nodiscard]] int BasicClient::init(CephContext *cct) {
  int init_error = init_env(cct);

  if (init_error != 0)
    return init_error;

  if (cct->_conf->subsys.should_gather(ceph_subsys_rgw, 20)) {
    const auto& env_map = get_env().get_map();

    for (const auto& iter: env_map) {
      rgw::crypt_sanitize::env x{iter.first, iter.second};
      ldout(cct, 20) << iter.first << ""="" << (x) << dendl;
    }
  }
  return init_error;
}","[[VAR_0]] int BasicClient::init(CephContext *VAR_1) {
  int VAR_2 = init_env(VAR_1);

  if (VAR_2 != 0)
    return VAR_2;

  if (VAR_1->_conf->subsys.should_gather(VAR_3, 20)) {
    const auto& VAR_4 = get_env().get_map();

    for (const auto& VAR_5: VAR_4) {
      rgw::crypt_sanitize::env VAR_6{VAR_5.first, VAR_5.second};
      ldout(VAR_1, 20) << VAR_5.first << ""="" << (VAR_6) << VAR_7;
    }
  }
  return VAR_2;
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_client_io.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
-void BasicClient::init(CephContext *cct) {
-  init_env(cct);
+[[nodiscard]] int BasicClient::init(CephContext *cct) {
+  int init_error = init_env(cct);
+
+  if (init_error != 0)
+    return init_error;
 
   if (cct->_conf->subsys.should_gather(ceph_subsys_rgw, 20)) {
     const auto& env_map = get_env().get_map();
@@ -9,4 +12,5 @@
       ldout(cct, 20) << iter.first << ""="" << (x) << dendl;
     }
   }
+  return init_error;
 }","{'deleted_lines': ['void BasicClient::init(CephContext *cct) {', '  init_env(cct);'], 'added_lines': ['[[nodiscard]] int BasicClient::init(CephContext *cct) {', '  int init_error = init_env(cct);', '', '  if (init_error != 0)', '    return init_error;', '  return init_error;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_lib.h,init_env,"void init_env(CephContext *cct) override {
env.init(cct);
}","void init_env(CephContext *VAR_0) override {
VAR_1.init(VAR_0);
}",,"int init_env(CephContext *cct) override {
      env.init(cct);
      return 0;
    }","int init_env(CephContext *VAR_0) override {
      VAR_1.init(VAR_0);
      return 0;
    }",,"--- func_before
+++ func_after
@@ -1,3 +1,4 @@
-void init_env(CephContext *cct) override {
+int init_env(CephContext *cct) override {
       env.init(cct);
+      return 0;
     }","{'deleted_lines': ['void init_env(CephContext *cct) override {'], 'added_lines': ['int init_env(CephContext *cct) override {', '      return 0;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_civetweb.cc,RGWCivetWeb::init_env,"void RGWCivetWeb::init_env(CephContext *cct)
{
env.init(cct);
const struct mg_request_info* info = mg_get_request_info(conn);
if (! info) {
return;
}
for (int i = 0; i < info->num_headers; i++) {
const struct mg_request_info::mg_header* header = &info->http_headers[i];
const boost::string_ref name(header->name);
const auto& value = header->value;
if (boost::algorithm::iequals(name, ""content-length"")) {
env.set(""CONTENT_LENGTH"", value);
continue;
}
if (boost::algorithm::iequals(name, ""content-type"")) {
env.set(""CONTENT_TYPE"", value);
continue;
}
if (boost::algorithm::iequals(name, ""connection"")) {
explicit_keepalive = boost::algorithm::iequals(value, ""keep-alive"");
explicit_conn_close = boost::algorithm::iequals(value, ""close"");
}
static const boost::string_ref HTTP_{""HTTP_""};
char buf[name.size() + HTTP_.size() + 1];
auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);
for (auto src = name.begin(); src != name.end(); ++src, ++dest) {
if (*src == '-') {
*dest = '_';
} else {
*dest = std::toupper(*src);
}
}
*dest = '\0';
env.set(buf, value);
}
env.set(""REMOTE_ADDR"", info->remote_addr);
env.set(""REQUEST_METHOD"", info->request_method);
env.set(""HTTP_VERSION"", info->http_version);
env.set(""REQUEST_URI"", info->request_uri);   env.set(""SCRIPT_URI"", info->uri); 
if (info->query_string) {
env.set(""QUERY_STRING"", info->query_string);
}
if (info->remote_user) {
env.set(""REMOTE_USER"", info->remote_user);
}
if (port <= 0)
lderr(cct) << ""init_env: bug: invalid port number"" << dendl;
char port_buf[16];
snprintf(port_buf, sizeof(port_buf), ""%d"", port);
env.set(""SERVER_PORT"", port_buf);
if (info->is_ssl) {
env.set(""SERVER_PORT_SECURE"", port_buf);
}
}","void RGWCivetWeb::init_env(CephContext *VAR_0)
{
VAR_1.init(VAR_0);
const struct mg_request_info* VAR_2 = mg_get_request_info(VAR_3);
if (! VAR_2) {
return;
}
for (int VAR_4 = 0; VAR_4 < VAR_2->num_headers; VAR_4++) {
const struct mg_request_info::mg_header* VAR_5 = &VAR_2->http_headers[VAR_4];
const boost::string_ref VAR_6(VAR_5->name);
const auto& VAR_7 = VAR_5->value;
if (boost::algorithm::iequals(VAR_6, ""content-length"")) {
VAR_1.set(""CONTENT_LENGTH"", VAR_7);
continue;
}
if (boost::algorithm::iequals(VAR_6, ""content-type"")) {
VAR_1.set(""CONTENT_TYPE"", VAR_7);
continue;
}
if (boost::algorithm::iequals(VAR_6, ""connection"")) {
VAR_8 = boost::algorithm::iequals(VAR_7, ""keep-alive"");
VAR_9 = boost::algorithm::iequals(VAR_7, ""close"");
}
static const boost::string_ref VAR_10{""HTTP_""};
char VAR_11[VAR_6.size() + VAR_10.size() + 1];
auto VAR_12 = std::copy(std::begin(VAR_10), std::end(VAR_10), VAR_11);
for (auto VAR_13 = VAR_6.begin(); VAR_13 != VAR_6.end(); ++VAR_13, ++VAR_12) {
if (*VAR_13 == '-') {
*VAR_12 = '_';
} else {
*VAR_12 = std::toupper(*VAR_13);
}
}
*VAR_12 = '\0';
VAR_1.set(VAR_11, VAR_7);
}
VAR_1.set(""REMOTE_ADDR"", VAR_2->remote_addr);
VAR_1.set(""REQUEST_METHOD"", VAR_2->request_method);
VAR_1.set(""HTTP_VERSION"", VAR_2->http_version);
VAR_1.set(""REQUEST_URI"", VAR_2->request_uri); 
VAR_1.set(""SCRIPT_URI"", VAR_2->uri); 
if (VAR_2->query_string) {
VAR_1.set(""QUERY_STRING"", VAR_2->query_string);
}
if (VAR_2->remote_user) {
VAR_1.set(""REMOTE_USER"", VAR_2->remote_user);
}
if (VAR_14 <= 0)
lderr(VAR_0) << ""init_env: bug: invalid port number"" << VAR_15;
char VAR_16[16];
snprintf(VAR_16, sizeof(VAR_16), ""%d"", VAR_14);
VAR_1.set(""SERVER_PORT"", VAR_16);
if (VAR_2->is_ssl) {
VAR_1.set(""SERVER_PORT_SECURE"", VAR_16);
}
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_civetweb.cc/vul/before/0.json,"int RGWCivetWeb::init_env(CephContext *cct)
{
  env.init(cct);
  const struct mg_request_info* info = mg_get_request_info(conn);

  if (! info) {
    // request info is NULL; we have no info about the connection
    return -EINVAL;
  }

  for (int i = 0; i < info->num_headers; i++) {
    const struct mg_request_info::mg_header* header = &info->http_headers[i];

    if (header->name == nullptr || header->value==nullptr) {
      lderr(cct) << ""client supplied malformatted headers"" << dendl;
      return -EINVAL;
    }

    const boost::string_ref name(header->name);
    const auto& value = header->value;

    if (boost::algorithm::iequals(name, ""content-length"")) {
      env.set(""CONTENT_LENGTH"", value);
      continue;
    }
    if (boost::algorithm::iequals(name, ""content-type"")) {
      env.set(""CONTENT_TYPE"", value);
      continue;
    }
    if (boost::algorithm::iequals(name, ""connection"")) {
      explicit_keepalive = boost::algorithm::iequals(value, ""keep-alive"");
      explicit_conn_close = boost::algorithm::iequals(value, ""close"");
    }

    static const boost::string_ref HTTP_{""HTTP_""};

    char buf[name.size() + HTTP_.size() + 1];
    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);
    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {
      if (*src == '-') {
        *dest = '_';
      } else {
        *dest = std::toupper(*src);
      }
    }
    *dest = '\0';

    env.set(buf, value);
  }

  env.set(""REMOTE_ADDR"", info->remote_addr);
  env.set(""REQUEST_METHOD"", info->request_method);
  env.set(""HTTP_VERSION"", info->http_version);
  env.set(""REQUEST_URI"", info->request_uri); // get the full uri, we anyway handle abs uris later
  env.set(""SCRIPT_URI"", info->uri); /* FIXME */
  if (info->query_string) {
    env.set(""QUERY_STRING"", info->query_string);
  }
  if (info->remote_user) {
    env.set(""REMOTE_USER"", info->remote_user);
  }

  if (port <= 0)
    lderr(cct) << ""init_env: bug: invalid port number"" << dendl;
  char port_buf[16];
  snprintf(port_buf, sizeof(port_buf), ""%d"", port);
  env.set(""SERVER_PORT"", port_buf);
  if (info->is_ssl) {
    env.set(""SERVER_PORT_SECURE"", port_buf);
  }
  return 0;
}","int RGWCivetWeb::init_env(CephContext *VAR_0)
{
  VAR_1.init(VAR_0);
  const struct mg_request_info* VAR_2 = mg_get_request_info(VAR_3);

  if (! VAR_2) {
    /* COMMENT_0 */
    return -VAR_4;
  }

  for (int VAR_5 = 0; VAR_5 < VAR_2->num_headers; VAR_5++) {
    const struct mg_request_info::mg_header* VAR_6 = &VAR_2->http_headers[VAR_5];

    if (VAR_6->name == nullptr || VAR_6->value==nullptr) {
      lderr(VAR_0) << ""client supplied malformatted headers"" << VAR_7;
      return -VAR_4;
    }

    const boost::string_ref VAR_8(VAR_6->name);
    const auto& VAR_9 = VAR_6->value;

    if (boost::algorithm::iequals(VAR_8, ""content-length"")) {
      VAR_1.set(""CONTENT_LENGTH"", VAR_9);
      continue;
    }
    if (boost::algorithm::iequals(VAR_8, ""content-type"")) {
      VAR_1.set(""CONTENT_TYPE"", VAR_9);
      continue;
    }
    if (boost::algorithm::iequals(VAR_8, ""connection"")) {
      VAR_10 = boost::algorithm::iequals(VAR_9, ""keep-alive"");
      VAR_11 = boost::algorithm::iequals(VAR_9, ""close"");
    }

    static const boost::string_ref VAR_12{""HTTP_""};

    char VAR_13[VAR_8.size() + VAR_12.size() + 1];
    auto VAR_14 = std::copy(std::begin(VAR_12), std::end(VAR_12), VAR_13);
    for (auto VAR_15 = VAR_8.begin(); VAR_15 != VAR_8.end(); ++VAR_15, ++VAR_14) {
      if (*VAR_15 == '-') {
        *VAR_14 = '_';
      } else {
        *VAR_14 = std::toupper(*VAR_15);
      }
    }
    *VAR_14 = '\0';

    VAR_1.set(VAR_13, VAR_9);
  }

  VAR_1.set(""REMOTE_ADDR"", VAR_2->remote_addr);
  VAR_1.set(""REQUEST_METHOD"", VAR_2->request_method);
  VAR_1.set(""HTTP_VERSION"", VAR_2->http_version);
  VAR_1.set(""REQUEST_URI"", VAR_2->request_uri); /* COMMENT_1 */
  VAR_1.set(""SCRIPT_URI"", VAR_2->uri); /* COMMENT_2 */
  if (VAR_2->query_string) {
    VAR_1.set(""QUERY_STRING"", VAR_2->query_string);
  }
  if (VAR_2->remote_user) {
    VAR_1.set(""REMOTE_USER"", VAR_2->remote_user);
  }

  if (VAR_16 <= 0)
    lderr(VAR_0) << ""init_env: bug: invalid port number"" << VAR_7;
  char VAR_17[16];
  snprintf(VAR_17, sizeof(VAR_17), ""%d"", VAR_16);
  VAR_1.set(""SERVER_PORT"", VAR_17);
  if (VAR_2->is_ssl) {
    VAR_1.set(""SERVER_PORT_SECURE"", VAR_17);
  }
  return 0;
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_civetweb.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,14 +1,21 @@
-void RGWCivetWeb::init_env(CephContext *cct)
+int RGWCivetWeb::init_env(CephContext *cct)
 {
   env.init(cct);
   const struct mg_request_info* info = mg_get_request_info(conn);
 
   if (! info) {
-    return;
+    // request info is NULL; we have no info about the connection
+    return -EINVAL;
   }
 
   for (int i = 0; i < info->num_headers; i++) {
     const struct mg_request_info::mg_header* header = &info->http_headers[i];
+
+    if (header->name == nullptr || header->value==nullptr) {
+      lderr(cct) << ""client supplied malformatted headers"" << dendl;
+      return -EINVAL;
+    }
+
     const boost::string_ref name(header->name);
     const auto& value = header->value;
 
@@ -61,4 +68,5 @@
   if (info->is_ssl) {
     env.set(""SERVER_PORT_SECURE"", port_buf);
   }
+  return 0;
 }","{'deleted_lines': ['void RGWCivetWeb::init_env(CephContext *cct)', '    return;'], 'added_lines': ['int RGWCivetWeb::init_env(CephContext *cct)', '    // request info is NULL; we have no info about the connection', '    return -EINVAL;', '', '    if (header->name == nullptr || header->value==nullptr) {', '      lderr(cct) << ""client supplied malformatted headers"" << dendl;', '      return -EINVAL;', '    }', '', '  return 0;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_client_io.h,init_env,"void init_env(CephContext *cct) override {
return get_decoratee().init_env(cct);
}","void init_env(CephContext *VAR_0) override {
return get_decoratee().init_env(VAR_0);
}",,"int init_env(CephContext *cct) override {
    return get_decoratee().init_env(cct);
  }","int init_env(CephContext *VAR_0) override {
    return get_decoratee().init_env(VAR_0);
  }",,"--- func_before
+++ func_after
@@ -1,3 +1,3 @@
-void init_env(CephContext *cct) override {
+int init_env(CephContext *cct) override {
     return get_decoratee().init_env(cct);
   }","{'deleted_lines': ['void init_env(CephContext *cct) override {'], 'added_lines': ['int init_env(CephContext *cct) override {']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7262,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ceph,"rgw:  make init env methods return an error

Since web frontends may signal an error when requests are malformed or so, let
us double check this and raise errors early. The current user of this is
civetweb frontend; which can potentially return null from `parse_http_headers`
when a HTTP header without a "":"" is supplied at which point headers.value is
null which can lead to undefined behaviour later in RGW.

Fixes: http://tracker.ceph.com/issues/23039
Signed-off-by: Abhishek Lekshmanan <abhishek@suse.com>",7872a831783e17dcc4d0aa70cffc256afb664f7a,https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a,src/rgw/rgw_loadgen.cc,RGWLoadGenIO::init_env,"void RGWLoadGenIO::init_env(CephContext *cct)
{
env.init(cct);
left_to_read = req->content_length;
char buf[32];
snprintf(buf, sizeof(buf), ""%lld"", (long long)req->content_length);
env.set(""CONTENT_LENGTH"", buf);
env.set(""CONTENT_TYPE"", req->content_type.c_str());
env.set(""HTTP_DATE"", req->date_str.c_str());
for (map<string, string>::iterator iter = req->headers.begin(); iter != req->headers.end(); ++iter) {
env.set(iter->first.c_str(), iter->second.c_str());
}
env.set(""REQUEST_METHOD"", req->request_method.c_str());
env.set(""REQUEST_URI"", req->uri.c_str());
env.set(""QUERY_STRING"", req->query_string.c_str());
env.set(""SCRIPT_URI"", req->uri.c_str());
char port_buf[16];
snprintf(port_buf, sizeof(port_buf), ""%d"", req->port);
env.set(""SERVER_PORT"", port_buf);
}","void RGWLoadGenIO::init_env(CephContext *VAR_0)
{
VAR_1.init(VAR_0);
VAR_2 = VAR_3->content_length;
char VAR_4[32];
snprintf(VAR_4, sizeof(VAR_4), ""%lld"", (long long)VAR_3->content_length);
VAR_1.set(""CONTENT_LENGTH"", VAR_4);
VAR_1.set(""CONTENT_TYPE"", VAR_3->content_type.c_str());
VAR_1.set(""HTTP_DATE"", VAR_3->date_str.c_str());
for (map<string, string>::iterator VAR_5 = VAR_3->headers.begin(); VAR_5 != VAR_3->headers.end(); ++VAR_5) {
VAR_1.set(VAR_5->first.c_str(), VAR_5->second.c_str());
}
VAR_1.set(""REQUEST_METHOD"", VAR_3->request_method.c_str());
VAR_1.set(""REQUEST_URI"", VAR_3->uri.c_str());
VAR_1.set(""QUERY_STRING"", VAR_3->query_string.c_str());
VAR_1.set(""SCRIPT_URI"", VAR_3->uri.c_str());
char VAR_6[16];
snprintf(VAR_6, sizeof(VAR_6), ""%d"", VAR_3->port);
VAR_1.set(""SERVER_PORT"", VAR_6);
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_loadgen.cc/vul/before/0.json,"int RGWLoadGenIO::init_env(CephContext *cct)
{
  env.init(cct);

  left_to_read = req->content_length;

  char buf[32];
  snprintf(buf, sizeof(buf), ""%lld"", (long long)req->content_length);
  env.set(""CONTENT_LENGTH"", buf);

  env.set(""CONTENT_TYPE"", req->content_type.c_str());
  env.set(""HTTP_DATE"", req->date_str.c_str());

  for (map<string, string>::iterator iter = req->headers.begin(); iter != req->headers.end(); ++iter) {
    env.set(iter->first.c_str(), iter->second.c_str());
  }

  env.set(""REQUEST_METHOD"", req->request_method.c_str());
  env.set(""REQUEST_URI"", req->uri.c_str());
  env.set(""QUERY_STRING"", req->query_string.c_str());
  env.set(""SCRIPT_URI"", req->uri.c_str());

  char port_buf[16];
  snprintf(port_buf, sizeof(port_buf), ""%d"", req->port);
  env.set(""SERVER_PORT"", port_buf);
  return 0;
}","int RGWLoadGenIO::init_env(CephContext *VAR_0)
{
  VAR_1.init(VAR_0);

  VAR_2 = VAR_3->content_length;

  char VAR_4[32];
  snprintf(VAR_4, sizeof(VAR_4), ""%lld"", (long long)VAR_3->content_length);
  VAR_1.set(""CONTENT_LENGTH"", VAR_4);

  VAR_1.set(""CONTENT_TYPE"", VAR_3->content_type.c_str());
  VAR_1.set(""HTTP_DATE"", VAR_3->date_str.c_str());

  for (map<string, string>::iterator VAR_5 = VAR_3->headers.begin(); VAR_5 != VAR_3->headers.end(); ++VAR_5) {
    VAR_1.set(VAR_5->first.c_str(), VAR_5->second.c_str());
  }

  VAR_1.set(""REQUEST_METHOD"", VAR_3->request_method.c_str());
  VAR_1.set(""REQUEST_URI"", VAR_3->uri.c_str());
  VAR_1.set(""QUERY_STRING"", VAR_3->query_string.c_str());
  VAR_1.set(""SCRIPT_URI"", VAR_3->uri.c_str());

  char VAR_6[16];
  snprintf(VAR_6, sizeof(VAR_6), ""%d"", VAR_3->port);
  VAR_1.set(""SERVER_PORT"", VAR_6);
  return 0;
}",ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_loadgen.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void RGWLoadGenIO::init_env(CephContext *cct)
+int RGWLoadGenIO::init_env(CephContext *cct)
 {
   env.init(cct);
 
@@ -23,4 +23,5 @@
   char port_buf[16];
   snprintf(port_buf, sizeof(port_buf), ""%d"", req->port);
   env.set(""SERVER_PORT"", port_buf);
+  return 0;
 }","{'deleted_lines': ['void RGWLoadGenIO::init_env(CephContext *cct)'], 'added_lines': ['int RGWLoadGenIO::init_env(CephContext *cct)', '  return 0;']}",True,"In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.",7.5,HIGH,2,valid,2018-02-12T17:05:03Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/sel1.c,selaGetCombName,"char *
selaGetCombName(SELA    *sela,
l_int32  size,
l_int32  direction)
{
char    *selname;
char     combname[L_BUF_SIZE];
l_int32  i, nsels, sx, sy, found;
SEL     *sel;
PROCNAME(""selaGetCombName"");
if (!sela)
return (char *)ERROR_PTR(""sela not defined"", procName, NULL);
if (direction != L_HORIZ && direction != L_VERT)
return (char *)ERROR_PTR(""invalid direction"", procName, NULL);
if (direction == L_HORIZ)
snprintf(combname, L_BUF_SIZE, ""sel_comb_%dh"", size);
else  
snprintf(combname, L_BUF_SIZE, ""sel_comb_%dv"", size);
found = FALSE;
nsels = selaGetCount(sela);
for (i = 0; i < nsels; i++) {
sel = selaGetSel(sela, i);
selGetParameters(sel, &sy, &sx, NULL, NULL);
if (sy != 1 && sx != 1)  
continue;
selname = selGetName(sel);
if (!strcmp(selname, combname)) {
found = TRUE;
break;
}
}
if (found)
return stringNew(selname);
else
return (char *)ERROR_PTR(""sel not found"", procName, NULL);
}","char *
selaGetCombName(SELA    *VAR_0,
l_int32  VAR_1,
l_int32  VAR_2)
{
char    *VAR_3;
char     VAR_4[VAR_5];
l_int32  VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
SEL     *VAR_11;
PROCNAME(""selaGetCombName"");
if (!VAR_0)
return (char *)ERROR_PTR(""sela not defined"", VAR_12, NULL);
if (VAR_2 != VAR_13 && VAR_2 != VAR_14)
return (char *)ERROR_PTR(""invalid direction"", VAR_12, NULL);
if (VAR_2 == VAR_13)
snprintf(VAR_4, VAR_5, ""sel_comb_%dh"", VAR_1);
else  
snprintf(VAR_4, VAR_5, ""sel_comb_%dv"", VAR_1);
VAR_10 = FALSE;
VAR_7 = selaGetCount(VAR_0);
for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
VAR_11 = selaGetSel(VAR_0, VAR_6);
selGetParameters(VAR_11, &VAR_9, &VAR_8, NULL, NULL);
if (VAR_9 != 1 && VAR_8 != 1)  
continue;
VAR_3 = selGetName(VAR_11);
if (!strcmp(VAR_3, VAR_4)) {
VAR_10 = TRUE;
break;
}
}
if (VAR_10)
return stringNew(VAR_3);
else
return (char *)ERROR_PTR(""sel not found"", VAR_12, NULL);
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/before/0.json,"char *
selaGetCombName(SELA    *sela,
                l_int32  size,
                l_int32  direction)
{
char    *selname;
char     combname[L_BUFSIZE];
l_int32  i, nsels, sx, sy, found;
SEL     *sel;

    PROCNAME(""selaGetCombName"");

    if (!sela)
        return (char *)ERROR_PTR(""sela not defined"", procName, NULL);
    if (direction != L_HORIZ && direction != L_VERT)
        return (char *)ERROR_PTR(""invalid direction"", procName, NULL);

        /* Derive the comb name we're looking for */
    if (direction == L_HORIZ)
        snprintf(combname, L_BUFSIZE, ""sel_comb_%dh"", size);
    else  /* direction == L_VERT */
        snprintf(combname, L_BUFSIZE, ""sel_comb_%dv"", size);

    found = FALSE;
    nsels = selaGetCount(sela);
    for (i = 0; i < nsels; i++) {
        sel = selaGetSel(sela, i);
        selGetParameters(sel, &sy, &sx, NULL, NULL);
        if (sy != 1 && sx != 1)  /* 2-D; not a comb */
            continue;
        selname = selGetName(sel);
        if (!strcmp(selname, combname)) {
            found = TRUE;
            break;
        }
    }

    if (found)
        return stringNew(selname);
    else
        return (char *)ERROR_PTR(""sel not found"", procName, NULL);
}","char *
selaGetCombName(SELA    *VAR_0,
                l_int32  VAR_1,
                l_int32  VAR_2)
{
char    *VAR_3;
char     VAR_4[VAR_5];
l_int32  VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
SEL     *VAR_11;

    PROCNAME(""selaGetCombName"");

    if (!VAR_0)
        return (char *)ERROR_PTR(""sela not defined"", VAR_12, NULL);
    if (VAR_2 != VAR_13 && VAR_2 != VAR_14)
        return (char *)ERROR_PTR(""invalid direction"", VAR_12, NULL);

        /* COMMENT_0 */
    if (VAR_2 == VAR_13)
        snprintf(VAR_4, VAR_5, ""sel_comb_%dh"", VAR_1);
    else  /* COMMENT_1 */
        snprintf(VAR_4, VAR_5, ""sel_comb_%dv"", VAR_1);

    VAR_10 = FALSE;
    VAR_7 = selaGetCount(VAR_0);
    for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
        VAR_11 = selaGetSel(VAR_0, VAR_6);
        selGetParameters(VAR_11, &VAR_9, &VAR_8, NULL, NULL);
        if (VAR_9 != 1 && VAR_8 != 1)  /* COMMENT_2 */
            continue;
        VAR_3 = selGetName(VAR_11);
        if (!strcmp(VAR_3, VAR_4)) {
            VAR_10 = TRUE;
            break;
        }
    }

    if (VAR_10)
        return stringNew(VAR_3);
    else
        return (char *)ERROR_PTR(""sel not found"", VAR_12, NULL);
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
                 l_int32  direction)
 {
 char    *selname;
-char     combname[L_BUF_SIZE];
+char     combname[L_BUFSIZE];
 l_int32  i, nsels, sx, sy, found;
 SEL     *sel;
 
@@ -17,9 +17,9 @@
 
         /* Derive the comb name we're looking for */
     if (direction == L_HORIZ)
-        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dh"", size);
+        snprintf(combname, L_BUFSIZE, ""sel_comb_%dh"", size);
     else  /* direction == L_VERT */
-        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dv"", size);
+        snprintf(combname, L_BUFSIZE, ""sel_comb_%dv"", size);
 
     found = FALSE;
     nsels = selaGetCount(sela);","{'deleted_lines': ['char     combname[L_BUF_SIZE];', '        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dh"", size);', '        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dv"", size);'], 'added_lines': ['char     combname[L_BUFSIZE];', '        snprintf(combname, L_BUFSIZE, ""sel_comb_%dh"", size);', '        snprintf(combname, L_BUFSIZE, ""sel_comb_%dv"", size);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/ptabasic.c,ptaReadStream,"PTA *
ptaReadStream(FILE  *fp)
{
char       typestr[128];
l_int32    i, n, ix, iy, type, version;
l_float32  x, y;
PTA       *pta;
PROCNAME(""ptaReadStream"");
if (!fp)
return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);
if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1)
return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
if (version != PTA_VERSION_NUMBER)
return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2)
return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
if (!strcmp(typestr, ""float""))
type = 0;
else  
type = 1;
if ((pta = ptaCreate(n)) == NULL)
return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
for (i = 0; i < n; i++) {
if (type == 0) {  
if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) {
ptaDestroy(&pta);
return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
}
ptaAddPt(pta, x, y);
} else {   
if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) {
ptaDestroy(&pta);
return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
}
ptaAddPt(pta, ix, iy);
}
}
return pta;
}","PTA *
ptaReadStream(FILE  *VAR_0)
{
char       VAR_1[128];
l_int32    VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
l_float32  VAR_8, VAR_9;
PTA       *VAR_10;
PROCNAME(""ptaReadStream"");
if (!VAR_0)
return (PTA *)ERROR_PTR(""stream not defined"", VAR_11, NULL);
if (fscanf(VAR_0, ""\n Pta Version %d\n"", &VAR_7) != 1)
return (PTA *)ERROR_PTR(""not a pta file"", VAR_11, NULL);
if (VAR_7 != VAR_12)
return (PTA *)ERROR_PTR(""invalid pta version"", VAR_11, NULL);
if (fscanf(VAR_0, "" Number of pts = %d; format = %s\n"", &VAR_3, VAR_1) != 2)
return (PTA *)ERROR_PTR(""not a pta file"", VAR_11, NULL);
if (!strcmp(VAR_1, ""float""))
VAR_6 = 0;
else  
VAR_6 = 1;
if ((VAR_10 = ptaCreate(VAR_3)) == NULL)
return (PTA *)ERROR_PTR(""pta not made"", VAR_11, NULL);
for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
if (VAR_6 == 0) {  
if (fscanf(VAR_0, ""   (%f, %f)\n"", &VAR_8, &VAR_9) != 2) {
ptaDestroy(&VAR_10);
return (PTA *)ERROR_PTR(""error reading floats"", VAR_11, NULL);
}
ptaAddPt(VAR_10, VAR_8, VAR_9);
} else {   
if (fscanf(VAR_0, ""   (%d, %d)\n"", &VAR_4, &VAR_5) != 2) {
ptaDestroy(&VAR_10);
return (PTA *)ERROR_PTR(""error reading ints"", VAR_11, NULL);
}
ptaAddPt(VAR_10, VAR_4, VAR_5);
}
}
return VAR_10;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/ptabasic.c/vul/before/0.json,"PTA *
ptaReadStream(FILE  *fp)
{
char       typestr[128];  /* hardcoded below in fscanf */
l_int32    i, n, ix, iy, type, version;
l_float32  x, y;
PTA       *pta;

    PROCNAME(""ptaReadStream"");

    if (!fp)
        return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);

    if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1)
        return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
    if (version != PTA_VERSION_NUMBER)
        return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
    if (fscanf(fp, "" Number of pts = %d; format = %127s\n"", &n, typestr) != 2)
        return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
    if (!strcmp(typestr, ""float""))
        type = 0;
    else  /* typestr is ""integer"" */
        type = 1;

    if ((pta = ptaCreate(n)) == NULL)
        return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
    for (i = 0; i < n; i++) {
        if (type == 0) {  /* data is float */
            if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
            }
            ptaAddPt(pta, x, y);
        } else {   /* data is integer */
            if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
            }
            ptaAddPt(pta, ix, iy);
        }
    }

    return pta;
}","PTA *
ptaReadStream(FILE  *VAR_0)
{
char       VAR_1[128];  /* COMMENT_0 */
l_int32    VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
l_float32  VAR_8, VAR_9;
PTA       *VAR_10;

    PROCNAME(""ptaReadStream"");

    if (!VAR_0)
        return (PTA *)ERROR_PTR(""stream not defined"", VAR_11, NULL);

    if (fscanf(VAR_0, ""\n Pta Version %d\n"", &VAR_7) != 1)
        return (PTA *)ERROR_PTR(""not a pta file"", VAR_11, NULL);
    if (VAR_7 != VAR_12)
        return (PTA *)ERROR_PTR(""invalid pta version"", VAR_11, NULL);
    if (fscanf(VAR_0, "" Number of pts = %d; format = %127s\n"", &VAR_3, VAR_1) != 2)
        return (PTA *)ERROR_PTR(""not a pta file"", VAR_11, NULL);
    if (!strcmp(VAR_1, ""float""))
        VAR_6 = 0;
    else  /* COMMENT_1 */
        VAR_6 = 1;

    if ((VAR_10 = ptaCreate(VAR_3)) == NULL)
        return (PTA *)ERROR_PTR(""pta not made"", VAR_11, NULL);
    for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
        if (VAR_6 == 0) {  /* COMMENT_2 */
            if (fscanf(VAR_0, ""   (%f, %f)\n"", &VAR_8, &VAR_9) != 2) {
                ptaDestroy(&VAR_10);
                return (PTA *)ERROR_PTR(""error reading floats"", VAR_11, NULL);
            }
            ptaAddPt(VAR_10, VAR_8, VAR_9);
        } else {   /* COMMENT_3 */
            if (fscanf(VAR_0, ""   (%d, %d)\n"", &VAR_4, &VAR_5) != 2) {
                ptaDestroy(&VAR_10);
                return (PTA *)ERROR_PTR(""error reading ints"", VAR_11, NULL);
            }
            ptaAddPt(VAR_10, VAR_4, VAR_5);
        }
    }

    return VAR_10;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/ptabasic.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 PTA *
 ptaReadStream(FILE  *fp)
 {
-char       typestr[128];
+char       typestr[128];  /* hardcoded below in fscanf */
 l_int32    i, n, ix, iy, type, version;
 l_float32  x, y;
 PTA       *pta;
@@ -15,7 +15,7 @@
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (version != PTA_VERSION_NUMBER)
         return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
-    if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2)
+    if (fscanf(fp, "" Number of pts = %d; format = %127s\n"", &n, typestr) != 2)
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (!strcmp(typestr, ""float""))
         type = 0;","{'deleted_lines': ['char       typestr[128];', '    if (fscanf(fp, "" Number of pts = %d; format = %s\\n"", &n, typestr) != 2)'], 'added_lines': ['char       typestr[128];  /* hardcoded below in fscanf */', '    if (fscanf(fp, "" Number of pts = %d; format = %127s\\n"", &n, typestr) != 2)']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,prog/xtractprotos.c,main,"int main(int    argc,
char **argv)
{
char        *filein, *str, *tempfile, *prestring, *outprotos, *protostr;
const char  *spacestr = "" "";
char         buf[L_BUF_SIZE];
l_uint8     *allheaders;
l_int32      i, maxindex, in_line, nflags, protos_added, firstfile, len, ret;
size_t       nbytes;
L_BYTEA     *ba, *ba2;
SARRAY      *sa, *safirst;
static char  mainName[] = ""xtractprotos"";
if (argc == 1) {
fprintf(stderr,
""xtractprotos [-prestring=<string>] [-protos=<where>] ""
""[list of C files]\n""
""where the prestring is prepended to each prototype, and \n""
""protos can be either 'inline' or the name of an output ""
""prototype file\n"");
return 1;
}
prestring = outprotos = NULL;
in_line = FALSE;
nflags = 0;
maxindex = L_MIN(3, argc);
for (i = 1; i < maxindex; i++) {
if (argv[i][0] == '-') {
if (!strncmp(argv[i], ""-prestring"", 10)) {
nflags++;
ret = sscanf(argv[i] + 1, ""prestring=%s"", buf);
if (ret != 1) {
fprintf(stderr, ""parse failure for prestring\n"");
return 1;
}
if ((len = strlen(buf)) > L_BUF_SIZE - 3) {
L_WARNING(""prestring too large; omitting!\n"", mainName);
} else {
buf[len] = ' ';
buf[len + 1] = '\0';
prestring = stringNew(buf);
}
} else if (!strncmp(argv[i], ""-protos"", 7)) {
nflags++;
ret = sscanf(argv[i] + 1, ""protos=%s"", buf);
if (ret != 1) {
fprintf(stderr, ""parse failure for protos\n"");
return 1;
}
outprotos = stringNew(buf);
if (!strncmp(outprotos, ""inline"", 7))
in_line = TRUE;
}
}
}
if (argc - nflags < 2) {
fprintf(stderr, ""no files specified!\n"");
return 1;
}
ba = l_byteaCreate(500);
sa = sarrayCreate(0);
sarrayAddString(sa, (char *)"""", L_COPY);
sarrayAddString(sa, (char *)""#ifdef __cplusplus"", L_COPY);
sarrayAddString(sa, (char *)""extern \""C\"" {"", L_COPY);
sarrayAddString(sa, (char *)""#endif  \n"", L_COPY);
str = sarrayToString(sa, 1);
l_byteaAppendString(ba, str);
lept_free(str);
sarrayDestroy(&sa);
firstfile = 1 + nflags;
protos_added = FALSE;
if ((tempfile = l_makeTempFilename()) == NULL) {
fprintf(stderr, ""failure to make a writeable temp file\n"");
return 1;
}
for (i = firstfile; i < argc; i++) {
filein = argv[i];
len = strlen(filein);
if (filein[len - 1] == 'h')  
continue;
snprintf(buf, L_BUF_SIZE, ""cpp -ansi -DNO_PROTOS %s %s"",
filein, tempfile);
ret = system(buf);  
if (ret) {
fprintf(stderr, ""cpp failure for %s; continuing\n"", filein);
continue;
}
if ((str = parseForProtos(tempfile, prestring)) == NULL) {
fprintf(stderr, ""parse failure for %s; continuing\n"", filein);
continue;
}
if (strlen(str) > 1) {  
l_byteaAppendString(ba, str);
protos_added = TRUE;
}
lept_free(str);
}
lept_rmfile(tempfile);
lept_free(tempfile);
sa = sarrayCreate(0);
sarrayAddString(sa, (char *)""\n#ifdef __cplusplus"", L_COPY);
sarrayAddString(sa, (char *)""}"", L_COPY);
sarrayAddString(sa, (char *)""#endif  "", L_COPY);
str = sarrayToString(sa, 1);
l_byteaAppendString(ba, str);
lept_free(str);
sarrayDestroy(&sa);
protostr = (char *)l_byteaCopyData(ba, &nbytes);
l_byteaDestroy(&ba);
if (!outprotos) {  
fprintf(stderr, ""%s\n"", protostr);
lept_free(protostr);
return 0;
}
if (!protos_added) {
fprintf(stderr, ""No protos found\n"");
lept_free(protostr);
return 1;
}
ba = l_byteaInitFromFile(""allheaders_top.txt"");
if (!in_line) {
snprintf(buf, sizeof(buf), ""#include \""%s\""\n"", outprotos);
l_byteaAppendString(ba, buf);
l_binaryWrite(outprotos, ""w"", protostr, nbytes);
} else {
l_byteaAppendString(ba, protostr);
}
ba2 = l_byteaInitFromFile(""allheaders_bot.txt"");
l_byteaJoin(ba, &ba2);
l_byteaWrite(""allheaders.h"", ba, 0, 0);
l_byteaDestroy(&ba);
lept_free(protostr);
return 0;
}","int main(int    VAR_0,
char **VAR_1)
{
char        *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;
const char  *VAR_8 = "" "";
char         VAR_9[VAR_10];
l_uint8     *VAR_11;
l_int32      VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
size_t       VAR_20;
L_BYTEA     *VAR_21, *VAR_22;
SARRAY      *VAR_23, *VAR_24;
static char  VAR_25[] = ""xtractprotos"";
if (VAR_0 == 1) {
fprintf(VAR_26,
""xtractprotos [-prestring=<string>] [-protos=<where>] ""
""[list of C files]\n""
""where the prestring is prepended to each prototype, and \n""
""protos can be either 'inline' or the name of an output ""
""prototype file\n"");
return 1;
}
VAR_5 = VAR_6 = NULL;
VAR_14 = FALSE;
VAR_15 = 0;
VAR_13 = L_MIN(3, VAR_0);
for (VAR_12 = 1; VAR_12 < VAR_13; VAR_12++) {
if (VAR_1[VAR_12][0] == '-') {
if (!strncmp(VAR_1[VAR_12], ""-prestring"", 10)) {
VAR_15++;
VAR_19 = sscanf(VAR_1[VAR_12] + 1, ""prestring=%s"", VAR_9);
if (VAR_19 != 1) {
fprintf(VAR_26, ""parse failure for prestring\n"");
return 1;
}
if ((VAR_18 = strlen(VAR_9)) > VAR_10 - 3) {
L_WARNING(""prestring too large; omitting!\n"", VAR_25);
} else {
VAR_9[VAR_18] = ' ';
VAR_9[VAR_18 + 1] = '\0';
VAR_5 = stringNew(VAR_9);
}
} else if (!strncmp(VAR_1[VAR_12], ""-protos"", 7)) {
VAR_15++;
VAR_19 = sscanf(VAR_1[VAR_12] + 1, ""protos=%s"", VAR_9);
if (VAR_19 != 1) {
fprintf(VAR_26, ""parse failure for protos\n"");
return 1;
}
VAR_6 = stringNew(VAR_9);
if (!strncmp(VAR_6, ""inline"", 7))
VAR_14 = TRUE;
}
}
}
if (VAR_0 - VAR_15 < 2) {
fprintf(VAR_26, ""no files specified!\n"");
return 1;
}
VAR_21 = l_byteaCreate(500);
VAR_23 = sarrayCreate(0);
sarrayAddString(VAR_23, (char *)"""", VAR_27);
sarrayAddString(VAR_23, (char *)""#ifdef __cplusplus"", VAR_27);
sarrayAddString(VAR_23, (char *)""extern \""C\"" {"", VAR_27);
sarrayAddString(VAR_23, (char *)""#endif  \n"", VAR_27);
VAR_3 = sarrayToString(VAR_23, 1);
l_byteaAppendString(VAR_21, VAR_3);
lept_free(VAR_3);
sarrayDestroy(&VAR_23);
VAR_17 = 1 + VAR_15;
VAR_16 = FALSE;
if ((VAR_4 = l_makeTempFilename()) == NULL) {
fprintf(VAR_26, ""failure to make a writeable temp file\n"");
return 1;
}
for (VAR_12 = VAR_17; VAR_12 < VAR_0; VAR_12++) {
VAR_2 = VAR_1[VAR_12];
VAR_18 = strlen(VAR_2);
if (VAR_2[VAR_18 - 1] == 'h')  
continue;
snprintf(VAR_9, VAR_10, ""cpp -ansi -DNO_PROTOS %s %s"",
VAR_2, VAR_4);
VAR_19 = system(VAR_9);  
if (VAR_19) {
fprintf(VAR_26, ""cpp failure for %s; continuing\n"", VAR_2);
continue;
}
if ((VAR_3 = parseForProtos(VAR_4, VAR_5)) == NULL) {
fprintf(VAR_26, ""parse failure for %s; continuing\n"", VAR_2);
continue;
}
if (strlen(VAR_3) > 1) {  
l_byteaAppendString(VAR_21, VAR_3);
VAR_16 = TRUE;
}
lept_free(VAR_3);
}
lept_rmfile(VAR_4);
lept_free(VAR_4);
VAR_23 = sarrayCreate(0);
sarrayAddString(VAR_23, (char *)""\n#ifdef __cplusplus"", VAR_27);
sarrayAddString(VAR_23, (char *)""}"", VAR_27);
sarrayAddString(VAR_23, (char *)""#endif  "", VAR_27);
VAR_3 = sarrayToString(VAR_23, 1);
l_byteaAppendString(VAR_21, VAR_3);
lept_free(VAR_3);
sarrayDestroy(&VAR_23);
VAR_7 = (char *)l_byteaCopyData(VAR_21, &VAR_20);
l_byteaDestroy(&VAR_21);
if (!VAR_6) {  
fprintf(VAR_26, ""%s\n"", VAR_7);
lept_free(VAR_7);
return 0;
}
if (!VAR_16) {
fprintf(VAR_26, ""No protos found\n"");
lept_free(VAR_7);
return 1;
}
VAR_21 = l_byteaInitFromFile(""allheaders_top.txt"");
if (!VAR_14) {
snprintf(VAR_9, sizeof(VAR_9), ""#include \""%s\""\n"", VAR_6);
l_byteaAppendString(VAR_21, VAR_9);
l_binaryWrite(VAR_6, ""w"", VAR_7, VAR_20);
} else {
l_byteaAppendString(VAR_21, VAR_7);
}
VAR_22 = l_byteaInitFromFile(""allheaders_bot.txt"");
l_byteaJoin(VAR_21, &VAR_22);
l_byteaWrite(""allheaders.h"", VAR_21, 0, 0);
l_byteaDestroy(&VAR_21);
lept_free(VAR_7);
return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/xtractprotos.c/vul/before/0.json,"int main(int    argc,
         char **argv)
{
char        *filein, *str, *tempfile, *prestring, *outprotos, *protostr;
const char  *spacestr = "" "";
char         buf[L_BUFSIZE];
l_uint8     *allheaders;
l_int32      i, maxindex, in_line, nflags, protos_added, firstfile, len, ret;
size_t       nbytes;
L_BYTEA     *ba, *ba2;
SARRAY      *sa, *safirst;
static char  mainName[] = ""xtractprotos"";

    if (argc == 1) {
        fprintf(stderr,
                ""xtractprotos [-prestring=<string>] [-protos=<where>] ""
                ""[list of C files]\n""
                ""where the prestring is prepended to each prototype, and \n""
                ""protos can be either 'inline' or the name of an output ""
                ""prototype file\n"");
        return 1;
    }

    /* ---------------------------------------------------------------- */
    /* Parse input flags and find prestring and outprotos, if requested */
    /* ---------------------------------------------------------------- */
    prestring = outprotos = NULL;
    in_line = FALSE;
    nflags = 0;
    maxindex = L_MIN(3, argc);
    for (i = 1; i < maxindex; i++) {
        if (argv[i][0] == '-') {
            if (!strncmp(argv[i], ""-prestring"", 10)) {
                nflags++;
                ret = sscanf(argv[i] + 1, ""prestring=%490s"", buf);
                if (ret != 1) {
                    fprintf(stderr, ""parse failure for prestring\n"");
                    return 1;
                }
                if ((len = strlen(buf)) > L_BUFSIZE - 3) {
                    L_WARNING(""prestring too large; omitting!\n"", mainName);
                } else {
                    buf[len] = ' ';
                    buf[len + 1] = '\0';
                    prestring = stringNew(buf);
                }
            } else if (!strncmp(argv[i], ""-protos"", 7)) {
                nflags++;
                ret = sscanf(argv[i] + 1, ""protos=%490s"", buf);
                if (ret != 1) {
                    fprintf(stderr, ""parse failure for protos\n"");
                    return 1;
                }
                outprotos = stringNew(buf);
                if (!strncmp(outprotos, ""inline"", 7))
                    in_line = TRUE;
            }
        }
    }

    if (argc - nflags < 2) {
        fprintf(stderr, ""no files specified!\n"");
        return 1;
    }


    /* ---------------------------------------------------------------- */
    /*                   Generate the prototype string                  */
    /* ---------------------------------------------------------------- */
    ba = l_byteaCreate(500);

        /* First the extern C head */
    sa = sarrayCreate(0);
    sarrayAddString(sa, (char *)""/*"", L_COPY);
    snprintf(buf, L_BUFSIZE,
             "" *  These prototypes were autogen'd by xtractprotos, v. %s"",
             version);
    sarrayAddString(sa, buf, L_COPY);
    sarrayAddString(sa, (char *)"" */"", L_COPY);
    sarrayAddString(sa, (char *)""#ifdef __cplusplus"", L_COPY);
    sarrayAddString(sa, (char *)""extern \""C\"" {"", L_COPY);
    sarrayAddString(sa, (char *)""#endif  /* __cplusplus */\n"", L_COPY);
    str = sarrayToString(sa, 1);
    l_byteaAppendString(ba, str);
    lept_free(str);
    sarrayDestroy(&sa);

        /* Then the prototypes */
    firstfile = 1 + nflags;
    protos_added = FALSE;
    if ((tempfile = l_makeTempFilename()) == NULL) {
        fprintf(stderr, ""failure to make a writeable temp file\n"");
        return 1;
    }
    for (i = firstfile; i < argc; i++) {
        filein = argv[i];
        len = strlen(filein);
        if (filein[len - 1] == 'h')  /* skip .h files */
            continue;
        snprintf(buf, L_BUFSIZE, ""cpp -ansi -DNO_PROTOS %s %s"",
                 filein, tempfile);
        ret = system(buf);  /* cpp */
        if (ret) {
            fprintf(stderr, ""cpp failure for %s; continuing\n"", filein);
            continue;
        }

        if ((str = parseForProtos(tempfile, prestring)) == NULL) {
            fprintf(stderr, ""parse failure for %s; continuing\n"", filein);
            continue;
        }
        if (strlen(str) > 1) {  /* strlen(str) == 1 is a file without protos */
            l_byteaAppendString(ba, str);
            protos_added = TRUE;
        }
        lept_free(str);
    }
    lept_rmfile(tempfile);
    lept_free(tempfile);

        /* Lastly the extern C tail */
    sa = sarrayCreate(0);
    sarrayAddString(sa, (char *)""\n#ifdef __cplusplus"", L_COPY);
    sarrayAddString(sa, (char *)""}"", L_COPY);
    sarrayAddString(sa, (char *)""#endif  /* __cplusplus */"", L_COPY);
    str = sarrayToString(sa, 1);
    l_byteaAppendString(ba, str);
    lept_free(str);
    sarrayDestroy(&sa);

    protostr = (char *)l_byteaCopyData(ba, &nbytes);
    l_byteaDestroy(&ba);


    /* ---------------------------------------------------------------- */
    /*                       Generate the output                        */
    /* ---------------------------------------------------------------- */
    if (!outprotos) {  /* just write to stdout */
        fprintf(stderr, ""%s\n"", protostr);
        lept_free(protostr);
        return 0;
    }

        /* If no protos were found, do nothing further */
    if (!protos_added) {
        fprintf(stderr, ""No protos found\n"");
        lept_free(protostr);
        return 1;
    }

        /* Make the output files */
    ba = l_byteaInitFromFile(""allheaders_top.txt"");
    if (!in_line) {
        snprintf(buf, sizeof(buf), ""#include \""%s\""\n"", outprotos);
        l_byteaAppendString(ba, buf);
        l_binaryWrite(outprotos, ""w"", protostr, nbytes);
    } else {
        l_byteaAppendString(ba, protostr);
    }
    ba2 = l_byteaInitFromFile(""allheaders_bot.txt"");
    l_byteaJoin(ba, &ba2);
    l_byteaWrite(""allheaders.h"", ba, 0, 0);
    l_byteaDestroy(&ba);
    lept_free(protostr);
    return 0;
}","int main(int    VAR_0,
         char **VAR_1)
{
char        *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;
const char  *VAR_8 = "" "";
char         VAR_9[VAR_10];
l_uint8     *VAR_11;
l_int32      VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
size_t       VAR_20;
L_BYTEA     *VAR_21, *VAR_22;
SARRAY      *VAR_23, *VAR_24;
static char  VAR_25[] = ""xtractprotos"";

    if (VAR_0 == 1) {
        fprintf(VAR_26,
                ""xtractprotos [-prestring=<string>] [-protos=<where>] ""
                ""[list of C files]\n""
                ""where the prestring is prepended to each prototype, and \n""
                ""protos can be either 'inline' or the name of an output ""
                ""prototype file\n"");
        return 1;
    }

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_0 */
    VAR_5 = VAR_6 = NULL;
    VAR_14 = FALSE;
    VAR_15 = 0;
    VAR_13 = L_MIN(3, VAR_0);
    for (VAR_12 = 1; VAR_12 < VAR_13; VAR_12++) {
        if (VAR_1[VAR_12][0] == '-') {
            if (!strncmp(VAR_1[VAR_12], ""-prestring"", 10)) {
                VAR_15++;
                VAR_19 = sscanf(VAR_1[VAR_12] + 1, ""prestring=%490s"", VAR_9);
                if (VAR_19 != 1) {
                    fprintf(VAR_26, ""parse failure for prestring\n"");
                    return 1;
                }
                if ((VAR_18 = strlen(VAR_9)) > VAR_10 - 3) {
                    L_WARNING(""prestring too large; omitting!\n"", VAR_25);
                } else {
                    VAR_9[VAR_18] = ' ';
                    VAR_9[VAR_18 + 1] = '\0';
                    VAR_5 = stringNew(VAR_9);
                }
            } else if (!strncmp(VAR_1[VAR_12], ""-protos"", 7)) {
                VAR_15++;
                VAR_19 = sscanf(VAR_1[VAR_12] + 1, ""protos=%490s"", VAR_9);
                if (VAR_19 != 1) {
                    fprintf(VAR_26, ""parse failure for protos\n"");
                    return 1;
                }
                VAR_6 = stringNew(VAR_9);
                if (!strncmp(VAR_6, ""inline"", 7))
                    VAR_14 = TRUE;
            }
        }
    }

    if (VAR_0 - VAR_15 < 2) {
        fprintf(VAR_26, ""no files specified!\n"");
        return 1;
    }


    /* COMMENT_0 */
    /* COMMENT_2 */
    /* COMMENT_0 */
    VAR_21 = l_byteaCreate(500);

        /* COMMENT_3 */
    VAR_23 = sarrayCreate(0);
    sarrayAddString(VAR_23, (char *)""/*"", VAR_27);
    snprintf(VAR_9, VAR_10,
             "" *  These prototypes were autogen'd by xtractprotos, v. %s"",
             VAR_28);
    sarrayAddString(VAR_23, VAR_9, VAR_27);
    sarrayAddString(VAR_23, (char *)"" */"", VAR_27);
    sarrayAddString(VAR_23, (char *)""#ifdef __cplusplus"", VAR_27);
    sarrayAddString(VAR_23, (char *)""extern \""C\"" {"", VAR_27);
    sarrayAddString(VAR_23, (char *)""#endif  /* __cplusplus */\n"", VAR_27);
    VAR_3 = sarrayToString(VAR_23, 1);
    l_byteaAppendString(VAR_21, VAR_3);
    lept_free(VAR_3);
    sarrayDestroy(&VAR_23);

        /* COMMENT_4 */
    VAR_17 = 1 + VAR_15;
    VAR_16 = FALSE;
    if ((VAR_4 = l_makeTempFilename()) == NULL) {
        fprintf(VAR_26, ""failure to make a writeable temp file\n"");
        return 1;
    }
    for (VAR_12 = VAR_17; VAR_12 < VAR_0; VAR_12++) {
        VAR_2 = VAR_1[VAR_12];
        VAR_18 = strlen(VAR_2);
        if (VAR_2[VAR_18 - 1] == 'h')  /* COMMENT_5 */
            continue;
        snprintf(VAR_9, VAR_10, ""cpp -ansi -DNO_PROTOS %s %s"",
                 VAR_2, VAR_4);
        VAR_19 = system(VAR_9);  /* COMMENT_6 */
        if (VAR_19) {
            fprintf(VAR_26, ""cpp failure for %s; continuing\n"", VAR_2);
            continue;
        }

        if ((VAR_3 = parseForProtos(VAR_4, VAR_5)) == NULL) {
            fprintf(VAR_26, ""parse failure for %s; continuing\n"", VAR_2);
            continue;
        }
        if (strlen(VAR_3) > 1) {  /* COMMENT_7 */
            l_byteaAppendString(VAR_21, VAR_3);
            VAR_16 = TRUE;
        }
        lept_free(VAR_3);
    }
    lept_rmfile(VAR_4);
    lept_free(VAR_4);

        /* COMMENT_8 */
    VAR_23 = sarrayCreate(0);
    sarrayAddString(VAR_23, (char *)""\n#ifdef __cplusplus"", VAR_27);
    sarrayAddString(VAR_23, (char *)""}"", VAR_27);
    sarrayAddString(VAR_23, (char *)""#endif  /* __cplusplus */"", VAR_27);
    VAR_3 = sarrayToString(VAR_23, 1);
    l_byteaAppendString(VAR_21, VAR_3);
    lept_free(VAR_3);
    sarrayDestroy(&VAR_23);

    VAR_7 = (char *)l_byteaCopyData(VAR_21, &VAR_20);
    l_byteaDestroy(&VAR_21);


    /* COMMENT_0 */
    /* COMMENT_9 */
    /* COMMENT_0 */
    if (!VAR_6) {  /* COMMENT_10 */
        fprintf(VAR_26, ""%s\n"", VAR_7);
        lept_free(VAR_7);
        return 0;
    }

        /* COMMENT_11 */
    if (!VAR_16) {
        fprintf(VAR_26, ""No protos found\n"");
        lept_free(VAR_7);
        return 1;
    }

        /* COMMENT_12 */
    VAR_21 = l_byteaInitFromFile(""allheaders_top.txt"");
    if (!VAR_14) {
        snprintf(VAR_9, sizeof(VAR_9), ""#include \""%s\""\n"", VAR_6);
        l_byteaAppendString(VAR_21, VAR_9);
        l_binaryWrite(VAR_6, ""w"", VAR_7, VAR_20);
    } else {
        l_byteaAppendString(VAR_21, VAR_7);
    }
    VAR_22 = l_byteaInitFromFile(""allheaders_bot.txt"");
    l_byteaJoin(VAR_21, &VAR_22);
    l_byteaWrite(""allheaders.h"", VAR_21, 0, 0);
    l_byteaDestroy(&VAR_21);
    lept_free(VAR_7);
    return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/xtractprotos.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 char        *filein, *str, *tempfile, *prestring, *outprotos, *protostr;
 const char  *spacestr = "" "";
-char         buf[L_BUF_SIZE];
+char         buf[L_BUFSIZE];
 l_uint8     *allheaders;
 l_int32      i, maxindex, in_line, nflags, protos_added, firstfile, len, ret;
 size_t       nbytes;
@@ -32,12 +32,12 @@
         if (argv[i][0] == '-') {
             if (!strncmp(argv[i], ""-prestring"", 10)) {
                 nflags++;
-                ret = sscanf(argv[i] + 1, ""prestring=%s"", buf);
+                ret = sscanf(argv[i] + 1, ""prestring=%490s"", buf);
                 if (ret != 1) {
                     fprintf(stderr, ""parse failure for prestring\n"");
                     return 1;
                 }
-                if ((len = strlen(buf)) > L_BUF_SIZE - 3) {
+                if ((len = strlen(buf)) > L_BUFSIZE - 3) {
                     L_WARNING(""prestring too large; omitting!\n"", mainName);
                 } else {
                     buf[len] = ' ';
@@ -46,7 +46,7 @@
                 }
             } else if (!strncmp(argv[i], ""-protos"", 7)) {
                 nflags++;
-                ret = sscanf(argv[i] + 1, ""protos=%s"", buf);
+                ret = sscanf(argv[i] + 1, ""protos=%490s"", buf);
                 if (ret != 1) {
                     fprintf(stderr, ""parse failure for protos\n"");
                     return 1;
@@ -72,7 +72,7 @@
         /* First the extern C head */
     sa = sarrayCreate(0);
     sarrayAddString(sa, (char *)""/*"", L_COPY);
-    snprintf(buf, L_BUF_SIZE,
+    snprintf(buf, L_BUFSIZE,
              "" *  These prototypes were autogen'd by xtractprotos, v. %s"",
              version);
     sarrayAddString(sa, buf, L_COPY);
@@ -97,7 +97,7 @@
         len = strlen(filein);
         if (filein[len - 1] == 'h')  /* skip .h files */
             continue;
-        snprintf(buf, L_BUF_SIZE, ""cpp -ansi -DNO_PROTOS %s %s"",
+        snprintf(buf, L_BUFSIZE, ""cpp -ansi -DNO_PROTOS %s %s"",
                  filein, tempfile);
         ret = system(buf);  /* cpp */
         if (ret) {","{'deleted_lines': ['char         buf[L_BUF_SIZE];', '                ret = sscanf(argv[i] + 1, ""prestring=%s"", buf);', '                if ((len = strlen(buf)) > L_BUF_SIZE - 3) {', '                ret = sscanf(argv[i] + 1, ""protos=%s"", buf);', '    snprintf(buf, L_BUF_SIZE,', '        snprintf(buf, L_BUF_SIZE, ""cpp -ansi -DNO_PROTOS %s %s"",'], 'added_lines': ['char         buf[L_BUFSIZE];', '                ret = sscanf(argv[i] + 1, ""prestring=%490s"", buf);', '                if ((len = strlen(buf)) > L_BUFSIZE - 3) {', '                ret = sscanf(argv[i] + 1, ""protos=%490s"", buf);', '    snprintf(buf, L_BUFSIZE,', '        snprintf(buf, L_BUFSIZE, ""cpp -ansi -DNO_PROTOS %s %s"",']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/gplot.c,gplotCreate,"GPLOT  *
gplotCreate(const char  *rootname,
l_int32      outformat,
const char  *title,
const char  *xlabel,
const char  *ylabel)
{
char    *newroot;
char     buf[L_BUF_SIZE];
l_int32  badchar;
GPLOT   *gplot;
PROCNAME(""gplotCreate"");
if (!rootname)
return (GPLOT *)ERROR_PTR(""rootname not defined"", procName, NULL);
if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&
outformat != GPLOT_EPS && outformat != GPLOT_LATEX)
return (GPLOT *)ERROR_PTR(""outformat invalid"", procName, NULL);
stringCheckForChars(rootname, ""`;&|><\""?*"", &badchar);
if (badchar)  
return (GPLOT *)ERROR_PTR(""invalid rootname"", procName, NULL);
if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)
return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL);
gplot->cmddata = sarrayCreate(0);
gplot->datanames = sarrayCreate(0);
gplot->plotdata = sarrayCreate(0);
gplot->plottitles = sarrayCreate(0);
gplot->plotstyles = numaCreate(0);
newroot = genPathname(rootname, NULL);
gplot->rootname = newroot;
gplot->outformat = outformat;
snprintf(buf, L_BUF_SIZE, ""%s.cmd"", rootname);
gplot->cmdname = stringNew(buf);
if (outformat == GPLOT_PNG)
snprintf(buf, L_BUF_SIZE, ""%s.png"", newroot);
else if (outformat == GPLOT_PS)
snprintf(buf, L_BUF_SIZE, ""%s.ps"", newroot);
else if (outformat == GPLOT_EPS)
snprintf(buf, L_BUF_SIZE, ""%s.eps"", newroot);
else if (outformat == GPLOT_LATEX)
snprintf(buf, L_BUF_SIZE, ""%s.tex"", newroot);
gplot->outname = stringNew(buf);
if (title) gplot->title = stringNew(title);
if (xlabel) gplot->xlabel = stringNew(xlabel);
if (ylabel) gplot->ylabel = stringNew(ylabel);
return gplot;
}","GPLOT  *
gplotCreate(const char  *VAR_0,
l_int32      VAR_1,
const char  *VAR_2,
const char  *VAR_3,
const char  *VAR_4)
{
char    *VAR_5;
char     VAR_6[VAR_7];
l_int32  VAR_8;
GPLOT   *VAR_9;
PROCNAME(""gplotCreate"");
if (!VAR_0)
return (GPLOT *)ERROR_PTR(""rootname not defined"", VAR_10, NULL);
if (VAR_1 != VAR_11 && VAR_1 != VAR_12 &&
VAR_1 != VAR_13 && VAR_1 != VAR_14)
return (GPLOT *)ERROR_PTR(""outformat invalid"", VAR_10, NULL);
stringCheckForChars(VAR_0, ""`;&|><\""?*"", &VAR_8);
if (VAR_8)  
return (GPLOT *)ERROR_PTR(""invalid rootname"", VAR_10, NULL);
if ((VAR_9 = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)
return (GPLOT *)ERROR_PTR(""gplot not made"", VAR_10, NULL);
VAR_9->cmddata = sarrayCreate(0);
VAR_9->datanames = sarrayCreate(0);
VAR_9->plotdata = sarrayCreate(0);
VAR_9->plottitles = sarrayCreate(0);
VAR_9->plotstyles = numaCreate(0);
VAR_5 = genPathname(VAR_0, NULL);
VAR_9->rootname = VAR_5;
VAR_9->outformat = VAR_1;
snprintf(VAR_6, VAR_7, ""%s.cmd"", VAR_0);
VAR_9->cmdname = stringNew(VAR_6);
if (VAR_1 == VAR_11)
snprintf(VAR_6, VAR_7, ""%s.png"", VAR_5);
else if (VAR_1 == VAR_12)
snprintf(VAR_6, VAR_7, ""%s.ps"", VAR_5);
else if (VAR_1 == VAR_13)
snprintf(VAR_6, VAR_7, ""%s.eps"", VAR_5);
else if (VAR_1 == VAR_14)
snprintf(VAR_6, VAR_7, ""%s.tex"", VAR_5);
VAR_9->outname = stringNew(VAR_6);
if (VAR_2) VAR_9->title = stringNew(VAR_2);
if (VAR_3) VAR_9->xlabel = stringNew(VAR_3);
if (VAR_4) VAR_9->ylabel = stringNew(VAR_4);
return VAR_9;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/before/4.json,"GPLOT  *
gplotCreate(const char  *rootname,
            l_int32      outformat,
            const char  *title,
            const char  *xlabel,
            const char  *ylabel)
{
char    *newroot;
char     buf[L_BUFSIZE];
l_int32  badchar;
GPLOT   *gplot;

    PROCNAME(""gplotCreate"");

    if (!rootname)
        return (GPLOT *)ERROR_PTR(""rootname not defined"", procName, NULL);
    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&
        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)
        return (GPLOT *)ERROR_PTR(""outformat invalid"", procName, NULL);
    stringCheckForChars(rootname, ""`;&|><\""?*"", &badchar);
    if (badchar)  /* danger of command injection */
        return (GPLOT *)ERROR_PTR(""invalid rootname"", procName, NULL);

    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)
        return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL);
    gplot->cmddata = sarrayCreate(0);
    gplot->datanames = sarrayCreate(0);
    gplot->plotdata = sarrayCreate(0);
    gplot->plottitles = sarrayCreate(0);
    gplot->plotstyles = numaCreate(0);

        /* Save title, labels, rootname, outformat, cmdname, outname */
    newroot = genPathname(rootname, NULL);
    gplot->rootname = newroot;
    gplot->outformat = outformat;
    snprintf(buf, L_BUFSIZE, ""%s.cmd"", rootname);
    gplot->cmdname = stringNew(buf);
    if (outformat == GPLOT_PNG)
        snprintf(buf, L_BUFSIZE, ""%s.png"", newroot);
    else if (outformat == GPLOT_PS)
        snprintf(buf, L_BUFSIZE, ""%s.ps"", newroot);
    else if (outformat == GPLOT_EPS)
        snprintf(buf, L_BUFSIZE, ""%s.eps"", newroot);
    else if (outformat == GPLOT_LATEX)
        snprintf(buf, L_BUFSIZE, ""%s.tex"", newroot);
    gplot->outname = stringNew(buf);
    if (title) gplot->title = stringNew(title);
    if (xlabel) gplot->xlabel = stringNew(xlabel);
    if (ylabel) gplot->ylabel = stringNew(ylabel);

    return gplot;
}","GPLOT  *
gplotCreate(const char  *VAR_0,
            l_int32      VAR_1,
            const char  *VAR_2,
            const char  *VAR_3,
            const char  *VAR_4)
{
char    *VAR_5;
char     VAR_6[VAR_7];
l_int32  VAR_8;
GPLOT   *VAR_9;

    PROCNAME(""gplotCreate"");

    if (!VAR_0)
        return (GPLOT *)ERROR_PTR(""rootname not defined"", VAR_10, NULL);
    if (VAR_1 != VAR_11 && VAR_1 != VAR_12 &&
        VAR_1 != VAR_13 && VAR_1 != VAR_14)
        return (GPLOT *)ERROR_PTR(""outformat invalid"", VAR_10, NULL);
    stringCheckForChars(VAR_0, ""`;&|><\""?*"", &VAR_8);
    if (VAR_8)  /* COMMENT_0 */
        return (GPLOT *)ERROR_PTR(""invalid rootname"", VAR_10, NULL);

    if ((VAR_9 = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)
        return (GPLOT *)ERROR_PTR(""gplot not made"", VAR_10, NULL);
    VAR_9->cmddata = sarrayCreate(0);
    VAR_9->datanames = sarrayCreate(0);
    VAR_9->plotdata = sarrayCreate(0);
    VAR_9->plottitles = sarrayCreate(0);
    VAR_9->plotstyles = numaCreate(0);

        /* COMMENT_1 */
    VAR_5 = genPathname(VAR_0, NULL);
    VAR_9->rootname = VAR_5;
    VAR_9->outformat = VAR_1;
    snprintf(VAR_6, VAR_7, ""%s.cmd"", VAR_0);
    VAR_9->cmdname = stringNew(VAR_6);
    if (VAR_1 == VAR_11)
        snprintf(VAR_6, VAR_7, ""%s.png"", VAR_5);
    else if (VAR_1 == VAR_12)
        snprintf(VAR_6, VAR_7, ""%s.ps"", VAR_5);
    else if (VAR_1 == VAR_13)
        snprintf(VAR_6, VAR_7, ""%s.eps"", VAR_5);
    else if (VAR_1 == VAR_14)
        snprintf(VAR_6, VAR_7, ""%s.tex"", VAR_5);
    VAR_9->outname = stringNew(VAR_6);
    if (VAR_2) VAR_9->title = stringNew(VAR_2);
    if (VAR_3) VAR_9->xlabel = stringNew(VAR_3);
    if (VAR_4) VAR_9->ylabel = stringNew(VAR_4);

    return VAR_9;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
             const char  *ylabel)
 {
 char    *newroot;
-char     buf[L_BUF_SIZE];
+char     buf[L_BUFSIZE];
 l_int32  badchar;
 GPLOT   *gplot;
 
@@ -33,16 +33,16 @@
     newroot = genPathname(rootname, NULL);
     gplot->rootname = newroot;
     gplot->outformat = outformat;
-    snprintf(buf, L_BUF_SIZE, ""%s.cmd"", rootname);
+    snprintf(buf, L_BUFSIZE, ""%s.cmd"", rootname);
     gplot->cmdname = stringNew(buf);
     if (outformat == GPLOT_PNG)
-        snprintf(buf, L_BUF_SIZE, ""%s.png"", newroot);
+        snprintf(buf, L_BUFSIZE, ""%s.png"", newroot);
     else if (outformat == GPLOT_PS)
-        snprintf(buf, L_BUF_SIZE, ""%s.ps"", newroot);
+        snprintf(buf, L_BUFSIZE, ""%s.ps"", newroot);
     else if (outformat == GPLOT_EPS)
-        snprintf(buf, L_BUF_SIZE, ""%s.eps"", newroot);
+        snprintf(buf, L_BUFSIZE, ""%s.eps"", newroot);
     else if (outformat == GPLOT_LATEX)
-        snprintf(buf, L_BUF_SIZE, ""%s.tex"", newroot);
+        snprintf(buf, L_BUFSIZE, ""%s.tex"", newroot);
     gplot->outname = stringNew(buf);
     if (title) gplot->title = stringNew(title);
     if (xlabel) gplot->xlabel = stringNew(xlabel);","{'deleted_lines': ['char     buf[L_BUF_SIZE];', '    snprintf(buf, L_BUF_SIZE, ""%s.cmd"", rootname);', '        snprintf(buf, L_BUF_SIZE, ""%s.png"", newroot);', '        snprintf(buf, L_BUF_SIZE, ""%s.ps"", newroot);', '        snprintf(buf, L_BUF_SIZE, ""%s.eps"", newroot);', '        snprintf(buf, L_BUF_SIZE, ""%s.tex"", newroot);'], 'added_lines': ['char     buf[L_BUFSIZE];', '    snprintf(buf, L_BUFSIZE, ""%s.cmd"", rootname);', '        snprintf(buf, L_BUFSIZE, ""%s.png"", newroot);', '        snprintf(buf, L_BUFSIZE, ""%s.ps"", newroot);', '        snprintf(buf, L_BUFSIZE, ""%s.eps"", newroot);', '        snprintf(buf, L_BUFSIZE, ""%s.tex"", newroot);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/sel1.c,selReadStream,"SEL  *
selReadStream(FILE  *fp)
{
char    *selname;
char     linebuf[L_BUF_SIZE];
l_int32  sy, sx, cy, cx, i, j, version, ignore;
SEL     *sel;
PROCNAME(""selReadStream"");
if (!fp)
return (SEL *)ERROR_PTR(""stream not defined"", procName, NULL);
if (fscanf(fp, ""  Sel Version %d\n"", &version) != 1)
return (SEL *)ERROR_PTR(""not a sel file"", procName, NULL);
if (version != SEL_VERSION_NUMBER)
return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL);
if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)
return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
selname = stringNew(linebuf);
sscanf(linebuf, ""  ------  %s  ------"", selname);
if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
&sy, &sx, &cy, &cx) != 4) {
LEPT_FREE(selname);
return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL);
}
if ((sel = selCreate(sy, sx, selname)) == NULL) {
LEPT_FREE(selname);
return (SEL *)ERROR_PTR(""sel not made"", procName, NULL);
}
selSetOrigin(sel, cy, cx);
for (i = 0; i < sy; i++) {
ignore = fscanf(fp, ""    "");
for (j = 0; j < sx; j++)
ignore = fscanf(fp, ""%1d"", &sel->data[i][j]);
ignore = fscanf(fp, ""\n"");
}
ignore = fscanf(fp, ""\n"");
LEPT_FREE(selname);
return sel;
}","SEL  *
selReadStream(FILE  *VAR_0)
{
char    *VAR_1;
char     VAR_2[VAR_3];
l_int32  VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
SEL     *VAR_12;
PROCNAME(""selReadStream"");
if (!VAR_0)
return (SEL *)ERROR_PTR(""stream not defined"", VAR_13, NULL);
if (fscanf(VAR_0, ""  Sel Version %d\n"", &VAR_10) != 1)
return (SEL *)ERROR_PTR(""not a sel file"", VAR_13, NULL);
if (VAR_10 != VAR_14)
return (SEL *)ERROR_PTR(""invalid sel version"", VAR_13, NULL);
if (fgets(VAR_2, VAR_3, VAR_0) == NULL)
return (SEL *)ERROR_PTR(""error reading into linebuf"", VAR_13, NULL);
VAR_1 = stringNew(VAR_2);
sscanf(VAR_2, ""  ------  %s  ------"", VAR_1);
if (fscanf(VAR_0, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
&VAR_4, &VAR_5, &VAR_6, &VAR_7) != 4) {
LEPT_FREE(VAR_1);
return (SEL *)ERROR_PTR(""dimensions not read"", VAR_13, NULL);
}
if ((VAR_12 = selCreate(VAR_4, VAR_5, VAR_1)) == NULL) {
LEPT_FREE(VAR_1);
return (SEL *)ERROR_PTR(""sel not made"", VAR_13, NULL);
}
selSetOrigin(VAR_12, VAR_6, VAR_7);
for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++) {
VAR_11 = fscanf(VAR_0, ""    "");
for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++)
VAR_11 = fscanf(VAR_0, ""%1d"", &VAR_12->data[VAR_8][VAR_9]);
VAR_11 = fscanf(VAR_0, ""\n"");
}
VAR_11 = fscanf(VAR_0, ""\n"");
LEPT_FREE(VAR_1);
return VAR_12;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/before/1.json,"SEL  *
selReadStream(FILE  *fp)
{
char    *selname;
char     linebuf[L_BUFSIZE];
l_int32  sy, sx, cy, cx, i, j, version, ignore;
SEL     *sel;

    PROCNAME(""selReadStream"");

    if (!fp)
        return (SEL *)ERROR_PTR(""stream not defined"", procName, NULL);

    if (fscanf(fp, ""  Sel Version %d\n"", &version) != 1)
        return (SEL *)ERROR_PTR(""not a sel file"", procName, NULL);
    if (version != SEL_VERSION_NUMBER)
        return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL);

    if (fgets(linebuf, L_BUFSIZE, fp) == NULL)
        return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
    selname = stringNew(linebuf);
    sscanf(linebuf, ""  ------  %200s  ------"", selname);

    if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
            &sy, &sx, &cy, &cx) != 4) {
        LEPT_FREE(selname);
        return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL);
    }

    if ((sel = selCreate(sy, sx, selname)) == NULL) {
        LEPT_FREE(selname);
        return (SEL *)ERROR_PTR(""sel not made"", procName, NULL);
    }
    selSetOrigin(sel, cy, cx);

    for (i = 0; i < sy; i++) {
        ignore = fscanf(fp, ""    "");
        for (j = 0; j < sx; j++)
            ignore = fscanf(fp, ""%1d"", &sel->data[i][j]);
        ignore = fscanf(fp, ""\n"");
    }
    ignore = fscanf(fp, ""\n"");

    LEPT_FREE(selname);
    return sel;
}","SEL  *
selReadStream(FILE  *VAR_0)
{
char    *VAR_1;
char     VAR_2[VAR_3];
l_int32  VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
SEL     *VAR_12;

    PROCNAME(""selReadStream"");

    if (!VAR_0)
        return (SEL *)ERROR_PTR(""stream not defined"", VAR_13, NULL);

    if (fscanf(VAR_0, ""  Sel Version %d\n"", &VAR_10) != 1)
        return (SEL *)ERROR_PTR(""not a sel file"", VAR_13, NULL);
    if (VAR_10 != VAR_14)
        return (SEL *)ERROR_PTR(""invalid sel version"", VAR_13, NULL);

    if (fgets(VAR_2, VAR_3, VAR_0) == NULL)
        return (SEL *)ERROR_PTR(""error reading into linebuf"", VAR_13, NULL);
    VAR_1 = stringNew(VAR_2);
    sscanf(VAR_2, ""  ------  %200s  ------"", VAR_1);

    if (fscanf(VAR_0, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
            &VAR_4, &VAR_5, &VAR_6, &VAR_7) != 4) {
        LEPT_FREE(VAR_1);
        return (SEL *)ERROR_PTR(""dimensions not read"", VAR_13, NULL);
    }

    if ((VAR_12 = selCreate(VAR_4, VAR_5, VAR_1)) == NULL) {
        LEPT_FREE(VAR_1);
        return (SEL *)ERROR_PTR(""sel not made"", VAR_13, NULL);
    }
    selSetOrigin(VAR_12, VAR_6, VAR_7);

    for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++) {
        VAR_11 = fscanf(VAR_0, ""    "");
        for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++)
            VAR_11 = fscanf(VAR_0, ""%1d"", &VAR_12->data[VAR_8][VAR_9]);
        VAR_11 = fscanf(VAR_0, ""\n"");
    }
    VAR_11 = fscanf(VAR_0, ""\n"");

    LEPT_FREE(VAR_1);
    return VAR_12;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 selReadStream(FILE  *fp)
 {
 char    *selname;
-char     linebuf[L_BUF_SIZE];
+char     linebuf[L_BUFSIZE];
 l_int32  sy, sx, cy, cx, i, j, version, ignore;
 SEL     *sel;
 
@@ -16,10 +16,10 @@
     if (version != SEL_VERSION_NUMBER)
         return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL);
 
-    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)
+    if (fgets(linebuf, L_BUFSIZE, fp) == NULL)
         return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
     selname = stringNew(linebuf);
-    sscanf(linebuf, ""  ------  %s  ------"", selname);
+    sscanf(linebuf, ""  ------  %200s  ------"", selname);
 
     if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
             &sy, &sx, &cy, &cx) != 4) {","{'deleted_lines': ['char     linebuf[L_BUF_SIZE];', '    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)', '    sscanf(linebuf, ""  ------  %s  ------"", selname);'], 'added_lines': ['char     linebuf[L_BUFSIZE];', '    if (fgets(linebuf, L_BUFSIZE, fp) == NULL)', '    sscanf(linebuf, ""  ------  %200s  ------"", selname);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/gplot.c,gplotMakeOutput,"l_int32
gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
PROCNAME(""gplotMakeOutput"");
if (!gplot)
return ERROR_INT(""gplot not defined"", procName, 1);
gplotGenCommandFile(gplot);
gplotGenDataFiles(gplot);
cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  
#ifndef OS_IOS 
ignore = system(buf);  
#endif 
LEPT_FREE(cmdname);
return 0;
}","l_int32
gplotMakeOutput(GPLOT  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3;
l_int32  VAR_4;
PROCNAME(""gplotMakeOutput"");
if (!VAR_0)
return ERROR_INT(""gplot not defined"", VAR_5, 1);
gplotGenCommandFile(VAR_0);
gplotGenDataFiles(VAR_0);
VAR_3 = genPathname(VAR_0->cmdname, NULL);
#ifndef VAR_6
snprintf(VAR_1, VAR_2, ""gnuplot %s"", VAR_3);
#else
snprintf(VAR_1, VAR_2, ""wgnuplot %s"", VAR_3);
#endif  
#ifndef VAR_7 
VAR_4 = system(VAR_1);  
#endif 
LEPT_FREE(VAR_3);
return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/before/2.json,"l_int32
gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUFSIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUFSIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUFSIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","l_int32
gplotMakeOutput(GPLOT  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3;
l_int32  VAR_4;

    PROCNAME(""gplotMakeOutput"");

    if (!VAR_0)
        return ERROR_INT(""gplot not defined"", VAR_5, 1);

    gplotGenCommandFile(VAR_0);
    gplotGenDataFiles(VAR_0);
    VAR_3 = genPathname(VAR_0->cmdname, NULL);

#ifndef VAR_6
    snprintf(VAR_1, VAR_2, ""gnuplot %s"", VAR_3);
#else
    snprintf(VAR_1, VAR_2, ""wgnuplot %s"", VAR_3);
#endif  /* COMMENT_0 */

#ifndef VAR_7 /* COMMENT_1 */
    VAR_4 = system(VAR_1);  /* COMMENT_2 */
#endif /* COMMENT_3 */

    LEPT_FREE(VAR_3);
    return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 l_int32
 gplotMakeOutput(GPLOT  *gplot)
 {
-char     buf[L_BUF_SIZE];
+char     buf[L_BUFSIZE];
 char    *cmdname;
 l_int32  ignore;
 
@@ -15,9 +15,9 @@
     cmdname = genPathname(gplot->cmdname, NULL);
 
 #ifndef _WIN32
-    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
+    snprintf(buf, L_BUFSIZE, ""gnuplot %s"", cmdname);
 #else
-    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
+    snprintf(buf, L_BUFSIZE, ""wgnuplot %s"", cmdname);
 #endif  /* _WIN32 */
 
 #ifndef OS_IOS /* iOS 11 does not support system() */","{'deleted_lines': ['char     buf[L_BUF_SIZE];', '    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);', '    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);'], 'added_lines': ['char     buf[L_BUFSIZE];', '    snprintf(buf, L_BUFSIZE, ""gnuplot %s"", cmdname);', '    snprintf(buf, L_BUFSIZE, ""wgnuplot %s"", cmdname);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/gplot.c,gplotRead,"GPLOT *
gplotRead(const char  *filename)
{
char     buf[L_BUF_SIZE];
char    *rootname, *title, *xlabel, *ylabel, *ignores;
l_int32  outformat, ret, version, ignore;
FILE    *fp;
GPLOT   *gplot;
PROCNAME(""gplotRead"");
if (!filename)
return (GPLOT *)ERROR_PTR(""filename not defined"", procName, NULL);
if ((fp = fopenReadStream(filename)) == NULL)
return (GPLOT *)ERROR_PTR(""stream not opened"", procName, NULL);
ret = fscanf(fp, ""Gplot Version %d\n"", &version);
if (ret != 1) {
fclose(fp);
return (GPLOT *)ERROR_PTR(""not a gplot file"", procName, NULL);
}
if (version != GPLOT_VERSION_NUMBER) {
fclose(fp);
return (GPLOT *)ERROR_PTR(""invalid gplot version"", procName, NULL);
}
ignore = fscanf(fp, ""Rootname: %s\n"", buf);
rootname = stringNew(buf);
ignore = fscanf(fp, ""Output format: %d\n"", &outformat);
ignores = fgets(buf, L_BUF_SIZE, fp);   
title = stringNew(buf + 7);
title[strlen(title) - 1] = '\0';
ignores = fgets(buf, L_BUF_SIZE, fp);   
xlabel = stringNew(buf + 14);
xlabel[strlen(xlabel) - 1] = '\0';
ignores = fgets(buf, L_BUF_SIZE, fp);   
ylabel = stringNew(buf + 14);
ylabel[strlen(ylabel) - 1] = '\0';
gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);
LEPT_FREE(rootname);
LEPT_FREE(title);
LEPT_FREE(xlabel);
LEPT_FREE(ylabel);
if (!gplot) {
fclose(fp);
return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL);
}
sarrayDestroy(&gplot->cmddata);
sarrayDestroy(&gplot->datanames);
sarrayDestroy(&gplot->plotdata);
sarrayDestroy(&gplot->plottitles);
numaDestroy(&gplot->plotstyles);
ignore = fscanf(fp, ""Commandfile name: %s\n"", buf);
stringReplace(&gplot->cmdname, buf);
ignore = fscanf(fp, ""\nCommandfile data:"");
gplot->cmddata = sarrayReadStream(fp);
ignore = fscanf(fp, ""\nDatafile names:"");
gplot->datanames = sarrayReadStream(fp);
ignore = fscanf(fp, ""\nPlot data:"");
gplot->plotdata = sarrayReadStream(fp);
ignore = fscanf(fp, ""\nPlot titles:"");
gplot->plottitles = sarrayReadStream(fp);
ignore = fscanf(fp, ""\nPlot styles:"");
gplot->plotstyles = numaReadStream(fp);
ignore = fscanf(fp, ""Number of plots: %d\n"", &gplot->nplots);
ignore = fscanf(fp, ""Output file name: %s\n"", buf);
stringReplace(&gplot->outname, buf);
ignore = fscanf(fp, ""Axis scaling: %d\n"", &gplot->scaling);
fclose(fp);
return gplot;
}","GPLOT *
gplotRead(const char  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;
l_int32  VAR_8, VAR_9, VAR_10, VAR_11;
FILE    *VAR_12;
GPLOT   *VAR_13;
PROCNAME(""gplotRead"");
if (!VAR_0)
return (GPLOT *)ERROR_PTR(""filename not defined"", VAR_14, NULL);
if ((VAR_12 = fopenReadStream(VAR_0)) == NULL)
return (GPLOT *)ERROR_PTR(""stream not opened"", VAR_14, NULL);
VAR_9 = fscanf(VAR_12, ""Gplot Version %d\n"", &VAR_10);
if (VAR_9 != 1) {
fclose(VAR_12);
return (GPLOT *)ERROR_PTR(""not a gplot file"", VAR_14, NULL);
}
if (VAR_10 != VAR_15) {
fclose(VAR_12);
return (GPLOT *)ERROR_PTR(""invalid gplot version"", VAR_14, NULL);
}
VAR_11 = fscanf(VAR_12, ""Rootname: %s\n"", VAR_1);
VAR_3 = stringNew(VAR_1);
VAR_11 = fscanf(VAR_12, ""Output format: %d\n"", &VAR_8);
VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   
VAR_4 = stringNew(VAR_1 + 7);
VAR_4[strlen(VAR_4) - 1] = '\0';
VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   
VAR_5 = stringNew(VAR_1 + 14);
VAR_5[strlen(VAR_5) - 1] = '\0';
VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   
VAR_6 = stringNew(VAR_1 + 14);
VAR_6[strlen(VAR_6) - 1] = '\0';
VAR_13 = gplotCreate(VAR_3, VAR_8, VAR_4, VAR_5, VAR_6);
LEPT_FREE(VAR_3);
LEPT_FREE(VAR_4);
LEPT_FREE(VAR_5);
LEPT_FREE(VAR_6);
if (!VAR_13) {
fclose(VAR_12);
return (GPLOT *)ERROR_PTR(""gplot not made"", VAR_14, NULL);
}
sarrayDestroy(&VAR_13->cmddata);
sarrayDestroy(&VAR_13->datanames);
sarrayDestroy(&VAR_13->plotdata);
sarrayDestroy(&VAR_13->plottitles);
numaDestroy(&VAR_13->plotstyles);
VAR_11 = fscanf(VAR_12, ""Commandfile name: %s\n"", VAR_1);
stringReplace(&VAR_13->cmdname, VAR_1);
VAR_11 = fscanf(VAR_12, ""\nCommandfile data:"");
VAR_13->cmddata = sarrayReadStream(VAR_12);
VAR_11 = fscanf(VAR_12, ""\nDatafile names:"");
VAR_13->datanames = sarrayReadStream(VAR_12);
VAR_11 = fscanf(VAR_12, ""\nPlot data:"");
VAR_13->plotdata = sarrayReadStream(VAR_12);
VAR_11 = fscanf(VAR_12, ""\nPlot titles:"");
VAR_13->plottitles = sarrayReadStream(VAR_12);
VAR_11 = fscanf(VAR_12, ""\nPlot styles:"");
VAR_13->plotstyles = numaReadStream(VAR_12);
VAR_11 = fscanf(VAR_12, ""Number of plots: %d\n"", &VAR_13->nplots);
VAR_11 = fscanf(VAR_12, ""Output file name: %s\n"", VAR_1);
stringReplace(&VAR_13->outname, VAR_1);
VAR_11 = fscanf(VAR_12, ""Axis scaling: %d\n"", &VAR_13->scaling);
fclose(VAR_12);
return VAR_13;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/before/1.json,"GPLOT *
gplotRead(const char  *filename)
{
char     buf[L_BUFSIZE];
char    *rootname, *title, *xlabel, *ylabel, *ignores;
l_int32  outformat, ret, version, ignore;
FILE    *fp;
GPLOT   *gplot;

    PROCNAME(""gplotRead"");

    if (!filename)
        return (GPLOT *)ERROR_PTR(""filename not defined"", procName, NULL);

    if ((fp = fopenReadStream(filename)) == NULL)
        return (GPLOT *)ERROR_PTR(""stream not opened"", procName, NULL);

    ret = fscanf(fp, ""Gplot Version %d\n"", &version);
    if (ret != 1) {
        fclose(fp);
        return (GPLOT *)ERROR_PTR(""not a gplot file"", procName, NULL);
    }
    if (version != GPLOT_VERSION_NUMBER) {
        fclose(fp);
        return (GPLOT *)ERROR_PTR(""invalid gplot version"", procName, NULL);
    }

    ignore = fscanf(fp, ""Rootname: %511s\n"", buf);  /* L_BUFSIZE - 1 */
    rootname = stringNew(buf);
    ignore = fscanf(fp, ""Output format: %d\n"", &outformat);
    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */
    title = stringNew(buf + 7);
    title[strlen(title) - 1] = '\0';
    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */
    xlabel = stringNew(buf + 14);
    xlabel[strlen(xlabel) - 1] = '\0';
    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */
    ylabel = stringNew(buf + 14);
    ylabel[strlen(ylabel) - 1] = '\0';

    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);
    LEPT_FREE(rootname);
    LEPT_FREE(title);
    LEPT_FREE(xlabel);
    LEPT_FREE(ylabel);
    if (!gplot) {
        fclose(fp);
        return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL);
    }
    sarrayDestroy(&gplot->cmddata);
    sarrayDestroy(&gplot->datanames);
    sarrayDestroy(&gplot->plotdata);
    sarrayDestroy(&gplot->plottitles);
    numaDestroy(&gplot->plotstyles);

    ignore = fscanf(fp, ""Commandfile name: %511s\n"", buf);  /* L_BUFSIZE - 1 */
    stringReplace(&gplot->cmdname, buf);
    ignore = fscanf(fp, ""\nCommandfile data:"");
    gplot->cmddata = sarrayReadStream(fp);
    ignore = fscanf(fp, ""\nDatafile names:"");
    gplot->datanames = sarrayReadStream(fp);
    ignore = fscanf(fp, ""\nPlot data:"");
    gplot->plotdata = sarrayReadStream(fp);
    ignore = fscanf(fp, ""\nPlot titles:"");
    gplot->plottitles = sarrayReadStream(fp);
    ignore = fscanf(fp, ""\nPlot styles:"");
    gplot->plotstyles = numaReadStream(fp);

    ignore = fscanf(fp, ""Number of plots: %d\n"", &gplot->nplots);
    ignore = fscanf(fp, ""Output file name: %511s\n"", buf);
    stringReplace(&gplot->outname, buf);
    ignore = fscanf(fp, ""Axis scaling: %d\n"", &gplot->scaling);

    fclose(fp);
    return gplot;
}","GPLOT *
gplotRead(const char  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;
l_int32  VAR_8, VAR_9, VAR_10, VAR_11;
FILE    *VAR_12;
GPLOT   *VAR_13;

    PROCNAME(""gplotRead"");

    if (!VAR_0)
        return (GPLOT *)ERROR_PTR(""filename not defined"", VAR_14, NULL);

    if ((VAR_12 = fopenReadStream(VAR_0)) == NULL)
        return (GPLOT *)ERROR_PTR(""stream not opened"", VAR_14, NULL);

    VAR_9 = fscanf(VAR_12, ""Gplot Version %d\n"", &VAR_10);
    if (VAR_9 != 1) {
        fclose(VAR_12);
        return (GPLOT *)ERROR_PTR(""not a gplot file"", VAR_14, NULL);
    }
    if (VAR_10 != VAR_15) {
        fclose(VAR_12);
        return (GPLOT *)ERROR_PTR(""invalid gplot version"", VAR_14, NULL);
    }

    VAR_11 = fscanf(VAR_12, ""Rootname: %511s\n"", VAR_1);  /* COMMENT_0 */
    VAR_3 = stringNew(VAR_1);
    VAR_11 = fscanf(VAR_12, ""Output format: %d\n"", &VAR_8);
    VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   /* COMMENT_1 */
    VAR_4 = stringNew(VAR_1 + 7);
    VAR_4[strlen(VAR_4) - 1] = '\0';
    VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   /* COMMENT_2 */
    VAR_5 = stringNew(VAR_1 + 14);
    VAR_5[strlen(VAR_5) - 1] = '\0';
    VAR_7 = fgets(VAR_1, VAR_2, VAR_12);   /* COMMENT_3 */
    VAR_6 = stringNew(VAR_1 + 14);
    VAR_6[strlen(VAR_6) - 1] = '\0';

    VAR_13 = gplotCreate(VAR_3, VAR_8, VAR_4, VAR_5, VAR_6);
    LEPT_FREE(VAR_3);
    LEPT_FREE(VAR_4);
    LEPT_FREE(VAR_5);
    LEPT_FREE(VAR_6);
    if (!VAR_13) {
        fclose(VAR_12);
        return (GPLOT *)ERROR_PTR(""gplot not made"", VAR_14, NULL);
    }
    sarrayDestroy(&VAR_13->cmddata);
    sarrayDestroy(&VAR_13->datanames);
    sarrayDestroy(&VAR_13->plotdata);
    sarrayDestroy(&VAR_13->plottitles);
    numaDestroy(&VAR_13->plotstyles);

    VAR_11 = fscanf(VAR_12, ""Commandfile name: %511s\n"", VAR_1);  /* COMMENT_0 */
    stringReplace(&VAR_13->cmdname, VAR_1);
    VAR_11 = fscanf(VAR_12, ""\nCommandfile data:"");
    VAR_13->cmddata = sarrayReadStream(VAR_12);
    VAR_11 = fscanf(VAR_12, ""\nDatafile names:"");
    VAR_13->datanames = sarrayReadStream(VAR_12);
    VAR_11 = fscanf(VAR_12, ""\nPlot data:"");
    VAR_13->plotdata = sarrayReadStream(VAR_12);
    VAR_11 = fscanf(VAR_12, ""\nPlot titles:"");
    VAR_13->plottitles = sarrayReadStream(VAR_12);
    VAR_11 = fscanf(VAR_12, ""\nPlot styles:"");
    VAR_13->plotstyles = numaReadStream(VAR_12);

    VAR_11 = fscanf(VAR_12, ""Number of plots: %d\n"", &VAR_13->nplots);
    VAR_11 = fscanf(VAR_12, ""Output file name: %511s\n"", VAR_1);
    stringReplace(&VAR_13->outname, VAR_1);
    VAR_11 = fscanf(VAR_12, ""Axis scaling: %d\n"", &VAR_13->scaling);

    fclose(VAR_12);
    return VAR_13;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 GPLOT *
 gplotRead(const char  *filename)
 {
-char     buf[L_BUF_SIZE];
+char     buf[L_BUFSIZE];
 char    *rootname, *title, *xlabel, *ylabel, *ignores;
 l_int32  outformat, ret, version, ignore;
 FILE    *fp;
@@ -25,16 +25,16 @@
         return (GPLOT *)ERROR_PTR(""invalid gplot version"", procName, NULL);
     }
 
-    ignore = fscanf(fp, ""Rootname: %s\n"", buf);
+    ignore = fscanf(fp, ""Rootname: %511s\n"", buf);  /* L_BUFSIZE - 1 */
     rootname = stringNew(buf);
     ignore = fscanf(fp, ""Output format: %d\n"", &outformat);
-    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Title: ... */
+    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */
     title = stringNew(buf + 7);
     title[strlen(title) - 1] = '\0';
-    ignores = fgets(buf, L_BUF_SIZE, fp);   /* X axis label: ... */
+    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */
     xlabel = stringNew(buf + 14);
     xlabel[strlen(xlabel) - 1] = '\0';
-    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Y axis label: ... */
+    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */
     ylabel = stringNew(buf + 14);
     ylabel[strlen(ylabel) - 1] = '\0';
 
@@ -53,7 +53,7 @@
     sarrayDestroy(&gplot->plottitles);
     numaDestroy(&gplot->plotstyles);
 
-    ignore = fscanf(fp, ""Commandfile name: %s\n"", buf);
+    ignore = fscanf(fp, ""Commandfile name: %511s\n"", buf);  /* L_BUFSIZE - 1 */
     stringReplace(&gplot->cmdname, buf);
     ignore = fscanf(fp, ""\nCommandfile data:"");
     gplot->cmddata = sarrayReadStream(fp);
@@ -67,7 +67,7 @@
     gplot->plotstyles = numaReadStream(fp);
 
     ignore = fscanf(fp, ""Number of plots: %d\n"", &gplot->nplots);
-    ignore = fscanf(fp, ""Output file name: %s\n"", buf);
+    ignore = fscanf(fp, ""Output file name: %511s\n"", buf);
     stringReplace(&gplot->outname, buf);
     ignore = fscanf(fp, ""Axis scaling: %d\n"", &gplot->scaling);
 ","{'deleted_lines': ['char     buf[L_BUF_SIZE];', '    ignore = fscanf(fp, ""Rootname: %s\\n"", buf);', '    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Title: ... */', '    ignores = fgets(buf, L_BUF_SIZE, fp);   /* X axis label: ... */', '    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Y axis label: ... */', '    ignore = fscanf(fp, ""Commandfile name: %s\\n"", buf);', '    ignore = fscanf(fp, ""Output file name: %s\\n"", buf);'], 'added_lines': ['char     buf[L_BUFSIZE];', '    ignore = fscanf(fp, ""Rootname: %511s\\n"", buf);  /* L_BUFSIZE - 1 */', '    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */', '    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */', '    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */', '    ignore = fscanf(fp, ""Commandfile name: %511s\\n"", buf);  /* L_BUFSIZE - 1 */', '    ignore = fscanf(fp, ""Output file name: %511s\\n"", buf);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/gplot.c,gplotGenCommandFile,"l_int32
gplotGenCommandFile(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdstr, *plottitle, *dataname;
l_int32  i, plotstyle, nplots;
FILE    *fp;
PROCNAME(""gplotGenCommandFile"");
if (!gplot)
return ERROR_INT(""gplot not defined"", procName, 1);
sarrayClear(gplot->cmddata);
if (gplot->title) {   
snprintf(buf, L_BUF_SIZE, ""set title '%s'"", gplot->title);
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
if (gplot->xlabel) {   
snprintf(buf, L_BUF_SIZE, ""set xlabel '%s'"", gplot->xlabel);
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
if (gplot->ylabel) {   
snprintf(buf, L_BUF_SIZE, ""set ylabel '%s'"", gplot->ylabel);
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
if (gplot->outformat == GPLOT_PNG) {
snprintf(buf, L_BUF_SIZE, ""set terminal png; set output '%s'"",
gplot->outname);
} else if (gplot->outformat == GPLOT_PS) {
snprintf(buf, L_BUF_SIZE, ""set terminal postscript; set output '%s'"",
gplot->outname);
} else if (gplot->outformat == GPLOT_EPS) {
snprintf(buf, L_BUF_SIZE,
""set terminal postscript eps; set output '%s'"",
gplot->outname);
} else if (gplot->outformat == GPLOT_LATEX) {
snprintf(buf, L_BUF_SIZE, ""set terminal latex; set output '%s'"",
gplot->outname);
}
sarrayAddString(gplot->cmddata, buf, L_COPY);
if (gplot->scaling == GPLOT_LOG_SCALE_X ||
gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
snprintf(buf, L_BUF_SIZE, ""set logscale x"");
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
if (gplot->scaling == GPLOT_LOG_SCALE_Y ||
gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
snprintf(buf, L_BUF_SIZE, ""set logscale y"");
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
nplots = sarrayGetCount(gplot->datanames);
for (i = 0; i < nplots; i++) {
plottitle = sarrayGetString(gplot->plottitles, i, L_NOCOPY);
dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);
numaGetIValue(gplot->plotstyles, i, &plotstyle);
if (nplots == 1) {
snprintf(buf, L_BUF_SIZE, ""plot '%s' title '%s' %s"",
dataname, plottitle, gplotstylenames[plotstyle]);
} else {
if (i == 0)
snprintf(buf, L_BUF_SIZE, ""plot '%s' title '%s' %s, \\"",
dataname, plottitle, gplotstylenames[plotstyle]);
else if (i < nplots - 1)
snprintf(buf, L_BUF_SIZE, "" '%s' title '%s' %s, \\"",
dataname, plottitle, gplotstylenames[plotstyle]);
else
snprintf(buf, L_BUF_SIZE, "" '%s' title '%s' %s"",
dataname, plottitle, gplotstylenames[plotstyle]);
}
sarrayAddString(gplot->cmddata, buf, L_COPY);
}
cmdstr = sarrayToString(gplot->cmddata, 1);
if ((fp = fopenWriteStream(gplot->cmdname, ""w"")) == NULL) {
LEPT_FREE(cmdstr);
return ERROR_INT(""cmd stream not opened"", procName, 1);
}
fwrite(cmdstr, 1, strlen(cmdstr), fp);
fclose(fp);
LEPT_FREE(cmdstr);
return 0;
}","l_int32
gplotGenCommandFile(GPLOT  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3, *VAR_4, *VAR_5;
l_int32  VAR_6, VAR_7, VAR_8;
FILE    *VAR_9;
PROCNAME(""gplotGenCommandFile"");
if (!VAR_0)
return ERROR_INT(""gplot not defined"", VAR_10, 1);
sarrayClear(VAR_0->cmddata);
if (VAR_0->title) {   
snprintf(VAR_1, VAR_2, ""set title '%s'"", VAR_0->title);
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
if (VAR_0->xlabel) {   
snprintf(VAR_1, VAR_2, ""set xlabel '%s'"", VAR_0->xlabel);
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
if (VAR_0->ylabel) {   
snprintf(VAR_1, VAR_2, ""set ylabel '%s'"", VAR_0->ylabel);
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
if (VAR_0->outformat == VAR_12) {
snprintf(VAR_1, VAR_2, ""set terminal png; set output '%s'"",
VAR_0->outname);
} else if (VAR_0->outformat == VAR_13) {
snprintf(VAR_1, VAR_2, ""set terminal postscript; set output '%s'"",
VAR_0->outname);
} else if (VAR_0->outformat == VAR_14) {
snprintf(VAR_1, VAR_2,
""set terminal postscript eps; set output '%s'"",
VAR_0->outname);
} else if (VAR_0->outformat == VAR_15) {
snprintf(VAR_1, VAR_2, ""set terminal latex; set output '%s'"",
VAR_0->outname);
}
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
if (VAR_0->scaling == VAR_16 ||
VAR_0->scaling == VAR_17) {
snprintf(VAR_1, VAR_2, ""set logscale x"");
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
if (VAR_0->scaling == VAR_18 ||
VAR_0->scaling == VAR_17) {
snprintf(VAR_1, VAR_2, ""set logscale y"");
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
VAR_8 = sarrayGetCount(VAR_0->datanames);
for (VAR_6 = 0; VAR_6 < VAR_8; VAR_6++) {
VAR_4 = sarrayGetString(VAR_0->plottitles, VAR_6, VAR_19);
VAR_5 = sarrayGetString(VAR_0->datanames, VAR_6, VAR_19);
numaGetIValue(VAR_0->plotstyles, VAR_6, &VAR_7);
if (VAR_8 == 1) {
snprintf(VAR_1, VAR_2, ""plot '%s' title '%s' %s"",
VAR_5, VAR_4, VAR_20[VAR_7]);
} else {
if (VAR_6 == 0)
snprintf(VAR_1, VAR_2, ""plot '%s' title '%s' %s, \\"",
VAR_5, VAR_4, VAR_20[VAR_7]);
else if (VAR_6 < VAR_8 - 1)
snprintf(VAR_1, VAR_2, "" '%s' title '%s' %s, \\"",
VAR_5, VAR_4, VAR_20[VAR_7]);
else
snprintf(VAR_1, VAR_2, "" '%s' title '%s' %s"",
VAR_5, VAR_4, VAR_20[VAR_7]);
}
sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
}
VAR_3 = sarrayToString(VAR_0->cmddata, 1);
if ((VAR_9 = fopenWriteStream(VAR_0->cmdname, ""w"")) == NULL) {
LEPT_FREE(VAR_3);
return ERROR_INT(""cmd stream not opened"", VAR_10, 1);
}
fwrite(VAR_3, 1, strlen(VAR_3), VAR_9);
fclose(VAR_9);
LEPT_FREE(VAR_3);
return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/before/0.json,"l_int32
gplotGenCommandFile(GPLOT  *gplot)
{
char     buf[L_BUFSIZE];
char    *cmdstr, *plottitle, *dataname;
l_int32  i, plotstyle, nplots;
FILE    *fp;

    PROCNAME(""gplotGenCommandFile"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

        /* Remove any previous command data */
    sarrayClear(gplot->cmddata);

        /* Generate command data instructions */
    if (gplot->title) {   /* set title */
        snprintf(buf, L_BUFSIZE, ""set title '%s'"", gplot->title);
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }
    if (gplot->xlabel) {   /* set xlabel */
        snprintf(buf, L_BUFSIZE, ""set xlabel '%s'"", gplot->xlabel);
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }
    if (gplot->ylabel) {   /* set ylabel */
        snprintf(buf, L_BUFSIZE, ""set ylabel '%s'"", gplot->ylabel);
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }

        /* Set terminal type and output */
    if (gplot->outformat == GPLOT_PNG) {
        snprintf(buf, L_BUFSIZE, ""set terminal png; set output '%s'"",
                 gplot->outname);
    } else if (gplot->outformat == GPLOT_PS) {
        snprintf(buf, L_BUFSIZE, ""set terminal postscript; set output '%s'"",
                 gplot->outname);
    } else if (gplot->outformat == GPLOT_EPS) {
        snprintf(buf, L_BUFSIZE,
                 ""set terminal postscript eps; set output '%s'"",
                 gplot->outname);
    } else if (gplot->outformat == GPLOT_LATEX) {
        snprintf(buf, L_BUFSIZE, ""set terminal latex; set output '%s'"",
                 gplot->outname);
    }
    sarrayAddString(gplot->cmddata, buf, L_COPY);

    if (gplot->scaling == GPLOT_LOG_SCALE_X ||
        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
        snprintf(buf, L_BUFSIZE, ""set logscale x"");
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }
    if (gplot->scaling == GPLOT_LOG_SCALE_Y ||
        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
        snprintf(buf, L_BUFSIZE, ""set logscale y"");
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }

    nplots = sarrayGetCount(gplot->datanames);
    for (i = 0; i < nplots; i++) {
        plottitle = sarrayGetString(gplot->plottitles, i, L_NOCOPY);
        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);
        numaGetIValue(gplot->plotstyles, i, &plotstyle);
        if (nplots == 1) {
            snprintf(buf, L_BUFSIZE, ""plot '%s' title '%s' %s"",
                     dataname, plottitle, gplotstylenames[plotstyle]);
        } else {
            if (i == 0)
                snprintf(buf, L_BUFSIZE, ""plot '%s' title '%s' %s, \\"",
                     dataname, plottitle, gplotstylenames[plotstyle]);
            else if (i < nplots - 1)
                snprintf(buf, L_BUFSIZE, "" '%s' title '%s' %s, \\"",
                     dataname, plottitle, gplotstylenames[plotstyle]);
            else
                snprintf(buf, L_BUFSIZE, "" '%s' title '%s' %s"",
                     dataname, plottitle, gplotstylenames[plotstyle]);
        }
        sarrayAddString(gplot->cmddata, buf, L_COPY);
    }

        /* Write command data to file */
    cmdstr = sarrayToString(gplot->cmddata, 1);
    if ((fp = fopenWriteStream(gplot->cmdname, ""w"")) == NULL) {
        LEPT_FREE(cmdstr);
        return ERROR_INT(""cmd stream not opened"", procName, 1);
    }
    fwrite(cmdstr, 1, strlen(cmdstr), fp);
    fclose(fp);
    LEPT_FREE(cmdstr);
    return 0;
}","l_int32
gplotGenCommandFile(GPLOT  *VAR_0)
{
char     VAR_1[VAR_2];
char    *VAR_3, *VAR_4, *VAR_5;
l_int32  VAR_6, VAR_7, VAR_8;
FILE    *VAR_9;

    PROCNAME(""gplotGenCommandFile"");

    if (!VAR_0)
        return ERROR_INT(""gplot not defined"", VAR_10, 1);

        /* COMMENT_0 */
    sarrayClear(VAR_0->cmddata);

        /* COMMENT_1 */
    if (VAR_0->title) {   /* COMMENT_2 */
        snprintf(VAR_1, VAR_2, ""set title '%s'"", VAR_0->title);
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }
    if (VAR_0->xlabel) {   /* COMMENT_3 */
        snprintf(VAR_1, VAR_2, ""set xlabel '%s'"", VAR_0->xlabel);
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }
    if (VAR_0->ylabel) {   /* COMMENT_4 */
        snprintf(VAR_1, VAR_2, ""set ylabel '%s'"", VAR_0->ylabel);
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }

        /* COMMENT_5 */
    if (VAR_0->outformat == VAR_12) {
        snprintf(VAR_1, VAR_2, ""set terminal png; set output '%s'"",
                 VAR_0->outname);
    } else if (VAR_0->outformat == VAR_13) {
        snprintf(VAR_1, VAR_2, ""set terminal postscript; set output '%s'"",
                 VAR_0->outname);
    } else if (VAR_0->outformat == VAR_14) {
        snprintf(VAR_1, VAR_2,
                 ""set terminal postscript eps; set output '%s'"",
                 VAR_0->outname);
    } else if (VAR_0->outformat == VAR_15) {
        snprintf(VAR_1, VAR_2, ""set terminal latex; set output '%s'"",
                 VAR_0->outname);
    }
    sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);

    if (VAR_0->scaling == VAR_16 ||
        VAR_0->scaling == VAR_17) {
        snprintf(VAR_1, VAR_2, ""set logscale x"");
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }
    if (VAR_0->scaling == VAR_18 ||
        VAR_0->scaling == VAR_17) {
        snprintf(VAR_1, VAR_2, ""set logscale y"");
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }

    VAR_8 = sarrayGetCount(VAR_0->datanames);
    for (VAR_6 = 0; VAR_6 < VAR_8; VAR_6++) {
        VAR_4 = sarrayGetString(VAR_0->plottitles, VAR_6, VAR_19);
        VAR_5 = sarrayGetString(VAR_0->datanames, VAR_6, VAR_19);
        numaGetIValue(VAR_0->plotstyles, VAR_6, &VAR_7);
        if (VAR_8 == 1) {
            snprintf(VAR_1, VAR_2, ""plot '%s' title '%s' %s"",
                     VAR_5, VAR_4, VAR_20[VAR_7]);
        } else {
            if (VAR_6 == 0)
                snprintf(VAR_1, VAR_2, ""plot '%s' title '%s' %s, \\"",
                     VAR_5, VAR_4, VAR_20[VAR_7]);
            else if (VAR_6 < VAR_8 - 1)
                snprintf(VAR_1, VAR_2, "" '%s' title '%s' %s, \\"",
                     VAR_5, VAR_4, VAR_20[VAR_7]);
            else
                snprintf(VAR_1, VAR_2, "" '%s' title '%s' %s"",
                     VAR_5, VAR_4, VAR_20[VAR_7]);
        }
        sarrayAddString(VAR_0->cmddata, VAR_1, VAR_11);
    }

        /* COMMENT_6 */
    VAR_3 = sarrayToString(VAR_0->cmddata, 1);
    if ((VAR_9 = fopenWriteStream(VAR_0->cmdname, ""w"")) == NULL) {
        LEPT_FREE(VAR_3);
        return ERROR_INT(""cmd stream not opened"", VAR_10, 1);
    }
    fwrite(VAR_3, 1, strlen(VAR_3), VAR_9);
    fclose(VAR_9);
    LEPT_FREE(VAR_3);
    return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 l_int32
 gplotGenCommandFile(GPLOT  *gplot)
 {
-char     buf[L_BUF_SIZE];
+char     buf[L_BUFSIZE];
 char    *cmdstr, *plottitle, *dataname;
 l_int32  i, plotstyle, nplots;
 FILE    *fp;
@@ -16,43 +16,43 @@
 
         /* Generate command data instructions */
     if (gplot->title) {   /* set title */
-        snprintf(buf, L_BUF_SIZE, ""set title '%s'"", gplot->title);
+        snprintf(buf, L_BUFSIZE, ""set title '%s'"", gplot->title);
         sarrayAddString(gplot->cmddata, buf, L_COPY);
     }
     if (gplot->xlabel) {   /* set xlabel */
-        snprintf(buf, L_BUF_SIZE, ""set xlabel '%s'"", gplot->xlabel);
+        snprintf(buf, L_BUFSIZE, ""set xlabel '%s'"", gplot->xlabel);
         sarrayAddString(gplot->cmddata, buf, L_COPY);
     }
     if (gplot->ylabel) {   /* set ylabel */
-        snprintf(buf, L_BUF_SIZE, ""set ylabel '%s'"", gplot->ylabel);
+        snprintf(buf, L_BUFSIZE, ""set ylabel '%s'"", gplot->ylabel);
         sarrayAddString(gplot->cmddata, buf, L_COPY);
     }
 
         /* Set terminal type and output */
     if (gplot->outformat == GPLOT_PNG) {
-        snprintf(buf, L_BUF_SIZE, ""set terminal png; set output '%s'"",
+        snprintf(buf, L_BUFSIZE, ""set terminal png; set output '%s'"",
                  gplot->outname);
     } else if (gplot->outformat == GPLOT_PS) {
-        snprintf(buf, L_BUF_SIZE, ""set terminal postscript; set output '%s'"",
+        snprintf(buf, L_BUFSIZE, ""set terminal postscript; set output '%s'"",
                  gplot->outname);
     } else if (gplot->outformat == GPLOT_EPS) {
-        snprintf(buf, L_BUF_SIZE,
+        snprintf(buf, L_BUFSIZE,
                  ""set terminal postscript eps; set output '%s'"",
                  gplot->outname);
     } else if (gplot->outformat == GPLOT_LATEX) {
-        snprintf(buf, L_BUF_SIZE, ""set terminal latex; set output '%s'"",
+        snprintf(buf, L_BUFSIZE, ""set terminal latex; set output '%s'"",
                  gplot->outname);
     }
     sarrayAddString(gplot->cmddata, buf, L_COPY);
 
     if (gplot->scaling == GPLOT_LOG_SCALE_X ||
         gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
-        snprintf(buf, L_BUF_SIZE, ""set logscale x"");
+        snprintf(buf, L_BUFSIZE, ""set logscale x"");
         sarrayAddString(gplot->cmddata, buf, L_COPY);
     }
     if (gplot->scaling == GPLOT_LOG_SCALE_Y ||
         gplot->scaling == GPLOT_LOG_SCALE_X_Y) {
-        snprintf(buf, L_BUF_SIZE, ""set logscale y"");
+        snprintf(buf, L_BUFSIZE, ""set logscale y"");
         sarrayAddString(gplot->cmddata, buf, L_COPY);
     }
 
@@ -62,17 +62,17 @@
         dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);
         numaGetIValue(gplot->plotstyles, i, &plotstyle);
         if (nplots == 1) {
-            snprintf(buf, L_BUF_SIZE, ""plot '%s' title '%s' %s"",
+            snprintf(buf, L_BUFSIZE, ""plot '%s' title '%s' %s"",
                      dataname, plottitle, gplotstylenames[plotstyle]);
         } else {
             if (i == 0)
-                snprintf(buf, L_BUF_SIZE, ""plot '%s' title '%s' %s, \\"",
+                snprintf(buf, L_BUFSIZE, ""plot '%s' title '%s' %s, \\"",
                      dataname, plottitle, gplotstylenames[plotstyle]);
             else if (i < nplots - 1)
-                snprintf(buf, L_BUF_SIZE, "" '%s' title '%s' %s, \\"",
+                snprintf(buf, L_BUFSIZE, "" '%s' title '%s' %s, \\"",
                      dataname, plottitle, gplotstylenames[plotstyle]);
             else
-                snprintf(buf, L_BUF_SIZE, "" '%s' title '%s' %s"",
+                snprintf(buf, L_BUFSIZE, "" '%s' title '%s' %s"",
                      dataname, plottitle, gplotstylenames[plotstyle]);
         }
         sarrayAddString(gplot->cmddata, buf, L_COPY);","{'deleted_lines': ['char     buf[L_BUF_SIZE];', '        snprintf(buf, L_BUF_SIZE, ""set title \'%s\'"", gplot->title);', '        snprintf(buf, L_BUF_SIZE, ""set xlabel \'%s\'"", gplot->xlabel);', '        snprintf(buf, L_BUF_SIZE, ""set ylabel \'%s\'"", gplot->ylabel);', '        snprintf(buf, L_BUF_SIZE, ""set terminal png; set output \'%s\'"",', '        snprintf(buf, L_BUF_SIZE, ""set terminal postscript; set output \'%s\'"",', '        snprintf(buf, L_BUF_SIZE,', '        snprintf(buf, L_BUF_SIZE, ""set terminal latex; set output \'%s\'"",', '        snprintf(buf, L_BUF_SIZE, ""set logscale x"");', '        snprintf(buf, L_BUF_SIZE, ""set logscale y"");', '            snprintf(buf, L_BUF_SIZE, ""plot \'%s\' title \'%s\' %s"",', '                snprintf(buf, L_BUF_SIZE, ""plot \'%s\' title \'%s\' %s, \\\\"",', '                snprintf(buf, L_BUF_SIZE, "" \'%s\' title \'%s\' %s, \\\\"",', '                snprintf(buf, L_BUF_SIZE, "" \'%s\' title \'%s\' %s"",'], 'added_lines': ['char     buf[L_BUFSIZE];', '        snprintf(buf, L_BUFSIZE, ""set title \'%s\'"", gplot->title);', '        snprintf(buf, L_BUFSIZE, ""set xlabel \'%s\'"", gplot->xlabel);', '        snprintf(buf, L_BUFSIZE, ""set ylabel \'%s\'"", gplot->ylabel);', '        snprintf(buf, L_BUFSIZE, ""set terminal png; set output \'%s\'"",', '        snprintf(buf, L_BUFSIZE, ""set terminal postscript; set output \'%s\'"",', '        snprintf(buf, L_BUFSIZE,', '        snprintf(buf, L_BUFSIZE, ""set terminal latex; set output \'%s\'"",', '        snprintf(buf, L_BUFSIZE, ""set logscale x"");', '        snprintf(buf, L_BUFSIZE, ""set logscale y"");', '            snprintf(buf, L_BUFSIZE, ""plot \'%s\' title \'%s\' %s"",', '                snprintf(buf, L_BUFSIZE, ""plot \'%s\' title \'%s\' %s, \\\\"",', '                snprintf(buf, L_BUFSIZE, "" \'%s\' title \'%s\' %s, \\\\"",', '                snprintf(buf, L_BUFSIZE, "" \'%s\' title \'%s\' %s"",']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/sel1.c,selaComputeCompositeParameters,"static void
selaComputeCompositeParameters(const char  *fileout)
{
char    *str, *nameh1, *nameh2, *namev1, *namev2;
char     buf[L_BUF_SIZE];
l_int32  size, size1, size2, len;
SARRAY  *sa;
SELA    *selabasic, *selacomb;
selabasic = selaAddBasic(NULL);
selacomb = selaAddDwaCombs(NULL);
sa = sarrayCreate(64);
for (size = 2; size < 64; size++) {
selectComposableSizes(size, &size1, &size2);
nameh1 = selaGetBrickName(selabasic, size1, 1);
namev1 = selaGetBrickName(selabasic, 1, size1);
if (size2 > 1) {
nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);
namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);
} else {
nameh2 = stringNew("""");
namev2 = stringNew("""");
}
snprintf(buf, L_BUF_SIZE,
""      { %d, %d, %d, \""%s\"", \""%s\"", \""%s\"", \""%s\"" },"",
size, size1, size2, nameh1, nameh2, namev1, namev2);
sarrayAddString(sa, buf, L_COPY);
LEPT_FREE(nameh1);
LEPT_FREE(nameh2);
LEPT_FREE(namev1);
LEPT_FREE(namev2);
}
str = sarrayToString(sa, 1);
len = strlen(str);
l_binaryWrite(fileout, ""w"", str, len + 1);
LEPT_FREE(str);
sarrayDestroy(&sa);
selaDestroy(&selabasic);
selaDestroy(&selacomb);
return;
}","static void
selaComputeCompositeParameters(const char  *VAR_0)
{
char    *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5;
char     VAR_6[VAR_7];
l_int32  VAR_8, VAR_9, VAR_10, VAR_11;
SARRAY  *VAR_12;
SELA    *VAR_13, *VAR_14;
VAR_13 = selaAddBasic(NULL);
VAR_14 = selaAddDwaCombs(NULL);
VAR_12 = sarrayCreate(64);
for (VAR_8 = 2; VAR_8 < 64; VAR_8++) {
selectComposableSizes(VAR_8, &VAR_9, &VAR_10);
VAR_2 = selaGetBrickName(VAR_13, VAR_9, 1);
VAR_4 = selaGetBrickName(VAR_13, 1, VAR_9);
if (VAR_10 > 1) {
VAR_3 = selaGetCombName(VAR_14, VAR_9 * VAR_10, VAR_15);
VAR_5 = selaGetCombName(VAR_14, VAR_9 * VAR_10, VAR_16);
} else {
VAR_3 = stringNew("""");
VAR_5 = stringNew("""");
}
snprintf(VAR_6, VAR_7,
""      { %d, %d, %d, \""%s\"", \""%s\"", \""%s\"", \""%s\"" },"",
VAR_8, VAR_9, VAR_10, VAR_2, VAR_3, VAR_4, VAR_5);
sarrayAddString(VAR_12, VAR_6, VAR_17);
LEPT_FREE(VAR_2);
LEPT_FREE(VAR_3);
LEPT_FREE(VAR_4);
LEPT_FREE(VAR_5);
}
VAR_1 = sarrayToString(VAR_12, 1);
VAR_11 = strlen(VAR_1);
l_binaryWrite(VAR_0, ""w"", VAR_1, VAR_11 + 1);
LEPT_FREE(VAR_1);
sarrayDestroy(&VAR_12);
selaDestroy(&VAR_13);
selaDestroy(&VAR_14);
return;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/before/2.json,"static void
selaComputeCompositeParameters(const char  *fileout)
{
char    *str, *nameh1, *nameh2, *namev1, *namev2;
char     buf[L_BUFSIZE];
l_int32  size, size1, size2, len;
SARRAY  *sa;
SELA    *selabasic, *selacomb;

    selabasic = selaAddBasic(NULL);
    selacomb = selaAddDwaCombs(NULL);
    sa = sarrayCreate(64);
    for (size = 2; size < 64; size++) {
        selectComposableSizes(size, &size1, &size2);
        nameh1 = selaGetBrickName(selabasic, size1, 1);
        namev1 = selaGetBrickName(selabasic, 1, size1);
        if (size2 > 1) {
            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);
            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);
        } else {
            nameh2 = stringNew("""");
            namev2 = stringNew("""");
        }
        snprintf(buf, L_BUFSIZE,
                 ""      { %d, %d, %d, \""%s\"", \""%s\"", \""%s\"", \""%s\"" },"",
                 size, size1, size2, nameh1, nameh2, namev1, namev2);
        sarrayAddString(sa, buf, L_COPY);
        LEPT_FREE(nameh1);
        LEPT_FREE(nameh2);
        LEPT_FREE(namev1);
        LEPT_FREE(namev2);
    }
    str = sarrayToString(sa, 1);
    len = strlen(str);
    l_binaryWrite(fileout, ""w"", str, len + 1);
    LEPT_FREE(str);
    sarrayDestroy(&sa);
    selaDestroy(&selabasic);
    selaDestroy(&selacomb);
    return;
}","static void
selaComputeCompositeParameters(const char  *VAR_0)
{
char    *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5;
char     VAR_6[VAR_7];
l_int32  VAR_8, VAR_9, VAR_10, VAR_11;
SARRAY  *VAR_12;
SELA    *VAR_13, *VAR_14;

    VAR_13 = selaAddBasic(NULL);
    VAR_14 = selaAddDwaCombs(NULL);
    VAR_12 = sarrayCreate(64);
    for (VAR_8 = 2; VAR_8 < 64; VAR_8++) {
        selectComposableSizes(VAR_8, &VAR_9, &VAR_10);
        VAR_2 = selaGetBrickName(VAR_13, VAR_9, 1);
        VAR_4 = selaGetBrickName(VAR_13, 1, VAR_9);
        if (VAR_10 > 1) {
            VAR_3 = selaGetCombName(VAR_14, VAR_9 * VAR_10, VAR_15);
            VAR_5 = selaGetCombName(VAR_14, VAR_9 * VAR_10, VAR_16);
        } else {
            VAR_3 = stringNew("""");
            VAR_5 = stringNew("""");
        }
        snprintf(VAR_6, VAR_7,
                 ""      { %d, %d, %d, \""%s\"", \""%s\"", \""%s\"", \""%s\"" },"",
                 VAR_8, VAR_9, VAR_10, VAR_2, VAR_3, VAR_4, VAR_5);
        sarrayAddString(VAR_12, VAR_6, VAR_17);
        LEPT_FREE(VAR_2);
        LEPT_FREE(VAR_3);
        LEPT_FREE(VAR_4);
        LEPT_FREE(VAR_5);
    }
    VAR_1 = sarrayToString(VAR_12, 1);
    VAR_11 = strlen(VAR_1);
    l_binaryWrite(VAR_0, ""w"", VAR_1, VAR_11 + 1);
    LEPT_FREE(VAR_1);
    sarrayDestroy(&VAR_12);
    selaDestroy(&VAR_13);
    selaDestroy(&VAR_14);
    return;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/sel1.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 selaComputeCompositeParameters(const char  *fileout)
 {
 char    *str, *nameh1, *nameh2, *namev1, *namev2;
-char     buf[L_BUF_SIZE];
+char     buf[L_BUFSIZE];
 l_int32  size, size1, size2, len;
 SARRAY  *sa;
 SELA    *selabasic, *selacomb;
@@ -21,7 +21,7 @@
             nameh2 = stringNew("""");
             namev2 = stringNew("""");
         }
-        snprintf(buf, L_BUF_SIZE,
+        snprintf(buf, L_BUFSIZE,
                  ""      { %d, %d, %d, \""%s\"", \""%s\"", \""%s\"", \""%s\"" },"",
                  size, size1, size2, nameh1, nameh2, namev1, namev2);
         sarrayAddString(sa, buf, L_COPY);","{'deleted_lines': ['char     buf[L_BUF_SIZE];', '        snprintf(buf, L_BUF_SIZE,'], 'added_lines': ['char     buf[L_BUFSIZE];', '        snprintf(buf, L_BUFSIZE,']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7186,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DanBloomberg/leptonica,"Security fixes: expect final changes for release 1.75.3.
* Fixed a debian security issue with fscanf() reading a string with
  possible buffer overflow.
* There were also a few similar situations with sscanf().",ee301cb2029db8a6289c5295daa42bba7715e99a,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,src/gplot.c,gplotAddPlot,"l_int32
gplotAddPlot(GPLOT       *gplot,
NUMA        *nax,
NUMA        *nay,
l_int32      plotstyle,
const char  *plottitle)
{
char       buf[L_BUF_SIZE];
char       emptystring[] = """";
char      *datastr, *title;
l_int32    n, i;
l_float32  valx, valy, startx, delx;
SARRAY    *sa;
PROCNAME(""gplotAddPlot"");
if (!gplot)
return ERROR_INT(""gplot not defined"", procName, 1);
if (!nay)
return ERROR_INT(""nay not defined"", procName, 1);
if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)
return ERROR_INT(""invalid plotstyle"", procName, 1);
if ((n = numaGetCount(nay)) == 0)
return ERROR_INT(""no points to plot"", procName, 1);
if (nax && (n != numaGetCount(nax)))
return ERROR_INT(""nax and nay sizes differ"", procName, 1);
if (n == 1 && plotstyle == GPLOT_LINES) {
L_INFO(""only 1 pt; changing style to points\n"", procName);
plotstyle = GPLOT_POINTS;
}
numaGetParameters(nay, &startx, &delx);
numaAddNumber(gplot->plotstyles, plotstyle);
if (plottitle) {
title = stringNew(plottitle);
sarrayAddString(gplot->plottitles, title, L_INSERT);
} else {
sarrayAddString(gplot->plottitles, emptystring, L_COPY);
}
gplot->nplots++;
snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
sarrayAddString(gplot->datanames, buf, L_COPY);
sa = sarrayCreate(n);
for (i = 0; i < n; i++) {
if (nax)
numaGetFValue(nax, i, &valx);
else
valx = startx + i * delx;
numaGetFValue(nay, i, &valy);
snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);
sarrayAddString(sa, buf, L_COPY);
}
datastr = sarrayToString(sa, 0);
sarrayAddString(gplot->plotdata, datastr, L_INSERT);
sarrayDestroy(&sa);
return 0;
}","l_int32
gplotAddPlot(GPLOT       *VAR_0,
NUMA        *VAR_1,
NUMA        *VAR_2,
l_int32      VAR_3,
const char  *VAR_4)
{
char       VAR_5[VAR_6];
char       VAR_7[] = """";
char      *VAR_8, *VAR_9;
l_int32    VAR_10, VAR_11;
l_float32  VAR_12, VAR_13, VAR_14, VAR_15;
SARRAY    *VAR_16;
PROCNAME(""gplotAddPlot"");
if (!VAR_0)
return ERROR_INT(""gplot not defined"", VAR_17, 1);
if (!VAR_2)
return ERROR_INT(""nay not defined"", VAR_17, 1);
if (VAR_3 < 0 || VAR_3 >= VAR_18)
return ERROR_INT(""invalid plotstyle"", VAR_17, 1);
if ((VAR_10 = numaGetCount(VAR_2)) == 0)
return ERROR_INT(""no points to plot"", VAR_17, 1);
if (VAR_1 && (VAR_10 != numaGetCount(VAR_1)))
return ERROR_INT(""nax and nay sizes differ"", VAR_17, 1);
if (VAR_10 == 1 && VAR_3 == VAR_19) {
L_INFO(""only 1 pt; changing style to points\n"", VAR_17);
VAR_3 = VAR_20;
}
numaGetParameters(VAR_2, &VAR_14, &VAR_15);
numaAddNumber(VAR_0->plotstyles, VAR_3);
if (VAR_4) {
VAR_9 = stringNew(VAR_4);
sarrayAddString(VAR_0->plottitles, VAR_9, VAR_21);
} else {
sarrayAddString(VAR_0->plottitles, VAR_7, VAR_22);
}
VAR_0->nplots++;
snprintf(VAR_5, VAR_6, ""%s.data.%d"", VAR_0->rootname, VAR_0->nplots);
sarrayAddString(VAR_0->datanames, VAR_5, VAR_22);
VAR_16 = sarrayCreate(VAR_10);
for (VAR_11 = 0; VAR_11 < VAR_10; VAR_11++) {
if (VAR_1)
numaGetFValue(VAR_1, VAR_11, &VAR_12);
else
VAR_12 = VAR_14 + VAR_11 * VAR_15;
numaGetFValue(VAR_2, VAR_11, &VAR_13);
snprintf(VAR_5, VAR_6, ""%f %f\n"", VAR_12, VAR_13);
sarrayAddString(VAR_16, VAR_5, VAR_22);
}
VAR_8 = sarrayToString(VAR_16, 0);
sarrayAddString(VAR_0->plotdata, VAR_8, VAR_21);
sarrayDestroy(&VAR_16);
return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/before/3.json,"l_int32
gplotAddPlot(GPLOT       *gplot,
             NUMA        *nax,
             NUMA        *nay,
             l_int32      plotstyle,
             const char  *plottitle)
{
char       buf[L_BUFSIZE];
char       emptystring[] = """";
char      *datastr, *title;
l_int32    n, i;
l_float32  valx, valy, startx, delx;
SARRAY    *sa;

    PROCNAME(""gplotAddPlot"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    if (!nay)
        return ERROR_INT(""nay not defined"", procName, 1);
    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)
        return ERROR_INT(""invalid plotstyle"", procName, 1);

    if ((n = numaGetCount(nay)) == 0)
        return ERROR_INT(""no points to plot"", procName, 1);
    if (nax && (n != numaGetCount(nax)))
        return ERROR_INT(""nax and nay sizes differ"", procName, 1);
    if (n == 1 && plotstyle == GPLOT_LINES) {
        L_INFO(""only 1 pt; changing style to points\n"", procName);
        plotstyle = GPLOT_POINTS;
    }

        /* Save plotstyle and plottitle */
    numaGetParameters(nay, &startx, &delx);
    numaAddNumber(gplot->plotstyles, plotstyle);
    if (plottitle) {
        title = stringNew(plottitle);
        sarrayAddString(gplot->plottitles, title, L_INSERT);
    } else {
        sarrayAddString(gplot->plottitles, emptystring, L_COPY);
    }

        /* Generate and save data filename */
    gplot->nplots++;
    snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
    sarrayAddString(gplot->datanames, buf, L_COPY);

        /* Generate data and save as a string */
    sa = sarrayCreate(n);
    for (i = 0; i < n; i++) {
        if (nax)
            numaGetFValue(nax, i, &valx);
        else
            valx = startx + i * delx;
        numaGetFValue(nay, i, &valy);
        snprintf(buf, L_BUFSIZE, ""%f %f\n"", valx, valy);
        sarrayAddString(sa, buf, L_COPY);
    }
    datastr = sarrayToString(sa, 0);
    sarrayAddString(gplot->plotdata, datastr, L_INSERT);
    sarrayDestroy(&sa);

    return 0;
}","l_int32
gplotAddPlot(GPLOT       *VAR_0,
             NUMA        *VAR_1,
             NUMA        *VAR_2,
             l_int32      VAR_3,
             const char  *VAR_4)
{
char       VAR_5[VAR_6];
char       VAR_7[] = """";
char      *VAR_8, *VAR_9;
l_int32    VAR_10, VAR_11;
l_float32  VAR_12, VAR_13, VAR_14, VAR_15;
SARRAY    *VAR_16;

    PROCNAME(""gplotAddPlot"");

    if (!VAR_0)
        return ERROR_INT(""gplot not defined"", VAR_17, 1);
    if (!VAR_2)
        return ERROR_INT(""nay not defined"", VAR_17, 1);
    if (VAR_3 < 0 || VAR_3 >= VAR_18)
        return ERROR_INT(""invalid plotstyle"", VAR_17, 1);

    if ((VAR_10 = numaGetCount(VAR_2)) == 0)
        return ERROR_INT(""no points to plot"", VAR_17, 1);
    if (VAR_1 && (VAR_10 != numaGetCount(VAR_1)))
        return ERROR_INT(""nax and nay sizes differ"", VAR_17, 1);
    if (VAR_10 == 1 && VAR_3 == VAR_19) {
        L_INFO(""only 1 pt; changing style to points\n"", VAR_17);
        VAR_3 = VAR_20;
    }

        /* COMMENT_0 */
    numaGetParameters(VAR_2, &VAR_14, &VAR_15);
    numaAddNumber(VAR_0->plotstyles, VAR_3);
    if (VAR_4) {
        VAR_9 = stringNew(VAR_4);
        sarrayAddString(VAR_0->plottitles, VAR_9, VAR_21);
    } else {
        sarrayAddString(VAR_0->plottitles, VAR_7, VAR_22);
    }

        /* COMMENT_1 */
    VAR_0->nplots++;
    snprintf(VAR_5, VAR_6, ""%s.data.%d"", VAR_0->rootname, VAR_0->nplots);
    sarrayAddString(VAR_0->datanames, VAR_5, VAR_22);

        /* COMMENT_2 */
    VAR_16 = sarrayCreate(VAR_10);
    for (VAR_11 = 0; VAR_11 < VAR_10; VAR_11++) {
        if (VAR_1)
            numaGetFValue(VAR_1, VAR_11, &VAR_12);
        else
            VAR_12 = VAR_14 + VAR_11 * VAR_15;
        numaGetFValue(VAR_2, VAR_11, &VAR_13);
        snprintf(VAR_5, VAR_6, ""%f %f\n"", VAR_12, VAR_13);
        sarrayAddString(VAR_16, VAR_5, VAR_22);
    }
    VAR_8 = sarrayToString(VAR_16, 0);
    sarrayAddString(VAR_0->plotdata, VAR_8, VAR_21);
    sarrayDestroy(&VAR_16);

    return 0;
}",DanBloomberg/leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a/gplot.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
              l_int32      plotstyle,
              const char  *plottitle)
 {
-char       buf[L_BUF_SIZE];
+char       buf[L_BUFSIZE];
 char       emptystring[] = """";
 char      *datastr, *title;
 l_int32    n, i;
@@ -42,7 +42,7 @@
 
         /* Generate and save data filename */
     gplot->nplots++;
-    snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
+    snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
     sarrayAddString(gplot->datanames, buf, L_COPY);
 
         /* Generate data and save as a string */
@@ -53,7 +53,7 @@
         else
             valx = startx + i * delx;
         numaGetFValue(nay, i, &valy);
-        snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);
+        snprintf(buf, L_BUFSIZE, ""%f %f\n"", valx, valy);
         sarrayAddString(sa, buf, L_COPY);
     }
     datastr = sarrayToString(sa, 0);","{'deleted_lines': ['char       buf[L_BUF_SIZE];', '    snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);', '        snprintf(buf, L_BUF_SIZE, ""%f %f\\n"", valx, valy);'], 'added_lines': ['char       buf[L_BUFSIZE];', '    snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);', '        snprintf(buf, L_BUFSIZE, ""%f %f\\n"", valx, valy);']}",True,"Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.",9.8,CRITICAL,3,valid,2018-02-15T23:19:04Z,2
CVE-2018-7470,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/998,9e80713e5132a3bd26702ee0a833306f7e801469,https://github.com/ImageMagick/ImageMagick/commit/9e80713e5132a3bd26702ee0a833306f7e801469,coders/webp.c,IsWEBPImageLossless,"static MagickBooleanType IsWEBPImageLossless(const unsigned char *stream,
const size_t length)
{
#define VP8_CHUNK_INDEX  15
#define LOSSLESS_FLAG  'L'
#define EXTENDED_HEADER  'X'
#define VP8_CHUNK_HEADER  ""VP8""
#define VP8_CHUNK_HEADER_SIZE  3
#define RIFF_HEADER_SIZE  12
#define VP8X_CHUNK_SIZE  10
#define TAG_SIZE  4
#define CHUNK_SIZE_BYTES  4
#define CHUNK_HEADER_SIZE  8
#define MAX_CHUNK_PAYLOAD  (~0U-CHUNK_HEADER_SIZE-1)
ssize_t
offset;
if (stream[VP8_CHUNK_INDEX] != EXTENDED_HEADER)
return(stream[VP8_CHUNK_INDEX] == LOSSLESS_FLAG ? MagickTrue : MagickFalse);
offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;
while (offset <= (ssize_t) length)
{
uint32_t
chunk_size,
chunk_size_pad;
chunk_size=ReadWebPLSBWord(stream+offset+TAG_SIZE);
if (chunk_size > MAX_CHUNK_PAYLOAD)
break;
chunk_size_pad=(CHUNK_HEADER_SIZE+chunk_size+1) & ~1;
if (memcmp(stream+offset,VP8_CHUNK_HEADER,VP8_CHUNK_HEADER_SIZE) == 0)
return(*(stream+offset+VP8_CHUNK_HEADER_SIZE) == LOSSLESS_FLAG ?
MagickTrue : MagickFalse);
offset+=chunk_size_pad;
}
return(MagickFalse);
}","static MagickBooleanType IsWEBPImageLossless(const unsigned char *VAR_0,
const size_t VAR_1)
{
#define VAR_2  15
#define VAR_3  'L'
#define VAR_4  'X'
#define VAR_5  ""VP8""
#define VAR_6  3
#define VAR_7  12
#define VAR_8  10
#define VAR_9  4
#define VAR_10  4
#define VAR_11  8
#define VAR_12  (~0U-CHUNK_HEADER_SIZE-1)
ssize_t
VAR_13;
if (VAR_0[VAR_2] != VAR_4)
return(VAR_0[VAR_2] == VAR_3 ? VAR_14 : VAR_15);
VAR_13=VAR_7+VAR_9+VAR_10+VAR_8;
while (VAR_13 <= (ssize_t) VAR_1)
{
uint32_t
VAR_16,
VAR_17;
VAR_16=ReadWebPLSBWord(VAR_0+VAR_13+VAR_9);
if (VAR_16 > VAR_12)
break;
VAR_17=(VAR_11+VAR_16+1) & ~1;
if (memcmp(VAR_0+VAR_13,VAR_5,VAR_6) == 0)
return(*(VAR_0+VAR_13+VAR_6) == VAR_3 ?
VAR_14 : VAR_15);
VAR_13+=VAR_17;
}
return(VAR_15);
}",ImageMagick/9e80713e5132a3bd26702ee0a833306f7e801469/webp.c/vul/before/0.json,"static MagickBooleanType IsWEBPImageLossless(const unsigned char *stream,
  const size_t length)
{
#define VP8_CHUNK_INDEX  15
#define LOSSLESS_FLAG  'L'
#define EXTENDED_HEADER  'X'
#define VP8_CHUNK_HEADER  ""VP8""
#define VP8_CHUNK_HEADER_SIZE  3
#define RIFF_HEADER_SIZE  12
#define VP8X_CHUNK_SIZE  10
#define TAG_SIZE  4
#define CHUNK_SIZE_BYTES  4
#define CHUNK_HEADER_SIZE  8
#define MAX_CHUNK_PAYLOAD  (~0U-CHUNK_HEADER_SIZE-1)

  ssize_t
    offset;

  /*
    Read simple header.
  */
  if (stream[VP8_CHUNK_INDEX] != EXTENDED_HEADER)
    return(stream[VP8_CHUNK_INDEX] == LOSSLESS_FLAG ? MagickTrue : MagickFalse);
  /*
    Read extended header.
  */
  offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;
  while (offset <= (ssize_t) (length-TAG_SIZE))
  {
    uint32_t
      chunk_size,
      chunk_size_pad;

    chunk_size=ReadWebPLSBWord(stream+offset+TAG_SIZE);
    if (chunk_size > MAX_CHUNK_PAYLOAD)
      break;
    chunk_size_pad=(CHUNK_HEADER_SIZE+chunk_size+1) & ~1;
    if (memcmp(stream+offset,VP8_CHUNK_HEADER,VP8_CHUNK_HEADER_SIZE) == 0)
      return(*(stream+offset+VP8_CHUNK_HEADER_SIZE) == LOSSLESS_FLAG ?
        MagickTrue : MagickFalse);
    offset+=chunk_size_pad;
  }
  return(MagickFalse);
}","static MagickBooleanType IsWEBPImageLossless(const unsigned char *VAR_0,
  const size_t VAR_1)
{
#define VAR_2  15
#define VAR_3  'L'
#define VAR_4  'X'
#define VAR_5  ""VP8""
#define VAR_6  3
#define VAR_7  12
#define VAR_8  10
#define VAR_9  4
#define VAR_10  4
#define VAR_11  8
#define VAR_12  (~0U-CHUNK_HEADER_SIZE-1)

  ssize_t
    VAR_13;

  /* COMMENT_0 */
                       
    
  if (VAR_0[VAR_2] != VAR_4)
    return(VAR_0[VAR_2] == VAR_3 ? VAR_14 : VAR_15);
  /* COMMENT_3 */
                         
    
  VAR_13=VAR_7+VAR_9+VAR_10+VAR_8;
  while (VAR_13 <= (ssize_t) (VAR_1-VAR_9))
  {
    uint32_t
      VAR_16,
      VAR_17;

    VAR_16=ReadWebPLSBWord(VAR_0+VAR_13+VAR_9);
    if (VAR_16 > VAR_12)
      break;
    VAR_17=(VAR_11+VAR_16+1) & ~1;
    if (memcmp(VAR_0+VAR_13,VAR_5,VAR_6) == 0)
      return(*(VAR_0+VAR_13+VAR_6) == VAR_3 ?
        VAR_14 : VAR_15);
    VAR_13+=VAR_17;
  }
  return(VAR_15);
}",ImageMagick/9e80713e5132a3bd26702ee0a833306f7e801469/webp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,7 @@
     Read extended header.
   */
   offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;
-  while (offset <= (ssize_t) length)
+  while (offset <= (ssize_t) (length-TAG_SIZE))
   {
     uint32_t
       chunk_size,","{'deleted_lines': ['  while (offset <= (ssize_t) length)'], 'added_lines': ['  while (offset <= (ssize_t) (length-TAG_SIZE))']}",True,An issue was discovered in ImageMagick 7.0.7-22 Q16. The IsWEBPImageLossless function in coders/webp.c allows attackers to cause a denial of service (segmentation violation) via a crafted file.,6.5,MEDIUM,1,valid,2018-02-23T10:15:02Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_mfhd_body,"static gint
dissect_mp4_mfhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo _U_, proto_tree *tree)
{
gint offset_start;
offset_start = offset;
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
proto_tree_add_item(tree, hf_mp4_mfhd_seq_num,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
return offset-offset_start;
}","static gint
dissect_mp4_mfhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
gint VAR_5;
VAR_5 = VAR_1;
proto_tree_add_item(VAR_4, VAR_6,
VAR_0, VAR_1, 1, VAR_7);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_8,
VAR_0, VAR_1, 3, VAR_7);
VAR_1 += 3;
proto_tree_add_item(VAR_4, VAR_9,
VAR_0, VAR_1, 4, VAR_7);
VAR_1 += 4;
return VAR_1-VAR_5;
}",,"static gint
dissect_mp4_mfhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
    gint offset_start;

    offset_start = offset;
    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    proto_tree_add_item(tree, hf_mp4_mfhd_seq_num,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    return offset-offset_start;
}","static gint
dissect_mp4_mfhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint VAR_6;

    VAR_6 = VAR_1;
    proto_tree_add_item(VAR_5, VAR_7,
            VAR_0, VAR_1, 1, VAR_8);
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_9,
            VAR_0, VAR_1, 3, VAR_8);
    VAR_1 += 3;

    proto_tree_add_item(VAR_5, VAR_10,
            VAR_0, VAR_1, 4, VAR_8);
    VAR_1 += 4;

    return VAR_1-VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_mfhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
     gint offset_start;
 ","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_ftyp_body,"static gint
dissect_mp4_ftyp_body(tvbuff_t *tvb, gint offset, gint len,
packet_info *pinfo _U_, proto_tree *tree)
{
gint offset_start;
offset_start = offset;
proto_tree_add_item(tree, hf_mp4_ftyp_brand,
tvb, offset, 4, ENC_ASCII|ENC_NA);
offset += 4;
proto_tree_add_item(tree, hf_mp4_ftyp_ver,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
while ((offset-offset_start) < len) {
proto_tree_add_item(tree, hf_mp4_ftyp_add_brand,
tvb, offset, 4, ENC_ASCII|ENC_NA);
offset += 4;
}
return offset - offset_start;
}","static gint
dissect_mp4_ftyp_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
gint VAR_5;
VAR_5 = VAR_1;
proto_tree_add_item(VAR_4, VAR_6,
VAR_0, VAR_1, 4, VAR_7|VAR_8);
VAR_1 += 4;
proto_tree_add_item(VAR_4, VAR_9,
VAR_0, VAR_1, 4, VAR_10);
VAR_1 += 4;
while ((VAR_1-VAR_5) < VAR_2) {
proto_tree_add_item(VAR_4, VAR_11,
VAR_0, VAR_1, 4, VAR_7|VAR_8);
VAR_1 += 4;
}
return VAR_1 - VAR_5;
}",,"static gint
dissect_mp4_ftyp_body(tvbuff_t *tvb, gint offset, gint len,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
    gint offset_start;

    offset_start = offset;
    proto_tree_add_item(tree, hf_mp4_ftyp_brand,
            tvb, offset, 4, ENC_ASCII|ENC_NA);
    offset += 4;
    proto_tree_add_item(tree, hf_mp4_ftyp_ver,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    while ((offset-offset_start) < len) {
        proto_tree_add_item(tree, hf_mp4_ftyp_add_brand,
                tvb, offset, 4, ENC_ASCII|ENC_NA);
        offset += 4;
    }

    return offset - offset_start;
}","static gint
dissect_mp4_ftyp_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint VAR_6;

    VAR_6 = VAR_1;
    proto_tree_add_item(VAR_5, VAR_7,
            VAR_0, VAR_1, 4, VAR_8|VAR_9);
    VAR_1 += 4;
    proto_tree_add_item(VAR_5, VAR_10,
            VAR_0, VAR_1, 4, VAR_11);
    VAR_1 += 4;

    while ((VAR_1-VAR_6) < VAR_2) {
        proto_tree_add_item(VAR_5, VAR_12,
                VAR_0, VAR_1, 4, VAR_8|VAR_9);
        VAR_1 += 4;
    }

    return VAR_1 - VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_ftyp_body(tvbuff_t *tvb, gint offset, gint len,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
     gint offset_start;
 ","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_stsd_body,"static gint
dissect_mp4_stsd_body(tvbuff_t *tvb, gint offset, gint len,
packet_info *pinfo, proto_tree *tree)
{
guint32  entry_cnt, i;
gint     ret;
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
entry_cnt = tvb_get_ntohl(tvb, offset);
proto_tree_add_item(tree, hf_mp4_stsd_entry_cnt,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
for(i=0; i<entry_cnt; i++) {
ret = dissect_mp4_box(BOX_TYPE_STSD, tvb, offset, pinfo, tree);
if (ret<=0)
break;
offset += ret;
}
return len;
}","static gint
dissect_mp4_stsd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
packet_info *VAR_3, proto_tree *VAR_4)
{
guint32  VAR_5, VAR_6;
gint     VAR_7;
proto_tree_add_item(VAR_4, VAR_8,
VAR_0, VAR_1, 1, VAR_9);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_10,
VAR_0, VAR_1, 3, VAR_9);
VAR_1 += 3;
VAR_5 = tvb_get_ntohl(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_11,
VAR_0, VAR_1, 4, VAR_9);
VAR_1 += 4;
for(VAR_6=0; VAR_6<VAR_5; VAR_6++) {
VAR_7 = dissect_mp4_box(VAR_12, VAR_0, VAR_1, VAR_3, VAR_4);
if (VAR_7<=0)
break;
VAR_1 += VAR_7;
}
return VAR_2;
}",wireshark/2113179835b37549f245ac7c05ff2b96276893e4/file-mp4.c/vul/before/7.json,"static gint
dissect_mp4_stsd_body(tvbuff_t *tvb, gint offset, gint len,
        packet_info *pinfo, guint depth, proto_tree *tree)
{
    guint32  entry_cnt, i;
    gint     ret;

    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    /* XXX - put up an expert info if version!=0 */
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    entry_cnt = tvb_get_ntohl(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_stsd_entry_cnt,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    for(i=0; i<entry_cnt; i++) {
        /* a sample entry has the same format as an mp4 box
           we call dissect_mp4_box() to dissect it
           alternatively, we could parse it ourselves, we'd then have to
           handle the extended lengths etc */

        /* XXX - dissect the content of each Sample Entry,
           this depends on the handler_type, we could add an optional
           void *data parameter to dissect_mp4_box() and handle sample
           entry boxes based on parent box and data parameter */
        ret = dissect_mp4_box(BOX_TYPE_STSD, depth, tvb, offset, pinfo, tree);
        if (ret<=0)
            break;

        offset += ret;
    }

    return len;
}","static gint
dissect_mp4_stsd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
        packet_info *VAR_3, guint VAR_4, proto_tree *VAR_5)
{
    guint32  VAR_6, VAR_7;
    gint     VAR_8;

    proto_tree_add_item(VAR_5, VAR_9,
            VAR_0, VAR_1, 1, VAR_10);
    /* COMMENT_0 */
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_11,
            VAR_0, VAR_1, 3, VAR_10);
    VAR_1 += 3;

    VAR_6 = tvb_get_ntohl(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_12,
            VAR_0, VAR_1, 4, VAR_10);
    VAR_1 += 4;

    for(VAR_7=0; VAR_7<VAR_6; VAR_7++) {
        /* COMMENT_1 */
                                                  
                                                                        
                                             

        /* COMMENT_5 */
                                                                     
                                                                      
                                                                
        VAR_8 = dissect_mp4_box(VAR_13, VAR_4, VAR_0, VAR_1, VAR_3, VAR_5);
        if (VAR_8<=0)
            break;

        VAR_1 += VAR_8;
    }

    return VAR_2;
}",wireshark/2113179835b37549f245ac7c05ff2b96276893e4/file-mp4.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_stsd_body(tvbuff_t *tvb, gint offset, gint len,
-        packet_info *pinfo, proto_tree *tree)
+        packet_info *pinfo, guint depth, proto_tree *tree)
 {
     guint32  entry_cnt, i;
     gint     ret;
@@ -28,7 +28,7 @@
            this depends on the handler_type, we could add an optional
            void *data parameter to dissect_mp4_box() and handle sample
            entry boxes based on parent box and data parameter */
-        ret = dissect_mp4_box(BOX_TYPE_STSD, tvb, offset, pinfo, tree);
+        ret = dissect_mp4_box(BOX_TYPE_STSD, depth, tvb, offset, pinfo, tree);
         if (ret<=0)
             break;
 ","{'deleted_lines': ['        packet_info *pinfo, proto_tree *tree)', '        ret = dissect_mp4_box(BOX_TYPE_STSD, tvb, offset, pinfo, tree);'], 'added_lines': ['        packet_info *pinfo, guint depth, proto_tree *tree)', '        ret = dissect_mp4_box(BOX_TYPE_STSD, depth, tvb, offset, pinfo, tree);']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_dref_body,"static gint
dissect_mp4_dref_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo, proto_tree *tree)
{
gint     offset_start;
guint32  entry_cnt, i;
gint     ret;
offset_start = offset;
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
entry_cnt = tvb_get_ntohl(tvb, offset);
proto_tree_add_item(tree, hf_mp4_dref_entry_cnt,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
for(i=0; i<entry_cnt; i++) {
ret = dissect_mp4_box(BOX_TYPE_DREF, tvb, offset, pinfo, tree);
if (ret<=0)
break;
offset += ret;
}
return offset-offset_start;
}","static gint
dissect_mp4_dref_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3, proto_tree *VAR_4)
{
gint     VAR_5;
guint32  VAR_6, VAR_7;
gint     VAR_8;
VAR_5 = VAR_1;
proto_tree_add_item(VAR_4, VAR_9,
VAR_0, VAR_1, 1, VAR_10);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_11,
VAR_0, VAR_1, 3, VAR_10);
VAR_1 += 3;
VAR_6 = tvb_get_ntohl(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_12,
VAR_0, VAR_1, 4, VAR_10);
VAR_1 += 4;
for(VAR_7=0; VAR_7<VAR_6; VAR_7++) {
VAR_8 = dissect_mp4_box(VAR_13, VAR_0, VAR_1, VAR_3, VAR_4);
if (VAR_8<=0)
break;
VAR_1 += VAR_8;
}
return VAR_1-VAR_5;
}",,"static gint
dissect_mp4_dref_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo, guint depth, proto_tree *tree)
{
    gint     offset_start;
    guint32  entry_cnt, i;
    gint     ret;

    offset_start = offset;

    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    /* XXX - put up an expert info if version!=0 */
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    entry_cnt = tvb_get_ntohl(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_dref_entry_cnt,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    for(i=0; i<entry_cnt; i++) {
        ret = dissect_mp4_box(BOX_TYPE_DREF, depth, tvb, offset, pinfo, tree);
        if (ret<=0)
            break;

        offset += ret;
    }

    return offset-offset_start;
}","static gint
dissect_mp4_dref_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3, guint VAR_4, proto_tree *VAR_5)
{
    gint     VAR_6;
    guint32  VAR_7, VAR_8;
    gint     VAR_9;

    VAR_6 = VAR_1;

    proto_tree_add_item(VAR_5, VAR_10,
            VAR_0, VAR_1, 1, VAR_11);
    /* COMMENT_0 */
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_12,
            VAR_0, VAR_1, 3, VAR_11);
    VAR_1 += 3;

    VAR_7 = tvb_get_ntohl(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_13,
            VAR_0, VAR_1, 4, VAR_11);
    VAR_1 += 4;

    for(VAR_8=0; VAR_8<VAR_7; VAR_8++) {
        VAR_9 = dissect_mp4_box(VAR_14, VAR_4, VAR_0, VAR_1, VAR_3, VAR_5);
        if (VAR_9<=0)
            break;

        VAR_1 += VAR_9;
    }

    return VAR_1-VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_dref_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo, proto_tree *tree)
+        packet_info *pinfo, guint depth, proto_tree *tree)
 {
     gint     offset_start;
     guint32  entry_cnt, i;
@@ -22,7 +22,7 @@
     offset += 4;
 
     for(i=0; i<entry_cnt; i++) {
-        ret = dissect_mp4_box(BOX_TYPE_DREF, tvb, offset, pinfo, tree);
+        ret = dissect_mp4_box(BOX_TYPE_DREF, depth, tvb, offset, pinfo, tree);
         if (ret<=0)
             break;
 ","{'deleted_lines': ['        packet_info *pinfo, proto_tree *tree)', '        ret = dissect_mp4_box(BOX_TYPE_DREF, tvb, offset, pinfo, tree);'], 'added_lines': ['        packet_info *pinfo, guint depth, proto_tree *tree)', '        ret = dissect_mp4_box(BOX_TYPE_DREF, depth, tvb, offset, pinfo, tree);']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4,"static int
dissect_mp4(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
gint        offset = 0;
guint32     box_type;
proto_item *pi;
proto_tree *mp4_tree;
gint        ret;
if (tvb_reported_length(tvb) < MIN_BOX_SIZE)
return 0;
box_type = tvb_get_ntohl(tvb, 4);
if (try_val_to_str(box_type, box_types) == NULL)
return 0;
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""MP4"");
col_clear(pinfo->cinfo, COL_INFO);
pi = proto_tree_add_protocol_format(tree, proto_mp4,
tvb, 0, (gint)tvb_reported_length(tvb), ""MP4"");
mp4_tree = proto_item_add_subtree(pi, ett_mp4);
while (tvb_reported_length_remaining(tvb, offset) > 0) {
ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);
if (ret <= 0)
break;
offset += ret;
}
return offset;
}","static int
dissect_mp4(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)
{
gint        VAR_4 = 0;
guint32     VAR_5;
proto_item *VAR_6;
proto_tree *VAR_7;
gint        VAR_8;
if (tvb_reported_length(VAR_0) < VAR_9)
return 0;
VAR_5 = tvb_get_ntohl(VAR_0, 4);
if (try_val_to_str(VAR_5, VAR_10) == NULL)
return 0;
col_set_str(VAR_1->cinfo, VAR_11, ""MP4"");
col_clear(VAR_1->cinfo, VAR_12);
VAR_6 = proto_tree_add_protocol_format(VAR_2, VAR_13,
VAR_0, 0, (gint)tvb_reported_length(VAR_0), ""MP4"");
VAR_7 = proto_item_add_subtree(VAR_6, VAR_14);
while (tvb_reported_length_remaining(VAR_0, VAR_4) > 0) {
VAR_8 = dissect_mp4_box(VAR_15, VAR_0, VAR_4, VAR_1, VAR_7);
if (VAR_8 <= 0)
break;
VAR_4 += VAR_8;
}
return VAR_4;
}",,"static int
dissect_mp4(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{
    gint        offset = 0;
    guint32     box_type;
    proto_item *pi;
    proto_tree *mp4_tree;
    gint        ret;

    /* to make sure that we have an mp4 file, we check that it starts with
        a box of a known type
       please note that we do not allow the first box to be an extended box
       this detection should be safe as long as the dissector is only called for
        the video/mp4 mime type
       when we read mp4 files directly, we might need stricter checks here */
    if (tvb_reported_length(tvb) < MIN_BOX_SIZE)
        return 0;
    box_type = tvb_get_ntohl(tvb, 4);
    if (try_val_to_str(box_type, box_types) == NULL)
        return 0;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""MP4"");
    col_clear(pinfo->cinfo, COL_INFO);

    pi = proto_tree_add_protocol_format(tree, proto_mp4,
            tvb, 0, (gint)tvb_reported_length(tvb), ""MP4"");
    mp4_tree = proto_item_add_subtree(pi, ett_mp4);

    while (tvb_reported_length_remaining(tvb, offset) > 0) {
        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);
        if (ret <= 0)
            break;
        offset += ret;
    }

    return offset;
}","static int
dissect_mp4(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)
{
    gint        VAR_4 = 0;
    guint32     VAR_5;
    proto_item *VAR_6;
    proto_tree *VAR_7;
    gint        VAR_8;

    /* COMMENT_0 */
                             
                                                                           
                                                                                
                               
                                                                             
    if (tvb_reported_length(VAR_0) < VAR_9)
        return 0;
    VAR_5 = tvb_get_ntohl(VAR_0, 4);
    if (try_val_to_str(VAR_5, VAR_10) == NULL)
        return 0;

    col_set_str(VAR_1->cinfo, VAR_11, ""MP4"");
    col_clear(VAR_1->cinfo, VAR_12);

    VAR_6 = proto_tree_add_protocol_format(VAR_2, VAR_13,
            VAR_0, 0, (gint)tvb_reported_length(VAR_0), ""MP4"");
    VAR_7 = proto_item_add_subtree(VAR_6, VAR_14);

    while (tvb_reported_length_remaining(VAR_0, VAR_4) > 0) {
        VAR_8 = dissect_mp4_box(VAR_15, 0, VAR_0, VAR_4, VAR_1, VAR_7);
        if (VAR_8 <= 0)
            break;
        VAR_4 += VAR_8;
    }

    return VAR_4;
}",,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
     mp4_tree = proto_item_add_subtree(pi, ett_mp4);
 
     while (tvb_reported_length_remaining(tvb, offset) > 0) {
-        ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);
+        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);
         if (ret <= 0)
             break;
         offset += ret;","{'deleted_lines': ['        ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);'], 'added_lines': ['        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_box,"static gint
dissect_mp4_box(guint32 parent_box_type _U_,
tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)
{
gint        offset_start;
guint64     box_size;
guint32     box_type;
guint8     *box_type_str;
proto_item *type_pi, *size_pi, *ext_size_pi = NULL;
proto_tree *box_tree;
gint        ret;
gint        body_size;
offset_start = offset;
box_size = (guint64)tvb_get_ntohl(tvb, offset);
if ((box_size != BOX_SIZE_EXTENDED) && (box_size < MIN_BOX_SIZE))
return -1;
box_type = tvb_get_ntohl(tvb, offset+4);
box_type_str = tvb_get_string_enc(wmem_packet_scope(), tvb,
offset+4, 4, ENC_ASCII|ENC_NA);
box_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1, ett_mp4_box, &type_pi, ""%s (%s)"",
val_to_str_const(box_type, box_types, ""unknown""), box_type_str);
size_pi = proto_tree_add_item(box_tree, hf_mp4_box_size,
tvb, offset, 4, ENC_BIG_ENDIAN);
if (box_size == BOX_SIZE_EXTENDED)
proto_item_append_text(size_pi, "" (actual size is in largesize)"");
offset += 4;
proto_tree_add_item(box_tree, hf_mp4_box_type_str,
tvb, offset, 4, ENC_ASCII|ENC_NA);
offset += 4;
if (box_size == BOX_SIZE_EXTENDED) {
box_size = tvb_get_ntoh64(tvb, offset);
ext_size_pi = proto_tree_add_item(box_tree, hf_mp4_box_largesize,
tvb, offset, 8, ENC_BIG_ENDIAN);
offset += 8;
}
if (box_size > G_MAXINT) {
expert_add_info(pinfo, ext_size_pi, &ei_mp4_box_too_large);
return -1;
}
proto_item_set_len(type_pi, (gint)box_size);
body_size = (gint)box_size - (offset-offset_start);
switch (box_type) {
case BOX_TYPE_FTYP:
dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_MVHD:
dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_MFHD:
dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_TKHD:
dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_STSZ:
dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_HDLR:
dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_DREF:
dissect_mp4_dref_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_URL_:
dissect_mp4_url_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_STSD:
dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, box_tree);
break;
case BOX_TYPE_MOOV:
case BOX_TYPE_MOOF:
case BOX_TYPE_STBL:
case BOX_TYPE_MDIA:
case BOX_TYPE_TRAK:
case BOX_TYPE_TRAF:
case BOX_TYPE_MINF:
case BOX_TYPE_MVEX:
case BOX_TYPE_DINF:
case BOX_TYPE_UDTA:
while (offset-offset_start < (gint)box_size) {
ret = dissect_mp4_box(box_type, tvb, offset, pinfo, box_tree);
if (ret <= 0)
break;
offset += ret;
}
break;
default:
break;
}
return (gint)box_size;
}","static gint
dissect_mp4_box(guint32 VAR_0 _U_,
tvbuff_t *VAR_1, gint VAR_2, packet_info *VAR_3, proto_tree *VAR_4)
{
gint        VAR_5;
guint64     VAR_6;
guint32     VAR_7;
guint8     *VAR_8;
proto_item *VAR_9, *VAR_10, *VAR_11 = NULL;
proto_tree *VAR_12;
gint        VAR_13;
gint        VAR_14;
VAR_5 = VAR_2;
VAR_6 = (guint64)tvb_get_ntohl(VAR_1, VAR_2);
if ((VAR_6 != VAR_15) && (VAR_6 < VAR_16))
return -1;
VAR_7 = tvb_get_ntohl(VAR_1, VAR_2+4);
VAR_8 = tvb_get_string_enc(wmem_packet_scope(), VAR_1,
VAR_2+4, 4, VAR_17|VAR_18);
VAR_12 = proto_tree_add_subtree_format(VAR_4, VAR_1, VAR_2, -1, VAR_19, &VAR_9, ""%s (%s)"",
val_to_str_const(VAR_7, VAR_20, ""unknown""), VAR_8);
VAR_10 = proto_tree_add_item(VAR_12, VAR_21,
VAR_1, VAR_2, 4, VAR_22);
if (VAR_6 == VAR_15)
proto_item_append_text(VAR_10, "" (actual size is in largesize)"");
VAR_2 += 4;
proto_tree_add_item(VAR_12, VAR_23,
VAR_1, VAR_2, 4, VAR_17|VAR_18);
VAR_2 += 4;
if (VAR_6 == VAR_15) {
VAR_6 = tvb_get_ntoh64(VAR_1, VAR_2);
VAR_11 = proto_tree_add_item(VAR_12, VAR_24,
VAR_1, VAR_2, 8, VAR_22);
VAR_2 += 8;
}
if (VAR_6 > VAR_25) {
expert_add_info(VAR_3, VAR_11, &VAR_26);
return -1;
}
proto_item_set_len(VAR_9, (gint)VAR_6);
VAR_14 = (gint)VAR_6 - (VAR_2-VAR_5);
switch (VAR_7) {
case VAR_27:
dissect_mp4_ftyp_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_28:
dissect_mp4_mvhd_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_29:
dissect_mp4_mfhd_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_30:
dissect_mp4_tkhd_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_31:
dissect_mp4_stsz_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_32:
dissect_mp4_hdlr_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_33:
dissect_mp4_dref_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_34:
dissect_mp4_url_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_35:
dissect_mp4_stsd_body(VAR_1, VAR_2, VAR_14, VAR_3, VAR_12);
break;
case VAR_36:
case VAR_37:
case VAR_38:
case VAR_39:
case VAR_40:
case VAR_41:
case VAR_42:
case VAR_43:
case VAR_44:
case VAR_45:
while (VAR_2-VAR_5 < (gint)VAR_6) {
VAR_13 = dissect_mp4_box(VAR_7, VAR_1, VAR_2, VAR_3, VAR_12);
if (VAR_13 <= 0)
break;
VAR_2 += VAR_13;
}
break;
default:
break;
}
return (gint)VAR_6;
}",,"static gint
dissect_mp4_box(guint32 parent_box_type _U_, guint depth,
        tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)
{
    gint        offset_start;
    guint64     box_size;
    guint32     box_type;
    guint8     *box_type_str;
    proto_item *type_pi, *size_pi, *ext_size_pi = NULL;
    proto_tree *box_tree;
    gint        ret;
    gint        body_size;


    offset_start = offset;

    /* the following mechanisms are not supported for now
       - size==0, indicating that the box extends to the end of the file
       - extended box types */

    box_size = (guint64)tvb_get_ntohl(tvb, offset);
    if ((box_size != BOX_SIZE_EXTENDED) && (box_size < MIN_BOX_SIZE))
        return -1;

    box_type = tvb_get_ntohl(tvb, offset+4);
    box_type_str = tvb_get_string_enc(wmem_packet_scope(), tvb,
            offset+4, 4, ENC_ASCII|ENC_NA);

    box_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1, ett_mp4_box, &type_pi, ""%s (%s)"",
            val_to_str_const(box_type, box_types, ""unknown""), box_type_str);

    size_pi = proto_tree_add_item(box_tree, hf_mp4_box_size,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    if (box_size == BOX_SIZE_EXTENDED)
        proto_item_append_text(size_pi, "" (actual size is in largesize)"");

    offset += 4;
    proto_tree_add_item(box_tree, hf_mp4_box_type_str,
            tvb, offset, 4, ENC_ASCII|ENC_NA);
    offset += 4;

    if (box_size == BOX_SIZE_EXTENDED) {
        box_size = tvb_get_ntoh64(tvb, offset);
        ext_size_pi = proto_tree_add_item(box_tree, hf_mp4_box_largesize,
                tvb, offset, 8, ENC_BIG_ENDIAN);
        offset += 8;
    }

    if (box_size > G_MAXINT) {
        /* this should be ok for ext_size_pi==NULL */
        expert_add_info(pinfo, ext_size_pi, &ei_mp4_box_too_large);
        return -1;
    }
    proto_item_set_len(type_pi, (gint)box_size);
    body_size = (gint)box_size - (offset-offset_start);

    depth++;
    if (depth > MP4_BOX_MAX_REC_LVL) {
        proto_tree_add_expert(tree, pinfo, &ei_mp4_too_many_rec_lvls,
                tvb, offset_start, (gint)box_size);
        return -1;
    }

    /* we do not dissect full box version and flags here
       these two components are required by the function dissecting the body
       some fields of the body depend on the version and flags */

    /* XXX - check parent box if supplied */
    switch (box_type) {
        case BOX_TYPE_FTYP:
            dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_MVHD:
            dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_MFHD:
            dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_TKHD:
            dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_STSZ:
            dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_HDLR:
            dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_DREF:
            dissect_mp4_dref_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_URL_:
            dissect_mp4_url_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_STSD:
            dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, depth, box_tree);
            break;
        case BOX_TYPE_MOOV:
        case BOX_TYPE_MOOF:
        case BOX_TYPE_STBL:
        case BOX_TYPE_MDIA:
        case BOX_TYPE_TRAK:
        case BOX_TYPE_TRAF:
        case BOX_TYPE_MINF:
        case BOX_TYPE_MVEX:
        case BOX_TYPE_DINF:
        case BOX_TYPE_UDTA:
            while (offset-offset_start < (gint)box_size) {
                ret = dissect_mp4_box(box_type, depth,
                        tvb, offset, pinfo, box_tree);
                if (ret <= 0)
                    break;
                offset += ret;
            }
            break;
        default:
            break;
    }

    return (gint)box_size;
}","static gint
dissect_mp4_box(guint32 VAR_0 _U_, guint VAR_1,
        tvbuff_t *VAR_2, gint VAR_3, packet_info *VAR_4, proto_tree *VAR_5)
{
    gint        VAR_6;
    guint64     VAR_7;
    guint32     VAR_8;
    guint8     *VAR_9;
    proto_item *VAR_10, *VAR_11, *VAR_12 = NULL;
    proto_tree *VAR_13;
    gint        VAR_14;
    gint        VAR_15;


    VAR_6 = VAR_3;

    /* COMMENT_0 */
                                                                        
                              

    VAR_7 = (guint64)tvb_get_ntohl(VAR_2, VAR_3);
    if ((VAR_7 != VAR_16) && (VAR_7 < VAR_17))
        return -1;

    VAR_8 = tvb_get_ntohl(VAR_2, VAR_3+4);
    VAR_9 = tvb_get_string_enc(wmem_packet_scope(), VAR_2,
            VAR_3+4, 4, VAR_18|VAR_19);

    VAR_13 = proto_tree_add_subtree_format(VAR_5, VAR_2, VAR_3, -1, VAR_20, &VAR_10, ""%s (%s)"",
            val_to_str_const(VAR_8, VAR_21, ""unknown""), VAR_9);

    VAR_11 = proto_tree_add_item(VAR_13, VAR_22,
            VAR_2, VAR_3, 4, VAR_23);
    if (VAR_7 == VAR_16)
        proto_item_append_text(VAR_11, "" (actual size is in largesize)"");

    VAR_3 += 4;
    proto_tree_add_item(VAR_13, VAR_24,
            VAR_2, VAR_3, 4, VAR_18|VAR_19);
    VAR_3 += 4;

    if (VAR_7 == VAR_16) {
        VAR_7 = tvb_get_ntoh64(VAR_2, VAR_3);
        VAR_12 = proto_tree_add_item(VAR_13, VAR_25,
                VAR_2, VAR_3, 8, VAR_23);
        VAR_3 += 8;
    }

    if (VAR_7 > VAR_26) {
        /* COMMENT_3 */
        expert_add_info(VAR_4, VAR_12, &VAR_27);
        return -1;
    }
    proto_item_set_len(VAR_10, (gint)VAR_7);
    VAR_15 = (gint)VAR_7 - (VAR_3-VAR_6);

    VAR_1++;
    if (VAR_1 > VAR_28) {
        proto_tree_add_expert(VAR_5, VAR_4, &VAR_29,
                VAR_2, VAR_6, (gint)VAR_7);
        return -1;
    }

    /* COMMENT_4 */
                                                                            
                                                                 

    /* COMMENT_7 */
    switch (VAR_8) {
        case VAR_30:
            dissect_mp4_ftyp_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_31:
            dissect_mp4_mvhd_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_32:
            dissect_mp4_mfhd_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_33:
            dissect_mp4_tkhd_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_34:
            dissect_mp4_stsz_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_35:
            dissect_mp4_hdlr_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_36:
            dissect_mp4_dref_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_37:
            dissect_mp4_url_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_38:
            dissect_mp4_stsd_body(VAR_2, VAR_3, VAR_15, VAR_4, VAR_1, VAR_13);
            break;
        case VAR_39:
        case VAR_40:
        case VAR_41:
        case VAR_42:
        case VAR_43:
        case VAR_44:
        case VAR_45:
        case VAR_46:
        case VAR_47:
        case VAR_48:
            while (VAR_3-VAR_6 < (gint)VAR_7) {
                VAR_14 = dissect_mp4_box(VAR_8, VAR_1,
                        VAR_2, VAR_3, VAR_4, VAR_13);
                if (VAR_14 <= 0)
                    break;
                VAR_3 += VAR_14;
            }
            break;
        default:
            break;
    }

    return (gint)VAR_7;
}",,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static gint
-dissect_mp4_box(guint32 parent_box_type _U_,
+dissect_mp4_box(guint32 parent_box_type _U_, guint depth,
         tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)
 {
     gint        offset_start;
@@ -54,6 +54,13 @@
     proto_item_set_len(type_pi, (gint)box_size);
     body_size = (gint)box_size - (offset-offset_start);
 
+    depth++;
+    if (depth > MP4_BOX_MAX_REC_LVL) {
+        proto_tree_add_expert(tree, pinfo, &ei_mp4_too_many_rec_lvls,
+                tvb, offset_start, (gint)box_size);
+        return -1;
+    }
+
     /* we do not dissect full box version and flags here
        these two components are required by the function dissecting the body
        some fields of the body depend on the version and flags */
@@ -61,31 +68,31 @@
     /* XXX - check parent box if supplied */
     switch (box_type) {
         case BOX_TYPE_FTYP:
-            dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_MVHD:
-            dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_MFHD:
-            dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_TKHD:
-            dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_STSZ:
-            dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_HDLR:
-            dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_DREF:
-            dissect_mp4_dref_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_dref_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_URL_:
-            dissect_mp4_url_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_url_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_STSD:
-            dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, box_tree);
+            dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, depth, box_tree);
             break;
         case BOX_TYPE_MOOV:
         case BOX_TYPE_MOOF:
@@ -98,7 +105,8 @@
         case BOX_TYPE_DINF:
         case BOX_TYPE_UDTA:
             while (offset-offset_start < (gint)box_size) {
-                ret = dissect_mp4_box(box_type, tvb, offset, pinfo, box_tree);
+                ret = dissect_mp4_box(box_type, depth,
+                        tvb, offset, pinfo, box_tree);
                 if (ret <= 0)
                     break;
                 offset += ret;","{'deleted_lines': ['dissect_mp4_box(guint32 parent_box_type _U_,', '            dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_dref_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_url_body(tvb, offset, body_size, pinfo, box_tree);', '            dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, box_tree);', '                ret = dissect_mp4_box(box_type, tvb, offset, pinfo, box_tree);'], 'added_lines': ['dissect_mp4_box(guint32 parent_box_type _U_, guint depth,', '    depth++;', '    if (depth > MP4_BOX_MAX_REC_LVL) {', '        proto_tree_add_expert(tree, pinfo, &ei_mp4_too_many_rec_lvls,', '                tvb, offset_start, (gint)box_size);', '        return -1;', '    }', '', '            dissect_mp4_ftyp_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_mvhd_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_mfhd_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_tkhd_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_stsz_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_hdlr_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_dref_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_url_body(tvb, offset, body_size, pinfo, depth, box_tree);', '            dissect_mp4_stsd_body(tvb, offset, body_size, pinfo, depth, box_tree);', '                ret = dissect_mp4_box(box_type, depth,', '                        tvb, offset, pinfo, box_tree);']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_stsz_body,"static gint
dissect_mp4_stsz_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo _U_, proto_tree *tree)
{
gint offset_start;
guint32  sample_size, sample_count, i;
offset_start = offset;
sample_size = tvb_get_ntohl(tvb, offset);
proto_tree_add_item(tree, hf_mp4_stsz_sample_size,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
sample_count = tvb_get_ntohl(tvb, offset);
proto_tree_add_item(tree, hf_mp4_stsz_sample_count,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
if (sample_size != 0)
return offset - offset_start;
for (i=0; i<sample_count; i++) {
proto_tree_add_item(tree, hf_mp4_stsz_entry_size,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
}
return offset - offset_start;
}","static gint
dissect_mp4_stsz_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
gint VAR_5;
guint32  VAR_6, VAR_7, VAR_8;
VAR_5 = VAR_1;
VAR_6 = tvb_get_ntohl(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_9,
VAR_0, VAR_1, 4, VAR_10);
VAR_1 += 4;
VAR_7 = tvb_get_ntohl(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_11,
VAR_0, VAR_1, 4, VAR_10);
VAR_1 += 4;
if (VAR_6 != 0)
return VAR_1 - VAR_5;
for (VAR_8=0; VAR_8<VAR_7; VAR_8++) {
proto_tree_add_item(VAR_4, VAR_12,
VAR_0, VAR_1, 4, VAR_10);
VAR_1 += 4;
}
return VAR_1 - VAR_5;
}",,"static gint
dissect_mp4_stsz_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
    gint offset_start;
    guint32  sample_size, sample_count, i;

    offset_start = offset;
    sample_size = tvb_get_ntohl(tvb, offset);

    proto_tree_add_item(tree, hf_mp4_stsz_sample_size,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    /* XXX - expert info for sample size == 0 */
    offset += 4;

    sample_count = tvb_get_ntohl(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_stsz_sample_count,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    if (sample_size != 0)
        return offset - offset_start;

    for (i=0; i<sample_count; i++) {
        proto_tree_add_item(tree, hf_mp4_stsz_entry_size,
                tvb, offset, 4, ENC_BIG_ENDIAN);
        offset += 4;
    }

    return offset - offset_start;
}","static gint
dissect_mp4_stsz_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint VAR_6;
    guint32  VAR_7, VAR_8, VAR_9;

    VAR_6 = VAR_1;
    VAR_7 = tvb_get_ntohl(VAR_0, VAR_1);

    proto_tree_add_item(VAR_5, VAR_10,
            VAR_0, VAR_1, 4, VAR_11);
    /* COMMENT_0 */
    VAR_1 += 4;

    VAR_8 = tvb_get_ntohl(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_12,
            VAR_0, VAR_1, 4, VAR_11);
    VAR_1 += 4;

    if (VAR_7 != 0)
        return VAR_1 - VAR_6;

    for (VAR_9=0; VAR_9<VAR_8; VAR_9++) {
        proto_tree_add_item(VAR_5, VAR_13,
                VAR_0, VAR_1, 4, VAR_11);
        VAR_1 += 4;
    }

    return VAR_1 - VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_stsz_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
     gint offset_start;
     guint32  sample_size, sample_count, i;","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,proto_register_mp4,"void
proto_register_mp4(void)
{
static hf_register_info hf[] = {
{ &hf_mp4_box_size,
{ ""Box size"", ""mp4.box.size"", FT_UINT32, BASE_DEC,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_box_type_str,
{ ""Box type"", ""mp4.box.type_str"", FT_STRING, BASE_NONE,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_box_largesize,
{ ""Box size (largesize)"", ""mp4.box.largesize"", FT_UINT64, BASE_DEC,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_full_box_ver,
{ ""Box version"", ""mp4.full_box.version"", FT_UINT8, BASE_DEC,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_full_box_flags,
{ ""Flags"", ""mp4.full_box.flags"", FT_UINT24, BASE_HEX,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_full_box_flags_media_data_location,
{ ""Media data location is defined in the movie box"", ""mp4.full_box.flags.media_data_location"", FT_BOOLEAN, 24,
NULL, ENTRY_FLAG_MOVIE, NULL, HFILL } },
{ &hf_mp4_ftyp_brand,
{ ""Brand"", ""mp4.ftyp.brand"", FT_STRING, BASE_NONE,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_ftyp_ver,
{ ""Version"", ""mp4.ftyp.version"", FT_UINT32, BASE_DEC,
NULL, 0, NULL, HFILL } },
{ &hf_mp4_ftyp_add_brand,
{ ""Additional brand"", ""mp4.ftyp.additional_brand"", FT_STRING,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_stsz_sample_size,
{ ""Sample size"", ""mp4.stsz.sample_size"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_stsz_sample_count,
{ ""Sample count"", ""mp4.stsz.sample_count"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_stsz_entry_size,
{ ""Entry size"", ""mp4.stsz.entry_size"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_creat_time,
{ ""Creation time"", ""mp4.mvhd.creation_time"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_mod_time,
{ ""Modification time"", ""mp4.mvhd.modification_time"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_timescale,
{ ""Timescale"", ""mp4.mvhd.timescale"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_duration,
{ ""Duration"", ""mp4.mvhd.duration"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_rate,
{ ""Rate"", ""mp4.mvhd.rate"", FT_DOUBLE,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_vol,
{ ""Volume"", ""mp4.mvhd.volume"", FT_DOUBLE,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mvhd_next_tid,
{ ""Next Track ID"", ""mp4.mvhd.next_track_id"", FT_UINT32,
BASE_HEX, NULL, 0, NULL, HFILL } },
{ &hf_mp4_mfhd_seq_num,
{ ""Sequence number"", ""mp4.mfhd.sequence_number"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_creat_time,
{ ""Creation time"", ""mp4.tkhd.creation_time"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_mod_time,
{ ""Modification time"", ""mp4.tkhd.modification_time"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_track_id,
{ ""Track ID"", ""mp4.tkhd.track_id"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_duration,
{ ""Duration"", ""mp4.tkhd.duration"", FT_UINT64,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_width,
{ ""Width"", ""mp4.tkhd.width"", FT_DOUBLE,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_tkhd_height,
{ ""Height"", ""mp4.tkhd.height"", FT_DOUBLE,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_hdlr_type,
{ ""Handler type"", ""mp4.hdlr.type"", FT_STRING,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_hdlr_name,
{ ""Handler name"", ""mp4.hdlr.name"", FT_STRINGZ,
BASE_NONE, NULL, 0, NULL, HFILL } },
{ &hf_mp4_dref_entry_cnt,
{ ""Number of entries"", ""mp4.dref.entry_count"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } },
{ &hf_mp4_stsd_entry_cnt,
{ ""Number of entries"", ""mp4.stsd.entry_count"", FT_UINT32,
BASE_DEC, NULL, 0, NULL, HFILL } }
};
static gint *ett[] = {
&ett_mp4,
&ett_mp4_box
};
static ei_register_info ei[] = {
{ &ei_mp4_box_too_large,
{ ""mp4.box_too_large"", PI_PROTOCOL, PI_WARN,
""box size too large, dissection of this box is not supported"", EXPFILL }},
{ &ei_mp4_mvhd_next_tid_unknown,
{ ""mp4.mvhd.next_tid_unknown"", PI_PROTOCOL, PI_CHAT,
""Next track ID is unknown. Search for an unused track ID if you want to insert a new track."", EXPFILL }}
};
expert_module_t *expert_mp4;
proto_mp4 = proto_register_protocol(""MP4 / ISOBMFF file format"", ""mp4"", ""mp4"");
proto_register_field_array(proto_mp4, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
expert_mp4 = expert_register_protocol(proto_mp4);
expert_register_field_array(expert_mp4, ei, array_length(ei));
}","void
proto_register_mp4(void)
{
static hf_register_info VAR_0[] = {
{ &VAR_1,
{ ""Box size"", ""mp4.box.size"", VAR_2, VAR_3,
NULL, 0, NULL, VAR_4 } },
{ &VAR_5,
{ ""Box type"", ""mp4.box.type_str"", VAR_6, VAR_7,
NULL, 0, NULL, VAR_4 } },
{ &VAR_8,
{ ""Box size (largesize)"", ""mp4.box.largesize"", VAR_9, VAR_3,
NULL, 0, NULL, VAR_4 } },
{ &VAR_10,
{ ""Box version"", ""mp4.full_box.version"", VAR_11, VAR_3,
NULL, 0, NULL, VAR_4 } },
{ &VAR_12,
{ ""Flags"", ""mp4.full_box.flags"", VAR_13, VAR_14,
NULL, 0, NULL, VAR_4 } },
{ &VAR_15,
{ ""Media data location is defined in the movie box"", ""mp4.full_box.flags.media_data_location"", VAR_16, 24,
NULL, VAR_17, NULL, VAR_4 } },
{ &VAR_18,
{ ""Brand"", ""mp4.ftyp.brand"", VAR_6, VAR_7,
NULL, 0, NULL, VAR_4 } },
{ &VAR_19,
{ ""Version"", ""mp4.ftyp.version"", VAR_2, VAR_3,
NULL, 0, NULL, VAR_4 } },
{ &VAR_20,
{ ""Additional brand"", ""mp4.ftyp.additional_brand"", VAR_6,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_21,
{ ""Sample size"", ""mp4.stsz.sample_size"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_22,
{ ""Sample count"", ""mp4.stsz.sample_count"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_23,
{ ""Entry size"", ""mp4.stsz.entry_size"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_24,
{ ""Creation time"", ""mp4.mvhd.creation_time"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_25,
{ ""Modification time"", ""mp4.mvhd.modification_time"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_26,
{ ""Timescale"", ""mp4.mvhd.timescale"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_27,
{ ""Duration"", ""mp4.mvhd.duration"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_28,
{ ""Rate"", ""mp4.mvhd.rate"", VAR_29,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_30,
{ ""Volume"", ""mp4.mvhd.volume"", VAR_29,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_31,
{ ""Next Track ID"", ""mp4.mvhd.next_track_id"", VAR_2,
VAR_14, NULL, 0, NULL, VAR_4 } },
{ &VAR_32,
{ ""Sequence number"", ""mp4.mfhd.sequence_number"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_33,
{ ""Creation time"", ""mp4.tkhd.creation_time"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_34,
{ ""Modification time"", ""mp4.tkhd.modification_time"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_35,
{ ""Track ID"", ""mp4.tkhd.track_id"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_36,
{ ""Duration"", ""mp4.tkhd.duration"", VAR_9,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_37,
{ ""Width"", ""mp4.tkhd.width"", VAR_29,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_38,
{ ""Height"", ""mp4.tkhd.height"", VAR_29,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_39,
{ ""Handler type"", ""mp4.hdlr.type"", VAR_6,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_40,
{ ""Handler name"", ""mp4.hdlr.name"", VAR_41,
VAR_7, NULL, 0, NULL, VAR_4 } },
{ &VAR_42,
{ ""Number of entries"", ""mp4.dref.entry_count"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } },
{ &VAR_43,
{ ""Number of entries"", ""mp4.stsd.entry_count"", VAR_2,
VAR_3, NULL, 0, NULL, VAR_4 } }
};
static gint *VAR_44[] = {
&VAR_45,
&VAR_46
};
static ei_register_info VAR_47[] = {
{ &VAR_48,
{ ""mp4.box_too_large"", VAR_49, VAR_50,
""box size too large, dissection of this box is not supported"", VAR_51 }},
{ &VAR_52,
{ ""mp4.mvhd.next_tid_unknown"", VAR_49, VAR_53,
""Next track ID is unknown. Search for an unused track ID if you want to insert a new track."", VAR_51 }}
};
expert_module_t *VAR_54;
VAR_55 = proto_register_protocol(""MP4 / ISOBMFF file format"", ""mp4"", ""mp4"");
proto_register_field_array(VAR_55, VAR_0, array_length(VAR_0));
proto_register_subtree_array(VAR_44, array_length(VAR_44));
VAR_54 = expert_register_protocol(VAR_55);
expert_register_field_array(VAR_54, VAR_47, array_length(VAR_47));
}",wireshark/2113179835b37549f245ac7c05ff2b96276893e4/file-mp4.c/vul/before/2.json,"void
proto_register_mp4(void)
{
    static hf_register_info hf[] = {
        { &hf_mp4_box_size,
            { ""Box size"", ""mp4.box.size"", FT_UINT32, BASE_DEC,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_box_type_str,
            { ""Box type"", ""mp4.box.type_str"", FT_STRING, BASE_NONE,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_box_largesize,
            { ""Box size (largesize)"", ""mp4.box.largesize"", FT_UINT64, BASE_DEC,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_full_box_ver,
            { ""Box version"", ""mp4.full_box.version"", FT_UINT8, BASE_DEC,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_full_box_flags,
            { ""Flags"", ""mp4.full_box.flags"", FT_UINT24, BASE_HEX,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_full_box_flags_media_data_location,
            { ""Media data location is defined in the movie box"", ""mp4.full_box.flags.media_data_location"", FT_BOOLEAN, 24,
                NULL, ENTRY_FLAG_MOVIE, NULL, HFILL } },
        { &hf_mp4_ftyp_brand,
            { ""Brand"", ""mp4.ftyp.brand"", FT_STRING, BASE_NONE,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_ftyp_ver,
            { ""Version"", ""mp4.ftyp.version"", FT_UINT32, BASE_DEC,
                NULL, 0, NULL, HFILL } },
        { &hf_mp4_ftyp_add_brand,
            { ""Additional brand"", ""mp4.ftyp.additional_brand"", FT_STRING,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_stsz_sample_size,
            { ""Sample size"", ""mp4.stsz.sample_size"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_stsz_sample_count,
            { ""Sample count"", ""mp4.stsz.sample_count"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_stsz_entry_size,
            { ""Entry size"", ""mp4.stsz.entry_size"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_creat_time,
            { ""Creation time"", ""mp4.mvhd.creation_time"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_mod_time,
            { ""Modification time"", ""mp4.mvhd.modification_time"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_timescale,
            { ""Timescale"", ""mp4.mvhd.timescale"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_duration,
            { ""Duration"", ""mp4.mvhd.duration"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_rate,
            { ""Rate"", ""mp4.mvhd.rate"", FT_DOUBLE,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_vol,
            { ""Volume"", ""mp4.mvhd.volume"", FT_DOUBLE,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mvhd_next_tid,
            { ""Next Track ID"", ""mp4.mvhd.next_track_id"", FT_UINT32,
                BASE_HEX, NULL, 0, NULL, HFILL } },
        { &hf_mp4_mfhd_seq_num,
            { ""Sequence number"", ""mp4.mfhd.sequence_number"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_creat_time,
            { ""Creation time"", ""mp4.tkhd.creation_time"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_mod_time,
            { ""Modification time"", ""mp4.tkhd.modification_time"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_track_id,
            { ""Track ID"", ""mp4.tkhd.track_id"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_duration,
            { ""Duration"", ""mp4.tkhd.duration"", FT_UINT64,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_width,
            { ""Width"", ""mp4.tkhd.width"", FT_DOUBLE,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_tkhd_height,
            { ""Height"", ""mp4.tkhd.height"", FT_DOUBLE,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_hdlr_type,
            { ""Handler type"", ""mp4.hdlr.type"", FT_STRING,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_hdlr_name,
            { ""Handler name"", ""mp4.hdlr.name"", FT_STRINGZ,
                BASE_NONE, NULL, 0, NULL, HFILL } },
        { &hf_mp4_dref_entry_cnt,
            { ""Number of entries"", ""mp4.dref.entry_count"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } },
        { &hf_mp4_stsd_entry_cnt,
            { ""Number of entries"", ""mp4.stsd.entry_count"", FT_UINT32,
                BASE_DEC, NULL, 0, NULL, HFILL } }
    };

    static gint *ett[] = {
        &ett_mp4,
        &ett_mp4_box
    };

    static ei_register_info ei[] = {
        { &ei_mp4_box_too_large,
            { ""mp4.box_too_large"", PI_PROTOCOL, PI_WARN,
                ""box size too large, dissection of this box is not supported"", EXPFILL }},
        { &ei_mp4_too_many_rec_lvls,
            { ""mp4.too_many_levels"", PI_UNDECODED, PI_WARN,
                ""too many recursion levels"", EXPFILL }},
        { &ei_mp4_mvhd_next_tid_unknown,
            { ""mp4.mvhd.next_tid_unknown"", PI_PROTOCOL, PI_CHAT,
                ""Next track ID is unknown. Search for an unused track ID if you want to insert a new track."", EXPFILL }}
    };

    expert_module_t *expert_mp4;

    proto_mp4 = proto_register_protocol(""MP4 / ISOBMFF file format"", ""mp4"", ""mp4"");

    proto_register_field_array(proto_mp4, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_mp4 = expert_register_protocol(proto_mp4);
    expert_register_field_array(expert_mp4, ei, array_length(ei));
}","void
proto_register_mp4(void)
{
    static hf_register_info VAR_0[] = {
        { &VAR_1,
            { ""Box size"", ""mp4.box.size"", VAR_2, VAR_3,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_5,
            { ""Box type"", ""mp4.box.type_str"", VAR_6, VAR_7,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_8,
            { ""Box size (largesize)"", ""mp4.box.largesize"", VAR_9, VAR_3,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_10,
            { ""Box version"", ""mp4.full_box.version"", VAR_11, VAR_3,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_12,
            { ""Flags"", ""mp4.full_box.flags"", VAR_13, VAR_14,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_15,
            { ""Media data location is defined in the movie box"", ""mp4.full_box.flags.media_data_location"", VAR_16, 24,
                NULL, VAR_17, NULL, VAR_4 } },
        { &VAR_18,
            { ""Brand"", ""mp4.ftyp.brand"", VAR_6, VAR_7,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_19,
            { ""Version"", ""mp4.ftyp.version"", VAR_2, VAR_3,
                NULL, 0, NULL, VAR_4 } },
        { &VAR_20,
            { ""Additional brand"", ""mp4.ftyp.additional_brand"", VAR_6,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_21,
            { ""Sample size"", ""mp4.stsz.sample_size"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_22,
            { ""Sample count"", ""mp4.stsz.sample_count"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_23,
            { ""Entry size"", ""mp4.stsz.entry_size"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_24,
            { ""Creation time"", ""mp4.mvhd.creation_time"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_25,
            { ""Modification time"", ""mp4.mvhd.modification_time"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_26,
            { ""Timescale"", ""mp4.mvhd.timescale"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_27,
            { ""Duration"", ""mp4.mvhd.duration"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_28,
            { ""Rate"", ""mp4.mvhd.rate"", VAR_29,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_30,
            { ""Volume"", ""mp4.mvhd.volume"", VAR_29,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_31,
            { ""Next Track ID"", ""mp4.mvhd.next_track_id"", VAR_2,
                VAR_14, NULL, 0, NULL, VAR_4 } },
        { &VAR_32,
            { ""Sequence number"", ""mp4.mfhd.sequence_number"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_33,
            { ""Creation time"", ""mp4.tkhd.creation_time"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_34,
            { ""Modification time"", ""mp4.tkhd.modification_time"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_35,
            { ""Track ID"", ""mp4.tkhd.track_id"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_36,
            { ""Duration"", ""mp4.tkhd.duration"", VAR_9,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_37,
            { ""Width"", ""mp4.tkhd.width"", VAR_29,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_38,
            { ""Height"", ""mp4.tkhd.height"", VAR_29,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_39,
            { ""Handler type"", ""mp4.hdlr.type"", VAR_6,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_40,
            { ""Handler name"", ""mp4.hdlr.name"", VAR_41,
                VAR_7, NULL, 0, NULL, VAR_4 } },
        { &VAR_42,
            { ""Number of entries"", ""mp4.dref.entry_count"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } },
        { &VAR_43,
            { ""Number of entries"", ""mp4.stsd.entry_count"", VAR_2,
                VAR_3, NULL, 0, NULL, VAR_4 } }
    };

    static gint *VAR_44[] = {
        &VAR_45,
        &VAR_46
    };

    static ei_register_info VAR_47[] = {
        { &VAR_48,
            { ""mp4.box_too_large"", VAR_49, VAR_50,
                ""box size too large, dissection of this box is not supported"", VAR_51 }},
        { &VAR_52,
            { ""mp4.too_many_levels"", VAR_53, VAR_50,
                ""too many recursion levels"", VAR_51 }},
        { &VAR_54,
            { ""mp4.mvhd.next_tid_unknown"", VAR_49, VAR_55,
                ""Next track ID is unknown. Search for an unused track ID if you want to insert a new track."", VAR_51 }}
    };

    expert_module_t *VAR_56;

    VAR_57 = proto_register_protocol(""MP4 / ISOBMFF file format"", ""mp4"", ""mp4"");

    proto_register_field_array(VAR_57, VAR_0, array_length(VAR_0));
    proto_register_subtree_array(VAR_44, array_length(VAR_44));
    VAR_56 = expert_register_protocol(VAR_57);
    expert_register_field_array(VAR_56, VAR_47, array_length(VAR_47));
}",wireshark/2113179835b37549f245ac7c05ff2b96276893e4/file-mp4.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -103,6 +103,9 @@
         { &ei_mp4_box_too_large,
             { ""mp4.box_too_large"", PI_PROTOCOL, PI_WARN,
                 ""box size too large, dissection of this box is not supported"", EXPFILL }},
+        { &ei_mp4_too_many_rec_lvls,
+            { ""mp4.too_many_levels"", PI_UNDECODED, PI_WARN,
+                ""too many recursion levels"", EXPFILL }},
         { &ei_mp4_mvhd_next_tid_unknown,
             { ""mp4.mvhd.next_tid_unknown"", PI_PROTOCOL, PI_CHAT,
                 ""Next track ID is unknown. Search for an unused track ID if you want to insert a new track."", EXPFILL }}","{'deleted_lines': [], 'added_lines': ['        { &ei_mp4_too_many_rec_lvls,', '            { ""mp4.too_many_levels"", PI_UNDECODED, PI_WARN,', '                ""too many recursion levels"", EXPFILL }},']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_tkhd_body,"static gint
dissect_mp4_tkhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo _U_, proto_tree *tree)
{
gint     offset_start;
guint8   version;
guint8   time_len;
double   width, height;
guint16  fract_dec;
offset_start = offset;
version = tvb_get_guint8(tvb, offset);
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
time_len = (version==0) ? 4 : 8;
proto_tree_add_item(tree, hf_mp4_tkhd_creat_time,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
proto_tree_add_item(tree, hf_mp4_tkhd_mod_time,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
proto_tree_add_item(tree, hf_mp4_tkhd_track_id,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
offset += 4;   
proto_tree_add_item(tree, hf_mp4_tkhd_duration,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
offset += 2*4; 
offset += 2;   
offset += 2;   
offset += 2;   
offset += 2;   
offset += 9*4; 
width = tvb_get_ntohs(tvb, offset);
fract_dec = tvb_get_ntohs(tvb, offset+2);
width += make_fract(fract_dec);
proto_tree_add_double(tree, hf_mp4_tkhd_width, tvb, offset, 4, width);
offset += 4;
height = tvb_get_ntohs(tvb, offset);
fract_dec = tvb_get_ntohs(tvb, offset+2);
height += make_fract(fract_dec);
proto_tree_add_double(tree, hf_mp4_tkhd_height, tvb, offset, 4, height);
offset += 4;
return offset-offset_start;
}","static gint
dissect_mp4_tkhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
gint     VAR_5;
guint8   VAR_6;
guint8   VAR_7;
double   VAR_8, VAR_9;
guint16  VAR_10;
VAR_5 = VAR_1;
VAR_6 = tvb_get_guint8(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_11,
VAR_0, VAR_1, 1, VAR_12);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_13,
VAR_0, VAR_1, 3, VAR_12);
VAR_1 += 3;
VAR_7 = (VAR_6==0) ? 4 : 8;
proto_tree_add_item(VAR_4, VAR_14,
VAR_0, VAR_1, VAR_7, VAR_12);
VAR_1 += VAR_7;
proto_tree_add_item(VAR_4, VAR_15,
VAR_0, VAR_1, VAR_7, VAR_12);
VAR_1 += VAR_7;
proto_tree_add_item(VAR_4, VAR_16,
VAR_0, VAR_1, 4, VAR_12);
VAR_1 += 4;
VAR_1 += 4;   
proto_tree_add_item(VAR_4, VAR_17,
VAR_0, VAR_1, VAR_7, VAR_12);
VAR_1 += VAR_7;
VAR_1 += 2*4; 
VAR_1 += 2;   
VAR_1 += 2;   
VAR_1 += 2;   
VAR_1 += 2;   
VAR_1 += 9*4; 
VAR_8 = tvb_get_ntohs(VAR_0, VAR_1);
VAR_10 = tvb_get_ntohs(VAR_0, VAR_1+2);
VAR_8 += make_fract(VAR_10);
proto_tree_add_double(VAR_4, VAR_18, VAR_0, VAR_1, 4, VAR_8);
VAR_1 += 4;
VAR_9 = tvb_get_ntohs(VAR_0, VAR_1);
VAR_10 = tvb_get_ntohs(VAR_0, VAR_1+2);
VAR_9 += make_fract(VAR_10);
proto_tree_add_double(VAR_4, VAR_19, VAR_0, VAR_1, 4, VAR_9);
VAR_1 += 4;
return VAR_1-VAR_5;
}",,"static gint
dissect_mp4_tkhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
    gint     offset_start;
    guint8   version;
    guint8   time_len;
    double   width, height;
    guint16  fract_dec;

    offset_start = offset;

    version = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    time_len = (version==0) ? 4 : 8;
    proto_tree_add_item(tree, hf_mp4_tkhd_creat_time,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;
    proto_tree_add_item(tree, hf_mp4_tkhd_mod_time,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;

    proto_tree_add_item(tree, hf_mp4_tkhd_track_id,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    offset += 4;   /* 32bit reserved */

    proto_tree_add_item(tree, hf_mp4_tkhd_duration,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;

    offset += 2*4; /* 2*32bit reserved */
    offset += 2;   /* 16bit layer */
    offset += 2;   /* 16bit alternate_group */
    offset += 2;   /* 16bit volume */
    offset += 2;   /* 16bit reserved */
    offset += 9*4; /* 9*32bit matrix */

    width = tvb_get_ntohs(tvb, offset);
    fract_dec = tvb_get_ntohs(tvb, offset+2);
    width += make_fract(fract_dec);
    proto_tree_add_double(tree, hf_mp4_tkhd_width, tvb, offset, 4, width);
    offset += 4;

    height = tvb_get_ntohs(tvb, offset);
    fract_dec = tvb_get_ntohs(tvb, offset+2);
    height += make_fract(fract_dec);
    proto_tree_add_double(tree, hf_mp4_tkhd_height, tvb, offset, 4, height);
    offset += 4;

    return offset-offset_start;
}","static gint
dissect_mp4_tkhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint     VAR_6;
    guint8   VAR_7;
    guint8   VAR_8;
    double   VAR_9, VAR_10;
    guint16  VAR_11;

    VAR_6 = VAR_1;

    VAR_7 = tvb_get_guint8(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_12,
            VAR_0, VAR_1, 1, VAR_13);
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_14,
            VAR_0, VAR_1, 3, VAR_13);
    VAR_1 += 3;

    VAR_8 = (VAR_7==0) ? 4 : 8;
    proto_tree_add_item(VAR_5, VAR_15,
            VAR_0, VAR_1, VAR_8, VAR_13);
    VAR_1 += VAR_8;
    proto_tree_add_item(VAR_5, VAR_16,
            VAR_0, VAR_1, VAR_8, VAR_13);
    VAR_1 += VAR_8;

    proto_tree_add_item(VAR_5, VAR_17,
            VAR_0, VAR_1, 4, VAR_13);
    VAR_1 += 4;

    VAR_1 += 4;   /* COMMENT_0 */

    proto_tree_add_item(VAR_5, VAR_18,
            VAR_0, VAR_1, VAR_8, VAR_13);
    VAR_1 += VAR_8;

    VAR_1 += 2*4; /* COMMENT_1 */
    VAR_1 += 2;   /* COMMENT_2 */
    VAR_1 += 2;   /* COMMENT_3 */
    VAR_1 += 2;   /* COMMENT_4 */
    VAR_1 += 2;   /* COMMENT_5 */
    VAR_1 += 9*4; /* COMMENT_6 */

    VAR_9 = tvb_get_ntohs(VAR_0, VAR_1);
    VAR_11 = tvb_get_ntohs(VAR_0, VAR_1+2);
    VAR_9 += make_fract(VAR_11);
    proto_tree_add_double(VAR_5, VAR_19, VAR_0, VAR_1, 4, VAR_9);
    VAR_1 += 4;

    VAR_10 = tvb_get_ntohs(VAR_0, VAR_1);
    VAR_11 = tvb_get_ntohs(VAR_0, VAR_1+2);
    VAR_10 += make_fract(VAR_11);
    proto_tree_add_double(VAR_5, VAR_20, VAR_0, VAR_1, 4, VAR_10);
    VAR_1 += 4;

    return VAR_1-VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_tkhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
     gint     offset_start;
     guint8   version;","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_hdlr_body,"static gint
dissect_mp4_hdlr_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo _U_, proto_tree *tree)
{
gint   offset_start;
guint  hdlr_name_len;
offset_start = offset;
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
offset += 4;   
proto_tree_add_item(tree, hf_mp4_hdlr_type,
tvb, offset, 4, ENC_ASCII|ENC_NA);
offset += 4;
offset += 12;   
hdlr_name_len = tvb_strsize(tvb, offset);
proto_tree_add_item(tree, hf_mp4_hdlr_name,
tvb, offset, hdlr_name_len, ENC_UTF_8|ENC_NA);
offset += hdlr_name_len;
return offset-offset_start;
}","static gint
dissect_mp4_hdlr_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
gint   VAR_5;
guint  VAR_6;
VAR_5 = VAR_1;
proto_tree_add_item(VAR_4, VAR_7,
VAR_0, VAR_1, 1, VAR_8);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_9,
VAR_0, VAR_1, 3, VAR_8);
VAR_1 += 3;
VAR_1 += 4;   
proto_tree_add_item(VAR_4, VAR_10,
VAR_0, VAR_1, 4, VAR_11|VAR_12);
VAR_1 += 4;
VAR_1 += 12;   
VAR_6 = tvb_strsize(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_13,
VAR_0, VAR_1, VAR_6, VAR_14|VAR_12);
VAR_1 += VAR_6;
return VAR_1-VAR_5;
}",,"static gint
dissect_mp4_hdlr_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
    gint   offset_start;
    guint  hdlr_name_len;

    offset_start = offset;

    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    /* XXX - put up an expert info if version!=0 */
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    offset += 4;   /* four reserved 0 bytes */

    proto_tree_add_item(tree, hf_mp4_hdlr_type,
            tvb, offset, 4, ENC_ASCII|ENC_NA);
    offset += 4;

    offset += 12;   /* 3x32bit reserved */

    /* name is a 0-terminated UTF-8 string, len includes the final 0 */
    hdlr_name_len = tvb_strsize(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_hdlr_name,
            tvb, offset, hdlr_name_len, ENC_UTF_8|ENC_NA);
    offset += hdlr_name_len;

    return offset-offset_start;
}","static gint
dissect_mp4_hdlr_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint   VAR_6;
    guint  VAR_7;

    VAR_6 = VAR_1;

    proto_tree_add_item(VAR_5, VAR_8,
            VAR_0, VAR_1, 1, VAR_9);
    /* COMMENT_0 */
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_10,
            VAR_0, VAR_1, 3, VAR_9);
    VAR_1 += 3;

    VAR_1 += 4;   /* COMMENT_1 */

    proto_tree_add_item(VAR_5, VAR_11,
            VAR_0, VAR_1, 4, VAR_12|VAR_13);
    VAR_1 += 4;

    VAR_1 += 12;   /* COMMENT_2 */

    /* COMMENT_3 */
    VAR_7 = tvb_strsize(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_14,
            VAR_0, VAR_1, VAR_7, VAR_15|VAR_13);
    VAR_1 += VAR_7;

    return VAR_1-VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_hdlr_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
     gint   offset_start;
     guint  hdlr_name_len;","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_mvhd_body,"static gint
dissect_mp4_mvhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
packet_info *pinfo, proto_tree *tree)
{
gint        offset_start;
guint8      version;
guint8      time_len;
double      rate, vol;
guint16     fract_dec;
guint32     next_tid;
proto_item *next_tid_it;
offset_start = offset;
version = tvb_get_guint8(tvb, offset);
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
offset += 3;
time_len = (version==0) ? 4 : 8;
proto_tree_add_item(tree, hf_mp4_mvhd_creat_time,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
proto_tree_add_item(tree, hf_mp4_mvhd_mod_time,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
proto_tree_add_item(tree, hf_mp4_mvhd_timescale,
tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(tree, hf_mp4_mvhd_duration,
tvb, offset, time_len, ENC_BIG_ENDIAN);
offset += time_len;
rate = tvb_get_ntohs(tvb, offset);
fract_dec = tvb_get_ntohs(tvb, offset+2);
rate += make_fract(fract_dec);
proto_tree_add_double(tree, hf_mp4_mvhd_rate, tvb, offset, 4, rate);
offset += 4;
vol = tvb_get_guint8(tvb, offset);
fract_dec = tvb_get_guint8(tvb, offset+1);
vol += make_fract(fract_dec);
proto_tree_add_double(tree, hf_mp4_mvhd_vol, tvb, offset, 4, vol);
offset += 2;
offset += 2;   
offset += 2*4; 
offset += 9*4; 
offset += 6*4; 
next_tid = tvb_get_ntohl(tvb, offset);
next_tid_it = proto_tree_add_item(tree, hf_mp4_mvhd_next_tid,
tvb, offset, 4, ENC_BIG_ENDIAN);
if (next_tid == G_MAXUINT32)
expert_add_info(pinfo, next_tid_it, &ei_mp4_mvhd_next_tid_unknown);
offset += 4;
return offset-offset_start;
}","static gint
dissect_mp4_mvhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
packet_info *VAR_3, proto_tree *VAR_4)
{
gint        VAR_5;
guint8      VAR_6;
guint8      VAR_7;
double      VAR_8, VAR_9;
guint16     VAR_10;
guint32     VAR_11;
proto_item *VAR_12;
VAR_5 = VAR_1;
VAR_6 = tvb_get_guint8(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_13,
VAR_0, VAR_1, 1, VAR_14);
VAR_1 += 1;
proto_tree_add_item(VAR_4, VAR_15,
VAR_0, VAR_1, 3, VAR_14);
VAR_1 += 3;
VAR_7 = (VAR_6==0) ? 4 : 8;
proto_tree_add_item(VAR_4, VAR_16,
VAR_0, VAR_1, VAR_7, VAR_14);
VAR_1 += VAR_7;
proto_tree_add_item(VAR_4, VAR_17,
VAR_0, VAR_1, VAR_7, VAR_14);
VAR_1 += VAR_7;
proto_tree_add_item(VAR_4, VAR_18,
VAR_0, VAR_1, 4, VAR_14);
VAR_1 += 4;
proto_tree_add_item(VAR_4, VAR_19,
VAR_0, VAR_1, VAR_7, VAR_14);
VAR_1 += VAR_7;
VAR_8 = tvb_get_ntohs(VAR_0, VAR_1);
VAR_10 = tvb_get_ntohs(VAR_0, VAR_1+2);
VAR_8 += make_fract(VAR_10);
proto_tree_add_double(VAR_4, VAR_20, VAR_0, VAR_1, 4, VAR_8);
VAR_1 += 4;
VAR_9 = tvb_get_guint8(VAR_0, VAR_1);
VAR_10 = tvb_get_guint8(VAR_0, VAR_1+1);
VAR_9 += make_fract(VAR_10);
proto_tree_add_double(VAR_4, VAR_21, VAR_0, VAR_1, 4, VAR_9);
VAR_1 += 2;
VAR_1 += 2;   
VAR_1 += 2*4; 
VAR_1 += 9*4; 
VAR_1 += 6*4; 
VAR_11 = tvb_get_ntohl(VAR_0, VAR_1);
VAR_12 = proto_tree_add_item(VAR_4, VAR_22,
VAR_0, VAR_1, 4, VAR_14);
if (VAR_11 == VAR_23)
expert_add_info(VAR_3, VAR_12, &VAR_24);
VAR_1 += 4;
return VAR_1-VAR_5;
}",,"static gint
dissect_mp4_mvhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
        packet_info *pinfo, guint depth _U_, proto_tree *tree)
{
    gint        offset_start;
    guint8      version;
    guint8      time_len;
    double      rate, vol;
    guint16     fract_dec;
    guint32     next_tid;
    proto_item *next_tid_it;

    offset_start = offset;

    version = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;

    time_len = (version==0) ? 4 : 8;
    proto_tree_add_item(tree, hf_mp4_mvhd_creat_time,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;
    proto_tree_add_item(tree, hf_mp4_mvhd_mod_time,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;
    proto_tree_add_item(tree, hf_mp4_mvhd_timescale,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(tree, hf_mp4_mvhd_duration,
            tvb, offset, time_len, ENC_BIG_ENDIAN);
    offset += time_len;

    rate = tvb_get_ntohs(tvb, offset);
    fract_dec = tvb_get_ntohs(tvb, offset+2);
    rate += make_fract(fract_dec);
    proto_tree_add_double(tree, hf_mp4_mvhd_rate, tvb, offset, 4, rate);
    offset += 4;

    vol = tvb_get_guint8(tvb, offset);
    fract_dec = tvb_get_guint8(tvb, offset+1);
    vol += make_fract(fract_dec);
    proto_tree_add_double(tree, hf_mp4_mvhd_vol, tvb, offset, 4, vol);
    offset += 2;

    offset += 2;   /* 16 bits reserved */
    offset += 2*4; /* 2 * uint32 reserved */

    offset += 9*4; /* XXX - unity matrix */
    offset += 6*4; /* 6 * 32 bits predefined = 0 */

    next_tid = tvb_get_ntohl(tvb, offset);
    next_tid_it = proto_tree_add_item(tree, hf_mp4_mvhd_next_tid,
            tvb, offset, 4, ENC_BIG_ENDIAN);
    if (next_tid == G_MAXUINT32)
        expert_add_info(pinfo, next_tid_it, &ei_mp4_mvhd_next_tid_unknown);
    offset += 4;

    return offset-offset_start;
}","static gint
dissect_mp4_mvhd_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2 _U_,
        packet_info *VAR_3, guint VAR_4 _U_, proto_tree *VAR_5)
{
    gint        VAR_6;
    guint8      VAR_7;
    guint8      VAR_8;
    double      VAR_9, VAR_10;
    guint16     VAR_11;
    guint32     VAR_12;
    proto_item *VAR_13;

    VAR_6 = VAR_1;

    VAR_7 = tvb_get_guint8(VAR_0, VAR_1);
    proto_tree_add_item(VAR_5, VAR_14,
            VAR_0, VAR_1, 1, VAR_15);
    VAR_1 += 1;
    proto_tree_add_item(VAR_5, VAR_16,
            VAR_0, VAR_1, 3, VAR_15);
    VAR_1 += 3;

    VAR_8 = (VAR_7==0) ? 4 : 8;
    proto_tree_add_item(VAR_5, VAR_17,
            VAR_0, VAR_1, VAR_8, VAR_15);
    VAR_1 += VAR_8;
    proto_tree_add_item(VAR_5, VAR_18,
            VAR_0, VAR_1, VAR_8, VAR_15);
    VAR_1 += VAR_8;
    proto_tree_add_item(VAR_5, VAR_19,
            VAR_0, VAR_1, 4, VAR_15);
    VAR_1 += 4;
    proto_tree_add_item(VAR_5, VAR_20,
            VAR_0, VAR_1, VAR_8, VAR_15);
    VAR_1 += VAR_8;

    VAR_9 = tvb_get_ntohs(VAR_0, VAR_1);
    VAR_11 = tvb_get_ntohs(VAR_0, VAR_1+2);
    VAR_9 += make_fract(VAR_11);
    proto_tree_add_double(VAR_5, VAR_21, VAR_0, VAR_1, 4, VAR_9);
    VAR_1 += 4;

    VAR_10 = tvb_get_guint8(VAR_0, VAR_1);
    VAR_11 = tvb_get_guint8(VAR_0, VAR_1+1);
    VAR_10 += make_fract(VAR_11);
    proto_tree_add_double(VAR_5, VAR_22, VAR_0, VAR_1, 4, VAR_10);
    VAR_1 += 2;

    VAR_1 += 2;   /* COMMENT_0 */
    VAR_1 += 2*4; /* COMMENT_1 */

    VAR_1 += 9*4; /* COMMENT_2 */
    VAR_1 += 6*4; /* COMMENT_3 */

    VAR_12 = tvb_get_ntohl(VAR_0, VAR_1);
    VAR_13 = proto_tree_add_item(VAR_5, VAR_23,
            VAR_0, VAR_1, 4, VAR_15);
    if (VAR_12 == VAR_24)
        expert_add_info(VAR_3, VAR_13, &VAR_25);
    VAR_1 += 4;

    return VAR_1-VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_mvhd_body(tvbuff_t *tvb, gint offset, gint len _U_,
-        packet_info *pinfo, proto_tree *tree)
+        packet_info *pinfo, guint depth _U_, proto_tree *tree)
 {
     gint        offset_start;
     guint8      version;","{'deleted_lines': ['        packet_info *pinfo, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-9259,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"mp4: limit the recursion depth for boxes

Although the dissection of each box header consumes a couple of bytes,
it turned out that it's still possible to crash wireshark with a sample
file that contains a large number of nested boxes. The stack will fill
up before we reach the end of the data bytes.

Keep track of the recursion depth as we walk through the hierarchy of
boxes. Abort if we reach the (locally defined) upper limit.

Bug: 13777
Change-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775
Reviewed-on: https://code.wireshark.org/review/26167
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)
Reviewed-on: https://code.wireshark.org/review/26204",2113179835b37549f245ac7c05ff2b96276893e4,https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4,epan/dissectors/file-mp4.c,dissect_mp4_url_body,"static gint
dissect_mp4_url_body(tvbuff_t *tvb, gint offset, gint len,
packet_info *pinfo _U_, proto_tree *tree)
{
#if 0
guint32  flags;
#endif
proto_tree_add_item(tree, hf_mp4_full_box_ver,
tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
#if 0
flags = tvb_get_ntoh24(tvb, offset);
#endif
proto_tree_add_item(tree, hf_mp4_full_box_flags,
tvb, offset, 3, ENC_BIG_ENDIAN);
proto_tree_add_item(tree, hf_mp4_full_box_flags_media_data_location, tvb, offset, 3, ENC_BIG_ENDIAN);
#if 0
if (flags&ENTRY_FLAG_MOVIE) {
}
else {
}
#endif
return len;
}","static gint
dissect_mp4_url_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
packet_info *VAR_3 _U_, proto_tree *VAR_4)
{
#if 0
guint32  VAR_5;
#endif
proto_tree_add_item(VAR_4, VAR_6,
VAR_0, VAR_1, 1, VAR_7);
VAR_1 += 1;
#if 0
VAR_5 = tvb_get_ntoh24(VAR_0, VAR_1);
#endif
proto_tree_add_item(VAR_4, VAR_8,
VAR_0, VAR_1, 3, VAR_7);
proto_tree_add_item(VAR_4, VAR_9, VAR_0, VAR_1, 3, VAR_7);
#if 0
if (VAR_5&VAR_10) {
}
else {
}
#endif
return VAR_2;
}",,"static gint
dissect_mp4_url_body(tvbuff_t *tvb, gint offset, gint len,
        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
{
#if 0
    guint32  flags;
#endif

    proto_tree_add_item(tree, hf_mp4_full_box_ver,
            tvb, offset, 1, ENC_BIG_ENDIAN);
    /* XXX - put up an expert info if version!=0 */
    offset += 1;

#if 0
    flags = tvb_get_ntoh24(tvb, offset);
#endif
    proto_tree_add_item(tree, hf_mp4_full_box_flags,
            tvb, offset, 3, ENC_BIG_ENDIAN);
    proto_tree_add_item(tree, hf_mp4_full_box_flags_media_data_location, tvb, offset, 3, ENC_BIG_ENDIAN);
    /*offset += 3;*/

#if 0
    if (flags&ENTRY_FLAG_MOVIE) {
    }
    else {
        /* XXX - dissect location string */
    }
#endif

    return len;
}","static gint
dissect_mp4_url_body(tvbuff_t *VAR_0, gint VAR_1, gint VAR_2,
        packet_info *VAR_3 _U_, guint VAR_4 _U_, proto_tree *VAR_5)
{
#if 0
    guint32  VAR_6;
#endif

    proto_tree_add_item(VAR_5, VAR_7,
            VAR_0, VAR_1, 1, VAR_8);
    /* COMMENT_0 */
    VAR_1 += 1;

#if 0
    VAR_6 = tvb_get_ntoh24(VAR_0, VAR_1);
#endif
    proto_tree_add_item(VAR_5, VAR_9,
            VAR_0, VAR_1, 3, VAR_8);
    proto_tree_add_item(VAR_5, VAR_10, VAR_0, VAR_1, 3, VAR_8);
    /* COMMENT_1 */

#if 0
    if (VAR_6&VAR_11) {
    }
    else {
        /* COMMENT_2 */
    }
#endif

    return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static gint
 dissect_mp4_url_body(tvbuff_t *tvb, gint offset, gint len,
-        packet_info *pinfo _U_, proto_tree *tree)
+        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)
 {
 #if 0
     guint32  flags;","{'deleted_lines': ['        packet_info *pinfo _U_, proto_tree *tree)'], 'added_lines': ['        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the MP4 dissector could crash. This was addressed in epan/dissectors/file-mp4.c by restricting the box recursion depth.",7.5,HIGH,2,valid,2018-02-26T22:19:15Z,2
CVE-2018-7540,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"memory: don't implicitly unpin for decrease-reservation

It very likely was a mistake (copy-and-paste from domain cleanup code)
to implicitly unpin here: The caller should really unpin itself before
(or after, if they so wish) requesting the page to be removed.

This is XSA-252.

Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",d798a0952903db9d8ee0a580e03f214d2b49b7d7,https://github.com/xen-project/xen/commit/d798a0952903db9d8ee0a580e03f214d2b49b7d7,xen/common/memory.c,guest_remove_page,"int guest_remove_page(struct domain *d, unsigned long gmfn)
{
struct page_info *page;
#ifdef CONFIG_X86
p2m_type_t p2mt;
#endif
mfn_t mfn;
int rc;
#ifdef CONFIG_X86
mfn = get_gfn_query(d, gmfn, &p2mt);
if ( unlikely(p2mt == p2m_invalid) || unlikely(p2mt == p2m_mmio_dm) )
return -ENOENT;
if ( unlikely(p2m_is_paging(p2mt)) )
{
rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);
if ( rc )
goto out_put_gfn;
put_gfn(d, gmfn);
if ( p2mt == p2m_ram_paging_out )
{
ASSERT(mfn_valid(mfn));
page = mfn_to_page(mfn_x(mfn));
if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )
put_page(page);
}
p2m_mem_paging_drop_page(d, gmfn, p2mt);
return 0;
}
if ( p2mt == p2m_mmio_direct )
{
rc = clear_mmio_p2m_entry(d, gmfn, mfn, PAGE_ORDER_4K);
goto out_put_gfn;
}
#else
mfn = gfn_to_mfn(d, _gfn(gmfn));
#endif
if ( unlikely(!mfn_valid(mfn)) )
{
put_gfn(d, gmfn);
gdprintk(XENLOG_INFO, ""Domain %u page number %lx invalid\n"",
d->domain_id, gmfn);
return -EINVAL;
}
#ifdef CONFIG_X86
if ( p2m_is_shared(p2mt) )
{
rc = mem_sharing_unshare_page(d, gmfn, 0);
if ( rc )
{
(void)mem_sharing_notify_enomem(d, gmfn, 0);
goto out_put_gfn;
}
mfn = get_gfn_query_unlocked(d, gmfn, &p2mt);
ASSERT(!p2m_is_shared(p2mt));
}
#endif 
page = mfn_to_page(mfn_x(mfn));
if ( unlikely(!get_page(page, d)) )
{
put_gfn(d, gmfn);
gdprintk(XENLOG_INFO, ""Bad page free for domain %u\n"", d->domain_id);
return -ENXIO;
}
rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);
#ifdef _PGT_pinned
if ( !rc && test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
put_page_and_type(page);
#endif
if ( !rc && !is_domain_direct_mapped(d) &&
test_and_clear_bit(_PGC_allocated, &page->count_info) )
put_page(page);
put_page(page);
out_put_gfn: __maybe_unused
put_gfn(d, gmfn);
return rc != -ENOENT ? rc : -EINVAL;
}","int guest_remove_page(struct domain *VAR_0, unsigned long VAR_1)
{
struct page_info *VAR_2;
#ifdef VAR_3
p2m_type_t VAR_4;
#endif
mfn_t VAR_5;
int VAR_6;
#ifdef VAR_3
VAR_5 = get_gfn_query(VAR_0, VAR_1, &VAR_4);
if ( unlikely(VAR_4 == VAR_7) || unlikely(VAR_4 == VAR_8) )
return -VAR_9;
if ( unlikely(p2m_is_paging(VAR_4)) )
{
VAR_6 = guest_physmap_remove_page(VAR_0, _gfn(VAR_1), VAR_5, 0);
if ( VAR_6 )
goto out_put_gfn;
put_gfn(VAR_0, VAR_1);
if ( VAR_4 == VAR_10 )
{
ASSERT(mfn_valid(VAR_5));
VAR_2 = mfn_to_page(mfn_x(VAR_5));
if ( test_and_clear_bit(VAR_11, &VAR_2->count_info) )
put_page(VAR_2);
}
p2m_mem_paging_drop_page(VAR_0, VAR_1, VAR_4);
return 0;
}
if ( VAR_4 == VAR_12 )
{
VAR_6 = clear_mmio_p2m_entry(VAR_0, VAR_1, VAR_5, VAR_13);
goto out_put_gfn;
}
#else
VAR_5 = gfn_to_mfn(VAR_0, _gfn(VAR_1));
#endif
if ( unlikely(!mfn_valid(VAR_5)) )
{
put_gfn(VAR_0, VAR_1);
gdprintk(VAR_14, ""Domain %u page number %lx invalid\n"",
VAR_0->domain_id, VAR_1);
return -VAR_15;
}
#ifdef VAR_3
if ( p2m_is_shared(VAR_4) )
{
VAR_6 = mem_sharing_unshare_page(VAR_0, VAR_1, 0);
if ( VAR_6 )
{
(void)mem_sharing_notify_enomem(VAR_0, VAR_1, 0);
goto out_put_gfn;
}
VAR_5 = get_gfn_query_unlocked(VAR_0, VAR_1, &VAR_4);
ASSERT(!p2m_is_shared(VAR_4));
}
#endif 
VAR_2 = mfn_to_page(mfn_x(VAR_5));
if ( unlikely(!get_page(VAR_2, VAR_0)) )
{
put_gfn(VAR_0, VAR_1);
gdprintk(VAR_14, ""Bad page free for domain %u\n"", VAR_0->domain_id);
return -VAR_16;
}
VAR_6 = guest_physmap_remove_page(VAR_0, _gfn(VAR_1), VAR_5, 0);
#ifdef VAR_17
if ( !VAR_6 && test_and_clear_bit(VAR_17, &VAR_2->u.inuse.type_info) )
put_page_and_type(VAR_2);
#endif
if ( !VAR_6 && !is_domain_direct_mapped(VAR_0) &&
test_and_clear_bit(VAR_11, &VAR_2->count_info) )
put_page(VAR_2);
put_page(VAR_2);
out_put_gfn: VAR_18
put_gfn(VAR_0, VAR_1);
return VAR_6 != -VAR_9 ? VAR_6 : -VAR_15;
}",xen-project/xen/d798a0952903db9d8ee0a580e03f214d2b49b7d7/memory.c/vul/before/0.json,"int guest_remove_page(struct domain *d, unsigned long gmfn)
{
    struct page_info *page;
#ifdef CONFIG_X86
    p2m_type_t p2mt;
#endif
    mfn_t mfn;
    int rc;

#ifdef CONFIG_X86
    mfn = get_gfn_query(d, gmfn, &p2mt);
    if ( unlikely(p2mt == p2m_invalid) || unlikely(p2mt == p2m_mmio_dm) )
        return -ENOENT;

    if ( unlikely(p2m_is_paging(p2mt)) )
    {
        rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);
        if ( rc )
            goto out_put_gfn;

        put_gfn(d, gmfn);

        /* If the page hasn't yet been paged out, there is an
         * actual page that needs to be released. */
        if ( p2mt == p2m_ram_paging_out )
        {
            ASSERT(mfn_valid(mfn));
            page = mfn_to_page(mfn_x(mfn));
            if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )
                put_page(page);
        }
        p2m_mem_paging_drop_page(d, gmfn, p2mt);

        return 0;
    }
    if ( p2mt == p2m_mmio_direct )
    {
        rc = clear_mmio_p2m_entry(d, gmfn, mfn, PAGE_ORDER_4K);
        goto out_put_gfn;
    }
#else
    mfn = gfn_to_mfn(d, _gfn(gmfn));
#endif
    if ( unlikely(!mfn_valid(mfn)) )
    {
        put_gfn(d, gmfn);
        gdprintk(XENLOG_INFO, ""Domain %u page number %lx invalid\n"",
                d->domain_id, gmfn);

        return -EINVAL;
    }
            
#ifdef CONFIG_X86
    if ( p2m_is_shared(p2mt) )
    {
        /*
         * Unshare the page, bail out on error. We unshare because we
         * might be the only one using this shared page, and we need to
         * trigger proper cleanup. Once done, this is like any other page.
         */
        rc = mem_sharing_unshare_page(d, gmfn, 0);
        if ( rc )
        {
            (void)mem_sharing_notify_enomem(d, gmfn, 0);
            goto out_put_gfn;
        }
        /* Maybe the mfn changed */
        mfn = get_gfn_query_unlocked(d, gmfn, &p2mt);
        ASSERT(!p2m_is_shared(p2mt));
    }
#endif /* CONFIG_X86 */

    page = mfn_to_page(mfn_x(mfn));
    if ( unlikely(!get_page(page, d)) )
    {
        put_gfn(d, gmfn);
        gdprintk(XENLOG_INFO, ""Bad page free for domain %u\n"", d->domain_id);

        return -ENXIO;
    }

    rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);

    /*
     * With the lack of an IOMMU on some platforms, domains with DMA-capable
     * device must retrieve the same pfn when the hypercall populate_physmap
     * is called.
     *
     * For this purpose (and to match populate_physmap() behavior), the page
     * is kept allocated.
     */
    if ( !rc && !is_domain_direct_mapped(d) &&
         test_and_clear_bit(_PGC_allocated, &page->count_info) )
        put_page(page);

    put_page(page);
 out_put_gfn: __maybe_unused
    put_gfn(d, gmfn);

    /*
     * Filter out -ENOENT return values that aren't a result of an empty p2m
     * entry.
     */
    return rc != -ENOENT ? rc : -EINVAL;
}","int guest_remove_page(struct domain *VAR_0, unsigned long VAR_1)
{
    struct page_info *VAR_2;
#ifdef VAR_3
    p2m_type_t VAR_4;
#endif
    mfn_t VAR_5;
    int VAR_6;

#ifdef VAR_3
    VAR_5 = get_gfn_query(VAR_0, VAR_1, &VAR_4);
    if ( unlikely(VAR_4 == VAR_7) || unlikely(VAR_4 == VAR_8) )
        return -VAR_9;

    if ( unlikely(p2m_is_paging(VAR_4)) )
    {
        VAR_6 = guest_physmap_remove_page(VAR_0, _gfn(VAR_1), VAR_5, 0);
        if ( VAR_6 )
            goto out_put_gfn;

        put_gfn(VAR_0, VAR_1);

        /* COMMENT_0 */
                                                    
        if ( VAR_4 == VAR_10 )
        {
            ASSERT(mfn_valid(VAR_5));
            VAR_2 = mfn_to_page(mfn_x(VAR_5));
            if ( test_and_clear_bit(VAR_11, &VAR_2->count_info) )
                put_page(VAR_2);
        }
        p2m_mem_paging_drop_page(VAR_0, VAR_1, VAR_4);

        return 0;
    }
    if ( VAR_4 == VAR_12 )
    {
        VAR_6 = clear_mmio_p2m_entry(VAR_0, VAR_1, VAR_5, VAR_13);
        goto out_put_gfn;
    }
#else
    VAR_5 = gfn_to_mfn(VAR_0, _gfn(VAR_1));
#endif
    if ( unlikely(!mfn_valid(VAR_5)) )
    {
        put_gfn(VAR_0, VAR_1);
        gdprintk(VAR_14, ""Domain %u page number %lx invalid\n"",
                VAR_0->domain_id, VAR_1);

        return -VAR_15;
    }
            
#ifdef VAR_3
    if ( p2m_is_shared(VAR_4) )
    {
        /* COMMENT_2 */
                                                                     
                                                                       
                                                                          
           
        VAR_6 = mem_sharing_unshare_page(VAR_0, VAR_1, 0);
        if ( VAR_6 )
        {
            (void)mem_sharing_notify_enomem(VAR_0, VAR_1, 0);
            goto out_put_gfn;
        }
        /* COMMENT_7 */
        VAR_5 = get_gfn_query_unlocked(VAR_0, VAR_1, &VAR_4);
        ASSERT(!p2m_is_shared(VAR_4));
    }
#endif /* COMMENT_8 */

    VAR_2 = mfn_to_page(mfn_x(VAR_5));
    if ( unlikely(!get_page(VAR_2, VAR_0)) )
    {
        put_gfn(VAR_0, VAR_1);
        gdprintk(VAR_14, ""Bad page free for domain %u\n"", VAR_0->domain_id);

        return -VAR_16;
    }

    VAR_6 = guest_physmap_remove_page(VAR_0, _gfn(VAR_1), VAR_5, 0);

    /* COMMENT_9 */
                                                                            
                                                                            
                 
      
                                                                            
                         
       
    if ( !VAR_6 && !is_domain_direct_mapped(VAR_0) &&
         test_and_clear_bit(VAR_11, &VAR_2->count_info) )
        put_page(VAR_2);

    put_page(VAR_2);
 out_put_gfn: VAR_17
    put_gfn(VAR_0, VAR_1);

    /* COMMENT_17 */
                                                                            
             
       
    return VAR_6 != -VAR_9 ? VAR_6 : -VAR_15;
}",xen-project/xen/d798a0952903db9d8ee0a580e03f214d2b49b7d7/memory.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -81,11 +81,6 @@
 
     rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);
 
-#ifdef _PGT_pinned
-    if ( !rc && test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
-        put_page_and_type(page);
-#endif
-
     /*
      * With the lack of an IOMMU on some platforms, domains with DMA-capable
      * device must retrieve the same pfn when the hypercall populate_physmap","{'deleted_lines': ['#ifdef _PGT_pinned', '    if ( !rc && test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )', '        put_page_and_type(page);', '#endif', ''], 'added_lines': []}",True,An issue was discovered in Xen through 4.10.x allowing x86 PV guest OS users to cause a denial of service (host OS CPU hang) via non-preemptable L3/L4 pagetable freeing.,6.5,MEDIUM,1,valid,2018-02-27T13:03:27Z,2
CVE-2018-7648,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,uclouvain/openjpeg,"opj_mj2_extract: Check provided output prefix for length

This uses snprintf() with correct buffer length instead of sprintf(), which
prevents a buffer overflow when providing a long output prefix. Furthermore
the program exits with an error when the provided output prefix is too long.

Fixes #1088.",cc3824767bde397fedb8a1ae4786a222ba860c8d,https://github.com/uclouvain/openjpeg/commit/cc3824767bde397fedb8a1ae4786a222ba860c8d,src/bin/mj2/opj_mj2_extract.c,main,"int main(int argc, char *argv[])
{
opj_dinfo_t* dinfo;
opj_event_mgr_t event_mgr;      
int tnum;
unsigned int snum;
opj_mj2_t *movie;
mj2_tk_t *track;
mj2_sample_t *sample;
unsigned char* frame_codestream;
FILE *file, *outfile;
char outfilename[50];
mj2_dparameters_t parameters;
if (argc != 3) {
printf(""Usage: %s mj2filename output_location\n"", argv[0]);
printf(""Example: %s foreman.mj2 output/foreman\n"", argv[0]);
return 1;
}
file = fopen(argv[1], ""rb"");
if (!file) {
fprintf(stderr, ""failed to open %s for reading\n"", argv[1]);
return 1;
}
memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
event_mgr.error_handler = error_callback;
event_mgr.warning_handler = warning_callback;
event_mgr.info_handler = info_callback;
dinfo = mj2_create_decompress();
opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
memset(&parameters, 0, sizeof(mj2_dparameters_t));
movie = (opj_mj2_t*) dinfo->mj2_handle;
mj2_setup_decoder(movie, &parameters);
if (mj2_read_struct(file, movie)) { 
return 1;
}
tnum = 0;
while (movie->tk[tnum].track_type != 0) {
tnum ++;
}
track = &movie->tk[tnum];
fprintf(stdout, ""Extracting %d frames from file...\n"", track->num_samples);
for (snum = 0; snum < track->num_samples; snum++) {
sample = &track->sample[snum];
frame_codestream = (unsigned char*) malloc(sample->sample_size -
8); 
fseek(file, sample->offset + 8, SEEK_SET);
fread(frame_codestream, sample->sample_size - 8, 1,
file); 
sprintf(outfilename, ""%s_%05d.j2k"", argv[2], snum);
outfile = fopen(outfilename, ""wb"");
if (!outfile) {
fprintf(stderr, ""failed to open %s for writing\n"", outfilename);
return 1;
}
fwrite(frame_codestream, sample->sample_size - 8, 1, outfile);
fclose(outfile);
free(frame_codestream);
}
fclose(file);
fprintf(stdout, ""%d frames correctly extracted\n"", snum);
if (dinfo) {
mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
}
return 0;
}","int main(int VAR_0, char *VAR_1[])
{
opj_dinfo_t* VAR_2;
opj_event_mgr_t VAR_3;      
int VAR_4;
unsigned int VAR_5;
opj_mj2_t *VAR_6;
mj2_tk_t *VAR_7;
mj2_sample_t *VAR_8;
unsigned char* VAR_9;
FILE *VAR_10, *VAR_11;
char VAR_12[50];
mj2_dparameters_t VAR_13;
if (VAR_0 != 3) {
printf(""Usage: %s mj2filename output_location\n"", VAR_1[0]);
printf(""Example: %s foreman.mj2 output/foreman\n"", VAR_1[0]);
return 1;
}
VAR_10 = fopen(VAR_1[1], ""rb"");
if (!VAR_10) {
fprintf(VAR_14, ""failed to open %s for reading\n"", VAR_1[1]);
return 1;
}
memset(&VAR_3, 0, sizeof(opj_event_mgr_t));
VAR_3.error_handler = VAR_15;
VAR_3.warning_handler = VAR_16;
VAR_3.info_handler = VAR_17;
VAR_2 = mj2_create_decompress();
opj_set_event_mgr((opj_common_ptr)VAR_2, &VAR_3, VAR_14);
memset(&VAR_13, 0, sizeof(mj2_dparameters_t));
VAR_6 = (opj_mj2_t*) VAR_2->mj2_handle;
mj2_setup_decoder(VAR_6, &VAR_13);
if (mj2_read_struct(VAR_10, VAR_6)) { 
return 1;
}
VAR_4 = 0;
while (VAR_6->tk[VAR_4].track_type != 0) {
VAR_4 ++;
}
VAR_7 = &VAR_6->tk[VAR_4];
fprintf(VAR_18, ""Extracting %d frames from file...\n"", VAR_7->num_samples);
for (VAR_5 = 0; VAR_5 < VAR_7->num_samples; VAR_5++) {
VAR_8 = &VAR_7->sample[VAR_5];
VAR_9 = (unsigned char*) malloc(VAR_8->sample_size -
8); 
fseek(VAR_10, VAR_8->offset + 8, VAR_19);
fread(VAR_9, VAR_8->sample_size - 8, 1,
VAR_10); 
sprintf(VAR_12, ""%s_%05d.j2k"", VAR_1[2], VAR_5);
VAR_11 = fopen(VAR_12, ""wb"");
if (!VAR_11) {
fprintf(VAR_14, ""failed to open %s for writing\n"", VAR_12);
return 1;
}
fwrite(VAR_9, VAR_8->sample_size - 8, 1, VAR_11);
fclose(VAR_11);
free(VAR_9);
}
fclose(VAR_10);
fprintf(VAR_18, ""%d frames correctly extracted\n"", VAR_5);
if (VAR_2) {
mj2_destroy_decompress((opj_mj2_t*)VAR_2->mj2_handle);
}
return 0;
}",uclouvain/openjpeg/cc3824767bde397fedb8a1ae4786a222ba860c8d/opj_mj2_extract.c/vul/before/0.json,"int main(int argc, char *argv[])
{
    opj_dinfo_t* dinfo;
    opj_event_mgr_t event_mgr;      /* event manager */
    int tnum;
    unsigned int snum;
    opj_mj2_t *movie;
    mj2_tk_t *track;
    mj2_sample_t *sample;
    unsigned char* frame_codestream;
    FILE *file, *outfile;
    char outfilename[50];
    mj2_dparameters_t parameters;

    if (argc != 3) {
        printf(""Usage: %s mj2filename output_location\n"", argv[0]);
        printf(""Example: %s foreman.mj2 output/foreman\n"", argv[0]);
        return 1;
    }

    file = fopen(argv[1], ""rb"");

    if (!file) {
        fprintf(stderr, ""failed to open %s for reading\n"", argv[1]);
        return 1;
    }

    /*
    configure the event callbacks (not required)
    setting of each callback is optional
    */
    memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
    event_mgr.error_handler = error_callback;
    event_mgr.warning_handler = warning_callback;
    event_mgr.info_handler = info_callback;

    /* get a MJ2 decompressor handle */
    dinfo = mj2_create_decompress();

    /* catch events using our callbacks and give a local context */
    opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);

    /* setup the decoder decoding parameters using user parameters */
    memset(&parameters, 0, sizeof(mj2_dparameters_t));
    movie = (opj_mj2_t*) dinfo->mj2_handle;
    mj2_setup_decoder(movie, &parameters);

    if (mj2_read_struct(file, movie)) { /* Creating the movie structure*/
        return 1;
    }

    /* Decode first video track */
    tnum = 0;
    while (movie->tk[tnum].track_type != 0) {
        tnum ++;
    }

    track = &movie->tk[tnum];

    fprintf(stdout, ""Extracting %d frames from file...\n"", track->num_samples);

    for (snum = 0; snum < track->num_samples; snum++) {
        sample = &track->sample[snum];
        frame_codestream = (unsigned char*) malloc(sample->sample_size -
                           8); /* Skipping JP2C marker*/
        fseek(file, sample->offset + 8, SEEK_SET);
        fread(frame_codestream, sample->sample_size - 8, 1,
              file); /* Assuming that jp and ftyp markers size do*/

        {
            int num = snprintf(outfilename, sizeof(outfilename),
                               ""%s_%05d.j2k"", argv[2],
                               snum);
            if (num >= sizeof(outfilename)) {
                fprintf(stderr, ""maximum length of output prefix exceeded\n"");
                free(frame_codestream);
                return 1;
            }
        }

        outfile = fopen(outfilename, ""wb"");
        if (!outfile) {
            fprintf(stderr, ""failed to open %s for writing\n"", outfilename);
            free(frame_codestream);
            return 1;
        }
        fwrite(frame_codestream, sample->sample_size - 8, 1, outfile);
        fclose(outfile);
        free(frame_codestream);
    }
    fclose(file);
    fprintf(stdout, ""%d frames correctly extracted\n"", snum);

    /* free remaining structures */
    if (dinfo) {
        mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
    }

    return 0;
}","int main(int VAR_0, char *VAR_1[])
{
    opj_dinfo_t* VAR_2;
    opj_event_mgr_t VAR_3;      /* COMMENT_0 */
    int VAR_4;
    unsigned int VAR_5;
    opj_mj2_t *VAR_6;
    mj2_tk_t *VAR_7;
    mj2_sample_t *VAR_8;
    unsigned char* VAR_9;
    FILE *VAR_10, *VAR_11;
    char VAR_12[50];
    mj2_dparameters_t VAR_13;

    if (VAR_0 != 3) {
        printf(""Usage: %s mj2filename output_location\n"", VAR_1[0]);
        printf(""Example: %s foreman.mj2 output/foreman\n"", VAR_1[0]);
        return 1;
    }

    VAR_10 = fopen(VAR_1[1], ""rb"");

    if (!VAR_10) {
        fprintf(VAR_14, ""failed to open %s for reading\n"", VAR_1[1]);
        return 1;
    }

    /* COMMENT_1 */
                                                
                                        
      
    memset(&VAR_3, 0, sizeof(opj_event_mgr_t));
    VAR_3.error_handler = VAR_15;
    VAR_3.warning_handler = VAR_16;
    VAR_3.info_handler = VAR_17;

    /* COMMENT_5 */
    VAR_2 = mj2_create_decompress();

    /* COMMENT_6 */
    opj_set_event_mgr((opj_common_ptr)VAR_2, &VAR_3, VAR_14);

    /* COMMENT_7 */
    memset(&VAR_13, 0, sizeof(mj2_dparameters_t));
    VAR_6 = (opj_mj2_t*) VAR_2->mj2_handle;
    mj2_setup_decoder(VAR_6, &VAR_13);

    if (mj2_read_struct(VAR_10, VAR_6)) { /* COMMENT_8 */
        return 1;
    }

    /* COMMENT_9 */
    VAR_4 = 0;
    while (VAR_6->tk[VAR_4].track_type != 0) {
        VAR_4 ++;
    }

    VAR_7 = &VAR_6->tk[VAR_4];

    fprintf(VAR_18, ""Extracting %d frames from file...\n"", VAR_7->num_samples);

    for (VAR_5 = 0; VAR_5 < VAR_7->num_samples; VAR_5++) {
        VAR_8 = &VAR_7->sample[VAR_5];
        VAR_9 = (unsigned char*) malloc(VAR_8->sample_size -
                           8); /* COMMENT_10 */
        fseek(VAR_10, VAR_8->offset + 8, VAR_19);
        fread(VAR_9, VAR_8->sample_size - 8, 1,
              VAR_10); /* COMMENT_11 */

        {
            int VAR_20 = snprintf(VAR_12, sizeof(VAR_12),
                               ""%s_%05d.j2k"", VAR_1[2],
                               VAR_5);
            if (VAR_20 >= sizeof(VAR_12)) {
                fprintf(VAR_14, ""maximum length of output prefix exceeded\n"");
                free(VAR_9);
                return 1;
            }
        }

        VAR_11 = fopen(VAR_12, ""wb"");
        if (!VAR_11) {
            fprintf(VAR_14, ""failed to open %s for writing\n"", VAR_12);
            free(VAR_9);
            return 1;
        }
        fwrite(VAR_9, VAR_8->sample_size - 8, 1, VAR_11);
        fclose(VAR_11);
        free(VAR_9);
    }
    fclose(VAR_10);
    fprintf(VAR_18, ""%d frames correctly extracted\n"", VAR_5);

    /* COMMENT_12 */
    if (VAR_2) {
        mj2_destroy_decompress((opj_mj2_t*)VAR_2->mj2_handle);
    }

    return 0;
}",uclouvain/openjpeg/cc3824767bde397fedb8a1ae4786a222ba860c8d/opj_mj2_extract.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -67,10 +67,21 @@
         fread(frame_codestream, sample->sample_size - 8, 1,
               file); /* Assuming that jp and ftyp markers size do*/
 
-        sprintf(outfilename, ""%s_%05d.j2k"", argv[2], snum);
+        {
+            int num = snprintf(outfilename, sizeof(outfilename),
+                               ""%s_%05d.j2k"", argv[2],
+                               snum);
+            if (num >= sizeof(outfilename)) {
+                fprintf(stderr, ""maximum length of output prefix exceeded\n"");
+                free(frame_codestream);
+                return 1;
+            }
+        }
+
         outfile = fopen(outfilename, ""wb"");
         if (!outfile) {
             fprintf(stderr, ""failed to open %s for writing\n"", outfilename);
+            free(frame_codestream);
             return 1;
         }
         fwrite(frame_codestream, sample->sample_size - 8, 1, outfile);","{'deleted_lines': ['        sprintf(outfilename, ""%s_%05d.j2k"", argv[2], snum);'], 'added_lines': ['        {', '            int num = snprintf(outfilename, sizeof(outfilename),', '                               ""%s_%05d.j2k"", argv[2],', '                               snum);', '            if (num >= sizeof(outfilename)) {', '                fprintf(stderr, ""maximum length of output prefix exceeded\\n"");', '                free(frame_codestream);', '                return 1;', '            }', '        }', '', '            free(frame_codestream);']}",True,"An issue was discovered in mj2/opj_mj2_extract.c in OpenJPEG 2.3.0. The output prefix was not checked for length, which could overflow a buffer, when providing a prefix with 50 or more characters on the command line.",9.8,CRITICAL,3,valid,2018-03-02T13:40:58Z,2
CVE-2018-9261,['CWE-834'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"NBAP: avoid linking a DCH-ID to itself

Otherwise it can create an infinite loop, leading to a buffer overflow.
Also add explicit cheks on the buffer usage and set its maximum size to
128 instead of 32 per ASN.1 description.

Bug: 14471
Change-Id: I18d26369cf3d1cf2a32c86a972c78ea9f6f7a503
Reviewed-on: https://code.wireshark.org/review/26264
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
(cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38)
Conflicts:
	epan/dissectors/asn1/nbap/nbap.cnf
	epan/dissectors/packet-nbap.c
	epan/dissectors/packet-umts_fp.h
Reviewed-on: https://code.wireshark.org/review/26267",66bc372716e04d6a8afdf6712583c9b5d11fee55,https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55,epan/dissectors/packet-nbap.c,dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD,"static int
dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 817 ""./asn1/nbap/nbap.cnf""
address     dst_addr, null_addr;
conversation_t *conversation;
umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;
transportLayerAddress_ipv4 = 0;
BindingID_port = 0;
num_items = 1;
offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
ett_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD, PCH_ParametersItem_CTCH_SetupRqstFDD_sequence);
if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
{
return offset;
}
clear_address(&null_addr);
set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);
conversation = find_conversation(actx->pinfo->num,&dst_addr,
&null_addr, PT_UDP, BindingID_port,
0, NO_ADDR_B|NO_PORT_B);
if (conversation == NULL) {
conversation = conversation_new(actx->pinfo->num, &dst_addr,
&null_addr, PT_UDP,BindingID_port ,
0, NO_ADDR2|NO_PORT2);
conversation_set_dissector(conversation, fp_handle);
if(actx->pinfo->link_dir==P2P_DIR_DL){
umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
umts_fp_conversation_info->iface_type         = IuB_Interface;
umts_fp_conversation_info->division           = Division_FDD;
umts_fp_conversation_info->channel            = CHANNEL_PCH;
umts_fp_conversation_info->dl_frame_number    = 0;
umts_fp_conversation_info->ul_frame_number    = actx->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
umts_fp_conversation_info->crnc_port          = BindingID_port;
umts_fp_conversation_info->paging_indications = paging_indications;
umts_fp_conversation_info->rlc_mode           = FP_RLC_MODE_UNKNOWN;
umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;
umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_ul_chans;
nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u"",
actx->pinfo->num,
num_tf);
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_num_tbs[j];
nbap_debug(""    UL tf %u ul_chan_tf_size %u"",j, nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j]);
}
umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_num_tbs[j];
nbap_debug(""    DL tf %u ul_chan_tf_size %u"",j, nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j]);
}
i = commontransportchannelid;
nbap_debug(""    commontransportchannelid %u next ch %u"",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);
umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;
while(nbap_dch_chnl_info[i].next_dch != 0){
i = nbap_dch_chnl_info[i].next_dch;
umts_fp_conversation_info->num_dch_in_flow++;
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
}
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
}
}
umts_fp_conversation_info->num_dch_in_flow++;
nbap_debug(""    num_dch_in_flow %u"", umts_fp_conversation_info->num_dch_in_flow);
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
set_umts_fp_conv_data(conversation, umts_fp_conversation_info);
nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End"",
actx->pinfo->num);
}
}
return offset;
}","static int
dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 817 ""./asn1/nbap/nbap.cnf""
address     VAR_5, VAR_6;
conversation_t *VAR_7;
umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;
VAR_12 = 0;
VAR_13 = 0;
VAR_14 = 1;
VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_15, VAR_16);
if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
{
return VAR_1;
}
clear_address(&VAR_6);
set_address(&VAR_5, VAR_17, 4, &VAR_12);
VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
&VAR_6, VAR_18, VAR_13,
0, VAR_19|VAR_20);
if (VAR_7 == NULL) {
VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
&VAR_6, VAR_18,VAR_13 ,
0, VAR_21|VAR_22);
conversation_set_dissector(VAR_7, VAR_23);
if(VAR_2->pinfo->link_dir==VAR_24){
VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
VAR_8->iface_type         = VAR_25;
VAR_8->division           = VAR_26;
VAR_8->channel            = VAR_27;
VAR_8->dl_frame_number    = 0;
VAR_8->ul_frame_number    = VAR_2->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
VAR_8->crnc_port          = VAR_13;
VAR_8->paging_indications = VAR_28;
VAR_8->rlc_mode           = VAR_29;
VAR_8->dch_crc_present = VAR_30.dch_crc_present;
VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_31[VAR_32].num_ul_chans;
nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u"",
VAR_2->pinfo->num,
VAR_11);
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_31[VAR_32].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_31[VAR_32].ul_chan_num_tbs[VAR_10];
nbap_debug(""    UL tf %u ul_chan_tf_size %u"",VAR_10, VAR_31[VAR_32].ul_chan_tf_size[VAR_10]);
}
VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_31[VAR_32].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_31[VAR_32].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_31[VAR_32].dl_chan_num_tbs[VAR_10];
nbap_debug(""    DL tf %u ul_chan_tf_size %u"",VAR_10, VAR_31[VAR_32].dl_chan_tf_size[VAR_10]);
}
VAR_9 = VAR_32;
nbap_debug(""    commontransportchannelid %u next ch %u"",VAR_32, VAR_31[VAR_9].next_dch);
VAR_8->dchs_in_flow_list[0] = VAR_32;
while(VAR_31[VAR_9].next_dch != 0){
VAR_9 = VAR_31[VAR_9].next_dch;
VAR_8->num_dch_in_flow++;
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_31[VAR_9].num_ul_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_31[VAR_9].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_31[VAR_9].ul_chan_num_tbs[VAR_10];
}
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_31[VAR_9].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_31[VAR_9].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_31[VAR_9].dl_chan_num_tbs[VAR_10];
}
}
VAR_8->num_dch_in_flow++;
nbap_debug(""    num_dch_in_flow %u"", VAR_8->num_dch_in_flow);
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
set_umts_fp_conv_data(VAR_7, VAR_8);
nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End"",
VAR_2->pinfo->num);
}
}
return VAR_1;
}",,"static int
dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 817 ""./asn1/nbap/nbap.cnf""

address     dst_addr, null_addr;
conversation_t *conversation;

umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;

transportLayerAddress_ipv4 = 0;
BindingID_port = 0;

/* There can only be one item, set num_items here to collect the TransportFormatSet data */
num_items = 1;

  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
                                   ett_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD, PCH_ParametersItem_CTCH_SetupRqstFDD_sequence);


        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
        {
            return offset;
        }
        clear_address(&null_addr);

        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);

        conversation = find_conversation(actx->pinfo->num,&dst_addr,
            &null_addr, PT_UDP, BindingID_port,
            0, NO_ADDR_B|NO_PORT_B);

        if (conversation == NULL) {
            /* It's not part of any conversation - create a new one. */
            conversation = conversation_new(actx->pinfo->num, &dst_addr,
                &null_addr, PT_UDP,BindingID_port ,
                0, NO_ADDR2|NO_PORT2);

            /* Set dissector */
            conversation_set_dissector(conversation, fp_handle);
            if(actx->pinfo->link_dir==P2P_DIR_DL){
                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
                /* Fill in the data */
                umts_fp_conversation_info->iface_type         = IuB_Interface;
                umts_fp_conversation_info->division           = Division_FDD;
                umts_fp_conversation_info->channel            = CHANNEL_PCH;
                umts_fp_conversation_info->dl_frame_number    = 0;
                umts_fp_conversation_info->ul_frame_number    = actx->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
                umts_fp_conversation_info->crnc_port          = BindingID_port;
                umts_fp_conversation_info->paging_indications = paging_indications;
                umts_fp_conversation_info->rlc_mode           = FP_RLC_MODE_UNKNOWN;

                /* DCH's in this flow */
                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;
                /* Set data for First or single channel */
                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_ul_chans;

                nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u"",
                        actx->pinfo->num,
                        num_tf);

                for (j = 0; j < num_tf; j++) {
                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j];
                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_num_tbs[j];
                    nbap_debug(""    UL tf %u ul_chan_tf_size %u"",j, nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j]);
                }

                /* Traffic flows per DCH(DL) */
                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_dl_chans;
                for (j = 0; j < num_tf; j++) {
                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j];
                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_num_tbs[j];
                    nbap_debug(""    DL tf %u ul_chan_tf_size %u"",j, nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j]);
                }

                /* Set data for associated DCH's if we have any */
                i = commontransportchannelid;

                nbap_debug(""    commontransportchannelid %u next ch %u"",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);

                umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;
                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){
                    i = nbap_dch_chnl_info[i].next_dch;
                    umts_fp_conversation_info->num_dch_in_flow++;
                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
                    /* Traffic flows per DCH(UL) */
                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
                    }

                    /* Traffic flows per DCH(DL) */
                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
                    }
                }
                umts_fp_conversation_info->num_dch_in_flow++;

                nbap_debug(""    num_dch_in_flow %u"", umts_fp_conversation_info->num_dch_in_flow);

                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);

                nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End"",
                        actx->pinfo->num);

            }

        }




  return offset;
}","static int
dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 817 ""./asn1/nbap/nbap.cnf""

address     VAR_5, VAR_6;
conversation_t *VAR_7;

umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;

VAR_12 = 0;
VAR_13 = 0;

/* COMMENT_0 */
VAR_14 = 1;

  VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                   VAR_15, VAR_16);


        if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
        {
            return VAR_1;
        }
        clear_address(&VAR_6);

        set_address(&VAR_5, VAR_17, 4, &VAR_12);

        VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
            &VAR_6, VAR_18, VAR_13,
            0, VAR_19|VAR_20);

        if (VAR_7 == NULL) {
            /* COMMENT_1 */
            VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
                &VAR_6, VAR_18,VAR_13 ,
                0, VAR_21|VAR_22);

            /* COMMENT_2 */
            conversation_set_dissector(VAR_7, VAR_23);
            if(VAR_2->pinfo->link_dir==VAR_24){
                VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
                /* COMMENT_3 */
                VAR_8->iface_type         = VAR_25;
                VAR_8->division           = VAR_26;
                VAR_8->channel            = VAR_27;
                VAR_8->dl_frame_number    = 0;
                VAR_8->ul_frame_number    = VAR_2->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
                VAR_8->crnc_port          = VAR_13;
                VAR_8->paging_indications = VAR_28;
                VAR_8->rlc_mode           = VAR_29;

                /* COMMENT_4 */
                VAR_8->dch_crc_present = VAR_30.dch_crc_present;
                /* COMMENT_5 */
                VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_31[VAR_32].num_ul_chans;

                nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u"",
                        VAR_2->pinfo->num,
                        VAR_11);

                for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                    VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_31[VAR_32].ul_chan_tf_size[VAR_10];
                    VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_31[VAR_32].ul_chan_num_tbs[VAR_10];
                    nbap_debug(""    UL tf %u ul_chan_tf_size %u"",VAR_10, VAR_31[VAR_32].ul_chan_tf_size[VAR_10]);
                }

                /* COMMENT_6 */
                VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_31[VAR_32].num_dl_chans;
                for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                    VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_31[VAR_32].dl_chan_tf_size[VAR_10];
                    VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_31[VAR_32].dl_chan_num_tbs[VAR_10];
                    nbap_debug(""    DL tf %u ul_chan_tf_size %u"",VAR_10, VAR_31[VAR_32].dl_chan_tf_size[VAR_10]);
                }

                /* COMMENT_7 */
                VAR_9 = VAR_32;

                nbap_debug(""    commontransportchannelid %u next ch %u"",VAR_32, VAR_31[VAR_9].next_dch);

                VAR_8->dchs_in_flow_list[0] = VAR_32;
                while(VAR_31[VAR_9].next_dch != 0 && VAR_8->num_dch_in_flow < VAR_33){
                    VAR_9 = VAR_31[VAR_9].next_dch;
                    VAR_8->num_dch_in_flow++;
                    VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
                    /* COMMENT_8 */
                    VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_31[VAR_9].num_ul_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_31[VAR_9].ul_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_31[VAR_9].ul_chan_num_tbs[VAR_10];
                    }

                    /* COMMENT_6 */
                    VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_31[VAR_9].num_dl_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_31[VAR_9].dl_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_31[VAR_9].dl_chan_num_tbs[VAR_10];
                    }
                }
                VAR_8->num_dch_in_flow++;

                nbap_debug(""    num_dch_in_flow %u"", VAR_8->num_dch_in_flow);

                VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
                set_umts_fp_conv_data(VAR_7, VAR_8);

                nbap_debug(""Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End"",
                        VAR_2->pinfo->num);

            }

        }




  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -80,7 +80,7 @@
                 nbap_debug(""    commontransportchannelid %u next ch %u"",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);
 
                 umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;
-                while(nbap_dch_chnl_info[i].next_dch != 0){
+                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){
                     i = nbap_dch_chnl_info[i].next_dch;
                     umts_fp_conversation_info->num_dch_in_flow++;
                     umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;","{'deleted_lines': ['                while(nbap_dch_chnl_info[i].next_dch != 0){'], 'added_lines': ['                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",7.5,HIGH,2,valid,2018-03-05T10:42:38Z,2
CVE-2018-9261,['CWE-834'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"NBAP: avoid linking a DCH-ID to itself

Otherwise it can create an infinite loop, leading to a buffer overflow.
Also add explicit cheks on the buffer usage and set its maximum size to
128 instead of 32 per ASN.1 description.

Bug: 14471
Change-Id: I18d26369cf3d1cf2a32c86a972c78ea9f6f7a503
Reviewed-on: https://code.wireshark.org/review/26264
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
(cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38)
Conflicts:
	epan/dissectors/asn1/nbap/nbap.cnf
	epan/dissectors/packet-nbap.c
	epan/dissectors/packet-umts_fp.h
Reviewed-on: https://code.wireshark.org/review/26267",66bc372716e04d6a8afdf6712583c9b5d11fee55,https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55,epan/dissectors/packet-nbap.c,dissect_nbap_T_dCH_ID,"static int
dissect_nbap_T_dCH_ID(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 671 ""./asn1/nbap/nbap.cnf""
offset = dissect_per_constrained_integer(tvb, offset, actx, tree, hf_index,
0U, 255U, &dch_id, FALSE);
if(g_num_dch_in_flow>0){
g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;
nbap_dch_chnl_info[dch_id].next_dch = 0;
if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){
nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;
}
}
return offset;
}","static int
dissect_nbap_T_dCH_ID(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 671 ""./asn1/nbap/nbap.cnf""
VAR_1 = dissect_per_constrained_integer(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
0U, 255U, &VAR_5, FALSE);
if(VAR_6>0){
VAR_7[VAR_6-1]=VAR_5;
VAR_8[VAR_5].next_dch = 0;
if(VAR_9 != 0 && VAR_9 != 0xffffffff){
VAR_8[VAR_9].next_dch = VAR_5;
}
}
return VAR_1;
}",,"static int
dissect_nbap_T_dCH_ID(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 671 ""./asn1/nbap/nbap.cnf""

  offset = dissect_per_constrained_integer(tvb, offset, actx, tree, hf_index,
                                                            0U, 255U, &dch_id, FALSE);

    if(g_num_dch_in_flow>0){
        g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;
        nbap_dch_chnl_info[dch_id].next_dch = 0;
        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){
            nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;
        }
    }



  return offset;
}","static int
dissect_nbap_T_dCH_ID(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 671 ""./asn1/nbap/nbap.cnf""

  VAR_1 = dissect_per_constrained_integer(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                                            0U, 255U, &VAR_5, FALSE);

    if(VAR_6>0){
        VAR_7[VAR_6-1]=VAR_5;
        VAR_8[VAR_5].next_dch = 0;
        if(VAR_9 != 0 && VAR_9 != 0xffffffff && VAR_9 != VAR_5){
            VAR_8[VAR_9].next_dch = VAR_5;
        }
    }



  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
     if(g_num_dch_in_flow>0){
         g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;
         nbap_dch_chnl_info[dch_id].next_dch = 0;
-        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){
+        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){
             nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;
         }
     }","{'deleted_lines': ['        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){'], 'added_lines': ['        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",7.5,HIGH,2,valid,2018-03-05T10:42:38Z,2
CVE-2018-9261,['CWE-834'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"NBAP: avoid linking a DCH-ID to itself

Otherwise it can create an infinite loop, leading to a buffer overflow.
Also add explicit cheks on the buffer usage and set its maximum size to
128 instead of 32 per ASN.1 description.

Bug: 14471
Change-Id: I18d26369cf3d1cf2a32c86a972c78ea9f6f7a503
Reviewed-on: https://code.wireshark.org/review/26264
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
(cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38)
Conflicts:
	epan/dissectors/asn1/nbap/nbap.cnf
	epan/dissectors/packet-nbap.c
	epan/dissectors/packet-umts_fp.h
Reviewed-on: https://code.wireshark.org/review/26267",66bc372716e04d6a8afdf6712583c9b5d11fee55,https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55,epan/dissectors/packet-nbap.c,dissect_nbap_RL_Specific_DCH_Info_Item,"static int
dissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 1138 ""./asn1/nbap/nbap.cnf""
address     dst_addr, null_addr;
conversation_t *conversation = NULL;
umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;
transportLayerAddress_ipv4 = 0;
BindingID_port = 0;
dch_id = 0xFFFFFFFF;
offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
ett_nbap_RL_Specific_DCH_Info_Item, RL_Specific_DCH_Info_Item_sequence);
if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
{
return offset;
}
if(BindingID_port == NBAP_IGNORE_PORT){
return offset;
}
clear_address(&null_addr);
set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);
conversation = find_conversation(actx->pinfo->num,&dst_addr,
&null_addr, PT_UDP, BindingID_port,
0, NO_ADDR_B|NO_PORT_B);
if (conversation == NULL) {
conversation = conversation_new(actx->pinfo->num, &dst_addr,
&null_addr, PT_UDP,BindingID_port ,
0, NO_ADDR2|NO_PORT2);
conversation_set_dissector(conversation, fp_handle);
if(actx->pinfo->link_dir==P2P_DIR_DL){
umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
umts_fp_conversation_info->iface_type        = IuB_Interface;
umts_fp_conversation_info->division          = Division_FDD;
umts_fp_conversation_info->channel           = CHANNEL_DCH;
umts_fp_conversation_info->dl_frame_number   = 0;
umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
umts_fp_conversation_info->crnc_port         = BindingID_port;
umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;
umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;
umts_fp_conversation_info->com_context_id = com_context_id;
if (dch_id != 0xffffffff) {
umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[dch_id].num_ul_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].ul_chan_num_tbs[j];
}
umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[dch_id].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].dl_chan_num_tbs[j];
}
i = dch_id;
umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;
while(nbap_dch_chnl_info[i].next_dch != 0){
i = nbap_dch_chnl_info[i].next_dch;
umts_fp_conversation_info->num_dch_in_flow++;
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;   
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
}
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
}
}
umts_fp_conversation_info->num_dch_in_flow++;
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
set_umts_fp_conv_data(conversation, umts_fp_conversation_info);
}
}
nbap_debug(""Frame %u RL-Specific-DCH-Info-Item Start"", actx->pinfo->num);
nbap_debug(""    Total no of ch in flow will be: %d"", umts_fp_conversation_info->num_dch_in_flow);
nbap_debug(""Frame %u RL-Specific-DCH-Info-Item End"", actx->pinfo->num);
}
return offset;
}","static int
dissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 1138 ""./asn1/nbap/nbap.cnf""
address     VAR_5, VAR_6;
conversation_t *VAR_7 = NULL;
umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;
VAR_12 = 0;
VAR_13 = 0;
VAR_14 = 0xFFFFFFFF;
VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_15, VAR_16);
if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
{
return VAR_1;
}
if(VAR_13 == VAR_17){
return VAR_1;
}
clear_address(&VAR_6);
set_address(&VAR_5, VAR_18, 4, &VAR_12);
VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
&VAR_6, VAR_19, VAR_13,
0, VAR_20|VAR_21);
if (VAR_7 == NULL) {
VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
&VAR_6, VAR_19,VAR_13 ,
0, VAR_22|VAR_23);
conversation_set_dissector(VAR_7, VAR_24);
if(VAR_2->pinfo->link_dir==VAR_25){
VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
VAR_8->iface_type        = VAR_26;
VAR_8->division          = VAR_27;
VAR_8->channel           = VAR_28;
VAR_8->dl_frame_number   = 0;
VAR_8->ul_frame_number   = VAR_2->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
VAR_8->crnc_port         = VAR_13;
VAR_8->rlc_mode          = VAR_29;
VAR_8->dch_crc_present = VAR_30.dch_crc_present;
VAR_8->com_context_id = VAR_31;
if (VAR_14 != 0xffffffff) {
VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_32[VAR_14].num_ul_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_32[VAR_14].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_32[VAR_14].ul_chan_num_tbs[VAR_10];
}
VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_32[VAR_14].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_32[VAR_14].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_32[VAR_14].dl_chan_num_tbs[VAR_10];
}
VAR_9 = VAR_14;
VAR_8->dchs_in_flow_list[0] = VAR_14;
while(VAR_32[VAR_9].next_dch != 0){
VAR_9 = VAR_32[VAR_9].next_dch;
VAR_8->num_dch_in_flow++;
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;   
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_32[VAR_9].num_ul_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_32[VAR_9].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_32[VAR_9].ul_chan_num_tbs[VAR_10];
}
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_32[VAR_9].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_32[VAR_9].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_32[VAR_9].dl_chan_num_tbs[VAR_10];
}
}
VAR_8->num_dch_in_flow++;
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
set_umts_fp_conv_data(VAR_7, VAR_8);
}
}
nbap_debug(""Frame %u RL-Specific-DCH-Info-Item Start"", VAR_2->pinfo->num);
nbap_debug(""    Total no of ch in flow will be: %d"", VAR_8->num_dch_in_flow);
nbap_debug(""Frame %u RL-Specific-DCH-Info-Item End"", VAR_2->pinfo->num);
}
return VAR_1;
}",,"static int
dissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 1138 ""./asn1/nbap/nbap.cnf""
address     dst_addr, null_addr;
conversation_t *conversation = NULL;
umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;

transportLayerAddress_ipv4 = 0;
BindingID_port = 0;
dch_id = 0xFFFFFFFF;

  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
                                   ett_nbap_RL_Specific_DCH_Info_Item, RL_Specific_DCH_Info_Item_sequence);


        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
        {
            return offset;
        }

        /*RBS might sometimes send a nonsens bind, to indicate that no DCH is present*/
        if(BindingID_port == NBAP_IGNORE_PORT){
                return offset;
        }

        clear_address(&null_addr);

        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);

        conversation = find_conversation(actx->pinfo->num,&dst_addr,
            &null_addr, PT_UDP, BindingID_port,
            0, NO_ADDR_B|NO_PORT_B);

        if (conversation == NULL) {
            /* It's not part of any conversation - create a new one. */
            conversation = conversation_new(actx->pinfo->num, &dst_addr,
                &null_addr, PT_UDP,BindingID_port ,
                0, NO_ADDR2|NO_PORT2);

            /* Set dissector */
            conversation_set_dissector(conversation, fp_handle);
            if(actx->pinfo->link_dir==P2P_DIR_DL){
                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);

                /* Fill in the data */
                umts_fp_conversation_info->iface_type        = IuB_Interface;
                umts_fp_conversation_info->division          = Division_FDD;
                umts_fp_conversation_info->channel           = CHANNEL_DCH;
                umts_fp_conversation_info->dl_frame_number   = 0;
                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
                umts_fp_conversation_info->crnc_port         = BindingID_port;
                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;

                /* DCH's in this flow */
                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;

                /*Save unique UE-identifier */
                umts_fp_conversation_info->com_context_id = com_context_id;

                if (dch_id != 0xffffffff) {
                    /*UPLINK*/
                    /* Set data for First or single channel */
                    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[dch_id].num_ul_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].ul_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].ul_chan_num_tbs[j];
                    }

                    /* Traffic flows per DCH(DL) */
                    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[dch_id].num_dl_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].dl_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].dl_chan_num_tbs[j];
                    }

                    /* Set data for associated DCH's if we have any */
                    i = dch_id;
                    umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;
                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){


                        i = nbap_dch_chnl_info[i].next_dch;
                        umts_fp_conversation_info->num_dch_in_flow++;
                        umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;   /*Set transport channel id*/

                        /*Setting Logical Channel's for this DCH*/
                        /* Traffic flows per DCH(UL) */
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
                        for (j = 0; j < num_tf; j++) {
                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
                        }

                        /* Traffic flows per DCH(DL) */
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
                        for (j = 0; j < num_tf; j++) {
                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
                        }

                    }
                    umts_fp_conversation_info->num_dch_in_flow++;
                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
                    set_umts_fp_conv_data(conversation, umts_fp_conversation_info);
                }
            }

            nbap_debug(""Frame %u RL-Specific-DCH-Info-Item Start"", actx->pinfo->num);
            nbap_debug(""    Total no of ch in flow will be: %d"", umts_fp_conversation_info->num_dch_in_flow);
            nbap_debug(""Frame %u RL-Specific-DCH-Info-Item End"", actx->pinfo->num);

        }






  return offset;
}","static int
dissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 1138 ""./asn1/nbap/nbap.cnf""
address     VAR_5, VAR_6;
conversation_t *VAR_7 = NULL;
umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;

VAR_12 = 0;
VAR_13 = 0;
VAR_14 = 0xFFFFFFFF;

  VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                   VAR_15, VAR_16);


        if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
        {
            return VAR_1;
        }

        /* COMMENT_0 */
        if(VAR_13 == VAR_17){
                return VAR_1;
        }

        clear_address(&VAR_6);

        set_address(&VAR_5, VAR_18, 4, &VAR_12);

        VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
            &VAR_6, VAR_19, VAR_13,
            0, VAR_20|VAR_21);

        if (VAR_7 == NULL) {
            /* COMMENT_1 */
            VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
                &VAR_6, VAR_19,VAR_13 ,
                0, VAR_22|VAR_23);

            /* COMMENT_2 */
            conversation_set_dissector(VAR_7, VAR_24);
            if(VAR_2->pinfo->link_dir==VAR_25){
                VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);

                /* COMMENT_3 */
                VAR_8->iface_type        = VAR_26;
                VAR_8->division          = VAR_27;
                VAR_8->channel           = VAR_28;
                VAR_8->dl_frame_number   = 0;
                VAR_8->ul_frame_number   = VAR_2->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
                VAR_8->crnc_port         = VAR_13;
                VAR_8->rlc_mode          = VAR_29;

                /* COMMENT_4 */
                VAR_8->dch_crc_present = VAR_30.dch_crc_present;

                /* COMMENT_5 */
                VAR_8->com_context_id = VAR_31;

                if (VAR_14 != 0xffffffff) {
                    /* COMMENT_6 */
                    /* COMMENT_7 */
                    VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_32[VAR_14].num_ul_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_32[VAR_14].ul_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_32[VAR_14].ul_chan_num_tbs[VAR_10];
                    }

                    /* COMMENT_8 */
                    VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_32[VAR_14].num_dl_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_32[VAR_14].dl_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_32[VAR_14].dl_chan_num_tbs[VAR_10];
                    }

                    /* COMMENT_9 */
                    VAR_9 = VAR_14;
                    VAR_8->dchs_in_flow_list[0] = VAR_14;
                    while(VAR_32[VAR_9].next_dch != 0 && VAR_8->num_dch_in_flow < VAR_33){


                        VAR_9 = VAR_32[VAR_9].next_dch;
                        VAR_8->num_dch_in_flow++;
                        VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;   /* COMMENT_10 */

                        /* COMMENT_11 */
                        /* COMMENT_12 */
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_32[VAR_9].num_ul_chans;
                        for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                            VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_32[VAR_9].ul_chan_tf_size[VAR_10];
                            VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_32[VAR_9].ul_chan_num_tbs[VAR_10];
                        }

                        /* COMMENT_8 */
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_32[VAR_9].num_dl_chans;
                        for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                            VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_32[VAR_9].dl_chan_tf_size[VAR_10];
                            VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_32[VAR_9].dl_chan_num_tbs[VAR_10];
                        }

                    }
                    VAR_8->num_dch_in_flow++;
                    VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
                    set_umts_fp_conv_data(VAR_7, VAR_8);
                }
            }

            nbap_debug(""Frame %u RL-Specific-DCH-Info-Item Start"", VAR_2->pinfo->num);
            nbap_debug(""    Total no of ch in flow will be: %d"", VAR_8->num_dch_in_flow);
            nbap_debug(""Frame %u RL-Specific-DCH-Info-Item End"", VAR_2->pinfo->num);

        }






  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -78,7 +78,7 @@
                     /* Set data for associated DCH's if we have any */
                     i = dch_id;
                     umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;
-                    while(nbap_dch_chnl_info[i].next_dch != 0){
+                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){
 
 
                         i = nbap_dch_chnl_info[i].next_dch;","{'deleted_lines': ['                    while(nbap_dch_chnl_info[i].next_dch != 0){'], 'added_lines': ['                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",7.5,HIGH,2,valid,2018-03-05T10:42:38Z,2
CVE-2018-9261,['CWE-834'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"NBAP: avoid linking a DCH-ID to itself

Otherwise it can create an infinite loop, leading to a buffer overflow.
Also add explicit cheks on the buffer usage and set its maximum size to
128 instead of 32 per ASN.1 description.

Bug: 14471
Change-Id: I18d26369cf3d1cf2a32c86a972c78ea9f6f7a503
Reviewed-on: https://code.wireshark.org/review/26264
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
(cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38)
Conflicts:
	epan/dissectors/asn1/nbap/nbap.cnf
	epan/dissectors/packet-nbap.c
	epan/dissectors/packet-umts_fp.h
Reviewed-on: https://code.wireshark.org/review/26267",66bc372716e04d6a8afdf6712583c9b5d11fee55,https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55,epan/dissectors/packet-nbap.c,dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD,"static int
dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 928 ""./asn1/nbap/nbap.cnf""
address     dst_addr, null_addr;
conversation_t *conversation;
umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;
transportLayerAddress_ipv4 = 0;
BindingID_port = 0;
transportFormatSet_type = NBAP_CPCH;
offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
ett_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD, FACH_ParametersItem_CTCH_SetupRqstFDD_sequence);
if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
{
return offset;
}
clear_address(&null_addr);
set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);
conversation = find_conversation(actx->pinfo->num,&dst_addr,
&null_addr, PT_UDP, BindingID_port,
0, NO_ADDR_B|NO_PORT_B);
if (conversation == NULL) {
conversation = conversation_new(actx->pinfo->num, &dst_addr,
&null_addr, PT_UDP,BindingID_port ,
0, NO_ADDR2|NO_PORT2);
conversation_set_dissector(conversation, fp_handle);
if(actx->pinfo->link_dir==P2P_DIR_DL){
umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
umts_fp_conversation_info->iface_type        = IuB_Interface;
umts_fp_conversation_info->division          = Division_FDD;
umts_fp_conversation_info->channel           = CHANNEL_FACH_FDD;
umts_fp_conversation_info->dl_frame_number   = 0;
umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
umts_fp_conversation_info->crnc_port         = BindingID_port;
umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;
umts_fp_conversation_info->com_context_id = crcn_context_present ? com_context_id : 1;
umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;
umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_ul_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_num_tbs[j];
}
umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_num_tbs[j];
}
i = commonphysicalchannelid;
umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;
while(nbap_dch_chnl_info[i].next_dch != 0){
i = nbap_dch_chnl_info[i].next_dch;
umts_fp_conversation_info->num_dch_in_flow++;
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
}
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
for (j = 0; j < num_tf; j++) {
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
}
}
umts_fp_conversation_info->num_dch_in_flow++;
umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
set_umts_fp_conv_data(conversation, umts_fp_conversation_info);
}
}
return offset;
}","static int
dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 928 ""./asn1/nbap/nbap.cnf""
address     VAR_5, VAR_6;
conversation_t *VAR_7;
umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;
VAR_12 = 0;
VAR_13 = 0;
VAR_14 = VAR_15;
VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_16, VAR_17);
if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
{
return VAR_1;
}
clear_address(&VAR_6);
set_address(&VAR_5, VAR_18, 4, &VAR_12);
VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
&VAR_6, VAR_19, VAR_13,
0, VAR_20|VAR_21);
if (VAR_7 == NULL) {
VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
&VAR_6, VAR_19,VAR_13 ,
0, VAR_22|VAR_23);
conversation_set_dissector(VAR_7, VAR_24);
if(VAR_2->pinfo->link_dir==VAR_25){
VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
VAR_8->iface_type        = VAR_26;
VAR_8->division          = VAR_27;
VAR_8->channel           = VAR_28;
VAR_8->dl_frame_number   = 0;
VAR_8->ul_frame_number   = VAR_2->pinfo->num;
copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
VAR_8->crnc_port         = VAR_13;
VAR_8->rlc_mode          = VAR_29;
VAR_8->com_context_id = VAR_30 ? VAR_31 : 1;
VAR_8->dch_crc_present = VAR_32.dch_crc_present;
VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_33[VAR_34].num_ul_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_33[VAR_34].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_33[VAR_34].ul_chan_num_tbs[VAR_10];
}
VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_33[VAR_34].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_33[VAR_34].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_33[VAR_34].dl_chan_num_tbs[VAR_10];
}
VAR_9 = VAR_34;
VAR_8->dchs_in_flow_list[0] = VAR_34;
while(VAR_33[VAR_9].next_dch != 0){
VAR_9 = VAR_33[VAR_9].next_dch;
VAR_8->num_dch_in_flow++;
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_33[VAR_9].num_ul_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_33[VAR_9].ul_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_33[VAR_9].ul_chan_num_tbs[VAR_10];
}
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_33[VAR_9].num_dl_chans;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_33[VAR_9].dl_chan_tf_size[VAR_10];
VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_33[VAR_9].dl_chan_num_tbs[VAR_10];
}
}
VAR_8->num_dch_in_flow++;
VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
set_umts_fp_conv_data(VAR_7, VAR_8);
}
}
return VAR_1;
}",,"static int
dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 928 ""./asn1/nbap/nbap.cnf""
address     dst_addr, null_addr;
conversation_t *conversation;

umts_fp_conversation_info_t *umts_fp_conversation_info;
int i, j, num_tf;

transportLayerAddress_ipv4 = 0;
BindingID_port = 0;

transportFormatSet_type = NBAP_CPCH;

  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,
                                   ett_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD, FACH_ParametersItem_CTCH_SetupRqstFDD_sequence);


        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)
        {
            return offset;
        }
        clear_address(&null_addr);

        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);

        conversation = find_conversation(actx->pinfo->num,&dst_addr,
            &null_addr, PT_UDP, BindingID_port,
            0, NO_ADDR_B|NO_PORT_B);

        if (conversation == NULL) {
            /* It's not part of any conversation - create a new one. */
            conversation = conversation_new(actx->pinfo->num, &dst_addr,
                &null_addr, PT_UDP,BindingID_port ,
                0, NO_ADDR2|NO_PORT2);

            /* Set dissector */
            conversation_set_dissector(conversation, fp_handle);
            if(actx->pinfo->link_dir==P2P_DIR_DL){
                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
                /* Fill in the data */
                umts_fp_conversation_info->iface_type        = IuB_Interface;
                umts_fp_conversation_info->division          = Division_FDD;
                umts_fp_conversation_info->channel           = CHANNEL_FACH_FDD;
                umts_fp_conversation_info->dl_frame_number   = 0;
                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);
                umts_fp_conversation_info->crnc_port         = BindingID_port;
                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;
                /*Save unique UE-identifier */
                umts_fp_conversation_info->com_context_id = crcn_context_present ? com_context_id : 1;


                /* DCH's in this flow */
                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;
                /* Set data for First or single channel */
                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_ul_chans;
                for (j = 0; j < num_tf; j++) {
                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_tf_size[j];
                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_num_tbs[j];
                }

                /* Traffic flows per DCH(DL) */
                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_dl_chans;
                for (j = 0; j < num_tf; j++) {
                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_tf_size[j];
                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_num_tbs[j];
                }

                /* Set data for associated DCH's if we have any */
                i = commonphysicalchannelid;
                umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;
                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){
                    i = nbap_dch_chnl_info[i].next_dch;
                    umts_fp_conversation_info->num_dch_in_flow++;
                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
                    /* Traffic flows per DCH(UL) */
                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];
                    }

                    /* Traffic flows per DCH(DL) */
                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;
                    for (j = 0; j < num_tf; j++) {
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];
                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];
                    }
                }
                umts_fp_conversation_info->num_dch_in_flow++;
                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;
                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);
            }

        }



  return offset;
}","static int
dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
#line 928 ""./asn1/nbap/nbap.cnf""
address     VAR_5, VAR_6;
conversation_t *VAR_7;

umts_fp_conversation_info_t *VAR_8;
int VAR_9, VAR_10, VAR_11;

VAR_12 = 0;
VAR_13 = 0;

VAR_14 = VAR_15;

  VAR_1 = dissect_per_sequence(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                   VAR_16, VAR_17);


        if (VAR_2->pinfo->fd->flags.visited||VAR_12==0||VAR_13 == 0)
        {
            return VAR_1;
        }
        clear_address(&VAR_6);

        set_address(&VAR_5, VAR_18, 4, &VAR_12);

        VAR_7 = find_conversation(VAR_2->pinfo->num,&VAR_5,
            &VAR_6, VAR_19, VAR_13,
            0, VAR_20|VAR_21);

        if (VAR_7 == NULL) {
            /* COMMENT_0 */
            VAR_7 = conversation_new(VAR_2->pinfo->num, &VAR_5,
                &VAR_6, VAR_19,VAR_13 ,
                0, VAR_22|VAR_23);

            /* COMMENT_1 */
            conversation_set_dissector(VAR_7, VAR_24);
            if(VAR_2->pinfo->link_dir==VAR_25){
                VAR_8 = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);
                /* COMMENT_2 */
                VAR_8->iface_type        = VAR_26;
                VAR_8->division          = VAR_27;
                VAR_8->channel           = VAR_28;
                VAR_8->dl_frame_number   = 0;
                VAR_8->ul_frame_number   = VAR_2->pinfo->num;
                copy_address_wmem(wmem_file_scope(), &(VAR_8->crnc_address), &VAR_5);
                VAR_8->crnc_port         = VAR_13;
                VAR_8->rlc_mode          = VAR_29;
                /* COMMENT_3 */
                VAR_8->com_context_id = VAR_30 ? VAR_31 : 1;


                /* COMMENT_4 */
                VAR_8->dch_crc_present = VAR_32.dch_crc_present;
                /* COMMENT_5 */
                VAR_8->fp_dch_channel_info[0].num_ul_chans = VAR_11 = VAR_33[VAR_34].num_ul_chans;
                for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                    VAR_8->fp_dch_channel_info[0].ul_chan_tf_size[VAR_10] = VAR_33[VAR_34].ul_chan_tf_size[VAR_10];
                    VAR_8->fp_dch_channel_info[0].ul_chan_num_tbs[VAR_10] = VAR_33[VAR_34].ul_chan_num_tbs[VAR_10];
                }

                /* COMMENT_6 */
                VAR_8->fp_dch_channel_info[0].num_dl_chans = VAR_11 = VAR_33[VAR_34].num_dl_chans;
                for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                    VAR_8->fp_dch_channel_info[0].dl_chan_tf_size[VAR_10] = VAR_33[VAR_34].dl_chan_tf_size[VAR_10];
                    VAR_8->fp_dch_channel_info[0].dl_chan_num_tbs[VAR_10] = VAR_33[VAR_34].dl_chan_num_tbs[VAR_10];
                }

                /* COMMENT_7 */
                VAR_9 = VAR_34;
                VAR_8->dchs_in_flow_list[0] = VAR_34;
                while(VAR_33[VAR_9].next_dch != 0 && VAR_8->num_dch_in_flow < VAR_35){
                    VAR_9 = VAR_33[VAR_9].next_dch;
                    VAR_8->num_dch_in_flow++;
                    VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
                    /* COMMENT_8 */
                    VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_ul_chans = VAR_11 = VAR_33[VAR_9].num_ul_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_tf_size[VAR_10] = VAR_33[VAR_9].ul_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].ul_chan_num_tbs[VAR_10] = VAR_33[VAR_9].ul_chan_num_tbs[VAR_10];
                    }

                    /* COMMENT_6 */
                    VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].num_dl_chans = VAR_11 = VAR_33[VAR_9].num_dl_chans;
                    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_tf_size[VAR_10] = VAR_33[VAR_9].dl_chan_tf_size[VAR_10];
                        VAR_8->fp_dch_channel_info[VAR_8->num_dch_in_flow].dl_chan_num_tbs[VAR_10] = VAR_33[VAR_9].dl_chan_num_tbs[VAR_10];
                    }
                }
                VAR_8->num_dch_in_flow++;
                VAR_8->dchs_in_flow_list[VAR_8->num_dch_in_flow] = VAR_9;
                set_umts_fp_conv_data(VAR_7, VAR_8);
            }

        }



  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -70,7 +70,7 @@
                 /* Set data for associated DCH's if we have any */
                 i = commonphysicalchannelid;
                 umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;
-                while(nbap_dch_chnl_info[i].next_dch != 0){
+                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){
                     i = nbap_dch_chnl_info[i].next_dch;
                     umts_fp_conversation_info->num_dch_in_flow++;
                     umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;","{'deleted_lines': ['                while(nbap_dch_chnl_info[i].next_dch != 0){'], 'added_lines': ['                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){']}",True,"In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",7.5,HIGH,2,valid,2018-03-05T10:42:38Z,2
CVE-2018-1000100,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,"fix some exploitable overflows (#994, #997)",90dc7f853d31b0a4e9441cba97feccf36d8b69a4,https://github.com/gpac/gpac/commit/90dc7f853d31b0a4e9441cba97feccf36d8b69a4,src/isomedia/avc_ext.c,gf_isom_oinf_read_entry,"GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)
{
GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;
u32 i, j, count;
if (!ptr) return GF_BAD_PARAM;
ptr->scalability_mask = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 2);count = gf_bs_read_int(bs, 6);
for (i = 0; i < count; i++) {
LHEVC_ProfileTierLevel *ptl;
GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);
if (!ptl) return GF_OUT_OF_MEM;
ptl->general_profile_space = gf_bs_read_int(bs, 2);
ptl->general_tier_flag= gf_bs_read_int(bs, 1);
ptl->general_profile_idc = gf_bs_read_int(bs, 5);
ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);
ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);
ptl->general_level_idc = gf_bs_read_u8(bs);
gf_list_add(ptr->profile_tier_levels, ptl);
}
count = gf_bs_read_u16(bs);
for (i = 0; i < count; i++) {
LHEVC_OperatingPoint *op;
GF_SAFEALLOC(op, LHEVC_OperatingPoint);
if (!op) return GF_OUT_OF_MEM;
op->output_layer_set_idx = gf_bs_read_u16(bs);
op->max_temporal_id = gf_bs_read_u8(bs);
op->layer_count = gf_bs_read_u8(bs);
for (j = 0; j < op->layer_count; j++) {
op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
}
op->minPicWidth = gf_bs_read_u16(bs);
op->minPicHeight = gf_bs_read_u16(bs);
op->maxPicWidth = gf_bs_read_u16(bs);
op->maxPicHeight = gf_bs_read_u16(bs);
op->maxChromaFormat = gf_bs_read_int(bs, 2);
op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;
gf_bs_read_int(bs, 1);op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
if (op->frame_rate_info_flag) {
op->avgFrameRate = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 6); op->constantFrameRate = gf_bs_read_int(bs, 2);
}
if (op->bit_rate_info_flag) {
op->maxBitRate = gf_bs_read_u32(bs);
op->avgBitRate = gf_bs_read_u32(bs);
}
gf_list_add(ptr->operating_points, op);
}
count = gf_bs_read_u8(bs);
for (i = 0; i < count; i++) {
LHEVC_DependentLayer *dep;
GF_SAFEALLOC(dep, LHEVC_DependentLayer);
if (!dep) return GF_OUT_OF_MEM;
dep->dependent_layerID = gf_bs_read_u8(bs);
dep->num_layers_dependent_on = gf_bs_read_u8(bs);
for (j = 0; j < dep->num_layers_dependent_on; j++)
dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);
for (j = 0; j < 16; j++) {
if (ptr->scalability_mask & (1 << j))
dep->dimension_identifier[j] = gf_bs_read_u8(bs);
}
gf_list_add(ptr->dependency_layers, dep);
}
return GF_OK;
}","GF_Err gf_isom_oinf_read_entry(void *VAR_0, GF_BitStream *VAR_1)
{
GF_OperatingPointsInformation* VAR_2 = (GF_OperatingPointsInformation *)VAR_0;
u32 VAR_3, VAR_4, VAR_5;
if (!VAR_2) return VAR_6;
VAR_2->scalability_mask = gf_bs_read_u16(VAR_1);
gf_bs_read_int(VAR_1, 2);
VAR_5 = gf_bs_read_int(VAR_1, 6);
for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
LHEVC_ProfileTierLevel *VAR_7;
GF_SAFEALLOC(VAR_7, LHEVC_ProfileTierLevel);
if (!VAR_7) return VAR_8;
VAR_7->general_profile_space = gf_bs_read_int(VAR_1, 2);
VAR_7->general_tier_flag= gf_bs_read_int(VAR_1, 1);
VAR_7->general_profile_idc = gf_bs_read_int(VAR_1, 5);
VAR_7->general_profile_compatibility_flags = gf_bs_read_u32(VAR_1);
VAR_7->general_constraint_indicator_flags = gf_bs_read_long_int(VAR_1, 48);
VAR_7->general_level_idc = gf_bs_read_u8(VAR_1);
gf_list_add(VAR_2->profile_tier_levels, VAR_7);
}
VAR_5 = gf_bs_read_u16(VAR_1);
for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
LHEVC_OperatingPoint *VAR_9;
GF_SAFEALLOC(VAR_9, LHEVC_OperatingPoint);
if (!VAR_9) return VAR_8;
VAR_9->output_layer_set_idx = gf_bs_read_u16(VAR_1);
VAR_9->max_temporal_id = gf_bs_read_u8(VAR_1);
VAR_9->layer_count = gf_bs_read_u8(VAR_1);
for (VAR_4 = 0; VAR_4 < VAR_9->layer_count; VAR_4++) {
VAR_9->layers_info[VAR_4].ptl_idx = gf_bs_read_u8(VAR_1);
VAR_9->layers_info[VAR_4].layer_id = gf_bs_read_int(VAR_1, 6);
VAR_9->layers_info[VAR_4].is_outputlayer = gf_bs_read_int(VAR_1, 1) ? VAR_10 : VAR_11;
VAR_9->layers_info[VAR_4].is_alternate_outputlayer = gf_bs_read_int(VAR_1, 1) ? VAR_10 : VAR_11;
}
VAR_9->minPicWidth = gf_bs_read_u16(VAR_1);
VAR_9->minPicHeight = gf_bs_read_u16(VAR_1);
VAR_9->maxPicWidth = gf_bs_read_u16(VAR_1);
VAR_9->maxPicHeight = gf_bs_read_u16(VAR_1);
VAR_9->maxChromaFormat = gf_bs_read_int(VAR_1, 2);
VAR_9->maxBitDepth = gf_bs_read_int(VAR_1, 3) + 8;
gf_bs_read_int(VAR_1, 1);
VAR_9->frame_rate_info_flag = gf_bs_read_int(VAR_1, 1) ? VAR_10 : VAR_11;
VAR_9->bit_rate_info_flag = gf_bs_read_int(VAR_1, 1) ? VAR_10 : VAR_11;
if (VAR_9->frame_rate_info_flag) {
VAR_9->avgFrameRate = gf_bs_read_u16(VAR_1);
gf_bs_read_int(VAR_1, 6); 
VAR_9->constantFrameRate = gf_bs_read_int(VAR_1, 2);
}
if (VAR_9->bit_rate_info_flag) {
VAR_9->maxBitRate = gf_bs_read_u32(VAR_1);
VAR_9->avgBitRate = gf_bs_read_u32(VAR_1);
}
gf_list_add(VAR_2->operating_points, VAR_9);
}
VAR_5 = gf_bs_read_u8(VAR_1);
for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
LHEVC_DependentLayer *VAR_12;
GF_SAFEALLOC(VAR_12, LHEVC_DependentLayer);
if (!VAR_12) return VAR_8;
VAR_12->dependent_layerID = gf_bs_read_u8(VAR_1);
VAR_12->num_layers_dependent_on = gf_bs_read_u8(VAR_1);
for (VAR_4 = 0; VAR_4 < VAR_12->num_layers_dependent_on; VAR_4++)
VAR_12->dependent_on_layerID[VAR_4] = gf_bs_read_u8(VAR_1);
for (VAR_4 = 0; VAR_4 < 16; VAR_4++) {
if (VAR_2->scalability_mask & (1 << VAR_4))
VAR_12->dimension_identifier[VAR_4] = gf_bs_read_u8(VAR_1);
}
gf_list_add(VAR_2->dependency_layers, VAR_12);
}
return VAR_13;
}",gpac/90dc7f853d31b0a4e9441cba97feccf36d8b69a4/avc_ext.c/vul/before/0.json,"GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)
{
	GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;
	u32 i, j, count;

	if (!ptr) return GF_BAD_PARAM;
	ptr->scalability_mask = gf_bs_read_u16(bs);
	gf_bs_read_int(bs, 2);//reserved
	count = gf_bs_read_int(bs, 6);
	for (i = 0; i < count; i++) {
		LHEVC_ProfileTierLevel *ptl;
		GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);
		if (!ptl) return GF_OUT_OF_MEM;
		ptl->general_profile_space = gf_bs_read_int(bs, 2);
		ptl->general_tier_flag= gf_bs_read_int(bs, 1);
		ptl->general_profile_idc = gf_bs_read_int(bs, 5);
		ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);
		ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);
		ptl->general_level_idc = gf_bs_read_u8(bs);
		gf_list_add(ptr->profile_tier_levels, ptl);
	}
	count = gf_bs_read_u16(bs);
	for (i = 0; i < count; i++) {
		LHEVC_OperatingPoint *op;
		GF_SAFEALLOC(op, LHEVC_OperatingPoint);
		if (!op) return GF_OUT_OF_MEM;
		op->output_layer_set_idx = gf_bs_read_u16(bs);
		op->max_temporal_id = gf_bs_read_u8(bs);
		op->layer_count = gf_bs_read_u8(bs);
		if (op->layer_count > ARRAY_LENGTH(op->layers_info))
			return GF_NON_COMPLIANT_BITSTREAM;
		for (j = 0; j < op->layer_count; j++) {
			op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
			op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
			op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
			op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
		}
		op->minPicWidth = gf_bs_read_u16(bs);
		op->minPicHeight = gf_bs_read_u16(bs);
		op->maxPicWidth = gf_bs_read_u16(bs);
		op->maxPicHeight = gf_bs_read_u16(bs);
		op->maxChromaFormat = gf_bs_read_int(bs, 2);
		op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;
		gf_bs_read_int(bs, 1);//reserved
		op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
		op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
		if (op->frame_rate_info_flag) {
			op->avgFrameRate = gf_bs_read_u16(bs);
			gf_bs_read_int(bs, 6); //reserved
			op->constantFrameRate = gf_bs_read_int(bs, 2);
		}
		if (op->bit_rate_info_flag) {
			op->maxBitRate = gf_bs_read_u32(bs);
			op->avgBitRate = gf_bs_read_u32(bs);
		}
		gf_list_add(ptr->operating_points, op);
	}
	count = gf_bs_read_u8(bs);
	for (i = 0; i < count; i++) {
		LHEVC_DependentLayer *dep;
		GF_SAFEALLOC(dep, LHEVC_DependentLayer);
		if (!dep) return GF_OUT_OF_MEM;
		dep->dependent_layerID = gf_bs_read_u8(bs);
		dep->num_layers_dependent_on = gf_bs_read_u8(bs);
		for (j = 0; j < dep->num_layers_dependent_on; j++)
			dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);
		for (j = 0; j < 16; j++) {
			if (ptr->scalability_mask & (1 << j))
				dep->dimension_identifier[j] = gf_bs_read_u8(bs);
		}
		gf_list_add(ptr->dependency_layers, dep);
	}

	return GF_OK;
}","GF_Err gf_isom_oinf_read_entry(void *VAR_0, GF_BitStream *VAR_1)
{
	GF_OperatingPointsInformation* VAR_2 = (GF_OperatingPointsInformation *)VAR_0;
	u32 VAR_3, VAR_4, VAR_5;

	if (!VAR_2) return VAR_6;
	VAR_2->scalability_mask = gf_bs_read_u16(VAR_1);
	gf_bs_read_int(VAR_1, 2);/* COMMENT_0 */
	VAR_5 = gf_bs_read_int(VAR_1, 6);
	for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
		LHEVC_ProfileTierLevel *VAR_7;
		GF_SAFEALLOC(VAR_7, LHEVC_ProfileTierLevel);
		if (!VAR_7) return VAR_8;
		VAR_7->general_profile_space = gf_bs_read_int(VAR_1, 2);
		VAR_7->general_tier_flag= gf_bs_read_int(VAR_1, 1);
		VAR_7->general_profile_idc = gf_bs_read_int(VAR_1, 5);
		VAR_7->general_profile_compatibility_flags = gf_bs_read_u32(VAR_1);
		VAR_7->general_constraint_indicator_flags = gf_bs_read_long_int(VAR_1, 48);
		VAR_7->general_level_idc = gf_bs_read_u8(VAR_1);
		gf_list_add(VAR_2->profile_tier_levels, VAR_7);
	}
	VAR_5 = gf_bs_read_u16(VAR_1);
	for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
		LHEVC_OperatingPoint *VAR_9;
		GF_SAFEALLOC(VAR_9, LHEVC_OperatingPoint);
		if (!VAR_9) return VAR_8;
		VAR_9->output_layer_set_idx = gf_bs_read_u16(VAR_1);
		VAR_9->max_temporal_id = gf_bs_read_u8(VAR_1);
		VAR_9->layer_count = gf_bs_read_u8(VAR_1);
		if (VAR_9->layer_count > ARRAY_LENGTH(VAR_9->layers_info))
			return VAR_10;
		for (VAR_4 = 0; VAR_4 < VAR_9->layer_count; VAR_4++) {
			VAR_9->layers_info[VAR_4].ptl_idx = gf_bs_read_u8(VAR_1);
			VAR_9->layers_info[VAR_4].layer_id = gf_bs_read_int(VAR_1, 6);
			VAR_9->layers_info[VAR_4].is_outputlayer = gf_bs_read_int(VAR_1, 1) ? VAR_11 : VAR_12;
			VAR_9->layers_info[VAR_4].is_alternate_outputlayer = gf_bs_read_int(VAR_1, 1) ? VAR_11 : VAR_12;
		}
		VAR_9->minPicWidth = gf_bs_read_u16(VAR_1);
		VAR_9->minPicHeight = gf_bs_read_u16(VAR_1);
		VAR_9->maxPicWidth = gf_bs_read_u16(VAR_1);
		VAR_9->maxPicHeight = gf_bs_read_u16(VAR_1);
		VAR_9->maxChromaFormat = gf_bs_read_int(VAR_1, 2);
		VAR_9->maxBitDepth = gf_bs_read_int(VAR_1, 3) + 8;
		gf_bs_read_int(VAR_1, 1);/* COMMENT_0 */
		VAR_9->frame_rate_info_flag = gf_bs_read_int(VAR_1, 1) ? VAR_11 : VAR_12;
		VAR_9->bit_rate_info_flag = gf_bs_read_int(VAR_1, 1) ? VAR_11 : VAR_12;
		if (VAR_9->frame_rate_info_flag) {
			VAR_9->avgFrameRate = gf_bs_read_u16(VAR_1);
			gf_bs_read_int(VAR_1, 6); /* COMMENT_0 */
			VAR_9->constantFrameRate = gf_bs_read_int(VAR_1, 2);
		}
		if (VAR_9->bit_rate_info_flag) {
			VAR_9->maxBitRate = gf_bs_read_u32(VAR_1);
			VAR_9->avgBitRate = gf_bs_read_u32(VAR_1);
		}
		gf_list_add(VAR_2->operating_points, VAR_9);
	}
	VAR_5 = gf_bs_read_u8(VAR_1);
	for (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {
		LHEVC_DependentLayer *VAR_13;
		GF_SAFEALLOC(VAR_13, LHEVC_DependentLayer);
		if (!VAR_13) return VAR_8;
		VAR_13->dependent_layerID = gf_bs_read_u8(VAR_1);
		VAR_13->num_layers_dependent_on = gf_bs_read_u8(VAR_1);
		for (VAR_4 = 0; VAR_4 < VAR_13->num_layers_dependent_on; VAR_4++)
			VAR_13->dependent_on_layerID[VAR_4] = gf_bs_read_u8(VAR_1);
		for (VAR_4 = 0; VAR_4 < 16; VAR_4++) {
			if (VAR_2->scalability_mask & (1 << VAR_4))
				VAR_13->dimension_identifier[VAR_4] = gf_bs_read_u8(VAR_1);
		}
		gf_list_add(VAR_2->dependency_layers, VAR_13);
	}

	return VAR_14;
}",gpac/90dc7f853d31b0a4e9441cba97feccf36d8b69a4/avc_ext.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,6 +27,8 @@
 		op->output_layer_set_idx = gf_bs_read_u16(bs);
 		op->max_temporal_id = gf_bs_read_u8(bs);
 		op->layer_count = gf_bs_read_u8(bs);
+		if (op->layer_count > ARRAY_LENGTH(op->layers_info))
+			return GF_NON_COMPLIANT_BITSTREAM;
 		for (j = 0; j < op->layer_count; j++) {
 			op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
 			op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);","{'deleted_lines': [], 'added_lines': ['\t\tif (op->layer_count > ARRAY_LENGTH(op->layers_info))', '\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;']}",True,"GPAC MP4Box version 0.7.1 and earlier contains a Buffer Overflow vulnerability in src/isomedia/avc_ext.c lines 2417 to 2420 that can result in Heap chunks being modified, this could lead to RCE. This attack appear to be exploitable via an attacker supplied MP4 file that when run by the victim may result in RCE.",7.8,HIGH,2,valid,2018-03-06T10:23:31Z,2
CVE-2018-1000100,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,"fix some exploitable overflows (#994, #997)",90dc7f853d31b0a4e9441cba97feccf36d8b69a4,https://github.com/gpac/gpac/commit/90dc7f853d31b0a4e9441cba97feccf36d8b69a4,src/media_tools/av_parsers.c,gf_media_avc_read_sps,"GF_EXPORT
s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)
{
AVC_SPS *sps;
u32 ChromaArrayType = 0;
s32 mb_width, mb_height, sps_id = -1;
u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;
u8 separate_colour_plane_flag = 0;
GF_BitStream *bs;
char *sps_data_without_emulation_bytes = NULL;
u32 sps_data_without_emulation_bytes_size = 0;
sps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));
sps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);
bs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);
if (!bs) {
sps_id = -1;
goto exit;
}
if (vui_flag_pos) *vui_flag_pos = 0;
gf_bs_read_int(bs, 8);
profile_idc = gf_bs_read_int(bs, 8);
pcomp = gf_bs_read_int(bs, 8);
if (pcomp & 0x3)
goto exit;
level_idc = gf_bs_read_int(bs, 8);
sps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
if (sps_id >=32) {
sps_id = -1;
goto exit;
}
if (sps_id < 0) {
sps_id = -1;
goto exit;
}
luma_bd = chroma_bd = 0;
chroma_format_idc = ChromaArrayType = 1;
sps = &avc->sps[sps_id];
sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
switch (profile_idc) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (pcomp & 0xE0)
goto exit;
case 83:
case 86:
case 118:
case 128:
chroma_format_idc = bs_get_ue(bs);
ChromaArrayType = chroma_format_idc;
if (chroma_format_idc == 3) {
separate_colour_plane_flag = gf_bs_read_int(bs, 1);
if (separate_colour_plane_flag) ChromaArrayType = 0;
}
luma_bd = bs_get_ue(bs);
chroma_bd = bs_get_ue(bs);
gf_bs_read_int(bs, 1);
if (gf_bs_read_int(bs, 1)) {
u32 k;
for (k=0; k<8; k++) {
if (gf_bs_read_int(bs, 1)) {
u32 z, last = 8, next = 8;
u32 sl = k<6 ? 16 : 64;
for (z=0; z<sl; z++) {
if (next) {
s32 delta = bs_get_se(bs);
next = (last + delta + 256) % 256;
}
last = next ? next : last;
}
}
}
}
break;
}
sps->profile_idc = profile_idc;
sps->level_idc = level_idc;
sps->prof_compat = pcomp;
sps->log2_max_frame_num = bs_get_ue(bs) + 4;
sps->poc_type = bs_get_ue(bs);
sps->chroma_format = chroma_format_idc;
sps->luma_bit_depth_m8 = luma_bd;
sps->chroma_bit_depth_m8 = chroma_bd;
if (sps->poc_type == 0) {
sps->log2_max_poc_lsb = bs_get_ue(bs) + 4;
} else if(sps->poc_type == 1) {
sps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);
sps->offset_for_non_ref_pic = bs_get_se(bs);
sps->offset_for_top_to_bottom_field = bs_get_se(bs);
sps->poc_cycle_length = bs_get_ue(bs);
for(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);
}
if (sps->poc_type > 2) {
sps_id = -1;
goto exit;
}
sps->max_num_ref_frames = bs_get_ue(bs); 
sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); 
mb_width = bs_get_ue(bs) + 1;
mb_height= bs_get_ue(bs) + 1;
sps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);
sps->width = mb_width * 16;
sps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;
if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 1); 
if (gf_bs_read_int(bs, 1)) { 
int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;
if (chroma_format_idc == 1) {
SubWidthC = 2, SubHeightC = 2;
} else if (chroma_format_idc == 2) {
SubWidthC = 2, SubHeightC = 1;
} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
SubWidthC = 1, SubHeightC = 1;
}
if (ChromaArrayType == 0) {
assert(SubWidthC==-1);
CropUnitX = 1;
CropUnitY = 2-sps->frame_mbs_only_flag;
} else {
CropUnitX = SubWidthC;
CropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);
}
cl = bs_get_ue(bs); 
cr = bs_get_ue(bs); 
ct = bs_get_ue(bs); 
cb = bs_get_ue(bs); 
sps->width -= CropUnitX * (cl + cr);
sps->height -= CropUnitY * (ct + cb);
cl *= CropUnitX;
cr *= CropUnitX;
ct *= CropUnitY;
cb *= CropUnitY;
} 
sps->crop.left = cl;
sps->crop.right = cr;
sps->crop.top = ct;
sps->crop.bottom = cb;
if (vui_flag_pos) {
*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);
}
sps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui_parameters_present_flag) {
sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.aspect_ratio_info_present_flag) {
s32 aspect_ratio_idc = gf_bs_read_int(bs, 8);
if (aspect_ratio_idc == 255) {
sps->vui.par_num = gf_bs_read_int(bs, 16); 
sps->vui.par_den = gf_bs_read_int(bs, 16); 
} else if (aspect_ratio_idc<14) {
sps->vui.par_num = avc_sar[aspect_ratio_idc].w;
sps->vui.par_den = avc_sar[aspect_ratio_idc].h;
}
}
sps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);
if(sps->vui.overscan_info_present_flag)
gf_bs_read_int(bs, 1);
sps->vui.video_format = 5;
sps->vui.colour_primaries = 2;
sps->vui.transfer_characteristics = 2;
sps->vui.matrix_coefficients = 2;
sps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.video_signal_type_present_flag) {
sps->vui.video_format = gf_bs_read_int(bs, 3);
sps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);
sps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.colour_description_present_flag) { 
sps->vui.colour_primaries = gf_bs_read_int(bs, 8);  
sps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  
sps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  
}
}
if (gf_bs_read_int(bs, 1)) {
bs_get_ue(bs);
bs_get_ue(bs);
}
sps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.timing_info_present_flag) {
sps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);
sps->vui.time_scale = gf_bs_read_int(bs, 32);
sps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);
}
sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
if (sps->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
sps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); 
sps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);
}
if (subseq_sps) {
if ((profile_idc==83) || (profile_idc==86)) {
u8 extended_spatial_scalability_idc;
gf_bs_read_int(bs, 1);
extended_spatial_scalability_idc = gf_bs_read_int(bs, 2);
if (ChromaArrayType == 1 || ChromaArrayType == 2) {
gf_bs_read_int(bs, 1);
}
if( ChromaArrayType  ==  1 ) {
gf_bs_read_int(bs, 2);
}
if (extended_spatial_scalability_idc == 1) {
if( ChromaArrayType > 0 ) {
gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 2);
}
bs_get_se(bs);
bs_get_se(bs);
bs_get_se(bs);
bs_get_se(bs);
}
if (gf_bs_read_int(bs, 1)) {
gf_bs_read_int(bs, 1);
}
gf_bs_read_int(bs, 1);
if (gf_bs_read_int(bs, 1)) {
u32 i, vui_ext_num_entries_minus1;
vui_ext_num_entries_minus1 = bs_get_ue(bs);
for (i=0; i <= vui_ext_num_entries_minus1; i++) {
u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
gf_bs_read_int(bs, 3);
gf_bs_read_int(bs, 4);
gf_bs_read_int(bs, 3);
vui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);
if (vui_ext_timing_info_present_flag) {
gf_bs_read_int(bs, 32);
gf_bs_read_int(bs, 32);
gf_bs_read_int(bs, 1);
}
vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
if (vui_ext_nal_hrd_parameters_present_flag) {
}
vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
if (vui_ext_vcl_hrd_parameters_present_flag) {
}
if ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {
gf_bs_read_int(bs, 1);
}
gf_bs_read_int(bs, 1);
}
}
}
else if ((profile_idc==118) || (profile_idc==128)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] MVC not supported - skipping parsing end of Subset SPS\n""));
goto exit;
}
if (gf_bs_read_int(bs, 1)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
goto exit;
}
}
exit:
gf_bs_del(bs);
gf_free(sps_data_without_emulation_bytes);
return sps_id;
}","GF_EXPORT
VAR_0 gf_media_avc_read_sps(const char *VAR_1, u32 VAR_2, AVCState *VAR_3, u32 VAR_4, u32 *VAR_5)
{
AVC_SPS *VAR_6;
u32 VAR_7 = 0;
s32 VAR_8, VAR_9, VAR_10 = -1;
u32 VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16=0, VAR_17=0, VAR_18=0, VAR_19=0, VAR_20, VAR_21;
u8 VAR_22 = 0;
GF_BitStream *VAR_23;
char *VAR_24 = NULL;
u32 VAR_25 = 0;
VAR_24 = gf_malloc(VAR_2*sizeof(char));
VAR_25 = avc_remove_emulation_bytes(VAR_1, VAR_24, VAR_2);
VAR_23 = gf_bs_new(VAR_24, VAR_25, VAR_26);
if (!VAR_23) {
VAR_10 = -1;
goto exit;
}
if (VAR_5) *VAR_5 = 0;
gf_bs_read_int(VAR_23, 8);
VAR_11 = gf_bs_read_int(VAR_23, 8);
VAR_13 = gf_bs_read_int(VAR_23, 8);
if (VAR_13 & 0x3)
goto exit;
VAR_12 = gf_bs_read_int(VAR_23, 8);
VAR_10 = bs_get_ue(VAR_23) + VAR_27 * VAR_4;
if (VAR_10 >=32) {
VAR_10 = -1;
goto exit;
}
if (VAR_10 < 0) {
VAR_10 = -1;
goto exit;
}
VAR_20 = VAR_21 = 0;
VAR_15 = VAR_7 = 1;
VAR_6 = &VAR_3->sps[VAR_10];
VAR_6->state |= VAR_4 ? VAR_28 : VAR_29;
switch (VAR_11) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (VAR_13 & 0xE0)
goto exit;
case 83:
case 86:
case 118:
case 128:
VAR_15 = bs_get_ue(VAR_23);
VAR_7 = VAR_15;
if (VAR_15 == 3) {
VAR_22 = gf_bs_read_int(VAR_23, 1);
if (VAR_22) VAR_7 = 0;
}
VAR_20 = bs_get_ue(VAR_23);
VAR_21 = bs_get_ue(VAR_23);
gf_bs_read_int(VAR_23, 1);
if (gf_bs_read_int(VAR_23, 1)) {
u32 VAR_30;
for (VAR_30=0; VAR_30<8; VAR_30++) {
if (gf_bs_read_int(VAR_23, 1)) {
u32 VAR_31, VAR_32 = 8, VAR_33 = 8;
u32 VAR_34 = VAR_30<6 ? 16 : 64;
for (VAR_31=0; VAR_31<VAR_34; VAR_31++) {
if (VAR_33) {
s32 VAR_35 = bs_get_se(VAR_23);
VAR_33 = (VAR_32 + VAR_35 + 256) % 256;
}
VAR_32 = VAR_33 ? VAR_33 : VAR_32;
}
}
}
}
break;
}
VAR_6->profile_idc = VAR_11;
VAR_6->level_idc = VAR_12;
VAR_6->prof_compat = VAR_13;
VAR_6->log2_max_frame_num = bs_get_ue(VAR_23) + 4;
VAR_6->poc_type = bs_get_ue(VAR_23);
VAR_6->chroma_format = VAR_15;
VAR_6->luma_bit_depth_m8 = VAR_20;
VAR_6->chroma_bit_depth_m8 = VAR_21;
if (VAR_6->poc_type == 0) {
VAR_6->log2_max_poc_lsb = bs_get_ue(VAR_23) + 4;
} else if(VAR_6->poc_type == 1) {
VAR_6->delta_pic_order_always_zero_flag = gf_bs_read_int(VAR_23, 1);
VAR_6->offset_for_non_ref_pic = bs_get_se(VAR_23);
VAR_6->offset_for_top_to_bottom_field = bs_get_se(VAR_23);
VAR_6->poc_cycle_length = bs_get_ue(VAR_23);
for(VAR_14=0; VAR_14<VAR_6->poc_cycle_length; VAR_14++) VAR_6->offset_for_ref_frame[VAR_14] = bs_get_se(VAR_23);
}
if (VAR_6->poc_type > 2) {
VAR_10 = -1;
goto exit;
}
VAR_6->max_num_ref_frames = bs_get_ue(VAR_23); 
VAR_6->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(VAR_23, 1); 
VAR_8 = bs_get_ue(VAR_23) + 1;
VAR_9= bs_get_ue(VAR_23) + 1;
VAR_6->frame_mbs_only_flag = gf_bs_read_int(VAR_23, 1);
VAR_6->width = VAR_8 * 16;
VAR_6->height = (2-VAR_6->frame_mbs_only_flag) * VAR_9 * 16;
if (!VAR_6->frame_mbs_only_flag) VAR_6->mb_adaptive_frame_field_flag = gf_bs_read_int(VAR_23, 1);
gf_bs_read_int(VAR_23, 1); 
if (gf_bs_read_int(VAR_23, 1)) { 
int VAR_36, VAR_37, VAR_38 = -1, VAR_39 = -1;
if (VAR_15 == 1) {
VAR_38 = 2, VAR_39 = 2;
} else if (VAR_15 == 2) {
VAR_38 = 2, VAR_39 = 1;
} else if ((VAR_15 == 3) && (VAR_22 == 0)) {
VAR_38 = 1, VAR_39 = 1;
}
if (VAR_7 == 0) {
assert(VAR_38==-1);
VAR_36 = 1;
VAR_37 = 2-VAR_6->frame_mbs_only_flag;
} else {
VAR_36 = VAR_38;
VAR_37 = VAR_39 * (2-VAR_6->frame_mbs_only_flag);
}
VAR_16 = bs_get_ue(VAR_23); 
VAR_17 = bs_get_ue(VAR_23); 
VAR_18 = bs_get_ue(VAR_23); 
VAR_19 = bs_get_ue(VAR_23); 
VAR_6->width -= VAR_36 * (VAR_16 + VAR_17);
VAR_6->height -= VAR_37 * (VAR_18 + VAR_19);
VAR_16 *= VAR_36;
VAR_17 *= VAR_36;
VAR_18 *= VAR_37;
VAR_19 *= VAR_37;
} 
VAR_6->crop.left = VAR_16;
VAR_6->crop.right = VAR_17;
VAR_6->crop.top = VAR_18;
VAR_6->crop.bottom = VAR_19;
if (VAR_5) {
*VAR_5 = (u32) gf_bs_get_bit_offset(VAR_23);
}
VAR_6->vui_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui_parameters_present_flag) {
VAR_6->vui.aspect_ratio_info_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.aspect_ratio_info_present_flag) {
s32 VAR_40 = gf_bs_read_int(VAR_23, 8);
if (VAR_40 == 255) {
VAR_6->vui.par_num = gf_bs_read_int(VAR_23, 16); 
VAR_6->vui.par_den = gf_bs_read_int(VAR_23, 16); 
} else if (VAR_40<14) {
VAR_6->vui.par_num = VAR_41[VAR_40].w;
VAR_6->vui.par_den = VAR_41[VAR_40].h;
}
}
VAR_6->vui.overscan_info_present_flag = gf_bs_read_int(VAR_23, 1);
if(VAR_6->vui.overscan_info_present_flag)
gf_bs_read_int(VAR_23, 1);
VAR_6->vui.video_format = 5;
VAR_6->vui.colour_primaries = 2;
VAR_6->vui.transfer_characteristics = 2;
VAR_6->vui.matrix_coefficients = 2;
VAR_6->vui.video_signal_type_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.video_signal_type_present_flag) {
VAR_6->vui.video_format = gf_bs_read_int(VAR_23, 3);
VAR_6->vui.video_full_range_flag = gf_bs_read_int(VAR_23, 1);
VAR_6->vui.colour_description_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.colour_description_present_flag) { 
VAR_6->vui.colour_primaries = gf_bs_read_int(VAR_23, 8);  
VAR_6->vui.transfer_characteristics = gf_bs_read_int(VAR_23, 8);  
VAR_6->vui.matrix_coefficients = gf_bs_read_int(VAR_23, 8);  
}
}
if (gf_bs_read_int(VAR_23, 1)) {
bs_get_ue(VAR_23);
bs_get_ue(VAR_23);
}
VAR_6->vui.timing_info_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.timing_info_present_flag) {
VAR_6->vui.num_units_in_tick = gf_bs_read_int(VAR_23, 32);
VAR_6->vui.time_scale = gf_bs_read_int(VAR_23, 32);
VAR_6->vui.fixed_frame_rate_flag = gf_bs_read_int(VAR_23, 1);
}
VAR_6->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_23, &VAR_6->vui.hrd);
VAR_6->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
if (VAR_6->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_23, &VAR_6->vui.hrd);
if (VAR_6->vui.nal_hrd_parameters_present_flag || VAR_6->vui.vcl_hrd_parameters_present_flag)
VAR_6->vui.low_delay_hrd_flag = gf_bs_read_int(VAR_23, 1); 
VAR_6->vui.pic_struct_present_flag = gf_bs_read_int(VAR_23, 1);
}
if (VAR_4) {
if ((VAR_11==83) || (VAR_11==86)) {
u8 VAR_42;
gf_bs_read_int(VAR_23, 1);
VAR_42 = gf_bs_read_int(VAR_23, 2);
if (VAR_7 == 1 || VAR_7 == 2) {
gf_bs_read_int(VAR_23, 1);
}
if( VAR_7  ==  1 ) {
gf_bs_read_int(VAR_23, 2);
}
if (VAR_42 == 1) {
if( VAR_7 > 0 ) {
gf_bs_read_int(VAR_23, 1);
gf_bs_read_int(VAR_23, 2);
}
bs_get_se(VAR_23);
bs_get_se(VAR_23);
bs_get_se(VAR_23);
bs_get_se(VAR_23);
}
if (gf_bs_read_int(VAR_23, 1)) {
gf_bs_read_int(VAR_23, 1);
}
gf_bs_read_int(VAR_23, 1);
if (gf_bs_read_int(VAR_23, 1)) {
u32 VAR_14, VAR_43;
VAR_43 = bs_get_ue(VAR_23);
for (VAR_14=0; VAR_14 <= VAR_43; VAR_14++) {
u8 VAR_44, VAR_45, VAR_46;
gf_bs_read_int(VAR_23, 3);
gf_bs_read_int(VAR_23, 4);
gf_bs_read_int(VAR_23, 3);
VAR_46 = gf_bs_read_int(VAR_23, 1);
if (VAR_46) {
gf_bs_read_int(VAR_23, 32);
gf_bs_read_int(VAR_23, 32);
gf_bs_read_int(VAR_23, 1);
}
VAR_44 = gf_bs_read_int(VAR_23, 1);
if (VAR_44) {
}
VAR_45 = gf_bs_read_int(VAR_23, 1);
if (VAR_45) {
}
if ( VAR_44 ||  VAR_45) {
gf_bs_read_int(VAR_23, 1);
}
gf_bs_read_int(VAR_23, 1);
}
}
}
else if ((VAR_11==118) || (VAR_11==128)) {
GF_LOG(VAR_47, VAR_48, (""[avc-h264] MVC not supported - skipping parsing end of Subset SPS\n""));
goto exit;
}
if (gf_bs_read_int(VAR_23, 1)) {
GF_LOG(VAR_47, VAR_48, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
goto exit;
}
}
exit:
gf_bs_del(VAR_23);
gf_free(VAR_24);
return VAR_10;
}",,"GF_EXPORT
s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)
{
	AVC_SPS *sps;
	u32 ChromaArrayType = 0;
	s32 mb_width, mb_height, sps_id = -1;
	u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;
	u8 separate_colour_plane_flag = 0;
	GF_BitStream *bs;
	char *sps_data_without_emulation_bytes = NULL;
	u32 sps_data_without_emulation_bytes_size = 0;

	/*SPS still contains emulation bytes*/
	sps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));
	sps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);
	bs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);
	if (!bs) {
		sps_id = -1;
		goto exit;
	}
	if (vui_flag_pos) *vui_flag_pos = 0;

	/*nal hdr*/ gf_bs_read_int(bs, 8);

	profile_idc = gf_bs_read_int(bs, 8);

	pcomp = gf_bs_read_int(bs, 8);
	/*sanity checks*/
	if (pcomp & 0x3)
		goto exit;

	level_idc = gf_bs_read_int(bs, 8);

	/*SubsetSps is used to be sure that AVC SPS are not going to be scratched
	by subset SPS. According to the SVC standard, subset SPS can have the same sps_id
	than its base layer, but it does not refer to the same SPS. */
	sps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
	if (sps_id >=32) {
		sps_id = -1;
		goto exit;
	}
	if (sps_id < 0) {
		sps_id = -1;
		goto exit;
	}

	luma_bd = chroma_bd = 0;
	chroma_format_idc = ChromaArrayType = 1;
	sps = &avc->sps[sps_id];
	sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;

	/*High Profile and SVC*/
	switch (profile_idc) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/
		if (pcomp & 0xE0)
			goto exit;
	case 83:
	case 86:
	case 118:
	case 128:
		chroma_format_idc = bs_get_ue(bs);
		ChromaArrayType = chroma_format_idc;
		if (chroma_format_idc == 3) {
			separate_colour_plane_flag = gf_bs_read_int(bs, 1);
			/*
			Depending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.
			\96	If separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.
			\96	Otherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.
			*/
			if (separate_colour_plane_flag) ChromaArrayType = 0;
		}
		luma_bd = bs_get_ue(bs);
		chroma_bd = bs_get_ue(bs);
		/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int(bs, 1);
		/*seq_scaling_matrix_present_flag*/
		if (gf_bs_read_int(bs, 1)) {
			u32 k;
			for (k=0; k<8; k++) {
				if (gf_bs_read_int(bs, 1)) {
					u32 z, last = 8, next = 8;
					u32 sl = k<6 ? 16 : 64;
					for (z=0; z<sl; z++) {
						if (next) {
							s32 delta = bs_get_se(bs);
							next = (last + delta + 256) % 256;
						}
						last = next ? next : last;
					}
				}
			}
		}
		break;
	}

	sps->profile_idc = profile_idc;
	sps->level_idc = level_idc;
	sps->prof_compat = pcomp;
	sps->log2_max_frame_num = bs_get_ue(bs) + 4;
	sps->poc_type = bs_get_ue(bs);
	sps->chroma_format = chroma_format_idc;
	sps->luma_bit_depth_m8 = luma_bd;
	sps->chroma_bit_depth_m8 = chroma_bd;

	if (sps->poc_type == 0) {
		sps->log2_max_poc_lsb = bs_get_ue(bs) + 4;
	} else if(sps->poc_type == 1) {
		sps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);
		sps->offset_for_non_ref_pic = bs_get_se(bs);
		sps->offset_for_top_to_bottom_field = bs_get_se(bs);
		sps->poc_cycle_length = bs_get_ue(bs);
		if (sps->poc_cycle_length > ARRAY_LENGTH(sps->offset_for_ref_frame)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			goto exit;
		}
		for(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);
	}
	if (sps->poc_type > 2) {
		sps_id = -1;
		goto exit;
	}
	sps->max_num_ref_frames = bs_get_ue(bs); 
	sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); 
	mb_width = bs_get_ue(bs) + 1;
	mb_height= bs_get_ue(bs) + 1;

	sps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);

	sps->width = mb_width * 16;
	sps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;
	
	if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);
	gf_bs_read_int(bs, 1); /*direct_8x8_inference_flag*/
	
	if (gf_bs_read_int(bs, 1)) { /*crop*/
		int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;

		if (chroma_format_idc == 1) {
			SubWidthC = 2, SubHeightC = 2;
		} else if (chroma_format_idc == 2) {
			SubWidthC = 2, SubHeightC = 1;
		} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
			SubWidthC = 1, SubHeightC = 1;
		}

		if (ChromaArrayType == 0) {
			assert(SubWidthC==-1);
			CropUnitX = 1;
			CropUnitY = 2-sps->frame_mbs_only_flag;
		} else {
			CropUnitX = SubWidthC;
			CropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);
		}

		cl = bs_get_ue(bs); /*crop_left*/
		cr = bs_get_ue(bs); /*crop_right*/
		ct = bs_get_ue(bs); /*crop_top*/
		cb = bs_get_ue(bs); /*crop_bottom*/

		sps->width -= CropUnitX * (cl + cr);
		sps->height -= CropUnitY * (ct + cb);
		cl *= CropUnitX;
		cr *= CropUnitX;
		ct *= CropUnitY;
		cb *= CropUnitY;
	} 
	sps->crop.left = cl;
	sps->crop.right = cr;
	sps->crop.top = ct;
	sps->crop.bottom = cb;

	if (vui_flag_pos) {
		*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);
	}
	/*vui_parameters_present_flag*/
	sps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);
	if (sps->vui_parameters_present_flag) {
		sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);
		if (sps->vui.aspect_ratio_info_present_flag) {
			s32 aspect_ratio_idc = gf_bs_read_int(bs, 8);
			if (aspect_ratio_idc == 255) {
				sps->vui.par_num = gf_bs_read_int(bs, 16); /*AR num*/
				sps->vui.par_den = gf_bs_read_int(bs, 16); /*AR den*/
			} else if (aspect_ratio_idc<14) {
				sps->vui.par_num = avc_sar[aspect_ratio_idc].w;
				sps->vui.par_den = avc_sar[aspect_ratio_idc].h;
			}
		}
		sps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);
		if(sps->vui.overscan_info_present_flag)		
			gf_bs_read_int(bs, 1);		/* overscan_appropriate_flag */

		/* default values */
		sps->vui.video_format = 5;
		sps->vui.colour_primaries = 2;
		sps->vui.transfer_characteristics = 2;
		sps->vui.matrix_coefficients = 2;
		/* now read values if possible */
		sps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);
		if (sps->vui.video_signal_type_present_flag) {
			sps->vui.video_format = gf_bs_read_int(bs, 3);
			sps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);
			sps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);
			if (sps->vui.colour_description_present_flag) { 
				sps->vui.colour_primaries = gf_bs_read_int(bs, 8);  
				sps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  
				sps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  
			}
		}

		if (gf_bs_read_int(bs, 1)) {	/* chroma_location_info_present_flag */
			bs_get_ue(bs);				/* chroma_sample_location_type_top_field */
			bs_get_ue(bs);				/* chroma_sample_location_type_bottom_field */
		}

		sps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);
		if (sps->vui.timing_info_present_flag) {
			sps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);
			sps->vui.time_scale = gf_bs_read_int(bs, 32);
			sps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);
		}

		sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
		if (sps->vui.nal_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(bs, &sps->vui.hrd);

		sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
		if (sps->vui.vcl_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(bs, &sps->vui.hrd);

		if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
			sps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); 

		sps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);
	}
	/*end of seq_parameter_set_data*/

	if (subseq_sps) {
		if ((profile_idc==83) || (profile_idc==86)) {
			u8 extended_spatial_scalability_idc;
			/*parsing seq_parameter_set_svc_extension*/

			/*inter_layer_deblocking_filter_control_present_flag=*/	gf_bs_read_int(bs, 1);
			extended_spatial_scalability_idc = gf_bs_read_int(bs, 2);
			if (ChromaArrayType == 1 || ChromaArrayType == 2) {
				/*chroma_phase_x_plus1_flag*/ gf_bs_read_int(bs, 1);
			}
			if( ChromaArrayType  ==  1 ) {
				/*chroma_phase_y_plus1*/ gf_bs_read_int(bs, 2);
			}
			if (extended_spatial_scalability_idc == 1) {
				if( ChromaArrayType > 0 ) {
					/*seq_ref_layer_chroma_phase_x_plus1_flag*/gf_bs_read_int(bs, 1);
					/*seq_ref_layer_chroma_phase_y_plus1*/gf_bs_read_int(bs, 2);
				}
				/*seq_scaled_ref_layer_left_offset*/ bs_get_se(bs);
				/*seq_scaled_ref_layer_top_offset*/bs_get_se(bs);
				/*seq_scaled_ref_layer_right_offset*/bs_get_se(bs);
				/*seq_scaled_ref_layer_bottom_offset*/bs_get_se(bs);
			}
			if (/*seq_tcoeff_level_prediction_flag*/gf_bs_read_int(bs, 1)) {
				/*adaptive_tcoeff_level_prediction_flag*/ gf_bs_read_int(bs, 1);
			}
			/*slice_header_restriction_flag*/gf_bs_read_int(bs, 1);

			/*svc_vui_parameters_present*/
			if (gf_bs_read_int(bs, 1)) {
				u32 i, vui_ext_num_entries_minus1;
				vui_ext_num_entries_minus1 = bs_get_ue(bs);

				for (i=0; i <= vui_ext_num_entries_minus1; i++) {
					u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
					/*u8 vui_ext_dependency_id =*/ gf_bs_read_int(bs, 3);
					/*u8 vui_ext_quality_id =*/ gf_bs_read_int(bs, 4);
					/*u8 vui_ext_temporal_id =*/ gf_bs_read_int(bs, 3);
					vui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);
					if (vui_ext_timing_info_present_flag) {
						/*u32 vui_ext_num_units_in_tick = */gf_bs_read_int(bs, 32);
						/*u32 vui_ext_time_scale = */gf_bs_read_int(bs, 32);
						/*u8 vui_ext_fixed_frame_rate_flag = */gf_bs_read_int(bs, 1);
					}
					vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
					if (vui_ext_nal_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);
					if (vui_ext_vcl_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					if ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {
						/*vui_ext_low_delay_hrd_flag*/gf_bs_read_int(bs, 1);
					}
					/*vui_ext_pic_struct_present_flag*/gf_bs_read_int(bs, 1);
				}
			}
		}
		else if ((profile_idc==118) || (profile_idc==128)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] MVC not supported - skipping parsing end of Subset SPS\n""));
			goto exit;
		}

		if (gf_bs_read_int(bs, 1)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			goto exit;
		}
	}

exit:
	gf_bs_del(bs);
	gf_free(sps_data_without_emulation_bytes);
	return sps_id;
}","GF_EXPORT
VAR_0 gf_media_avc_read_sps(const char *VAR_1, u32 VAR_2, AVCState *VAR_3, u32 VAR_4, u32 *VAR_5)
{
	AVC_SPS *VAR_6;
	u32 VAR_7 = 0;
	s32 VAR_8, VAR_9, VAR_10 = -1;
	u32 VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16=0, VAR_17=0, VAR_18=0, VAR_19=0, VAR_20, VAR_21;
	u8 VAR_22 = 0;
	GF_BitStream *VAR_23;
	char *VAR_24 = NULL;
	u32 VAR_25 = 0;

	/* COMMENT_0 */
	VAR_24 = gf_malloc(VAR_2*sizeof(char));
	VAR_25 = avc_remove_emulation_bytes(VAR_1, VAR_24, VAR_2);
	VAR_23 = gf_bs_new(VAR_24, VAR_25, VAR_26);
	if (!VAR_23) {
		VAR_10 = -1;
		goto exit;
	}
	if (VAR_5) *VAR_5 = 0;

	/* COMMENT_1 */ gf_bs_read_int(VAR_23, 8);

	VAR_11 = gf_bs_read_int(VAR_23, 8);

	VAR_13 = gf_bs_read_int(VAR_23, 8);
	/* COMMENT_2 */
	if (VAR_13 & 0x3)
		goto exit;

	VAR_12 = gf_bs_read_int(VAR_23, 8);

	/* COMMENT_3 */
                                                                                  
                                                               
	VAR_10 = bs_get_ue(VAR_23) + VAR_27 * VAR_4;
	if (VAR_10 >=32) {
		VAR_10 = -1;
		goto exit;
	}
	if (VAR_10 < 0) {
		VAR_10 = -1;
		goto exit;
	}

	VAR_20 = VAR_21 = 0;
	VAR_15 = VAR_7 = 1;
	VAR_6 = &VAR_3->sps[VAR_10];
	VAR_6->state |= VAR_4 ? VAR_28 : VAR_29;

	/* COMMENT_6 */
	switch (VAR_11) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/* COMMENT_7 */
		if (VAR_13 & 0xE0)
			goto exit;
	case 83:
	case 86:
	case 118:
	case 128:
		VAR_15 = bs_get_ue(VAR_23);
		VAR_7 = VAR_15;
		if (VAR_15 == 3) {
			VAR_22 = gf_bs_read_int(VAR_23, 1);
			/* COMMENT_8 */
                                                                                                                          
                                                                                                      
                                                                                               
     
			if (VAR_22) VAR_7 = 0;
		}
		VAR_20 = bs_get_ue(VAR_23);
		VAR_21 = bs_get_ue(VAR_23);
		/* COMMENT_13 */ gf_bs_read_int(VAR_23, 1);
		/* COMMENT_14 */
		if (gf_bs_read_int(VAR_23, 1)) {
			u32 VAR_30;
			for (VAR_30=0; VAR_30<8; VAR_30++) {
				if (gf_bs_read_int(VAR_23, 1)) {
					u32 VAR_31, VAR_32 = 8, VAR_33 = 8;
					u32 VAR_34 = VAR_30<6 ? 16 : 64;
					for (VAR_31=0; VAR_31<VAR_34; VAR_31++) {
						if (VAR_33) {
							s32 VAR_35 = bs_get_se(VAR_23);
							VAR_33 = (VAR_32 + VAR_35 + 256) % 256;
						}
						VAR_32 = VAR_33 ? VAR_33 : VAR_32;
					}
				}
			}
		}
		break;
	}

	VAR_6->profile_idc = VAR_11;
	VAR_6->level_idc = VAR_12;
	VAR_6->prof_compat = VAR_13;
	VAR_6->log2_max_frame_num = bs_get_ue(VAR_23) + 4;
	VAR_6->poc_type = bs_get_ue(VAR_23);
	VAR_6->chroma_format = VAR_15;
	VAR_6->luma_bit_depth_m8 = VAR_20;
	VAR_6->chroma_bit_depth_m8 = VAR_21;

	if (VAR_6->poc_type == 0) {
		VAR_6->log2_max_poc_lsb = bs_get_ue(VAR_23) + 4;
	} else if(VAR_6->poc_type == 1) {
		VAR_6->delta_pic_order_always_zero_flag = gf_bs_read_int(VAR_23, 1);
		VAR_6->offset_for_non_ref_pic = bs_get_se(VAR_23);
		VAR_6->offset_for_top_to_bottom_field = bs_get_se(VAR_23);
		VAR_6->poc_cycle_length = bs_get_ue(VAR_23);
		if (VAR_6->poc_cycle_length > ARRAY_LENGTH(VAR_6->offset_for_ref_frame)) {
			GF_LOG(VAR_36, VAR_37, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			goto exit;
		}
		for(VAR_14=0; VAR_14<VAR_6->poc_cycle_length; VAR_14++) VAR_6->offset_for_ref_frame[VAR_14] = bs_get_se(VAR_23);
	}
	if (VAR_6->poc_type > 2) {
		VAR_10 = -1;
		goto exit;
	}
	VAR_6->max_num_ref_frames = bs_get_ue(VAR_23); 
	VAR_6->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(VAR_23, 1); 
	VAR_8 = bs_get_ue(VAR_23) + 1;
	VAR_9= bs_get_ue(VAR_23) + 1;

	VAR_6->frame_mbs_only_flag = gf_bs_read_int(VAR_23, 1);

	VAR_6->width = VAR_8 * 16;
	VAR_6->height = (2-VAR_6->frame_mbs_only_flag) * VAR_9 * 16;
	
	if (!VAR_6->frame_mbs_only_flag) VAR_6->mb_adaptive_frame_field_flag = gf_bs_read_int(VAR_23, 1);
	gf_bs_read_int(VAR_23, 1); /* COMMENT_15 */
	
	if (gf_bs_read_int(VAR_23, 1)) { /* COMMENT_16 */
		int VAR_38, VAR_39, VAR_40 = -1, VAR_41 = -1;

		if (VAR_15 == 1) {
			VAR_40 = 2, VAR_41 = 2;
		} else if (VAR_15 == 2) {
			VAR_40 = 2, VAR_41 = 1;
		} else if ((VAR_15 == 3) && (VAR_22 == 0)) {
			VAR_40 = 1, VAR_41 = 1;
		}

		if (VAR_7 == 0) {
			assert(VAR_40==-1);
			VAR_38 = 1;
			VAR_39 = 2-VAR_6->frame_mbs_only_flag;
		} else {
			VAR_38 = VAR_40;
			VAR_39 = VAR_41 * (2-VAR_6->frame_mbs_only_flag);
		}

		VAR_16 = bs_get_ue(VAR_23); /* COMMENT_17 */
		VAR_17 = bs_get_ue(VAR_23); /* COMMENT_18 */
		VAR_18 = bs_get_ue(VAR_23); /* COMMENT_19 */
		VAR_19 = bs_get_ue(VAR_23); /* COMMENT_20 */

		VAR_6->width -= VAR_38 * (VAR_16 + VAR_17);
		VAR_6->height -= VAR_39 * (VAR_18 + VAR_19);
		VAR_16 *= VAR_38;
		VAR_17 *= VAR_38;
		VAR_18 *= VAR_39;
		VAR_19 *= VAR_39;
	} 
	VAR_6->crop.left = VAR_16;
	VAR_6->crop.right = VAR_17;
	VAR_6->crop.top = VAR_18;
	VAR_6->crop.bottom = VAR_19;

	if (VAR_5) {
		*VAR_5 = (u32) gf_bs_get_bit_offset(VAR_23);
	}
	/* COMMENT_21 */
	VAR_6->vui_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
	if (VAR_6->vui_parameters_present_flag) {
		VAR_6->vui.aspect_ratio_info_present_flag = gf_bs_read_int(VAR_23, 1);
		if (VAR_6->vui.aspect_ratio_info_present_flag) {
			s32 VAR_42 = gf_bs_read_int(VAR_23, 8);
			if (VAR_42 == 255) {
				VAR_6->vui.par_num = gf_bs_read_int(VAR_23, 16); /* COMMENT_22 */
				VAR_6->vui.par_den = gf_bs_read_int(VAR_23, 16); /* COMMENT_23 */
			} else if (VAR_42<14) {
				VAR_6->vui.par_num = VAR_43[VAR_42].w;
				VAR_6->vui.par_den = VAR_43[VAR_42].h;
			}
		}
		VAR_6->vui.overscan_info_present_flag = gf_bs_read_int(VAR_23, 1);
		if(VAR_6->vui.overscan_info_present_flag)		
			gf_bs_read_int(VAR_23, 1);		/* COMMENT_24 */

		/* COMMENT_25 */
		VAR_6->vui.video_format = 5;
		VAR_6->vui.colour_primaries = 2;
		VAR_6->vui.transfer_characteristics = 2;
		VAR_6->vui.matrix_coefficients = 2;
		/* COMMENT_26 */
		VAR_6->vui.video_signal_type_present_flag = gf_bs_read_int(VAR_23, 1);
		if (VAR_6->vui.video_signal_type_present_flag) {
			VAR_6->vui.video_format = gf_bs_read_int(VAR_23, 3);
			VAR_6->vui.video_full_range_flag = gf_bs_read_int(VAR_23, 1);
			VAR_6->vui.colour_description_present_flag = gf_bs_read_int(VAR_23, 1);
			if (VAR_6->vui.colour_description_present_flag) { 
				VAR_6->vui.colour_primaries = gf_bs_read_int(VAR_23, 8);  
				VAR_6->vui.transfer_characteristics = gf_bs_read_int(VAR_23, 8);  
				VAR_6->vui.matrix_coefficients = gf_bs_read_int(VAR_23, 8);  
			}
		}

		if (gf_bs_read_int(VAR_23, 1)) {	/* COMMENT_27 */
			bs_get_ue(VAR_23);				/* COMMENT_28 */
			bs_get_ue(VAR_23);				/* COMMENT_29 */
		}

		VAR_6->vui.timing_info_present_flag = gf_bs_read_int(VAR_23, 1);
		if (VAR_6->vui.timing_info_present_flag) {
			VAR_6->vui.num_units_in_tick = gf_bs_read_int(VAR_23, 32);
			VAR_6->vui.time_scale = gf_bs_read_int(VAR_23, 32);
			VAR_6->vui.fixed_frame_rate_flag = gf_bs_read_int(VAR_23, 1);
		}

		VAR_6->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
		if (VAR_6->vui.nal_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(VAR_23, &VAR_6->vui.hrd);

		VAR_6->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(VAR_23, 1);
		if (VAR_6->vui.vcl_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(VAR_23, &VAR_6->vui.hrd);

		if (VAR_6->vui.nal_hrd_parameters_present_flag || VAR_6->vui.vcl_hrd_parameters_present_flag)
			VAR_6->vui.low_delay_hrd_flag = gf_bs_read_int(VAR_23, 1); 

		VAR_6->vui.pic_struct_present_flag = gf_bs_read_int(VAR_23, 1);
	}
	/* COMMENT_30 */

	if (VAR_4) {
		if ((VAR_11==83) || (VAR_11==86)) {
			u8 VAR_44;
			/* COMMENT_31 */

			/* COMMENT_32 */	gf_bs_read_int(VAR_23, 1);
			VAR_44 = gf_bs_read_int(VAR_23, 2);
			if (VAR_7 == 1 || VAR_7 == 2) {
				/* COMMENT_33 */ gf_bs_read_int(VAR_23, 1);
			}
			if( VAR_7  ==  1 ) {
				/* COMMENT_34 */ gf_bs_read_int(VAR_23, 2);
			}
			if (VAR_44 == 1) {
				if( VAR_7 > 0 ) {
					/* COMMENT_35 */gf_bs_read_int(VAR_23, 1);
					/* COMMENT_36 */gf_bs_read_int(VAR_23, 2);
				}
				/* COMMENT_37 */ bs_get_se(VAR_23);
				/* COMMENT_38 */bs_get_se(VAR_23);
				/* COMMENT_39 */bs_get_se(VAR_23);
				/* COMMENT_40 */bs_get_se(VAR_23);
			}
			if (/* COMMENT_41 */gf_bs_read_int(VAR_23, 1)) {
				/* COMMENT_42 */ gf_bs_read_int(VAR_23, 1);
			}
			/* COMMENT_43 */gf_bs_read_int(VAR_23, 1);

			/* COMMENT_44 */
			if (gf_bs_read_int(VAR_23, 1)) {
				u32 VAR_14, VAR_45;
				VAR_45 = bs_get_ue(VAR_23);

				for (VAR_14=0; VAR_14 <= VAR_45; VAR_14++) {
					u8 VAR_46, VAR_47, VAR_48;
					/* COMMENT_45 */ gf_bs_read_int(VAR_23, 3);
					/* COMMENT_46 */ gf_bs_read_int(VAR_23, 4);
					/* COMMENT_47 */ gf_bs_read_int(VAR_23, 3);
					VAR_48 = gf_bs_read_int(VAR_23, 1);
					if (VAR_48) {
						/* COMMENT_48 */gf_bs_read_int(VAR_23, 32);
						/* COMMENT_49 */gf_bs_read_int(VAR_23, 32);
						/* COMMENT_50 */gf_bs_read_int(VAR_23, 1);
					}
					VAR_46 = gf_bs_read_int(VAR_23, 1);
					if (VAR_46) {
						/* COMMENT_51 */
					}
					VAR_47 = gf_bs_read_int(VAR_23, 1);
					if (VAR_47) {
						/* COMMENT_51 */
					}
					if ( VAR_46 ||  VAR_47) {
						/* COMMENT_52 */gf_bs_read_int(VAR_23, 1);
					}
					/* COMMENT_53 */gf_bs_read_int(VAR_23, 1);
				}
			}
		}
		else if ((VAR_11==118) || (VAR_11==128)) {
			GF_LOG(VAR_49, VAR_37, (""[avc-h264] MVC not supported - skipping parsing end of Subset SPS\n""));
			goto exit;
		}

		if (gf_bs_read_int(VAR_23, 1)) {
			GF_LOG(VAR_49, VAR_37, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			goto exit;
		}
	}

exit:
	gf_bs_del(VAR_23);
	gf_free(VAR_24);
	return VAR_10;
}",,"--- func_before
+++ func_after
@@ -113,6 +113,10 @@
 		sps->offset_for_non_ref_pic = bs_get_se(bs);
 		sps->offset_for_top_to_bottom_field = bs_get_se(bs);
 		sps->poc_cycle_length = bs_get_ue(bs);
+		if (sps->poc_cycle_length > ARRAY_LENGTH(sps->offset_for_ref_frame)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
+			goto exit;
+		}
 		for(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);
 	}
 	if (sps->poc_type > 2) {","{'deleted_lines': [], 'added_lines': ['\t\tif (sps->poc_cycle_length > ARRAY_LENGTH(sps->offset_for_ref_frame)) {', '\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n""));', '\t\t\tgoto exit;', '\t\t}']}",True,"GPAC MP4Box version 0.7.1 and earlier contains a Buffer Overflow vulnerability in src/isomedia/avc_ext.c lines 2417 to 2420 that can result in Heap chunks being modified, this could lead to RCE. This attack appear to be exploitable via an attacker supplied MP4 file that when run by the victim may result in RCE.",7.8,HIGH,2,valid,2018-03-06T10:23:31Z,2
CVE-2018-15853,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,xkbcommon/libxkbcommon,"xkbcomp: fix stack overflow when evaluating boolean negation

The expression evaluator would go into an infinite recursion when
evaluating something like this as a boolean: `!True`. Instead of
recursing to just `True` and negating, it recursed to `!True` itself
again.

Bug inherited from xkbcomp.

Caught with the afl fuzzer.

Signed-off-by: Ran Benita <ran234@gmail.com>",1f9d1248c07cda8aaff762429c0dce146de8632a,https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a,src/xkbcomp/expr.c,ExprResolveBoolean,"bool
ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
bool *set_rtrn)
{
bool ok = false;
const char *ident;
switch (expr->expr.op) {
case EXPR_VALUE:
if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {
log_err(ctx,
""Found constant of type %s where boolean was expected\n"",
expr_value_type_to_string(expr->expr.value_type));
return false;
}
*set_rtrn = expr->boolean.set;
return true;
case EXPR_IDENT:
ident = xkb_atom_text(ctx, expr->ident.ident);
if (ident) {
if (istreq(ident, ""true"") ||
istreq(ident, ""yes"") ||
istreq(ident, ""on"")) {
*set_rtrn = true;
return true;
}
else if (istreq(ident, ""false"") ||
istreq(ident, ""no"") ||
istreq(ident, ""off"")) {
*set_rtrn = false;
return true;
}
}
log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident);
return false;
case EXPR_FIELD_REF:
log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"",
xkb_atom_text(ctx, expr->field_ref.element),
xkb_atom_text(ctx, expr->field_ref.field));
return false;
case EXPR_INVERT:
case EXPR_NOT:
ok = ExprResolveBoolean(ctx, expr, set_rtrn);
if (ok)
*set_rtrn = !*set_rtrn;
return ok;
case EXPR_ADD:
case EXPR_SUBTRACT:
case EXPR_MULTIPLY:
case EXPR_DIVIDE:
case EXPR_ASSIGN:
case EXPR_NEGATE:
case EXPR_UNARY_PLUS:
log_err(ctx, ""%s of boolean values not permitted\n"",
expr_op_type_to_string(expr->expr.op));
break;
default:
log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"",
expr->expr.op);
break;
}
return false;
}","bool
ExprResolveBoolean(struct xkb_context *VAR_0, const ExprDef *VAR_1,
bool *VAR_2)
{
bool VAR_3 = false;
const char *VAR_4;
switch (VAR_1->expr.op) {
case VAR_5:
if (VAR_1->expr.value_type != VAR_6) {
log_err(VAR_0,
""Found constant of type %s where boolean was expected\n"",
expr_value_type_to_string(VAR_1->expr.value_type));
return false;
}
*VAR_2 = VAR_1->boolean.set;
return true;
case VAR_7:
VAR_4 = xkb_atom_text(VAR_0, VAR_1->ident.ident);
if (VAR_4) {
if (istreq(VAR_4, ""true"") ||
istreq(VAR_4, ""yes"") ||
istreq(VAR_4, ""on"")) {
*VAR_2 = true;
return true;
}
else if (istreq(VAR_4, ""false"") ||
istreq(VAR_4, ""no"") ||
istreq(VAR_4, ""off"")) {
*VAR_2 = false;
return true;
}
}
log_err(VAR_0, ""Identifier \""%s\"" of type boolean is unknown\n"", VAR_4);
return false;
case VAR_8:
log_err(VAR_0, ""Default \""%s.%s\"" of type boolean is unknown\n"",
xkb_atom_text(VAR_0, VAR_1->field_ref.element),
xkb_atom_text(VAR_0, VAR_1->field_ref.field));
return false;
case VAR_9:
case VAR_10:
VAR_3 = ExprResolveBoolean(VAR_0, VAR_1, VAR_2);
if (VAR_3)
*VAR_2 = !*VAR_2;
return VAR_3;
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
log_err(VAR_0, ""%s of boolean values not permitted\n"",
expr_op_type_to_string(VAR_1->expr.op));
break;
default:
log_wsgo(VAR_0, ""Unknown operator %d in ResolveBoolean\n"",
VAR_1->expr.op);
break;
}
return false;
}",xkbcommon/libxkbcommon/1f9d1248c07cda8aaff762429c0dce146de8632a/expr.c/vul/before/0.json,"bool
ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
                   bool *set_rtrn)
{
    bool ok = false;
    const char *ident;

    switch (expr->expr.op) {
    case EXPR_VALUE:
        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {
            log_err(ctx,
                    ""Found constant of type %s where boolean was expected\n"",
                    expr_value_type_to_string(expr->expr.value_type));
            return false;
        }
        *set_rtrn = expr->boolean.set;
        return true;

    case EXPR_IDENT:
        ident = xkb_atom_text(ctx, expr->ident.ident);
        if (ident) {
            if (istreq(ident, ""true"") ||
                istreq(ident, ""yes"") ||
                istreq(ident, ""on"")) {
                *set_rtrn = true;
                return true;
            }
            else if (istreq(ident, ""false"") ||
                     istreq(ident, ""no"") ||
                     istreq(ident, ""off"")) {
                *set_rtrn = false;
                return true;
            }
        }
        log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident);
        return false;

    case EXPR_FIELD_REF:
        log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"",
                xkb_atom_text(ctx, expr->field_ref.element),
                xkb_atom_text(ctx, expr->field_ref.field));
        return false;

    case EXPR_INVERT:
    case EXPR_NOT:
        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
        if (ok)
            *set_rtrn = !*set_rtrn;
        return ok;
    case EXPR_ADD:
    case EXPR_SUBTRACT:
    case EXPR_MULTIPLY:
    case EXPR_DIVIDE:
    case EXPR_ASSIGN:
    case EXPR_NEGATE:
    case EXPR_UNARY_PLUS:
        log_err(ctx, ""%s of boolean values not permitted\n"",
                expr_op_type_to_string(expr->expr.op));
        break;

    default:
        log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"",
                 expr->expr.op);
        break;
    }

    return false;
}","bool
ExprResolveBoolean(struct xkb_context *VAR_0, const ExprDef *VAR_1,
                   bool *VAR_2)
{
    bool VAR_3 = false;
    const char *VAR_4;

    switch (VAR_1->expr.op) {
    case VAR_5:
        if (VAR_1->expr.value_type != VAR_6) {
            log_err(VAR_0,
                    ""Found constant of type %s where boolean was expected\n"",
                    expr_value_type_to_string(VAR_1->expr.value_type));
            return false;
        }
        *VAR_2 = VAR_1->boolean.set;
        return true;

    case VAR_7:
        VAR_4 = xkb_atom_text(VAR_0, VAR_1->ident.ident);
        if (VAR_4) {
            if (istreq(VAR_4, ""true"") ||
                istreq(VAR_4, ""yes"") ||
                istreq(VAR_4, ""on"")) {
                *VAR_2 = true;
                return true;
            }
            else if (istreq(VAR_4, ""false"") ||
                     istreq(VAR_4, ""no"") ||
                     istreq(VAR_4, ""off"")) {
                *VAR_2 = false;
                return true;
            }
        }
        log_err(VAR_0, ""Identifier \""%s\"" of type boolean is unknown\n"", VAR_4);
        return false;

    case VAR_8:
        log_err(VAR_0, ""Default \""%s.%s\"" of type boolean is unknown\n"",
                xkb_atom_text(VAR_0, VAR_1->field_ref.element),
                xkb_atom_text(VAR_0, VAR_1->field_ref.field));
        return false;

    case VAR_9:
    case VAR_10:
        VAR_3 = ExprResolveBoolean(VAR_0, VAR_1->unary.child, VAR_2);
        if (VAR_3)
            *VAR_2 = !*VAR_2;
        return VAR_3;
    case VAR_11:
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_16:
    case VAR_17:
        log_err(VAR_0, ""%s of boolean values not permitted\n"",
                expr_op_type_to_string(VAR_1->expr.op));
        break;

    default:
        log_wsgo(VAR_0, ""Unknown operator %d in ResolveBoolean\n"",
                 VAR_1->expr.op);
        break;
    }

    return false;
}",xkbcommon/libxkbcommon/1f9d1248c07cda8aaff762429c0dce146de8632a/expr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,7 +43,7 @@
 
     case EXPR_INVERT:
     case EXPR_NOT:
-        ok = ExprResolveBoolean(ctx, expr, set_rtrn);
+        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;","{'deleted_lines': ['        ok = ExprResolveBoolean(ctx, expr, set_rtrn);'], 'added_lines': ['        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);']}",True,"Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation.",5.5,MEDIUM,1,valid,2018-03-10T21:10:47Z,2
CVE-2018-10771,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,lewdlime/abcm2ps,"fix: crash when too many accidentals in K: (signature + explicit)

Issue #17.",dc0372993674d0b50fedfbf7b9fad1239b8efc5f,https://github.com/lewdlime/abcm2ps/commit/dc0372993674d0b50fedfbf7b9fad1239b8efc5f,parse.c,set_k_acc,"static void set_k_acc(struct SYMBOL *s)
{
int i, j, nacc;
char accs[8], pits[8];
static char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};
static char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};
if (s->u.key.sf > 0) {
for (nacc = 0; nacc < s->u.key.sf; nacc++) {
accs[nacc] = A_SH;
pits[nacc] = sharp_tb[nacc];
}
} else {
for (nacc = 0; nacc < -s->u.key.sf; nacc++) {
accs[nacc] = A_FT;
pits[nacc] = flat_tb[nacc];
}
}
for (i = 0; i < s->u.key.nacc; i++) {
for (j = 0; j < nacc; j++) {
if (pits[j] == s->u.key.pits[i]) {
accs[j] = s->u.key.accs[i];
break;
}
}
if (j == nacc) {
accs[j] = s->u.key.accs[i];
pits[j] = s->u.key.pits[i];
nacc++;
}
}
for (i = 0; i < nacc; i++) {
s->u.key.accs[i] = accs[i];
s->u.key.pits[i] = pits[i];
}
s->u.key.nacc = nacc;
}","static void set_k_acc(struct SYMBOL *VAR_0)
{
int VAR_1, VAR_2, VAR_3;
char VAR_4[8], VAR_5[8];
static char VAR_6[8] = {26, 23, 27, 24, 21, 25, 22};
static char VAR_7[8] = {22, 25, 21, 24, 20, 23, 26};
if (VAR_0->u.key.sf > 0) {
for (VAR_3 = 0; VAR_3 < VAR_0->u.key.sf; VAR_3++) {
VAR_4[VAR_3] = VAR_8;
VAR_5[VAR_3] = VAR_6[VAR_3];
}
} else {
for (VAR_3 = 0; VAR_3 < -VAR_0->u.key.sf; VAR_3++) {
VAR_4[VAR_3] = VAR_9;
VAR_5[VAR_3] = VAR_7[VAR_3];
}
}
for (VAR_1 = 0; VAR_1 < VAR_0->u.key.nacc; VAR_1++) {
for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
if (VAR_5[VAR_2] == VAR_0->u.key.pits[VAR_1]) {
VAR_4[VAR_2] = VAR_0->u.key.accs[VAR_1];
break;
}
}
if (VAR_2 == VAR_3) {
VAR_4[VAR_2] = VAR_0->u.key.accs[VAR_1];
VAR_5[VAR_2] = VAR_0->u.key.pits[VAR_1];
VAR_3++;
}
}
for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
VAR_0->u.key.accs[VAR_1] = VAR_4[VAR_1];
VAR_0->u.key.pits[VAR_1] = VAR_5[VAR_1];
}
VAR_0->u.key.nacc = VAR_3;
}",lewdlime/abcm2ps/dc0372993674d0b50fedfbf7b9fad1239b8efc5f/parse.c/vul/before/0.json,"static void set_k_acc(struct SYMBOL *s)
{
	int i, j, nacc;
	char accs[8], pits[8];
	static char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};
	static char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};

	if (s->u.key.sf > 0) {
		for (nacc = 0; nacc < s->u.key.sf; nacc++) {
			accs[nacc] = A_SH;
			pits[nacc] = sharp_tb[nacc];
		}
	} else {
		for (nacc = 0; nacc < -s->u.key.sf; nacc++) {
			accs[nacc] = A_FT;
			pits[nacc] = flat_tb[nacc];
		}
	}
	for (i = 0; i < s->u.key.nacc; i++) {
		for (j = 0; j < nacc; j++) {
//			if ((pits[j] - s->u.key.pits[i]) % 7 == 0) {
			if (pits[j] == s->u.key.pits[i]) {
				accs[j] = s->u.key.accs[i];
				break;
			}
		}
		if (j == nacc) {
			if (nacc >= sizeof accs) {
				error(1, s, ""Too many accidentals"");
			} else {
				accs[j] = s->u.key.accs[i];
				pits[j] = s->u.key.pits[i];
				nacc++;
			}
		}
	}
	for (i = 0; i < nacc; i++) {
		s->u.key.accs[i] = accs[i];
		s->u.key.pits[i] = pits[i];
	}
	s->u.key.nacc = nacc;
}","static void set_k_acc(struct SYMBOL *VAR_0)
{
	int VAR_1, VAR_2, VAR_3;
	char VAR_4[8], VAR_5[8];
	static char VAR_6[8] = {26, 23, 27, 24, 21, 25, 22};
	static char VAR_7[8] = {22, 25, 21, 24, 20, 23, 26};

	if (VAR_0->u.key.sf > 0) {
		for (VAR_3 = 0; VAR_3 < VAR_0->u.key.sf; VAR_3++) {
			VAR_4[VAR_3] = VAR_8;
			VAR_5[VAR_3] = VAR_6[VAR_3];
		}
	} else {
		for (VAR_3 = 0; VAR_3 < -VAR_0->u.key.sf; VAR_3++) {
			VAR_4[VAR_3] = VAR_9;
			VAR_5[VAR_3] = VAR_7[VAR_3];
		}
	}
	for (VAR_1 = 0; VAR_1 < VAR_0->u.key.nacc; VAR_1++) {
		for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
/* COMMENT_0 */
			if (VAR_5[VAR_2] == VAR_0->u.key.pits[VAR_1]) {
				VAR_4[VAR_2] = VAR_0->u.key.accs[VAR_1];
				break;
			}
		}
		if (VAR_2 == VAR_3) {
			if (VAR_3 >= sizeof VAR_4) {
				error(1, VAR_0, ""Too many accidentals"");
			} else {
				VAR_4[VAR_2] = VAR_0->u.key.accs[VAR_1];
				VAR_5[VAR_2] = VAR_0->u.key.pits[VAR_1];
				VAR_3++;
			}
		}
	}
	for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
		VAR_0->u.key.accs[VAR_1] = VAR_4[VAR_1];
		VAR_0->u.key.pits[VAR_1] = VAR_5[VAR_1];
	}
	VAR_0->u.key.nacc = VAR_3;
}",lewdlime/abcm2ps/dc0372993674d0b50fedfbf7b9fad1239b8efc5f/parse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,9 +25,13 @@
 			}
 		}
 		if (j == nacc) {
-			accs[j] = s->u.key.accs[i];
-			pits[j] = s->u.key.pits[i];
-			nacc++;		/* cannot overflow */
+			if (nacc >= sizeof accs) {
+				error(1, s, ""Too many accidentals"");
+			} else {
+				accs[j] = s->u.key.accs[i];
+				pits[j] = s->u.key.pits[i];
+				nacc++;
+			}
 		}
 	}
 	for (i = 0; i < nacc; i++) {","{'deleted_lines': ['\t\t\taccs[j] = s->u.key.accs[i];', '\t\t\tpits[j] = s->u.key.pits[i];', '\t\t\tnacc++;\t\t/* cannot overflow */'], 'added_lines': ['\t\t\tif (nacc >= sizeof accs) {', '\t\t\t\terror(1, s, ""Too many accidentals"");', '\t\t\t} else {', '\t\t\t\taccs[j] = s->u.key.accs[i];', '\t\t\t\tpits[j] = s->u.key.pits[i];', '\t\t\t\tnacc++;', '\t\t\t}']}",True,Stack-based buffer overflow in the get_key function in parse.c in abcm2ps through 8.13.20 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact.,9.8,CRITICAL,3,valid,2018-04-13T14:17:50Z,2
CVE-2018-11383,['CWE-908'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,Fix #9943 - Invalid free on RAnal.avr,9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,https://github.com/radareorg/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,libr/core/cmd_anal.c,cmd_anal_esil,"static void cmd_anal_esil(RCore *core, const char *input) {
RAnalEsil *esil = core->anal->esil;
ut64 addr = core->offset;
ut64 adr ;
char *n, *n1;
int off;
int stacksize = r_config_get_i (core->config, ""esil.stack.depth"");
int iotrap = r_config_get_i (core->config, ""esil.iotrap"");
int romem = r_config_get_i (core->config, ""esil.romem"");
int stats = r_config_get_i (core->config, ""esil.stats"");
int noNULL = r_config_get_i (core->config, ""esil.noNULL"");
ut64 until_addr = UT64_MAX;
unsigned int addrsize = r_config_get_i (core->config, ""esil.addr.size"");
const char *until_expr = NULL;
RAnalOp *op;
switch (input[0]) {
case 'p': switch (input[1]) {
case 'c':
if (input[2] == ' ') {
r_core_cmdf (core, ""ar PC=%s"", input + 3);
r_core_cmd0 (core, "".ar*"");
} else {
eprintf (""Missing argument\n"");
}
break;
case 0:
r_anal_pin_list (core->anal);
break;
case '-':
if (input[2])
addr = r_num_math (core->num, input + 2);
r_anal_pin_unset (core->anal, addr);
break;
case ' ':
r_anal_pin (core->anal, addr, input + 2);
break;
default:
r_core_cmd_help (core, help_msg_aep);
break;
}
break;
case 'r': cmd_anal_reg (core, input + 1);
break;
case '*':
if (core->anal->esil) {
r_cons_printf (""trap: %d\n"", core->anal->esil->trap);
r_cons_printf (""trap-code: %d\n"", core->anal->esil->trap_code);
} else {
eprintf (""esil vm not initialized. run `aei`\n"");
}
break;
case ' ':
if (!esil) {
if (!(core->anal->esil = esil = r_anal_esil_new (stacksize, iotrap, addrsize)))
return;
}
r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); r_anal_esil_set_pc (esil, core->offset);
r_anal_esil_parse (esil, input + 1);
r_anal_esil_dumpstack (esil);
r_anal_esil_stack_free (esil);
break;
case 's': switch (input[1]) {
case '?':
eprintf (""See: ae?~aes\n"");
break;
case 'l': {
ut64 pc = r_debug_reg_get (core->dbg, ""PC"");
RAnalOp *op = r_core_anal_op (core, pc);
if (!op) {
break;
}
r_core_esil_step (core, UT64_MAX, NULL, NULL);
r_debug_reg_set (core->dbg, ""PC"", pc + op->size);
r_anal_esil_set_pc (esil, pc + op->size);
r_core_cmd0 (core, "".ar*"");
} break;
case 'b': if (!r_core_esil_step_back (core)) {
eprintf (""cannnot step back\n"");
}
r_core_cmd0 (core, "".ar*"");
break;
case 'u': if (input[2] == 'e') {
until_expr = input + 3;
} else {
until_addr = r_num_math (core->num, input + 2);
}
r_core_esil_step (core, until_addr, until_expr, NULL);
r_core_cmd0 (core, "".ar*"");
break;
case 'o': op = r_core_anal_op (core, r_reg_getv (core->anal->reg,
r_reg_get_name (core->anal->reg, R_REG_NAME_PC)));
if (op && op->type == R_ANAL_OP_TYPE_CALL) {
until_addr = op->addr + op->size;
}
r_core_esil_step (core, until_addr, until_expr, NULL);
r_anal_op_free (op);
r_core_cmd0 (core, "".ar*"");
break;
case 'p': n = strchr (input, ' ');
n1 = n ? strchr (n + 1, ' ') : NULL;
if ((!n || !n1) || (!(n + 1) || !(n1 + 1))) {
eprintf (""aesp [offset] [num]\n"");
break;
}
adr = r_num_math (core->num, n + 1);
off = r_num_math (core->num, n1 + 1);
cmd_aespc (core, adr, off);
break;
case ' ':
n = strchr (input, ' ');
if (!(n + 1)) {
r_core_esil_step (core, until_addr, until_expr, NULL);
break;
}
off = r_num_math (core->num, n + 1);
cmd_aespc (core, -1, off);
break;
default:
r_core_esil_step (core, until_addr, until_expr, NULL);
r_core_cmd0 (core, "".ar*"");
break;
}
break;
case 'c': if (input[1] == '?') { r_core_cmd_help (core, help_msg_aec);
} else if (input[1] == 's') { const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
ut64 newaddr;
int ret;
for (;;) {
op = r_core_anal_op (core, addr);
if (!op) {
break;
}
if (op->type == R_ANAL_OP_TYPE_SWI) {
eprintf (""syscall at 0x%08"" PFMT64x ""\n"", addr);
break;
}
if (op->type == R_ANAL_OP_TYPE_TRAP) {
eprintf (""trap at 0x%08"" PFMT64x ""\n"", addr);
break;
}
ret = r_core_esil_step (core, UT64_MAX, NULL, NULL);
r_anal_op_free (op);
op = NULL;
if (core->anal->esil->trap || core->anal->esil->trap_code) {
break;
}
if (!ret)
break;
r_core_cmd0 (core, "".ar*"");
newaddr = r_num_get (core->num, pc);
if (addr == newaddr) {
addr++;
break;
} else {
addr = newaddr;
}
}
if (op) {
r_anal_op_free (op);
}
} else {
if (input[1] == 'u' && input[2] == 'e')
until_expr = input + 3;
else if (input[1] == 'u')
until_addr = r_num_math (core->num, input + 2);
else until_expr = ""0"";
r_core_esil_step (core, until_addr, until_expr, NULL);
r_core_cmd0 (core, "".ar*"");
}
break;
case 'i': switch (input[1]) {
case 's':
case 'm': cmd_esil_mem (core, input + 2);
break;
case 'p': r_core_cmd0 (core, ""ar PC=$$"");
break;
case '?':
cmd_esil_mem (core, ""?"");
break;
case '-':
if (esil) {
sdb_reset (esil->stats);
}
r_anal_esil_free (esil);
core->anal->esil = NULL;
break;
case 0:r_anal_esil_free (esil);
{
const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
if (r_reg_getv (core->anal->reg, pc) == 0LL) {
r_core_cmd0 (core, ""ar PC=$$"");
}
}
if (!(esil = core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {
return;
}
r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); esil->verbose = (int)r_config_get_i (core->config, ""esil.verbose"");
{
const char *s = r_config_get (core->config, ""cmd.esil.intr"");
if (s) {
char *my = strdup (s);
if (my) {
r_config_set (core->config, ""cmd.esil.intr"", my);
free (my);
}
}
}
break;
}
break;
case 'k': switch (input[1]) {
case '\0':
input = ""123*"";
case ' ':
if (esil && esil->stats) {
char *out = sdb_querys (esil->stats, NULL, 0, input + 2);
if (out) {
r_cons_println (out);
free (out);
}
} else {
eprintf (""esil.stats is empty. Run 'aei'\n"");
}
break;
case '-':
if (esil) {
sdb_reset (esil->stats);
}
break;
}
break;
case 'f': {
RListIter *iter;
RAnalBlock *bb;
RAnalFunction *fcn = r_anal_get_fcn_in (core->anal,
core->offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);
if (fcn) {
r_list_foreach (fcn->bbs, iter, bb) {
ut64 pc = bb->addr;
ut64 end = bb->addr + bb->size;
RAnalOp op;
ut8 *buf;
int ret, bbs = end - pc;
if (bbs < 1 || bbs > 0xfffff) {
eprintf (""Invalid block size\n"");
}
buf = calloc (1, bbs + 1);
r_io_read_at (core->io, pc, buf, bbs);
int left;
while (pc < end) {
left = R_MIN (end - pc, 32);
r_asm_set_pc (core->assembler, pc);
ret = r_anal_op (core->anal, &op, addr, buf, left, R_ANAL_OP_MASK_ALL); if (ret) {
r_reg_set_value_by_role (core->anal->reg, R_REG_NAME_PC, pc);
r_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));
r_anal_esil_dumpstack (esil);
r_anal_esil_stack_free (esil);
pc += op.size;
} else {
pc += 4; }
}
}
} else {
eprintf (""Cannot find function at 0x%08"" PFMT64x ""\n"", core->offset);
}
} break;
case 't': switch (input[1]) {
case 'r': {
RAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);
if (!esil)
return;
r_anal_esil_to_reil_setup (esil, core->anal, romem, stats);
r_anal_esil_set_pc (esil, core->offset);
r_anal_esil_parse (esil, input + 2);
r_anal_esil_dumpstack (esil);
r_anal_esil_free (esil);
break;
}
case 's': switch (input[2]) {
case 0:
r_anal_esil_session_list (esil);
break;
case '+':
r_anal_esil_session_add (esil);
break;
default:
r_core_cmd_help (core, help_msg_aets);
break;
}
break;
default:
eprintf (""Unknown command. Use `aetr`.\n"");
break;
}
break;
case 'A': if (input[1] == '?') {
r_core_cmd_help (core, help_msg_aea);
} else if (input[1] == 'r') {
cmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'w') {
cmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'n') {
cmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'j') {
cmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));
} else if (input[1] == '*') {
cmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'f') {
RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
if (fcn) {
cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));
}
} else {
cmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input+2));
}
break;
case 'a': if (input[1] == '?') {
r_core_cmd_help (core, help_msg_aea);
} else if (input[1] == 'r') {
cmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'w') {
cmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'n') {
cmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'j') {
cmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));
} else if (input[1] == '*') {
cmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));
} else if (input[1] == 'f') {
RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
if (fcn) {
switch (input[2]) {
case 'j': cmd_aea (core, 1<<4, fcn->addr, r_anal_fcn_size (fcn));
break;
default:
cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));
break;
}
break;
}
} else {
const char *arg = input[1]? input + 2: """";
ut64 len = r_num_math (core->num, arg);
cmd_aea (core, 0, core->offset, len);
}
break;
case 'x': { char *hex;
int ret, bufsz;
input = r_str_trim_ro (input + 1);
hex = strdup (input);
if (!hex) {
break;
}
RAnalOp aop = R_EMPTY;
bufsz = r_hex_str2bin (hex, (ut8*)hex);
ret = r_anal_op (core->anal, &aop, core->offset,
(const ut8*)hex, bufsz, R_ANAL_OP_MASK_ALL);
if (ret>0) {
const char *str = R_STRBUF_SAFEGET (&aop.esil);
char *str2 = r_str_newf ("" %s"", str);
cmd_anal_esil (core, str2);
free (str2);
}
r_anal_op_fini (&aop);
break;
}
case '?': if (input[1] == '?') {
r_core_cmd_help (core, help_detail_ae);
break;
}
default:
r_core_cmd_help (core, help_msg_ae);
break;
}
}","static void cmd_anal_esil(RCore *VAR_0, const char *VAR_1) {
RAnalEsil *VAR_2 = VAR_0->anal->esil;
ut64 VAR_3 = VAR_0->offset;
ut64 VAR_4 ;
char *VAR_5, *VAR_6;
int VAR_7;
int VAR_8 = r_config_get_i (VAR_0->config, ""esil.stack.depth"");
int VAR_9 = r_config_get_i (VAR_0->config, ""esil.iotrap"");
int VAR_10 = r_config_get_i (VAR_0->config, ""esil.romem"");
int VAR_11 = r_config_get_i (VAR_0->config, ""esil.stats"");
int VAR_12 = r_config_get_i (VAR_0->config, ""esil.noNULL"");
ut64 VAR_13 = VAR_14;
unsigned int VAR_15 = r_config_get_i (VAR_0->config, ""esil.addr.size"");
const char *VAR_16 = NULL;
RAnalOp *VAR_17;
switch (VAR_1[0]) {
case 'p': 
switch (VAR_1[1]) {
case 'c':
if (VAR_1[2] == ' ') {
r_core_cmdf (VAR_0, ""ar PC=%s"", VAR_1 + 3);
r_core_cmd0 (VAR_0, "".ar*"");
} else {
eprintf (""Missing argument\n"");
}
break;
case 0:
r_anal_pin_list (VAR_0->anal);
break;
case '-':
if (VAR_1[2])
VAR_3 = r_num_math (VAR_0->num, VAR_1 + 2);
r_anal_pin_unset (VAR_0->anal, VAR_3);
break;
case ' ':
r_anal_pin (VAR_0->anal, VAR_3, VAR_1 + 2);
break;
default:
r_core_cmd_help (VAR_0, VAR_18);
break;
}
break;
case 'r': 
cmd_anal_reg (VAR_0, VAR_1 + 1);
break;
case '*':
if (VAR_0->anal->esil) {
r_cons_printf (""trap: %d\n"", VAR_0->anal->esil->trap);
r_cons_printf (""trap-code: %d\n"", VAR_0->anal->esil->trap_code);
} else {
eprintf (""esil vm not initialized. run `aei`\n"");
}
break;
case ' ':
if (!VAR_2) {
if (!(VAR_0->anal->esil = VAR_2 = r_anal_esil_new (VAR_8, VAR_9, VAR_15)))
return;
}
r_anal_esil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11, VAR_12); 
r_anal_esil_set_pc (VAR_2, VAR_0->offset);
r_anal_esil_parse (VAR_2, VAR_1 + 1);
r_anal_esil_dumpstack (VAR_2);
r_anal_esil_stack_free (VAR_2);
break;
case 's': 
switch (VAR_1[1]) {
case '?':
eprintf (""See: ae?~aes\n"");
break;
case 'l': 
{
ut64 VAR_19 = r_debug_reg_get (VAR_0->dbg, ""PC"");
RAnalOp *VAR_17 = r_core_anal_op (VAR_0, VAR_19);
if (!VAR_17) {
break;
}
r_core_esil_step (VAR_0, VAR_14, NULL, NULL);
r_debug_reg_set (VAR_0->dbg, ""PC"", VAR_19 + VAR_17->size);
r_anal_esil_set_pc (VAR_2, VAR_19 + VAR_17->size);
r_core_cmd0 (VAR_0, "".ar*"");
} break;
case 'b': 
if (!r_core_esil_step_back (VAR_0)) {
eprintf (""cannnot step back\n"");
}
r_core_cmd0 (VAR_0, "".ar*"");
break;
case 'u': 
if (VAR_1[2] == 'e') {
VAR_16 = VAR_1 + 3;
} else {
VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);
}
r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
r_core_cmd0 (VAR_0, "".ar*"");
break;
case 'o': 
VAR_17 = r_core_anal_op (VAR_0, r_reg_getv (VAR_0->anal->reg,
r_reg_get_name (VAR_0->anal->reg, VAR_20)));
if (VAR_17 && VAR_17->type == VAR_21) {
VAR_13 = VAR_17->addr + VAR_17->size;
}
r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
r_anal_op_free (VAR_17);
r_core_cmd0 (VAR_0, "".ar*"");
break;
case 'p': 
VAR_5 = strchr (VAR_1, ' ');
VAR_6 = VAR_5 ? strchr (VAR_5 + 1, ' ') : NULL;
if ((!VAR_5 || !VAR_6) || (!(VAR_5 + 1) || !(VAR_6 + 1))) {
eprintf (""aesp [offset] [num]\n"");
break;
}
VAR_4 = r_num_math (VAR_0->num, VAR_5 + 1);
VAR_7 = r_num_math (VAR_0->num, VAR_6 + 1);
cmd_aespc (VAR_0, VAR_4, VAR_7);
break;
case ' ':
VAR_5 = strchr (VAR_1, ' ');
if (!(VAR_5 + 1)) {
r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
break;
}
VAR_7 = r_num_math (VAR_0->num, VAR_5 + 1);
cmd_aespc (VAR_0, -1, VAR_7);
break;
default:
r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
r_core_cmd0 (VAR_0, "".ar*"");
break;
}
break;
case 'c': 
if (VAR_1[1] == '?') { 
r_core_cmd_help (VAR_0, VAR_22);
} else if (VAR_1[1] == 's') { 
const char *VAR_19 = r_reg_get_name (VAR_0->anal->reg, VAR_20);
ut64 VAR_23;
int VAR_24;
for (;;) {
VAR_17 = r_core_anal_op (VAR_0, VAR_3);
if (!VAR_17) {
break;
}
if (VAR_17->type == VAR_25) {
eprintf (""syscall at 0x%08"" VAR_26 ""\n"", VAR_3);
break;
}
if (VAR_17->type == VAR_27) {
eprintf (""trap at 0x%08"" VAR_26 ""\n"", VAR_3);
break;
}
VAR_24 = r_core_esil_step (VAR_0, VAR_14, NULL, NULL);
r_anal_op_free (VAR_17);
VAR_17 = NULL;
if (VAR_0->anal->esil->trap || VAR_0->anal->esil->trap_code) {
break;
}
if (!VAR_24)
break;
r_core_cmd0 (VAR_0, "".ar*"");
VAR_23 = r_num_get (VAR_0->num, VAR_19);
if (VAR_3 == VAR_23) {
VAR_3++;
break;
} else {
VAR_3 = VAR_23;
}
}
if (VAR_17) {
r_anal_op_free (VAR_17);
}
} else {
if (VAR_1[1] == 'u' && VAR_1[2] == 'e')
VAR_16 = VAR_1 + 3;
else if (VAR_1[1] == 'u')
VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);
else VAR_16 = ""0"";
r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
r_core_cmd0 (VAR_0, "".ar*"");
}
break;
case 'i': 
switch (VAR_1[1]) {
case 's':
case 'm': 
cmd_esil_mem (VAR_0, VAR_1 + 2);
break;
case 'p': 
r_core_cmd0 (VAR_0, ""ar PC=$$"");
break;
case '?':
cmd_esil_mem (VAR_0, ""?"");
break;
case '-':
if (VAR_2) {
sdb_reset (VAR_2->stats);
}
r_anal_esil_free (VAR_2);
VAR_0->anal->esil = NULL;
break;
case 0:
r_anal_esil_free (VAR_2);
{
const char *VAR_19 = r_reg_get_name (VAR_0->anal->reg, VAR_20);
if (r_reg_getv (VAR_0->anal->reg, VAR_19) == 0LL) {
r_core_cmd0 (VAR_0, ""ar PC=$$"");
}
}
if (!(VAR_2 = VAR_0->anal->esil = r_anal_esil_new (VAR_8, VAR_9, VAR_15))) {
return;
}
r_anal_esil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11, VAR_12); 
VAR_2->verbose = (int)r_config_get_i (VAR_0->config, ""esil.verbose"");
{
const char *VAR_28 = r_config_get (VAR_0->config, ""cmd.esil.intr"");
if (VAR_28) {
char *VAR_29 = strdup (VAR_28);
if (VAR_29) {
r_config_set (VAR_0->config, ""cmd.esil.intr"", VAR_29);
free (VAR_29);
}
}
}
break;
}
break;
case 'k': 
switch (VAR_1[1]) {
case '\0':
VAR_1 = ""123*"";
case ' ':
if (VAR_2 && VAR_2->stats) {
char *VAR_30 = sdb_querys (VAR_2->stats, NULL, 0, VAR_1 + 2);
if (VAR_30) {
r_cons_println (VAR_30);
free (VAR_30);
}
} else {
eprintf (""esil.stats is empty. Run 'aei'\n"");
}
break;
case '-':
if (VAR_2) {
sdb_reset (VAR_2->stats);
}
break;
}
break;
case 'f': 
{
RListIter *VAR_31;
RAnalBlock *VAR_32;
RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal,
VAR_0->offset, VAR_34 | VAR_35);
if (VAR_33) {
r_list_foreach (VAR_33->bbs, VAR_31, VAR_32) {
ut64 VAR_19 = VAR_32->addr;
ut64 VAR_36 = VAR_32->addr + VAR_32->size;
RAnalOp VAR_17;
ut8 *VAR_37;
int VAR_24, VAR_38 = VAR_36 - VAR_19;
if (VAR_38 < 1 || VAR_38 > 0xfffff) {
eprintf (""Invalid block size\n"");
}
VAR_37 = calloc (1, VAR_38 + 1);
r_io_read_at (VAR_0->io, VAR_19, VAR_37, VAR_38);
int VAR_39;
while (VAR_19 < VAR_36) {
VAR_39 = R_MIN (VAR_36 - VAR_19, 32);
r_asm_set_pc (VAR_0->assembler, VAR_19);
VAR_24 = r_anal_op (VAR_0->anal, &VAR_17, VAR_3, VAR_37, VAR_39, VAR_40); 
if (VAR_24) {
r_reg_set_value_by_role (VAR_0->anal->reg, VAR_20, VAR_19);
r_anal_esil_parse (VAR_2, R_STRBUF_SAFEGET (&VAR_17.esil));
r_anal_esil_dumpstack (VAR_2);
r_anal_esil_stack_free (VAR_2);
VAR_19 += VAR_17.size;
} else {
VAR_19 += 4; 
}
}
}
} else {
eprintf (""Cannot find function at 0x%08"" VAR_26 ""\n"", VAR_0->offset);
}
} break;
case 't': 
switch (VAR_1[1]) {
case 'r': 
{
RAnalEsil *VAR_2 = r_anal_esil_new (VAR_8, VAR_9, VAR_15);
if (!VAR_2)
return;
r_anal_esil_to_reil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11);
r_anal_esil_set_pc (VAR_2, VAR_0->offset);
r_anal_esil_parse (VAR_2, VAR_1 + 2);
r_anal_esil_dumpstack (VAR_2);
r_anal_esil_free (VAR_2);
break;
}
case 's': 
switch (VAR_1[2]) {
case 0:
r_anal_esil_session_list (VAR_2);
break;
case '+':
r_anal_esil_session_add (VAR_2);
break;
default:
r_core_cmd_help (VAR_0, VAR_41);
break;
}
break;
default:
eprintf (""Unknown command. Use `aetr`.\n"");
break;
}
break;
case 'A': 
if (VAR_1[1] == '?') {
r_core_cmd_help (VAR_0, VAR_42);
} else if (VAR_1[1] == 'r') {
cmd_aea (VAR_0, 1 + (1<<1), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'w') {
cmd_aea (VAR_0, 1 + (1<<2), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'n') {
cmd_aea (VAR_0, 1 + (1<<3), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'j') {
cmd_aea (VAR_0, 1 + (1<<4), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == '*') {
cmd_aea (VAR_0, 1 + (1<<5), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'f') {
RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, -1);
if (VAR_33) {
cmd_aea (VAR_0, 1, VAR_33->addr, r_anal_fcn_size (VAR_33));
}
} else {
cmd_aea (VAR_0, 1, VAR_0->offset, (int)r_num_math (VAR_0->num, VAR_1+2));
}
break;
case 'a': 
if (VAR_1[1] == '?') {
r_core_cmd_help (VAR_0, VAR_42);
} else if (VAR_1[1] == 'r') {
cmd_aea (VAR_0, 1<<1, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'w') {
cmd_aea (VAR_0, 1<<2, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'n') {
cmd_aea (VAR_0, 1<<3, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'j') {
cmd_aea (VAR_0, 1<<4, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == '*') {
cmd_aea (VAR_0, 1<<5, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
} else if (VAR_1[1] == 'f') {
RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, -1);
if (VAR_33) {
switch (VAR_1[2]) {
case 'j': 
cmd_aea (VAR_0, 1<<4, VAR_33->addr, r_anal_fcn_size (VAR_33));
break;
default:
cmd_aea (VAR_0, 1, VAR_33->addr, r_anal_fcn_size (VAR_33));
break;
}
break;
}
} else {
const char *VAR_43 = VAR_1[1]? VAR_1 + 2: """";
ut64 VAR_44 = r_num_math (VAR_0->num, VAR_43);
cmd_aea (VAR_0, 0, VAR_0->offset, VAR_44);
}
break;
case 'x': { 
char *VAR_45;
int VAR_24, VAR_46;
VAR_1 = r_str_trim_ro (VAR_1 + 1);
VAR_45 = strdup (VAR_1);
if (!VAR_45) {
break;
}
RAnalOp VAR_47 = VAR_48;
VAR_46 = r_hex_str2bin (VAR_45, (ut8*)VAR_45);
VAR_24 = r_anal_op (VAR_0->anal, &VAR_47, VAR_0->offset,
(const ut8*)VAR_45, VAR_46, VAR_40);
if (VAR_24>0) {
const char *VAR_49 = R_STRBUF_SAFEGET (&VAR_47.esil);
char *VAR_50 = r_str_newf ("" %s"", VAR_49);
cmd_anal_esil (VAR_0, VAR_50);
free (VAR_50);
}
r_anal_op_fini (&VAR_47);
break;
}
case '?': 
if (VAR_1[1] == '?') {
r_core_cmd_help (VAR_0, VAR_51);
break;
}
default:
r_core_cmd_help (VAR_0, VAR_52);
break;
}
}",radareorg/radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/cmd_anal.c/vul/before/0.json,"static void cmd_anal_esil(RCore *core, const char *input) {
	RAnalEsil *esil = core->anal->esil;
	ut64 addr = core->offset;
	ut64 adr ;
	char *n, *n1;
	int off;
	int stacksize = r_config_get_i (core->config, ""esil.stack.depth"");
	int iotrap = r_config_get_i (core->config, ""esil.iotrap"");
	int romem = r_config_get_i (core->config, ""esil.romem"");
	int stats = r_config_get_i (core->config, ""esil.stats"");
	int noNULL = r_config_get_i (core->config, ""esil.noNULL"");
	ut64 until_addr = UT64_MAX;
	unsigned int addrsize = r_config_get_i (core->config, ""esil.addr.size"");

	const char *until_expr = NULL;
	RAnalOp *op;

	switch (input[0]) {
	case 'p': // ""aep""
		switch (input[1]) {
		case 'c':
			if (input[2] == ' ') {
				// seek to this address
				r_core_cmdf (core, ""ar PC=%s"", input + 3);
				r_core_cmd0 (core, "".ar*"");
			} else {
				eprintf (""Missing argument\n"");
			}
			break;
		case 0:
			r_anal_pin_list (core->anal);
			break;
		case '-':
			if (input[2])
				addr = r_num_math (core->num, input + 2);
			r_anal_pin_unset (core->anal, addr);
			break;
		case ' ':
			r_anal_pin (core->anal, addr, input + 2);
			break;
		default:
			r_core_cmd_help (core, help_msg_aep);
			break;
		}
		break;
	case 'r': // ""aer""
		// 'aer' is an alias for 'ar'
		cmd_anal_reg (core, input + 1);
		break;
	case '*':
		// XXX: this is wip, not working atm
		if (core->anal->esil) {
			r_cons_printf (""trap: %d\n"", core->anal->esil->trap);
			r_cons_printf (""trap-code: %d\n"", core->anal->esil->trap_code);
		} else {
			eprintf (""esil vm not initialized. run `aei`\n"");
		}
		break;
	case ' ':
		//r_anal_esil_eval (core->anal, input+1);
		if (!esil) {
			if (!(core->anal->esil = esil = r_anal_esil_new (stacksize, iotrap, addrsize)))
				return;
		}
		r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io
		r_anal_esil_set_pc (esil, core->offset);
		r_anal_esil_parse (esil, input + 1);
		r_anal_esil_dumpstack (esil);
		r_anal_esil_stack_free (esil);
		break;
	case 's': // ""aes""
		// ""aes"" ""aeso"" ""aesu"" ""aesue""
		// aes -> single step
		// aesb -> single step back
		// aeso -> single step over
		// aesu -> until address
		// aesue -> until esil expression
		switch (input[1]) {
		case '?':
			eprintf (""See: ae?~aes\n"");
			break;
		case 'l': // ""aesl""
		{
			ut64 pc = r_debug_reg_get (core->dbg, ""PC"");
			RAnalOp *op = r_core_anal_op (core, pc);
// TODO: honor hint
			if (!op) {
				break;
			}
			r_core_esil_step (core, UT64_MAX, NULL, NULL);
			r_debug_reg_set (core->dbg, ""PC"", pc + op->size);
			r_anal_esil_set_pc (esil, pc + op->size);
			r_core_cmd0 (core, "".ar*"");
		} break;
		case 'b': // ""aesb""
			if (!r_core_esil_step_back (core)) {
				eprintf (""cannnot step back\n"");
			}
			r_core_cmd0 (core, "".ar*"");
			break;
		case 'u': // ""aesu""
			if (input[2] == 'e') {
				until_expr = input + 3;
			} else {
				until_addr = r_num_math (core->num, input + 2);
			}
			r_core_esil_step (core, until_addr, until_expr, NULL);
			r_core_cmd0 (core, "".ar*"");
			break;
		case 'o': // ""aeso""
			// step over
			op = r_core_anal_op (core, r_reg_getv (core->anal->reg,
				r_reg_get_name (core->anal->reg, R_REG_NAME_PC)));
			if (op && op->type == R_ANAL_OP_TYPE_CALL) {
				until_addr = op->addr + op->size;
			}
			r_core_esil_step (core, until_addr, until_expr, NULL);
			r_anal_op_free (op);
			r_core_cmd0 (core, "".ar*"");
			break;
		case 'p': //""aesp""
			n = strchr (input, ' ');
			n1 = n ? strchr (n + 1, ' ') : NULL;
			if ((!n || !n1) || (!(n + 1) || !(n1 + 1))) {
				eprintf (""aesp [offset] [num]\n"");
				break;
			}
			adr = r_num_math (core->num, n + 1);
			off = r_num_math (core->num, n1 + 1);
			cmd_aespc (core, adr, off);
			break;
		case ' ':
			n = strchr (input, ' ');
			if (!(n + 1)) {
				r_core_esil_step (core, until_addr, until_expr, NULL);
				break;
			}
			off = r_num_math (core->num, n + 1);
			cmd_aespc (core, -1, off);
			break;
		default:
			r_core_esil_step (core, until_addr, until_expr, NULL);
			r_core_cmd0 (core, "".ar*"");
			break;
		}
		break;
	case 'c': // ""aec""
		if (input[1] == '?') { // ""aec?""
			r_core_cmd_help (core, help_msg_aec);
		} else if (input[1] == 's') { // ""aecs""
			const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
			ut64 newaddr;
			int ret;
			for (;;) {
				op = r_core_anal_op (core, addr);
				if (!op) {
					break;
				}
				if (op->type == R_ANAL_OP_TYPE_SWI) {
					eprintf (""syscall at 0x%08"" PFMT64x ""\n"", addr);
					break;
				}
				if (op->type == R_ANAL_OP_TYPE_TRAP) {
					eprintf (""trap at 0x%08"" PFMT64x ""\n"", addr);
					break;
				}
				ret = r_core_esil_step (core, UT64_MAX, NULL, NULL);
				r_anal_op_free (op);
				op = NULL;
				if (core->anal->esil->trap || core->anal->esil->trap_code) {
					break;
				}
				if (!ret)
					break;
				r_core_cmd0 (core, "".ar*"");
				newaddr = r_num_get (core->num, pc);
				if (addr == newaddr) {
					addr++;
					break;
				} else {
					addr = newaddr;
				}
			}
			if (op) {
				r_anal_op_free (op);
			}
		} else {
			// ""aec""  -> continue until ^C
			// ""aecu"" -> until address
			// ""aecue"" -> until esil expression
			if (input[1] == 'u' && input[2] == 'e')
				until_expr = input + 3;
			else if (input[1] == 'u')
				until_addr = r_num_math (core->num, input + 2);
			else until_expr = ""0"";
			r_core_esil_step (core, until_addr, until_expr, NULL);
			r_core_cmd0 (core, "".ar*"");
		}
		break;
	case 'i': // ""aei""
		switch (input[1]) {
		case 's':
		case 'm': // ""aeim""
			cmd_esil_mem (core, input + 2);
			break;
		case 'p': // initialize pc = $$
			r_core_cmd0 (core, ""ar PC=$$"");
			break;
		case '?':
			cmd_esil_mem (core, ""?"");
			break;
		case '-':
			if (esil) {
				sdb_reset (esil->stats);
			}
			r_anal_esil_free (esil);
			core->anal->esil = NULL;
			break;
		case 0:				//lolololol
			r_anal_esil_free (esil);
			// reinitialize
			{
				const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
				if (r_reg_getv (core->anal->reg, pc) == 0LL) {
					r_core_cmd0 (core, ""ar PC=$$"");
				}
			}
			if (!(esil = core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {
				return;
			}
			r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io
			esil->verbose = (int)r_config_get_i (core->config, ""esil.verbose"");
			/* restore user settings for interrupt handling */
			{
				const char *s = r_config_get (core->config, ""cmd.esil.intr"");
				if (s) {
					char *my = strdup (s);
					if (my) {
						r_config_set (core->config, ""cmd.esil.intr"", my);
						free (my);
					}
				}
			}
			break;
		}
		break;
	case 'k': // ""aek""
		switch (input[1]) {
		case '\0':
			input = ""123*"";
			/* fall through */
		case ' ':
			if (esil && esil->stats) {
				char *out = sdb_querys (esil->stats, NULL, 0, input + 2);
				if (out) {
					r_cons_println (out);
					free (out);
				}
			} else {
				eprintf (""esil.stats is empty. Run 'aei'\n"");
			}
			break;
		case '-':
			if (esil) {
				sdb_reset (esil->stats);
			}
			break;
		}
		break;
	case 'f': // ""aef""
	{
		RListIter *iter;
		RAnalBlock *bb;
		RAnalFunction *fcn = r_anal_get_fcn_in (core->anal,
							core->offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);
		if (fcn) {
			// emulate every instruction in the function recursively across all the basic blocks
			r_list_foreach (fcn->bbs, iter, bb) {
				ut64 pc = bb->addr;
				ut64 end = bb->addr + bb->size;
				RAnalOp op;
				ut8 *buf;
				int ret, bbs = end - pc;
				if (bbs < 1 || bbs > 0xfffff) {
					eprintf (""Invalid block size\n"");
				}
		//		eprintf (""[*] Emulating 0x%08""PFMT64x"" basic block 0x%08"" PFMT64x "" - 0x%08"" PFMT64x ""\r["", fcn->addr, pc, end);
				buf = calloc (1, bbs + 1);
				r_io_read_at (core->io, pc, buf, bbs);
				int left;
				while (pc < end) {
					left = R_MIN (end - pc, 32);
					r_asm_set_pc (core->assembler, pc);
					ret = r_anal_op (core->anal, &op, addr, buf, left, R_ANAL_OP_MASK_ALL); // read overflow
					if (ret) {
						r_reg_set_value_by_role (core->anal->reg, R_REG_NAME_PC, pc);
						r_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));
						r_anal_esil_dumpstack (esil);
						r_anal_esil_stack_free (esil);
						pc += op.size;
					} else {
						pc += 4; // XXX
					}
				}
			}
		} else {
			eprintf (""Cannot find function at 0x%08"" PFMT64x ""\n"", core->offset);
		}
	} break;
	case 't': // ""aet""
		switch (input[1]) {
		case 'r': // ""aetr""
		{
			// anal ESIL to REIL.
			RAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);
			if (!esil) {
				return;
			}
			r_anal_esil_to_reil_setup (esil, core->anal, romem, stats);
			r_anal_esil_set_pc (esil, core->offset);
			r_anal_esil_parse (esil, input + 2);
			r_anal_esil_dumpstack (esil);
			r_anal_esil_free (esil);
			break;
		}
		case 's': // ""aets""
			switch (input[2]) {
			case 0:
				r_anal_esil_session_list (esil);
				break;
			case '+':
				r_anal_esil_session_add (esil);
				break;
			default:
				r_core_cmd_help (core, help_msg_aets);
				break;
			}
			break;
		default:
			eprintf (""Unknown command. Use `aetr`.\n"");
			break;
		}
		break;
	case 'A': // ""aeA""
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_aea);
		} else if (input[1] == 'r') {
			cmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'w') {
			cmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'n') {
			cmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'j') {
			cmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == '*') {
			cmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'f') {
			RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
			if (fcn) {
				cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));
			}
		} else {
			cmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input+2));
		}
		break;
	case 'a': // ""aea""
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_aea);
		} else if (input[1] == 'r') {
			cmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'w') {
			cmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'n') {
			cmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'j') {
			cmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == '*') {
			cmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));
		} else if (input[1] == 'f') {
			RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
                        // ""aeafj""
			if (fcn) {
				switch (input[2]) {
				case 'j': // ""aeafj""
					cmd_aea (core, 1<<4, fcn->addr, r_anal_fcn_size (fcn));
					break;
				default:
					cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));
					break;
				}
				break;
			}
		} else {
			const char *arg = input[1]? input + 2: """";
			ut64 len = r_num_math (core->num, arg);
			cmd_aea (core, 0, core->offset, len);
		}
		break;
	case 'x': { // ""aex""
		char *hex;
		int ret, bufsz;

		input = r_str_trim_ro (input + 1);
		hex = strdup (input);
		if (!hex) {
			break;
		}

		RAnalOp aop = R_EMPTY;
		bufsz = r_hex_str2bin (hex, (ut8*)hex);
		ret = r_anal_op (core->anal, &aop, core->offset,
			(const ut8*)hex, bufsz, R_ANAL_OP_MASK_ALL);
		if (ret>0) {
			const char *str = R_STRBUF_SAFEGET (&aop.esil);
			char *str2 = r_str_newf ("" %s"", str);
			cmd_anal_esil (core, str2);
			free (str2);
		}
		r_anal_op_fini (&aop);
		break;
	}
	case '?': // ""ae?""
		if (input[1] == '?') {
			r_core_cmd_help (core, help_detail_ae);
			break;
		}
		/* fallthrough */
	default:
		r_core_cmd_help (core, help_msg_ae);
		break;
	}
}","static void cmd_anal_esil(RCore *VAR_0, const char *VAR_1) {
	RAnalEsil *VAR_2 = VAR_0->anal->esil;
	ut64 VAR_3 = VAR_0->offset;
	ut64 VAR_4 ;
	char *VAR_5, *VAR_6;
	int VAR_7;
	int VAR_8 = r_config_get_i (VAR_0->config, ""esil.stack.depth"");
	int VAR_9 = r_config_get_i (VAR_0->config, ""esil.iotrap"");
	int VAR_10 = r_config_get_i (VAR_0->config, ""esil.romem"");
	int VAR_11 = r_config_get_i (VAR_0->config, ""esil.stats"");
	int VAR_12 = r_config_get_i (VAR_0->config, ""esil.noNULL"");
	ut64 VAR_13 = VAR_14;
	unsigned int VAR_15 = r_config_get_i (VAR_0->config, ""esil.addr.size"");

	const char *VAR_16 = NULL;
	RAnalOp *VAR_17;

	switch (VAR_1[0]) {
	case 'p': /* COMMENT_0 */
		switch (VAR_1[1]) {
		case 'c':
			if (VAR_1[2] == ' ') {
				/* COMMENT_1 */
				r_core_cmdf (VAR_0, ""ar PC=%s"", VAR_1 + 3);
				r_core_cmd0 (VAR_0, "".ar*"");
			} else {
				eprintf (""Missing argument\n"");
			}
			break;
		case 0:
			r_anal_pin_list (VAR_0->anal);
			break;
		case '-':
			if (VAR_1[2])
				VAR_3 = r_num_math (VAR_0->num, VAR_1 + 2);
			r_anal_pin_unset (VAR_0->anal, VAR_3);
			break;
		case ' ':
			r_anal_pin (VAR_0->anal, VAR_3, VAR_1 + 2);
			break;
		default:
			r_core_cmd_help (VAR_0, VAR_18);
			break;
		}
		break;
	case 'r': /* COMMENT_2 */
		/* COMMENT_3 */
		cmd_anal_reg (VAR_0, VAR_1 + 1);
		break;
	case '*':
		/* COMMENT_4 */
		if (VAR_0->anal->esil) {
			r_cons_printf (""trap: %d\n"", VAR_0->anal->esil->trap);
			r_cons_printf (""trap-code: %d\n"", VAR_0->anal->esil->trap_code);
		} else {
			eprintf (""esil vm not initialized. run `aei`\n"");
		}
		break;
	case ' ':
		/* COMMENT_5 */
		if (!VAR_2) {
			if (!(VAR_0->anal->esil = VAR_2 = r_anal_esil_new (VAR_8, VAR_9, VAR_15)))
				return;
		}
		r_anal_esil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11, VAR_12); /* COMMENT_6 */
		r_anal_esil_set_pc (VAR_2, VAR_0->offset);
		r_anal_esil_parse (VAR_2, VAR_1 + 1);
		r_anal_esil_dumpstack (VAR_2);
		r_anal_esil_stack_free (VAR_2);
		break;
	case 's': /* COMMENT_7 */
		/* COMMENT_8 */
		/* COMMENT_9 */
		/* COMMENT_10 */
		/* COMMENT_11 */
		/* COMMENT_12 */
		/* COMMENT_13 */
		switch (VAR_1[1]) {
		case '?':
			eprintf (""See: ae?~aes\n"");
			break;
		case 'l': /* COMMENT_14 */
		{
			ut64 VAR_19 = r_debug_reg_get (VAR_0->dbg, ""PC"");
			RAnalOp *VAR_17 = r_core_anal_op (VAR_0, VAR_19);
/* COMMENT_15 */
			if (!VAR_17) {
				break;
			}
			r_core_esil_step (VAR_0, VAR_14, NULL, NULL);
			r_debug_reg_set (VAR_0->dbg, ""PC"", VAR_19 + VAR_17->size);
			r_anal_esil_set_pc (VAR_2, VAR_19 + VAR_17->size);
			r_core_cmd0 (VAR_0, "".ar*"");
		} break;
		case 'b': /* COMMENT_16 */
			if (!r_core_esil_step_back (VAR_0)) {
				eprintf (""cannnot step back\n"");
			}
			r_core_cmd0 (VAR_0, "".ar*"");
			break;
		case 'u': /* COMMENT_17 */
			if (VAR_1[2] == 'e') {
				VAR_16 = VAR_1 + 3;
			} else {
				VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);
			}
			r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
			r_core_cmd0 (VAR_0, "".ar*"");
			break;
		case 'o': /* COMMENT_18 */
			/* COMMENT_19 */
			VAR_17 = r_core_anal_op (VAR_0, r_reg_getv (VAR_0->anal->reg,
				r_reg_get_name (VAR_0->anal->reg, VAR_20)));
			if (VAR_17 && VAR_17->type == VAR_21) {
				VAR_13 = VAR_17->addr + VAR_17->size;
			}
			r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
			r_anal_op_free (VAR_17);
			r_core_cmd0 (VAR_0, "".ar*"");
			break;
		case 'p': /* COMMENT_20 */
			VAR_5 = strchr (VAR_1, ' ');
			VAR_6 = VAR_5 ? strchr (VAR_5 + 1, ' ') : NULL;
			if ((!VAR_5 || !VAR_6) || (!(VAR_5 + 1) || !(VAR_6 + 1))) {
				eprintf (""aesp [offset] [num]\n"");
				break;
			}
			VAR_4 = r_num_math (VAR_0->num, VAR_5 + 1);
			VAR_7 = r_num_math (VAR_0->num, VAR_6 + 1);
			cmd_aespc (VAR_0, VAR_4, VAR_7);
			break;
		case ' ':
			VAR_5 = strchr (VAR_1, ' ');
			if (!(VAR_5 + 1)) {
				r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
				break;
			}
			VAR_7 = r_num_math (VAR_0->num, VAR_5 + 1);
			cmd_aespc (VAR_0, -1, VAR_7);
			break;
		default:
			r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
			r_core_cmd0 (VAR_0, "".ar*"");
			break;
		}
		break;
	case 'c': /* COMMENT_21 */
		if (VAR_1[1] == '?') { /* COMMENT_22 */
			r_core_cmd_help (VAR_0, VAR_22);
		} else if (VAR_1[1] == 's') { /* COMMENT_23 */
			const char *VAR_19 = r_reg_get_name (VAR_0->anal->reg, VAR_20);
			ut64 VAR_23;
			int VAR_24;
			for (;;) {
				VAR_17 = r_core_anal_op (VAR_0, VAR_3);
				if (!VAR_17) {
					break;
				}
				if (VAR_17->type == VAR_25) {
					eprintf (""syscall at 0x%08"" VAR_26 ""\n"", VAR_3);
					break;
				}
				if (VAR_17->type == VAR_27) {
					eprintf (""trap at 0x%08"" VAR_26 ""\n"", VAR_3);
					break;
				}
				VAR_24 = r_core_esil_step (VAR_0, VAR_14, NULL, NULL);
				r_anal_op_free (VAR_17);
				VAR_17 = NULL;
				if (VAR_0->anal->esil->trap || VAR_0->anal->esil->trap_code) {
					break;
				}
				if (!VAR_24)
					break;
				r_core_cmd0 (VAR_0, "".ar*"");
				VAR_23 = r_num_get (VAR_0->num, VAR_19);
				if (VAR_3 == VAR_23) {
					VAR_3++;
					break;
				} else {
					VAR_3 = VAR_23;
				}
			}
			if (VAR_17) {
				r_anal_op_free (VAR_17);
			}
		} else {
			/* COMMENT_24 */
			/* COMMENT_25 */
			/* COMMENT_26 */
			if (VAR_1[1] == 'u' && VAR_1[2] == 'e')
				VAR_16 = VAR_1 + 3;
			else if (VAR_1[1] == 'u')
				VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);
			else VAR_16 = ""0"";
			r_core_esil_step (VAR_0, VAR_13, VAR_16, NULL);
			r_core_cmd0 (VAR_0, "".ar*"");
		}
		break;
	case 'i': /* COMMENT_27 */
		switch (VAR_1[1]) {
		case 's':
		case 'm': /* COMMENT_28 */
			cmd_esil_mem (VAR_0, VAR_1 + 2);
			break;
		case 'p': /* COMMENT_29 */
			r_core_cmd0 (VAR_0, ""ar PC=$$"");
			break;
		case '?':
			cmd_esil_mem (VAR_0, ""?"");
			break;
		case '-':
			if (VAR_2) {
				sdb_reset (VAR_2->stats);
			}
			r_anal_esil_free (VAR_2);
			VAR_0->anal->esil = NULL;
			break;
		case 0:				/* COMMENT_30 */
			r_anal_esil_free (VAR_2);
			/* COMMENT_31 */
			{
				const char *VAR_19 = r_reg_get_name (VAR_0->anal->reg, VAR_20);
				if (r_reg_getv (VAR_0->anal->reg, VAR_19) == 0LL) {
					r_core_cmd0 (VAR_0, ""ar PC=$$"");
				}
			}
			if (!(VAR_2 = VAR_0->anal->esil = r_anal_esil_new (VAR_8, VAR_9, VAR_15))) {
				return;
			}
			r_anal_esil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11, VAR_12); /* COMMENT_6 */
			VAR_2->verbose = (int)r_config_get_i (VAR_0->config, ""esil.verbose"");
			/* COMMENT_32 */
			{
				const char *VAR_28 = r_config_get (VAR_0->config, ""cmd.esil.intr"");
				if (VAR_28) {
					char *VAR_29 = strdup (VAR_28);
					if (VAR_29) {
						r_config_set (VAR_0->config, ""cmd.esil.intr"", VAR_29);
						free (VAR_29);
					}
				}
			}
			break;
		}
		break;
	case 'k': /* COMMENT_33 */
		switch (VAR_1[1]) {
		case '\0':
			VAR_1 = ""123*"";
			/* COMMENT_34 */
		case ' ':
			if (VAR_2 && VAR_2->stats) {
				char *VAR_30 = sdb_querys (VAR_2->stats, NULL, 0, VAR_1 + 2);
				if (VAR_30) {
					r_cons_println (VAR_30);
					free (VAR_30);
				}
			} else {
				eprintf (""esil.stats is empty. Run 'aei'\n"");
			}
			break;
		case '-':
			if (VAR_2) {
				sdb_reset (VAR_2->stats);
			}
			break;
		}
		break;
	case 'f': /* COMMENT_35 */
	{
		RListIter *VAR_31;
		RAnalBlock *VAR_32;
		RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal,
							VAR_0->offset, VAR_34 | VAR_35);
		if (VAR_33) {
			/* COMMENT_36 */
			r_list_foreach (VAR_33->bbs, VAR_31, VAR_32) {
				ut64 VAR_19 = VAR_32->addr;
				ut64 VAR_36 = VAR_32->addr + VAR_32->size;
				RAnalOp VAR_17;
				ut8 *VAR_37;
				int VAR_24, VAR_38 = VAR_36 - VAR_19;
				if (VAR_38 < 1 || VAR_38 > 0xfffff) {
					eprintf (""Invalid block size\n"");
				}
		/* COMMENT_37 */
				VAR_37 = calloc (1, VAR_38 + 1);
				r_io_read_at (VAR_0->io, VAR_19, VAR_37, VAR_38);
				int VAR_39;
				while (VAR_19 < VAR_36) {
					VAR_39 = R_MIN (VAR_36 - VAR_19, 32);
					r_asm_set_pc (VAR_0->assembler, VAR_19);
					VAR_24 = r_anal_op (VAR_0->anal, &VAR_17, VAR_3, VAR_37, VAR_39, VAR_40); /* COMMENT_38 */
					if (VAR_24) {
						r_reg_set_value_by_role (VAR_0->anal->reg, VAR_20, VAR_19);
						r_anal_esil_parse (VAR_2, R_STRBUF_SAFEGET (&VAR_17.esil));
						r_anal_esil_dumpstack (VAR_2);
						r_anal_esil_stack_free (VAR_2);
						VAR_19 += VAR_17.size;
					} else {
						VAR_19 += 4; /* COMMENT_39 */
					}
				}
			}
		} else {
			eprintf (""Cannot find function at 0x%08"" VAR_26 ""\n"", VAR_0->offset);
		}
	} break;
	case 't': /* COMMENT_40 */
		switch (VAR_1[1]) {
		case 'r': /* COMMENT_41 */
		{
			/* COMMENT_42 */
			RAnalEsil *VAR_2 = r_anal_esil_new (VAR_8, VAR_9, VAR_15);
			if (!VAR_2) {
				return;
			}
			r_anal_esil_to_reil_setup (VAR_2, VAR_0->anal, VAR_10, VAR_11);
			r_anal_esil_set_pc (VAR_2, VAR_0->offset);
			r_anal_esil_parse (VAR_2, VAR_1 + 2);
			r_anal_esil_dumpstack (VAR_2);
			r_anal_esil_free (VAR_2);
			break;
		}
		case 's': /* COMMENT_43 */
			switch (VAR_1[2]) {
			case 0:
				r_anal_esil_session_list (VAR_2);
				break;
			case '+':
				r_anal_esil_session_add (VAR_2);
				break;
			default:
				r_core_cmd_help (VAR_0, VAR_41);
				break;
			}
			break;
		default:
			eprintf (""Unknown command. Use `aetr`.\n"");
			break;
		}
		break;
	case 'A': /* COMMENT_44 */
		if (VAR_1[1] == '?') {
			r_core_cmd_help (VAR_0, VAR_42);
		} else if (VAR_1[1] == 'r') {
			cmd_aea (VAR_0, 1 + (1<<1), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'w') {
			cmd_aea (VAR_0, 1 + (1<<2), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'n') {
			cmd_aea (VAR_0, 1 + (1<<3), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'j') {
			cmd_aea (VAR_0, 1 + (1<<4), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == '*') {
			cmd_aea (VAR_0, 1 + (1<<5), VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'f') {
			RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, -1);
			if (VAR_33) {
				cmd_aea (VAR_0, 1, VAR_33->addr, r_anal_fcn_size (VAR_33));
			}
		} else {
			cmd_aea (VAR_0, 1, VAR_0->offset, (int)r_num_math (VAR_0->num, VAR_1+2));
		}
		break;
	case 'a': /* COMMENT_45 */
		if (VAR_1[1] == '?') {
			r_core_cmd_help (VAR_0, VAR_42);
		} else if (VAR_1[1] == 'r') {
			cmd_aea (VAR_0, 1<<1, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'w') {
			cmd_aea (VAR_0, 1<<2, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'n') {
			cmd_aea (VAR_0, 1<<3, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'j') {
			cmd_aea (VAR_0, 1<<4, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == '*') {
			cmd_aea (VAR_0, 1<<5, VAR_0->offset, r_num_math (VAR_0->num, VAR_1+2));
		} else if (VAR_1[1] == 'f') {
			RAnalFunction *VAR_33 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, -1);
                        /* COMMENT_46 */
			if (VAR_33) {
				switch (VAR_1[2]) {
				case 'j': /* COMMENT_46 */
					cmd_aea (VAR_0, 1<<4, VAR_33->addr, r_anal_fcn_size (VAR_33));
					break;
				default:
					cmd_aea (VAR_0, 1, VAR_33->addr, r_anal_fcn_size (VAR_33));
					break;
				}
				break;
			}
		} else {
			const char *VAR_43 = VAR_1[1]? VAR_1 + 2: """";
			ut64 VAR_44 = r_num_math (VAR_0->num, VAR_43);
			cmd_aea (VAR_0, 0, VAR_0->offset, VAR_44);
		}
		break;
	case 'x': { /* COMMENT_47 */
		char *VAR_45;
		int VAR_24, VAR_46;

		VAR_1 = r_str_trim_ro (VAR_1 + 1);
		VAR_45 = strdup (VAR_1);
		if (!VAR_45) {
			break;
		}

		RAnalOp VAR_47 = VAR_48;
		VAR_46 = r_hex_str2bin (VAR_45, (ut8*)VAR_45);
		VAR_24 = r_anal_op (VAR_0->anal, &VAR_47, VAR_0->offset,
			(const ut8*)VAR_45, VAR_46, VAR_40);
		if (VAR_24>0) {
			const char *VAR_49 = R_STRBUF_SAFEGET (&VAR_47.esil);
			char *VAR_50 = r_str_newf ("" %s"", VAR_49);
			cmd_anal_esil (VAR_0, VAR_50);
			free (VAR_50);
		}
		r_anal_op_fini (&VAR_47);
		break;
	}
	case '?': /* COMMENT_48 */
		if (VAR_1[1] == '?') {
			r_core_cmd_help (VAR_0, VAR_51);
			break;
		}
		/* COMMENT_49 */
	default:
		r_core_cmd_help (VAR_0, VAR_52);
		break;
	}
}",radareorg/radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/cmd_anal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -313,8 +313,9 @@
 		{
 			// anal ESIL to REIL.
 			RAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);
-			if (!esil)
+			if (!esil) {
 				return;
+			}
 			r_anal_esil_to_reil_setup (esil, core->anal, romem, stats);
 			r_anal_esil_set_pc (esil, core->offset);
 			r_anal_esil_parse (esil, input + 2);","{'deleted_lines': ['\t\t\tif (!esil)'], 'added_lines': ['\t\t\tif (!esil) {', '\t\t\t}']}",True,The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.,5.5,MEDIUM,1,valid,2018-04-24T07:55:19Z,2
CVE-2018-10528,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,LibRaw,X3F parser possible buffer overrun,efd8cfabb93fd0396266a7607069901657c082e3,https://github.com/LibRaw/LibRaw/commit/efd8cfabb93fd0396266a7607069901657c082e3,src/libraw_cxx.cpp,LibRaw::parse_x3f,"void LibRaw::parse_x3f()
{
x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);
if(!x3f)
return;
_x3f_data = x3f;
x3f_header_t *H = NULL;
x3f_directory_section_t *DS = NULL;
H = &x3f->header;
x3f_directory_entry_t *DE = x3f_get_raw(x3f);
if(!DE) return;
imgdata.sizes.flip = H->rotation;
x3f_directory_entry_header_t *DEH = &DE->header;
x3f_image_data_t *ID = &DEH->data_subsection.image_data;
imgdata.sizes.raw_width = ID->columns;
imgdata.sizes.raw_height = ID->rows;
DE = x3f_get_prop(x3f);
if((x3f_load_data(x3f,DE) == X3F_OK))
{
DEH = &DE->header;
x3f_property_list_t *PL = &DEH->data_subsection.property_list;
if (PL->property_table.size != 0) {
int i;
x3f_property_t *P = PL->property_table.element;
for (i=0; i<PL->num_properties; i++) {
char name[100], value[100];
utf2char(P[i].name,name);
utf2char(P[i].value,value);
if (!strcmp (name, ""ISO""))
imgdata.other.iso_speed = atoi(value);
if (!strcmp (name, ""CAMMANUF""))
strcpy (imgdata.idata.make, value);
if (!strcmp (name, ""CAMMODEL""))
strcpy (imgdata.idata.model, value);
if (!strcmp (name, ""CAMSERIAL""))
strcpy (imgdata.shootinginfo.BodySerial, value);
if (!strcmp (name, ""WB_DESC""))
strcpy (imgdata.color.model2, value);
if (!strcmp (name, ""TIME""))
imgdata.other.timestamp = atoi(value);
if (!strcmp (name, ""SHUTTER""))
imgdata.other.shutter = atof(value);
if (!strcmp (name, ""APERTURE""))
imgdata.other.aperture = atof(value);
if (!strcmp (name, ""FLENGTH""))
imgdata.other.focal_len = atof(value);
if (!strcmp (name, ""FLEQ35MM""))
imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);
if (!strcmp (name, ""LENSARANGE""))
{
char *sp;
imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);
sp = strrchr (value, ' ');
if (sp)
{
imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);
if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)
my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);
}
}
if (!strcmp (name, ""LENSFRANGE""))
{
char *sp;
imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);
sp = strrchr (value, ' ');
if (sp)
{
imgdata.lens.makernotes.MaxFocal = atof(sp);
if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)
my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);
}
}
if (!strcmp (name, ""LENSMODEL""))
{
char *sp;
imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); if (imgdata.lens.makernotes.LensID)
imgdata.lens.makernotes.LensMount = Sigma_X3F;
}
}
imgdata.idata.raw_count=1;
load_raw = &LibRaw::x3f_load_raw;
imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;
imgdata.idata.is_foveon = 1;
libraw_internal_data.internal_output_params.raw_color=1;   imgdata.color.maximum=0x3fff;   libraw_internal_data.unpacker_data.order = 0x4949;
}
}
else
{
if(imgdata.sizes.raw_width == 5888 ||imgdata.sizes.raw_width == 2944 
|| imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328   
|| imgdata.sizes.raw_width == 5504 ||imgdata.sizes.raw_width == 2752   
)   {
imgdata.idata.raw_count=1;
load_raw = &LibRaw::x3f_load_raw;
imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;
imgdata.idata.is_foveon = 1;
libraw_internal_data.internal_output_params.raw_color=1;   libraw_internal_data.unpacker_data.order = 0x4949;
strcpy (imgdata.idata.make, ""SIGMA"");
#if 1
int pos = libraw_internal_data.internal_data.input->tell();
libraw_internal_data.internal_data.input->seek(0,SEEK_SET);
unsigned char buf[2048];
libraw_internal_data.internal_data.input->read(buf,2048,1);
libraw_internal_data.internal_data.input->seek(pos,SEEK_SET);
unsigned char *fnd=(unsigned char*)lr_memmem(buf,2048,""SIGMA dp"",8);
unsigned char *fndsd=(unsigned char*)lr_memmem(buf,2048,""sd Quatt"",8);
if(fnd)
{
unsigned char *nm = fnd+8;
snprintf(imgdata.idata.model,64,""dp%c Quattro"",*nm<='9' && *nm >='0' ? *nm: '2');
}
else if(fndsd)
{
snprintf(imgdata.idata.model,64,""%s"",fndsd);
}
else
#endif
if(imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 )
strcpy (imgdata.idata.model, ""sd Quattro H"");
else
strcpy (imgdata.idata.model, ""dp2 Quattro"");
}
}
LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;
if( (DE = x3f_get_thumb_jpeg(x3f)))
{
format = LIBRAW_THUMBNAIL_JPEG;
}
else if( (DE = x3f_get_thumb_plain(x3f)))
{
format = LIBRAW_THUMBNAIL_BITMAP;
}
if(DE)
{
x3f_directory_entry_header_t *DEH = &DE->header;
x3f_image_data_t *ID = &DEH->data_subsection.image_data;
imgdata.thumbnail.twidth = ID->columns;
imgdata.thumbnail.theight = ID->rows;
imgdata.thumbnail.tcolors = 3;
imgdata.thumbnail.tformat = format;
libraw_internal_data.internal_data.toffset = DE->input.offset;
write_thumb = &LibRaw::x3f_thumb_loader;
}
}","void LibRaw::parse_x3f()
{
x3f_t *VAR_0 = x3f_new_from_file(VAR_1.internal_data.input);
if(!VAR_0)
return;
VAR_2 = VAR_0;
x3f_header_t *VAR_3 = NULL;
x3f_directory_section_t *VAR_4 = NULL;
VAR_3 = &VAR_0->header;
x3f_directory_entry_t *VAR_5 = x3f_get_raw(VAR_0);
if(!VAR_5) return;
VAR_6.sizes.flip = VAR_3->rotation;
x3f_directory_entry_header_t *VAR_7 = &VAR_5->header;
x3f_image_data_t *VAR_8 = &VAR_7->data_subsection.image_data;
VAR_6.sizes.raw_width = VAR_8->columns;
VAR_6.sizes.raw_height = VAR_8->rows;
VAR_5 = x3f_get_prop(VAR_0);
if((x3f_load_data(VAR_0,VAR_5) == VAR_9))
{
VAR_7 = &VAR_5->header;
x3f_property_list_t *VAR_10 = &VAR_7->data_subsection.property_list;
if (VAR_10->property_table.size != 0) {
int VAR_11;
x3f_property_t *VAR_12 = VAR_10->property_table.element;
for (VAR_11=0; VAR_11<VAR_10->num_properties; VAR_11++) {
char VAR_13[100], VAR_14[100];
utf2char(VAR_12[VAR_11].name,VAR_13);
utf2char(VAR_12[VAR_11].value,VAR_14);
if (!strcmp (VAR_13, ""ISO""))
VAR_6.other.iso_speed = atoi(VAR_14);
if (!strcmp (VAR_13, ""CAMMANUF""))
strcpy (VAR_6.idata.make, VAR_14);
if (!strcmp (VAR_13, ""CAMMODEL""))
strcpy (VAR_6.idata.model, VAR_14);
if (!strcmp (VAR_13, ""CAMSERIAL""))
strcpy (VAR_6.shootinginfo.BodySerial, VAR_14);
if (!strcmp (VAR_13, ""WB_DESC""))
strcpy (VAR_6.color.model2, VAR_14);
if (!strcmp (VAR_13, ""TIME""))
VAR_6.other.timestamp = atoi(VAR_14);
if (!strcmp (VAR_13, ""SHUTTER""))
VAR_6.other.shutter = atof(VAR_14);
if (!strcmp (VAR_13, ""APERTURE""))
VAR_6.other.aperture = atof(VAR_14);
if (!strcmp (VAR_13, ""FLENGTH""))
VAR_6.other.focal_len = atof(VAR_14);
if (!strcmp (VAR_13, ""FLEQ35MM""))
VAR_6.lens.makernotes.FocalLengthIn35mmFormat = atof(VAR_14);
if (!strcmp (VAR_13, ""LENSARANGE""))
{
char *VAR_15;
VAR_6.lens.makernotes.MaxAp4CurFocal = VAR_6.lens.makernotes.MinAp4CurFocal = atof(VAR_14);
VAR_15 = strrchr (VAR_14, ' ');
if (VAR_15)
{
VAR_6.lens.makernotes.MinAp4CurFocal = atof(VAR_15);
if (VAR_6.lens.makernotes.MaxAp4CurFocal > VAR_6.lens.makernotes.MinAp4CurFocal)
my_swap (float, VAR_6.lens.makernotes.MaxAp4CurFocal, VAR_6.lens.makernotes.MinAp4CurFocal);
}
}
if (!strcmp (VAR_13, ""LENSFRANGE""))
{
char *VAR_15;
VAR_6.lens.makernotes.MinFocal = VAR_6.lens.makernotes.MaxFocal = atof(VAR_14);
VAR_15 = strrchr (VAR_14, ' ');
if (VAR_15)
{
VAR_6.lens.makernotes.MaxFocal = atof(VAR_15);
if ((VAR_6.lens.makernotes.MaxFocal + 0.17f) < VAR_6.lens.makernotes.MinFocal)
my_swap (float, VAR_6.lens.makernotes.MaxFocal, VAR_6.lens.makernotes.MinFocal);
}
}
if (!strcmp (VAR_13, ""LENSMODEL""))
{
char *VAR_15;
VAR_6.lens.makernotes.LensID = strtol (VAR_14, &VAR_15, 16); 
if (VAR_6.lens.makernotes.LensID)
VAR_6.lens.makernotes.LensMount = VAR_16;
}
}
VAR_6.idata.raw_count=1;
VAR_17 = &LibRaw::x3f_load_raw;
VAR_6.sizes.raw_pitch = VAR_6.sizes.raw_width*6;
VAR_6.idata.is_foveon = 1;
VAR_1.internal_output_params.raw_color=1; 
VAR_6.color.maximum=0x3fff; 
VAR_1.unpacker_data.order = 0x4949;
}
}
else
{
if(VAR_6.sizes.raw_width == 5888 ||VAR_6.sizes.raw_width == 2944 
|| VAR_6.sizes.raw_width == 6656 ||VAR_6.sizes.raw_width == 3328   
|| VAR_6.sizes.raw_width == 5504 ||VAR_6.sizes.raw_width == 2752   
) 
{
VAR_6.idata.raw_count=1;
VAR_17 = &LibRaw::x3f_load_raw;
VAR_6.sizes.raw_pitch = VAR_6.sizes.raw_width*6;
VAR_6.idata.is_foveon = 1;
VAR_1.internal_output_params.raw_color=1; 
VAR_1.unpacker_data.order = 0x4949;
strcpy (VAR_6.idata.make, ""SIGMA"");
#if 1
int VAR_18 = VAR_1.internal_data.input->tell();
VAR_1.internal_data.input->seek(0,VAR_19);
unsigned char VAR_20[2048];
VAR_1.internal_data.input->read(VAR_20,2048,1);
VAR_1.internal_data.input->seek(VAR_18,VAR_19);
unsigned char *VAR_21=(unsigned char*)lr_memmem(VAR_20,2048,""SIGMA dp"",8);
unsigned char *VAR_22=(unsigned char*)lr_memmem(VAR_20,2048,""sd Quatt"",8);
if(VAR_21)
{
unsigned char *VAR_23 = VAR_21+8;
snprintf(VAR_6.idata.model,64,""dp%c Quattro"",*VAR_23<='9' && *VAR_23 >='0' ? *VAR_23: '2');
}
else if(VAR_22)
{
snprintf(VAR_6.idata.model,64,""%s"",VAR_22);
}
else
#endif
if(VAR_6.sizes.raw_width == 6656 ||VAR_6.sizes.raw_width == 3328 )
strcpy (VAR_6.idata.model, ""sd Quattro H"");
else
strcpy (VAR_6.idata.model, ""dp2 Quattro"");
}
}
LibRaw_thumbnail_formats VAR_24 = VAR_25;
if( (VAR_5 = x3f_get_thumb_jpeg(VAR_0)))
{
VAR_24 = VAR_26;
}
else if( (VAR_5 = x3f_get_thumb_plain(VAR_0)))
{
VAR_24 = VAR_27;
}
if(VAR_5)
{
x3f_directory_entry_header_t *VAR_7 = &VAR_5->header;
x3f_image_data_t *VAR_8 = &VAR_7->data_subsection.image_data;
VAR_6.thumbnail.twidth = VAR_8->columns;
VAR_6.thumbnail.theight = VAR_8->rows;
VAR_6.thumbnail.tcolors = 3;
VAR_6.thumbnail.tformat = VAR_24;
VAR_1.internal_data.toffset = VAR_5->input.offset;
VAR_28 = &LibRaw::x3f_thumb_loader;
}
}",LibRaw/efd8cfabb93fd0396266a7607069901657c082e3/libraw_cxx.cpp/vul/before/0.json,"void LibRaw::parse_x3f()
{
  x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);
  if(!x3f)
      return;
  _x3f_data = x3f;

  x3f_header_t *H = NULL;
  x3f_directory_section_t *DS = NULL;

  H = &x3f->header;
  // Parse RAW size from RAW section
  x3f_directory_entry_t *DE = x3f_get_raw(x3f);
  if(!DE) return;
  imgdata.sizes.flip = H->rotation;
  x3f_directory_entry_header_t *DEH = &DE->header;
  x3f_image_data_t *ID = &DEH->data_subsection.image_data;
  imgdata.sizes.raw_width = ID->columns;
  imgdata.sizes.raw_height = ID->rows;
  // Parse other params from property section
  DE = x3f_get_prop(x3f);
  if((x3f_load_data(x3f,DE) == X3F_OK))
  {
	  // Parse property list
	  DEH = &DE->header;
	  x3f_property_list_t *PL = &DEH->data_subsection.property_list;
	  if (PL->property_table.size != 0) {
		  int i;
		  x3f_property_t *P = PL->property_table.element;
		  for (i=0; i<PL->num_properties; i++) {
			  char name[100], value[100];
			  utf2char(P[i].name,name,sizeof(name));
			  utf2char(P[i].value,value,sizeof(value));
			  if (!strcmp (name, ""ISO""))
				  imgdata.other.iso_speed = atoi(value);
			  if (!strcmp (name, ""CAMMANUF""))
				  strcpy (imgdata.idata.make, value);
			  if (!strcmp (name, ""CAMMODEL""))
				  strcpy (imgdata.idata.model, value);
			  if (!strcmp (name, ""CAMSERIAL""))
				  strcpy (imgdata.shootinginfo.BodySerial, value);
			  if (!strcmp (name, ""WB_DESC""))
				  strcpy (imgdata.color.model2, value);
			  if (!strcmp (name, ""TIME""))
				  imgdata.other.timestamp = atoi(value);
			  if (!strcmp (name, ""SHUTTER""))
				  imgdata.other.shutter = atof(value);
			  if (!strcmp (name, ""APERTURE""))
				  imgdata.other.aperture = atof(value);
			  if (!strcmp (name, ""FLENGTH""))
				  imgdata.other.focal_len = atof(value);
				if (!strcmp (name, ""FLEQ35MM""))
				  imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);
				if (!strcmp (name, ""LENSARANGE""))
				{
				  char *sp;
				  imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);
				  sp = strrchr (value, ' ');
				  if (sp)
				    {
				      imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);
				      if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)
				        my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);
				    }
				}
				if (!strcmp (name, ""LENSFRANGE""))
				{
					char *sp;
					imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);
					sp = strrchr (value, ' ');
					if (sp)
						{
							imgdata.lens.makernotes.MaxFocal = atof(sp);
							if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)
								my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);
						}
				}
				if (!strcmp (name, ""LENSMODEL""))
				{
					char *sp;
                                        imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);
					if (imgdata.lens.makernotes.LensID)
					 imgdata.lens.makernotes.LensMount = Sigma_X3F;
				}
		  }
		  imgdata.idata.raw_count=1;
		  load_raw = &LibRaw::x3f_load_raw;
		  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;
		  imgdata.idata.is_foveon = 1;
		  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff
		  imgdata.color.maximum=0x3fff; // To be reset by color table
		  libraw_internal_data.unpacker_data.order = 0x4949;
	  }
  }
  else
  {
	  // No property list
	  if(imgdata.sizes.raw_width == 5888 ||imgdata.sizes.raw_width == 2944 
		  || imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 	  
		  || imgdata.sizes.raw_width == 5504 ||imgdata.sizes.raw_width == 2752 	  
		  ) // Quattro
	  {
		  imgdata.idata.raw_count=1;
		  load_raw = &LibRaw::x3f_load_raw;
		  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;
		  imgdata.idata.is_foveon = 1;
		  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff
		  libraw_internal_data.unpacker_data.order = 0x4949;
		  strcpy (imgdata.idata.make, ""SIGMA"");
#if 1
		  // Try to find model number in first 2048 bytes;
		  int pos = libraw_internal_data.internal_data.input->tell();
		  libraw_internal_data.internal_data.input->seek(0,SEEK_SET);
		  unsigned char buf[2048];
		  libraw_internal_data.internal_data.input->read(buf,2048,1);
		  libraw_internal_data.internal_data.input->seek(pos,SEEK_SET);
		  unsigned char *fnd=(unsigned char*)lr_memmem(buf,2048,""SIGMA dp"",8);
		  unsigned char *fndsd=(unsigned char*)lr_memmem(buf,2048,""sd Quatt"",8);
		  if(fnd)
		  {
			  unsigned char *nm = fnd+8;
			  snprintf(imgdata.idata.model,64,""dp%c Quattro"",*nm<='9' && *nm >='0' ? *nm: '2');
		  }
		  else if(fndsd)
		  {
			  snprintf(imgdata.idata.model,64,""%s"",fndsd);
		  }
		  else
#endif
		  if(imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 )
			strcpy (imgdata.idata.model, ""sd Quattro H"");
		  else
			strcpy (imgdata.idata.model, ""dp2 Quattro"");
	  }
	  //else
  }
  // Try to get thumbnail data
  LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;
  if( (DE = x3f_get_thumb_jpeg(x3f)))
    {
      format = LIBRAW_THUMBNAIL_JPEG;
    }
  else if( (DE = x3f_get_thumb_plain(x3f)))
    {
      format = LIBRAW_THUMBNAIL_BITMAP;
    }
  if(DE)
    {
      x3f_directory_entry_header_t *DEH = &DE->header;
      x3f_image_data_t *ID = &DEH->data_subsection.image_data;
      imgdata.thumbnail.twidth = ID->columns;
      imgdata.thumbnail.theight = ID->rows;
      imgdata.thumbnail.tcolors = 3;
      imgdata.thumbnail.tformat = format;
      libraw_internal_data.internal_data.toffset = DE->input.offset;
      write_thumb = &LibRaw::x3f_thumb_loader;
    }
}","void LibRaw::parse_x3f()
{
  x3f_t *VAR_0 = x3f_new_from_file(VAR_1.internal_data.input);
  if(!VAR_0)
      return;
  VAR_2 = VAR_0;

  x3f_header_t *VAR_3 = NULL;
  x3f_directory_section_t *VAR_4 = NULL;

  VAR_3 = &VAR_0->header;
  /* COMMENT_0 */
  x3f_directory_entry_t *VAR_5 = x3f_get_raw(VAR_0);
  if(!VAR_5) return;
  VAR_6.sizes.flip = VAR_3->rotation;
  x3f_directory_entry_header_t *VAR_7 = &VAR_5->header;
  x3f_image_data_t *VAR_8 = &VAR_7->data_subsection.image_data;
  VAR_6.sizes.raw_width = VAR_8->columns;
  VAR_6.sizes.raw_height = VAR_8->rows;
  /* COMMENT_1 */
  VAR_5 = x3f_get_prop(VAR_0);
  if((x3f_load_data(VAR_0,VAR_5) == VAR_9))
  {
	  /* COMMENT_2 */
	  VAR_7 = &VAR_5->header;
	  x3f_property_list_t *VAR_10 = &VAR_7->data_subsection.property_list;
	  if (VAR_10->property_table.size != 0) {
		  int VAR_11;
		  x3f_property_t *VAR_12 = VAR_10->property_table.element;
		  for (VAR_11=0; VAR_11<VAR_10->num_properties; VAR_11++) {
			  char VAR_13[100], VAR_14[100];
			  utf2char(VAR_12[VAR_11].name,VAR_13,sizeof(VAR_13));
			  utf2char(VAR_12[VAR_11].value,VAR_14,sizeof(VAR_14));
			  if (!strcmp (VAR_13, ""ISO""))
				  VAR_6.other.iso_speed = atoi(VAR_14);
			  if (!strcmp (VAR_13, ""CAMMANUF""))
				  strcpy (VAR_6.idata.make, VAR_14);
			  if (!strcmp (VAR_13, ""CAMMODEL""))
				  strcpy (VAR_6.idata.model, VAR_14);
			  if (!strcmp (VAR_13, ""CAMSERIAL""))
				  strcpy (VAR_6.shootinginfo.BodySerial, VAR_14);
			  if (!strcmp (VAR_13, ""WB_DESC""))
				  strcpy (VAR_6.color.model2, VAR_14);
			  if (!strcmp (VAR_13, ""TIME""))
				  VAR_6.other.timestamp = atoi(VAR_14);
			  if (!strcmp (VAR_13, ""SHUTTER""))
				  VAR_6.other.shutter = atof(VAR_14);
			  if (!strcmp (VAR_13, ""APERTURE""))
				  VAR_6.other.aperture = atof(VAR_14);
			  if (!strcmp (VAR_13, ""FLENGTH""))
				  VAR_6.other.focal_len = atof(VAR_14);
				if (!strcmp (VAR_13, ""FLEQ35MM""))
				  VAR_6.lens.makernotes.FocalLengthIn35mmFormat = atof(VAR_14);
				if (!strcmp (VAR_13, ""LENSARANGE""))
				{
				  char *VAR_15;
				  VAR_6.lens.makernotes.MaxAp4CurFocal = VAR_6.lens.makernotes.MinAp4CurFocal = atof(VAR_14);
				  VAR_15 = strrchr (VAR_14, ' ');
				  if (VAR_15)
				    {
				      VAR_6.lens.makernotes.MinAp4CurFocal = atof(VAR_15);
				      if (VAR_6.lens.makernotes.MaxAp4CurFocal > VAR_6.lens.makernotes.MinAp4CurFocal)
				        my_swap (float, VAR_6.lens.makernotes.MaxAp4CurFocal, VAR_6.lens.makernotes.MinAp4CurFocal);
				    }
				}
				if (!strcmp (VAR_13, ""LENSFRANGE""))
				{
					char *VAR_15;
					VAR_6.lens.makernotes.MinFocal = VAR_6.lens.makernotes.MaxFocal = atof(VAR_14);
					VAR_15 = strrchr (VAR_14, ' ');
					if (VAR_15)
						{
							VAR_6.lens.makernotes.MaxFocal = atof(VAR_15);
							if ((VAR_6.lens.makernotes.MaxFocal + 0.17f) < VAR_6.lens.makernotes.MinFocal)
								my_swap (float, VAR_6.lens.makernotes.MaxFocal, VAR_6.lens.makernotes.MinFocal);
						}
				}
				if (!strcmp (VAR_13, ""LENSMODEL""))
				{
					char *VAR_15;
                                        VAR_6.lens.makernotes.LensID = strtol (VAR_14, &VAR_15, 16); /* COMMENT_3 */
					if (VAR_6.lens.makernotes.LensID)
					 VAR_6.lens.makernotes.LensMount = VAR_16;
				}
		  }
		  VAR_6.idata.raw_count=1;
		  VAR_17 = &LibRaw::x3f_load_raw;
		  VAR_6.sizes.raw_pitch = VAR_6.sizes.raw_width*6;
		  VAR_6.idata.is_foveon = 1;
		  VAR_1.internal_output_params.raw_color=1; /* COMMENT_4 */
		  VAR_6.color.maximum=0x3fff; /* COMMENT_5 */
		  VAR_1.unpacker_data.order = 0x4949;
	  }
  }
  else
  {
	  /* COMMENT_6 */
	  if(VAR_6.sizes.raw_width == 5888 ||VAR_6.sizes.raw_width == 2944 
		  || VAR_6.sizes.raw_width == 6656 ||VAR_6.sizes.raw_width == 3328 	  
		  || VAR_6.sizes.raw_width == 5504 ||VAR_6.sizes.raw_width == 2752 	  
		  ) /* COMMENT_7 */
	  {
		  VAR_6.idata.raw_count=1;
		  VAR_17 = &LibRaw::x3f_load_raw;
		  VAR_6.sizes.raw_pitch = VAR_6.sizes.raw_width*6;
		  VAR_6.idata.is_foveon = 1;
		  VAR_1.internal_output_params.raw_color=1; /* COMMENT_4 */
		  VAR_1.unpacker_data.order = 0x4949;
		  strcpy (VAR_6.idata.make, ""SIGMA"");
#if 1
		  /* COMMENT_8 */
		  int VAR_18 = VAR_1.internal_data.input->tell();
		  VAR_1.internal_data.input->seek(0,VAR_19);
		  unsigned char VAR_20[2048];
		  VAR_1.internal_data.input->read(VAR_20,2048,1);
		  VAR_1.internal_data.input->seek(VAR_18,VAR_19);
		  unsigned char *VAR_21=(unsigned char*)lr_memmem(VAR_20,2048,""SIGMA dp"",8);
		  unsigned char *VAR_22=(unsigned char*)lr_memmem(VAR_20,2048,""sd Quatt"",8);
		  if(VAR_21)
		  {
			  unsigned char *VAR_23 = VAR_21+8;
			  snprintf(VAR_6.idata.model,64,""dp%c Quattro"",*VAR_23<='9' && *VAR_23 >='0' ? *VAR_23: '2');
		  }
		  else if(VAR_22)
		  {
			  snprintf(VAR_6.idata.model,64,""%s"",VAR_22);
		  }
		  else
#endif
		  if(VAR_6.sizes.raw_width == 6656 ||VAR_6.sizes.raw_width == 3328 )
			strcpy (VAR_6.idata.model, ""sd Quattro H"");
		  else
			strcpy (VAR_6.idata.model, ""dp2 Quattro"");
	  }
	  /* COMMENT_9 */
  }
  /* COMMENT_10 */
  LibRaw_thumbnail_formats VAR_24 = VAR_25;
  if( (VAR_5 = x3f_get_thumb_jpeg(VAR_0)))
    {
      VAR_24 = VAR_26;
    }
  else if( (VAR_5 = x3f_get_thumb_plain(VAR_0)))
    {
      VAR_24 = VAR_27;
    }
  if(VAR_5)
    {
      x3f_directory_entry_header_t *VAR_7 = &VAR_5->header;
      x3f_image_data_t *VAR_8 = &VAR_7->data_subsection.image_data;
      VAR_6.thumbnail.twidth = VAR_8->columns;
      VAR_6.thumbnail.theight = VAR_8->rows;
      VAR_6.thumbnail.tcolors = 3;
      VAR_6.thumbnail.tformat = VAR_24;
      VAR_1.internal_data.toffset = VAR_5->input.offset;
      VAR_28 = &LibRaw::x3f_thumb_loader;
    }
}",LibRaw/efd8cfabb93fd0396266a7607069901657c082e3/libraw_cxx.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,8 +29,8 @@
 		  x3f_property_t *P = PL->property_table.element;
 		  for (i=0; i<PL->num_properties; i++) {
 			  char name[100], value[100];
-			  utf2char(P[i].name,name);
-			  utf2char(P[i].value,value);
+			  utf2char(P[i].name,name,sizeof(name));
+			  utf2char(P[i].value,value,sizeof(value));
 			  if (!strcmp (name, ""ISO""))
 				  imgdata.other.iso_speed = atoi(value);
 			  if (!strcmp (name, ""CAMMANUF""))","{'deleted_lines': ['\t\t\t  utf2char(P[i].name,name);', '\t\t\t  utf2char(P[i].value,value);'], 'added_lines': ['\t\t\t  utf2char(P[i].name,name,sizeof(name));', '\t\t\t  utf2char(P[i].value,value,sizeof(value));']}",True,An issue was discovered in LibRaw 0.18.9. There is a stack-based buffer overflow in the utf2char function in libraw_cxx.cpp.,8.8,HIGH,2,valid,2018-04-27T09:41:18Z,2
CVE-2018-10528,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,LibRaw,X3F parser possible buffer overrun,efd8cfabb93fd0396266a7607069901657c082e3,https://github.com/LibRaw/LibRaw/commit/efd8cfabb93fd0396266a7607069901657c082e3,src/libraw_cxx.cpp,utf2char,"static char *utf2char(utf16_t *str, char *buffer)
{
char *b = buffer;
while (*str != 0x00) {
char *chr = (char *)str;
*b++ = *chr;
str++;
}
*b = 0;
return buffer;
}","static char *utf2char(utf16_t *VAR_0, char *VAR_1)
{
char *VAR_2 = VAR_1;
while (*VAR_0 != 0x00) {
char *VAR_3 = (char *)VAR_0;
*VAR_2++ = *VAR_3;
VAR_0++;
}
*VAR_2 = 0;
return VAR_1;
}",LibRaw/efd8cfabb93fd0396266a7607069901657c082e3/libraw_cxx.cpp/vul/before/1.json,"void utf2char(utf16_t *str, char *buffer, unsigned bufsz)
{
 if(bufsz<1) return;
 buffer[bufsz-1] = 0;
  char *b = buffer;

  while (*str != 0x00 && --bufsz>0)
  {
    char *chr = (char *)str;
    *b++ = *chr;
    str++;
  }
  *b = 0;
}","void utf2char(utf16_t *VAR_0, char *VAR_1, unsigned VAR_2)
{
 if(VAR_2<1) return;
 VAR_1[VAR_2-1] = 0;
  char *VAR_3 = VAR_1;

  while (*VAR_0 != 0x00 && --VAR_2>0)
  {
    char *VAR_4 = (char *)VAR_0;
    *VAR_3++ = *VAR_4;
    VAR_0++;
  }
  *VAR_3 = 0;
}",LibRaw/efd8cfabb93fd0396266a7607069901657c082e3/libraw_cxx.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,14 @@
-static char *utf2char(utf16_t *str, char *buffer)
+void utf2char(utf16_t *str, char *buffer, unsigned bufsz)
 {
+ if(bufsz<1) return;
+ buffer[bufsz-1] = 0;
   char *b = buffer;
 
-  while (*str != 0x00) {
+  while (*str != 0x00 && --bufsz>0)
+  {
     char *chr = (char *)str;
     *b++ = *chr;
     str++;
   }
   *b = 0;
-  return buffer;
 }","{'deleted_lines': ['static char *utf2char(utf16_t *str, char *buffer)', '  while (*str != 0x00) {', '  return buffer;'], 'added_lines': ['void utf2char(utf16_t *str, char *buffer, unsigned bufsz)', ' if(bufsz<1) return;', ' buffer[bufsz-1] = 0;', '  while (*str != 0x00 && --bufsz>0)', '  {']}",True,An issue was discovered in LibRaw 0.18.9. There is a stack-based buffer overflow in the utf2char function in libraw_cxx.cpp.,8.8,HIGH,2,valid,2018-04-27T09:41:18Z,2
CVE-2018-10982,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/vpt: add support for IO-APIC routed interrupts

And modify the HPET code to make use of it. Currently HPET interrupts
are always treated as ISA and thus injected through the vPIC. This is
wrong because HPET interrupts when not in legacy mode should be
injected from the IO-APIC.

To make things worse, the supported interrupt routing values are set
to [20..23], which clearly falls outside of the ISA range, thus
leading to an ASSERT in debug builds or memory corruption in non-debug
builds because the interrupt injection code will write out of the
bounds of the arch.hvm_domain.vpic array.

Since the HPET interrupt source can change between ISA and IO-APIC
always destroy the timer before changing the mode, or else Xen risks
changing it while the timer is active.

Note that vpt interrupt injection is racy in the sense that the
vIO-APIC RTE entry can be written by the guest in between the call to
pt_irq_masked and hvm_ioapic_assert, or the call to pt_update_irq and
pt_intr_post. Those are not deemed to be security issues, but rather
quirks of the current implementation. In the worse case the guest
might lose interrupts or get multiple interrupt vectors injected for
the same timer source.

This is part of XSA-261.

Address actual and potential compiler warnings. Fix formatting.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",14c3f68a57361f20be33ec3848f83d8636a0d34e,https://github.com/xen-project/xen/commit/14c3f68a57361f20be33ec3848f83d8636a0d34e,xen/arch/x86/hvm/vpt.c,create_periodic_time,"void create_periodic_time(
struct vcpu *v, struct periodic_time *pt, uint64_t delta,
uint64_t period, uint8_t irq, time_cb *cb, void *data)
{
ASSERT(pt->source != 0);
destroy_periodic_time(pt);
spin_lock(&v->arch.hvm_vcpu.tm_lock);
pt->pending_intr_nr = 0;
pt->do_not_freeze = 0;
pt->irq_issued = 0;
if ( (period < 100000) && period )
{
if ( !test_and_set_bool(pt->warned_timeout_too_short) )
gdprintk(XENLOG_WARNING, ""HVM_PlatformTime: program too ""
""small period %""PRIu64""\n"", period);
period = 100000;
}
pt->period = period;
pt->vcpu = v;
pt->last_plt_gtime = hvm_get_guest_time(pt->vcpu);
pt->irq = irq;
pt->one_shot = !period;
pt->scheduled = NOW() + delta;
if ( !pt->one_shot )
{
if ( v->domain->arch.hvm_domain.params[HVM_PARAM_VPT_ALIGN] )
{
pt->scheduled = align_timer(pt->scheduled, pt->period);
}
else if ( pt->source == PTSRC_lapic )
{
pt->scheduled += delta >> 1;
}
}
pt->cb = cb;
pt->priv = data;
pt->on_list = 1;
list_add(&pt->list, &v->arch.hvm_vcpu.tm_list);
init_timer(&pt->timer, pt_timer_fn, pt, v->processor);
set_timer(&pt->timer, pt->scheduled);
spin_unlock(&v->arch.hvm_vcpu.tm_lock);
}","void create_periodic_time(
struct vcpu *VAR_0, struct periodic_time *VAR_1, uint64_t VAR_2,
uint64_t VAR_3, uint8_t VAR_4, time_cb *VAR_5, void *VAR_6)
{
ASSERT(VAR_1->source != 0);
destroy_periodic_time(VAR_1);
spin_lock(&VAR_0->arch.hvm_vcpu.tm_lock);
VAR_1->pending_intr_nr = 0;
VAR_1->do_not_freeze = 0;
VAR_1->irq_issued = 0;
if ( (VAR_3 < 100000) && VAR_3 )
{
if ( !test_and_set_bool(VAR_1->warned_timeout_too_short) )
gdprintk(VAR_7, ""HVM_PlatformTime: program too ""
""small period %""VAR_8""\n"", VAR_3);
VAR_3 = 100000;
}
VAR_1->period = VAR_3;
VAR_1->vcpu = VAR_0;
VAR_1->last_plt_gtime = hvm_get_guest_time(VAR_1->vcpu);
VAR_1->irq = VAR_4;
VAR_1->one_shot = !VAR_3;
VAR_1->scheduled = NOW() + VAR_2;
if ( !VAR_1->one_shot )
{
if ( VAR_0->domain->arch.hvm_domain.params[VAR_9] )
{
VAR_1->scheduled = align_timer(VAR_1->scheduled, VAR_1->period);
}
else if ( VAR_1->source == VAR_10 )
{
VAR_1->scheduled += VAR_2 >> 1;
}
}
VAR_1->cb = VAR_5;
VAR_1->priv = VAR_6;
VAR_1->on_list = 1;
list_add(&VAR_1->list, &VAR_0->arch.hvm_vcpu.tm_list);
init_timer(&VAR_1->timer, VAR_11, VAR_1, VAR_0->processor);
set_timer(&VAR_1->timer, VAR_1->scheduled);
spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/before/1.json,"void create_periodic_time(
    struct vcpu *v, struct periodic_time *pt, uint64_t delta,
    uint64_t period, uint8_t irq, time_cb *cb, void *data)
{
    if ( !pt->source ||
         (pt->irq >= NR_ISAIRQS && pt->source == PTSRC_isa) ||
         (pt->irq >= hvm_domain_irq(v->domain)->nr_gsis &&
          pt->source == PTSRC_ioapic) )
    {
        ASSERT_UNREACHABLE();
        return;
    }

    destroy_periodic_time(pt);

    spin_lock(&v->arch.hvm_vcpu.tm_lock);

    pt->pending_intr_nr = 0;
    pt->do_not_freeze = 0;
    pt->irq_issued = 0;

    /* Periodic timer must be at least 0.1ms. */
    if ( (period < 100000) && period )
    {
        if ( !test_and_set_bool(pt->warned_timeout_too_short) )
            gdprintk(XENLOG_WARNING, ""HVM_PlatformTime: program too ""
                     ""small period %""PRIu64""\n"", period);
        period = 100000;
    }

    pt->period = period;
    pt->vcpu = v;
    pt->last_plt_gtime = hvm_get_guest_time(pt->vcpu);
    pt->irq = irq;
    pt->one_shot = !period;
    pt->scheduled = NOW() + delta;

    if ( !pt->one_shot )
    {
        if ( v->domain->arch.hvm_domain.params[HVM_PARAM_VPT_ALIGN] )
        {
            pt->scheduled = align_timer(pt->scheduled, pt->period);
        }
        else if ( pt->source == PTSRC_lapic )
        {
            /*
             * Offset LAPIC ticks from other timer ticks. Otherwise guests
             * which use LAPIC ticks for process accounting can see long
             * sequences of process ticks incorrectly accounted to interrupt
             * processing (seen with RHEL3 guest).
             */
            pt->scheduled += delta >> 1;
        }
    }

    pt->cb = cb;
    pt->priv = data;

    pt->on_list = 1;
    list_add(&pt->list, &v->arch.hvm_vcpu.tm_list);

    init_timer(&pt->timer, pt_timer_fn, pt, v->processor);
    set_timer(&pt->timer, pt->scheduled);

    spin_unlock(&v->arch.hvm_vcpu.tm_lock);
}","void create_periodic_time(
    struct vcpu *VAR_0, struct periodic_time *VAR_1, uint64_t VAR_2,
    uint64_t VAR_3, uint8_t VAR_4, time_cb *VAR_5, void *VAR_6)
{
    if ( !VAR_1->source ||
         (VAR_1->irq >= VAR_7 && VAR_1->source == VAR_8) ||
         (VAR_1->irq >= hvm_domain_irq(VAR_0->domain)->nr_gsis &&
          VAR_1->source == VAR_9) )
    {
        ASSERT_UNREACHABLE();
        return;
    }

    destroy_periodic_time(VAR_1);

    spin_lock(&VAR_0->arch.hvm_vcpu.tm_lock);

    VAR_1->pending_intr_nr = 0;
    VAR_1->do_not_freeze = 0;
    VAR_1->irq_issued = 0;

    /* COMMENT_0 */
    if ( (VAR_3 < 100000) && VAR_3 )
    {
        if ( !test_and_set_bool(VAR_1->warned_timeout_too_short) )
            gdprintk(VAR_10, ""HVM_PlatformTime: program too ""
                     ""small period %""VAR_11""\n"", VAR_3);
        VAR_3 = 100000;
    }

    VAR_1->period = VAR_3;
    VAR_1->vcpu = VAR_0;
    VAR_1->last_plt_gtime = hvm_get_guest_time(VAR_1->vcpu);
    VAR_1->irq = VAR_4;
    VAR_1->one_shot = !VAR_3;
    VAR_1->scheduled = NOW() + VAR_2;

    if ( !VAR_1->one_shot )
    {
        if ( VAR_0->domain->arch.hvm_domain.params[VAR_12] )
        {
            VAR_1->scheduled = align_timer(VAR_1->scheduled, VAR_1->period);
        }
        else if ( VAR_1->source == VAR_13 )
        {
            /* COMMENT_1 */
                                                                          
                                                                        
                                                                            
                                                  
               
            VAR_1->scheduled += VAR_2 >> 1;
        }
    }

    VAR_1->cb = VAR_5;
    VAR_1->priv = VAR_6;

    VAR_1->on_list = 1;
    list_add(&VAR_1->list, &VAR_0->arch.hvm_vcpu.tm_list);

    init_timer(&VAR_1->timer, VAR_14, VAR_1, VAR_0->processor);
    set_timer(&VAR_1->timer, VAR_1->scheduled);

    spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,14 @@
     struct vcpu *v, struct periodic_time *pt, uint64_t delta,
     uint64_t period, uint8_t irq, time_cb *cb, void *data)
 {
-    ASSERT(pt->source != 0);
+    if ( !pt->source ||
+         (pt->irq >= NR_ISAIRQS && pt->source == PTSRC_isa) ||
+         (pt->irq >= hvm_domain_irq(v->domain)->nr_gsis &&
+          pt->source == PTSRC_ioapic) )
+    {
+        ASSERT_UNREACHABLE();
+        return;
+    }
 
     destroy_periodic_time(pt);
 ","{'deleted_lines': ['    ASSERT(pt->source != 0);'], 'added_lines': ['    if ( !pt->source ||', '         (pt->irq >= NR_ISAIRQS && pt->source == PTSRC_isa) ||', '         (pt->irq >= hvm_domain_irq(v->domain)->nr_gsis &&', '          pt->source == PTSRC_ioapic) )', '    {', '        ASSERT_UNREACHABLE();', '        return;', '    }']}",True,"An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (unexpectedly high interrupt number, array overrun, and hypervisor crash) or possibly gain hypervisor privileges by setting up an HPET timer to deliver interrupts in IO-APIC mode, aka vHPET interrupt injection.",8.8,HIGH,2,valid,2018-05-08T17:12:10Z,2
CVE-2018-10982,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/vpt: add support for IO-APIC routed interrupts

And modify the HPET code to make use of it. Currently HPET interrupts
are always treated as ISA and thus injected through the vPIC. This is
wrong because HPET interrupts when not in legacy mode should be
injected from the IO-APIC.

To make things worse, the supported interrupt routing values are set
to [20..23], which clearly falls outside of the ISA range, thus
leading to an ASSERT in debug builds or memory corruption in non-debug
builds because the interrupt injection code will write out of the
bounds of the arch.hvm_domain.vpic array.

Since the HPET interrupt source can change between ISA and IO-APIC
always destroy the timer before changing the mode, or else Xen risks
changing it while the timer is active.

Note that vpt interrupt injection is racy in the sense that the
vIO-APIC RTE entry can be written by the guest in between the call to
pt_irq_masked and hvm_ioapic_assert, or the call to pt_update_irq and
pt_intr_post. Those are not deemed to be security issues, but rather
quirks of the current implementation. In the worse case the guest
might lose interrupts or get multiple interrupt vectors injected for
the same timer source.

This is part of XSA-261.

Address actual and potential compiler warnings. Fix formatting.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",14c3f68a57361f20be33ec3848f83d8636a0d34e,https://github.com/xen-project/xen/commit/14c3f68a57361f20be33ec3848f83d8636a0d34e,xen/arch/x86/hvm/vpt.c,pt_adjust_vcpu,"static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
{
int on_list;
ASSERT(pt->source == PTSRC_isa);
if ( pt->vcpu == NULL )
return;
pt_lock(pt);
on_list = pt->on_list;
if ( pt->on_list )
list_del(&pt->list);
pt->on_list = 0;
pt_unlock(pt);
spin_lock(&v->arch.hvm_vcpu.tm_lock);
pt->vcpu = v;
if ( on_list )
{
pt->on_list = 1;
list_add(&pt->list, &v->arch.hvm_vcpu.tm_list);
migrate_timer(&pt->timer, v->processor);
}
spin_unlock(&v->arch.hvm_vcpu.tm_lock);
}","static void pt_adjust_vcpu(struct periodic_time *VAR_0, struct vcpu *VAR_1)
{
int VAR_2;
ASSERT(VAR_0->source == VAR_3);
if ( VAR_0->vcpu == NULL )
return;
pt_lock(VAR_0);
VAR_2 = VAR_0->on_list;
if ( VAR_0->on_list )
list_del(&VAR_0->list);
VAR_0->on_list = 0;
pt_unlock(VAR_0);
spin_lock(&VAR_1->arch.hvm_vcpu.tm_lock);
VAR_0->vcpu = VAR_1;
if ( VAR_2 )
{
VAR_0->on_list = 1;
list_add(&VAR_0->list, &VAR_1->arch.hvm_vcpu.tm_list);
migrate_timer(&VAR_0->timer, VAR_1->processor);
}
spin_unlock(&VAR_1->arch.hvm_vcpu.tm_lock);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/before/0.json,"static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
{
    int on_list;

    ASSERT(pt->source == PTSRC_isa || pt->source == PTSRC_ioapic);

    if ( pt->vcpu == NULL )
        return;

    pt_lock(pt);
    on_list = pt->on_list;
    if ( pt->on_list )
        list_del(&pt->list);
    pt->on_list = 0;
    pt_unlock(pt);

    spin_lock(&v->arch.hvm_vcpu.tm_lock);
    pt->vcpu = v;
    if ( on_list )
    {
        pt->on_list = 1;
        list_add(&pt->list, &v->arch.hvm_vcpu.tm_list);

        migrate_timer(&pt->timer, v->processor);
    }
    spin_unlock(&v->arch.hvm_vcpu.tm_lock);
}","static void pt_adjust_vcpu(struct periodic_time *VAR_0, struct vcpu *VAR_1)
{
    int VAR_2;

    ASSERT(VAR_0->source == VAR_3 || VAR_0->source == VAR_4);

    if ( VAR_0->vcpu == NULL )
        return;

    pt_lock(VAR_0);
    VAR_2 = VAR_0->on_list;
    if ( VAR_0->on_list )
        list_del(&VAR_0->list);
    VAR_0->on_list = 0;
    pt_unlock(VAR_0);

    spin_lock(&VAR_1->arch.hvm_vcpu.tm_lock);
    VAR_0->vcpu = VAR_1;
    if ( VAR_2 )
    {
        VAR_0->on_list = 1;
        list_add(&VAR_0->list, &VAR_1->arch.hvm_vcpu.tm_list);

        migrate_timer(&VAR_0->timer, VAR_1->processor);
    }
    spin_unlock(&VAR_1->arch.hvm_vcpu.tm_lock);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     int on_list;
 
-    ASSERT(pt->source == PTSRC_isa);
+    ASSERT(pt->source == PTSRC_isa || pt->source == PTSRC_ioapic);
 
     if ( pt->vcpu == NULL )
         return;","{'deleted_lines': ['    ASSERT(pt->source == PTSRC_isa);'], 'added_lines': ['    ASSERT(pt->source == PTSRC_isa || pt->source == PTSRC_ioapic);']}",True,"An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (unexpectedly high interrupt number, array overrun, and hypervisor crash) or possibly gain hypervisor privileges by setting up an HPET timer to deliver interrupts in IO-APIC mode, aka vHPET interrupt injection.",8.8,HIGH,2,valid,2018-05-08T17:12:10Z,2
CVE-2018-10982,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/vpt: add support for IO-APIC routed interrupts

And modify the HPET code to make use of it. Currently HPET interrupts
are always treated as ISA and thus injected through the vPIC. This is
wrong because HPET interrupts when not in legacy mode should be
injected from the IO-APIC.

To make things worse, the supported interrupt routing values are set
to [20..23], which clearly falls outside of the ISA range, thus
leading to an ASSERT in debug builds or memory corruption in non-debug
builds because the interrupt injection code will write out of the
bounds of the arch.hvm_domain.vpic array.

Since the HPET interrupt source can change between ISA and IO-APIC
always destroy the timer before changing the mode, or else Xen risks
changing it while the timer is active.

Note that vpt interrupt injection is racy in the sense that the
vIO-APIC RTE entry can be written by the guest in between the call to
pt_irq_masked and hvm_ioapic_assert, or the call to pt_update_irq and
pt_intr_post. Those are not deemed to be security issues, but rather
quirks of the current implementation. In the worse case the guest
might lose interrupts or get multiple interrupt vectors injected for
the same timer source.

This is part of XSA-261.

Address actual and potential compiler warnings. Fix formatting.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",14c3f68a57361f20be33ec3848f83d8636a0d34e,https://github.com/xen-project/xen/commit/14c3f68a57361f20be33ec3848f83d8636a0d34e,xen/arch/x86/hvm/vpt.c,pt_irq_masked,"static int pt_irq_masked(struct periodic_time *pt)
{
struct vcpu *v = pt->vcpu;
unsigned int gsi, isa_irq;
int mask;
uint8_t pic_imr;
if ( pt->source == PTSRC_lapic )
{
struct vlapic *vlapic = vcpu_vlapic(v);
return (!vlapic_enabled(vlapic) ||
(vlapic_get_reg(vlapic, APIC_LVTT) & APIC_LVT_MASKED));
}
isa_irq = pt->irq;
gsi = hvm_isa_irq_to_gsi(isa_irq);
pic_imr = v->domain->arch.hvm_domain.vpic[isa_irq >> 3].imr;
mask = vioapic_get_mask(v->domain, gsi);
if ( mask < 0 )
{
dprintk(XENLOG_WARNING, ""d%u: invalid GSI (%u) for platform timer\n"",
v->domain->domain_id, gsi);
domain_crash(v->domain);
return -1;
}
return (((pic_imr & (1 << (isa_irq & 7))) || !vlapic_accept_pic_intr(v)) &&
mask);
}","static int pt_irq_masked(struct periodic_time *VAR_0)
{
struct vcpu *VAR_1 = VAR_0->vcpu;
unsigned int VAR_2, VAR_3;
int VAR_4;
uint8_t VAR_5;
if ( VAR_0->source == VAR_6 )
{
struct vlapic *vlapic = vcpu_vlapic(VAR_1);
return (!vlapic_enabled(vlapic) ||
(vlapic_get_reg(vlapic, VAR_7) & VAR_8));
}
VAR_3 = VAR_0->irq;
VAR_2 = hvm_isa_irq_to_gsi(VAR_3);
VAR_5 = VAR_1->domain->arch.hvm_domain.vpic[VAR_3 >> 3].imr;
VAR_4 = vioapic_get_mask(VAR_1->domain, VAR_2);
if ( VAR_4 < 0 )
{
dprintk(VAR_9, ""d%u: invalid GSI (%u) for platform timer\n"",
VAR_1->domain->domain_id, VAR_2);
domain_crash(VAR_1->domain);
return -1;
}
return (((VAR_5 & (1 << (VAR_3 & 7))) || !vlapic_accept_pic_intr(VAR_1)) &&
VAR_4);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/before/3.json,"static int pt_irq_masked(struct periodic_time *pt)
{
    struct vcpu *v = pt->vcpu;
    unsigned int gsi = pt->irq;

    switch ( pt->source )
    {
    case PTSRC_lapic:
    {
        struct vlapic *vlapic = vcpu_vlapic(v);

        return (!vlapic_enabled(vlapic) ||
                (vlapic_get_reg(vlapic, APIC_LVTT) & APIC_LVT_MASKED));
    }

    case PTSRC_isa:
    {
        uint8_t pic_imr = v->domain->arch.hvm_domain.vpic[pt->irq >> 3].imr;

        /* Check if the interrupt is unmasked in the PIC. */
        if ( !(pic_imr & (1 << (pt->irq & 7))) && vlapic_accept_pic_intr(v) )
            return 0;

        gsi = hvm_isa_irq_to_gsi(pt->irq);
    }

    /* Fallthrough to check if the interrupt is masked on the IO APIC. */
    case PTSRC_ioapic:
    {
        int mask = vioapic_get_mask(v->domain, gsi);

        if ( mask < 0 )
        {
            dprintk(XENLOG_WARNING,
                    ""d%d: invalid GSI (%u) for platform timer\n"",
                    v->domain->domain_id, gsi);
            domain_crash(v->domain);
            return -1;
        }

        return mask;
    }
    }

    ASSERT_UNREACHABLE();
    return 1;
}","static int pt_irq_masked(struct periodic_time *VAR_0)
{
    struct vcpu *VAR_1 = VAR_0->vcpu;
    unsigned int VAR_2 = VAR_0->irq;

    switch ( VAR_0->source )
    {
    case VAR_3:
    {
        struct vlapic *vlapic = vcpu_vlapic(VAR_1);

        return (!vlapic_enabled(vlapic) ||
                (vlapic_get_reg(vlapic, VAR_4) & VAR_5));
    }

    case VAR_6:
    {
        uint8_t VAR_7 = VAR_1->domain->arch.hvm_domain.vpic[VAR_0->irq >> 3].imr;

        /* COMMENT_0 */
        if ( !(VAR_7 & (1 << (VAR_0->irq & 7))) && vlapic_accept_pic_intr(VAR_1) )
            return 0;

        VAR_2 = hvm_isa_irq_to_gsi(VAR_0->irq);
    }

    /* COMMENT_1 */
    case VAR_8:
    {
        int VAR_9 = vioapic_get_mask(VAR_1->domain, VAR_2);

        if ( VAR_9 < 0 )
        {
            dprintk(VAR_10,
                    ""d%d: invalid GSI (%u) for platform timer\n"",
                    VAR_1->domain->domain_id, VAR_2);
            domain_crash(VAR_1->domain);
            return -1;
        }

        return VAR_9;
    }
    }

    ASSERT_UNREACHABLE();
    return 1;
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,29 +1,47 @@
 static int pt_irq_masked(struct periodic_time *pt)
 {
     struct vcpu *v = pt->vcpu;
-    unsigned int gsi, isa_irq;
-    int mask;
-    uint8_t pic_imr;
+    unsigned int gsi = pt->irq;
 
-    if ( pt->source == PTSRC_lapic )
+    switch ( pt->source )
+    {
+    case PTSRC_lapic:
     {
         struct vlapic *vlapic = vcpu_vlapic(v);
+
         return (!vlapic_enabled(vlapic) ||
                 (vlapic_get_reg(vlapic, APIC_LVTT) & APIC_LVT_MASKED));
     }
 
-    isa_irq = pt->irq;
-    gsi = hvm_isa_irq_to_gsi(isa_irq);
-    pic_imr = v->domain->arch.hvm_domain.vpic[isa_irq >> 3].imr;
-    mask = vioapic_get_mask(v->domain, gsi);
-    if ( mask < 0 )
+    case PTSRC_isa:
     {
-        dprintk(XENLOG_WARNING, ""d%u: invalid GSI (%u) for platform timer\n"",
-                v->domain->domain_id, gsi);
-        domain_crash(v->domain);
-        return -1;
+        uint8_t pic_imr = v->domain->arch.hvm_domain.vpic[pt->irq >> 3].imr;
+
+        /* Check if the interrupt is unmasked in the PIC. */
+        if ( !(pic_imr & (1 << (pt->irq & 7))) && vlapic_accept_pic_intr(v) )
+            return 0;
+
+        gsi = hvm_isa_irq_to_gsi(pt->irq);
     }
 
-    return (((pic_imr & (1 << (isa_irq & 7))) || !vlapic_accept_pic_intr(v)) &&
-            mask);
+    /* Fallthrough to check if the interrupt is masked on the IO APIC. */
+    case PTSRC_ioapic:
+    {
+        int mask = vioapic_get_mask(v->domain, gsi);
+
+        if ( mask < 0 )
+        {
+            dprintk(XENLOG_WARNING,
+                    ""d%d: invalid GSI (%u) for platform timer\n"",
+                    v->domain->domain_id, gsi);
+            domain_crash(v->domain);
+            return -1;
+        }
+
+        return mask;
+    }
+    }
+
+    ASSERT_UNREACHABLE();
+    return 1;
 }","{'deleted_lines': ['    unsigned int gsi, isa_irq;', '    int mask;', '    uint8_t pic_imr;', '    if ( pt->source == PTSRC_lapic )', '    isa_irq = pt->irq;', '    gsi = hvm_isa_irq_to_gsi(isa_irq);', '    pic_imr = v->domain->arch.hvm_domain.vpic[isa_irq >> 3].imr;', '    mask = vioapic_get_mask(v->domain, gsi);', '    if ( mask < 0 )', '        dprintk(XENLOG_WARNING, ""d%u: invalid GSI (%u) for platform timer\\n"",', '                v->domain->domain_id, gsi);', '        domain_crash(v->domain);', '        return -1;', '    return (((pic_imr & (1 << (isa_irq & 7))) || !vlapic_accept_pic_intr(v)) &&', '            mask);'], 'added_lines': ['    unsigned int gsi = pt->irq;', '    switch ( pt->source )', '    {', '    case PTSRC_lapic:', '', '    case PTSRC_isa:', '        uint8_t pic_imr = v->domain->arch.hvm_domain.vpic[pt->irq >> 3].imr;', '', '        /* Check if the interrupt is unmasked in the PIC. */', '        if ( !(pic_imr & (1 << (pt->irq & 7))) && vlapic_accept_pic_intr(v) )', '            return 0;', '', '        gsi = hvm_isa_irq_to_gsi(pt->irq);', '    /* Fallthrough to check if the interrupt is masked on the IO APIC. */', '    case PTSRC_ioapic:', '    {', '        int mask = vioapic_get_mask(v->domain, gsi);', '', '        if ( mask < 0 )', '        {', '            dprintk(XENLOG_WARNING,', '                    ""d%d: invalid GSI (%u) for platform timer\\n"",', '                    v->domain->domain_id, gsi);', '            domain_crash(v->domain);', '            return -1;', '        }', '', '        return mask;', '    }', '    }', '', '    ASSERT_UNREACHABLE();', '    return 1;']}",True,"An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (unexpectedly high interrupt number, array overrun, and hypervisor crash) or possibly gain hypervisor privileges by setting up an HPET timer to deliver interrupts in IO-APIC mode, aka vHPET interrupt injection.",8.8,HIGH,2,valid,2018-05-08T17:12:10Z,2
CVE-2018-10982,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/vpt: add support for IO-APIC routed interrupts

And modify the HPET code to make use of it. Currently HPET interrupts
are always treated as ISA and thus injected through the vPIC. This is
wrong because HPET interrupts when not in legacy mode should be
injected from the IO-APIC.

To make things worse, the supported interrupt routing values are set
to [20..23], which clearly falls outside of the ISA range, thus
leading to an ASSERT in debug builds or memory corruption in non-debug
builds because the interrupt injection code will write out of the
bounds of the arch.hvm_domain.vpic array.

Since the HPET interrupt source can change between ISA and IO-APIC
always destroy the timer before changing the mode, or else Xen risks
changing it while the timer is active.

Note that vpt interrupt injection is racy in the sense that the
vIO-APIC RTE entry can be written by the guest in between the call to
pt_irq_masked and hvm_ioapic_assert, or the call to pt_update_irq and
pt_intr_post. Those are not deemed to be security issues, but rather
quirks of the current implementation. In the worse case the guest
might lose interrupts or get multiple interrupt vectors injected for
the same timer source.

This is part of XSA-261.

Address actual and potential compiler warnings. Fix formatting.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",14c3f68a57361f20be33ec3848f83d8636a0d34e,https://github.com/xen-project/xen/commit/14c3f68a57361f20be33ec3848f83d8636a0d34e,xen/arch/x86/hvm/vpt.c,pt_update_irq,"int pt_update_irq(struct vcpu *v)
{
struct list_head *head = &v->arch.hvm_vcpu.tm_list;
struct periodic_time *pt, *temp, *earliest_pt;
uint64_t max_lag;
int irq, is_lapic, pt_vector;
spin_lock(&v->arch.hvm_vcpu.tm_lock);
earliest_pt = NULL;
max_lag = -1ULL;
list_for_each_entry_safe ( pt, temp, head, list )
{
if ( pt->pending_intr_nr )
{
if ( (pt->irq != RTC_IRQ || !pt->priv) && pt_irq_masked(pt) )
{
list_del(&pt->list);
pt->on_list = 0;
}
else
{
if ( (pt->last_plt_gtime + pt->period) < max_lag )
{
max_lag = pt->last_plt_gtime + pt->period;
earliest_pt = pt;
}
}
}
}
if ( earliest_pt == NULL )
{
spin_unlock(&v->arch.hvm_vcpu.tm_lock);
return -1;
}
earliest_pt->irq_issued = 1;
irq = earliest_pt->irq;
is_lapic = (earliest_pt->source == PTSRC_lapic);
spin_unlock(&v->arch.hvm_vcpu.tm_lock);
if ( is_lapic )
{
vlapic_set_irq(vcpu_vlapic(v), irq, 0);
pt_vector = irq;
}
else
{
hvm_isa_irq_deassert(v->domain, irq);
if ( platform_legacy_irq(irq) && vlapic_accept_pic_intr(v) &&
v->domain->arch.hvm_domain.vpic[irq >> 3].int_output )
{
hvm_isa_irq_assert(v->domain, irq, NULL);
pt_vector = -1;
}
else
{
pt_vector = hvm_isa_irq_assert(v->domain, irq, vioapic_get_vector);
if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )
pt_vector = -1;
}
}
return pt_vector;
}","int pt_update_irq(struct vcpu *VAR_0)
{
struct list_head *VAR_1 = &VAR_0->arch.hvm_vcpu.tm_list;
struct periodic_time *VAR_2, *VAR_3, *VAR_4;
uint64_t VAR_5;
int VAR_6, VAR_7, VAR_8;
spin_lock(&VAR_0->arch.hvm_vcpu.tm_lock);
VAR_4 = NULL;
VAR_5 = -1ULL;
list_for_each_entry_safe ( VAR_2, VAR_3, VAR_1, VAR_9 )
{
if ( VAR_2->pending_intr_nr )
{
if ( (VAR_2->irq != VAR_10 || !VAR_2->priv) && pt_irq_masked(VAR_2) )
{
list_del(&VAR_2->list);
VAR_2->on_list = 0;
}
else
{
if ( (VAR_2->last_plt_gtime + VAR_2->period) < VAR_5 )
{
VAR_5 = VAR_2->last_plt_gtime + VAR_2->period;
VAR_4 = VAR_2;
}
}
}
}
if ( VAR_4 == NULL )
{
spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);
return -1;
}
VAR_4->irq_issued = 1;
VAR_6 = VAR_4->irq;
VAR_7 = (VAR_4->source == VAR_11);
spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);
if ( VAR_7 )
{
vlapic_set_irq(vcpu_vlapic(VAR_0), VAR_6, 0);
VAR_8 = VAR_6;
}
else
{
hvm_isa_irq_deassert(VAR_0->domain, VAR_6);
if ( platform_legacy_irq(VAR_6) && vlapic_accept_pic_intr(VAR_0) &&
VAR_0->domain->arch.hvm_domain.vpic[VAR_6 >> 3].int_output )
{
hvm_isa_irq_assert(VAR_0->domain, VAR_6, NULL);
VAR_8 = -1;
}
else
{
VAR_8 = hvm_isa_irq_assert(VAR_0->domain, VAR_6, VAR_12);
if ( VAR_8 < 0 || !vlapic_test_irq(vcpu_vlapic(VAR_0), VAR_8) )
VAR_8 = -1;
}
}
return VAR_8;
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/before/2.json,"int pt_update_irq(struct vcpu *v)
{
    struct list_head *head = &v->arch.hvm_vcpu.tm_list;
    struct periodic_time *pt, *temp, *earliest_pt;
    uint64_t max_lag;
    int irq, pt_vector = -1;

    spin_lock(&v->arch.hvm_vcpu.tm_lock);

    earliest_pt = NULL;
    max_lag = -1ULL;
    list_for_each_entry_safe ( pt, temp, head, list )
    {
        if ( pt->pending_intr_nr )
        {
            /* RTC code takes care of disabling the timer itself. */
            if ( (pt->irq != RTC_IRQ || !pt->priv) && pt_irq_masked(pt) )
            {
                /* suspend timer emulation */
                list_del(&pt->list);
                pt->on_list = 0;
            }
            else
            {
                if ( (pt->last_plt_gtime + pt->period) < max_lag )
                {
                    max_lag = pt->last_plt_gtime + pt->period;
                    earliest_pt = pt;
                }
            }
        }
    }

    if ( earliest_pt == NULL )
    {
        spin_unlock(&v->arch.hvm_vcpu.tm_lock);
        return -1;
    }

    earliest_pt->irq_issued = 1;
    irq = earliest_pt->irq;

    spin_unlock(&v->arch.hvm_vcpu.tm_lock);

    switch ( earliest_pt->source )
    {
    case PTSRC_lapic:
        /*
         * If periodic timer interrupt is handled by lapic, its vector in
         * IRR is returned and used to set eoi_exit_bitmap for virtual
         * interrupt delivery case. Otherwise return -1 to do nothing.
         */
        vlapic_set_irq(vcpu_vlapic(v), irq, 0);
        pt_vector = irq;
        break;

    case PTSRC_isa:
        hvm_isa_irq_deassert(v->domain, irq);
        if ( platform_legacy_irq(irq) && vlapic_accept_pic_intr(v) &&
             v->domain->arch.hvm_domain.vpic[irq >> 3].int_output )
            hvm_isa_irq_assert(v->domain, irq, NULL);
        else
        {
            pt_vector = hvm_isa_irq_assert(v->domain, irq, vioapic_get_vector);
            /*
             * hvm_isa_irq_assert may not set the corresponding bit in vIRR
             * when mask field of IOAPIC RTE is set. Check it again.
             */
            if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )
                pt_vector = -1;
        }
        break;

    case PTSRC_ioapic:
        /*
         * NB: At the moment IO-APIC routed interrupts generated by vpt devices
         * (HPET) are edge-triggered.
         */
        pt_vector = hvm_ioapic_assert(v->domain, irq, false);
        if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )
            pt_vector = -1;
        break;
    }

    return pt_vector;
}","int pt_update_irq(struct vcpu *VAR_0)
{
    struct list_head *VAR_1 = &VAR_0->arch.hvm_vcpu.tm_list;
    struct periodic_time *VAR_2, *VAR_3, *VAR_4;
    uint64_t VAR_5;
    int VAR_6, VAR_7 = -1;

    spin_lock(&VAR_0->arch.hvm_vcpu.tm_lock);

    VAR_4 = NULL;
    VAR_5 = -1ULL;
    list_for_each_entry_safe ( VAR_2, VAR_3, VAR_1, VAR_8 )
    {
        if ( VAR_2->pending_intr_nr )
        {
            /* COMMENT_0 */
            if ( (VAR_2->irq != VAR_9 || !VAR_2->priv) && pt_irq_masked(VAR_2) )
            {
                /* COMMENT_1 */
                list_del(&VAR_2->list);
                VAR_2->on_list = 0;
            }
            else
            {
                if ( (VAR_2->last_plt_gtime + VAR_2->period) < VAR_5 )
                {
                    VAR_5 = VAR_2->last_plt_gtime + VAR_2->period;
                    VAR_4 = VAR_2;
                }
            }
        }
    }

    if ( VAR_4 == NULL )
    {
        spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);
        return -1;
    }

    VAR_4->irq_issued = 1;
    VAR_6 = VAR_4->irq;

    spin_unlock(&VAR_0->arch.hvm_vcpu.tm_lock);

    switch ( VAR_4->source )
    {
    case VAR_10:
        /* COMMENT_2 */
                                                                         
                                                                      
                                                                      
           
        vlapic_set_irq(vcpu_vlapic(VAR_0), VAR_6, 0);
        VAR_7 = VAR_6;
        break;

    case VAR_11:
        hvm_isa_irq_deassert(VAR_0->domain, VAR_6);
        if ( platform_legacy_irq(VAR_6) && vlapic_accept_pic_intr(VAR_0) &&
             VAR_0->domain->arch.hvm_domain.vpic[VAR_6 >> 3].int_output )
            hvm_isa_irq_assert(VAR_0->domain, VAR_6, NULL);
        else
        {
            VAR_7 = hvm_isa_irq_assert(VAR_0->domain, VAR_6, VAR_12);
            /* COMMENT_7 */
                                                                           
                                                                    
               
            if ( VAR_7 < 0 || !vlapic_test_irq(vcpu_vlapic(VAR_0), VAR_7) )
                VAR_7 = -1;
        }
        break;

    case VAR_13:
        /* COMMENT_11 */
                                                                               
                                     
           
        VAR_7 = hvm_ioapic_assert(VAR_0->domain, VAR_6, false);
        if ( VAR_7 < 0 || !vlapic_test_irq(vcpu_vlapic(VAR_0), VAR_7) )
            VAR_7 = -1;
        break;
    }

    return VAR_7;
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/vpt.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
     struct list_head *head = &v->arch.hvm_vcpu.tm_list;
     struct periodic_time *pt, *temp, *earliest_pt;
     uint64_t max_lag;
-    int irq, is_lapic, pt_vector;
+    int irq, pt_vector = -1;
 
     spin_lock(&v->arch.hvm_vcpu.tm_lock);
 
@@ -39,29 +39,26 @@
 
     earliest_pt->irq_issued = 1;
     irq = earliest_pt->irq;
-    is_lapic = (earliest_pt->source == PTSRC_lapic);
 
     spin_unlock(&v->arch.hvm_vcpu.tm_lock);
 
-    /*
-     * If periodic timer interrut is handled by lapic, its vector in
-     * IRR is returned and used to set eoi_exit_bitmap for virtual
-     * interrupt delivery case. Otherwise return -1 to do nothing.
-     */
-    if ( is_lapic )
+    switch ( earliest_pt->source )
     {
+    case PTSRC_lapic:
+        /*
+         * If periodic timer interrupt is handled by lapic, its vector in
+         * IRR is returned and used to set eoi_exit_bitmap for virtual
+         * interrupt delivery case. Otherwise return -1 to do nothing.
+         */
         vlapic_set_irq(vcpu_vlapic(v), irq, 0);
         pt_vector = irq;
-    }
-    else
-    {
+        break;
+
+    case PTSRC_isa:
         hvm_isa_irq_deassert(v->domain, irq);
         if ( platform_legacy_irq(irq) && vlapic_accept_pic_intr(v) &&
              v->domain->arch.hvm_domain.vpic[irq >> 3].int_output )
-        {
             hvm_isa_irq_assert(v->domain, irq, NULL);
-            pt_vector = -1;
-        }
         else
         {
             pt_vector = hvm_isa_irq_assert(v->domain, irq, vioapic_get_vector);
@@ -72,6 +69,17 @@
             if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )
                 pt_vector = -1;
         }
+        break;
+
+    case PTSRC_ioapic:
+        /*
+         * NB: At the moment IO-APIC routed interrupts generated by vpt devices
+         * (HPET) are edge-triggered.
+         */
+        pt_vector = hvm_ioapic_assert(v->domain, irq, false);
+        if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )
+            pt_vector = -1;
+        break;
     }
 
     return pt_vector;","{'deleted_lines': ['    int irq, is_lapic, pt_vector;', '    is_lapic = (earliest_pt->source == PTSRC_lapic);', '    /*', '     * If periodic timer interrut is handled by lapic, its vector in', '     * IRR is returned and used to set eoi_exit_bitmap for virtual', '     * interrupt delivery case. Otherwise return -1 to do nothing.', '     */', '    if ( is_lapic )', '    }', '    else', '    {', '        {', '            pt_vector = -1;', '        }'], 'added_lines': ['    int irq, pt_vector = -1;', '    switch ( earliest_pt->source )', '    case PTSRC_lapic:', '        /*', '         * If periodic timer interrupt is handled by lapic, its vector in', '         * IRR is returned and used to set eoi_exit_bitmap for virtual', '         * interrupt delivery case. Otherwise return -1 to do nothing.', '         */', '        break;', '', '    case PTSRC_isa:', '        break;', '', '    case PTSRC_ioapic:', '        /*', '         * NB: At the moment IO-APIC routed interrupts generated by vpt devices', '         * (HPET) are edge-triggered.', '         */', '        pt_vector = hvm_ioapic_assert(v->domain, irq, false);', '        if ( pt_vector < 0 || !vlapic_test_irq(vcpu_vlapic(v), pt_vector) )', '            pt_vector = -1;', '        break;']}",True,"An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (unexpectedly high interrupt number, array overrun, and hypervisor crash) or possibly gain hypervisor privileges by setting up an HPET timer to deliver interrupts in IO-APIC mode, aka vHPET interrupt injection.",8.8,HIGH,2,valid,2018-05-08T17:12:10Z,2
CVE-2018-10982,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/vpt: add support for IO-APIC routed interrupts

And modify the HPET code to make use of it. Currently HPET interrupts
are always treated as ISA and thus injected through the vPIC. This is
wrong because HPET interrupts when not in legacy mode should be
injected from the IO-APIC.

To make things worse, the supported interrupt routing values are set
to [20..23], which clearly falls outside of the ISA range, thus
leading to an ASSERT in debug builds or memory corruption in non-debug
builds because the interrupt injection code will write out of the
bounds of the arch.hvm_domain.vpic array.

Since the HPET interrupt source can change between ISA and IO-APIC
always destroy the timer before changing the mode, or else Xen risks
changing it while the timer is active.

Note that vpt interrupt injection is racy in the sense that the
vIO-APIC RTE entry can be written by the guest in between the call to
pt_irq_masked and hvm_ioapic_assert, or the call to pt_update_irq and
pt_intr_post. Those are not deemed to be security issues, but rather
quirks of the current implementation. In the worse case the guest
might lose interrupts or get multiple interrupt vectors injected for
the same timer source.

This is part of XSA-261.

Address actual and potential compiler warnings. Fix formatting.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",14c3f68a57361f20be33ec3848f83d8636a0d34e,https://github.com/xen-project/xen/commit/14c3f68a57361f20be33ec3848f83d8636a0d34e,xen/arch/x86/hvm/hpet.c,hpet_set_timer,"static void hpet_set_timer(HPETState *h, unsigned int tn,
uint64_t guest_time)
{
uint64_t tn_cmp, cur_tick, diff;
unsigned int irq;
unsigned int oneshot;
ASSERT(tn < HPET_TIMER_NUM);
ASSERT(rw_is_write_locked(&h->lock));
if ( (tn == 0) && (h->hpet.config & HPET_CFG_LEGACY) )
{
pit_stop_channel0_irq(&vhpet_domain(h)->arch.vpit);
}
if ( !timer_enabled(h, tn) )
return;
tn_cmp   = hpet_get_comparator(h, tn, guest_time);
cur_tick = hpet_read_maincounter(h, guest_time);
if ( timer_is_32bit(h, tn) )
{
tn_cmp   = (uint32_t)tn_cmp;
cur_tick = (uint32_t)cur_tick;
}
diff = tn_cmp - cur_tick;
if ( (int64_t)diff < 0 )
diff = (timer_is_32bit(h, tn) && (-diff > HPET_TINY_TIME_SPAN))
? (uint32_t)diff : 0;
if ( (tn <= 1) && (h->hpet.config & HPET_CFG_LEGACY) )
irq = (tn == 0) ? 0 : 8;
else
irq = timer_int_route(h, tn);
oneshot = !timer_is_periodic(h, tn);
TRACE_2_LONG_4D(TRC_HVM_EMUL_HPET_START_TIMER, tn, irq,
TRC_PAR_LONG(hpet_tick_to_ns(h, diff)),
TRC_PAR_LONG(oneshot ? 0LL :
hpet_tick_to_ns(h, h->hpet.period[tn])));
create_periodic_time(vhpet_vcpu(h), &h->pt[tn],
hpet_tick_to_ns(h, diff),
oneshot ? 0 : hpet_tick_to_ns(h, h->hpet.period[tn]),
irq, NULL, NULL);
}","static void hpet_set_timer(HPETState *VAR_0, unsigned int VAR_1,
uint64_t VAR_2)
{
uint64_t VAR_3, VAR_4, VAR_5;
unsigned int VAR_6;
unsigned int VAR_7;
ASSERT(VAR_1 < VAR_8);
ASSERT(rw_is_write_locked(&VAR_0->lock));
if ( (VAR_1 == 0) && (VAR_0->hpet.config & VAR_9) )
{
pit_stop_channel0_irq(&vhpet_domain(VAR_0)->arch.vpit);
}
if ( !timer_enabled(VAR_0, VAR_1) )
return;
VAR_3   = hpet_get_comparator(VAR_0, VAR_1, VAR_2);
VAR_4 = hpet_read_maincounter(VAR_0, VAR_2);
if ( timer_is_32bit(VAR_0, VAR_1) )
{
VAR_3   = (uint32_t)VAR_3;
VAR_4 = (uint32_t)VAR_4;
}
VAR_5 = VAR_3 - VAR_4;
if ( (int64_t)VAR_5 < 0 )
VAR_5 = (timer_is_32bit(VAR_0, VAR_1) && (-VAR_5 > VAR_10))
? (uint32_t)VAR_5 : 0;
if ( (VAR_1 <= 1) && (VAR_0->hpet.config & VAR_9) )
VAR_6 = (VAR_1 == 0) ? 0 : 8;
else
VAR_6 = timer_int_route(VAR_0, VAR_1);
VAR_7 = !timer_is_periodic(VAR_0, VAR_1);
TRACE_2_LONG_4D(VAR_11, VAR_1, VAR_6,
TRC_PAR_LONG(hpet_tick_to_ns(VAR_0, VAR_5)),
TRC_PAR_LONG(VAR_7 ? 0LL :
hpet_tick_to_ns(VAR_0, VAR_0->hpet.period[VAR_1])));
create_periodic_time(vhpet_vcpu(VAR_0), &VAR_0->pt[VAR_1],
hpet_tick_to_ns(VAR_0, VAR_5),
VAR_7 ? 0 : hpet_tick_to_ns(VAR_0, VAR_0->hpet.period[VAR_1]),
VAR_6, NULL, NULL);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/hpet.c/vul/before/0.json,"static void hpet_set_timer(HPETState *h, unsigned int tn,
                           uint64_t guest_time)
{
    uint64_t tn_cmp, cur_tick, diff;
    unsigned int irq;
    unsigned int oneshot;

    ASSERT(tn < HPET_TIMER_NUM);
    ASSERT(rw_is_write_locked(&h->lock));

    if ( (tn == 0) && (h->hpet.config & HPET_CFG_LEGACY) )
    {
        /* HPET specification requires PIT shouldn't generate
         * interrupts if LegacyReplacementRoute is set for timer0 */
        pit_stop_channel0_irq(&vhpet_domain(h)->arch.vpit);
    }

    if ( !timer_enabled(h, tn) )
        return;

    tn_cmp   = hpet_get_comparator(h, tn, guest_time);
    cur_tick = hpet_read_maincounter(h, guest_time);
    if ( timer_is_32bit(h, tn) )
    {
        tn_cmp   = (uint32_t)tn_cmp;
        cur_tick = (uint32_t)cur_tick;
    }

    diff = tn_cmp - cur_tick;

    /*
     * Detect time values set in the past. This is hard to do for 32-bit
     * comparators as the timer does not have to be set that far in the future
     * for the counter difference to wrap a 32-bit signed integer. We fudge
     * by looking for a 'small' time value in the past.
     */
    if ( (int64_t)diff < 0 )
        diff = (timer_is_32bit(h, tn) && (-diff > HPET_TINY_TIME_SPAN))
            ? (uint32_t)diff : 0;

    destroy_periodic_time(&h->pt[tn]);
    if ( (tn <= 1) && (h->hpet.config & HPET_CFG_LEGACY) )
    {
        /* if LegacyReplacementRoute bit is set, HPET specification requires
           timer0 be routed to IRQ0 in NON-APIC or IRQ2 in the I/O APIC,
           timer1 be routed to IRQ8 in NON-APIC or IRQ8 in the I/O APIC. */
        irq = (tn == 0) ? 0 : 8;
        h->pt[tn].source = PTSRC_isa;
    }
    else
    {
        irq = timer_int_route(h, tn);
        h->pt[tn].source = PTSRC_ioapic;
    }

    /*
     * diff is the time from now when the timer should fire, for a periodic
     * timer we also need the period which may be different because time may
     * have elapsed between the time the comparator was written and the timer
     * being enabled (now).
     */
    oneshot = !timer_is_periodic(h, tn);
    TRACE_2_LONG_4D(TRC_HVM_EMUL_HPET_START_TIMER, tn, irq,
                    TRC_PAR_LONG(hpet_tick_to_ns(h, diff)),
                    TRC_PAR_LONG(oneshot ? 0LL :
                                 hpet_tick_to_ns(h, h->hpet.period[tn])));
    create_periodic_time(vhpet_vcpu(h), &h->pt[tn],
                         hpet_tick_to_ns(h, diff),
                         oneshot ? 0 : hpet_tick_to_ns(h, h->hpet.period[tn]),
                         irq, NULL, NULL);
}","static void hpet_set_timer(HPETState *VAR_0, unsigned int VAR_1,
                           uint64_t VAR_2)
{
    uint64_t VAR_3, VAR_4, VAR_5;
    unsigned int VAR_6;
    unsigned int VAR_7;

    ASSERT(VAR_1 < VAR_8);
    ASSERT(rw_is_write_locked(&VAR_0->lock));

    if ( (VAR_1 == 0) && (VAR_0->hpet.config & VAR_9) )
    {
        /* COMMENT_0 */
                                                                    
        pit_stop_channel0_irq(&vhpet_domain(VAR_0)->arch.vpit);
    }

    if ( !timer_enabled(VAR_0, VAR_1) )
        return;

    VAR_3   = hpet_get_comparator(VAR_0, VAR_1, VAR_2);
    VAR_4 = hpet_read_maincounter(VAR_0, VAR_2);
    if ( timer_is_32bit(VAR_0, VAR_1) )
    {
        VAR_3   = (uint32_t)VAR_3;
        VAR_4 = (uint32_t)VAR_4;
    }

    VAR_5 = VAR_3 - VAR_4;

    /* COMMENT_2 */
                                                                        
                                                                              
                                                                           
                                                       
       
    if ( (int64_t)VAR_5 < 0 )
        VAR_5 = (timer_is_32bit(VAR_0, VAR_1) && (-VAR_5 > VAR_10))
            ? (uint32_t)VAR_5 : 0;

    destroy_periodic_time(&VAR_0->pt[VAR_1]);
    if ( (VAR_1 <= 1) && (VAR_0->hpet.config & VAR_9) )
    {
        /* COMMENT_8 */
                                                                        
                                                                           
        VAR_6 = (VAR_1 == 0) ? 0 : 8;
        VAR_0->pt[VAR_1].source = VAR_11;
    }
    else
    {
        VAR_6 = timer_int_route(VAR_0, VAR_1);
        VAR_0->pt[VAR_1].source = VAR_12;
    }

    /* COMMENT_11 */
                                                                           
                                                                            
                                                                             
                           
       
    VAR_7 = !timer_is_periodic(VAR_0, VAR_1);
    TRACE_2_LONG_4D(VAR_13, VAR_1, VAR_6,
                    TRC_PAR_LONG(hpet_tick_to_ns(VAR_0, VAR_5)),
                    TRC_PAR_LONG(VAR_7 ? 0LL :
                                 hpet_tick_to_ns(VAR_0, VAR_0->hpet.period[VAR_1])));
    create_periodic_time(vhpet_vcpu(VAR_0), &VAR_0->pt[VAR_1],
                         hpet_tick_to_ns(VAR_0, VAR_5),
                         VAR_7 ? 0 : hpet_tick_to_ns(VAR_0, VAR_0->hpet.period[VAR_1]),
                         VAR_6, NULL, NULL);
}",xen-project/xen/14c3f68a57361f20be33ec3848f83d8636a0d34e/hpet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,13 +38,20 @@
         diff = (timer_is_32bit(h, tn) && (-diff > HPET_TINY_TIME_SPAN))
             ? (uint32_t)diff : 0;
 
+    destroy_periodic_time(&h->pt[tn]);
     if ( (tn <= 1) && (h->hpet.config & HPET_CFG_LEGACY) )
+    {
         /* if LegacyReplacementRoute bit is set, HPET specification requires
            timer0 be routed to IRQ0 in NON-APIC or IRQ2 in the I/O APIC,
            timer1 be routed to IRQ8 in NON-APIC or IRQ8 in the I/O APIC. */
         irq = (tn == 0) ? 0 : 8;
+        h->pt[tn].source = PTSRC_isa;
+    }
     else
+    {
         irq = timer_int_route(h, tn);
+        h->pt[tn].source = PTSRC_ioapic;
+    }
 
     /*
      * diff is the time from now when the timer should fire, for a periodic","{'deleted_lines': [], 'added_lines': ['    destroy_periodic_time(&h->pt[tn]);', '    {', '        h->pt[tn].source = PTSRC_isa;', '    }', '    {', '        h->pt[tn].source = PTSRC_ioapic;', '    }']}",True,"An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (unexpectedly high interrupt number, array overrun, and hypervisor crash) or possibly gain hypervisor privileges by setting up an HPET timer to deliver interrupts in IO-APIC mode, aka vHPET interrupt injection.",8.8,HIGH,2,valid,2018-05-08T17:12:10Z,2
CVE-2018-11355,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"rtcp: fix buffer overflow in transport-cc dissection

When the packet status chunks cover more packets than advertised in the
packet status count field, fail rather than writing past the end.
https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01#section-3.1.2

Bug: 14673
Change-Id: If90baef3610d8f884b0772a4b81d6dcb4ebc9227
Fixes: v2.5.0rc0-2533-ga584eab239 (""New RTCP dissector for transport-cc"")
Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6464
Reviewed-on: https://code.wireshark.org/review/27527
Petri-Dish: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot
Reviewed-by: Rui Zhang <rzhang@grandstream.cn>
Reviewed-by: Peter Wu <peter@lekensteyn.nl>
(cherry picked from commit 4413d43962e1aed72a285ae8fb68780bb64a11fe)
Reviewed-on: https://code.wireshark.org/review/27536",99d27a5fd2c540f837154aca3b3647f5ccfa0c33,https://github.com/wireshark/wireshark/commit/99d27a5fd2c540f837154aca3b3647f5ccfa0c33,epan/dissectors/packet-rtcp.c,dissect_rtcp_rtpfb_transport_cc,"static int
dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, int pkt_len)
{
proto_tree *fci_tree, *pkt_chunk_tree, *recv_delta_tree;
proto_item *item       = NULL;
guint8  *delta_array;
guint16 *pkt_seq_array;
guint32 i, pkt_base_seq, pkt_seq_num, pkt_count;
gint fci_length        = pkt_len - RTCP_HEADER_LENGTH;
int delta_index        = 0;
int padding_length     = offset;
fci_tree = proto_tree_add_subtree_format( rtcp_tree, tvb, offset, fci_length, ett_ssrc, NULL, ""Transport-cc"" );
proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_base_seq, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_base_seq );
offset += 2;
pkt_seq_num = pkt_base_seq;
proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_stats_cnt, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_count );
offset += 2;
delta_array   = wmem_alloc0_array( wmem_packet_scope(), gint8, pkt_count );
pkt_seq_array = wmem_alloc0_array( wmem_packet_scope(), gint16, pkt_count );
proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_ref_time, tvb, offset, 3, ENC_BIG_ENDIAN );
offset += 3;
proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_fb_pkt_cnt, tvb, offset, 1, ENC_BIG_ENDIAN );
offset += 1;
pkt_chunk_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Packet Chunks"" );
for (i = 0; i < pkt_count; )
{
guint32 chunk = 0;
item = proto_tree_add_item_ret_uint( pkt_chunk_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_chunk, tvb, offset, 2, ENC_BIG_ENDIAN, &chunk );
if ( !(chunk & 0x8000) )
{
int length = chunk & 0x1FFF;
if ( length <= 0 )
{
delta_array = NULL;
pkt_seq_array = NULL;
offset += 2;
return offset;
}
if ( !(chunk & 0x6000) )
{
proto_item_append_text( item, "" [Run Length Chunk] Packet not received. Length : %d"", length);
pkt_seq_num += length;
}
else if ( chunk & 0x2000 )
{
proto_item_append_text( item, "" [Run Length Chunk] Small Delta. Length : %d"", length);
for (int j = 0; j < length; j++)
{
delta_array[delta_index+j] = 1;
pkt_seq_array[delta_index+j] = pkt_seq_num++;
}
delta_index += length;
}
else if ( chunk & 0x4000 )
{
proto_item_append_text( item, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", length);
for (int j = 0; j < length; j++)
{
delta_array[delta_index+j] = 2;
pkt_seq_array[delta_index+j] = pkt_seq_num++;
}
delta_index += length;
}
else
{
proto_item_append_text( item, "" [Run Length Chunk] [Reserved]. Length : %d"", length);
pkt_seq_num += length;
}
i += length;
}
else
{
wmem_strbuf_t* status = wmem_strbuf_new(wmem_packet_scope(), ""|"");
if ( !(chunk & 0x4000) )
{
int data = chunk & 0x3FFF;
int chunk_count = 14;
for (int k = 0; k < chunk_count; k++)
{
if ( (data & (0x2000>>k)) == 0 )
{
if ( i + k < pkt_count )
{
wmem_strbuf_append(status, "" N |"");
pkt_seq_num++;
}
else
{
wmem_strbuf_append(status, "" _ |"");
}
}
else
{
wmem_strbuf_append(status, "" R |"");
delta_array[delta_index] = 1;
pkt_seq_array[delta_index] = pkt_seq_num++;
delta_index++;
}
}
proto_item_append_text( item, "" [1 bit Status Vector Chunk]: %s"", wmem_strbuf_get_str(status));
i += chunk_count;
}
else
{
int chunk_count = 7;
int data = chunk & 0x3FFF;
for (int k = 0; k < chunk_count; k++)
{
switch ( (data & (0x3000 >> (2*k))) >> ( 2 * (6-k) ) )
{
case 0: 
if ( i + k < pkt_count )
{
wmem_strbuf_append(status, "" NR |"");
pkt_seq_num++;
}
else
{
wmem_strbuf_append(status, "" __ |"");
}
break;
case 1: 
wmem_strbuf_append(status, "" SD |"");
delta_array[delta_index] = 1;
pkt_seq_array[delta_index] = pkt_seq_num++;
delta_index++;
break;
case 2: 
wmem_strbuf_append(status, "" LD |"");
delta_array[delta_index] = 2;
pkt_seq_array[delta_index] = pkt_seq_num++;
delta_index++;
break;
case 3: 
default:
wmem_strbuf_append(status, "" WO |"");
pkt_seq_num++;
break;
}
}
proto_item_append_text( item, "" [2 bits Status Vector Chunk]: %s"", wmem_strbuf_get_str(status));
i += chunk_count;
}
}
offset += 2;
}
recv_delta_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Recv Delta"" );
for (i = 0; i < pkt_count; i++ )
{
if ( delta_array[i] == 1 )
{
guint32 delta;
item = proto_tree_add_item_ret_uint( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_1_byte, tvb, offset, 1, ENC_BIG_ENDIAN, &delta );
proto_item_append_text( item, "" Small Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000);
offset += 1;
}
else if ( delta_array[i] == 2 )
{
gint16 delta;
item = proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_2_bytes, tvb, offset, 2, ENC_BIG_ENDIAN);
delta = tvb_get_ntohs(tvb, offset);
if ( delta < 0 )
{
proto_item_append_text( item, "" Negative Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 );
}
else
{
proto_item_append_text( item, "" Large Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 );
}
offset += 2;
}
else
{
break;
}
}
padding_length = fci_length - (offset - padding_length);
if ( padding_length > 0 )
{
proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_padding, tvb, offset, padding_length, ENC_BIG_ENDIAN );
offset += padding_length;
}
delta_array = NULL;
pkt_seq_array = NULL;
return offset;
}","static int
dissect_rtcp_rtpfb_transport_cc( tvbuff_t *VAR_0, int VAR_1, proto_tree *VAR_2, int VAR_3)
{
proto_tree *VAR_4, *VAR_5, *VAR_6;
proto_item *VAR_7       = NULL;
guint8  *VAR_8;
guint16 *VAR_9;
guint32 VAR_10, VAR_11, VAR_12, VAR_13;
gint VAR_14        = VAR_3 - VAR_15;
int VAR_16        = 0;
int VAR_17     = VAR_1;
VAR_4 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_1, VAR_14, VAR_18, NULL, ""Transport-cc"" );
proto_tree_add_item_ret_uint( VAR_4, VAR_19, VAR_0, VAR_1, 2, VAR_20, &VAR_11 );
VAR_1 += 2;
VAR_12 = VAR_11;
proto_tree_add_item_ret_uint( VAR_4, VAR_21, VAR_0, VAR_1, 2, VAR_20, &VAR_13 );
VAR_1 += 2;
VAR_8   = wmem_alloc0_array( wmem_packet_scope(), VAR_22, VAR_13 );
VAR_9 = wmem_alloc0_array( wmem_packet_scope(), VAR_23, VAR_13 );
proto_tree_add_item( VAR_4, VAR_24, VAR_0, VAR_1, 3, VAR_20 );
VAR_1 += 3;
proto_tree_add_item( VAR_4, VAR_25, VAR_0, VAR_1, 1, VAR_20 );
VAR_1 += 1;
VAR_5 = proto_tree_add_subtree_format( VAR_4, VAR_0, VAR_1, 0, VAR_18, NULL, ""Packet Chunks"" );
for (VAR_10 = 0; VAR_10 < VAR_13; )
{
guint32 VAR_26 = 0;
VAR_7 = proto_tree_add_item_ret_uint( VAR_5, VAR_27, VAR_0, VAR_1, 2, VAR_20, &VAR_26 );
if ( !(VAR_26 & 0x8000) )
{
int VAR_28 = VAR_26 & 0x1FFF;
if ( VAR_28 <= 0 )
{
VAR_8 = NULL;
VAR_9 = NULL;
VAR_1 += 2;
return VAR_1;
}
if ( !(VAR_26 & 0x6000) )
{
proto_item_append_text( VAR_7, "" [Run Length Chunk] Packet not received. Length : %d"", VAR_28);
VAR_12 += VAR_28;
}
else if ( VAR_26 & 0x2000 )
{
proto_item_append_text( VAR_7, "" [Run Length Chunk] Small Delta. Length : %d"", VAR_28);
for (int VAR_29 = 0; VAR_29 < VAR_28; VAR_29++)
{
VAR_8[VAR_16+VAR_29] = 1;
VAR_9[VAR_16+VAR_29] = VAR_12++;
}
VAR_16 += VAR_28;
}
else if ( VAR_26 & 0x4000 )
{
proto_item_append_text( VAR_7, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", VAR_28);
for (int VAR_29 = 0; VAR_29 < VAR_28; VAR_29++)
{
VAR_8[VAR_16+VAR_29] = 2;
VAR_9[VAR_16+VAR_29] = VAR_12++;
}
VAR_16 += VAR_28;
}
else
{
proto_item_append_text( VAR_7, "" [Run Length Chunk] [Reserved]. Length : %d"", VAR_28);
VAR_12 += VAR_28;
}
VAR_10 += VAR_28;
}
else
{
wmem_strbuf_t* VAR_30 = wmem_strbuf_new(wmem_packet_scope(), ""|"");
if ( !(VAR_26 & 0x4000) )
{
int VAR_31 = VAR_26 & 0x3FFF;
int VAR_32 = 14;
for (int VAR_33 = 0; VAR_33 < VAR_32; VAR_33++)
{
if ( (VAR_31 & (0x2000>>VAR_33)) == 0 )
{
if ( VAR_10 + VAR_33 < VAR_13 )
{
wmem_strbuf_append(VAR_30, "" N |"");
VAR_12++;
}
else
{
wmem_strbuf_append(VAR_30, "" _ |"");
}
}
else
{
wmem_strbuf_append(VAR_30, "" R |"");
VAR_8[VAR_16] = 1;
VAR_9[VAR_16] = VAR_12++;
VAR_16++;
}
}
proto_item_append_text( VAR_7, "" [1 bit Status Vector Chunk]: %s"", wmem_strbuf_get_str(VAR_30));
VAR_10 += VAR_32;
}
else
{
int VAR_32 = 7;
int VAR_31 = VAR_26 & 0x3FFF;
for (int VAR_33 = 0; VAR_33 < VAR_32; VAR_33++)
{
switch ( (VAR_31 & (0x3000 >> (2*VAR_33))) >> ( 2 * (6-VAR_33) ) )
{
case 0: 
if ( VAR_10 + VAR_33 < VAR_13 )
{
wmem_strbuf_append(VAR_30, "" NR |"");
VAR_12++;
}
else
{
wmem_strbuf_append(VAR_30, "" __ |"");
}
break;
case 1: 
wmem_strbuf_append(VAR_30, "" SD |"");
VAR_8[VAR_16] = 1;
VAR_9[VAR_16] = VAR_12++;
VAR_16++;
break;
case 2: 
wmem_strbuf_append(VAR_30, "" LD |"");
VAR_8[VAR_16] = 2;
VAR_9[VAR_16] = VAR_12++;
VAR_16++;
break;
case 3: 
default:
wmem_strbuf_append(VAR_30, "" WO |"");
VAR_12++;
break;
}
}
proto_item_append_text( VAR_7, "" [2 bits Status Vector Chunk]: %s"", wmem_strbuf_get_str(VAR_30));
VAR_10 += VAR_32;
}
}
VAR_1 += 2;
}
VAR_6 = proto_tree_add_subtree_format( VAR_4, VAR_0, VAR_1, 0, VAR_18, NULL, ""Recv Delta"" );
for (VAR_10 = 0; VAR_10 < VAR_13; VAR_10++ )
{
if ( VAR_8[VAR_10] == 1 )
{
guint32 VAR_34;
VAR_7 = proto_tree_add_item_ret_uint( VAR_6, VAR_35, VAR_0, VAR_1, 1, VAR_20, &VAR_34 );
proto_item_append_text( VAR_7, "" Small Delta: [seq: %d] %lf ms"", VAR_9[VAR_10], VAR_34*250.0/1000);
VAR_1 += 1;
}
else if ( VAR_8[VAR_10] == 2 )
{
gint16 VAR_34;
VAR_7 = proto_tree_add_item( VAR_6, VAR_36, VAR_0, VAR_1, 2, VAR_20);
VAR_34 = tvb_get_ntohs(VAR_0, VAR_1);
if ( VAR_34 < 0 )
{
proto_item_append_text( VAR_7, "" Negative Delta: [seq: %d] %lf ms"", VAR_9[VAR_10], VAR_34*250.0/1000 );
}
else
{
proto_item_append_text( VAR_7, "" Large Delta: [seq: %d] %lf ms"", VAR_9[VAR_10], VAR_34*250.0/1000 );
}
VAR_1 += 2;
}
else
{
break;
}
}
VAR_17 = VAR_14 - (VAR_1 - VAR_17);
if ( VAR_17 > 0 )
{
proto_tree_add_item( VAR_6, VAR_37, VAR_0, VAR_1, VAR_17, VAR_20 );
VAR_1 += VAR_17;
}
VAR_8 = NULL;
VAR_9 = NULL;
return VAR_1;
}",wireshark/99d27a5fd2c540f837154aca3b3647f5ccfa0c33/packet-rtcp.c/vul/before/0.json,"static int
dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rtcp_tree, int pkt_len)
{
    proto_tree *fci_tree, *pkt_chunk_tree, *recv_delta_tree;
    proto_item *item       = NULL;
    guint8  *delta_array;
    guint16 *pkt_seq_array;
    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count, delta_index = 0;
    gint fci_length        = pkt_len - RTCP_HEADER_LENGTH;
    int padding_length     = offset;

    fci_tree = proto_tree_add_subtree_format( rtcp_tree, tvb, offset, fci_length, ett_ssrc, NULL, ""Transport-cc"" );

    /* base sequence number */
    proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_base_seq, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_base_seq );
    offset += 2;
    pkt_seq_num = pkt_base_seq;

    /* packet status count */
    proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_stats_cnt, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_count );
    offset += 2;

    delta_array   = wmem_alloc0_array( wmem_packet_scope(), gint8, pkt_count );
    pkt_seq_array = wmem_alloc0_array( wmem_packet_scope(), gint16, pkt_count );

    /* reference time */
    proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_ref_time, tvb, offset, 3, ENC_BIG_ENDIAN );
    offset += 3;

    /* feedback packet count */
    proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_fb_pkt_cnt, tvb, offset, 1, ENC_BIG_ENDIAN );
    offset += 1;

    /* packet chunk */
    pkt_chunk_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Packet Chunks"" );

    for (i = 0; i < pkt_count; )
    {
        guint32 chunk = 0;
        item = proto_tree_add_item_ret_uint( pkt_chunk_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_chunk, tvb, offset, 2, ENC_BIG_ENDIAN, &chunk );

        /* Packet Status Symbols */
        /**
         * 00 Packet not received
         * 01 Packet received, small delta
         * 10 Packet received, large or negative delta
         * 11 [Reserved]
         */
        if ( !(chunk & 0x8000) )
        {
            /* Run length chunk, first bit is zero */
            guint length = chunk & 0x1FFF;

            if ( length <= 0 || pkt_count - delta_index < length )
            {
                /* Malformed packet (zero or too many packets), stop parsing. */
                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                offset += 2;
                return offset;
            }

            if ( !(chunk & 0x6000) )
            {
                proto_item_append_text( item, "" [Run Length Chunk] Packet not received. Length : %d"", length);
                pkt_seq_num += length;
            }
            else if ( chunk & 0x2000 )
            {
                proto_item_append_text( item, "" [Run Length Chunk] Small Delta. Length : %d"", length);
                for (guint j = 0; j < length; j++)
                {
                    /*1 means 1 byte delta, 2 means 2 bytes delta*/
                    delta_array[delta_index+j] = 1;
                    pkt_seq_array[delta_index+j] = pkt_seq_num++;
                }
                delta_index += length;
            }
            else if ( chunk & 0x4000 )
            {
                proto_item_append_text( item, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", length);
                for (guint j = 0; j < length; j++)
                {
                    delta_array[delta_index+j] = 2;
                    pkt_seq_array[delta_index+j] = pkt_seq_num++;
                }
                delta_index += length;
            }
            else
            {
                proto_item_append_text( item, "" [Run Length Chunk] [Reserved]. Length : %d"", length);
                pkt_seq_num += length;
            }

            i += length;

        }
        else
        {
            wmem_strbuf_t* status = wmem_strbuf_new(wmem_packet_scope(), ""|"");

            /* Status Vector Chunk, first bit is one */
            if ( !(chunk & 0x4000) )
            {
                /* 1 bit symbols */

                int data = chunk & 0x3FFF;
                int chunk_count = 14;

                for (int k = 0; k < chunk_count; k++)
                {
                    if ( (data & (0x2000>>k)) == 0 )
                    {
                        if ( i + k < pkt_count )
                        {
                            wmem_strbuf_append(status, "" N |"");
                            pkt_seq_num++;
                        }
                        else
                        {
                            /* padding */
                            wmem_strbuf_append(status, "" _ |"");
                        }
                    }
                    else
                    {
                        if (delta_index >= pkt_count) {
                            /* Malformed packet (too many status packets). */
                            proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                            offset += 2;
                            return offset;
                        }
                        wmem_strbuf_append(status, "" R |"");
                        delta_array[delta_index] = 1;
                        pkt_seq_array[delta_index] = pkt_seq_num++;
                        delta_index++;
                    }
                }
                proto_item_append_text( item, "" [1 bit Status Vector Chunk]: %s"", wmem_strbuf_get_str(status));
                i += chunk_count;
            }
            else
            {
                /* 2 bits symbols */
                int chunk_count = 7;
                int data = chunk & 0x3FFF;

                for (int k = 0; k < chunk_count; k++)
                {
                    switch ( (data & (0x3000 >> (2*k))) >> ( 2 * (6-k) ) )
                    {
                        case 0: /*00 packet not received*/
                            if ( i + k < pkt_count )
                            {
                                wmem_strbuf_append(status, "" NR |"");
                                pkt_seq_num++;
                            }
                            else
                            {
                                /*padding*/
                                wmem_strbuf_append(status, "" __ |"");
                            }
                            break;

                        case 1: /*01 Packet received, small delta*/
                            if (delta_index >= pkt_count) {
                                /* Malformed packet (too many status packets). */
                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                                offset += 2;
                                return offset;
                            }
                            wmem_strbuf_append(status, "" SD |"");
                            delta_array[delta_index] = 1;
                            pkt_seq_array[delta_index] = pkt_seq_num++;
                            delta_index++;
                            break;

                        case 2: /*10 Packet received, large or negative delta*/
                            if (delta_index >= pkt_count) {
                                /* Malformed packet (too many status packets). */
                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                                offset += 2;
                                return offset;
                            }
                            wmem_strbuf_append(status, "" LD |"");
                            delta_array[delta_index] = 2;
                            pkt_seq_array[delta_index] = pkt_seq_num++;
                            delta_index++;
                            break;

                        case 3: /*11 packet received, w/o(wrong? overflow?) timestamp*/
                        default:
                            /*TODO: process overflow status which is not details on draft.*/
                            wmem_strbuf_append(status, "" WO |"");
                            pkt_seq_num++;
                            break;

                    }
                }

                proto_item_append_text( item, "" [2 bits Status Vector Chunk]: %s"", wmem_strbuf_get_str(status));
                i += chunk_count;
            }

        }

        offset += 2;
    }

    /* recv delta */
    recv_delta_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Recv Delta"" );
    for (i = 0; i < pkt_count; i++ )
    {
        if ( delta_array[i] == 1 )
        {
            /*1 byte delta*/
            guint32 delta;
            item = proto_tree_add_item_ret_uint( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_1_byte, tvb, offset, 1, ENC_BIG_ENDIAN, &delta );

            proto_item_append_text( item, "" Small Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000);

            offset += 1;
        }
        else if ( delta_array[i] == 2 )
        {
            /*2 bytes delta*/
            gint16 delta;
            item = proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_2_bytes, tvb, offset, 2, ENC_BIG_ENDIAN);
            delta = tvb_get_ntohs(tvb, offset);

            if ( delta < 0 )
            {
                proto_item_append_text( item, "" Negative Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 );
            }
            else
            {
                proto_item_append_text( item, "" Large Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 );
            }

            offset += 2;
        }
        else
        {
            /*End with 0*/
            break;
        }
    }

    /* padding */
    padding_length = fci_length - (offset - padding_length);
    if ( padding_length > 0 )
    {
        proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_padding, tvb, offset, padding_length, ENC_BIG_ENDIAN );
        offset += padding_length;
    }

    /* delta_array / pkt_seq_array will be freed out of wmem_packet_scope*/
    delta_array = NULL;
    pkt_seq_array = NULL;

    return offset;
}","static int
dissect_rtcp_rtpfb_transport_cc( tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2, proto_tree *VAR_3, int VAR_4)
{
    proto_tree *VAR_5, *VAR_6, *VAR_7;
    proto_item *VAR_8       = NULL;
    guint8  *VAR_9;
    guint16 *VAR_10;
    guint32 VAR_11, VAR_12, VAR_13, VAR_14, VAR_15 = 0;
    gint VAR_16        = VAR_4 - VAR_17;
    int VAR_18     = VAR_1;

    VAR_5 = proto_tree_add_subtree_format( VAR_3, VAR_0, VAR_1, VAR_16, VAR_19, NULL, ""Transport-cc"" );

    /* COMMENT_0 */
    proto_tree_add_item_ret_uint( VAR_5, VAR_20, VAR_0, VAR_1, 2, VAR_21, &VAR_12 );
    VAR_1 += 2;
    VAR_13 = VAR_12;

    /* COMMENT_1 */
    proto_tree_add_item_ret_uint( VAR_5, VAR_22, VAR_0, VAR_1, 2, VAR_21, &VAR_14 );
    VAR_1 += 2;

    VAR_9   = wmem_alloc0_array( wmem_packet_scope(), VAR_23, VAR_14 );
    VAR_10 = wmem_alloc0_array( wmem_packet_scope(), VAR_24, VAR_14 );

    /* COMMENT_2 */
    proto_tree_add_item( VAR_5, VAR_25, VAR_0, VAR_1, 3, VAR_21 );
    VAR_1 += 3;

    /* COMMENT_3 */
    proto_tree_add_item( VAR_5, VAR_26, VAR_0, VAR_1, 1, VAR_21 );
    VAR_1 += 1;

    /* COMMENT_4 */
    VAR_6 = proto_tree_add_subtree_format( VAR_5, VAR_0, VAR_1, 0, VAR_19, NULL, ""Packet Chunks"" );

    for (VAR_11 = 0; VAR_11 < VAR_14; )
    {
        guint32 VAR_27 = 0;
        VAR_8 = proto_tree_add_item_ret_uint( VAR_6, VAR_28, VAR_0, VAR_1, 2, VAR_21, &VAR_27 );

        /* COMMENT_5 */
        /* COMMENT_6 */
                                 
                                          
                                                      
                        
           
        if ( !(VAR_27 & 0x8000) )
        {
            /* COMMENT_12 */
            guint VAR_29 = VAR_27 & 0x1FFF;

            if ( VAR_29 <= 0 || VAR_14 - VAR_15 < VAR_29 )
            {
                /* COMMENT_13 */
                proto_tree_add_expert(VAR_6, VAR_2, &VAR_30, VAR_0, VAR_1, 2);
                VAR_1 += 2;
                return VAR_1;
            }

            if ( !(VAR_27 & 0x6000) )
            {
                proto_item_append_text( VAR_8, "" [Run Length Chunk] Packet not received. Length : %d"", VAR_29);
                VAR_13 += VAR_29;
            }
            else if ( VAR_27 & 0x2000 )
            {
                proto_item_append_text( VAR_8, "" [Run Length Chunk] Small Delta. Length : %d"", VAR_29);
                for (guint VAR_31 = 0; VAR_31 < VAR_29; VAR_31++)
                {
                    /* COMMENT_14 */
                    VAR_9[VAR_15+VAR_31] = 1;
                    VAR_10[VAR_15+VAR_31] = VAR_13++;
                }
                VAR_15 += VAR_29;
            }
            else if ( VAR_27 & 0x4000 )
            {
                proto_item_append_text( VAR_8, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", VAR_29);
                for (guint VAR_31 = 0; VAR_31 < VAR_29; VAR_31++)
                {
                    VAR_9[VAR_15+VAR_31] = 2;
                    VAR_10[VAR_15+VAR_31] = VAR_13++;
                }
                VAR_15 += VAR_29;
            }
            else
            {
                proto_item_append_text( VAR_8, "" [Run Length Chunk] [Reserved]. Length : %d"", VAR_29);
                VAR_13 += VAR_29;
            }

            VAR_11 += VAR_29;

        }
        else
        {
            wmem_strbuf_t* VAR_32 = wmem_strbuf_new(wmem_packet_scope(), ""|"");

            /* COMMENT_15 */
            if ( !(VAR_27 & 0x4000) )
            {
                /* COMMENT_16 */

                int VAR_33 = VAR_27 & 0x3FFF;
                int VAR_34 = 14;

                for (int VAR_35 = 0; VAR_35 < VAR_34; VAR_35++)
                {
                    if ( (VAR_33 & (0x2000>>VAR_35)) == 0 )
                    {
                        if ( VAR_11 + VAR_35 < VAR_14 )
                        {
                            wmem_strbuf_append(VAR_32, "" N |"");
                            VAR_13++;
                        }
                        else
                        {
                            /* COMMENT_17 */
                            wmem_strbuf_append(VAR_32, "" _ |"");
                        }
                    }
                    else
                    {
                        if (VAR_15 >= VAR_14) {
                            /* COMMENT_18 */
                            proto_tree_add_expert(VAR_6, VAR_2, &VAR_30, VAR_0, VAR_1, 2);
                            VAR_1 += 2;
                            return VAR_1;
                        }
                        wmem_strbuf_append(VAR_32, "" R |"");
                        VAR_9[VAR_15] = 1;
                        VAR_10[VAR_15] = VAR_13++;
                        VAR_15++;
                    }
                }
                proto_item_append_text( VAR_8, "" [1 bit Status Vector Chunk]: %s"", wmem_strbuf_get_str(VAR_32));
                VAR_11 += VAR_34;
            }
            else
            {
                /* COMMENT_19 */
                int VAR_34 = 7;
                int VAR_33 = VAR_27 & 0x3FFF;

                for (int VAR_35 = 0; VAR_35 < VAR_34; VAR_35++)
                {
                    switch ( (VAR_33 & (0x3000 >> (2*VAR_35))) >> ( 2 * (6-VAR_35) ) )
                    {
                        case 0: /* COMMENT_20 */
                            if ( VAR_11 + VAR_35 < VAR_14 )
                            {
                                wmem_strbuf_append(VAR_32, "" NR |"");
                                VAR_13++;
                            }
                            else
                            {
                                /* COMMENT_21 */
                                wmem_strbuf_append(VAR_32, "" __ |"");
                            }
                            break;

                        case 1: /* COMMENT_22 */
                            if (VAR_15 >= VAR_14) {
                                /* COMMENT_18 */
                                proto_tree_add_expert(VAR_6, VAR_2, &VAR_30, VAR_0, VAR_1, 2);
                                VAR_1 += 2;
                                return VAR_1;
                            }
                            wmem_strbuf_append(VAR_32, "" SD |"");
                            VAR_9[VAR_15] = 1;
                            VAR_10[VAR_15] = VAR_13++;
                            VAR_15++;
                            break;

                        case 2: /* COMMENT_23 */
                            if (VAR_15 >= VAR_14) {
                                /* COMMENT_18 */
                                proto_tree_add_expert(VAR_6, VAR_2, &VAR_30, VAR_0, VAR_1, 2);
                                VAR_1 += 2;
                                return VAR_1;
                            }
                            wmem_strbuf_append(VAR_32, "" LD |"");
                            VAR_9[VAR_15] = 2;
                            VAR_10[VAR_15] = VAR_13++;
                            VAR_15++;
                            break;

                        case 3: /* COMMENT_24 */
                        default:
                            /* COMMENT_25 */
                            wmem_strbuf_append(VAR_32, "" WO |"");
                            VAR_13++;
                            break;

                    }
                }

                proto_item_append_text( VAR_8, "" [2 bits Status Vector Chunk]: %s"", wmem_strbuf_get_str(VAR_32));
                VAR_11 += VAR_34;
            }

        }

        VAR_1 += 2;
    }

    /* COMMENT_26 */
    VAR_7 = proto_tree_add_subtree_format( VAR_5, VAR_0, VAR_1, 0, VAR_19, NULL, ""Recv Delta"" );
    for (VAR_11 = 0; VAR_11 < VAR_14; VAR_11++ )
    {
        if ( VAR_9[VAR_11] == 1 )
        {
            /* COMMENT_27 */
            guint32 VAR_36;
            VAR_8 = proto_tree_add_item_ret_uint( VAR_7, VAR_37, VAR_0, VAR_1, 1, VAR_21, &VAR_36 );

            proto_item_append_text( VAR_8, "" Small Delta: [seq: %d] %lf ms"", VAR_10[VAR_11], VAR_36*250.0/1000);

            VAR_1 += 1;
        }
        else if ( VAR_9[VAR_11] == 2 )
        {
            /* COMMENT_28 */
            gint16 VAR_36;
            VAR_8 = proto_tree_add_item( VAR_7, VAR_38, VAR_0, VAR_1, 2, VAR_21);
            VAR_36 = tvb_get_ntohs(VAR_0, VAR_1);

            if ( VAR_36 < 0 )
            {
                proto_item_append_text( VAR_8, "" Negative Delta: [seq: %d] %lf ms"", VAR_10[VAR_11], VAR_36*250.0/1000 );
            }
            else
            {
                proto_item_append_text( VAR_8, "" Large Delta: [seq: %d] %lf ms"", VAR_10[VAR_11], VAR_36*250.0/1000 );
            }

            VAR_1 += 2;
        }
        else
        {
            /* COMMENT_29 */
            break;
        }
    }

    /* COMMENT_17 */
    VAR_18 = VAR_16 - (VAR_1 - VAR_18);
    if ( VAR_18 > 0 )
    {
        proto_tree_add_item( VAR_7, VAR_39, VAR_0, VAR_1, VAR_18, VAR_21 );
        VAR_1 += VAR_18;
    }

    /* COMMENT_30 */
    VAR_9 = NULL;
    VAR_10 = NULL;

    return VAR_1;
}",wireshark/99d27a5fd2c540f837154aca3b3647f5ccfa0c33/packet-rtcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,12 @@
 static int
-dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, int pkt_len)
+dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rtcp_tree, int pkt_len)
 {
     proto_tree *fci_tree, *pkt_chunk_tree, *recv_delta_tree;
     proto_item *item       = NULL;
     guint8  *delta_array;
     guint16 *pkt_seq_array;
-    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count;
+    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count, delta_index = 0;
     gint fci_length        = pkt_len - RTCP_HEADER_LENGTH;
-    int delta_index        = 0;
     int padding_length     = offset;
 
     fci_tree = proto_tree_add_subtree_format( rtcp_tree, tvb, offset, fci_length, ett_ssrc, NULL, ""Transport-cc"" );
@@ -50,14 +49,12 @@
         if ( !(chunk & 0x8000) )
         {
             /* Run length chunk, first bit is zero */
-            int length = chunk & 0x1FFF;
-
-            if ( length <= 0 )
-            {
-                /*Malfromed Packet, stop parse it*/
-                delta_array = NULL;
-                pkt_seq_array = NULL;
-
+            guint length = chunk & 0x1FFF;
+
+            if ( length <= 0 || pkt_count - delta_index < length )
+            {
+                /* Malformed packet (zero or too many packets), stop parsing. */
+                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                 offset += 2;
                 return offset;
             }
@@ -70,7 +67,7 @@
             else if ( chunk & 0x2000 )
             {
                 proto_item_append_text( item, "" [Run Length Chunk] Small Delta. Length : %d"", length);
-                for (int j = 0; j < length; j++)
+                for (guint j = 0; j < length; j++)
                 {
                     /*1 means 1 byte delta, 2 means 2 bytes delta*/
                     delta_array[delta_index+j] = 1;
@@ -81,7 +78,7 @@
             else if ( chunk & 0x4000 )
             {
                 proto_item_append_text( item, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", length);
-                for (int j = 0; j < length; j++)
+                for (guint j = 0; j < length; j++)
                 {
                     delta_array[delta_index+j] = 2;
                     pkt_seq_array[delta_index+j] = pkt_seq_num++;
@@ -126,6 +123,12 @@
                     }
                     else
                     {
+                        if (delta_index >= pkt_count) {
+                            /* Malformed packet (too many status packets). */
+                            proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
+                            offset += 2;
+                            return offset;
+                        }
                         wmem_strbuf_append(status, "" R |"");
                         delta_array[delta_index] = 1;
                         pkt_seq_array[delta_index] = pkt_seq_num++;
@@ -159,6 +162,12 @@
                             break;
 
                         case 1: /*01 Packet received, small delta*/
+                            if (delta_index >= pkt_count) {
+                                /* Malformed packet (too many status packets). */
+                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
+                                offset += 2;
+                                return offset;
+                            }
                             wmem_strbuf_append(status, "" SD |"");
                             delta_array[delta_index] = 1;
                             pkt_seq_array[delta_index] = pkt_seq_num++;
@@ -166,6 +175,12 @@
                             break;
 
                         case 2: /*10 Packet received, large or negative delta*/
+                            if (delta_index >= pkt_count) {
+                                /* Malformed packet (too many status packets). */
+                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
+                                offset += 2;
+                                return offset;
+                            }
                             wmem_strbuf_append(status, "" LD |"");
                             delta_array[delta_index] = 2;
                             pkt_seq_array[delta_index] = pkt_seq_num++;","{'deleted_lines': ['dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, int pkt_len)', '    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count;', '    int delta_index        = 0;', '            int length = chunk & 0x1FFF;', '', '            if ( length <= 0 )', '            {', '                /*Malfromed Packet, stop parse it*/', '                delta_array = NULL;', '                pkt_seq_array = NULL;', '', '                for (int j = 0; j < length; j++)', '                for (int j = 0; j < length; j++)'], 'added_lines': ['dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rtcp_tree, int pkt_len)', '    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count, delta_index = 0;', '            guint length = chunk & 0x1FFF;', '', '            if ( length <= 0 || pkt_count - delta_index < length )', '            {', '                /* Malformed packet (zero or too many packets), stop parsing. */', '                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);', '                for (guint j = 0; j < length; j++)', '                for (guint j = 0; j < length; j++)', '                        if (delta_index >= pkt_count) {', '                            /* Malformed packet (too many status packets). */', '                            proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);', '                            offset += 2;', '                            return offset;', '                        }', '                            if (delta_index >= pkt_count) {', '                                /* Malformed packet (too many status packets). */', '                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);', '                                offset += 2;', '                                return offset;', '                            }', '                            if (delta_index >= pkt_count) {', '                                /* Malformed packet (too many status packets). */', '                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);', '                                offset += 2;', '                                return offset;', '                            }']}",True,"In Wireshark 2.6.0, the RTCP dissector could crash. This was addressed in epan/dissectors/packet-rtcp.c by avoiding a buffer overflow for packet status chunks.",7.5,HIGH,2,valid,2018-05-14T13:18:29Z,2
CVE-2018-11355,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"rtcp: fix buffer overflow in transport-cc dissection

When the packet status chunks cover more packets than advertised in the
packet status count field, fail rather than writing past the end.
https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01#section-3.1.2

Bug: 14673
Change-Id: If90baef3610d8f884b0772a4b81d6dcb4ebc9227
Fixes: v2.5.0rc0-2533-ga584eab239 (""New RTCP dissector for transport-cc"")
Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6464
Reviewed-on: https://code.wireshark.org/review/27527
Petri-Dish: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot
Reviewed-by: Rui Zhang <rzhang@grandstream.cn>
Reviewed-by: Peter Wu <peter@lekensteyn.nl>
(cherry picked from commit 4413d43962e1aed72a285ae8fb68780bb64a11fe)
Reviewed-on: https://code.wireshark.org/review/27536",99d27a5fd2c540f837154aca3b3647f5ccfa0c33,https://github.com/wireshark/wireshark/commit/99d27a5fd2c540f837154aca3b3647f5ccfa0c33,epan/dissectors/packet-rtcp.c,dissect_rtcp_rtpfb,"static int
dissect_rtcp_rtpfb( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, proto_item *top_item, packet_info *pinfo )
{
unsigned int counter;
unsigned int rtcp_rtpfb_fmt;
int          packet_length;
int          start_offset   = offset;
proto_tree_add_item( rtcp_tree, hf_rtcp_rtpfb_fmt, tvb, offset, 1, ENC_BIG_ENDIAN );
rtcp_rtpfb_fmt = (tvb_get_guint8(tvb, offset) & 0x1f);
offset++;
proto_tree_add_item( rtcp_tree, hf_rtcp_pt, tvb, offset, 1, ENC_BIG_ENDIAN );
offset++;
packet_length = (tvb_get_ntohs(tvb, offset) + 1) * 4;
offset = dissect_rtcp_length_field(rtcp_tree, tvb, offset);
proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_sender, tvb, offset, 4, ENC_BIG_ENDIAN );
offset += 4;
proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_media_source, tvb, offset, 4, ENC_BIG_ENDIAN );
offset += 4;
if (packet_length > 12) {
tvbuff_t *subtvb = tvb_new_subset_length(tvb, offset, packet_length - 12);
if (dissector_try_uint (rtcp_rtpfb_dissector_table, rtcp_rtpfb_fmt,
subtvb, pinfo, rtcp_tree))
return start_offset + packet_length;
}
counter = 0;
while ((offset - start_offset) < packet_length) {
counter++;
if (rtcp_rtpfb_fmt == 1) {
offset = dissect_rtcp_rtpfb_nack(tvb, offset, rtcp_tree, top_item);
} else if (rtcp_rtpfb_fmt == 3) {
offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 0);
} else if (rtcp_rtpfb_fmt == 4) {
offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 1);
} else if (rtcp_rtpfb_fmt == 15) {
proto_tree_add_item(rtcp_tree, hf_rtcp_fci, tvb, offset, start_offset + packet_length - offset, ENC_NA );
offset = start_offset + packet_length;
}
}
return offset;
}","static int
dissect_rtcp_rtpfb( tvbuff_t *VAR_0, int VAR_1, proto_tree *VAR_2, proto_item *VAR_3, packet_info *VAR_4 )
{
unsigned int VAR_5;
unsigned int VAR_6;
int          VAR_7;
int          VAR_8   = VAR_1;
proto_tree_add_item( VAR_2, VAR_9, VAR_0, VAR_1, 1, VAR_10 );
VAR_6 = (tvb_get_guint8(VAR_0, VAR_1) & 0x1f);
VAR_1++;
proto_tree_add_item( VAR_2, VAR_11, VAR_0, VAR_1, 1, VAR_10 );
VAR_1++;
VAR_7 = (tvb_get_ntohs(VAR_0, VAR_1) + 1) * 4;
VAR_1 = dissect_rtcp_length_field(VAR_2, VAR_0, VAR_1);
proto_tree_add_item( VAR_2, VAR_12, VAR_0, VAR_1, 4, VAR_10 );
VAR_1 += 4;
proto_tree_add_item( VAR_2, VAR_13, VAR_0, VAR_1, 4, VAR_10 );
VAR_1 += 4;
if (VAR_7 > 12) {
tvbuff_t *VAR_14 = tvb_new_subset_length(VAR_0, VAR_1, VAR_7 - 12);
if (dissector_try_uint (VAR_15, VAR_6,
VAR_14, VAR_4, VAR_2))
return VAR_8 + VAR_7;
}
VAR_5 = 0;
while ((VAR_1 - VAR_8) < VAR_7) {
VAR_5++;
if (VAR_6 == 1) {
VAR_1 = dissect_rtcp_rtpfb_nack(VAR_0, VAR_1, VAR_2, VAR_3);
} else if (VAR_6 == 3) {
VAR_1 = dissect_rtcp_rtpfb_tmmbr(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, 0);
} else if (VAR_6 == 4) {
VAR_1 = dissect_rtcp_rtpfb_tmmbr(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, 1);
} else if (VAR_6 == 15) {
VAR_1 = dissect_rtcp_rtpfb_transport_cc( VAR_0, VAR_1, VAR_2, VAR_7);
} else {
proto_tree_add_item(VAR_2, VAR_16, VAR_0, VAR_1, VAR_8 + VAR_7 - VAR_1, VAR_17 );
VAR_1 = VAR_8 + VAR_7;
}
}
return VAR_1;
}",wireshark/99d27a5fd2c540f837154aca3b3647f5ccfa0c33/packet-rtcp.c/vul/before/1.json,"static int
dissect_rtcp_rtpfb( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, proto_item *top_item, packet_info *pinfo )
{
    unsigned int counter;
    unsigned int rtcp_rtpfb_fmt;
    int          packet_length;
    int          start_offset   = offset;

    /* Transport layer FB message */
    /* Feedback message type (FMT): 5 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_rtpfb_fmt, tvb, offset, 1, ENC_BIG_ENDIAN );
    rtcp_rtpfb_fmt = (tvb_get_guint8(tvb, offset) & 0x1f);
    offset++;

    /* Packet type, 8 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_pt, tvb, offset, 1, ENC_BIG_ENDIAN );
    offset++;

    /* Packet length in 32 bit words MINUS one, 16 bits */
    packet_length = (tvb_get_ntohs(tvb, offset) + 1) * 4;
    offset = dissect_rtcp_length_field(rtcp_tree, tvb, offset);

    /* SSRC of packet sender, 32 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_sender, tvb, offset, 4, ENC_BIG_ENDIAN );
    offset += 4;

    /* SSRC of media source, 32 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_media_source, tvb, offset, 4, ENC_BIG_ENDIAN );
    offset += 4;

    /* Check if we have a type specific dissector,
     * if we do, just return from here
     */
    if (packet_length > 12) {
      tvbuff_t *subtvb = tvb_new_subset_length(tvb, offset, packet_length - 12);

      if (dissector_try_uint (rtcp_rtpfb_dissector_table, rtcp_rtpfb_fmt,
              subtvb, pinfo, rtcp_tree))
        return start_offset + packet_length;
    }

    /* Transport-Layer Feedback Message Elements */
    counter = 0;
    while ((offset - start_offset) < packet_length) {
      counter++;
      if (rtcp_rtpfb_fmt == 1) {
        offset = dissect_rtcp_rtpfb_nack(tvb, offset, rtcp_tree, top_item);
      } else if (rtcp_rtpfb_fmt == 3) {
        offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 0);
      } else if (rtcp_rtpfb_fmt == 4) {
        offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 1);
      } else if (rtcp_rtpfb_fmt == 15) {
        /* Handle transport-cc (RTP Extensions for Transport-wide Congestion Control) - https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01 */
        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, pinfo, rtcp_tree, packet_length);
      } else {
        /* Unknown FMT */
        proto_tree_add_item(rtcp_tree, hf_rtcp_fci, tvb, offset, start_offset + packet_length - offset, ENC_NA );
        offset = start_offset + packet_length;
      }
    }

    return offset;
}","static int
dissect_rtcp_rtpfb( tvbuff_t *VAR_0, int VAR_1, proto_tree *VAR_2, proto_item *VAR_3, packet_info *VAR_4 )
{
    unsigned int VAR_5;
    unsigned int VAR_6;
    int          VAR_7;
    int          VAR_8   = VAR_1;

    /* COMMENT_0 */
    /* COMMENT_1 */
    proto_tree_add_item( VAR_2, VAR_9, VAR_0, VAR_1, 1, VAR_10 );
    VAR_6 = (tvb_get_guint8(VAR_0, VAR_1) & 0x1f);
    VAR_1++;

    /* COMMENT_2 */
    proto_tree_add_item( VAR_2, VAR_11, VAR_0, VAR_1, 1, VAR_10 );
    VAR_1++;

    /* COMMENT_3 */
    VAR_7 = (tvb_get_ntohs(VAR_0, VAR_1) + 1) * 4;
    VAR_1 = dissect_rtcp_length_field(VAR_2, VAR_0, VAR_1);

    /* COMMENT_4 */
    proto_tree_add_item( VAR_2, VAR_12, VAR_0, VAR_1, 4, VAR_10 );
    VAR_1 += 4;

    /* COMMENT_5 */
    proto_tree_add_item( VAR_2, VAR_13, VAR_0, VAR_1, 4, VAR_10 );
    VAR_1 += 4;

    /* COMMENT_6 */
                                      
       
    if (VAR_7 > 12) {
      tvbuff_t *VAR_14 = tvb_new_subset_length(VAR_0, VAR_1, VAR_7 - 12);

      if (dissector_try_uint (VAR_15, VAR_6,
              VAR_14, VAR_4, VAR_2))
        return VAR_8 + VAR_7;
    }

    /* COMMENT_9 */
    VAR_5 = 0;
    while ((VAR_1 - VAR_8) < VAR_7) {
      VAR_5++;
      if (VAR_6 == 1) {
        VAR_1 = dissect_rtcp_rtpfb_nack(VAR_0, VAR_1, VAR_2, VAR_3);
      } else if (VAR_6 == 3) {
        VAR_1 = dissect_rtcp_rtpfb_tmmbr(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, 0);
      } else if (VAR_6 == 4) {
        VAR_1 = dissect_rtcp_rtpfb_tmmbr(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, 1);
      } else if (VAR_6 == 15) {
        /* COMMENT_10 */
        VAR_1 = dissect_rtcp_rtpfb_transport_cc( VAR_0, VAR_1, VAR_4, VAR_2, VAR_7);
      } else {
        /* COMMENT_11 */
        proto_tree_add_item(VAR_2, VAR_16, VAR_0, VAR_1, VAR_8 + VAR_7 - VAR_1, VAR_17 );
        VAR_1 = VAR_8 + VAR_7;
      }
    }

    return VAR_1;
}",wireshark/99d27a5fd2c540f837154aca3b3647f5ccfa0c33/packet-rtcp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -51,7 +51,7 @@
         offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 1);
       } else if (rtcp_rtpfb_fmt == 15) {
         /* Handle transport-cc (RTP Extensions for Transport-wide Congestion Control) - https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01 */
-        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, rtcp_tree, packet_length);
+        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, pinfo, rtcp_tree, packet_length);
       } else {
         /* Unknown FMT */
         proto_tree_add_item(rtcp_tree, hf_rtcp_fci, tvb, offset, start_offset + packet_length - offset, ENC_NA );","{'deleted_lines': ['        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, rtcp_tree, packet_length);'], 'added_lines': ['        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, pinfo, rtcp_tree, packet_length);']}",True,"In Wireshark 2.6.0, the RTCP dissector could crash. This was addressed in epan/dissectors/packet-rtcp.c by avoiding a buffer overflow for packet status chunks.",7.5,HIGH,2,valid,2018-05-14T13:18:29Z,2
CVE-2018-11506,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"sr: pass down correctly sized SCSI sense buffer

We're casting the CDROM layer request_sense to the SCSI sense
buffer, but the former is 64 bytes and the latter is 96 bytes.
As we generally allocate these on the stack, we end up blowing
up the stack.

Fix this by wrapping the scsi_execute() call with a properly
sized sense buffer, and copying back the bits for the CDROM
layer.

Cc: stable@vger.kernel.org
Reported-by: Piotr Gabriel Kosinski <pg.kosinski@gmail.com>
Reported-by: Daniel Shapira <daniel@twistlock.com>
Tested-by: Kees Cook <keescook@chromium.org>
Fixes: 82ed4db499b8 (""block: split scsi_request out of struct request"")
Signed-off-by: Jens Axboe <axboe@kernel.dk>",f7068114d45ec55996b9040e98111afa56e010fe,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,drivers/scsi/sr_ioctl.c,sr_do_ioctl,"int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
{
struct scsi_device *SDev;
struct scsi_sense_hdr sshdr;
int result, err = 0, retries = 0;
SDev = cd->device;
retry:
if (!scsi_block_when_processing_errors(SDev)) {
err = -ENODEV;
goto out;
}
result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
cgc->buffer, cgc->buflen,
(unsigned char *)cgc->sense, &sshdr,
cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);
if (driver_byte(result) != 0) {
switch (sshdr.sense_key) {
case UNIT_ATTENTION:
SDev->changed = 1;
if (!cgc->quiet)
sr_printk(KERN_INFO, cd,
""disc change detected.\n"");
if (retries++ < 10)
goto retry;
err = -ENOMEDIUM;
break;
case NOT_READY:
if (sshdr.asc == 0x04 &&
sshdr.ascq == 0x01) {
if (!cgc->quiet)
sr_printk(KERN_INFO, cd,
""CDROM not ready yet.\n"");
if (retries++ < 10) {
ssleep(2);
goto retry;
} else {
err = -ENOMEDIUM;
break;
}
}
if (!cgc->quiet)
sr_printk(KERN_INFO, cd,
""CDROM not ready.  Make sure there ""
""is a disc in the drive.\n"");
err = -ENOMEDIUM;
break;
case ILLEGAL_REQUEST:
err = -EIO;
if (sshdr.asc == 0x20 &&
sshdr.ascq == 0x00)
err = -EDRIVE_CANT_DO_THIS;
break;
default:
err = -EIO;
}
}
out:
cgc->stat = err;
return err;
}","int sr_do_ioctl(Scsi_CD *VAR_0, struct packet_command *VAR_1)
{
struct scsi_device *VAR_2;
struct scsi_sense_hdr VAR_3;
int VAR_4, VAR_5 = 0, VAR_6 = 0;
VAR_2 = VAR_0->device;
retry:
if (!scsi_block_when_processing_errors(VAR_2)) {
VAR_5 = -VAR_7;
goto out;
}
VAR_4 = scsi_execute(VAR_2, VAR_1->cmd, VAR_1->data_direction,
VAR_1->buffer, VAR_1->buflen,
(unsigned char *)VAR_1->sense, &VAR_3,
VAR_1->timeout, VAR_8, 0, 0, NULL);
if (driver_byte(VAR_4) != 0) {
switch (VAR_3.sense_key) {
case VAR_9:
VAR_2->changed = 1;
if (!VAR_1->quiet)
sr_printk(VAR_10, VAR_0,
""disc change detected.\n"");
if (VAR_6++ < 10)
goto retry;
VAR_5 = -VAR_11;
break;
case VAR_12:
if (VAR_3.asc == 0x04 &&
VAR_3.ascq == 0x01) {
if (!VAR_1->quiet)
sr_printk(VAR_10, VAR_0,
""CDROM not ready yet.\n"");
if (VAR_6++ < 10) {
ssleep(2);
goto retry;
} else {
VAR_5 = -VAR_11;
break;
}
}
if (!VAR_1->quiet)
sr_printk(VAR_10, VAR_0,
""CDROM not ready.  Make sure there ""
""is a disc in the drive.\n"");
VAR_5 = -VAR_11;
break;
case VAR_13:
VAR_5 = -VAR_14;
if (VAR_3.asc == 0x20 &&
VAR_3.ascq == 0x00)
VAR_5 = -VAR_15;
break;
default:
VAR_5 = -VAR_14;
}
}
out:
VAR_1->stat = VAR_5;
return VAR_5;
}",torvalds/linux/f7068114d45ec55996b9040e98111afa56e010fe/sr_ioctl.c/vul/before/0.json,"int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
{
	struct scsi_device *SDev;
	struct scsi_sense_hdr sshdr;
	int result, err = 0, retries = 0;
	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;

	SDev = cd->device;

	if (cgc->sense)
		senseptr = sense_buffer;

      retry:
	if (!scsi_block_when_processing_errors(SDev)) {
		err = -ENODEV;
		goto out;
	}

	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
			      cgc->buffer, cgc->buflen, senseptr, &sshdr,
			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);

	if (cgc->sense)
		memcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));

	/* Minimal error checking.  Ignore cases we know about, and report the rest. */
	if (driver_byte(result) != 0) {
		switch (sshdr.sense_key) {
		case UNIT_ATTENTION:
			SDev->changed = 1;
			if (!cgc->quiet)
				sr_printk(KERN_INFO, cd,
					  ""disc change detected.\n"");
			if (retries++ < 10)
				goto retry;
			err = -ENOMEDIUM;
			break;
		case NOT_READY:	/* This happens if there is no disc in drive */
			if (sshdr.asc == 0x04 &&
			    sshdr.ascq == 0x01) {
				/* sense: Logical unit is in process of becoming ready */
				if (!cgc->quiet)
					sr_printk(KERN_INFO, cd,
						  ""CDROM not ready yet.\n"");
				if (retries++ < 10) {
					/* sleep 2 sec and try again */
					ssleep(2);
					goto retry;
				} else {
					/* 20 secs are enough? */
					err = -ENOMEDIUM;
					break;
				}
			}
			if (!cgc->quiet)
				sr_printk(KERN_INFO, cd,
					  ""CDROM not ready.  Make sure there ""
					  ""is a disc in the drive.\n"");
			err = -ENOMEDIUM;
			break;
		case ILLEGAL_REQUEST:
			err = -EIO;
			if (sshdr.asc == 0x20 &&
			    sshdr.ascq == 0x00)
				/* sense: Invalid command operation code */
				err = -EDRIVE_CANT_DO_THIS;
			break;
		default:
			err = -EIO;
		}
	}

	/* Wake up a process waiting for device */
      out:
	cgc->stat = err;
	return err;
}","int sr_do_ioctl(Scsi_CD *VAR_0, struct packet_command *VAR_1)
{
	struct scsi_device *VAR_2;
	struct scsi_sense_hdr VAR_3;
	int VAR_4, VAR_5 = 0, VAR_6 = 0;
	unsigned char VAR_7[VAR_8], *VAR_9 = NULL;

	VAR_2 = VAR_0->device;

	if (VAR_1->sense)
		VAR_9 = VAR_7;

      retry:
	if (!scsi_block_when_processing_errors(VAR_2)) {
		VAR_5 = -VAR_10;
		goto out;
	}

	VAR_4 = scsi_execute(VAR_2, VAR_1->cmd, VAR_1->data_direction,
			      VAR_1->buffer, VAR_1->buflen, VAR_9, &VAR_3,
			      VAR_1->timeout, VAR_11, 0, 0, NULL);

	if (VAR_1->sense)
		memcpy(VAR_1->sense, VAR_7, sizeof(*VAR_1->sense));

	/* COMMENT_0 */
	if (driver_byte(VAR_4) != 0) {
		switch (VAR_3.sense_key) {
		case VAR_12:
			VAR_2->changed = 1;
			if (!VAR_1->quiet)
				sr_printk(VAR_13, VAR_0,
					  ""disc change detected.\n"");
			if (VAR_6++ < 10)
				goto retry;
			VAR_5 = -VAR_14;
			break;
		case VAR_15:	/* COMMENT_1 */
			if (VAR_3.asc == 0x04 &&
			    VAR_3.ascq == 0x01) {
				/* COMMENT_2 */
				if (!VAR_1->quiet)
					sr_printk(VAR_13, VAR_0,
						  ""CDROM not ready yet.\n"");
				if (VAR_6++ < 10) {
					/* COMMENT_3 */
					ssleep(2);
					goto retry;
				} else {
					/* COMMENT_4 */
					VAR_5 = -VAR_14;
					break;
				}
			}
			if (!VAR_1->quiet)
				sr_printk(VAR_13, VAR_0,
					  ""CDROM not ready.  Make sure there ""
					  ""is a disc in the drive.\n"");
			VAR_5 = -VAR_14;
			break;
		case VAR_16:
			VAR_5 = -VAR_17;
			if (VAR_3.asc == 0x20 &&
			    VAR_3.ascq == 0x00)
				/* COMMENT_5 */
				VAR_5 = -VAR_18;
			break;
		default:
			VAR_5 = -VAR_17;
		}
	}

	/* COMMENT_6 */
      out:
	VAR_1->stat = VAR_5;
	return VAR_5;
}",torvalds/linux/f7068114d45ec55996b9040e98111afa56e010fe/sr_ioctl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,8 +3,12 @@
 	struct scsi_device *SDev;
 	struct scsi_sense_hdr sshdr;
 	int result, err = 0, retries = 0;
+	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;
 
 	SDev = cd->device;
+
+	if (cgc->sense)
+		senseptr = sense_buffer;
 
       retry:
 	if (!scsi_block_when_processing_errors(SDev)) {
@@ -13,9 +17,11 @@
 	}
 
 	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
-			      cgc->buffer, cgc->buflen,
-			      (unsigned char *)cgc->sense, &sshdr,
+			      cgc->buffer, cgc->buflen, senseptr, &sshdr,
 			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);
+
+	if (cgc->sense)
+		memcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));
 
 	/* Minimal error checking.  Ignore cases we know about, and report the rest. */
 	if (driver_byte(result) != 0) {","{'deleted_lines': ['\t\t\t      cgc->buffer, cgc->buflen,', '\t\t\t      (unsigned char *)cgc->sense, &sshdr,'], 'added_lines': ['\tunsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;', '', '\tif (cgc->sense)', '\t\tsenseptr = sense_buffer;', '\t\t\t      cgc->buffer, cgc->buflen, senseptr, &sshdr,', '', '\tif (cgc->sense)', '\t\tmemcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));']}",True,"The sr_do_ioctl function in drivers/scsi/sr_ioctl.c in the Linux kernel through 4.16.12 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact because sense buffers have different sizes at the CDROM layer and the SCSI layer, as demonstrated by a CDROMREADMODE2 ioctl call.",7.8,HIGH,2,valid,2018-05-21T18:21:14Z,2
CVE-2018-11546,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,mity/md4c,"md_is_named_entity_contents: Fix buffer overflow.

Fixes #38.",e5feaf2c96a08390f89a72972b5f8b808ca34e79,https://github.com/mity/md4c/commit/e5feaf2c96a08390f89a72972b5f8b808ca34e79,md4c/md4c.c,md_is_named_entity_contents,"static int
md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
{
OFF off = beg;
if(off <= max_end  &&  ISALPHA_(text[off]))
off++;
else
return FALSE;
while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)
off++;
if(2 <= off - beg  &&  off - beg <= 48) {
*p_end = off;
return TRUE;
} else {
return FALSE;
}
}","static int
md_is_named_entity_contents(MD_CTX* VAR_0, const CHAR* VAR_1, OFF VAR_2, OFF VAR_3, OFF* VAR_4)
{
OFF VAR_5 = VAR_2;
if(VAR_5 <= VAR_3  &&  ISALPHA_(VAR_1[VAR_5]))
VAR_5++;
else
return FALSE;
while(VAR_5 < VAR_3  &&  ISALNUM_(VAR_1[VAR_5])  &&  VAR_5 - VAR_2 <= 48)
VAR_5++;
if(2 <= VAR_5 - VAR_2  &&  VAR_5 - VAR_2 <= 48) {
*VAR_4 = VAR_5;
return TRUE;
} else {
return FALSE;
}
}",mity/md4c/e5feaf2c96a08390f89a72972b5f8b808ca34e79/md4c.c/vul/before/0.json,"static int
md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
{
    OFF off = beg;

    if(off < max_end  &&  ISALPHA_(text[off]))
        off++;
    else
        return FALSE;

    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)
        off++;

    if(2 <= off - beg  &&  off - beg <= 48) {
        *p_end = off;
        return TRUE;
    } else {
        return FALSE;
    }
}","static int
md_is_named_entity_contents(MD_CTX* VAR_0, const CHAR* VAR_1, OFF VAR_2, OFF VAR_3, OFF* VAR_4)
{
    OFF VAR_5 = VAR_2;

    if(VAR_5 < VAR_3  &&  ISALPHA_(VAR_1[VAR_5]))
        VAR_5++;
    else
        return FALSE;

    while(VAR_5 < VAR_3  &&  ISALNUM_(VAR_1[VAR_5])  &&  VAR_5 - VAR_2 <= 48)
        VAR_5++;

    if(2 <= VAR_5 - VAR_2  &&  VAR_5 - VAR_2 <= 48) {
        *VAR_4 = VAR_5;
        return TRUE;
    } else {
        return FALSE;
    }
}",mity/md4c/e5feaf2c96a08390f89a72972b5f8b808ca34e79/md4c.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
     OFF off = beg;
 
-    if(off <= max_end  &&  ISALPHA_(text[off]))
+    if(off < max_end  &&  ISALPHA_(text[off]))
         off++;
     else
         return FALSE;","{'deleted_lines': ['    if(off <= max_end  &&  ISALPHA_(text[off]))'], 'added_lines': ['    if(off < max_end  &&  ISALPHA_(text[off]))']}",True,md4c 0.2.5 has a heap-based buffer over-read because md_is_named_entity_contents has an off-by-one error.,9.8,CRITICAL,3,valid,2018-05-29T17:42:13Z,2
CVE-2018-11575,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,miniupnp/ngiflib,Fix #4,be4c7dffdcf7543fe24acc7448d6014a939fd26b,https://github.com/miniupnp/ngiflib/commit/be4c7dffdcf7543fe24acc7448d6014a939fd26b,ngiflib.c,DecodeGifImg,"static int DecodeGifImg(struct ngiflib_img * i) {
struct ngiflib_decode_context context;
long npix;
u8 * stackp;
u8 * stack_top;
u16 clr;
u16 eof;
u16 free;
u16 act_code = 0;
u16 old_code = 0;
u16 read_byt;
u16 ab_prfx[4096];
u8 ab_suffx[4096];
u8 ab_stack[4096];
u8 flags;
u8 casspecial = 0;
if(!i) return -1;
i->posX = GetWord(i->parent);
i->posY = GetWord(i->parent);
i->width = GetWord(i->parent);
i->height = GetWord(i->parent);
if((i->width > i->parent->width) || (i->height > i->parent->height)) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
return -1;
}
if((i->posX + i->width) > i->parent->width) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
i->posX = i->parent->width - i->width;
}
if((i->posY + i->height) > i->parent->height) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
i->posY = i->parent->height - i->height;
}
context.Xtogo = i->width;
context.curY = i->posY;
#ifdef NGIFLIB_INDEXED_ONLY
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
context.frbuff_p.p8 = context.line_p.p8 + i->posX;
#else
context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
#endif 
#else
if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
context.frbuff_p.p8 = context.line_p.p8 + i->posX;
#else
context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
#endif 
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
context.frbuff_p.p32 = context.line_p.p32 + i->posX;
#else
context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
#endif 
}
#endif 
npix = (long)i->width * i->height;
flags = GetByte(i->parent);
i->interlaced = (flags & 64) >> 6;
context.pass = i->interlaced ? 1 : 0;
i->sort_flag = (flags & 32) >> 5;
i->localpalbits = (flags & 7) + 1;
if(flags&128) { 
int k;
int localpalsize = 1 << i->localpalbits;
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
#endif 
i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
for(k=0; k<localpalsize; k++) {
i->palette[k].r = GetByte(i->parent);
i->palette[k].g = GetByte(i->parent);
i->palette[k].b = GetByte(i->parent);
}
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
#endif 
} else {
i->palette = i->parent->palette;
i->localpalbits = i->parent->imgbits;
}
i->ncolors = 1 << i->localpalbits;
i->imgbits = GetByte(i->parent);
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) {
if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
}
#endif 
if(i->imgbits==1) {
i->imgbits = 2;
}
clr = 1 << i->imgbits;
eof = clr + 1;
free = clr + 2;
context.nbbit = i->imgbits + 1;
context.max = clr + clr - 1; 
stackp = stack_top = ab_stack + 4096;
context.restbits = 0;
context.restbyte = 0;
context.lbyte = 0;
for(;;) {
act_code = GetGifWord(i, &context);
if(act_code==eof) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code\n"");
#endif 
return 0;
}
if(npix==0) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
#endif 
return 1;
}
if(act_code==clr) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (free=%hu) npix=%ld\n"", free, npix);
#endif 
free = clr + 2;
context.nbbit = i->imgbits + 1;
context.max = clr + clr - 1; 
act_code = GetGifWord(i, &context);
casspecial = (u8)act_code;
old_code = act_code;
if(npix > 0) WritePixel(i, &context, casspecial);
npix--;
} else {
read_byt = act_code;
if(act_code >= free) {
*(--stackp) = casspecial; 
act_code = old_code;
}
while(act_code > clr) { 
*(--stackp) = ab_suffx[act_code];
act_code = ab_prfx[act_code];
}
casspecial = (u8)act_code;
*(--stackp) = casspecial;
if(npix >= (stack_top - stackp)) {
WritePixels(i, &context, stackp, stack_top - stackp);
} else if(npix > 0) {
WritePixels(i, &context, stackp, npix);
}
npix -= (stack_top - stackp);
stackp = stack_top;
if(free < 4096) { 
ab_prfx[free] = old_code;
ab_suffx[free] = (u8)act_code;
free++;
if((free > context.max) && (context.nbbit < 12)) {
context.nbbit++;
context.max += context.max + 1;
}
}
old_code = read_byt;
}
}
return 0;
}","static int DecodeGifImg(struct ngiflib_img * VAR_0) {
struct ngiflib_decode_context VAR_1;
long VAR_2;
u8 * VAR_3;
u8 * VAR_4;
u16 VAR_5;
u16 VAR_6;
u16 VAR_7;
u16 VAR_8 = 0;
u16 VAR_9 = 0;
u16 VAR_10;
u16 VAR_11[4096];
u8 VAR_12[4096];
u8 VAR_13[4096];
u8 VAR_14;
u8 VAR_15 = 0;
if(!VAR_0) return -1;
VAR_0->posX = GetWord(VAR_0->parent);
VAR_0->posY = GetWord(VAR_0->parent);
VAR_0->width = GetWord(VAR_0->parent);
VAR_0->height = GetWord(VAR_0->parent);
if((VAR_0->width > VAR_0->parent->width) || (VAR_0->height > VAR_0->parent->height)) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
return -1;
}
if((VAR_0->posX + VAR_0->width) > VAR_0->parent->width) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
VAR_0->posX = VAR_0->parent->width - VAR_0->width;
}
if((VAR_0->posY + VAR_0->height) > VAR_0->parent->height) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
VAR_0->posY = VAR_0->parent->height - VAR_0->height;
}
VAR_1.Xtogo = VAR_0->width;
VAR_1.curY = VAR_0->posY;
#ifdef VAR_17
#ifdef VAR_18
VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
#else
VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
#else
if(VAR_0->parent->mode & VAR_19) {
#ifdef VAR_18
VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
#else
VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
} else {
#ifdef VAR_18
VAR_1.line_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p32 = VAR_1.line_p.p32 + VAR_0->posX;
#else
VAR_1.frbuff_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
}
#endif 
VAR_2 = (long)VAR_0->width * VAR_0->height;
VAR_14 = GetByte(VAR_0->parent);
VAR_0->interlaced = (VAR_14 & 64) >> 6;
VAR_1.pass = VAR_0->interlaced ? 1 : 0;
VAR_0->sort_flag = (VAR_14 & 32) >> 5;
VAR_0->localpalbits = (VAR_14 & 7) + 1;
if(VAR_14&128) { 
int VAR_20;
int VAR_21 = 1 << VAR_0->localpalbits;
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Local palette\n"");
#endif 
VAR_0->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*VAR_21);
for(VAR_20=0; VAR_20<VAR_21; VAR_20++) {
VAR_0->palette[VAR_20].r = GetByte(VAR_0->parent);
VAR_0->palette[VAR_20].g = GetByte(VAR_0->parent);
VAR_0->palette[VAR_20].b = GetByte(VAR_0->parent);
}
#ifdef VAR_18
if(VAR_0->parent->palette_cb) VAR_0->parent->palette_cb(VAR_0->parent, VAR_0->palette, VAR_21);
#endif 
} else {
VAR_0->palette = VAR_0->parent->palette;
VAR_0->localpalbits = VAR_0->parent->imgbits;
}
VAR_0->ncolors = 1 << VAR_0->localpalbits;
VAR_0->imgbits = GetByte(VAR_0->parent);
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) {
if(VAR_0->interlaced) fprintf(VAR_0->parent->log, ""interlaced "");
fprintf(VAR_0->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
VAR_0->posX, VAR_0->posY, VAR_0->width, VAR_0->height, VAR_0->localpalbits, VAR_0->imgbits, VAR_0->ncolors);
}
#endif 
if(VAR_0->imgbits==1) {
VAR_0->imgbits = 2;
}
VAR_5 = 1 << VAR_0->imgbits;
VAR_6 = VAR_5 + 1;
VAR_7 = VAR_5 + 2;
VAR_1.nbbit = VAR_0->imgbits + 1;
VAR_1.max = VAR_5 + VAR_5 - 1; 
VAR_3 = VAR_4 = VAR_13 + 4096;
VAR_1.restbits = 0;
VAR_1.restbyte = 0;
VAR_1.lbyte = 0;
for(;;) {
VAR_8 = GetGifWord(VAR_0, &VAR_1);
if(VAR_8==VAR_6) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""End of image code\n"");
#endif 
return 0;
}
if(VAR_2==0) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""assez de pixels, On se casse !\n"");
#endif 
return 1;
}
if(VAR_8==VAR_5) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Code clear (free=%hu) npix=%ld\n"", VAR_7, VAR_2);
#endif 
VAR_7 = VAR_5 + 2;
VAR_1.nbbit = VAR_0->imgbits + 1;
VAR_1.max = VAR_5 + VAR_5 - 1; 
VAR_8 = GetGifWord(VAR_0, &VAR_1);
VAR_15 = (u8)VAR_8;
VAR_9 = VAR_8;
if(VAR_2 > 0) WritePixel(VAR_0, &VAR_1, VAR_15);
VAR_2--;
} else {
VAR_10 = VAR_8;
if(VAR_8 >= VAR_7) {
*(--VAR_3) = VAR_15; 
VAR_8 = VAR_9;
}
while(VAR_8 > VAR_5) { 
*(--VAR_3) = VAR_12[VAR_8];
VAR_8 = VAR_11[VAR_8];
}
VAR_15 = (u8)VAR_8;
*(--VAR_3) = VAR_15;
if(VAR_2 >= (VAR_4 - VAR_3)) {
WritePixels(VAR_0, &VAR_1, VAR_3, VAR_4 - VAR_3);
} else if(VAR_2 > 0) {
WritePixels(VAR_0, &VAR_1, VAR_3, VAR_2);
}
VAR_2 -= (VAR_4 - VAR_3);
VAR_3 = VAR_4;
if(VAR_7 < 4096) { 
VAR_11[VAR_7] = VAR_9;
VAR_12[VAR_7] = (u8)VAR_8;
VAR_7++;
if((VAR_7 > VAR_1.max) && (VAR_1.nbbit < 12)) {
VAR_1.nbbit++;
VAR_1.max += VAR_1.max + 1;
}
}
VAR_9 = VAR_10;
}
}
return 0;
}",miniupnp/ngiflib/be4c7dffdcf7543fe24acc7448d6014a939fd26b/ngiflib.c/vul/before/0.json,"static int DecodeGifImg(struct ngiflib_img * i) {
	struct ngiflib_decode_context context;
	long npix;
	u8 * stackp;
	u8 * stack_top;
	u16 clr;
	u16 eof;
	u16 free;
	u16 act_code = 0;
	u16 old_code = 0;
	u16 read_byt;
	u16 ab_prfx[4096];
	u8 ab_suffx[4096];
	u8 ab_stack[4096];
	u8 flags;
	u8 casspecial = 0;

	if(!i) return -1;

	i->posX = GetWord(i->parent);	/* offsetX */
	i->posY = GetWord(i->parent);	/* offsetY */
	i->width = GetWord(i->parent);	/* SizeX   */
	i->height = GetWord(i->parent);	/* SizeY   */

	if((i->width > i->parent->width) || (i->height > i->parent->height)) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
		return -1;
	}
	if((i->posX + i->width) > i->parent->width) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
		i->posX = i->parent->width - i->width;
	}
	if((i->posY + i->height) > i->parent->height) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
		i->posY = i->parent->height - i->height;
	}
	context.Xtogo = i->width;
	context.curY = i->posY;
#ifdef NGIFLIB_INDEXED_ONLY
	#ifdef NGIFLIB_ENABLE_CALLBACKS
	context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
	context.frbuff_p.p8 = context.line_p.p8 + i->posX;
	#else
	context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
	#endif /* NGIFLIB_ENABLE_CALLBACKS */
#else
	if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
		#ifdef NGIFLIB_ENABLE_CALLBACKS
		context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
		context.frbuff_p.p8 = context.line_p.p8 + i->posX;
		#else
		context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
		#endif /* NGIFLIB_ENABLE_CALLBACKS */
	} else {
		#ifdef NGIFLIB_ENABLE_CALLBACKS
		context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
		context.frbuff_p.p32 = context.line_p.p32 + i->posX;
		#else
		context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
		#endif /* NGIFLIB_ENABLE_CALLBACKS */
	}
#endif /* NGIFLIB_INDEXED_ONLY */

	npix = (long)i->width * i->height;
	flags = GetByte(i->parent);
	i->interlaced = (flags & 64) >> 6;
	context.pass = i->interlaced ? 1 : 0;
	i->sort_flag = (flags & 32) >> 5;	/* is local palette sorted by color frequency ? */
	i->localpalbits = (flags & 7) + 1;
	if(flags&128) { /* palette locale */
		int k;
		int localpalsize = 1 << i->localpalbits;
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
#endif /* !defined(NGIFLIB_NO_FILE) */
		i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
		for(k=0; k<localpalsize; k++) {
			i->palette[k].r = GetByte(i->parent);
			i->palette[k].g = GetByte(i->parent);
			i->palette[k].b = GetByte(i->parent);
		}
#ifdef NGIFLIB_ENABLE_CALLBACKS
		if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
#endif /* NGIFLIB_ENABLE_CALLBACKS */
	} else {
		i->palette = i->parent->palette;
		i->localpalbits = i->parent->imgbits;
	}
	i->ncolors = 1 << i->localpalbits;
	
	i->imgbits = GetByte(i->parent);	/* LZW Minimum Code Size */

#if !defined(NGIFLIB_NO_FILE)
	if(i->parent && i->parent->log) {
		if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
		fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
	       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
	}
#endif /* !defined(NGIFLIB_NO_FILE) */

	if(i->imgbits==1) {	/* fix for 1bit images ? */
		i->imgbits = 2;
	}
	clr = 1 << i->imgbits;
	eof = clr + 1;
	free = clr + 2;
	context.nbbit = i->imgbits + 1;
	context.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */
	stackp = stack_top = ab_stack + 4096;
	
	context.restbits = 0;	/* initialise le ""buffer"" de lecture */
	context.restbyte = 0;	/* des codes LZW */
	context.lbyte = 0;
	for(;;) {
		act_code = GetGifWord(i, &context);
		if(act_code==eof) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code\n"");
#endif /* !defined(NGIFLIB_NO_FILE) */
			return 0;
		}
		if(npix==0) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
#endif /* !defined(NGIFLIB_NO_FILE) */
			return 1;
		}	
		if(act_code==clr) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (free=%hu) npix=%ld\n"", free, npix);
#endif /* !defined(NGIFLIB_NO_FILE) */
			/* clear */
			free = clr + 2;
			context.nbbit = i->imgbits + 1;
			context.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */
			act_code = GetGifWord(i, &context);
			casspecial = (u8)act_code;
			old_code = act_code;
			if(npix > 0) WritePixel(i, &context, casspecial);
			npix--;
		} else if(act_code > free) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu (free=%hu) !\n"", act_code, free);
#endif /* !defined(NGIFLIB_NO_FILE) */
			return -1;
		} else {
			read_byt = act_code;
			if(act_code == free) {	/* code pas encore dans alphabet */
/*				printf(""Code pas dans alphabet : %d>=%d push %d\n"", act_code, free, casspecial); */
				*(--stackp) = casspecial; /* dernier debut de chaine ! */
				act_code = old_code;
			}
/*			printf(""actcode=%d\n"", act_code); */
			while(act_code > clr) { /* code non concret */
				/* fillstackloop empile les suffixes ! */
				*(--stackp) = ab_suffx[act_code];
				act_code = ab_prfx[act_code];	/* prefixe */
			}
			/* act_code est concret */
			casspecial = (u8)act_code;	/* dernier debut de chaine ! */
			*(--stackp) = casspecial;	/* push on stack */
			if(npix >= (stack_top - stackp)) {
				WritePixels(i, &context, stackp, stack_top - stackp);	/* unstack all pixels at once */
			} else if(npix > 0) {	/* ""pixel overflow"" */
				WritePixels(i, &context, stackp, npix);
			}
			npix -= (stack_top - stackp);
			stackp = stack_top;
/*			putchar('\n'); */
			if(free < 4096) { /* la taille du dico est 4096 max ! */
				ab_prfx[free] = old_code;
				ab_suffx[free] = (u8)act_code;
				free++;
				if((free > context.max) && (context.nbbit < 12)) {
					context.nbbit++;	/* 1 bit de plus pour les codes LZW */
					context.max += context.max + 1;
				}
			}
			old_code = read_byt;
		}
			
	}
	return 0;
}","static int DecodeGifImg(struct ngiflib_img * VAR_0) {
	struct ngiflib_decode_context VAR_1;
	long VAR_2;
	u8 * VAR_3;
	u8 * VAR_4;
	u16 VAR_5;
	u16 VAR_6;
	u16 VAR_7;
	u16 VAR_8 = 0;
	u16 VAR_9 = 0;
	u16 VAR_10;
	u16 VAR_11[4096];
	u8 VAR_12[4096];
	u8 VAR_13[4096];
	u8 VAR_14;
	u8 VAR_15 = 0;

	if(!VAR_0) return -1;

	VAR_0->posX = GetWord(VAR_0->parent);	/* COMMENT_0 */
	VAR_0->posY = GetWord(VAR_0->parent);	/* COMMENT_1 */
	VAR_0->width = GetWord(VAR_0->parent);	/* COMMENT_2 */
	VAR_0->height = GetWord(VAR_0->parent);	/* COMMENT_3 */

	if((VAR_0->width > VAR_0->parent->width) || (VAR_0->height > VAR_0->parent->height)) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
		return -1;
	}
	if((VAR_0->posX + VAR_0->width) > VAR_0->parent->width) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
		VAR_0->posX = VAR_0->parent->width - VAR_0->width;
	}
	if((VAR_0->posY + VAR_0->height) > VAR_0->parent->height) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
		VAR_0->posY = VAR_0->parent->height - VAR_0->height;
	}
	VAR_1.Xtogo = VAR_0->width;
	VAR_1.curY = VAR_0->posY;
#ifdef VAR_17
	#ifdef VAR_18
	VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
	VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
	#else
	VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
	#endif /* COMMENT_4 */
#else
	if(VAR_0->parent->mode & VAR_19) {
		#ifdef VAR_18
		VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
		VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
		#else
		VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
		#endif /* COMMENT_4 */
	} else {
		#ifdef VAR_18
		VAR_1.line_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width;
		VAR_1.frbuff_p.p32 = VAR_1.line_p.p32 + VAR_0->posX;
		#else
		VAR_1.frbuff_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
		#endif /* COMMENT_4 */
	}
#endif /* COMMENT_5 */

	VAR_2 = (long)VAR_0->width * VAR_0->height;
	VAR_14 = GetByte(VAR_0->parent);
	VAR_0->interlaced = (VAR_14 & 64) >> 6;
	VAR_1.pass = VAR_0->interlaced ? 1 : 0;
	VAR_0->sort_flag = (VAR_14 & 32) >> 5;	/* COMMENT_6 */
	VAR_0->localpalbits = (VAR_14 & 7) + 1;
	if(VAR_14&128) { /* COMMENT_7 */
		int VAR_20;
		int VAR_21 = 1 << VAR_0->localpalbits;
#if !defined(VAR_16)
		if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Local palette\n"");
#endif /* COMMENT_8 */
		VAR_0->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*VAR_21);
		for(VAR_20=0; VAR_20<VAR_21; VAR_20++) {
			VAR_0->palette[VAR_20].r = GetByte(VAR_0->parent);
			VAR_0->palette[VAR_20].g = GetByte(VAR_0->parent);
			VAR_0->palette[VAR_20].b = GetByte(VAR_0->parent);
		}
#ifdef VAR_18
		if(VAR_0->parent->palette_cb) VAR_0->parent->palette_cb(VAR_0->parent, VAR_0->palette, VAR_21);
#endif /* COMMENT_4 */
	} else {
		VAR_0->palette = VAR_0->parent->palette;
		VAR_0->localpalbits = VAR_0->parent->imgbits;
	}
	VAR_0->ncolors = 1 << VAR_0->localpalbits;
	
	VAR_0->imgbits = GetByte(VAR_0->parent);	/* COMMENT_9 */

#if !defined(VAR_16)
	if(VAR_0->parent && VAR_0->parent->log) {
		if(VAR_0->interlaced) fprintf(VAR_0->parent->log, ""interlaced "");
		fprintf(VAR_0->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
	       VAR_0->posX, VAR_0->posY, VAR_0->width, VAR_0->height, VAR_0->localpalbits, VAR_0->imgbits, VAR_0->ncolors);
	}
#endif /* COMMENT_8 */

	if(VAR_0->imgbits==1) {	/* COMMENT_10 */
		VAR_0->imgbits = 2;
	}
	VAR_5 = 1 << VAR_0->imgbits;
	VAR_6 = VAR_5 + 1;
	VAR_7 = VAR_5 + 2;
	VAR_1.nbbit = VAR_0->imgbits + 1;
	VAR_1.max = VAR_5 + VAR_5 - 1; /* COMMENT_11 */
	VAR_3 = VAR_4 = VAR_13 + 4096;
	
	VAR_1.restbits = 0;	/* COMMENT_12 */
	VAR_1.restbyte = 0;	/* COMMENT_13 */
	VAR_1.lbyte = 0;
	for(;;) {
		VAR_8 = GetGifWord(VAR_0, &VAR_1);
		if(VAR_8==VAR_6) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""End of image code\n"");
#endif /* COMMENT_8 */
			return 0;
		}
		if(VAR_2==0) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""assez de pixels, On se casse !\n"");
#endif /* COMMENT_8 */
			return 1;
		}	
		if(VAR_8==VAR_5) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Code clear (free=%hu) npix=%ld\n"", VAR_7, VAR_2);
#endif /* COMMENT_8 */
			/* COMMENT_14 */
			VAR_7 = VAR_5 + 2;
			VAR_1.nbbit = VAR_0->imgbits + 1;
			VAR_1.max = VAR_5 + VAR_5 - 1; /* COMMENT_11 */
			VAR_8 = GetGifWord(VAR_0, &VAR_1);
			VAR_15 = (u8)VAR_8;
			VAR_9 = VAR_8;
			if(VAR_2 > 0) WritePixel(VAR_0, &VAR_1, VAR_15);
			VAR_2--;
		} else if(VAR_8 > VAR_7) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Invalid code %hu (free=%hu) !\n"", VAR_8, VAR_7);
#endif /* COMMENT_8 */
			return -1;
		} else {
			VAR_10 = VAR_8;
			if(VAR_8 == VAR_7) {	/* COMMENT_15 */
/* COMMENT_16 */
				*(--VAR_3) = VAR_15; /* COMMENT_17 */
				VAR_8 = VAR_9;
			}
/* COMMENT_18 */
			while(VAR_8 > VAR_5) { /* COMMENT_19 */
				/* COMMENT_20 */
				*(--VAR_3) = VAR_12[VAR_8];
				VAR_8 = VAR_11[VAR_8];	/* COMMENT_21 */
			}
			/* COMMENT_22 */
			VAR_15 = (u8)VAR_8;	/* COMMENT_17 */
			*(--VAR_3) = VAR_15;	/* COMMENT_23 */
			if(VAR_2 >= (VAR_4 - VAR_3)) {
				WritePixels(VAR_0, &VAR_1, VAR_3, VAR_4 - VAR_3);	/* COMMENT_24 */
			} else if(VAR_2 > 0) {	/* COMMENT_25 */
				WritePixels(VAR_0, &VAR_1, VAR_3, VAR_2);
			}
			VAR_2 -= (VAR_4 - VAR_3);
			VAR_3 = VAR_4;
/* COMMENT_26 */
			if(VAR_7 < 4096) { /* COMMENT_27 */
				VAR_11[VAR_7] = VAR_9;
				VAR_12[VAR_7] = (u8)VAR_8;
				VAR_7++;
				if((VAR_7 > VAR_1.max) && (VAR_1.nbbit < 12)) {
					VAR_1.nbbit++;	/* COMMENT_28 */
					VAR_1.max += VAR_1.max + 1;
				}
			}
			VAR_9 = VAR_10;
		}
			
	}
	return 0;
}",miniupnp/ngiflib/be4c7dffdcf7543fe24acc7448d6014a939fd26b/ngiflib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -144,9 +144,14 @@
 			old_code = act_code;
 			if(npix > 0) WritePixel(i, &context, casspecial);
 			npix--;
+		} else if(act_code > free) {
+#if !defined(NGIFLIB_NO_FILE)
+			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu (free=%hu) !\n"", act_code, free);
+#endif /* !defined(NGIFLIB_NO_FILE) */
+			return -1;
 		} else {
 			read_byt = act_code;
-			if(act_code >= free) {	/* code pas encore dans alphabet */
+			if(act_code == free) {	/* code pas encore dans alphabet */
 /*				printf(""Code pas dans alphabet : %d>=%d push %d\n"", act_code, free, casspecial); */
 				*(--stackp) = casspecial; /* dernier debut de chaine ! */
 				act_code = old_code;","{'deleted_lines': ['\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */'], 'added_lines': ['\t\t} else if(act_code > free) {', '#if !defined(NGIFLIB_NO_FILE)', '\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu (free=%hu) !\\n"", act_code, free);', '#endif /* !defined(NGIFLIB_NO_FILE) */', '\t\t\treturn -1;', '\t\t\tif(act_code == free) {\t/* code pas encore dans alphabet */']}",True,ngiflib.c in MiniUPnP ngiflib 0.4 has a stack-based buffer overflow in DecodeGifImg.,9.8,CRITICAL,3,valid,2018-06-01T07:54:19Z,2
CVE-2018-11226,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libming,"decompile: introduce new method Offset

The getString method in decompile.c is vulnerable to a buffer
overflow which can be triggered using a crafted SWF file.

This vulnerability is the consequence of unchecked accesses to the
actions array when getting the offset of SWF_ACTIONRECORD objects.

This pattern is present a bit everywhere in the source code, leading
to a large number of potential flaws similar to this one. In this
commit we introduce a new Offset method similar to the OpCode method
which handles bound checking when retrieving the offset of
SWF_ACTIONRECORD objects.

This commit also modifies getString to use this newly introduced
method and address the previously explained bug.

Usage of the newly introduced Offset method will be generalized in a
future commit.

Please, note that this commit won't be sufficient to fix #144
(CVE-2018-11226) since another issue is triggered by the same sample.",6e5a28dc0419e5c6681292db40cbd996fadf9213,https://github.com/libming/libming/commit/6e5a28dc0419e5c6681292db40cbd996fadf9213,util/decompile.c,decompile_SWITCH,"static int
decompile_SWITCH(int n, SWF_ACTION *actions, int maxn, int off1end)
{
int i,j;
int start;int ccsize=0;int cvsize=0;int maxoff=0;int n_maxoff=0;int pend=0;int xsize=0;int jmpsize=0;int lastoff=0;int n_firstactions=maxn;int lastcasestart=0;char *defa=""[last]"";char *tmp=NULL;struct strbufinfo origbuf;struct _stack *StackSave;
struct SWF_ACTIONPUSHPARAM *swcopy,*sw=pop();
struct SWF_ACTIONPUSHPARAM *compare=pop();
int offSave;
for (i=0; i<n_firstactions; i++) {
if (actions[i+1].SWF_ACTIONRECORD.Offset==off1end)
{
if (OpCode(actions, i, maxn) == SWFACTION_JUMP)
{
maxoff=actions[i].SWF_ACTIONJUMP.BranchOffset+actions[i].SWF_ACTIONJUMP.Offset+5;
j=1;
}
else
{
}
break;
} 
}
if (!maxoff)
{
for (i=maxn-1;i>=0;i--){
if (OpCode(actions, i, maxn) == SWFACTION_JUMP && !actions[i].SWF_ACTIONJUMP.BranchOffset)
{
maxoff=actions[i].SWF_ACTIONRECORD.Offset+5;
j=2;
break;
} 
}
}
for (i=0;i<maxn;i++)
{
if (actions[i].SWF_ACTIONRECORD.Offset>=maxoff)
{
n_maxoff=i;break;
}
}
if (!n_maxoff) 
n_maxoff=maxn;
INDENT
println(""switch( %s ) {        getString(sw), maxoff,n_maxoff,j);
push(sw);
push(compare);
i=1;
do {
if((OpCode(actions, i, maxn) == SWFACTION_IF
&& OpCode(actions, i-1, maxn) == SWFACTION_STRICTEQUALS )
||(OpCode(actions, i, maxn) == SWFACTION_JUMP
&& OpCode(actions, i-1, maxn) == SWFACTION_IF) )
{
start=i;
while (start<maxn 
&& actions[start].SWF_ACTIONRECORD.Offset < actions[i].SWF_ACTIONRECORD.Offset+5+actions[i].SWF_ACTIONJUMP.BranchOffset
){
start++;}
if (n_firstactions==maxn) {
n_firstactions=start;}
for (ccsize=0; ccsize+start<n_maxoff; ccsize++){
#ifdef DEBUGSWITCH
println(""in ccsize: ccsize=%d  off=%d %s"",
ccsize,actions[ccsize+start].SWF_ACTIONRECORD.Offset,
actionName(OpCode(actions, ccsize+start, maxn)));
#endif
if (OpCode(actions, ccsize+start, maxn) == SWFACTION_JUMP)
{
if (maxoff == actions[ccsize+start].SWF_ACTIONJUMP.Offset+5 + actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset)
{
jmpsize= actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset;
lastoff= actions[ccsize+start].SWF_ACTIONJUMP.Offset;
ccsize++; break;
}
}
}
#if USE_LIB
if (tmp && (start!=pend)) {
puts(tmp);
}
if (tmp)
{
free(tmp);
tmp=NULL;
}
pend=start;
#endif
if (OpCode(actions, i, maxn) == SWFACTION_JUMP)
{
if (ccsize<=1)
break;else
{
INDENT
if (actions[start].SWF_ACTIONRECORD.Offset>lastcasestart)
xsize+=ccsize;        
else
defa=""[early]"";
println(""default:        actions[start].SWF_ACTIONRECORD.Offset,defa, start, ccsize);
}
}
else
{
INDENT
xsize=ccsize;
lastcasestart=actions[start].SWF_ACTIONRECORD.Offset;
println(""case %s:        getString(pop()), lastcasestart, start, ccsize, lastoff,jmpsize);
swcopy=pop();
}
#if USE_LIB
origbuf=setTempString(); #endif
StackSave=Stack;
offSave=offseoloop;
offseoloop=maxoff;
decompileActions( ccsize, &actions[start],gIndent+1);
offseoloop=offSave;
Stack=StackSave;
#if USE_LIB
tmp=switchToOrigString(origbuf);
#endif
if (OpCode(actions, i, maxn) == SWFACTION_JUMP){
break;     }
else
{
if (OpCode(actions, i+1, maxn) != SWFACTION_JUMP) {
i++; cvsize=0;
while (i+cvsize < n_firstactions 
&& OpCode(actions, i+cvsize, maxn) != SWFACTION_STRICTEQUALS)
{
#ifdef DEBUGSWITCH
println(""in  cvsize=%d  %d %s"",
cvsize, actions[i+cvsize].SWF_ACTIONRECORD.Offset,
actionName(OpCode(actions, i+cvsize, maxn)));
#endif
cvsize++;}
decompileActions( cvsize, &actions[i],gIndent+1); i+=cvsize;
}
}
}
} while (++i < n_firstactions);
#if USE_LIB
if (tmp)
{
puts(tmp);free(tmp);
}
#endif
INDENT
println(""}","static int
decompile_SWITCH(int VAR_0, SWF_ACTION *VAR_1, int VAR_2, int VAR_3)
{
int VAR_4,VAR_5;
int VAR_6;
int VAR_7=0;
int VAR_8=0;
int VAR_9=0;
int VAR_10=0;
int VAR_11=0;
int VAR_12=0;
int VAR_13=0;
int VAR_14=0;
int VAR_15=VAR_2;
int VAR_16=0;
char *VAR_17=""[last]"";
char *VAR_18=NULL;
struct strbufinfo VAR_19;
struct _stack *VAR_20;
struct SWF_ACTIONPUSHPARAM *VAR_21,*VAR_22=pop();
struct SWF_ACTIONPUSHPARAM *VAR_23=pop();
int VAR_24;
for (VAR_4=0; VAR_4<VAR_15; VAR_4++) 
{
if (VAR_1[VAR_4+1].SWF_ACTIONRECORD.Offset==VAR_3)
{
if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25)
{
VAR_9=VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset+VAR_1[VAR_4].SWF_ACTIONJUMP.Offset+5;
VAR_5=1;
}
else
{
}
break;
} 
}
if (!VAR_9)
{
for (VAR_4=VAR_2-1;VAR_4>=0;VAR_4--)
{
if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25 && !VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset)
{
VAR_9=VAR_1[VAR_4].SWF_ACTIONRECORD.Offset+5;
VAR_5=2;
break;
} 
}
}
for (VAR_4=0;VAR_4<VAR_2;VAR_4++)
{
if (VAR_1[VAR_4].SWF_ACTIONRECORD.Offset>=VAR_9)
{
VAR_10=VAR_4;
break;
}
}
if (!VAR_10) 
VAR_10=VAR_2;
INDENT
VAR_26(""switch( %s ) {// end switch at %d (index %d) / found via meth %d)"",
getString(VAR_22), VAR_9,VAR_10,VAR_5);
push(VAR_22);
push(VAR_23);
VAR_4=1;
do 
{
if((OpCode(VAR_1, VAR_4, VAR_2) == VAR_27
&& OpCode(VAR_1, VAR_4-1, VAR_2) == VAR_28 )
||(OpCode(VAR_1, VAR_4, VAR_2) == VAR_25
&& OpCode(VAR_1, VAR_4-1, VAR_2) == VAR_27) )
{
VAR_6=VAR_4;
while (VAR_6<VAR_2 
&& VAR_1[VAR_6].SWF_ACTIONRECORD.Offset < VAR_1[VAR_4].SWF_ACTIONRECORD.Offset+5+VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset
){
VAR_6++;
}
if (VAR_15==VAR_2) 
{
VAR_15=VAR_6;
}
for (VAR_7=0; VAR_7+VAR_6<VAR_10; VAR_7++)
{
#ifdef VAR_29
VAR_26(""in ccsize: ccsize=%d  off=%d %s"",
VAR_7,VAR_1[VAR_7+VAR_6].SWF_ACTIONRECORD.Offset,
actionName(OpCode(VAR_1, VAR_7+VAR_6, VAR_2)));
#endif
if (OpCode(VAR_1, VAR_7+VAR_6, VAR_2) == VAR_25)
{
if (VAR_9 == VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.Offset+5 + VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.BranchOffset)
{
VAR_13= VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.BranchOffset;
VAR_14= VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.Offset;
VAR_7++; 
break;
}
}
}
#if VAR_30
if (VAR_18 && (VAR_6!=VAR_11)) 
{
puts(VAR_18);
}
if (VAR_18)
{
free(VAR_18);
VAR_18=NULL;
}
VAR_11=VAR_6;
#endif
if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25)
{
if (VAR_7<=1)
break;
else
{
INDENT
if (actions[VAR_6].VAR_31.VAR_32>VAR_16)
VAR_12+=VAR_7;        
else
VAR_17=""[early]"";
VAR_26(""default:// at %d %s start=%d ccsize=%d"",
actions[VAR_6].SWF_ACTIONRECORD.Offset,VAR_17, VAR_6, VAR_7);
}
}
else
{
INDENT
VAR_12=VAR_7;
VAR_16=actions[VAR_6].SWF_ACTIONRECORD.Offset;
VAR_26(""case %s:// at %d  start=%d ccsize=%d jmp=%d+%d+5"",
getString(pop()), VAR_16, VAR_6, VAR_7, VAR_14,VAR_13);
VAR_21=pop();
}
#if VAR_30
VAR_19=setTempString(); 
#endif
VAR_20=VAR_33;
VAR_24=VAR_34;
VAR_34=VAR_9;
decompileActions( VAR_7, &actions[VAR_6],VAR_35+1);
VAR_34=VAR_24;
VAR_33=VAR_20;
#if VAR_30
VAR_18=switchToOrigString(VAR_19);
#endif
if (OpCode(actions, VAR_4, VAR_2) == VAR_25)
{
break;     
}
else
{
if (OpCode(actions, VAR_4+1, VAR_2) != VAR_25) 
{
VAR_4++; 
VAR_8=0;
while (VAR_4+VAR_8 < VAR_15 
&& OpCode(actions, VAR_4+VAR_8, VAR_2) != VAR_28)
{
#ifdef VAR_29
VAR_26(""in  cvsize=%d  %d %s"",
VAR_8, actions[VAR_4+VAR_8].SWF_ACTIONRECORD.Offset,
actionName(OpCode(actions, VAR_4+VAR_8, VAR_2)));
#endif
VAR_8++;
}
decompileActions( VAR_8, &actions[VAR_4],VAR_35+1); 
VAR_4+=VAR_8;
}
}
}
} while (++VAR_4 < VAR_15);
#if VAR_30
if (VAR_18)
{
puts(VAR_18);
free(VAR_18);
}
#endif
INDENT
VAR_26(""}",libming/6e5a28dc0419e5c6681292db40cbd996fadf9213/decompile.c/vul/before/0.json,"static int
decompile_SWITCH(int n, SWF_ACTION *actions, int maxn, int off1end)
{
	int i,j;
	int start;		// base action index for case value and code
	int ccsize=0;		// size of code for case value
	int cvsize=0;		// size of case value
	int maxoff=0;		// action offset AFTER switch
	int n_maxoff=0;		// array index of maxoff
	int pend=0;		// control pending output
	int xsize=0;		// ret val
	int jmpsize=0;		// debug helper
	int lastoff=0;		// debug helper
	int n_firstactions=maxn;// array index of 1st case actions code
	int lastcasestart=0;	// offs where last ""case x:"" begins
	char *defa=""[last]"";	// debug helper for early ""default:"" 
	char *tmp=NULL;		// helper for pending output
	struct strbufinfo origbuf;	// pending output buffer
	struct _stack *StackSave;
	struct SWF_ACTIONPUSHPARAM *swcopy,*sw=pop();
	struct SWF_ACTIONPUSHPARAM *compare=pop();
	int offSave;
	for (i=0; i<n_firstactions; i++) // seek last op in 1st if
	{
		if (Offset(actions, i+1, maxn) == off1end)
		{
			// println(""found #off end first= %d"",i+1);
			if (OpCode(actions, i, maxn) == SWFACTION_JUMP)
			{
				maxoff=actions[i].SWF_ACTIONJUMP.BranchOffset+actions[i].SWF_ACTIONJUMP.Offset+5;
				j=1;
			}
			else
			{
				// SanityCheck(decompile_SWITCH,0,""no jump found where expected"");
			}
			break;
		} 
	}
	
	if (!maxoff)
	{
		for (i=maxn-1;i>=0;i--)			// seek from end of block last op of switch{}
		{
			if (OpCode(actions, i, maxn) == SWFACTION_JUMP && !actions[i].SWF_ACTIONJUMP.BranchOffset)
			{
				maxoff=actions[i].SWF_ACTIONRECORD.Offset+5;
				j=2;
				break;
			} 
		}
	}

	for (i=0;i<maxn;i++)	
	{
		if (actions[i].SWF_ACTIONRECORD.Offset>=maxoff)
		{
			n_maxoff=i;		// part of block is switch
			break;
		}
	}
		
	if (!n_maxoff) 
		n_maxoff=maxn;			// whole block is switch

	INDENT
	println(""switch( %s ) {			// end switch at %d (index %d) / found via meth %d)"",
	        getString(sw), maxoff,n_maxoff,j);
		
	push(sw);
	push(compare);

	i=1;
	do 					// here we go into main loop
	{
		if((OpCode(actions, i, maxn) == SWFACTION_IF
		   && OpCode(actions, i-1, maxn) == SWFACTION_STRICTEQUALS )
		   ||(OpCode(actions, i, maxn) == SWFACTION_JUMP
		   && OpCode(actions, i-1, maxn) == SWFACTION_IF) )
		{
			start=i;
			while (start<maxn 
			       && actions[start].SWF_ACTIONRECORD.Offset < actions[i].SWF_ACTIONRECORD.Offset+5+actions[i].SWF_ACTIONJUMP.BranchOffset
)			{
				start++;		// count actions until start of ""case x:""
			}
			if (n_firstactions==maxn) // if not done store earliest ""case x: ""actions
			{
				n_firstactions=start;	// same as array index
			}

			for (ccsize=0; ccsize+start<n_maxoff; ccsize++)	// count actions belonging to ""case x:""
			{
#ifdef DEBUGSWITCH
				println(""in ccsize: ccsize=%d  off=%d %s"",
				        ccsize,actions[ccsize+start].SWF_ACTIONRECORD.Offset,
				        actionName(OpCode(actions, ccsize+start, maxn)));
#endif
				if (OpCode(actions, ccsize+start, maxn) == SWFACTION_JUMP)
				{
					if (maxoff == actions[ccsize+start].SWF_ACTIONJUMP.Offset+5 + actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset)
					{
						jmpsize= actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset;
						lastoff= actions[ccsize+start].SWF_ACTIONJUMP.Offset;
						ccsize++; // the jmp itself
						break;
					}
				}
			}

#if USE_LIB
			if (tmp && (start!=pend)) // output pending buffer if neccessary
			{
				puts(tmp);
			}
			
			if (tmp)
			{
				free(tmp);
				tmp=NULL;
			}
			pend=start;
#endif
			if (OpCode(actions, i, maxn) == SWFACTION_JUMP)
			{
				if (ccsize<=1)
					break;	// ready
				else
				{
					INDENT
					if (actions[start].SWF_ACTIONRECORD.Offset>lastcasestart)
						xsize+=ccsize;        
					else
						defa=""[early]"";
						println(""default:			// at %d %s start=%d ccsize=%d"",
						        actions[start].SWF_ACTIONRECORD.Offset,defa, start, ccsize);
				}
			}
			else
			{
				INDENT
				xsize=ccsize;
				lastcasestart=actions[start].SWF_ACTIONRECORD.Offset;
				println(""case %s:			// at %d  start=%d ccsize=%d jmp=%d+%d+5"",
			        getString(pop()), lastcasestart, start, ccsize, lastoff,jmpsize);
				swcopy=pop();
				//   SanityCheck(decompile_SWITCH,!strcmp(getName(swcopy),getName(sw)),""sw0 != sw"");
			}

#if USE_LIB
			origbuf=setTempString(); // switch to temp buffer
#endif
			StackSave=Stack;
			offSave=offseoloop;
			offseoloop=maxoff;
			decompileActions( ccsize, &actions[start],gIndent+1);
			offseoloop=offSave;
			Stack=StackSave;
#if USE_LIB
			tmp=switchToOrigString(origbuf);
#endif

			if (OpCode(actions, i, maxn) == SWFACTION_JUMP)		// after ""default:""
			{
				break;     							// ready
			}
			else
			{
				if (OpCode(actions, i+1, maxn) != SWFACTION_JUMP) 	// not before ""default:"" or end
				{
					i++; // the 'if' itself
					cvsize=0;
					while (i+cvsize < n_firstactions 
					       && OpCode(actions, i+cvsize, maxn) != SWFACTION_STRICTEQUALS)
					{
#ifdef DEBUGSWITCH
						println(""in  cvsize=%d  %d %s"",
						        cvsize, actions[i+cvsize].SWF_ACTIONRECORD.Offset,
						        actionName(OpCode(actions, i+cvsize, maxn)));
#endif
							cvsize++;	// count ""case X:"" code size
					}
					decompileActions( cvsize, &actions[i],gIndent+1); // at least one push on stack expected
					i+=cvsize;
				}
			}
		}
	} while (++i < n_firstactions);

#if USE_LIB
	if (tmp)
	{
		puts(tmp);		// print last pending output
		free(tmp);
	}
#endif	
	INDENT
	println(""}","static int
decompile_SWITCH(int VAR_0, SWF_ACTION *VAR_1, int VAR_2, int VAR_3)
{
	int VAR_4,VAR_5;
	int VAR_6;		/* COMMENT_0 */
	int VAR_7=0;		/* COMMENT_1 */
	int VAR_8=0;		/* COMMENT_2 */
	int VAR_9=0;		/* COMMENT_3 */
	int VAR_10=0;		/* COMMENT_4 */
	int VAR_11=0;		/* COMMENT_5 */
	int VAR_12=0;		/* COMMENT_6 */
	int VAR_13=0;		/* COMMENT_7 */
	int VAR_14=0;		/* COMMENT_7 */
	int VAR_15=VAR_2;/* COMMENT_8 */
	int VAR_16=0;	/* COMMENT_9 */
	char *VAR_17=""[last]"";	/* COMMENT_10 */
	char *VAR_18=NULL;		/* COMMENT_11 */
	struct strbufinfo VAR_19;	/* COMMENT_12 */
	struct _stack *VAR_20;
	struct SWF_ACTIONPUSHPARAM *VAR_21,*VAR_22=pop();
	struct SWF_ACTIONPUSHPARAM *VAR_23=pop();
	int VAR_24;
	for (VAR_4=0; VAR_4<VAR_15; VAR_4++) /* COMMENT_13 */
	{
		if (Offset(VAR_1, VAR_4+1, VAR_2) == VAR_3)
		{
			/* COMMENT_14 */
			if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25)
			{
				VAR_9=VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset+VAR_1[VAR_4].SWF_ACTIONJUMP.Offset+5;
				VAR_5=1;
			}
			else
			{
				/* COMMENT_15 */
			}
			break;
		} 
	}
	
	if (!VAR_9)
	{
		for (VAR_4=VAR_2-1;VAR_4>=0;VAR_4--)			/* COMMENT_16 */
		{
			if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25 && !VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset)
			{
				VAR_9=VAR_1[VAR_4].SWF_ACTIONRECORD.Offset+5;
				VAR_5=2;
				break;
			} 
		}
	}

	for (VAR_4=0;VAR_4<VAR_2;VAR_4++)	
	{
		if (VAR_1[VAR_4].SWF_ACTIONRECORD.Offset>=VAR_9)
		{
			VAR_10=VAR_4;		/* COMMENT_17 */
			break;
		}
	}
		
	if (!VAR_10) 
		VAR_10=VAR_2;			/* COMMENT_18 */

	INDENT
	VAR_26(""switch( %s ) {			// end switch at %d (index %d) / found via meth %d)"",
	        getString(VAR_22), VAR_9,VAR_10,VAR_5);
		
	push(VAR_22);
	push(VAR_23);

	VAR_4=1;
	do 					/* COMMENT_19 */
	{
		if((OpCode(VAR_1, VAR_4, VAR_2) == VAR_27
		   && OpCode(VAR_1, VAR_4-1, VAR_2) == VAR_28 )
		   ||(OpCode(VAR_1, VAR_4, VAR_2) == VAR_25
		   && OpCode(VAR_1, VAR_4-1, VAR_2) == VAR_27) )
		{
			VAR_6=VAR_4;
			while (VAR_6<VAR_2 
			       && VAR_1[VAR_6].SWF_ACTIONRECORD.Offset < VAR_1[VAR_4].SWF_ACTIONRECORD.Offset+5+VAR_1[VAR_4].SWF_ACTIONJUMP.BranchOffset
)			{
				VAR_6++;		/* COMMENT_20 */
			}
			if (VAR_15==VAR_2) /* COMMENT_21 */
			{
				VAR_15=VAR_6;	/* COMMENT_22 */
			}

			for (VAR_7=0; VAR_7+VAR_6<VAR_10; VAR_7++)	/* COMMENT_23 */
			{
#ifdef VAR_29
				VAR_26(""in ccsize: ccsize=%d  off=%d %s"",
				        VAR_7,VAR_1[VAR_7+VAR_6].SWF_ACTIONRECORD.Offset,
				        actionName(OpCode(VAR_1, VAR_7+VAR_6, VAR_2)));
#endif
				if (OpCode(VAR_1, VAR_7+VAR_6, VAR_2) == VAR_25)
				{
					if (VAR_9 == VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.Offset+5 + VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.BranchOffset)
					{
						VAR_13= VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.BranchOffset;
						VAR_14= VAR_1[VAR_7+VAR_6].SWF_ACTIONJUMP.Offset;
						VAR_7++; /* COMMENT_24 */
						break;
					}
				}
			}

#if VAR_30
			if (VAR_18 && (VAR_6!=VAR_11)) /* COMMENT_25 */
			{
				puts(VAR_18);
			}
			
			if (VAR_18)
			{
				free(VAR_18);
				VAR_18=NULL;
			}
			VAR_11=VAR_6;
#endif
			if (OpCode(VAR_1, VAR_4, VAR_2) == VAR_25)
			{
				if (VAR_7<=1)
					break;	/* COMMENT_26 */
				else
				{
					INDENT
					if (actions[VAR_6].VAR_31.VAR_32>VAR_16)
						VAR_12+=VAR_7;        
					else
						VAR_17=""[early]"";
						VAR_26(""default:			// at %d %s start=%d ccsize=%d"",
						        actions[VAR_6].SWF_ACTIONRECORD.Offset,VAR_17, VAR_6, VAR_7);
				}
			}
			else
			{
				INDENT
				VAR_12=VAR_7;
				VAR_16=actions[VAR_6].SWF_ACTIONRECORD.Offset;
				VAR_26(""case %s:			// at %d  start=%d ccsize=%d jmp=%d+%d+5"",
			        getString(pop()), VAR_16, VAR_6, VAR_7, VAR_14,VAR_13);
				VAR_21=pop();
				/* COMMENT_27 */
			}

#if VAR_30
			VAR_19=setTempString(); /* COMMENT_28 */
#endif
			VAR_20=VAR_33;
			VAR_24=VAR_34;
			VAR_34=VAR_9;
			decompileActions( VAR_7, &actions[VAR_6],VAR_35+1);
			VAR_34=VAR_24;
			VAR_33=VAR_20;
#if VAR_30
			VAR_18=switchToOrigString(VAR_19);
#endif

			if (OpCode(actions, VAR_4, VAR_2) == VAR_25)		/* COMMENT_29 */
			{
				break;     							/* COMMENT_26 */
			}
			else
			{
				if (OpCode(actions, VAR_4+1, VAR_2) != VAR_25) 	/* COMMENT_30 */
				{
					VAR_4++; /* COMMENT_31 */
					VAR_8=0;
					while (VAR_4+VAR_8 < VAR_15 
					       && OpCode(actions, VAR_4+VAR_8, VAR_2) != VAR_28)
					{
#ifdef VAR_29
						VAR_26(""in  cvsize=%d  %d %s"",
						        VAR_8, actions[VAR_4+VAR_8].SWF_ACTIONRECORD.Offset,
						        actionName(OpCode(actions, VAR_4+VAR_8, VAR_2)));
#endif
							VAR_8++;	/* COMMENT_32 */
					}
					decompileActions( VAR_8, &actions[VAR_4],VAR_35+1); /* COMMENT_33 */
					VAR_4+=VAR_8;
				}
			}
		}
	} while (++VAR_4 < VAR_15);

#if VAR_30
	if (VAR_18)
	{
		puts(VAR_18);		/* COMMENT_34 */
		free(VAR_18);
	}
#endif	
	INDENT
	VAR_26(""}",libming/6e5a28dc0419e5c6681292db40cbd996fadf9213/decompile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,7 +22,7 @@
 	int offSave;
 	for (i=0; i<n_firstactions; i++) // seek last op in 1st if
 	{
-		if (actions[i+1].SWF_ACTIONRECORD.Offset==off1end)
+		if (Offset(actions, i+1, maxn) == off1end)
 		{
 			// println(""found #off end first= %d"",i+1);
 			if (OpCode(actions, i, maxn) == SWFACTION_JUMP)","{'deleted_lines': ['\t\tif (actions[i+1].SWF_ACTIONRECORD.Offset==off1end)'], 'added_lines': ['\t\tif (Offset(actions, i+1, maxn) == off1end)']}",True,"The getString function in decompile.c in libming through 0.4.8 mishandles cases where the header indicates a file size greater than the actual size, which allows remote attackers to cause a denial of service (Segmentation fault and application crash) or possibly have unspecified other impact.",8.8,HIGH,2,valid,2018-06-10T20:33:29Z,2
CVE-2018-12321,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,radareorg/radare2,Fix #10296 - Heap out of bounds read in java_switch_op(),224e6bc13fa353dd3b7f7a2334588f1c4229e58d,https://github.com/radareorg/radare2/commit/224e6bc13fa353dd3b7f7a2334588f1c4229e58d,libr/anal/p/anal_java.c,java_switch_op,"static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
ut8 op_byte = data[0];
ut64 offset = addr - java_get_method_start ();
ut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;
if (op_byte == 0xaa) {
if (pos + 8 > len) {
return op->size;
}
int min_val = (ut32)(UINT (data, pos + 4)),
max_val = (ut32)(UINT (data, pos + 8));
ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;
op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);
RAnalCaseOp *caseop = NULL;
pos += 12;
if (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {
for (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {
if (pos + 4 >= len) {
break;
}
int offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));
caseop = r_anal_switch_op_add_case (op->switch_op,
addr + pos, cur_case + min_val, addr + offset);
if (caseop) {
caseop->bb_ref_to = addr+offset;
caseop->bb_ref_from = addr; }
}
} else {
eprintf (""Invalid switch boundaries at 0x%""PFMT64x""\n"", addr);
}
}
op->size = pos;
return op->size;
}","static int java_switch_op(RAnal *VAR_0, RAnalOp *VAR_1, ut64 VAR_2, const ut8 *VAR_3, int VAR_4) {
ut8 VAR_5 = VAR_3[0];
ut64 VAR_6 = VAR_2 - java_get_method_start ();
ut8 VAR_7 = (VAR_6+1)%4 ? 1 + 4 - (VAR_6+1)%4 : 1;
if (VAR_5 == 0xaa) {
if (VAR_7 + 8 > VAR_4) {
return VAR_1->size;
}
int VAR_8 = (VAR_9)(UINT (VAR_3, VAR_7 + 4)),
VAR_10 = (VAR_9)(UINT (VAR_3, VAR_7 + 8));
ut32 VAR_11 = (ut32) (UINT (VAR_3, VAR_7)), VAR_12 = 0;
VAR_1->switch_op = r_anal_switch_op_new (VAR_2, VAR_8, VAR_11);
RAnalCaseOp *VAR_13 = NULL;
VAR_7 += 12;
if (VAR_10 > VAR_8 && ((VAR_10 - VAR_8)<(VAR_14/4))) {
for (VAR_12 = 0; VAR_12 <= VAR_10 - VAR_8; VAR_7 += 4, VAR_12++) {
if (VAR_7 + 4 >= VAR_4) {
break;
}
int VAR_6 = (int)(ut32)(R_BIN_JAVA_UINT (VAR_3, VAR_7));
VAR_13 = r_anal_switch_op_add_case (VAR_1->switch_op,
VAR_2 + VAR_7, VAR_12 + VAR_8, VAR_2 + VAR_6);
if (VAR_13) {
VAR_13->bb_ref_to = VAR_2+VAR_6;
VAR_13->bb_ref_from = VAR_2; 
}
}
} else {
eprintf (""Invalid switch boundaries at 0x%""VAR_15""\n"", VAR_2);
}
}
VAR_1->size = VAR_7;
return VAR_1->size;
}",radareorg/radare2/224e6bc13fa353dd3b7f7a2334588f1c4229e58d/anal_java.c/vul/before/0.json,"static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
	ut8 op_byte = data[0];
	ut64 offset = addr - java_get_method_start ();
	ut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;

	if (op_byte == 0xaa) {
		// handle a table switch condition
		if (pos + 8 + 8 > len) {
			return op->size;
		}
		const int min_val = (ut32)(UINT (data, pos + 4));
		const int max_val = (ut32)(UINT (data, pos + 8));

		ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;
		op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);
		RAnalCaseOp *caseop = NULL;
		pos += 12;
		if (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {
			//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset);
			for (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {
				//ut32 value = (ut32)(UINT (data, pos));
				if (pos + 4 >= len) {
					// switch is too big cant read further
					break;
				}
				int offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));
				caseop = r_anal_switch_op_add_case (op->switch_op,
					addr + pos, cur_case + min_val, addr + offset);
				if (caseop) {
					caseop->bb_ref_to = addr+offset;
					caseop->bb_ref_from = addr; // TODO figure this one out
				}
			}
		} else {
			eprintf (""Invalid switch boundaries at 0x%""PFMT64x""\n"", addr);
		}
	}
	op->size = pos;
	return op->size;
}","static int java_switch_op(RAnal *VAR_0, RAnalOp *VAR_1, ut64 VAR_2, const ut8 *VAR_3, int VAR_4) {
	ut8 VAR_5 = VAR_3[0];
	ut64 VAR_6 = VAR_2 - java_get_method_start ();
	ut8 VAR_7 = (VAR_6+1)%4 ? 1 + 4 - (VAR_6+1)%4 : 1;

	if (VAR_5 == 0xaa) {
		/* COMMENT_0 */
		if (VAR_7 + 8 + 8 > VAR_4) {
			return VAR_1->size;
		}
		const int VAR_8 = (VAR_9)(UINT (VAR_3, VAR_7 + 4));
		const int VAR_10 = (VAR_9)(UINT (VAR_3, VAR_7 + 8));

		ut32 VAR_11 = (ut32) (UINT (VAR_3, VAR_7)), VAR_12 = 0;
		VAR_1->switch_op = r_anal_switch_op_new (VAR_2, VAR_8, VAR_11);
		RAnalCaseOp *VAR_13 = NULL;
		VAR_7 += 12;
		if (VAR_10 > VAR_8 && ((VAR_10 - VAR_8)<(VAR_14/4))) {
			/* COMMENT_1 */
			for (VAR_12 = 0; VAR_12 <= VAR_10 - VAR_8; VAR_7 += 4, VAR_12++) {
				/* COMMENT_2 */
				if (VAR_7 + 4 >= VAR_4) {
					/* COMMENT_3 */
					break;
				}
				int VAR_6 = (int)(ut32)(R_BIN_JAVA_UINT (VAR_3, VAR_7));
				VAR_13 = r_anal_switch_op_add_case (VAR_1->switch_op,
					VAR_2 + VAR_7, VAR_12 + VAR_8, VAR_2 + VAR_6);
				if (VAR_13) {
					VAR_13->bb_ref_to = VAR_2+VAR_6;
					VAR_13->bb_ref_from = VAR_2; /* COMMENT_4 */
				}
			}
		} else {
			eprintf (""Invalid switch boundaries at 0x%""VAR_15""\n"", VAR_2);
		}
	}
	VAR_1->size = VAR_7;
	return VAR_1->size;
}",radareorg/radare2/224e6bc13fa353dd3b7f7a2334588f1c4229e58d/anal_java.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,11 +5,11 @@
 
 	if (op_byte == 0xaa) {
 		// handle a table switch condition
-		if (pos + 8 > len) {
+		if (pos + 8 + 8 > len) {
 			return op->size;
 		}
-		int min_val = (ut32)(UINT (data, pos + 4)),
-			max_val = (ut32)(UINT (data, pos + 8));
+		const int min_val = (ut32)(UINT (data, pos + 4));
+		const int max_val = (ut32)(UINT (data, pos + 8));
 
 		ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;
 		op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);","{'deleted_lines': ['\t\tif (pos + 8 > len) {', '\t\tint min_val = (ut32)(UINT (data, pos + 4)),', '\t\t\tmax_val = (ut32)(UINT (data, pos + 8));'], 'added_lines': ['\t\tif (pos + 8 + 8 > len) {', '\t\tconst int min_val = (ut32)(UINT (data, pos + 4));', '\t\tconst int max_val = (ut32)(UINT (data, pos + 8));']}",True,There is a heap out of bounds read in radare2 2.6.0 in java_switch_op() in libr/anal/p/anal_java.c via a crafted Java binary file.,7.8,HIGH,2,valid,2018-06-11T01:15:07Z,2
CVE-2018-12265,"['CWE-190', 'CWE-125']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Exiv2/exiv2,"Add offset_ and size_ safely in LoaderExifJpeg::LoaderExifJpeg

offset_ can become arbitrarily large and overflows once its added to size_,
this causes all kinds of problems further in the code when offset_ is used
again.
=> Use Safe::add() to catch potential overflows
This fixes #365.",937a1a2bd067b8b3b787f3757089d972f3a39853,https://github.com/Exiv2/exiv2/commit/937a1a2bd067b8b3b787f3757089d972f3a39853,src/preview.cpp,LoaderExifJpeg::LoaderExifJpeg,"LoaderExifJpeg::LoaderExifJpeg(PreviewId id, const Image &image, int parIdx)
: Loader(id, image)
{
offset_ = 0;
const ExifData &exifData = image_.exifData();
ExifData::const_iterator pos = exifData.findKey(ExifKey(param_[parIdx].offsetKey_));
if (pos != exifData.end() && pos->count() > 0) {
offset_ = pos->toLong();
}
size_ = 0;
pos = exifData.findKey(ExifKey(param_[parIdx].sizeKey_));
if (pos != exifData.end() && pos->count() > 0) {
size_ = pos->toLong();
}
if (offset_ == 0 || size_ == 0) return;
if (param_[parIdx].baseOffsetKey_) {
pos = exifData.findKey(ExifKey(param_[parIdx].baseOffsetKey_));
if (pos != exifData.end() && pos->count() > 0) {
offset_ += pos->toLong();
}
}
if (offset_ + size_ > static_cast<uint32_t>(image_.io().size())) return;
valid_ = true;
}","LoaderExifJpeg::LoaderExifJpeg(PreviewId VAR_0, const Image &VAR_1, int VAR_2)
: Loader(VAR_0, VAR_1)
{
VAR_3 = 0;
const ExifData &VAR_4 = VAR_5.exifData();
ExifData::const_iterator VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].offsetKey_));
if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
VAR_3 = VAR_6->toLong();
}
VAR_8 = 0;
VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].sizeKey_));
if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
VAR_8 = VAR_6->toLong();
}
if (VAR_3 == 0 || VAR_8 == 0) return;
if (VAR_7[VAR_2].baseOffsetKey_) {
VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].baseOffsetKey_));
if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
VAR_3 += VAR_6->toLong();
}
}
if (VAR_3 + VAR_8 > VAR_9<uint32_t>(VAR_5.io().size())) return;
VAR_10 = true;
}",Exiv2/exiv2/937a1a2bd067b8b3b787f3757089d972f3a39853/preview.cpp/vul/before/0.json,"LoaderExifJpeg::LoaderExifJpeg(PreviewId id, const Image &image, int parIdx)
        : Loader(id, image)
    {
        offset_ = 0;
		const ExifData &exifData = image_.exifData();
        ExifData::const_iterator pos = exifData.findKey(ExifKey(param_[parIdx].offsetKey_));
        if (pos != exifData.end() && pos->count() > 0) {
            offset_ = pos->toLong();
        }

        size_ = 0;
        pos = exifData.findKey(ExifKey(param_[parIdx].sizeKey_));
        if (pos != exifData.end() && pos->count() > 0) {
            size_ = pos->toLong();
        }

        if (offset_ == 0 || size_ == 0) return;

        if (param_[parIdx].baseOffsetKey_) {
            pos = exifData.findKey(ExifKey(param_[parIdx].baseOffsetKey_));
            if (pos != exifData.end() && pos->count() > 0) {
                offset_ += pos->toLong();
            }
        }

        if (Safe::add(offset_, size_) > static_cast<uint32_t>(image_.io().size()))
            return;

        valid_ = true;
    }","LoaderExifJpeg::LoaderExifJpeg(PreviewId VAR_0, const Image &VAR_1, int VAR_2)
        : Loader(VAR_0, VAR_1)
    {
        VAR_3 = 0;
		const ExifData &VAR_4 = VAR_5.exifData();
        ExifData::const_iterator VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].offsetKey_));
        if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
            VAR_3 = VAR_6->toLong();
        }

        VAR_8 = 0;
        VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].sizeKey_));
        if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
            VAR_8 = VAR_6->toLong();
        }

        if (VAR_3 == 0 || VAR_8 == 0) return;

        if (VAR_7[VAR_2].baseOffsetKey_) {
            VAR_6 = VAR_4.findKey(ExifKey(VAR_7[VAR_2].baseOffsetKey_));
            if (VAR_6 != VAR_4.end() && VAR_6->count() > 0) {
                VAR_3 += VAR_6->toLong();
            }
        }

        if (Safe::add(VAR_3, VAR_8) > VAR_9<uint32_t>(VAR_5.io().size()))
            return;

        VAR_10 = true;
    }",Exiv2/exiv2/937a1a2bd067b8b3b787f3757089d972f3a39853/preview.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,7 +23,8 @@
             }
         }
 
-        if (offset_ + size_ > static_cast<uint32_t>(image_.io().size())) return;
+        if (Safe::add(offset_, size_) > static_cast<uint32_t>(image_.io().size()))
+            return;
 
         valid_ = true;
     }","{'deleted_lines': ['        if (offset_ + size_ > static_cast<uint32_t>(image_.io().size())) return;'], 'added_lines': ['        if (Safe::add(offset_, size_) > static_cast<uint32_t>(image_.io().size()))', '            return;']}",True,"Exiv2 0.26 has an integer overflow in the LoaderExifJpeg class in preview.cpp, leading to an out-of-bounds read in Exiv2::MemIo::read in basicio.cpp.",8.8,HIGH,2,valid,2018-06-11T14:04:28Z,2
CVE-2015-9253,['CWE-400'],AV:N/AC:L/Au:S/C:N/I:N/A:C,0,php/php-src,"Fixed bug #73342

Directly listen on socket, instead of duping it to STDIN and
listening on that.",69dee5c732fe982c82edb17d0dbc3e79a47748d8,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,sapi/fpm/fpm/fpm_stdio.c,fpm_stdio_init_child,"int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) 
{
#ifdef HAVE_SYSLOG_H
if (fpm_globals.error_log_fd == ZLOG_SYSLOG) {
closelog(); 
} else
#endif
if (fpm_globals.error_log_fd > 0) {
close(fpm_globals.error_log_fd);
}
fpm_globals.error_log_fd = -1;
zlog_set_fd(-1);
if (wp->listening_socket != STDIN_FILENO) {
if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
return -1;
}
}
return 0;
}","int fpm_stdio_init_child(struct fpm_worker_pool_s *VAR_0) 
{
#ifdef VAR_1
if (VAR_2.error_log_fd == VAR_3) {
closelog(); 
} else
#endif
if (VAR_2.error_log_fd > 0) {
close(VAR_2.error_log_fd);
}
VAR_2.error_log_fd = -1;
zlog_set_fd(-1);
if (VAR_0->listening_socket != VAR_4) {
if (0 > dup2(VAR_0->listening_socket, VAR_4)) {
zlog(VAR_5, ""failed to init child stdio: dup2()"");
return -1;
}
}
return 0;
}",php/php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8/fpm_stdio.c/vul/before/0.json,"int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */
{
#ifdef HAVE_SYSLOG_H
	if (fpm_globals.error_log_fd == ZLOG_SYSLOG) {
		closelog(); /* ensure to close syslog not to interrupt with PHP syslog code */
	} else
#endif

	/* Notice: child cannot use master error_log
	 * because not aware when being reopen
	 * else, should use if (!fpm_use_error_log())
	 */
	if (fpm_globals.error_log_fd > 0) {
		close(fpm_globals.error_log_fd);
	}
	fpm_globals.error_log_fd = -1;
	zlog_set_fd(-1);

	return 0;
}","int fpm_stdio_init_child(struct fpm_worker_pool_s *VAR_0) /* COMMENT_0 */
{
#ifdef VAR_1
	if (VAR_2.error_log_fd == VAR_3) {
		closelog(); /* COMMENT_1 */
	} else
#endif

	/* COMMENT_2 */
                                       
                                              
    
	if (VAR_2.error_log_fd > 0) {
		close(VAR_2.error_log_fd);
	}
	VAR_2.error_log_fd = -1;
	zlog_set_fd(-1);

	return 0;
}",php/php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8/fpm_stdio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,11 +16,5 @@
 	fpm_globals.error_log_fd = -1;
 	zlog_set_fd(-1);
 
-	if (wp->listening_socket != STDIN_FILENO) {
-		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
-			zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
-			return -1;
-		}
-	}
 	return 0;
 }","{'deleted_lines': ['\tif (wp->listening_socket != STDIN_FILENO) {', '\t\tif (0 > dup2(wp->listening_socket, STDIN_FILENO)) {', '\t\t\tzlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");', '\t\t\treturn -1;', '\t\t}', '\t}'], 'added_lines': []}",True,"An issue was discovered in PHP 7.3.x before 7.3.0alpha3, 7.2.x before 7.2.8, and before 7.1.20. The php-fpm master process restarts a child process in an endless loop when using program execution functions (e.g., passthru, exec, shell_exec, or system) with a non-blocking STDIN stream, causing this master process to consume 100% of the CPU, and consume disk space with a large volume of error logs, as demonstrated by an attack by a customer of a shared-hosting facility.",6.5,MEDIUM,1,valid,2018-06-12T18:34:01Z,2
CVE-2015-9253,['CWE-400'],AV:N/AC:L/Au:S/C:N/I:N/A:C,0,php/php-src,"Fixed bug #73342

Directly listen on socket, instead of duping it to STDIN and
listening on that.",69dee5c732fe982c82edb17d0dbc3e79a47748d8,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,sapi/fpm/fpm/fpm_children.c,fpm_child_init,"static void fpm_child_init(struct fpm_worker_pool_s *wp) 
{
fpm_globals.max_requests = wp->config->pm_max_requests;
if (0 > fpm_stdio_init_child(wp)  ||
0 > fpm_log_init_child(wp)    ||
0 > fpm_status_init_child(wp) ||
0 > fpm_unix_init_child(wp)   ||
0 > fpm_signals_init_child()  ||
0 > fpm_env_init_child(wp)    ||
0 > fpm_php_init_child(wp)) {
zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
exit(FPM_EXIT_SOFTWARE);
}
}","static void fpm_child_init(struct fpm_worker_pool_s *VAR_0) 
{
VAR_1.max_requests = VAR_0->config->pm_max_requests;
if (0 > fpm_stdio_init_child(VAR_0)  ||
0 > fpm_log_init_child(VAR_0)    ||
0 > fpm_status_init_child(VAR_0) ||
0 > fpm_unix_init_child(VAR_0)   ||
0 > fpm_signals_init_child()  ||
0 > fpm_env_init_child(VAR_0)    ||
0 > fpm_php_init_child(VAR_0)) {
zlog(VAR_2, ""[pool %s] child failed to initialize"", VAR_0->config->name);
exit(VAR_3);
}
}",php/php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8/fpm_children.c/vul/before/0.json,"static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
{
	fpm_globals.max_requests = wp->config->pm_max_requests;
	fpm_globals.listening_socket = dup(wp->listening_socket);

	if (0 > fpm_stdio_init_child(wp)  ||
	    0 > fpm_log_init_child(wp)    ||
	    0 > fpm_status_init_child(wp) ||
	    0 > fpm_unix_init_child(wp)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(wp)    ||
	    0 > fpm_php_init_child(wp)) {

		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
		exit(FPM_EXIT_SOFTWARE);
	}
}","static void fpm_child_init(struct fpm_worker_pool_s *VAR_0) /* COMMENT_0 */
{
	VAR_1.max_requests = VAR_0->config->pm_max_requests;
	VAR_1.listening_socket = dup(VAR_0->listening_socket);

	if (0 > fpm_stdio_init_child(VAR_0)  ||
	    0 > fpm_log_init_child(VAR_0)    ||
	    0 > fpm_status_init_child(VAR_0) ||
	    0 > fpm_unix_init_child(VAR_0)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(VAR_0)    ||
	    0 > fpm_php_init_child(VAR_0)) {

		zlog(VAR_2, ""[pool %s] child failed to initialize"", VAR_0->config->name);
		exit(VAR_3);
	}
}",php/php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8/fpm_children.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
+	fpm_globals.listening_socket = dup(wp->listening_socket);
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||","{'deleted_lines': [], 'added_lines': ['\tfpm_globals.listening_socket = dup(wp->listening_socket);']}",True,"An issue was discovered in PHP 7.3.x before 7.3.0alpha3, 7.2.x before 7.2.8, and before 7.1.20. The php-fpm master process restarts a child process in an endless loop when using program execution functions (e.g., passthru, exec, shell_exec, or system) with a non-blocking STDIN stream, causing this master process to consume 100% of the CPU, and consume disk space with a large volume of error logs, as demonstrated by an attack by a customer of a shared-hosting facility.",6.5,MEDIUM,1,valid,2018-06-12T18:34:01Z,2
CVE-2018-1000524,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,spheredev/neosphere,"Fix integer overflow in layer_resize in map_engine.c (#268)

* Fix integer overflow in layer_resize in map_engine.c

There's a buffer overflow bug in the function layer_resize. It allocates
a buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`.
But it didn't check for integer overflow, so if x_size and y_size are
very large, it's possible that the buffer size is smaller than needed,
causing a buffer overflow later.

PoC: `SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`

* move malloc to a separate line",252c1ca184cb38e1acb917aa0e451c5f08519996,https://github.com/spheredev/neosphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996,src/minisphere/map_engine.c,layer_resize,"bool
layer_resize(int layer, int x_size, int y_size)
{
int                 old_height;
int                 old_width;
struct map_tile*    tile;
int                 tile_width;
int                 tile_height;
struct map_tile*    tilemap;
struct map_trigger* trigger;
struct map_zone*    zone;
int x, y, i;
old_width = s_map->layers[layer].width;
old_height = s_map->layers[layer].height;
if (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))
return false;
for (x = 0; x < x_size; ++x) {
for (y = 0; y < y_size; ++y) {
if (x < old_width && y < old_height) {
tilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];
}
else {
tile = &tilemap[x + y * x_size];
tile->frames_left = tileset_get_delay(s_map->tileset, 0);
tile->tile_index = 0;
}
}
}
free(s_map->layers[layer].tilemap);
s_map->layers[layer].tilemap = tilemap;
s_map->layers[layer].width = x_size;
s_map->layers[layer].height = y_size;
tileset_get_size(s_map->tileset, &tile_width, &tile_height);
s_map->width = 0;
s_map->height = 0;
for (i = 0; i < s_map->num_layers; ++i) {
if (!s_map->layers[i].is_parallax) {
s_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);
s_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);
}
}
for (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {
zone = vector_get(s_map->zones, i);
if (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)
vector_remove(s_map->zones, i);
else {
if (zone->bounds.x2 > s_map->width)
zone->bounds.x2 = s_map->width;
if (zone->bounds.y2 > s_map->height)
zone->bounds.y2 = s_map->height;
}
}
for (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {
trigger = vector_get(s_map->triggers, i);
if (trigger->x >= s_map->width || trigger->y >= s_map->height)
vector_remove(s_map->triggers, i);
}
return true;
}","bool
layer_resize(int VAR_0, int VAR_1, int VAR_2)
{
int                 VAR_3;
int                 VAR_4;
struct map_tile*    VAR_5;
int                 VAR_6;
int                 VAR_7;
struct map_tile*    VAR_8;
struct map_trigger* VAR_9;
struct map_zone*    VAR_10;
int VAR_11, VAR_12, VAR_13;
VAR_4 = VAR_14->layers[VAR_0].width;
VAR_3 = VAR_14->layers[VAR_0].height;
if (!(VAR_8 = malloc(VAR_1 * VAR_2 * sizeof(struct map_tile))))
return false;
for (VAR_11 = 0; VAR_11 < VAR_1; ++VAR_11) {
for (VAR_12 = 0; VAR_12 < VAR_2; ++VAR_12) {
if (VAR_11 < VAR_4 && VAR_12 < VAR_3) {
VAR_8[VAR_11 + VAR_12 * VAR_1] = VAR_14->layers[VAR_0].tilemap[VAR_11 + VAR_12 * VAR_4];
}
else {
VAR_5 = &VAR_8[VAR_11 + VAR_12 * VAR_1];
VAR_5->frames_left = tileset_get_delay(VAR_14->tileset, 0);
VAR_5->tile_index = 0;
}
}
}
free(VAR_14->layers[VAR_0].tilemap);
VAR_14->layers[VAR_0].tilemap = VAR_8;
VAR_14->layers[VAR_0].width = VAR_1;
VAR_14->layers[VAR_0].height = VAR_2;
tileset_get_size(VAR_14->tileset, &VAR_6, &VAR_7);
VAR_14->width = 0;
VAR_14->height = 0;
for (VAR_13 = 0; VAR_13 < VAR_14->num_layers; ++VAR_13) {
if (!VAR_14->layers[VAR_13].is_parallax) {
VAR_14->width = fmax(VAR_14->width, VAR_14->layers[VAR_13].width * VAR_6);
VAR_14->height = fmax(VAR_14->height, VAR_14->layers[VAR_13].height * VAR_7);
}
}
for (VAR_13 = (int)vector_len(VAR_14->zones) - 1; VAR_13 >= 0; --VAR_13) {
VAR_10 = vector_get(VAR_14->zones, VAR_13);
if (VAR_10->bounds.x1 >= VAR_14->width || VAR_10->bounds.y1 >= VAR_14->height)
vector_remove(VAR_14->zones, VAR_13);
else {
if (VAR_10->bounds.x2 > VAR_14->width)
VAR_10->bounds.x2 = VAR_14->width;
if (VAR_10->bounds.y2 > VAR_14->height)
VAR_10->bounds.y2 = VAR_14->height;
}
}
for (VAR_13 = (int)vector_len(VAR_14->triggers) - 1; VAR_13 >= 0; --VAR_13) {
VAR_9 = vector_get(VAR_14->triggers, VAR_13);
if (VAR_9->x >= VAR_14->width || VAR_9->y >= VAR_14->height)
vector_remove(VAR_14->triggers, VAR_13);
}
return true;
}",spheredev/neosphere/252c1ca184cb38e1acb917aa0e451c5f08519996/map_engine.c/vul/before/0.json,"bool
layer_resize(int layer, int x_size, int y_size)
{
	int                 old_height;
	int                 old_width;
	struct map_tile*    tile;
	int                 tile_width;
	int                 tile_height;
	struct map_tile*    tilemap;
	struct map_trigger* trigger;
	struct map_zone*    zone;
	size_t              tilemap_size;

	int x, y, i;

	old_width = s_map->layers[layer].width;
	old_height = s_map->layers[layer].height;

	// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc
	// because the tilemap is a 2D array.
	tilemap_size = x_size * y_size * sizeof(struct map_tile);
	if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size
		|| !(tilemap = malloc(tilemap_size)))
		return false;
	for (x = 0; x < x_size; ++x) {
		for (y = 0; y < y_size; ++y) {
			if (x < old_width && y < old_height) {
				tilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];
			}
			else {
				tile = &tilemap[x + y * x_size];
				tile->frames_left = tileset_get_delay(s_map->tileset, 0);
				tile->tile_index = 0;
			}
		}
	}

	// free the old tilemap and substitute the new one
	free(s_map->layers[layer].tilemap);
	s_map->layers[layer].tilemap = tilemap;
	s_map->layers[layer].width = x_size;
	s_map->layers[layer].height = y_size;

	// if we resize the largest layer, the overall map size will change.
	// recalcuate it.
	tileset_get_size(s_map->tileset, &tile_width, &tile_height);
	s_map->width = 0;
	s_map->height = 0;
	for (i = 0; i < s_map->num_layers; ++i) {
		if (!s_map->layers[i].is_parallax) {
			s_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);
			s_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);
		}
	}

	// ensure zones and triggers remain in-bounds.  if any are completely
	// out-of-bounds, delete them.
	for (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {
		zone = vector_get(s_map->zones, i);
		if (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)
			vector_remove(s_map->zones, i);
		else {
			if (zone->bounds.x2 > s_map->width)
				zone->bounds.x2 = s_map->width;
			if (zone->bounds.y2 > s_map->height)
				zone->bounds.y2 = s_map->height;
		}
	}
	for (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {
		trigger = vector_get(s_map->triggers, i);
		if (trigger->x >= s_map->width || trigger->y >= s_map->height)
			vector_remove(s_map->triggers, i);
	}

	return true;
}","bool
layer_resize(int VAR_0, int VAR_1, int VAR_2)
{
	int                 VAR_3;
	int                 VAR_4;
	struct map_tile*    VAR_5;
	int                 VAR_6;
	int                 VAR_7;
	struct map_tile*    VAR_8;
	struct map_trigger* VAR_9;
	struct map_zone*    VAR_10;
	size_t              VAR_11;

	int VAR_12, VAR_13, VAR_14;

	VAR_4 = VAR_15->layers[VAR_0].width;
	VAR_3 = VAR_15->layers[VAR_0].height;

	/* COMMENT_0 */
	/* COMMENT_1 */
	VAR_11 = VAR_1 * VAR_2 * sizeof(struct map_tile);
	if (VAR_1 == 0 || VAR_11 / VAR_1 / sizeof(struct map_tile) != VAR_2
		|| !(VAR_8 = malloc(VAR_11)))
		return false;
	for (VAR_12 = 0; VAR_12 < VAR_1; ++VAR_12) {
		for (VAR_13 = 0; VAR_13 < VAR_2; ++VAR_13) {
			if (VAR_12 < VAR_4 && VAR_13 < VAR_3) {
				VAR_8[VAR_12 + VAR_13 * VAR_1] = VAR_15->layers[VAR_0].tilemap[VAR_12 + VAR_13 * VAR_4];
			}
			else {
				VAR_5 = &VAR_8[VAR_12 + VAR_13 * VAR_1];
				VAR_5->frames_left = tileset_get_delay(VAR_15->tileset, 0);
				VAR_5->tile_index = 0;
			}
		}
	}

	/* COMMENT_2 */
	free(VAR_15->layers[VAR_0].tilemap);
	VAR_15->layers[VAR_0].tilemap = VAR_8;
	VAR_15->layers[VAR_0].width = VAR_1;
	VAR_15->layers[VAR_0].height = VAR_2;

	/* COMMENT_3 */
	/* COMMENT_4 */
	tileset_get_size(VAR_15->tileset, &VAR_6, &VAR_7);
	VAR_15->width = 0;
	VAR_15->height = 0;
	for (VAR_14 = 0; VAR_14 < VAR_15->num_layers; ++VAR_14) {
		if (!VAR_15->layers[VAR_14].is_parallax) {
			VAR_15->width = fmax(VAR_15->width, VAR_15->layers[VAR_14].width * VAR_6);
			VAR_15->height = fmax(VAR_15->height, VAR_15->layers[VAR_14].height * VAR_7);
		}
	}

	/* COMMENT_5 */
	/* COMMENT_6 */
	for (VAR_14 = (int)vector_len(VAR_15->zones) - 1; VAR_14 >= 0; --VAR_14) {
		VAR_10 = vector_get(VAR_15->zones, VAR_14);
		if (VAR_10->bounds.x1 >= VAR_15->width || VAR_10->bounds.y1 >= VAR_15->height)
			vector_remove(VAR_15->zones, VAR_14);
		else {
			if (VAR_10->bounds.x2 > VAR_15->width)
				VAR_10->bounds.x2 = VAR_15->width;
			if (VAR_10->bounds.y2 > VAR_15->height)
				VAR_10->bounds.y2 = VAR_15->height;
		}
	}
	for (VAR_14 = (int)vector_len(VAR_15->triggers) - 1; VAR_14 >= 0; --VAR_14) {
		VAR_9 = vector_get(VAR_15->triggers, VAR_14);
		if (VAR_9->x >= VAR_15->width || VAR_9->y >= VAR_15->height)
			vector_remove(VAR_15->triggers, VAR_14);
	}

	return true;
}",spheredev/neosphere/252c1ca184cb38e1acb917aa0e451c5f08519996/map_engine.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,7 @@
 	struct map_tile*    tilemap;
 	struct map_trigger* trigger;
 	struct map_zone*    zone;
+	size_t              tilemap_size;
 
 	int x, y, i;
 
@@ -17,7 +18,9 @@
 
 	// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc
 	// because the tilemap is a 2D array.
-	if (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))
+	tilemap_size = x_size * y_size * sizeof(struct map_tile);
+	if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size
+		|| !(tilemap = malloc(tilemap_size)))
 		return false;
 	for (x = 0; x < x_size; ++x) {
 		for (y = 0; y < y_size; ++y) {","{'deleted_lines': ['\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))'], 'added_lines': ['\tsize_t              tilemap_size;', '\ttilemap_size = x_size * y_size * sizeof(struct map_tile);', '\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size', '\t\t|| !(tilemap = malloc(tilemap_size)))']}",True,"miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later.",5.5,MEDIUM,1,valid,2018-06-13T05:12:57Z,2
CVE-2018-13785,"['CWE-190', 'CWE-369']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pnggroup/libpng,"[libpng16] Fix the calculation of row_factor in png_check_chunk_length

(Bug report by Thuan Pham, SourceForge issue #278)",8a05766cb74af05c04c53e6c9d60c13fc4d59bf2,https://github.com/pnggroup/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2,pngrutil.c,png_check_chunk_length,"void 
png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
{
png_alloc_size_t limit = PNG_UINT_31_MAX;
# ifdef PNG_SET_USER_LIMITS_SUPPORTED
if (png_ptr->user_chunk_malloc_max > 0 &&
png_ptr->user_chunk_malloc_max < limit)
limit = png_ptr->user_chunk_malloc_max;
# elif PNG_USER_CHUNK_MALLOC_MAX > 0
if (PNG_USER_CHUNK_MALLOC_MAX < limit)
limit = PNG_USER_CHUNK_MALLOC_MAX;
# endif
if (png_ptr->chunk_name == png_IDAT)
{
png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
size_t row_factor =
(png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
+ 1 + (png_ptr->interlaced? 6: 0));
if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
idat_limit=PNG_UINT_31_MAX;
else
idat_limit = png_ptr->height * row_factor;
row_factor = row_factor > 32566? 32566 : row_factor;
idat_limit += 6 + 5*(idat_limit/row_factor+1); 
idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
limit = limit < idat_limit? idat_limit : limit;
}
if (length > limit)
{
png_debug2(0,"" length = %lu, limit = %lu"",
(unsigned long)length,(unsigned long)limit);
png_chunk_error(png_ptr, ""chunk data is too large"");
}
}","void 
png_check_chunk_length(png_const_structrp VAR_0, const png_uint_32 VAR_1)
{
png_alloc_size_t VAR_2 = VAR_3;
# ifdef VAR_4
if (VAR_0->user_chunk_malloc_max > 0 &&
VAR_0->user_chunk_malloc_max < VAR_2)
VAR_2 = VAR_0->user_chunk_malloc_max;
# elif VAR_5 > 0
if (VAR_5 < VAR_2)
VAR_2 = VAR_5;
# endif
if (VAR_0->chunk_name == VAR_6)
{
png_alloc_size_t VAR_7 = VAR_3;
size_t VAR_8 =
(VAR_0->width * VAR_0->channels * (VAR_0->bit_depth > 8? 2: 1)
+ 1 + (VAR_0->interlaced? 6: 0));
if (VAR_0->height > VAR_9/VAR_8)
VAR_7=VAR_3;
else
VAR_7 = VAR_0->height * VAR_8;
VAR_8 = VAR_8 > 32566? 32566 : VAR_8;
VAR_7 += 6 + 5*(VAR_7/VAR_8+1); 
VAR_7=VAR_7 < VAR_3? VAR_7 : VAR_3;
VAR_2 = VAR_2 < VAR_7? VAR_7 : VAR_2;
}
if (VAR_1 > VAR_2)
{
png_debug2(0,"" length = %lu, limit = %lu"",
(unsigned long)VAR_1,(unsigned long)VAR_2);
png_chunk_error(VAR_0, ""chunk data is too large"");
}
}",pnggroup/libpng/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2/pngrutil.c/vul/before/0.json,"void /* PRIVATE */
png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
{
   png_alloc_size_t limit = PNG_UINT_31_MAX;

# ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_malloc_max > 0 &&
       png_ptr->user_chunk_malloc_max < limit)
      limit = png_ptr->user_chunk_malloc_max;
# elif PNG_USER_CHUNK_MALLOC_MAX > 0
   if (PNG_USER_CHUNK_MALLOC_MAX < limit)
      limit = PNG_USER_CHUNK_MALLOC_MAX;
# endif
   if (png_ptr->chunk_name == png_IDAT)
   {
      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
      size_t row_factor =
         (size_t)png_ptr->width
         * (size_t)png_ptr->channels
         * (png_ptr->bit_depth > 8? 2: 1)
         + 1
         + (png_ptr->interlaced? 6: 0);
      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
         idat_limit = PNG_UINT_31_MAX;
      else
         idat_limit = png_ptr->height * row_factor;
      row_factor = row_factor > 32566? 32566 : row_factor;
      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */
      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
      limit = limit < idat_limit? idat_limit : limit;
   }

   if (length > limit)
   {
      png_debug2(0,"" length = %lu, limit = %lu"",
         (unsigned long)length,(unsigned long)limit);
      png_chunk_error(png_ptr, ""chunk data is too large"");
   }
}","void /* COMMENT_0 */
png_check_chunk_length(png_const_structrp VAR_0, const png_uint_32 VAR_1)
{
   png_alloc_size_t VAR_2 = VAR_3;

# ifdef VAR_4
   if (VAR_0->user_chunk_malloc_max > 0 &&
       VAR_0->user_chunk_malloc_max < VAR_2)
      VAR_2 = VAR_0->user_chunk_malloc_max;
# elif VAR_5 > 0
   if (VAR_5 < VAR_2)
      VAR_2 = VAR_5;
# endif
   if (VAR_0->chunk_name == VAR_6)
   {
      png_alloc_size_t VAR_7 = VAR_3;
      size_t VAR_8 =
         (size_t)VAR_0->width
         * (size_t)VAR_0->channels
         * (VAR_0->bit_depth > 8? 2: 1)
         + 1
         + (VAR_0->interlaced? 6: 0);
      if (VAR_0->height > VAR_9/VAR_8)
         VAR_7 = VAR_3;
      else
         VAR_7 = VAR_0->height * VAR_8;
      VAR_8 = VAR_8 > 32566? 32566 : VAR_8;
      VAR_7 += 6 + 5*(VAR_7/VAR_8+1); /* COMMENT_1 */
      VAR_7=VAR_7 < VAR_3? VAR_7 : VAR_3;
      VAR_2 = VAR_2 < VAR_7? VAR_7 : VAR_2;
   }

   if (VAR_1 > VAR_2)
   {
      png_debug2(0,"" length = %lu, limit = %lu"",
         (unsigned long)VAR_1,(unsigned long)VAR_2);
      png_chunk_error(VAR_0, ""chunk data is too large"");
   }
}",pnggroup/libpng/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2/pngrutil.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,10 +15,13 @@
    {
       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
       size_t row_factor =
-         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
-          + 1 + (png_ptr->interlaced? 6: 0));
+         (size_t)png_ptr->width
+         * (size_t)png_ptr->channels
+         * (png_ptr->bit_depth > 8? 2: 1)
+         + 1
+         + (png_ptr->interlaced? 6: 0);
       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
-         idat_limit=PNG_UINT_31_MAX;
+         idat_limit = PNG_UINT_31_MAX;
       else
          idat_limit = png_ptr->height * row_factor;
       row_factor = row_factor > 32566? 32566 : row_factor;","{'deleted_lines': ['         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)', '          + 1 + (png_ptr->interlaced? 6: 0));', '         idat_limit=PNG_UINT_31_MAX;'], 'added_lines': ['         (size_t)png_ptr->width', '         * (size_t)png_ptr->channels', '         * (png_ptr->bit_depth > 8? 2: 1)', '         + 1', '         + (png_ptr->interlaced? 6: 0);', '         idat_limit = PNG_UINT_31_MAX;']}",True,"In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service.",6.5,MEDIUM,1,valid,2018-06-18T02:56:29Z,2
CVE-2018-12600,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1178,921f208c2ea3cc45847f380257f270ff424adfff,https://github.com/ImageMagick/ImageMagick/commit/921f208c2ea3cc45847f380257f270ff424adfff,coders/dib.c,ReadDIBImage,"static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
DIBInfo
dib_info;
Image
*image;
MagickBooleanType
status;
MemoryInfo
*pixel_info;
Quantum
index;
register ssize_t
x;
register Quantum
*q;
register ssize_t
i;
register unsigned char
*p;
size_t
bytes_per_line,
length;
ssize_t
bit,
count,
y;
unsigned char
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) memset(&dib_info,0,sizeof(dib_info));
dib_info.size=ReadBlobLSBLong(image);
if (dib_info.size != 40)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
dib_info.width=ReadBlobLSBSignedLong(image);
dib_info.height=ReadBlobLSBSignedLong(image);
dib_info.planes=ReadBlobLSBShort(image);
dib_info.bits_per_pixel=ReadBlobLSBShort(image);
if (dib_info.bits_per_pixel > 32)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
dib_info.compression=ReadBlobLSBLong(image);
dib_info.image_size=ReadBlobLSBLong(image);
dib_info.x_pixels=ReadBlobLSBLong(image);
dib_info.y_pixels=ReadBlobLSBLong(image);
dib_info.number_colors=ReadBlobLSBLong(image);
dib_info.colors_important=ReadBlobLSBLong(image);
if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&
(dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&
(dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((dib_info.compression == BI_BITFIELDS) &&
((dib_info.bits_per_pixel == 16) || (dib_info.bits_per_pixel == 32)))
{
dib_info.red_mask=(unsigned short) ReadBlobLSBLong(image);
dib_info.green_mask=(unsigned short) ReadBlobLSBLong(image);
dib_info.blue_mask=(unsigned short) ReadBlobLSBLong(image);
}
if (EOFBlob(image) != MagickFalse)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
if (dib_info.width <= 0)
ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
if (dib_info.height == 0)
ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
if (dib_info.planes != 1)
ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");
if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&
(dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&
(dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))
ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
if ((dib_info.bits_per_pixel < 16) &&
(dib_info.number_colors > (unsigned int) (1UL << dib_info.bits_per_pixel)))
ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");
if ((dib_info.compression == 1) && (dib_info.bits_per_pixel != 8))
ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
if ((dib_info.compression == 2) && (dib_info.bits_per_pixel != 4))
ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
if ((dib_info.compression == 3) && (dib_info.bits_per_pixel < 16))
ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
switch (dib_info.compression)
{
case BI_RGB:
case BI_RLE8:
case BI_RLE4:
case BI_BITFIELDS:
break;
case BI_JPEG:
ThrowReaderException(CoderError,""JPEGCompressNotSupported"");
case BI_PNG:
ThrowReaderException(CoderError,""PNGCompressNotSupported"");
default:
ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
}
image->columns=(size_t) MagickAbsoluteValue((ssize_t) dib_info.width);
image->rows=(size_t) MagickAbsoluteValue((ssize_t) dib_info.height);
image->depth=8;
image->alpha_trait=dib_info.bits_per_pixel == 32 ? BlendPixelTrait :
UndefinedPixelTrait;
if ((dib_info.number_colors > 256) || (dib_info.colors_important > 256))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((dib_info.number_colors != 0) || (dib_info.bits_per_pixel < 16))
{
size_t
one;
image->storage_class=PseudoClass;
image->colors=dib_info.number_colors;
one=1;
if (image->colors == 0)
image->colors=one << dib_info.bits_per_pixel;
}
if (image_info->size)
{
RectangleInfo
geometry;
MagickStatusType
flags;
flags=ParseAbsoluteGeometry(image_info->size,&geometry);
if (flags & WidthValue)
if ((geometry.width != 0) && (geometry.width < image->columns))
image->columns=geometry.width;
if (flags & HeightValue)
if ((geometry.height != 0) && (geometry.height < image->rows))
image->rows=geometry.height;
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if (image->storage_class == PseudoClass)
{
size_t
packet_size;
unsigned char
*dib_colormap;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
length=(size_t) image->colors;
dib_colormap=(unsigned char *) AcquireQuantumMemory(length,
4*sizeof(*dib_colormap));
if (dib_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
packet_size=4;
count=ReadBlob(image,packet_size*image->colors,dib_colormap);
if (count != (ssize_t) (packet_size*image->colors))
{
dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
}
p=dib_colormap;
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);
image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);
image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);
if (packet_size == 4)
p++;
}
dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
}
if (dib_info.compression == BI_RLE4)
dib_info.bits_per_pixel<<=1;
bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);
length=bytes_per_line*image->rows;
pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(
bytes_per_line,image->columns+256UL)*sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
if ((dib_info.compression == BI_RGB) ||
(dib_info.compression == BI_BITFIELDS))
{
count=ReadBlob(image,length,pixels);
if (count != (ssize_t) (length))
{
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
}
}
else
{
status=DecodeImage(image,dib_info.compression ? MagickTrue : MagickFalse,
pixels,image->columns*image->rows);
if (status == MagickFalse)
{
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,
""UnableToRunlengthDecodeImage"");
}
}
image->units=PixelsPerCentimeterResolution;
image->resolution.x=(double) dib_info.x_pixels/100.0;
image->resolution.y=(double) dib_info.y_pixels/100.0;
switch (dib_info.bits_per_pixel)
{
case 1:
{
for (y=(ssize_t) image->rows-1; y >= 0; y--)
{
p=pixels+(image->rows-y-1)*bytes_per_line;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=0; bit < 8; bit++)
{
index=(Quantum) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
{
index=(Quantum) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
}
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
image->rows-y-1,image->rows);
if (status == MagickFalse)
break;
}
}
(void) SyncImage(image,exception);
break;
}
case 4:
{
for (y=(ssize_t) image->rows-1; y >= 0; y--)
{
p=pixels+(image->rows-y-1)*bytes_per_line;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-1); x+=2)
{
index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (*p >> 4) &
0xf,exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
index=(Quantum) ConstrainColormapIndex(image,(ssize_t) *p & 0xf,
exception);
SetPixelIndex(image,index,q);
p++;
q+=GetPixelChannels(image);
}
if ((image->columns % 2) != 0)
{
index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (*p >> 4) &
0xf,exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
image->rows-y-1,image->rows);
if (status == MagickFalse)
break;
}
}
(void) SyncImage(image,exception);
break;
}
case 8:
{
if ((dib_info.compression == BI_RLE8) ||
(dib_info.compression == BI_RLE4))
bytes_per_line=image->columns;
for (y=(ssize_t) image->rows-1; y >= 0; y--)
{
p=pixels+(image->rows-y-1)*bytes_per_line;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
index=(Quantum) ConstrainColormapIndex(image,(ssize_t) *p,exception);
SetPixelIndex(image,index,q);
p++;
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
image->rows-y-1,image->rows);
if (status == MagickFalse)
break;
}
}
(void) SyncImage(image,exception);
break;
}
case 16:
{
unsigned short
word;
image->storage_class=DirectClass;
if (dib_info.compression == BI_RLE8)
bytes_per_line=2*image->columns;
for (y=(ssize_t) image->rows-1; y >= 0; y--)
{
p=pixels+(image->rows-y-1)*bytes_per_line;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
word=(*p++);
word|=(*p++ << 8);
if (dib_info.red_mask == 0)
{
SetPixelRed(image,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((word >> 10) & 0x1f))),q);
SetPixelGreen(image,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((word >> 5) & 0x1f))),q);
SetPixelBlue(image,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) (word & 0x1f))),q);
}
else
{
SetPixelRed(image,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((word >> 11) & 0x1f))),q);
SetPixelGreen(image,ScaleCharToQuantum(ScaleColor6to8(
(unsigned char) ((word >> 5) & 0x3f))),q);
SetPixelBlue(image,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) (word & 0x1f))),q);
}
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
image->rows-y-1,image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 24:
case 32:
{
for (y=(ssize_t) image->rows-1; y >= 0; y--)
{
p=pixels+(image->rows-y-1)*bytes_per_line;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
image->rows-y-1,image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
default:
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
pixel_info=RelinquishVirtualMemory(pixel_info);
if (strcmp(image_info->magick,""ICODIB"") == 0)
{
int
c;
image->storage_class=DirectClass;
image->alpha_trait=BlendPixelTrait;
for (y=0; y < (ssize_t) image->rows; y++)
{
register ssize_t
x;
register Quantum
*magick_restrict q;
q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
c=ReadBlobByte(image);
for (bit=0; bit < 8; bit++)
SetPixelAlpha(image,c & (0x80 >> bit) ? TransparentAlpha :
OpaqueAlpha,q+x*GetPixelChannels(image)+bit);
}
if ((image->columns % 8) != 0)
{
c=ReadBlobByte(image);
for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
SetPixelAlpha(image,c & (0x80 >> bit) ? TransparentAlpha :
OpaqueAlpha,q+x*GetPixelChannels(image)+bit);
}
if (image->columns % 32)
for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)
c=ReadBlobByte(image);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
}
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
if (dib_info.height < 0)
{
Image
*flipped_image;
flipped_image=FlipImage(image,exception);
if (flipped_image != (Image *) NULL)
{
DuplicateBlob(flipped_image,image);
image=DestroyImage(image);
image=flipped_image;
}
}
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadDIBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
DIBInfo
VAR_2;
Image
*VAR_3;
MagickBooleanType
VAR_4;
MemoryInfo
*VAR_5;
Quantum
VAR_6;
register ssize_t
VAR_7;
register Quantum
*VAR_8;
register ssize_t
VAR_9;
register unsigned char
*VAR_10;
size_t
VAR_11,
VAR_12;
ssize_t
VAR_13,
VAR_14,
VAR_15;
unsigned char
*VAR_16;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
VAR_3=AcquireImage(VAR_0,VAR_1);
VAR_4=OpenBlob(VAR_0,VAR_3,VAR_20,VAR_1);
if (VAR_4 == VAR_18)
{
VAR_3=DestroyImageList(VAR_3);
return((Image *) NULL);
}
(void) memset(&VAR_2,0,sizeof(VAR_2));
VAR_2.size=ReadBlobLSBLong(VAR_3);
if (VAR_2.size != 40)
ThrowReaderException(VAR_21,""ImproperImageHeader"");
VAR_2.width=ReadBlobLSBSignedLong(VAR_3);
VAR_2.height=ReadBlobLSBSignedLong(VAR_3);
VAR_2.planes=ReadBlobLSBShort(VAR_3);
VAR_2.bits_per_pixel=ReadBlobLSBShort(VAR_3);
if (VAR_2.bits_per_pixel > 32)
ThrowReaderException(VAR_21,""ImproperImageHeader"");
VAR_2.compression=ReadBlobLSBLong(VAR_3);
VAR_2.image_size=ReadBlobLSBLong(VAR_3);
VAR_2.x_pixels=ReadBlobLSBLong(VAR_3);
VAR_2.y_pixels=ReadBlobLSBLong(VAR_3);
VAR_2.number_colors=ReadBlobLSBLong(VAR_3);
VAR_2.colors_important=ReadBlobLSBLong(VAR_3);
if ((VAR_2.bits_per_pixel != 1) && (VAR_2.bits_per_pixel != 4) &&
(VAR_2.bits_per_pixel != 8) && (VAR_2.bits_per_pixel != 16) &&
(VAR_2.bits_per_pixel != 24) && (VAR_2.bits_per_pixel != 32))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
if ((VAR_2.compression == VAR_22) &&
((VAR_2.bits_per_pixel == 16) || (VAR_2.bits_per_pixel == 32)))
{
VAR_2.red_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
VAR_2.green_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
VAR_2.blue_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
}
if (EOFBlob(VAR_3) != VAR_18)
ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
if (VAR_2.width <= 0)
ThrowReaderException(VAR_21,""NegativeOrZeroImageSize"");
if (VAR_2.height == 0)
ThrowReaderException(VAR_21,""NegativeOrZeroImageSize"");
if (VAR_2.planes != 1)
ThrowReaderException(VAR_21,""StaticPlanesValueNotEqualToOne"");
if ((VAR_2.bits_per_pixel != 1) && (VAR_2.bits_per_pixel != 4) &&
(VAR_2.bits_per_pixel != 8) && (VAR_2.bits_per_pixel != 16) &&
(VAR_2.bits_per_pixel != 24) && (VAR_2.bits_per_pixel != 32))
ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
if ((VAR_2.bits_per_pixel < 16) &&
(VAR_2.number_colors > (unsigned int) (1UL << VAR_2.bits_per_pixel)))
ThrowReaderException(VAR_21,""UnrecognizedNumberOfColors"");
if ((VAR_2.compression == 1) && (VAR_2.bits_per_pixel != 8))
ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
if ((VAR_2.compression == 2) && (VAR_2.bits_per_pixel != 4))
ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
if ((VAR_2.compression == 3) && (VAR_2.bits_per_pixel < 16))
ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
switch (VAR_2.compression)
{
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_22:
break;
case VAR_26:
ThrowReaderException(VAR_27,""JPEGCompressNotSupported"");
case VAR_28:
ThrowReaderException(VAR_27,""PNGCompressNotSupported"");
default:
ThrowReaderException(VAR_21,""UnrecognizedImageCompression"");
}
VAR_3->columns=(size_t) MagickAbsoluteValue((ssize_t) VAR_2.width);
VAR_3->rows=(size_t) MagickAbsoluteValue((ssize_t) VAR_2.height);
VAR_3->depth=8;
VAR_3->alpha_trait=VAR_2.bits_per_pixel == 32 ? VAR_29 :
VAR_30;
if ((VAR_2.number_colors > 256) || (VAR_2.colors_important > 256))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
if ((VAR_2.number_colors != 0) || (VAR_2.bits_per_pixel < 16))
{
size_t
VAR_31;
VAR_3->storage_class=VAR_32;
VAR_3->colors=VAR_2.number_colors;
VAR_31=1;
if (VAR_3->colors == 0)
VAR_3->colors=VAR_31 << VAR_2.bits_per_pixel;
}
if (VAR_0->size)
{
RectangleInfo
VAR_33;
MagickStatusType
VAR_34;
VAR_34=ParseAbsoluteGeometry(VAR_0->size,&VAR_33);
if (VAR_34 & VAR_35)
if ((VAR_33.width != 0) && (VAR_33.width < VAR_3->columns))
VAR_3->columns=VAR_33.width;
if (VAR_34 & VAR_36)
if ((VAR_33.height != 0) && (VAR_33.height < VAR_3->rows))
VAR_3->rows=VAR_33.height;
}
VAR_4=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);
if (VAR_4 == VAR_18)
return(DestroyImageList(VAR_3));
if (VAR_3->storage_class == VAR_32)
{
size_t
VAR_37;
unsigned char
*VAR_38;
if (AcquireImageColormap(VAR_3,VAR_3->colors,VAR_1) == VAR_18)
ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
VAR_12=(size_t) VAR_3->colors;
VAR_38=(unsigned char *) AcquireQuantumMemory(VAR_12,
4*sizeof(*VAR_38));
if (VAR_38 == (unsigned char *) NULL)
ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
VAR_37=4;
VAR_14=ReadBlob(VAR_3,VAR_37*VAR_3->colors,VAR_38);
if (VAR_14 != (ssize_t) (VAR_37*VAR_3->colors))
{
VAR_38=(unsigned char *) RelinquishMagickMemory(VAR_38);
ThrowReaderException(VAR_21,""InsufficientImageDataInFile"");
}
VAR_10=VAR_38;
for (VAR_9=0; VAR_9 < (ssize_t) VAR_3->colors; VAR_9++)
{
VAR_3->colormap[VAR_9].blue=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
VAR_3->colormap[VAR_9].green=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
VAR_3->colormap[VAR_9].red=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
if (VAR_37 == 4)
VAR_10++;
}
VAR_38=(unsigned char *) RelinquishMagickMemory(VAR_38);
}
if (VAR_2.compression == VAR_25)
VAR_2.bits_per_pixel<<=1;
VAR_11=4*((VAR_3->columns*VAR_2.bits_per_pixel+31)/32);
VAR_12=VAR_11*VAR_3->rows;
VAR_5=AcquireVirtualMemory((size_t) VAR_3->rows,MagickMax(
VAR_11,VAR_3->columns+256UL)*sizeof(*VAR_16));
if (VAR_5 == (MemoryInfo *) NULL)
ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_5);
if ((VAR_2.compression == VAR_23) ||
(VAR_2.compression == VAR_22))
{
VAR_14=ReadBlob(VAR_3,VAR_12,VAR_16);
if (VAR_14 != (ssize_t) (VAR_12))
{
VAR_5=RelinquishVirtualMemory(VAR_5);
ThrowReaderException(VAR_21,""InsufficientImageDataInFile"");
}
}
else
{
VAR_4=DecodeImage(VAR_3,VAR_2.compression ? VAR_40 : VAR_18,
VAR_16,VAR_3->columns*VAR_3->rows);
if (VAR_4 == VAR_18)
{
VAR_5=RelinquishVirtualMemory(VAR_5);
ThrowReaderException(VAR_21,
""UnableToRunlengthDecodeImage"");
}
}
VAR_3->units=VAR_41;
VAR_3->resolution.x=(double) VAR_2.x_pixels/100.0;
VAR_3->resolution.y=(double) VAR_2.y_pixels/100.0;
switch (VAR_2.bits_per_pixel)
{
case 1:
{
for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
{
VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-7); VAR_7+=8)
{
for (VAR_13=0; VAR_13 < 8; VAR_13++)
{
VAR_6=(Quantum) ((*VAR_10) & (0x80 >> VAR_13) ? 0x01 : 0x00);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_8+=GetPixelChannels(VAR_3);
}
VAR_10++;
}
if ((VAR_3->columns % 8) != 0)
{
for (VAR_13=0; VAR_13 < (ssize_t) (VAR_3->columns % 8); VAR_13++)
{
VAR_6=(Quantum) ((*VAR_10) & (0x80 >> VAR_13) ? 0x01 : 0x00);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_8+=GetPixelChannels(VAR_3);
}
VAR_10++;
}
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
if (VAR_3->previous == (Image *) NULL)
{
VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
VAR_3->rows-VAR_15-1,VAR_3->rows);
if (VAR_4 == VAR_18)
break;
}
}
(void) SyncImage(VAR_3,VAR_1);
break;
}
case 4:
{
for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
{
VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-1); VAR_7+=2)
{
VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) (*VAR_10 >> 4) &
0xf,VAR_1);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_8+=GetPixelChannels(VAR_3);
VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) *VAR_10 & 0xf,
VAR_1);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_10++;
VAR_8+=GetPixelChannels(VAR_3);
}
if ((VAR_3->columns % 2) != 0)
{
VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) (*VAR_10 >> 4) &
0xf,VAR_1);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_8+=GetPixelChannels(VAR_3);
VAR_10++;
}
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
if (VAR_3->previous == (Image *) NULL)
{
VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
VAR_3->rows-VAR_15-1,VAR_3->rows);
if (VAR_4 == VAR_18)
break;
}
}
(void) SyncImage(VAR_3,VAR_1);
break;
}
case 8:
{
if ((VAR_2.compression == VAR_24) ||
(VAR_2.compression == VAR_25))
VAR_11=VAR_3->columns;
for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
{
VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
{
VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) *VAR_10,VAR_1);
SetPixelIndex(VAR_3,VAR_6,VAR_8);
VAR_10++;
VAR_8+=GetPixelChannels(VAR_3);
}
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
if (VAR_3->previous == (Image *) NULL)
{
VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
VAR_3->rows-VAR_15-1,VAR_3->rows);
if (VAR_4 == VAR_18)
break;
}
}
(void) SyncImage(VAR_3,VAR_1);
break;
}
case 16:
{
unsigned short
VAR_43;
VAR_3->storage_class=VAR_44;
if (VAR_2.compression == VAR_24)
VAR_11=2*VAR_3->columns;
for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
{
VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
{
VAR_43=(*VAR_10++);
VAR_43|=(*VAR_10++ << 8);
if (VAR_2.red_mask == 0)
{
SetPixelRed(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((VAR_43 >> 10) & 0x1f))),VAR_8);
SetPixelGreen(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((VAR_43 >> 5) & 0x1f))),VAR_8);
SetPixelBlue(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) (VAR_43 & 0x1f))),VAR_8);
}
else
{
SetPixelRed(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) ((VAR_43 >> 11) & 0x1f))),VAR_8);
SetPixelGreen(VAR_3,ScaleCharToQuantum(ScaleColor6to8(
(unsigned char) ((VAR_43 >> 5) & 0x3f))),VAR_8);
SetPixelBlue(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
(unsigned char) (VAR_43 & 0x1f))),VAR_8);
}
VAR_8+=GetPixelChannels(VAR_3);
}
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
if (VAR_3->previous == (Image *) NULL)
{
VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
VAR_3->rows-VAR_15-1,VAR_3->rows);
if (VAR_4 == VAR_18)
break;
}
}
break;
}
case 24:
case 32:
{
for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
{
VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
{
SetPixelBlue(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
SetPixelGreen(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
if (VAR_3->alpha_trait != VAR_30)
SetPixelAlpha(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
VAR_8+=GetPixelChannels(VAR_3);
}
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
if (VAR_3->previous == (Image *) NULL)
{
VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
VAR_3->rows-VAR_15-1,VAR_3->rows);
if (VAR_4 == VAR_18)
break;
}
}
break;
}
default:
VAR_5=RelinquishVirtualMemory(VAR_5);
ThrowReaderException(VAR_21,""ImproperImageHeader"");
}
VAR_5=RelinquishVirtualMemory(VAR_5);
if (strcmp(VAR_0->magick,""ICODIB"") == 0)
{
int
VAR_45;
VAR_3->storage_class=VAR_44;
VAR_3->alpha_trait=VAR_29;
for (VAR_15=0; VAR_15 < (ssize_t) VAR_3->rows; VAR_15++)
{
register ssize_t
VAR_7;
register Quantum
*magick_restrict VAR_8;
VAR_8=GetAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
if (VAR_8 == (Quantum *) NULL)
break;
for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-7); VAR_7+=8)
{
VAR_45=ReadBlobByte(VAR_3);
for (VAR_13=0; VAR_13 < 8; VAR_13++)
SetPixelAlpha(VAR_3,VAR_45 & (0x80 >> VAR_13) ? VAR_46 :
VAR_47,VAR_8+VAR_7*GetPixelChannels(VAR_3)+VAR_13);
}
if ((VAR_3->columns % 8) != 0)
{
VAR_45=ReadBlobByte(VAR_3);
for (VAR_13=0; VAR_13 < (ssize_t) (VAR_3->columns % 8); VAR_13++)
SetPixelAlpha(VAR_3,VAR_45 & (0x80 >> VAR_13) ? VAR_46 :
VAR_47,VAR_8+VAR_7*GetPixelChannels(VAR_3)+VAR_13);
}
if (VAR_3->columns % 32)
for (VAR_7=0; VAR_7 < (ssize_t) ((32-(VAR_3->columns % 32))/8); VAR_7++)
VAR_45=ReadBlobByte(VAR_3);
if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
break;
}
}
if (EOFBlob(VAR_3) != VAR_18)
ThrowFileException(VAR_1,VAR_21,""UnexpectedEndOfFile"",
VAR_3->filename);
if (VAR_2.height < 0)
{
Image
*VAR_48;
VAR_48=FlipImage(VAR_3,VAR_1);
if (VAR_48 != (Image *) NULL)
{
DuplicateBlob(VAR_48,VAR_3);
VAR_3=DestroyImage(VAR_3);
VAR_3=VAR_48;
}
}
(void) CloseBlob(VAR_3);
return(GetFirstImageInList(VAR_3));
}",ImageMagick/921f208c2ea3cc45847f380257f270ff424adfff/dib.c/vul/before/0.json,"static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  DIBInfo
    dib_info;

  Image
    *image;

  MagickBooleanType
    status;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    length;

  ssize_t
    bit,
    count,
    y;


  unsigned char
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a DIB file.
  */
  (void) memset(&dib_info,0,sizeof(dib_info));
  dib_info.size=ReadBlobLSBLong(image);
  if (dib_info.size != 40)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  /*
    Microsoft Windows 3.X DIB image file.
  */
  dib_info.width=ReadBlobLSBSignedLong(image);
  dib_info.height=ReadBlobLSBSignedLong(image);
  dib_info.planes=ReadBlobLSBShort(image);
  dib_info.bits_per_pixel=ReadBlobLSBShort(image);
  if (dib_info.bits_per_pixel > 32)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  dib_info.compression=ReadBlobLSBLong(image);
  dib_info.image_size=ReadBlobLSBLong(image);
  dib_info.x_pixels=ReadBlobLSBLong(image);
  dib_info.y_pixels=ReadBlobLSBLong(image);
  dib_info.number_colors=ReadBlobLSBLong(image);
  dib_info.colors_important=ReadBlobLSBLong(image);
  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&
      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&
      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if ((dib_info.compression == BI_BITFIELDS) &&
      ((dib_info.bits_per_pixel == 16) || (dib_info.bits_per_pixel == 32)))
    {
      dib_info.red_mask=(unsigned short) ReadBlobLSBLong(image);
      dib_info.green_mask=(unsigned short) ReadBlobLSBLong(image);
      dib_info.blue_mask=(unsigned short) ReadBlobLSBLong(image);
    }
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
  if (dib_info.width <= 0)
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  if (dib_info.height == 0)
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  if (dib_info.planes != 1)
    ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");
  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&
      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&
      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))
    ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
  if ((dib_info.bits_per_pixel < 16) &&
      (dib_info.number_colors > (unsigned int) (1UL << dib_info.bits_per_pixel)))
    ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");
  if ((dib_info.compression == 1) && (dib_info.bits_per_pixel != 8))
    ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
  if ((dib_info.compression == 2) && (dib_info.bits_per_pixel != 4))
    ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
  if ((dib_info.compression == 3) && (dib_info.bits_per_pixel < 16))
    ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
  switch (dib_info.compression)
  {
    case BI_RGB:
    case BI_RLE8:
    case BI_RLE4:
    case BI_BITFIELDS:
      break;
    case BI_JPEG:
      ThrowReaderException(CoderError,""JPEGCompressNotSupported"");
    case BI_PNG:
      ThrowReaderException(CoderError,""PNGCompressNotSupported"");
    default:
      ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
  }
  image->columns=(size_t) MagickAbsoluteValue((ssize_t) dib_info.width);
  image->rows=(size_t) MagickAbsoluteValue((ssize_t) dib_info.height);
  image->depth=8;
  image->alpha_trait=dib_info.bits_per_pixel == 32 ? BlendPixelTrait :
    UndefinedPixelTrait;
  if ((dib_info.number_colors > 256) || (dib_info.colors_important > 256))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if ((dib_info.number_colors != 0) || (dib_info.bits_per_pixel < 16))
    {
      size_t
        one;

      image->storage_class=PseudoClass;
      image->colors=dib_info.number_colors;
      one=1;
      if (image->colors == 0)
        image->colors=one << dib_info.bits_per_pixel;
    }
  if (image_info->size)
    {
      RectangleInfo
        geometry;

      MagickStatusType
        flags;

      flags=ParseAbsoluteGeometry(image_info->size,&geometry);
      if (flags & WidthValue)
        if ((geometry.width != 0) && (geometry.width < image->columns))
          image->columns=geometry.width;
      if (flags & HeightValue)
        if ((geometry.height != 0) && (geometry.height < image->rows))
          image->rows=geometry.height;
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  if (image->storage_class == PseudoClass)
    {
      size_t
        packet_size;

      unsigned char
        *dib_colormap;

      /*
        Read DIB raster colormap.
      */
      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      length=(size_t) image->colors;
      dib_colormap=(unsigned char *) AcquireQuantumMemory(length,
        4*sizeof(*dib_colormap));
      if (dib_colormap == (unsigned char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      packet_size=4;
      count=ReadBlob(image,packet_size*image->colors,dib_colormap);
      if (count != (ssize_t) (packet_size*image->colors))
        {
          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
      p=dib_colormap;
      for (i=0; i < (ssize_t) image->colors; i++)
      {
        image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);
        image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);
        image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);
        if (packet_size == 4)
          p++;
      }
      dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
    }
  /*
    Read image data.
  */
  if (dib_info.compression == BI_RLE4)
    dib_info.bits_per_pixel<<=1;
  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);
  length=bytes_per_line*image->rows;
  pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,
    image->columns+256UL)*sizeof(*pixels));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  if ((dib_info.compression == BI_RGB) ||
      (dib_info.compression == BI_BITFIELDS))
    {
      count=ReadBlob(image,length,pixels);
      if (count != (ssize_t) (length))
        {
          pixel_info=RelinquishVirtualMemory(pixel_info);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  else
    {
      /*
        Convert run-length encoded raster pixels.
      */
      status=DecodeImage(image,dib_info.compression ? MagickTrue : MagickFalse,
        pixels,image->columns*image->rows);
      if (status == MagickFalse)
        {
          pixel_info=RelinquishVirtualMemory(pixel_info);
          ThrowReaderException(CorruptImageError,
            ""UnableToRunlengthDecodeImage"");
        }
    }
  /*
    Initialize image structure.
  */
  image->units=PixelsPerCentimeterResolution;
  image->resolution.x=(double) dib_info.x_pixels/100.0;
  image->resolution.y=(double) dib_info.y_pixels/100.0;
  /*
    Convert DIB raster image to pixel packets.
  */
  switch (dib_info.bits_per_pixel)
  {
    case 1:
    {
      /*
        Convert bitmap scanline.
      */
      for (y=(ssize_t) image->rows-1; y >= 0; y--)
      {
        p=pixels+(image->rows-y-1)*bytes_per_line;
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=0; bit < 8; bit++)
          {
            index=(Quantum) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
            {
              index=(Quantum) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              image->rows-y-1,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
      (void) SyncImage(image,exception);
      break;
    }
    case 4:
    {
      /*
        Convert PseudoColor scanline.
      */
      for (y=(ssize_t) image->rows-1; y >= 0; y--)
      {
        p=pixels+(image->rows-y-1)*bytes_per_line;
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
        {
          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (*p >> 4) &
            0xf,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) *p & 0xf,
            exception);
          SetPixelIndex(image,index,q);
          p++;
          q+=GetPixelChannels(image);
        }
        if ((image->columns % 2) != 0)
          {
            index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (*p >> 4) &
              0xf,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            p++;
          }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              image->rows-y-1,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
      (void) SyncImage(image,exception);
      break;
    }
    case 8:
    {
      /*
        Convert PseudoColor scanline.
      */
      if ((dib_info.compression == BI_RLE8) ||
          (dib_info.compression == BI_RLE4))
        bytes_per_line=image->columns;
      for (y=(ssize_t) image->rows-1; y >= 0; y--)
      {
        p=pixels+(image->rows-y-1)*bytes_per_line;
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) *p,exception);
          SetPixelIndex(image,index,q);
          p++;
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              image->rows-y-1,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
      (void) SyncImage(image,exception);
      break;
    }
    case 16:
    {
      unsigned short
        word;

      /*
        Convert PseudoColor scanline.
      */
      image->storage_class=DirectClass;
      if (dib_info.compression == BI_RLE8)
        bytes_per_line=2*image->columns;
      for (y=(ssize_t) image->rows-1; y >= 0; y--)
      {
        p=pixels+(image->rows-y-1)*bytes_per_line;
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          word=(*p++);
          word|=(*p++ << 8);
          if (dib_info.red_mask == 0)
            {
              SetPixelRed(image,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((word >> 10) & 0x1f))),q);
              SetPixelGreen(image,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((word >> 5) & 0x1f))),q);
              SetPixelBlue(image,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) (word & 0x1f))),q);
            }
          else
            {
              SetPixelRed(image,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((word >> 11) & 0x1f))),q);
              SetPixelGreen(image,ScaleCharToQuantum(ScaleColor6to8(
                (unsigned char) ((word >> 5) & 0x3f))),q);
              SetPixelBlue(image,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) (word & 0x1f))),q);
            }
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              image->rows-y-1,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
      break;
    }
    case 24:
    case 32:
    {
      /*
        Convert DirectColor scanline.
      */
      for (y=(ssize_t) image->rows-1; y >= 0; y--)
      {
        p=pixels+(image->rows-y-1)*bytes_per_line;
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          if (image->alpha_trait != UndefinedPixelTrait)
            SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
              image->rows-y-1,image->rows);
            if (status == MagickFalse)
              break;
          }
      }
      break;
    }
    default:
      pixel_info=RelinquishVirtualMemory(pixel_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  if (strcmp(image_info->magick,""ICODIB"") == 0)
    {
      int
        c;

      /*
        Handle ICO mask.
      */
      image->storage_class=DirectClass;
      image->alpha_trait=BlendPixelTrait;
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        register ssize_t
          x;

        register Quantum
          *magick_restrict q;

        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          c=ReadBlobByte(image);
          for (bit=0; bit < 8; bit++)
            SetPixelAlpha(image,c & (0x80 >> bit) ? TransparentAlpha :
              OpaqueAlpha,q+x*GetPixelChannels(image)+bit);
        }
        if ((image->columns % 8) != 0)
          {
            c=ReadBlobByte(image);
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
              SetPixelAlpha(image,c & (0x80 >> bit) ? TransparentAlpha :
                OpaqueAlpha,q+x*GetPixelChannels(image)+bit);
          }
        if (image->columns % 32)
          for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)
            c=ReadBlobByte(image);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  if (dib_info.height < 0)
    {
      Image
        *flipped_image;

      /*
        Correct image orientation.
      */
      flipped_image=FlipImage(image,exception);
      if (flipped_image != (Image *) NULL)
        {
          DuplicateBlob(flipped_image,image);
          image=DestroyImage(image);
          image=flipped_image;
        }
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadDIBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  DIBInfo
    VAR_2;

  Image
    *VAR_3;

  MagickBooleanType
    VAR_4;

  MemoryInfo
    *VAR_5;

  Quantum
    VAR_6;

  register ssize_t
    VAR_7;

  register Quantum
    *VAR_8;

  register ssize_t
    VAR_9;

  register unsigned char
    *VAR_10;

  size_t
    VAR_11,
    VAR_12;

  ssize_t
    VAR_13,
    VAR_14,
    VAR_15;


  unsigned char
    *VAR_16;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  VAR_3=AcquireImage(VAR_0,VAR_1);
  VAR_4=OpenBlob(VAR_0,VAR_3,VAR_20,VAR_1);
  if (VAR_4 == VAR_18)
    {
      VAR_3=DestroyImageList(VAR_3);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                 
    
  (void) memset(&VAR_2,0,sizeof(VAR_2));
  VAR_2.size=ReadBlobLSBLong(VAR_3);
  if (VAR_2.size != 40)
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  /* COMMENT_6 */
                                         
    
  VAR_2.width=ReadBlobLSBSignedLong(VAR_3);
  VAR_2.height=ReadBlobLSBSignedLong(VAR_3);
  VAR_2.planes=ReadBlobLSBShort(VAR_3);
  VAR_2.bits_per_pixel=ReadBlobLSBShort(VAR_3);
  if (VAR_2.bits_per_pixel > 32)
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  VAR_2.compression=ReadBlobLSBLong(VAR_3);
  VAR_2.image_size=ReadBlobLSBLong(VAR_3);
  VAR_2.x_pixels=ReadBlobLSBLong(VAR_3);
  VAR_2.y_pixels=ReadBlobLSBLong(VAR_3);
  VAR_2.number_colors=ReadBlobLSBLong(VAR_3);
  VAR_2.colors_important=ReadBlobLSBLong(VAR_3);
  if ((VAR_2.bits_per_pixel != 1) && (VAR_2.bits_per_pixel != 4) &&
      (VAR_2.bits_per_pixel != 8) && (VAR_2.bits_per_pixel != 16) &&
      (VAR_2.bits_per_pixel != 24) && (VAR_2.bits_per_pixel != 32))
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  if ((VAR_2.compression == VAR_22) &&
      ((VAR_2.bits_per_pixel == 16) || (VAR_2.bits_per_pixel == 32)))
    {
      VAR_2.red_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
      VAR_2.green_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
      VAR_2.blue_mask=(unsigned short) ReadBlobLSBLong(VAR_3);
    }
  if (EOFBlob(VAR_3) != VAR_18)
    ThrowReaderException(VAR_21,""UnexpectedEndOfFile"");
  if (VAR_2.width <= 0)
    ThrowReaderException(VAR_21,""NegativeOrZeroImageSize"");
  if (VAR_2.height == 0)
    ThrowReaderException(VAR_21,""NegativeOrZeroImageSize"");
  if (VAR_2.planes != 1)
    ThrowReaderException(VAR_21,""StaticPlanesValueNotEqualToOne"");
  if ((VAR_2.bits_per_pixel != 1) && (VAR_2.bits_per_pixel != 4) &&
      (VAR_2.bits_per_pixel != 8) && (VAR_2.bits_per_pixel != 16) &&
      (VAR_2.bits_per_pixel != 24) && (VAR_2.bits_per_pixel != 32))
    ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
  if ((VAR_2.bits_per_pixel < 16) &&
      (VAR_2.number_colors > (unsigned int) (1UL << VAR_2.bits_per_pixel)))
    ThrowReaderException(VAR_21,""UnrecognizedNumberOfColors"");
  if ((VAR_2.compression == 1) && (VAR_2.bits_per_pixel != 8))
    ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
  if ((VAR_2.compression == 2) && (VAR_2.bits_per_pixel != 4))
    ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
  if ((VAR_2.compression == 3) && (VAR_2.bits_per_pixel < 16))
    ThrowReaderException(VAR_21,""UnrecognizedBitsPerPixel"");
  switch (VAR_2.compression)
  {
    case VAR_23:
    case VAR_24:
    case VAR_25:
    case VAR_22:
      break;
    case VAR_26:
      ThrowReaderException(VAR_27,""JPEGCompressNotSupported"");
    case VAR_28:
      ThrowReaderException(VAR_27,""PNGCompressNotSupported"");
    default:
      ThrowReaderException(VAR_21,""UnrecognizedImageCompression"");
  }
  VAR_3->columns=(size_t) MagickAbsoluteValue((ssize_t) VAR_2.width);
  VAR_3->rows=(size_t) MagickAbsoluteValue((ssize_t) VAR_2.height);
  VAR_3->depth=8;
  VAR_3->alpha_trait=VAR_2.bits_per_pixel == 32 ? VAR_29 :
    VAR_30;
  if ((VAR_2.number_colors > 256) || (VAR_2.colors_important > 256))
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  if ((VAR_2.number_colors != 0) || (VAR_2.bits_per_pixel < 16))
    {
      size_t
        VAR_31;

      VAR_3->storage_class=VAR_32;
      VAR_3->colors=VAR_2.number_colors;
      VAR_31=1;
      if (VAR_3->colors == 0)
        VAR_3->colors=VAR_31 << VAR_2.bits_per_pixel;
    }
  if (VAR_0->size)
    {
      RectangleInfo
        VAR_33;

      MagickStatusType
        VAR_34;

      VAR_34=ParseAbsoluteGeometry(VAR_0->size,&VAR_33);
      if (VAR_34 & VAR_35)
        if ((VAR_33.width != 0) && (VAR_33.width < VAR_3->columns))
          VAR_3->columns=VAR_33.width;
      if (VAR_34 & VAR_36)
        if ((VAR_33.height != 0) && (VAR_33.height < VAR_3->rows))
          VAR_3->rows=VAR_33.height;
    }
  VAR_4=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);
  if (VAR_4 == VAR_18)
    return(DestroyImageList(VAR_3));
  if (VAR_3->storage_class == VAR_32)
    {
      size_t
        VAR_37;

      unsigned char
        *VAR_38;

      /* COMMENT_9 */
                                 
        
      if (AcquireImageColormap(VAR_3,VAR_3->colors,VAR_1) == VAR_18)
        ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
      VAR_12=(size_t) VAR_3->colors;
      VAR_38=(unsigned char *) AcquireQuantumMemory(VAR_12,
        4*sizeof(*VAR_38));
      if (VAR_38 == (unsigned char *) NULL)
        ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
      VAR_37=4;
      VAR_14=ReadBlob(VAR_3,VAR_37*VAR_3->colors,VAR_38);
      if (VAR_14 != (ssize_t) (VAR_37*VAR_3->colors))
        {
          VAR_38=(unsigned char *) RelinquishMagickMemory(VAR_38);
          ThrowReaderException(VAR_21,""InsufficientImageDataInFile"");
        }
      VAR_10=VAR_38;
      for (VAR_9=0; VAR_9 < (ssize_t) VAR_3->colors; VAR_9++)
      {
        VAR_3->colormap[VAR_9].blue=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
        VAR_3->colormap[VAR_9].green=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
        VAR_3->colormap[VAR_9].red=(MagickRealType) ScaleCharToQuantum(*VAR_10++);
        if (VAR_37 == 4)
          VAR_10++;
      }
      VAR_38=(unsigned char *) RelinquishMagickMemory(VAR_38);
    }
  /* COMMENT_12 */
                    
    
  if (VAR_2.compression == VAR_25)
    VAR_2.bits_per_pixel<<=1;
  VAR_11=4*((VAR_3->columns*VAR_2.bits_per_pixel+31)/32);
  VAR_12=VAR_11*VAR_3->rows;
  VAR_5=AcquireVirtualMemory(VAR_3->rows,MagickMax(VAR_11,
    VAR_3->columns+256UL)*sizeof(*VAR_16));
  if (VAR_5 == (MemoryInfo *) NULL)
    ThrowReaderException(VAR_39,""MemoryAllocationFailed"");
  VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_5);
  if ((VAR_2.compression == VAR_23) ||
      (VAR_2.compression == VAR_22))
    {
      VAR_14=ReadBlob(VAR_3,VAR_12,VAR_16);
      if (VAR_14 != (ssize_t) (VAR_12))
        {
          VAR_5=RelinquishVirtualMemory(VAR_5);
          ThrowReaderException(VAR_21,""InsufficientImageDataInFile"");
        }
    }
  else
    {
      /* COMMENT_15 */
                                                 
        
      VAR_4=DecodeImage(VAR_3,VAR_2.compression ? VAR_40 : VAR_18,
        VAR_16,VAR_3->columns*VAR_3->rows);
      if (VAR_4 == VAR_18)
        {
          VAR_5=RelinquishVirtualMemory(VAR_5);
          ThrowReaderException(VAR_21,
            ""UnableToRunlengthDecodeImage"");
        }
    }
  /* COMMENT_18 */
                               
    
  VAR_3->units=VAR_41;
  VAR_3->resolution.x=(double) VAR_2.x_pixels/100.0;
  VAR_3->resolution.y=(double) VAR_2.y_pixels/100.0;
  /* COMMENT_21 */
                                              
    
  switch (VAR_2.bits_per_pixel)
  {
    case 1:
    {
      /* COMMENT_24 */
                                
        
      for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
      {
        VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
        VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-7); VAR_7+=8)
        {
          for (VAR_13=0; VAR_13 < 8; VAR_13++)
          {
            VAR_6=(Quantum) ((*VAR_10) & (0x80 >> VAR_13) ? 0x01 : 0x00);
            SetPixelIndex(VAR_3,VAR_6,VAR_8);
            VAR_8+=GetPixelChannels(VAR_3);
          }
          VAR_10++;
        }
        if ((VAR_3->columns % 8) != 0)
          {
            for (VAR_13=0; VAR_13 < (ssize_t) (VAR_3->columns % 8); VAR_13++)
            {
              VAR_6=(Quantum) ((*VAR_10) & (0x80 >> VAR_13) ? 0x01 : 0x00);
              SetPixelIndex(VAR_3,VAR_6,VAR_8);
              VAR_8+=GetPixelChannels(VAR_3);
            }
            VAR_10++;
          }
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
        if (VAR_3->previous == (Image *) NULL)
          {
            VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
              VAR_3->rows-VAR_15-1,VAR_3->rows);
            if (VAR_4 == VAR_18)
              break;
          }
      }
      (void) SyncImage(VAR_3,VAR_1);
      break;
    }
    case 4:
    {
      /* COMMENT_27 */
                                     
        
      for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
      {
        VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
        VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-1); VAR_7+=2)
        {
          VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) (*VAR_10 >> 4) &
            0xf,VAR_1);
          SetPixelIndex(VAR_3,VAR_6,VAR_8);
          VAR_8+=GetPixelChannels(VAR_3);
          VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) *VAR_10 & 0xf,
            VAR_1);
          SetPixelIndex(VAR_3,VAR_6,VAR_8);
          VAR_10++;
          VAR_8+=GetPixelChannels(VAR_3);
        }
        if ((VAR_3->columns % 2) != 0)
          {
            VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) (*VAR_10 >> 4) &
              0xf,VAR_1);
            SetPixelIndex(VAR_3,VAR_6,VAR_8);
            VAR_8+=GetPixelChannels(VAR_3);
            VAR_10++;
          }
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
        if (VAR_3->previous == (Image *) NULL)
          {
            VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
              VAR_3->rows-VAR_15-1,VAR_3->rows);
            if (VAR_4 == VAR_18)
              break;
          }
      }
      (void) SyncImage(VAR_3,VAR_1);
      break;
    }
    case 8:
    {
      /* COMMENT_30 */
                                     
        
      if ((VAR_2.compression == VAR_24) ||
          (VAR_2.compression == VAR_25))
        VAR_11=VAR_3->columns;
      for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
      {
        VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
        VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
        {
          VAR_6=(Quantum) ConstrainColormapIndex(VAR_3,(ssize_t) *VAR_10,VAR_1);
          SetPixelIndex(VAR_3,VAR_6,VAR_8);
          VAR_10++;
          VAR_8+=GetPixelChannels(VAR_3);
        }
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
        if (VAR_3->previous == (Image *) NULL)
          {
            VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
              VAR_3->rows-VAR_15-1,VAR_3->rows);
            if (VAR_4 == VAR_18)
              break;
          }
      }
      (void) SyncImage(VAR_3,VAR_1);
      break;
    }
    case 16:
    {
      unsigned short
        VAR_43;

      /* COMMENT_33 */
                                     
        
      VAR_3->storage_class=VAR_44;
      if (VAR_2.compression == VAR_24)
        VAR_11=2*VAR_3->columns;
      for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
      {
        VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
        VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
        {
          VAR_43=(*VAR_10++);
          VAR_43|=(*VAR_10++ << 8);
          if (VAR_2.red_mask == 0)
            {
              SetPixelRed(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((VAR_43 >> 10) & 0x1f))),VAR_8);
              SetPixelGreen(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((VAR_43 >> 5) & 0x1f))),VAR_8);
              SetPixelBlue(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) (VAR_43 & 0x1f))),VAR_8);
            }
          else
            {
              SetPixelRed(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) ((VAR_43 >> 11) & 0x1f))),VAR_8);
              SetPixelGreen(VAR_3,ScaleCharToQuantum(ScaleColor6to8(
                (unsigned char) ((VAR_43 >> 5) & 0x3f))),VAR_8);
              SetPixelBlue(VAR_3,ScaleCharToQuantum(ScaleColor5to8(
                (unsigned char) (VAR_43 & 0x1f))),VAR_8);
            }
          VAR_8+=GetPixelChannels(VAR_3);
        }
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
        if (VAR_3->previous == (Image *) NULL)
          {
            VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
              VAR_3->rows-VAR_15-1,VAR_3->rows);
            if (VAR_4 == VAR_18)
              break;
          }
      }
      break;
    }
    case 24:
    case 32:
    {
      /* COMMENT_36 */
                                     
        
      for (VAR_15=(ssize_t) VAR_3->rows-1; VAR_15 >= 0; VAR_15--)
      {
        VAR_10=VAR_16+(VAR_3->rows-VAR_15-1)*VAR_11;
        VAR_8=QueueAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_3->columns; VAR_7++)
        {
          SetPixelBlue(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
          SetPixelGreen(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
          SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
          if (VAR_3->alpha_trait != VAR_30)
            SetPixelAlpha(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_8);
          VAR_8+=GetPixelChannels(VAR_3);
        }
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
        if (VAR_3->previous == (Image *) NULL)
          {
            VAR_4=SetImageProgress(VAR_3,VAR_42,(MagickOffsetType)
              VAR_3->rows-VAR_15-1,VAR_3->rows);
            if (VAR_4 == VAR_18)
              break;
          }
      }
      break;
    }
    default:
      VAR_5=RelinquishVirtualMemory(VAR_5);
      ThrowReaderException(VAR_21,""ImproperImageHeader"");
  }
  VAR_5=RelinquishVirtualMemory(VAR_5);
  if (strcmp(VAR_0->magick,""ICODIB"") == 0)
    {
      int
        VAR_45;

      /* COMMENT_39 */
                        
        
      VAR_3->storage_class=VAR_44;
      VAR_3->alpha_trait=VAR_29;
      for (VAR_15=0; VAR_15 < (ssize_t) VAR_3->rows; VAR_15++)
      {
        register ssize_t
          VAR_7;

        register Quantum
          *magick_restrict VAR_8;

        VAR_8=GetAuthenticPixels(VAR_3,0,VAR_15,VAR_3->columns,1,VAR_1);
        if (VAR_8 == (Quantum *) NULL)
          break;
        for (VAR_7=0; VAR_7 < ((ssize_t) VAR_3->columns-7); VAR_7+=8)
        {
          VAR_45=ReadBlobByte(VAR_3);
          for (VAR_13=0; VAR_13 < 8; VAR_13++)
            SetPixelAlpha(VAR_3,VAR_45 & (0x80 >> VAR_13) ? VAR_46 :
              VAR_47,VAR_8+VAR_7*GetPixelChannels(VAR_3)+VAR_13);
        }
        if ((VAR_3->columns % 8) != 0)
          {
            VAR_45=ReadBlobByte(VAR_3);
            for (VAR_13=0; VAR_13 < (ssize_t) (VAR_3->columns % 8); VAR_13++)
              SetPixelAlpha(VAR_3,VAR_45 & (0x80 >> VAR_13) ? VAR_46 :
                VAR_47,VAR_8+VAR_7*GetPixelChannels(VAR_3)+VAR_13);
          }
        if (VAR_3->columns % 32)
          for (VAR_7=0; VAR_7 < (ssize_t) ((32-(VAR_3->columns % 32))/8); VAR_7++)
            VAR_45=ReadBlobByte(VAR_3);
        if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_18)
          break;
      }
    }
  if (EOFBlob(VAR_3) != VAR_18)
    ThrowFileException(VAR_1,VAR_21,""UnexpectedEndOfFile"",
      VAR_3->filename);
  if (VAR_2.height < 0)
    {
      Image
        *VAR_48;

      /* COMMENT_42 */
                                  
        
      VAR_48=FlipImage(VAR_3,VAR_1);
      if (VAR_48 != (Image *) NULL)
        {
          DuplicateBlob(VAR_48,VAR_3);
          VAR_3=DestroyImage(VAR_3);
          VAR_3=VAR_48;
        }
    }
  (void) CloseBlob(VAR_3);
  return(GetFirstImageInList(VAR_3));
}",ImageMagick/921f208c2ea3cc45847f380257f270ff424adfff/dib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -205,8 +205,8 @@
     dib_info.bits_per_pixel<<=1;
   bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);
   length=bytes_per_line*image->rows;
-  pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(
-    bytes_per_line,image->columns+256UL)*sizeof(*pixels));
+  pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,
+    image->columns+256UL)*sizeof(*pixels));
   if (pixel_info == (MemoryInfo *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);","{'deleted_lines': ['  pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(', '    bytes_per_line,image->columns+256UL)*sizeof(*pixels));'], 'added_lines': ['  pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,', '    image->columns+256UL)*sizeof(*pixels));']}",True,"In ImageMagick 7.0.8-3 Q16, ReadDIBImage and WriteDIBImage in coders/dib.c allow attackers to cause an out of bounds write via a crafted file.",8.8,HIGH,2,valid,2018-06-20T00:37:56Z,2
CVE-2018-12600,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1178,921f208c2ea3cc45847f380257f270ff424adfff,https://github.com/ImageMagick/ImageMagick/commit/921f208c2ea3cc45847f380257f270ff424adfff,coders/dib.c,WriteDIBImage,"static MagickBooleanType WriteDIBImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
DIBInfo
dib_info;
MagickBooleanType
status;
register const Quantum
*p;
register ssize_t
i,
x;
register unsigned char
*q;
size_t
bytes_per_line;
ssize_t
y;
unsigned char
*dib_data,
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) TransformImageColorspace(image,sRGBColorspace,exception);
if (image->storage_class == DirectClass)
{
dib_info.number_colors=0;
dib_info.bits_per_pixel=(unsigned short) (image->alpha_trait ? 32 : 24);
}
else
{
dib_info.bits_per_pixel=8;
if (image_info->depth > 8)
dib_info.bits_per_pixel=16;
if (SetImageMonochrome(image,exception) != MagickFalse)
dib_info.bits_per_pixel=1;
dib_info.number_colors=(unsigned int) (dib_info.bits_per_pixel == 16 ? 0 :
(1UL << dib_info.bits_per_pixel));
}
bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);
dib_info.size=40;
dib_info.width=(int) image->columns;
dib_info.height=(int) image->rows;
dib_info.planes=1;
dib_info.compression=(unsigned int) (dib_info.bits_per_pixel == 16 ?
BI_BITFIELDS : BI_RGB);
dib_info.image_size=(unsigned int) (bytes_per_line*image->rows);
dib_info.x_pixels=75*39;
dib_info.y_pixels=75*39;
switch (image->units)
{
case UndefinedResolution:
case PixelsPerInchResolution:
{
dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
break;
}
case PixelsPerCentimeterResolution:
{
dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
break;
}
}
dib_info.colors_important=dib_info.number_colors;
pixels=(unsigned char *) AcquireQuantumMemory(dib_info.image_size,
sizeof(*pixels));
if (pixels == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
(void) memset(pixels,0,dib_info.image_size);
switch (dib_info.bits_per_pixel)
{
case 1:
{
register unsigned char
bit,
byte;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
bit=0;
byte=0;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=1;
byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
bit++;
if (bit == 8)
{
*q++=byte;
bit=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (bit != 0)
{
*q++=(unsigned char) (byte << (8-bit));
x++;
}
for (x=(ssize_t) (image->columns+7)/8; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
break;
}
case 8:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=(unsigned char) GetPixelIndex(image,p);
p+=GetPixelChannels(image);
}
for ( ; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
break;
}
case 16:
{
unsigned short
word;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
word=(unsigned short) ((ScaleColor8to5((unsigned char)
ScaleQuantumToChar(GetPixelRed(image,p))) << 11) | (ScaleColor8to6(
(unsigned char) ScaleQuantumToChar(GetPixelGreen(image,p))) << 5) |
(ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)
GetPixelBlue(image,p)) << 0)));
*q++=(unsigned char)(word & 0xff);
*q++=(unsigned char)(word >> 8);
p+=GetPixelChannels(image);
}
for (x=(ssize_t) (2*image->columns); x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
break;
}
case 24:
case 32:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
if (image->alpha_trait != UndefinedPixelTrait)
*q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
p+=GetPixelChannels(image);
}
if (dib_info.bits_per_pixel == 24)
for (x=(ssize_t) (3*image->columns); x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
break;
}
}
if (dib_info.bits_per_pixel == 8)
if (image_info->compression != NoCompression)
{
size_t
length;
length=2UL*(bytes_per_line+2UL)+2UL;
dib_data=(unsigned char *) AcquireQuantumMemory(length,
(image->rows+2UL)*sizeof(*dib_data));
if (dib_data == (unsigned char *) NULL)
{
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
}
dib_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
pixels,dib_data);
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
pixels=dib_data;
dib_info.compression = BI_RLE8;
}
(void) WriteBlobLSBLong(image,dib_info.size);
(void) WriteBlobLSBLong(image,(unsigned int) dib_info.width);
(void) WriteBlobLSBLong(image,(unsigned int) dib_info.height);
(void) WriteBlobLSBShort(image,(unsigned short) dib_info.planes);
(void) WriteBlobLSBShort(image,dib_info.bits_per_pixel);
(void) WriteBlobLSBLong(image,dib_info.compression);
(void) WriteBlobLSBLong(image,dib_info.image_size);
(void) WriteBlobLSBLong(image,dib_info.x_pixels);
(void) WriteBlobLSBLong(image,dib_info.y_pixels);
(void) WriteBlobLSBLong(image,dib_info.number_colors);
(void) WriteBlobLSBLong(image,dib_info.colors_important);
if (image->storage_class == PseudoClass)
{
if (dib_info.bits_per_pixel <= 8)
{
unsigned char
*dib_colormap;
dib_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
(1UL << dib_info.bits_per_pixel),4*sizeof(*dib_colormap));
if (dib_colormap == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
q=dib_colormap;
for (i=0; i < (ssize_t) MagickMin(image->colors,dib_info.number_colors); i++)
{
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
*q++=(Quantum) 0x0;
}
for ( ; i < (ssize_t) (1L << dib_info.bits_per_pixel); i++)
{
*q++=(Quantum) 0x0;
*q++=(Quantum) 0x0;
*q++=(Quantum) 0x0;
*q++=(Quantum) 0x0;
}
(void) WriteBlob(image,(size_t) (4*(1 << dib_info.bits_per_pixel)),
dib_colormap);
dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
}
else
if ((dib_info.bits_per_pixel == 16) &&
(dib_info.compression == BI_BITFIELDS))
{
(void) WriteBlobLSBLong(image,0xf800);
(void) WriteBlobLSBLong(image,0x07e0);
(void) WriteBlobLSBLong(image,0x001f);
}
}
(void) WriteBlob(image,dib_info.image_size,pixels);
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteDIBImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
DIBInfo
VAR_3;
MagickBooleanType
VAR_4;
register const Quantum
*VAR_5;
register ssize_t
VAR_6,
VAR_7;
register unsigned char
*VAR_8;
size_t
VAR_9;
ssize_t
VAR_10;
unsigned char
*VAR_11,
*VAR_12;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_13);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_13);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_13);
VAR_4=OpenBlob(VAR_0,VAR_1,VAR_16,VAR_2);
if (VAR_4 == VAR_14)
return(VAR_4);
(void) TransformImageColorspace(VAR_1,VAR_17,VAR_2);
if (VAR_1->storage_class == VAR_18)
{
VAR_3.number_colors=0;
VAR_3.bits_per_pixel=(unsigned short) (VAR_1->alpha_trait ? 32 : 24);
}
else
{
VAR_3.bits_per_pixel=8;
if (VAR_0->depth > 8)
VAR_3.bits_per_pixel=16;
if (SetImageMonochrome(VAR_1,VAR_2) != VAR_14)
VAR_3.bits_per_pixel=1;
VAR_3.number_colors=(unsigned int) (VAR_3.bits_per_pixel == 16 ? 0 :
(1UL << VAR_3.bits_per_pixel));
}
VAR_9=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
VAR_3.size=40;
VAR_3.width=(int) VAR_1->columns;
VAR_3.height=(int) VAR_1->rows;
VAR_3.planes=1;
VAR_3.compression=(unsigned int) (VAR_3.bits_per_pixel == 16 ?
VAR_19 : VAR_20);
VAR_3.image_size=(unsigned int) (VAR_9*VAR_1->rows);
VAR_3.x_pixels=75*39;
VAR_3.y_pixels=75*39;
switch (VAR_1->units)
{
case VAR_21:
case VAR_22:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
break;
}
case VAR_23:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
break;
}
}
VAR_3.colors_important=VAR_3.number_colors;
VAR_12=(unsigned char *) AcquireQuantumMemory(VAR_3.image_size,
sizeof(*VAR_12));
if (VAR_12 == (unsigned char *) NULL)
ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
(void) memset(VAR_12,0,VAR_3.image_size);
switch (VAR_3.bits_per_pixel)
{
case 1:
{
register unsigned char
VAR_25,
VAR_26;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
{
VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
if (VAR_5 == (const Quantum *) NULL)
break;
VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
VAR_25=0;
VAR_26=0;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
{
VAR_26<<=1;
VAR_26|=GetPixelIndex(VAR_1,VAR_5) != 0 ? 0x01 : 0x00;
VAR_25++;
if (VAR_25 == 8)
{
*VAR_8++=VAR_26;
VAR_25=0;
VAR_26=0;
}
VAR_5+=GetPixelChannels(VAR_1);
}
if (VAR_25 != 0)
{
*VAR_8++=(unsigned char) (VAR_26 << (8-VAR_25));
VAR_7++;
}
for (VAR_7=(ssize_t) (VAR_1->columns+7)/8; VAR_7 < (ssize_t) VAR_9; VAR_7++)
*VAR_8++=0x00;
VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
VAR_1->rows);
if (VAR_4 == VAR_14)
break;
}
break;
}
case 8:
{
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
{
VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
if (VAR_5 == (const Quantum *) NULL)
break;
VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
{
*VAR_8++=(unsigned char) GetPixelIndex(VAR_1,VAR_5);
VAR_5+=GetPixelChannels(VAR_1);
}
for ( ; VAR_7 < (ssize_t) VAR_9; VAR_7++)
*VAR_8++=0x00;
VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
VAR_1->rows);
if (VAR_4 == VAR_14)
break;
}
break;
}
case 16:
{
unsigned short
VAR_28;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
{
VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
if (VAR_5 == (const Quantum *) NULL)
break;
VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
{
VAR_28=(unsigned short) ((ScaleColor8to5((unsigned char)
ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_5))) << 11) | (ScaleColor8to6(
(unsigned char) ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_5))) << 5) |
(ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)
GetPixelBlue(VAR_1,VAR_5)) << 0)));
*VAR_8++=(unsigned char)(VAR_28 & 0xff);
*VAR_8++=(unsigned char)(VAR_28 >> 8);
VAR_5+=GetPixelChannels(VAR_1);
}
for (VAR_7=(ssize_t) (2*VAR_1->columns); VAR_7 < (ssize_t) VAR_9; VAR_7++)
*VAR_8++=0x00;
VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
VAR_1->rows);
if (VAR_4 == VAR_14)
break;
}
break;
}
case 24:
case 32:
{
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
{
VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
if (VAR_5 == (const Quantum *) NULL)
break;
VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
{
*VAR_8++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_5));
*VAR_8++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_5));
*VAR_8++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_5));
if (VAR_1->alpha_trait != VAR_29)
*VAR_8++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_5));
VAR_5+=GetPixelChannels(VAR_1);
}
if (VAR_3.bits_per_pixel == 24)
for (VAR_7=(ssize_t) (3*VAR_1->columns); VAR_7 < (ssize_t) VAR_9; VAR_7++)
*VAR_8++=0x00;
VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
VAR_1->rows);
if (VAR_4 == VAR_14)
break;
}
break;
}
}
if (VAR_3.bits_per_pixel == 8)
if (VAR_0->compression != VAR_30)
{
size_t
VAR_31;
VAR_31=2UL*(VAR_9+2UL)+2UL;
VAR_11=(unsigned char *) AcquireQuantumMemory(VAR_31,
(VAR_1->rows+2UL)*sizeof(*VAR_11));
if (VAR_11 == (unsigned char *) NULL)
{
VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
}
VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_9,
VAR_12,VAR_11);
VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
VAR_12=VAR_11;
VAR_3.compression = VAR_32;
}
(void) WriteBlobLSBLong(VAR_1,VAR_3.size);
(void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_3.width);
(void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_3.height);
(void) WriteBlobLSBShort(VAR_1,(unsigned short) VAR_3.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
(void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
(void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
(void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
(void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
if (VAR_1->storage_class == VAR_33)
{
if (VAR_3.bits_per_pixel <= 8)
{
unsigned char
*VAR_34;
VAR_34=(unsigned char *) AcquireQuantumMemory((size_t)
(1UL << VAR_3.bits_per_pixel),4*sizeof(*VAR_34));
if (VAR_34 == (unsigned char *) NULL)
ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
VAR_8=VAR_34;
for (VAR_6=0; VAR_6 < (ssize_t) MagickMin(VAR_1->colors,VAR_3.number_colors); VAR_6++)
{
*VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].blue));
*VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].green));
*VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].red));
*VAR_8++=(Quantum) 0x0;
}
for ( ; VAR_6 < (ssize_t) (1L << VAR_3.bits_per_pixel); VAR_6++)
{
*VAR_8++=(Quantum) 0x0;
*VAR_8++=(Quantum) 0x0;
*VAR_8++=(Quantum) 0x0;
*VAR_8++=(Quantum) 0x0;
}
(void) WriteBlob(VAR_1,(size_t) (4*(1 << VAR_3.bits_per_pixel)),
VAR_34);
VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
}
else
if ((VAR_3.bits_per_pixel == 16) &&
(VAR_3.compression == VAR_19))
{
(void) WriteBlobLSBLong(VAR_1,0xf800);
(void) WriteBlobLSBLong(VAR_1,0x07e0);
(void) WriteBlobLSBLong(VAR_1,0x001f);
}
}
(void) WriteBlob(VAR_1,VAR_3.image_size,VAR_12);
VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
(void) CloseBlob(VAR_1);
return(VAR_35);
}",ImageMagick/921f208c2ea3cc45847f380257f270ff424adfff/dib.c/vul/before/1.json,"static MagickBooleanType WriteDIBImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  DIBInfo
    dib_info;

  MagickBooleanType
    status;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register unsigned char
    *q;

  size_t
    bytes_per_line;

  ssize_t
    y;

  unsigned char
    *dib_data,
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  /*
    Initialize DIB raster file header.
  */
  (void) TransformImageColorspace(image,sRGBColorspace,exception);
  if (image->storage_class == DirectClass)
    {
      /*
        Full color DIB raster.
      */
      dib_info.number_colors=0;
      dib_info.bits_per_pixel=(unsigned short) (image->alpha_trait ? 32 : 24);
    }
  else
    {
      /*
        Colormapped DIB raster.
      */
      dib_info.bits_per_pixel=8;
      if (image_info->depth > 8)
        dib_info.bits_per_pixel=16;
      if (SetImageMonochrome(image,exception) != MagickFalse)
        dib_info.bits_per_pixel=1;
      dib_info.number_colors=(unsigned int) (dib_info.bits_per_pixel == 16 ? 0 :
        (1UL << dib_info.bits_per_pixel));
    }
  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);
  dib_info.size=40;
  dib_info.width=(int) image->columns;
  dib_info.height=(int) image->rows;
  dib_info.planes=1;
  dib_info.compression=(unsigned int) (dib_info.bits_per_pixel == 16 ?
    BI_BITFIELDS : BI_RGB);
  dib_info.image_size=(unsigned int) (bytes_per_line*image->rows);
  dib_info.x_pixels=75*39;
  dib_info.y_pixels=75*39;
  switch (image->units)
  {
    case UndefinedResolution:
    case PixelsPerInchResolution:
    {
      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
      break;
    }
    case PixelsPerCentimeterResolution:
    {
      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
      break;
    }
  }
  dib_info.colors_important=dib_info.number_colors;
  /*
    Convert MIFF to DIB raster pixels.
  */
  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,MagickMax(
    bytes_per_line,image->columns+256UL)*sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  (void) memset(pixels,0,dib_info.image_size);
  switch (dib_info.bits_per_pixel)
  {
    case 1:
    {
      register unsigned char
        bit,
        byte;

      /*
        Convert PseudoClass image to a DIB monochrome image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        p=GetVirtualPixels(image,0,y,image->columns,1,exception);
        if (p == (const Quantum *) NULL)
          break;
        q=pixels+(image->rows-y-1)*bytes_per_line;
        bit=0;
        byte=0;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          byte<<=1;
          byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
          bit++;
          if (bit == 8)
            {
              *q++=byte;
              bit=0;
              byte=0;
            }
           p+=GetPixelChannels(image);
         }
         if (bit != 0)
           {
             *q++=(unsigned char) (byte << (8-bit));
             x++;
           }
        for (x=(ssize_t) (image->columns+7)/8; x < (ssize_t) bytes_per_line; x++)
          *q++=0x00;
        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      break;
    }
    case 8:
    {
      /*
        Convert PseudoClass packet to DIB pixel.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        p=GetVirtualPixels(image,0,y,image->columns,1,exception);
        if (p == (const Quantum *) NULL)
          break;
        q=pixels+(image->rows-y-1)*bytes_per_line;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          *q++=(unsigned char) GetPixelIndex(image,p);
          p+=GetPixelChannels(image);
        }
        for ( ; x < (ssize_t) bytes_per_line; x++)
          *q++=0x00;
        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      break;
    }
    case 16:
    {
      unsigned short
        word;
      /*
        Convert PseudoClass packet to DIB pixel.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        p=GetVirtualPixels(image,0,y,image->columns,1,exception);
        if (p == (const Quantum *) NULL)
          break;
        q=pixels+(image->rows-y-1)*bytes_per_line;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          word=(unsigned short) ((ScaleColor8to5((unsigned char)
            ScaleQuantumToChar(GetPixelRed(image,p))) << 11) | (ScaleColor8to6(
            (unsigned char) ScaleQuantumToChar(GetPixelGreen(image,p))) << 5) |
            (ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)
            GetPixelBlue(image,p)) << 0)));
          *q++=(unsigned char)(word & 0xff);
          *q++=(unsigned char)(word >> 8);
          p+=GetPixelChannels(image);
        }
        for (x=(ssize_t) (2*image->columns); x < (ssize_t) bytes_per_line; x++)
          *q++=0x00;
        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      break;
    }
    case 24:
    case 32:
    {
      /*
        Convert DirectClass packet to DIB RGB pixel.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        p=GetVirtualPixels(image,0,y,image->columns,1,exception);
        if (p == (const Quantum *) NULL)
          break;
        q=pixels+(image->rows-y-1)*bytes_per_line;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
          *q++=ScaleQuantumToChar(GetPixelRed(image,p));
          if (image->alpha_trait != UndefinedPixelTrait)
            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
          p+=GetPixelChannels(image);
        }
        if (dib_info.bits_per_pixel == 24)
          for (x=(ssize_t) (3*image->columns); x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      break;
    }
  }
  if (dib_info.bits_per_pixel == 8)
    if (image_info->compression != NoCompression)
      {
        size_t
          length;

        /*
          Convert run-length encoded raster pixels.
        */
        length=2UL*(bytes_per_line+2UL)+2UL;
        dib_data=(unsigned char *) AcquireQuantumMemory(length,
          (image->rows+2UL)*sizeof(*dib_data));
        if (dib_data == (unsigned char *) NULL)
          {
            pixels=(unsigned char *) RelinquishMagickMemory(pixels);
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        dib_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
          pixels,dib_data);
        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
        pixels=dib_data;
        dib_info.compression = BI_RLE8;
      }
  /*
    Write DIB header.
  */
  (void) WriteBlobLSBLong(image,dib_info.size);
  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.width);
  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.height);
  (void) WriteBlobLSBShort(image,(unsigned short) dib_info.planes);
  (void) WriteBlobLSBShort(image,dib_info.bits_per_pixel);
  (void) WriteBlobLSBLong(image,dib_info.compression);
  (void) WriteBlobLSBLong(image,dib_info.image_size);
  (void) WriteBlobLSBLong(image,dib_info.x_pixels);
  (void) WriteBlobLSBLong(image,dib_info.y_pixels);
  (void) WriteBlobLSBLong(image,dib_info.number_colors);
  (void) WriteBlobLSBLong(image,dib_info.colors_important);
  if (image->storage_class == PseudoClass)
    {
      if (dib_info.bits_per_pixel <= 8)
        {
          unsigned char
            *dib_colormap;

          /*
            Dump colormap to file.
          */
          dib_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
            (1UL << dib_info.bits_per_pixel),4*sizeof(*dib_colormap));
          if (dib_colormap == (unsigned char *) NULL)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
          q=dib_colormap;
          for (i=0; i < (ssize_t) MagickMin(image->colors,dib_info.number_colors); i++)
          {
            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
            *q++=(Quantum) 0x0;
          }
          for ( ; i < (ssize_t) (1L << dib_info.bits_per_pixel); i++)
          {
            *q++=(Quantum) 0x0;
            *q++=(Quantum) 0x0;
            *q++=(Quantum) 0x0;
            *q++=(Quantum) 0x0;
          }
          (void) WriteBlob(image,(size_t) (4*(1 << dib_info.bits_per_pixel)),
            dib_colormap);
          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);
        }
      else
        if ((dib_info.bits_per_pixel == 16) &&
            (dib_info.compression == BI_BITFIELDS))
          {
            (void) WriteBlobLSBLong(image,0xf800);
            (void) WriteBlobLSBLong(image,0x07e0);
            (void) WriteBlobLSBLong(image,0x001f);
          }
    }
  (void) WriteBlob(image,dib_info.image_size,pixels);
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteDIBImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  DIBInfo
    VAR_3;

  MagickBooleanType
    VAR_4;

  register const Quantum
    *VAR_5;

  register ssize_t
    VAR_6,
    VAR_7;

  register unsigned char
    *VAR_8;

  size_t
    VAR_9;

  ssize_t
    VAR_10;

  unsigned char
    *VAR_11,
    *VAR_12;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_13);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_13);
  if (VAR_1->debug != VAR_14)
    (void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_13);
  VAR_4=OpenBlob(VAR_0,VAR_1,VAR_16,VAR_2);
  if (VAR_4 == VAR_14)
    return(VAR_4);
  /* COMMENT_3 */
                                      
    
  (void) TransformImageColorspace(VAR_1,VAR_17,VAR_2);
  if (VAR_1->storage_class == VAR_18)
    {
      /* COMMENT_6 */
                              
        
      VAR_3.number_colors=0;
      VAR_3.bits_per_pixel=(unsigned short) (VAR_1->alpha_trait ? 32 : 24);
    }
  else
    {
      /* COMMENT_9 */
                               
        
      VAR_3.bits_per_pixel=8;
      if (VAR_0->depth > 8)
        VAR_3.bits_per_pixel=16;
      if (SetImageMonochrome(VAR_1,VAR_2) != VAR_14)
        VAR_3.bits_per_pixel=1;
      VAR_3.number_colors=(unsigned int) (VAR_3.bits_per_pixel == 16 ? 0 :
        (1UL << VAR_3.bits_per_pixel));
    }
  VAR_9=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
  VAR_3.size=40;
  VAR_3.width=(int) VAR_1->columns;
  VAR_3.height=(int) VAR_1->rows;
  VAR_3.planes=1;
  VAR_3.compression=(unsigned int) (VAR_3.bits_per_pixel == 16 ?
    VAR_19 : VAR_20);
  VAR_3.image_size=(unsigned int) (VAR_9*VAR_1->rows);
  VAR_3.x_pixels=75*39;
  VAR_3.y_pixels=75*39;
  switch (VAR_1->units)
  {
    case VAR_21:
    case VAR_22:
    {
      VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
      VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
      break;
    }
    case VAR_23:
    {
      VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
      VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
      break;
    }
  }
  VAR_3.colors_important=VAR_3.number_colors;
  /* COMMENT_12 */
                                      
    
  VAR_12=(unsigned char *) AcquireQuantumMemory(VAR_1->rows,MagickMax(
    VAR_9,VAR_1->columns+256UL)*sizeof(*VAR_12));
  if (VAR_12 == (unsigned char *) NULL)
    ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
  (void) memset(VAR_12,0,VAR_3.image_size);
  switch (VAR_3.bits_per_pixel)
  {
    case 1:
    {
      register unsigned char
        VAR_25,
        VAR_26;

      /* COMMENT_15 */
                                                            
        
      for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
      {
        VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
        if (VAR_5 == (const Quantum *) NULL)
          break;
        VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
        VAR_25=0;
        VAR_26=0;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
        {
          VAR_26<<=1;
          VAR_26|=GetPixelIndex(VAR_1,VAR_5) != 0 ? 0x01 : 0x00;
          VAR_25++;
          if (VAR_25 == 8)
            {
              *VAR_8++=VAR_26;
              VAR_25=0;
              VAR_26=0;
            }
           VAR_5+=GetPixelChannels(VAR_1);
         }
         if (VAR_25 != 0)
           {
             *VAR_8++=(unsigned char) (VAR_26 << (8-VAR_25));
             VAR_7++;
           }
        for (VAR_7=(ssize_t) (VAR_1->columns+7)/8; VAR_7 < (ssize_t) VAR_9; VAR_7++)
          *VAR_8++=0x00;
        VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
          VAR_1->rows);
        if (VAR_4 == VAR_14)
          break;
      }
      break;
    }
    case 8:
    {
      /* COMMENT_18 */
                                                
        
      for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
      {
        VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
        if (VAR_5 == (const Quantum *) NULL)
          break;
        VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
        {
          *VAR_8++=(unsigned char) GetPixelIndex(VAR_1,VAR_5);
          VAR_5+=GetPixelChannels(VAR_1);
        }
        for ( ; VAR_7 < (ssize_t) VAR_9; VAR_7++)
          *VAR_8++=0x00;
        VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
          VAR_1->rows);
        if (VAR_4 == VAR_14)
          break;
      }
      break;
    }
    case 16:
    {
      unsigned short
        VAR_28;
      /* COMMENT_21 */
                                                
        
      for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
      {
        VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
        if (VAR_5 == (const Quantum *) NULL)
          break;
        VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
        {
          VAR_28=(unsigned short) ((ScaleColor8to5((unsigned char)
            ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_5))) << 11) | (ScaleColor8to6(
            (unsigned char) ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_5))) << 5) |
            (ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)
            GetPixelBlue(VAR_1,VAR_5)) << 0)));
          *VAR_8++=(unsigned char)(VAR_28 & 0xff);
          *VAR_8++=(unsigned char)(VAR_28 >> 8);
          VAR_5+=GetPixelChannels(VAR_1);
        }
        for (VAR_7=(ssize_t) (2*VAR_1->columns); VAR_7 < (ssize_t) VAR_9; VAR_7++)
          *VAR_8++=0x00;
        VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
          VAR_1->rows);
        if (VAR_4 == VAR_14)
          break;
      }
      break;
    }
    case 24:
    case 32:
    {
      /* COMMENT_24 */
                                                    
        
      for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
      {
        VAR_5=GetVirtualPixels(VAR_1,0,VAR_10,VAR_1->columns,1,VAR_2);
        if (VAR_5 == (const Quantum *) NULL)
          break;
        VAR_8=VAR_12+(VAR_1->rows-VAR_10-1)*VAR_9;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->columns; VAR_7++)
        {
          *VAR_8++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_5));
          *VAR_8++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_5));
          *VAR_8++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_5));
          if (VAR_1->alpha_trait != VAR_29)
            *VAR_8++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_5));
          VAR_5+=GetPixelChannels(VAR_1);
        }
        if (VAR_3.bits_per_pixel == 24)
          for (VAR_7=(ssize_t) (3*VAR_1->columns); VAR_7 < (ssize_t) VAR_9; VAR_7++)
            *VAR_8++=0x00;
        VAR_4=SetImageProgress(VAR_1,VAR_27,(MagickOffsetType) VAR_10,
          VAR_1->rows);
        if (VAR_4 == VAR_14)
          break;
      }
      break;
    }
  }
  if (VAR_3.bits_per_pixel == 8)
    if (VAR_0->compression != VAR_30)
      {
        size_t
          VAR_31;

        /* COMMENT_27 */
                                                   
          
        VAR_31=2UL*(VAR_9+2UL)+2UL;
        VAR_11=(unsigned char *) AcquireQuantumMemory(VAR_31,
          (VAR_1->rows+2UL)*sizeof(*VAR_11));
        if (VAR_11 == (unsigned char *) NULL)
          {
            VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
            ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
          }
        VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_9,
          VAR_12,VAR_11);
        VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
        VAR_12=VAR_11;
        VAR_3.compression = VAR_32;
      }
  /* COMMENT_30 */
                     
    
  (void) WriteBlobLSBLong(VAR_1,VAR_3.size);
  (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_3.width);
  (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_3.height);
  (void) WriteBlobLSBShort(VAR_1,(unsigned short) VAR_3.planes);
  (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
  (void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
  if (VAR_1->storage_class == VAR_33)
    {
      if (VAR_3.bits_per_pixel <= 8)
        {
          unsigned char
            *VAR_34;

          /* COMMENT_33 */
                                  
            
          VAR_34=(unsigned char *) AcquireQuantumMemory((size_t)
            (1UL << VAR_3.bits_per_pixel),4*sizeof(*VAR_34));
          if (VAR_34 == (unsigned char *) NULL)
            ThrowWriterException(VAR_24,""MemoryAllocationFailed"");
          VAR_8=VAR_34;
          for (VAR_6=0; VAR_6 < (ssize_t) MagickMin(VAR_1->colors,VAR_3.number_colors); VAR_6++)
          {
            *VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].blue));
            *VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].green));
            *VAR_8++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_6].red));
            *VAR_8++=(Quantum) 0x0;
          }
          for ( ; VAR_6 < (ssize_t) (1L << VAR_3.bits_per_pixel); VAR_6++)
          {
            *VAR_8++=(Quantum) 0x0;
            *VAR_8++=(Quantum) 0x0;
            *VAR_8++=(Quantum) 0x0;
            *VAR_8++=(Quantum) 0x0;
          }
          (void) WriteBlob(VAR_1,(size_t) (4*(1 << VAR_3.bits_per_pixel)),
            VAR_34);
          VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
        }
      else
        if ((VAR_3.bits_per_pixel == 16) &&
            (VAR_3.compression == VAR_19))
          {
            (void) WriteBlobLSBLong(VAR_1,0xf800);
            (void) WriteBlobLSBLong(VAR_1,0x07e0);
            (void) WriteBlobLSBLong(VAR_1,0x001f);
          }
    }
  (void) WriteBlob(VAR_1,VAR_3.image_size,VAR_12);
  VAR_12=(unsigned char *) RelinquishMagickMemory(VAR_12);
  (void) CloseBlob(VAR_1);
  return(VAR_35);
}",ImageMagick/921f208c2ea3cc45847f380257f270ff424adfff/dib.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -96,8 +96,8 @@
   /*
     Convert MIFF to DIB raster pixels.
   */
-  pixels=(unsigned char *) AcquireQuantumMemory(dib_info.image_size,
-    sizeof(*pixels));
+  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,MagickMax(
+    bytes_per_line,image->columns+256UL)*sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   (void) memset(pixels,0,dib_info.image_size);","{'deleted_lines': ['  pixels=(unsigned char *) AcquireQuantumMemory(dib_info.image_size,', '    sizeof(*pixels));'], 'added_lines': ['  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,MagickMax(', '    bytes_per_line,image->columns+256UL)*sizeof(*pixels));']}",True,"In ImageMagick 7.0.8-3 Q16, ReadDIBImage and WriteDIBImage in coders/dib.c allow attackers to cause an out of bounds write via a crafted file.",8.8,HIGH,2,valid,2018-06-20T00:37:56Z,2
CVE-2018-13303,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"avcodec/ac3_parser: Check init_get_bits8() for failure

Fixes: null pointer dereference
Fixes: ffmpeg_crash_6.avi

Found-by: Thuan Pham, Marcel Bhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart
Reviewed-by: Paul B Mahol <onemda@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",00e8181bd97c834fe60751b0c511d4bb97875f78,https://github.com/FFmpeg/FFmpeg/commit/00e8181bd97c834fe60751b0c511d4bb97875f78,libavcodec/ac3_parser.c,avpriv_ac3_parse_header,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
size_t size)
{
GetBitContext gb;
AC3HeaderInfo *hdr;
int err;
if (!*phdr)
*phdr = av_mallocz(sizeof(AC3HeaderInfo));
if (!*phdr)
return AVERROR(ENOMEM);
hdr = *phdr;
init_get_bits8(&gb, buf, size);
err = ff_ac3_parse_header(&gb, hdr);
if (err < 0)
return AVERROR_INVALIDDATA;
return get_bits_count(&gb);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **VAR_0, const uint8_t *VAR_1,
size_t VAR_2)
{
GetBitContext VAR_3;
AC3HeaderInfo *VAR_4;
int VAR_5;
if (!*VAR_0)
*VAR_0 = av_mallocz(sizeof(AC3HeaderInfo));
if (!*VAR_0)
return AVERROR(VAR_6);
VAR_4 = *VAR_0;
init_get_bits8(&VAR_3, VAR_1, VAR_2);
VAR_5 = ff_ac3_parse_header(&VAR_3, VAR_4);
if (VAR_5 < 0)
return VAR_7;
return get_bits_count(&VAR_3);
}",ffmpeg/00e8181bd97c834fe60751b0c511d4bb97875f78/ac3_parser.c/vul/before/0.json,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    GetBitContext gb;
    AC3HeaderInfo *hdr;
    int err;

    if (!*phdr)
        *phdr = av_mallocz(sizeof(AC3HeaderInfo));
    if (!*phdr)
        return AVERROR(ENOMEM);
    hdr = *phdr;

    err = init_get_bits8(&gb, buf, size);
    if (err < 0)
        return AVERROR_INVALIDDATA;
    err = ff_ac3_parse_header(&gb, hdr);
    if (err < 0)
        return AVERROR_INVALIDDATA;

    return get_bits_count(&gb);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **VAR_0, const uint8_t *VAR_1,
                            size_t VAR_2)
{
    GetBitContext VAR_3;
    AC3HeaderInfo *VAR_4;
    int VAR_5;

    if (!*VAR_0)
        *VAR_0 = av_mallocz(sizeof(AC3HeaderInfo));
    if (!*VAR_0)
        return AVERROR(VAR_6);
    VAR_4 = *VAR_0;

    VAR_5 = init_get_bits8(&VAR_3, VAR_1, VAR_2);
    if (VAR_5 < 0)
        return VAR_7;
    VAR_5 = ff_ac3_parse_header(&VAR_3, VAR_4);
    if (VAR_5 < 0)
        return VAR_7;

    return get_bits_count(&VAR_3);
}",ffmpeg/00e8181bd97c834fe60751b0c511d4bb97875f78/ac3_parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,9 @@
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
-    init_get_bits8(&gb, buf, size);
+    err = init_get_bits8(&gb, buf, size);
+    if (err < 0)
+        return AVERROR_INVALIDDATA;
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;","{'deleted_lines': ['    init_get_bits8(&gb, buf, size);'], 'added_lines': ['    err = init_get_bits8(&gb, buf, size);', '    if (err < 0)', '        return AVERROR_INVALIDDATA;']}",True,"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",6.5,MEDIUM,1,valid,2018-06-27T14:59:13Z,2
CVE-2018-1999012,['CWE-835'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ffmpeg,"avformat/pva: Check for EOF before retrying in read_part_of_packet()

Fixes: Infinite loop
Fixes: pva-4b1835dbc2027bf3c567005dcc78e85199240d06

Found-by: Paul Ch <paulcher@icloud.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",9807d3976be0e92e4ece3b4b1701be894cd7c2e1,https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,libavformat/pva.c,read_part_of_packet,"static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
int *len, int *strid, int read_packet) {
AVIOContext *pb = s->pb;
PVAContext *pvactx = s->priv_data;
int syncword, streamid, reserved, flags, length, pts_flag;
int64_t pva_pts = AV_NOPTS_VALUE, startpos;
int ret;
recover:
startpos = avio_tell(pb);
syncword = avio_rb16(pb);
streamid = avio_r8(pb);
avio_r8(pb);               
reserved = avio_r8(pb);
flags    = avio_r8(pb);
length   = avio_rb16(pb);
pts_flag = flags & 0x10;
if (syncword != PVA_MAGIC) {
pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
return AVERROR(EIO);
}
if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
return AVERROR(EIO);
}
if (reserved != 0x55) {
pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
}
if (length > PVA_MAX_PAYLOAD_LENGTH) {
pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
return AVERROR(EIO);
}
if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
pva_pts = avio_rb32(pb);
length -= 4;
} else if (streamid == PVA_AUDIO_PAYLOAD) {
if (!pvactx->continue_pes) {
int pes_signal, pes_header_data_length, pes_packet_length,
pes_flags;
unsigned char pes_header_data[256];
pes_signal             = avio_rb24(pb);
avio_r8(pb);
pes_packet_length      = avio_rb16(pb);
pes_flags              = avio_rb16(pb);
pes_header_data_length = avio_r8(pb);
if (pes_signal != 1 || pes_header_data_length == 0) {
pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
""trying to recover\n"");
avio_skip(pb, length - 9);
if (!read_packet)
return AVERROR(EIO);
goto recover;
}
ret = avio_read(pb, pes_header_data, pes_header_data_length);
if (ret != pes_header_data_length)
return ret < 0 ? ret : AVERROR_INVALIDDATA;
length -= 9 + pes_header_data_length;
pes_packet_length -= 3 + pes_header_data_length;
pvactx->continue_pes = pes_packet_length;
if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
if (pes_header_data_length < 5) {
pva_log(s, AV_LOG_ERROR, ""header too short\n"");
avio_skip(pb, length);
return AVERROR_INVALIDDATA;
}
pva_pts = ff_parse_pes_pts(pes_header_data);
}
}
pvactx->continue_pes -= length;
if (pvactx->continue_pes < 0) {
pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
pvactx->continue_pes = 0;
}
}
if (pva_pts != AV_NOPTS_VALUE)
av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);
*pts   = pva_pts;
*len   = length;
*strid = streamid;
return 0;
}","static int read_part_of_packet(AVFormatContext *VAR_0, int64_t *VAR_1,
int *VAR_2, int *VAR_3, int VAR_4) {
AVIOContext *VAR_5 = VAR_0->pb;
PVAContext *VAR_6 = VAR_0->priv_data;
int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
int64_t VAR_13 = VAR_14, VAR_15;
int VAR_16;
recover:
VAR_15 = avio_tell(VAR_5);
VAR_7 = avio_rb16(VAR_5);
VAR_8 = avio_r8(VAR_5);
avio_r8(VAR_5);               
VAR_9 = avio_r8(VAR_5);
VAR_10    = avio_r8(VAR_5);
VAR_11   = avio_rb16(VAR_5);
VAR_12 = VAR_10 & 0x10;
if (VAR_7 != VAR_17) {
pva_log(VAR_0, VAR_18, ""invalid syncword\n"");
return AVERROR(VAR_19);
}
if (VAR_8 != VAR_20 && VAR_8 != VAR_21) {
pva_log(VAR_0, VAR_18, ""invalid streamid\n"");
return AVERROR(VAR_19);
}
if (VAR_9 != 0x55) {
pva_log(VAR_0, VAR_22, ""expected reserved byte to be 0x55\n"");
}
if (VAR_11 > VAR_23) {
pva_log(VAR_0, VAR_18, ""invalid payload length %u\n"", VAR_11);
return AVERROR(VAR_19);
}
if (VAR_8 == VAR_20 && VAR_12) {
VAR_13 = avio_rb32(VAR_5);
VAR_11 -= 4;
} else if (VAR_8 == VAR_21) {
if (!VAR_6->continue_pes) {
int VAR_24, VAR_25, VAR_26,
VAR_27;
unsigned char VAR_28[256];
VAR_24             = avio_rb24(VAR_5);
avio_r8(VAR_5);
VAR_26      = avio_rb16(VAR_5);
VAR_27              = avio_rb16(VAR_5);
VAR_25 = avio_r8(VAR_5);
if (VAR_24 != 1 || VAR_25 == 0) {
pva_log(VAR_0, VAR_22, ""expected non empty signaled PES packet, ""
""trying to recover\n"");
avio_skip(VAR_5, VAR_11 - 9);
if (!VAR_4)
return AVERROR(VAR_19);
goto recover;
}
VAR_16 = avio_read(VAR_5, VAR_28, VAR_25);
if (VAR_16 != VAR_25)
return VAR_16 < 0 ? VAR_16 : VAR_29;
VAR_11 -= 9 + VAR_25;
VAR_26 -= 3 + VAR_25;
VAR_6->continue_pes = VAR_26;
if (VAR_27 & 0x80 && (VAR_28[0] & 0xf0) == 0x20) {
if (VAR_25 < 5) {
pva_log(VAR_0, VAR_18, ""header too short\n"");
avio_skip(VAR_5, VAR_11);
return VAR_29;
}
VAR_13 = ff_parse_pes_pts(VAR_28);
}
}
VAR_6->continue_pes -= VAR_11;
if (VAR_6->continue_pes < 0) {
pva_log(VAR_0, VAR_22, ""audio data corruption\n"");
VAR_6->continue_pes = 0;
}
}
if (VAR_13 != VAR_14)
av_add_index_entry(VAR_0->streams[VAR_8-1], VAR_15, VAR_13, 0, 0, VAR_30);
*VAR_1   = VAR_13;
*VAR_2   = VAR_11;
*VAR_3 = VAR_8;
return 0;
}",ffmpeg/9807d3976be0e92e4ece3b4b1701be894cd7c2e1/pva.c/vul/before/0.json,"static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
                               int *len, int *strid, int read_packet) {
    AVIOContext *pb = s->pb;
    PVAContext *pvactx = s->priv_data;
    int syncword, streamid, reserved, flags, length, pts_flag;
    int64_t pva_pts = AV_NOPTS_VALUE, startpos;
    int ret;

recover:
    startpos = avio_tell(pb);

    syncword = avio_rb16(pb);
    streamid = avio_r8(pb);
    avio_r8(pb);               /* counter not used */
    reserved = avio_r8(pb);
    flags    = avio_r8(pb);
    length   = avio_rb16(pb);

    pts_flag = flags & 0x10;

    if (syncword != PVA_MAGIC) {
        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
        return AVERROR(EIO);
    }
    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
        return AVERROR(EIO);
    }
    if (reserved != 0x55) {
        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
    }
    if (length > PVA_MAX_PAYLOAD_LENGTH) {
        pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
        return AVERROR(EIO);
    }

    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
        pva_pts = avio_rb32(pb);
        length -= 4;
    } else if (streamid == PVA_AUDIO_PAYLOAD) {
        /* PVA Audio Packets either start with a signaled PES packet or
         * are a continuation of the previous PES packet. New PES packets
         * always start at the beginning of a PVA Packet, never somewhere in
         * the middle. */
        if (!pvactx->continue_pes) {
            int pes_signal, pes_header_data_length, pes_packet_length,
                pes_flags;
            unsigned char pes_header_data[256];

            pes_signal             = avio_rb24(pb);
            avio_r8(pb);
            pes_packet_length      = avio_rb16(pb);
            pes_flags              = avio_rb16(pb);
            pes_header_data_length = avio_r8(pb);

            if (avio_feof(pb)) {
                return AVERROR_EOF;
            }

            if (pes_signal != 1 || pes_header_data_length == 0) {
                pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                          ""trying to recover\n"");
                avio_skip(pb, length - 9);
                if (!read_packet)
                    return AVERROR(EIO);
                goto recover;
            }

            ret = avio_read(pb, pes_header_data, pes_header_data_length);
            if (ret != pes_header_data_length)
                return ret < 0 ? ret : AVERROR_INVALIDDATA;
            length -= 9 + pes_header_data_length;

            pes_packet_length -= 3 + pes_header_data_length;

            pvactx->continue_pes = pes_packet_length;

            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
                if (pes_header_data_length < 5) {
                    pva_log(s, AV_LOG_ERROR, ""header too short\n"");
                    avio_skip(pb, length);
                    return AVERROR_INVALIDDATA;
                }
                pva_pts = ff_parse_pes_pts(pes_header_data);
            }
        }

        pvactx->continue_pes -= length;

        if (pvactx->continue_pes < 0) {
            pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
            pvactx->continue_pes = 0;
        }
    }

    if (pva_pts != AV_NOPTS_VALUE)
        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);

    *pts   = pva_pts;
    *len   = length;
    *strid = streamid;
    return 0;
}","static int read_part_of_packet(AVFormatContext *VAR_0, int64_t *VAR_1,
                               int *VAR_2, int *VAR_3, int VAR_4) {
    AVIOContext *VAR_5 = VAR_0->pb;
    PVAContext *VAR_6 = VAR_0->priv_data;
    int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
    int64_t VAR_13 = VAR_14, VAR_15;
    int VAR_16;

recover:
    VAR_15 = avio_tell(VAR_5);

    VAR_7 = avio_rb16(VAR_5);
    VAR_8 = avio_r8(VAR_5);
    avio_r8(VAR_5);               /* COMMENT_0 */
    VAR_9 = avio_r8(VAR_5);
    VAR_10    = avio_r8(VAR_5);
    VAR_11   = avio_rb16(VAR_5);

    VAR_12 = VAR_10 & 0x10;

    if (VAR_7 != VAR_17) {
        pva_log(VAR_0, VAR_18, ""invalid syncword\n"");
        return AVERROR(VAR_19);
    }
    if (VAR_8 != VAR_20 && VAR_8 != VAR_21) {
        pva_log(VAR_0, VAR_18, ""invalid streamid\n"");
        return AVERROR(VAR_19);
    }
    if (VAR_9 != 0x55) {
        pva_log(VAR_0, VAR_22, ""expected reserved byte to be 0x55\n"");
    }
    if (VAR_11 > VAR_23) {
        pva_log(VAR_0, VAR_18, ""invalid payload length %u\n"", VAR_11);
        return AVERROR(VAR_19);
    }

    if (VAR_8 == VAR_20 && VAR_12) {
        VAR_13 = avio_rb32(VAR_5);
        VAR_11 -= 4;
    } else if (VAR_8 == VAR_21) {
        /* COMMENT_1 */
                                                                         
                                                                            
                         
        if (!VAR_6->continue_pes) {
            int VAR_24, VAR_25, VAR_26,
                VAR_27;
            unsigned char VAR_28[256];

            VAR_24             = avio_rb24(VAR_5);
            avio_r8(VAR_5);
            VAR_26      = avio_rb16(VAR_5);
            VAR_27              = avio_rb16(VAR_5);
            VAR_25 = avio_r8(VAR_5);

            if (avio_feof(VAR_5)) {
                return VAR_29;
            }

            if (VAR_24 != 1 || VAR_25 == 0) {
                pva_log(VAR_0, VAR_22, ""expected non empty signaled PES packet, ""
                                          ""trying to recover\n"");
                avio_skip(VAR_5, VAR_11 - 9);
                if (!VAR_4)
                    return AVERROR(VAR_19);
                goto recover;
            }

            VAR_16 = avio_read(VAR_5, VAR_28, VAR_25);
            if (VAR_16 != VAR_25)
                return VAR_16 < 0 ? VAR_16 : VAR_30;
            VAR_11 -= 9 + VAR_25;

            VAR_26 -= 3 + VAR_25;

            VAR_6->continue_pes = VAR_26;

            if (VAR_27 & 0x80 && (VAR_28[0] & 0xf0) == 0x20) {
                if (VAR_25 < 5) {
                    pva_log(VAR_0, VAR_18, ""header too short\n"");
                    avio_skip(VAR_5, VAR_11);
                    return VAR_30;
                }
                VAR_13 = ff_parse_pes_pts(VAR_28);
            }
        }

        VAR_6->continue_pes -= VAR_11;

        if (VAR_6->continue_pes < 0) {
            pva_log(VAR_0, VAR_22, ""audio data corruption\n"");
            VAR_6->continue_pes = 0;
        }
    }

    if (VAR_13 != VAR_14)
        av_add_index_entry(VAR_0->streams[VAR_8-1], VAR_15, VAR_13, 0, 0, VAR_31);

    *VAR_1   = VAR_13;
    *VAR_2   = VAR_11;
    *VAR_3 = VAR_8;
    return 0;
}",ffmpeg/9807d3976be0e92e4ece3b4b1701be894cd7c2e1/pva.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,6 +53,10 @@
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }
+
             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");","{'deleted_lines': [], 'added_lines': ['            if (avio_feof(pb)) {', '                return AVERROR_EOF;', '            }', '']}",True,FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.,6.5,MEDIUM,1,valid,2018-07-03T20:14:42Z,2
CVE-2018-14351,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,neomutt,Ensure litlen isn't larger than our mailbox,3c49c44be9b459d9c616bcaef6eb5d51298c1741,https://github.com/neomutt/neomutt/commit/3c49c44be9b459d9c616bcaef6eb5d51298c1741,imap/command.c,cmd_parse_status,"static void cmd_parse_status(struct ImapData *idata, char *s)
{
char *value = NULL;
struct Buffy *inc = NULL;
struct ImapMbox mx;
struct ImapStatus *status = NULL;
unsigned int olduv, oldun;
unsigned int litlen;
short new = 0;
short new_msg_count = 0;
char *mailbox = imap_next_word(s);
if (imap_get_literal_count(mailbox, &litlen) == 0)
{
if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)
{
idata->status = IMAP_FATAL;
return;
}
mailbox = idata->buf;
s = mailbox + litlen;
*s = '\0';
s++;
SKIPWS(s);
}
else
{
s = imap_next_word(mailbox);
*(s - 1) = '\0';
imap_unmunge_mbox_name(idata, mailbox);
}
status = imap_mboxcache_get(idata, mailbox, 1);
olduv = status->uidvalidity;
oldun = status->uidnext;
if (*s++ != '(')
{
mutt_debug(1, ""Error parsing STATUS\n"");
return;
}
while (*s && *s != ')')
{
value = imap_next_word(s);
errno = 0;
const unsigned long ulcount = strtoul(value, &value, 10);
if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))
{
mutt_debug(1, ""Error parsing STATUS number\n"");
return;
}
const unsigned int count = (unsigned int) ulcount;
if (mutt_str_strncmp(""MESSAGES"", s, 8) == 0)
{
status->messages = count;
new_msg_count = 1;
}
else if (mutt_str_strncmp(""RECENT"", s, 6) == 0)
status->recent = count;
else if (mutt_str_strncmp(""UIDNEXT"", s, 7) == 0)
status->uidnext = count;
else if (mutt_str_strncmp(""UIDVALIDITY"", s, 11) == 0)
status->uidvalidity = count;
else if (mutt_str_strncmp(""UNSEEN"", s, 6) == 0)
status->unseen = count;
s = value;
if (*s && *s != ')')
s = imap_next_word(s);
}
mutt_debug(3, ""%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\n"",
status->name, status->uidvalidity, status->uidnext,
status->messages, status->recent, status->unseen);
if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)
{
memcpy(idata->cmddata, status, sizeof(struct ImapStatus));
return;
}
mutt_debug(3, ""Running default STATUS handler\n"");
for (inc = Incoming; inc; inc = inc->next)
{
if (inc->magic != MUTT_IMAP)
continue;
if (imap_parse_path(inc->path, &mx) < 0)
{
mutt_debug(1, ""Error parsing mailbox %s, skipping\n"", inc->path);
continue;
}
if (imap_account_match(&idata->conn->account, &mx.account))
{
if (mx.mbox)
{
value = mutt_str_strdup(mx.mbox);
imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);
FREE(&mx.mbox);
}
else
value = mutt_str_strdup(""INBOX"");
if (value && (imap_mxcmp(mailbox, value) == 0))
{
mutt_debug(3, ""Found %s in buffy list (OV: %u ON: %u U: %d)\n"", mailbox,
olduv, oldun, status->unseen);
if (MailCheckRecent)
{
if (olduv && olduv == status->uidvalidity)
{
if (oldun < status->uidnext)
new = (status->unseen > 0);
}
else if (!olduv && !oldun)
{
new = (status->recent > 0);
}
else
new = (status->unseen > 0);
}
else
new = (status->unseen > 0);
#ifdef USE_SIDEBAR
if ((inc->new != new) || (inc->msg_count != status->messages) ||
(inc->msg_unread != status->unseen))
{
mutt_menu_set_current_redraw(REDRAW_SIDEBAR);
}
#endif
inc->new = new;
if (new_msg_count)
inc->msg_count = status->messages;
inc->msg_unread = status->unseen;
if (inc->new)
{
status->uidnext = oldun;
}
FREE(&value);
return;
}
FREE(&value);
}
FREE(&mx.mbox);
}
}","static void cmd_parse_status(struct ImapData *VAR_0, char *VAR_1)
{
char *VAR_2 = NULL;
struct Buffy *VAR_3 = NULL;
struct ImapMbox VAR_4;
struct ImapStatus *VAR_5 = NULL;
unsigned int VAR_6, VAR_7;
unsigned int VAR_8;
short VAR_9 = 0;
short VAR_10 = 0;
char *VAR_11 = imap_next_word(VAR_1);
if (imap_get_literal_count(VAR_11, &VAR_8) == 0)
{
if (imap_cmd_step(VAR_0) != VAR_12)
{
VAR_0->status = VAR_13;
return;
}
VAR_11 = VAR_0->buf;
VAR_1 = VAR_11 + VAR_8;
*VAR_1 = '\0';
VAR_1++;
SKIPWS(VAR_1);
}
else
{
VAR_1 = imap_next_word(VAR_11);
*(VAR_1 - 1) = '\0';
imap_unmunge_mbox_name(VAR_0, VAR_11);
}
VAR_5 = imap_mboxcache_get(VAR_0, VAR_11, 1);
VAR_6 = VAR_5->uidvalidity;
VAR_7 = VAR_5->uidnext;
if (*VAR_1++ != '(')
{
mutt_debug(1, ""Error parsing STATUS\n"");
return;
}
while (*VAR_1 && *VAR_1 != ')')
{
VAR_2 = imap_next_word(VAR_1);
VAR_14 = 0;
const unsigned long VAR_15 = strtoul(VAR_2, &VAR_2, 10);
if (((VAR_14 == VAR_16) && (VAR_15 == VAR_17)) || ((unsigned int) VAR_15 != VAR_15))
{
mutt_debug(1, ""Error parsing STATUS number\n"");
return;
}
const unsigned int VAR_18 = (unsigned int) VAR_15;
if (mutt_str_strncmp(""MESSAGES"", VAR_1, 8) == 0)
{
VAR_5->messages = VAR_18;
VAR_10 = 1;
}
else if (mutt_str_strncmp(""RECENT"", VAR_1, 6) == 0)
VAR_5->recent = VAR_18;
else if (mutt_str_strncmp(""UIDNEXT"", VAR_1, 7) == 0)
VAR_5->uidnext = VAR_18;
else if (mutt_str_strncmp(""UIDVALIDITY"", VAR_1, 11) == 0)
VAR_5->uidvalidity = VAR_18;
else if (mutt_str_strncmp(""UNSEEN"", VAR_1, 6) == 0)
VAR_5->unseen = VAR_18;
VAR_1 = VAR_2;
if (*VAR_1 && *VAR_1 != ')')
VAR_1 = imap_next_word(VAR_1);
}
mutt_debug(3, ""%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\n"",
VAR_5->name, VAR_5->uidvalidity, VAR_5->uidnext,
VAR_5->messages, VAR_5->recent, VAR_5->unseen);
if (VAR_0->cmddata && VAR_0->cmdtype == VAR_19)
{
memcpy(VAR_0->cmddata, VAR_5, sizeof(struct ImapStatus));
return;
}
mutt_debug(3, ""Running default STATUS handler\n"");
for (VAR_3 = VAR_20; VAR_3; VAR_3 = VAR_3->next)
{
if (VAR_3->magic != VAR_21)
continue;
if (imap_parse_path(VAR_3->path, &VAR_4) < 0)
{
mutt_debug(1, ""Error parsing mailbox %s, skipping\n"", VAR_3->path);
continue;
}
if (imap_account_match(&VAR_0->conn->account, &VAR_4.account))
{
if (VAR_4.mbox)
{
VAR_2 = mutt_str_strdup(VAR_4.mbox);
imap_fix_path(VAR_0, VAR_4.mbox, VAR_2, mutt_str_strlen(VAR_2) + 1);
FREE(&VAR_4.mbox);
}
else
VAR_2 = mutt_str_strdup(""INBOX"");
if (VAR_2 && (imap_mxcmp(VAR_11, VAR_2) == 0))
{
mutt_debug(3, ""Found %s in buffy list (OV: %u ON: %u U: %d)\n"", VAR_11,
VAR_6, VAR_7, VAR_5->unseen);
if (VAR_22)
{
if (VAR_6 && VAR_6 == VAR_5->uidvalidity)
{
if (VAR_7 < VAR_5->uidnext)
VAR_9 = (VAR_5->unseen > 0);
}
else if (!VAR_6 && !VAR_7)
{
VAR_9 = (VAR_5->recent > 0);
}
else
VAR_9 = (VAR_5->unseen > 0);
}
else
VAR_9 = (VAR_5->unseen > 0);
#ifdef VAR_23
if ((VAR_3->new != VAR_9) || (VAR_3->msg_count != VAR_5->messages) ||
(VAR_3->msg_unread != VAR_5->unseen))
{
mutt_menu_set_current_redraw(VAR_24);
}
#endif
VAR_3->new = VAR_9;
if (VAR_10)
VAR_3->msg_count = VAR_5->messages;
VAR_3->msg_unread = VAR_5->unseen;
if (VAR_3->new)
{
VAR_5->uidnext = VAR_7;
}
FREE(&VAR_2);
return;
}
FREE(&VAR_2);
}
FREE(&VAR_4.mbox);
}
}",neomutt/3c49c44be9b459d9c616bcaef6eb5d51298c1741/command.c/vul/before/0.json,"static void cmd_parse_status(struct ImapData *idata, char *s)
{
  char *value = NULL;
  struct Buffy *inc = NULL;
  struct ImapMbox mx;
  struct ImapStatus *status = NULL;
  unsigned int olduv, oldun;
  unsigned int litlen;
  short new = 0;
  short new_msg_count = 0;

  char *mailbox = imap_next_word(s);

  /* We need a real tokenizer. */
  if (imap_get_literal_count(mailbox, &litlen) == 0)
  {
    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)
    {
      idata->status = IMAP_FATAL;
      return;
    }

    if (strlen(idata->buf) < litlen)
    {
      mutt_debug(1, ""Error parsing STATUS mailbox\n"");
      return;
    }

    mailbox = idata->buf;
    s = mailbox + litlen;
    *s = '\0';
    s++;
    SKIPWS(s);
  }
  else
  {
    s = imap_next_word(mailbox);
    *(s - 1) = '\0';
    imap_unmunge_mbox_name(idata, mailbox);
  }

  status = imap_mboxcache_get(idata, mailbox, 1);
  olduv = status->uidvalidity;
  oldun = status->uidnext;

  if (*s++ != '(')
  {
    mutt_debug(1, ""Error parsing STATUS\n"");
    return;
  }
  while (*s && *s != ')')
  {
    value = imap_next_word(s);

    errno = 0;
    const unsigned long ulcount = strtoul(value, &value, 10);
    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))
    {
      mutt_debug(1, ""Error parsing STATUS number\n"");
      return;
    }
    const unsigned int count = (unsigned int) ulcount;

    if (mutt_str_strncmp(""MESSAGES"", s, 8) == 0)
    {
      status->messages = count;
      new_msg_count = 1;
    }
    else if (mutt_str_strncmp(""RECENT"", s, 6) == 0)
      status->recent = count;
    else if (mutt_str_strncmp(""UIDNEXT"", s, 7) == 0)
      status->uidnext = count;
    else if (mutt_str_strncmp(""UIDVALIDITY"", s, 11) == 0)
      status->uidvalidity = count;
    else if (mutt_str_strncmp(""UNSEEN"", s, 6) == 0)
      status->unseen = count;

    s = value;
    if (*s && *s != ')')
      s = imap_next_word(s);
  }
  mutt_debug(3, ""%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\n"",
             status->name, status->uidvalidity, status->uidnext,
             status->messages, status->recent, status->unseen);

  /* caller is prepared to handle the result herself */
  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)
  {
    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));
    return;
  }

  mutt_debug(3, ""Running default STATUS handler\n"");

  /* should perhaps move this code back to imap_buffy_check */
  for (inc = Incoming; inc; inc = inc->next)
  {
    if (inc->magic != MUTT_IMAP)
      continue;

    if (imap_parse_path(inc->path, &mx) < 0)
    {
      mutt_debug(1, ""Error parsing mailbox %s, skipping\n"", inc->path);
      continue;
    }

    if (imap_account_match(&idata->conn->account, &mx.account))
    {
      if (mx.mbox)
      {
        value = mutt_str_strdup(mx.mbox);
        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);
        FREE(&mx.mbox);
      }
      else
        value = mutt_str_strdup(""INBOX"");

      if (value && (imap_mxcmp(mailbox, value) == 0))
      {
        mutt_debug(3, ""Found %s in buffy list (OV: %u ON: %u U: %d)\n"", mailbox,
                   olduv, oldun, status->unseen);

        if (MailCheckRecent)
        {
          if (olduv && olduv == status->uidvalidity)
          {
            if (oldun < status->uidnext)
              new = (status->unseen > 0);
          }
          else if (!olduv && !oldun)
          {
            /* first check per session, use recent. might need a flag for this. */
            new = (status->recent > 0);
          }
          else
            new = (status->unseen > 0);
        }
        else
          new = (status->unseen > 0);

#ifdef USE_SIDEBAR
        if ((inc->new != new) || (inc->msg_count != status->messages) ||
            (inc->msg_unread != status->unseen))
        {
          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);
        }
#endif
        inc->new = new;
        if (new_msg_count)
          inc->msg_count = status->messages;
        inc->msg_unread = status->unseen;

        if (inc->new)
        {
          /* force back to keep detecting new mail until the mailbox is
             opened */
          status->uidnext = oldun;
        }

        FREE(&value);
        return;
      }

      FREE(&value);
    }

    FREE(&mx.mbox);
  }
}","static void cmd_parse_status(struct ImapData *VAR_0, char *VAR_1)
{
  char *VAR_2 = NULL;
  struct Buffy *VAR_3 = NULL;
  struct ImapMbox VAR_4;
  struct ImapStatus *VAR_5 = NULL;
  unsigned int VAR_6, VAR_7;
  unsigned int VAR_8;
  short VAR_9 = 0;
  short VAR_10 = 0;

  char *VAR_11 = imap_next_word(VAR_1);

  /* COMMENT_0 */
  if (imap_get_literal_count(VAR_11, &VAR_8) == 0)
  {
    if (imap_cmd_step(VAR_0) != VAR_12)
    {
      VAR_0->status = VAR_13;
      return;
    }

    if (strlen(VAR_0->buf) < VAR_8)
    {
      mutt_debug(1, ""Error parsing STATUS mailbox\n"");
      return;
    }

    VAR_11 = VAR_0->buf;
    VAR_1 = VAR_11 + VAR_8;
    *VAR_1 = '\0';
    VAR_1++;
    SKIPWS(VAR_1);
  }
  else
  {
    VAR_1 = imap_next_word(VAR_11);
    *(VAR_1 - 1) = '\0';
    imap_unmunge_mbox_name(VAR_0, VAR_11);
  }

  VAR_5 = imap_mboxcache_get(VAR_0, VAR_11, 1);
  VAR_6 = VAR_5->uidvalidity;
  VAR_7 = VAR_5->uidnext;

  if (*VAR_1++ != '(')
  {
    mutt_debug(1, ""Error parsing STATUS\n"");
    return;
  }
  while (*VAR_1 && *VAR_1 != ')')
  {
    VAR_2 = imap_next_word(VAR_1);

    VAR_14 = 0;
    const unsigned long VAR_15 = strtoul(VAR_2, &VAR_2, 10);
    if (((VAR_14 == VAR_16) && (VAR_15 == VAR_17)) || ((unsigned int) VAR_15 != VAR_15))
    {
      mutt_debug(1, ""Error parsing STATUS number\n"");
      return;
    }
    const unsigned int VAR_18 = (unsigned int) VAR_15;

    if (mutt_str_strncmp(""MESSAGES"", VAR_1, 8) == 0)
    {
      VAR_5->messages = VAR_18;
      VAR_10 = 1;
    }
    else if (mutt_str_strncmp(""RECENT"", VAR_1, 6) == 0)
      VAR_5->recent = VAR_18;
    else if (mutt_str_strncmp(""UIDNEXT"", VAR_1, 7) == 0)
      VAR_5->uidnext = VAR_18;
    else if (mutt_str_strncmp(""UIDVALIDITY"", VAR_1, 11) == 0)
      VAR_5->uidvalidity = VAR_18;
    else if (mutt_str_strncmp(""UNSEEN"", VAR_1, 6) == 0)
      VAR_5->unseen = VAR_18;

    VAR_1 = VAR_2;
    if (*VAR_1 && *VAR_1 != ')')
      VAR_1 = imap_next_word(VAR_1);
  }
  mutt_debug(3, ""%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\n"",
             VAR_5->name, VAR_5->uidvalidity, VAR_5->uidnext,
             VAR_5->messages, VAR_5->recent, VAR_5->unseen);

  /* COMMENT_1 */
  if (VAR_0->cmddata && VAR_0->cmdtype == VAR_19)
  {
    memcpy(VAR_0->cmddata, VAR_5, sizeof(struct ImapStatus));
    return;
  }

  mutt_debug(3, ""Running default STATUS handler\n"");

  /* COMMENT_2 */
  for (VAR_3 = VAR_20; VAR_3; VAR_3 = VAR_3->next)
  {
    if (VAR_3->magic != VAR_21)
      continue;

    if (imap_parse_path(VAR_3->path, &VAR_4) < 0)
    {
      mutt_debug(1, ""Error parsing mailbox %s, skipping\n"", VAR_3->path);
      continue;
    }

    if (imap_account_match(&VAR_0->conn->account, &VAR_4.account))
    {
      if (VAR_4.mbox)
      {
        VAR_2 = mutt_str_strdup(VAR_4.mbox);
        imap_fix_path(VAR_0, VAR_4.mbox, VAR_2, mutt_str_strlen(VAR_2) + 1);
        FREE(&VAR_4.mbox);
      }
      else
        VAR_2 = mutt_str_strdup(""INBOX"");

      if (VAR_2 && (imap_mxcmp(VAR_11, VAR_2) == 0))
      {
        mutt_debug(3, ""Found %s in buffy list (OV: %u ON: %u U: %d)\n"", VAR_11,
                   VAR_6, VAR_7, VAR_5->unseen);

        if (VAR_22)
        {
          if (VAR_6 && VAR_6 == VAR_5->uidvalidity)
          {
            if (VAR_7 < VAR_5->uidnext)
              VAR_9 = (VAR_5->unseen > 0);
          }
          else if (!VAR_6 && !VAR_7)
          {
            /* COMMENT_3 */
            VAR_9 = (VAR_5->recent > 0);
          }
          else
            VAR_9 = (VAR_5->unseen > 0);
        }
        else
          VAR_9 = (VAR_5->unseen > 0);

#ifdef VAR_23
        if ((VAR_3->new != VAR_9) || (VAR_3->msg_count != VAR_5->messages) ||
            (VAR_3->msg_unread != VAR_5->unseen))
        {
          mutt_menu_set_current_redraw(VAR_24);
        }
#endif
        VAR_3->new = VAR_9;
        if (VAR_10)
          VAR_3->msg_count = VAR_5->messages;
        VAR_3->msg_unread = VAR_5->unseen;

        if (VAR_3->new)
        {
          /* COMMENT_4 */
                      
          VAR_5->uidnext = VAR_7;
        }

        FREE(&VAR_2);
        return;
      }

      FREE(&VAR_2);
    }

    FREE(&VAR_4.mbox);
  }
}",neomutt/3c49c44be9b459d9c616bcaef6eb5d51298c1741/command.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,6 +19,13 @@
       idata->status = IMAP_FATAL;
       return;
     }
+
+    if (strlen(idata->buf) < litlen)
+    {
+      mutt_debug(1, ""Error parsing STATUS mailbox\n"");
+      return;
+    }
+
     mailbox = idata->buf;
     s = mailbox + litlen;
     *s = '\0';","{'deleted_lines': [], 'added_lines': ['', '    if (strlen(idata->buf) < litlen)', '    {', '      mutt_debug(1, ""Error parsing STATUS mailbox\\n"");', '      return;', '    }', '']}",True,An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a long IMAP status mailbox literal count size.,9.8,CRITICAL,3,valid,2018-07-07T20:19:58Z,2
CVE-2018-14056,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,znc,"Don't let web skin name ../../../../ access files outside of usual skins directories.

Thanks for Jeriko One <jeriko.one@gmx.us> for finding and reporting this.",a4a5aeeb17d32937d8c7d743dae9a4cc755ce773,https://github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773,src/WebModules.cpp,CWebSock::GetSkinPath,"CString CWebSock::GetSkinPath(const CString& sSkinName) {
CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkinName;
if (!CFile::IsDir(sRet)) {
sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkinName;
if (!CFile::IsDir(sRet)) {
sRet = CString(_SKINDIR_) + ""/"" + sSkinName;
}
}
return sRet + ""/"";
}","CString CWebSock::GetSkinPath(const CString& VAR_0) {
CString VAR_1 = CZNC::Get().GetZNCPath() + ""/webskins/"" + VAR_0;
if (!CFile::IsDir(VAR_1)) {
VAR_1 = CZNC::Get().GetCurPath() + ""/webskins/"" + VAR_0;
if (!CFile::IsDir(VAR_1)) {
VAR_1 = CString(VAR_2) + ""/"" + VAR_0;
}
}
return VAR_1 + ""/"";
}",znc/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773/WebModules.cpp/vul/before/0.json,"CString CWebSock::GetSkinPath(const CString& sSkinName) {
    const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");

    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin;

    if (!CFile::IsDir(sRet)) {
        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin;

        if (!CFile::IsDir(sRet)) {
            sRet = CString(_SKINDIR_) + ""/"" + sSkin;
        }
    }

    return sRet + ""/"";
}","CString CWebSock::GetSkinPath(const CString& VAR_0) {
    const CString VAR_1 = VAR_0.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");

    CString VAR_2 = CZNC::Get().GetZNCPath() + ""/webskins/"" + VAR_1;

    if (!CFile::IsDir(VAR_2)) {
        VAR_2 = CZNC::Get().GetCurPath() + ""/webskins/"" + VAR_1;

        if (!CFile::IsDir(VAR_2)) {
            VAR_2 = CString(VAR_3) + ""/"" + VAR_1;
        }
    }

    return VAR_2 + ""/"";
}",znc/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773/WebModules.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,13 @@
 CString CWebSock::GetSkinPath(const CString& sSkinName) {
-    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkinName;
+    const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");
+
+    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin;
 
     if (!CFile::IsDir(sRet)) {
-        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkinName;
+        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin;
 
         if (!CFile::IsDir(sRet)) {
-            sRet = CString(_SKINDIR_) + ""/"" + sSkinName;
+            sRet = CString(_SKINDIR_) + ""/"" + sSkin;
         }
     }
 ","{'deleted_lines': ['    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkinName;', '        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkinName;', '            sRet = CString(_SKINDIR_) + ""/"" + sSkinName;'], 'added_lines': ['    const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");', '', '    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin;', '        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin;', '            sRet = CString(_SKINDIR_) + ""/"" + sSkin;']}",True,ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories.,5.3,MEDIUM,1,valid,2018-07-13T23:12:28Z,2
CVE-2018-15501,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,libgit2,"smart_pkt: fix potential OOB-read when processing ng packet

OSS-fuzz has reported a potential out-of-bounds read when processing a
""ng"" smart packet:

==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6310000249c0 at pc 0x000000493a92 bp 0x7ffddc882cd0 sp 0x7ffddc882480
	READ of size 65529 at 0x6310000249c0 thread T0
	SCARINESS: 26 (multi-byte-read-heap-buffer-overflow)
	#0 0x493a91 in __interceptor_strchr.part.35 /src/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc:673
	#1 0x813960 in ng_pkt libgit2/src/transports/smart_pkt.c:320:14
	#2 0x810f79 in git_pkt_parse_line libgit2/src/transports/smart_pkt.c:478:9
	#3 0x82c3c9 in git_smart__store_refs libgit2/src/transports/smart_protocol.c:47:12
	#4 0x6373a2 in git_smart__connect libgit2/src/transports/smart.c:251:15
	#5 0x57688f in git_remote_connect libgit2/src/remote.c:708:15
	#6 0x52e59b in LLVMFuzzerTestOneInput /src/download_refs_fuzzer.cc:145:9
	#7 0x52ef3f in ExecuteFilesOnyByOne(int, char**) /src/libfuzzer/afl/afl_driver.cpp:301:5
	#8 0x52f4ee in main /src/libfuzzer/afl/afl_driver.cpp:339:12
	#9 0x7f6c910db82f in __libc_start_main /build/glibc-Cl5G7W/glibc-2.23/csu/libc-start.c:291
	#10 0x41d518 in _start

When parsing an ""ng"" packet, we keep track of both the current position
as well as the remaining length of the packet itself. But instead of
taking care not to exceed the length, we pass the current pointer's
position to `strchr`, which will search for a certain character until
hitting NUL. It is thus possible to create a crafted packet which
doesn't contain a NUL byte to trigger an out-of-bounds read.

Fix the issue by instead using `memchr`, passing the remaining length as
restriction. Furthermore, verify that we actually have enough bytes left
to produce a match at all.

OSS-Fuzz-Issue: 9406",1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,src/transports/smart_pkt.c,ng_pkt,"static int ng_pkt(git_pkt **out, const char *line, size_t len)
{
git_pkt_ng *pkt;
const char *ptr;
size_t alloclen;
pkt = git__malloc(sizeof(*pkt));
GITERR_CHECK_ALLOC(pkt);
pkt->ref = NULL;
pkt->type = GIT_PKT_NG;
line += 3; 
if (!(ptr = strchr(line, ' ')))
goto out_err;
len = ptr - line;
GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);
pkt->ref = git__malloc(alloclen);
GITERR_CHECK_ALLOC(pkt->ref);
memcpy(pkt->ref, line, len);
pkt->ref[len] = '\0';
line = ptr + 1;
if (!(ptr = strchr(line, '\n')))
goto out_err;
len = ptr - line;
GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);
pkt->msg = git__malloc(alloclen);
GITERR_CHECK_ALLOC(pkt->msg);
memcpy(pkt->msg, line, len);
pkt->msg[len] = '\0';
*out = (git_pkt *)pkt;
return 0;
out_err:
giterr_set(GITERR_NET, ""invalid packet line"");
git__free(pkt->ref);
git__free(pkt);
return -1;
}","static int ng_pkt(git_pkt **VAR_0, const char *VAR_1, size_t VAR_2)
{
git_pkt_ng *VAR_3;
const char *VAR_4;
size_t VAR_5;
VAR_3 = git__malloc(sizeof(*VAR_3));
GITERR_CHECK_ALLOC(VAR_3);
VAR_3->ref = NULL;
VAR_3->type = VAR_6;
VAR_1 += 3; 
if (!(VAR_4 = strchr(VAR_1, ' ')))
goto out_err;
VAR_2 = VAR_4 - VAR_1;
GITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);
VAR_3->ref = git__malloc(VAR_5);
GITERR_CHECK_ALLOC(VAR_3->ref);
memcpy(VAR_3->ref, VAR_1, VAR_2);
VAR_3->ref[VAR_2] = '\0';
VAR_1 = VAR_4 + 1;
if (!(VAR_4 = strchr(VAR_1, '\n')))
goto out_err;
VAR_2 = VAR_4 - VAR_1;
GITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);
VAR_3->msg = git__malloc(VAR_5);
GITERR_CHECK_ALLOC(VAR_3->msg);
memcpy(VAR_3->msg, VAR_1, VAR_2);
VAR_3->msg[VAR_2] = '\0';
*VAR_0 = (git_pkt *)VAR_3;
return 0;
out_err:
giterr_set(VAR_7, ""invalid packet line"");
git__free(VAR_3->ref);
git__free(VAR_3);
return -1;
}",libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649/smart_pkt.c/vul/before/0.json,"static int ng_pkt(git_pkt **out, const char *line, size_t len)
{
	git_pkt_ng *pkt;
	const char *ptr;
	size_t alloclen;

	pkt = git__malloc(sizeof(*pkt));
	GITERR_CHECK_ALLOC(pkt);

	pkt->ref = NULL;
	pkt->type = GIT_PKT_NG;

	if (len < 3)
		goto out_err;
	line += 3; /* skip ""ng "" */
	len -= 3;
	if (!(ptr = memchr(line, ' ', len)))
		goto out_err;
	len = ptr - line;

	GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);
	pkt->ref = git__malloc(alloclen);
	GITERR_CHECK_ALLOC(pkt->ref);

	memcpy(pkt->ref, line, len);
	pkt->ref[len] = '\0';

	if (len < 1)
		goto out_err;
	line = ptr + 1;
	len -= 1;
	if (!(ptr = memchr(line, '\n', len)))
		goto out_err;
	len = ptr - line;

	GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);
	pkt->msg = git__malloc(alloclen);
	GITERR_CHECK_ALLOC(pkt->msg);

	memcpy(pkt->msg, line, len);
	pkt->msg[len] = '\0';

	*out = (git_pkt *)pkt;
	return 0;

out_err:
	giterr_set(GITERR_NET, ""invalid packet line"");
	git__free(pkt->ref);
	git__free(pkt);
	return -1;
}","static int ng_pkt(git_pkt **VAR_0, const char *VAR_1, size_t VAR_2)
{
	git_pkt_ng *VAR_3;
	const char *VAR_4;
	size_t VAR_5;

	VAR_3 = git__malloc(sizeof(*VAR_3));
	GITERR_CHECK_ALLOC(VAR_3);

	VAR_3->ref = NULL;
	VAR_3->type = VAR_6;

	if (VAR_2 < 3)
		goto out_err;
	VAR_1 += 3; /* COMMENT_0 */
	VAR_2 -= 3;
	if (!(VAR_4 = memchr(VAR_1, ' ', VAR_2)))
		goto out_err;
	VAR_2 = VAR_4 - VAR_1;

	GITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);
	VAR_3->ref = git__malloc(VAR_5);
	GITERR_CHECK_ALLOC(VAR_3->ref);

	memcpy(VAR_3->ref, VAR_1, VAR_2);
	VAR_3->ref[VAR_2] = '\0';

	if (VAR_2 < 1)
		goto out_err;
	VAR_1 = VAR_4 + 1;
	VAR_2 -= 1;
	if (!(VAR_4 = memchr(VAR_1, '\n', VAR_2)))
		goto out_err;
	VAR_2 = VAR_4 - VAR_1;

	GITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);
	VAR_3->msg = git__malloc(VAR_5);
	GITERR_CHECK_ALLOC(VAR_3->msg);

	memcpy(VAR_3->msg, VAR_1, VAR_2);
	VAR_3->msg[VAR_2] = '\0';

	*VAR_0 = (git_pkt *)VAR_3;
	return 0;

out_err:
	giterr_set(VAR_7, ""invalid packet line"");
	git__free(VAR_3->ref);
	git__free(VAR_3);
	return -1;
}",libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649/smart_pkt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,8 +10,11 @@
 	pkt->ref = NULL;
 	pkt->type = GIT_PKT_NG;
 
+	if (len < 3)
+		goto out_err;
 	line += 3; /* skip ""ng "" */
-	if (!(ptr = strchr(line, ' ')))
+	len -= 3;
+	if (!(ptr = memchr(line, ' ', len)))
 		goto out_err;
 	len = ptr - line;
 
@@ -22,8 +25,11 @@
 	memcpy(pkt->ref, line, len);
 	pkt->ref[len] = '\0';
 
+	if (len < 1)
+		goto out_err;
 	line = ptr + 1;
-	if (!(ptr = strchr(line, '\n')))
+	len -= 1;
+	if (!(ptr = memchr(line, '\n', len)))
 		goto out_err;
 	len = ptr - line;
 ","{'deleted_lines': [""\tif (!(ptr = strchr(line, ' ')))"", ""\tif (!(ptr = strchr(line, '\\n')))""], 'added_lines': ['\tif (len < 3)', '\t\tgoto out_err;', '\tlen -= 3;', ""\tif (!(ptr = memchr(line, ' ', len)))"", '\tif (len < 1)', '\t\tgoto out_err;', '\tlen -= 1;', ""\tif (!(ptr = memchr(line, '\\n', len)))""]}",True,"In ng_pkt in transports/smart_pkt.c in libgit2 before 0.26.6 and 0.27.x before 0.27.4, a remote attacker can send a crafted smart-protocol ""ng"" packet that lacks a '\0' byte to trigger an out-of-bounds read that leads to DoS.",7.5,HIGH,2,valid,2018-07-19T11:00:42Z,2
CVE-2018-16329,['CWE-476'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1225,2c75f301d9ac84f91071393b02d8c88c8341c91c,https://github.com/ImageMagick/ImageMagick/commit/2c75f301d9ac84f91071393b02d8c88c8341c91c,MagickCore/delegate.c,InterpretDelegateProperties,"static char *InterpretDelegateProperties(ImageInfo *image_info,
Image *image,const char *embed_text,ExceptionInfo *exception)
{
#define ExtendInterpretText(string_length) \
DisableMSCWarning(4127) \
{ \
size_t length=(string_length); \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
} \
RestoreMSCWarning
#define AppendKeyValue2Text(key,value)\
DisableMSCWarning(4127) \
{ \
size_t length=strlen(key)+strlen(value)+2; \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
q+=FormatLocaleString(q,extent,""%s=%s\n"",(key),(value)); \
} \
RestoreMSCWarning
#define AppendString2Text(string) \
DisableMSCWarning(4127) \
{ \
size_t length=strlen((string)); \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
(void) CopyMagickString(q,(string),extent); \
q+=length; \
} \
RestoreMSCWarning
char
*interpret_text,
*string;
register char
*q;  
register const char
*p;  
size_t
extent;  
MagickBooleanType
number;
assert(image == NULL || image->signature == MagickCoreSignature);
assert(image_info == NULL || image_info->signature == MagickCoreSignature);
if ((image != (Image *) NULL) && (image->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
else
if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-image"");
if (embed_text == (const char *) NULL)
return(ConstantString(""""));
p=embed_text;
while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\0'))
p++;
if (*p == '\0')
return(ConstantString(""""));
interpret_text=AcquireString(embed_text);  
extent=MagickPathExtent;  
number=MagickFalse;  
for (q=interpret_text; *p!='\0';
number=isdigit((int) ((unsigned char) *p)) ? MagickTrue : MagickFalse,p++)
{
*q='\0';
ExtendInterpretText(MagickPathExtent);
switch (*p)
{
case '\\':
{
switch (*(p+1))
{
case '\0':
continue;
case 'r':  
{
*q++='\r';
p++;
continue;
}
case 'n':  
{
*q++='\n';
p++;
continue;
}
case '\n':  
{
p++;
continue;
}
case '\r':  
{
p++;
if (*p == '\n') 
p++;
continue;
}
default:
{
p++;
*q++=(*p);
}
}
continue;
}
case '&':
{
if (LocaleNCompare(""&lt;"",p,4) == 0)
{
*q++='<';
p+=3;
}
else
if (LocaleNCompare(""&gt;"",p,4) == 0)
{
*q++='>';
p+=3;
}
else
if (LocaleNCompare(""&amp;"",p,5) == 0)
{
*q++='&';
p+=4;
}
else
*q++=(*p);
continue;
}
case '%':
break;  
default:
{
*q++=(*p);  
continue;
}
}
p++; 
if ((*p == '\0') || (*p == '\'') || (*p == '""'))
p--;
if (*p == '%')
{
*q++='%';
continue;
}
if (number != MagickFalse)
{
*q++='%'; 
p--;      
continue;
}
string=GetMagickPropertyLetter(image_info,image,*p, exception);
if (string != (char *) NULL)
{
AppendString2Text(string);
string=DestroyString(string);
continue;
}
(void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
""UnknownImageProperty"",""\""%%%c\"""",*p);
}
*q='\0';
return(interpret_text);
}","static char *InterpretDelegateProperties(ImageInfo *VAR_0,
Image *VAR_1,const char *VAR_2,ExceptionInfo *VAR_3)
{
#define ExtendInterpretText(VAR_4) \
DisableMSCWarning(4127) \
{ \
size_t length=(string_length); \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
} \
RestoreMSCWarning
#define AppendKeyValue2Text(VAR_5,VAR_6)\
DisableMSCWarning(4127) \
{ \
size_t length=strlen(key)+strlen(value)+2; \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
q+=FormatLocaleString(q,extent,""%s=%s\n"",(key),(value)); \
} \
RestoreMSCWarning
#define AppendString2Text(VAR_7) \
DisableMSCWarning(4127) \
{ \
size_t length=strlen((string)); \
if ((size_t) (q-interpret_text+length+1) >= extent) \
{ \
extent+=length; \
interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
MaxTextExtent,sizeof(*interpret_text)); \
if (interpret_text == (char *) NULL) \
return((char *) NULL); \
q=interpret_text+strlen(interpret_text); \
} \
(void) CopyMagickString(q,(string),extent); \
q+=length; \
} \
RestoreMSCWarning
char
*VAR_8,
*VAR_7;
register char
*VAR_9;  
register const char
*VAR_10;  
size_t
VAR_11;  
MagickBooleanType
VAR_12;
assert(VAR_1 == NULL || VAR_1->signature == VAR_13);
assert(VAR_0 == NULL || VAR_0->signature == VAR_13);
if ((VAR_1 != (Image *) NULL) && (VAR_1->debug != VAR_14))
(void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",VAR_1->filename);
else
if ((VAR_0 != (ImageInfo *) NULL) && (VAR_0->debug != VAR_14))
(void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",""no-image"");
if (VAR_2 == (const char *) NULL)
return(ConstantString(""""));
VAR_10=VAR_2;
while ((isspace((int) ((unsigned char) *VAR_10)) != 0) && (*VAR_10 != '\0'))
VAR_10++;
if (*VAR_10 == '\0')
return(ConstantString(""""));
VAR_8=AcquireString(VAR_2);  
VAR_11=VAR_16;  
VAR_12=VAR_14;  
for (VAR_9=VAR_8; *VAR_10!='\0';
VAR_12=isdigit((int) ((unsigned char) *VAR_10)) ? VAR_17 : VAR_14,VAR_10++)
{
*VAR_9='\0';
ExtendInterpretText(VAR_16);
switch (*VAR_10)
{
case '\\':
{
switch (*(VAR_10+1))
{
case '\0':
continue;
case 'r':  
{
*VAR_9++='\r';
VAR_10++;
continue;
}
case 'n':  
{
*VAR_9++='\n';
VAR_10++;
continue;
}
case '\n':  
{
VAR_10++;
continue;
}
case '\r':  
{
VAR_10++;
if (*VAR_10 == '\n') 
VAR_10++;
continue;
}
default:
{
VAR_10++;
*VAR_9++=(*VAR_10);
}
}
continue;
}
case '&':
{
if (LocaleNCompare(""&lt;"",VAR_10,4) == 0)
{
*VAR_9++='<';
VAR_10+=3;
}
else
if (LocaleNCompare(""&gt;"",VAR_10,4) == 0)
{
*VAR_9++='>';
VAR_10+=3;
}
else
if (LocaleNCompare(""&amp;"",VAR_10,5) == 0)
{
*VAR_9++='&';
VAR_10+=4;
}
else
*VAR_9++=(*VAR_10);
continue;
}
case '%':
break;  
default:
{
*VAR_9++=(*VAR_10);  
continue;
}
}
VAR_10++; 
if ((*VAR_10 == '\0') || (*VAR_10 == '\'') || (*VAR_10 == '""'))
VAR_10--;
if (*VAR_10 == '%')
{
*VAR_9++='%';
continue;
}
if (VAR_12 != VAR_14)
{
*VAR_9++='%'; 
VAR_10--;      
continue;
}
VAR_7=GetMagickPropertyLetter(VAR_0,VAR_1,*VAR_10, VAR_3);
if (VAR_7 != (char *) NULL)
{
AppendString2Text(VAR_7);
VAR_7=DestroyString(VAR_7);
continue;
}
(void) ThrowMagickException(VAR_3,GetMagickModule(),VAR_18,
""UnknownImageProperty"",""\""%%%c\"""",*VAR_10);
}
*VAR_9='\0';
return(VAR_8);
}",ImageMagick/2c75f301d9ac84f91071393b02d8c88c8341c91c/delegate.c/vul/before/0.json,"static char *InterpretDelegateProperties(ImageInfo *image_info,
  Image *image,const char *embed_text,ExceptionInfo *exception)
{
#define ExtendInterpretText(string_length) \
DisableMSCWarning(4127) \
{ \
  size_t length=(string_length); \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
   } \
} \
RestoreMSCWarning

#define AppendKeyValue2Text(key,value)\
DisableMSCWarning(4127) \
{ \
  size_t length=strlen(key)+strlen(value)+2; \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
     } \
   q+=FormatLocaleString(q,extent,""%s=%s\n"",(key),(value)); \
} \
RestoreMSCWarning

#define AppendString2Text(string) \
DisableMSCWarning(4127) \
{ \
  size_t length=strlen((string)); \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
    } \
  (void) CopyMagickString(q,(string),extent); \
  q+=length; \
} \
RestoreMSCWarning

  char
    *interpret_text,
    *string;

  register char
    *q;  /* current position in interpret_text */

  register const char
    *p;  /* position in embed_text string being expanded */

  size_t
    extent;  /* allocated length of interpret_text */

  MagickBooleanType
    number;

  assert(image == NULL || image->signature == MagickCoreSignature);
  assert(image_info == NULL || image_info->signature == MagickCoreSignature);
  if ((image != (Image *) NULL) && (image->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  else
   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-image"");
  if (embed_text == (const char *) NULL)
    return(ConstantString(""""));
  p=embed_text;
  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\0'))
    p++;
  if (*p == '\0')
    return(ConstantString(""""));
  /*
    Translate any embedded format characters.
  */
  interpret_text=AcquireString(embed_text);  /* new string with extra space */
  extent=MagickPathExtent;  /* allocated space in string */
  number=MagickFalse;  /* is last char a number? */
  for (q=interpret_text; *p!='\0';
    number=isdigit((int) ((unsigned char) *p)) ? MagickTrue : MagickFalse,p++)
  {
    /*
      Interpret escape characters (e.g. Filename: %M).
    */
    *q='\0';
    ExtendInterpretText(MagickPathExtent);
    switch (*p)
    {
      case '\\':
      {
        switch (*(p+1))
        {
          case '\0':
            continue;
          case 'r':  /* convert to RETURN */
          {
            *q++='\r';
            p++;
            continue;
          }
          case 'n':  /* convert to NEWLINE */
          {
            *q++='\n';
            p++;
            continue;
          }
          case '\n':  /* EOL removal UNIX,MacOSX */
          {
            p++;
            continue;
          }
          case '\r':  /* EOL removal DOS,Windows */
          {
            p++;
            if (*p == '\n') /* return-newline EOL */
              p++;
            continue;
          }
          default:
          {
            p++;
            *q++=(*p);
          }
        }
        continue;
      }
      case '&':
      {
        if (LocaleNCompare(""&lt;"",p,4) == 0)
          {
            *q++='<';
            p+=3;
          }
        else
          if (LocaleNCompare(""&gt;"",p,4) == 0)
            {
              *q++='>';
              p+=3;
            }
          else
            if (LocaleNCompare(""&amp;"",p,5) == 0)
              {
                *q++='&';
                p+=4;
              }
            else
              *q++=(*p);
        continue;
      }
      case '%':
        break;  /* continue to next set of handlers */
      default:
      {
        *q++=(*p);  /* any thing else is 'as normal' */
        continue;
      }
    }
    p++; /* advance beyond the percent */
    /*
      Doubled Percent - or percent at end of string.
    */
    if ((*p == '\0') || (*p == '\'') || (*p == '""'))
      p--;
    if (*p == '%')
      {
        *q++='%';
        continue;
      }
    /*
      Single letter escapes %c.
    */
    if (number != MagickFalse)
      {
        /*
          But only if not preceeded by a number!
        */
        *q++='%'; /* do NOT substitute the percent */
        p--;      /* back up one */
        continue;
      }
    string=GetMagickPropertyLetter(image_info,image,*p,exception);
    if (string != (char *) NULL)
      {
        AppendString2Text(string);
        string=DestroyString(string);
        continue;
      }
    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
      ""UnknownImageProperty"",""\""%%%c\"""",*p);
  }
  *q='\0';
  return(interpret_text);
}","static char *InterpretDelegateProperties(ImageInfo *VAR_0,
  Image *VAR_1,const char *VAR_2,ExceptionInfo *VAR_3)
{
#define ExtendInterpretText(VAR_4) \
DisableMSCWarning(4127) \
{ \
  size_t length=(string_length); \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
   } \
} \
RestoreMSCWarning

#define AppendKeyValue2Text(VAR_5,VAR_6)\
DisableMSCWarning(4127) \
{ \
  size_t length=strlen(key)+strlen(value)+2; \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
     } \
   q+=FormatLocaleString(q,extent,""%s=%s\n"",(key),(value)); \
} \
RestoreMSCWarning

#define AppendString2Text(VAR_7) \
DisableMSCWarning(4127) \
{ \
  size_t length=strlen((string)); \
  if ((size_t) (q-interpret_text+length+1) >= extent) \
    { \
      extent+=length; \
      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \
        MaxTextExtent,sizeof(*interpret_text)); \
      if (interpret_text == (char *) NULL) \
        return((char *) NULL); \
      q=interpret_text+strlen(interpret_text); \
    } \
  (void) CopyMagickString(q,(string),extent); \
  q+=length; \
} \
RestoreMSCWarning

  char
    *VAR_8,
    *VAR_7;

  register char
    *VAR_9;  /* COMMENT_0 */

  register const char
    *VAR_10;  /* COMMENT_1 */

  size_t
    VAR_11;  /* COMMENT_2 */

  MagickBooleanType
    VAR_12;

  assert(VAR_1 == NULL || VAR_1->signature == VAR_13);
  assert(VAR_0 == NULL || VAR_0->signature == VAR_13);
  if ((VAR_1 != (Image *) NULL) && (VAR_1->debug != VAR_14))
    (void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",VAR_1->filename);
  else
   if ((VAR_0 != (ImageInfo *) NULL) && (VAR_0->debug != VAR_14))
     (void) LogMagickEvent(VAR_15,GetMagickModule(),""%s"",""no-image"");
  if (VAR_2 == (const char *) NULL)
    return(ConstantString(""""));
  VAR_10=VAR_2;
  while ((isspace((int) ((unsigned char) *VAR_10)) != 0) && (*VAR_10 != '\0'))
    VAR_10++;
  if (*VAR_10 == '\0')
    return(ConstantString(""""));
  /* COMMENT_3 */
                                             
    
  VAR_8=AcquireString(VAR_2);  /* COMMENT_6 */
  VAR_11=VAR_16;  /* COMMENT_7 */
  VAR_12=VAR_14;  /* COMMENT_8 */
  for (VAR_9=VAR_8; *VAR_10!='\0';
    VAR_12=isdigit((int) ((unsigned char) *VAR_10)) ? VAR_17 : VAR_14,VAR_10++)
  {
    /* COMMENT_9 */
                                                      
      
    *VAR_9='\0';
    ExtendInterpretText(VAR_16);
    switch (*VAR_10)
    {
      case '\\':
      {
        switch (*(VAR_10+1))
        {
          case '\0':
            continue;
          case 'r':  /* COMMENT_12 */
          {
            *VAR_9++='\r';
            VAR_10++;
            continue;
          }
          case 'n':  /* COMMENT_13 */
          {
            *VAR_9++='\n';
            VAR_10++;
            continue;
          }
          case '\n':  /* COMMENT_14 */
          {
            VAR_10++;
            continue;
          }
          case '\r':  /* COMMENT_15 */
          {
            VAR_10++;
            if (*VAR_10 == '\n') /* COMMENT_16 */
              VAR_10++;
            continue;
          }
          default:
          {
            VAR_10++;
            *VAR_9++=(*VAR_10);
          }
        }
        continue;
      }
      case '&':
      {
        if (LocaleNCompare(""&lt;"",VAR_10,4) == 0)
          {
            *VAR_9++='<';
            VAR_10+=3;
          }
        else
          if (LocaleNCompare(""&gt;"",VAR_10,4) == 0)
            {
              *VAR_9++='>';
              VAR_10+=3;
            }
          else
            if (LocaleNCompare(""&amp;"",VAR_10,5) == 0)
              {
                *VAR_9++='&';
                VAR_10+=4;
              }
            else
              *VAR_9++=(*VAR_10);
        continue;
      }
      case '%':
        break;  /* COMMENT_17 */
      default:
      {
        *VAR_9++=(*VAR_10);  /* COMMENT_18 */
        continue;
      }
    }
    VAR_10++; /* COMMENT_19 */
    /* COMMENT_20 */
                                                    
      
    if ((*VAR_10 == '\0') || (*VAR_10 == '\'') || (*VAR_10 == '""'))
      VAR_10--;
    if (*VAR_10 == '%')
      {
        *VAR_9++='%';
        continue;
      }
    /* COMMENT_23 */
                               
      
    if (VAR_12 != VAR_14)
      {
        /* COMMENT_26 */
                                                
          
        *VAR_9++='%'; /* COMMENT_29 */
        VAR_10--;      /* COMMENT_30 */
        continue;
      }
    VAR_7=GetMagickPropertyLetter(VAR_0,VAR_1,*VAR_10,VAR_3);
    if (VAR_7 != (char *) NULL)
      {
        AppendString2Text(VAR_7);
        VAR_7=DestroyString(VAR_7);
        continue;
      }
    (void) ThrowMagickException(VAR_3,GetMagickModule(),VAR_18,
      ""UnknownImageProperty"",""\""%%%c\"""",*VAR_10);
  }
  *VAR_9='\0';
  return(VAR_8);
}",ImageMagick/2c75f301d9ac84f91071393b02d8c88c8341c91c/delegate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -190,7 +190,7 @@
         p--;      /* back up one */
         continue;
       }
-    string=GetMagickPropertyLetter(image_info,image,*p, exception);
+    string=GetMagickPropertyLetter(image_info,image,*p,exception);
     if (string != (char *) NULL)
       {
         AppendString2Text(string);","{'deleted_lines': ['    string=GetMagickPropertyLetter(image_info,image,*p, exception);'], 'added_lines': ['    string=GetMagickPropertyLetter(image_info,image,*p,exception);']}",True,"In ImageMagick before 7.0.8-8, a NULL pointer dereference exists in the GetMagickProperty function in MagickCore/property.c.",9.8,CRITICAL,3,valid,2018-07-23T18:34:05Z,2
CVE-2018-16329,['CWE-476'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1225,2c75f301d9ac84f91071393b02d8c88c8341c91c,https://github.com/ImageMagick/ImageMagick/commit/2c75f301d9ac84f91071393b02d8c88c8341c91c,MagickCore/property.c,GetMagickPropertyLetter,"static const char *GetMagickPropertyLetter(ImageInfo *image_info,
Image *image,const char letter,ExceptionInfo *exception)
{
#define WarnNoImageReturn(format,arg) \
if (image == (Image *) NULL ) { \
(void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
""NoImageForProperty"",format,arg); \
return((const char *) NULL); \
}
#define WarnNoImageInfoReturn(format,arg) \
if (image_info == (ImageInfo *) NULL ) { \
(void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
""NoImageInfoForProperty"",format,arg); \
return((const char *) NULL); \
}
char
value[MagickPathExtent];  
const char
*string;     
if ((image != (Image *) NULL) && (image->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
else
if ((image_info != (ImageInfo *) NULL) &&
(image_info->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-images"");
*value='\0';           
string=(char *) NULL;  
switch (letter)
{
case 'b':  
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatMagickSize(image->extent,MagickFalse,""B"",MagickPathExtent,
value);
if (image->extent == 0)
(void) FormatMagickSize(GetBlobSize(image),MagickFalse,""B"",
MagickPathExtent,value);
break;
}
case 'c':  
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=GetImageProperty(image,""comment"",exception);
if ( string == (const char *) NULL )
string="""";
break;
}
case 'd':  
{
WarnNoImageReturn(""\""%%%c\"""",letter);
GetPathComponent(image->magick_filename,HeadPath,value);
if (*value == '\0')
string="""";
break;
}
case 'e': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
GetPathComponent(image->magick_filename,ExtensionPath,value);
if (*value == '\0')
string="""";
break;
}
case 'f': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
GetPathComponent(image->magick_filename,TailPath,value);
if (*value == '\0')
string="""";
break;
}
case 'g': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,
""%.20gx%.20g%+.20g%+.20g"",(double) image->page.width,(double)
image->page.height,(double) image->page.x,(double) image->page.y);
break;
}
case 'h': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
(image->rows != 0 ? image->rows : image->magick_rows));
break;
}
case 'i': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=image->filename;
break;
}
case 'k': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetNumberColors(image,(FILE *) NULL,exception));
break;
}
case 'l': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=GetImageProperty(image,""label"",exception);
if (string == (const char *) NULL)
string="""";
break;
}
case 'm': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=image->magick;
break;
}
case 'n': 
{
if ( image != (Image *) NULL )
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetImageListLength(image));
else
string=""0"";    
break;
}
case 'o': 
WarnNoImageInfoReturn(""\""%%%c\"""",letter);
string=image_info->filename;
break;
case 'p': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetImageIndexInList(image));
break;
}
case 'q': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
MAGICKCORE_QUANTUM_DEPTH);
break;
}
case 'r': 
{
ColorspaceType
colorspace;
WarnNoImageReturn(""\""%%%c\"""",letter);
colorspace=image->colorspace;
if ((image->columns != 0) && (image->rows != 0) &&
(SetImageGray(image,exception) != MagickFalse))
colorspace=GRAYColorspace;   
(void) FormatLocaleString(value,MagickPathExtent,""%s %s %s"",
CommandOptionToMnemonic(MagickClassOptions,(ssize_t)
image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,
(ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?
""Alpha"" : """");
break;
}
case 's': 
{
#if 0  
if (image_info->number_scenes != 0)
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image_info->scene);
else if (image != (Image *) NULL)
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->scene);
else
string=""0"";
#else
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->scene);
#endif
break;
}
case 't': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
GetPathComponent(image->magick_filename,BasePath,value);
if (*value == '\0')
string="""";
break;
}
case 'u': 
{
WarnNoImageInfoReturn(""\""%%%c\"""",letter);
string=image_info->unique;
break;
}
case 'w': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
(image->columns != 0 ? image->columns : image->magick_columns));
break;
}
case 'x': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);
break;
}
case 'y': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);
break;
}
case 'z': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->depth);
break;
}
case 'A': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)
image->alpha_trait);
break;
}
case 'B':  
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->extent);
if (image->extent == 0)
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetBlobSize(image));
break;
}
case 'C': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)
image->compression);
break;
}
case 'D': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)
image->dispose);
break;
}
case 'G': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",(double)
image->magick_columns,(double) image->magick_rows);
break;
}
case 'H': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->page.height);
break;
}
case 'M': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=image->magick_filename;
break;
}
case 'O': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%+ld%+ld"",(long)
image->page.x,(long) image->page.y);
break;
}
case 'P': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",(double)
image->page.width,(double) image->page.height);
break;
}
case 'Q': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
(image->quality == 0 ? 92 : image->quality));
break;
}
case 'S': 
{
WarnNoImageInfoReturn(""\""%%%c\"""",letter);
#if 0 
if (image_info->number_scenes == 0)
string=""2147483647"";
else if ( image != (Image *) NULL )
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image_info->scene+image_info->number_scenes);
else
string=""0"";
#else
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
(image_info->number_scenes == 0 ? 2147483647 :
image_info->number_scenes));
#endif
break;
}
case 'T': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->delay);
break;
}
case 'U': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)
image->units);
break;
}
case 'W': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->page.width);
break;
}
case 'X': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%+.20g"",(double)
image->page.x);
break;
}
case 'Y': 
{
WarnNoImageReturn(""\""%%%c\"""",letter);
(void) FormatLocaleString(value,MagickPathExtent,""%+.20g"",(double)
image->page.y);
break;
}
case '%': 
{
string=""%"";
break;
}
case '@': 
{
RectangleInfo
page;
WarnNoImageReturn(""\""%%%c\"""",letter);
page=GetImageBoundingBox(image,exception);
(void) FormatLocaleString(value,MagickPathExtent,
""%.20gx%.20g%+.20g%+.20g"",(double) page.width,(double) page.height,
(double) page.x,(double)page.y);
break;
}
case '#':
{
WarnNoImageReturn(""\""%%%c\"""",letter);
if ((image->columns != 0) && (image->rows != 0))
(void) SignatureImage(image,exception);
string=GetImageProperty(image,""signature"",exception);
break;
}
}
if (string != (char *) NULL)
return(string);
if (*value != '\0')
{
if (image != (Image *) NULL)
{
(void) SetImageArtifact(image,""get-property"",value);
return(GetImageArtifact(image,""get-property""));
}
else
{
(void) SetImageOption(image_info,""get-property"",value);
return(GetImageOption(image_info,""get-property""));
}
}
return((char *) NULL);
}","static const char *GetMagickPropertyLetter(ImageInfo *VAR_0,
Image *VAR_1,const char VAR_2,ExceptionInfo *VAR_3)
{
#define WarnNoImageReturn(VAR_4,VAR_5) \
if (image == (Image *) NULL ) { \
(void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
""NoImageForProperty"",format,arg); \
return((const char *) NULL); \
}
#define WarnNoImageInfoReturn(VAR_4,VAR_5) \
if (image_info == (ImageInfo *) NULL ) { \
(void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
""NoImageInfoForProperty"",format,arg); \
return((const char *) NULL); \
}
char
VAR_6[VAR_7];  
const char
*VAR_8;     
if ((VAR_1 != (Image *) NULL) && (VAR_1->debug != VAR_9))
(void) LogMagickEvent(VAR_10,GetMagickModule(),""%s"",VAR_1->filename);
else
if ((VAR_0 != (ImageInfo *) NULL) &&
(VAR_0->debug != VAR_9))
(void) LogMagickEvent(VAR_10,GetMagickModule(),""%s"",""no-images"");
*VAR_6='\0';           
VAR_8=(char *) NULL;  
switch (VAR_2)
{
case 'b':  
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatMagickSize(VAR_1->extent,VAR_9,""B"",VAR_7,
VAR_6);
if (VAR_1->extent == 0)
(void) FormatMagickSize(GetBlobSize(VAR_1),VAR_9,""B"",
VAR_7,VAR_6);
break;
}
case 'c':  
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=GetImageProperty(VAR_1,""comment"",VAR_3);
if ( VAR_8 == (const char *) NULL )
VAR_8="""";
break;
}
case 'd':  
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
GetPathComponent(VAR_1->magick_filename,VAR_11,VAR_6);
if (*VAR_6 == '\0')
VAR_8="""";
break;
}
case 'e': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
GetPathComponent(VAR_1->magick_filename,VAR_12,VAR_6);
if (*VAR_6 == '\0')
VAR_8="""";
break;
}
case 'f': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
GetPathComponent(VAR_1->magick_filename,VAR_13,VAR_6);
if (*VAR_6 == '\0')
VAR_8="""";
break;
}
case 'g': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,
""%.20gx%.20g%+.20g%+.20g"",(double) VAR_1->page.width,(double)
VAR_1->page.height,(double) VAR_1->page.x,(double) VAR_1->page.y);
break;
}
case 'h': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
(VAR_1->rows != 0 ? VAR_1->rows : VAR_1->magick_rows));
break;
}
case 'i': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=VAR_1->filename;
break;
}
case 'k': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
GetNumberColors(VAR_1,(FILE *) NULL,VAR_3));
break;
}
case 'l': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=GetImageProperty(VAR_1,""label"",VAR_3);
if (VAR_8 == (const char *) NULL)
VAR_8="""";
break;
}
case 'm': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=VAR_1->magick;
break;
}
case 'n': 
{
if ( VAR_1 != (Image *) NULL )
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
GetImageListLength(VAR_1));
else
VAR_8=""0"";    
break;
}
case 'o': 
WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
VAR_8=VAR_0->filename;
break;
case 'p': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
GetImageIndexInList(VAR_1));
break;
}
case 'q': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_14);
break;
}
case 'r': 
{
ColorspaceType
VAR_15;
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_15=VAR_1->colorspace;
if ((VAR_1->columns != 0) && (VAR_1->rows != 0) &&
(SetImageGray(VAR_1,VAR_3) != VAR_9))
VAR_15=VAR_16;   
(void) FormatLocaleString(VAR_6,VAR_7,""%s %s %s"",
CommandOptionToMnemonic(VAR_17,(ssize_t)
VAR_1->storage_class),CommandOptionToMnemonic(VAR_18,
(ssize_t) VAR_15),VAR_1->alpha_trait != VAR_19 ?
""Alpha"" : """");
break;
}
case 's': 
{
#if 0  
if (VAR_0->number_scenes != 0)
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_0->scene);
else if (VAR_1 != (Image *) NULL)
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->scene);
else
VAR_8=""0"";
#else
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->scene);
#endif
break;
}
case 't': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
GetPathComponent(VAR_1->magick_filename,VAR_20,VAR_6);
if (*VAR_6 == '\0')
VAR_8="""";
break;
}
case 'u': 
{
WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
VAR_8=VAR_0->unique;
break;
}
case 'w': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
(VAR_1->columns != 0 ? VAR_1->columns : VAR_1->magick_columns));
break;
}
case 'x': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",
fabs(VAR_1->resolution.x) > VAR_21 ? VAR_1->resolution.x : 72.0);
break;
}
case 'y': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",
fabs(VAR_1->resolution.y) > VAR_21 ? VAR_1->resolution.y : 72.0);
break;
}
case 'z': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->depth);
break;
}
case 'A': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=CommandOptionToMnemonic(VAR_22,(ssize_t)
VAR_1->alpha_trait);
break;
}
case 'B':  
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->extent);
if (VAR_1->extent == 0)
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
GetBlobSize(VAR_1));
break;
}
case 'C': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=CommandOptionToMnemonic(VAR_23,(ssize_t)
VAR_1->compression);
break;
}
case 'D': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=CommandOptionToMnemonic(VAR_24,(ssize_t)
VAR_1->dispose);
break;
}
case 'G': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20gx%.20g"",(double)
VAR_1->magick_columns,(double) VAR_1->magick_rows);
break;
}
case 'H': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->page.height);
break;
}
case 'M': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=VAR_1->magick_filename;
break;
}
case 'O': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%+ld%+ld"",(long)
VAR_1->page.x,(long) VAR_1->page.y);
break;
}
case 'P': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20gx%.20g"",(double)
VAR_1->page.width,(double) VAR_1->page.height);
break;
}
case 'Q': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
(VAR_1->quality == 0 ? 92 : VAR_1->quality));
break;
}
case 'S': 
{
WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
#if 0 
if (VAR_0->number_scenes == 0)
VAR_8=""2147483647"";
else if ( VAR_1 != (Image *) NULL )
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_0->scene+VAR_0->number_scenes);
else
VAR_8=""0"";
#else
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
(VAR_0->number_scenes == 0 ? 2147483647 :
VAR_0->number_scenes));
#endif
break;
}
case 'T': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->delay);
break;
}
case 'U': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_8=CommandOptionToMnemonic(VAR_25,(ssize_t)
VAR_1->units);
break;
}
case 'W': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
VAR_1->page.width);
break;
}
case 'X': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%+.20g"",(double)
VAR_1->page.x);
break;
}
case 'Y': 
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
(void) FormatLocaleString(VAR_6,VAR_7,""%+.20g"",(double)
VAR_1->page.y);
break;
}
case '%': 
{
VAR_8=""%"";
break;
}
case '@': 
{
RectangleInfo
VAR_26;
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
VAR_26=GetImageBoundingBox(VAR_1,VAR_3);
(void) FormatLocaleString(VAR_6,VAR_7,
""%.20gx%.20g%+.20g%+.20g"",(double) VAR_26.width,(double) VAR_26.height,
(double) VAR_26.x,(double)VAR_26.y);
break;
}
case '#':
{
WarnNoImageReturn(""\""%%%c\"""",VAR_2);
if ((VAR_1->columns != 0) && (VAR_1->rows != 0))
(void) SignatureImage(VAR_1,VAR_3);
VAR_8=GetImageProperty(VAR_1,""signature"",VAR_3);
break;
}
}
if (VAR_8 != (char *) NULL)
return(VAR_8);
if (*VAR_6 != '\0')
{
if (VAR_1 != (Image *) NULL)
{
(void) SetImageArtifact(VAR_1,""get-property"",VAR_6);
return(GetImageArtifact(VAR_1,""get-property""));
}
else
{
(void) SetImageOption(VAR_0,""get-property"",VAR_6);
return(GetImageOption(VAR_0,""get-property""));
}
}
return((char *) NULL);
}",ImageMagick/2c75f301d9ac84f91071393b02d8c88c8341c91c/property.c/vul/before/1.json,"static const char *GetMagickPropertyLetter(ImageInfo *image_info,
  Image *image,const char letter,ExceptionInfo *exception)
{
#define WarnNoImageReturn(format,arg) \
  if (image == (Image *) NULL ) { \
    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
      ""NoImageForProperty"",format,arg); \
    return((const char *) NULL); \
  }
#define WarnNoImageInfoReturn(format,arg) \
  if (image_info == (ImageInfo *) NULL ) { \
    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
      ""NoImageInfoForProperty"",format,arg); \
    return((const char *) NULL); \
  }

  char
    value[MagickPathExtent];  /* formatted string to store as an artifact */

  const char
    *string;     /* return a string already stored somewher */

  if ((image != (Image *) NULL) && (image->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  else
    if ((image_info != (ImageInfo *) NULL) &&
        (image_info->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-images"");
  *value='\0';           /* formatted string */
  string=(char *) NULL;  /* constant string reference */
  /*
    Get properities that are directly defined by images.
  */
  switch (letter)
  {
    case 'b':  /* image size read in - in bytes */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatMagickSize(image->extent,MagickFalse,""B"",MagickPathExtent,
        value);
      if (image->extent == 0)
        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,""B"",
          MagickPathExtent,value);
      break;
    }
    case 'c':  /* image comment property - empty string by default */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=GetImageProperty(image,""comment"",exception);
      if ( string == (const char *) NULL )
        string="""";
      break;
    }
    case 'd':  /* Directory component of filename */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      GetPathComponent(image->magick_filename,HeadPath,value);
      if (*value == '\0')
        string="""";
      break;
    }
    case 'e': /* Filename extension (suffix) of image file */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      GetPathComponent(image->magick_filename,ExtensionPath,value);
      if (*value == '\0')
        string="""";
      break;
    }
    case 'f': /* Filename without directory component */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      GetPathComponent(image->magick_filename,TailPath,value);
      if (*value == '\0')
        string="""";
      break;
    }
    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,
        ""%.20gx%.20g%+.20g%+.20g"",(double) image->page.width,(double)
        image->page.height,(double) image->page.x,(double) image->page.y);
      break;
    }
    case 'h': /* Image height (current) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        (image->rows != 0 ? image->rows : image->magick_rows));
      break;
    }
    case 'i': /* Filename last used for an image (read or write) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=image->filename;
      break;
    }
    case 'k': /* Number of unique colors  */
    {
      /*
        FUTURE: ensure this does not generate the formatted comment!
      */
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        GetNumberColors(image,(FILE *) NULL,exception));
      break;
    }
    case 'l': /* Image label property - empty string by default */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=GetImageProperty(image,""label"",exception);
      if (string == (const char *) NULL)
        string="""";
      break;
    }
    case 'm': /* Image format (file magick) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=image->magick;
      break;
    }
    case 'n': /* Number of images in the list.  */
    {
      if ( image != (Image *) NULL )
        (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
          GetImageListLength(image));
      else
        string=""0"";    /* no images or scenes */
      break;
    }
    case 'o': /* Output Filename - for delegate use only */
      WarnNoImageInfoReturn(""\""%%%c\"""",letter);
      string=image_info->filename;
      break;
    case 'p': /* Image index in current image list */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        GetImageIndexInList(image));
      break;
    }
    case 'q': /* Quantum depth of image in memory */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        MAGICKCORE_QUANTUM_DEPTH);
      break;
    }
    case 'r': /* Image storage class, colorspace, and alpha enabled.  */
    {
      ColorspaceType
        colorspace;

      WarnNoImageReturn(""\""%%%c\"""",letter);
      colorspace=image->colorspace;
      if ((image->columns != 0) && (image->rows != 0) &&
          (SetImageGray(image,exception) != MagickFalse))
        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */
      (void) FormatLocaleString(value,MagickPathExtent,""%s %s %s"",
        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)
        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,
        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?
        ""Alpha"" : """");
      break;
    }
    case 's': /* Image scene number */
    {
#if 0  /* this seems non-sensical -- simplifing */
      if (image_info->number_scenes != 0)
        (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
          image_info->scene);
      else if (image != (Image *) NULL)
        (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
          image->scene);
      else
          string=""0"";
#else
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->scene);
#endif
      break;
    }
    case 't': /* Base filename without directory or extention */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      GetPathComponent(image->magick_filename,BasePath,value);
      if (*value == '\0')
        string="""";
      break;
    }
    case 'u': /* Unique filename */
    {
      WarnNoImageInfoReturn(""\""%%%c\"""",letter);
      string=image_info->unique;
      break;
    }
    case 'w': /* Image width (current) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        (image->columns != 0 ? image->columns : image->magick_columns));
      break;
    }
    case 'x': /* Image horizontal resolution (with units) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);
      break;
    }
    case 'y': /* Image vertical resolution (with units) */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);
      break;
    }
    case 'z': /* Image depth as read in */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->depth);
      break;
    }
    case 'A': /* Image alpha channel  */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)
        image->alpha_trait);
      break;
    }
    case 'B':  /* image size read in - in bytes */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->extent);
      if (image->extent == 0)
        (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
          GetBlobSize(image));
      break;
    }
    case 'C': /* Image compression method.  */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)
        image->compression);
      break;
    }
    case 'D': /* Image dispose method.  */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)
        image->dispose);
      break;
    }
    case 'G': /* Image size as geometry = ""%wx%h"" */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",(double)
        image->magick_columns,(double) image->magick_rows);
      break;
    }
    case 'H': /* layer canvas height */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->page.height);
      break;
    }
    case 'M': /* Magick filename - filename given incl. coder & read mods */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=image->magick_filename;
      break;
    }
    case 'O': /* layer canvas offset with sign = ""+%X+%Y"" */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%+ld%+ld"",(long)
        image->page.x,(long) image->page.y);
      break;
    }
    case 'P': /* layer canvas page size = ""%Wx%H"" */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",(double)
        image->page.width,(double) image->page.height);
      break;
    }
    case 'Q': /* image compression quality */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        (image->quality == 0 ? 92 : image->quality));
      break;
    }
    case 'S': /* Number of scenes in image list.  */
    {
      WarnNoImageInfoReturn(""\""%%%c\"""",letter);
#if 0 /* What is this number? -- it makes no sense - simplifing */
      if (image_info->number_scenes == 0)
         string=""2147483647"";
      else if ( image != (Image *) NULL )
        (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
                image_info->scene+image_info->number_scenes);
      else
        string=""0"";
#else
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        (image_info->number_scenes == 0 ? 2147483647 :
         image_info->number_scenes));
#endif
      break;
    }
    case 'T': /* image time delay for animations */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->delay);
      break;
    }
    case 'U': /* Image resolution units. */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)
        image->units);
      break;
    }
    case 'W': /* layer canvas width */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
        image->page.width);
      break;
    }
    case 'X': /* layer canvas X offset */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%+.20g"",(double)
        image->page.x);
      break;
    }
    case 'Y': /* layer canvas Y offset */
    {
      WarnNoImageReturn(""\""%%%c\"""",letter);
      (void) FormatLocaleString(value,MagickPathExtent,""%+.20g"",(double)
        image->page.y);
      break;
    }
    case '%': /* percent escaped */
    {
      string=""%"";
      break;
    }
    case '@': /* Trim bounding box, without actually Trimming! */
    {
      RectangleInfo
        page;

      WarnNoImageReturn(""\""%%%c\"""",letter);
      page=GetImageBoundingBox(image,exception);
      (void) FormatLocaleString(value,MagickPathExtent,
        ""%.20gx%.20g%+.20g%+.20g"",(double) page.width,(double) page.height,
        (double) page.x,(double)page.y);
      break;
    }
    case '#':
    {
      /*
        Image signature.
      */
      WarnNoImageReturn(""\""%%%c\"""",letter);
      if ((image->columns != 0) && (image->rows != 0))
        (void) SignatureImage(image,exception);
      string=GetImageProperty(image,""signature"",exception);
      break;
    }
  }
  if (string != (char *) NULL)
    return(string);
  if (*value != '\0')
    {
      /*
        Create a cloned copy of result.
      */
      if (image != (Image *) NULL)
        {
          (void) SetImageArtifact(image,""get-property"",value);
          return(GetImageArtifact(image,""get-property""));
        }
      else
        {
          (void) SetImageOption(image_info,""get-property"",value);
          return(GetImageOption(image_info,""get-property""));
        }
    }
  return((char *) NULL);
}","static const char *GetMagickPropertyLetter(ImageInfo *VAR_0,
  Image *VAR_1,const char VAR_2,ExceptionInfo *VAR_3)
{
#define WarnNoImageReturn(VAR_4,VAR_5) \
  if (image == (Image *) NULL ) { \
    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
      ""NoImageForProperty"",format,arg); \
    return((const char *) NULL); \
  }
#define WarnNoImageInfoReturn(VAR_4,VAR_5) \
  if (image_info == (ImageInfo *) NULL ) { \
    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \
      ""NoImageInfoForProperty"",format,arg); \
    return((const char *) NULL); \
  }

  char
    VAR_6[VAR_7];  /* COMMENT_0 */

  const char
    *VAR_8;     /* COMMENT_1 */

  if ((VAR_1 != (Image *) NULL) && (VAR_1->debug != VAR_9))
    (void) LogMagickEvent(VAR_10,GetMagickModule(),""%s"",VAR_1->filename);
  else
    if ((VAR_0 != (ImageInfo *) NULL) &&
        (VAR_0->debug != VAR_9))
    (void) LogMagickEvent(VAR_10,GetMagickModule(),""%s"",""no-images"");
  *VAR_6='\0';           /* COMMENT_2 */
  VAR_8=(char *) NULL;  /* COMMENT_3 */
  /* COMMENT_4 */
                                                        
    
  switch (VAR_2)
  {
    case 'b':  /* COMMENT_7 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatMagickSize(VAR_1->extent,VAR_9,""B"",VAR_7,
        VAR_6);
      if (VAR_1->extent == 0)
        (void) FormatMagickSize(GetBlobSize(VAR_1),VAR_9,""B"",
          VAR_7,VAR_6);
      break;
    }
    case 'c':  /* COMMENT_8 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=GetImageProperty(VAR_1,""comment"",VAR_3);
      if ( VAR_8 == (const char *) NULL )
        VAR_8="""";
      break;
    }
    case 'd':  /* COMMENT_9 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      GetPathComponent(VAR_1->magick_filename,VAR_11,VAR_6);
      if (*VAR_6 == '\0')
        VAR_8="""";
      break;
    }
    case 'e': /* COMMENT_10 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      GetPathComponent(VAR_1->magick_filename,VAR_12,VAR_6);
      if (*VAR_6 == '\0')
        VAR_8="""";
      break;
    }
    case 'f': /* COMMENT_11 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      GetPathComponent(VAR_1->magick_filename,VAR_13,VAR_6);
      if (*VAR_6 == '\0')
        VAR_8="""";
      break;
    }
    case 'g': /* COMMENT_12 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,
        ""%.20gx%.20g%+.20g%+.20g"",(double) VAR_1->page.width,(double)
        VAR_1->page.height,(double) VAR_1->page.x,(double) VAR_1->page.y);
      break;
    }
    case 'h': /* COMMENT_13 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        (VAR_1->rows != 0 ? VAR_1->rows : VAR_1->magick_rows));
      break;
    }
    case 'i': /* COMMENT_14 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=VAR_1->filename;
      break;
    }
    case 'k': /* COMMENT_15 */
    {
      /* COMMENT_16 */
                                                                    
        
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        GetNumberColors(VAR_1,(FILE *) NULL,VAR_3));
      break;
    }
    case 'l': /* COMMENT_19 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=GetImageProperty(VAR_1,""label"",VAR_3);
      if (VAR_8 == (const char *) NULL)
        VAR_8="""";
      break;
    }
    case 'm': /* COMMENT_20 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=VAR_1->magick;
      break;
    }
    case 'n': /* COMMENT_21 */
    {
      if ( VAR_1 != (Image *) NULL )
        (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
          GetImageListLength(VAR_1));
      else
        VAR_8=""0"";    /* COMMENT_22 */
      break;
    }
    case 'o': /* COMMENT_23 */
      WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
      VAR_8=VAR_0->filename;
      break;
    case 'p': /* COMMENT_24 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        GetImageIndexInList(VAR_1));
      break;
    }
    case 'q': /* COMMENT_25 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_14);
      break;
    }
    case 'r': /* COMMENT_26 */
    {
      ColorspaceType
        VAR_15;

      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_15=VAR_1->colorspace;
      if ((VAR_1->columns != 0) && (VAR_1->rows != 0) &&
          (SetImageGray(VAR_1,VAR_3) != VAR_9))
        VAR_15=VAR_16;   /* COMMENT_27 */
      (void) FormatLocaleString(VAR_6,VAR_7,""%s %s %s"",
        CommandOptionToMnemonic(VAR_17,(ssize_t)
        VAR_1->storage_class),CommandOptionToMnemonic(VAR_18,
        (ssize_t) VAR_15),VAR_1->alpha_trait != VAR_19 ?
        ""Alpha"" : """");
      break;
    }
    case 's': /* COMMENT_28 */
    {
#if 0  /* COMMENT_29 */
      if (VAR_0->number_scenes != 0)
        (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
          VAR_0->scene);
      else if (VAR_1 != (Image *) NULL)
        (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
          VAR_1->scene);
      else
          VAR_8=""0"";
#else
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->scene);
#endif
      break;
    }
    case 't': /* COMMENT_30 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      GetPathComponent(VAR_1->magick_filename,VAR_20,VAR_6);
      if (*VAR_6 == '\0')
        VAR_8="""";
      break;
    }
    case 'u': /* COMMENT_31 */
    {
      WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
      VAR_8=VAR_0->unique;
      break;
    }
    case 'w': /* COMMENT_32 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        (VAR_1->columns != 0 ? VAR_1->columns : VAR_1->magick_columns));
      break;
    }
    case 'x': /* COMMENT_33 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",
        fabs(VAR_1->resolution.x) > VAR_21 ? VAR_1->resolution.x : 72.0);
      break;
    }
    case 'y': /* COMMENT_34 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",
        fabs(VAR_1->resolution.y) > VAR_21 ? VAR_1->resolution.y : 72.0);
      break;
    }
    case 'z': /* COMMENT_35 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->depth);
      break;
    }
    case 'A': /* COMMENT_36 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=CommandOptionToMnemonic(VAR_22,(ssize_t)
        VAR_1->alpha_trait);
      break;
    }
    case 'B':  /* COMMENT_7 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->extent);
      if (VAR_1->extent == 0)
        (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
          GetBlobSize(VAR_1));
      break;
    }
    case 'C': /* COMMENT_37 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=CommandOptionToMnemonic(VAR_23,(ssize_t)
        VAR_1->compression);
      break;
    }
    case 'D': /* COMMENT_38 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=CommandOptionToMnemonic(VAR_24,(ssize_t)
        VAR_1->dispose);
      break;
    }
    case 'G': /* COMMENT_39 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20gx%.20g"",(double)
        VAR_1->magick_columns,(double) VAR_1->magick_rows);
      break;
    }
    case 'H': /* COMMENT_40 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->page.height);
      break;
    }
    case 'M': /* COMMENT_41 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=VAR_1->magick_filename;
      break;
    }
    case 'O': /* COMMENT_42 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%+ld%+ld"",(long)
        VAR_1->page.x,(long) VAR_1->page.y);
      break;
    }
    case 'P': /* COMMENT_43 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20gx%.20g"",(double)
        VAR_1->page.width,(double) VAR_1->page.height);
      break;
    }
    case 'Q': /* COMMENT_44 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        (VAR_1->quality == 0 ? 92 : VAR_1->quality));
      break;
    }
    case 'S': /* COMMENT_45 */
    {
      WarnNoImageInfoReturn(""\""%%%c\"""",VAR_2);
#if 0 /* COMMENT_46 */
      if (VAR_0->number_scenes == 0)
         VAR_8=""2147483647"";
      else if ( VAR_1 != (Image *) NULL )
        (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
                VAR_0->scene+VAR_0->number_scenes);
      else
        VAR_8=""0"";
#else
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        (VAR_0->number_scenes == 0 ? 2147483647 :
         VAR_0->number_scenes));
#endif
      break;
    }
    case 'T': /* COMMENT_47 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->delay);
      break;
    }
    case 'U': /* COMMENT_48 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_8=CommandOptionToMnemonic(VAR_25,(ssize_t)
        VAR_1->units);
      break;
    }
    case 'W': /* COMMENT_49 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%.20g"",(double)
        VAR_1->page.width);
      break;
    }
    case 'X': /* COMMENT_50 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%+.20g"",(double)
        VAR_1->page.x);
      break;
    }
    case 'Y': /* COMMENT_51 */
    {
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      (void) FormatLocaleString(VAR_6,VAR_7,""%+.20g"",(double)
        VAR_1->page.y);
      break;
    }
    case '%': /* COMMENT_52 */
    {
      VAR_8=""%"";
      break;
    }
    case '@': /* COMMENT_53 */
    {
      RectangleInfo
        VAR_26;

      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      VAR_26=GetImageBoundingBox(VAR_1,VAR_3);
      (void) FormatLocaleString(VAR_6,VAR_7,
        ""%.20gx%.20g%+.20g%+.20g"",(double) VAR_26.width,(double) VAR_26.height,
        (double) VAR_26.x,(double)VAR_26.y);
      break;
    }
    case '#':
    {
      /* COMMENT_54 */
                        
        
      WarnNoImageReturn(""\""%%%c\"""",VAR_2);
      if ((VAR_1->columns != 0) && (VAR_1->rows != 0))
        (void) SignatureImage(VAR_1,VAR_3);
      VAR_8=GetImageProperty(VAR_1,""signature"",VAR_3);
      break;
    }
  }
  if (VAR_8 != (char *) NULL)
    return(VAR_8);
  if (*VAR_6 != '\0')
    {
      /* COMMENT_57 */
                                       
        
      if (VAR_1 != (Image *) NULL)
        {
          (void) SetImageArtifact(VAR_1,""get-property"",VAR_6);
          return(GetImageArtifact(VAR_1,""get-property""));
        }
      else
        {
          (void) SetImageOption(VAR_0,""get-property"",VAR_6);
          return(GetImageOption(VAR_0,""get-property""));
        }
    }
  return((char *) NULL);
}",ImageMagick/2c75f301d9ac84f91071393b02d8c88c8341c91c/property.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -178,7 +178,7 @@
 #else
       WarnNoImageReturn(""\""%%%c\"""",letter);
       (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
-         image->scene);
+        image->scene);
 #endif
       break;
     }","{'deleted_lines': ['         image->scene);'], 'added_lines': ['        image->scene);']}",True,"In ImageMagick before 7.0.8-8, a NULL pointer dereference exists in the GetMagickProperty function in MagickCore/property.c.",9.8,CRITICAL,3,valid,2018-07-23T18:34:05Z,2
CVE-2018-16329,['CWE-476'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1225,2c75f301d9ac84f91071393b02d8c88c8341c91c,https://github.com/ImageMagick/ImageMagick/commit/2c75f301d9ac84f91071393b02d8c88c8341c91c,MagickCore/property.c,GetMagickProperty,"MagickExport const char *GetMagickProperty(ImageInfo *image_info,
Image *image,const char *property,ExceptionInfo *exception)
{
char
value[MagickPathExtent];
const char
*string;
assert(property[0] != '\0');
assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );
if (property[1] == '\0')  
return(GetMagickPropertyLetter(image_info,image,*property,exception));
if ((image != (Image *) NULL) && (image->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
else
if ((image_info != (ImageInfo *) NULL) &&
(image_info->debug != MagickFalse))
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-images"");
*value='\0';           
string=(char *) NULL;  
switch (*property)
{
case 'b':
{
if (LocaleCompare(""basename"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
GetPathComponent(image->magick_filename,BasePath,value);
if (*value == '\0')
string="""";
break;
}
if (LocaleCompare(""bit-depth"",property) == 0)
{
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetImageDepth(image,exception));
break;
}
break;
}
case 'c':
{
if (LocaleCompare(""channels"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%s"",
CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
image->colorspace));
LocaleLower(value);
if( image->alpha_trait != UndefinedPixelTrait )
(void) ConcatenateMagickString(value,""a"",MagickPathExtent);
break;
}
if (LocaleCompare(""colorspace"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
image->colorspace);
break;
}
if (LocaleCompare(""compose"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)
image->compose);
break;
}
if (LocaleCompare(""compression"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)
image->compression);
break;
}
if (LocaleCompare(""copyright"",property) == 0)
{
(void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);
break;
}
break;
}
case 'd':
{
if (LocaleCompare(""depth"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->depth);
break;
}
if (LocaleCompare(""directory"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
GetPathComponent(image->magick_filename,HeadPath,value);
if (*value == '\0')
string="""";
break;
}
break;
}
case 'e':
{
if (LocaleCompare(""entropy"",property) == 0)
{
double
entropy;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageEntropy(image,&entropy,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),entropy);
break;
}
if (LocaleCompare(""extension"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
GetPathComponent(image->magick_filename,ExtensionPath,value);
if (*value == '\0')
string="""";
break;
}
break;
}
case 'g':
{
if (LocaleCompare(""gamma"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),image->gamma);
break;
}
break;
}
case 'h':
{
if (LocaleCompare(""height"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
image->magick_rows != 0 ? (double) image->magick_rows : 256.0);
break;
}
break;
}
case 'i':
{
if (LocaleCompare(""input"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=image->filename;
break;
}
if (LocaleCompare(""interlace"",property) == 0)
{
string=CommandOptionToMnemonic(MagickInterlaceOptions,(ssize_t)
image->interlace);
break;
}
break;
}
case 'k':
{
if (LocaleCompare(""kurtosis"",property) == 0)
{
double
kurtosis,
skewness;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),kurtosis);
break;
}
break;
}
case 'm':
{
if (LocaleCompare(""magick"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=image->magick;
break;
}
if ((LocaleCompare(""maxima"",property) == 0) ||
(LocaleCompare(""max"",property) == 0))
{
double
maximum,
minimum;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageRange(image,&minimum,&maximum,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),maximum);
break;
}
if (LocaleCompare(""mean"",property) == 0)
{
double
mean,
standard_deviation;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageMean(image,&mean,&standard_deviation,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),mean);
break;
}
if ((LocaleCompare(""minima"",property) == 0) ||
(LocaleCompare(""min"",property) == 0))
{
double
maximum,
minimum;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageRange(image,&minimum,&maximum,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),minimum);
break;
}
break;
}
case 'o':
{
if (LocaleCompare(""opaque"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)
IsImageOpaque(image,exception));
break;
}
if (LocaleCompare(""orientation"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)
image->orientation);
break;
}
if (LocaleCompare(""output"",property) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
(void) CopyMagickString(value,image_info->filename,MagickPathExtent);
break;
}
break;
}
case 'p':
{
if (LocaleCompare(""page"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",
(double) image->page.width,(double) image->page.height);
break;
}
#if defined(MAGICKCORE_LCMS_DELEGATE)
if (LocaleCompare(""profile:icc"",property) == 0 ||
LocaleCompare(""profile:icm"",property) == 0)
{
#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)
#define cmsUInt32Number  DWORD
#endif
const StringInfo
*profile;
cmsHPROFILE
icc_profile;
profile=GetImageProfile(image,property+8);
if (profile == (StringInfo *) NULL)
break;
icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),
(cmsUInt32Number) GetStringInfoLength(profile));
if (icc_profile != (cmsHPROFILE *) NULL)
{
#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)
string=cmsTakeProductName(icc_profile);
#else
(void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,
""en"",""US"",value,MagickPathExtent);
#endif
(void) cmsCloseProfile(icc_profile);
}
}
#endif
if (LocaleCompare(""profiles"",property) == 0)
{
const char
*name;
ResetImageProfileIterator(image);
name=GetNextImageProfile(image);
if (name != (char *) NULL)
{
(void) CopyMagickString(value,name,MagickPathExtent);
name=GetNextImageProfile(image);
while (name != (char *) NULL)
{
ConcatenateMagickString(value,"","",MagickPathExtent);
ConcatenateMagickString(value,name,MagickPathExtent);
name=GetNextImageProfile(image);
}
}
break;
}
break;
}
case 'q':
{
if (LocaleCompare(""quality"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->quality);
break;
}
break;
}
case 'r':
{
if (LocaleCompare(""resolution.x"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%g"",
image->resolution.x);
break;
}
if (LocaleCompare(""resolution.y"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%g"",
image->resolution.y);
break;
}
break;
}
case 's':
{
if (LocaleCompare(""scene"",property) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
if (image_info->number_scenes != 0)
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image_info->scene);
else {
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
image->scene);
}
break;
}
if (LocaleCompare(""scenes"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
GetImageListLength(image));
break;
}
if (LocaleCompare(""size"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatMagickSize(GetBlobSize(image),MagickFalse,""B"",
MagickPathExtent,value);
break;
}
if (LocaleCompare(""skewness"",property) == 0)
{
double
kurtosis,
skewness;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),skewness);
break;
}
if (LocaleCompare(""standard-deviation"",property) == 0)
{
double
mean,
standard_deviation;
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) GetImageMean(image,&mean,&standard_deviation,exception);
(void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
GetMagickPrecision(),standard_deviation);
break;
}
break;
}
case 't':
{
if (LocaleCompare(""type"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)
IdentifyImageType(image,exception));
break;
}
break;
}
case 'u':
{
if (LocaleCompare(""unique"",property) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
string=image_info->unique;
break;
}
if (LocaleCompare(""units"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)
image->units);
break;
}
break;
}
case 'v':
{
if (LocaleCompare(""version"",property) == 0)
{
string=GetMagickVersion((size_t *) NULL);
break;
}
break;
}
case 'w':
{
if (LocaleCompare(""width"",property) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",property);
(void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
(image->magick_columns != 0 ? image->magick_columns : 256));
break;
}
break;
}
}
if (string != (char *) NULL)
return(string);
if (*value != '\0')
{
if (image != (Image *) NULL)
{
(void) SetImageArtifact(image,""get-property"",value);
return(GetImageArtifact(image,""get-property""));
}
else
{
(void) SetImageOption(image_info,""get-property"",value);
return(GetImageOption(image_info,""get-property""));
}
}
return((char *) NULL);
}","MagickExport const VAR_0 *GetMagickProperty(ImageInfo *VAR_1,
Image *VAR_2,const char *VAR_3,ExceptionInfo *VAR_4)
{
char
VAR_5[VAR_6];
const char
*VAR_7;
assert(VAR_3[0] != '\0');
assert(VAR_2 != (Image *) NULL || VAR_1 != (ImageInfo *) NULL );
if (VAR_3[1] == '\0')  
return(GetMagickPropertyLetter(VAR_1,VAR_2,*VAR_3,VAR_4));
if ((VAR_2 != (Image *) NULL) && (VAR_2->debug != VAR_8))
(void) LogMagickEvent(VAR_9,GetMagickModule(),""%s"",VAR_2->filename);
else
if ((VAR_1 != (ImageInfo *) NULL) &&
(VAR_1->debug != VAR_8))
(void) LogMagickEvent(VAR_9,GetMagickModule(),""%s"",""no-images"");
*VAR_5='\0';           
VAR_7=(char *) NULL;  
switch (*VAR_3)
{
case 'b':
{
if (LocaleCompare(""basename"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
GetPathComponent(VAR_2->magick_filename,VAR_10,VAR_5);
if (*VAR_5 == '\0')
VAR_7="""";
break;
}
if (LocaleCompare(""bit-depth"",VAR_3) == 0)
{
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
GetImageDepth(VAR_2,VAR_4));
break;
}
break;
}
case 'c':
{
if (LocaleCompare(""channels"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%s"",
CommandOptionToMnemonic(VAR_11,(ssize_t)
VAR_2->colorspace));
LocaleLower(VAR_5);
if( VAR_2->alpha_trait != VAR_12 )
(void) ConcatenateMagickString(VAR_5,""a"",VAR_6);
break;
}
if (LocaleCompare(""colorspace"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_11,(ssize_t)
VAR_2->colorspace);
break;
}
if (LocaleCompare(""compose"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_13,(ssize_t)
VAR_2->compose);
break;
}
if (LocaleCompare(""compression"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_14,(ssize_t)
VAR_2->compression);
break;
}
if (LocaleCompare(""copyright"",VAR_3) == 0)
{
(void) CopyMagickString(VAR_5,GetMagickCopyright(),VAR_6);
break;
}
break;
}
case 'd':
{
if (LocaleCompare(""depth"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
VAR_2->depth);
break;
}
if (LocaleCompare(""directory"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
GetPathComponent(VAR_2->magick_filename,VAR_15,VAR_5);
if (*VAR_5 == '\0')
VAR_7="""";
break;
}
break;
}
case 'e':
{
if (LocaleCompare(""entropy"",VAR_3) == 0)
{
double
VAR_16;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageEntropy(VAR_2,&VAR_16,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_16);
break;
}
if (LocaleCompare(""extension"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
GetPathComponent(VAR_2->magick_filename,VAR_17,VAR_5);
if (*VAR_5 == '\0')
VAR_7="""";
break;
}
break;
}
case 'g':
{
if (LocaleCompare(""gamma"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_2->gamma);
break;
}
break;
}
case 'h':
{
if (LocaleCompare(""height"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",
VAR_2->magick_rows != 0 ? (double) VAR_2->magick_rows : 256.0);
break;
}
break;
}
case 'i':
{
if (LocaleCompare(""input"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=VAR_2->filename;
break;
}
if (LocaleCompare(""interlace"",VAR_3) == 0)
{
VAR_7=CommandOptionToMnemonic(VAR_18,(ssize_t)
VAR_2->interlace);
break;
}
break;
}
case 'k':
{
if (LocaleCompare(""kurtosis"",VAR_3) == 0)
{
double
VAR_19,
VAR_20;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageKurtosis(VAR_2,&VAR_19,&VAR_20,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_19);
break;
}
break;
}
case 'm':
{
if (LocaleCompare(""magick"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=VAR_2->magick;
break;
}
if ((LocaleCompare(""maxima"",VAR_3) == 0) ||
(LocaleCompare(""max"",VAR_3) == 0))
{
double
VAR_21,
VAR_22;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageRange(VAR_2,&VAR_22,&VAR_21,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_21);
break;
}
if (LocaleCompare(""mean"",VAR_3) == 0)
{
double
VAR_23,
VAR_24;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageMean(VAR_2,&VAR_23,&VAR_24,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_23);
break;
}
if ((LocaleCompare(""minima"",VAR_3) == 0) ||
(LocaleCompare(""min"",VAR_3) == 0))
{
double
VAR_21,
VAR_22;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageRange(VAR_2,&VAR_22,&VAR_21,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_22);
break;
}
break;
}
case 'o':
{
if (LocaleCompare(""opaque"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_25,(ssize_t)
IsImageOpaque(VAR_2,VAR_4));
break;
}
if (LocaleCompare(""orientation"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_26,(ssize_t)
VAR_2->orientation);
break;
}
if (LocaleCompare(""output"",VAR_3) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
(void) CopyMagickString(VAR_5,VAR_1->filename,VAR_6);
break;
}
break;
}
case 'p':
{
if (LocaleCompare(""page"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20gx%.20g"",
(double) VAR_2->page.width,(double) VAR_2->page.height);
break;
}
#if defined(VAR_27)
if (LocaleCompare(""profile:icc"",VAR_3) == 0 ||
LocaleCompare(""profile:icm"",VAR_3) == 0)
{
#if !defined(VAR_28) || (VAR_28 < 2000)
#define VAR_29  DWORD
#endif
const StringInfo
*VAR_30;
cmsHPROFILE
VAR_31;
VAR_30=GetImageProfile(VAR_2,VAR_3+8);
if (VAR_30 == (StringInfo *) NULL)
break;
VAR_31=cmsOpenProfileFromMem(GetStringInfoDatum(VAR_30),
(cmsUInt32Number) GetStringInfoLength(VAR_30));
if (VAR_31 != (cmsHPROFILE *) NULL)
{
#if defined(VAR_28) && (VAR_28 < 2000)
VAR_7=cmsTakeProductName(VAR_31);
#else
(void) cmsGetProfileInfoASCII(VAR_31,VAR_32,
""en"",""US"",VAR_5,VAR_6);
#endif
(void) cmsCloseProfile(VAR_31);
}
}
#endif
if (LocaleCompare(""profiles"",VAR_3) == 0)
{
const char
*VAR_33;
ResetImageProfileIterator(VAR_2);
VAR_33=GetNextImageProfile(VAR_2);
if (VAR_33 != (char *) NULL)
{
(void) CopyMagickString(VAR_5,VAR_33,VAR_6);
VAR_33=GetNextImageProfile(VAR_2);
while (VAR_33 != (char *) NULL)
{
ConcatenateMagickString(VAR_5,"","",VAR_6);
ConcatenateMagickString(VAR_5,VAR_33,VAR_6);
VAR_33=GetNextImageProfile(VAR_2);
}
}
break;
}
break;
}
case 'q':
{
if (LocaleCompare(""quality"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
VAR_2->quality);
break;
}
break;
}
case 'r':
{
if (LocaleCompare(""resolution.x"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%g"",
VAR_2->resolution.x);
break;
}
if (LocaleCompare(""resolution.y"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%g"",
VAR_2->resolution.y);
break;
}
break;
}
case 's':
{
if (LocaleCompare(""scene"",VAR_3) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
if (VAR_1->number_scenes != 0)
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
VAR_1->scene);
else {
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
VAR_2->scene);
}
break;
}
if (LocaleCompare(""scenes"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
GetImageListLength(VAR_2));
break;
}
if (LocaleCompare(""size"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatMagickSize(GetBlobSize(VAR_2),VAR_8,""B"",
VAR_6,VAR_5);
break;
}
if (LocaleCompare(""skewness"",VAR_3) == 0)
{
double
VAR_19,
VAR_20;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageKurtosis(VAR_2,&VAR_19,&VAR_20,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_20);
break;
}
if (LocaleCompare(""standard-deviation"",VAR_3) == 0)
{
double
VAR_23,
VAR_24;
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) GetImageMean(VAR_2,&VAR_23,&VAR_24,VAR_4);
(void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
GetMagickPrecision(),VAR_24);
break;
}
break;
}
case 't':
{
if (LocaleCompare(""type"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_34,(ssize_t)
IdentifyImageType(VAR_2,VAR_4));
break;
}
break;
}
case 'u':
{
if (LocaleCompare(""unique"",VAR_3) == 0)
{
WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=VAR_1->unique;
break;
}
if (LocaleCompare(""units"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
VAR_7=CommandOptionToMnemonic(VAR_35,(ssize_t)
VAR_2->units);
break;
}
break;
}
case 'v':
{
if (LocaleCompare(""version"",VAR_3) == 0)
{
VAR_7=GetMagickVersion((size_t *) NULL);
break;
}
break;
}
case 'w':
{
if (LocaleCompare(""width"",VAR_3) == 0)
{
WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
(void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
(VAR_2->magick_columns != 0 ? VAR_2->magick_columns : 256));
break;
}
break;
}
}
if (VAR_7 != (char *) NULL)
return(VAR_7);
if (*VAR_5 != '\0')
{
if (VAR_2 != (Image *) NULL)
{
(void) SetImageArtifact(VAR_2,""get-property"",VAR_5);
return(GetImageArtifact(VAR_2,""get-property""));
}
else
{
(void) SetImageOption(VAR_1,""get-property"",VAR_5);
return(GetImageOption(VAR_1,""get-property""));
}
}
return((char *) NULL);
}",,"MagickExport const char *GetMagickProperty(ImageInfo *image_info,
  Image *image,const char *property,ExceptionInfo *exception)
{
  char
    value[MagickPathExtent];

  const char
    *string;

  assert(property[0] != '\0');
  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );
  if (property[1] == '\0')  /* single letter property request */
    return(GetMagickPropertyLetter(image_info,image,*property,exception));
  if ((image != (Image *) NULL) && (image->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  else
    if ((image_info != (ImageInfo *) NULL) &&
        (image_info->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",""no-images"");
  *value='\0';           /* formated string */
  string=(char *) NULL;  /* constant string reference */
  switch (*property)
  {
    case 'b':
    {
      if (LocaleCompare(""basename"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          GetPathComponent(image->magick_filename,BasePath,value);
          if (*value == '\0')
            string="""";
          break;
        }
      if (LocaleCompare(""bit-depth"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
            GetImageDepth(image,exception));
          break;
        }
      break;
    }
    case 'c':
    {
      if (LocaleCompare(""channels"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          /* FUTURE: return actual image channels */
          (void) FormatLocaleString(value,MagickPathExtent,""%s"",
            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
            image->colorspace));
          LocaleLower(value);
          if( image->alpha_trait != UndefinedPixelTrait )
            (void) ConcatenateMagickString(value,""a"",MagickPathExtent);
          break;
        }
      if (LocaleCompare(""colorspace"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
            image->colorspace);
          break;
        }
      if (LocaleCompare(""compose"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)
            image->compose);
          break;
        }
      if (LocaleCompare(""compression"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)
            image->compression);
          break;
        }
      if (LocaleCompare(""copyright"",property) == 0)
        {
          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);
          break;
        }
      break;
    }
    case 'd':
    {
      if (LocaleCompare(""depth"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
            image->depth);
          break;
        }
      if (LocaleCompare(""directory"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          GetPathComponent(image->magick_filename,HeadPath,value);
          if (*value == '\0')
            string="""";
          break;
        }
      break;
    }
    case 'e':
    {
      if (LocaleCompare(""entropy"",property) == 0)
        {
          double
            entropy;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageEntropy(image,&entropy,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),entropy);
          break;
        }
      if (LocaleCompare(""extension"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          GetPathComponent(image->magick_filename,ExtensionPath,value);
          if (*value == '\0')
            string="""";
          break;
        }
      break;
    }
    case 'g':
    {
      if (LocaleCompare(""gamma"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),image->gamma);
          break;
        }
      break;
    }
    case 'h':
    {
      if (LocaleCompare(""height"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",
            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);
          break;
        }
      break;
    }
    case 'i':
    {
      if (LocaleCompare(""input"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=image->filename;
          break;
        }
      if (LocaleCompare(""interlace"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickInterlaceOptions,(ssize_t)
            image->interlace);
          break;
        }
      break;
    }
    case 'k':
    {
      if (LocaleCompare(""kurtosis"",property) == 0)
        {
          double
            kurtosis,
            skewness;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),kurtosis);
          break;
        }
      break;
    }
    case 'm':
    {
      if (LocaleCompare(""magick"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=image->magick;
          break;
        }
      if ((LocaleCompare(""maxima"",property) == 0) ||
          (LocaleCompare(""max"",property) == 0))
        {
          double
            maximum,
            minimum;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageRange(image,&minimum,&maximum,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),maximum);
          break;
        }
      if (LocaleCompare(""mean"",property) == 0)
        {
          double
            mean,
            standard_deviation;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageMean(image,&mean,&standard_deviation,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),mean);
          break;
        }
      if ((LocaleCompare(""minima"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0))
        {
          double
            maximum,
            minimum;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageRange(image,&minimum,&maximum,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),minimum);
          break;
        }
      break;
    }
    case 'o':
    {
      if (LocaleCompare(""opaque"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)
            IsImageOpaque(image,exception));
          break;
        }
      if (LocaleCompare(""orientation"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)
            image->orientation);
          break;
        }
      if (LocaleCompare(""output"",property) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);
          break;
        }
      break;
    }
    case 'p':
    {
      if (LocaleCompare(""page"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20gx%.20g"",
            (double) image->page.width,(double) image->page.height);
          break;
        }
#if defined(MAGICKCORE_LCMS_DELEGATE)
      if (LocaleCompare(""profile:icc"",property) == 0 ||
          LocaleCompare(""profile:icm"",property) == 0)
        {
#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)
#define cmsUInt32Number  DWORD
#endif

          const StringInfo
            *profile;

          cmsHPROFILE
            icc_profile;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          profile=GetImageProfile(image,property+8);
          if (profile == (StringInfo *) NULL)
            break;
          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),
            (cmsUInt32Number) GetStringInfoLength(profile));
          if (icc_profile != (cmsHPROFILE *) NULL)
            {
#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)
              string=cmsTakeProductName(icc_profile);
#else
              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,
                ""en"",""US"",value,MagickPathExtent);
#endif
              (void) cmsCloseProfile(icc_profile);
            }
      }
#endif
      if (LocaleCompare(""profiles"",property) == 0)
        {
          const char
            *name;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          ResetImageProfileIterator(image);
          name=GetNextImageProfile(image);
          if (name != (char *) NULL)
            {
              (void) CopyMagickString(value,name,MagickPathExtent);
              name=GetNextImageProfile(image);
              while (name != (char *) NULL)
              {
                ConcatenateMagickString(value,"","",MagickPathExtent);
                ConcatenateMagickString(value,name,MagickPathExtent);
                name=GetNextImageProfile(image);
              }
            }
          break;
        }
      break;
    }
    case 'q':
    {
      if (LocaleCompare(""quality"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
            image->quality);
          break;
        }
      break;
    }
    case 'r':
    {
      if (LocaleCompare(""resolution.x"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%g"",
            image->resolution.x);
          break;
        }
      if (LocaleCompare(""resolution.y"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%g"",
            image->resolution.y);
          break;
        }
      break;
    }
    case 's':
    {
      if (LocaleCompare(""scene"",property) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
          if (image_info->number_scenes != 0)
            (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
              image_info->scene);
          else {
            WarnNoImageReturn(""\""%%[%s]\"""",property);
            (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
              image->scene);
          }
          break;
        }
      if (LocaleCompare(""scenes"",property) == 0)
        {
          /* FUTURE: equivelent to %n? */
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
            GetImageListLength(image));
          break;
        }
      if (LocaleCompare(""size"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,""B"",
            MagickPathExtent,value);
          break;
        }
      if (LocaleCompare(""skewness"",property) == 0)
        {
          double
            kurtosis,
            skewness;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),skewness);
          break;
        }
      if (LocaleCompare(""standard-deviation"",property) == 0)
        {
          double
            mean,
            standard_deviation;

          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) GetImageMean(image,&mean,&standard_deviation,exception);
          (void) FormatLocaleString(value,MagickPathExtent,""%.*g"",
            GetMagickPrecision(),standard_deviation);
          break;
        }
      break;
    }
    case 't':
    {
      if (LocaleCompare(""type"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)
            IdentifyImageType(image,exception));
          break;
        }
       break;
    }
    case 'u':
    {
      if (LocaleCompare(""unique"",property) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",property);
          string=image_info->unique;
          break;
        }
      if (LocaleCompare(""units"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)
            image->units);
          break;
        }
      break;
    }
    case 'v':
    {
      if (LocaleCompare(""version"",property) == 0)
        {
          string=GetMagickVersion((size_t *) NULL);
          break;
        }
      break;
    }
    case 'w':
    {
      if (LocaleCompare(""width"",property) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",property);
          (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
            (image->magick_columns != 0 ? image->magick_columns : 256));
          break;
        }
      break;
    }
  }
  if (string != (char *) NULL)
    return(string);
  if (*value != '\0')
    {
      /*
        Create a cloned copy of result, that will get cleaned up, eventually.
      */
      if (image != (Image *) NULL)
        {
          (void) SetImageArtifact(image,""get-property"",value);
          return(GetImageArtifact(image,""get-property""));
        }
      else
        {
          (void) SetImageOption(image_info,""get-property"",value);
          return(GetImageOption(image_info,""get-property""));
        }
    }
  return((char *) NULL);
}","MagickExport const VAR_0 *GetMagickProperty(ImageInfo *VAR_1,
  Image *VAR_2,const char *VAR_3,ExceptionInfo *VAR_4)
{
  char
    VAR_5[VAR_6];

  const char
    *VAR_7;

  assert(VAR_3[0] != '\0');
  assert(VAR_2 != (Image *) NULL || VAR_1 != (ImageInfo *) NULL );
  if (VAR_3[1] == '\0')  /* COMMENT_0 */
    return(GetMagickPropertyLetter(VAR_1,VAR_2,*VAR_3,VAR_4));
  if ((VAR_2 != (Image *) NULL) && (VAR_2->debug != VAR_8))
    (void) LogMagickEvent(VAR_9,GetMagickModule(),""%s"",VAR_2->filename);
  else
    if ((VAR_1 != (ImageInfo *) NULL) &&
        (VAR_1->debug != VAR_8))
    (void) LogMagickEvent(VAR_9,GetMagickModule(),""%s"",""no-images"");
  *VAR_5='\0';           /* COMMENT_1 */
  VAR_7=(char *) NULL;  /* COMMENT_2 */
  switch (*VAR_3)
  {
    case 'b':
    {
      if (LocaleCompare(""basename"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          GetPathComponent(VAR_2->magick_filename,VAR_10,VAR_5);
          if (*VAR_5 == '\0')
            VAR_7="""";
          break;
        }
      if (LocaleCompare(""bit-depth"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
            GetImageDepth(VAR_2,VAR_4));
          break;
        }
      break;
    }
    case 'c':
    {
      if (LocaleCompare(""channels"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          /* COMMENT_3 */
          (void) FormatLocaleString(VAR_5,VAR_6,""%s"",
            CommandOptionToMnemonic(VAR_11,(ssize_t)
            VAR_2->colorspace));
          LocaleLower(VAR_5);
          if( VAR_2->alpha_trait != VAR_12 )
            (void) ConcatenateMagickString(VAR_5,""a"",VAR_6);
          break;
        }
      if (LocaleCompare(""colorspace"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_11,(ssize_t)
            VAR_2->colorspace);
          break;
        }
      if (LocaleCompare(""compose"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_13,(ssize_t)
            VAR_2->compose);
          break;
        }
      if (LocaleCompare(""compression"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_14,(ssize_t)
            VAR_2->compression);
          break;
        }
      if (LocaleCompare(""copyright"",VAR_3) == 0)
        {
          (void) CopyMagickString(VAR_5,GetMagickCopyright(),VAR_6);
          break;
        }
      break;
    }
    case 'd':
    {
      if (LocaleCompare(""depth"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
            VAR_2->depth);
          break;
        }
      if (LocaleCompare(""directory"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          GetPathComponent(VAR_2->magick_filename,VAR_15,VAR_5);
          if (*VAR_5 == '\0')
            VAR_7="""";
          break;
        }
      break;
    }
    case 'e':
    {
      if (LocaleCompare(""entropy"",VAR_3) == 0)
        {
          double
            VAR_16;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageEntropy(VAR_2,&VAR_16,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_16);
          break;
        }
      if (LocaleCompare(""extension"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          GetPathComponent(VAR_2->magick_filename,VAR_17,VAR_5);
          if (*VAR_5 == '\0')
            VAR_7="""";
          break;
        }
      break;
    }
    case 'g':
    {
      if (LocaleCompare(""gamma"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_2->gamma);
          break;
        }
      break;
    }
    case 'h':
    {
      if (LocaleCompare(""height"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",
            VAR_2->magick_rows != 0 ? (double) VAR_2->magick_rows : 256.0);
          break;
        }
      break;
    }
    case 'i':
    {
      if (LocaleCompare(""input"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=VAR_2->filename;
          break;
        }
      if (LocaleCompare(""interlace"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_18,(ssize_t)
            VAR_2->interlace);
          break;
        }
      break;
    }
    case 'k':
    {
      if (LocaleCompare(""kurtosis"",VAR_3) == 0)
        {
          double
            VAR_19,
            VAR_20;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageKurtosis(VAR_2,&VAR_19,&VAR_20,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_19);
          break;
        }
      break;
    }
    case 'm':
    {
      if (LocaleCompare(""magick"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=VAR_2->magick;
          break;
        }
      if ((LocaleCompare(""maxima"",VAR_3) == 0) ||
          (LocaleCompare(""max"",VAR_3) == 0))
        {
          double
            VAR_21,
            VAR_22;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageRange(VAR_2,&VAR_22,&VAR_21,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_21);
          break;
        }
      if (LocaleCompare(""mean"",VAR_3) == 0)
        {
          double
            VAR_23,
            VAR_24;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageMean(VAR_2,&VAR_23,&VAR_24,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_23);
          break;
        }
      if ((LocaleCompare(""minima"",VAR_3) == 0) ||
          (LocaleCompare(""min"",VAR_3) == 0))
        {
          double
            VAR_21,
            VAR_22;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageRange(VAR_2,&VAR_22,&VAR_21,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_22);
          break;
        }
      break;
    }
    case 'o':
    {
      if (LocaleCompare(""opaque"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_25,(ssize_t)
            IsImageOpaque(VAR_2,VAR_4));
          break;
        }
      if (LocaleCompare(""orientation"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_26,(ssize_t)
            VAR_2->orientation);
          break;
        }
      if (LocaleCompare(""output"",VAR_3) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
          (void) CopyMagickString(VAR_5,VAR_1->filename,VAR_6);
          break;
        }
      break;
    }
    case 'p':
    {
      if (LocaleCompare(""page"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20gx%.20g"",
            (double) VAR_2->page.width,(double) VAR_2->page.height);
          break;
        }
#if defined(VAR_27)
      if (LocaleCompare(""profile:icc"",VAR_3) == 0 ||
          LocaleCompare(""profile:icm"",VAR_3) == 0)
        {
#if !defined(VAR_28) || (VAR_28 < 2000)
#define VAR_29  DWORD
#endif

          const StringInfo
            *VAR_30;

          cmsHPROFILE
            VAR_31;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_30=GetImageProfile(VAR_2,VAR_3+8);
          if (VAR_30 == (StringInfo *) NULL)
            break;
          VAR_31=cmsOpenProfileFromMem(GetStringInfoDatum(VAR_30),
            (cmsUInt32Number) GetStringInfoLength(VAR_30));
          if (VAR_31 != (cmsHPROFILE *) NULL)
            {
#if defined(VAR_28) && (VAR_28 < 2000)
              VAR_7=cmsTakeProductName(VAR_31);
#else
              (void) cmsGetProfileInfoASCII(VAR_31,VAR_32,
                ""en"",""US"",VAR_5,VAR_6);
#endif
              (void) cmsCloseProfile(VAR_31);
            }
      }
#endif
      if (LocaleCompare(""profiles"",VAR_3) == 0)
        {
          const char
            *VAR_33;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          ResetImageProfileIterator(VAR_2);
          VAR_33=GetNextImageProfile(VAR_2);
          if (VAR_33 != (char *) NULL)
            {
              (void) CopyMagickString(VAR_5,VAR_33,VAR_6);
              VAR_33=GetNextImageProfile(VAR_2);
              while (VAR_33 != (char *) NULL)
              {
                ConcatenateMagickString(VAR_5,"","",VAR_6);
                ConcatenateMagickString(VAR_5,VAR_33,VAR_6);
                VAR_33=GetNextImageProfile(VAR_2);
              }
            }
          break;
        }
      break;
    }
    case 'q':
    {
      if (LocaleCompare(""quality"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
            VAR_2->quality);
          break;
        }
      break;
    }
    case 'r':
    {
      if (LocaleCompare(""resolution.x"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%g"",
            VAR_2->resolution.x);
          break;
        }
      if (LocaleCompare(""resolution.y"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%g"",
            VAR_2->resolution.y);
          break;
        }
      break;
    }
    case 's':
    {
      if (LocaleCompare(""scene"",VAR_3) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
          if (VAR_1->number_scenes != 0)
            (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
              VAR_1->scene);
          else {
            WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
            (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
              VAR_2->scene);
          }
          break;
        }
      if (LocaleCompare(""scenes"",VAR_3) == 0)
        {
          /* COMMENT_4 */
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
            GetImageListLength(VAR_2));
          break;
        }
      if (LocaleCompare(""size"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatMagickSize(GetBlobSize(VAR_2),VAR_8,""B"",
            VAR_6,VAR_5);
          break;
        }
      if (LocaleCompare(""skewness"",VAR_3) == 0)
        {
          double
            VAR_19,
            VAR_20;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageKurtosis(VAR_2,&VAR_19,&VAR_20,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_20);
          break;
        }
      if (LocaleCompare(""standard-deviation"",VAR_3) == 0)
        {
          double
            VAR_23,
            VAR_24;

          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) GetImageMean(VAR_2,&VAR_23,&VAR_24,VAR_4);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.*g"",
            GetMagickPrecision(),VAR_24);
          break;
        }
      break;
    }
    case 't':
    {
      if (LocaleCompare(""type"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_34,(ssize_t)
            IdentifyImageType(VAR_2,VAR_4));
          break;
        }
       break;
    }
    case 'u':
    {
      if (LocaleCompare(""unique"",VAR_3) == 0)
        {
          WarnNoImageInfoReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=VAR_1->unique;
          break;
        }
      if (LocaleCompare(""units"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          VAR_7=CommandOptionToMnemonic(VAR_35,(ssize_t)
            VAR_2->units);
          break;
        }
      break;
    }
    case 'v':
    {
      if (LocaleCompare(""version"",VAR_3) == 0)
        {
          VAR_7=GetMagickVersion((size_t *) NULL);
          break;
        }
      break;
    }
    case 'w':
    {
      if (LocaleCompare(""width"",VAR_3) == 0)
        {
          WarnNoImageReturn(""\""%%[%s]\"""",VAR_3);
          (void) FormatLocaleString(VAR_5,VAR_6,""%.20g"",(double)
            (VAR_2->magick_columns != 0 ? VAR_2->magick_columns : 256));
          break;
        }
      break;
    }
  }
  if (VAR_7 != (char *) NULL)
    return(VAR_7);
  if (*VAR_5 != '\0')
    {
      /* COMMENT_5 */
                                                                             
        
      if (VAR_2 != (Image *) NULL)
        {
          (void) SetImageArtifact(VAR_2,""get-property"",VAR_5);
          return(GetImageArtifact(VAR_2,""get-property""));
        }
      else
        {
          (void) SetImageOption(VAR_1,""get-property"",VAR_5);
          return(GetImageOption(VAR_1,""get-property""));
        }
    }
  return((char *) NULL);
}",,"--- func_before
+++ func_after
@@ -33,6 +33,7 @@
         }
       if (LocaleCompare(""bit-depth"",property) == 0)
         {
+          WarnNoImageReturn(""\""%%[%s]\"""",property);
           (void) FormatLocaleString(value,MagickPathExtent,""%.20g"",(double)
             GetImageDepth(image,exception));
           break;
@@ -155,6 +156,7 @@
         }
       if (LocaleCompare(""interlace"",property) == 0)
         {
+          WarnNoImageReturn(""\""%%[%s]\"""",property);
           string=CommandOptionToMnemonic(MagickInterlaceOptions,(ssize_t)
             image->interlace);
           break;
@@ -272,6 +274,7 @@
           cmsHPROFILE
             icc_profile;
 
+          WarnNoImageReturn(""\""%%[%s]\"""",property);
           profile=GetImageProfile(image,property+8);
           if (profile == (StringInfo *) NULL)
             break;
@@ -294,6 +297,7 @@
           const char
             *name;
 
+          WarnNoImageReturn(""\""%%[%s]\"""",property);
           ResetImageProfileIterator(image);
           name=GetNextImageProfile(image);
           if (name != (char *) NULL)","{'deleted_lines': [], 'added_lines': ['          WarnNoImageReturn(""\\""%%[%s]\\"""",property);', '          WarnNoImageReturn(""\\""%%[%s]\\"""",property);', '          WarnNoImageReturn(""\\""%%[%s]\\"""",property);', '          WarnNoImageReturn(""\\""%%[%s]\\"""",property);']}",True,"In ImageMagick before 7.0.8-8, a NULL pointer dereference exists in the GetMagickProperty function in MagickCore/property.c.",9.8,CRITICAL,3,valid,2018-07-23T18:34:05Z,2
CVE-2018-1000636,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Fix for null pointer dereference in jmem_heap_free_block

Fixes #2435.

JerryScript-DCO-1.0-Signed-off-by: Daniel Balla dballa@inf.u-szeged.hu",a4ee88ce3f30126a456d3f261014868385ab2fa9,https://github.com/jerryscript-project/jerryscript/commit/a4ee88ce3f30126a456d3f261014868385ab2fa9,jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c,ecma_builtin_typedarray_prototype_filter,"static ecma_value_t
ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, 
ecma_value_t cb_func_val, 
ecma_value_t cb_this_arg) 
{
if (!ecma_is_typedarray (this_arg))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Argument 'this' is not a TypedArray.""));
}
if (!ecma_op_is_callable (cb_func_val))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Callback function is not callable.""));
}
ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
uint32_t len = ecma_typedarray_get_length (obj_p);
lit_utf8_byte_t *buffer_p = ecma_typedarray_get_buffer (obj_p);
uint8_t shift = ecma_typedarray_get_element_size_shift (obj_p);
uint8_t element_size = (uint8_t) (1 << shift);
ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
ecma_value_t ret_value = ECMA_VALUE_EMPTY;
JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, len * element_size, lit_utf8_byte_t);
lit_utf8_byte_t *pass_value_p = pass_value_list_p;
for (uint32_t index = 0; index < len && ecma_is_value_empty (ret_value); index++)
{
ecma_value_t current_index = ecma_make_uint32_value (index);
ecma_value_t get_value = ecma_op_typedarray_get_index_prop (obj_p, index);
JERRY_ASSERT (ecma_is_value_number (get_value));
ecma_value_t call_args[] = { get_value, current_index, this_arg };
ECMA_TRY_CATCH (call_value, ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3), ret_value);
if (ecma_op_to_boolean (call_value))
{
memcpy (pass_value_p, buffer_p, element_size);
pass_value_p += element_size;
}
buffer_p += element_size;
ECMA_FINALIZE (call_value);
ecma_fast_free_value (current_index);
ecma_fast_free_value (get_value);
}
if (ecma_is_value_empty (ret_value))
{
uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> shift);
ret_value = ecma_op_create_typedarray_with_type_and_length (obj_p, pass_num);
if (!ECMA_IS_VALUE_ERROR (ret_value))
{
obj_p = ecma_get_object_from_value (ret_value);
JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);
memcpy (ecma_typedarray_get_buffer (obj_p),
pass_value_list_p,
(size_t) (pass_value_p - pass_value_list_p));
}
}
JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);
return ret_value;
}","static ecma_value_t
ecma_builtin_typedarray_prototype_filter (ecma_value_t VAR_0, 
ecma_value_t VAR_1, 
ecma_value_t VAR_2) 
{
if (!ecma_is_typedarray (VAR_0))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Argument 'this' is not a TypedArray.""));
}
if (!ecma_op_is_callable (VAR_1))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Callback function is not callable.""));
}
ecma_object_t *VAR_3 = ecma_get_object_from_value (VAR_0);
uint32_t VAR_4 = ecma_typedarray_get_length (VAR_3);
lit_utf8_byte_t *VAR_5 = ecma_typedarray_get_buffer (VAR_3);
uint8_t VAR_6 = ecma_typedarray_get_element_size_shift (VAR_3);
uint8_t VAR_7 = (uint8_t) (1 << VAR_6);
ecma_object_t *VAR_8 = ecma_get_object_from_value (VAR_1);
ecma_value_t VAR_9 = VAR_10;
JMEM_DEFINE_LOCAL_ARRAY (VAR_11, VAR_4 * VAR_7, lit_utf8_byte_t);
lit_utf8_byte_t *VAR_12 = VAR_11;
for (uint32_t VAR_13 = 0; VAR_13 < VAR_4 && ecma_is_value_empty (VAR_9); VAR_13++)
{
ecma_value_t VAR_14 = ecma_make_uint32_value (VAR_13);
ecma_value_t VAR_15 = ecma_op_typedarray_get_index_prop (VAR_3, VAR_13);
JERRY_ASSERT (ecma_is_value_number (VAR_15));
ecma_value_t VAR_16[] = { VAR_15, VAR_14, VAR_0 };
ECMA_TRY_CATCH (VAR_17, ecma_op_function_call (VAR_8, VAR_2, VAR_16, 3), VAR_9);
if (ecma_op_to_boolean (VAR_17))
{
memcpy (VAR_12, VAR_5, VAR_7);
VAR_12 += VAR_7;
}
VAR_5 += VAR_7;
ECMA_FINALIZE (VAR_17);
ecma_fast_free_value (VAR_14);
ecma_fast_free_value (VAR_15);
}
if (ecma_is_value_empty (VAR_9))
{
uint32_t VAR_18 = (uint32_t) ((VAR_12 - VAR_11) >> VAR_6);
VAR_9 = ecma_op_create_typedarray_with_type_and_length (VAR_3, VAR_18);
if (!ECMA_IS_VALUE_ERROR (VAR_9))
{
VAR_3 = ecma_get_object_from_value (VAR_9);
JERRY_ASSERT (ecma_typedarray_get_offset (VAR_3) == 0);
memcpy (ecma_typedarray_get_buffer (VAR_3),
VAR_11,
(size_t) (VAR_12 - VAR_11));
}
}
JMEM_FINALIZE_LOCAL_ARRAY (VAR_11);
return VAR_9;
}",jerryscript-project/jerryscript/a4ee88ce3f30126a456d3f261014868385ab2fa9/ecma-builtin-typedarray-prototype.c/vul/before/0.json,"static ecma_value_t
ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this argument */
                                          ecma_value_t cb_func_val, /**< callback function */
                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
{
  if (!ecma_is_typedarray (this_arg))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""Argument 'this' is not a TypedArray.""));
  }

  if (!ecma_op_is_callable (cb_func_val))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""Callback function is not callable.""));
  }

  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
  uint32_t len = ecma_typedarray_get_length (obj_p);
  lit_utf8_byte_t *buffer_p = ecma_typedarray_get_buffer (obj_p);
  uint8_t shift = ecma_typedarray_get_element_size_shift (obj_p);
  uint8_t element_size = (uint8_t) (1 << shift);
  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
  ecma_value_t ret_value = ECMA_VALUE_EMPTY;

  if (len == 0)
  {
    return ecma_op_create_typedarray_with_type_and_length (obj_p, 0);
  }

  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, len * element_size, lit_utf8_byte_t);

  lit_utf8_byte_t *pass_value_p = pass_value_list_p;

  for (uint32_t index = 0; index < len && ecma_is_value_empty (ret_value); index++)
  {
    ecma_value_t current_index = ecma_make_uint32_value (index);
    ecma_value_t get_value = ecma_op_typedarray_get_index_prop (obj_p, index);

    JERRY_ASSERT (ecma_is_value_number (get_value));

    ecma_value_t call_args[] = { get_value, current_index, this_arg };

    ECMA_TRY_CATCH (call_value, ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3), ret_value);

    if (ecma_op_to_boolean (call_value))
    {
      memcpy (pass_value_p, buffer_p, element_size);
      pass_value_p += element_size;
    }

    buffer_p += element_size;

    ECMA_FINALIZE (call_value);

    ecma_fast_free_value (current_index);
    ecma_fast_free_value (get_value);
  }

  if (ecma_is_value_empty (ret_value))
  {
    uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> shift);

    ret_value = ecma_op_create_typedarray_with_type_and_length (obj_p, pass_num);

    if (!ECMA_IS_VALUE_ERROR (ret_value))
    {
      obj_p = ecma_get_object_from_value (ret_value);

      JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);

      memcpy (ecma_typedarray_get_buffer (obj_p),
              pass_value_list_p,
              (size_t) (pass_value_p - pass_value_list_p));
    }
  }

  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);

  return ret_value;
}","static ecma_value_t
ecma_builtin_typedarray_prototype_filter (ecma_value_t VAR_0, /* COMMENT_0 */
                                          ecma_value_t VAR_1, /* COMMENT_1 */
                                          ecma_value_t VAR_2) /* COMMENT_2 */
{
  if (!ecma_is_typedarray (VAR_0))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""Argument 'this' is not a TypedArray.""));
  }

  if (!ecma_op_is_callable (VAR_1))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""Callback function is not callable.""));
  }

  ecma_object_t *VAR_3 = ecma_get_object_from_value (VAR_0);
  uint32_t VAR_4 = ecma_typedarray_get_length (VAR_3);
  lit_utf8_byte_t *VAR_5 = ecma_typedarray_get_buffer (VAR_3);
  uint8_t VAR_6 = ecma_typedarray_get_element_size_shift (VAR_3);
  uint8_t VAR_7 = (uint8_t) (1 << VAR_6);
  ecma_object_t *VAR_8 = ecma_get_object_from_value (VAR_1);
  ecma_value_t VAR_9 = VAR_10;

  if (VAR_4 == 0)
  {
    return ecma_op_create_typedarray_with_type_and_length (VAR_3, 0);
  }

  JMEM_DEFINE_LOCAL_ARRAY (VAR_11, VAR_4 * VAR_7, lit_utf8_byte_t);

  lit_utf8_byte_t *VAR_12 = VAR_11;

  for (uint32_t VAR_13 = 0; VAR_13 < VAR_4 && ecma_is_value_empty (VAR_9); VAR_13++)
  {
    ecma_value_t VAR_14 = ecma_make_uint32_value (VAR_13);
    ecma_value_t VAR_15 = ecma_op_typedarray_get_index_prop (VAR_3, VAR_13);

    JERRY_ASSERT (ecma_is_value_number (VAR_15));

    ecma_value_t VAR_16[] = { VAR_15, VAR_14, VAR_0 };

    ECMA_TRY_CATCH (VAR_17, ecma_op_function_call (VAR_8, VAR_2, VAR_16, 3), VAR_9);

    if (ecma_op_to_boolean (VAR_17))
    {
      memcpy (VAR_12, VAR_5, VAR_7);
      VAR_12 += VAR_7;
    }

    VAR_5 += VAR_7;

    ECMA_FINALIZE (VAR_17);

    ecma_fast_free_value (VAR_14);
    ecma_fast_free_value (VAR_15);
  }

  if (ecma_is_value_empty (VAR_9))
  {
    uint32_t VAR_18 = (uint32_t) ((VAR_12 - VAR_11) >> VAR_6);

    VAR_9 = ecma_op_create_typedarray_with_type_and_length (VAR_3, VAR_18);

    if (!ECMA_IS_VALUE_ERROR (VAR_9))
    {
      VAR_3 = ecma_get_object_from_value (VAR_9);

      JERRY_ASSERT (ecma_typedarray_get_offset (VAR_3) == 0);

      memcpy (ecma_typedarray_get_buffer (VAR_3),
              VAR_11,
              (size_t) (VAR_12 - VAR_11));
    }
  }

  JMEM_FINALIZE_LOCAL_ARRAY (VAR_11);

  return VAR_9;
}",jerryscript-project/jerryscript/a4ee88ce3f30126a456d3f261014868385ab2fa9/ecma-builtin-typedarray-prototype.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,6 +20,11 @@
   uint8_t element_size = (uint8_t) (1 << shift);
   ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
   ecma_value_t ret_value = ECMA_VALUE_EMPTY;
+
+  if (len == 0)
+  {
+    return ecma_op_create_typedarray_with_type_and_length (obj_p, 0);
+  }
 
   JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, len * element_size, lit_utf8_byte_t);
 
@@ -56,7 +61,6 @@
 
     ret_value = ecma_op_create_typedarray_with_type_and_length (obj_p, pass_num);
 
-
     if (!ECMA_IS_VALUE_ERROR (ret_value))
     {
       obj_p = ecma_get_object_from_value (ret_value);","{'deleted_lines': [''], 'added_lines': ['', '  if (len == 0)', '  {', '    return ecma_op_create_typedarray_with_type_and_length (obj_p, 0);', '  }']}",True,JerryScript version Tested on commit f86d7459d195c8ba58479d1861b0cc726c8b3793. Analysing history it seems that the issue has been present since commit 64a340ffeb8809b2b66bbe32fd443a8b79fdd860 contains a CWE-476: NULL Pointer Dereference vulnerability in Triggering undefined behavior at jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c:598 (passing NULL to memcpy as 2nd argument) results in null pointer dereference (segfault) at jerry-core/jmem/jmem-heap.c:463 that can result in Crash due to segmentation fault. This attack appear to be exploitable via The victim must execute specially crafted javascript code. This vulnerability appears to have been fixed in after commit 87897849f6879df10e8ad68a41bf8cf507edf710.,6.5,MEDIUM,1,valid,2018-07-30T13:46:08Z,2
CVE-2018-15120,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,GNOME/pango,"Prevent an assertion with invalid Unicode sequences

Invalid Unicode sequences, such as 0x2665 0xfe0e 0xfe0f,
can trick the Emoji iter code into returning an empty
segment, which then triggers an assertion in the itemizer.

Prevent this by ensuring that we make progress.

This issue was reported by Jeffrey M.",71aaeaf020340412b8d012fe23a556c0420eda5f,https://github.com/GNOME/pango/commit/71aaeaf020340412b8d012fe23a556c0420eda5f,pango/pango-emoji.c,_pango_emoji_iter_next,"gboolean
_pango_emoji_iter_next (PangoEmojiIter *iter)
{
PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID;
if (iter->end == iter->text_end)
return FALSE;
iter->start = iter->end;
for (; iter->end < iter->text_end; iter->end = g_utf8_next_char (iter->end))
{
gunichar ch = g_utf8_get_char (iter->end);
if ((!(ch == kZeroWidthJoinerCharacter && !iter->is_emoji) &&
ch != kVariationSelector15Character &&
ch != kVariationSelector16Character &&
ch != kCombiningEnclosingCircleBackslashCharacter &&
!_pango_Is_Regional_Indicator(ch) &&
!((ch == kLeftSpeechBubbleCharacter ||
ch == kRainbowCharacter ||
ch == kMaleSignCharacter ||
ch == kFemaleSignCharacter ||
ch == kStaffOfAesculapiusCharacter) &&
!iter->is_emoji)) ||
current_emoji_type == PANGO_EMOJI_TYPE_INVALID) {
current_emoji_type = _pango_get_emoji_type (ch);
}
if (g_utf8_next_char (iter->end) < iter->text_end) 
{
gunichar peek_char = g_utf8_get_char (g_utf8_next_char (iter->end));
if (current_emoji_type ==
PANGO_EMOJI_TYPE_EMOJI_EMOJI &&
peek_char == kVariationSelector15Character) {
current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT;
}
if ((current_emoji_type ==
PANGO_EMOJI_TYPE_EMOJI_TEXT ||
_pango_Is_Emoji_Keycap_Base(ch)) &&
peek_char == kVariationSelector16Character) {
current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
}
if (_pango_Is_Emoji_Keycap_Base(ch) &&
peek_char == kCombiningEnclosingKeycapCharacter) {
current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
};
if (_pango_Is_Regional_Indicator(ch) &&
_pango_Is_Regional_Indicator(peek_char)) {
current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
}
if ((ch == kEyeCharacter ||
ch == kWavingWhiteFlagCharacter) &&
peek_char == kZeroWidthJoinerCharacter) {
current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
}
}
if (iter->is_emoji == (gboolean) 2)
iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
if (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))
{
iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
return TRUE;
}
}
iter->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
return TRUE;
}","gboolean
_pango_emoji_iter_next (PangoEmojiIter *VAR_0)
{
PangoEmojiType VAR_1 = VAR_2;
if (VAR_0->end == VAR_0->text_end)
return FALSE;
VAR_0->start = VAR_0->end;
for (; VAR_0->end < VAR_0->text_end; VAR_0->end = g_utf8_next_char (VAR_0->end))
{
gunichar VAR_3 = g_utf8_get_char (VAR_0->end);
if ((!(VAR_3 == VAR_4 && !VAR_0->is_emoji) &&
VAR_3 != VAR_5 &&
VAR_3 != VAR_6 &&
VAR_3 != VAR_7 &&
!_pango_Is_Regional_Indicator(VAR_3) &&
!((VAR_3 == VAR_8 ||
VAR_3 == VAR_9 ||
VAR_3 == VAR_10 ||
VAR_3 == VAR_11 ||
VAR_3 == VAR_12) &&
!VAR_0->is_emoji)) ||
VAR_1 == VAR_2) {
VAR_1 = _pango_get_emoji_type (VAR_3);
}
if (g_utf8_next_char (VAR_0->end) < VAR_0->text_end) 
{
gunichar VAR_13 = g_utf8_get_char (g_utf8_next_char (VAR_0->end));
if (VAR_1 ==
VAR_14 &&
VAR_13 == VAR_5) {
VAR_1 = VAR_15;
}
if ((VAR_1 ==
VAR_15 ||
_pango_Is_Emoji_Keycap_Base(VAR_3)) &&
VAR_13 == VAR_6) {
VAR_1 = VAR_14;
}
if (_pango_Is_Emoji_Keycap_Base(VAR_3) &&
VAR_13 == VAR_16) {
VAR_1 = VAR_14;
};
if (_pango_Is_Regional_Indicator(VAR_3) &&
_pango_Is_Regional_Indicator(VAR_13)) {
VAR_1 = VAR_14;
}
if ((VAR_3 == VAR_17 ||
VAR_3 == VAR_18) &&
VAR_13 == VAR_4) {
VAR_1 = VAR_14;
}
}
if (VAR_0->is_emoji == (gboolean) 2)
VAR_0->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);
if (VAR_0->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1))
{
VAR_0->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);
return TRUE;
}
}
VAR_0->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);
return TRUE;
}",GNOME/pango/71aaeaf020340412b8d012fe23a556c0420eda5f/pango-emoji.c/vul/before/0.json,"gboolean
_pango_emoji_iter_next (PangoEmojiIter *iter)
{
  PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID;

  if (iter->end == iter->text_end)
    return FALSE;

  iter->start = iter->end;

  for (; iter->end < iter->text_end; iter->end = g_utf8_next_char (iter->end))
    {
      gunichar ch = g_utf8_get_char (iter->end);

    /* Except at the beginning, ZWJ just carries over the emoji or neutral
     * text type, VS15 & VS16 we just carry over as well, since we already
     * resolved those through lookahead. Also, don't downgrade to text
     * presentation for emoji that are part of a ZWJ sequence, example
     * U+1F441 U+200D U+1F5E8, eye (text presentation) + ZWJ + left speech
     * bubble, see below. */
    if ((!(ch == kZeroWidthJoinerCharacter && !iter->is_emoji) &&
	 ch != kVariationSelector15Character &&
	 ch != kVariationSelector16Character &&
	 ch != kCombiningEnclosingCircleBackslashCharacter &&
	 !_pango_Is_Regional_Indicator(ch) &&
	 !((ch == kLeftSpeechBubbleCharacter ||
	    ch == kRainbowCharacter ||
	    ch == kMaleSignCharacter ||
	    ch == kFemaleSignCharacter ||
	    ch == kStaffOfAesculapiusCharacter) &&
	   !iter->is_emoji)) ||
	current_emoji_type == PANGO_EMOJI_TYPE_INVALID) {
      current_emoji_type = _pango_get_emoji_type (ch);
    }

    if (g_utf8_next_char (iter->end) < iter->text_end) /* Optimize. */
    {
      gunichar peek_char = g_utf8_get_char (g_utf8_next_char (iter->end));

      /* Variation Selectors */
      if (current_emoji_type ==
	      PANGO_EMOJI_TYPE_EMOJI_EMOJI &&
	  peek_char == kVariationSelector15Character) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT;
      }

      if ((current_emoji_type ==
	       PANGO_EMOJI_TYPE_EMOJI_TEXT ||
	   _pango_Is_Emoji_Keycap_Base(ch)) &&
	  peek_char == kVariationSelector16Character) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }

      /* Combining characters Keycap... */
      if (_pango_Is_Emoji_Keycap_Base(ch) &&
	  peek_char == kCombiningEnclosingKeycapCharacter) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      };

      /* Regional indicators */
      if (_pango_Is_Regional_Indicator(ch) &&
	  _pango_Is_Regional_Indicator(peek_char)) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }

      /* Upgrade text presentation emoji to emoji presentation when followed by
       * ZWJ, Example U+1F441 U+200D U+1F5E8, eye + ZWJ + left speech bubble. */
      if ((ch == kEyeCharacter ||
	   ch == kWavingWhiteFlagCharacter) &&
	  peek_char == kZeroWidthJoinerCharacter) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }
    }

    if (iter->is_emoji == (gboolean) 2)
      iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
    if (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))
    {
      iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);

      /* Make sure we make progress.  Weird sequences, like a VC15 followed
       * by VC16, can trick us into stalling otherwise. */
      if (iter->start == iter->end)
        iter->end = g_utf8_next_char (iter->end);

      return TRUE;
    }
  }

  iter->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);

  return TRUE;
}","gboolean
_pango_emoji_iter_next (PangoEmojiIter *VAR_0)
{
  PangoEmojiType VAR_1 = VAR_2;

  if (VAR_0->end == VAR_0->text_end)
    return FALSE;

  VAR_0->start = VAR_0->end;

  for (; VAR_0->end < VAR_0->text_end; VAR_0->end = g_utf8_next_char (VAR_0->end))
    {
      gunichar VAR_3 = g_utf8_get_char (VAR_0->end);

    /* COMMENT_0 */
                                                                          
                                                                      
                                                                      
                                                                          
                            
    if ((!(VAR_3 == VAR_4 && !VAR_0->is_emoji) &&
	 VAR_3 != VAR_5 &&
	 VAR_3 != VAR_6 &&
	 VAR_3 != VAR_7 &&
	 !_pango_Is_Regional_Indicator(VAR_3) &&
	 !((VAR_3 == VAR_8 ||
	    VAR_3 == VAR_9 ||
	    VAR_3 == VAR_10 ||
	    VAR_3 == VAR_11 ||
	    VAR_3 == VAR_12) &&
	   !VAR_0->is_emoji)) ||
	VAR_1 == VAR_2) {
      VAR_1 = _pango_get_emoji_type (VAR_3);
    }

    if (g_utf8_next_char (VAR_0->end) < VAR_0->text_end) /* COMMENT_6 */
    {
      gunichar VAR_13 = g_utf8_get_char (g_utf8_next_char (VAR_0->end));

      /* COMMENT_7 */
      if (VAR_1 ==
	      VAR_14 &&
	  VAR_13 == VAR_5) {
	VAR_1 = VAR_15;
      }

      if ((VAR_1 ==
	       VAR_15 ||
	   _pango_Is_Emoji_Keycap_Base(VAR_3)) &&
	  VAR_13 == VAR_6) {
	VAR_1 = VAR_14;
      }

      /* COMMENT_8 */
      if (_pango_Is_Emoji_Keycap_Base(VAR_3) &&
	  VAR_13 == VAR_16) {
	VAR_1 = VAR_14;
      };

      /* COMMENT_9 */
      if (_pango_Is_Regional_Indicator(VAR_3) &&
	  _pango_Is_Regional_Indicator(VAR_13)) {
	VAR_1 = VAR_14;
      }

      /* COMMENT_10 */
                                                                                
      if ((VAR_3 == VAR_17 ||
	   VAR_3 == VAR_18) &&
	  VAR_13 == VAR_4) {
	VAR_1 = VAR_14;
      }
    }

    if (VAR_0->is_emoji == (gboolean) 2)
      VAR_0->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);
    if (VAR_0->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1))
    {
      VAR_0->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);

      /* COMMENT_12 */
                                                          
      if (VAR_0->start == VAR_0->end)
        VAR_0->end = g_utf8_next_char (VAR_0->end);

      return TRUE;
    }
  }

  VAR_0->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (VAR_1);

  return TRUE;
}",GNOME/pango/71aaeaf020340412b8d012fe23a556c0420eda5f/pango-emoji.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,12 @@
     if (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))
     {
       iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
+
+      /* Make sure we make progress.  Weird sequences, like a VC15 followed
+       * by VC16, can trick us into stalling otherwise. */
+      if (iter->start == iter->end)
+        iter->end = g_utf8_next_char (iter->end);
+
       return TRUE;
     }
   }","{'deleted_lines': [], 'added_lines': ['', '      /* Make sure we make progress.  Weird sequences, like a VC15 followed', '       * by VC16, can trick us into stalling otherwise. */', '      if (iter->start == iter->end)', '        iter->end = g_utf8_next_char (iter->end);', '']}",True,"libpango in Pango 1.40.8 through 1.42.3, as used in hexchat and other products, allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted text with invalid Unicode sequences.",6.5,MEDIUM,1,valid,2018-08-18T02:29:36Z,2
CVE-2018-16511,['CWE-704'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,Bug 699659: Don't just assume an object is a t_(a)struct,0edd3d6c634a577db261615a9dc2719bca7f6e01,https://github.com/ArtifexSoftware/ghostpdl/commit/0edd3d6c634a577db261615a9dc2719bca7f6e01,psi/ztype.c,ztype,"static int
ztype(i_ctx_t *i_ctx_p)
{
os_ptr op = osp;
ref tnref;
int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);
if (code < 0)
return code;
if (!r_has_type(&tnref, t_name)) {
check_op(2);
{                       
if (op[-1].value.pstruct != 0x00) {
const char *sname =
gs_struct_type_name_string(gs_object_type(imemory,
op[-1].value.pstruct));
int code = name_ref(imemory, (const byte *)sname, strlen(sname),
(ref *) (op - 1), 0);
if (code < 0)
return code;
} else
return_error(gs_error_stackunderflow);
}
r_set_attrs(op - 1, a_executable);
} else {
ref_assign(op - 1, &tnref);
}
pop(1);
return 0;
}","static int
ztype(i_ctx_t *VAR_0)
{
os_ptr VAR_1 = VAR_2;
ref VAR_3;
int VAR_4 = array_get(VAR_5, VAR_1, (long)r_btype(VAR_1 - 1), &VAR_3);
if (VAR_4 < 0)
return VAR_4;
if (!r_has_type(&VAR_3, VAR_6)) {
check_op(2);
{                       
if (VAR_1[-1].value.pstruct != 0x00) {
const char *VAR_7 =
gs_struct_type_name_string(gs_object_type(VAR_5,
VAR_1[-1].value.pstruct));
int VAR_4 = name_ref(VAR_5, (const byte *)VAR_7, strlen(VAR_7),
(ref *) (VAR_1 - 1), 0);
if (VAR_4 < 0)
return VAR_4;
} else
return_error(VAR_8);
}
r_set_attrs(VAR_1 - 1, VAR_9);
} else {
ref_assign(VAR_1 - 1, &VAR_3);
}
pop(1);
return 0;
}",ArtifexSoftware/ghostpdl/0edd3d6c634a577db261615a9dc2719bca7f6e01/ztype.c/vul/before/0.json,"static int
ztype(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    ref tnref;
    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);

    if (code < 0)
        return code;
    if (!r_has_type(&tnref, t_name)) {
        /* Must be either a stack underflow or a t_[a]struct. */
        check_op(2);
        {                       /* Get the type name from the structure. */
            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
            const char *sname =
                gs_struct_type_name_string(gs_object_type(imemory,
                                                          op[-1].value.pstruct));
            int code = name_ref(imemory, (const byte *)sname, strlen(sname),
                                (ref *) (op - 1), 0);

            if (code < 0)
                return code;
            } else
                return_error(gs_error_stackunderflow);
        }
        r_set_attrs(op - 1, a_executable);
    } else {
        ref_assign(op - 1, &tnref);
    }
    pop(1);
    return 0;
}","static int
ztype(i_ctx_t *VAR_0)
{
    os_ptr VAR_1 = VAR_2;
    ref VAR_3;
    int VAR_4 = array_get(VAR_5, VAR_1, (long)r_btype(VAR_1 - 1), &VAR_3);

    if (VAR_4 < 0)
        return VAR_4;
    if (!r_has_type(&VAR_3, VAR_6)) {
        /* COMMENT_0 */
        check_op(2);
        {                       /* COMMENT_1 */
            if ((r_has_type(&VAR_1[-1], VAR_7) || r_has_type(&VAR_1[-1], VAR_8)) && VAR_1[-1].value.pstruct != 0x00) {
            const char *VAR_9 =
                gs_struct_type_name_string(gs_object_type(VAR_5,
                                                          VAR_1[-1].value.pstruct));
            int VAR_4 = name_ref(VAR_5, (const byte *)VAR_9, strlen(VAR_9),
                                (ref *) (VAR_1 - 1), 0);

            if (VAR_4 < 0)
                return VAR_4;
            } else
                return_error(VAR_10);
        }
        r_set_attrs(VAR_1 - 1, VAR_11);
    } else {
        ref_assign(VAR_1 - 1, &VAR_3);
    }
    pop(1);
    return 0;
}",ArtifexSoftware/ghostpdl/0edd3d6c634a577db261615a9dc2719bca7f6e01/ztype.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,7 @@
         /* Must be either a stack underflow or a t_[a]struct. */
         check_op(2);
         {                       /* Get the type name from the structure. */
-            if (op[-1].value.pstruct != 0x00) {
+            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
             const char *sname =
                 gs_struct_type_name_string(gs_object_type(imemory,
                                                           op[-1].value.pstruct));","{'deleted_lines': ['            if (op[-1].value.pstruct != 0x00) {'], 'added_lines': ['            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {']}",True,"An issue was discovered in Artifex Ghostscript before 9.24. A type confusion in ""ztype"" could be used by remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact.",7.8,HIGH,2,valid,2018-08-21T19:36:52Z,2
CVE-2018-9304,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Exiv2/exiv2,"Fix division by zero in BigTiffImage::printIFD

This fixes #262",b3199a072073ac6292e5bbbd5cce2167f1932ea8,https://github.com/Exiv2/exiv2/commit/b3199a072073ac6292e5bbbd5cce2167f1932ea8,src/bigtiffimage.cpp,printIFD,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
{
BasicIo& io = Image::io();
depth++;
bool bFirst  = true;
bool bPrint = true;
do
{
io.seek(dir_offset, BasicIo::beg);
const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
const bool tooBig = entries > 500;
if ( bFirst && bPrint )
{
out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF BIGTIFF FILE "") << io.path() << std::endl;
if (tooBig)
out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
}
if (tooBig)
break;
for ( uint64_t i = 0; i < entries; i ++ )
{
if ( bFirst && bPrint )
out << Internal::indent(depth)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
bFirst = false;
const uint16_t tag   = (uint16_t) readData(2);
const uint16_t type  = (uint16_t) readData(2);
const uint64_t count = readData(dataSize_);
const DataBuf  data  = io.read(dataSize_);        
std::string sp = """" ; 
const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count)                                                             : count > 5              ? 5
: count
;
const uint32_t pad    = isStringType(type) ? 1 : 0;
const uint32_t size   = isStringType(type) ? 1
: is2ByteType(type)  ? 2
: is4ByteType(type)  ? 4
: is8ByteType(type)  ? 8
: 1;
if (size > std::numeric_limits<uint64_t>::max() / count)
throw Error(kerInvalidMalloc);                                                                          
if (size * count > std::numeric_limits<uint64_t>::max() - pad)
throw Error(kerInvalidMalloc);             
const uint64_t allocate = size*count + pad;
if ( allocate > io.size() ) {
throw Error(kerInvalidMalloc);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t offset = header_.format() == Header::StandardTiff?
byteSwap4(data, 0, doSwap_):
byteSwap8(data, 0, doSwap_);
const bool usePointer = (size_t) count*size > (size_t) dataSize_;
if ( usePointer )                                                      {
size_t   restore = io.tell();                                          io.seek(offset, BasicIo::beg);                                         io.read(buf.pData_, (long) count * size);                                     io.seek(restore, BasicIo::beg);                                    }
else                                  std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     
if ( bPrint )
{
const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
const uint64_t address = dir_offset + 2 + i * entrySize;
const std::string offsetString = usePointer?
Internal::stringFormat(""%10u"", offset):
"""";
out << Internal::indent(depth)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |%10s | "",
address, tag, tagName(tag).c_str(), typeName(type), count, offsetString.c_str());
if ( isShortType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap2(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap4(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap8(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isRationalType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
out << sp << a << ""/"" << b;
sp = "" "";
}
}
else if ( isStringType(type) )
out << sp << Internal::binaryToString(buf, (size_t) kount);
sp = kount == count ? """" : "" ..."";
out << sp << std::endl;
if ( option == kpsRecursive &&
(tag == 0x8769  || tag == 0x014a || type == tiffIfd || type == tiffIfd8) )
{
for ( size_t k = 0 ; k < count ; k++ )
{
const size_t restore = io.tell();
const uint64_t ifdOffset = type == tiffIfd8?
byteSwap8(buf, k*size, doSwap_):
byteSwap4(buf, k*size, doSwap_);
printIFD(out, option, ifdOffset, depth);
io.seek(restore, BasicIo::beg);
}
}
else if ( option == kpsRecursive && tag == 0x83bb  )
{
const size_t restore = io.tell();                                          io.seek(offset, BasicIo::beg);                                             byte* bytes=new byte[(size_t)count] ;                                      io.read(bytes,(long)count)        ;                                        io.seek(restore, BasicIo::beg);                                            IptcData::printStructure(out,bytes,(size_t)count,depth);
delete[] bytes;                                                        }
else if ( option == kpsRecursive && tag == 0x927c  && count > 10)
{
size_t   restore = io.tell();  
long jump= 10           ;
byte     bytes[20]          ;
const char* chars = (const char*) &bytes[0] ;
io.seek(dir_offset, BasicIo::beg);                                      io.read(bytes,jump    )     ;                                      bytes[jump]=0               ;
if ( ::strcmp(""Nikon"",chars) == 0 )
{
std::vector<byte> nikon_bytes(count - jump);
io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
MemIo memIo(&nikon_bytes.at(0), (long)count - jump);                                       std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
io.seek(0, BasicIo::beg);                                          std::cerr << ""makernote"" << std::endl;
printIFD(out,option,offset,depth);
}
io.seek(restore,BasicIo::beg);                                 }
}
}
const uint64_t nextDirOffset = readData(dataSize_);
dir_offset = tooBig ? 0 : nextDirOffset;
out.flush();
} while (dir_offset != 0);
if ( bPrint )
out << Internal::indent(depth) << ""END "" << io.path() << std::endl;
depth--;
}","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
{
BasicIo& VAR_4 = Image::io();
VAR_3++;
bool VAR_5  = true;
bool VAR_6 = true;
do
{
VAR_4.seek(VAR_2, BasicIo::beg);
const uint64_t VAR_7 = readData(VAR_8.format() == Header::StandardTiff? 2: 8);
const bool VAR_9 = VAR_7 > 500;
if ( VAR_5 && VAR_6 )
{
VAR_0 << Internal::indent(VAR_3) << Internal::stringFormat(""STRUCTURE OF BIGTIFF FILE "") << VAR_4.path() << std::endl;
if (VAR_9)
VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_7 << std::endl;
}
if (VAR_9)
break;
for ( uint64_t VAR_10 = 0; VAR_10 < VAR_7; VAR_10 ++ )
{
if ( VAR_5 && VAR_6 )
VAR_0 << Internal::indent(VAR_3)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
VAR_5 = false;
const uint16_t VAR_11   = (uint16_t) readData(2);
const uint16_t VAR_12  = (uint16_t) readData(2);
const uint64_t VAR_13 = readData(VAR_14);
const DataBuf  VAR_15  = VAR_4.read(VAR_14);        
std::string VAR_16 = """" ; 
const uint64_t VAR_17  = isStringType(VAR_12)? (VAR_13 > 32 ? 32 : VAR_13) 
: VAR_13 > 5              ? 5
: VAR_13
;
const uint32_t VAR_18    = isStringType(VAR_12) ? 1 : 0;
const uint32_t VAR_19   = isStringType(VAR_12) ? 1
: is2ByteType(VAR_12)  ? 2
: is4ByteType(VAR_12)  ? 4
: is8ByteType(VAR_12)  ? 8
: 1;
if (VAR_19 > std::numeric_limits<uint64_t>::max() / VAR_13)
throw Error(VAR_20);             
if (VAR_19 * VAR_13 > std::numeric_limits<uint64_t>::max() - VAR_18)
throw Error(VAR_20);             
const uint64_t VAR_21 = VAR_19*VAR_13 + VAR_18;
if ( VAR_21 > VAR_4.size() ) {
throw Error(VAR_20);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t VAR_22 = VAR_8.format() == Header::StandardTiff?
byteSwap4(VAR_15, 0, VAR_23):
byteSwap8(VAR_15, 0, VAR_23);
const bool VAR_24 = (size_t) VAR_13*VAR_19 > (size_t) VAR_14;
if ( VAR_24 )                          
{
size_t   VAR_25 = VAR_4.tell();          
VAR_4.seek(VAR_22, BasicIo::beg);         
VAR_4.read(VAR_26.pData_, (long) VAR_13 * VAR_19);     
VAR_4.seek(VAR_25, BasicIo::beg);        
}
else  
std::memcpy(VAR_26.pData_, VAR_15.pData_, (size_t) VAR_13 * VAR_19);     
if ( VAR_6 )
{
const uint64_t VAR_27 = VAR_8.format() == Header::StandardTiff? 12: 20;
const uint64_t VAR_28 = VAR_2 + 2 + VAR_10 * VAR_27;
const std::string VAR_29 = VAR_24?
Internal::stringFormat(""%10u"", VAR_22):
"""";
VAR_0 << Internal::indent(VAR_3)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |%10s | "",
VAR_28, VAR_11, tagName(VAR_11).c_str(), typeName(VAR_12), VAR_13, VAR_29.c_str());
if ( isShortType(VAR_12) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
{
VAR_0 << VAR_16 << byteSwap2(VAR_26, VAR_30*VAR_19, VAR_23);
VAR_16 = "" "";
}
}
else if ( isLongType(VAR_12) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
{
VAR_0 << VAR_16 << byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);
VAR_16 = "" "";
}
}
else if ( isLongLongType(VAR_12) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
{
VAR_0 << VAR_16 << byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23);
VAR_16 = "" "";
}
}
else if ( isRationalType(VAR_12) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
{
uint32_t VAR_31 = byteSwap4(VAR_26, VAR_30*VAR_19+0, VAR_23);
uint32_t VAR_32 = byteSwap4(VAR_26, VAR_30*VAR_19+4, VAR_23);
VAR_0 << VAR_16 << VAR_31 << ""/"" << VAR_32;
VAR_16 = "" "";
}
}
else if ( isStringType(VAR_12) )
VAR_0 << VAR_16 << Internal::binaryToString(VAR_26, (size_t) VAR_17);
VAR_16 = VAR_17 == VAR_13 ? """" : "" ..."";
VAR_0 << VAR_16 << std::endl;
if ( VAR_1 == VAR_33 &&
(VAR_11 == 0x8769  || VAR_11 == 0x014a || VAR_12 == VAR_34 || VAR_12 == VAR_35) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_13 ; VAR_30++ )
{
const size_t VAR_25 = VAR_4.tell();
const uint64_t VAR_36 = VAR_12 == VAR_35?
byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23):
byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);
printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
VAR_4.seek(VAR_25, BasicIo::beg);
}
}
else if ( VAR_1 == VAR_33 && VAR_11 == 0x83bb  )
{
const size_t VAR_25 = VAR_4.tell();      
VAR_4.seek(VAR_22, BasicIo::beg);         
byte* VAR_37=new byte[(size_t)VAR_13] ;  
VAR_4.read(VAR_37,(long)VAR_13)        ;    
VAR_4.seek(VAR_25, BasicIo::beg);        
IptcData::printStructure(VAR_0,VAR_37,(size_t)VAR_13,VAR_3);
delete[] VAR_37;                        
}
else if ( VAR_1 == VAR_33 && VAR_11 == 0x927c  && VAR_13 > 10)
{
size_t   VAR_25 = VAR_4.tell();  
long VAR_38= 10           ;
byte     VAR_37[20]          ;
const char* VAR_39 = (const char*) &VAR_37[0] ;
VAR_4.seek(VAR_2, BasicIo::beg);  
VAR_4.read(VAR_37,VAR_38    )     ;  
VAR_37[VAR_38]=0               ;
if ( ::strcmp(""Nikon"",VAR_39) == 0 )
{
std::vector<byte> VAR_40(VAR_13 - VAR_38);
VAR_4.read(&VAR_40.at(0), (long)VAR_40.size());
MemIo VAR_41(&VAR_40.at(0), (long)VAR_13 - VAR_38); 
std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
VAR_4.seek(0, BasicIo::beg);  
std::cerr << ""makernote"" << std::endl;
printIFD(VAR_0,VAR_1,VAR_22,VAR_3);
}
VAR_4.seek(VAR_25,BasicIo::beg); 
}
}
}
const uint64_t VAR_42 = readData(VAR_14);
VAR_2 = VAR_9 ? 0 : VAR_42;
VAR_0.flush();
} while (VAR_2 != 0);
if ( VAR_6 )
VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;
VAR_3--;
}",Exiv2/exiv2/b3199a072073ac6292e5bbbd5cce2167f1932ea8/bigtiffimage.cpp/vul/before/0.json,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
                {
                    BasicIo& io = Image::io();

                    depth++;
                    bool bFirst  = true;

                    // buffer
                    bool bPrint = true;

                    do
                    {
                        // Read top of directory
                        io.seek(dir_offset, BasicIo::beg);

                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
                        const bool tooBig = entries > 500;

                        if ( bFirst && bPrint )
                        {
                            out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF BIGTIFF FILE "") << io.path() << std::endl;
                            if (tooBig)
                                out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
                        }

                        if (tooBig)
                            break;

                        // Read the dictionary
                        for ( uint64_t i = 0; i < entries; i ++ )
                        {
                            if ( bFirst && bPrint )
                                out << Internal::indent(depth)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            bFirst = false;

                            const uint16_t tag   = (uint16_t) readData(2);
                            const uint16_t type  = (uint16_t) readData(2);
                            const uint64_t count = readData(dataSize_);
                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type

                            std::string sp = """" ; // output spacer

                            //prepare to print the value
                            // TODO: figure out what's going on with kount
                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays
                                                            : count > 5              ? 5
                                                            : count
                                                            ;
                            const uint32_t pad    = isStringType(type) ? 1 : 0;
                            const uint32_t size   = isStringType(type) ? 1
                                                  : is2ByteType(type)  ? 2
                                                  : is4ByteType(type)  ? 4
                                                  : is8ByteType(type)  ? 8
                                                  : 1;

                            // #55 and #56 memory allocation crash test/data/POC8

                            // size * count > std::numeric_limits<uint64_t>::max()
                            // =>
                            // size > std::numeric_limits<uint64_t>::max() / count
                            // (don't perform that check when count == 0 => will cause a division by zero exception)
                            if (count != 0) {
                                if (size > std::numeric_limits<uint64_t>::max() / count) {
                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64
                                }
                            }
                                                             // more than we can handle

                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)
                                throw Error(kerInvalidMalloc);             // again more than 2^64

                            const uint64_t allocate = size*count + pad;
                            if ( allocate > io.size() ) {
                                throw Error(kerInvalidMalloc);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t offset = header_.format() == Header::StandardTiff?
                                    byteSwap4(data, 0, doSwap_):
                                    byteSwap8(data, 0, doSwap_);

                            // big data? Use 'data' as pointer to real data
                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;

                            if ( usePointer )                          // read into buffer
                            {
                                size_t   restore = io.tell();          // save
                                io.seek(offset, BasicIo::beg);         // position
                                io.read(buf.pData_, (long) count * size);     // read
                                io.seek(restore, BasicIo::beg);        // restore
                            }
                            else  // use 'data' as data :)
                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data

                            if ( bPrint )
                            {
                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
                                const uint64_t address = dir_offset + 2 + i * entrySize;
                                const std::string offsetString = usePointer?
                                    Internal::stringFormat(""%10u"", offset):
                                    """";

                                out << Internal::indent(depth)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |%10s | "",
                                        address, tag, tagName(tag).c_str(), typeName(type), count, offsetString.c_str());

                                if ( isShortType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap2(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap4(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap8(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isRationalType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
                                        out << sp << a << ""/"" << b;
                                        sp = "" "";
                                    }
                                }
                                else if ( isStringType(type) )
                                    out << sp << Internal::binaryToString(buf, (size_t) kount);

                                sp = kount == count ? """" : "" ..."";
                                out << sp << std::endl;

                                if ( option == kpsRecursive &&
                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )
                                {
                                    for ( size_t k = 0 ; k < count ; k++ )
                                    {
                                        const size_t restore = io.tell();
                                        const uint64_t ifdOffset = type == tiffIfd8?
                                            byteSwap8(buf, k*size, doSwap_):
                                            byteSwap4(buf, k*size, doSwap_);

                                        printIFD(out, option, ifdOffset, depth);
                                        io.seek(restore, BasicIo::beg);
                                    }
                                }
                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )
                                {
                                    const size_t restore = io.tell();      // save
                                    io.seek(offset, BasicIo::beg);         // position
                                    byte* bytes=new byte[(size_t)count] ;  // allocate memory
                                    io.read(bytes,(long)count)        ;    // read
                                    io.seek(restore, BasicIo::beg);        // restore
                                    IptcData::printStructure(out,bytes,(size_t)count,depth);
                                    delete[] bytes;                        // free
                                }
                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)
                                {
                                    size_t   restore = io.tell();  // save

                                    long jump= 10           ;
                                    byte     bytes[20]          ;
                                    const char* chars = (const char*) &bytes[0] ;
                                    io.seek(dir_offset, BasicIo::beg);  // position
                                    io.read(bytes,jump    )     ;  // read
                                    bytes[jump]=0               ;
                                    if ( ::strcmp(""Nikon"",chars) == 0 )
                                    {
                                      // tag is an embedded tiff
                                      std::vector<byte> nikon_bytes(count - jump);

                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      // printTiffStructure(memIo,out,option,depth);
                                      // TODO: fix it
                                    }
                                    else
                                    {
                                        // tag is an IFD
                                        io.seek(0, BasicIo::beg);  // position
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(out,option,offset,depth);
                                    }

                                    io.seek(restore,BasicIo::beg); // restore
                                }
                            }
                        }

                        const uint64_t nextDirOffset = readData(dataSize_);

                        dir_offset = tooBig ? 0 : nextDirOffset;
                        out.flush();
                    } while (dir_offset != 0);

                    if ( bPrint )
                        out << Internal::indent(depth) << ""END "" << io.path() << std::endl;

                    depth--;
                }","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
                {
                    BasicIo& VAR_4 = Image::io();

                    VAR_3++;
                    bool VAR_5  = true;

                    /* COMMENT_0 */
                    bool VAR_6 = true;

                    do
                    {
                        /* COMMENT_1 */
                        VAR_4.seek(VAR_2, BasicIo::beg);

                        const uint64_t VAR_7 = readData(VAR_8.format() == Header::StandardTiff? 2: 8);
                        const bool VAR_9 = VAR_7 > 500;

                        if ( VAR_5 && VAR_6 )
                        {
                            VAR_0 << Internal::indent(VAR_3) << Internal::stringFormat(""STRUCTURE OF BIGTIFF FILE "") << VAR_4.path() << std::endl;
                            if (VAR_9)
                                VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_7 << std::endl;
                        }

                        if (VAR_9)
                            break;

                        /* COMMENT_2 */
                        for ( uint64_t VAR_10 = 0; VAR_10 < VAR_7; VAR_10 ++ )
                        {
                            if ( VAR_5 && VAR_6 )
                                VAR_0 << Internal::indent(VAR_3)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            VAR_5 = false;

                            const uint16_t VAR_11   = (uint16_t) readData(2);
                            const uint16_t VAR_12  = (uint16_t) readData(2);
                            const uint64_t VAR_13 = readData(VAR_14);
                            const DataBuf  VAR_15  = VAR_4.read(VAR_14);        /* COMMENT_3 */

                            std::string VAR_16 = """" ; /* COMMENT_4 */

                            /* COMMENT_5 */
                            /* COMMENT_6 */
                            const uint64_t VAR_17  = isStringType(VAR_12)? (VAR_13 > 32 ? 32 : VAR_13) /* COMMENT_7 */
                                                            : VAR_13 > 5              ? 5
                                                            : VAR_13
                                                            ;
                            const uint32_t VAR_18    = isStringType(VAR_12) ? 1 : 0;
                            const uint32_t VAR_19   = isStringType(VAR_12) ? 1
                                                  : is2ByteType(VAR_12)  ? 2
                                                  : is4ByteType(VAR_12)  ? 4
                                                  : is8ByteType(VAR_12)  ? 8
                                                  : 1;

                            /* COMMENT_8 */

                            /* COMMENT_9 */
                            /* COMMENT_10 */
                            /* COMMENT_11 */
                            /* COMMENT_12 */
                            if (VAR_13 != 0) {
                                if (VAR_19 > std::numeric_limits<uint64_t>::max() / VAR_13) {
                                    throw Error(VAR_20);             /* COMMENT_13 */
                                }
                            }
                                                             /* COMMENT_14 */

                            if (VAR_19 * VAR_13 > std::numeric_limits<uint64_t>::max() - VAR_18)
                                throw Error(VAR_20);             /* COMMENT_15 */

                            const uint64_t VAR_21 = VAR_19*VAR_13 + VAR_18;
                            if ( VAR_21 > VAR_4.size() ) {
                                throw Error(VAR_20);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t VAR_22 = VAR_8.format() == Header::StandardTiff?
                                    byteSwap4(VAR_15, 0, VAR_23):
                                    byteSwap8(VAR_15, 0, VAR_23);

                            /* COMMENT_16 */
                            const bool VAR_24 = (size_t) VAR_13*VAR_19 > (size_t) VAR_14;

                            if ( VAR_24 )                          /* COMMENT_17 */
                            {
                                size_t   VAR_25 = VAR_4.tell();          /* COMMENT_18 */
                                VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_19 */
                                VAR_4.read(VAR_26.pData_, (long) VAR_13 * VAR_19);     /* COMMENT_20 */
                                VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_21 */
                            }
                            else  /* COMMENT_22 */
                                std::memcpy(VAR_26.pData_, VAR_15.pData_, (size_t) VAR_13 * VAR_19);     /* COMMENT_23 */

                            if ( VAR_6 )
                            {
                                const uint64_t VAR_27 = VAR_8.format() == Header::StandardTiff? 12: 20;
                                const uint64_t VAR_28 = VAR_2 + 2 + VAR_10 * VAR_27;
                                const std::string VAR_29 = VAR_24?
                                    Internal::stringFormat(""%10u"", VAR_22):
                                    """";

                                VAR_0 << Internal::indent(VAR_3)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |%10s | "",
                                        VAR_28, VAR_11, tagName(VAR_11).c_str(), typeName(VAR_12), VAR_13, VAR_29.c_str());

                                if ( isShortType(VAR_12) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_16 << byteSwap2(VAR_26, VAR_30*VAR_19, VAR_23);
                                        VAR_16 = "" "";
                                    }
                                }
                                else if ( isLongType(VAR_12) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_16 << byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);
                                        VAR_16 = "" "";
                                    }
                                }
                                else if ( isLongLongType(VAR_12) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_16 << byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23);
                                        VAR_16 = "" "";
                                    }
                                }
                                else if ( isRationalType(VAR_12) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )
                                    {
                                        uint32_t VAR_31 = byteSwap4(VAR_26, VAR_30*VAR_19+0, VAR_23);
                                        uint32_t VAR_32 = byteSwap4(VAR_26, VAR_30*VAR_19+4, VAR_23);
                                        VAR_0 << VAR_16 << VAR_31 << ""/"" << VAR_32;
                                        VAR_16 = "" "";
                                    }
                                }
                                else if ( isStringType(VAR_12) )
                                    VAR_0 << VAR_16 << Internal::binaryToString(VAR_26, (size_t) VAR_17);

                                VAR_16 = VAR_17 == VAR_13 ? """" : "" ..."";
                                VAR_0 << VAR_16 << std::endl;

                                if ( VAR_1 == VAR_33 &&
                                        (VAR_11 == 0x8769 /* COMMENT_24 */ || VAR_11 == 0x014a/* COMMENT_25 */ || VAR_12 == VAR_34 || VAR_12 == VAR_35) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_13 ; VAR_30++ )
                                    {
                                        const size_t VAR_25 = VAR_4.tell();
                                        const uint64_t VAR_36 = VAR_12 == VAR_35?
                                            byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23):
                                            byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);

                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
                                        VAR_4.seek(VAR_25, BasicIo::beg);
                                    }
                                }
                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x83bb /* COMMENT_26 */ )
                                {
                                    const size_t VAR_25 = VAR_4.tell();      /* COMMENT_18 */
                                    VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_19 */
                                    byte* VAR_37=new byte[(size_t)VAR_13] ;  /* COMMENT_27 */
                                    VAR_4.read(VAR_37,(long)VAR_13)        ;    /* COMMENT_20 */
                                    VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_21 */
                                    IptcData::printStructure(VAR_0,VAR_37,(size_t)VAR_13,VAR_3);
                                    delete[] VAR_37;                        /* COMMENT_28 */
                                }
                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x927c /* COMMENT_29 */ && VAR_13 > 10)
                                {
                                    size_t   VAR_25 = VAR_4.tell();  /* COMMENT_18 */

                                    long VAR_38= 10           ;
                                    byte     VAR_37[20]          ;
                                    const char* VAR_39 = (const char*) &VAR_37[0] ;
                                    VAR_4.seek(VAR_2, BasicIo::beg);  /* COMMENT_19 */
                                    VAR_4.read(VAR_37,VAR_38    )     ;  /* COMMENT_20 */
                                    VAR_37[VAR_38]=0               ;
                                    if ( ::strcmp(""Nikon"",VAR_39) == 0 )
                                    {
                                      /* COMMENT_30 */
                                      std::vector<byte> VAR_40(VAR_13 - VAR_38);

                                      VAR_4.read(&VAR_40.at(0), (long)VAR_40.size());
                                      MemIo VAR_41(&VAR_40.at(0), (long)VAR_13 - VAR_38); /* COMMENT_31 */
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      /* COMMENT_32 */
                                      /* COMMENT_33 */
                                    }
                                    else
                                    {
                                        /* COMMENT_34 */
                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_19 */
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(VAR_0,VAR_1,VAR_22,VAR_3);
                                    }

                                    VAR_4.seek(VAR_25,BasicIo::beg); /* COMMENT_21 */
                                }
                            }
                        }

                        const uint64_t VAR_42 = readData(VAR_14);

                        VAR_2 = VAR_9 ? 0 : VAR_42;
                        VAR_0.flush();
                    } while (VAR_2 != 0);

                    if ( VAR_6 )
                        VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;

                    VAR_3--;
                }",Exiv2/exiv2/b3199a072073ac6292e5bbbd5cce2167f1932ea8/bigtiffimage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -61,8 +61,12 @@
                             // size * count > std::numeric_limits<uint64_t>::max()
                             // =>
                             // size > std::numeric_limits<uint64_t>::max() / count
-                            if (size > std::numeric_limits<uint64_t>::max() / count)
-                                throw Error(kerInvalidMalloc);             // we got number bigger than 2^64
+                            // (don't perform that check when count == 0 => will cause a division by zero exception)
+                            if (count != 0) {
+                                if (size > std::numeric_limits<uint64_t>::max() / count) {
+                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64
+                                }
+                            }
                                                              // more than we can handle
 
                             if (size * count > std::numeric_limits<uint64_t>::max() - pad)","{'deleted_lines': ['                            if (size > std::numeric_limits<uint64_t>::max() / count)', '                                throw Error(kerInvalidMalloc);             // we got number bigger than 2^64'], 'added_lines': [""                            // (don't perform that check when count == 0 => will cause a division by zero exception)"", '                            if (count != 0) {', '                                if (size > std::numeric_limits<uint64_t>::max() / count) {', '                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64', '                                }', '                            }']}",True,"In Exiv2 0.26, a divide by zero in BigTiffImage::printIFD in bigtiffimage.cpp could result in denial of service.",6.5,MEDIUM,1,valid,2018-09-03T19:14:16Z,2
CVE-2018-8784,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRDP,"Fixed CVE-2018-8784

Thanks to Eyal Itkin from Check Point Software Technologies.",17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7,https://github.com/FreeRDP/FreeRDP/commit/17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7,libfreerdp/codec/zgfx.c,zgfx_GetBits,"static INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)
{
if (!_zgfx)
return FALSE;
while (_zgfx->cBitsCurrent < _nbits)
{
_zgfx->BitsCurrent <<= 8;
if (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)
_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;
_zgfx->cBitsCurrent += 8;
}
_zgfx->cBitsRemaining -= _nbits;
_zgfx->cBitsCurrent -= _nbits;
_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;
_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);
}","static INLINE VAR_0 zgfx_GetBits(ZGFX_CONTEXT* VAR_1, UINT32 VAR_2)
{
if (!VAR_1)
return FALSE;
while (VAR_1->cBitsCurrent < VAR_2)
{
VAR_1->BitsCurrent <<= 8;
if (VAR_1->pbInputCurrent < VAR_1->pbInputEnd)
VAR_1->BitsCurrent += *(VAR_1->pbInputCurrent)++;
VAR_1->cBitsCurrent += 8;
}
VAR_1->cBitsRemaining -= VAR_2;
VAR_1->cBitsCurrent -= VAR_2;
VAR_1->bits = VAR_1->BitsCurrent >> VAR_1->cBitsCurrent;
VAR_1->BitsCurrent &= ((1 << VAR_1->cBitsCurrent) - 1);
}",,"static INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)
{
	if (!_zgfx)
		return FALSE;

	while (_zgfx->cBitsCurrent < _nbits)
	{
		_zgfx->BitsCurrent <<= 8;

		if (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)
			_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;

		_zgfx->cBitsCurrent += 8;
	}

	_zgfx->cBitsRemaining -= _nbits;
	_zgfx->cBitsCurrent -= _nbits;
	_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;
	_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);
	return TRUE;
}","static INLINE VAR_0 zgfx_GetBits(ZGFX_CONTEXT* VAR_1, UINT32 VAR_2)
{
	if (!VAR_1)
		return FALSE;

	while (VAR_1->cBitsCurrent < VAR_2)
	{
		VAR_1->BitsCurrent <<= 8;

		if (VAR_1->pbInputCurrent < VAR_1->pbInputEnd)
			VAR_1->BitsCurrent += *(VAR_1->pbInputCurrent)++;

		VAR_1->cBitsCurrent += 8;
	}

	VAR_1->cBitsRemaining -= VAR_2;
	VAR_1->cBitsCurrent -= VAR_2;
	VAR_1->bits = VAR_1->BitsCurrent >> VAR_1->cBitsCurrent;
	VAR_1->BitsCurrent &= ((1 << VAR_1->cBitsCurrent) - 1);
	return TRUE;
}",,"--- func_before
+++ func_after
@@ -17,4 +17,5 @@
 	_zgfx->cBitsCurrent -= _nbits;
 	_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;
 	_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);
+	return TRUE;
 }","{'deleted_lines': [], 'added_lines': ['\treturn TRUE;']}",True,FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress_segment() that results in a memory corruption and probably even a remote code execution.,9.8,CRITICAL,3,valid,2018-10-22T15:51:26Z,2
CVE-2018-8784,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRDP,"Fixed CVE-2018-8784

Thanks to Eyal Itkin from Check Point Software Technologies.",17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7,https://github.com/FreeRDP/FreeRDP/commit/17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7,libfreerdp/codec/zgfx.c,zgfx_decompress_segment,"static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)
{
BYTE c;
BYTE flags;
UINT32 extra = 0;
int opIndex;
int haveBits;
int inPrefix;
UINT32 count;
UINT32 distance;
BYTE* pbSegment;
size_t cbSegment = segmentSize - 1;
if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))
return FALSE;
Stream_Read_UINT8(stream, flags); 
zgfx->OutputCount = 0;
pbSegment = Stream_Pointer(stream);
Stream_Seek(stream, cbSegment);
if (!(flags & PACKET_COMPRESSED))
{
zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);
CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);
zgfx->OutputCount = cbSegment;
return TRUE;
}
zgfx->pbInputCurrent = pbSegment;
zgfx->pbInputEnd = &pbSegment[cbSegment - 1];
zgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;
zgfx->cBitsCurrent = 0;
zgfx->BitsCurrent = 0;
while (zgfx->cBitsRemaining)
{
haveBits = 0;
inPrefix = 0;
for (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)
{
while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)
{
zgfx_GetBits(zgfx, 1);
inPrefix = (inPrefix << 1) + zgfx->bits;
haveBits++;
}
if (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)
{
if (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)
{
zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
c = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);
zgfx->HistoryBuffer[zgfx->HistoryIndex] = c;
if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)
zgfx->HistoryIndex = 0;
zgfx->OutputBuffer[zgfx->OutputCount++] = c;
}
else
{
zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
distance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;
if (distance != 0)
{
zgfx_GetBits(zgfx, 1);
if (zgfx->bits == 0)
{
count = 3;
}
else
{
count = 4;
extra = 2;
zgfx_GetBits(zgfx, 1);
while (zgfx->bits == 1)
{
count *= 2;
extra++;
zgfx_GetBits(zgfx, 1);
}
zgfx_GetBits(zgfx, extra);
count += zgfx->bits;
}
zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
zgfx->OutputCount += count;
}
else
{
zgfx_GetBits(zgfx, 15);
count = zgfx->bits;
zgfx->cBitsRemaining -= zgfx->cBitsCurrent;
zgfx->cBitsCurrent = 0;
zgfx->BitsCurrent = 0;
CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);
zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);
zgfx->pbInputCurrent += count;
zgfx->cBitsRemaining -= (8 * count);
zgfx->OutputCount += count;
}
}
break;
}
}
}
return TRUE;
}","static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* VAR_0, wStream* VAR_1, size_t VAR_2)
{
BYTE VAR_3;
BYTE VAR_4;
UINT32 VAR_5 = 0;
int VAR_6;
int VAR_7;
int VAR_8;
UINT32 VAR_9;
UINT32 VAR_10;
BYTE* VAR_11;
size_t VAR_12 = VAR_2 - 1;
if ((Stream_GetRemainingLength(VAR_1) < VAR_2) || (VAR_2 < 1))
return FALSE;
Stream_Read_UINT8(VAR_1, VAR_4); 
VAR_0->OutputCount = 0;
VAR_11 = Stream_Pointer(VAR_1);
Stream_Seek(VAR_1, VAR_12);
if (!(VAR_4 & VAR_13))
{
zgfx_history_buffer_ring_write(VAR_0, VAR_11, VAR_12);
CopyMemory(VAR_0->OutputBuffer, VAR_11, VAR_12);
VAR_0->OutputCount = VAR_12;
return TRUE;
}
VAR_0->pbInputCurrent = VAR_11;
VAR_0->pbInputEnd = &VAR_11[VAR_12 - 1];
VAR_0->cBitsRemaining = 8 * (VAR_12 - 1) - *VAR_0->pbInputEnd;
VAR_0->cBitsCurrent = 0;
VAR_0->BitsCurrent = 0;
while (VAR_0->cBitsRemaining)
{
VAR_7 = 0;
VAR_8 = 0;
for (VAR_6 = 0; VAR_14[VAR_6].prefixLength != 0; VAR_6++)
{
while (VAR_7 < VAR_14[VAR_6].prefixLength)
{
zgfx_GetBits(VAR_0, 1);
VAR_8 = (VAR_8 << 1) + VAR_0->bits;
VAR_7++;
}
if (VAR_8 == VAR_14[VAR_6].prefixCode)
{
if (VAR_14[VAR_6].tokenType == 0)
{
zgfx_GetBits(VAR_0, VAR_14[VAR_6].valueBits);
VAR_3 = (BYTE)(VAR_14[VAR_6].valueBase + VAR_0->bits);
VAR_0->HistoryBuffer[VAR_0->HistoryIndex] = VAR_3;
if (++VAR_0->HistoryIndex == VAR_0->HistoryBufferSize)
VAR_0->HistoryIndex = 0;
VAR_0->OutputBuffer[VAR_0->OutputCount++] = VAR_3;
}
else
{
zgfx_GetBits(VAR_0, VAR_14[VAR_6].valueBits);
VAR_10 = VAR_14[VAR_6].valueBase + VAR_0->bits;
if (VAR_10 != 0)
{
zgfx_GetBits(VAR_0, 1);
if (VAR_0->bits == 0)
{
VAR_9 = 3;
}
else
{
VAR_9 = 4;
VAR_5 = 2;
zgfx_GetBits(VAR_0, 1);
while (VAR_0->bits == 1)
{
VAR_9 *= 2;
VAR_5++;
zgfx_GetBits(VAR_0, 1);
}
zgfx_GetBits(VAR_0, VAR_5);
VAR_9 += VAR_0->bits;
}
zgfx_history_buffer_ring_read(VAR_0, VAR_10, &(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_9);
zgfx_history_buffer_ring_write(VAR_0, &(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_9);
VAR_0->OutputCount += VAR_9;
}
else
{
zgfx_GetBits(VAR_0, 15);
VAR_9 = VAR_0->bits;
VAR_0->cBitsRemaining -= VAR_0->cBitsCurrent;
VAR_0->cBitsCurrent = 0;
VAR_0->BitsCurrent = 0;
CopyMemory(&(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_0->pbInputCurrent, VAR_9);
zgfx_history_buffer_ring_write(VAR_0, VAR_0->pbInputCurrent, VAR_9);
VAR_0->pbInputCurrent += VAR_9;
VAR_0->cBitsRemaining -= (8 * VAR_9);
VAR_0->OutputCount += VAR_9;
}
}
break;
}
}
}
return TRUE;
}",FreeRDP/17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7/zgfx.c/vul/before/0.json,"static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)
{
	BYTE c;
	BYTE flags;
	UINT32 extra = 0;
	int opIndex;
	int haveBits;
	int inPrefix;
	UINT32 count;
	UINT32 distance;
	BYTE* pbSegment;
	size_t cbSegment;

	if (!zgfx || !stream)
		return FALSE;

	cbSegment = segmentSize - 1;

	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||
	    (segmentSize > UINT32_MAX))
		return FALSE;

	Stream_Read_UINT8(stream, flags); /* header (1 byte) */
	zgfx->OutputCount = 0;
	pbSegment = Stream_Pointer(stream);
	Stream_Seek(stream, cbSegment);

	if (!(flags & PACKET_COMPRESSED))
	{
		zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);

		if (cbSegment > sizeof(zgfx->OutputBuffer))
			return FALSE;

		CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);
		zgfx->OutputCount = cbSegment;
		return TRUE;
	}

	zgfx->pbInputCurrent = pbSegment;
	zgfx->pbInputEnd = &pbSegment[cbSegment - 1];
	/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */
	zgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;
	zgfx->cBitsCurrent = 0;
	zgfx->BitsCurrent = 0;

	while (zgfx->cBitsRemaining)
	{
		haveBits = 0;
		inPrefix = 0;

		for (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)
		{
			while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)
			{
				zgfx_GetBits(zgfx, 1);
				inPrefix = (inPrefix << 1) + zgfx->bits;
				haveBits++;
			}

			if (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)
			{
				if (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)
				{
					/* Literal */
					zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
					c = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);
					zgfx->HistoryBuffer[zgfx->HistoryIndex] = c;

					if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)
						zgfx->HistoryIndex = 0;

					if (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))
						return FALSE;

					zgfx->OutputBuffer[zgfx->OutputCount++] = c;
				}
				else
				{
					zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
					distance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;

					if (distance != 0)
					{
						/* Match */
						zgfx_GetBits(zgfx, 1);

						if (zgfx->bits == 0)
						{
							count = 3;
						}
						else
						{
							count = 4;
							extra = 2;
							zgfx_GetBits(zgfx, 1);

							while (zgfx->bits == 1)
							{
								count *= 2;
								extra++;
								zgfx_GetBits(zgfx, 1);
							}

							zgfx_GetBits(zgfx, extra);
							count += zgfx->bits;
						}

						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
							return FALSE;

						zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
						zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
						zgfx->OutputCount += count;
					}
					else
					{
						/* Unencoded */
						zgfx_GetBits(zgfx, 15);
						count = zgfx->bits;
						zgfx->cBitsRemaining -= zgfx->cBitsCurrent;
						zgfx->cBitsCurrent = 0;
						zgfx->BitsCurrent = 0;

						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
							return FALSE;

						CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);
						zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);
						zgfx->pbInputCurrent += count;
						zgfx->cBitsRemaining -= (8 * count);
						zgfx->OutputCount += count;
					}
				}

				break;
			}
		}
	}

	return TRUE;
}","static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* VAR_0, wStream* VAR_1, size_t VAR_2)
{
	BYTE VAR_3;
	BYTE VAR_4;
	UINT32 VAR_5 = 0;
	int VAR_6;
	int VAR_7;
	int VAR_8;
	UINT32 VAR_9;
	UINT32 VAR_10;
	BYTE* VAR_11;
	size_t VAR_12;

	if (!VAR_0 || !VAR_1)
		return FALSE;

	VAR_12 = VAR_2 - 1;

	if ((Stream_GetRemainingLength(VAR_1) < VAR_2) || (VAR_2 < 1) ||
	    (VAR_2 > VAR_13))
		return FALSE;

	Stream_Read_UINT8(VAR_1, VAR_4); /* COMMENT_0 */
	VAR_0->OutputCount = 0;
	VAR_11 = Stream_Pointer(VAR_1);
	Stream_Seek(VAR_1, VAR_12);

	if (!(VAR_4 & VAR_14))
	{
		zgfx_history_buffer_ring_write(VAR_0, VAR_11, VAR_12);

		if (VAR_12 > sizeof(VAR_0->OutputBuffer))
			return FALSE;

		CopyMemory(VAR_0->OutputBuffer, VAR_11, VAR_12);
		VAR_0->OutputCount = VAR_12;
		return TRUE;
	}

	VAR_0->pbInputCurrent = VAR_11;
	VAR_0->pbInputEnd = &VAR_11[VAR_12 - 1];
	/* COMMENT_1 */
	VAR_0->cBitsRemaining = 8 * (VAR_12 - 1) - *VAR_0->pbInputEnd;
	VAR_0->cBitsCurrent = 0;
	VAR_0->BitsCurrent = 0;

	while (VAR_0->cBitsRemaining)
	{
		VAR_7 = 0;
		VAR_8 = 0;

		for (VAR_6 = 0; VAR_15[VAR_6].prefixLength != 0; VAR_6++)
		{
			while (VAR_7 < VAR_15[VAR_6].prefixLength)
			{
				zgfx_GetBits(VAR_0, 1);
				VAR_8 = (VAR_8 << 1) + VAR_0->bits;
				VAR_7++;
			}

			if (VAR_8 == VAR_15[VAR_6].prefixCode)
			{
				if (VAR_15[VAR_6].tokenType == 0)
				{
					/* COMMENT_2 */
					zgfx_GetBits(VAR_0, VAR_15[VAR_6].valueBits);
					VAR_3 = (BYTE)(VAR_15[VAR_6].valueBase + VAR_0->bits);
					VAR_0->HistoryBuffer[VAR_0->HistoryIndex] = VAR_3;

					if (++VAR_0->HistoryIndex == VAR_0->HistoryBufferSize)
						VAR_0->HistoryIndex = 0;

					if (VAR_0->OutputCount >= sizeof(VAR_0->OutputBuffer))
						return FALSE;

					VAR_0->OutputBuffer[VAR_0->OutputCount++] = VAR_3;
				}
				else
				{
					zgfx_GetBits(VAR_0, VAR_15[VAR_6].valueBits);
					VAR_10 = VAR_15[VAR_6].valueBase + VAR_0->bits;

					if (VAR_10 != 0)
					{
						/* COMMENT_3 */
						zgfx_GetBits(VAR_0, 1);

						if (VAR_0->bits == 0)
						{
							VAR_9 = 3;
						}
						else
						{
							VAR_9 = 4;
							VAR_5 = 2;
							zgfx_GetBits(VAR_0, 1);

							while (VAR_0->bits == 1)
							{
								VAR_9 *= 2;
								VAR_5++;
								zgfx_GetBits(VAR_0, 1);
							}

							zgfx_GetBits(VAR_0, VAR_5);
							VAR_9 += VAR_0->bits;
						}

						if (VAR_9 > sizeof(VAR_0->OutputBuffer) - VAR_0->OutputCount)
							return FALSE;

						zgfx_history_buffer_ring_read(VAR_0, VAR_10, &(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_9);
						zgfx_history_buffer_ring_write(VAR_0, &(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_9);
						VAR_0->OutputCount += VAR_9;
					}
					else
					{
						/* COMMENT_4 */
						zgfx_GetBits(VAR_0, 15);
						VAR_9 = VAR_0->bits;
						VAR_0->cBitsRemaining -= VAR_0->cBitsCurrent;
						VAR_0->cBitsCurrent = 0;
						VAR_0->BitsCurrent = 0;

						if (VAR_9 > sizeof(VAR_0->OutputBuffer) - VAR_0->OutputCount)
							return FALSE;

						CopyMemory(&(VAR_0->OutputBuffer[VAR_0->OutputCount]), VAR_0->pbInputCurrent, VAR_9);
						zgfx_history_buffer_ring_write(VAR_0, VAR_0->pbInputCurrent, VAR_9);
						VAR_0->pbInputCurrent += VAR_9;
						VAR_0->cBitsRemaining -= (8 * VAR_9);
						VAR_0->OutputCount += VAR_9;
					}
				}

				break;
			}
		}
	}

	return TRUE;
}",FreeRDP/17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7/zgfx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,9 +9,15 @@
 	UINT32 count;
 	UINT32 distance;
 	BYTE* pbSegment;
-	size_t cbSegment = segmentSize - 1;
+	size_t cbSegment;
 
-	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))
+	if (!zgfx || !stream)
+		return FALSE;
+
+	cbSegment = segmentSize - 1;
+
+	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||
+	    (segmentSize > UINT32_MAX))
 		return FALSE;
 
 	Stream_Read_UINT8(stream, flags); /* header (1 byte) */
@@ -22,6 +28,10 @@
 	if (!(flags & PACKET_COMPRESSED))
 	{
 		zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);
+
+		if (cbSegment > sizeof(zgfx->OutputBuffer))
+			return FALSE;
+
 		CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);
 		zgfx->OutputCount = cbSegment;
 		return TRUE;
@@ -60,6 +70,9 @@
 					if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)
 						zgfx->HistoryIndex = 0;
 
+					if (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))
+						return FALSE;
+
 					zgfx->OutputBuffer[zgfx->OutputCount++] = c;
 				}
 				else
@@ -93,6 +106,9 @@
 							count += zgfx->bits;
 						}
 
+						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
+							return FALSE;
+
 						zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
 						zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
 						zgfx->OutputCount += count;
@@ -105,6 +121,10 @@
 						zgfx->cBitsRemaining -= zgfx->cBitsCurrent;
 						zgfx->cBitsCurrent = 0;
 						zgfx->BitsCurrent = 0;
+
+						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
+							return FALSE;
+
 						CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);
 						zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);
 						zgfx->pbInputCurrent += count;","{'deleted_lines': ['\tsize_t cbSegment = segmentSize - 1;', '\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))'], 'added_lines': ['\tsize_t cbSegment;', '\tif (!zgfx || !stream)', '\t\treturn FALSE;', '', '\tcbSegment = segmentSize - 1;', '', '\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||', '\t    (segmentSize > UINT32_MAX))', '', '\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))', '\t\t\treturn FALSE;', '', '\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))', '\t\t\t\t\t\treturn FALSE;', '', '\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)', '\t\t\t\t\t\t\treturn FALSE;', '', '', '\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)', '\t\t\t\t\t\t\treturn FALSE;', '']}",True,FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress_segment() that results in a memory corruption and probably even a remote code execution.,9.8,CRITICAL,3,valid,2018-10-22T15:51:26Z,2
CVE-2018-18928,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,unicode-org/icu,ICU-20246 Fixing another integer overflow in number parsing.,53d8c8f3d181d87a6aa925b449b51c4a2c922a51,https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51,icu4c/source/i18n/fmtable.cpp,Formattable::internalGetCharString,"CharString *Formattable::internalGetCharString(UErrorCode &status) {
if(fDecimalStr == NULL) {
if (fDecimalQuantity == NULL) {
LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);
if (U_FAILURE(status)) { return nullptr; }
populateDecimalQuantity(*dq, status);
if (U_FAILURE(status)) { return nullptr; }
fDecimalQuantity = dq.orphan();
}
fDecimalStr = new CharString();
if (fDecimalStr == NULL) {
status = U_MEMORY_ALLOCATION_ERROR;
return NULL;
}
if (fDecimalQuantity->isZero()) {
fDecimalStr->append(""0"", -1, status);
} else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {
fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);
} else {
fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);
}
}
return fDecimalStr;
}","CharString *Formattable::internalGetCharString(UErrorCode &VAR_0) {
if(VAR_1 == NULL) {
if (VAR_2 == NULL) {
LocalPointer<DecimalQuantity> VAR_3(new DecimalQuantity(), VAR_0);
if (U_FAILURE(VAR_0)) { return nullptr; }
populateDecimalQuantity(*VAR_3, VAR_0);
if (U_FAILURE(VAR_0)) { return nullptr; }
VAR_2 = VAR_3.orphan();
}
VAR_1 = new CharString();
if (VAR_1 == NULL) {
VAR_0 = VAR_4;
return NULL;
}
if (VAR_2->isZero()) {
VAR_1->append(""0"", -1, VAR_0);
} else if (std::abs(VAR_2->getMagnitude()) < 5) {
VAR_1->appendInvariantChars(VAR_2->toPlainString(), VAR_0);
} else {
VAR_1->appendInvariantChars(VAR_2->toScientificString(), VAR_0);
}
}
return VAR_1;
}",unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/fmtable.cpp/vul/before/0.json,"CharString *Formattable::internalGetCharString(UErrorCode &status) {
    if(fDecimalStr == NULL) {
      if (fDecimalQuantity == NULL) {
        // No decimal number for the formattable yet.  Which means the value was
        // set directly by the user as an int, int64 or double.  If the value came
        // from parsing, or from the user setting a decimal number, fDecimalNum
        // would already be set.
        //
        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);
        if (U_FAILURE(status)) { return nullptr; }
        populateDecimalQuantity(*dq, status);
        if (U_FAILURE(status)) { return nullptr; }
        fDecimalQuantity = dq.orphan();
      }

      fDecimalStr = new CharString();
      if (fDecimalStr == NULL) {
        status = U_MEMORY_ALLOCATION_ERROR;
        return NULL;
      }
      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as
      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does
      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).
      if (fDecimalQuantity->isZero()) {
        fDecimalStr->append(""0"", -1, status);
      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {
        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);
      } else {
        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);
      }
    }
    return fDecimalStr;
}","CharString *Formattable::internalGetCharString(UErrorCode &VAR_0) {
    if(VAR_1 == NULL) {
      if (VAR_2 == NULL) {
        /* COMMENT_0 */
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */
        /* COMMENT_4 */
        LocalPointer<DecimalQuantity> VAR_3(new DecimalQuantity(), VAR_0);
        if (U_FAILURE(VAR_0)) { return nullptr; }
        populateDecimalQuantity(*VAR_3, VAR_0);
        if (U_FAILURE(VAR_0)) { return nullptr; }
        VAR_2 = VAR_3.orphan();
      }

      VAR_1 = new CharString();
      if (VAR_1 == NULL) {
        VAR_0 = VAR_4;
        return NULL;
      }
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      if (VAR_2->isZero()) {
        VAR_1->append(""0"", -1, VAR_0);
      } else if (VAR_2->getMagnitude() != VAR_5 && std::abs(VAR_2->getMagnitude()) < 5) {
        VAR_1->appendInvariantChars(VAR_2->toPlainString(), VAR_0);
      } else {
        VAR_1->appendInvariantChars(VAR_2->toScientificString(), VAR_0);
      }
    }
    return VAR_1;
}",unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/fmtable.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,7 +23,7 @@
       // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).
       if (fDecimalQuantity->isZero()) {
         fDecimalStr->append(""0"", -1, status);
-      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {
+      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {
         fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);
       } else {
         fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);","{'deleted_lines': ['      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {'], 'added_lines': ['      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {']}",True,International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp.,9.8,CRITICAL,3,valid,2018-10-30T06:52:44Z,2
CVE-2018-18928,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,unicode-org/icu,ICU-20246 Fixing another integer overflow in number parsing.,53d8c8f3d181d87a6aa925b449b51c4a2c922a51,https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51,icu4c/source/i18n/number_decimalquantity.cpp,DecimalQuantity::toScientificString,"UnicodeString DecimalQuantity::toScientificString() const {
U_ASSERT(!isApproximate);
UnicodeString result;
if (isNegative()) {
result.append(u'-');
}
if (precision == 0) {
result.append(u""0E+0"", -1);
return result;
}
int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;
int32_t lowerPos = std::max(scale, rOptPos) - scale;
int32_t p = upperPos;
result.append(u'0' + getDigitPos(p));
if ((--p) >= lowerPos) {
result.append(u'.');
for (; p >= lowerPos; p--) {
result.append(u'0' + getDigitPos(p));
}
}
result.append(u'E');
int32_t _scale = upperPos + scale;
if (_scale < 0) {
_scale *= -1;
result.append(u'-');
} else {
result.append(u'+');
}
if (_scale == 0) {
result.append(u'0');
}
int32_t insertIndex = result.length();
while (_scale > 0) {
std::div_t res = std::div(_scale, 10);
result.insert(insertIndex, u'0' + res.rem);
_scale = res.quot;
}
return result;
}","UnicodeString DecimalQuantity::toScientificString() const {
U_ASSERT(!VAR_0);
UnicodeString VAR_1;
if (isNegative()) {
VAR_1.append(u'-');
}
if (VAR_2 == 0) {
VAR_1.append(u""0E+0"", -1);
return VAR_1;
}
int32_t VAR_3 = std::min(VAR_2 + VAR_4, VAR_5) - VAR_4 - 1;
int32_t VAR_6 = std::max(VAR_4, VAR_7) - VAR_4;
int32_t VAR_8 = VAR_3;
VAR_1.append(u'0' + getDigitPos(VAR_8));
if ((--VAR_8) >= VAR_6) {
VAR_1.append(u'.');
for (; VAR_8 >= VAR_6; VAR_8--) {
VAR_1.append(u'0' + getDigitPos(VAR_8));
}
}
VAR_1.append(u'E');
int32_t VAR_9 = VAR_3 + VAR_4;
if (VAR_9 < 0) {
VAR_9 *= -1;
VAR_1.append(u'-');
} else {
VAR_1.append(u'+');
}
if (VAR_9 == 0) {
VAR_1.append(u'0');
}
int32_t VAR_10 = VAR_1.length();
while (VAR_9 > 0) {
std::div_t VAR_11 = std::div(VAR_9, 10);
VAR_1.insert(VAR_10, u'0' + VAR_11.rem);
VAR_9 = VAR_11.quot;
}
return VAR_1;
}",unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/number_decimalquantity.cpp/vul/before/0.json,"UnicodeString DecimalQuantity::toScientificString() const {
    U_ASSERT(!isApproximate);
    UnicodeString result;
    if (isNegative()) {
        result.append(u'-');
    }
    if (precision == 0) {
        result.append(u""0E+0"", -1);
        return result;
    }
    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from
    // rOptPos (aka -maxFrac) due to overflow.
    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;
    int32_t lowerPos = std::max(scale, rOptPos) - scale;
    int32_t p = upperPos;
    result.append(u'0' + getDigitPos(p));
    if ((--p) >= lowerPos) {
        result.append(u'.');
        for (; p >= lowerPos; p--) {
            result.append(u'0' + getDigitPos(p));
        }
    }
    result.append(u'E');
    int32_t _scale = upperPos + scale;
    if (_scale == INT32_MIN) {
        result.append({u""-2147483648"", -1});
        return result;
    } else if (_scale < 0) {
        _scale *= -1;
        result.append(u'-');
    } else {
        result.append(u'+');
    }
    if (_scale == 0) {
        result.append(u'0');
    }
    int32_t insertIndex = result.length();
    while (_scale > 0) {
        std::div_t res = std::div(_scale, 10);
        result.insert(insertIndex, u'0' + res.rem);
        _scale = res.quot;
    }
    return result;
}","UnicodeString DecimalQuantity::toScientificString() const {
    U_ASSERT(!VAR_0);
    UnicodeString VAR_1;
    if (isNegative()) {
        VAR_1.append(u'-');
    }
    if (VAR_2 == 0) {
        VAR_1.append(u""0E+0"", -1);
        return VAR_1;
    }
    /* COMMENT_0 */
    /* COMMENT_1 */
    int32_t VAR_3 = std::min(VAR_2 + VAR_4, VAR_5) - VAR_4 - 1;
    int32_t VAR_6 = std::max(VAR_4, VAR_7) - VAR_4;
    int32_t VAR_8 = VAR_3;
    VAR_1.append(u'0' + getDigitPos(VAR_8));
    if ((--VAR_8) >= VAR_6) {
        VAR_1.append(u'.');
        for (; VAR_8 >= VAR_6; VAR_8--) {
            VAR_1.append(u'0' + getDigitPos(VAR_8));
        }
    }
    VAR_1.append(u'E');
    int32_t VAR_9 = VAR_3 + VAR_4;
    if (VAR_9 == VAR_10) {
        VAR_1.append({u""-2147483648"", -1});
        return VAR_1;
    } else if (VAR_9 < 0) {
        VAR_9 *= -1;
        VAR_1.append(u'-');
    } else {
        VAR_1.append(u'+');
    }
    if (VAR_9 == 0) {
        VAR_1.append(u'0');
    }
    int32_t VAR_11 = VAR_1.length();
    while (VAR_9 > 0) {
        std::div_t VAR_12 = std::div(VAR_9, 10);
        VAR_1.insert(VAR_11, u'0' + VAR_12.rem);
        VAR_9 = VAR_12.quot;
    }
    return VAR_1;
}",unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/number_decimalquantity.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,7 +22,10 @@
     }
     result.append(u'E');
     int32_t _scale = upperPos + scale;
-    if (_scale < 0) {
+    if (_scale == INT32_MIN) {
+        result.append({u""-2147483648"", -1});
+        return result;
+    } else if (_scale < 0) {
         _scale *= -1;
         result.append(u'-');
     } else {","{'deleted_lines': ['    if (_scale < 0) {'], 'added_lines': ['    if (_scale == INT32_MIN) {', '        result.append({u""-2147483648"", -1});', '        return result;', '    } else if (_scale < 0) {']}",True,International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp.,9.8,CRITICAL,3,valid,2018-10-30T06:52:44Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_get_property,"static void
g_keyfile_settings_backend_get_property (GObject    *object,
guint       prop_id,
GValue     *value,
GParamSpec *pspec)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
switch (prop_id)
{
case PROP_FILENAME:
g_value_set_string (value, g_file_peek_path (kfsb->file));
break;
case PROP_ROOT_PATH:
g_value_set_string (value, kfsb->prefix);
break;
case PROP_ROOT_GROUP:
g_value_set_string (value, kfsb->root_group);
break;
default:
G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
break;
}
}","static void
g_keyfile_settings_backend_get_property (GObject    *VAR_0,
guint       VAR_1,
GValue     *VAR_2,
GParamSpec *VAR_3)
{
GKeyfileSettingsBackend *VAR_4 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
switch (VAR_1)
{
case VAR_5:
g_value_set_string (VAR_2, g_file_peek_path (VAR_4->file));
break;
case VAR_6:
g_value_set_string (VAR_2, VAR_4->prefix);
break;
case VAR_7:
g_value_set_string (VAR_2, VAR_4->root_group);
break;
default:
G_OBJECT_WARN_INVALID_PROPERTY_ID (VAR_0, VAR_1, VAR_3);
break;
}
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/0.json,"static void
g_keyfile_settings_backend_get_property (GObject    *object,
                                         guint       prop_id,
                                         GValue     *value,
                                         GParamSpec *pspec)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);

  switch ((GKeyfileSettingsBackendProperty)prop_id)
    {
    case PROP_FILENAME:
      g_value_set_string (value, g_file_peek_path (kfsb->file));
      break;

    case PROP_ROOT_PATH:
      g_value_set_string (value, kfsb->prefix);
      break;

    case PROP_ROOT_GROUP:
      g_value_set_string (value, kfsb->root_group);
      break;

    case PROP_DEFAULTS_DIR:
      g_value_set_string (value, kfsb->defaults_dir);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
    }
}","static void
g_keyfile_settings_backend_get_property (GObject    *VAR_0,
                                         guint       VAR_1,
                                         GValue     *VAR_2,
                                         GParamSpec *VAR_3)
{
  GKeyfileSettingsBackend *VAR_4 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  switch ((GKeyfileSettingsBackendProperty)VAR_1)
    {
    case VAR_5:
      g_value_set_string (VAR_2, g_file_peek_path (VAR_4->file));
      break;

    case VAR_6:
      g_value_set_string (VAR_2, VAR_4->prefix);
      break;

    case VAR_7:
      g_value_set_string (VAR_2, VAR_4->root_group);
      break;

    case VAR_8:
      g_value_set_string (VAR_2, VAR_4->defaults_dir);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (VAR_0, VAR_1, VAR_3);
      break;
    }
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 {
   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
 
-  switch (prop_id)
+  switch ((GKeyfileSettingsBackendProperty)prop_id)
     {
     case PROP_FILENAME:
       g_value_set_string (value, g_file_peek_path (kfsb->file));
@@ -20,6 +20,10 @@
       g_value_set_string (value, kfsb->root_group);
       break;
 
+    case PROP_DEFAULTS_DIR:
+      g_value_set_string (value, kfsb->defaults_dir);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;","{'deleted_lines': ['  switch (prop_id)'], 'added_lines': ['  switch ((GKeyfileSettingsBackendProperty)prop_id)', '    case PROP_DEFAULTS_DIR:', '      g_value_set_string (value, kfsb->defaults_dir);', '      break;', '']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_constructed,"static void
g_keyfile_settings_backend_constructed (GObject *object)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
if (kfsb->file == NULL)
{
char *filename = g_build_filename (g_get_user_config_dir (),
""glib-2.0"", ""settings"", ""keyfile"",
NULL);
kfsb->file = g_file_new_for_path (filename);
g_free (filename);
}
if (kfsb->prefix == NULL)
{
kfsb->prefix = g_strdup (""/"");
kfsb->prefix_len = 1;
}
kfsb->keyfile = g_key_file_new ();
kfsb->permission = g_simple_permission_new (TRUE);
kfsb->dir = g_file_get_parent (kfsb->file);
g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);
kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);
kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);
compute_checksum (kfsb->digest, NULL, 0);
g_signal_connect (kfsb->file_monitor, ""changed"",
G_CALLBACK (file_changed), kfsb);
g_signal_connect (kfsb->dir_monitor, ""changed"",
G_CALLBACK (dir_changed), kfsb);
g_keyfile_settings_backend_keyfile_writable (kfsb);
g_keyfile_settings_backend_keyfile_reload (kfsb);
}","static void
g_keyfile_settings_backend_constructed (GObject *VAR_0)
{
GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
if (VAR_1->file == NULL)
{
char *VAR_2 = g_build_filename (g_get_user_config_dir (),
""glib-2.0"", ""settings"", ""keyfile"",
NULL);
VAR_1->file = g_file_new_for_path (VAR_2);
g_free (VAR_2);
}
if (VAR_1->prefix == NULL)
{
VAR_1->prefix = g_strdup (""/"");
VAR_1->prefix_len = 1;
}
VAR_1->keyfile = g_key_file_new ();
VAR_1->permission = g_simple_permission_new (TRUE);
VAR_1->dir = g_file_get_parent (VAR_1->file);
g_file_make_directory_with_parents (VAR_1->dir, NULL, NULL);
VAR_1->file_monitor = g_file_monitor (VAR_1->file, VAR_3, NULL, NULL);
VAR_1->dir_monitor = g_file_monitor (VAR_1->dir, VAR_3, NULL, NULL);
compute_checksum (VAR_1->digest, NULL, 0);
g_signal_connect (VAR_1->file_monitor, ""changed"",
G_CALLBACK (VAR_4), VAR_1);
g_signal_connect (VAR_1->dir_monitor, ""changed"",
G_CALLBACK (VAR_5), VAR_1);
g_keyfile_settings_backend_keyfile_writable (VAR_1);
g_keyfile_settings_backend_keyfile_reload (VAR_1);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/5.json,"static void
g_keyfile_settings_backend_constructed (GObject *object)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);

  if (kfsb->file == NULL)
    {
      char *filename = g_build_filename (g_get_user_config_dir (),
                                         ""glib-2.0"", ""settings"", ""keyfile"",
                                         NULL);
      kfsb->file = g_file_new_for_path (filename);
      g_free (filename);
    }

  if (kfsb->prefix == NULL)
    {
      kfsb->prefix = g_strdup (""/"");
      kfsb->prefix_len = 1;
    }
  
  kfsb->keyfile = g_key_file_new ();
  kfsb->permission = g_simple_permission_new (TRUE);

  kfsb->dir = g_file_get_parent (kfsb->file);
  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);

  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);
  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);

  compute_checksum (kfsb->digest, NULL, 0);

  g_signal_connect (kfsb->file_monitor, ""changed"",
                    G_CALLBACK (file_changed), kfsb);
  g_signal_connect (kfsb->dir_monitor, ""changed"",
                    G_CALLBACK (dir_changed), kfsb);

  g_keyfile_settings_backend_keyfile_writable (kfsb);
  g_keyfile_settings_backend_keyfile_reload (kfsb);

  load_system_settings (kfsb);
}","static void
g_keyfile_settings_backend_constructed (GObject *VAR_0)
{
  GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  if (VAR_1->file == NULL)
    {
      char *VAR_2 = g_build_filename (g_get_user_config_dir (),
                                         ""glib-2.0"", ""settings"", ""keyfile"",
                                         NULL);
      VAR_1->file = g_file_new_for_path (VAR_2);
      g_free (VAR_2);
    }

  if (VAR_1->prefix == NULL)
    {
      VAR_1->prefix = g_strdup (""/"");
      VAR_1->prefix_len = 1;
    }
  
  VAR_1->keyfile = g_key_file_new ();
  VAR_1->permission = g_simple_permission_new (TRUE);

  VAR_1->dir = g_file_get_parent (VAR_1->file);
  g_file_make_directory_with_parents (VAR_1->dir, NULL, NULL);

  VAR_1->file_monitor = g_file_monitor (VAR_1->file, VAR_3, NULL, NULL);
  VAR_1->dir_monitor = g_file_monitor (VAR_1->dir, VAR_3, NULL, NULL);

  compute_checksum (VAR_1->digest, NULL, 0);

  g_signal_connect (VAR_1->file_monitor, ""changed"",
                    G_CALLBACK (VAR_4), VAR_1);
  g_signal_connect (VAR_1->dir_monitor, ""changed"",
                    G_CALLBACK (VAR_5), VAR_1);

  g_keyfile_settings_backend_keyfile_writable (VAR_1);
  g_keyfile_settings_backend_keyfile_reload (VAR_1);

  load_system_settings (VAR_1);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -36,4 +36,6 @@
 
   g_keyfile_settings_backend_keyfile_writable (kfsb);
   g_keyfile_settings_backend_keyfile_reload (kfsb);
+
+  load_system_settings (kfsb);
 }","{'deleted_lines': [], 'added_lines': ['', '  load_system_settings (kfsb);']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_finalize,"static void
g_keyfile_settings_backend_finalize (GObject *object)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
g_key_file_free (kfsb->keyfile);
g_object_unref (kfsb->permission);
g_file_monitor_cancel (kfsb->file_monitor);
g_object_unref (kfsb->file_monitor);
g_object_unref (kfsb->file);
g_file_monitor_cancel (kfsb->dir_monitor);
g_object_unref (kfsb->dir_monitor);
g_object_unref (kfsb->dir);
g_free (kfsb->root_group);
g_free (kfsb->prefix);
G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)
->finalize (object);
}","static void
g_keyfile_settings_backend_finalize (GObject *VAR_0)
{
GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
g_key_file_free (VAR_1->keyfile);
g_object_unref (VAR_1->permission);
g_file_monitor_cancel (VAR_1->file_monitor);
g_object_unref (VAR_1->file_monitor);
g_object_unref (VAR_1->file);
g_file_monitor_cancel (VAR_1->dir_monitor);
g_object_unref (VAR_1->dir_monitor);
g_object_unref (VAR_1->dir);
g_free (VAR_1->root_group);
g_free (VAR_1->prefix);
G_OBJECT_CLASS (VAR_2)
->finalize (VAR_0);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/1.json,"static void
g_keyfile_settings_backend_finalize (GObject *object)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);

  g_key_file_free (kfsb->keyfile);
  g_object_unref (kfsb->permission);
  g_key_file_unref (kfsb->system_keyfile);
  g_hash_table_unref (kfsb->system_locks);
  g_free (kfsb->defaults_dir);

  g_file_monitor_cancel (kfsb->file_monitor);
  g_object_unref (kfsb->file_monitor);
  g_object_unref (kfsb->file);

  g_file_monitor_cancel (kfsb->dir_monitor);
  g_object_unref (kfsb->dir_monitor);
  g_object_unref (kfsb->dir);

  g_free (kfsb->root_group);
  g_free (kfsb->prefix);

  G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)
    ->finalize (object);
}","static void
g_keyfile_settings_backend_finalize (GObject *VAR_0)
{
  GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  g_key_file_free (VAR_1->keyfile);
  g_object_unref (VAR_1->permission);
  g_key_file_unref (VAR_1->system_keyfile);
  g_hash_table_unref (VAR_1->system_locks);
  g_free (VAR_1->defaults_dir);

  g_file_monitor_cancel (VAR_1->file_monitor);
  g_object_unref (VAR_1->file_monitor);
  g_object_unref (VAR_1->file);

  g_file_monitor_cancel (VAR_1->dir_monitor);
  g_object_unref (VAR_1->dir_monitor);
  g_object_unref (VAR_1->dir);

  g_free (VAR_1->root_group);
  g_free (VAR_1->prefix);

  G_OBJECT_CLASS (VAR_2)
    ->finalize (VAR_0);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
 
   g_key_file_free (kfsb->keyfile);
   g_object_unref (kfsb->permission);
+  g_key_file_unref (kfsb->system_keyfile);
+  g_hash_table_unref (kfsb->system_locks);
+  g_free (kfsb->defaults_dir);
 
   g_file_monitor_cancel (kfsb->file_monitor);
   g_object_unref (kfsb->file_monitor);","{'deleted_lines': [], 'added_lines': ['  g_key_file_unref (kfsb->system_keyfile);', '  g_hash_table_unref (kfsb->system_locks);', '  g_free (kfsb->defaults_dir);']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_class_init,"static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)
{
GObjectClass *object_class = G_OBJECT_CLASS (class);
object_class->finalize = g_keyfile_settings_backend_finalize;
object_class->constructed = g_keyfile_settings_backend_constructed;
object_class->get_property = g_keyfile_settings_backend_get_property;
object_class->set_property = g_keyfile_settings_backend_set_property;
class->read = g_keyfile_settings_backend_read;
class->write = g_keyfile_settings_backend_write;
class->write_tree = g_keyfile_settings_backend_write_tree;
class->reset = g_keyfile_settings_backend_reset;
class->get_writable = g_keyfile_settings_backend_get_writable;
class->get_permission = g_keyfile_settings_backend_get_permission;
g_object_class_install_property (object_class,
PROP_FILENAME,
g_param_spec_string (""filename"",
P_(""Filename""),
P_(""The filename""),
NULL,
G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
G_PARAM_STATIC_STRINGS));
g_object_class_install_property (object_class,
PROP_ROOT_PATH,
g_param_spec_string (""root-path"",
P_(""Root path""),
P_(""The root path""),
NULL,
G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
G_PARAM_STATIC_STRINGS));
g_object_class_install_property (object_class,
PROP_ROOT_GROUP,
g_param_spec_string (""root-group"",
P_(""Root group""),
P_(""The root group""),
NULL,
G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
G_PARAM_STATIC_STRINGS));
}","static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *VAR_0)
{
GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);
VAR_1->finalize = VAR_2;
VAR_1->constructed = VAR_3;
VAR_1->get_property = VAR_4;
VAR_1->set_property = VAR_5;
VAR_0->read = VAR_6;
VAR_0->write = VAR_7;
VAR_0->write_tree = VAR_8;
VAR_0->reset = VAR_9;
VAR_0->get_writable = VAR_10;
VAR_0->get_permission = VAR_11;
g_object_class_install_property (VAR_1,
VAR_12,
g_param_spec_string (""filename"",
P_(""Filename""),
P_(""The filename""),
NULL,
VAR_13 | VAR_14 |
VAR_15));
g_object_class_install_property (VAR_1,
VAR_16,
g_param_spec_string (""root-path"",
P_(""Root path""),
P_(""The root path""),
NULL,
VAR_13 | VAR_14 |
VAR_15));
g_object_class_install_property (VAR_1,
VAR_17,
g_param_spec_string (""root-group"",
P_(""Root group""),
P_(""The root group""),
NULL,
VAR_13 | VAR_14 |
VAR_15));
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/6.json,"static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)
{
  GObjectClass *object_class = G_OBJECT_CLASS (class);

  object_class->finalize = g_keyfile_settings_backend_finalize;
  object_class->constructed = g_keyfile_settings_backend_constructed;
  object_class->get_property = g_keyfile_settings_backend_get_property;
  object_class->set_property = g_keyfile_settings_backend_set_property;

  class->read = g_keyfile_settings_backend_read;
  class->write = g_keyfile_settings_backend_write;
  class->write_tree = g_keyfile_settings_backend_write_tree;
  class->reset = g_keyfile_settings_backend_reset;
  class->get_writable = g_keyfile_settings_backend_get_writable;
  class->get_permission = g_keyfile_settings_backend_get_permission;
  /* No need to implement subscribed/unsubscribe: the only point would be to
   * stop monitoring the file when there's no GSettings anymore, which is no
   * big win.
   */

  /**
   * GKeyfileSettingsBackend:filename:
   *
   * The location where the settings are stored on disk.
   *
   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.
   */
  g_object_class_install_property (object_class,
                                   PROP_FILENAME,
                                   g_param_spec_string (""filename"",
                                                        P_(""Filename""),
                                                        P_(""The filename""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));

  /**
   * GKeyfileSettingsBackend:root-path:
   *
   * All settings read to or written from the backend must fall under the
   * path given in @root_path (which must start and end with a slash and
   * not contain two consecutive slashes).  @root_path may be ""/"".
   * 
   * Defaults to ""/"".
   */
  g_object_class_install_property (object_class,
                                   PROP_ROOT_PATH,
                                   g_param_spec_string (""root-path"",
                                                        P_(""Root path""),
                                                        P_(""The root path""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));

  /**
   * GKeyfileSettingsBackend:root-group:
   *
   * If @root_group is non-%NULL then it specifies the name of the keyfile
   * group used for keys that are written directly below the root path.
   *
   * Defaults to NULL.
   */
  g_object_class_install_property (object_class,
                                   PROP_ROOT_GROUP,
                                   g_param_spec_string (""root-group"",
                                                        P_(""Root group""),
                                                        P_(""The root group""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));

  /**
   * GKeyfileSettingsBackend:default-dir:
   *
   * The directory where the system defaults and locks are located.
   *
   * Defaults to `/etc/glib-2.0/settings`.
   */
  g_object_class_install_property (object_class,
                                   PROP_DEFAULTS_DIR,
                                   g_param_spec_string (""defaults-dir"",
                                                        P_(""Default dir""),
                                                        P_(""Defaults dir""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));
}","static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *VAR_0)
{
  GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);

  VAR_1->finalize = VAR_2;
  VAR_1->constructed = VAR_3;
  VAR_1->get_property = VAR_4;
  VAR_1->set_property = VAR_5;

  VAR_0->read = VAR_6;
  VAR_0->write = VAR_7;
  VAR_0->write_tree = VAR_8;
  VAR_0->reset = VAR_9;
  VAR_0->get_writable = VAR_10;
  VAR_0->get_permission = VAR_11;
  /* COMMENT_0 */
                                                                            
             
     

  /* COMMENT_4 */
                                      
    
                                                        
    
                                                              
     
  g_object_class_install_property (VAR_1,
                                   VAR_12,
                                   g_param_spec_string (""filename"",
                                                        P_(""Filename""),
                                                        P_(""The filename""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));

  /* COMMENT_10 */
                                       
    
                                                                         
                                                                        
                                                                  
     
                     
     
  g_object_class_install_property (VAR_1,
                                   VAR_16,
                                   g_param_spec_string (""root-path"",
                                                        P_(""Root path""),
                                                        P_(""The root path""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));

  /* COMMENT_19 */
                                        
    
                                                                          
                                                                       
    
                      
     
  g_object_class_install_property (VAR_1,
                                   VAR_17,
                                   g_param_spec_string (""root-group"",
                                                        P_(""Root group""),
                                                        P_(""The root group""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));

  /* COMMENT_26 */
                                         
    
                                                                   
    
                                          
     
  g_object_class_install_property (VAR_1,
                                   VAR_18,
                                   g_param_spec_string (""defaults-dir"",
                                                        P_(""Default dir""),
                                                        P_(""Defaults dir""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -69,4 +69,20 @@
                                                         NULL,
                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                         G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GKeyfileSettingsBackend:default-dir:
+   *
+   * The directory where the system defaults and locks are located.
+   *
+   * Defaults to `/etc/glib-2.0/settings`.
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_DEFAULTS_DIR,
+                                   g_param_spec_string (""defaults-dir"",
+                                                        P_(""Default dir""),
+                                                        P_(""Defaults dir""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
 }","{'deleted_lines': [], 'added_lines': ['', '  /**', '   * GKeyfileSettingsBackend:default-dir:', '   *', '   * The directory where the system defaults and locks are located.', '   *', '   * Defaults to `/etc/glib-2.0/settings`.', '   */', '  g_object_class_install_property (object_class,', '                                   PROP_DEFAULTS_DIR,', '                                   g_param_spec_string (""defaults-dir"",', '                                                        P_(""Default dir""),', '                                                        P_(""Defaults dir""),', '                                                        NULL,', '                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |', '                                                        G_PARAM_STATIC_STRINGS));']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,set_to_keyfile,"static gboolean
set_to_keyfile (GKeyfileSettingsBackend *kfsb,
const gchar             *key,
GVariant                *value)
{
gchar *group, *name;
if (convert_path (kfsb, key, &group, &name))
{
if (value)
{
gchar *str = g_variant_print (value, FALSE);
g_key_file_set_value (kfsb->keyfile, group, name, str);
g_variant_unref (g_variant_ref_sink (value));
g_free (str);
}
else
{
if (*name == '\0')
{
gchar **groups;
gint i;
groups = g_key_file_get_groups (kfsb->keyfile, NULL);
for (i = 0; groups[i]; i++)
if (group_name_matches (groups[i], group))
g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);
g_strfreev (groups);
}
else
g_key_file_remove_key (kfsb->keyfile, group, name, NULL);
}
g_free (group);
g_free (name);
return TRUE;
}
return FALSE;
}","static gboolean
set_to_keyfile (GKeyfileSettingsBackend *VAR_0,
const gchar             *VAR_1,
GVariant                *VAR_2)
{
gchar *VAR_3, *VAR_4;
if (convert_path (VAR_0, VAR_1, &VAR_3, &VAR_4))
{
if (VAR_2)
{
gchar *VAR_5 = g_variant_print (VAR_2, FALSE);
g_key_file_set_value (VAR_0->keyfile, VAR_3, VAR_4, VAR_5);
g_variant_unref (g_variant_ref_sink (VAR_2));
g_free (VAR_5);
}
else
{
if (*VAR_4 == '\0')
{
gchar **VAR_6;
gint VAR_7;
VAR_6 = g_key_file_get_groups (VAR_0->keyfile, NULL);
for (VAR_7 = 0; VAR_6[VAR_7]; VAR_7++)
if (group_name_matches (VAR_6[VAR_7], VAR_3))
g_key_file_remove_group (VAR_0->keyfile, VAR_6[VAR_7], NULL);
g_strfreev (VAR_6);
}
else
g_key_file_remove_key (VAR_0->keyfile, VAR_3, VAR_4, NULL);
}
g_free (VAR_3);
g_free (VAR_4);
return TRUE;
}
return FALSE;
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/3.json,"static gboolean
set_to_keyfile (GKeyfileSettingsBackend *kfsb,
                const gchar             *key,
                GVariant                *value)
{
  gchar *group, *name;

  if (g_hash_table_contains (kfsb->system_locks, key))
    return FALSE;

  if (convert_path (kfsb, key, &group, &name))
    {
      if (value)
        {
          gchar *str = g_variant_print (value, FALSE);
          g_key_file_set_value (kfsb->keyfile, group, name, str);
          g_variant_unref (g_variant_ref_sink (value));
          g_free (str);
        }
      else
        {
          if (*name == '\0')
            {
              gchar **groups;
              gint i;

              groups = g_key_file_get_groups (kfsb->keyfile, NULL);

              for (i = 0; groups[i]; i++)
                if (group_name_matches (groups[i], group))
                  g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);

              g_strfreev (groups);
            }
          else
            g_key_file_remove_key (kfsb->keyfile, group, name, NULL);
        }

      g_free (group);
      g_free (name);

      return TRUE;
    }

  return FALSE;
}","static gboolean
set_to_keyfile (GKeyfileSettingsBackend *VAR_0,
                const gchar             *VAR_1,
                GVariant                *VAR_2)
{
  gchar *VAR_3, *VAR_4;

  if (g_hash_table_contains (VAR_0->system_locks, VAR_1))
    return FALSE;

  if (convert_path (VAR_0, VAR_1, &VAR_3, &VAR_4))
    {
      if (VAR_2)
        {
          gchar *VAR_5 = g_variant_print (VAR_2, FALSE);
          g_key_file_set_value (VAR_0->keyfile, VAR_3, VAR_4, VAR_5);
          g_variant_unref (g_variant_ref_sink (VAR_2));
          g_free (VAR_5);
        }
      else
        {
          if (*VAR_4 == '\0')
            {
              gchar **VAR_6;
              gint VAR_7;

              VAR_6 = g_key_file_get_groups (VAR_0->keyfile, NULL);

              for (VAR_7 = 0; VAR_6[VAR_7]; VAR_7++)
                if (group_name_matches (VAR_6[VAR_7], VAR_3))
                  g_key_file_remove_group (VAR_0->keyfile, VAR_6[VAR_7], NULL);

              g_strfreev (VAR_6);
            }
          else
            g_key_file_remove_key (VAR_0->keyfile, VAR_3, VAR_4, NULL);
        }

      g_free (VAR_3);
      g_free (VAR_4);

      return TRUE;
    }

  return FALSE;
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -4,6 +4,9 @@
                 GVariant                *value)
 {
   gchar *group, *name;
+
+  if (g_hash_table_contains (kfsb->system_locks, key))
+    return FALSE;
 
   if (convert_path (kfsb, key, &group, &name))
     {","{'deleted_lines': [], 'added_lines': ['', '  if (g_hash_table_contains (kfsb->system_locks, key))', '    return FALSE;']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_set_property,"static void
g_keyfile_settings_backend_set_property (GObject      *object,
guint         prop_id,
const GValue *value,
GParamSpec   *pspec)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
switch (prop_id)
{
case PROP_FILENAME:
g_assert (kfsb->file == NULL);
kfsb->file = g_file_new_for_path (g_value_get_string (value));
break;
case PROP_ROOT_PATH:
g_assert (kfsb->prefix == NULL);
kfsb->prefix = g_value_dup_string (value);
if (kfsb->prefix)
kfsb->prefix_len = strlen (kfsb->prefix);
break;
case PROP_ROOT_GROUP:
g_assert (kfsb->root_group == NULL);
kfsb->root_group = g_value_dup_string (value);
if (kfsb->root_group)
kfsb->root_group_len = strlen (kfsb->root_group);
break;
default:
G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
break;
}
}","static void
g_keyfile_settings_backend_set_property (GObject      *VAR_0,
guint         VAR_1,
const GValue *VAR_2,
GParamSpec   *VAR_3)
{
GKeyfileSettingsBackend *VAR_4 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
switch (VAR_1)
{
case VAR_5:
g_assert (VAR_4->file == NULL);
VAR_4->file = g_file_new_for_path (g_value_get_string (VAR_2));
break;
case VAR_6:
g_assert (VAR_4->prefix == NULL);
VAR_4->prefix = g_value_dup_string (VAR_2);
if (VAR_4->prefix)
VAR_4->prefix_len = strlen (VAR_4->prefix);
break;
case VAR_7:
g_assert (VAR_4->root_group == NULL);
VAR_4->root_group = g_value_dup_string (VAR_2);
if (VAR_4->root_group)
VAR_4->root_group_len = strlen (VAR_4->root_group);
break;
default:
G_OBJECT_WARN_INVALID_PROPERTY_ID (VAR_0, VAR_1, VAR_3);
break;
}
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/7.json,"static void
g_keyfile_settings_backend_set_property (GObject      *object,
                                         guint         prop_id,
                                         const GValue *value,
                                         GParamSpec   *pspec)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);

  switch ((GKeyfileSettingsBackendProperty)prop_id)
    {
    case PROP_FILENAME:
      /* Construct only. */
      g_assert (kfsb->file == NULL);
      kfsb->file = g_file_new_for_path (g_value_get_string (value));
      break;

    case PROP_ROOT_PATH:
      /* Construct only. */
      g_assert (kfsb->prefix == NULL);
      kfsb->prefix = g_value_dup_string (value);
      if (kfsb->prefix)
        kfsb->prefix_len = strlen (kfsb->prefix);
      break;

    case PROP_ROOT_GROUP:
      /* Construct only. */
      g_assert (kfsb->root_group == NULL);
      kfsb->root_group = g_value_dup_string (value);
      if (kfsb->root_group)
        kfsb->root_group_len = strlen (kfsb->root_group);
      break;

    case PROP_DEFAULTS_DIR:
      /* Construct only. */
      g_assert (kfsb->defaults_dir == NULL);
      kfsb->defaults_dir = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
    }
}","static void
g_keyfile_settings_backend_set_property (GObject      *VAR_0,
                                         guint         VAR_1,
                                         const GValue *VAR_2,
                                         GParamSpec   *VAR_3)
{
  GKeyfileSettingsBackend *VAR_4 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  switch ((GKeyfileSettingsBackendProperty)VAR_1)
    {
    case VAR_5:
      /* COMMENT_0 */
      g_assert (VAR_4->file == NULL);
      VAR_4->file = g_file_new_for_path (g_value_get_string (VAR_2));
      break;

    case VAR_6:
      /* COMMENT_0 */
      g_assert (VAR_4->prefix == NULL);
      VAR_4->prefix = g_value_dup_string (VAR_2);
      if (VAR_4->prefix)
        VAR_4->prefix_len = strlen (VAR_4->prefix);
      break;

    case VAR_7:
      /* COMMENT_0 */
      g_assert (VAR_4->root_group == NULL);
      VAR_4->root_group = g_value_dup_string (VAR_2);
      if (VAR_4->root_group)
        VAR_4->root_group_len = strlen (VAR_4->root_group);
      break;

    case VAR_8:
      /* COMMENT_0 */
      g_assert (VAR_4->defaults_dir == NULL);
      VAR_4->defaults_dir = g_value_dup_string (VAR_2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (VAR_0, VAR_1, VAR_3);
      break;
    }
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 {
   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
 
-  switch (prop_id)
+  switch ((GKeyfileSettingsBackendProperty)prop_id)
     {
     case PROP_FILENAME:
       /* Construct only. */
@@ -30,6 +30,12 @@
         kfsb->root_group_len = strlen (kfsb->root_group);
       break;
 
+    case PROP_DEFAULTS_DIR:
+      /* Construct only. */
+      g_assert (kfsb->defaults_dir == NULL);
+      kfsb->defaults_dir = g_value_dup_string (value);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;","{'deleted_lines': ['  switch (prop_id)'], 'added_lines': ['  switch ((GKeyfileSettingsBackendProperty)prop_id)', '    case PROP_DEFAULTS_DIR:', '      /* Construct only. */', '      g_assert (kfsb->defaults_dir == NULL);', '      kfsb->defaults_dir = g_value_dup_string (value);', '      break;', '']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,get_from_keyfile,"static GVariant *
get_from_keyfile (GKeyfileSettingsBackend *kfsb,
const GVariantType      *type,
const gchar             *key)
{
GVariant *return_value = NULL;
gchar *group, *name;
if (convert_path (kfsb, key, &group, &name))
{
gchar *str;
g_assert (*name);
str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);
if (str)
{
return_value = g_variant_parse (type, str, NULL, NULL, NULL);
g_free (str);
}
g_free (group);
g_free (name);
}
return return_value;
}","static GVariant *
get_from_keyfile (GKeyfileSettingsBackend *VAR_0,
const GVariantType      *VAR_1,
const gchar             *VAR_2)
{
GVariant *VAR_3 = NULL;
gchar *VAR_4, *VAR_5;
if (convert_path (VAR_0, VAR_2, &VAR_4, &VAR_5))
{
gchar *VAR_6;
g_assert (*VAR_5);
VAR_6 = g_key_file_get_value (VAR_0->keyfile, VAR_4, VAR_5, NULL);
if (VAR_6)
{
VAR_3 = g_variant_parse (VAR_1, VAR_6, NULL, NULL, NULL);
g_free (VAR_6);
}
g_free (VAR_4);
g_free (VAR_5);
}
return VAR_3;
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/4.json,"static GVariant *
get_from_keyfile (GKeyfileSettingsBackend *kfsb,
                  const GVariantType      *type,
                  const gchar             *key)
{
  GVariant *return_value = NULL;
  gchar *group, *name;

  if (convert_path (kfsb, key, &group, &name))
    {
      gchar *str;
      gchar *sysstr;

      g_assert (*name);

      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);
      str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);
      if (sysstr &&
          (g_hash_table_contains (kfsb->system_locks, key) ||
           str == NULL))
        {
          g_free (str);
          str = g_steal_pointer (&sysstr);
        }

      if (str)
        {
          return_value = g_variant_parse (type, str, NULL, NULL, NULL);
          g_free (str);
        }

      g_free (sysstr);

      g_free (group);
      g_free (name);
    }

  return return_value;
}","static GVariant *
get_from_keyfile (GKeyfileSettingsBackend *VAR_0,
                  const GVariantType      *VAR_1,
                  const gchar             *VAR_2)
{
  GVariant *VAR_3 = NULL;
  gchar *VAR_4, *VAR_5;

  if (convert_path (VAR_0, VAR_2, &VAR_4, &VAR_5))
    {
      gchar *VAR_6;
      gchar *VAR_7;

      g_assert (*VAR_5);

      VAR_7 = g_key_file_get_value (VAR_0->system_keyfile, VAR_4, VAR_5, NULL);
      VAR_6 = g_key_file_get_value (VAR_0->keyfile, VAR_4, VAR_5, NULL);
      if (VAR_7 &&
          (g_hash_table_contains (VAR_0->system_locks, VAR_2) ||
           VAR_6 == NULL))
        {
          g_free (VAR_6);
          VAR_6 = g_steal_pointer (&VAR_7);
        }

      if (VAR_6)
        {
          VAR_3 = g_variant_parse (VAR_1, VAR_6, NULL, NULL, NULL);
          g_free (VAR_6);
        }

      g_free (VAR_7);

      g_free (VAR_4);
      g_free (VAR_5);
    }

  return VAR_3;
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -9,10 +9,19 @@
   if (convert_path (kfsb, key, &group, &name))
     {
       gchar *str;
+      gchar *sysstr;
 
       g_assert (*name);
 
+      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);
       str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);
+      if (sysstr &&
+          (g_hash_table_contains (kfsb->system_locks, key) ||
+           str == NULL))
+        {
+          g_free (str);
+          str = g_steal_pointer (&sysstr);
+        }
 
       if (str)
         {
@@ -20,6 +29,8 @@
           g_free (str);
         }
 
+      g_free (sysstr);
+
       g_free (group);
       g_free (name);
     }","{'deleted_lines': [], 'added_lines': ['      gchar *sysstr;', '      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);', '      if (sysstr &&', '          (g_hash_table_contains (kfsb->system_locks, key) ||', '           str == NULL))', '        {', '          g_free (str);', '          str = g_steal_pointer (&sysstr);', '        }', '      g_free (sysstr);', '']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Add support for defaults to keyfile backend

Stacked databases and locks are dconf features that allow
management software like Fleet Commander to set system-wide
defaults and overrides centrally for applications.

This patch adds minimal support for the same to the keyfile
backend. We look for a keyfile named 'defaults' and a
lock-list named 'locks'.

Suitable files can be produced from a dconf database with
dconf dump and dconf list-locks, respectively.

The default location for these files is /etc/glib-2.0/settings/.
For test purposes, this can be overwritten with the
GSETTINGS_DEFAULTS_DIR environment variable.

Writes always go to the per-user keyfile.",c63e3a4ada9852138042cb69441644bfe06ac430,https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_get_writable,"static gboolean
g_keyfile_settings_backend_get_writable (GSettingsBackend *backend,
const gchar      *name)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);
return kfsb->writable && path_is_valid (kfsb, name);
}","static gboolean
g_keyfile_settings_backend_get_writable (GSettingsBackend *VAR_0,
const gchar      *VAR_1)
{
GKeyfileSettingsBackend *VAR_2 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
return VAR_2->writable && path_is_valid (VAR_2, VAR_1);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/before/2.json,"static gboolean
g_keyfile_settings_backend_get_writable (GSettingsBackend *backend,
                                         const gchar      *name)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);

  return kfsb->writable &&
         !g_hash_table_contains (kfsb->system_locks, name) &&
         path_is_valid (kfsb, name);
}","static gboolean
g_keyfile_settings_backend_get_writable (GSettingsBackend *VAR_0,
                                         const gchar      *VAR_1)
{
  GKeyfileSettingsBackend *VAR_2 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  return VAR_2->writable &&
         !g_hash_table_contains (VAR_2->system_locks, VAR_1) &&
         path_is_valid (VAR_2, VAR_1);
}",GNOME/glib/c63e3a4ada9852138042cb69441644bfe06ac430/gkeyfilesettingsbackend.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,5 +4,7 @@
 {
   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);
 
-  return kfsb->writable && path_is_valid (kfsb, name);
+  return kfsb->writable &&
+         !g_hash_table_contains (kfsb->system_locks, name) &&
+         path_is_valid (kfsb, name);
 }","{'deleted_lines': ['  return kfsb->writable && path_is_valid (kfsb, name);'], 'added_lines': ['  return kfsb->writable &&', '         !g_hash_table_contains (kfsb->system_locks, name) &&', '         path_is_valid (kfsb, name);']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-11-05T21:07:55Z,2
CVE-2019-11922,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,facebook/zstd,fixed T36302429,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,https://github.com/facebook/zstd/commit/3e5cdf1b6a85843e991d7d10f6a2567c15580da0,lib/compress/zstd_compress.c,ZSTD_encodeSequences_body,"FORCE_INLINE_TEMPLATE size_t
ZSTD_encodeSequences_body(
void* dst, size_t dstCapacity,
FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
seqDef const* sequences, size_t nbSeq, int longOffsets)
{
BIT_CStream_t blockStream;
FSE_CState_t  stateMatchLength;
FSE_CState_t  stateOffsetBits;
FSE_CState_t  stateLitLength;
CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); 
FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);
FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);
BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);
if (MEM_32bits()) BIT_flushBits(&blockStream);
BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);
if (MEM_32bits()) BIT_flushBits(&blockStream);
if (longOffsets) {
U32 const ofBits = ofCodeTable[nbSeq-1];
int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
if (extraBits) {
BIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);
BIT_flushBits(&blockStream);
}
BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,
ofBits - extraBits);
} else {
BIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);
}
BIT_flushBits(&blockStream);
{   size_t n;
for (n=nbSeq-2 ; n<nbSeq ; n--) {      
BYTE const llCode = llCodeTable[n];
BYTE const ofCode = ofCodeTable[n];
BYTE const mlCode = mlCodeTable[n];
U32  const llBits = LL_bits[llCode];
U32  const ofBits = ofCode;
U32  const mlBits = ML_bits[mlCode];
DEBUGLOG(6, ""encoding: litlen:%2u - matchlen:%2u - offCode:%7u"",
sequences[n].litLength,
sequences[n].matchLength + MINMATCH,
sequences[n].offset);
FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);         
FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);        
if (MEM_32bits()) BIT_flushBits(&blockStream);                  
FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);          
if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))
BIT_flushBits(&blockStream);                                
BIT_addBits(&blockStream, sequences[n].litLength, llBits);
if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);
BIT_addBits(&blockStream, sequences[n].matchLength, mlBits);
if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);
if (longOffsets) {
int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
if (extraBits) {
BIT_addBits(&blockStream, sequences[n].offset, extraBits);
BIT_flushBits(&blockStream);                            
}
BIT_addBits(&blockStream, sequences[n].offset >> extraBits,
ofBits - extraBits);                            
} else {
BIT_addBits(&blockStream, sequences[n].offset, ofBits);     
}
BIT_flushBits(&blockStream);                                    
}   }
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);
FSE_flushCState(&blockStream, &stateMatchLength);
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing Off state with %u bits"", stateOffsetBits.stateLog);
FSE_flushCState(&blockStream, &stateOffsetBits);
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing LL state with %u bits"", stateLitLength.stateLog);
FSE_flushCState(&blockStream, &stateLitLength);
{   size_t const streamSize = BIT_closeCStream(&blockStream);
if (streamSize==0) return ERROR(dstSize_tooSmall);   
return streamSize;
}
}","FORCE_INLINE_TEMPLATE VAR_0
ZSTD_encodeSequences_body(
void* VAR_1, size_t VAR_2,
FSE_CTable const* VAR_3, BYTE const* VAR_4,
FSE_CTable const* VAR_5, BYTE const* VAR_6,
FSE_CTable const* VAR_7, BYTE const* VAR_8,
seqDef const* VAR_9, size_t VAR_10, int VAR_11)
{
BIT_CStream_t VAR_12;
FSE_CState_t  VAR_13;
FSE_CState_t  VAR_14;
FSE_CState_t  VAR_15;
CHECK_E(BIT_initCStream(&VAR_12, VAR_1, VAR_2), VAR_16); 
FSE_initCState2(&VAR_13, VAR_3, VAR_4[VAR_10-1]);
FSE_initCState2(&VAR_14,  VAR_5,  VAR_6[VAR_10-1]);
FSE_initCState2(&VAR_15,   VAR_7,   VAR_8[VAR_10-1]);
BIT_addBits(&VAR_12, VAR_9[VAR_10-1].litLength, VAR_17[VAR_8[VAR_10-1]]);
if (MEM_32bits()) BIT_flushBits(&VAR_12);
BIT_addBits(&VAR_12, VAR_9[VAR_10-1].matchLength, VAR_18[VAR_4[VAR_10-1]]);
if (MEM_32bits()) BIT_flushBits(&VAR_12);
if (VAR_11) {
U32 const VAR_19 = VAR_6[VAR_10-1];
int const VAR_20 = VAR_19 - MIN(VAR_19, VAR_21-1);
if (VAR_20) {
BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset, VAR_20);
BIT_flushBits(&VAR_12);
}
BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset >> VAR_20,
VAR_19 - VAR_20);
} else {
BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset, VAR_6[VAR_10-1]);
}
BIT_flushBits(&VAR_12);
{   size_t VAR_22;
for (VAR_22=VAR_10-2 ; VAR_22<VAR_10 ; VAR_22--) {      
BYTE const VAR_23 = VAR_8[VAR_22];
BYTE const VAR_24 = VAR_6[VAR_22];
BYTE const VAR_25 = VAR_4[VAR_22];
U32  const VAR_26 = VAR_17[VAR_23];
U32  const VAR_19 = VAR_24;
U32  const VAR_27 = VAR_18[VAR_25];
DEBUGLOG(6, ""encoding: litlen:%2u - matchlen:%2u - offCode:%7u"",
VAR_9[VAR_22].litLength,
VAR_9[VAR_22].matchLength + VAR_28,
VAR_9[VAR_22].offset);
FSE_encodeSymbol(&VAR_12, &VAR_14, VAR_24);         
FSE_encodeSymbol(&VAR_12, &VAR_13, VAR_25);        
if (MEM_32bits()) BIT_flushBits(&VAR_12);                  
FSE_encodeSymbol(&VAR_12, &VAR_15, VAR_23);          
if (MEM_32bits() || (VAR_19+VAR_27+VAR_26 >= 64-7-(VAR_29+VAR_30+VAR_31)))
BIT_flushBits(&VAR_12);                                
BIT_addBits(&VAR_12, VAR_9[VAR_22].litLength, VAR_26);
if (MEM_32bits() && ((VAR_26+VAR_27)>24)) BIT_flushBits(&VAR_12);
BIT_addBits(&VAR_12, VAR_9[VAR_22].matchLength, VAR_27);
if (MEM_32bits() || (VAR_19+VAR_27+VAR_26 > 56)) BIT_flushBits(&VAR_12);
if (VAR_11) {
int const VAR_20 = VAR_19 - MIN(VAR_19, VAR_21-1);
if (VAR_20) {
BIT_addBits(&VAR_12, VAR_9[VAR_22].offset, VAR_20);
BIT_flushBits(&VAR_12);                            
}
BIT_addBits(&VAR_12, VAR_9[VAR_22].offset >> VAR_20,
VAR_19 - VAR_20);                            
} else {
BIT_addBits(&VAR_12, VAR_9[VAR_22].offset, VAR_19);     
}
BIT_flushBits(&VAR_12);                                    
}   }
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", VAR_13.stateLog);
FSE_flushCState(&VAR_12, &VAR_13);
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing Off state with %u bits"", VAR_14.stateLog);
FSE_flushCState(&VAR_12, &VAR_14);
DEBUGLOG(6, ""ZSTD_encodeSequences: flushing LL state with %u bits"", VAR_15.stateLog);
FSE_flushCState(&VAR_12, &VAR_15);
{   size_t const VAR_32 = BIT_closeCStream(&VAR_12);
if (VAR_32==0) return ERROR(VAR_16);   
return VAR_32;
}
}",,"FORCE_INLINE_TEMPLATE size_t
ZSTD_encodeSequences_body(
            void* dst, size_t dstCapacity,
            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
            seqDef const* sequences, size_t nbSeq, int longOffsets)
{
    BIT_CStream_t blockStream;
    FSE_CState_t  stateMatchLength;
    FSE_CState_t  stateOffsetBits;
    FSE_CState_t  stateLitLength;

    CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); /* not enough space remaining */
    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
                (int)(blockStream.endPtr - blockStream.startPtr),
                (unsigned)dstCapacity);

    /* first symbols */
    FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
    FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);
    FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);
    BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);
    if (MEM_32bits()) BIT_flushBits(&blockStream);
    BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);
    if (MEM_32bits()) BIT_flushBits(&blockStream);
    if (longOffsets) {
        U32 const ofBits = ofCodeTable[nbSeq-1];
        int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
        if (extraBits) {
            BIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);
            BIT_flushBits(&blockStream);
        }
        BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,
                    ofBits - extraBits);
    } else {
        BIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);
    }
    BIT_flushBits(&blockStream);

    {   size_t n;
        for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */
            BYTE const llCode = llCodeTable[n];
            BYTE const ofCode = ofCodeTable[n];
            BYTE const mlCode = mlCodeTable[n];
            U32  const llBits = LL_bits[llCode];
            U32  const ofBits = ofCode;
            U32  const mlBits = ML_bits[mlCode];
            DEBUGLOG(6, ""encoding: litlen:%2u - matchlen:%2u - offCode:%7u"",
                        sequences[n].litLength,
                        sequences[n].matchLength + MINMATCH,
                        sequences[n].offset);
                                                                            /* 32b*/  /* 64b*/
                                                                            /* (7)*/  /* (7)*/
            FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);       /* 15 */  /* 15 */
            FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);      /* 24 */  /* 24 */
            if (MEM_32bits()) BIT_flushBits(&blockStream);                  /* (7)*/
            FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);        /* 16 */  /* 33 */
            if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))
                BIT_flushBits(&blockStream);                                /* (7)*/
            BIT_addBits(&blockStream, sequences[n].litLength, llBits);
            if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);
            BIT_addBits(&blockStream, sequences[n].matchLength, mlBits);
            if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);
            if (longOffsets) {
                int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
                if (extraBits) {
                    BIT_addBits(&blockStream, sequences[n].offset, extraBits);
                    BIT_flushBits(&blockStream);                            /* (7)*/
                }
                BIT_addBits(&blockStream, sequences[n].offset >> extraBits,
                            ofBits - extraBits);                            /* 31 */
            } else {
                BIT_addBits(&blockStream, sequences[n].offset, ofBits);     /* 31 */
            }
            BIT_flushBits(&blockStream);                                    /* (7)*/
            DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));
    }   }

    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);
    FSE_flushCState(&blockStream, &stateMatchLength);
    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing Off state with %u bits"", stateOffsetBits.stateLog);
    FSE_flushCState(&blockStream, &stateOffsetBits);
    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing LL state with %u bits"", stateLitLength.stateLog);
    FSE_flushCState(&blockStream, &stateLitLength);

    {   size_t const streamSize = BIT_closeCStream(&blockStream);
        if (streamSize==0) return ERROR(dstSize_tooSmall);   /* not enough space */
        return streamSize;
    }
}","FORCE_INLINE_TEMPLATE VAR_0
ZSTD_encodeSequences_body(
            void* VAR_1, size_t VAR_2,
            FSE_CTable const* VAR_3, BYTE const* VAR_4,
            FSE_CTable const* VAR_5, BYTE const* VAR_6,
            FSE_CTable const* VAR_7, BYTE const* VAR_8,
            seqDef const* VAR_9, size_t VAR_10, int VAR_11)
{
    BIT_CStream_t VAR_12;
    FSE_CState_t  VAR_13;
    FSE_CState_t  VAR_14;
    FSE_CState_t  VAR_15;

    CHECK_E(BIT_initCStream(&VAR_12, VAR_1, VAR_2), VAR_16); /* COMMENT_0 */
    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
                (int)(VAR_12.endPtr - VAR_12.startPtr),
                (unsigned)VAR_2);

    /* COMMENT_1 */
    FSE_initCState2(&VAR_13, VAR_3, VAR_4[VAR_10-1]);
    FSE_initCState2(&VAR_14,  VAR_5,  VAR_6[VAR_10-1]);
    FSE_initCState2(&VAR_15,   VAR_7,   VAR_8[VAR_10-1]);
    BIT_addBits(&VAR_12, VAR_9[VAR_10-1].litLength, VAR_17[VAR_8[VAR_10-1]]);
    if (MEM_32bits()) BIT_flushBits(&VAR_12);
    BIT_addBits(&VAR_12, VAR_9[VAR_10-1].matchLength, VAR_18[VAR_4[VAR_10-1]]);
    if (MEM_32bits()) BIT_flushBits(&VAR_12);
    if (VAR_11) {
        U32 const VAR_19 = VAR_6[VAR_10-1];
        int const VAR_20 = VAR_19 - MIN(VAR_19, VAR_21-1);
        if (VAR_20) {
            BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset, VAR_20);
            BIT_flushBits(&VAR_12);
        }
        BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset >> VAR_20,
                    VAR_19 - VAR_20);
    } else {
        BIT_addBits(&VAR_12, VAR_9[VAR_10-1].offset, VAR_6[VAR_10-1]);
    }
    BIT_flushBits(&VAR_12);

    {   size_t VAR_22;
        for (VAR_22=VAR_10-2 ; VAR_22<VAR_10 ; VAR_22--) {      /* COMMENT_2 */
            BYTE const VAR_23 = VAR_8[VAR_22];
            BYTE const VAR_24 = VAR_6[VAR_22];
            BYTE const VAR_25 = VAR_4[VAR_22];
            U32  const VAR_26 = VAR_17[VAR_23];
            U32  const VAR_19 = VAR_24;
            U32  const VAR_27 = VAR_18[VAR_25];
            DEBUGLOG(6, ""encoding: litlen:%2u - matchlen:%2u - offCode:%7u"",
                        VAR_9[VAR_22].litLength,
                        VAR_9[VAR_22].matchLength + VAR_28,
                        VAR_9[VAR_22].offset);
                                                                            /* COMMENT_3 */  /* COMMENT_4 */
                                                                            /* COMMENT_5 */  /* COMMENT_5 */
            FSE_encodeSymbol(&VAR_12, &VAR_14, VAR_24);       /* COMMENT_6 */  /* COMMENT_6 */
            FSE_encodeSymbol(&VAR_12, &VAR_13, VAR_25);      /* COMMENT_7 */  /* COMMENT_7 */
            if (MEM_32bits()) BIT_flushBits(&VAR_12);                  /* COMMENT_5 */
            FSE_encodeSymbol(&VAR_12, &VAR_15, VAR_23);        /* COMMENT_8 */  /* COMMENT_9 */
            if (MEM_32bits() || (VAR_19+VAR_27+VAR_26 >= 64-7-(VAR_29+VAR_30+VAR_31)))
                BIT_flushBits(&VAR_12);                                /* COMMENT_5 */
            BIT_addBits(&VAR_12, VAR_9[VAR_22].litLength, VAR_26);
            if (MEM_32bits() && ((VAR_26+VAR_27)>24)) BIT_flushBits(&VAR_12);
            BIT_addBits(&VAR_12, VAR_9[VAR_22].matchLength, VAR_27);
            if (MEM_32bits() || (VAR_19+VAR_27+VAR_26 > 56)) BIT_flushBits(&VAR_12);
            if (VAR_11) {
                int const VAR_20 = VAR_19 - MIN(VAR_19, VAR_21-1);
                if (VAR_20) {
                    BIT_addBits(&VAR_12, VAR_9[VAR_22].offset, VAR_20);
                    BIT_flushBits(&VAR_12);                            /* COMMENT_5 */
                }
                BIT_addBits(&VAR_12, VAR_9[VAR_22].offset >> VAR_20,
                            VAR_19 - VAR_20);                            /* COMMENT_10 */
            } else {
                BIT_addBits(&VAR_12, VAR_9[VAR_22].offset, VAR_19);     /* COMMENT_10 */
            }
            BIT_flushBits(&VAR_12);                                    /* COMMENT_5 */
            DEBUGLOG(7, ""remaining space : %i"", (int)(VAR_12.endPtr - VAR_12.ptr));
    }   }

    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", VAR_13.stateLog);
    FSE_flushCState(&VAR_12, &VAR_13);
    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing Off state with %u bits"", VAR_14.stateLog);
    FSE_flushCState(&VAR_12, &VAR_14);
    DEBUGLOG(6, ""ZSTD_encodeSequences: flushing LL state with %u bits"", VAR_15.stateLog);
    FSE_flushCState(&VAR_12, &VAR_15);

    {   size_t const VAR_32 = BIT_closeCStream(&VAR_12);
        if (VAR_32==0) return ERROR(VAR_16);   /* COMMENT_11 */
        return VAR_32;
    }
}",,"--- func_before
+++ func_after
@@ -12,6 +12,9 @@
     FSE_CState_t  stateLitLength;
 
     CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); /* not enough space remaining */
+    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
+                (int)(blockStream.endPtr - blockStream.startPtr),
+                (unsigned)dstCapacity);
 
     /* first symbols */
     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
@@ -71,6 +74,7 @@
                 BIT_addBits(&blockStream, sequences[n].offset, ofBits);     /* 31 */
             }
             BIT_flushBits(&blockStream);                                    /* (7)*/
+            DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));
     }   }
 
     DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);","{'deleted_lines': [], 'added_lines': ['    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",', '                (int)(blockStream.endPtr - blockStream.startPtr),', '                (unsigned)dstCapacity);', '            DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));']}",True,A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,8.1,HIGH,2,valid,2018-11-06T01:50:30Z,2
CVE-2019-11922,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,facebook/zstd,fixed T36302429,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,https://github.com/facebook/zstd/commit/3e5cdf1b6a85843e991d7d10f6a2567c15580da0,lib/compress/zstd_compress.c,ZSTD_buildCTable,"MEM_STATIC size_t
ZSTD_buildCTable(void* dst, size_t dstCapacity,
FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
U32* count, U32 max,
const BYTE* codeTable, size_t nbSeq,
const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
const FSE_CTable* prevCTable, size_t prevCTableSize,
void* workspace, size_t workspaceSize)
{
BYTE* op = (BYTE*)dst;
const BYTE* const oend = op + dstCapacity;
switch (type) {
case set_rle:
*op = codeTable[0];
CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
return 1;
case set_repeat:
memcpy(nextCTable, prevCTable, prevCTableSize);
return 0;
case set_basic:
CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));  
return 0;
case set_compressed: {
S16 norm[MaxSeq + 1];
size_t nbSeq_1 = nbSeq;
const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
if (count[codeTable[nbSeq-1]] > 1) {
count[codeTable[nbSeq-1]]--;
nbSeq_1--;
}
assert(nbSeq_1 > 1);
CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));
{   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);   
if (FSE_isError(NCountSize)) return NCountSize;
CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));
return NCountSize;
}
}
default: return assert(0), ERROR(GENERIC);
}
}","MEM_STATIC VAR_0
ZSTD_buildCTable(void* VAR_1, size_t VAR_2,
FSE_CTable* VAR_3, U32 VAR_4, symbolEncodingType_e VAR_5,
U32* VAR_6, U32 VAR_7,
const BYTE* VAR_8, size_t VAR_9,
const S16* VAR_10, U32 VAR_11, U32 VAR_12,
const FSE_CTable* VAR_13, size_t VAR_14,
void* VAR_15, size_t VAR_16)
{
BYTE* VAR_17 = (BYTE*)VAR_1;
const BYTE* const VAR_18 = VAR_17 + VAR_2;
switch (VAR_5) {
case VAR_19:
*VAR_17 = VAR_8[0];
CHECK_F(FSE_buildCTable_rle(VAR_3, (BYTE)VAR_7));
return 1;
case VAR_20:
memcpy(VAR_3, VAR_13, VAR_14);
return 0;
case VAR_21:
CHECK_F(FSE_buildCTable_wksp(VAR_3, VAR_10, VAR_12, VAR_11, VAR_15, VAR_16));  
return 0;
case VAR_22: {
S16 VAR_23[VAR_24 + 1];
size_t VAR_25 = VAR_9;
const U32 VAR_26 = FSE_optimalTableLog(VAR_4, VAR_9, VAR_7);
if (VAR_6[VAR_8[VAR_9-1]] > 1) {
VAR_6[VAR_8[VAR_9-1]]--;
VAR_25--;
}
assert(VAR_25 > 1);
CHECK_F(FSE_normalizeCount(VAR_23, VAR_26, VAR_6, VAR_25, VAR_7));
{   size_t const VAR_27 = FSE_writeNCount(VAR_17, VAR_18 - VAR_17, VAR_23, VAR_7, VAR_26);   
if (FSE_isError(VAR_27)) return VAR_27;
CHECK_F(FSE_buildCTable_wksp(VAR_3, VAR_23, VAR_7, VAR_26, VAR_15, VAR_16));
return VAR_27;
}
}
default: return assert(0), ERROR(VAR_28);
}
}",,"MEM_STATIC size_t
ZSTD_buildCTable(void* dst, size_t dstCapacity,
                FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
                U32* count, U32 max,
                const BYTE* codeTable, size_t nbSeq,
                const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
                const FSE_CTable* prevCTable, size_t prevCTableSize,
                void* workspace, size_t workspaceSize)
{
    BYTE* op = (BYTE*)dst;
    const BYTE* const oend = op + dstCapacity;
    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);

    switch (type) {
    case set_rle:
        CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
        if (dstCapacity==0) return ERROR(dstSize_tooSmall);
        *op = codeTable[0];
        return 1;
    case set_repeat:
        memcpy(nextCTable, prevCTable, prevCTableSize);
        return 0;
    case set_basic:
        CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));  /* note : could be pre-calculated */
        return 0;
    case set_compressed: {
        S16 norm[MaxSeq + 1];
        size_t nbSeq_1 = nbSeq;
        const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
        if (count[codeTable[nbSeq-1]] > 1) {
            count[codeTable[nbSeq-1]]--;
            nbSeq_1--;
        }
        assert(nbSeq_1 > 1);
        CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));
        {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);   /* overflow protected */
            if (FSE_isError(NCountSize)) return NCountSize;
            CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));
            return NCountSize;
        }
    }
    default: return assert(0), ERROR(GENERIC);
    }
}","MEM_STATIC VAR_0
ZSTD_buildCTable(void* VAR_1, size_t VAR_2,
                FSE_CTable* VAR_3, U32 VAR_4, symbolEncodingType_e VAR_5,
                U32* VAR_6, U32 VAR_7,
                const BYTE* VAR_8, size_t VAR_9,
                const S16* VAR_10, U32 VAR_11, U32 VAR_12,
                const FSE_CTable* VAR_13, size_t VAR_14,
                void* VAR_15, size_t VAR_16)
{
    BYTE* VAR_17 = (BYTE*)VAR_1;
    const BYTE* const VAR_18 = VAR_17 + VAR_2;
    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)VAR_2);

    switch (VAR_5) {
    case VAR_19:
        CHECK_F(FSE_buildCTable_rle(VAR_3, (BYTE)VAR_7));
        if (VAR_2==0) return ERROR(VAR_20);
        *VAR_17 = VAR_8[0];
        return 1;
    case VAR_21:
        memcpy(VAR_3, VAR_13, VAR_14);
        return 0;
    case VAR_22:
        CHECK_F(FSE_buildCTable_wksp(VAR_3, VAR_10, VAR_12, VAR_11, VAR_15, VAR_16));  /* COMMENT_0 */
        return 0;
    case VAR_23: {
        S16 VAR_24[VAR_25 + 1];
        size_t VAR_26 = VAR_9;
        const U32 VAR_27 = FSE_optimalTableLog(VAR_4, VAR_9, VAR_7);
        if (VAR_6[VAR_8[VAR_9-1]] > 1) {
            VAR_6[VAR_8[VAR_9-1]]--;
            VAR_26--;
        }
        assert(VAR_26 > 1);
        CHECK_F(FSE_normalizeCount(VAR_24, VAR_27, VAR_6, VAR_26, VAR_7));
        {   size_t const VAR_28 = FSE_writeNCount(VAR_17, VAR_18 - VAR_17, VAR_24, VAR_7, VAR_27);   /* COMMENT_1 */
            if (FSE_isError(VAR_28)) return VAR_28;
            CHECK_F(FSE_buildCTable_wksp(VAR_3, VAR_24, VAR_7, VAR_27, VAR_15, VAR_16));
            return VAR_28;
        }
    }
    default: return assert(0), ERROR(VAR_29);
    }
}",,"--- func_before
+++ func_after
@@ -9,11 +9,13 @@
 {
     BYTE* op = (BYTE*)dst;
     const BYTE* const oend = op + dstCapacity;
+    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);
 
     switch (type) {
     case set_rle:
+        CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
+        if (dstCapacity==0) return ERROR(dstSize_tooSmall);
         *op = codeTable[0];
-        CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
         return 1;
     case set_repeat:
         memcpy(nextCTable, prevCTable, prevCTableSize);","{'deleted_lines': ['        CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));'], 'added_lines': ['    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);', '        CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));', '        if (dstCapacity==0) return ERROR(dstSize_tooSmall);']}",True,A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,8.1,HIGH,2,valid,2018-11-06T01:50:30Z,2
CVE-2019-11922,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,facebook/zstd,fixed T36302429,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,https://github.com/facebook/zstd/commit/3e5cdf1b6a85843e991d7d10f6a2567c15580da0,lib/compress/zstd_compress.c,ZSTD_encodeSequences,"static size_t ZSTD_encodeSequences(
void* dst, size_t dstCapacity,
FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
{
#if DYNAMIC_BMI2
if (bmi2) {
return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
CTable_MatchLength, mlCodeTable,
CTable_OffsetBits, ofCodeTable,
CTable_LitLength, llCodeTable,
sequences, nbSeq, longOffsets);
}
#endif
(void)bmi2;
return ZSTD_encodeSequences_default(dst, dstCapacity,
CTable_MatchLength, mlCodeTable,
CTable_OffsetBits, ofCodeTable,
CTable_LitLength, llCodeTable,
sequences, nbSeq, longOffsets);
}","static size_t ZSTD_encodeSequences(
void* VAR_0, size_t VAR_1,
FSE_CTable const* VAR_2, BYTE const* VAR_3,
FSE_CTable const* VAR_4, BYTE const* VAR_5,
FSE_CTable const* VAR_6, BYTE const* VAR_7,
seqDef const* VAR_8, size_t VAR_9, int VAR_10, int VAR_11)
{
#if VAR_12
if (VAR_11) {
return ZSTD_encodeSequences_bmi2(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6, VAR_7,
VAR_8, VAR_9, VAR_10);
}
#endif
(void)VAR_11;
return ZSTD_encodeSequences_default(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6, VAR_7,
VAR_8, VAR_9, VAR_10);
}",facebook/zstd/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/zstd_compress.c/vul/before/0.json,"static size_t ZSTD_encodeSequences(
            void* dst, size_t dstCapacity,
            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
            seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
{
    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);
#if DYNAMIC_BMI2
    if (bmi2) {
        return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
                                         CTable_MatchLength, mlCodeTable,
                                         CTable_OffsetBits, ofCodeTable,
                                         CTable_LitLength, llCodeTable,
                                         sequences, nbSeq, longOffsets);
    }
#endif
    (void)bmi2;
    return ZSTD_encodeSequences_default(dst, dstCapacity,
                                        CTable_MatchLength, mlCodeTable,
                                        CTable_OffsetBits, ofCodeTable,
                                        CTable_LitLength, llCodeTable,
                                        sequences, nbSeq, longOffsets);
}","static size_t ZSTD_encodeSequences(
            void* VAR_0, size_t VAR_1,
            FSE_CTable const* VAR_2, BYTE const* VAR_3,
            FSE_CTable const* VAR_4, BYTE const* VAR_5,
            FSE_CTable const* VAR_6, BYTE const* VAR_7,
            seqDef const* VAR_8, size_t VAR_9, int VAR_10, int VAR_11)
{
    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)VAR_1);
#if VAR_12
    if (VAR_11) {
        return ZSTD_encodeSequences_bmi2(VAR_0, VAR_1,
                                         VAR_2, VAR_3,
                                         VAR_4, VAR_5,
                                         VAR_6, VAR_7,
                                         VAR_8, VAR_9, VAR_10);
    }
#endif
    (void)VAR_11;
    return ZSTD_encodeSequences_default(VAR_0, VAR_1,
                                        VAR_2, VAR_3,
                                        VAR_4, VAR_5,
                                        VAR_6, VAR_7,
                                        VAR_8, VAR_9, VAR_10);
}",facebook/zstd/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/zstd_compress.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
 {
+    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);
 #if DYNAMIC_BMI2
     if (bmi2) {
         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,","{'deleted_lines': [], 'added_lines': ['    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);']}",True,A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,8.1,HIGH,2,valid,2018-11-06T01:50:30Z,2
CVE-2019-11922,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,facebook/zstd,fixed T36302429,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,https://github.com/facebook/zstd/commit/3e5cdf1b6a85843e991d7d10f6a2567c15580da0,lib/compress/zstd_compress.c,ZSTD_compressSequences_internal,"MEM_STATIC size_t
ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,
ZSTD_entropyCTables_t const* prevEntropy,
ZSTD_entropyCTables_t* nextEntropy,
ZSTD_CCtx_params const* cctxParams,
void* dst, size_t dstCapacity,
void* workspace, size_t wkspSize,
const int bmi2)
{
const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;
ZSTD_strategy const strategy = cctxParams->cParams.strategy;
U32 count[MaxSeq+1];
FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;
FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;
FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;
U32 LLtype, Offtype, MLtype;   
const seqDef* const sequences = seqStorePtr->sequencesStart;
const BYTE* const ofCodeTable = seqStorePtr->ofCode;
const BYTE* const llCodeTable = seqStorePtr->llCode;
const BYTE* const mlCodeTable = seqStorePtr->mlCode;
BYTE* const ostart = (BYTE*)dst;
BYTE* const oend = ostart + dstCapacity;
BYTE* op = ostart;
size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;
BYTE* seqHead;
BYTE* lastNCount = NULL;
ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
{   const BYTE* const literals = seqStorePtr->litStart;
size_t const litSize = seqStorePtr->lit - literals;
int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);
size_t const cSize = ZSTD_compressLiterals(
&prevEntropy->huf, &nextEntropy->huf,
cctxParams->cParams.strategy, disableLiteralCompression,
op, dstCapacity,
literals, litSize,
workspace, wkspSize,
bmi2);
if (ZSTD_isError(cSize))
return cSize;
assert(cSize <= dstCapacity);
op += cSize;
}
if ((oend-op) < 3  + 1 ) return ERROR(dstSize_tooSmall);
if (nbSeq < 0x7F)
*op++ = (BYTE)nbSeq;
else if (nbSeq < LONGNBSEQ)
op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;
else
op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;
if (nbSeq==0) {
memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));
return op - ostart;
}
seqHead = op++;
ZSTD_seqToCodes(seqStorePtr);
{   U32 max = MaxLL;
size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);   
DEBUGLOG(5, ""Building LL table"");
nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;
LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);
assert(set_basic < set_compressed && set_rle < set_compressed);
assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none)); 
{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,
count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,
prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),
workspace, wkspSize);
if (ZSTD_isError(countSize)) return countSize;
if (LLtype == set_compressed)
lastNCount = op;
op += countSize;
}   }
{   U32 max = MaxOff;
size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);  
ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;
DEBUGLOG(5, ""Building OF table"");
nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;
Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);
assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none)); 
{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,
count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),
workspace, wkspSize);
if (ZSTD_isError(countSize)) return countSize;
if (Offtype == set_compressed)
lastNCount = op;
op += countSize;
}   }
{   U32 max = MaxML;
size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   
DEBUGLOG(5, ""Building ML table"");
nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); 
{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,
count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,
prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),
workspace, wkspSize);
if (ZSTD_isError(countSize)) return countSize;
if (MLtype == set_compressed)
lastNCount = op;
op += countSize;
}   }
*seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));
{   size_t const bitstreamSize = ZSTD_encodeSequences(
op, oend - op,
CTable_MatchLength, mlCodeTable,
CTable_OffsetBits, ofCodeTable,
CTable_LitLength, llCodeTable,
sequences, nbSeq,
longOffsets, bmi2);
if (ZSTD_isError(bitstreamSize)) return bitstreamSize;
op += bitstreamSize;
if (lastNCount && (op - lastNCount) < 4) {
assert(op - lastNCount == 3);
DEBUGLOG(5, ""Avoiding bug in zstd decoder in versions <= 1.3.4 by ""
""emitting an uncompressed block."");
return 0;
}
}
return op - ostart;
}","MEM_STATIC VAR_0
ZSTD_compressSequences_internal(seqStore_t* VAR_1,
ZSTD_entropyCTables_t const* VAR_2,
ZSTD_entropyCTables_t* VAR_3,
ZSTD_CCtx_params const* VAR_4,
void* VAR_5, size_t VAR_6,
void* VAR_7, size_t VAR_8,
const int VAR_9)
{
const int VAR_10 = VAR_4->cParams.windowLog > VAR_11;
ZSTD_strategy const VAR_12 = VAR_4->cParams.strategy;
U32 VAR_13[VAR_14+1];
FSE_CTable* VAR_15 = VAR_3->fse.litlengthCTable;
FSE_CTable* VAR_16 = VAR_3->fse.offcodeCTable;
FSE_CTable* VAR_17 = VAR_3->fse.matchlengthCTable;
U32 VAR_18, VAR_19, VAR_20;   
const seqDef* const VAR_21 = VAR_1->sequencesStart;
const BYTE* const VAR_22 = VAR_1->ofCode;
const BYTE* const VAR_23 = VAR_1->llCode;
const BYTE* const VAR_24 = VAR_1->mlCode;
BYTE* const VAR_25 = (BYTE*)VAR_5;
BYTE* const VAR_26 = VAR_25 + VAR_6;
BYTE* VAR_27 = VAR_25;
size_t const VAR_28 = VAR_1->sequences - VAR_1->sequencesStart;
BYTE* VAR_29;
BYTE* VAR_30 = NULL;
ZSTD_STATIC_ASSERT(VAR_31 >= (1<<MAX(VAR_32,VAR_33)));
{   const BYTE* const VAR_34 = VAR_1->litStart;
size_t const VAR_35 = VAR_1->lit - VAR_34;
int const VAR_36 = (VAR_4->cParams.strategy == VAR_37) && (VAR_4->cParams.targetLength > 0);
size_t const VAR_38 = ZSTD_compressLiterals(
&VAR_2->huf, &VAR_3->huf,
VAR_4->cParams.strategy, VAR_36,
VAR_27, VAR_6,
VAR_34, VAR_35,
VAR_7, VAR_8,
VAR_9);
if (ZSTD_isError(VAR_38))
return VAR_38;
assert(VAR_38 <= VAR_6);
VAR_27 += VAR_38;
}
if ((VAR_26-VAR_27) < 3  + 1 ) return ERROR(VAR_39);
if (VAR_28 < 0x7F)
*VAR_27++ = (BYTE)VAR_28;
else if (VAR_28 < VAR_40)
VAR_27[0] = (BYTE)((VAR_28>>8) + 0x80), VAR_27[1] = (BYTE)VAR_28, VAR_27+=2;
else
VAR_27[0]=0xFF, MEM_writeLE16(VAR_27+1, (VAR_41)(VAR_28 - VAR_40)), VAR_27+=3;
if (VAR_28==0) {
memcpy(&VAR_3->fse, &VAR_2->fse, sizeof(VAR_2->fse));
return VAR_27 - VAR_25;
}
VAR_29 = VAR_27++;
ZSTD_seqToCodes(VAR_1);
{   U32 VAR_42 = VAR_43;
size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_23, VAR_28, VAR_7, VAR_8);   
DEBUGLOG(5, ""Building LL table"");
VAR_3->fse.litlength_repeatMode = VAR_2->fse.litlength_repeatMode;
VAR_18 = ZSTD_selectEncodingType(&VAR_3->fse.litlength_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_33, VAR_2->fse.litlengthCTable, VAR_45, VAR_46, VAR_47, VAR_12);
assert(VAR_48 < VAR_49 && VAR_50 < VAR_49);
assert(!(VAR_18 < VAR_49 && VAR_3->fse.litlength_repeatMode != VAR_51)); 
{   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_15, VAR_33, (symbolEncodingType_e)VAR_18,
VAR_13, VAR_42, VAR_23, VAR_28, VAR_45, VAR_46, VAR_43,
VAR_2->fse.litlengthCTable, sizeof(VAR_2->fse.litlengthCTable),
VAR_7, VAR_8);
if (ZSTD_isError(VAR_52)) return VAR_52;
if (VAR_18 == VAR_49)
VAR_30 = VAR_27;
VAR_27 += VAR_52;
}   }
{   U32 VAR_42 = VAR_53;
size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_22, VAR_28, VAR_7, VAR_8);  
ZSTD_defaultPolicy_e const VAR_54 = (VAR_42 <= VAR_55) ? VAR_47 : VAR_56;
DEBUGLOG(5, ""Building OF table"");
VAR_3->fse.offcode_repeatMode = VAR_2->fse.offcode_repeatMode;
VAR_19 = ZSTD_selectEncodingType(&VAR_3->fse.offcode_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_57, VAR_2->fse.offcodeCTable, VAR_58, VAR_59, VAR_54, VAR_12);
assert(!(VAR_19 < VAR_49 && VAR_3->fse.offcode_repeatMode != VAR_51)); 
{   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_16, VAR_57, (symbolEncodingType_e)VAR_19,
VAR_13, VAR_42, VAR_22, VAR_28, VAR_58, VAR_59, VAR_55,
VAR_2->fse.offcodeCTable, sizeof(VAR_2->fse.offcodeCTable),
VAR_7, VAR_8);
if (ZSTD_isError(VAR_52)) return VAR_52;
if (VAR_19 == VAR_49)
VAR_30 = VAR_27;
VAR_27 += VAR_52;
}   }
{   U32 VAR_42 = VAR_60;
size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_24, VAR_28, VAR_7, VAR_8);   
DEBUGLOG(5, ""Building ML table"");
VAR_3->fse.matchlength_repeatMode = VAR_2->fse.matchlength_repeatMode;
VAR_20 = ZSTD_selectEncodingType(&VAR_3->fse.matchlength_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_32, VAR_2->fse.matchlengthCTable, VAR_61, VAR_62, VAR_47, VAR_12);
assert(!(VAR_20 < VAR_49 && VAR_3->fse.matchlength_repeatMode != VAR_51)); 
{   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_17, VAR_32, (symbolEncodingType_e)VAR_20,
VAR_13, VAR_42, VAR_24, VAR_28, VAR_61, VAR_62, VAR_60,
VAR_2->fse.matchlengthCTable, sizeof(VAR_2->fse.matchlengthCTable),
VAR_7, VAR_8);
if (ZSTD_isError(VAR_52)) return VAR_52;
if (VAR_20 == VAR_49)
VAR_30 = VAR_27;
VAR_27 += VAR_52;
}   }
*VAR_29 = (BYTE)((VAR_18<<6) + (VAR_19<<4) + (VAR_20<<2));
{   size_t const VAR_63 = ZSTD_encodeSequences(
VAR_27, VAR_26 - VAR_27,
VAR_17, VAR_24,
VAR_16, VAR_22,
VAR_15, VAR_23,
VAR_21, VAR_28,
VAR_10, VAR_9);
if (ZSTD_isError(VAR_63)) return VAR_63;
VAR_27 += VAR_63;
if (VAR_30 && (VAR_27 - VAR_30) < 4) {
assert(VAR_27 - VAR_30 == 3);
DEBUGLOG(5, ""Avoiding bug in zstd decoder in versions <= 1.3.4 by ""
""emitting an uncompressed block."");
return 0;
}
}
return VAR_27 - VAR_25;
}",,"MEM_STATIC size_t
ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,
                              ZSTD_entropyCTables_t const* prevEntropy,
                              ZSTD_entropyCTables_t* nextEntropy,
                              ZSTD_CCtx_params const* cctxParams,
                              void* dst, size_t dstCapacity,
                              void* workspace, size_t wkspSize,
                              const int bmi2)
{
    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;
    ZSTD_strategy const strategy = cctxParams->cParams.strategy;
    U32 count[MaxSeq+1];
    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;
    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;
    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;
    U32 LLtype, Offtype, MLtype;   /* compressed, raw or rle */
    const seqDef* const sequences = seqStorePtr->sequencesStart;
    const BYTE* const ofCodeTable = seqStorePtr->ofCode;
    const BYTE* const llCodeTable = seqStorePtr->llCode;
    const BYTE* const mlCodeTable = seqStorePtr->mlCode;
    BYTE* const ostart = (BYTE*)dst;
    BYTE* const oend = ostart + dstCapacity;
    BYTE* op = ostart;
    size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;
    BYTE* seqHead;
    BYTE* lastNCount = NULL;

    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));

    /* Compress literals */
    {   const BYTE* const literals = seqStorePtr->litStart;
        size_t const litSize = seqStorePtr->lit - literals;
        int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);
        size_t const cSize = ZSTD_compressLiterals(
                                    &prevEntropy->huf, &nextEntropy->huf,
                                    cctxParams->cParams.strategy, disableLiteralCompression,
                                    op, dstCapacity,
                                    literals, litSize,
                                    workspace, wkspSize,
                                    bmi2);
        if (ZSTD_isError(cSize))
          return cSize;
        assert(cSize <= dstCapacity);
        op += cSize;
    }

    /* Sequences Header */
    if ((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/) return ERROR(dstSize_tooSmall);
    if (nbSeq < 0x7F)
        *op++ = (BYTE)nbSeq;
    else if (nbSeq < LONGNBSEQ)
        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;
    else
        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;
    if (nbSeq==0) {
        /* Copy the old tables over as if we repeated them */
        memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));
        return op - ostart;
    }

    /* seqHead : flags for FSE encoding type */
    seqHead = op++;

    /* convert length/distances into codes */
    ZSTD_seqToCodes(seqStorePtr);
    /* build CTable for Literal Lengths */
    {   U32 max = MaxLL;
        size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */
        DEBUGLOG(5, ""Building LL table"");
        nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;
        LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);
        assert(set_basic < set_compressed && set_rle < set_compressed);
        assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */
        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,
                                                    count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,
                                                    prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),
                                                    workspace, wkspSize);
            if (ZSTD_isError(countSize)) return countSize;
            if (LLtype == set_compressed)
                lastNCount = op;
            op += countSize;
    }   }
    /* build CTable for Offsets */
    {   U32 max = MaxOff;
        size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */
        /* We can only use the basic table if max <= DefaultMaxOff, otherwise the offsets are too large */
        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;
        DEBUGLOG(5, ""Building OF table"");
        nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;
        Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);
        assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */
        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,
                                                    count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
                                                    prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),
                                                    workspace, wkspSize);
            if (ZSTD_isError(countSize)) return countSize;
            if (Offtype == set_compressed)
                lastNCount = op;
            op += countSize;
    }   }
    /* build CTable for MatchLengths */
    {   U32 max = MaxML;
        size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */
        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));
        nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
        MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
        assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */
        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,
                                                    count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,
                                                    prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),
                                                    workspace, wkspSize);
            if (ZSTD_isError(countSize)) return countSize;
            if (MLtype == set_compressed)
                lastNCount = op;
            op += countSize;
    }   }

    *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));

    {   size_t const bitstreamSize = ZSTD_encodeSequences(
                                        op, oend - op,
                                        CTable_MatchLength, mlCodeTable,
                                        CTable_OffsetBits, ofCodeTable,
                                        CTable_LitLength, llCodeTable,
                                        sequences, nbSeq,
                                        longOffsets, bmi2);
        if (ZSTD_isError(bitstreamSize)) return bitstreamSize;
        op += bitstreamSize;
        /* zstd versions <= 1.3.4 mistakenly report corruption when
         * FSE_readNCount() recieves a buffer < 4 bytes.
         * Fixed by https://github.com/facebook/zstd/pull/1146.
         * This can happen when the last set_compressed table present is 2
         * bytes and the bitstream is only one byte.
         * In this exceedingly rare case, we will simply emit an uncompressed
         * block, since it isn't worth optimizing.
         */
        if (lastNCount && (op - lastNCount) < 4) {
            /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
            assert(op - lastNCount == 3);
            DEBUGLOG(5, ""Avoiding bug in zstd decoder in versions <= 1.3.4 by ""
                        ""emitting an uncompressed block."");
            return 0;
        }
    }

    return op - ostart;
}","MEM_STATIC VAR_0
ZSTD_compressSequences_internal(seqStore_t* VAR_1,
                              ZSTD_entropyCTables_t const* VAR_2,
                              ZSTD_entropyCTables_t* VAR_3,
                              ZSTD_CCtx_params const* VAR_4,
                              void* VAR_5, size_t VAR_6,
                              void* VAR_7, size_t VAR_8,
                              const int VAR_9)
{
    const int VAR_10 = VAR_4->cParams.windowLog > VAR_11;
    ZSTD_strategy const VAR_12 = VAR_4->cParams.strategy;
    U32 VAR_13[VAR_14+1];
    FSE_CTable* VAR_15 = VAR_3->fse.litlengthCTable;
    FSE_CTable* VAR_16 = VAR_3->fse.offcodeCTable;
    FSE_CTable* VAR_17 = VAR_3->fse.matchlengthCTable;
    U32 VAR_18, VAR_19, VAR_20;   /* COMMENT_0 */
    const seqDef* const VAR_21 = VAR_1->sequencesStart;
    const BYTE* const VAR_22 = VAR_1->ofCode;
    const BYTE* const VAR_23 = VAR_1->llCode;
    const BYTE* const VAR_24 = VAR_1->mlCode;
    BYTE* const VAR_25 = (BYTE*)VAR_5;
    BYTE* const VAR_26 = VAR_25 + VAR_6;
    BYTE* VAR_27 = VAR_25;
    size_t const VAR_28 = VAR_1->sequences - VAR_1->sequencesStart;
    BYTE* VAR_29;
    BYTE* VAR_30 = NULL;

    ZSTD_STATIC_ASSERT(VAR_31 >= (1<<MAX(VAR_32,VAR_33)));

    /* COMMENT_1 */
    {   const BYTE* const VAR_34 = VAR_1->litStart;
        size_t const VAR_35 = VAR_1->lit - VAR_34;
        int const VAR_36 = (VAR_4->cParams.strategy == VAR_37) && (VAR_4->cParams.targetLength > 0);
        size_t const VAR_38 = ZSTD_compressLiterals(
                                    &VAR_2->huf, &VAR_3->huf,
                                    VAR_4->cParams.strategy, VAR_36,
                                    VAR_27, VAR_6,
                                    VAR_34, VAR_35,
                                    VAR_7, VAR_8,
                                    VAR_9);
        if (ZSTD_isError(VAR_38))
          return VAR_38;
        assert(VAR_38 <= VAR_6);
        VAR_27 += VAR_38;
    }

    /* COMMENT_2 */
    if ((VAR_26-VAR_27) < 3 /* COMMENT_3 */ + 1 /* COMMENT_4 */) return ERROR(VAR_39);
    if (VAR_28 < 0x7F)
        *VAR_27++ = (BYTE)VAR_28;
    else if (VAR_28 < VAR_40)
        VAR_27[0] = (BYTE)((VAR_28>>8) + 0x80), VAR_27[1] = (BYTE)VAR_28, VAR_27+=2;
    else
        VAR_27[0]=0xFF, MEM_writeLE16(VAR_27+1, (VAR_41)(VAR_28 - VAR_40)), VAR_27+=3;
    if (VAR_28==0) {
        /* COMMENT_5 */
        memcpy(&VAR_3->fse, &VAR_2->fse, sizeof(VAR_2->fse));
        return VAR_27 - VAR_25;
    }

    /* COMMENT_6 */
    VAR_29 = VAR_27++;

    /* COMMENT_7 */
    ZSTD_seqToCodes(VAR_1);
    /* COMMENT_8 */
    {   U32 VAR_42 = VAR_43;
        size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_23, VAR_28, VAR_7, VAR_8);   /* COMMENT_9 */
        DEBUGLOG(5, ""Building LL table"");
        VAR_3->fse.litlength_repeatMode = VAR_2->fse.litlength_repeatMode;
        VAR_18 = ZSTD_selectEncodingType(&VAR_3->fse.litlength_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_33, VAR_2->fse.litlengthCTable, VAR_45, VAR_46, VAR_47, VAR_12);
        assert(VAR_48 < VAR_49 && VAR_50 < VAR_49);
        assert(!(VAR_18 < VAR_49 && VAR_3->fse.litlength_repeatMode != VAR_51)); /* COMMENT_10 */
        {   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_15, VAR_33, (symbolEncodingType_e)VAR_18,
                                                    VAR_13, VAR_42, VAR_23, VAR_28, VAR_45, VAR_46, VAR_43,
                                                    VAR_2->fse.litlengthCTable, sizeof(VAR_2->fse.litlengthCTable),
                                                    VAR_7, VAR_8);
            if (ZSTD_isError(VAR_52)) return VAR_52;
            if (VAR_18 == VAR_49)
                VAR_30 = VAR_27;
            VAR_27 += VAR_52;
    }   }
    /* COMMENT_11 */
    {   U32 VAR_42 = VAR_53;
        size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_22, VAR_28, VAR_7, VAR_8);  /* COMMENT_9 */
        /* COMMENT_12 */
        ZSTD_defaultPolicy_e const VAR_54 = (VAR_42 <= VAR_55) ? VAR_47 : VAR_56;
        DEBUGLOG(5, ""Building OF table"");
        VAR_3->fse.offcode_repeatMode = VAR_2->fse.offcode_repeatMode;
        VAR_19 = ZSTD_selectEncodingType(&VAR_3->fse.offcode_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_57, VAR_2->fse.offcodeCTable, VAR_58, VAR_59, VAR_54, VAR_12);
        assert(!(VAR_19 < VAR_49 && VAR_3->fse.offcode_repeatMode != VAR_51)); /* COMMENT_10 */
        {   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_16, VAR_57, (symbolEncodingType_e)VAR_19,
                                                    VAR_13, VAR_42, VAR_22, VAR_28, VAR_58, VAR_59, VAR_55,
                                                    VAR_2->fse.offcodeCTable, sizeof(VAR_2->fse.offcodeCTable),
                                                    VAR_7, VAR_8);
            if (ZSTD_isError(VAR_52)) return VAR_52;
            if (VAR_19 == VAR_49)
                VAR_30 = VAR_27;
            VAR_27 += VAR_52;
    }   }
    /* COMMENT_13 */
    {   U32 VAR_42 = VAR_60;
        size_t const VAR_44 = HIST_countFast_wksp(VAR_13, &VAR_42, VAR_24, VAR_28, VAR_7, VAR_8);   /* COMMENT_9 */
        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(VAR_26-VAR_27));
        VAR_3->fse.matchlength_repeatMode = VAR_2->fse.matchlength_repeatMode;
        VAR_20 = ZSTD_selectEncodingType(&VAR_3->fse.matchlength_repeatMode, VAR_13, VAR_42, VAR_44, VAR_28, VAR_32, VAR_2->fse.matchlengthCTable, VAR_61, VAR_62, VAR_47, VAR_12);
        assert(!(VAR_20 < VAR_49 && VAR_3->fse.matchlength_repeatMode != VAR_51)); /* COMMENT_10 */
        {   size_t const VAR_52 = ZSTD_buildCTable(VAR_27, VAR_26 - VAR_27, VAR_17, VAR_32, (symbolEncodingType_e)VAR_20,
                                                    VAR_13, VAR_42, VAR_24, VAR_28, VAR_61, VAR_62, VAR_60,
                                                    VAR_2->fse.matchlengthCTable, sizeof(VAR_2->fse.matchlengthCTable),
                                                    VAR_7, VAR_8);
            if (ZSTD_isError(VAR_52)) return VAR_52;
            if (VAR_20 == VAR_49)
                VAR_30 = VAR_27;
            VAR_27 += VAR_52;
    }   }

    *VAR_29 = (BYTE)((VAR_18<<6) + (VAR_19<<4) + (VAR_20<<2));

    {   size_t const VAR_63 = ZSTD_encodeSequences(
                                        VAR_27, VAR_26 - VAR_27,
                                        VAR_17, VAR_24,
                                        VAR_16, VAR_22,
                                        VAR_15, VAR_23,
                                        VAR_21, VAR_28,
                                        VAR_10, VAR_9);
        if (ZSTD_isError(VAR_63)) return VAR_63;
        VAR_27 += VAR_63;
        /* COMMENT_14 */
                                                        
                                                               
                                                                          
                                                    
                                                                             
                                                  
           
        if (VAR_30 && (VAR_27 - VAR_30) < 4) {
            /* COMMENT_22 */
            assert(VAR_27 - VAR_30 == 3);
            DEBUGLOG(5, ""Avoiding bug in zstd decoder in versions <= 1.3.4 by ""
                        ""emitting an uncompressed block."");
            return 0;
        }
    }

    return VAR_27 - VAR_25;
}",,"--- func_before
+++ func_after
@@ -101,7 +101,7 @@
     /* build CTable for MatchLengths */
     {   U32 max = MaxML;
         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */
-        DEBUGLOG(5, ""Building ML table"");
+        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));
         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */","{'deleted_lines': ['        DEBUGLOG(5, ""Building ML table"");'], 'added_lines': ['        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));']}",True,A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,8.1,HIGH,2,valid,2018-11-06T01:50:30Z,2
CVE-2018-19476,['CWE-704'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Bug #700169 - unchecked type

Bug #700169 ""Type confusion in setcolorspace""

In seticc() we extract ""Name"" from a dictionary, if it succeeds we then
use it as a string, without checking the type to see if it is in fact
a string.

Add a check on the type, and add a couple to check that 'N' is an integer
in a few places too.",67d760ab775dae4efe803b5944b0439aa3c0b04a,https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a,psi/zicc.c,zset_outputintent,"static int
zset_outputintent(i_ctx_t * i_ctx_p)
{
os_ptr                  op = osp;
int                     code = 0;
gx_device *dev = gs_currentdevice(igs);
cmm_dev_profile_t       *dev_profile;
stream *                s = 0L;
ref *                   pnval;
ref *                   pstrmval;
int                     ncomps, dev_comps;
cmm_profile_t           *picc_profile;
int                     expected = 0;
gs_color_space_index    index;
gsicc_manager_t         *icc_manager = igs->icc_manager;
cmm_profile_t           *source_profile = NULL;
check_type(*op, t_dictionary);
check_dict_read(*op);
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n"");
code = dev_proc(dev, get_profile)(dev,  &dev_profile);
if (code < 0)
return code;
if (dev_profile == NULL) {
code = gsicc_init_device_profile_struct(dev, NULL, 0);
if (code < 0)
return code;
code = dev_proc(dev, get_profile)(dev,  &dev_profile);
if (code < 0)
return code;
}
if (dev_profile->oi_profile != NULL) {
return 0;  
}
code = dict_find_string(op, ""N"", &pnval);
if (code < 0)
return code;
if (code == 0)
return_error(gs_error_undefined);
ncomps = pnval->value.intval;
if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
return_error(gs_error_undefined);
check_read_file(i_ctx_p, s, pstrmval);
picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
if (picc_profile == NULL)
return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
picc_profile->num_comps = ncomps;
picc_profile->profile_handle =
gsicc_get_profile_handle_buffer(picc_profile->buffer,
picc_profile->buffer_size,
gs_gstate_memory(igs));
if (picc_profile->profile_handle == NULL) {
rc_decrement(picc_profile,""zset_outputintent"");
return -1;
}
picc_profile->data_cs =
gscms_get_profile_data_space(picc_profile->profile_handle,
picc_profile->memory);
switch (picc_profile->data_cs) {
case gsCIEXYZ:
case gsCIELAB:
case gsRGB:
expected = 3;
source_profile = icc_manager->default_rgb;
break;
case gsGRAY:
expected = 1;
source_profile = icc_manager->default_gray;
break;
case gsCMYK:
expected = 4;
source_profile = icc_manager->default_cmyk;
break;
case gsNCHANNEL:
expected = 0;
break;
case gsNAMED:
case gsUNDEFINED:
break;
}
if (expected && ncomps != expected) {
rc_decrement(picc_profile,""zset_outputintent"");
return_error(gs_error_rangecheck);
}
gsicc_init_hash_cs(picc_profile, igs);
dev_profile->oi_profile = picc_profile;
picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,
MAX_DEFAULT_ICC_LENGTH,
""zset_outputintent"");
strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));
picc_profile->name[strlen(OI_PROFILE)] = 0;
picc_profile->name_length = strlen(OI_PROFILE);
gsicc_set_icc_range(&picc_profile);
dev_comps = dev_profile->device_profile[0]->num_comps;
index = gsicc_get_default_type(dev_profile->device_profile[0]);
if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {
rc_assign(dev_profile->device_profile[0], picc_profile,
""zset_outputintent"");
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n"");
} else {
if (dev_profile->proof_profile == NULL) {
dev_profile->proof_profile = picc_profile;
rc_increment(picc_profile);
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n"");
}
}
index = gsicc_get_default_type(source_profile);
if (index < gs_color_space_index_DevicePixel) {
switch (picc_profile->data_cs) {
case gsGRAY:
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n"");
rc_assign(icc_manager->default_gray, picc_profile,
""zset_outputintent"");
break;
case gsRGB:
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n"");
rc_assign(icc_manager->default_rgb, picc_profile,
""zset_outputintent"");
break;
case gsCMYK:
if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n"");
rc_assign(icc_manager->default_cmyk, picc_profile,
""zset_outputintent"");
break;
default:
break;
}
}
pop(1);
return code;
}","static int
zset_outputintent(i_ctx_t * VAR_0)
{
os_ptr                  VAR_1 = VAR_2;
int                     VAR_3 = 0;
gx_device *VAR_4 = gs_currentdevice(VAR_5);
cmm_dev_profile_t       *VAR_6;
stream *                VAR_7 = 0L;
ref *                   VAR_8;
ref *                   VAR_9;
int                     VAR_10, VAR_11;
cmm_profile_t           *VAR_12;
int                     VAR_13 = 0;
gs_color_space_index    VAR_14;
gsicc_manager_t         *VAR_15 = VAR_5->icc_manager;
cmm_profile_t           *VAR_16 = NULL;
check_type(*VAR_1, VAR_17);
check_dict_read(*VAR_1);
if_debug0m(VAR_18, VAR_19, ""[icc] Using OutputIntent\n"");
VAR_3 = dev_proc(VAR_4, VAR_20)(VAR_4,  &VAR_6);
if (VAR_3 < 0)
return VAR_3;
if (VAR_6 == NULL) {
VAR_3 = gsicc_init_device_profile_struct(VAR_4, NULL, 0);
if (VAR_3 < 0)
return VAR_3;
VAR_3 = dev_proc(VAR_4, VAR_20)(VAR_4,  &VAR_6);
if (VAR_3 < 0)
return VAR_3;
}
if (VAR_6->oi_profile != NULL) {
return 0;  
}
VAR_3 = dict_find_string(VAR_1, ""N"", &VAR_8);
if (VAR_3 < 0)
return VAR_3;
if (VAR_3 == 0)
return_error(VAR_21);
VAR_10 = VAR_8->value.intval;
if (dict_find_string(VAR_1, ""DataSource"", &VAR_9) <= 0)
return_error(VAR_21);
check_read_file(VAR_0, VAR_7, VAR_9);
VAR_12 = gsicc_profile_new(VAR_7, gs_gstate_memory(VAR_5), NULL, 0);
if (VAR_12 == NULL)
return gs_throw(VAR_22, ""Creation of ICC profile failed"");
VAR_12->num_comps = VAR_10;
VAR_12->profile_handle =
gsicc_get_profile_handle_buffer(VAR_12->buffer,
VAR_12->buffer_size,
gs_gstate_memory(VAR_5));
if (VAR_12->profile_handle == NULL) {
rc_decrement(VAR_12,""zset_outputintent"");
return -1;
}
VAR_12->data_cs =
gscms_get_profile_data_space(VAR_12->profile_handle,
VAR_12->memory);
switch (VAR_12->data_cs) {
case VAR_23:
case VAR_24:
case VAR_25:
VAR_13 = 3;
VAR_16 = VAR_15->default_rgb;
break;
case VAR_26:
VAR_13 = 1;
VAR_16 = VAR_15->default_gray;
break;
case VAR_27:
VAR_13 = 4;
VAR_16 = VAR_15->default_cmyk;
break;
case VAR_28:
VAR_13 = 0;
break;
case VAR_29:
case VAR_30:
break;
}
if (VAR_13 && VAR_10 != VAR_13) {
rc_decrement(VAR_12,""zset_outputintent"");
return_error(VAR_31);
}
gsicc_init_hash_cs(VAR_12, VAR_5);
VAR_6->oi_profile = VAR_12;
VAR_12->name = (char *) gs_alloc_bytes(VAR_12->memory,
VAR_32,
""zset_outputintent"");
strncpy(VAR_12->name, VAR_33, strlen(VAR_33));
VAR_12->name[strlen(VAR_33)] = 0;
VAR_12->name_length = strlen(VAR_33);
gsicc_set_icc_range(&VAR_12);
VAR_11 = VAR_6->device_profile[0]->num_comps;
VAR_14 = gsicc_get_default_type(VAR_6->device_profile[0]);
if (VAR_10 == VAR_11 && VAR_14 < VAR_34) {
rc_assign(VAR_6->device_profile[0], VAR_12,
""zset_outputintent"");
if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used for device profile\n"");
} else {
if (VAR_6->proof_profile == NULL) {
VAR_6->proof_profile = VAR_12;
rc_increment(VAR_12);
if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used for proof profile\n"");
}
}
VAR_14 = gsicc_get_default_type(VAR_16);
if (VAR_14 < VAR_34) {
switch (VAR_12->data_cs) {
case VAR_26:
if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source Gray\n"");
rc_assign(VAR_15->default_gray, VAR_12,
""zset_outputintent"");
break;
case VAR_25:
if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source RGB\n"");
rc_assign(VAR_15->default_rgb, VAR_12,
""zset_outputintent"");
break;
case VAR_27:
if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source CMYK\n"");
rc_assign(VAR_15->default_cmyk, VAR_12,
""zset_outputintent"");
break;
default:
break;
}
}
pop(1);
return VAR_3;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/before/1.json,"static int
zset_outputintent(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    int                     code = 0;
    gx_device *dev = gs_currentdevice(igs);
    cmm_dev_profile_t       *dev_profile;
    stream *                s = 0L;
    ref *                   pnval;
    ref *                   pstrmval;
    int                     ncomps, dev_comps;
    cmm_profile_t           *picc_profile;
    int                     expected = 0;
    gs_color_space_index    index;
    gsicc_manager_t         *icc_manager = igs->icc_manager;
    cmm_profile_t           *source_profile = NULL;

    check_type(*op, t_dictionary);
    check_dict_read(*op);
    if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n"");

    /* Get the device structure */
    code = dev_proc(dev, get_profile)(dev,  &dev_profile);
    if (code < 0)
        return code;

    if (dev_profile == NULL) {
        code = gsicc_init_device_profile_struct(dev, NULL, 0);
        if (code < 0)
            return code;
        code = dev_proc(dev, get_profile)(dev,  &dev_profile);
        if (code < 0)
            return code;
    }
    if (dev_profile->oi_profile != NULL) {
        return 0;  /* Allow only one setting of this object */
    }
    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
        return code;
    if (code == 0)
        return_error(gs_error_undefined);
    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
    ncomps = pnval->value.intval;

    /* verify the DataSource entry. Creat profile from stream */
    if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return -1;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            source_profile = icc_manager->default_rgb;
            break;
        case gsGRAY:
            expected = 1;
            source_profile = icc_manager->default_gray;
            break;
        case gsCMYK:
            expected = 4;
            source_profile = icc_manager->default_cmyk;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            break;
    }
    if (expected && ncomps != expected) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return_error(gs_error_rangecheck);
    }
    gsicc_init_hash_cs(picc_profile, igs);

    /* All is well with the profile.  Lets set the stuff that needs to be set */
    dev_profile->oi_profile = picc_profile;
    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,
                                                 MAX_DEFAULT_ICC_LENGTH,
                                                 ""zset_outputintent"");
    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));
    picc_profile->name[strlen(OI_PROFILE)] = 0;
    picc_profile->name_length = strlen(OI_PROFILE);
    /* Set the range of the profile */
    gsicc_set_icc_range(&picc_profile);

    /* If the output device has a different number of componenets, then we are
       going to set the output intent as the proofing profile, unless the
       proofing profile has already been set.

       If the device has the same number of components (and color model) then as
       the profile we will use this as the output profile, unless someone has
       explicitly set the output profile.

       Finally, we will use the output intent profile for the default profile
       of the proper Device profile in the icc manager, again, unless someone
       has explicitly set this default profile. */

    dev_comps = dev_profile->device_profile[0]->num_comps;
    index = gsicc_get_default_type(dev_profile->device_profile[0]);
    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {
        /* The OI profile is the same type as the profile for the device and a
           ""default"" profile for the device was not externally set. So we go
           ahead and use the OI profile as the device profile.  Care needs to be
           taken here to keep from screwing up any device parameters.   We will
           use a keyword of OIProfile for the user/device parameter to indicate
           its usage.  Also, note conflicts if one is setting object dependent
           color management */
        rc_assign(dev_profile->device_profile[0], picc_profile,
                  ""zset_outputintent"");
        if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n"");
    } else {
        if (dev_profile->proof_profile == NULL) {
            /* This means that we should use the OI profile as the proofing
               profile.  Note that if someone already has specified a
               proofing profile it is unclear what they are trying to do
               with the output intent.  In this case, we will use it
               just for the source data below */
            dev_profile->proof_profile = picc_profile;
            rc_increment(picc_profile);
            if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n"");
        }
    }
    /* Now the source colors.  See which source color space needs to use the
       output intent ICC profile */
    index = gsicc_get_default_type(source_profile);
    if (index < gs_color_space_index_DevicePixel) {
        /* source_profile is currently the default.  Set it to the OI profile */
        switch (picc_profile->data_cs) {
            case gsGRAY:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n"");
                rc_assign(icc_manager->default_gray, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsRGB:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n"");
                rc_assign(icc_manager->default_rgb, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsCMYK:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n"");
                rc_assign(icc_manager->default_cmyk, picc_profile,
                          ""zset_outputintent"");
                break;
            default:
                break;
        }
    }
    /* Remove the output intent dict from the stack */
    pop(1);
    return code;
}","static int
zset_outputintent(i_ctx_t * VAR_0)
{
    os_ptr                  VAR_1 = VAR_2;
    int                     VAR_3 = 0;
    gx_device *VAR_4 = gs_currentdevice(VAR_5);
    cmm_dev_profile_t       *VAR_6;
    stream *                VAR_7 = 0L;
    ref *                   VAR_8;
    ref *                   VAR_9;
    int                     VAR_10, VAR_11;
    cmm_profile_t           *VAR_12;
    int                     VAR_13 = 0;
    gs_color_space_index    VAR_14;
    gsicc_manager_t         *VAR_15 = VAR_5->icc_manager;
    cmm_profile_t           *VAR_16 = NULL;

    check_type(*VAR_1, VAR_17);
    check_dict_read(*VAR_1);
    if_debug0m(VAR_18, VAR_19, ""[icc] Using OutputIntent\n"");

    /* COMMENT_0 */
    VAR_3 = dev_proc(VAR_4, VAR_20)(VAR_4,  &VAR_6);
    if (VAR_3 < 0)
        return VAR_3;

    if (VAR_6 == NULL) {
        VAR_3 = gsicc_init_device_profile_struct(VAR_4, NULL, 0);
        if (VAR_3 < 0)
            return VAR_3;
        VAR_3 = dev_proc(VAR_4, VAR_20)(VAR_4,  &VAR_6);
        if (VAR_3 < 0)
            return VAR_3;
    }
    if (VAR_6->oi_profile != NULL) {
        return 0;  /* COMMENT_1 */
    }
    VAR_3 = dict_find_string(VAR_1, ""N"", &VAR_8);
    if (VAR_3 < 0)
        return VAR_3;
    if (VAR_3 == 0)
        return_error(VAR_21);
    if (r_type(VAR_8) != VAR_22)
        return gs_note_error(VAR_23);
    VAR_10 = VAR_8->value.intval;

    /* COMMENT_2 */
    if (dict_find_string(VAR_1, ""DataSource"", &VAR_9) <= 0)
        return_error(VAR_21);
    check_read_file(VAR_0, VAR_7, VAR_9);

    VAR_12 = gsicc_profile_new(VAR_7, gs_gstate_memory(VAR_5), NULL, 0);
    if (VAR_12 == NULL)
        return gs_throw(VAR_24, ""Creation of ICC profile failed"");
    VAR_12->num_comps = VAR_10;
    VAR_12->profile_handle =
        gsicc_get_profile_handle_buffer(VAR_12->buffer,
                                        VAR_12->buffer_size,
                                        gs_gstate_memory(VAR_5));
    if (VAR_12->profile_handle == NULL) {
        rc_decrement(VAR_12,""zset_outputintent"");
        return -1;
    }
    VAR_12->data_cs =
        gscms_get_profile_data_space(VAR_12->profile_handle,
            VAR_12->memory);
    switch (VAR_12->data_cs) {
        case VAR_25:
        case VAR_26:
        case VAR_27:
            VAR_13 = 3;
            VAR_16 = VAR_15->default_rgb;
            break;
        case VAR_28:
            VAR_13 = 1;
            VAR_16 = VAR_15->default_gray;
            break;
        case VAR_29:
            VAR_13 = 4;
            VAR_16 = VAR_15->default_cmyk;
            break;
        case VAR_30:
            VAR_13 = 0;
            break;
        case VAR_31:
        case VAR_32:
            break;
    }
    if (VAR_13 && VAR_10 != VAR_13) {
        rc_decrement(VAR_12,""zset_outputintent"");
        return_error(VAR_33);
    }
    gsicc_init_hash_cs(VAR_12, VAR_5);

    /* COMMENT_3 */
    VAR_6->oi_profile = VAR_12;
    VAR_12->name = (char *) gs_alloc_bytes(VAR_12->memory,
                                                 VAR_34,
                                                 ""zset_outputintent"");
    strncpy(VAR_12->name, VAR_35, strlen(VAR_35));
    VAR_12->name[strlen(VAR_35)] = 0;
    VAR_12->name_length = strlen(VAR_35);
    /* COMMENT_4 */
    gsicc_set_icc_range(&VAR_12);

    /* COMMENT_5 */
                                                                         
                                             

                                                                                
                                                                             
                                         

                                                                             
                                                                             
                                                  

    VAR_11 = VAR_6->device_profile[0]->num_comps;
    VAR_14 = gsicc_get_default_type(VAR_6->device_profile[0]);
    if (VAR_10 == VAR_11 && VAR_14 < VAR_36) {
        /* COMMENT_15 */
                                                                            
                                                                                
                                                                               
                                                                               
                                                                              
                              
        rc_assign(VAR_6->device_profile[0], VAR_12,
                  ""zset_outputintent"");
        if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used for device profile\n"");
    } else {
        if (VAR_6->proof_profile == NULL) {
            /* COMMENT_22 */
                                                                     
                                                                        
                                                                    
                                                
            VAR_6->proof_profile = VAR_12;
            rc_increment(VAR_12);
            if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used for proof profile\n"");
        }
    }
    /* COMMENT_27 */
                                   
    VAR_14 = gsicc_get_default_type(VAR_16);
    if (VAR_14 < VAR_36) {
        /* COMMENT_29 */
        switch (VAR_12->data_cs) {
            case VAR_28:
                if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source Gray\n"");
                rc_assign(VAR_15->default_gray, VAR_12,
                          ""zset_outputintent"");
                break;
            case VAR_27:
                if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source RGB\n"");
                rc_assign(VAR_15->default_rgb, VAR_12,
                          ""zset_outputintent"");
                break;
            case VAR_29:
                if_debug0m(VAR_18, VAR_19, ""[icc] OutputIntent used source CMYK\n"");
                rc_assign(VAR_15->default_cmyk, VAR_12,
                          ""zset_outputintent"");
                break;
            default:
                break;
        }
    }
    /* COMMENT_30 */
    pop(1);
    return VAR_3;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -40,6 +40,8 @@
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */","{'deleted_lines': [], 'added_lines': ['    if (r_type(pnval) != t_integer)', '        return gs_note_error(gs_error_typecheck);']}",True,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,7.8,HIGH,2,valid,2018-11-14T09:25:13Z,2
CVE-2018-19476,['CWE-704'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Bug #700169 - unchecked type

Bug #700169 ""Type confusion in setcolorspace""

In seticc() we extract ""Name"" from a dictionary, if it succeeds we then
use it as a string, without checking the type to see if it is in fact
a string.

Add a check on the type, and add a couple to check that 'N' is an integer
in a few places too.",67d760ab775dae4efe803b5944b0439aa3c0b04a,https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a,psi/zicc.c,seticc,"int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
{
int                     code, k;
gs_color_space *        pcs;
ref *                   pstrmval;
stream *                s = 0L;
cmm_profile_t           *picc_profile = NULL;
int                     i, expected = 0;
ref *                   pnameval;
static const char *const icc_std_profile_names[] = {
GSICC_STANDARD_PROFILES
};
static const char *const icc_std_profile_keys[] = {
GSICC_STANDARD_PROFILES_KEYS
};
if (dict_find_string(ICCdict, ""DataSource"", &pstrmval) <= 0)
return_error(gs_error_undefined);
check_read_file(i_ctx_p, s, pstrmval);
code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));
if (code < 0)
return gs_rethrow(code, ""building color space object"");
if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
uint size = r_size(pnameval);
char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
memcpy(str, (const char *)pnameval->value.bytes, size);
str[size] = 0;
for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {
if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {
picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],
strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));
break;
}
}
gs_free_object(gs_gstate_memory(igs), str, ""seticc"");
} else {
picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
if (picc_profile == NULL)
return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
picc_profile->profile_handle =
gsicc_get_profile_handle_buffer(picc_profile->buffer,
picc_profile->buffer_size,
gs_gstate_memory(igs));
}
if (picc_profile == NULL || picc_profile->profile_handle == NULL) {
rc_decrement(picc_profile,""seticc"");
rc_decrement(pcs,""seticc"");
return -1;
}
code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));
if (code < 0) {
rc_decrement(picc_profile,""seticc"");
rc_decrement(pcs,""seticc"");
return code;
}
picc_profile->num_comps = ncomps;
picc_profile->data_cs =
gscms_get_profile_data_space(picc_profile->profile_handle,
picc_profile->memory);
switch (picc_profile->data_cs) {
case gsCIEXYZ:
case gsCIELAB:
case gsRGB:
expected = 3;
break;
case gsGRAY:
expected = 1;
break;
case gsCMYK:
expected = 4;
break;
case gsNCHANNEL:
case gsNAMED:            
case gsUNDEFINED:        
break;
}
if (!expected || ncomps != expected) {
rc_decrement(picc_profile,""seticc"");
rc_decrement(pcs,""seticc"");
return_error(gs_error_rangecheck);
}
gsicc_init_hash_cs(picc_profile, igs);
if (picc_profile->data_cs == gsCIELAB) {
picc_profile->Range.ranges[0].rmin = 0.0;
picc_profile->Range.ranges[0].rmax = 100.0;
picc_profile->Range.ranges[1].rmin = -128.0;
picc_profile->Range.ranges[1].rmax = 127.0;
picc_profile->Range.ranges[2].rmin = -128.0;
picc_profile->Range.ranges[2].rmax = 127.0;
picc_profile->islab = true;
} else {
for (i = 0; i < ncomps; i++) {
picc_profile->Range.ranges[i].rmin = range_buff[2 * i];
picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];
}
}
if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {
switch( picc_profile->data_cs ) {
case gsRGB:
pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;
break;
case gsGRAY:
pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;
break;
case gsCMYK:
pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;
break;
default:
break;
}
rc_adjust(picc_profile, -2, ""seticc"");
rc_increment(pcs->cmm_icc_profile_data);
}
code = gs_setcolorspace(igs, pcs);
rc_decrement_only(pcs, ""seticc"");
rc_decrement(picc_profile,""seticc"");
pop(1);
return code;
}","int seticc(i_ctx_t * VAR_0, int VAR_1, ref *VAR_2, float *VAR_3)
{
int                     VAR_4, VAR_5;
gs_color_space *        VAR_6;
ref *                   VAR_7;
stream *                VAR_8 = 0L;
cmm_profile_t           *VAR_9 = NULL;
int                     VAR_10, VAR_11 = 0;
ref *                   VAR_12;
static const char *const VAR_13[] = {
VAR_14
};
static const char *const VAR_15[] = {
VAR_16
};
if (dict_find_string(VAR_2, ""DataSource"", &VAR_7) <= 0)
return_error(VAR_17);
check_read_file(VAR_0, VAR_8, VAR_7);
VAR_4 = gs_cspace_build_ICC(&VAR_6, NULL, gs_gstate_memory(VAR_18));
if (VAR_4 < 0)
return gs_rethrow(VAR_4, ""building color space object"");
if (dict_find_string(VAR_2, ""Name"", &VAR_12) > 0){
uint VAR_19 = r_size(VAR_12);
char *VAR_20 = (char *)gs_alloc_bytes(gs_gstate_memory(VAR_18), VAR_19+1, ""seticc"");
memcpy(VAR_20, (const char *)VAR_12->value.bytes, VAR_19);
VAR_20[VAR_19] = 0;
for (VAR_5 = 0; VAR_5 < VAR_21; VAR_5++) {
if ( strcmp( VAR_20, VAR_15[VAR_5] ) == 0 ) {
VAR_9 = gsicc_get_profile_handle_file(VAR_13[VAR_5],
strlen(VAR_13[VAR_5]), gs_gstate_memory(VAR_18));
break;
}
}
gs_free_object(gs_gstate_memory(VAR_18), VAR_20, ""seticc"");
} else {
VAR_9 = gsicc_profile_new(VAR_8, gs_gstate_memory(VAR_18), NULL, 0);
if (VAR_9 == NULL)
return gs_throw(VAR_22, ""Creation of ICC profile failed"");
VAR_9->profile_handle =
gsicc_get_profile_handle_buffer(VAR_9->buffer,
VAR_9->buffer_size,
gs_gstate_memory(VAR_18));
}
if (VAR_9 == NULL || VAR_9->profile_handle == NULL) {
rc_decrement(VAR_9,""seticc"");
rc_decrement(VAR_6,""seticc"");
return -1;
}
VAR_4 = gsicc_set_gscs_profile(VAR_6, VAR_9, gs_gstate_memory(VAR_18));
if (VAR_4 < 0) {
rc_decrement(VAR_9,""seticc"");
rc_decrement(VAR_6,""seticc"");
return VAR_4;
}
VAR_9->num_comps = VAR_1;
VAR_9->data_cs =
gscms_get_profile_data_space(VAR_9->profile_handle,
VAR_9->memory);
switch (VAR_9->data_cs) {
case VAR_23:
case VAR_24:
case VAR_25:
VAR_11 = 3;
break;
case VAR_26:
VAR_11 = 1;
break;
case VAR_27:
VAR_11 = 4;
break;
case VAR_28:
case VAR_29:            
case VAR_30:        
break;
}
if (!VAR_11 || VAR_1 != VAR_11) {
rc_decrement(VAR_9,""seticc"");
rc_decrement(VAR_6,""seticc"");
return_error(VAR_31);
}
gsicc_init_hash_cs(VAR_9, VAR_18);
if (VAR_9->data_cs == VAR_24) {
VAR_9->Range.ranges[0].rmin = 0.0;
VAR_9->Range.ranges[0].rmax = 100.0;
VAR_9->Range.ranges[1].rmin = -128.0;
VAR_9->Range.ranges[1].rmax = 127.0;
VAR_9->Range.ranges[2].rmin = -128.0;
VAR_9->Range.ranges[2].rmax = 127.0;
VAR_9->islab = true;
} else {
for (VAR_10 = 0; VAR_10 < VAR_1; VAR_10++) {
VAR_9->Range.ranges[VAR_10].rmin = VAR_3[2 * VAR_10];
VAR_9->Range.ranges[VAR_10].rmax = VAR_3[2 * VAR_10 + 1];
}
}
if (gs_currentoverrideicc(VAR_18) && VAR_9->data_cs != VAR_24) {
switch( VAR_9->data_cs ) {
case VAR_25:
VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_rgb;
break;
case VAR_26:
VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_gray;
break;
case VAR_27:
VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_cmyk;
break;
default:
break;
}
rc_adjust(VAR_9, -2, ""seticc"");
rc_increment(VAR_6->cmm_icc_profile_data);
}
VAR_4 = gs_setcolorspace(VAR_18, VAR_6);
rc_decrement_only(VAR_6, ""seticc"");
rc_decrement(VAR_9,""seticc"");
pop(1);
return VAR_4;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/before/0.json,"int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
{
    int                     code, k;
    gs_color_space *        pcs;
    ref *                   pstrmval;
    stream *                s = 0L;
    cmm_profile_t           *picc_profile = NULL;
    int                     i, expected = 0;
    ref *                   pnameval;
    static const char *const icc_std_profile_names[] = {
            GSICC_STANDARD_PROFILES
        };
    static const char *const icc_std_profile_keys[] = {
            GSICC_STANDARD_PROFILES_KEYS
        };

    /* verify the DataSource entry */
    if (dict_find_string(ICCdict, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    /* build the color space object */
    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));
    if (code < 0)
        return gs_rethrow(code, ""building color space object"");
    /*  For now, dump the profile into a buffer
        and obtain handle from the buffer when we need it.
        We may want to change this later.
        This depends to some degree on what the CMS is capable of doing.
        I don't want to get bogged down on stream I/O at this point.
        Note also, if we are going to be putting these into the clist we will
        want to have this buffer. */
    /* Check if we have the /Name entry.  This is used to associate with
       specs that have enumerated types to indicate sRGB sGray etc */
    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
        uint size = r_size(pnameval);
        char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
        memcpy(str, (const char *)pnameval->value.bytes, size);
        str[size] = 0;

        /* Compare this to the standard profile names */
        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {
            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {
                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],
                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));
                break;
            }
        }
        gs_free_object(gs_gstate_memory(igs), str, ""seticc"");
    } else {
        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
        if (picc_profile == NULL)
            return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
        /* We have to get the profile handle due to the fact that we need to know
           if it has a data space that is CIELAB */
        picc_profile->profile_handle =
            gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                            picc_profile->buffer_size,
                                            gs_gstate_memory(igs));
    }
    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {
        /* Free up everything, the profile is not valid. We will end up going
           ahead and using a default based upon the number of components */
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return -1;
    }
    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));
    if (code < 0) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return code;
    }
    picc_profile->num_comps = ncomps;

    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
        case gsNAMED:            /* Silence warnings */
        case gsUNDEFINED:        /* Silence warnings */
            break;
    }
    if (!expected || ncomps != expected) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return_error(gs_error_rangecheck);
    }

    /* Lets go ahead and get the hash code and check if we match one of the default spaces */
    /* Later we may want to delay this, but for now lets go ahead and do it */
    gsicc_init_hash_cs(picc_profile, igs);

    /* Set the range according to the data type that is associated with the
       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB
       profiles for spot colors in PDF documents. These spot colors are typically described
       as separation colors with tint transforms that go from a tint value
       to a linear mapping between the CIELAB white point and the CIELAB tint
       color.  This results in a CIELAB value that we need to use to fill.  We
       need to detect this to make sure we do the proper scaling of the data.  For
       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data
       in the range from 0 to 255 or 0 to 65535.  In that case, there should not
       be any encoding and decoding to CIELAB.  The PDF content will not include
       an ICC profile but will set the color space to \Lab.  In this case, we use
       our seticc_lab operation to install the LAB to LAB profile, but we detect
       that we did that through the use of the is_lab flag in the profile descriptor.
       When then avoid the CIELAB encode and decode */
    if (picc_profile->data_cs == gsCIELAB) {
    /* If the input space to this profile is CIELAB, then we need to adjust the limits */
        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to
           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though
           at some point. */
        picc_profile->Range.ranges[0].rmin = 0.0;
        picc_profile->Range.ranges[0].rmax = 100.0;
        picc_profile->Range.ranges[1].rmin = -128.0;
        picc_profile->Range.ranges[1].rmax = 127.0;
        picc_profile->Range.ranges[2].rmin = -128.0;
        picc_profile->Range.ranges[2].rmax = 127.0;
        picc_profile->islab = true;
    } else {
        for (i = 0; i < ncomps; i++) {
            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];
            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];
        }
    }
    /* Now see if we are in an overide situation.  We have to wait until now
       in case this is an LAB profile which we will not overide */
    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {
        /* Free up the profile structure */
        switch( picc_profile->data_cs ) {
            case gsRGB:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;
                break;
            case gsGRAY:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;
                break;
            case gsCMYK:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;
                break;
            default:
                break;
        }
        /* Have one increment from the color space.  Having these tied
           together is not really correct.  Need to fix that.  ToDo.  MJV */
        rc_adjust(picc_profile, -2, ""seticc"");
        rc_increment(pcs->cmm_icc_profile_data);
    }
    /* Set the color space.  We are done.  No joint cache here... */
    code = gs_setcolorspace(igs, pcs);
    /* The context has taken a reference to the colorspace. We no longer need
     * ours, so drop it. */
    rc_decrement_only(pcs, ""seticc"");
    /* In this case, we already have a ref count of 2 on the icc profile
       one for when it was created and one for when it was set.  We really
       only want one here so adjust */
    rc_decrement(picc_profile,""seticc"");
    /* Remove the ICC dict from the stack */
    pop(1);
    return code;
}","int seticc(i_ctx_t * VAR_0, int VAR_1, ref *VAR_2, float *VAR_3)
{
    int                     VAR_4, VAR_5;
    gs_color_space *        VAR_6;
    ref *                   VAR_7;
    stream *                VAR_8 = 0L;
    cmm_profile_t           *VAR_9 = NULL;
    int                     VAR_10, VAR_11 = 0;
    ref *                   VAR_12;
    static const char *const VAR_13[] = {
            VAR_14
        };
    static const char *const VAR_15[] = {
            VAR_16
        };

    /* COMMENT_0 */
    if (dict_find_string(VAR_2, ""DataSource"", &VAR_7) <= 0)
        return_error(VAR_17);
    check_read_file(VAR_0, VAR_8, VAR_7);

    /* COMMENT_1 */
    VAR_4 = gs_cspace_build_ICC(&VAR_6, NULL, gs_gstate_memory(VAR_18));
    if (VAR_4 < 0)
        return gs_rethrow(VAR_4, ""building color space object"");
    /* COMMENT_2 */
                                                          
                                         
                                                                        
                                                                    
                                                                             
                                    
    /* COMMENT_9 */
                                                                     
    if (dict_find_string(VAR_2, ""Name"", &VAR_12) > 0 && r_has_type(VAR_12, VAR_19)){
        uint VAR_20 = r_size(VAR_12);
        char *VAR_21 = (char *)gs_alloc_bytes(gs_gstate_memory(VAR_18), VAR_20+1, ""seticc"");
        memcpy(VAR_21, (const char *)VAR_12->value.bytes, VAR_20);
        VAR_21[VAR_20] = 0;

        /* COMMENT_11 */
        for (VAR_5 = 0; VAR_5 < VAR_22; VAR_5++) {
            if ( strcmp( VAR_21, VAR_15[VAR_5] ) == 0 ) {
                VAR_9 = gsicc_get_profile_handle_file(VAR_13[VAR_5],
                    strlen(VAR_13[VAR_5]), gs_gstate_memory(VAR_18));
                break;
            }
        }
        gs_free_object(gs_gstate_memory(VAR_18), VAR_21, ""seticc"");
    } else {
        VAR_9 = gsicc_profile_new(VAR_8, gs_gstate_memory(VAR_18), NULL, 0);
        if (VAR_9 == NULL)
            return gs_throw(VAR_23, ""Creation of ICC profile failed"");
        /* COMMENT_12 */
                                                   
        VAR_9->profile_handle =
            gsicc_get_profile_handle_buffer(VAR_9->buffer,
                                            VAR_9->buffer_size,
                                            gs_gstate_memory(VAR_18));
    }
    if (VAR_9 == NULL || VAR_9->profile_handle == NULL) {
        /* COMMENT_14 */
                                                                           
        rc_decrement(VAR_9,""seticc"");
        rc_decrement(VAR_6,""seticc"");
        return -1;
    }
    VAR_4 = gsicc_set_gscs_profile(VAR_6, VAR_9, gs_gstate_memory(VAR_18));
    if (VAR_4 < 0) {
        rc_decrement(VAR_9,""seticc"");
        rc_decrement(VAR_6,""seticc"");
        return VAR_4;
    }
    VAR_9->num_comps = VAR_1;

    VAR_9->data_cs =
        gscms_get_profile_data_space(VAR_9->profile_handle,
            VAR_9->memory);
    switch (VAR_9->data_cs) {
        case VAR_24:
        case VAR_25:
        case VAR_26:
            VAR_11 = 3;
            break;
        case VAR_27:
            VAR_11 = 1;
            break;
        case VAR_28:
            VAR_11 = 4;
            break;
        case VAR_29:
        case VAR_30:            /* COMMENT_16 */
        case VAR_31:        /* COMMENT_16 */
            break;
    }
    if (!VAR_11 || VAR_1 != VAR_11) {
        rc_decrement(VAR_9,""seticc"");
        rc_decrement(VAR_6,""seticc"");
        return_error(VAR_32);
    }

    /* COMMENT_17 */
    /* COMMENT_18 */
    gsicc_init_hash_cs(VAR_9, VAR_18);

    /* COMMENT_19 */
                                                                             
                                                                                           
                                                                          
                                                                             
                                                                              
                                                                                  
                                                                                 
                                                                                
                                                                                
                                                                                 
                                                                                
                                                                                     
                                                      
    if (VAR_9->data_cs == VAR_25) {
    /* COMMENT_33 */
        /* COMMENT_34 */
                                                                                                
                            
        VAR_9->Range.ranges[0].rmin = 0.0;
        VAR_9->Range.ranges[0].rmax = 100.0;
        VAR_9->Range.ranges[1].rmin = -128.0;
        VAR_9->Range.ranges[1].rmax = 127.0;
        VAR_9->Range.ranges[2].rmin = -128.0;
        VAR_9->Range.ranges[2].rmax = 127.0;
        VAR_9->islab = true;
    } else {
        for (VAR_10 = 0; VAR_10 < VAR_1; VAR_10++) {
            VAR_9->Range.ranges[VAR_10].rmin = VAR_3[2 * VAR_10];
            VAR_9->Range.ranges[VAR_10].rmax = VAR_3[2 * VAR_10 + 1];
        }
    }
    /* COMMENT_37 */
                                                                  
    if (gs_currentoverrideicc(VAR_18) && VAR_9->data_cs != VAR_25) {
        /* COMMENT_39 */
        switch( VAR_9->data_cs ) {
            case VAR_26:
                VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_rgb;
                break;
            case VAR_27:
                VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_gray;
                break;
            case VAR_28:
                VAR_6->cmm_icc_profile_data = VAR_18->icc_manager->default_cmyk;
                break;
            default:
                break;
        }
        /* COMMENT_40 */
                                                                            
        rc_adjust(VAR_9, -2, ""seticc"");
        rc_increment(VAR_6->cmm_icc_profile_data);
    }
    /* COMMENT_42 */
    VAR_4 = gs_setcolorspace(VAR_18, VAR_6);
    /* COMMENT_43 */
                           
    rc_decrement_only(VAR_6, ""seticc"");
    /* COMMENT_45 */
                                                                          
                                      
    rc_decrement(VAR_9,""seticc"");
    /* COMMENT_48 */
    pop(1);
    return VAR_4;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,7 +32,7 @@
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
-    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
+    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);","{'deleted_lines': ['    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){'], 'added_lines': ['    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){']}",True,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,7.8,HIGH,2,valid,2018-11-14T09:25:13Z,2
CVE-2018-19476,['CWE-704'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Bug #700169 - unchecked type

Bug #700169 ""Type confusion in setcolorspace""

In seticc() we extract ""Name"" from a dictionary, if it succeeds we then
use it as a string, without checking the type to see if it is in fact
a string.

Add a check on the type, and add a couple to check that 'N' is an integer
in a few places too.",67d760ab775dae4efe803b5944b0439aa3c0b04a,https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a,psi/zicc.c,znumicc_components,"static int
znumicc_components(i_ctx_t * i_ctx_p)
{
ref *                   pnval;
ref *                   pstrmval;
stream *                s;
int                     ncomps, expected = 0, code;
cmm_profile_t           *picc_profile;
os_ptr                  op = osp;
check_type(*op, t_dictionary);
check_dict_read(*op);
code = dict_find_string(op, ""N"", &pnval);
if (code < 0)
return code;
if (code == 0)
return_error(gs_error_undefined);
ncomps = pnval->value.intval;
if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
return_error(gs_error_undefined);
check_read_file(i_ctx_p, s, pstrmval);
picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
if (picc_profile == NULL)
return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
picc_profile->num_comps = ncomps;
picc_profile->profile_handle =
gsicc_get_profile_handle_buffer(picc_profile->buffer,
picc_profile->buffer_size,
gs_gstate_memory(igs));
if (picc_profile->profile_handle == NULL) {
rc_decrement(picc_profile,""znumicc_components"");
make_int(op, expected);
return 0;
}
picc_profile->data_cs =
gscms_get_profile_data_space(picc_profile->profile_handle,
picc_profile->memory);
switch (picc_profile->data_cs) {
case gsCIEXYZ:
case gsCIELAB:
case gsRGB:
expected = 3;
break;
case gsGRAY:
expected = 1;
break;
case gsCMYK:
expected = 4;
break;
case gsNCHANNEL:
expected = 0;
break;
case gsNAMED:
case gsUNDEFINED:
expected = -1;
break;
}
make_int(op, expected);
rc_decrement(picc_profile,""zset_outputintent"");
return 0;
}","static int
znumicc_components(i_ctx_t * VAR_0)
{
ref *                   VAR_1;
ref *                   VAR_2;
stream *                VAR_3;
int                     VAR_4, VAR_5 = 0, VAR_6;
cmm_profile_t           *VAR_7;
os_ptr                  VAR_8 = VAR_9;
check_type(*VAR_8, VAR_10);
check_dict_read(*VAR_8);
VAR_6 = dict_find_string(VAR_8, ""N"", &VAR_1);
if (VAR_6 < 0)
return VAR_6;
if (VAR_6 == 0)
return_error(VAR_11);
VAR_4 = VAR_1->value.intval;
if (dict_find_string(VAR_8, ""DataSource"", &VAR_2) <= 0)
return_error(VAR_11);
check_read_file(VAR_0, VAR_3, VAR_2);
VAR_7 = gsicc_profile_new(VAR_3, gs_gstate_memory(VAR_12), NULL, 0);
if (VAR_7 == NULL)
return gs_throw(VAR_13, ""Creation of ICC profile failed"");
VAR_7->num_comps = VAR_4;
VAR_7->profile_handle =
gsicc_get_profile_handle_buffer(VAR_7->buffer,
VAR_7->buffer_size,
gs_gstate_memory(VAR_12));
if (VAR_7->profile_handle == NULL) {
rc_decrement(VAR_7,""znumicc_components"");
make_int(VAR_8, VAR_5);
return 0;
}
VAR_7->data_cs =
gscms_get_profile_data_space(VAR_7->profile_handle,
VAR_7->memory);
switch (VAR_7->data_cs) {
case VAR_14:
case VAR_15:
case VAR_16:
VAR_5 = 3;
break;
case VAR_17:
VAR_5 = 1;
break;
case VAR_18:
VAR_5 = 4;
break;
case VAR_19:
VAR_5 = 0;
break;
case VAR_20:
case VAR_21:
VAR_5 = -1;
break;
}
make_int(VAR_8, VAR_5);
rc_decrement(VAR_7,""zset_outputintent"");
return 0;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/before/2.json,"static int
znumicc_components(i_ctx_t * i_ctx_p)
{
    ref *                   pnval;
    ref *                   pstrmval;
    stream *                s;
    int                     ncomps, expected = 0, code;
    cmm_profile_t           *picc_profile;
    os_ptr                  op = osp;

    check_type(*op, t_dictionary);
    check_dict_read(*op);

    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
        return code;
    if (code == 0)
        return_error(gs_error_undefined);
    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
    ncomps = pnval->value.intval;
    /* verify the DataSource entry. Create profile from stream */
    if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");

    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""znumicc_components"");
        make_int(op, expected);
        return 0;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);

    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            expected = -1;
            break;
    }

    make_int(op, expected);

    rc_decrement(picc_profile,""zset_outputintent"");
    return 0;
}","static int
znumicc_components(i_ctx_t * VAR_0)
{
    ref *                   VAR_1;
    ref *                   VAR_2;
    stream *                VAR_3;
    int                     VAR_4, VAR_5 = 0, VAR_6;
    cmm_profile_t           *VAR_7;
    os_ptr                  VAR_8 = VAR_9;

    check_type(*VAR_8, VAR_10);
    check_dict_read(*VAR_8);

    VAR_6 = dict_find_string(VAR_8, ""N"", &VAR_1);
    if (VAR_6 < 0)
        return VAR_6;
    if (VAR_6 == 0)
        return_error(VAR_11);
    if (r_type(VAR_1) != VAR_12)
        return gs_note_error(VAR_13);
    VAR_4 = VAR_1->value.intval;
    /* COMMENT_0 */
    if (dict_find_string(VAR_8, ""DataSource"", &VAR_2) <= 0)
        return_error(VAR_11);
    check_read_file(VAR_0, VAR_3, VAR_2);

    VAR_7 = gsicc_profile_new(VAR_3, gs_gstate_memory(VAR_14), NULL, 0);
    if (VAR_7 == NULL)
        return gs_throw(VAR_15, ""Creation of ICC profile failed"");

    VAR_7->num_comps = VAR_4;
    VAR_7->profile_handle =
        gsicc_get_profile_handle_buffer(VAR_7->buffer,
                                        VAR_7->buffer_size,
                                        gs_gstate_memory(VAR_14));
    if (VAR_7->profile_handle == NULL) {
        rc_decrement(VAR_7,""znumicc_components"");
        make_int(VAR_8, VAR_5);
        return 0;
    }
    VAR_7->data_cs =
        gscms_get_profile_data_space(VAR_7->profile_handle,
            VAR_7->memory);

    switch (VAR_7->data_cs) {
        case VAR_16:
        case VAR_17:
        case VAR_18:
            VAR_5 = 3;
            break;
        case VAR_19:
            VAR_5 = 1;
            break;
        case VAR_20:
            VAR_5 = 4;
            break;
        case VAR_21:
            VAR_5 = 0;
            break;
        case VAR_22:
        case VAR_23:
            VAR_5 = -1;
            break;
    }

    make_int(VAR_8, VAR_5);

    rc_decrement(VAR_7,""zset_outputintent"");
    return 0;
}",ArtifexSoftware/ghostpdl/67d760ab775dae4efe803b5944b0439aa3c0b04a/zicc.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -16,6 +16,8 @@
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)","{'deleted_lines': [], 'added_lines': ['    if (r_type(pnval) != t_integer)', '        return gs_note_error(gs_error_typecheck);']}",True,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,7.8,HIGH,2,valid,2018-11-14T09:25:13Z,2
CVE-2019-1010293,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,OP-TEE/optee_os,"core: tee_mmu_check_access_rights() check all pages

Prior to this patch tee_mmu_check_access_rights() checks an address in
each page of a supplied range. If both the start and length of that
range is unaligned the last page in the range is sometimes not checked.
With this patch the first address of each page in the range is checked
to simplify the logic of checking each page and the range and also to
cover the last page under all circumstances.

Fixes: OP-TEE-2018-0005: ""tee_mmu_check_access_rights does not check
final page of TA buffer""

Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
Tested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)
Reviewed-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Riscure <inforequest@riscure.com>
Reported-by: Alyssa Milburn <a.a.milburn@vu.nl>
Acked-by: Etienne Carriere <etienne.carriere@linaro.org>",95f36d661f2b75887772ea28baaad904bde96970,https://github.com/OP-TEE/optee_os/commit/95f36d661f2b75887772ea28baaad904bde96970,core/arch/arm/mm/tee_mmu.c,tee_mmu_check_access_rights,"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
uint32_t flags, uaddr_t uaddr,
size_t len)
{
uaddr_t a;
size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
CORE_MMU_USER_PARAM_SIZE);
if (ADD_OVERFLOW(uaddr, len, &a))
return TEE_ERROR_ACCESS_DENIED;
if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
(flags & TEE_MEMORY_ACCESS_SECURE))
return TEE_ERROR_ACCESS_DENIED;
if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
!tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
return TEE_ERROR_ACCESS_DENIED;
for (a = uaddr; a < (uaddr + len); a += addr_incr) {
uint32_t attr;
TEE_Result res;
res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);
if (res != TEE_SUCCESS)
return res;
if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
(attr & TEE_MATTR_SECURE))
return TEE_ERROR_ACCESS_DENIED;
if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
!(attr & TEE_MATTR_SECURE))
return TEE_ERROR_ACCESS_DENIED;
if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
return TEE_ERROR_ACCESS_DENIED;
if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
return TEE_ERROR_ACCESS_DENIED;
}
return TEE_SUCCESS;
}","TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *VAR_0,
uint32_t VAR_1, uaddr_t VAR_2,
size_t VAR_3)
{
uaddr_t VAR_4;
size_t VAR_5 = MIN(VAR_6,
VAR_7);
if (ADD_OVERFLOW(VAR_2, VAR_3, &VAR_4))
return VAR_8;
if ((VAR_1 & VAR_9) &&
(VAR_1 & VAR_10))
return VAR_8;
if (!(VAR_1 & VAR_11) &&
!tee_mmu_is_vbuf_inside_ta_private(VAR_0, (void *)VAR_2, VAR_3))
return VAR_8;
for (VAR_4 = VAR_2; VAR_4 < (VAR_2 + VAR_3); VAR_4 += VAR_5) {
uint32_t VAR_12;
TEE_Result VAR_13;
VAR_13 = tee_mmu_user_va2pa_attr(VAR_0, (void *)VAR_4, NULL, &VAR_12);
if (VAR_13 != VAR_14)
return VAR_13;
if ((VAR_1 & VAR_9) &&
(VAR_12 & VAR_15))
return VAR_8;
if ((VAR_1 & VAR_10) &&
!(VAR_12 & VAR_15))
return VAR_8;
if ((VAR_1 & VAR_16) && !(VAR_12 & VAR_17))
return VAR_8;
if ((VAR_1 & VAR_18) && !(VAR_12 & VAR_19))
return VAR_8;
}
return VAR_14;
}",OP-TEE/optee_os/95f36d661f2b75887772ea28baaad904bde96970/tee_mmu.c/vul/before/0.json,"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
				       uint32_t flags, uaddr_t uaddr,
				       size_t len)
{
	uaddr_t a;
	uaddr_t end_addr = 0;
	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
			       CORE_MMU_USER_PARAM_SIZE);

	if (ADD_OVERFLOW(uaddr, len, &end_addr))
		return TEE_ERROR_ACCESS_DENIED;

	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
	    (flags & TEE_MEMORY_ACCESS_SECURE))
		return TEE_ERROR_ACCESS_DENIED;

	/*
	 * Rely on TA private memory test to check if address range is private
	 * to TA or not.
	 */
	if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
		return TEE_ERROR_ACCESS_DENIED;

	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
		uint32_t attr;
		TEE_Result res;

		res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);
		if (res != TEE_SUCCESS)
			return res;

		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
		    (attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
		    !(attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
			return TEE_ERROR_ACCESS_DENIED;
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
			return TEE_ERROR_ACCESS_DENIED;
	}

	return TEE_SUCCESS;
}","TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *VAR_0,
				       uint32_t VAR_1, uaddr_t VAR_2,
				       size_t VAR_3)
{
	uaddr_t VAR_4;
	uaddr_t VAR_5 = 0;
	size_t VAR_6 = MIN(VAR_7,
			       VAR_8);

	if (ADD_OVERFLOW(VAR_2, VAR_3, &VAR_5))
		return VAR_9;

	if ((VAR_1 & VAR_10) &&
	    (VAR_1 & VAR_11))
		return VAR_9;

	/* COMMENT_0 */
                                                                       
                 
    
	if (!(VAR_1 & VAR_12) &&
	   !tee_mmu_is_vbuf_inside_ta_private(VAR_0, (void *)VAR_2, VAR_3))
		return VAR_9;

	for (VAR_4 = ROUNDDOWN(VAR_2, VAR_6); VAR_4 < VAR_5; VAR_4 += VAR_6) {
		uint32_t VAR_13;
		TEE_Result VAR_14;

		VAR_14 = tee_mmu_user_va2pa_attr(VAR_0, (void *)VAR_4, NULL, &VAR_13);
		if (VAR_14 != VAR_15)
			return VAR_14;

		if ((VAR_1 & VAR_10) &&
		    (VAR_13 & VAR_16))
			return VAR_9;

		if ((VAR_1 & VAR_11) &&
		    !(VAR_13 & VAR_16))
			return VAR_9;

		if ((VAR_1 & VAR_17) && !(VAR_13 & VAR_18))
			return VAR_9;
		if ((VAR_1 & VAR_19) && !(VAR_13 & VAR_20))
			return VAR_9;
	}

	return VAR_15;
}",OP-TEE/optee_os/95f36d661f2b75887772ea28baaad904bde96970/tee_mmu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,10 +3,11 @@
 				       size_t len)
 {
 	uaddr_t a;
+	uaddr_t end_addr = 0;
 	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
 			       CORE_MMU_USER_PARAM_SIZE);
 
-	if (ADD_OVERFLOW(uaddr, len, &a))
+	if (ADD_OVERFLOW(uaddr, len, &end_addr))
 		return TEE_ERROR_ACCESS_DENIED;
 
 	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
@@ -21,7 +22,7 @@
 	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
 		return TEE_ERROR_ACCESS_DENIED;
 
-	for (a = uaddr; a < (uaddr + len); a += addr_incr) {
+	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
 		uint32_t attr;
 		TEE_Result res;
 ","{'deleted_lines': ['\tif (ADD_OVERFLOW(uaddr, len, &a))', '\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {'], 'added_lines': ['\tuaddr_t end_addr = 0;', '\tif (ADD_OVERFLOW(uaddr, len, &end_addr))', '\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {']}",True,Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Boundary crossing. The impact is: Memory corruption of the TEE itself. The component is: optee_os. The fixed version is: 3.4.0 and later.,9.8,CRITICAL,3,valid,2018-11-19T12:34:23Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: move OOS flag bit positions

In preparation of reducing struct page_info's shadow_flags field to 16
bits, lower the bit positions used for SHF_out_of_sync and
SHF_oos_may_write.

Instead of also adjusting the open coded use in _get_page_type(),
introduce shadow_prepare_page_type_change() to contain knowledge of the
bit positions to shadow code.

This is part of XSA-280.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d,https://github.com/xen-project/xen/commit/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d,xen/arch/x86/mm.c,_get_page_type,"static int _get_page_type(struct page_info *page, unsigned long type,
bool preemptible)
{
unsigned long nx, x, y = page->u.inuse.type_info;
int rc = 0, iommu_ret = 0;
ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
ASSERT(!in_irq());
for ( ; ; )
{
x  = y;
nx = x + 1;
if ( unlikely((nx & PGT_count_mask) == 0) )
{
gdprintk(XENLOG_WARNING,
""Type count overflow on mfn %""PRI_mfn""\n"",
mfn_x(page_to_mfn(page)));
return -EINVAL;
}
else if ( unlikely((x & PGT_count_mask) == 0) )
{
struct domain *d = page_get_owner(page);
if ( d && shadow_mode_enabled(d)
&& (page->count_info & PGC_page_table)
&& !((page->shadow_flags & (1u<<29))
&& type == PGT_writable_page) )
shadow_remove_all_shadows(d, page_to_mfn(page));
ASSERT(!(x & PGT_pae_xen_l2));
if ( (x & PGT_type_mask) != type )
{
cpumask_t *mask = this_cpu(scratch_cpumask);
BUG_ON(in_irq());
cpumask_copy(mask, d->dirty_cpumask);
tlbflush_filter(mask, page->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(mask)) &&
(!shadow_mode_enabled(page_get_owner(page)) ||
((nx & PGT_type_mask) == PGT_writable_page)) )
{
perfc_incr(need_flush_tlb_flush);
flush_tlb_mask(mask);
}
nx &= ~(PGT_type_mask | PGT_validated);
nx |= type;
if ( type == PGT_writable_page || type == PGT_shared_page )
nx |= PGT_validated;
}
}
else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
{
if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
(type == PGT_l1_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
(type == PGT_l2_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
(type == PGT_l3_page_table) )
return -EINVAL;
gdprintk(XENLOG_WARNING,
""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
x, type, mfn_x(page_to_mfn(page)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
return -EINVAL;
}
else if ( unlikely(!(x & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
do {
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
cpu_relax();
} while ( (y = page->u.inuse.type_info) == x );
continue;
}
ASSERT((x & PGT_count_mask) == 1);
nx = x & ~PGT_partial;
}
if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
break;
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
}
if ( unlikely((x & PGT_type_mask) != type) )
{
struct domain *d = page_get_owner(page);
if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
{
mfn_t mfn = page_to_mfn(page);
if ( (x & PGT_type_mask) == PGT_writable_page )
iommu_ret = iommu_unmap_page(d, _dfn(mfn_x(mfn)));
else if ( type == PGT_writable_page )
iommu_ret = iommu_map_page(d, _dfn(mfn_x(mfn)), mfn,
IOMMUF_readable |
IOMMUF_writable);
}
}
if ( unlikely(!(nx & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
page->nr_validated_ptes = 0;
page->partial_pte = 0;
}
page->linear_pt_count = 0;
rc = alloc_page_type(page, type, preemptible);
}
if ( (x & PGT_partial) && !(nx & PGT_partial) )
put_page(page);
if ( !rc )
rc = iommu_ret;
return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
bool VAR_2)
{
unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
int VAR_6 = 0, VAR_7 = 0;
ASSERT(!(VAR_1 & ~(VAR_8 | VAR_9)));
ASSERT(!in_irq());
for ( ; ; )
{
VAR_4  = VAR_5;
VAR_3 = VAR_4 + 1;
if ( unlikely((VAR_3 & VAR_10) == 0) )
{
gdprintk(VAR_11,
""Type count overflow on mfn %""VAR_12""\n"",
mfn_x(page_to_mfn(VAR_0)));
return -VAR_13;
}
else if ( unlikely((VAR_4 & VAR_10) == 0) )
{
struct domain *VAR_14 = page_get_owner(VAR_0);
if ( VAR_14 && shadow_mode_enabled(VAR_14)
&& (VAR_0->count_info & VAR_15)
&& !((VAR_0->shadow_flags & (1u<<29))
&& VAR_1 == VAR_16) )
shadow_remove_all_shadows(VAR_14, page_to_mfn(VAR_0));
ASSERT(!(VAR_4 & VAR_9));
if ( (VAR_4 & VAR_8) != VAR_1 )
{
cpumask_t *VAR_17 = this_cpu(VAR_18);
BUG_ON(in_irq());
cpumask_copy(VAR_17, VAR_14->dirty_cpumask);
tlbflush_filter(VAR_17, VAR_0->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(VAR_17)) &&
(!shadow_mode_enabled(page_get_owner(VAR_0)) ||
((VAR_3 & VAR_8) == VAR_16)) )
{
perfc_incr(VAR_19);
flush_tlb_mask(VAR_17);
}
VAR_3 &= ~(VAR_8 | VAR_20);
VAR_3 |= VAR_1;
if ( VAR_1 == VAR_16 || VAR_1 == VAR_21 )
VAR_3 |= VAR_20;
}
}
else if ( unlikely((VAR_4 & (VAR_8|VAR_9)) != VAR_1) )
{
if ( ((VAR_4 & VAR_8) == VAR_22) &&
(VAR_1 == VAR_23) )
return -VAR_13;
if ( ((VAR_4 & VAR_8) == VAR_24) &&
(VAR_1 == VAR_22) )
return -VAR_13;
if ( ((VAR_4 & VAR_8) == VAR_25) &&
(VAR_1 == VAR_24) )
return -VAR_13;
gdprintk(VAR_11,
""Bad type (saw %"" VAR_26 "" != exp %"" VAR_26 "") ""
""for mfn %"" VAR_12 "" (pfn %"" VAR_27 "")\n"",
VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
return -VAR_13;
}
else if ( unlikely(!(VAR_4 & VAR_20)) )
{
if ( !(VAR_4 & VAR_28) )
{
do {
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_29;
cpu_relax();
} while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
continue;
}
ASSERT((VAR_4 & VAR_10) == 1);
VAR_3 = VAR_4 & ~VAR_28;
}
if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
break;
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_29;
}
if ( unlikely((VAR_4 & VAR_8) != VAR_1) )
{
struct domain *VAR_14 = page_get_owner(VAR_0);
if ( VAR_14 && is_pv_domain(VAR_14) && unlikely(need_iommu_pt_sync(VAR_14)) )
{
mfn_t VAR_30 = page_to_mfn(VAR_0);
if ( (VAR_4 & VAR_8) == VAR_16 )
VAR_7 = iommu_unmap_page(VAR_14, _dfn(mfn_x(VAR_30)));
else if ( VAR_1 == VAR_16 )
VAR_7 = iommu_map_page(VAR_14, _dfn(mfn_x(VAR_30)), VAR_30,
VAR_31 |
VAR_32);
}
}
if ( unlikely(!(VAR_3 & VAR_20)) )
{
if ( !(VAR_4 & VAR_28) )
{
VAR_0->nr_validated_ptes = 0;
VAR_0->partial_pte = 0;
}
VAR_0->linear_pt_count = 0;
VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
}
if ( (VAR_4 & VAR_28) && !(VAR_3 & VAR_28) )
put_page(VAR_0);
if ( !VAR_6 )
VAR_6 = VAR_7;
return VAR_6;
}",xen-project/xen/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d/mm.c/vul/before/0.json,"static int _get_page_type(struct page_info *page, unsigned long type,
                          bool preemptible)
{
    unsigned long nx, x, y = page->u.inuse.type_info;
    int rc = 0, iommu_ret = 0;

    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        x  = y;
        nx = x + 1;
        if ( unlikely((nx & PGT_count_mask) == 0) )
        {
            gdprintk(XENLOG_WARNING,
                     ""Type count overflow on mfn %""PRI_mfn""\n"",
                     mfn_x(page_to_mfn(page)));
            return -EINVAL;
        }
        else if ( unlikely((x & PGT_count_mask) == 0) )
        {
            struct domain *d = page_get_owner(page);

            if ( d && shadow_mode_enabled(d) )
               shadow_prepare_page_type_change(d, page, type);

            ASSERT(!(x & PGT_pae_xen_l2));
            if ( (x & PGT_type_mask) != type )
            {
                /*
                 * On type change we check to flush stale TLB entries. It is
                 * vital that no other CPUs are left with mappings of a frame
                 * which is about to become writeable to the guest.
                 */
                cpumask_t *mask = this_cpu(scratch_cpumask);

                BUG_ON(in_irq());
                cpumask_copy(mask, d->dirty_cpumask);

                /* Don't flush if the timestamp is old enough */
                tlbflush_filter(mask, page->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(mask)) &&
                     /* Shadow mode: track only writable pages. */
                     (!shadow_mode_enabled(page_get_owner(page)) ||
                      ((nx & PGT_type_mask) == PGT_writable_page)) )
                {
                    perfc_incr(need_flush_tlb_flush);
                    flush_tlb_mask(mask);
                }

                /* We lose existing type and validity. */
                nx &= ~(PGT_type_mask | PGT_validated);
                nx |= type;

                /*
                 * No special validation needed for writable pages.
                 * Page tables and GDT/LDT need to be scanned for validity.
                 */
                if ( type == PGT_writable_page || type == PGT_shared_page )
                    nx |= PGT_validated;
            }
        }
        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
        {
            /* Don't log failure if it could be a recursive-mapping attempt. */
            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
                 (type == PGT_l1_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
                 (type == PGT_l2_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
                 (type == PGT_l3_page_table) )
                return -EINVAL;
            gdprintk(XENLOG_WARNING,
                     ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
                     ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
                     x, type, mfn_x(page_to_mfn(page)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
            return -EINVAL;
        }
        else if ( unlikely(!(x & PGT_validated)) )
        {
            if ( !(x & PGT_partial) )
            {
                /* Someone else is updating validation of this page. Wait... */
                do {
                    if ( preemptible && hypercall_preempt_check() )
                        return -EINTR;
                    cpu_relax();
                } while ( (y = page->u.inuse.type_info) == x );
                continue;
            }
            /* Type ref count was left at 1 when PGT_partial got set. */
            ASSERT((x & PGT_count_mask) == 1);
            nx = x & ~PGT_partial;
        }

        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
            break;

        if ( preemptible && hypercall_preempt_check() )
            return -EINTR;
    }

    if ( unlikely((x & PGT_type_mask) != type) )
    {
        /* Special pages should not be accessible from devices. */
        struct domain *d = page_get_owner(page);
        if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
        {
            mfn_t mfn = page_to_mfn(page);

            if ( (x & PGT_type_mask) == PGT_writable_page )
                iommu_ret = iommu_unmap_page(d, _dfn(mfn_x(mfn)));
            else if ( type == PGT_writable_page )
                iommu_ret = iommu_map_page(d, _dfn(mfn_x(mfn)), mfn,
                                           IOMMUF_readable |
                                           IOMMUF_writable);
        }
    }

    if ( unlikely(!(nx & PGT_validated)) )
    {
        if ( !(x & PGT_partial) )
        {
            page->nr_validated_ptes = 0;
            page->partial_pte = 0;
        }
        page->linear_pt_count = 0;
        rc = alloc_page_type(page, type, preemptible);
    }

    if ( (x & PGT_partial) && !(nx & PGT_partial) )
        put_page(page);

    if ( !rc )
        rc = iommu_ret;

    return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
                          bool VAR_2)
{
    unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
    int VAR_6 = 0, VAR_7 = 0;

    ASSERT(!(VAR_1 & ~(VAR_8 | VAR_9)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        VAR_4  = VAR_5;
        VAR_3 = VAR_4 + 1;
        if ( unlikely((VAR_3 & VAR_10) == 0) )
        {
            gdprintk(VAR_11,
                     ""Type count overflow on mfn %""VAR_12""\n"",
                     mfn_x(page_to_mfn(VAR_0)));
            return -VAR_13;
        }
        else if ( unlikely((VAR_4 & VAR_10) == 0) )
        {
            struct domain *VAR_14 = page_get_owner(VAR_0);

            if ( VAR_14 && shadow_mode_enabled(VAR_14) )
               shadow_prepare_page_type_change(VAR_14, VAR_0, VAR_1);

            ASSERT(!(VAR_4 & VAR_9));
            if ( (VAR_4 & VAR_8) != VAR_1 )
            {
                /* COMMENT_0 */
                                                                            
                                                                             
                                                                   
                   
                cpumask_t *VAR_15 = this_cpu(VAR_16);

                BUG_ON(in_irq());
                cpumask_copy(VAR_15, VAR_14->dirty_cpumask);

                /* COMMENT_5 */
                tlbflush_filter(VAR_15, VAR_0->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(VAR_15)) &&
                     /* COMMENT_6 */
                     (!shadow_mode_enabled(page_get_owner(VAR_0)) ||
                      ((VAR_3 & VAR_8) == VAR_17)) )
                {
                    perfc_incr(VAR_18);
                    flush_tlb_mask(VAR_15);
                }

                /* COMMENT_7 */
                VAR_3 &= ~(VAR_8 | VAR_19);
                VAR_3 |= VAR_1;

                /* COMMENT_8 */
                                                                   
                                                                           
                   
                if ( VAR_1 == VAR_17 || VAR_1 == VAR_20 )
                    VAR_3 |= VAR_19;
            }
        }
        else if ( unlikely((VAR_4 & (VAR_8|VAR_9)) != VAR_1) )
        {
            /* COMMENT_12 */
            if ( ((VAR_4 & VAR_8) == VAR_21) &&
                 (VAR_1 == VAR_22) )
                return -VAR_13;
            if ( ((VAR_4 & VAR_8) == VAR_23) &&
                 (VAR_1 == VAR_21) )
                return -VAR_13;
            if ( ((VAR_4 & VAR_8) == VAR_24) &&
                 (VAR_1 == VAR_23) )
                return -VAR_13;
            gdprintk(VAR_11,
                     ""Bad type (saw %"" VAR_25 "" != exp %"" VAR_25 "") ""
                     ""for mfn %"" VAR_12 "" (pfn %"" VAR_26 "")\n"",
                     VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
            return -VAR_13;
        }
        else if ( unlikely(!(VAR_4 & VAR_19)) )
        {
            if ( !(VAR_4 & VAR_27) )
            {
                /* COMMENT_13 */
                do {
                    if ( VAR_2 && hypercall_preempt_check() )
                        return -VAR_28;
                    cpu_relax();
                } while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
                continue;
            }
            /* COMMENT_14 */
            ASSERT((VAR_4 & VAR_10) == 1);
            VAR_3 = VAR_4 & ~VAR_27;
        }

        if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
            break;

        if ( VAR_2 && hypercall_preempt_check() )
            return -VAR_28;
    }

    if ( unlikely((VAR_4 & VAR_8) != VAR_1) )
    {
        /* COMMENT_15 */
        struct domain *VAR_14 = page_get_owner(VAR_0);
        if ( VAR_14 && is_pv_domain(VAR_14) && unlikely(need_iommu_pt_sync(VAR_14)) )
        {
            mfn_t VAR_29 = page_to_mfn(VAR_0);

            if ( (VAR_4 & VAR_8) == VAR_17 )
                VAR_7 = iommu_unmap_page(VAR_14, _dfn(mfn_x(VAR_29)));
            else if ( VAR_1 == VAR_17 )
                VAR_7 = iommu_map_page(VAR_14, _dfn(mfn_x(VAR_29)), VAR_29,
                                           VAR_30 |
                                           VAR_31);
        }
    }

    if ( unlikely(!(VAR_3 & VAR_19)) )
    {
        if ( !(VAR_4 & VAR_27) )
        {
            VAR_0->nr_validated_ptes = 0;
            VAR_0->partial_pte = 0;
        }
        VAR_0->linear_pt_count = 0;
        VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
    }

    if ( (VAR_4 & VAR_27) && !(VAR_3 & VAR_27) )
        put_page(VAR_0);

    if ( !VAR_6 )
        VAR_6 = VAR_7;

    return VAR_6;
}",xen-project/xen/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,17 +22,8 @@
         {
             struct domain *d = page_get_owner(page);
 
-            /*
-             * Normally we should never let a page go from type count 0
-             * to type count 1 when it is shadowed. One exception:
-             * out-of-sync shadowed pages are allowed to become
-             * writeable.
-             */
-            if ( d && shadow_mode_enabled(d)
-                 && (page->count_info & PGC_page_table)
-                 && !((page->shadow_flags & (1u<<29))
-                      && type == PGT_writable_page) )
-               shadow_remove_all_shadows(d, page_to_mfn(page));
+            if ( d && shadow_mode_enabled(d) )
+               shadow_prepare_page_type_change(d, page, type);
 
             ASSERT(!(x & PGT_pae_xen_l2));
             if ( (x & PGT_type_mask) != type )","{'deleted_lines': ['            /*', '             * Normally we should never let a page go from type count 0', '             * to type count 1 when it is shadowed. One exception:', '             * out-of-sync shadowed pages are allowed to become', '             * writeable.', '             */', '            if ( d && shadow_mode_enabled(d)', '                 && (page->count_info & PGC_page_table)', '                 && !((page->shadow_flags & (1u<<29))', '                      && type == PGT_writable_page) )', '               shadow_remove_all_shadows(d, page_to_mfn(page));'], 'added_lines': ['            if ( d && shadow_mode_enabled(d) )', '               shadow_prepare_page_type_change(d, page, type);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:13Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: move OOS flag bit positions

In preparation of reducing struct page_info's shadow_flags field to 16
bits, lower the bit positions used for SHF_out_of_sync and
SHF_oos_may_write.

Instead of also adjusting the open coded use in _get_page_type(),
introduce shadow_prepare_page_type_change() to contain knowledge of the
bit positions to shadow code.

This is part of XSA-280.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d,https://github.com/xen-project/xen/commit/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d,xen/arch/x86/mm/shadow/common.c,sh_unsync,"int sh_unsync(struct vcpu *v, mfn_t gmfn)
{
struct page_info *pg;
ASSERT(paging_locked_by_me(v->domain));
SHADOW_PRINTK(""%pv gmfn=%""PRI_mfn""\n"", v, mfn_x(gmfn));
pg = mfn_to_page(gmfn);
if ( pg->shadow_flags &
((SHF_page_type_mask & ~SHF_L1_ANY) | SHF_out_of_sync)
|| sh_page_has_multiple_shadows(pg)
|| is_pv_vcpu(v)
|| !v->domain->arch.paging.shadow.oos_active )
return 0;
pg->shadow_flags |= SHF_out_of_sync|SHF_oos_may_write;
oos_hash_add(v, gmfn);
perfc_incr(shadow_unsync);
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_UNSYNC);
return 1;
}","int sh_unsync(struct vcpu *VAR_0, mfn_t VAR_1)
{
struct page_info *VAR_2;
ASSERT(paging_locked_by_me(VAR_0->domain));
SHADOW_PRINTK(""%pv gmfn=%""VAR_3""\n"", VAR_0, mfn_x(VAR_1));
VAR_2 = mfn_to_page(VAR_1);
if ( VAR_2->shadow_flags &
((VAR_4 & ~VAR_5) | VAR_6)
|| sh_page_has_multiple_shadows(VAR_2)
|| is_pv_vcpu(VAR_0)
|| !VAR_0->domain->arch.paging.shadow.oos_active )
return 0;
VAR_2->shadow_flags |= VAR_6|VAR_7;
oos_hash_add(VAR_0, VAR_1);
perfc_incr(VAR_8);
TRACE_SHADOW_PATH_FLAG(VAR_9);
return 1;
}",xen-project/xen/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d/common.c/vul/before/0.json,"int sh_unsync(struct vcpu *v, mfn_t gmfn)
{
    struct page_info *pg;

    ASSERT(paging_locked_by_me(v->domain));

    SHADOW_PRINTK(""%pv gmfn=%""PRI_mfn""\n"", v, mfn_x(gmfn));

    pg = mfn_to_page(gmfn);

    /* Guest page must be shadowed *only* as L1 and *only* once when out
     * of sync.  Also, get out now if it's already out of sync.
     * Also, can't safely unsync if some vcpus have paging disabled.*/
    if ( pg->shadow_flags &
         ((SHF_page_type_mask & ~SHF_L1_ANY) | SHF_out_of_sync)
         || sh_page_has_multiple_shadows(pg)
         || is_pv_vcpu(v)
         || !v->domain->arch.paging.shadow.oos_active )
        return 0;

    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_out_of_sync);
    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_oos_may_write);

    pg->shadow_flags |= SHF_out_of_sync|SHF_oos_may_write;
    oos_hash_add(v, gmfn);
    perfc_incr(shadow_unsync);
    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_UNSYNC);
    return 1;
}","int sh_unsync(struct vcpu *VAR_0, mfn_t VAR_1)
{
    struct page_info *VAR_2;

    ASSERT(paging_locked_by_me(VAR_0->domain));

    SHADOW_PRINTK(""%pv gmfn=%""VAR_3""\n"", VAR_0, mfn_x(VAR_1));

    VAR_2 = mfn_to_page(VAR_1);

    /* COMMENT_0 */
                                                               
                                                                      
    if ( VAR_2->shadow_flags &
         ((VAR_4 & ~VAR_5) | VAR_6)
         || sh_page_has_multiple_shadows(VAR_2)
         || is_pv_vcpu(VAR_0)
         || !VAR_0->domain->arch.paging.shadow.oos_active )
        return 0;

    BUILD_BUG_ON(!(typeof(VAR_2->shadow_flags))VAR_6);
    BUILD_BUG_ON(!(typeof(VAR_2->shadow_flags))VAR_7);

    VAR_2->shadow_flags |= VAR_6|VAR_7;
    oos_hash_add(VAR_0, VAR_1);
    perfc_incr(VAR_8);
    TRACE_SHADOW_PATH_FLAG(VAR_9);
    return 1;
}",xen-project/xen/d68e1070c3e8f4af7a31040f08bdd98e6d6eac1d/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,9 @@
          || !v->domain->arch.paging.shadow.oos_active )
         return 0;
 
+    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_out_of_sync);
+    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_oos_may_write);
+
     pg->shadow_flags |= SHF_out_of_sync|SHF_oos_may_write;
     oos_hash_add(v, gmfn);
     perfc_incr(shadow_unsync);","{'deleted_lines': [], 'added_lines': ['    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_out_of_sync);', '    BUILD_BUG_ON(!(typeof(pg->shadow_flags))SHF_oos_may_write);', '']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:13Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/multi.c,sh_pagetable_dying,"static void sh_pagetable_dying(paddr_t gpa)
{
struct vcpu *v = current;
struct domain *d = v->domain;
int i = 0;
int flush = 0;
int fast_path = 0;
paddr_t gcr3 = 0;
p2m_type_t p2mt;
char *gl3pa = NULL;
guest_l3e_t *gl3e = NULL;
unsigned long l3gfn;
mfn_t l3mfn;
gcr3 = v->arch.hvm.guest_cr[3];
if ( gcr3 == gpa )
fast_path = 1;
l3gfn = gpa >> PAGE_SHIFT;
l3mfn = get_gfn_query(d, _gfn(l3gfn), &p2mt);
if ( !mfn_valid(l3mfn) || !p2m_is_ram(p2mt) )
{
printk(XENLOG_DEBUG ""sh_pagetable_dying: gpa not valid %""PRIpaddr""\n"",
gpa);
goto out_put_gfn;
}
paging_lock(d);
if ( !fast_path )
{
gl3pa = map_domain_page(l3mfn);
gl3e = (guest_l3e_t *)(gl3pa + ((unsigned long)gpa & ~PAGE_MASK));
}
for ( i = 0; i < 4; i++ )
{
mfn_t smfn, gmfn;
if ( fast_path ) {
if ( pagetable_is_null(v->arch.shadow_table[i]) )
smfn = INVALID_MFN;
else
smfn = pagetable_get_mfn(v->arch.shadow_table[i]);
}
else
{
gmfn = get_gfn_query_unlocked(d, gfn_x(guest_l3e_get_gfn(gl3e[i])),
&p2mt);
smfn = unlikely(mfn_eq(gmfn, INVALID_MFN))
? INVALID_MFN
: shadow_hash_lookup(d, mfn_x(gmfn), SH_type_l2_pae_shadow);
}
if ( mfn_valid(smfn) )
{
gmfn = _mfn(mfn_to_page(smfn)->v.sh.back);
mfn_to_page(gmfn)->shadow_flags |= SHF_pagetable_dying;
shadow_unhook_mappings(d, smfn, 1);
flush = 1;
}
}
if ( flush )
flush_tlb_mask(d->dirty_cpumask);
d->arch.paging.shadow.pagetable_dying_op = 1;
v->arch.paging.shadow.pagetable_dying = 1;
if ( !fast_path )
unmap_domain_page(gl3pa);
paging_unlock(d);
out_put_gfn:
put_gfn(d, l3gfn);
}","static void sh_pagetable_dying(paddr_t VAR_0)
{
struct vcpu *VAR_1 = VAR_2;
struct domain *VAR_3 = VAR_1->domain;
int VAR_4 = 0;
int VAR_5 = 0;
int VAR_6 = 0;
paddr_t VAR_7 = 0;
p2m_type_t VAR_8;
char *VAR_9 = NULL;
guest_l3e_t *VAR_10 = NULL;
unsigned long VAR_11;
mfn_t VAR_12;
VAR_7 = VAR_1->arch.hvm.guest_cr[3];
if ( VAR_7 == VAR_0 )
VAR_6 = 1;
VAR_11 = VAR_0 >> VAR_13;
VAR_12 = get_gfn_query(VAR_3, _gfn(VAR_11), &VAR_8);
if ( !mfn_valid(VAR_12) || !p2m_is_ram(VAR_8) )
{
VAR_14(VAR_15 ""sh_pagetable_dying: gpa not valid %""VAR_16""\n"",
VAR_0);
goto out_put_gfn;
}
paging_lock(VAR_3);
if ( !VAR_6 )
{
VAR_9 = map_domain_page(VAR_12);
VAR_10 = (guest_l3e_t *)(VAR_9 + ((unsigned long)VAR_0 & ~VAR_17));
}
for ( VAR_4 = 0; VAR_4 < 4; VAR_4++ )
{
mfn_t VAR_18, VAR_19;
if ( VAR_6 ) {
if ( pagetable_is_null(VAR_1->arch.shadow_table[VAR_4]) )
VAR_18 = VAR_20;
else
VAR_18 = pagetable_get_mfn(VAR_1->arch.shadow_table[VAR_4]);
}
else
{
VAR_19 = get_gfn_query_unlocked(VAR_3, gfn_x(guest_l3e_get_gfn(VAR_10[VAR_4])),
&VAR_8);
VAR_18 = unlikely(mfn_eq(VAR_19, VAR_20))
? VAR_20
: shadow_hash_lookup(VAR_3, mfn_x(VAR_19), VAR_21);
}
if ( mfn_valid(VAR_18) )
{
VAR_19 = _mfn(mfn_to_page(VAR_18)->v.sh.back);
mfn_to_page(VAR_19)->shadow_flags |= VAR_22;
shadow_unhook_mappings(VAR_3, VAR_18, 1);
VAR_5 = 1;
}
}
if ( VAR_5 )
flush_tlb_mask(VAR_3->dirty_cpumask);
VAR_3->arch.paging.shadow.pagetable_dying_op = 1;
VAR_1->arch.paging.shadow.pagetable_dying = 1;
if ( !VAR_6 )
unmap_domain_page(VAR_9);
paging_unlock(VAR_3);
out_put_gfn:
put_gfn(VAR_3, VAR_11);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/before/0.json,"static void sh_pagetable_dying(paddr_t gpa)
{
    struct vcpu *v = current;
    struct domain *d = v->domain;
    int i = 0;
    int flush = 0;
    int fast_path = 0;
    paddr_t gcr3 = 0;
    p2m_type_t p2mt;
    char *gl3pa = NULL;
    guest_l3e_t *gl3e = NULL;
    unsigned long l3gfn;
    mfn_t l3mfn;

    gcr3 = v->arch.hvm.guest_cr[3];
    /* fast path: the pagetable belongs to the current context */
    if ( gcr3 == gpa )
        fast_path = 1;

    l3gfn = gpa >> PAGE_SHIFT;
    l3mfn = get_gfn_query(d, _gfn(l3gfn), &p2mt);
    if ( !mfn_valid(l3mfn) || !p2m_is_ram(p2mt) )
    {
        printk(XENLOG_DEBUG ""sh_pagetable_dying: gpa not valid %""PRIpaddr""\n"",
               gpa);
        goto out_put_gfn;
    }

    paging_lock(d);

    if ( !fast_path )
    {
        gl3pa = map_domain_page(l3mfn);
        gl3e = (guest_l3e_t *)(gl3pa + ((unsigned long)gpa & ~PAGE_MASK));
    }
    for ( i = 0; i < 4; i++ )
    {
        mfn_t smfn, gmfn;

        if ( fast_path ) {
            if ( pagetable_is_null(v->arch.shadow_table[i]) )
                smfn = INVALID_MFN;
            else
                smfn = pagetable_get_mfn(v->arch.shadow_table[i]);
        }
        else
        {
            /* retrieving the l2s */
            gmfn = get_gfn_query_unlocked(d, gfn_x(guest_l3e_get_gfn(gl3e[i])),
                                          &p2mt);
            smfn = unlikely(mfn_eq(gmfn, INVALID_MFN))
                   ? INVALID_MFN
                   : shadow_hash_lookup(d, mfn_x(gmfn), SH_type_l2_pae_shadow);
        }

        if ( mfn_valid(smfn) && is_hvm_domain(d) )
        {
            gmfn = _mfn(mfn_to_page(smfn)->v.sh.back);
            mfn_to_page(gmfn)->pagetable_dying = true;
            shadow_unhook_mappings(d, smfn, 1/* user pages only */);
            flush = 1;
        }
    }
    if ( flush )
        flush_tlb_mask(d->dirty_cpumask);

    /* Remember that we've seen the guest use this interface, so we
     * can rely on it using it in future, instead of guessing at
     * when processes are being torn down. */
    d->arch.paging.shadow.pagetable_dying_op = 1;

    v->arch.paging.shadow.pagetable_dying = 1;

    if ( !fast_path )
        unmap_domain_page(gl3pa);
    paging_unlock(d);
out_put_gfn:
    put_gfn(d, l3gfn);
}","static void sh_pagetable_dying(paddr_t VAR_0)
{
    struct vcpu *VAR_1 = VAR_2;
    struct domain *VAR_3 = VAR_1->domain;
    int VAR_4 = 0;
    int VAR_5 = 0;
    int VAR_6 = 0;
    paddr_t VAR_7 = 0;
    p2m_type_t VAR_8;
    char *VAR_9 = NULL;
    guest_l3e_t *VAR_10 = NULL;
    unsigned long VAR_11;
    mfn_t VAR_12;

    VAR_7 = VAR_1->arch.hvm.guest_cr[3];
    /* COMMENT_0 */
    if ( VAR_7 == VAR_0 )
        VAR_6 = 1;

    VAR_11 = VAR_0 >> VAR_13;
    VAR_12 = get_gfn_query(VAR_3, _gfn(VAR_11), &VAR_8);
    if ( !mfn_valid(VAR_12) || !p2m_is_ram(VAR_8) )
    {
        VAR_14(VAR_15 ""sh_pagetable_dying: gpa not valid %""VAR_16""\n"",
               VAR_0);
        goto out_put_gfn;
    }

    paging_lock(VAR_3);

    if ( !VAR_6 )
    {
        VAR_9 = map_domain_page(VAR_12);
        VAR_10 = (guest_l3e_t *)(VAR_9 + ((unsigned long)VAR_0 & ~VAR_17));
    }
    for ( VAR_4 = 0; VAR_4 < 4; VAR_4++ )
    {
        mfn_t VAR_18, VAR_19;

        if ( VAR_6 ) {
            if ( pagetable_is_null(VAR_1->arch.shadow_table[VAR_4]) )
                VAR_18 = VAR_20;
            else
                VAR_18 = pagetable_get_mfn(VAR_1->arch.shadow_table[VAR_4]);
        }
        else
        {
            /* COMMENT_1 */
            VAR_19 = get_gfn_query_unlocked(VAR_3, gfn_x(guest_l3e_get_gfn(VAR_10[VAR_4])),
                                          &VAR_8);
            VAR_18 = unlikely(mfn_eq(VAR_19, VAR_20))
                   ? VAR_20
                   : shadow_hash_lookup(VAR_3, mfn_x(VAR_19), VAR_21);
        }

        if ( mfn_valid(VAR_18) && is_hvm_domain(VAR_3) )
        {
            VAR_19 = _mfn(mfn_to_page(VAR_18)->v.sh.back);
            mfn_to_page(VAR_19)->pagetable_dying = true;
            shadow_unhook_mappings(VAR_3, VAR_18, 1/* COMMENT_2 */);
            VAR_5 = 1;
        }
    }
    if ( VAR_5 )
        flush_tlb_mask(VAR_3->dirty_cpumask);

    /* COMMENT_3 */
                                                                
                                             
    VAR_3->arch.paging.shadow.pagetable_dying_op = 1;

    VAR_1->arch.paging.shadow.pagetable_dying = 1;

    if ( !VAR_6 )
        unmap_domain_page(VAR_9);
    paging_unlock(VAR_3);
out_put_gfn:
    put_gfn(VAR_3, VAR_11);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,10 +53,10 @@
                    : shadow_hash_lookup(d, mfn_x(gmfn), SH_type_l2_pae_shadow);
         }
 
-        if ( mfn_valid(smfn) )
+        if ( mfn_valid(smfn) && is_hvm_domain(d) )
         {
             gmfn = _mfn(mfn_to_page(smfn)->v.sh.back);
-            mfn_to_page(gmfn)->shadow_flags |= SHF_pagetable_dying;
+            mfn_to_page(gmfn)->pagetable_dying = true;
             shadow_unhook_mappings(d, smfn, 1/* user pages only */);
             flush = 1;
         }","{'deleted_lines': ['        if ( mfn_valid(smfn) )', '            mfn_to_page(gmfn)->shadow_flags |= SHF_pagetable_dying;'], 'added_lines': ['        if ( mfn_valid(smfn) && is_hvm_domain(d) )', '            mfn_to_page(gmfn)->pagetable_dying = true;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/common.c,shadow_promote,"void shadow_promote(struct domain *d, mfn_t gmfn, unsigned int type)
{
struct page_info *page = mfn_to_page(gmfn);
ASSERT(mfn_valid(gmfn));
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( page_is_out_of_sync(page) )
sh_resync(d, gmfn);
#endif
ASSERT((page->u.inuse.type_info & PGT_type_mask) != PGT_writable_page
|| (page->u.inuse.type_info & PGT_count_mask) == 0
|| d->is_shutting_down);
if ( !test_and_set_bit(_PGC_page_table, &page->count_info) )
page->shadow_flags = 0;
ASSERT(!test_bit(type, &page->shadow_flags));
set_bit(type, &page->shadow_flags);
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_PROMOTE);
}","void shadow_promote(struct domain *VAR_0, mfn_t VAR_1, unsigned int VAR_2)
{
struct page_info *VAR_3 = mfn_to_page(VAR_1);
ASSERT(mfn_valid(VAR_1));
#if (VAR_4 & VAR_5)
if ( page_is_out_of_sync(VAR_3) )
sh_resync(VAR_0, VAR_1);
#endif
ASSERT((VAR_3->u.inuse.type_info & VAR_6) != VAR_7
|| (VAR_3->u.inuse.type_info & VAR_8) == 0
|| VAR_0->is_shutting_down);
if ( !test_and_set_bit(VAR_9, &VAR_3->count_info) )
VAR_3->shadow_flags = 0;
ASSERT(!test_bit(VAR_2, &VAR_3->shadow_flags));
set_bit(VAR_2, &VAR_3->shadow_flags);
TRACE_SHADOW_PATH_FLAG(VAR_10);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/before/2.json,"void shadow_promote(struct domain *d, mfn_t gmfn, unsigned int type)
{
    struct page_info *page = mfn_to_page(gmfn);

    ASSERT(mfn_valid(gmfn));

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
    /* Is the page already shadowed and out of sync? */
    if ( page_is_out_of_sync(page) )
        sh_resync(d, gmfn);
#endif

    /* We should never try to promote a gmfn that has writeable mappings */
    ASSERT((page->u.inuse.type_info & PGT_type_mask) != PGT_writable_page
           || (page->u.inuse.type_info & PGT_count_mask) == 0
           || d->is_shutting_down);

    /* Is the page already shadowed? */
    if ( !test_and_set_bit(_PGC_page_table, &page->count_info) )
    {
        page->shadow_flags = 0;
        if ( is_hvm_domain(d) )
            page->pagetable_dying = false;
    }

    ASSERT(!(page->shadow_flags & (1u << type)));
    page->shadow_flags |= 1u << type;
    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_PROMOTE);
}","void shadow_promote(struct domain *VAR_0, mfn_t VAR_1, unsigned int VAR_2)
{
    struct page_info *VAR_3 = mfn_to_page(VAR_1);

    ASSERT(mfn_valid(VAR_1));

#if (VAR_4 & VAR_5)
    /* COMMENT_0 */
    if ( page_is_out_of_sync(VAR_3) )
        sh_resync(VAR_0, VAR_1);
#endif

    /* COMMENT_1 */
    ASSERT((VAR_3->u.inuse.type_info & VAR_6) != VAR_7
           || (VAR_3->u.inuse.type_info & VAR_8) == 0
           || VAR_0->is_shutting_down);

    /* COMMENT_2 */
    if ( !test_and_set_bit(VAR_9, &VAR_3->count_info) )
    {
        VAR_3->shadow_flags = 0;
        if ( is_hvm_domain(VAR_0) )
            VAR_3->pagetable_dying = false;
    }

    ASSERT(!(VAR_3->shadow_flags & (1u << VAR_2)));
    VAR_3->shadow_flags |= 1u << VAR_2;
    TRACE_SHADOW_PATH_FLAG(VAR_10);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -17,9 +17,13 @@
 
     /* Is the page already shadowed? */
     if ( !test_and_set_bit(_PGC_page_table, &page->count_info) )
+    {
         page->shadow_flags = 0;
+        if ( is_hvm_domain(d) )
+            page->pagetable_dying = false;
+    }
 
-    ASSERT(!test_bit(type, &page->shadow_flags));
-    set_bit(type, &page->shadow_flags);
+    ASSERT(!(page->shadow_flags & (1u << type)));
+    page->shadow_flags |= 1u << type;
     TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_PROMOTE);
 }","{'deleted_lines': ['    ASSERT(!test_bit(type, &page->shadow_flags));', '    set_bit(type, &page->shadow_flags);'], 'added_lines': ['    {', '        if ( is_hvm_domain(d) )', '            page->pagetable_dying = false;', '    }', '    ASSERT(!(page->shadow_flags & (1u << type)));', '    page->shadow_flags |= 1u << type;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/common.c,sh_remove_shadows,"void sh_remove_shadows(struct domain *d, mfn_t gmfn, int fast, int all)
{
struct page_info *pg = mfn_to_page(gmfn);
mfn_t smfn;
unsigned char t;
static const hash_domain_callback_t callbacks[SH_type_unused] = {
NULL, 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 2), 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), 
SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), 
SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), 
SHADOW_INTERNAL_NAME(sh_remove_l2_shadow, 4), 
SHADOW_INTERNAL_NAME(sh_remove_l3_shadow, 4), 
NULL, 
NULL  
};
static const unsigned int masks[SH_type_unused] = {
0, 
SHF_L2_32, 
0, 
0, 
SHF_L2H_PAE | SHF_L2_PAE, 
0, 
0, 
0, 
SHF_L2H_64 | SHF_L2_64, 
0, 
SHF_L3_64, 
SHF_L3_64, 
SHF_L4_64, 
0, 
0, 
0  
};
ASSERT(!(all && fast));
ASSERT(mfn_valid(gmfn));
paging_lock_recursive(d);
SHADOW_PRINTK(""d%d gmfn=%""PRI_mfn""\n"", d->domain_id, mfn_x(gmfn));
if ( (pg->count_info & PGC_page_table) == 0 )
{
paging_unlock(d);
return;
}
perfc_incr(shadow_unshadow);
#define DO_UNSHADOW(_type) do {                                         \
t = (_type);                                                        \
if( !(pg->count_info & PGC_page_table)                              \
|| !(pg->shadow_flags & (1 << t)) )                             \
break;                                                          \
smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \
if ( unlikely(!mfn_valid(smfn)) )                                   \
{                                                                   \
printk(XENLOG_G_ERR ""gmfn %""PRI_mfn"" has flags %#x""             \
"" but no type-%#x shadow\n"",                             \
mfn_x(gmfn), pg->shadow_flags, t);                       \
break;                                                          \
}                                                                   \
if ( sh_type_is_pinnable(d, t) )                                    \
sh_unpin(d, smfn);                                              \
else if ( sh_type_has_up_pointer(d, t) )                            \
sh_remove_shadow_via_pointer(d, smfn);                          \
if( !fast                                                           \
&& (pg->count_info & PGC_page_table)                            \
&& (pg->shadow_flags & (1 << t)) )                              \
hash_domain_foreach(d, masks[t], callbacks, smfn);              \
} while (0)
DO_UNSHADOW(SH_type_l2_32_shadow);
DO_UNSHADOW(SH_type_l1_32_shadow);
DO_UNSHADOW(SH_type_l2h_pae_shadow);
DO_UNSHADOW(SH_type_l2_pae_shadow);
DO_UNSHADOW(SH_type_l1_pae_shadow);
DO_UNSHADOW(SH_type_l4_64_shadow);
DO_UNSHADOW(SH_type_l3_64_shadow);
DO_UNSHADOW(SH_type_l2h_64_shadow);
DO_UNSHADOW(SH_type_l2_64_shadow);
DO_UNSHADOW(SH_type_l1_64_shadow);
#undef DO_UNSHADOW
if ( !fast && all && (pg->count_info & PGC_page_table) )
{
printk(XENLOG_G_ERR ""can't find all shadows of mfn %""PRI_mfn
"" (shadow_flags=%08x)\n"", mfn_x(gmfn), pg->shadow_flags);
domain_crash(d);
}
flush_tlb_mask(d->dirty_cpumask);
paging_unlock(d);
}","void sh_remove_shadows(struct domain *VAR_0, mfn_t VAR_1, int VAR_2, int VAR_3)
{
struct page_info *VAR_4 = mfn_to_page(VAR_1);
mfn_t VAR_5;
unsigned char VAR_6;
static const hash_domain_callback_t VAR_7[VAR_8] = {
NULL, 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(VAR_9, 2), 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(VAR_9, 3), 
SHADOW_INTERNAL_NAME(VAR_9, 3), 
NULL, 
NULL, 
SHADOW_INTERNAL_NAME(VAR_9, 4), 
SHADOW_INTERNAL_NAME(VAR_9, 4), 
SHADOW_INTERNAL_NAME(VAR_10, 4), 
SHADOW_INTERNAL_NAME(VAR_11, 4), 
NULL, 
NULL  
};
static const unsigned int VAR_12[VAR_8] = {
0, 
VAR_13, 
0, 
0, 
VAR_14 | VAR_15, 
0, 
0, 
0, 
VAR_16 | VAR_17, 
0, 
VAR_18, 
VAR_18, 
VAR_19, 
0, 
0, 
0  
};
ASSERT(!(VAR_3 && VAR_2));
ASSERT(mfn_valid(VAR_1));
paging_lock_recursive(VAR_0);
SHADOW_PRINTK(""d%d gmfn=%""VAR_20""\n"", VAR_0->domain_id, mfn_x(VAR_1));
if ( (VAR_4->count_info & VAR_21) == 0 )
{
paging_unlock(VAR_0);
return;
}
perfc_incr(VAR_22);
#define DO_UNSHADOW(VAR_23) do {                                         \
t = (_type);                                                        \
if( !(pg->count_info & PGC_page_table)                              \
|| !(pg->shadow_flags & (1 << t)) )                             \
break;                                                          \
smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \
if ( unlikely(!mfn_valid(smfn)) )                                   \
{                                                                   \
printk(XENLOG_G_ERR ""gmfn %""PRI_mfn"" has flags %#x""             \
"" but no type-%#x shadow\n"",                             \
mfn_x(gmfn), pg->shadow_flags, t);                       \
break;                                                          \
}                                                                   \
if ( sh_type_is_pinnable(d, t) )                                    \
sh_unpin(d, smfn);                                              \
else if ( sh_type_has_up_pointer(d, t) )                            \
sh_remove_shadow_via_pointer(d, smfn);                          \
if( !fast                                                           \
&& (pg->count_info & PGC_page_table)                            \
&& (pg->shadow_flags & (1 << t)) )                              \
hash_domain_foreach(d, masks[t], callbacks, smfn);              \
} while (0)
DO_UNSHADOW(VAR_24);
DO_UNSHADOW(VAR_25);
DO_UNSHADOW(VAR_26);
DO_UNSHADOW(VAR_27);
DO_UNSHADOW(VAR_28);
DO_UNSHADOW(VAR_29);
DO_UNSHADOW(VAR_30);
DO_UNSHADOW(VAR_31);
DO_UNSHADOW(VAR_32);
DO_UNSHADOW(VAR_33);
#undef DO_UNSHADOW
if ( !VAR_2 && VAR_3 && (VAR_4->count_info & VAR_21) )
{
printk(XENLOG_G_ERR ""can't find all shadows of mfn %""VAR_20
"" (shadow_flags=%08x)\n"", mfn_x(VAR_1), VAR_4->shadow_flags);
domain_crash(VAR_0);
}
flush_tlb_mask(VAR_0->dirty_cpumask);
paging_unlock(VAR_0);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/before/1.json,"void sh_remove_shadows(struct domain *d, mfn_t gmfn, int fast, int all)
/* Remove the shadows of this guest page.
 * If fast != 0, just try the quick heuristic, which will remove
 * at most one reference to each shadow of the page.  Otherwise, walk
 * all the shadow tables looking for refs to shadows of this gmfn.
 * If all != 0, kill the domain if we can't find all the shadows.
 * (all != 0 implies fast == 0)
 */
{
    struct page_info *pg = mfn_to_page(gmfn);
    mfn_t smfn;
    unsigned char t;

    /* Dispatch table for getting per-type functions: each level must
     * be called with the function to remove a lower-level shadow. */
    static const hash_domain_callback_t callbacks[SH_type_unused] = {
        NULL, /* none    */
        NULL, /* l1_32   */
        NULL, /* fl1_32  */
        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 2), /* l2_32   */
        NULL, /* l1_pae  */
        NULL, /* fl1_pae */
        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2_pae  */
        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2h_pae */
        NULL, /* l1_64   */
        NULL, /* fl1_64  */
        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2_64   */
        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2h_64  */
        SHADOW_INTERNAL_NAME(sh_remove_l2_shadow, 4), /* l3_64   */
        SHADOW_INTERNAL_NAME(sh_remove_l3_shadow, 4), /* l4_64   */
        NULL, /* p2m     */
        NULL  /* unused  */
    };

    /* Another lookup table, for choosing which mask to use */
    static const unsigned int masks[SH_type_unused] = {
        0, /* none    */
        SHF_L2_32, /* l1_32   */
        0, /* fl1_32  */
        0, /* l2_32   */
        SHF_L2H_PAE | SHF_L2_PAE, /* l1_pae  */
        0, /* fl1_pae */
        0, /* l2_pae  */
        0, /* l2h_pae  */
        SHF_L2H_64 | SHF_L2_64, /* l1_64   */
        0, /* fl1_64  */
        SHF_L3_64, /* l2_64   */
        SHF_L3_64, /* l2h_64  */
        SHF_L4_64, /* l3_64   */
        0, /* l4_64   */
        0, /* p2m     */
        0  /* unused  */
    };

    ASSERT(!(all && fast));
    ASSERT(mfn_valid(gmfn));

    /* Although this is an externally visible function, we do not know
     * whether the paging lock will be held when it is called (since it
     * can be called via put_page_type when we clear a shadow l1e).*/
    paging_lock_recursive(d);

    SHADOW_PRINTK(""d%d gmfn=%""PRI_mfn""\n"", d->domain_id, mfn_x(gmfn));

    /* Bail out now if the page is not shadowed */
    if ( (pg->count_info & PGC_page_table) == 0 )
    {
        paging_unlock(d);
        return;
    }

    /* Search for this shadow in all appropriate shadows */
    perfc_incr(shadow_unshadow);

    /* Lower-level shadows need to be excised from upper-level shadows.
     * This call to hash_vcpu_foreach() looks dangerous but is in fact OK: each
     * call will remove at most one shadow, and terminate immediately when
     * it does remove it, so we never walk the hash after doing a deletion.  */
#define DO_UNSHADOW(_type) do {                                         \
    t = (_type);                                                        \
    if( !(pg->count_info & PGC_page_table)                              \
        || !(pg->shadow_flags & (1 << t)) )                             \
        break;                                                          \
    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \
    if ( unlikely(!mfn_valid(smfn)) )                                   \
    {                                                                   \
        printk(XENLOG_G_ERR ""gmfn %""PRI_mfn"" has flags %#x""             \
               "" but no type-%#x shadow\n"",                             \
               mfn_x(gmfn), pg->shadow_flags, t);                       \
        break;                                                          \
    }                                                                   \
    if ( sh_type_is_pinnable(d, t) )                                    \
        sh_unpin(d, smfn);                                              \
    else if ( sh_type_has_up_pointer(d, t) )                            \
        sh_remove_shadow_via_pointer(d, smfn);                          \
    if( !fast                                                           \
        && (pg->count_info & PGC_page_table)                            \
        && (pg->shadow_flags & (1 << t)) )                              \
        hash_domain_foreach(d, masks[t], callbacks, smfn);              \
} while (0)

    DO_UNSHADOW(SH_type_l2_32_shadow);
    DO_UNSHADOW(SH_type_l1_32_shadow);
    DO_UNSHADOW(SH_type_l2h_pae_shadow);
    DO_UNSHADOW(SH_type_l2_pae_shadow);
    DO_UNSHADOW(SH_type_l1_pae_shadow);
    DO_UNSHADOW(SH_type_l4_64_shadow);
    DO_UNSHADOW(SH_type_l3_64_shadow);
    DO_UNSHADOW(SH_type_l2h_64_shadow);
    DO_UNSHADOW(SH_type_l2_64_shadow);
    DO_UNSHADOW(SH_type_l1_64_shadow);

#undef DO_UNSHADOW

    /* If that didn't catch the shadows, something is wrong */
    if ( !fast && all && (pg->count_info & PGC_page_table) )
    {
        printk(XENLOG_G_ERR ""can't find all shadows of mfn %""PRI_mfn
               "" (shadow_flags=%04x)\n"", mfn_x(gmfn), pg->shadow_flags);
        domain_crash(d);
    }

    /* Need to flush TLBs now, so that linear maps are safe next time we
     * take a fault. */
    flush_tlb_mask(d->dirty_cpumask);

    paging_unlock(d);
}","void sh_remove_shadows(struct domain *VAR_0, mfn_t VAR_1, int VAR_2, int VAR_3)
/* COMMENT_0 */
                                                                
                                                                     
                                                                  
                                                                 
                               
   
{
    struct page_info *VAR_4 = mfn_to_page(VAR_1);
    mfn_t VAR_5;
    unsigned char VAR_6;

    /* COMMENT_7 */
                                                                     
    static const hash_domain_callback_t VAR_7[VAR_8] = {
        NULL, /* COMMENT_9 */
        NULL, /* COMMENT_10 */
        NULL, /* COMMENT_11 */
        SHADOW_INTERNAL_NAME(VAR_9, 2), /* COMMENT_12 */
        NULL, /* COMMENT_13 */
        NULL, /* COMMENT_14 */
        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_15 */
        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_16 */
        NULL, /* COMMENT_17 */
        NULL, /* COMMENT_18 */
        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_19 */
        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_20 */
        SHADOW_INTERNAL_NAME(VAR_10, 4), /* COMMENT_21 */
        SHADOW_INTERNAL_NAME(VAR_11, 4), /* COMMENT_22 */
        NULL, /* COMMENT_23 */
        NULL  /* COMMENT_24 */
    };

    /* COMMENT_25 */
    static const unsigned int VAR_12[VAR_8] = {
        0, /* COMMENT_9 */
        VAR_13, /* COMMENT_10 */
        0, /* COMMENT_11 */
        0, /* COMMENT_12 */
        VAR_14 | VAR_15, /* COMMENT_13 */
        0, /* COMMENT_14 */
        0, /* COMMENT_15 */
        0, /* COMMENT_26 */
        VAR_16 | VAR_17, /* COMMENT_17 */
        0, /* COMMENT_18 */
        VAR_18, /* COMMENT_19 */
        VAR_18, /* COMMENT_20 */
        VAR_19, /* COMMENT_21 */
        0, /* COMMENT_22 */
        0, /* COMMENT_23 */
        0  /* COMMENT_24 */
    };

    ASSERT(!(VAR_3 && VAR_2));
    ASSERT(mfn_valid(VAR_1));

    /* COMMENT_27 */
                                                                       
                                                                     
    paging_lock_recursive(VAR_0);

    SHADOW_PRINTK(""d%d gmfn=%""VAR_20""\n"", VAR_0->domain_id, mfn_x(VAR_1));

    /* COMMENT_30 */
    if ( (VAR_4->count_info & VAR_21) == 0 )
    {
        paging_unlock(VAR_0);
        return;
    }

    /* COMMENT_31 */
    perfc_incr(VAR_22);

    /* COMMENT_32 */
                                                                               
                                                                          
                                                                               
#define DO_UNSHADOW(VAR_23) do {                                         \
    t = (_type);                                                        \
    if( !(pg->count_info & PGC_page_table)                              \
        || !(pg->shadow_flags & (1 << t)) )                             \
        break;                                                          \
    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \
    if ( unlikely(!mfn_valid(smfn)) )                                   \
    {                                                                   \
        printk(XENLOG_G_ERR ""gmfn %""PRI_mfn"" has flags %#x""             \
               "" but no type-%#x shadow\n"",                             \
               mfn_x(gmfn), pg->shadow_flags, t);                       \
        break;                                                          \
    }                                                                   \
    if ( sh_type_is_pinnable(d, t) )                                    \
        sh_unpin(d, smfn);                                              \
    else if ( sh_type_has_up_pointer(d, t) )                            \
        sh_remove_shadow_via_pointer(d, smfn);                          \
    if( !fast                                                           \
        && (pg->count_info & PGC_page_table)                            \
        && (pg->shadow_flags & (1 << t)) )                              \
        hash_domain_foreach(d, masks[t], callbacks, smfn);              \
} while (0)

    DO_UNSHADOW(VAR_24);
    DO_UNSHADOW(VAR_25);
    DO_UNSHADOW(VAR_26);
    DO_UNSHADOW(VAR_27);
    DO_UNSHADOW(VAR_28);
    DO_UNSHADOW(VAR_29);
    DO_UNSHADOW(VAR_30);
    DO_UNSHADOW(VAR_31);
    DO_UNSHADOW(VAR_32);
    DO_UNSHADOW(VAR_33);

#undef DO_UNSHADOW

    /* COMMENT_36 */
    if ( !VAR_2 && VAR_3 && (VAR_4->count_info & VAR_21) )
    {
        printk(XENLOG_G_ERR ""can't find all shadows of mfn %""VAR_20
               "" (shadow_flags=%04x)\n"", mfn_x(VAR_1), VAR_4->shadow_flags);
        domain_crash(VAR_0);
    }

    /* COMMENT_37 */
                       
    flush_tlb_mask(VAR_0->dirty_cpumask);

    paging_unlock(VAR_0);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -116,7 +116,7 @@
     if ( !fast && all && (pg->count_info & PGC_page_table) )
     {
         printk(XENLOG_G_ERR ""can't find all shadows of mfn %""PRI_mfn
-               "" (shadow_flags=%08x)\n"", mfn_x(gmfn), pg->shadow_flags);
+               "" (shadow_flags=%04x)\n"", mfn_x(gmfn), pg->shadow_flags);
         domain_crash(d);
     }
 ","{'deleted_lines': ['               "" (shadow_flags=%08x)\\n"", mfn_x(gmfn), pg->shadow_flags);'], 'added_lines': ['               "" (shadow_flags=%04x)\\n"", mfn_x(gmfn), pg->shadow_flags);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/common.c,shadow_demote,"void shadow_demote(struct domain *d, mfn_t gmfn, u32 type)
{
struct page_info *page = mfn_to_page(gmfn);
ASSERT(test_bit(_PGC_page_table, &page->count_info));
ASSERT(test_bit(type, &page->shadow_flags));
clear_bit(type, &page->shadow_flags);
if ( (page->shadow_flags & SHF_page_type_mask) == 0 )
{
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( page_is_out_of_sync(page) )
{
oos_hash_remove(d, gmfn);
}
#endif
clear_bit(_PGC_page_table, &page->count_info);
}
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_DEMOTE);
}","void shadow_demote(struct domain *VAR_0, mfn_t VAR_1, u32 VAR_2)
{
struct page_info *VAR_3 = mfn_to_page(VAR_1);
ASSERT(test_bit(VAR_4, &VAR_3->count_info));
ASSERT(test_bit(VAR_2, &VAR_3->shadow_flags));
clear_bit(VAR_2, &VAR_3->shadow_flags);
if ( (VAR_3->shadow_flags & VAR_5) == 0 )
{
#if (VAR_6 & VAR_7)
if ( page_is_out_of_sync(VAR_3) )
{
oos_hash_remove(VAR_0, VAR_1);
}
#endif
clear_bit(VAR_4, &VAR_3->count_info);
}
TRACE_SHADOW_PATH_FLAG(VAR_8);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/before/0.json,"void shadow_demote(struct domain *d, mfn_t gmfn, u32 type)
{
    struct page_info *page = mfn_to_page(gmfn);

    ASSERT(test_bit(_PGC_page_table, &page->count_info));
    ASSERT(page->shadow_flags & (1u << type));

    page->shadow_flags &= ~(1u << type);

    if ( (page->shadow_flags & SHF_page_type_mask) == 0 )
    {
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
        /* Was the page out of sync? */
        if ( page_is_out_of_sync(page) )
        {
            oos_hash_remove(d, gmfn);
        }
#endif
        clear_bit(_PGC_page_table, &page->count_info);
    }

    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_DEMOTE);
}","void shadow_demote(struct domain *VAR_0, mfn_t VAR_1, u32 VAR_2)
{
    struct page_info *VAR_3 = mfn_to_page(VAR_1);

    ASSERT(test_bit(VAR_4, &VAR_3->count_info));
    ASSERT(VAR_3->shadow_flags & (1u << VAR_2));

    VAR_3->shadow_flags &= ~(1u << VAR_2);

    if ( (VAR_3->shadow_flags & VAR_5) == 0 )
    {
#if (VAR_6 & VAR_7)
        /* COMMENT_0 */
        if ( page_is_out_of_sync(VAR_3) )
        {
            oos_hash_remove(VAR_0, VAR_1);
        }
#endif
        clear_bit(VAR_4, &VAR_3->count_info);
    }

    TRACE_SHADOW_PATH_FLAG(VAR_8);
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,9 +3,9 @@
     struct page_info *page = mfn_to_page(gmfn);
 
     ASSERT(test_bit(_PGC_page_table, &page->count_info));
-    ASSERT(test_bit(type, &page->shadow_flags));
+    ASSERT(page->shadow_flags & (1u << type));
 
-    clear_bit(type, &page->shadow_flags);
+    page->shadow_flags &= ~(1u << type);
 
     if ( (page->shadow_flags & SHF_page_type_mask) == 0 )
     {","{'deleted_lines': ['    ASSERT(test_bit(type, &page->shadow_flags));', '    clear_bit(type, &page->shadow_flags);'], 'added_lines': ['    ASSERT(page->shadow_flags & (1u << type));', '    page->shadow_flags &= ~(1u << type);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/multi.c,sh_rm_write_access_from_sl1p,"int sh_rm_write_access_from_sl1p(struct domain *d, mfn_t gmfn,
mfn_t smfn, unsigned long off)
{
struct vcpu *curr = current;
int r;
shadow_l1e_t *sl1p, sl1e;
struct page_info *sp;
ASSERT(mfn_valid(gmfn));
ASSERT(mfn_valid(smfn));
if ( curr->domain == d )
curr->arch.paging.shadow.pagetable_dying
= !!(mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying);
sp = mfn_to_page(smfn);
if ( ((sp->count_info & PGC_count_mask) != 0)
|| (sp->u.sh.type != SH_type_l1_shadow
&& sp->u.sh.type != SH_type_fl1_shadow) )
goto fail;
sl1p = map_domain_page(smfn);
sl1p += off;
sl1e = *sl1p;
if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
!= (_PAGE_PRESENT|_PAGE_RW))
|| !mfn_eq(shadow_l1e_get_mfn(sl1e), gmfn) )
{
unmap_domain_page(sl1p);
goto fail;
}
sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, smfn);
ASSERT( !(r & SHADOW_SET_ERROR) );
unmap_domain_page(sl1p);
perfc_incr(shadow_writeable_h_7);
return 1;
fail:
perfc_incr(shadow_writeable_h_8);
return 0;
}","int sh_rm_write_access_from_sl1p(struct domain *VAR_0, mfn_t VAR_1,
mfn_t VAR_2, unsigned long VAR_3)
{
struct vcpu *VAR_4 = VAR_5;
int VAR_6;
shadow_l1e_t *VAR_7, VAR_8;
struct page_info *VAR_9;
ASSERT(mfn_valid(VAR_1));
ASSERT(mfn_valid(VAR_2));
if ( VAR_4->domain == VAR_0 )
VAR_4->arch.paging.shadow.pagetable_dying
= !!(mfn_to_page(VAR_1)->shadow_flags & VAR_10);
VAR_9 = mfn_to_page(VAR_2);
if ( ((VAR_9->count_info & VAR_11) != 0)
|| (VAR_9->u.sh.type != VAR_12
&& VAR_9->u.sh.type != VAR_13) )
goto fail;
VAR_7 = map_domain_page(VAR_2);
VAR_7 += VAR_3;
VAR_8 = *VAR_7;
if ( ((shadow_l1e_get_flags(VAR_8) & (VAR_14|VAR_15))
!= (VAR_14|VAR_15))
|| !mfn_eq(shadow_l1e_get_mfn(VAR_8), VAR_1) )
{
unmap_domain_page(VAR_7);
goto fail;
}
VAR_8 = shadow_l1e_remove_flags(VAR_8, VAR_15);
VAR_6 = shadow_set_l1e(VAR_0, VAR_7, VAR_8, VAR_16, VAR_2);
ASSERT( !(VAR_6 & VAR_17) );
unmap_domain_page(VAR_7);
perfc_incr(VAR_18);
return 1;
fail:
perfc_incr(VAR_19);
return 0;
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/before/1.json,"int sh_rm_write_access_from_sl1p(struct domain *d, mfn_t gmfn,
                                 mfn_t smfn, unsigned long off)
{
    struct vcpu *curr = current;
    int r;
    shadow_l1e_t *sl1p, sl1e;
    struct page_info *sp;

    ASSERT(mfn_valid(gmfn));
    ASSERT(mfn_valid(smfn));

    /* Remember if we've been told that this process is being torn down */
    if ( curr->domain == d && is_hvm_domain(d) )
        curr->arch.paging.shadow.pagetable_dying
            = mfn_to_page(gmfn)->pagetable_dying;

    sp = mfn_to_page(smfn);

    if ( ((sp->count_info & PGC_count_mask) != 0)
         || (sp->u.sh.type != SH_type_l1_shadow
             && sp->u.sh.type != SH_type_fl1_shadow) )
        goto fail;

    sl1p = map_domain_page(smfn);
    sl1p += off;
    sl1e = *sl1p;
    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))
          != (_PAGE_PRESENT|_PAGE_RW))
         || !mfn_eq(shadow_l1e_get_mfn(sl1e), gmfn) )
    {
        unmap_domain_page(sl1p);
        goto fail;
    }

    /* Found it!  Need to remove its write permissions. */
    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);
    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, smfn);
    ASSERT( !(r & SHADOW_SET_ERROR) );

    unmap_domain_page(sl1p);
    perfc_incr(shadow_writeable_h_7);
    return 1;

 fail:
    perfc_incr(shadow_writeable_h_8);
    return 0;
}","int sh_rm_write_access_from_sl1p(struct domain *VAR_0, mfn_t VAR_1,
                                 mfn_t VAR_2, unsigned long VAR_3)
{
    struct vcpu *VAR_4 = VAR_5;
    int VAR_6;
    shadow_l1e_t *VAR_7, VAR_8;
    struct page_info *VAR_9;

    ASSERT(mfn_valid(VAR_1));
    ASSERT(mfn_valid(VAR_2));

    /* COMMENT_0 */
    if ( VAR_4->domain == VAR_0 && is_hvm_domain(VAR_0) )
        VAR_4->arch.paging.shadow.pagetable_dying
            = mfn_to_page(VAR_1)->pagetable_dying;

    VAR_9 = mfn_to_page(VAR_2);

    if ( ((VAR_9->count_info & VAR_10) != 0)
         || (VAR_9->u.sh.type != VAR_11
             && VAR_9->u.sh.type != VAR_12) )
        goto fail;

    VAR_7 = map_domain_page(VAR_2);
    VAR_7 += VAR_3;
    VAR_8 = *VAR_7;
    if ( ((shadow_l1e_get_flags(VAR_8) & (VAR_13|VAR_14))
          != (VAR_13|VAR_14))
         || !mfn_eq(shadow_l1e_get_mfn(VAR_8), VAR_1) )
    {
        unmap_domain_page(VAR_7);
        goto fail;
    }

    /* COMMENT_1 */
    VAR_8 = shadow_l1e_remove_flags(VAR_8, VAR_14);
    VAR_6 = shadow_set_l1e(VAR_0, VAR_7, VAR_8, VAR_15, VAR_2);
    ASSERT( !(VAR_6 & VAR_16) );

    unmap_domain_page(VAR_7);
    perfc_incr(VAR_17);
    return 1;

 fail:
    perfc_incr(VAR_18);
    return 0;
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,9 +10,9 @@
     ASSERT(mfn_valid(smfn));
 
     /* Remember if we've been told that this process is being torn down */
-    if ( curr->domain == d )
+    if ( curr->domain == d && is_hvm_domain(d) )
         curr->arch.paging.shadow.pagetable_dying
-            = !!(mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying);
+            = mfn_to_page(gmfn)->pagetable_dying;
 
     sp = mfn_to_page(smfn);
 ","{'deleted_lines': ['    if ( curr->domain == d )', '            = !!(mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying);'], 'added_lines': ['    if ( curr->domain == d && is_hvm_domain(d) )', '            = mfn_to_page(gmfn)->pagetable_dying;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19966,['CWE-436'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/shadow: shrink struct page_info's shadow_flags to 16 bits

This is to avoid it overlapping the linear_pt_count field needed for PV
domains. Introduce a separate, HVM-only pagetable_dying field to replace
the sole one left in the upper 16 bits.

Note that the accesses to ->shadow_flags in shadow_{pro,de}mote() get
switched to non-atomic, non-bitops operations, as {test,set,clear}_bit()
are not allowed on uint16_t fields and hence their use would have
required ugly casts. This is fine because all updates of the field ought
to occur with the paging lock held, and other updates of it use |= and
&= as well (i.e. using atomic operations here didn't really guard
against potentially racing updates elsewhere).

This is part of XSA-280.

Reported-by: Prgmr.com Security <security@prgmr.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Tim Deegan <tim@xen.org>",789589968ed90e82a832dbc60e958c76b787be7e,https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e,xen/arch/x86/mm/shadow/multi.c,sh_page_fault,"static int sh_page_fault(struct vcpu *v,
unsigned long va,
struct cpu_user_regs *regs)
{
struct domain *d = v->domain;
walk_t gw;
gfn_t gfn = _gfn(0);
mfn_t gmfn, sl1mfn = _mfn(0);
shadow_l1e_t sl1e, *ptr_sl1e;
paddr_t gpa;
struct sh_emulate_ctxt emul_ctxt;
const struct x86_emulate_ops *emul_ops;
int r;
p2m_type_t p2mt;
uint32_t rc, error_code;
bool walk_ok;
int version;
unsigned int cpl;
const struct npfec access = {
.read_access = 1,
.write_access = !!(regs->error_code & PFEC_write_access),
.gla_valid = 1,
.kind = npfec_kind_with_gla
};
const fetch_type_t ft =
access.write_access ? ft_demand_write : ft_demand_read;
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
int fast_emul = 0;
#endif
SHADOW_PRINTK(""%pv va=%#lx err=%#x, rip=%lx\n"",
v, va, regs->error_code, regs->rip);
perfc_incr(shadow_fault);
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
if ( v->arch.paging.last_write_emul_ok
&& v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )
{
if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )
{
fast_emul = 1;
gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )
{
fast_emul = 0;
v->arch.paging.last_write_emul_ok = 0;
goto page_fault_slow_path;
}
#endif 
perfc_incr(shadow_fault_fast_emulate);
goto early_emulation;
}
else
v->arch.paging.last_write_emul_ok = 0;
}
#endif
#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)
if ( (regs->error_code & PFEC_reserved_bit) )
{
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
{
shadow_l2e_t sl2e;
mfn_t gl1mfn;
if ( (__copy_from_user(&sl2e,
(sh_linear_l2_table(v)
+ shadow_l2_linear_offset(va)),
sizeof(sl2e)) != 0)
|| !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)
|| !mfn_valid(gl1mfn = backpointer(mfn_to_page(
shadow_l2e_get_mfn(sl2e))))
|| unlikely(mfn_is_out_of_sync(gl1mfn)) )
{
ASSERT(regs->error_code & PFEC_page_present);
regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);
goto page_fault_slow_path;
}
}
#endif 
if ( likely((__copy_from_user(&sl1e,
(sh_linear_l1_table(v)
+ shadow_l1_linear_offset(va)),
sizeof(sl1e)) == 0)
&& sh_l1e_is_magic(sl1e)) )
{
if ( sh_l1e_is_gnp(sl1e) )
{
ASSERT(regs->error_code & PFEC_page_present);
regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);
sh_reset_early_unshadow(v);
perfc_incr(shadow_fault_fast_gnp);
SHADOW_PRINTK(""fast path not-present\n"");
trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);
return 0;
}
#ifdef CONFIG_HVM
ASSERT(sh_l1e_is_mmio(sl1e));
ASSERT(is_hvm_vcpu(v));
gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);
perfc_incr(shadow_fault_fast_mmio);
SHADOW_PRINTK(""fast path mmio %#""PRIpaddr""\n"", gpa);
sh_reset_early_unshadow(v);
trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);
return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)
? EXCRET_fault_fixed : 0;
#else
BUG();
#endif
}
else
{
perfc_incr(shadow_fault_fast_fail);
SHADOW_PRINTK(""fast path false alarm!\n"");
trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);
return EXCRET_fault_fixed;
}
}
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
page_fault_slow_path:
#endif
#endif 
if ( unlikely(paging_locked_by_me(d)) )
{
printk(XENLOG_G_ERR ""Recursive shadow fault: lock taken by %s\n"",
d->arch.paging.lock.locker_function);
return 0;
}
cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);
rewalk:
error_code = regs->error_code;
if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )
error_code |= PFEC_implicit;
version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);
smp_rmb();
walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
regs->error_code &= ~PFEC_page_present;
if ( gw.pfec & PFEC_page_present )
regs->error_code |= PFEC_page_present;
#endif
if ( !walk_ok )
{
perfc_incr(shadow_fault_bail_real_fault);
SHADOW_PRINTK(""not a shadow fault\n"");
sh_reset_early_unshadow(v);
regs->error_code = gw.pfec & PFEC_arch_mask;
goto propagate;
}
if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )
{
SHADOW_PRINTK(""guest is shutting down\n"");
goto propagate;
}
gfn = guest_walk_to_gfn(&gw);
gmfn = get_gfn(d, gfn, &p2mt);
if ( shadow_mode_refcounts(d) &&
((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||
(!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )
{
perfc_incr(shadow_fault_bail_bad_gfn);
SHADOW_PRINTK(""BAD gfn=%""SH_PRI_gfn"" gmfn=%""PRI_mfn""\n"",
gfn_x(gfn), mfn_x(gmfn));
sh_reset_early_unshadow(v);
put_gfn(d, gfn_x(gfn));
goto propagate;
}
#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)
vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),
regs->error_code | PFEC_page_present);
#endif 
paging_lock(d);
TRACE_CLEAR_PATH_FLAGS;
shadow_prealloc(d,
SH_type_l1_shadow,
GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);
rc = gw_remove_write_accesses(v, va, &gw);
if ( rc & GW_RMWR_FLUSHTLB )
{
perfc_incr(shadow_rm_write_flush_tlb);
smp_wmb();
atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);
flush_tlb_mask(d->dirty_cpumask);
}
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( rc & GW_RMWR_REWALK )
{
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
goto rewalk;
}
#endif 
if ( !shadow_check_gwalk(v, va, &gw, version) )
{
perfc_incr(shadow_inconsistent_gwalk);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
goto rewalk;
}
shadow_audit_tables(v);
sh_audit_gw(v, &gw);
ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);
if ( unlikely(ptr_sl1e == NULL) )
{
#if GUEST_PAGING_LEVELS == 3
v->arch.paging.mode->update_cr3(v, 0, false);
#else
ASSERT(d->is_shutting_down);
#endif
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);
return 0;
}
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( sh_mfn_is_a_page_table(gmfn)
&& ft == ft_demand_write )
sh_unsync(v, gmfn);
if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )
{
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
return 0;
}
if ( shadow_check_gl1e(v, &gw)  )
{
perfc_incr(shadow_inconsistent_gwalk);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
goto rewalk;
}
#endif 
l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);
r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
if ( mfn_valid(gw.l1mfn)
&& mfn_is_out_of_sync(gw.l1mfn) )
{
mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);
guest_l1e_t *snp;
ASSERT(mfn_valid(snpmfn));
snp = map_domain_page(snpmfn);
snp[guest_l1_table_offset(va)] = gw.l1e;
unmap_domain_page(snp);
}
#endif 
#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH
sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);
#endif
if ( sh_mfn_is_a_page_table(gmfn)
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
&& !(mfn_is_out_of_sync(gmfn)
&& !(regs->error_code & PFEC_user_mode))
#endif
&& (ft == ft_demand_write) )
{
perfc_incr(shadow_fault_emulate_write);
goto emulate;
}
if ( p2mt == p2m_mmio_dm )
{
gpa = guest_walk_to_gpa(&gw);
goto mmio;
}
if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )
{
static unsigned long lastpage;
if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )
gdprintk(XENLOG_DEBUG, ""guest attempted write to read-only memory""
"" page. va page=%#lx, mfn=%#lx\n"",
va & PAGE_MASK, mfn_x(gmfn));
goto emulate_readonly; 
}
if ( is_hvm_domain(d)
&& unlikely(!hvm_wp_enabled(v))
&& regs->error_code == (PFEC_write_access|PFEC_page_present)
&& mfn_valid(gmfn) )
{
perfc_incr(shadow_fault_emulate_wp);
goto emulate;
}
perfc_incr(shadow_fault_fixed);
d->arch.paging.log_dirty.fault_count++;
sh_reset_early_unshadow(v);
trace_shadow_fixup(gw.l1e, va);
done:
sh_audit_gw(v, &gw);
SHADOW_PRINTK(""fixed\n"");
shadow_audit_tables(v);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
return EXCRET_fault_fixed;
emulate:
if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )
goto not_a_shadow_fault;
if ( (regs->error_code & PFEC_user_mode) )
{
SHADOW_PRINTK(""user-mode fault to PT, unshadowing mfn %#lx\n"",
mfn_x(gmfn));
perfc_incr(shadow_fault_emulate_failed);
sh_remove_shadows(d, gmfn, 0 , 1 );
trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,
va, gfn);
goto done;
}
emulate_readonly:
if ( sh_mfn_is_a_page_table(gmfn)
&& (mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying) )
{
int used = 0;
struct vcpu *tmp;
for_each_vcpu(d, tmp)
{
#if GUEST_PAGING_LEVELS == 3
int i;
for ( i = 0; i < 4; i++ )
{
mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);
if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )
{
used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));
if ( used )
break;
}
}
#else 
used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);
#endif
if ( used )
break;
}
if ( !used )
sh_remove_shadows(d, gmfn, 1 , 0 );
}
sh_audit_gw(v, &gw);
shadow_audit_tables(v);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
this_cpu(trace_emulate_write_val) = 0;
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
early_emulation:
#endif
if ( is_hvm_domain(d) )
{
if ( unlikely(hvm_event_pending(v)) )
{
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
if ( fast_emul )
{
perfc_incr(shadow_fault_fast_emulate_fail);
v->arch.paging.last_write_emul_ok = 0;
}
#endif
gdprintk(XENLOG_DEBUG, ""write to pagetable during event ""
""injection: cr2=%#lx, mfn=%#lx\n"",
va, mfn_x(gmfn));
sh_remove_shadows(d, gmfn, 0 , 1 );
trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,
va, gfn);
return EXCRET_fault_fixed;
}
}
SHADOW_PRINTK(""emulate: eip=%#lx esp=%#lx\n"", regs->rip, regs->rsp);
emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);
r = x86_emulate(&emul_ctxt.ctxt, emul_ops);
#ifdef CONFIG_HVM
if ( r == X86EMUL_EXCEPTION )
{
ASSERT(is_hvm_domain(d));
if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&
((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||
(((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||
(emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&
emul_ctxt.ctxt.event.error_code == 0)) )
hvm_inject_event(&emul_ctxt.ctxt.event);
else
{
SHADOW_PRINTK(
""Unexpected event (type %u, vector %#x) from emulation\n"",
emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);
r = X86EMUL_UNHANDLEABLE;
}
}
#endif
if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )
{
perfc_incr(shadow_fault_emulate_failed);
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
if ( fast_emul )
{
perfc_incr(shadow_fault_fast_emulate_fail);
v->arch.paging.last_write_emul_ok = 0;
}
#endif
SHADOW_PRINTK(""emulator failure (rc=%d), unshadowing mfn %#lx\n"",
r, mfn_x(gmfn));
shadow_remove_all_shadows(d, gmfn);
trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,
va, gfn);
goto emulate_done;
}
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )
{
if ( !fast_emul )
{
v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;
v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);
v->arch.paging.last_write_emul_ok = 1;
}
}
else if ( fast_emul )
v->arch.paging.last_write_emul_ok = 0;
#endif
if ( emul_ctxt.ctxt.retire.singlestep )
hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);
#if GUEST_PAGING_LEVELS == 3 
if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )
{
int i, emulation_count=0;
this_cpu(trace_emulate_initial_va) = va;
for ( i = 0 ; i < 4 ; i++ )
{
shadow_continue_emulation(&emul_ctxt, regs);
v->arch.paging.last_write_was_pt = 0;
r = x86_emulate(&emul_ctxt.ctxt, emul_ops);
if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )
{
emulation_count++;
if ( v->arch.paging.last_write_was_pt )
{
perfc_incr(shadow_em_ex_pt);
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);
break; 
}
else
perfc_incr(shadow_em_ex_non_pt);
}
else
{
perfc_incr(shadow_em_ex_fail);
TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);
if ( emul_ctxt.ctxt.retire.singlestep )
hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);
break; 
}
}
this_cpu(trace_extra_emulation_count)=emulation_count;
}
#endif 
trace_shadow_emulate(gw.l1e, va);
emulate_done:
SHADOW_PRINTK(""emulated\n"");
return EXCRET_fault_fixed;
mmio:
if ( !guest_mode(regs) )
goto not_a_shadow_fault;
#ifdef CONFIG_HVM
ASSERT(is_hvm_vcpu(v));
perfc_incr(shadow_fault_mmio);
sh_audit_gw(v, &gw);
SHADOW_PRINTK(""mmio %#""PRIpaddr""\n"", gpa);
shadow_audit_tables(v);
sh_reset_early_unshadow(v);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
trace_shadow_gen(TRC_SHADOW_MMIO, va);
return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)
? EXCRET_fault_fixed : 0);
#else
BUG();
#endif
not_a_shadow_fault:
sh_audit_gw(v, &gw);
SHADOW_PRINTK(""not a shadow fault\n"");
shadow_audit_tables(v);
sh_reset_early_unshadow(v);
paging_unlock(d);
put_gfn(d, gfn_x(gfn));
propagate:
trace_not_shadow_fault(gw.l1e, va);
return 0;
}","static int sh_page_fault(struct vcpu *VAR_0,
unsigned long VAR_1,
struct cpu_user_regs *VAR_2)
{
struct domain *VAR_3 = VAR_0->domain;
walk_t VAR_4;
gfn_t VAR_5 = _gfn(0);
mfn_t VAR_6, VAR_7 = _mfn(0);
shadow_l1e_t VAR_8, *VAR_9;
paddr_t VAR_10;
struct sh_emulate_ctxt VAR_11;
const struct x86_emulate_ops *VAR_12;
int VAR_13;
p2m_type_t VAR_14;
uint32_t VAR_15, VAR_16;
bool VAR_17;
int VAR_18;
unsigned int VAR_19;
const struct npfec VAR_20 = {
.read_access = 1,
.write_access = !!(VAR_2->error_code & VAR_21),
.gla_valid = 1,
.kind = VAR_22
};
const fetch_type_t VAR_23 =
VAR_20.write_access ? VAR_24 : VAR_25;
#if VAR_26 & VAR_27
int VAR_28 = 0;
#endif
SHADOW_PRINTK(""%pv va=%#lx err=%#x, rip=%lx\n"",
VAR_0, VAR_1, VAR_2->error_code, VAR_2->rip);
perfc_incr(VAR_29);
#if VAR_26 & VAR_27
if ( VAR_0->arch.paging.last_write_emul_ok
&& VAR_0->arch.paging.shadow.last_emulated_frame == (VAR_1 >> VAR_30) )
{
if ( VAR_2->error_code == (VAR_21 | VAR_31) )
{
VAR_28 = 1;
VAR_6 = _mfn(VAR_0->arch.paging.shadow.last_emulated_mfn);
#if (VAR_26 & VAR_32)
if ( mfn_valid(VAR_6) && mfn_is_out_of_sync(VAR_6) )
{
VAR_28 = 0;
VAR_0->arch.paging.last_write_emul_ok = 0;
goto page_fault_slow_path;
}
#endif 
perfc_incr(VAR_33);
goto early_emulation;
}
else
VAR_0->arch.paging.last_write_emul_ok = 0;
}
#endif
#if (VAR_26 & VAR_34)
if ( (VAR_2->error_code & VAR_35) )
{
#if (VAR_26 & VAR_32)
{
shadow_l2e_t VAR_36;
mfn_t VAR_37;
if ( (__copy_from_user(&VAR_36,
(sh_linear_l2_table(VAR_0)
+ shadow_l2_linear_offset(VAR_1)),
sizeof(VAR_36)) != 0)
|| !(shadow_l2e_get_flags(VAR_36) & VAR_38)
|| !mfn_valid(VAR_37 = backpointer(mfn_to_page(
shadow_l2e_get_mfn(VAR_36))))
|| unlikely(mfn_is_out_of_sync(VAR_37)) )
{
ASSERT(VAR_2->error_code & VAR_31);
VAR_2->error_code ^= (VAR_35|VAR_31);
goto page_fault_slow_path;
}
}
#endif 
if ( likely((__copy_from_user(&VAR_8,
(sh_linear_l1_table(VAR_0)
+ shadow_l1_linear_offset(VAR_1)),
sizeof(VAR_8)) == 0)
&& sh_l1e_is_magic(VAR_8)) )
{
if ( sh_l1e_is_gnp(VAR_8) )
{
ASSERT(VAR_2->error_code & VAR_31);
VAR_2->error_code ^= (VAR_35|VAR_31);
sh_reset_early_unshadow(VAR_0);
perfc_incr(VAR_39);
SHADOW_PRINTK(""fast path not-present\n"");
trace_shadow_gen(VAR_40, VAR_1);
return 0;
}
#ifdef VAR_41
ASSERT(sh_l1e_is_mmio(VAR_8));
ASSERT(is_hvm_vcpu(VAR_0));
VAR_10 = gfn_to_gaddr(sh_l1e_mmio_get_gfn(VAR_8)) | (VAR_1 & ~VAR_42);
perfc_incr(VAR_43);
SHADOW_PRINTK(""fast path mmio %#""VAR_44""\n"", VAR_10);
sh_reset_early_unshadow(VAR_0);
trace_shadow_gen(VAR_45, VAR_1);
return handle_mmio_with_translation(VAR_1, VAR_10 >> VAR_30, VAR_20)
? VAR_46 : 0;
#else
BUG();
#endif
}
else
{
perfc_incr(VAR_47);
SHADOW_PRINTK(""fast path false alarm!\n"");
trace_shadow_gen(VAR_48, VAR_1);
return VAR_46;
}
}
#if (VAR_26 & VAR_32)
page_fault_slow_path:
#endif
#endif 
if ( unlikely(paging_locked_by_me(VAR_3)) )
{
printk(XENLOG_G_ERR ""Recursive shadow fault: lock taken by %s\n"",
VAR_3->arch.paging.lock.locker_function);
return 0;
}
VAR_19 = is_pv_vcpu(VAR_0) ? (VAR_2->ss & 3) : hvm_get_cpl(VAR_0);
rewalk:
VAR_16 = VAR_2->error_code;
if ( !(VAR_16 & (VAR_49|VAR_50)) && VAR_19 == 3 )
VAR_16 |= VAR_51;
VAR_18 = atomic_read(&VAR_3->arch.paging.shadow.gtable_dirty_version);
smp_rmb();
VAR_17 = sh_walk_guest_tables(VAR_0, VAR_1, &VAR_4, VAR_16);
#if (VAR_26 & VAR_32)
VAR_2->error_code &= ~VAR_31;
if ( VAR_4.pfec & VAR_31 )
VAR_2->error_code |= VAR_31;
#endif
if ( !VAR_17 )
{
perfc_incr(VAR_52);
SHADOW_PRINTK(""not a shadow fault\n"");
sh_reset_early_unshadow(VAR_0);
VAR_2->error_code = VAR_4.pfec & VAR_53;
goto propagate;
}
if ( unlikely(VAR_3->is_shutting_down && VAR_3->shutdown_code == VAR_54) )
{
SHADOW_PRINTK(""guest is shutting down\n"");
goto propagate;
}
VAR_5 = guest_walk_to_gfn(&VAR_4);
VAR_6 = get_gfn(VAR_3, VAR_5, &VAR_14);
if ( shadow_mode_refcounts(VAR_3) &&
((!p2m_is_valid(VAR_14) && !p2m_is_grant(VAR_14)) ||
(!p2m_is_mmio(VAR_14) && !mfn_valid(VAR_6))) )
{
perfc_incr(VAR_55);
SHADOW_PRINTK(""BAD gfn=%""VAR_56"" gmfn=%""VAR_57""\n"",
gfn_x(VAR_5), mfn_x(VAR_6));
sh_reset_early_unshadow(VAR_0);
put_gfn(VAR_3, gfn_x(VAR_5));
goto propagate;
}
#if (VAR_26 & VAR_58)
vtlb_insert(VAR_0, VAR_1 >> VAR_30, gfn_x(VAR_5),
VAR_2->error_code | VAR_31);
#endif 
paging_lock(VAR_3);
VAR_59;
shadow_prealloc(VAR_3,
VAR_60,
VAR_61 < 4 ? 1 : VAR_61 - 1);
VAR_15 = gw_remove_write_accesses(VAR_0, VAR_1, &VAR_4);
if ( VAR_15 & VAR_62 )
{
perfc_incr(VAR_63);
smp_wmb();
atomic_inc(&VAR_3->arch.paging.shadow.gtable_dirty_version);
flush_tlb_mask(VAR_3->dirty_cpumask);
}
#if (VAR_26 & VAR_32)
if ( VAR_15 & VAR_64 )
{
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
goto rewalk;
}
#endif 
if ( !shadow_check_gwalk(VAR_0, VAR_1, &VAR_4, VAR_18) )
{
perfc_incr(VAR_65);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
goto rewalk;
}
shadow_audit_tables(VAR_0);
sh_audit_gw(VAR_0, &VAR_4);
VAR_9 = shadow_get_and_create_l1e(VAR_0, &VAR_4, &VAR_7, VAR_23);
if ( unlikely(VAR_9 == NULL) )
{
#if VAR_61 == 3
VAR_0->arch.paging.mode->update_cr3(VAR_0, 0, false);
#else
ASSERT(VAR_3->is_shutting_down);
#endif
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
trace_shadow_gen(VAR_66, VAR_1);
return 0;
}
#if (VAR_26 & VAR_32)
if ( sh_mfn_is_a_page_table(VAR_6)
&& VAR_23 == VAR_24 )
sh_unsync(VAR_0, VAR_6);
if ( unlikely(VAR_3->is_shutting_down && VAR_3->shutdown_code == VAR_54) )
{
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
return 0;
}
if ( shadow_check_gl1e(VAR_0, &VAR_4)  )
{
perfc_incr(VAR_65);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
goto rewalk;
}
#endif 
l1e_propagate_from_guest(VAR_0, VAR_4.l1e, VAR_6, &VAR_8, VAR_23, VAR_14);
VAR_13 = shadow_set_l1e(VAR_3, VAR_9, VAR_8, VAR_14, VAR_7);
#if (VAR_26 & VAR_32)
if ( mfn_valid(VAR_4.l1mfn)
&& mfn_is_out_of_sync(VAR_4.l1mfn) )
{
mfn_t VAR_67 = oos_snapshot_lookup(VAR_3, VAR_4.l1mfn);
guest_l1e_t *VAR_68;
ASSERT(mfn_valid(VAR_67));
VAR_68 = map_domain_page(VAR_67);
VAR_68[guest_l1_table_offset(VAR_1)] = VAR_4.l1e;
unmap_domain_page(VAR_68);
}
#endif 
#if VAR_26 & VAR_69
sh_prefetch(VAR_0, &VAR_4, VAR_9, VAR_7);
#endif
if ( sh_mfn_is_a_page_table(VAR_6)
#if (VAR_26 & VAR_32)
&& !(mfn_is_out_of_sync(VAR_6)
&& !(VAR_2->error_code & VAR_50))
#endif
&& (VAR_23 == VAR_24) )
{
perfc_incr(VAR_70);
goto emulate;
}
if ( VAR_14 == VAR_71 )
{
VAR_10 = guest_walk_to_gpa(&VAR_4);
goto mmio;
}
if ( p2m_is_readonly(VAR_14) && (VAR_23 == VAR_24) )
{
static unsigned long VAR_72;
if ( xchg(&VAR_72, VAR_1 & VAR_42) != (VAR_1 & VAR_42) )
gdprintk(VAR_73, ""guest attempted write to read-only memory""
"" page. va page=%#lx, mfn=%#lx\n"",
VAR_1 & VAR_42, mfn_x(VAR_6));
goto emulate_readonly; 
}
if ( is_hvm_domain(VAR_3)
&& unlikely(!hvm_wp_enabled(VAR_0))
&& VAR_2->error_code == (VAR_21|VAR_31)
&& mfn_valid(VAR_6) )
{
perfc_incr(VAR_74);
goto emulate;
}
perfc_incr(VAR_75);
VAR_3->arch.paging.log_dirty.fault_count++;
sh_reset_early_unshadow(VAR_0);
trace_shadow_fixup(VAR_4.l1e, VAR_1);
done:
sh_audit_gw(VAR_0, &VAR_4);
SHADOW_PRINTK(""fixed\n"");
shadow_audit_tables(VAR_0);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
return VAR_46;
emulate:
if ( !shadow_mode_refcounts(VAR_3) || !guest_mode(VAR_2) )
goto not_a_shadow_fault;
if ( (VAR_2->error_code & VAR_50) )
{
SHADOW_PRINTK(""user-mode fault to PT, unshadowing mfn %#lx\n"",
mfn_x(VAR_6));
perfc_incr(VAR_76);
sh_remove_shadows(VAR_3, VAR_6, 0 , 1 );
trace_shadow_emulate_other(VAR_77,
VAR_1, VAR_5);
goto done;
}
emulate_readonly:
if ( sh_mfn_is_a_page_table(VAR_6)
&& (mfn_to_page(VAR_6)->shadow_flags & VAR_78) )
{
int VAR_79 = 0;
struct vcpu *VAR_80;
for_each_vcpu(VAR_3, VAR_80)
{
#if VAR_61 == 3
int VAR_81;
for ( VAR_81 = 0; VAR_81 < 4; VAR_81++ )
{
mfn_t VAR_82 = pagetable_get_mfn(VAR_0->arch.shadow_table[VAR_81]);
if ( mfn_valid(VAR_82) && (mfn_x(VAR_82) != 0) )
{
VAR_79 |= (mfn_to_page(VAR_82)->v.sh.back == mfn_x(VAR_6));
if ( VAR_79 )
break;
}
}
#else 
VAR_79 = mfn_eq(pagetable_get_mfn(VAR_80->arch.guest_table), VAR_6);
#endif
if ( VAR_79 )
break;
}
if ( !VAR_79 )
sh_remove_shadows(VAR_3, VAR_6, 1 , 0 );
}
sh_audit_gw(VAR_0, &VAR_4);
shadow_audit_tables(VAR_0);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
this_cpu(VAR_83) = 0;
#if VAR_26 & VAR_27
early_emulation:
#endif
if ( is_hvm_domain(VAR_3) )
{
if ( unlikely(hvm_event_pending(VAR_0)) )
{
#if VAR_26 & VAR_27
if ( VAR_28 )
{
perfc_incr(VAR_84);
VAR_0->arch.paging.last_write_emul_ok = 0;
}
#endif
gdprintk(VAR_73, ""write to pagetable during event ""
""injection: cr2=%#lx, mfn=%#lx\n"",
VAR_1, mfn_x(VAR_6));
sh_remove_shadows(VAR_3, VAR_6, 0 , 1 );
trace_shadow_emulate_other(VAR_85,
VAR_1, VAR_5);
return VAR_46;
}
}
SHADOW_PRINTK(""emulate: eip=%#lx esp=%#lx\n"", VAR_2->rip, VAR_2->rsp);
VAR_12 = shadow_init_emulation(&VAR_11, VAR_2, VAR_86);
VAR_13 = x86_emulate(&VAR_11.ctxt, VAR_12);
#ifdef VAR_41
if ( VAR_13 == VAR_87 )
{
ASSERT(is_hvm_domain(VAR_3));
if ( VAR_11.ctxt.event.type == VAR_88 &&
((VAR_11.ctxt.event.vector == VAR_89) ||
(((VAR_11.ctxt.event.vector == VAR_90) ||
(VAR_11.ctxt.event.vector == VAR_91)) &&
VAR_11.ctxt.event.error_code == 0)) )
hvm_inject_event(&VAR_11.ctxt.event);
else
{
SHADOW_PRINTK(
""Unexpected event (type %u, vector %#x) from emulation\n"",
VAR_11.ctxt.event.type, VAR_11.ctxt.event.vector);
VAR_13 = VAR_92;
}
}
#endif
if ( VAR_13 == VAR_92 || VAR_13 == VAR_93 )
{
perfc_incr(VAR_76);
#if VAR_26 & VAR_27
if ( VAR_28 )
{
perfc_incr(VAR_84);
VAR_0->arch.paging.last_write_emul_ok = 0;
}
#endif
SHADOW_PRINTK(""emulator failure (rc=%d), unshadowing mfn %#lx\n"",
VAR_13, mfn_x(VAR_6));
shadow_remove_all_shadows(VAR_3, VAR_6);
trace_shadow_emulate_other(VAR_94,
VAR_1, VAR_5);
goto emulate_done;
}
#if VAR_26 & VAR_27
if ( (VAR_13 == VAR_95) && sh_mfn_is_a_page_table(VAR_6) )
{
if ( !VAR_28 )
{
VAR_0->arch.paging.shadow.last_emulated_frame = VAR_1 >> VAR_30;
VAR_0->arch.paging.shadow.last_emulated_mfn = mfn_x(VAR_6);
VAR_0->arch.paging.last_write_emul_ok = 1;
}
}
else if ( VAR_28 )
VAR_0->arch.paging.last_write_emul_ok = 0;
#endif
if ( VAR_11.ctxt.retire.singlestep )
hvm_inject_hw_exception(VAR_96, VAR_97);
#if VAR_61 == 3 
if ( VAR_13 == VAR_95 && !VAR_11.ctxt.retire.raw )
{
int VAR_81, VAR_98=0;
this_cpu(VAR_99) = VAR_1;
for ( VAR_81 = 0 ; VAR_81 < 4 ; VAR_81++ )
{
shadow_continue_emulation(&VAR_11, VAR_2);
VAR_0->arch.paging.last_write_was_pt = 0;
VAR_13 = x86_emulate(&VAR_11.ctxt, VAR_12);
if ( VAR_13 == VAR_95 && !VAR_11.ctxt.retire.raw )
{
VAR_98++;
if ( VAR_0->arch.paging.last_write_was_pt )
{
perfc_incr(VAR_100);
TRACE_SHADOW_PATH_FLAG(VAR_101);
break; 
}
else
perfc_incr(VAR_102);
}
else
{
perfc_incr(VAR_103);
TRACE_SHADOW_PATH_FLAG(VAR_104);
if ( VAR_11.ctxt.retire.singlestep )
hvm_inject_hw_exception(VAR_96, VAR_97);
break; 
}
}
this_cpu(VAR_105)=VAR_98;
}
#endif 
trace_shadow_emulate(VAR_4.l1e, VAR_1);
emulate_done:
SHADOW_PRINTK(""emulated\n"");
return VAR_46;
mmio:
if ( !guest_mode(VAR_2) )
goto not_a_shadow_fault;
#ifdef VAR_41
ASSERT(is_hvm_vcpu(VAR_0));
perfc_incr(VAR_106);
sh_audit_gw(VAR_0, &VAR_4);
SHADOW_PRINTK(""mmio %#""VAR_44""\n"", VAR_10);
shadow_audit_tables(VAR_0);
sh_reset_early_unshadow(VAR_0);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
trace_shadow_gen(VAR_107, VAR_1);
return (handle_mmio_with_translation(VAR_1, VAR_10 >> VAR_30, VAR_20)
? VAR_46 : 0);
#else
BUG();
#endif
not_a_shadow_fault:
sh_audit_gw(VAR_0, &VAR_4);
SHADOW_PRINTK(""not a shadow fault\n"");
shadow_audit_tables(VAR_0);
sh_reset_early_unshadow(VAR_0);
paging_unlock(VAR_3);
put_gfn(VAR_3, gfn_x(VAR_5));
propagate:
trace_not_shadow_fault(VAR_4.l1e, VAR_1);
return 0;
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/before/2.json,"static int sh_page_fault(struct vcpu *v,
                          unsigned long va,
                          struct cpu_user_regs *regs)
{
    struct domain *d = v->domain;
    walk_t gw;
    gfn_t gfn = _gfn(0);
    mfn_t gmfn, sl1mfn = _mfn(0);
    shadow_l1e_t sl1e, *ptr_sl1e;
    paddr_t gpa;
    struct sh_emulate_ctxt emul_ctxt;
    const struct x86_emulate_ops *emul_ops;
    int r;
    p2m_type_t p2mt;
    uint32_t rc, error_code;
    bool walk_ok;
    int version;
    unsigned int cpl;
    const struct npfec access = {
         .read_access = 1,
         .write_access = !!(regs->error_code & PFEC_write_access),
         .gla_valid = 1,
         .kind = npfec_kind_with_gla
    };
    const fetch_type_t ft =
        access.write_access ? ft_demand_write : ft_demand_read;
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
    int fast_emul = 0;
#endif

    SHADOW_PRINTK(""%pv va=%#lx err=%#x, rip=%lx\n"",
                  v, va, regs->error_code, regs->rip);

    perfc_incr(shadow_fault);

#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
    /* If faulting frame is successfully emulated in last shadow fault
     * it's highly likely to reach same emulation action for this frame.
     * Then try to emulate early to avoid lock aquisition.
     */
    if ( v->arch.paging.last_write_emul_ok
         && v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )
    {
        /* check whether error code is 3, or else fall back to normal path
         * in case of some validation is required
         */
        if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )
        {
            fast_emul = 1;
            gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
            /* Fall back to the slow path if we're trying to emulate
               writes to an out of sync page. */
            if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )
            {
                fast_emul = 0;
                v->arch.paging.last_write_emul_ok = 0;
                goto page_fault_slow_path;
            }
#endif /* OOS */

            perfc_incr(shadow_fault_fast_emulate);
            goto early_emulation;
        }
        else
            v->arch.paging.last_write_emul_ok = 0;
    }
#endif

    //
    // XXX: Need to think about eventually mapping superpages directly in the
    //      shadow (when possible), as opposed to splintering them into a
    //      bunch of 4K maps.
    //

#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)
    if ( (regs->error_code & PFEC_reserved_bit) )
    {
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
        /* First, need to check that this isn't an out-of-sync
         * shadow l1e.  If it is, we fall back to the slow path, which
         * will sync it up again. */
        {
            shadow_l2e_t sl2e;
            mfn_t gl1mfn;
            if ( (__copy_from_user(&sl2e,
                                   (sh_linear_l2_table(v)
                                    + shadow_l2_linear_offset(va)),
                                   sizeof(sl2e)) != 0)
                 || !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)
                 || !mfn_valid(gl1mfn = backpointer(mfn_to_page(
                                  shadow_l2e_get_mfn(sl2e))))
                 || unlikely(mfn_is_out_of_sync(gl1mfn)) )
            {
                /* Hit the slow path as if there had been no
                 * shadow entry at all, and let it tidy up */
                ASSERT(regs->error_code & PFEC_page_present);
                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);
                goto page_fault_slow_path;
            }
        }
#endif /* SHOPT_OUT_OF_SYNC */
        /* The only reasons for reserved bits to be set in shadow entries
         * are the two ""magic"" shadow_l1e entries. */
        if ( likely((__copy_from_user(&sl1e,
                                      (sh_linear_l1_table(v)
                                       + shadow_l1_linear_offset(va)),
                                      sizeof(sl1e)) == 0)
                    && sh_l1e_is_magic(sl1e)) )
        {

            if ( sh_l1e_is_gnp(sl1e) )
            {
                /* Not-present in a guest PT: pass to the guest as
                 * a not-present fault (by flipping two bits). */
                ASSERT(regs->error_code & PFEC_page_present);
                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);
                sh_reset_early_unshadow(v);
                perfc_incr(shadow_fault_fast_gnp);
                SHADOW_PRINTK(""fast path not-present\n"");
                trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);
                return 0;
            }
#ifdef CONFIG_HVM
            /* Magic MMIO marker: extract gfn for MMIO address */
            ASSERT(sh_l1e_is_mmio(sl1e));
            ASSERT(is_hvm_vcpu(v));
            gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);
            perfc_incr(shadow_fault_fast_mmio);
            SHADOW_PRINTK(""fast path mmio %#""PRIpaddr""\n"", gpa);
            sh_reset_early_unshadow(v);
            trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);
            return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)
                   ? EXCRET_fault_fixed : 0;
#else
            /* When HVM is not enabled, there shouldn't be MMIO marker */
            BUG();
#endif
        }
        else
        {
            /* This should be exceptionally rare: another vcpu has fixed
             * the tables between the fault and our reading the l1e.
             * Retry and let the hardware give us the right fault next time. */
            perfc_incr(shadow_fault_fast_fail);
            SHADOW_PRINTK(""fast path false alarm!\n"");
            trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);
            return EXCRET_fault_fixed;
        }
    }

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
 page_fault_slow_path:
#endif
#endif /* SHOPT_FAST_FAULT_PATH */

    /* Detect if this page fault happened while we were already in Xen
     * doing a shadow operation.  If that happens, the only thing we can
     * do is let Xen's normal fault handlers try to fix it.  In any case,
     * a diagnostic trace of the fault will be more useful than
     * a BUG() when we try to take the lock again. */
    if ( unlikely(paging_locked_by_me(d)) )
    {
        printk(XENLOG_G_ERR ""Recursive shadow fault: lock taken by %s\n"",
               d->arch.paging.lock.locker_function);
        return 0;
    }

    cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);

 rewalk:

    error_code = regs->error_code;

    /*
     * When CR4.SMAP is enabled, instructions which have a side effect of
     * accessing the system data structures (e.g. mov to %ds accessing the
     * LDT/GDT, or int $n accessing the IDT) are known as implicit supervisor
     * accesses.
     *
     * The distinction between implicit and explicit accesses form part of the
     * determination of access rights, controlling whether the access is
     * successful, or raises a #PF.
     *
     * Unfortunately, the processor throws away the implicit/explicit
     * distinction and does not provide it to the pagefault handler
     * (i.e. here.) in the #PF error code.  Therefore, we must try to
     * reconstruct the lost state so it can be fed back into our pagewalk
     * through the guest tables.
     *
     * User mode accesses are easy to reconstruct:
     *
     *   If we observe a cpl3 data fetch which was a supervisor walk, this
     *   must have been an implicit access to a system table.
     *
     * Supervisor mode accesses are not easy:
     *
     *   In principle, we could decode the instruction under %rip and have the
     *   instruction emulator tell us if there is an implicit access.
     *   However, this is racy with other vcpus updating the pagetable or
     *   rewriting the instruction stream under our feet.
     *
     *   Therefore, we do nothing.  (If anyone has a sensible suggestion for
     *   how to distinguish these cases, xen-devel@ is all ears...)
     *
     * As a result, one specific corner case will fail.  If a guest OS with
     * SMAP enabled ends up mapping a system table with user mappings, sets
     * EFLAGS.AC to allow explicit accesses to user mappings, and implicitly
     * accesses the user mapping, hardware and the shadow code will disagree
     * on whether a #PF should be raised.
     *
     * Hardware raises #PF because implicit supervisor accesses to user
     * mappings are strictly disallowed.  As we can't reconstruct the correct
     * input, the pagewalk is performed as if it were an explicit access,
     * which concludes that the access should have succeeded and the shadow
     * pagetables need modifying.  The shadow pagetables are modified (to the
     * same value), and we re-enter the guest to re-execute the instruction,
     * which causes another #PF, and the vcpu livelocks, unable to make
     * forward progress.
     *
     * In practice, this is tolerable.  No production OS will deliberately
     * construct this corner case (as doing so would mean that a system table
     * is directly accessable to userspace, and the OS is trivially rootable.)
     * If this corner case comes about accidentally, then a security-relevant
     * bug has been tickled.
     */
    if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )
        error_code |= PFEC_implicit;

    /* The walk is done in a lock-free style, with some sanity check
     * postponed after grabbing paging lock later. Those delayed checks
     * will make sure no inconsistent mapping being translated into
     * shadow page table. */
    version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);
    smp_rmb();
    walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
    regs->error_code &= ~PFEC_page_present;
    if ( gw.pfec & PFEC_page_present )
        regs->error_code |= PFEC_page_present;
#endif

    if ( !walk_ok )
    {
        perfc_incr(shadow_fault_bail_real_fault);
        SHADOW_PRINTK(""not a shadow fault\n"");
        sh_reset_early_unshadow(v);
        regs->error_code = gw.pfec & PFEC_arch_mask;
        goto propagate;
    }

    /* It's possible that the guest has put pagetables in memory that it has
     * already used for some special purpose (ioreq pages, or granted pages).
     * If that happens we'll have killed the guest already but it's still not
     * safe to propagate entries out of the guest PT so get out now. */
    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )
    {
        SHADOW_PRINTK(""guest is shutting down\n"");
        goto propagate;
    }

    /* What mfn is the guest trying to access? */
    gfn = guest_walk_to_gfn(&gw);
    gmfn = get_gfn(d, gfn, &p2mt);

    if ( shadow_mode_refcounts(d) &&
         ((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||
          (!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )
    {
        perfc_incr(shadow_fault_bail_bad_gfn);
        SHADOW_PRINTK(""BAD gfn=%""SH_PRI_gfn"" gmfn=%""PRI_mfn""\n"",
                      gfn_x(gfn), mfn_x(gmfn));
        sh_reset_early_unshadow(v);
        put_gfn(d, gfn_x(gfn));
        goto propagate;
    }

#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)
    /* Remember this successful VA->GFN translation for later. */
    vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),
                regs->error_code | PFEC_page_present);
#endif /* (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) */

    paging_lock(d);

    TRACE_CLEAR_PATH_FLAGS;

    /* Make sure there is enough free shadow memory to build a chain of
     * shadow tables. (We never allocate a top-level shadow on this path,
     * only a 32b l1, pae l1, or 64b l3+2+1. Note that while
     * SH_type_l1_shadow isn't correct in the latter case, all page
     * tables are the same size there.)
     *
     * Preallocate shadow pages *before* removing writable accesses
     * otherwhise an OOS L1 might be demoted and promoted again with
     * writable mappings. */
    shadow_prealloc(d,
                    SH_type_l1_shadow,
                    GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);

    rc = gw_remove_write_accesses(v, va, &gw);

    /* First bit set: Removed write access to a page. */
    if ( rc & GW_RMWR_FLUSHTLB )
    {
        /* Write permission removal is also a hint that other gwalks
         * overlapping with this one may be inconsistent
         */
        perfc_incr(shadow_rm_write_flush_tlb);
        smp_wmb();
        atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);
        flush_tlb_mask(d->dirty_cpumask);
    }

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
    /* Second bit set: Resynced a page. Re-walk needed. */
    if ( rc & GW_RMWR_REWALK )
    {
        paging_unlock(d);
        put_gfn(d, gfn_x(gfn));
        goto rewalk;
    }
#endif /* OOS */

    if ( !shadow_check_gwalk(v, va, &gw, version) )
    {
        perfc_incr(shadow_inconsistent_gwalk);
        paging_unlock(d);
        put_gfn(d, gfn_x(gfn));
        goto rewalk;
    }

    shadow_audit_tables(v);
    sh_audit_gw(v, &gw);

    /* Acquire the shadow.  This must happen before we figure out the rights
     * for the shadow entry, since we might promote a page here. */
    ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);
    if ( unlikely(ptr_sl1e == NULL) )
    {
        /* Couldn't get the sl1e!  Since we know the guest entries
         * are OK, this can only have been caused by a failed
         * shadow_set_l*e(), which will have crashed the guest.
         * Get out of the fault handler immediately. */
        /* Windows 7 apparently relies on the hardware to do something
         * it explicitly hasn't promised to do: load l3 values after
         * the cr3 is loaded.
         * In any case, in the PAE case, the ASSERT is not true; it can
         * happen because of actions the guest is taking. */
#if GUEST_PAGING_LEVELS == 3
        v->arch.paging.mode->update_cr3(v, 0, false);
#else
        ASSERT(d->is_shutting_down);
#endif
        paging_unlock(d);
        put_gfn(d, gfn_x(gfn));
        trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);
        return 0;
    }

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
    /* Always unsync when writing to L1 page tables. */
    if ( sh_mfn_is_a_page_table(gmfn)
         && ft == ft_demand_write )
        sh_unsync(v, gmfn);

    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )
    {
        /* We might end up with a crashed domain here if
         * sh_remove_shadows() in a previous sh_resync() call has
         * failed. We cannot safely continue since some page is still
         * OOS but not in the hash table anymore. */
        paging_unlock(d);
        put_gfn(d, gfn_x(gfn));
        return 0;
    }

    /* Final check: if someone has synced a page, it's possible that
     * our l1e is stale.  Compare the entries, and rewalk if necessary. */
    if ( shadow_check_gl1e(v, &gw)  )
    {
        perfc_incr(shadow_inconsistent_gwalk);
        paging_unlock(d);
        put_gfn(d, gfn_x(gfn));
        goto rewalk;
    }
#endif /* OOS */

    /* Calculate the shadow entry and write it */
    l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);
    r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);

#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
    if ( mfn_valid(gw.l1mfn)
         && mfn_is_out_of_sync(gw.l1mfn) )
    {
        /* Update the OOS snapshot. */
        mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);
        guest_l1e_t *snp;

        ASSERT(mfn_valid(snpmfn));

        snp = map_domain_page(snpmfn);
        snp[guest_l1_table_offset(va)] = gw.l1e;
        unmap_domain_page(snp);
    }
#endif /* OOS */

#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH
    /* Prefetch some more shadow entries */
    sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);
#endif

    /* Need to emulate accesses to page tables */
    if ( sh_mfn_is_a_page_table(gmfn)
#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)
         /* Unless they've been allowed to go out of sync with their
            shadows and we don't need to unshadow it. */
         && !(mfn_is_out_of_sync(gmfn)
              && !(regs->error_code & PFEC_user_mode))
#endif
         && (ft == ft_demand_write) )
    {
        perfc_incr(shadow_fault_emulate_write);
        goto emulate;
    }

    /* Need to hand off device-model MMIO to the device model */
    if ( p2mt == p2m_mmio_dm )
    {
        gpa = guest_walk_to_gpa(&gw);
        goto mmio;
    }

    /* Ignore attempts to write to read-only memory. */
    if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )
    {
        static unsigned long lastpage;
        if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )
            gdprintk(XENLOG_DEBUG, ""guest attempted write to read-only memory""
                     "" page. va page=%#lx, mfn=%#lx\n"",
                     va & PAGE_MASK, mfn_x(gmfn));
        goto emulate_readonly; /* skip over the instruction */
    }

    /* In HVM guests, we force CR0.WP always to be set, so that the
     * pagetables are always write-protected.  If the guest thinks
     * CR0.WP is clear, we must emulate faulting supervisor writes to
     * allow the guest to write through read-only PTEs.  Emulate if the
     * fault was a non-user write to a present page.  */
    if ( is_hvm_domain(d)
         && unlikely(!hvm_wp_enabled(v))
         && regs->error_code == (PFEC_write_access|PFEC_page_present)
         && mfn_valid(gmfn) )
    {
        perfc_incr(shadow_fault_emulate_wp);
        goto emulate;
    }

    perfc_incr(shadow_fault_fixed);
    d->arch.paging.log_dirty.fault_count++;
    sh_reset_early_unshadow(v);

    trace_shadow_fixup(gw.l1e, va);
 done:
    sh_audit_gw(v, &gw);
    SHADOW_PRINTK(""fixed\n"");
    shadow_audit_tables(v);
    paging_unlock(d);
    put_gfn(d, gfn_x(gfn));
    return EXCRET_fault_fixed;

 emulate:
    if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )
        goto not_a_shadow_fault;

    /*
     * We do not emulate user writes. Instead we use them as a hint that the
     * page is no longer a page table. This behaviour differs from native, but
     * it seems very unlikely that any OS grants user access to page tables.
     */
    if ( (regs->error_code & PFEC_user_mode) )
    {
        SHADOW_PRINTK(""user-mode fault to PT, unshadowing mfn %#lx\n"",
                      mfn_x(gmfn));
        perfc_incr(shadow_fault_emulate_failed);
        sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);
        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,
                                      va, gfn);
        goto done;
    }

    /*
     * Write from userspace to ro-mem needs to jump here to avoid getting
     * caught by user-mode page-table check above.
     */
 emulate_readonly:

    /* Unshadow if we are writing to a toplevel pagetable that is
     * flagged as a dying process, and that is not currently used. */
    if ( sh_mfn_is_a_page_table(gmfn) && is_hvm_domain(d) &&
         mfn_to_page(gmfn)->pagetable_dying )
    {
        int used = 0;
        struct vcpu *tmp;
        for_each_vcpu(d, tmp)
        {
#if GUEST_PAGING_LEVELS == 3
            int i;
            for ( i = 0; i < 4; i++ )
            {
                mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);

                if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )
                {
                    used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));

                    if ( used )
                        break;
                }
            }
#else /* 32 or 64 */
            used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);
#endif
            if ( used )
                break;
        }

        if ( !used )
            sh_remove_shadows(d, gmfn, 1 /* fast */, 0 /* can fail */);
    }

    /*
     * We don't need to hold the lock for the whole emulation; we will
     * take it again when we write to the pagetables.
     */
    sh_audit_gw(v, &gw);
    shadow_audit_tables(v);
    paging_unlock(d);
    put_gfn(d, gfn_x(gfn));

    this_cpu(trace_emulate_write_val) = 0;

#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
 early_emulation:
#endif
    if ( is_hvm_domain(d) )
    {
        /*
         * If we are in the middle of injecting an exception or interrupt then
         * we should not emulate: it is not the instruction at %eip that caused
         * the fault. Furthermore it is almost certainly the case the handler
         * stack is currently considered to be a page table, so we should
         * unshadow the faulting page before exiting.
         */
        if ( unlikely(hvm_event_pending(v)) )
        {
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
            if ( fast_emul )
            {
                perfc_incr(shadow_fault_fast_emulate_fail);
                v->arch.paging.last_write_emul_ok = 0;
            }
#endif
            gdprintk(XENLOG_DEBUG, ""write to pagetable during event ""
                     ""injection: cr2=%#lx, mfn=%#lx\n"",
                     va, mfn_x(gmfn));
            sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);
            trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,
                                       va, gfn);
            return EXCRET_fault_fixed;
        }
    }

    SHADOW_PRINTK(""emulate: eip=%#lx esp=%#lx\n"", regs->rip, regs->rsp);

    emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);

    r = x86_emulate(&emul_ctxt.ctxt, emul_ops);

#ifdef CONFIG_HVM
    if ( r == X86EMUL_EXCEPTION )
    {
        ASSERT(is_hvm_domain(d));
        /*
         * This emulation covers writes to shadow pagetables.  We tolerate #PF
         * (from accesses spanning pages, concurrent paging updated from
         * vcpus, etc) and #GP[0]/#SS[0] (from segmentation errors).  Anything
         * else is an emulation bug, or a guest playing with the instruction
         * stream under Xen's feet.
         */
        if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&
             ((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||
              (((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||
                (emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&
               emul_ctxt.ctxt.event.error_code == 0)) )
            hvm_inject_event(&emul_ctxt.ctxt.event);
        else
        {
            SHADOW_PRINTK(
                ""Unexpected event (type %u, vector %#x) from emulation\n"",
                emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);
            r = X86EMUL_UNHANDLEABLE;
        }
    }
#endif

    /*
     * NB. We do not unshadow on X86EMUL_EXCEPTION. It's not clear that it
     * would be a good unshadow hint. If we *do* decide to unshadow-on-fault
     * then it must be 'failable': we cannot require the unshadow to succeed.
     */
    if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )
    {
        perfc_incr(shadow_fault_emulate_failed);
#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
        if ( fast_emul )
        {
            perfc_incr(shadow_fault_fast_emulate_fail);
            v->arch.paging.last_write_emul_ok = 0;
        }
#endif
        SHADOW_PRINTK(""emulator failure (rc=%d), unshadowing mfn %#lx\n"",
                       r, mfn_x(gmfn));
        /* If this is actually a page table, then we have a bug, and need
         * to support more operations in the emulator.  More likely,
         * though, this is a hint that this page should not be shadowed. */
        shadow_remove_all_shadows(d, gmfn);

        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,
                                   va, gfn);
        goto emulate_done;
    }

#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION
    /* Record successfully emulated information as heuristics to next
     * fault on same frame for acceleration. But be careful to verify
     * its attribute still as page table, or else unshadow triggered
     * in write emulation normally requires a re-sync with guest page
     * table to recover r/w permission. Incorrect record for such case
     * will cause unexpected more shadow faults due to propagation is
     * skipped.
     */
    if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )
    {
        if ( !fast_emul )
        {
            v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;
            v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);
            v->arch.paging.last_write_emul_ok = 1;
        }
    }
    else if ( fast_emul )
        v->arch.paging.last_write_emul_ok = 0;
#endif

    if ( emul_ctxt.ctxt.retire.singlestep )
        hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);

#if GUEST_PAGING_LEVELS == 3 /* PAE guest */
    /*
     * If there are no pending actions, emulate up to four extra instructions
     * in the hope of catching the ""second half"" of a 64-bit pagetable write.
     */
    if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )
    {
        int i, emulation_count=0;
        this_cpu(trace_emulate_initial_va) = va;

        for ( i = 0 ; i < 4 ; i++ )
        {
            shadow_continue_emulation(&emul_ctxt, regs);
            v->arch.paging.last_write_was_pt = 0;
            r = x86_emulate(&emul_ctxt.ctxt, emul_ops);

            /*
             * Only continue the search for the second half if there are no
             * exceptions or pending actions.  Otherwise, give up and re-enter
             * the guest.
             */
            if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )
            {
                emulation_count++;
                if ( v->arch.paging.last_write_was_pt )
                {
                    perfc_incr(shadow_em_ex_pt);
                    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);
                    break; /* Don't emulate past the other half of the write */
                }
                else
                    perfc_incr(shadow_em_ex_non_pt);
            }
            else
            {
                perfc_incr(shadow_em_ex_fail);
                TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);

                if ( emul_ctxt.ctxt.retire.singlestep )
                    hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);

                break; /* Don't emulate again if we failed! */
            }
        }
        this_cpu(trace_extra_emulation_count)=emulation_count;
    }
#endif /* PAE guest */

    trace_shadow_emulate(gw.l1e, va);
 emulate_done:
    SHADOW_PRINTK(""emulated\n"");
    return EXCRET_fault_fixed;

 mmio:
    if ( !guest_mode(regs) )
        goto not_a_shadow_fault;
#ifdef CONFIG_HVM
    ASSERT(is_hvm_vcpu(v));
    perfc_incr(shadow_fault_mmio);
    sh_audit_gw(v, &gw);
    SHADOW_PRINTK(""mmio %#""PRIpaddr""\n"", gpa);
    shadow_audit_tables(v);
    sh_reset_early_unshadow(v);
    paging_unlock(d);
    put_gfn(d, gfn_x(gfn));
    trace_shadow_gen(TRC_SHADOW_MMIO, va);
    return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)
            ? EXCRET_fault_fixed : 0);
#else
    BUG();
#endif

 not_a_shadow_fault:
    sh_audit_gw(v, &gw);
    SHADOW_PRINTK(""not a shadow fault\n"");
    shadow_audit_tables(v);
    sh_reset_early_unshadow(v);
    paging_unlock(d);
    put_gfn(d, gfn_x(gfn));

propagate:
    trace_not_shadow_fault(gw.l1e, va);

    return 0;
}","static int sh_page_fault(struct vcpu *VAR_0,
                          unsigned long VAR_1,
                          struct cpu_user_regs *VAR_2)
{
    struct domain *VAR_3 = VAR_0->domain;
    walk_t VAR_4;
    gfn_t VAR_5 = _gfn(0);
    mfn_t VAR_6, VAR_7 = _mfn(0);
    shadow_l1e_t VAR_8, *VAR_9;
    paddr_t VAR_10;
    struct sh_emulate_ctxt VAR_11;
    const struct x86_emulate_ops *VAR_12;
    int VAR_13;
    p2m_type_t VAR_14;
    uint32_t VAR_15, VAR_16;
    bool VAR_17;
    int VAR_18;
    unsigned int VAR_19;
    const struct npfec VAR_20 = {
         .read_access = 1,
         .write_access = !!(VAR_2->error_code & VAR_21),
         .gla_valid = 1,
         .kind = VAR_22
    };
    const fetch_type_t VAR_23 =
        VAR_20.write_access ? VAR_24 : VAR_25;
#if VAR_26 & VAR_27
    int VAR_28 = 0;
#endif

    SHADOW_PRINTK(""%pv va=%#lx err=%#x, rip=%lx\n"",
                  VAR_0, VAR_1, VAR_2->error_code, VAR_2->rip);

    perfc_incr(VAR_29);

#if VAR_26 & VAR_27
    /* COMMENT_0 */
                                                                        
                                                          
       
    if ( VAR_0->arch.paging.last_write_emul_ok
         && VAR_0->arch.paging.shadow.last_emulated_frame == (VAR_1 >> VAR_30) )
    {
        /* COMMENT_4 */
                                                 
           
        if ( VAR_2->error_code == (VAR_21 | VAR_31) )
        {
            VAR_28 = 1;
            VAR_6 = _mfn(VAR_0->arch.paging.shadow.last_emulated_mfn);

#if (VAR_26 & VAR_32)
            /* COMMENT_7 */
                                                
            if ( mfn_valid(VAR_6) && mfn_is_out_of_sync(VAR_6) )
            {
                VAR_28 = 0;
                VAR_0->arch.paging.last_write_emul_ok = 0;
                goto page_fault_slow_path;
            }
#endif /* COMMENT_9 */

            perfc_incr(VAR_33);
            goto early_emulation;
        }
        else
            VAR_0->arch.paging.last_write_emul_ok = 0;
    }
#endif

    /* COMMENT_10 */
    /* COMMENT_11 */
    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_10 */

#if (VAR_26 & VAR_34)
    if ( (VAR_2->error_code & VAR_35) )
    {
#if (VAR_26 & VAR_32)
        /* COMMENT_14 */
                                                                      
                                    
        {
            shadow_l2e_t VAR_36;
            mfn_t VAR_37;
            if ( (__copy_from_user(&VAR_36,
                                   (sh_linear_l2_table(VAR_0)
                                    + shadow_l2_linear_offset(VAR_1)),
                                   sizeof(VAR_36)) != 0)
                 || !(shadow_l2e_get_flags(VAR_36) & VAR_38)
                 || !mfn_valid(VAR_37 = backpointer(mfn_to_page(
                                  shadow_l2e_get_mfn(VAR_36))))
                 || unlikely(mfn_is_out_of_sync(VAR_37)) )
            {
                /* COMMENT_17 */
                                                             
                ASSERT(VAR_2->error_code & VAR_31);
                VAR_2->error_code ^= (VAR_35|VAR_31);
                goto page_fault_slow_path;
            }
        }
#endif /* COMMENT_19 */
        /* COMMENT_20 */
                                                     
        if ( likely((__copy_from_user(&VAR_8,
                                      (sh_linear_l1_table(VAR_0)
                                       + shadow_l1_linear_offset(VAR_1)),
                                      sizeof(VAR_8)) == 0)
                    && sh_l1e_is_magic(VAR_8)) )
        {

            if ( sh_l1e_is_gnp(VAR_8) )
            {
                /* COMMENT_22 */
                                                                 
                ASSERT(VAR_2->error_code & VAR_31);
                VAR_2->error_code ^= (VAR_35|VAR_31);
                sh_reset_early_unshadow(VAR_0);
                perfc_incr(VAR_39);
                SHADOW_PRINTK(""fast path not-present\n"");
                trace_shadow_gen(VAR_40, VAR_1);
                return 0;
            }
#ifdef VAR_41
            /* COMMENT_24 */
            ASSERT(sh_l1e_is_mmio(VAR_8));
            ASSERT(is_hvm_vcpu(VAR_0));
            VAR_10 = gfn_to_gaddr(sh_l1e_mmio_get_gfn(VAR_8)) | (VAR_1 & ~VAR_42);
            perfc_incr(VAR_43);
            SHADOW_PRINTK(""fast path mmio %#""VAR_44""\n"", VAR_10);
            sh_reset_early_unshadow(VAR_0);
            trace_shadow_gen(VAR_45, VAR_1);
            return handle_mmio_with_translation(VAR_1, VAR_10 >> VAR_30, VAR_20)
                   ? VAR_46 : 0;
#else
            /* COMMENT_25 */
            BUG();
#endif
        }
        else
        {
            /* COMMENT_26 */
                                                                    
                                                                               
            perfc_incr(VAR_47);
            SHADOW_PRINTK(""fast path false alarm!\n"");
            trace_shadow_gen(VAR_48, VAR_1);
            return VAR_46;
        }
    }

#if (VAR_26 & VAR_32)
 page_fault_slow_path:
#endif
#endif /* COMMENT_29 */

    /* COMMENT_30 */
                                                                        
                                                                         
                                                               
                                                     
    if ( unlikely(paging_locked_by_me(VAR_3)) )
    {
        printk(XENLOG_G_ERR ""Recursive shadow fault: lock taken by %s\n"",
               VAR_3->arch.paging.lock.locker_function);
        return 0;
    }

    VAR_19 = is_pv_vcpu(VAR_0) ? (VAR_2->ss & 3) : hvm_get_cpl(VAR_0);

 rewalk:

    VAR_16 = VAR_2->error_code;

    /* COMMENT_35 */
                                                                         
                                                                          
                                                                             
                
      
                                                                              
                                                                        
                                   
      
                                                                     
                                                                   
                                                                     
                                                                         
                                
      
                                                  
      
                                                                          
                                                             
      
                                             
      
                                                                              
                                                                     
                                                                         
                                                         
      
                                                                            
                                                                   
      
                                                                           
                                                                           
                                                                            
                                                                            
                                         
      
                                                                       
                                                                             
                                                                         
                                                                           
                                                                             
                                                                            
                                                                       
                        
      
                                                                          
                                                                             
                                                                              
                                                                             
                            
       
    if ( !(VAR_16 & (VAR_49|VAR_50)) && VAR_19 == 3 )
        VAR_16 |= VAR_51;

    /* COMMENT_78 */
                                                                       
                                                                   
                            
    VAR_18 = atomic_read(&VAR_3->arch.paging.shadow.gtable_dirty_version);
    smp_rmb();
    VAR_17 = sh_walk_guest_tables(VAR_0, VAR_1, &VAR_4, VAR_16);

#if (VAR_26 & VAR_32)
    VAR_2->error_code &= ~VAR_31;
    if ( VAR_4.pfec & VAR_31 )
        VAR_2->error_code |= VAR_31;
#endif

    if ( !VAR_17 )
    {
        perfc_incr(VAR_52);
        SHADOW_PRINTK(""not a shadow fault\n"");
        sh_reset_early_unshadow(VAR_0);
        VAR_2->error_code = VAR_4.pfec & VAR_53;
        goto propagate;
    }

    /* COMMENT_82 */
                                                                             
                                                                             
                                                                       
    if ( unlikely(VAR_3->is_shutting_down && VAR_3->shutdown_code == VAR_54) )
    {
        SHADOW_PRINTK(""guest is shutting down\n"");
        goto propagate;
    }

    /* COMMENT_86 */
    VAR_5 = guest_walk_to_gfn(&VAR_4);
    VAR_6 = get_gfn(VAR_3, VAR_5, &VAR_14);

    if ( shadow_mode_refcounts(VAR_3) &&
         ((!p2m_is_valid(VAR_14) && !p2m_is_grant(VAR_14)) ||
          (!p2m_is_mmio(VAR_14) && !mfn_valid(VAR_6))) )
    {
        perfc_incr(VAR_55);
        SHADOW_PRINTK(""BAD gfn=%""VAR_56"" gmfn=%""VAR_57""\n"",
                      gfn_x(VAR_5), mfn_x(VAR_6));
        sh_reset_early_unshadow(VAR_0);
        put_gfn(VAR_3, gfn_x(VAR_5));
        goto propagate;
    }

#if (VAR_26 & VAR_58)
    /* COMMENT_87 */
    vtlb_insert(VAR_0, VAR_1 >> VAR_30, gfn_x(VAR_5),
                VAR_2->error_code | VAR_31);
#endif /* COMMENT_88 */

    paging_lock(VAR_3);

    VAR_59;

    /* COMMENT_89 */
                                                                         
                                                            
                                                                   
                                       
      
                                                                   
                                                                    
                            
    shadow_prealloc(VAR_3,
                    VAR_60,
                    VAR_61 < 4 ? 1 : VAR_61 - 1);

    VAR_15 = gw_remove_write_accesses(VAR_0, VAR_1, &VAR_4);

    /* COMMENT_98 */
    if ( VAR_15 & VAR_62 )
    {
        /* COMMENT_99 */
                                                        
           
        perfc_incr(VAR_63);
        smp_wmb();
        atomic_inc(&VAR_3->arch.paging.shadow.gtable_dirty_version);
        flush_tlb_mask(VAR_3->dirty_cpumask);
    }

#if (VAR_26 & VAR_32)
    /* COMMENT_102 */
    if ( VAR_15 & VAR_64 )
    {
        paging_unlock(VAR_3);
        put_gfn(VAR_3, gfn_x(VAR_5));
        goto rewalk;
    }
#endif /* COMMENT_9 */

    if ( !shadow_check_gwalk(VAR_0, VAR_1, &VAR_4, VAR_18) )
    {
        perfc_incr(VAR_65);
        paging_unlock(VAR_3);
        put_gfn(VAR_3, gfn_x(VAR_5));
        goto rewalk;
    }

    shadow_audit_tables(VAR_0);
    sh_audit_gw(VAR_0, &VAR_4);

    /* COMMENT_103 */
                                                                   
    VAR_9 = shadow_get_and_create_l1e(VAR_0, &VAR_4, &VAR_7, VAR_23);
    if ( unlikely(VAR_9 == NULL) )
    {
        /* COMMENT_105 */
                                                             
                                                               
                                                       
        /* COMMENT_109 */
                                                                    
                             
                                                                       
                                                            
#if VAR_61 == 3
        VAR_0->arch.paging.mode->update_cr3(VAR_0, 0, false);
#else
        ASSERT(VAR_3->is_shutting_down);
#endif
        paging_unlock(VAR_3);
        put_gfn(VAR_3, gfn_x(VAR_5));
        trace_shadow_gen(VAR_66, VAR_1);
        return 0;
    }

#if (VAR_26 & VAR_32)
    /* COMMENT_114 */
    if ( sh_mfn_is_a_page_table(VAR_6)
         && VAR_23 == VAR_24 )
        sh_unsync(VAR_0, VAR_6);

    if ( unlikely(VAR_3->is_shutting_down && VAR_3->shutdown_code == VAR_54) )
    {
        /* COMMENT_115 */
                                                                 
                                                                     
                                                    
        paging_unlock(VAR_3);
        put_gfn(VAR_3, gfn_x(VAR_5));
        return 0;
    }

    /* COMMENT_119 */
                                                                          
    if ( shadow_check_gl1e(VAR_0, &VAR_4)  )
    {
        perfc_incr(VAR_65);
        paging_unlock(VAR_3);
        put_gfn(VAR_3, gfn_x(VAR_5));
        goto rewalk;
    }
#endif /* COMMENT_9 */

    /* COMMENT_121 */
    l1e_propagate_from_guest(VAR_0, VAR_4.l1e, VAR_6, &VAR_8, VAR_23, VAR_14);
    VAR_13 = shadow_set_l1e(VAR_3, VAR_9, VAR_8, VAR_14, VAR_7);

#if (VAR_26 & VAR_32)
    if ( mfn_valid(VAR_4.l1mfn)
         && mfn_is_out_of_sync(VAR_4.l1mfn) )
    {
        /* COMMENT_122 */
        mfn_t VAR_67 = oos_snapshot_lookup(VAR_3, VAR_4.l1mfn);
        guest_l1e_t *VAR_68;

        ASSERT(mfn_valid(VAR_67));

        VAR_68 = map_domain_page(VAR_67);
        VAR_68[guest_l1_table_offset(VAR_1)] = VAR_4.l1e;
        unmap_domain_page(VAR_68);
    }
#endif /* COMMENT_9 */

#if VAR_26 & VAR_69
    /* COMMENT_123 */
    sh_prefetch(VAR_0, &VAR_4, VAR_9, VAR_7);
#endif

    /* COMMENT_124 */
    if ( sh_mfn_is_a_page_table(VAR_6)
#if (VAR_26 & VAR_32)
         /* COMMENT_125 */
                                                        
         && !(mfn_is_out_of_sync(VAR_6)
              && !(VAR_2->error_code & VAR_50))
#endif
         && (VAR_23 == VAR_24) )
    {
        perfc_incr(VAR_70);
        goto emulate;
    }

    /* COMMENT_127 */
    if ( VAR_14 == VAR_71 )
    {
        VAR_10 = guest_walk_to_gpa(&VAR_4);
        goto mmio;
    }

    /* COMMENT_128 */
    if ( p2m_is_readonly(VAR_14) && (VAR_23 == VAR_24) )
    {
        static unsigned long VAR_72;
        if ( xchg(&VAR_72, VAR_1 & VAR_42) != (VAR_1 & VAR_42) )
            gdprintk(VAR_73, ""guest attempted write to read-only memory""
                     "" page. va page=%#lx, mfn=%#lx\n"",
                     VAR_1 & VAR_42, mfn_x(VAR_6));
        goto emulate_readonly; /* COMMENT_129 */
    }

    /* COMMENT_130 */
                                                                  
                                                                     
                                                                       
                                                        
    if ( is_hvm_domain(VAR_3)
         && unlikely(!hvm_wp_enabled(VAR_0))
         && VAR_2->error_code == (VAR_21|VAR_31)
         && mfn_valid(VAR_6) )
    {
        perfc_incr(VAR_74);
        goto emulate;
    }

    perfc_incr(VAR_75);
    VAR_3->arch.paging.log_dirty.fault_count++;
    sh_reset_early_unshadow(VAR_0);

    trace_shadow_fixup(VAR_4.l1e, VAR_1);
 done:
    sh_audit_gw(VAR_0, &VAR_4);
    SHADOW_PRINTK(""fixed\n"");
    shadow_audit_tables(VAR_0);
    paging_unlock(VAR_3);
    put_gfn(VAR_3, gfn_x(VAR_5));
    return VAR_46;

 emulate:
    if ( !shadow_mode_refcounts(VAR_3) || !guest_mode(VAR_2) )
        goto not_a_shadow_fault;

    /* COMMENT_135 */
                                                                            
                                                                              
                                                                            
       
    if ( (VAR_2->error_code & VAR_50) )
    {
        SHADOW_PRINTK(""user-mode fault to PT, unshadowing mfn %#lx\n"",
                      mfn_x(VAR_6));
        perfc_incr(VAR_76);
        sh_remove_shadows(VAR_3, VAR_6, 0 /* COMMENT_140 */, 1 /* COMMENT_141 */);
        trace_shadow_emulate_other(VAR_77,
                                      VAR_1, VAR_5);
        goto done;
    }

    /* COMMENT_142 */
                                                                         
                                                  
       
 emulate_readonly:

    /* COMMENT_146 */
                                                                     
    if ( sh_mfn_is_a_page_table(VAR_6) && is_hvm_domain(VAR_3) &&
         mfn_to_page(VAR_6)->pagetable_dying )
    {
        int VAR_78 = 0;
        struct vcpu *VAR_79;
        for_each_vcpu(VAR_3, VAR_79)
        {
#if VAR_61 == 3
            int VAR_80;
            for ( VAR_80 = 0; VAR_80 < 4; VAR_80++ )
            {
                mfn_t VAR_81 = pagetable_get_mfn(VAR_0->arch.shadow_table[VAR_80]);

                if ( mfn_valid(VAR_81) && (mfn_x(VAR_81) != 0) )
                {
                    VAR_78 |= (mfn_to_page(VAR_81)->v.sh.back == mfn_x(VAR_6));

                    if ( VAR_78 )
                        break;
                }
            }
#else /* COMMENT_148 */
            VAR_78 = mfn_eq(pagetable_get_mfn(VAR_79->arch.guest_table), VAR_6);
#endif
            if ( VAR_78 )
                break;
        }

        if ( !VAR_78 )
            sh_remove_shadows(VAR_3, VAR_6, 1 /* COMMENT_149 */, 0 /* COMMENT_150 */);
    }

    /* COMMENT_151 */
                                                                      
                                                     
       
    sh_audit_gw(VAR_0, &VAR_4);
    shadow_audit_tables(VAR_0);
    paging_unlock(VAR_3);
    put_gfn(VAR_3, gfn_x(VAR_5));

    this_cpu(VAR_82) = 0;

#if VAR_26 & VAR_27
 early_emulation:
#endif
    if ( is_hvm_domain(VAR_3) )
    {
        /* COMMENT_155 */
                                                                              
                                                                               
                                                                             
                                                                         
                                                     
           
        if ( unlikely(hvm_event_pending(VAR_0)) )
        {
#if VAR_26 & VAR_27
            if ( VAR_28 )
            {
                perfc_incr(VAR_83);
                VAR_0->arch.paging.last_write_emul_ok = 0;
            }
#endif
            gdprintk(VAR_73, ""write to pagetable during event ""
                     ""injection: cr2=%#lx, mfn=%#lx\n"",
                     VAR_1, mfn_x(VAR_6));
            sh_remove_shadows(VAR_3, VAR_6, 0 /* COMMENT_140 */, 1 /* COMMENT_141 */);
            trace_shadow_emulate_other(VAR_84,
                                       VAR_1, VAR_5);
            return VAR_46;
        }
    }

    SHADOW_PRINTK(""emulate: eip=%#lx esp=%#lx\n"", VAR_2->rip, VAR_2->rsp);

    VAR_12 = shadow_init_emulation(&VAR_11, VAR_2, VAR_85);

    VAR_13 = x86_emulate(&VAR_11.ctxt, VAR_12);

#ifdef VAR_41
    if ( VAR_13 == VAR_86 )
    {
        ASSERT(is_hvm_domain(VAR_3));
        /* COMMENT_162 */
                                                                              
                                                                        
                                                                              
                                                                            
                                   
           
        if ( VAR_11.ctxt.event.type == VAR_87 &&
             ((VAR_11.ctxt.event.vector == VAR_88) ||
              (((VAR_11.ctxt.event.vector == VAR_89) ||
                (VAR_11.ctxt.event.vector == VAR_90)) &&
               VAR_11.ctxt.event.error_code == 0)) )
            hvm_inject_event(&VAR_11.ctxt.event);
        else
        {
            SHADOW_PRINTK(
                ""Unexpected event (type %u, vector %#x) from emulation\n"",
                VAR_11.ctxt.event.type, VAR_11.ctxt.event.vector);
            VAR_13 = VAR_91;
        }
    }
#endif

    /* COMMENT_169 */
                                                                          
                                                                            
                                                                             
       
    if ( VAR_13 == VAR_91 || VAR_13 == VAR_92 )
    {
        perfc_incr(VAR_76);
#if VAR_26 & VAR_27
        if ( VAR_28 )
        {
            perfc_incr(VAR_83);
            VAR_0->arch.paging.last_write_emul_ok = 0;
        }
#endif
        SHADOW_PRINTK(""emulator failure (rc=%d), unshadowing mfn %#lx\n"",
                       VAR_13, mfn_x(VAR_6));
        /* COMMENT_174 */
                                                                    
                                                                           
        shadow_remove_all_shadows(VAR_3, VAR_6);

        trace_shadow_emulate_other(VAR_93,
                                   VAR_1, VAR_5);
        goto emulate_done;
    }

#if VAR_26 & VAR_27
    /* COMMENT_177 */
                                                                     
                                                                    
                                                                     
                                                                      
                                                                     
               
       
    if ( (VAR_13 == VAR_94) && sh_mfn_is_a_page_table(VAR_6) )
    {
        if ( !VAR_28 )
        {
            VAR_0->arch.paging.shadow.last_emulated_frame = VAR_1 >> VAR_30;
            VAR_0->arch.paging.shadow.last_emulated_mfn = mfn_x(VAR_6);
            VAR_0->arch.paging.last_write_emul_ok = 1;
        }
    }
    else if ( VAR_28 )
        VAR_0->arch.paging.last_write_emul_ok = 0;
#endif

    if ( VAR_11.ctxt.retire.singlestep )
        hvm_inject_hw_exception(VAR_95, VAR_96);

#if VAR_61 == 3 /* COMMENT_185 */
    /* COMMENT_186 */
                                                                             
                                                                             
       
    if ( VAR_13 == VAR_94 && !VAR_11.ctxt.retire.raw )
    {
        int VAR_80, VAR_97=0;
        this_cpu(VAR_98) = VAR_1;

        for ( VAR_80 = 0 ; VAR_80 < 4 ; VAR_80++ )
        {
            shadow_continue_emulation(&VAR_11, VAR_2);
            VAR_0->arch.paging.last_write_was_pt = 0;
            VAR_13 = x86_emulate(&VAR_11.ctxt, VAR_12);

            /* COMMENT_190 */
                                                                           
                                                                              
                         
               
            if ( VAR_13 == VAR_94 && !VAR_11.ctxt.retire.raw )
            {
                VAR_97++;
                if ( VAR_0->arch.paging.last_write_was_pt )
                {
                    perfc_incr(VAR_99);
                    TRACE_SHADOW_PATH_FLAG(VAR_100);
                    break; /* COMMENT_195 */
                }
                else
                    perfc_incr(VAR_101);
            }
            else
            {
                perfc_incr(VAR_102);
                TRACE_SHADOW_PATH_FLAG(VAR_103);

                if ( VAR_11.ctxt.retire.singlestep )
                    hvm_inject_hw_exception(VAR_95, VAR_96);

                break; /* COMMENT_196 */
            }
        }
        this_cpu(VAR_104)=VAR_97;
    }
#endif /* COMMENT_185 */

    trace_shadow_emulate(VAR_4.l1e, VAR_1);
 emulate_done:
    SHADOW_PRINTK(""emulated\n"");
    return VAR_46;

 mmio:
    if ( !guest_mode(VAR_2) )
        goto not_a_shadow_fault;
#ifdef VAR_41
    ASSERT(is_hvm_vcpu(VAR_0));
    perfc_incr(VAR_105);
    sh_audit_gw(VAR_0, &VAR_4);
    SHADOW_PRINTK(""mmio %#""VAR_44""\n"", VAR_10);
    shadow_audit_tables(VAR_0);
    sh_reset_early_unshadow(VAR_0);
    paging_unlock(VAR_3);
    put_gfn(VAR_3, gfn_x(VAR_5));
    trace_shadow_gen(VAR_106, VAR_1);
    return (handle_mmio_with_translation(VAR_1, VAR_10 >> VAR_30, VAR_20)
            ? VAR_46 : 0);
#else
    BUG();
#endif

 not_a_shadow_fault:
    sh_audit_gw(VAR_0, &VAR_4);
    SHADOW_PRINTK(""not a shadow fault\n"");
    shadow_audit_tables(VAR_0);
    sh_reset_early_unshadow(VAR_0);
    paging_unlock(VAR_3);
    put_gfn(VAR_3, gfn_x(VAR_5));

propagate:
    trace_not_shadow_fault(VAR_4.l1e, VAR_1);

    return 0;
}",xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/multi.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -500,8 +500,8 @@
 
     /* Unshadow if we are writing to a toplevel pagetable that is
      * flagged as a dying process, and that is not currently used. */
-    if ( sh_mfn_is_a_page_table(gmfn)
-         && (mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying) )
+    if ( sh_mfn_is_a_page_table(gmfn) && is_hvm_domain(d) &&
+         mfn_to_page(gmfn)->pagetable_dying )
     {
         int used = 0;
         struct vcpu *tmp;","{'deleted_lines': ['    if ( sh_mfn_is_a_page_table(gmfn)', '         && (mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying) )'], 'added_lines': ['    if ( sh_mfn_is_a_page_table(gmfn) && is_hvm_domain(d) &&', '         mfn_to_page(gmfn)->pagetable_dying )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because of an interpretation conflict for a union data structure associated with shadow paging. NOTE: this issue exists because of an incorrect fix for CVE-2017-15595.,8.8,HIGH,2,valid,2018-11-20T13:59:54Z,2
CVE-2018-19395,"['CWE-476', 'CWE-502']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,php/php-src,"Fix #77177: Serializing or unserializing COM objects crashes

Firstly, we avoid returning NULL from the get_property handler, but
instead return an empty HashTable, which already prevents the crashes.
Secondly, since (de-)serialization obviously makes no sense for COM,
DOTNET and VARIANT objects (at least with the current implementation),
we prohibit it right away.",115ee49b0be12e3df7d2c7027609fbe1a1297e42,https://github.com/php/php-src/commit/115ee49b0be12e3df7d2c7027609fbe1a1297e42,ext/com_dotnet/com_handlers.c,com_properties_get,"static HashTable *com_properties_get(zval *object)
{
return NULL;
}","static HashTable *com_properties_get(zval *VAR_0)
{
return NULL;
}",php/php-src/115ee49b0be12e3df7d2c7027609fbe1a1297e42/com_handlers.c/vul/before/0.json,"static HashTable *com_properties_get(zval *object)
{
	/* TODO: use type-info to get all the names and values ?
	 * DANGER: if we do that, there is a strong possibility for
	 * infinite recursion when the hash is displayed via var_dump().
	 * Perhaps it is best to leave it un-implemented.
	 */
	return &com_dotnet_object_properties;
}","static HashTable *com_properties_get(zval *VAR_0)
{
	/* COMMENT_0 */
                                                            
                                                                 
                                                  
    
	return &VAR_1;
}",php/php-src/115ee49b0be12e3df7d2c7027609fbe1a1297e42/com_handlers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,5 +5,5 @@
 	 * infinite recursion when the hash is displayed via var_dump().
 	 * Perhaps it is best to leave it un-implemented.
 	 */
-	return NULL;
+	return &com_dotnet_object_properties;
 }","{'deleted_lines': ['\treturn NULL;'], 'added_lines': ['\treturn &com_dotnet_object_properties;']}",True,"ext/standard/var.c in PHP 5.x through 7.1.24 on Windows allows attackers to cause a denial of service (NULL pointer dereference and application crash) because com and com_safearray_proxy return NULL in com_properties_get in ext/com_dotnet/com_handlers.c, as demonstrated by a serialize call on COM(""WScript.Shell"").",7.5,HIGH,2,valid,2018-11-23T15:32:33Z,2
CVE-2018-18397,['CWE-863'],AV:L/AC:L/Au:N/C:N/I:P/A:N,0,torvalds/linux,"userfaultfd: shmem/hugetlbfs: only allow to register VM_MAYWRITE vmas

After the VMA to register the uffd onto is found, check that it has
VM_MAYWRITE set before allowing registration.  This way we inherit all
common code checks before allowing to fill file holes in shmem and
hugetlbfs with UFFDIO_COPY.

The userfaultfd memory model is not applicable for readonly files unless
it's a MAP_PRIVATE.

Link: http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com
Fixes: ff62a3421044 (""hugetlb: implement memfd sealing"")
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
Reviewed-by: Hugh Dickins <hughd@google.com>
Reported-by: Jann Horn <jannh@google.com>
Fixes: 4c27fe4c4c84 (""userfaultfd: shmem: add shmem_mcopy_atomic_pte for userfaultfd support"")
Cc: <stable@vger.kernel.org>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: Mike Kravetz <mike.kravetz@oracle.com>
Cc: Peter Xu <peterx@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",29ec90660d68bbdd69507c1c8b4e33aa299278b1,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,fs/userfaultfd.c,userfaultfd_unregister,"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
unsigned long arg)
{
struct mm_struct *mm = ctx->mm;
struct vm_area_struct *vma, *prev, *cur;
int ret;
struct uffdio_range uffdio_unregister;
unsigned long new_flags;
bool found;
unsigned long start, end, vma_end;
const void __user *buf = (void __user *)arg;
ret = -EFAULT;
if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))
goto out;
ret = validate_range(mm, uffdio_unregister.start,
uffdio_unregister.len);
if (ret)
goto out;
start = uffdio_unregister.start;
end = start + uffdio_unregister.len;
ret = -ENOMEM;
if (!mmget_not_zero(mm))
goto out;
down_write(&mm->mmap_sem);
vma = find_vma_prev(mm, start, &prev);
if (!vma)
goto out_unlock;
ret = -EINVAL;
if (vma->vm_start >= end)
goto out_unlock;
if (is_vm_hugetlb_page(vma)) {
unsigned long vma_hpagesize = vma_kernel_pagesize(vma);
if (start & (vma_hpagesize - 1))
goto out_unlock;
}
found = false;
ret = -EINVAL;
for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
cond_resched();
BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));
if (!vma_can_userfault(cur))
goto out_unlock;
found = true;
}
BUG_ON(!found);
if (vma->vm_start < start)
prev = vma;
ret = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(vma));
if (!vma->vm_userfaultfd_ctx.ctx)
goto skip;
if (vma->vm_start > start)
start = vma->vm_start;
vma_end = min(end, vma->vm_end);
if (userfaultfd_missing(vma)) {
struct userfaultfd_wake_range range;
range.start = start;
range.len = vma_end - start;
wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);
}
new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);
prev = vma_merge(mm, prev, start, vma_end, new_flags,
vma->anon_vma, vma->vm_file, vma->vm_pgoff,
vma_policy(vma),
NULL_VM_UFFD_CTX);
if (prev) {
vma = prev;
goto next;
}
if (vma->vm_start < start) {
ret = split_vma(mm, vma, start, 1);
if (ret)
break;
}
if (vma->vm_end > end) {
ret = split_vma(mm, vma, end, 0);
if (ret)
break;
}
next:
vma->vm_flags = new_flags;
vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
skip:
prev = vma;
start = vma->vm_end;
vma = vma->vm_next;
} while (vma && vma->vm_start < end);
out_unlock:
up_write(&mm->mmap_sem);
mmput(mm);
out:
return ret;
}","static int userfaultfd_unregister(struct userfaultfd_ctx *VAR_0,
unsigned long VAR_1)
{
struct mm_struct *VAR_2 = VAR_0->mm;
struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
int VAR_6;
struct uffdio_range VAR_7;
unsigned long VAR_8;
bool VAR_9;
unsigned long VAR_10, VAR_11, VAR_12;
const void __user *VAR_13 = (void __user *)VAR_1;
VAR_6 = -VAR_14;
if (copy_from_user(&VAR_7, VAR_13, sizeof(VAR_7)))
goto out;
VAR_6 = validate_range(VAR_2, VAR_7.start,
VAR_7.len);
if (VAR_6)
goto out;
VAR_10 = VAR_7.start;
VAR_11 = VAR_10 + VAR_7.len;
VAR_6 = -VAR_15;
if (!mmget_not_zero(VAR_2))
goto out;
down_write(&VAR_2->mmap_sem);
VAR_3 = find_vma_prev(VAR_2, VAR_10, &VAR_4);
if (!VAR_3)
goto out_unlock;
VAR_6 = -VAR_16;
if (VAR_3->vm_start >= VAR_11)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_3)) {
unsigned long VAR_17 = vma_kernel_pagesize(VAR_3);
if (VAR_10 & (VAR_17 - 1))
goto out_unlock;
}
VAR_9 = false;
VAR_6 = -VAR_16;
for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_11; VAR_5 = VAR_5->vm_next) {
cond_resched();
BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
!!(VAR_5->vm_flags & (VAR_18 | VAR_19)));
if (!vma_can_userfault(VAR_5))
goto out_unlock;
VAR_9 = true;
}
BUG_ON(!VAR_9);
if (VAR_3->vm_start < VAR_10)
VAR_4 = VAR_3;
VAR_6 = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(VAR_3));
if (!VAR_3->vm_userfaultfd_ctx.ctx)
goto skip;
if (VAR_3->vm_start > VAR_10)
VAR_10 = VAR_3->vm_start;
VAR_12 = min(VAR_11, VAR_3->vm_end);
if (userfaultfd_missing(VAR_3)) {
struct userfaultfd_wake_range VAR_20;
VAR_20.start = VAR_10;
VAR_20.len = VAR_12 - VAR_10;
wake_userfault(VAR_3->vm_userfaultfd_ctx.ctx, &VAR_20);
}
VAR_8 = VAR_3->vm_flags & ~(VAR_18 | VAR_19);
VAR_4 = vma_merge(VAR_2, VAR_4, VAR_10, VAR_12, VAR_8,
VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
vma_policy(VAR_3),
VAR_21);
if (VAR_4) {
VAR_3 = VAR_4;
goto next;
}
if (VAR_3->vm_start < VAR_10) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_10, 1);
if (VAR_6)
break;
}
if (VAR_3->vm_end > VAR_11) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_11, 0);
if (VAR_6)
break;
}
next:
VAR_3->vm_flags = VAR_8;
VAR_3->vm_userfaultfd_ctx = VAR_21;
skip:
VAR_4 = VAR_3;
VAR_10 = VAR_3->vm_end;
VAR_3 = VAR_3->vm_next;
} while (VAR_3 && VAR_3->vm_start < VAR_11);
out_unlock:
up_write(&VAR_2->mmap_sem);
mmput(VAR_2);
out:
return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/before/1.json,"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
				  unsigned long arg)
{
	struct mm_struct *mm = ctx->mm;
	struct vm_area_struct *vma, *prev, *cur;
	int ret;
	struct uffdio_range uffdio_unregister;
	unsigned long new_flags;
	bool found;
	unsigned long start, end, vma_end;
	const void __user *buf = (void __user *)arg;

	ret = -EFAULT;
	if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))
		goto out;

	ret = validate_range(mm, uffdio_unregister.start,
			     uffdio_unregister.len);
	if (ret)
		goto out;

	start = uffdio_unregister.start;
	end = start + uffdio_unregister.len;

	ret = -ENOMEM;
	if (!mmget_not_zero(mm))
		goto out;

	down_write(&mm->mmap_sem);
	vma = find_vma_prev(mm, start, &prev);
	if (!vma)
		goto out_unlock;

	/* check that there's at least one vma in the range */
	ret = -EINVAL;
	if (vma->vm_start >= end)
		goto out_unlock;

	/*
	 * If the first vma contains huge pages, make sure start address
	 * is aligned to huge page size.
	 */
	if (is_vm_hugetlb_page(vma)) {
		unsigned long vma_hpagesize = vma_kernel_pagesize(vma);

		if (start & (vma_hpagesize - 1))
			goto out_unlock;
	}

	/*
	 * Search for not compatible vmas.
	 */
	found = false;
	ret = -EINVAL;
	for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
		cond_resched();

		BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
		       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));

		/*
		 * Check not compatible vmas, not strictly required
		 * here as not compatible vmas cannot have an
		 * userfaultfd_ctx registered on them, but this
		 * provides for more strict behavior to notice
		 * unregistration errors.
		 */
		if (!vma_can_userfault(cur))
			goto out_unlock;

		found = true;
	}
	BUG_ON(!found);

	if (vma->vm_start < start)
		prev = vma;

	ret = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(vma));
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));

		/*
		 * Nothing to do: this vma is already registered into this
		 * userfaultfd and with the right tracking mode too.
		 */
		if (!vma->vm_userfaultfd_ctx.ctx)
			goto skip;

		if (vma->vm_start > start)
			start = vma->vm_start;
		vma_end = min(end, vma->vm_end);

		if (userfaultfd_missing(vma)) {
			/*
			 * Wake any concurrent pending userfault while
			 * we unregister, so they will not hang
			 * permanently and it avoids userland to call
			 * UFFDIO_WAKE explicitly.
			 */
			struct userfaultfd_wake_range range;
			range.start = start;
			range.len = vma_end - start;
			wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);
		}

		new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);
		prev = vma_merge(mm, prev, start, vma_end, new_flags,
				 vma->anon_vma, vma->vm_file, vma->vm_pgoff,
				 vma_policy(vma),
				 NULL_VM_UFFD_CTX);
		if (prev) {
			vma = prev;
			goto next;
		}
		if (vma->vm_start < start) {
			ret = split_vma(mm, vma, start, 1);
			if (ret)
				break;
		}
		if (vma->vm_end > end) {
			ret = split_vma(mm, vma, end, 0);
			if (ret)
				break;
		}
	next:
		/*
		 * In the vma_merge() successful mprotect-like case 8:
		 * the next vma was merged into the current one and
		 * the current one has not been updated yet.
		 */
		vma->vm_flags = new_flags;
		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;

	skip:
		prev = vma;
		start = vma->vm_end;
		vma = vma->vm_next;
	} while (vma && vma->vm_start < end);
out_unlock:
	up_write(&mm->mmap_sem);
	mmput(mm);
out:
	return ret;
}","static int userfaultfd_unregister(struct userfaultfd_ctx *VAR_0,
				  unsigned long VAR_1)
{
	struct mm_struct *VAR_2 = VAR_0->mm;
	struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
	int VAR_6;
	struct uffdio_range VAR_7;
	unsigned long VAR_8;
	bool VAR_9;
	unsigned long VAR_10, VAR_11, VAR_12;
	const void __user *VAR_13 = (void __user *)VAR_1;

	VAR_6 = -VAR_14;
	if (copy_from_user(&VAR_7, VAR_13, sizeof(VAR_7)))
		goto out;

	VAR_6 = validate_range(VAR_2, VAR_7.start,
			     VAR_7.len);
	if (VAR_6)
		goto out;

	VAR_10 = VAR_7.start;
	VAR_11 = VAR_10 + VAR_7.len;

	VAR_6 = -VAR_15;
	if (!mmget_not_zero(VAR_2))
		goto out;

	down_write(&VAR_2->mmap_sem);
	VAR_3 = find_vma_prev(VAR_2, VAR_10, &VAR_4);
	if (!VAR_3)
		goto out_unlock;

	/* COMMENT_0 */
	VAR_6 = -VAR_16;
	if (VAR_3->vm_start >= VAR_11)
		goto out_unlock;

	/* COMMENT_1 */
                                                                 
                                 
    
	if (is_vm_hugetlb_page(VAR_3)) {
		unsigned long VAR_17 = vma_kernel_pagesize(VAR_3);

		if (VAR_10 & (VAR_17 - 1))
			goto out_unlock;
	}

	/* COMMENT_5 */
                                   
    
	VAR_9 = false;
	VAR_6 = -VAR_16;
	for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_11; VAR_5 = VAR_5->vm_next) {
		cond_resched();

		BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
		       !!(VAR_5->vm_flags & (VAR_18 | VAR_19)));

		/* COMMENT_8 */
                                                     
                                               
                                                 
                                                
                           
     
		if (!vma_can_userfault(VAR_5))
			goto out_unlock;

		VAR_9 = true;
	}
	BUG_ON(!VAR_9);

	if (VAR_3->vm_start < VAR_10)
		VAR_4 = VAR_3;

	VAR_6 = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(VAR_3));
		WARN_ON(!(VAR_3->vm_flags & VAR_20));

		/* COMMENT_15 */
                                                            
                                                      
     
		if (!VAR_3->vm_userfaultfd_ctx.ctx)
			goto skip;

		if (VAR_3->vm_start > VAR_10)
			VAR_10 = VAR_3->vm_start;
		VAR_12 = min(VAR_11, VAR_3->vm_end);

		if (userfaultfd_missing(VAR_3)) {
			/* COMMENT_19 */
                                                 
                                          
                                                
                             
      
			struct userfaultfd_wake_range VAR_21;
			VAR_21.start = VAR_10;
			VAR_21.len = VAR_12 - VAR_10;
			wake_userfault(VAR_3->vm_userfaultfd_ctx.ctx, &VAR_21);
		}

		VAR_8 = VAR_3->vm_flags & ~(VAR_18 | VAR_19);
		VAR_4 = vma_merge(VAR_2, VAR_4, VAR_10, VAR_12, VAR_8,
				 VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
				 vma_policy(VAR_3),
				 VAR_22);
		if (VAR_4) {
			VAR_3 = VAR_4;
			goto next;
		}
		if (VAR_3->vm_start < VAR_10) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_10, 1);
			if (VAR_6)
				break;
		}
		if (VAR_3->vm_end > VAR_11) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_11, 0);
			if (VAR_6)
				break;
		}
	next:
		/* COMMENT_25 */
                                                        
                                                     
                                              
     
		VAR_3->vm_flags = VAR_8;
		VAR_3->vm_userfaultfd_ctx = VAR_22;

	skip:
		VAR_4 = VAR_3;
		VAR_10 = VAR_3->vm_end;
		VAR_3 = VAR_3->vm_next;
	} while (VAR_3 && VAR_3->vm_start < VAR_11);
out_unlock:
	up_write(&VAR_2->mmap_sem);
	mmput(VAR_2);
out:
	return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -80,6 +80,7 @@
 		cond_resched();
 
 		BUG_ON(!vma_can_userfault(vma));
+		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this","{'deleted_lines': [], 'added_lines': ['\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));']}",True,"The userfaultfd implementation in the Linux kernel before 4.19.7 mishandles access control for certain UFFDIO_ ioctl calls, as demonstrated by allowing local users to write data into holes in a tmpfs file (if the user has read-only access to that file, and that file contains holes), related to fs/userfaultfd.c and mm/userfaultfd.c.",5.5,MEDIUM,1,valid,2018-11-30T22:09:32Z,2
CVE-2018-18397,['CWE-863'],AV:L/AC:L/Au:N/C:N/I:P/A:N,0,torvalds/linux,"userfaultfd: shmem/hugetlbfs: only allow to register VM_MAYWRITE vmas

After the VMA to register the uffd onto is found, check that it has
VM_MAYWRITE set before allowing registration.  This way we inherit all
common code checks before allowing to fill file holes in shmem and
hugetlbfs with UFFDIO_COPY.

The userfaultfd memory model is not applicable for readonly files unless
it's a MAP_PRIVATE.

Link: http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com
Fixes: ff62a3421044 (""hugetlb: implement memfd sealing"")
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
Reviewed-by: Hugh Dickins <hughd@google.com>
Reported-by: Jann Horn <jannh@google.com>
Fixes: 4c27fe4c4c84 (""userfaultfd: shmem: add shmem_mcopy_atomic_pte for userfaultfd support"")
Cc: <stable@vger.kernel.org>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: Mike Kravetz <mike.kravetz@oracle.com>
Cc: Peter Xu <peterx@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",29ec90660d68bbdd69507c1c8b4e33aa299278b1,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,fs/userfaultfd.c,userfaultfd_register,"static int userfaultfd_register(struct userfaultfd_ctx *ctx,
unsigned long arg)
{
struct mm_struct *mm = ctx->mm;
struct vm_area_struct *vma, *prev, *cur;
int ret;
struct uffdio_register uffdio_register;
struct uffdio_register __user *user_uffdio_register;
unsigned long vm_flags, new_flags;
bool found;
bool basic_ioctls;
unsigned long start, end, vma_end;
user_uffdio_register = (struct uffdio_register __user *) arg;
ret = -EFAULT;
if (copy_from_user(&uffdio_register, user_uffdio_register,
sizeof(uffdio_register)-sizeof(__u64)))
goto out;
ret = -EINVAL;
if (!uffdio_register.mode)
goto out;
if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|
UFFDIO_REGISTER_MODE_WP))
goto out;
vm_flags = 0;
if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)
vm_flags |= VM_UFFD_MISSING;
if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {
vm_flags |= VM_UFFD_WP;
ret = -EINVAL;
goto out;
}
ret = validate_range(mm, uffdio_register.range.start,
uffdio_register.range.len);
if (ret)
goto out;
start = uffdio_register.range.start;
end = start + uffdio_register.range.len;
ret = -ENOMEM;
if (!mmget_not_zero(mm))
goto out;
down_write(&mm->mmap_sem);
vma = find_vma_prev(mm, start, &prev);
if (!vma)
goto out_unlock;
ret = -EINVAL;
if (vma->vm_start >= end)
goto out_unlock;
if (is_vm_hugetlb_page(vma)) {
unsigned long vma_hpagesize = vma_kernel_pagesize(vma);
if (start & (vma_hpagesize - 1))
goto out_unlock;
}
found = false;
basic_ioctls = false;
for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
cond_resched();
BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));
ret = -EINVAL;
if (!vma_can_userfault(cur))
goto out_unlock;
if (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&
end > cur->vm_start) {
unsigned long vma_hpagesize = vma_kernel_pagesize(cur);
ret = -EINVAL;
if (end & (vma_hpagesize - 1))
goto out_unlock;
}
ret = -EBUSY;
if (cur->vm_userfaultfd_ctx.ctx &&
cur->vm_userfaultfd_ctx.ctx != ctx)
goto out_unlock;
if (is_vm_hugetlb_page(cur))
basic_ioctls = true;
found = true;
}
BUG_ON(!found);
if (vma->vm_start < start)
prev = vma;
ret = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(vma));
BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
vma->vm_userfaultfd_ctx.ctx != ctx);
if (vma->vm_userfaultfd_ctx.ctx == ctx &&
(vma->vm_flags & vm_flags) == vm_flags)
goto skip;
if (vma->vm_start > start)
start = vma->vm_start;
vma_end = min(end, vma->vm_end);
new_flags = (vma->vm_flags & ~vm_flags) | vm_flags;
prev = vma_merge(mm, prev, start, vma_end, new_flags,
vma->anon_vma, vma->vm_file, vma->vm_pgoff,
vma_policy(vma),
((struct vm_userfaultfd_ctx){ ctx }));
if (prev) {
vma = prev;
goto next;
}
if (vma->vm_start < start) {
ret = split_vma(mm, vma, start, 1);
if (ret)
break;
}
if (vma->vm_end > end) {
ret = split_vma(mm, vma, end, 0);
if (ret)
break;
}
next:
vma->vm_flags = new_flags;
vma->vm_userfaultfd_ctx.ctx = ctx;
skip:
prev = vma;
start = vma->vm_end;
vma = vma->vm_next;
} while (vma && vma->vm_start < end);
out_unlock:
up_write(&mm->mmap_sem);
mmput(mm);
if (!ret) {
if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :
UFFD_API_RANGE_IOCTLS,
&user_uffdio_register->ioctls))
ret = -EFAULT;
}
out:
return ret;
}","static int userfaultfd_register(struct userfaultfd_ctx *VAR_0,
unsigned long VAR_1)
{
struct mm_struct *VAR_2 = VAR_0->mm;
struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
int VAR_6;
struct uffdio_register uffdio_register;
struct uffdio_register __user *VAR_7;
unsigned long VAR_8, VAR_9;
bool VAR_10;
bool VAR_11;
unsigned long VAR_12, VAR_13, VAR_14;
VAR_7 = (struct uffdio_register __user *) VAR_1;
VAR_6 = -VAR_15;
if (copy_from_user(&uffdio_register, VAR_7,
sizeof(uffdio_register)-sizeof(VAR_16)))
goto out;
VAR_6 = -VAR_17;
if (!uffdio_register.mode)
goto out;
if (uffdio_register.mode & ~(VAR_18|
VAR_19))
goto out;
VAR_8 = 0;
if (uffdio_register.mode & VAR_18)
VAR_8 |= VAR_20;
if (uffdio_register.mode & VAR_19) {
VAR_8 |= VAR_21;
VAR_6 = -VAR_17;
goto out;
}
VAR_6 = validate_range(VAR_2, uffdio_register.range.start,
uffdio_register.range.len);
if (VAR_6)
goto out;
VAR_12 = uffdio_register.range.start;
VAR_13 = VAR_12 + uffdio_register.range.len;
VAR_6 = -VAR_22;
if (!mmget_not_zero(VAR_2))
goto out;
down_write(&VAR_2->mmap_sem);
VAR_3 = find_vma_prev(VAR_2, VAR_12, &VAR_4);
if (!VAR_3)
goto out_unlock;
VAR_6 = -VAR_17;
if (VAR_3->vm_start >= VAR_13)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_3)) {
unsigned long VAR_23 = vma_kernel_pagesize(VAR_3);
if (VAR_12 & (VAR_23 - 1))
goto out_unlock;
}
VAR_10 = false;
VAR_11 = false;
for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_13; VAR_5 = VAR_5->vm_next) {
cond_resched();
BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
!!(VAR_5->vm_flags & (VAR_20 | VAR_21)));
VAR_6 = -VAR_17;
if (!vma_can_userfault(VAR_5))
goto out_unlock;
if (is_vm_hugetlb_page(VAR_5) && VAR_13 <= VAR_5->vm_end &&
VAR_13 > VAR_5->vm_start) {
unsigned long VAR_23 = vma_kernel_pagesize(VAR_5);
VAR_6 = -VAR_17;
if (VAR_13 & (VAR_23 - 1))
goto out_unlock;
}
VAR_6 = -VAR_24;
if (VAR_5->vm_userfaultfd_ctx.ctx &&
VAR_5->vm_userfaultfd_ctx.ctx != VAR_0)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_5))
VAR_11 = true;
VAR_10 = true;
}
BUG_ON(!VAR_10);
if (VAR_3->vm_start < VAR_12)
VAR_4 = VAR_3;
VAR_6 = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(VAR_3));
BUG_ON(VAR_3->vm_userfaultfd_ctx.ctx &&
VAR_3->vm_userfaultfd_ctx.ctx != VAR_0);
if (VAR_3->vm_userfaultfd_ctx.ctx == VAR_0 &&
(VAR_3->vm_flags & VAR_8) == VAR_8)
goto skip;
if (VAR_3->vm_start > VAR_12)
VAR_12 = VAR_3->vm_start;
VAR_14 = min(VAR_13, VAR_3->vm_end);
VAR_9 = (VAR_3->vm_flags & ~VAR_8) | VAR_8;
VAR_4 = vma_merge(VAR_2, VAR_4, VAR_12, VAR_14, VAR_9,
VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
vma_policy(VAR_3),
((struct vm_userfaultfd_ctx){ VAR_0 }));
if (VAR_4) {
VAR_3 = VAR_4;
goto next;
}
if (VAR_3->vm_start < VAR_12) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_12, 1);
if (VAR_6)
break;
}
if (VAR_3->vm_end > VAR_13) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_13, 0);
if (VAR_6)
break;
}
next:
VAR_3->vm_flags = VAR_9;
VAR_3->vm_userfaultfd_ctx.ctx = VAR_0;
skip:
VAR_4 = VAR_3;
VAR_12 = VAR_3->vm_end;
VAR_3 = VAR_3->vm_next;
} while (VAR_3 && VAR_3->vm_start < VAR_13);
out_unlock:
up_write(&VAR_2->mmap_sem);
mmput(VAR_2);
if (!VAR_6) {
if (put_user(VAR_11 ? VAR_25 :
VAR_26,
&VAR_7->ioctls))
VAR_6 = -VAR_15;
}
out:
return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/before/0.json,"static int userfaultfd_register(struct userfaultfd_ctx *ctx,
				unsigned long arg)
{
	struct mm_struct *mm = ctx->mm;
	struct vm_area_struct *vma, *prev, *cur;
	int ret;
	struct uffdio_register uffdio_register;
	struct uffdio_register __user *user_uffdio_register;
	unsigned long vm_flags, new_flags;
	bool found;
	bool basic_ioctls;
	unsigned long start, end, vma_end;

	user_uffdio_register = (struct uffdio_register __user *) arg;

	ret = -EFAULT;
	if (copy_from_user(&uffdio_register, user_uffdio_register,
			   sizeof(uffdio_register)-sizeof(__u64)))
		goto out;

	ret = -EINVAL;
	if (!uffdio_register.mode)
		goto out;
	if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|
				     UFFDIO_REGISTER_MODE_WP))
		goto out;
	vm_flags = 0;
	if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)
		vm_flags |= VM_UFFD_MISSING;
	if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {
		vm_flags |= VM_UFFD_WP;
		/*
		 * FIXME: remove the below error constraint by
		 * implementing the wprotect tracking mode.
		 */
		ret = -EINVAL;
		goto out;
	}

	ret = validate_range(mm, uffdio_register.range.start,
			     uffdio_register.range.len);
	if (ret)
		goto out;

	start = uffdio_register.range.start;
	end = start + uffdio_register.range.len;

	ret = -ENOMEM;
	if (!mmget_not_zero(mm))
		goto out;

	down_write(&mm->mmap_sem);
	vma = find_vma_prev(mm, start, &prev);
	if (!vma)
		goto out_unlock;

	/* check that there's at least one vma in the range */
	ret = -EINVAL;
	if (vma->vm_start >= end)
		goto out_unlock;

	/*
	 * If the first vma contains huge pages, make sure start address
	 * is aligned to huge page size.
	 */
	if (is_vm_hugetlb_page(vma)) {
		unsigned long vma_hpagesize = vma_kernel_pagesize(vma);

		if (start & (vma_hpagesize - 1))
			goto out_unlock;
	}

	/*
	 * Search for not compatible vmas.
	 */
	found = false;
	basic_ioctls = false;
	for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
		cond_resched();

		BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
		       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));

		/* check not compatible vmas */
		ret = -EINVAL;
		if (!vma_can_userfault(cur))
			goto out_unlock;

		/*
		 * UFFDIO_COPY will fill file holes even without
		 * PROT_WRITE. This check enforces that if this is a
		 * MAP_SHARED, the process has write permission to the backing
		 * file. If VM_MAYWRITE is set it also enforces that on a
		 * MAP_SHARED vma: there is no F_WRITE_SEAL and no further
		 * F_WRITE_SEAL can be taken until the vma is destroyed.
		 */
		ret = -EPERM;
		if (unlikely(!(cur->vm_flags & VM_MAYWRITE)))
			goto out_unlock;

		/*
		 * If this vma contains ending address, and huge pages
		 * check alignment.
		 */
		if (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&
		    end > cur->vm_start) {
			unsigned long vma_hpagesize = vma_kernel_pagesize(cur);

			ret = -EINVAL;

			if (end & (vma_hpagesize - 1))
				goto out_unlock;
		}

		/*
		 * Check that this vma isn't already owned by a
		 * different userfaultfd. We can't allow more than one
		 * userfaultfd to own a single vma simultaneously or we
		 * wouldn't know which one to deliver the userfaults to.
		 */
		ret = -EBUSY;
		if (cur->vm_userfaultfd_ctx.ctx &&
		    cur->vm_userfaultfd_ctx.ctx != ctx)
			goto out_unlock;

		/*
		 * Note vmas containing huge pages
		 */
		if (is_vm_hugetlb_page(cur))
			basic_ioctls = true;

		found = true;
	}
	BUG_ON(!found);

	if (vma->vm_start < start)
		prev = vma;

	ret = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(vma));
		BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
		       vma->vm_userfaultfd_ctx.ctx != ctx);
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));

		/*
		 * Nothing to do: this vma is already registered into this
		 * userfaultfd and with the right tracking mode too.
		 */
		if (vma->vm_userfaultfd_ctx.ctx == ctx &&
		    (vma->vm_flags & vm_flags) == vm_flags)
			goto skip;

		if (vma->vm_start > start)
			start = vma->vm_start;
		vma_end = min(end, vma->vm_end);

		new_flags = (vma->vm_flags & ~vm_flags) | vm_flags;
		prev = vma_merge(mm, prev, start, vma_end, new_flags,
				 vma->anon_vma, vma->vm_file, vma->vm_pgoff,
				 vma_policy(vma),
				 ((struct vm_userfaultfd_ctx){ ctx }));
		if (prev) {
			vma = prev;
			goto next;
		}
		if (vma->vm_start < start) {
			ret = split_vma(mm, vma, start, 1);
			if (ret)
				break;
		}
		if (vma->vm_end > end) {
			ret = split_vma(mm, vma, end, 0);
			if (ret)
				break;
		}
	next:
		/*
		 * In the vma_merge() successful mprotect-like case 8:
		 * the next vma was merged into the current one and
		 * the current one has not been updated yet.
		 */
		vma->vm_flags = new_flags;
		vma->vm_userfaultfd_ctx.ctx = ctx;

	skip:
		prev = vma;
		start = vma->vm_end;
		vma = vma->vm_next;
	} while (vma && vma->vm_start < end);
out_unlock:
	up_write(&mm->mmap_sem);
	mmput(mm);
	if (!ret) {
		/*
		 * Now that we scanned all vmas we can already tell
		 * userland which ioctls methods are guaranteed to
		 * succeed on this range.
		 */
		if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :
			     UFFD_API_RANGE_IOCTLS,
			     &user_uffdio_register->ioctls))
			ret = -EFAULT;
	}
out:
	return ret;
}","static int userfaultfd_register(struct userfaultfd_ctx *VAR_0,
				unsigned long VAR_1)
{
	struct mm_struct *VAR_2 = VAR_0->mm;
	struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
	int VAR_6;
	struct uffdio_register uffdio_register;
	struct uffdio_register __user *VAR_7;
	unsigned long VAR_8, VAR_9;
	bool VAR_10;
	bool VAR_11;
	unsigned long VAR_12, VAR_13, VAR_14;

	VAR_7 = (struct uffdio_register __user *) VAR_1;

	VAR_6 = -VAR_15;
	if (copy_from_user(&uffdio_register, VAR_7,
			   sizeof(uffdio_register)-sizeof(VAR_16)))
		goto out;

	VAR_6 = -VAR_17;
	if (!uffdio_register.mode)
		goto out;
	if (uffdio_register.mode & ~(VAR_18|
				     VAR_19))
		goto out;
	VAR_8 = 0;
	if (uffdio_register.mode & VAR_18)
		VAR_8 |= VAR_20;
	if (uffdio_register.mode & VAR_19) {
		VAR_8 |= VAR_21;
		/* COMMENT_0 */
                                                
                                             
     
		VAR_6 = -VAR_17;
		goto out;
	}

	VAR_6 = validate_range(VAR_2, uffdio_register.range.start,
			     uffdio_register.range.len);
	if (VAR_6)
		goto out;

	VAR_12 = uffdio_register.range.start;
	VAR_13 = VAR_12 + uffdio_register.range.len;

	VAR_6 = -VAR_22;
	if (!mmget_not_zero(VAR_2))
		goto out;

	down_write(&VAR_2->mmap_sem);
	VAR_3 = find_vma_prev(VAR_2, VAR_12, &VAR_4);
	if (!VAR_3)
		goto out_unlock;

	/* COMMENT_4 */
	VAR_6 = -VAR_17;
	if (VAR_3->vm_start >= VAR_13)
		goto out_unlock;

	/* COMMENT_5 */
                                                                 
                                 
    
	if (is_vm_hugetlb_page(VAR_3)) {
		unsigned long VAR_23 = vma_kernel_pagesize(VAR_3);

		if (VAR_12 & (VAR_23 - 1))
			goto out_unlock;
	}

	/* COMMENT_9 */
                                   
    
	VAR_10 = false;
	VAR_11 = false;
	for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_13; VAR_5 = VAR_5->vm_next) {
		cond_resched();

		BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
		       !!(VAR_5->vm_flags & (VAR_20 | VAR_21)));

		/* COMMENT_12 */
		VAR_6 = -VAR_17;
		if (!vma_can_userfault(VAR_5))
			goto out_unlock;

		/* COMMENT_13 */
                                                  
                                                      
                                                                
                                                           
                                                            
                                                          
     
		VAR_6 = -VAR_24;
		if (unlikely(!(VAR_5->vm_flags & VAR_25)))
			goto out_unlock;

		/* COMMENT_21 */
                                                        
                     
     
		if (is_vm_hugetlb_page(VAR_5) && VAR_13 <= VAR_5->vm_end &&
		    VAR_13 > VAR_5->vm_start) {
			unsigned long VAR_23 = vma_kernel_pagesize(VAR_5);

			VAR_6 = -VAR_17;

			if (VAR_13 & (VAR_23 - 1))
				goto out_unlock;
		}

		/* COMMENT_25 */
                                                 
                                                        
                                                         
                                                          
     
		VAR_6 = -VAR_26;
		if (VAR_5->vm_userfaultfd_ctx.ctx &&
		    VAR_5->vm_userfaultfd_ctx.ctx != VAR_0)
			goto out_unlock;

		/* COMMENT_31 */
                                    
     
		if (is_vm_hugetlb_page(VAR_5))
			VAR_11 = true;

		VAR_10 = true;
	}
	BUG_ON(!VAR_10);

	if (VAR_3->vm_start < VAR_12)
		VAR_4 = VAR_3;

	VAR_6 = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(VAR_3));
		BUG_ON(VAR_3->vm_userfaultfd_ctx.ctx &&
		       VAR_3->vm_userfaultfd_ctx.ctx != VAR_0);
		WARN_ON(!(VAR_3->vm_flags & VAR_25));

		/* COMMENT_34 */
                                                            
                                                      
     
		if (VAR_3->vm_userfaultfd_ctx.ctx == VAR_0 &&
		    (VAR_3->vm_flags & VAR_8) == VAR_8)
			goto skip;

		if (VAR_3->vm_start > VAR_12)
			VAR_12 = VAR_3->vm_start;
		VAR_14 = min(VAR_13, VAR_3->vm_end);

		VAR_9 = (VAR_3->vm_flags & ~VAR_8) | VAR_8;
		VAR_4 = vma_merge(VAR_2, VAR_4, VAR_12, VAR_14, VAR_9,
				 VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
				 vma_policy(VAR_3),
				 ((struct vm_userfaultfd_ctx){ VAR_0 }));
		if (VAR_4) {
			VAR_3 = VAR_4;
			goto next;
		}
		if (VAR_3->vm_start < VAR_12) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_12, 1);
			if (VAR_6)
				break;
		}
		if (VAR_3->vm_end > VAR_13) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_13, 0);
			if (VAR_6)
				break;
		}
	next:
		/* COMMENT_38 */
                                                        
                                                     
                                              
     
		VAR_3->vm_flags = VAR_9;
		VAR_3->vm_userfaultfd_ctx.ctx = VAR_0;

	skip:
		VAR_4 = VAR_3;
		VAR_12 = VAR_3->vm_end;
		VAR_3 = VAR_3->vm_next;
	} while (VAR_3 && VAR_3->vm_start < VAR_13);
out_unlock:
	up_write(&VAR_2->mmap_sem);
	mmput(VAR_2);
	if (!VAR_6) {
		/* COMMENT_43 */
                                                     
                                                    
                           
     
		if (put_user(VAR_11 ? VAR_27 :
			     VAR_28,
			     &VAR_7->ioctls))
			VAR_6 = -VAR_15;
	}
out:
	return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -85,6 +85,19 @@
 		ret = -EINVAL;
 		if (!vma_can_userfault(cur))
 			goto out_unlock;
+
+		/*
+		 * UFFDIO_COPY will fill file holes even without
+		 * PROT_WRITE. This check enforces that if this is a
+		 * MAP_SHARED, the process has write permission to the backing
+		 * file. If VM_MAYWRITE is set it also enforces that on a
+		 * MAP_SHARED vma: there is no F_WRITE_SEAL and no further
+		 * F_WRITE_SEAL can be taken until the vma is destroyed.
+		 */
+		ret = -EPERM;
+		if (unlikely(!(cur->vm_flags & VM_MAYWRITE)))
+			goto out_unlock;
+
 		/*
 		 * If this vma contains ending address, and huge pages
 		 * check alignment.
@@ -130,6 +143,7 @@
 		BUG_ON(!vma_can_userfault(vma));
 		BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
 		       vma->vm_userfaultfd_ctx.ctx != ctx);
+		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this","{'deleted_lines': [], 'added_lines': ['', '\t\t/*', '\t\t * UFFDIO_COPY will fill file holes even without', '\t\t * PROT_WRITE. This check enforces that if this is a', '\t\t * MAP_SHARED, the process has write permission to the backing', '\t\t * file. If VM_MAYWRITE is set it also enforces that on a', '\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further', '\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.', '\t\t */', '\t\tret = -EPERM;', '\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))', '\t\t\tgoto out_unlock;', '', '\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));']}",True,"The userfaultfd implementation in the Linux kernel before 4.19.7 mishandles access control for certain UFFDIO_ ioctl calls, as demonstrated by allowing local users to write data into holes in a tmpfs file (if the user has read-only access to that file, and that file contains holes), related to fs/userfaultfd.c and mm/userfaultfd.c.",5.5,MEDIUM,1,valid,2018-11-30T22:09:32Z,2
CVE-2018-18397,['CWE-863'],AV:L/AC:L/Au:N/C:N/I:P/A:N,0,torvalds/linux,"userfaultfd: shmem/hugetlbfs: only allow to register VM_MAYWRITE vmas

After the VMA to register the uffd onto is found, check that it has
VM_MAYWRITE set before allowing registration.  This way we inherit all
common code checks before allowing to fill file holes in shmem and
hugetlbfs with UFFDIO_COPY.

The userfaultfd memory model is not applicable for readonly files unless
it's a MAP_PRIVATE.

Link: http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com
Fixes: ff62a3421044 (""hugetlb: implement memfd sealing"")
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
Reviewed-by: Hugh Dickins <hughd@google.com>
Reported-by: Jann Horn <jannh@google.com>
Fixes: 4c27fe4c4c84 (""userfaultfd: shmem: add shmem_mcopy_atomic_pte for userfaultfd support"")
Cc: <stable@vger.kernel.org>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: Mike Kravetz <mike.kravetz@oracle.com>
Cc: Peter Xu <peterx@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",29ec90660d68bbdd69507c1c8b4e33aa299278b1,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,mm/userfaultfd.c,userfaultfd_unregister,"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
unsigned long arg)
{
struct mm_struct *mm = ctx->mm;
struct vm_area_struct *vma, *prev, *cur;
int ret;
struct uffdio_range uffdio_unregister;
unsigned long new_flags;
bool found;
unsigned long start, end, vma_end;
const void __user *buf = (void __user *)arg;
ret = -EFAULT;
if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))
goto out;
ret = validate_range(mm, uffdio_unregister.start,
uffdio_unregister.len);
if (ret)
goto out;
start = uffdio_unregister.start;
end = start + uffdio_unregister.len;
ret = -ENOMEM;
if (!mmget_not_zero(mm))
goto out;
down_write(&mm->mmap_sem);
vma = find_vma_prev(mm, start, &prev);
if (!vma)
goto out_unlock;
ret = -EINVAL;
if (vma->vm_start >= end)
goto out_unlock;
if (is_vm_hugetlb_page(vma)) {
unsigned long vma_hpagesize = vma_kernel_pagesize(vma);
if (start & (vma_hpagesize - 1))
goto out_unlock;
}
found = false;
ret = -EINVAL;
for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
cond_resched();
BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));
if (!vma_can_userfault(cur))
goto out_unlock;
found = true;
}
BUG_ON(!found);
if (vma->vm_start < start)
prev = vma;
ret = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(vma));
if (!vma->vm_userfaultfd_ctx.ctx)
goto skip;
if (vma->vm_start > start)
start = vma->vm_start;
vma_end = min(end, vma->vm_end);
if (userfaultfd_missing(vma)) {
struct userfaultfd_wake_range range;
range.start = start;
range.len = vma_end - start;
wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);
}
new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);
prev = vma_merge(mm, prev, start, vma_end, new_flags,
vma->anon_vma, vma->vm_file, vma->vm_pgoff,
vma_policy(vma),
NULL_VM_UFFD_CTX);
if (prev) {
vma = prev;
goto next;
}
if (vma->vm_start < start) {
ret = split_vma(mm, vma, start, 1);
if (ret)
break;
}
if (vma->vm_end > end) {
ret = split_vma(mm, vma, end, 0);
if (ret)
break;
}
next:
vma->vm_flags = new_flags;
vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
skip:
prev = vma;
start = vma->vm_end;
vma = vma->vm_next;
} while (vma && vma->vm_start < end);
out_unlock:
up_write(&mm->mmap_sem);
mmput(mm);
out:
return ret;
}","static int userfaultfd_unregister(struct userfaultfd_ctx *VAR_0,
unsigned long VAR_1)
{
struct mm_struct *VAR_2 = VAR_0->mm;
struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
int VAR_6;
struct uffdio_range VAR_7;
unsigned long VAR_8;
bool VAR_9;
unsigned long VAR_10, VAR_11, VAR_12;
const void __user *VAR_13 = (void __user *)VAR_1;
VAR_6 = -VAR_14;
if (copy_from_user(&VAR_7, VAR_13, sizeof(VAR_7)))
goto out;
VAR_6 = validate_range(VAR_2, VAR_7.start,
VAR_7.len);
if (VAR_6)
goto out;
VAR_10 = VAR_7.start;
VAR_11 = VAR_10 + VAR_7.len;
VAR_6 = -VAR_15;
if (!mmget_not_zero(VAR_2))
goto out;
down_write(&VAR_2->mmap_sem);
VAR_3 = find_vma_prev(VAR_2, VAR_10, &VAR_4);
if (!VAR_3)
goto out_unlock;
VAR_6 = -VAR_16;
if (VAR_3->vm_start >= VAR_11)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_3)) {
unsigned long VAR_17 = vma_kernel_pagesize(VAR_3);
if (VAR_10 & (VAR_17 - 1))
goto out_unlock;
}
VAR_9 = false;
VAR_6 = -VAR_16;
for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_11; VAR_5 = VAR_5->vm_next) {
cond_resched();
BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
!!(VAR_5->vm_flags & (VAR_18 | VAR_19)));
if (!vma_can_userfault(VAR_5))
goto out_unlock;
VAR_9 = true;
}
BUG_ON(!VAR_9);
if (VAR_3->vm_start < VAR_10)
VAR_4 = VAR_3;
VAR_6 = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(VAR_3));
if (!VAR_3->vm_userfaultfd_ctx.ctx)
goto skip;
if (VAR_3->vm_start > VAR_10)
VAR_10 = VAR_3->vm_start;
VAR_12 = min(VAR_11, VAR_3->vm_end);
if (userfaultfd_missing(VAR_3)) {
struct userfaultfd_wake_range VAR_20;
VAR_20.start = VAR_10;
VAR_20.len = VAR_12 - VAR_10;
wake_userfault(VAR_3->vm_userfaultfd_ctx.ctx, &VAR_20);
}
VAR_8 = VAR_3->vm_flags & ~(VAR_18 | VAR_19);
VAR_4 = vma_merge(VAR_2, VAR_4, VAR_10, VAR_12, VAR_8,
VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
vma_policy(VAR_3),
VAR_21);
if (VAR_4) {
VAR_3 = VAR_4;
goto next;
}
if (VAR_3->vm_start < VAR_10) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_10, 1);
if (VAR_6)
break;
}
if (VAR_3->vm_end > VAR_11) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_11, 0);
if (VAR_6)
break;
}
next:
VAR_3->vm_flags = VAR_8;
VAR_3->vm_userfaultfd_ctx = VAR_21;
skip:
VAR_4 = VAR_3;
VAR_10 = VAR_3->vm_end;
VAR_3 = VAR_3->vm_next;
} while (VAR_3 && VAR_3->vm_start < VAR_11);
out_unlock:
up_write(&VAR_2->mmap_sem);
mmput(VAR_2);
out:
return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/before/1.json,"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
				  unsigned long arg)
{
	struct mm_struct *mm = ctx->mm;
	struct vm_area_struct *vma, *prev, *cur;
	int ret;
	struct uffdio_range uffdio_unregister;
	unsigned long new_flags;
	bool found;
	unsigned long start, end, vma_end;
	const void __user *buf = (void __user *)arg;

	ret = -EFAULT;
	if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))
		goto out;

	ret = validate_range(mm, uffdio_unregister.start,
			     uffdio_unregister.len);
	if (ret)
		goto out;

	start = uffdio_unregister.start;
	end = start + uffdio_unregister.len;

	ret = -ENOMEM;
	if (!mmget_not_zero(mm))
		goto out;

	down_write(&mm->mmap_sem);
	vma = find_vma_prev(mm, start, &prev);
	if (!vma)
		goto out_unlock;

	/* check that there's at least one vma in the range */
	ret = -EINVAL;
	if (vma->vm_start >= end)
		goto out_unlock;

	/*
	 * If the first vma contains huge pages, make sure start address
	 * is aligned to huge page size.
	 */
	if (is_vm_hugetlb_page(vma)) {
		unsigned long vma_hpagesize = vma_kernel_pagesize(vma);

		if (start & (vma_hpagesize - 1))
			goto out_unlock;
	}

	/*
	 * Search for not compatible vmas.
	 */
	found = false;
	ret = -EINVAL;
	for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
		cond_resched();

		BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
		       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));

		/*
		 * Check not compatible vmas, not strictly required
		 * here as not compatible vmas cannot have an
		 * userfaultfd_ctx registered on them, but this
		 * provides for more strict behavior to notice
		 * unregistration errors.
		 */
		if (!vma_can_userfault(cur))
			goto out_unlock;

		found = true;
	}
	BUG_ON(!found);

	if (vma->vm_start < start)
		prev = vma;

	ret = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(vma));
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));

		/*
		 * Nothing to do: this vma is already registered into this
		 * userfaultfd and with the right tracking mode too.
		 */
		if (!vma->vm_userfaultfd_ctx.ctx)
			goto skip;

		if (vma->vm_start > start)
			start = vma->vm_start;
		vma_end = min(end, vma->vm_end);

		if (userfaultfd_missing(vma)) {
			/*
			 * Wake any concurrent pending userfault while
			 * we unregister, so they will not hang
			 * permanently and it avoids userland to call
			 * UFFDIO_WAKE explicitly.
			 */
			struct userfaultfd_wake_range range;
			range.start = start;
			range.len = vma_end - start;
			wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);
		}

		new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);
		prev = vma_merge(mm, prev, start, vma_end, new_flags,
				 vma->anon_vma, vma->vm_file, vma->vm_pgoff,
				 vma_policy(vma),
				 NULL_VM_UFFD_CTX);
		if (prev) {
			vma = prev;
			goto next;
		}
		if (vma->vm_start < start) {
			ret = split_vma(mm, vma, start, 1);
			if (ret)
				break;
		}
		if (vma->vm_end > end) {
			ret = split_vma(mm, vma, end, 0);
			if (ret)
				break;
		}
	next:
		/*
		 * In the vma_merge() successful mprotect-like case 8:
		 * the next vma was merged into the current one and
		 * the current one has not been updated yet.
		 */
		vma->vm_flags = new_flags;
		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;

	skip:
		prev = vma;
		start = vma->vm_end;
		vma = vma->vm_next;
	} while (vma && vma->vm_start < end);
out_unlock:
	up_write(&mm->mmap_sem);
	mmput(mm);
out:
	return ret;
}","static int userfaultfd_unregister(struct userfaultfd_ctx *VAR_0,
				  unsigned long VAR_1)
{
	struct mm_struct *VAR_2 = VAR_0->mm;
	struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
	int VAR_6;
	struct uffdio_range VAR_7;
	unsigned long VAR_8;
	bool VAR_9;
	unsigned long VAR_10, VAR_11, VAR_12;
	const void __user *VAR_13 = (void __user *)VAR_1;

	VAR_6 = -VAR_14;
	if (copy_from_user(&VAR_7, VAR_13, sizeof(VAR_7)))
		goto out;

	VAR_6 = validate_range(VAR_2, VAR_7.start,
			     VAR_7.len);
	if (VAR_6)
		goto out;

	VAR_10 = VAR_7.start;
	VAR_11 = VAR_10 + VAR_7.len;

	VAR_6 = -VAR_15;
	if (!mmget_not_zero(VAR_2))
		goto out;

	down_write(&VAR_2->mmap_sem);
	VAR_3 = find_vma_prev(VAR_2, VAR_10, &VAR_4);
	if (!VAR_3)
		goto out_unlock;

	/* COMMENT_0 */
	VAR_6 = -VAR_16;
	if (VAR_3->vm_start >= VAR_11)
		goto out_unlock;

	/* COMMENT_1 */
                                                                 
                                 
    
	if (is_vm_hugetlb_page(VAR_3)) {
		unsigned long VAR_17 = vma_kernel_pagesize(VAR_3);

		if (VAR_10 & (VAR_17 - 1))
			goto out_unlock;
	}

	/* COMMENT_5 */
                                   
    
	VAR_9 = false;
	VAR_6 = -VAR_16;
	for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_11; VAR_5 = VAR_5->vm_next) {
		cond_resched();

		BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
		       !!(VAR_5->vm_flags & (VAR_18 | VAR_19)));

		/* COMMENT_8 */
                                                     
                                               
                                                 
                                                
                           
     
		if (!vma_can_userfault(VAR_5))
			goto out_unlock;

		VAR_9 = true;
	}
	BUG_ON(!VAR_9);

	if (VAR_3->vm_start < VAR_10)
		VAR_4 = VAR_3;

	VAR_6 = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(VAR_3));
		WARN_ON(!(VAR_3->vm_flags & VAR_20));

		/* COMMENT_15 */
                                                            
                                                      
     
		if (!VAR_3->vm_userfaultfd_ctx.ctx)
			goto skip;

		if (VAR_3->vm_start > VAR_10)
			VAR_10 = VAR_3->vm_start;
		VAR_12 = min(VAR_11, VAR_3->vm_end);

		if (userfaultfd_missing(VAR_3)) {
			/* COMMENT_19 */
                                                 
                                          
                                                
                             
      
			struct userfaultfd_wake_range VAR_21;
			VAR_21.start = VAR_10;
			VAR_21.len = VAR_12 - VAR_10;
			wake_userfault(VAR_3->vm_userfaultfd_ctx.ctx, &VAR_21);
		}

		VAR_8 = VAR_3->vm_flags & ~(VAR_18 | VAR_19);
		VAR_4 = vma_merge(VAR_2, VAR_4, VAR_10, VAR_12, VAR_8,
				 VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
				 vma_policy(VAR_3),
				 VAR_22);
		if (VAR_4) {
			VAR_3 = VAR_4;
			goto next;
		}
		if (VAR_3->vm_start < VAR_10) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_10, 1);
			if (VAR_6)
				break;
		}
		if (VAR_3->vm_end > VAR_11) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_11, 0);
			if (VAR_6)
				break;
		}
	next:
		/* COMMENT_25 */
                                                        
                                                     
                                              
     
		VAR_3->vm_flags = VAR_8;
		VAR_3->vm_userfaultfd_ctx = VAR_22;

	skip:
		VAR_4 = VAR_3;
		VAR_10 = VAR_3->vm_end;
		VAR_3 = VAR_3->vm_next;
	} while (VAR_3 && VAR_3->vm_start < VAR_11);
out_unlock:
	up_write(&VAR_2->mmap_sem);
	mmput(VAR_2);
out:
	return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -80,6 +80,7 @@
 		cond_resched();
 
 		BUG_ON(!vma_can_userfault(vma));
+		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this","{'deleted_lines': [], 'added_lines': ['\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));']}",True,"The userfaultfd implementation in the Linux kernel before 4.19.7 mishandles access control for certain UFFDIO_ ioctl calls, as demonstrated by allowing local users to write data into holes in a tmpfs file (if the user has read-only access to that file, and that file contains holes), related to fs/userfaultfd.c and mm/userfaultfd.c.",5.5,MEDIUM,1,valid,2018-11-30T22:09:32Z,2
CVE-2018-18397,['CWE-863'],AV:L/AC:L/Au:N/C:N/I:P/A:N,0,torvalds/linux,"userfaultfd: shmem/hugetlbfs: only allow to register VM_MAYWRITE vmas

After the VMA to register the uffd onto is found, check that it has
VM_MAYWRITE set before allowing registration.  This way we inherit all
common code checks before allowing to fill file holes in shmem and
hugetlbfs with UFFDIO_COPY.

The userfaultfd memory model is not applicable for readonly files unless
it's a MAP_PRIVATE.

Link: http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com
Fixes: ff62a3421044 (""hugetlb: implement memfd sealing"")
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
Reviewed-by: Hugh Dickins <hughd@google.com>
Reported-by: Jann Horn <jannh@google.com>
Fixes: 4c27fe4c4c84 (""userfaultfd: shmem: add shmem_mcopy_atomic_pte for userfaultfd support"")
Cc: <stable@vger.kernel.org>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: Mike Kravetz <mike.kravetz@oracle.com>
Cc: Peter Xu <peterx@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",29ec90660d68bbdd69507c1c8b4e33aa299278b1,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,mm/userfaultfd.c,userfaultfd_register,"static int userfaultfd_register(struct userfaultfd_ctx *ctx,
unsigned long arg)
{
struct mm_struct *mm = ctx->mm;
struct vm_area_struct *vma, *prev, *cur;
int ret;
struct uffdio_register uffdio_register;
struct uffdio_register __user *user_uffdio_register;
unsigned long vm_flags, new_flags;
bool found;
bool basic_ioctls;
unsigned long start, end, vma_end;
user_uffdio_register = (struct uffdio_register __user *) arg;
ret = -EFAULT;
if (copy_from_user(&uffdio_register, user_uffdio_register,
sizeof(uffdio_register)-sizeof(__u64)))
goto out;
ret = -EINVAL;
if (!uffdio_register.mode)
goto out;
if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|
UFFDIO_REGISTER_MODE_WP))
goto out;
vm_flags = 0;
if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)
vm_flags |= VM_UFFD_MISSING;
if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {
vm_flags |= VM_UFFD_WP;
ret = -EINVAL;
goto out;
}
ret = validate_range(mm, uffdio_register.range.start,
uffdio_register.range.len);
if (ret)
goto out;
start = uffdio_register.range.start;
end = start + uffdio_register.range.len;
ret = -ENOMEM;
if (!mmget_not_zero(mm))
goto out;
down_write(&mm->mmap_sem);
vma = find_vma_prev(mm, start, &prev);
if (!vma)
goto out_unlock;
ret = -EINVAL;
if (vma->vm_start >= end)
goto out_unlock;
if (is_vm_hugetlb_page(vma)) {
unsigned long vma_hpagesize = vma_kernel_pagesize(vma);
if (start & (vma_hpagesize - 1))
goto out_unlock;
}
found = false;
basic_ioctls = false;
for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
cond_resched();
BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));
ret = -EINVAL;
if (!vma_can_userfault(cur))
goto out_unlock;
if (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&
end > cur->vm_start) {
unsigned long vma_hpagesize = vma_kernel_pagesize(cur);
ret = -EINVAL;
if (end & (vma_hpagesize - 1))
goto out_unlock;
}
ret = -EBUSY;
if (cur->vm_userfaultfd_ctx.ctx &&
cur->vm_userfaultfd_ctx.ctx != ctx)
goto out_unlock;
if (is_vm_hugetlb_page(cur))
basic_ioctls = true;
found = true;
}
BUG_ON(!found);
if (vma->vm_start < start)
prev = vma;
ret = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(vma));
BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
vma->vm_userfaultfd_ctx.ctx != ctx);
if (vma->vm_userfaultfd_ctx.ctx == ctx &&
(vma->vm_flags & vm_flags) == vm_flags)
goto skip;
if (vma->vm_start > start)
start = vma->vm_start;
vma_end = min(end, vma->vm_end);
new_flags = (vma->vm_flags & ~vm_flags) | vm_flags;
prev = vma_merge(mm, prev, start, vma_end, new_flags,
vma->anon_vma, vma->vm_file, vma->vm_pgoff,
vma_policy(vma),
((struct vm_userfaultfd_ctx){ ctx }));
if (prev) {
vma = prev;
goto next;
}
if (vma->vm_start < start) {
ret = split_vma(mm, vma, start, 1);
if (ret)
break;
}
if (vma->vm_end > end) {
ret = split_vma(mm, vma, end, 0);
if (ret)
break;
}
next:
vma->vm_flags = new_flags;
vma->vm_userfaultfd_ctx.ctx = ctx;
skip:
prev = vma;
start = vma->vm_end;
vma = vma->vm_next;
} while (vma && vma->vm_start < end);
out_unlock:
up_write(&mm->mmap_sem);
mmput(mm);
if (!ret) {
if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :
UFFD_API_RANGE_IOCTLS,
&user_uffdio_register->ioctls))
ret = -EFAULT;
}
out:
return ret;
}","static int userfaultfd_register(struct userfaultfd_ctx *VAR_0,
unsigned long VAR_1)
{
struct mm_struct *VAR_2 = VAR_0->mm;
struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
int VAR_6;
struct uffdio_register uffdio_register;
struct uffdio_register __user *VAR_7;
unsigned long VAR_8, VAR_9;
bool VAR_10;
bool VAR_11;
unsigned long VAR_12, VAR_13, VAR_14;
VAR_7 = (struct uffdio_register __user *) VAR_1;
VAR_6 = -VAR_15;
if (copy_from_user(&uffdio_register, VAR_7,
sizeof(uffdio_register)-sizeof(VAR_16)))
goto out;
VAR_6 = -VAR_17;
if (!uffdio_register.mode)
goto out;
if (uffdio_register.mode & ~(VAR_18|
VAR_19))
goto out;
VAR_8 = 0;
if (uffdio_register.mode & VAR_18)
VAR_8 |= VAR_20;
if (uffdio_register.mode & VAR_19) {
VAR_8 |= VAR_21;
VAR_6 = -VAR_17;
goto out;
}
VAR_6 = validate_range(VAR_2, uffdio_register.range.start,
uffdio_register.range.len);
if (VAR_6)
goto out;
VAR_12 = uffdio_register.range.start;
VAR_13 = VAR_12 + uffdio_register.range.len;
VAR_6 = -VAR_22;
if (!mmget_not_zero(VAR_2))
goto out;
down_write(&VAR_2->mmap_sem);
VAR_3 = find_vma_prev(VAR_2, VAR_12, &VAR_4);
if (!VAR_3)
goto out_unlock;
VAR_6 = -VAR_17;
if (VAR_3->vm_start >= VAR_13)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_3)) {
unsigned long VAR_23 = vma_kernel_pagesize(VAR_3);
if (VAR_12 & (VAR_23 - 1))
goto out_unlock;
}
VAR_10 = false;
VAR_11 = false;
for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_13; VAR_5 = VAR_5->vm_next) {
cond_resched();
BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
!!(VAR_5->vm_flags & (VAR_20 | VAR_21)));
VAR_6 = -VAR_17;
if (!vma_can_userfault(VAR_5))
goto out_unlock;
if (is_vm_hugetlb_page(VAR_5) && VAR_13 <= VAR_5->vm_end &&
VAR_13 > VAR_5->vm_start) {
unsigned long VAR_23 = vma_kernel_pagesize(VAR_5);
VAR_6 = -VAR_17;
if (VAR_13 & (VAR_23 - 1))
goto out_unlock;
}
VAR_6 = -VAR_24;
if (VAR_5->vm_userfaultfd_ctx.ctx &&
VAR_5->vm_userfaultfd_ctx.ctx != VAR_0)
goto out_unlock;
if (is_vm_hugetlb_page(VAR_5))
VAR_11 = true;
VAR_10 = true;
}
BUG_ON(!VAR_10);
if (VAR_3->vm_start < VAR_12)
VAR_4 = VAR_3;
VAR_6 = 0;
do {
cond_resched();
BUG_ON(!vma_can_userfault(VAR_3));
BUG_ON(VAR_3->vm_userfaultfd_ctx.ctx &&
VAR_3->vm_userfaultfd_ctx.ctx != VAR_0);
if (VAR_3->vm_userfaultfd_ctx.ctx == VAR_0 &&
(VAR_3->vm_flags & VAR_8) == VAR_8)
goto skip;
if (VAR_3->vm_start > VAR_12)
VAR_12 = VAR_3->vm_start;
VAR_14 = min(VAR_13, VAR_3->vm_end);
VAR_9 = (VAR_3->vm_flags & ~VAR_8) | VAR_8;
VAR_4 = vma_merge(VAR_2, VAR_4, VAR_12, VAR_14, VAR_9,
VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
vma_policy(VAR_3),
((struct vm_userfaultfd_ctx){ VAR_0 }));
if (VAR_4) {
VAR_3 = VAR_4;
goto next;
}
if (VAR_3->vm_start < VAR_12) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_12, 1);
if (VAR_6)
break;
}
if (VAR_3->vm_end > VAR_13) {
VAR_6 = split_vma(VAR_2, VAR_3, VAR_13, 0);
if (VAR_6)
break;
}
next:
VAR_3->vm_flags = VAR_9;
VAR_3->vm_userfaultfd_ctx.ctx = VAR_0;
skip:
VAR_4 = VAR_3;
VAR_12 = VAR_3->vm_end;
VAR_3 = VAR_3->vm_next;
} while (VAR_3 && VAR_3->vm_start < VAR_13);
out_unlock:
up_write(&VAR_2->mmap_sem);
mmput(VAR_2);
if (!VAR_6) {
if (put_user(VAR_11 ? VAR_25 :
VAR_26,
&VAR_7->ioctls))
VAR_6 = -VAR_15;
}
out:
return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/before/0.json,"static int userfaultfd_register(struct userfaultfd_ctx *ctx,
				unsigned long arg)
{
	struct mm_struct *mm = ctx->mm;
	struct vm_area_struct *vma, *prev, *cur;
	int ret;
	struct uffdio_register uffdio_register;
	struct uffdio_register __user *user_uffdio_register;
	unsigned long vm_flags, new_flags;
	bool found;
	bool basic_ioctls;
	unsigned long start, end, vma_end;

	user_uffdio_register = (struct uffdio_register __user *) arg;

	ret = -EFAULT;
	if (copy_from_user(&uffdio_register, user_uffdio_register,
			   sizeof(uffdio_register)-sizeof(__u64)))
		goto out;

	ret = -EINVAL;
	if (!uffdio_register.mode)
		goto out;
	if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|
				     UFFDIO_REGISTER_MODE_WP))
		goto out;
	vm_flags = 0;
	if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)
		vm_flags |= VM_UFFD_MISSING;
	if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {
		vm_flags |= VM_UFFD_WP;
		/*
		 * FIXME: remove the below error constraint by
		 * implementing the wprotect tracking mode.
		 */
		ret = -EINVAL;
		goto out;
	}

	ret = validate_range(mm, uffdio_register.range.start,
			     uffdio_register.range.len);
	if (ret)
		goto out;

	start = uffdio_register.range.start;
	end = start + uffdio_register.range.len;

	ret = -ENOMEM;
	if (!mmget_not_zero(mm))
		goto out;

	down_write(&mm->mmap_sem);
	vma = find_vma_prev(mm, start, &prev);
	if (!vma)
		goto out_unlock;

	/* check that there's at least one vma in the range */
	ret = -EINVAL;
	if (vma->vm_start >= end)
		goto out_unlock;

	/*
	 * If the first vma contains huge pages, make sure start address
	 * is aligned to huge page size.
	 */
	if (is_vm_hugetlb_page(vma)) {
		unsigned long vma_hpagesize = vma_kernel_pagesize(vma);

		if (start & (vma_hpagesize - 1))
			goto out_unlock;
	}

	/*
	 * Search for not compatible vmas.
	 */
	found = false;
	basic_ioctls = false;
	for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
		cond_resched();

		BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
		       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));

		/* check not compatible vmas */
		ret = -EINVAL;
		if (!vma_can_userfault(cur))
			goto out_unlock;

		/*
		 * UFFDIO_COPY will fill file holes even without
		 * PROT_WRITE. This check enforces that if this is a
		 * MAP_SHARED, the process has write permission to the backing
		 * file. If VM_MAYWRITE is set it also enforces that on a
		 * MAP_SHARED vma: there is no F_WRITE_SEAL and no further
		 * F_WRITE_SEAL can be taken until the vma is destroyed.
		 */
		ret = -EPERM;
		if (unlikely(!(cur->vm_flags & VM_MAYWRITE)))
			goto out_unlock;

		/*
		 * If this vma contains ending address, and huge pages
		 * check alignment.
		 */
		if (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&
		    end > cur->vm_start) {
			unsigned long vma_hpagesize = vma_kernel_pagesize(cur);

			ret = -EINVAL;

			if (end & (vma_hpagesize - 1))
				goto out_unlock;
		}

		/*
		 * Check that this vma isn't already owned by a
		 * different userfaultfd. We can't allow more than one
		 * userfaultfd to own a single vma simultaneously or we
		 * wouldn't know which one to deliver the userfaults to.
		 */
		ret = -EBUSY;
		if (cur->vm_userfaultfd_ctx.ctx &&
		    cur->vm_userfaultfd_ctx.ctx != ctx)
			goto out_unlock;

		/*
		 * Note vmas containing huge pages
		 */
		if (is_vm_hugetlb_page(cur))
			basic_ioctls = true;

		found = true;
	}
	BUG_ON(!found);

	if (vma->vm_start < start)
		prev = vma;

	ret = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(vma));
		BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
		       vma->vm_userfaultfd_ctx.ctx != ctx);
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));

		/*
		 * Nothing to do: this vma is already registered into this
		 * userfaultfd and with the right tracking mode too.
		 */
		if (vma->vm_userfaultfd_ctx.ctx == ctx &&
		    (vma->vm_flags & vm_flags) == vm_flags)
			goto skip;

		if (vma->vm_start > start)
			start = vma->vm_start;
		vma_end = min(end, vma->vm_end);

		new_flags = (vma->vm_flags & ~vm_flags) | vm_flags;
		prev = vma_merge(mm, prev, start, vma_end, new_flags,
				 vma->anon_vma, vma->vm_file, vma->vm_pgoff,
				 vma_policy(vma),
				 ((struct vm_userfaultfd_ctx){ ctx }));
		if (prev) {
			vma = prev;
			goto next;
		}
		if (vma->vm_start < start) {
			ret = split_vma(mm, vma, start, 1);
			if (ret)
				break;
		}
		if (vma->vm_end > end) {
			ret = split_vma(mm, vma, end, 0);
			if (ret)
				break;
		}
	next:
		/*
		 * In the vma_merge() successful mprotect-like case 8:
		 * the next vma was merged into the current one and
		 * the current one has not been updated yet.
		 */
		vma->vm_flags = new_flags;
		vma->vm_userfaultfd_ctx.ctx = ctx;

	skip:
		prev = vma;
		start = vma->vm_end;
		vma = vma->vm_next;
	} while (vma && vma->vm_start < end);
out_unlock:
	up_write(&mm->mmap_sem);
	mmput(mm);
	if (!ret) {
		/*
		 * Now that we scanned all vmas we can already tell
		 * userland which ioctls methods are guaranteed to
		 * succeed on this range.
		 */
		if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :
			     UFFD_API_RANGE_IOCTLS,
			     &user_uffdio_register->ioctls))
			ret = -EFAULT;
	}
out:
	return ret;
}","static int userfaultfd_register(struct userfaultfd_ctx *VAR_0,
				unsigned long VAR_1)
{
	struct mm_struct *VAR_2 = VAR_0->mm;
	struct vm_area_struct *VAR_3, *VAR_4, *VAR_5;
	int VAR_6;
	struct uffdio_register uffdio_register;
	struct uffdio_register __user *VAR_7;
	unsigned long VAR_8, VAR_9;
	bool VAR_10;
	bool VAR_11;
	unsigned long VAR_12, VAR_13, VAR_14;

	VAR_7 = (struct uffdio_register __user *) VAR_1;

	VAR_6 = -VAR_15;
	if (copy_from_user(&uffdio_register, VAR_7,
			   sizeof(uffdio_register)-sizeof(VAR_16)))
		goto out;

	VAR_6 = -VAR_17;
	if (!uffdio_register.mode)
		goto out;
	if (uffdio_register.mode & ~(VAR_18|
				     VAR_19))
		goto out;
	VAR_8 = 0;
	if (uffdio_register.mode & VAR_18)
		VAR_8 |= VAR_20;
	if (uffdio_register.mode & VAR_19) {
		VAR_8 |= VAR_21;
		/* COMMENT_0 */
                                                
                                             
     
		VAR_6 = -VAR_17;
		goto out;
	}

	VAR_6 = validate_range(VAR_2, uffdio_register.range.start,
			     uffdio_register.range.len);
	if (VAR_6)
		goto out;

	VAR_12 = uffdio_register.range.start;
	VAR_13 = VAR_12 + uffdio_register.range.len;

	VAR_6 = -VAR_22;
	if (!mmget_not_zero(VAR_2))
		goto out;

	down_write(&VAR_2->mmap_sem);
	VAR_3 = find_vma_prev(VAR_2, VAR_12, &VAR_4);
	if (!VAR_3)
		goto out_unlock;

	/* COMMENT_4 */
	VAR_6 = -VAR_17;
	if (VAR_3->vm_start >= VAR_13)
		goto out_unlock;

	/* COMMENT_5 */
                                                                 
                                 
    
	if (is_vm_hugetlb_page(VAR_3)) {
		unsigned long VAR_23 = vma_kernel_pagesize(VAR_3);

		if (VAR_12 & (VAR_23 - 1))
			goto out_unlock;
	}

	/* COMMENT_9 */
                                   
    
	VAR_10 = false;
	VAR_11 = false;
	for (VAR_5 = VAR_3; VAR_5 && VAR_5->vm_start < VAR_13; VAR_5 = VAR_5->vm_next) {
		cond_resched();

		BUG_ON(!!VAR_5->vm_userfaultfd_ctx.ctx ^
		       !!(VAR_5->vm_flags & (VAR_20 | VAR_21)));

		/* COMMENT_12 */
		VAR_6 = -VAR_17;
		if (!vma_can_userfault(VAR_5))
			goto out_unlock;

		/* COMMENT_13 */
                                                  
                                                      
                                                                
                                                           
                                                            
                                                          
     
		VAR_6 = -VAR_24;
		if (unlikely(!(VAR_5->vm_flags & VAR_25)))
			goto out_unlock;

		/* COMMENT_21 */
                                                        
                     
     
		if (is_vm_hugetlb_page(VAR_5) && VAR_13 <= VAR_5->vm_end &&
		    VAR_13 > VAR_5->vm_start) {
			unsigned long VAR_23 = vma_kernel_pagesize(VAR_5);

			VAR_6 = -VAR_17;

			if (VAR_13 & (VAR_23 - 1))
				goto out_unlock;
		}

		/* COMMENT_25 */
                                                 
                                                        
                                                         
                                                          
     
		VAR_6 = -VAR_26;
		if (VAR_5->vm_userfaultfd_ctx.ctx &&
		    VAR_5->vm_userfaultfd_ctx.ctx != VAR_0)
			goto out_unlock;

		/* COMMENT_31 */
                                    
     
		if (is_vm_hugetlb_page(VAR_5))
			VAR_11 = true;

		VAR_10 = true;
	}
	BUG_ON(!VAR_10);

	if (VAR_3->vm_start < VAR_12)
		VAR_4 = VAR_3;

	VAR_6 = 0;
	do {
		cond_resched();

		BUG_ON(!vma_can_userfault(VAR_3));
		BUG_ON(VAR_3->vm_userfaultfd_ctx.ctx &&
		       VAR_3->vm_userfaultfd_ctx.ctx != VAR_0);
		WARN_ON(!(VAR_3->vm_flags & VAR_25));

		/* COMMENT_34 */
                                                            
                                                      
     
		if (VAR_3->vm_userfaultfd_ctx.ctx == VAR_0 &&
		    (VAR_3->vm_flags & VAR_8) == VAR_8)
			goto skip;

		if (VAR_3->vm_start > VAR_12)
			VAR_12 = VAR_3->vm_start;
		VAR_14 = min(VAR_13, VAR_3->vm_end);

		VAR_9 = (VAR_3->vm_flags & ~VAR_8) | VAR_8;
		VAR_4 = vma_merge(VAR_2, VAR_4, VAR_12, VAR_14, VAR_9,
				 VAR_3->anon_vma, VAR_3->vm_file, VAR_3->vm_pgoff,
				 vma_policy(VAR_3),
				 ((struct vm_userfaultfd_ctx){ VAR_0 }));
		if (VAR_4) {
			VAR_3 = VAR_4;
			goto next;
		}
		if (VAR_3->vm_start < VAR_12) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_12, 1);
			if (VAR_6)
				break;
		}
		if (VAR_3->vm_end > VAR_13) {
			VAR_6 = split_vma(VAR_2, VAR_3, VAR_13, 0);
			if (VAR_6)
				break;
		}
	next:
		/* COMMENT_38 */
                                                        
                                                     
                                              
     
		VAR_3->vm_flags = VAR_9;
		VAR_3->vm_userfaultfd_ctx.ctx = VAR_0;

	skip:
		VAR_4 = VAR_3;
		VAR_12 = VAR_3->vm_end;
		VAR_3 = VAR_3->vm_next;
	} while (VAR_3 && VAR_3->vm_start < VAR_13);
out_unlock:
	up_write(&VAR_2->mmap_sem);
	mmput(VAR_2);
	if (!VAR_6) {
		/* COMMENT_43 */
                                                     
                                                    
                           
     
		if (put_user(VAR_11 ? VAR_27 :
			     VAR_28,
			     &VAR_7->ioctls))
			VAR_6 = -VAR_15;
	}
out:
	return VAR_6;
}",torvalds/linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1/userfaultfd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -85,6 +85,19 @@
 		ret = -EINVAL;
 		if (!vma_can_userfault(cur))
 			goto out_unlock;
+
+		/*
+		 * UFFDIO_COPY will fill file holes even without
+		 * PROT_WRITE. This check enforces that if this is a
+		 * MAP_SHARED, the process has write permission to the backing
+		 * file. If VM_MAYWRITE is set it also enforces that on a
+		 * MAP_SHARED vma: there is no F_WRITE_SEAL and no further
+		 * F_WRITE_SEAL can be taken until the vma is destroyed.
+		 */
+		ret = -EPERM;
+		if (unlikely(!(cur->vm_flags & VM_MAYWRITE)))
+			goto out_unlock;
+
 		/*
 		 * If this vma contains ending address, and huge pages
 		 * check alignment.
@@ -130,6 +143,7 @@
 		BUG_ON(!vma_can_userfault(vma));
 		BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
 		       vma->vm_userfaultfd_ctx.ctx != ctx);
+		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this","{'deleted_lines': [], 'added_lines': ['', '\t\t/*', '\t\t * UFFDIO_COPY will fill file holes even without', '\t\t * PROT_WRITE. This check enforces that if this is a', '\t\t * MAP_SHARED, the process has write permission to the backing', '\t\t * file. If VM_MAYWRITE is set it also enforces that on a', '\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further', '\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.', '\t\t */', '\t\tret = -EPERM;', '\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))', '\t\t\tgoto out_unlock;', '', '\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));']}",True,"The userfaultfd implementation in the Linux kernel before 4.19.7 mishandles access control for certain UFFDIO_ ioctl calls, as demonstrated by allowing local users to write data into holes in a tmpfs file (if the user has read-only access to that file, and that file contains holes), related to fs/userfaultfd.c and mm/userfaultfd.c.",5.5,MEDIUM,1,valid,2018-11-30T22:09:32Z,2
CVE-2018-20217,['CWE-617'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,krb5,"Ignore password attributes for S4U2Self requests

For consistency with Windows KDCs, allow protocol transition to work
even if the password has expired or needs changing.

Also, when looking up an enterprise principal with an AS request,
treat ERR_KEY_EXP as confirmation that the client is present in the
realm.

[ghudson@mit.edu: added comment in kdc_process_s4u2self_req(); edited
commit message]

ticket: 8763 (new)
tags: pullup
target_version: 1.17",5e6d1796106df8ba6bc1973ee0917c170d929086,https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086,src/kdc/kdc_util.c,kdc_process_s4u2self_req,"krb5_error_code
kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,
krb5_kdc_req *request,
krb5_const_principal client_princ,
krb5_const_principal header_srv_princ,
krb5_boolean issuing_referral,
const krb5_db_entry *server,
krb5_keyblock *tgs_subkey,
krb5_keyblock *tgs_session,
krb5_timestamp kdc_time,
krb5_pa_s4u_x509_user **s4u_x509_user,
krb5_db_entry **princ_ptr,
const char **status)
{
krb5_error_code             code;
krb5_boolean                is_local_tgt;
krb5_pa_data                *pa_data;
int                         flags;
krb5_db_entry               *princ;
*princ_ptr = NULL;
pa_data = krb5int_find_pa_data(kdc_context,
request->padata, KRB5_PADATA_S4U_X509_USER);
if (pa_data != NULL) {
code = kdc_process_s4u_x509_user(kdc_context,
request,
pa_data,
tgs_subkey,
tgs_session,
s4u_x509_user,
status);
if (code != 0)
return code;
} else {
pa_data = krb5int_find_pa_data(kdc_context,
request->padata, KRB5_PADATA_FOR_USER);
if (pa_data != NULL) {
code = kdc_process_for_user(kdc_active_realm,
pa_data,
tgs_session,
s4u_x509_user,
status);
if (code != 0)
return code;
} else
return 0;
}
flags = 0;
switch (krb5_princ_type(kdc_context, request->server)) {
case KRB5_NT_SRV_HST:                   
if (krb5_princ_size(kdc_context, request->server) == 2)
flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;
break;
case KRB5_NT_ENTERPRISE_PRINCIPAL:      
flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;
break;
default:                                
break;
}
if (!krb5_principal_compare_flags(kdc_context,
request->server,
client_princ,
flags)) {
*status = ""INVALID_S4U2SELF_REQUEST"";
return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; 
}
if (request->kdc_options & AS_INVALID_OPTIONS) {
*status = ""INVALID AS OPTIONS"";
return KRB5KDC_ERR_BADOPTION;
}
is_local_tgt = !is_cross_tgs_principal(header_srv_princ);
if (is_local_tgt && issuing_referral) {
*status = ""LOOKING_UP_SERVER"";
return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
}
if (is_local_principal(kdc_active_realm,
(*s4u_x509_user)->user_id.user)) {
krb5_db_entry no_server;
krb5_pa_data **e_data = NULL;
if (!is_local_tgt && !issuing_referral) {
*status = ""NOT_CROSS_REALM_REQUEST"";
return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; 
}
code = krb5_db_get_principal(kdc_context,
(*s4u_x509_user)->user_id.user,
KRB5_KDB_FLAG_INCLUDE_PAC, &princ);
if (code == KRB5_KDB_NOENTRY) {
*status = ""UNKNOWN_S4U2SELF_PRINCIPAL"";
return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
} else if (code) {
*status = ""LOOKING_UP_S4U2SELF_PRINCIPAL"";
return code; 
}
memset(&no_server, 0, sizeof(no_server));
code = validate_as_request(kdc_active_realm, request, *princ,
no_server, kdc_time, status, &e_data);
if (code) {
krb5_db_free_principal(kdc_context, princ);
krb5_free_pa_data(kdc_context, e_data);
return code;
}
*princ_ptr = princ;
} else if (is_local_tgt) {
*status = ""S4U2SELF_CLIENT_NOT_OURS"";
return KRB5KDC_ERR_POLICY; 
}
return 0;
}","krb5_error_code
kdc_process_s4u2self_req(kdc_realm_t *VAR_0,
krb5_kdc_req *VAR_1,
krb5_const_principal VAR_2,
krb5_const_principal VAR_3,
krb5_boolean VAR_4,
const krb5_db_entry *VAR_5,
krb5_keyblock *VAR_6,
krb5_keyblock *VAR_7,
krb5_timestamp VAR_8,
krb5_pa_s4u_x509_user **VAR_9,
krb5_db_entry **VAR_10,
const char **VAR_11)
{
krb5_error_code             VAR_12;
krb5_boolean                VAR_13;
krb5_pa_data                *VAR_14;
int                         VAR_15;
krb5_db_entry               *VAR_16;
*VAR_10 = NULL;
VAR_14 = krb5int_find_pa_data(VAR_17,
VAR_1->padata, VAR_18);
if (VAR_14 != NULL) {
VAR_12 = kdc_process_s4u_x509_user(VAR_17,
VAR_1,
VAR_14,
VAR_6,
VAR_7,
VAR_9,
VAR_11);
if (VAR_12 != 0)
return VAR_12;
} else {
VAR_14 = krb5int_find_pa_data(VAR_17,
VAR_1->padata, VAR_19);
if (VAR_14 != NULL) {
VAR_12 = kdc_process_for_user(VAR_0,
VAR_14,
VAR_7,
VAR_9,
VAR_11);
if (VAR_12 != 0)
return VAR_12;
} else
return 0;
}
VAR_15 = 0;
switch (krb5_princ_type(VAR_17, VAR_1->server)) {
case VAR_20:                   
if (krb5_princ_size(VAR_17, VAR_1->server) == 2)
VAR_15 |= VAR_21;
break;
case VAR_22:      
VAR_15 |= VAR_23;
break;
default:                                
break;
}
if (!krb5_principal_compare_flags(VAR_17,
VAR_1->server,
VAR_2,
VAR_15)) {
*VAR_11 = ""INVALID_S4U2SELF_REQUEST"";
return VAR_24; 
}
if (VAR_1->kdc_options & VAR_25) {
*VAR_11 = ""INVALID AS OPTIONS"";
return VAR_26;
}
VAR_13 = !is_cross_tgs_principal(VAR_3);
if (VAR_13 && VAR_4) {
*VAR_11 = ""LOOKING_UP_SERVER"";
return VAR_27;
}
if (is_local_principal(VAR_0,
(*VAR_9)->user_id.user)) {
krb5_db_entry VAR_28;
krb5_pa_data **VAR_29 = NULL;
if (!VAR_13 && !VAR_4) {
*VAR_11 = ""NOT_CROSS_REALM_REQUEST"";
return VAR_24; 
}
VAR_12 = krb5_db_get_principal(VAR_17,
(*VAR_9)->user_id.user,
VAR_30, &VAR_16);
if (VAR_12 == VAR_31) {
*VAR_11 = ""UNKNOWN_S4U2SELF_PRINCIPAL"";
return VAR_24;
} else if (VAR_12) {
*VAR_11 = ""LOOKING_UP_S4U2SELF_PRINCIPAL"";
return VAR_12; 
}
memset(&VAR_28, 0, sizeof(VAR_28));
VAR_12 = validate_as_request(VAR_0, VAR_1, *VAR_16,
VAR_28, VAR_8, VAR_11, &VAR_29);
if (VAR_12) {
krb5_db_free_principal(VAR_17, VAR_16);
krb5_free_pa_data(VAR_17, VAR_29);
return VAR_12;
}
*VAR_10 = VAR_16;
} else if (VAR_13) {
*VAR_11 = ""S4U2SELF_CLIENT_NOT_OURS"";
return VAR_32; 
}
return 0;
}",krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/kdc_util.c/vul/before/0.json,"krb5_error_code
kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,
                         krb5_kdc_req *request,
                         krb5_const_principal client_princ,
                         krb5_const_principal header_srv_princ,
                         krb5_boolean issuing_referral,
                         const krb5_db_entry *server,
                         krb5_keyblock *tgs_subkey,
                         krb5_keyblock *tgs_session,
                         krb5_timestamp kdc_time,
                         krb5_pa_s4u_x509_user **s4u_x509_user,
                         krb5_db_entry **princ_ptr,
                         const char **status)
{
    krb5_error_code             code;
    krb5_boolean                is_local_tgt;
    krb5_pa_data                *pa_data;
    int                         flags;
    krb5_db_entry               *princ;

    *princ_ptr = NULL;

    pa_data = krb5int_find_pa_data(kdc_context,
                                   request->padata, KRB5_PADATA_S4U_X509_USER);
    if (pa_data != NULL) {
        code = kdc_process_s4u_x509_user(kdc_context,
                                         request,
                                         pa_data,
                                         tgs_subkey,
                                         tgs_session,
                                         s4u_x509_user,
                                         status);
        if (code != 0)
            return code;
    } else {
        pa_data = krb5int_find_pa_data(kdc_context,
                                       request->padata, KRB5_PADATA_FOR_USER);
        if (pa_data != NULL) {
            code = kdc_process_for_user(kdc_active_realm,
                                        pa_data,
                                        tgs_session,
                                        s4u_x509_user,
                                        status);
            if (code != 0)
                return code;
        } else
            return 0;
    }

    /*
     * We need to compare the client name in the TGT with the requested
     * server name. Supporting server name aliases without assuming a
     * global name service makes this difficult to do.
     *
     * The comparison below handles the following cases (note that the
     * term ""principal name"" below excludes the realm).
     *
     * (1) The requested service is a host-based service with two name
     *     components, in which case we assume the principal name to
     *     contain sufficient qualifying information. The realm is
     *     ignored for the purpose of comparison.
     *
     * (2) The requested service name is an enterprise principal name:
     *     the service principal name is compared with the unparsed
     *     form of the client name (including its realm).
     *
     * (3) The requested service is some other name type: an exact
     *     match is required.
     *
     * An alternative would be to look up the server once again with
     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact
     * match between the returned name and client_princ. However, this
     * assumes that the client set FLAG_CANONICALIZE when requesting
     * the TGT and that we have a global name service.
     */
    flags = 0;
    switch (krb5_princ_type(kdc_context, request->server)) {
    case KRB5_NT_SRV_HST:                   /* (1) */
        if (krb5_princ_size(kdc_context, request->server) == 2)
            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;
        break;
    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */
        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;
        break;
    default:                                /* (3) */
        break;
    }

    if (!krb5_principal_compare_flags(kdc_context,
                                      request->server,
                                      client_princ,
                                      flags)) {
        *status = ""INVALID_S4U2SELF_REQUEST"";
        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */
    }

    /*
     * Protocol transition is mutually exclusive with renew/forward/etc
     * as well as user-to-user and constrained delegation. This check
     * is also made in validate_as_request().
     *
     * We can assert from this check that the header ticket was a TGT, as
     * that is validated previously in validate_tgs_request().
     */
    if (request->kdc_options & AS_INVALID_OPTIONS) {
        *status = ""INVALID AS OPTIONS"";
        return KRB5KDC_ERR_BADOPTION;
    }

    /*
     * Valid S4U2Self requests can occur in the following combinations:
     *
     * (1) local TGT, local user, local server
     * (2) cross TGT, local user, issuing referral
     * (3) cross TGT, non-local user, issuing referral
     * (4) cross TGT, non-local user, local server
     *
     * The first case is for a single-realm S4U2Self scenario; the second,
     * third, and fourth cases are for the initial, intermediate (if any), and
     * final cross-realm requests in a multi-realm scenario.
     */

    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);
    if (is_local_tgt && issuing_referral) {
        /* The requesting server appears to no longer exist, and we found
         * a referral instead.  Treat this as a server lookup failure. */
        *status = ""LOOKING_UP_SERVER"";
        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
    }

    /*
     * Do not attempt to lookup principals in foreign realms.
     */
    if (is_local_principal(kdc_active_realm,
                           (*s4u_x509_user)->user_id.user)) {
        krb5_db_entry no_server;
        krb5_pa_data **e_data = NULL;

        if (!is_local_tgt && !issuing_referral) {
            /* A local server should not need a cross-realm TGT to impersonate
             * a local principal. */
            *status = ""NOT_CROSS_REALM_REQUEST"";
            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */
        }

        code = krb5_db_get_principal(kdc_context,
                                     (*s4u_x509_user)->user_id.user,
                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);
        if (code == KRB5_KDB_NOENTRY) {
            *status = ""UNKNOWN_S4U2SELF_PRINCIPAL"";
            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
        } else if (code) {
            *status = ""LOOKING_UP_S4U2SELF_PRINCIPAL"";
            return code; /* caller can free for_user */
        }

        memset(&no_server, 0, sizeof(no_server));

        /* Ignore password expiration and needchange attributes (as Windows
         * does), since S4U2Self is not password authentication. */
        princ->pw_expiration = 0;
        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);

        code = validate_as_request(kdc_active_realm, request, *princ,
                                   no_server, kdc_time, status, &e_data);
        if (code) {
            krb5_db_free_principal(kdc_context, princ);
            krb5_free_pa_data(kdc_context, e_data);
            return code;
        }

        *princ_ptr = princ;
    } else if (is_local_tgt) {
        /*
         * The server is asking to impersonate a principal from another realm,
         * using a local TGT.  It should instead ask that principal's realm and
         * follow referrals back to us.
         */
        *status = ""S4U2SELF_CLIENT_NOT_OURS"";
        return KRB5KDC_ERR_POLICY; /* match Windows error */
    }

    return 0;
}","krb5_error_code
kdc_process_s4u2self_req(kdc_realm_t *VAR_0,
                         krb5_kdc_req *VAR_1,
                         krb5_const_principal VAR_2,
                         krb5_const_principal VAR_3,
                         krb5_boolean VAR_4,
                         const krb5_db_entry *VAR_5,
                         krb5_keyblock *VAR_6,
                         krb5_keyblock *VAR_7,
                         krb5_timestamp VAR_8,
                         krb5_pa_s4u_x509_user **VAR_9,
                         krb5_db_entry **VAR_10,
                         const char **VAR_11)
{
    krb5_error_code             VAR_12;
    krb5_boolean                VAR_13;
    krb5_pa_data                *VAR_14;
    int                         VAR_15;
    krb5_db_entry               *VAR_16;

    *VAR_10 = NULL;

    VAR_14 = krb5int_find_pa_data(VAR_17,
                                   VAR_1->padata, VAR_18);
    if (VAR_14 != NULL) {
        VAR_12 = kdc_process_s4u_x509_user(VAR_17,
                                         VAR_1,
                                         VAR_14,
                                         VAR_6,
                                         VAR_7,
                                         VAR_9,
                                         VAR_11);
        if (VAR_12 != 0)
            return VAR_12;
    } else {
        VAR_14 = krb5int_find_pa_data(VAR_17,
                                       VAR_1->padata, VAR_19);
        if (VAR_14 != NULL) {
            VAR_12 = kdc_process_for_user(VAR_0,
                                        VAR_14,
                                        VAR_7,
                                        VAR_9,
                                        VAR_11);
            if (VAR_12 != 0)
                return VAR_12;
        } else
            return 0;
    }

    /* COMMENT_0 */
                                                                       
                                                                     
                                                      
      
                                                                      
                                                       
      
                                                                      
                                                                    
                                                                  
                                                 
      
                                                                      
                                                                   
                                                         
      
                                                                  
                             
      
                                                                    
                                                                      
                                                                      
                                                                    
                                                      
       
    VAR_15 = 0;
    switch (krb5_princ_type(VAR_17, VAR_1->server)) {
    case VAR_20:                   /* COMMENT_22 */
        if (krb5_princ_size(VAR_17, VAR_1->server) == 2)
            VAR_15 |= VAR_21;
        break;
    case VAR_22:      /* COMMENT_23 */
        VAR_15 |= VAR_23;
        break;
    default:                                /* COMMENT_24 */
        break;
    }

    if (!krb5_principal_compare_flags(VAR_17,
                                      VAR_1->server,
                                      VAR_2,
                                      VAR_15)) {
        *VAR_11 = ""INVALID_S4U2SELF_REQUEST"";
        return VAR_24; /* COMMENT_25 */
    }

    /* COMMENT_26 */
                                                                       
                                                                     
                                             
      
                                                                         
                                                              
       
    if (VAR_1->kdc_options & VAR_25) {
        *VAR_11 = ""INVALID AS OPTIONS"";
        return VAR_26;
    }

    /* COMMENT_34 */
                                                                       
      
                                              
                                                  
                                                      
                                                  
      
                                                                          
                                                                              
                                                            
       

    VAR_13 = !is_cross_tgs_principal(VAR_3);
    if (VAR_13 && VAR_4) {
        /* COMMENT_45 */
                                                                         
        *VAR_11 = ""LOOKING_UP_SERVER"";
        return VAR_27;
    }

    /* COMMENT_47 */
                                                             
       
    if (is_local_principal(VAR_0,
                           (*VAR_9)->user_id.user)) {
        krb5_db_entry VAR_28;
        krb5_pa_data **VAR_29 = NULL;

        if (!VAR_13 && !VAR_4) {
            /* COMMENT_50 */
                                    
            *VAR_11 = ""NOT_CROSS_REALM_REQUEST"";
            return VAR_24; /* COMMENT_52 */
        }

        VAR_12 = krb5_db_get_principal(VAR_17,
                                     (*VAR_9)->user_id.user,
                                     VAR_30, &VAR_16);
        if (VAR_12 == VAR_31) {
            *VAR_11 = ""UNKNOWN_S4U2SELF_PRINCIPAL"";
            return VAR_24;
        } else if (VAR_12) {
            *VAR_11 = ""LOOKING_UP_S4U2SELF_PRINCIPAL"";
            return VAR_12; /* COMMENT_53 */
        }

        memset(&VAR_28, 0, sizeof(VAR_28));

        /* COMMENT_54 */
                                                                   
        VAR_16->pw_expiration = 0;
        clear(VAR_16->attributes, VAR_32);

        VAR_12 = validate_as_request(VAR_0, VAR_1, *VAR_16,
                                   VAR_28, VAR_8, VAR_11, &VAR_29);
        if (VAR_12) {
            krb5_db_free_principal(VAR_17, VAR_16);
            krb5_free_pa_data(VAR_17, VAR_29);
            return VAR_12;
        }

        *VAR_10 = VAR_16;
    } else if (VAR_13) {
        /* COMMENT_56 */
                                                                              
                                                                               
                                       
           
        *VAR_11 = ""S4U2SELF_CLIENT_NOT_OURS"";
        return VAR_33; /* COMMENT_52 */
    }

    return 0;
}",krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/kdc_util.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -156,6 +156,11 @@
 
         memset(&no_server, 0, sizeof(no_server));
 
+        /* Ignore password expiration and needchange attributes (as Windows
+         * does), since S4U2Self is not password authentication. */
+        princ->pw_expiration = 0;
+        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);
+
         code = validate_as_request(kdc_active_realm, request, *princ,
                                    no_server, kdc_time, status, &e_data);
         if (code) {","{'deleted_lines': [], 'added_lines': ['        /* Ignore password expiration and needchange attributes (as Windows', '         * does), since S4U2Self is not password authentication. */', '        princ->pw_expiration = 0;', '        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);', '']}",True,"A Reachable Assertion issue was discovered in the KDC in MIT Kerberos 5 (aka krb5) before 1.17. If an attacker can obtain a krbtgt ticket using an older encryption type (single-DES, triple-DES, or RC4), the attacker can crash the KDC by making an S4U2Self request.",5.3,MEDIUM,1,valid,2018-12-03T00:33:07Z,2
CVE-2018-20217,['CWE-617'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,krb5,"Ignore password attributes for S4U2Self requests

For consistency with Windows KDCs, allow protocol transition to work
even if the password has expired or needs changing.

Also, when looking up an enterprise principal with an AS request,
treat ERR_KEY_EXP as confirmation that the client is present in the
realm.

[ghudson@mit.edu: added comment in kdc_process_s4u2self_req(); edited
commit message]

ticket: 8763 (new)
tags: pullup
target_version: 1.17",5e6d1796106df8ba6bc1973ee0917c170d929086,https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086,src/lib/krb5/krb/s4u_creds.c,s4u_identify_user,"static krb5_error_code
s4u_identify_user(krb5_context context,
krb5_creds *in_creds,
krb5_data *subject_cert,
krb5_principal *canon_user)
{
krb5_error_code code;
krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };
krb5_creds creds;
int use_master = 0;
krb5_get_init_creds_opt *opts = NULL;
krb5_principal_data client;
krb5_s4u_userid userid;
*canon_user = NULL;
if (in_creds->client == NULL && subject_cert == NULL) {
return EINVAL;
}
if (in_creds->client != NULL &&
in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {
int anonymous;
anonymous = krb5_principal_compare(context, in_creds->client,
krb5_anonymous_principal());
return krb5_copy_principal(context,
anonymous ? in_creds->server
: in_creds->client,
canon_user);
}
memset(&creds, 0, sizeof(creds));
memset(&userid, 0, sizeof(userid));
if (subject_cert != NULL)
userid.subject_cert = *subject_cert;
code = krb5_get_init_creds_opt_alloc(context, &opts);
if (code != 0)
goto cleanup;
krb5_get_init_creds_opt_set_tkt_life(opts, 15);
krb5_get_init_creds_opt_set_renew_life(opts, 0);
krb5_get_init_creds_opt_set_forwardable(opts, 0);
krb5_get_init_creds_opt_set_proxiable(opts, 0);
krb5_get_init_creds_opt_set_canonicalize(opts, 1);
krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);
if (in_creds->client != NULL) {
client = *in_creds->client;
client.realm = in_creds->server->realm;
} else {
client.magic = KV5M_PRINCIPAL;
client.realm = in_creds->server->realm;
client.data = NULL;
client.length = 0;
client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;
}
code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,
opts, krb5_get_as_key_noop, &userid, &use_master,
NULL);
if (code == 0 || code == KRB5_PREAUTH_FAILED) {
*canon_user = userid.user;
userid.user = NULL;
code = 0;
}
cleanup:
krb5_free_cred_contents(context, &creds);
if (opts != NULL)
krb5_get_init_creds_opt_free(context, opts);
if (userid.user != NULL)
krb5_free_principal(context, userid.user);
return code;
}","static krb5_error_code
s4u_identify_user(krb5_context VAR_0,
krb5_creds *VAR_1,
krb5_data *VAR_2,
krb5_principal *VAR_3)
{
krb5_error_code VAR_4;
krb5_preauthtype VAR_5[1] = { VAR_6 };
krb5_creds VAR_7;
int VAR_8 = 0;
krb5_get_init_creds_opt *VAR_9 = NULL;
krb5_principal_data VAR_10;
krb5_s4u_userid VAR_11;
*VAR_3 = NULL;
if (VAR_1->client == NULL && VAR_2 == NULL) {
return VAR_12;
}
if (VAR_1->client != NULL &&
VAR_1->client->type != VAR_13) {
int VAR_14;
VAR_14 = krb5_principal_compare(VAR_0, VAR_1->client,
krb5_anonymous_principal());
return krb5_copy_principal(VAR_0,
VAR_14 ? VAR_1->server
: VAR_1->client,
VAR_3);
}
memset(&VAR_7, 0, sizeof(VAR_7));
memset(&VAR_11, 0, sizeof(VAR_11));
if (VAR_2 != NULL)
VAR_11.subject_cert = *VAR_2;
VAR_4 = krb5_get_init_creds_opt_alloc(VAR_0, &VAR_9);
if (VAR_4 != 0)
goto cleanup;
krb5_get_init_creds_opt_set_tkt_life(VAR_9, 15);
krb5_get_init_creds_opt_set_renew_life(VAR_9, 0);
krb5_get_init_creds_opt_set_forwardable(VAR_9, 0);
krb5_get_init_creds_opt_set_proxiable(VAR_9, 0);
krb5_get_init_creds_opt_set_canonicalize(VAR_9, 1);
krb5_get_init_creds_opt_set_preauth_list(VAR_9, VAR_5, 1);
if (VAR_1->client != NULL) {
VAR_10 = *VAR_1->client;
VAR_10.realm = VAR_1->server->realm;
} else {
VAR_10.magic = VAR_15;
VAR_10.realm = VAR_1->server->realm;
VAR_10.data = NULL;
VAR_10.length = 0;
VAR_10.type = VAR_13;
}
VAR_4 = k5_get_init_creds(VAR_0, &VAR_7, &VAR_10, NULL, NULL, 0, NULL,
VAR_9, VAR_16, &VAR_11, &VAR_8,
NULL);
if (VAR_4 == 0 || VAR_4 == VAR_17) {
*VAR_3 = VAR_11.user;
VAR_11.user = NULL;
VAR_4 = 0;
}
cleanup:
krb5_free_cred_contents(VAR_0, &VAR_7);
if (VAR_9 != NULL)
krb5_get_init_creds_opt_free(VAR_0, VAR_9);
if (VAR_11.user != NULL)
krb5_free_principal(VAR_0, VAR_11.user);
return VAR_4;
}",krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/s4u_creds.c/vul/before/0.json,"static krb5_error_code
s4u_identify_user(krb5_context context,
                  krb5_creds *in_creds,
                  krb5_data *subject_cert,
                  krb5_principal *canon_user)
{
    krb5_error_code code;
    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };
    krb5_creds creds;
    int use_master = 0;
    krb5_get_init_creds_opt *opts = NULL;
    krb5_principal_data client;
    krb5_s4u_userid userid;

    *canon_user = NULL;

    if (in_creds->client == NULL && subject_cert == NULL) {
        return EINVAL;
    }

    if (in_creds->client != NULL &&
        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {
        int anonymous;

        anonymous = krb5_principal_compare(context, in_creds->client,
                                           krb5_anonymous_principal());

        return krb5_copy_principal(context,
                                   anonymous ? in_creds->server
                                   : in_creds->client,
                                   canon_user);
    }

    memset(&creds, 0, sizeof(creds));

    memset(&userid, 0, sizeof(userid));
    if (subject_cert != NULL)
        userid.subject_cert = *subject_cert;

    code = krb5_get_init_creds_opt_alloc(context, &opts);
    if (code != 0)
        goto cleanup;
    krb5_get_init_creds_opt_set_tkt_life(opts, 15);
    krb5_get_init_creds_opt_set_renew_life(opts, 0);
    krb5_get_init_creds_opt_set_forwardable(opts, 0);
    krb5_get_init_creds_opt_set_proxiable(opts, 0);
    krb5_get_init_creds_opt_set_canonicalize(opts, 1);
    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);

    if (in_creds->client != NULL) {
        client = *in_creds->client;
        client.realm = in_creds->server->realm;
    } else {
        client.magic = KV5M_PRINCIPAL;
        client.realm = in_creds->server->realm;
        /* should this be NULL, empty or a fixed string? XXX */
        client.data = NULL;
        client.length = 0;
        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;
    }

    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,
                             opts, krb5_get_as_key_noop, &userid, &use_master,
                             NULL);
    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {
        *canon_user = userid.user;
        userid.user = NULL;
        code = 0;
    }

cleanup:
    krb5_free_cred_contents(context, &creds);
    if (opts != NULL)
        krb5_get_init_creds_opt_free(context, opts);
    if (userid.user != NULL)
        krb5_free_principal(context, userid.user);

    return code;
}","static krb5_error_code
s4u_identify_user(krb5_context VAR_0,
                  krb5_creds *VAR_1,
                  krb5_data *VAR_2,
                  krb5_principal *VAR_3)
{
    krb5_error_code VAR_4;
    krb5_preauthtype VAR_5[1] = { VAR_6 };
    krb5_creds VAR_7;
    int VAR_8 = 0;
    krb5_get_init_creds_opt *VAR_9 = NULL;
    krb5_principal_data VAR_10;
    krb5_s4u_userid VAR_11;

    *VAR_3 = NULL;

    if (VAR_1->client == NULL && VAR_2 == NULL) {
        return VAR_12;
    }

    if (VAR_1->client != NULL &&
        VAR_1->client->type != VAR_13) {
        int VAR_14;

        VAR_14 = krb5_principal_compare(VAR_0, VAR_1->client,
                                           krb5_anonymous_principal());

        return krb5_copy_principal(VAR_0,
                                   VAR_14 ? VAR_1->server
                                   : VAR_1->client,
                                   VAR_3);
    }

    memset(&VAR_7, 0, sizeof(VAR_7));

    memset(&VAR_11, 0, sizeof(VAR_11));
    if (VAR_2 != NULL)
        VAR_11.subject_cert = *VAR_2;

    VAR_4 = krb5_get_init_creds_opt_alloc(VAR_0, &VAR_9);
    if (VAR_4 != 0)
        goto cleanup;
    krb5_get_init_creds_opt_set_tkt_life(VAR_9, 15);
    krb5_get_init_creds_opt_set_renew_life(VAR_9, 0);
    krb5_get_init_creds_opt_set_forwardable(VAR_9, 0);
    krb5_get_init_creds_opt_set_proxiable(VAR_9, 0);
    krb5_get_init_creds_opt_set_canonicalize(VAR_9, 1);
    krb5_get_init_creds_opt_set_preauth_list(VAR_9, VAR_5, 1);

    if (VAR_1->client != NULL) {
        VAR_10 = *VAR_1->client;
        VAR_10.realm = VAR_1->server->realm;
    } else {
        VAR_10.magic = VAR_15;
        VAR_10.realm = VAR_1->server->realm;
        /* COMMENT_0 */
        VAR_10.data = NULL;
        VAR_10.length = 0;
        VAR_10.type = VAR_13;
    }

    VAR_4 = k5_get_init_creds(VAR_0, &VAR_7, &VAR_10, NULL, NULL, 0, NULL,
                             VAR_9, VAR_16, &VAR_11, &VAR_8,
                             NULL);
    if (!VAR_4 || VAR_4 == VAR_17 || VAR_4 == VAR_18) {
        *VAR_3 = VAR_11.user;
        VAR_11.user = NULL;
        VAR_4 = 0;
    }

cleanup:
    krb5_free_cred_contents(VAR_0, &VAR_7);
    if (VAR_9 != NULL)
        krb5_get_init_creds_opt_free(VAR_0, VAR_9);
    if (VAR_11.user != NULL)
        krb5_free_principal(VAR_0, VAR_11.user);

    return VAR_4;
}",krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/s4u_creds.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -62,7 +62,7 @@
     code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,
                              opts, krb5_get_as_key_noop, &userid, &use_master,
                              NULL);
-    if (code == 0 || code == KRB5_PREAUTH_FAILED) {
+    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {
         *canon_user = userid.user;
         userid.user = NULL;
         code = 0;","{'deleted_lines': ['    if (code == 0 || code == KRB5_PREAUTH_FAILED) {'], 'added_lines': ['    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {']}",True,"A Reachable Assertion issue was discovered in the KDC in MIT Kerberos 5 (aka krb5) before 1.17. If an attacker can obtain a krbtgt ticket using an older encryption type (single-DES, triple-DES, or RC4), the attacker can crash the KDC by making an S4U2Self request.",5.3,MEDIUM,1,valid,2018-12-03T00:33:07Z,2
CVE-2018-1000878,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libarchive,"rar: file split across multi-part archives must match

Fuzzing uncovered some UAF and memory overrun bugs where a file in a
single file archive reported that it was split across multiple
volumes. This was caused by ppmd7 operations calling
rar_br_fillup. This would invoke rar_read_ahead, which would in some
situations invoke archive_read_format_rar_read_header.  That would
check the new file name against the old file name, and if they didn't
match up it would free the ppmd7 buffer and allocate a new
one. However, because the ppmd7 decoder wasn't actually done with the
buffer, it would continue to used the freed buffer. Both reads and
writes to the freed region can be observed.

This is quite tricky to solve: once the buffer has been freed it is
too late, as the ppmd7 decoder functions almost universally assume
success - there's no way for ppmd_read to signal error, nor are there
good ways for functions like Range_Normalise to propagate them. So we
can't detect after the fact that we're in an invalid state - e.g. by
checking rar->cursor, we have to prevent ourselves from ever ending up
there. So, when we are in the dangerous part or rar_read_ahead that
assumes a valid split, we set a flag force read_header to either go
down the path for split files or bail. This means that the ppmd7
decoder keeps a valid buffer and just runs out of data.

Found with a combination of AFL, afl-rb and qsym.",bfcfe6f04ed20db2504db8a254d1f40a1d84eb28,https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28,libarchive/archive_read_support_format_rar.c,read_header,"static int
read_header(struct archive_read *a, struct archive_entry *entry,
char head_type)
{
const void *h;
const char *p, *endp;
struct rar *rar;
struct rar_header rar_header;
struct rar_file_header file_header;
int64_t header_size;
unsigned filename_size, end;
char *filename;
char *strp;
char packed_size[8];
char unp_size[8];
int ttime;
struct archive_string_conv *sconv, *fn_sconv;
unsigned long crc32_val;
int ret = (ARCHIVE_OK), ret2;
rar = (struct rar *)(a->format->data);
sconv = rar->opt_sconv;
if (sconv == NULL) {
if (!rar->init_default_conversion) {
rar->sconv_default =
archive_string_default_conversion_for_read(
&(a->archive));
rar->init_default_conversion = 1;
}
sconv = rar->sconv_default;
}
if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
p = h;
memcpy(&rar_header, p, sizeof(rar_header));
rar->file_flags = archive_le16dec(rar_header.flags);
header_size = archive_le16dec(rar_header.size);
if (header_size < (int64_t)sizeof(file_header) + 7) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
__archive_read_consume(a, 7);
if (!(rar->file_flags & FHD_SOLID))
{
rar->compression_method = 0;
rar->packed_size = 0;
rar->unp_size = 0;
rar->mtime = 0;
rar->ctime = 0;
rar->atime = 0;
rar->arctime = 0;
rar->mode = 0;
memset(&rar->salt, 0, sizeof(rar->salt));
rar->atime = 0;
rar->ansec = 0;
rar->ctime = 0;
rar->cnsec = 0;
rar->mtime = 0;
rar->mnsec = 0;
rar->arctime = 0;
rar->arcnsec = 0;
}
else
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""RAR solid archive support unavailable."");
return (ARCHIVE_FATAL);
}
if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Header CRC error"");
return (ARCHIVE_FATAL);
}
p = h;
endp = p + header_size - 7;
memcpy(&file_header, p, sizeof(file_header));
p += sizeof(file_header);
rar->compression_method = file_header.method;
ttime = archive_le32dec(file_header.file_time);
rar->mtime = get_time(ttime);
rar->file_crc = archive_le32dec(file_header.file_crc);
if (rar->file_flags & FHD_PASSWORD)
{
archive_entry_set_is_data_encrypted(entry, 1);
rar->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""RAR encryption support unavailable."");
}
if (rar->file_flags & FHD_LARGE)
{
memcpy(packed_size, file_header.pack_size, 4);
memcpy(packed_size + 4, p, 4); 
p += 4;
memcpy(unp_size, file_header.unp_size, 4);
memcpy(unp_size + 4, p, 4); 
p += 4;
rar->packed_size = archive_le64dec(&packed_size);
rar->unp_size = archive_le64dec(&unp_size);
}
else
{
rar->packed_size = archive_le32dec(file_header.pack_size);
rar->unp_size = archive_le32dec(file_header.unp_size);
}
if (rar->packed_size < 0 || rar->unp_size < 0)
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid sizes specified."");
return (ARCHIVE_FATAL);
}
rar->bytes_remaining = rar->packed_size;
if (head_type == NEWSUB_HEAD) {
size_t distance = p - (const char *)h;
header_size += rar->packed_size;
if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
return (ARCHIVE_FATAL);
p = h;
endp = p + header_size - 7;
p += distance;
}
filename_size = archive_le16dec(file_header.name_size);
if (p + filename_size > endp) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid filename size"");
return (ARCHIVE_FATAL);
}
if (rar->filename_allocated < filename_size * 2 + 2) {
char *newptr;
size_t newsize = filename_size * 2 + 2;
newptr = realloc(rar->filename, newsize);
if (newptr == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->filename = newptr;
rar->filename_allocated = newsize;
}
filename = rar->filename;
memcpy(filename, p, filename_size);
filename[filename_size] = '\0';
if (rar->file_flags & FHD_UNICODE)
{
if (filename_size != strlen(filename))
{
unsigned char highbyte, flagbits, flagbyte;
unsigned fn_end, offset;
end = filename_size;
fn_end = filename_size * 2;
filename_size = 0;
offset = (unsigned)strlen(filename) + 1;
highbyte = *(p + offset++);
flagbits = 0;
flagbyte = 0;
while (offset < end && filename_size < fn_end)
{
if (!flagbits)
{
flagbyte = *(p + offset++);
flagbits = 8;
}
flagbits -= 2;
switch((flagbyte >> flagbits) & 3)
{
case 0:
filename[filename_size++] = '\0';
filename[filename_size++] = *(p + offset++);
break;
case 1:
filename[filename_size++] = highbyte;
filename[filename_size++] = *(p + offset++);
break;
case 2:
filename[filename_size++] = *(p + offset + 1);
filename[filename_size++] = *(p + offset);
offset += 2;
break;
case 3:
{
char extra, high;
uint8_t length = *(p + offset++);
if (length & 0x80) {
extra = *(p + offset++);
high = (char)highbyte;
} else
extra = high = 0;
length = (length & 0x7f) + 2;
while (length && filename_size < fn_end) {
unsigned cp = filename_size >> 1;
filename[filename_size++] = high;
filename[filename_size++] = p[cp] + extra;
length--;
}
}
break;
}
}
if (filename_size > fn_end) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid filename"");
return (ARCHIVE_FATAL);
}
filename[filename_size++] = '\0';
filename[filename_size] = '\0';
if (rar->sconv_utf16be == NULL) {
rar->sconv_utf16be = archive_string_conversion_from_charset(
&a->archive, ""UTF-16BE"", 1);
if (rar->sconv_utf16be == NULL)
return (ARCHIVE_FATAL);
}
fn_sconv = rar->sconv_utf16be;
strp = filename;
while (memcmp(strp, ""\x00\x00"", 2))
{
if (!memcmp(strp, ""\x00\\"", 2))
*(strp + 1) = '/';
strp += 2;
}
p += offset;
} else {
if (rar->sconv_utf8 == NULL) {
rar->sconv_utf8 = archive_string_conversion_from_charset(
&a->archive, ""UTF-8"", 1);
if (rar->sconv_utf8 == NULL)
return (ARCHIVE_FATAL);
}
fn_sconv = rar->sconv_utf8;
while ((strp = strchr(filename, '\\')) != NULL)
*strp = '/';
p += filename_size;
}
}
else
{
fn_sconv = sconv;
while ((strp = strchr(filename, '\\')) != NULL)
*strp = '/';
p += filename_size;
}
if (rar->filename_save &&
filename_size == rar->filename_save_size &&
!memcmp(rar->filename, rar->filename_save, filename_size + 1))
{
__archive_read_consume(a, header_size - 7);
rar->cursor++;
if (rar->cursor >= rar->nodes)
{
rar->nodes++;
if ((rar->dbo =
realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
{
archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->dbo[rar->cursor].header_size = header_size;
rar->dbo[rar->cursor].start_offset = -1;
rar->dbo[rar->cursor].end_offset = -1;
}
if (rar->dbo[rar->cursor].start_offset < 0)
{
rar->dbo[rar->cursor].start_offset = a->filter->position;
rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
rar->packed_size;
}
return ret;
}
rar->filename_save = (char*)realloc(rar->filename_save,
filename_size + 1);
memcpy(rar->filename_save, rar->filename, filename_size + 1);
rar->filename_save_size = filename_size;
free(rar->dbo);
if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
{
archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
return (ARCHIVE_FATAL);
}
rar->dbo[0].header_size = header_size;
rar->dbo[0].start_offset = -1;
rar->dbo[0].end_offset = -1;
rar->cursor = 0;
rar->nodes = 1;
if (rar->file_flags & FHD_SALT)
{
if (p + 8 > endp) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
memcpy(rar->salt, p, 8);
p += 8;
}
if (rar->file_flags & FHD_EXTTIME) {
if (read_exttime(p, rar, endp) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid header size"");
return (ARCHIVE_FATAL);
}
}
__archive_read_consume(a, header_size - 7);
rar->dbo[0].start_offset = a->filter->position;
rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
switch(file_header.host_os)
{
case OS_MSDOS:
case OS_OS2:
case OS_WIN32:
rar->mode = archive_le32dec(file_header.file_attr);
if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
else
rar->mode = AE_IFREG;
rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
break;
case OS_UNIX:
case OS_MAC_OS:
case OS_BEOS:
rar->mode = archive_le32dec(file_header.file_attr);
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unknown file attributes from RAR file's host OS"");
return (ARCHIVE_FATAL);
}
rar->bytes_uncopied = rar->bytes_unconsumed = 0;
rar->lzss.position = rar->offset = 0;
rar->offset_seek = 0;
rar->dictionary_size = 0;
rar->offset_outgoing = 0;
rar->br.cache_avail = 0;
rar->br.avail_in = 0;
rar->crc_calculated = 0;
rar->entry_eof = 0;
rar->valid = 1;
rar->is_ppmd_block = 0;
rar->start_new_table = 1;
free(rar->unp_buffer);
rar->unp_buffer = NULL;
rar->unp_offset = 0;
rar->unp_buffer_size = UNP_BUFFER_SIZE;
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
rar->ppmd_valid = rar->ppmd_eod = 0;
if (head_type == NEWSUB_HEAD)
return ret;
archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
archive_entry_set_atime(entry, rar->atime, rar->ansec);
archive_entry_set_size(entry, rar->unp_size);
archive_entry_set_mode(entry, rar->mode);
if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
{
if (errno == ENOMEM)
{
archive_set_error(&a->archive, ENOMEM,
""Can't allocate memory for Pathname"");
return (ARCHIVE_FATAL);
}
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Pathname cannot be converted from %s to current locale."",
archive_string_conversion_charset_name(fn_sconv));
ret = (ARCHIVE_WARN);
}
if (((rar->mode) & AE_IFMT) == AE_IFLNK)
{
rar->bytes_remaining = 0;
archive_entry_set_size(entry, 0);
if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
return ret2;
if (ret > ret2)
ret = ret2;
}
if (rar->bytes_remaining == 0)
rar->entry_eof = 1;
return ret;
}","static int
read_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,
char VAR_2)
{
const void *VAR_3;
const char *VAR_4, *VAR_5;
struct rar *rar;
struct rar_header rar_header;
struct rar_file_header VAR_6;
int64_t VAR_7;
unsigned VAR_8, VAR_9;
char *VAR_10;
char *VAR_11;
char VAR_12[8];
char VAR_13[8];
int VAR_14;
struct archive_string_conv *VAR_15, *VAR_16;
unsigned long VAR_17;
int VAR_18 = (VAR_19), VAR_20;
rar = (struct rar *)(VAR_0->format->data);
VAR_15 = rar->opt_sconv;
if (VAR_15 == NULL) {
if (!rar->init_default_conversion) {
rar->sconv_default =
archive_string_default_conversion_for_read(
&(VAR_0->archive));
rar->init_default_conversion = 1;
}
VAR_15 = rar->sconv_default;
}
if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)
return (VAR_21);
VAR_4 = VAR_3;
memcpy(&rar_header, VAR_4, sizeof(rar_header));
rar->file_flags = archive_le16dec(rar_header.flags);
VAR_7 = archive_le16dec(rar_header.size);
if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);
__archive_read_consume(VAR_0, 7);
if (!(rar->file_flags & VAR_23))
{
rar->compression_method = 0;
rar->packed_size = 0;
rar->unp_size = 0;
rar->mtime = 0;
rar->ctime = 0;
rar->atime = 0;
rar->arctime = 0;
rar->mode = 0;
memset(&rar->salt, 0, sizeof(rar->salt));
rar->atime = 0;
rar->ansec = 0;
rar->ctime = 0;
rar->cnsec = 0;
rar->mtime = 0;
rar->mnsec = 0;
rar->arctime = 0;
rar->arcnsec = 0;
}
else
{
archive_set_error(&VAR_0->archive, VAR_22,
""RAR solid archive support unavailable."");
return (VAR_21);
}
if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
return (VAR_21);
VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));
if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {
archive_set_error(&VAR_0->archive, VAR_22,
""Header CRC error"");
return (VAR_21);
}
VAR_4 = VAR_3;
VAR_5 = VAR_4 + VAR_7 - 7;
memcpy(&VAR_6, VAR_4, sizeof(VAR_6));
VAR_4 += sizeof(VAR_6);
rar->compression_method = VAR_6.method;
VAR_14 = archive_le32dec(VAR_6.file_time);
rar->mtime = get_time(VAR_14);
rar->file_crc = archive_le32dec(VAR_6.file_crc);
if (rar->file_flags & VAR_24)
{
archive_entry_set_is_data_encrypted(VAR_1, 1);
rar->has_encrypted_entries = 1;
archive_set_error(&VAR_0->archive, VAR_22,
""RAR encryption support unavailable."");
}
if (rar->file_flags & VAR_25)
{
memcpy(VAR_12, VAR_6.pack_size, 4);
memcpy(VAR_12 + 4, VAR_4, 4); 
VAR_4 += 4;
memcpy(VAR_13, VAR_6.unp_size, 4);
memcpy(VAR_13 + 4, VAR_4, 4); 
VAR_4 += 4;
rar->packed_size = archive_le64dec(&VAR_12);
rar->unp_size = archive_le64dec(&VAR_13);
}
else
{
rar->packed_size = archive_le32dec(VAR_6.pack_size);
rar->unp_size = archive_le32dec(VAR_6.unp_size);
}
if (rar->packed_size < 0 || rar->unp_size < 0)
{
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid sizes specified."");
return (VAR_21);
}
rar->bytes_remaining = rar->packed_size;
if (VAR_2 == VAR_26) {
size_t VAR_27 = VAR_4 - (const char *)VAR_3;
VAR_7 += rar->packed_size;
if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
return (VAR_21);
VAR_4 = VAR_3;
VAR_5 = VAR_4 + VAR_7 - 7;
VAR_4 += VAR_27;
}
VAR_8 = archive_le16dec(VAR_6.name_size);
if (VAR_4 + VAR_8 > VAR_5) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid filename size"");
return (VAR_21);
}
if (rar->filename_allocated < VAR_8 * 2 + 2) {
char *VAR_28;
size_t VAR_29 = VAR_8 * 2 + 2;
VAR_28 = realloc(rar->filename, VAR_29);
if (VAR_28 == NULL) {
archive_set_error(&VAR_0->archive, VAR_30,
""Couldn't allocate memory."");
return (VAR_21);
}
rar->filename = VAR_28;
rar->filename_allocated = VAR_29;
}
VAR_10 = rar->filename;
memcpy(VAR_10, VAR_4, VAR_8);
VAR_10[VAR_8] = '\0';
if (rar->file_flags & VAR_31)
{
if (VAR_8 != strlen(VAR_10))
{
unsigned char VAR_32, VAR_33, VAR_34;
unsigned VAR_35, VAR_36;
VAR_9 = VAR_8;
VAR_35 = VAR_8 * 2;
VAR_8 = 0;
VAR_36 = (unsigned)strlen(VAR_10) + 1;
VAR_32 = *(VAR_4 + VAR_36++);
VAR_33 = 0;
VAR_34 = 0;
while (VAR_36 < VAR_9 && VAR_8 < VAR_35)
{
if (!VAR_33)
{
VAR_34 = *(VAR_4 + VAR_36++);
VAR_33 = 8;
}
VAR_33 -= 2;
switch((VAR_34 >> VAR_33) & 3)
{
case 0:
VAR_10[VAR_8++] = '\0';
VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
break;
case 1:
VAR_10[VAR_8++] = VAR_32;
VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
break;
case 2:
VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);
VAR_10[VAR_8++] = *(VAR_4 + VAR_36);
VAR_36 += 2;
break;
case 3:
{
char VAR_37, VAR_38;
uint8_t VAR_39 = *(VAR_4 + VAR_36++);
if (VAR_39 & 0x80) {
VAR_37 = *(VAR_4 + VAR_36++);
VAR_38 = (char)VAR_32;
} else
VAR_37 = VAR_38 = 0;
VAR_39 = (VAR_39 & 0x7f) + 2;
while (VAR_39 && VAR_8 < VAR_35) {
unsigned VAR_40 = VAR_8 >> 1;
VAR_10[VAR_8++] = VAR_38;
VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;
VAR_39--;
}
}
break;
}
}
if (VAR_8 > VAR_35) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid filename"");
return (VAR_21);
}
VAR_10[VAR_8++] = '\0';
VAR_10[VAR_8] = '\0';
if (rar->sconv_utf16be == NULL) {
rar->sconv_utf16be = archive_string_conversion_from_charset(
&VAR_0->archive, ""UTF-16BE"", 1);
if (rar->sconv_utf16be == NULL)
return (VAR_21);
}
VAR_16 = rar->sconv_utf16be;
VAR_11 = VAR_10;
while (memcmp(VAR_11, ""\x00\x00"", 2))
{
if (!memcmp(VAR_11, ""\x00\\"", 2))
*(VAR_11 + 1) = '/';
VAR_11 += 2;
}
VAR_4 += VAR_36;
} else {
if (rar->sconv_utf8 == NULL) {
rar->sconv_utf8 = archive_string_conversion_from_charset(
&VAR_0->archive, ""UTF-8"", 1);
if (rar->sconv_utf8 == NULL)
return (VAR_21);
}
VAR_16 = rar->sconv_utf8;
while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
*VAR_11 = '/';
VAR_4 += VAR_8;
}
}
else
{
VAR_16 = VAR_15;
while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
*VAR_11 = '/';
VAR_4 += VAR_8;
}
if (rar->filename_save &&
VAR_8 == rar->filename_save_size &&
!memcmp(rar->filename, rar->filename_save, VAR_8 + 1))
{
__archive_read_consume(VAR_0, VAR_7 - 7);
rar->cursor++;
if (rar->cursor >= rar->nodes)
{
rar->nodes++;
if ((rar->dbo =
realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
{
archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
return (VAR_21);
}
rar->dbo[rar->cursor].header_size = VAR_7;
rar->dbo[rar->cursor].start_offset = -1;
rar->dbo[rar->cursor].end_offset = -1;
}
if (rar->dbo[rar->cursor].start_offset < 0)
{
rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;
rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
rar->packed_size;
}
return VAR_18;
}
rar->filename_save = (char*)realloc(rar->filename_save,
VAR_8 + 1);
memcpy(rar->filename_save, rar->filename, VAR_8 + 1);
rar->filename_save_size = VAR_8;
free(rar->dbo);
if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
{
archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
return (VAR_21);
}
rar->dbo[0].header_size = VAR_7;
rar->dbo[0].start_offset = -1;
rar->dbo[0].end_offset = -1;
rar->cursor = 0;
rar->nodes = 1;
if (rar->file_flags & VAR_41)
{
if (VAR_4 + 8 > VAR_5) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
memcpy(rar->salt, VAR_4, 8);
VAR_4 += 8;
}
if (rar->file_flags & VAR_42) {
if (read_exttime(VAR_4, rar, VAR_5) < 0) {
archive_set_error(&VAR_0->archive, VAR_22,
""Invalid header size"");
return (VAR_21);
}
}
__archive_read_consume(VAR_0, VAR_7 - 7);
rar->dbo[0].start_offset = VAR_0->filter->position;
rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
switch(VAR_6.host_os)
{
case VAR_43:
case VAR_44:
case VAR_45:
rar->mode = archive_le32dec(VAR_6.file_attr);
if (rar->mode & VAR_46)
rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;
else
rar->mode = VAR_51;
rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;
break;
case VAR_56:
case VAR_57:
case VAR_58:
rar->mode = archive_le32dec(VAR_6.file_attr);
break;
default:
archive_set_error(&VAR_0->archive, VAR_22,
""Unknown file attributes from RAR file's host OS"");
return (VAR_21);
}
rar->bytes_uncopied = rar->bytes_unconsumed = 0;
rar->lzss.position = rar->offset = 0;
rar->offset_seek = 0;
rar->dictionary_size = 0;
rar->offset_outgoing = 0;
rar->br.cache_avail = 0;
rar->br.avail_in = 0;
rar->crc_calculated = 0;
rar->entry_eof = 0;
rar->valid = 1;
rar->is_ppmd_block = 0;
rar->start_new_table = 1;
free(rar->unp_buffer);
rar->unp_buffer = NULL;
rar->unp_offset = 0;
rar->unp_buffer_size = VAR_59;
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
VAR_60.Ppmd7_Free(&rar->ppmd7_context);
rar->ppmd_valid = rar->ppmd_eod = 0;
if (VAR_2 == VAR_26)
return VAR_18;
archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);
archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);
archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);
archive_entry_set_size(VAR_1, rar->unp_size);
archive_entry_set_mode(VAR_1, rar->mode);
if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))
{
if (VAR_61 == VAR_30)
{
archive_set_error(&VAR_0->archive, VAR_30,
""Can't allocate memory for Pathname"");
return (VAR_21);
}
archive_set_error(&VAR_0->archive, VAR_22,
""Pathname cannot be converted from %s to current locale."",
archive_string_conversion_charset_name(VAR_16));
VAR_18 = (VAR_62);
}
if (((rar->mode) & VAR_63) == VAR_64)
{
rar->bytes_remaining = 0;
archive_entry_set_size(VAR_1, 0);
if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_62))
return VAR_20;
if (VAR_18 > VAR_20)
VAR_18 = VAR_20;
}
if (rar->bytes_remaining == 0)
rar->entry_eof = 1;
return VAR_18;
}",libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/before/1.json,"static int
read_header(struct archive_read *a, struct archive_entry *entry,
            char head_type)
{
  const void *h;
  const char *p, *endp;
  struct rar *rar;
  struct rar_header rar_header;
  struct rar_file_header file_header;
  int64_t header_size;
  unsigned filename_size, end;
  char *filename;
  char *strp;
  char packed_size[8];
  char unp_size[8];
  int ttime;
  struct archive_string_conv *sconv, *fn_sconv;
  unsigned long crc32_val;
  int ret = (ARCHIVE_OK), ret2;

  rar = (struct rar *)(a->format->data);

  /* Setup a string conversion object for non-rar-unicode filenames. */
  sconv = rar->opt_sconv;
  if (sconv == NULL) {
    if (!rar->init_default_conversion) {
      rar->sconv_default =
          archive_string_default_conversion_for_read(
            &(a->archive));
      rar->init_default_conversion = 1;
    }
    sconv = rar->sconv_default;
  }


  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
    return (ARCHIVE_FATAL);
  p = h;
  memcpy(&rar_header, p, sizeof(rar_header));
  rar->file_flags = archive_le16dec(rar_header.flags);
  header_size = archive_le16dec(rar_header.size);
  if (header_size < (int64_t)sizeof(file_header) + 7) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Invalid header size"");
    return (ARCHIVE_FATAL);
  }
  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
  __archive_read_consume(a, 7);

  if (!(rar->file_flags & FHD_SOLID))
  {
    rar->compression_method = 0;
    rar->packed_size = 0;
    rar->unp_size = 0;
    rar->mtime = 0;
    rar->ctime = 0;
    rar->atime = 0;
    rar->arctime = 0;
    rar->mode = 0;
    memset(&rar->salt, 0, sizeof(rar->salt));
    rar->atime = 0;
    rar->ansec = 0;
    rar->ctime = 0;
    rar->cnsec = 0;
    rar->mtime = 0;
    rar->mnsec = 0;
    rar->arctime = 0;
    rar->arcnsec = 0;
  }
  else
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""RAR solid archive support unavailable."");
    return (ARCHIVE_FATAL);
  }

  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
    return (ARCHIVE_FATAL);

  /* File Header CRC check. */
  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Header CRC error"");
    return (ARCHIVE_FATAL);
  }
  /* If no CRC error, Go on parsing File Header. */
  p = h;
  endp = p + header_size - 7;
  memcpy(&file_header, p, sizeof(file_header));
  p += sizeof(file_header);

  rar->compression_method = file_header.method;

  ttime = archive_le32dec(file_header.file_time);
  rar->mtime = get_time(ttime);

  rar->file_crc = archive_le32dec(file_header.file_crc);

  if (rar->file_flags & FHD_PASSWORD)
  {
	archive_entry_set_is_data_encrypted(entry, 1);
	rar->has_encrypted_entries = 1;
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""RAR encryption support unavailable."");
    /* Since it is only the data part itself that is encrypted we can at least
       extract information about the currently processed entry and don't need
       to return ARCHIVE_FATAL here. */
    /*return (ARCHIVE_FATAL);*/
  }

  if (rar->file_flags & FHD_LARGE)
  {
    memcpy(packed_size, file_header.pack_size, 4);
    memcpy(packed_size + 4, p, 4); /* High pack size */
    p += 4;
    memcpy(unp_size, file_header.unp_size, 4);
    memcpy(unp_size + 4, p, 4); /* High unpack size */
    p += 4;
    rar->packed_size = archive_le64dec(&packed_size);
    rar->unp_size = archive_le64dec(&unp_size);
  }
  else
  {
    rar->packed_size = archive_le32dec(file_header.pack_size);
    rar->unp_size = archive_le32dec(file_header.unp_size);
  }

  if (rar->packed_size < 0 || rar->unp_size < 0)
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Invalid sizes specified."");
    return (ARCHIVE_FATAL);
  }

  rar->bytes_remaining = rar->packed_size;

  /* TODO: RARv3 subblocks contain comments. For now the complete block is
   * consumed at the end.
   */
  if (head_type == NEWSUB_HEAD) {
    size_t distance = p - (const char *)h;
    header_size += rar->packed_size;
    /* Make sure we have the extended data. */
    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
        return (ARCHIVE_FATAL);
    p = h;
    endp = p + header_size - 7;
    p += distance;
  }

  filename_size = archive_le16dec(file_header.name_size);
  if (p + filename_size > endp) {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Invalid filename size"");
    return (ARCHIVE_FATAL);
  }
  if (rar->filename_allocated < filename_size * 2 + 2) {
    char *newptr;
    size_t newsize = filename_size * 2 + 2;
    newptr = realloc(rar->filename, newsize);
    if (newptr == NULL) {
      archive_set_error(&a->archive, ENOMEM,
                        ""Couldn't allocate memory."");
      return (ARCHIVE_FATAL);
    }
    rar->filename = newptr;
    rar->filename_allocated = newsize;
  }
  filename = rar->filename;
  memcpy(filename, p, filename_size);
  filename[filename_size] = '\0';
  if (rar->file_flags & FHD_UNICODE)
  {
    if (filename_size != strlen(filename))
    {
      unsigned char highbyte, flagbits, flagbyte;
      unsigned fn_end, offset;

      end = filename_size;
      fn_end = filename_size * 2;
      filename_size = 0;
      offset = (unsigned)strlen(filename) + 1;
      highbyte = *(p + offset++);
      flagbits = 0;
      flagbyte = 0;
      while (offset < end && filename_size < fn_end)
      {
        if (!flagbits)
        {
          flagbyte = *(p + offset++);
          flagbits = 8;
        }

        flagbits -= 2;
        switch((flagbyte >> flagbits) & 3)
        {
          case 0:
            filename[filename_size++] = '\0';
            filename[filename_size++] = *(p + offset++);
            break;
          case 1:
            filename[filename_size++] = highbyte;
            filename[filename_size++] = *(p + offset++);
            break;
          case 2:
            filename[filename_size++] = *(p + offset + 1);
            filename[filename_size++] = *(p + offset);
            offset += 2;
            break;
          case 3:
          {
            char extra, high;
            uint8_t length = *(p + offset++);

            if (length & 0x80) {
              extra = *(p + offset++);
              high = (char)highbyte;
            } else
              extra = high = 0;
            length = (length & 0x7f) + 2;
            while (length && filename_size < fn_end) {
              unsigned cp = filename_size >> 1;
              filename[filename_size++] = high;
              filename[filename_size++] = p[cp] + extra;
              length--;
            }
          }
          break;
        }
      }
      if (filename_size > fn_end) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
          ""Invalid filename"");
        return (ARCHIVE_FATAL);
      }
      filename[filename_size++] = '\0';
      /*
       * Do not increment filename_size here as the computations below
       * add the space for the terminating NUL explicitly.
       */
      filename[filename_size] = '\0';

      /* Decoded unicode form is UTF-16BE, so we have to update a string
       * conversion object for it. */
      if (rar->sconv_utf16be == NULL) {
        rar->sconv_utf16be = archive_string_conversion_from_charset(
           &a->archive, ""UTF-16BE"", 1);
        if (rar->sconv_utf16be == NULL)
          return (ARCHIVE_FATAL);
      }
      fn_sconv = rar->sconv_utf16be;

      strp = filename;
      while (memcmp(strp, ""\x00\x00"", 2))
      {
        if (!memcmp(strp, ""\x00\\"", 2))
          *(strp + 1) = '/';
        strp += 2;
      }
      p += offset;
    } else {
      /*
       * If FHD_UNICODE is set but no unicode data, this file name form
       * is UTF-8, so we have to update a string conversion object for
       * it accordingly.
       */
      if (rar->sconv_utf8 == NULL) {
        rar->sconv_utf8 = archive_string_conversion_from_charset(
           &a->archive, ""UTF-8"", 1);
        if (rar->sconv_utf8 == NULL)
          return (ARCHIVE_FATAL);
      }
      fn_sconv = rar->sconv_utf8;
      while ((strp = strchr(filename, '\\')) != NULL)
        *strp = '/';
      p += filename_size;
    }
  }
  else
  {
    fn_sconv = sconv;
    while ((strp = strchr(filename, '\\')) != NULL)
      *strp = '/';
    p += filename_size;
  }

  /* Split file in multivolume RAR. No more need to process header. */
  if (rar->filename_save &&
    filename_size == rar->filename_save_size &&
    !memcmp(rar->filename, rar->filename_save, filename_size + 1))
  {
    __archive_read_consume(a, header_size - 7);
    rar->cursor++;
    if (rar->cursor >= rar->nodes)
    {
      rar->nodes++;
      if ((rar->dbo =
        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
      {
        archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
        return (ARCHIVE_FATAL);
      }
      rar->dbo[rar->cursor].header_size = header_size;
      rar->dbo[rar->cursor].start_offset = -1;
      rar->dbo[rar->cursor].end_offset = -1;
    }
    if (rar->dbo[rar->cursor].start_offset < 0)
    {
      rar->dbo[rar->cursor].start_offset = a->filter->position;
      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
        rar->packed_size;
    }
    return ret;
  }
  else if (rar->filename_must_match)
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Mismatch of file parts split across multi-volume archive"");
    return (ARCHIVE_FATAL);
  }

  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);
  memcpy(rar->filename_save, rar->filename, filename_size + 1);
  rar->filename_save_size = filename_size;

  /* Set info for seeking */
  free(rar->dbo);
  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
    return (ARCHIVE_FATAL);
  }
  rar->dbo[0].header_size = header_size;
  rar->dbo[0].start_offset = -1;
  rar->dbo[0].end_offset = -1;
  rar->cursor = 0;
  rar->nodes = 1;

  if (rar->file_flags & FHD_SALT)
  {
    if (p + 8 > endp) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
        ""Invalid header size"");
      return (ARCHIVE_FATAL);
    }
    memcpy(rar->salt, p, 8);
    p += 8;
  }

  if (rar->file_flags & FHD_EXTTIME) {
    if (read_exttime(p, rar, endp) < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
        ""Invalid header size"");
      return (ARCHIVE_FATAL);
    }
  }

  __archive_read_consume(a, header_size - 7);
  rar->dbo[0].start_offset = a->filter->position;
  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;

  switch(file_header.host_os)
  {
  case OS_MSDOS:
  case OS_OS2:
  case OS_WIN32:
    rar->mode = archive_le32dec(file_header.file_attr);
    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
    else
      rar->mode = AE_IFREG;
    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
    break;

  case OS_UNIX:
  case OS_MAC_OS:
  case OS_BEOS:
    rar->mode = archive_le32dec(file_header.file_attr);
    break;

  default:
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Unknown file attributes from RAR file's host OS"");
    return (ARCHIVE_FATAL);
  }

  rar->bytes_uncopied = rar->bytes_unconsumed = 0;
  rar->lzss.position = rar->offset = 0;
  rar->offset_seek = 0;
  rar->dictionary_size = 0;
  rar->offset_outgoing = 0;
  rar->br.cache_avail = 0;
  rar->br.avail_in = 0;
  rar->crc_calculated = 0;
  rar->entry_eof = 0;
  rar->valid = 1;
  rar->is_ppmd_block = 0;
  rar->start_new_table = 1;
  free(rar->unp_buffer);
  rar->unp_buffer = NULL;
  rar->unp_offset = 0;
  rar->unp_buffer_size = UNP_BUFFER_SIZE;
  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
  rar->ppmd_valid = rar->ppmd_eod = 0;

  /* Don't set any archive entries for non-file header types */
  if (head_type == NEWSUB_HEAD)
    return ret;

  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
  archive_entry_set_atime(entry, rar->atime, rar->ansec);
  archive_entry_set_size(entry, rar->unp_size);
  archive_entry_set_mode(entry, rar->mode);

  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
  {
    if (errno == ENOMEM)
    {
      archive_set_error(&a->archive, ENOMEM,
                        ""Can't allocate memory for Pathname"");
      return (ARCHIVE_FATAL);
    }
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                      ""Pathname cannot be converted from %s to current locale."",
                      archive_string_conversion_charset_name(fn_sconv));
    ret = (ARCHIVE_WARN);
  }

  if (((rar->mode) & AE_IFMT) == AE_IFLNK)
  {
    /* Make sure a symbolic-link file does not have its body. */
    rar->bytes_remaining = 0;
    archive_entry_set_size(entry, 0);

    /* Read a symbolic-link name. */
    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
      return ret2;
    if (ret > ret2)
      ret = ret2;
  }

  if (rar->bytes_remaining == 0)
    rar->entry_eof = 1;

  return ret;
}","static int
read_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,
            char VAR_2)
{
  const void *VAR_3;
  const char *VAR_4, *VAR_5;
  struct rar *rar;
  struct rar_header rar_header;
  struct rar_file_header VAR_6;
  int64_t VAR_7;
  unsigned VAR_8, VAR_9;
  char *VAR_10;
  char *VAR_11;
  char VAR_12[8];
  char VAR_13[8];
  int VAR_14;
  struct archive_string_conv *VAR_15, *VAR_16;
  unsigned long VAR_17;
  int VAR_18 = (VAR_19), VAR_20;

  rar = (struct rar *)(VAR_0->format->data);

  /* COMMENT_0 */
  VAR_15 = rar->opt_sconv;
  if (VAR_15 == NULL) {
    if (!rar->init_default_conversion) {
      rar->sconv_default =
          archive_string_default_conversion_for_read(
            &(VAR_0->archive));
      rar->init_default_conversion = 1;
    }
    VAR_15 = rar->sconv_default;
  }


  if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)
    return (VAR_21);
  VAR_4 = VAR_3;
  memcpy(&rar_header, VAR_4, sizeof(rar_header));
  rar->file_flags = archive_le16dec(rar_header.flags);
  VAR_7 = archive_le16dec(rar_header.size);
  if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Invalid header size"");
    return (VAR_21);
  }
  VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);
  __archive_read_consume(VAR_0, 7);

  if (!(rar->file_flags & VAR_23))
  {
    rar->compression_method = 0;
    rar->packed_size = 0;
    rar->unp_size = 0;
    rar->mtime = 0;
    rar->ctime = 0;
    rar->atime = 0;
    rar->arctime = 0;
    rar->mode = 0;
    memset(&rar->salt, 0, sizeof(rar->salt));
    rar->atime = 0;
    rar->ansec = 0;
    rar->ctime = 0;
    rar->cnsec = 0;
    rar->mtime = 0;
    rar->mnsec = 0;
    rar->arctime = 0;
    rar->arcnsec = 0;
  }
  else
  {
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""RAR solid archive support unavailable."");
    return (VAR_21);
  }

  if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
    return (VAR_21);

  /* COMMENT_1 */
  VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));
  if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Header CRC error"");
    return (VAR_21);
  }
  /* COMMENT_2 */
  VAR_4 = VAR_3;
  VAR_5 = VAR_4 + VAR_7 - 7;
  memcpy(&VAR_6, VAR_4, sizeof(VAR_6));
  VAR_4 += sizeof(VAR_6);

  rar->compression_method = VAR_6.method;

  VAR_14 = archive_le32dec(VAR_6.file_time);
  rar->mtime = get_time(VAR_14);

  rar->file_crc = archive_le32dec(VAR_6.file_crc);

  if (rar->file_flags & VAR_24)
  {
	archive_entry_set_is_data_encrypted(VAR_1, 1);
	rar->has_encrypted_entries = 1;
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""RAR encryption support unavailable."");
    /* COMMENT_3 */
                                                                             
                                       
    /* COMMENT_6 */
  }

  if (rar->file_flags & VAR_25)
  {
    memcpy(VAR_12, VAR_6.pack_size, 4);
    memcpy(VAR_12 + 4, VAR_4, 4); /* COMMENT_7 */
    VAR_4 += 4;
    memcpy(VAR_13, VAR_6.unp_size, 4);
    memcpy(VAR_13 + 4, VAR_4, 4); /* COMMENT_8 */
    VAR_4 += 4;
    rar->packed_size = archive_le64dec(&VAR_12);
    rar->unp_size = archive_le64dec(&VAR_13);
  }
  else
  {
    rar->packed_size = archive_le32dec(VAR_6.pack_size);
    rar->unp_size = archive_le32dec(VAR_6.unp_size);
  }

  if (rar->packed_size < 0 || rar->unp_size < 0)
  {
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Invalid sizes specified."");
    return (VAR_21);
  }

  rar->bytes_remaining = rar->packed_size;

  /* COMMENT_9 */
                         
     
  if (VAR_2 == VAR_26) {
    size_t VAR_27 = VAR_4 - (const char *)VAR_3;
    VAR_7 += rar->packed_size;
    /* COMMENT_12 */
    if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)
        return (VAR_21);
    VAR_4 = VAR_3;
    VAR_5 = VAR_4 + VAR_7 - 7;
    VAR_4 += VAR_27;
  }

  VAR_8 = archive_le16dec(VAR_6.name_size);
  if (VAR_4 + VAR_8 > VAR_5) {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Invalid filename size"");
    return (VAR_21);
  }
  if (rar->filename_allocated < VAR_8 * 2 + 2) {
    char *VAR_28;
    size_t VAR_29 = VAR_8 * 2 + 2;
    VAR_28 = realloc(rar->filename, VAR_29);
    if (VAR_28 == NULL) {
      archive_set_error(&VAR_0->archive, VAR_30,
                        ""Couldn't allocate memory."");
      return (VAR_21);
    }
    rar->filename = VAR_28;
    rar->filename_allocated = VAR_29;
  }
  VAR_10 = rar->filename;
  memcpy(VAR_10, VAR_4, VAR_8);
  VAR_10[VAR_8] = '\0';
  if (rar->file_flags & VAR_31)
  {
    if (VAR_8 != strlen(VAR_10))
    {
      unsigned char VAR_32, VAR_33, VAR_34;
      unsigned VAR_35, VAR_36;

      VAR_9 = VAR_8;
      VAR_35 = VAR_8 * 2;
      VAR_8 = 0;
      VAR_36 = (unsigned)strlen(VAR_10) + 1;
      VAR_32 = *(VAR_4 + VAR_36++);
      VAR_33 = 0;
      VAR_34 = 0;
      while (VAR_36 < VAR_9 && VAR_8 < VAR_35)
      {
        if (!VAR_33)
        {
          VAR_34 = *(VAR_4 + VAR_36++);
          VAR_33 = 8;
        }

        VAR_33 -= 2;
        switch((VAR_34 >> VAR_33) & 3)
        {
          case 0:
            VAR_10[VAR_8++] = '\0';
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
            break;
          case 1:
            VAR_10[VAR_8++] = VAR_32;
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);
            break;
          case 2:
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);
            VAR_10[VAR_8++] = *(VAR_4 + VAR_36);
            VAR_36 += 2;
            break;
          case 3:
          {
            char VAR_37, VAR_38;
            uint8_t VAR_39 = *(VAR_4 + VAR_36++);

            if (VAR_39 & 0x80) {
              VAR_37 = *(VAR_4 + VAR_36++);
              VAR_38 = (char)VAR_32;
            } else
              VAR_37 = VAR_38 = 0;
            VAR_39 = (VAR_39 & 0x7f) + 2;
            while (VAR_39 && VAR_8 < VAR_35) {
              unsigned VAR_40 = VAR_8 >> 1;
              VAR_10[VAR_8++] = VAR_38;
              VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;
              VAR_39--;
            }
          }
          break;
        }
      }
      if (VAR_8 > VAR_35) {
        archive_set_error(&VAR_0->archive, VAR_22,
          ""Invalid filename"");
        return (VAR_21);
      }
      VAR_10[VAR_8++] = '\0';
      /* COMMENT_13 */
                                                                      
                                                          
         
      VAR_10[VAR_8] = '\0';

      /* COMMENT_17 */
                                     
      if (rar->sconv_utf16be == NULL) {
        rar->sconv_utf16be = archive_string_conversion_from_charset(
           &VAR_0->archive, ""UTF-16BE"", 1);
        if (rar->sconv_utf16be == NULL)
          return (VAR_21);
      }
      VAR_16 = rar->sconv_utf16be;

      VAR_11 = VAR_10;
      while (memcmp(VAR_11, ""\x00\x00"", 2))
      {
        if (!memcmp(VAR_11, ""\x00\\"", 2))
          *(VAR_11 + 1) = '/';
        VAR_11 += 2;
      }
      VAR_4 += VAR_36;
    } else {
      /* COMMENT_19 */
                                                                       
                                                                      
                        
         
      if (rar->sconv_utf8 == NULL) {
        rar->sconv_utf8 = archive_string_conversion_from_charset(
           &VAR_0->archive, ""UTF-8"", 1);
        if (rar->sconv_utf8 == NULL)
          return (VAR_21);
      }
      VAR_16 = rar->sconv_utf8;
      while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
        *VAR_11 = '/';
      VAR_4 += VAR_8;
    }
  }
  else
  {
    VAR_16 = VAR_15;
    while ((VAR_11 = strchr(VAR_10, '\\')) != NULL)
      *VAR_11 = '/';
    VAR_4 += VAR_8;
  }

  /* COMMENT_24 */
  if (rar->filename_save &&
    VAR_8 == rar->filename_save_size &&
    !memcmp(rar->filename, rar->filename_save, VAR_8 + 1))
  {
    __archive_read_consume(VAR_0, VAR_7 - 7);
    rar->cursor++;
    if (rar->cursor >= rar->nodes)
    {
      rar->nodes++;
      if ((rar->dbo =
        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
      {
        archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
        return (VAR_21);
      }
      rar->dbo[rar->cursor].header_size = VAR_7;
      rar->dbo[rar->cursor].start_offset = -1;
      rar->dbo[rar->cursor].end_offset = -1;
    }
    if (rar->dbo[rar->cursor].start_offset < 0)
    {
      rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;
      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
        rar->packed_size;
    }
    return VAR_18;
  }
  else if (rar->filename_must_match)
  {
    archive_set_error(&VAR_0->archive, VAR_22,
      ""Mismatch of file parts split across multi-volume archive"");
    return (VAR_21);
  }

  rar->filename_save = (char*)realloc(rar->filename_save,
                                      VAR_8 + 1);
  memcpy(rar->filename_save, rar->filename, VAR_8 + 1);
  rar->filename_save_size = VAR_8;

  /* COMMENT_25 */
  free(rar->dbo);
  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
  {
    archive_set_error(&VAR_0->archive, VAR_30, ""Couldn't allocate memory."");
    return (VAR_21);
  }
  rar->dbo[0].header_size = VAR_7;
  rar->dbo[0].start_offset = -1;
  rar->dbo[0].end_offset = -1;
  rar->cursor = 0;
  rar->nodes = 1;

  if (rar->file_flags & VAR_41)
  {
    if (VAR_4 + 8 > VAR_5) {
      archive_set_error(&VAR_0->archive, VAR_22,
        ""Invalid header size"");
      return (VAR_21);
    }
    memcpy(rar->salt, VAR_4, 8);
    VAR_4 += 8;
  }

  if (rar->file_flags & VAR_42) {
    if (read_exttime(VAR_4, rar, VAR_5) < 0) {
      archive_set_error(&VAR_0->archive, VAR_22,
        ""Invalid header size"");
      return (VAR_21);
    }
  }

  __archive_read_consume(VAR_0, VAR_7 - 7);
  rar->dbo[0].start_offset = VAR_0->filter->position;
  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;

  switch(VAR_6.host_os)
  {
  case VAR_43:
  case VAR_44:
  case VAR_45:
    rar->mode = archive_le32dec(VAR_6.file_attr);
    if (rar->mode & VAR_46)
      rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;
    else
      rar->mode = VAR_51;
    rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;
    break;

  case VAR_56:
  case VAR_57:
  case VAR_58:
    rar->mode = archive_le32dec(VAR_6.file_attr);
    break;

  default:
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Unknown file attributes from RAR file's host OS"");
    return (VAR_21);
  }

  rar->bytes_uncopied = rar->bytes_unconsumed = 0;
  rar->lzss.position = rar->offset = 0;
  rar->offset_seek = 0;
  rar->dictionary_size = 0;
  rar->offset_outgoing = 0;
  rar->br.cache_avail = 0;
  rar->br.avail_in = 0;
  rar->crc_calculated = 0;
  rar->entry_eof = 0;
  rar->valid = 1;
  rar->is_ppmd_block = 0;
  rar->start_new_table = 1;
  free(rar->unp_buffer);
  rar->unp_buffer = NULL;
  rar->unp_offset = 0;
  rar->unp_buffer_size = VAR_59;
  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
  VAR_60.Ppmd7_Free(&rar->ppmd7_context);
  rar->ppmd_valid = rar->ppmd_eod = 0;

  /* COMMENT_26 */
  if (VAR_2 == VAR_26)
    return VAR_18;

  archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);
  archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);
  archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);
  archive_entry_set_size(VAR_1, rar->unp_size);
  archive_entry_set_mode(VAR_1, rar->mode);

  if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))
  {
    if (VAR_61 == VAR_30)
    {
      archive_set_error(&VAR_0->archive, VAR_30,
                        ""Can't allocate memory for Pathname"");
      return (VAR_21);
    }
    archive_set_error(&VAR_0->archive, VAR_22,
                      ""Pathname cannot be converted from %s to current locale."",
                      archive_string_conversion_charset_name(VAR_16));
    VAR_18 = (VAR_62);
  }

  if (((rar->mode) & VAR_63) == VAR_64)
  {
    /* COMMENT_27 */
    rar->bytes_remaining = 0;
    archive_entry_set_size(VAR_1, 0);

    /* COMMENT_28 */
    if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_62))
      return VAR_20;
    if (VAR_18 > VAR_20)
      VAR_18 = VAR_20;
  }

  if (rar->bytes_remaining == 0)
    rar->entry_eof = 1;

  return VAR_18;
}",libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -313,6 +313,12 @@
     }
     return ret;
   }
+  else if (rar->filename_must_match)
+  {
+    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+      ""Mismatch of file parts split across multi-volume archive"");
+    return (ARCHIVE_FATAL);
+  }
 
   rar->filename_save = (char*)realloc(rar->filename_save,
                                       filename_size + 1);","{'deleted_lines': [], 'added_lines': ['  else if (rar->filename_must_match)', '  {', '    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,', '      ""Mismatch of file parts split across multi-volume archive"");', '    return (ARCHIVE_FATAL);', '  }']}",True,libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.,8.8,HIGH,2,valid,2018-12-03T13:55:22Z,2
CVE-2018-1000878,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libarchive,"rar: file split across multi-part archives must match

Fuzzing uncovered some UAF and memory overrun bugs where a file in a
single file archive reported that it was split across multiple
volumes. This was caused by ppmd7 operations calling
rar_br_fillup. This would invoke rar_read_ahead, which would in some
situations invoke archive_read_format_rar_read_header.  That would
check the new file name against the old file name, and if they didn't
match up it would free the ppmd7 buffer and allocate a new
one. However, because the ppmd7 decoder wasn't actually done with the
buffer, it would continue to used the freed buffer. Both reads and
writes to the freed region can be observed.

This is quite tricky to solve: once the buffer has been freed it is
too late, as the ppmd7 decoder functions almost universally assume
success - there's no way for ppmd_read to signal error, nor are there
good ways for functions like Range_Normalise to propagate them. So we
can't detect after the fact that we're in an invalid state - e.g. by
checking rar->cursor, we have to prevent ourselves from ever ending up
there. So, when we are in the dangerous part or rar_read_ahead that
assumes a valid split, we set a flag force read_header to either go
down the path for split files or bail. This means that the ppmd7
decoder keeps a valid buffer and just runs out of data.

Found with a combination of AFL, afl-rb and qsym.",bfcfe6f04ed20db2504db8a254d1f40a1d84eb28,https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28,libarchive/archive_read_support_format_rar.c,rar_read_ahead,"static const void *
rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
{
struct rar *rar = (struct rar *)(a->format->data);
const void *h = __archive_read_ahead(a, min, avail);
int ret;
if (avail)
{
if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)
*avail = a->archive.read_data_requested;
if (*avail > rar->bytes_remaining)
*avail = (ssize_t)rar->bytes_remaining;
if (*avail < 0)
return NULL;
else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
rar->file_flags & FHD_SPLIT_AFTER)
{
ret = archive_read_format_rar_read_header(a, a->entry);
if (ret == (ARCHIVE_EOF))
{
rar->has_endarc_header = 1;
ret = archive_read_format_rar_read_header(a, a->entry);
}
if (ret != (ARCHIVE_OK))
return NULL;
return rar_read_ahead(a, min, avail);
}
}
return h;
}","static const void *
rar_read_ahead(struct archive_read *VAR_0, size_t VAR_1, ssize_t *VAR_2)
{
struct rar *rar = (struct rar *)(VAR_0->format->data);
const void *VAR_3 = __archive_read_ahead(VAR_0, VAR_1, VAR_2);
int VAR_4;
if (VAR_2)
{
if (VAR_0->archive.read_data_is_posix_read && *VAR_2 > (ssize_t)VAR_0->archive.read_data_requested)
*VAR_2 = VAR_0->archive.read_data_requested;
if (*VAR_2 > rar->bytes_remaining)
*VAR_2 = (ssize_t)rar->bytes_remaining;
if (*VAR_2 < 0)
return NULL;
else if (*VAR_2 == 0 && rar->main_flags & VAR_5 &&
rar->file_flags & VAR_6)
{
VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);
if (VAR_4 == (VAR_7))
{
rar->has_endarc_header = 1;
VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);
}
if (VAR_4 != (VAR_8))
return NULL;
return rar_read_ahead(VAR_0, VAR_1, VAR_2);
}
}
return VAR_3;
}",libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/before/0.json,"static const void *
rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
{
  struct rar *rar = (struct rar *)(a->format->data);
  const void *h = __archive_read_ahead(a, min, avail);
  int ret;
  if (avail)
  {
    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)
      *avail = a->archive.read_data_requested;
    if (*avail > rar->bytes_remaining)
      *avail = (ssize_t)rar->bytes_remaining;
    if (*avail < 0)
      return NULL;
    else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
      rar->file_flags & FHD_SPLIT_AFTER)
    {
      rar->filename_must_match = 1;
      ret = archive_read_format_rar_read_header(a, a->entry);
      if (ret == (ARCHIVE_EOF))
      {
        rar->has_endarc_header = 1;
        ret = archive_read_format_rar_read_header(a, a->entry);
      }
      rar->filename_must_match = 0;
      if (ret != (ARCHIVE_OK))
        return NULL;
      return rar_read_ahead(a, min, avail);
    }
  }
  return h;
}","static const void *
rar_read_ahead(struct archive_read *VAR_0, size_t VAR_1, ssize_t *VAR_2)
{
  struct rar *rar = (struct rar *)(VAR_0->format->data);
  const void *VAR_3 = __archive_read_ahead(VAR_0, VAR_1, VAR_2);
  int VAR_4;
  if (VAR_2)
  {
    if (VAR_0->archive.read_data_is_posix_read && *VAR_2 > (ssize_t)VAR_0->archive.read_data_requested)
      *VAR_2 = VAR_0->archive.read_data_requested;
    if (*VAR_2 > rar->bytes_remaining)
      *VAR_2 = (ssize_t)rar->bytes_remaining;
    if (*VAR_2 < 0)
      return NULL;
    else if (*VAR_2 == 0 && rar->main_flags & VAR_5 &&
      rar->file_flags & VAR_6)
    {
      rar->filename_must_match = 1;
      VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);
      if (VAR_4 == (VAR_7))
      {
        rar->has_endarc_header = 1;
        VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);
      }
      rar->filename_must_match = 0;
      if (VAR_4 != (VAR_8))
        return NULL;
      return rar_read_ahead(VAR_0, VAR_1, VAR_2);
    }
  }
  return VAR_3;
}",libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,12 +15,14 @@
     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
       rar->file_flags & FHD_SPLIT_AFTER)
     {
+      rar->filename_must_match = 1;
       ret = archive_read_format_rar_read_header(a, a->entry);
       if (ret == (ARCHIVE_EOF))
       {
         rar->has_endarc_header = 1;
         ret = archive_read_format_rar_read_header(a, a->entry);
       }
+      rar->filename_must_match = 0;
       if (ret != (ARCHIVE_OK))
         return NULL;
       return rar_read_ahead(a, min, avail);","{'deleted_lines': [], 'added_lines': ['      rar->filename_must_match = 1;', '      rar->filename_must_match = 0;']}",True,libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.,8.8,HIGH,2,valid,2018-12-03T13:55:22Z,2
CVE-2018-20460,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix #12376 - crash in: rasm2 -a arm -b 64 '0 ,0,0,0,0,0,0,'",df167c7db545953bb7f71c72e98e7a3ca0c793bf,https://github.com/radareorg/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,libr/asm/arch/arm/armass64.c,parseOperands,"static bool parseOperands(char* str, ArmOp *op) {
char *t = strdup (str);
int operand = 0;
char *token = t;
char *x;
int imm_count = 0;
int mem_opt = 0;
if (!token) {
return false;
}
while (token) {
char *next = strchr (token, ',');
if (next) {
*next++ = 0;
}
while (token[0] == ' ') {
token++;
}
op->operands[operand].type = ARM_NOTYPE;
op->operands[operand].reg_type = ARM_UNDEFINED;
op->operands[operand].shift = ARM_NO_SHIFT;
while (token[0] == ' ' || token[0] == '[' || token[0] == ']') {
token ++;
}
if (!strncmp (token, ""lsl"", 3)) {
op->operands[operand].shift = ARM_LSL;
} else if (!strncmp (token, ""lsr"", 3)) {
op->operands[operand].shift = ARM_LSR;
} else if (!strncmp (token, ""asr"", 3)) {
op->operands[operand].shift = ARM_ASR;
}
if (op->operands[operand].shift != ARM_NO_SHIFT) {
op->operands_count ++;
op->operands[operand].shift_amount = r_num_math (NULL, token + 4);
if (op->operands[operand].shift_amount > 63) {
return false;
}
operand ++;
token = next;
continue;
}
switch (token[0]) {
case 'x':
x = strchr (token, ',');
if (x) {
x[0] = '\0';
}
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_REG64;
op->operands[operand].reg = r_num_math (NULL, token + 1);
if (op->operands[operand].reg > 31) {
return false;
}
break;
case 'w':
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_REG32;
op->operands[operand].reg = r_num_math (NULL, token + 1);
if (op->operands[operand].reg > 31) {
return false;
}
break;
case 'v':
op->operands_count ++;
op->operands[operand].type = ARM_FP;
op->operands[operand].reg = r_num_math (NULL, token + 1);
break;
case 's':
case 'S':
if (token[1] == 'P' || token [1] == 'p') {
int i;
for (i = 0; msr_const[i].name; i++) {
if (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {
op->operands[operand].sp_val = msr_const[i].val;
break;
}
}
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_SP | ARM_REG64;
op->operands[operand].reg = 31;
break;
}
mem_opt = get_mem_option (token);
if (mem_opt != -1) {
op->operands_count ++;
op->operands[operand].type = ARM_MEM_OPT;
op->operands[operand].mem_option = mem_opt;
}
break;
case 'L':
case 'l':
case 'I':
case 'i':
case 'N':
case 'n':
case 'O':
case 'o':
case 'p':
case 'P':
mem_opt = get_mem_option (token);
if (mem_opt != -1) {
op->operands_count ++;
op->operands[operand].type = ARM_MEM_OPT;
op->operands[operand].mem_option = mem_opt;
}
break;
case '-':
op->operands[operand].sign = -1;
default:
op->operands_count ++;
op->operands[operand].type = ARM_CONSTANT;
op->operands[operand].immediate = r_num_math (NULL, token);
imm_count++;
break;
}
token = next;
operand ++;
if (operand > MAX_OPERANDS) {
free (t);
return false;
}
}
free (t);
return true;
}","static bool parseOperands(char* VAR_0, ArmOp *VAR_1) {
char *VAR_2 = strdup (VAR_0);
int VAR_3 = 0;
char *VAR_4 = VAR_2;
char *VAR_5;
int VAR_6 = 0;
int VAR_7 = 0;
if (!VAR_4) {
return false;
}
while (VAR_4) {
char *VAR_8 = strchr (VAR_4, ',');
if (VAR_8) {
*VAR_8++ = 0;
}
while (VAR_4[0] == ' ') {
VAR_4++;
}
VAR_1->operands[VAR_3].type = VAR_9;
VAR_1->operands[VAR_3].reg_type = VAR_10;
VAR_1->operands[VAR_3].shift = VAR_11;
while (VAR_4[0] == ' ' || VAR_4[0] == '[' || VAR_4[0] == ']') {
VAR_4 ++;
}
if (!strncmp (VAR_4, ""lsl"", 3)) {
VAR_1->operands[VAR_3].shift = VAR_12;
} else if (!strncmp (VAR_4, ""lsr"", 3)) {
VAR_1->operands[VAR_3].shift = VAR_13;
} else if (!strncmp (VAR_4, ""asr"", 3)) {
VAR_1->operands[VAR_3].shift = VAR_14;
}
if (VAR_1->operands[VAR_3].shift != VAR_11) {
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].shift_amount = r_num_math (NULL, VAR_4 + 4);
if (VAR_1->operands[VAR_3].shift_amount > 63) {
return false;
}
VAR_3 ++;
VAR_4 = VAR_8;
continue;
}
switch (VAR_4[0]) {
case 'x':
VAR_5 = strchr (VAR_4, ',');
if (VAR_5) {
VAR_5[0] = '\0';
}
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_15;
VAR_1->operands[VAR_3].reg_type = VAR_16;
VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
if (VAR_1->operands[VAR_3].reg > 31) {
return false;
}
break;
case 'w':
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_15;
VAR_1->operands[VAR_3].reg_type = VAR_17;
VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
if (VAR_1->operands[VAR_3].reg > 31) {
return false;
}
break;
case 'v':
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_18;
VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
break;
case 's':
case 'S':
if (VAR_4[1] == 'P' || VAR_4 [1] == 'p') {
int VAR_19;
for (VAR_19 = 0; VAR_20[VAR_19].name; VAR_19++) {
if (!r_str_ncasecmp (VAR_4, VAR_20[VAR_19].name, strlen (VAR_20[VAR_19].name))) {
VAR_1->operands[VAR_3].sp_val = VAR_20[VAR_19].val;
break;
}
}
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_15;
VAR_1->operands[VAR_3].reg_type = VAR_21 | VAR_16;
VAR_1->operands[VAR_3].reg = 31;
break;
}
VAR_7 = get_mem_option (VAR_4);
if (VAR_7 != -1) {
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_22;
VAR_1->operands[VAR_3].mem_option = VAR_7;
}
break;
case 'L':
case 'l':
case 'I':
case 'i':
case 'N':
case 'n':
case 'O':
case 'o':
case 'p':
case 'P':
VAR_7 = get_mem_option (VAR_4);
if (VAR_7 != -1) {
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_22;
VAR_1->operands[VAR_3].mem_option = VAR_7;
}
break;
case '-':
VAR_1->operands[VAR_3].sign = -1;
default:
VAR_1->operands_count ++;
VAR_1->operands[VAR_3].type = VAR_23;
VAR_1->operands[VAR_3].immediate = r_num_math (NULL, VAR_4);
VAR_6++;
break;
}
VAR_4 = VAR_8;
VAR_3 ++;
if (VAR_3 > VAR_24) {
free (VAR_2);
return false;
}
}
free (VAR_2);
return true;
}",radareorg/radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf/armass64.c/vul/before/0.json,"static bool parseOperands(char* str, ArmOp *op) {
	char *t = strdup (str);
	int operand = 0;
	char *token = t;
	char *x;
	int imm_count = 0;
	int mem_opt = 0;
	if (!token) {
		return false;
	}

	while (token) {
		char *next = strchr (token, ',');
		if (next) {
			*next++ = 0;
		}
		while (token[0] == ' ') {
			token++;
		}
		if (operand >= MAX_OPERANDS) {
			eprintf (""Too many operands\n"");
			return false;
		}
		op->operands[operand].type = ARM_NOTYPE;
		op->operands[operand].reg_type = ARM_UNDEFINED;
		op->operands[operand].shift = ARM_NO_SHIFT;

		while (token[0] == ' ' || token[0] == '[' || token[0] == ']') {
			token ++;
		}

		if (!strncmp (token, ""lsl"", 3)) {
			op->operands[operand].shift = ARM_LSL;
		} else if (!strncmp (token, ""lsr"", 3)) {
			op->operands[operand].shift = ARM_LSR;
		} else if (!strncmp (token, ""asr"", 3)) {
			op->operands[operand].shift = ARM_ASR;
		}
		if (op->operands[operand].shift != ARM_NO_SHIFT) {
			op->operands_count ++;
			op->operands[operand].shift_amount = r_num_math (NULL, token + 4);
			if (op->operands[operand].shift_amount > 63) {
				return false;
			}
			operand ++;
			token = next;
			continue;
		}

		switch (token[0]) {
		case 'x':
			x = strchr (token, ',');
			if (x) {
				x[0] = '\0';
			}
			op->operands_count ++;
			op->operands[operand].type = ARM_GPR;
			op->operands[operand].reg_type = ARM_REG64;
			op->operands[operand].reg = r_num_math (NULL, token + 1);
			if (op->operands[operand].reg > 31) {
				return false;
			}
			break;
		case 'w':
			op->operands_count ++;
			op->operands[operand].type = ARM_GPR;
			op->operands[operand].reg_type = ARM_REG32;
			op->operands[operand].reg = r_num_math (NULL, token + 1);
			if (op->operands[operand].reg > 31) {
				return false;
			}
			break;
		case 'v':
			op->operands_count ++;
			op->operands[operand].type = ARM_FP;
			op->operands[operand].reg = r_num_math (NULL, token + 1);
			break;
		case 's':
		case 'S':
			if (token[1] == 'P' || token [1] == 'p') {
				int i;
				for (i = 0; msr_const[i].name; i++) {
					if (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {
						op->operands[operand].sp_val = msr_const[i].val;
						break;
					}
				}
				op->operands_count ++;
				op->operands[operand].type = ARM_GPR;
				op->operands[operand].reg_type = ARM_SP | ARM_REG64;
				op->operands[operand].reg = 31;
				break;
			}
			mem_opt = get_mem_option (token);
			if (mem_opt != -1) {
				op->operands_count ++;
				op->operands[operand].type = ARM_MEM_OPT;
				op->operands[operand].mem_option = mem_opt;
			}
			break;
		case 'L':
		case 'l':
		case 'I':
		case 'i':
		case 'N':
		case 'n':
		case 'O':
		case 'o':
		case 'p':
		case 'P':
			mem_opt = get_mem_option (token);
			if (mem_opt != -1) {
				op->operands_count ++;
				op->operands[operand].type = ARM_MEM_OPT;
				op->operands[operand].mem_option = mem_opt;
			}
			break;
		case '-':
			op->operands[operand].sign = -1;
			// falthru
		default:
			op->operands_count ++;
			op->operands[operand].type = ARM_CONSTANT;
			op->operands[operand].immediate = r_num_math (NULL, token);
			imm_count++;
			break;
		}
		token = next;

		operand ++;
		if (operand > MAX_OPERANDS) {
			free (t);
			return false;
		}
	}
	free (t);
	return true;
}","static bool parseOperands(char* VAR_0, ArmOp *VAR_1) {
	char *VAR_2 = strdup (VAR_0);
	int VAR_3 = 0;
	char *VAR_4 = VAR_2;
	char *VAR_5;
	int VAR_6 = 0;
	int VAR_7 = 0;
	if (!VAR_4) {
		return false;
	}

	while (VAR_4) {
		char *VAR_8 = strchr (VAR_4, ',');
		if (VAR_8) {
			*VAR_8++ = 0;
		}
		while (VAR_4[0] == ' ') {
			VAR_4++;
		}
		if (VAR_3 >= VAR_9) {
			eprintf (""Too many operands\n"");
			return false;
		}
		VAR_1->operands[VAR_3].type = VAR_10;
		VAR_1->operands[VAR_3].reg_type = VAR_11;
		VAR_1->operands[VAR_3].shift = VAR_12;

		while (VAR_4[0] == ' ' || VAR_4[0] == '[' || VAR_4[0] == ']') {
			VAR_4 ++;
		}

		if (!strncmp (VAR_4, ""lsl"", 3)) {
			VAR_1->operands[VAR_3].shift = VAR_13;
		} else if (!strncmp (VAR_4, ""lsr"", 3)) {
			VAR_1->operands[VAR_3].shift = VAR_14;
		} else if (!strncmp (VAR_4, ""asr"", 3)) {
			VAR_1->operands[VAR_3].shift = VAR_15;
		}
		if (VAR_1->operands[VAR_3].shift != VAR_12) {
			VAR_1->operands_count ++;
			VAR_1->operands[VAR_3].shift_amount = r_num_math (NULL, VAR_4 + 4);
			if (VAR_1->operands[VAR_3].shift_amount > 63) {
				return false;
			}
			VAR_3 ++;
			VAR_4 = VAR_8;
			continue;
		}

		switch (VAR_4[0]) {
		case 'x':
			VAR_5 = strchr (VAR_4, ',');
			if (VAR_5) {
				VAR_5[0] = '\0';
			}
			VAR_1->operands_count ++;
			VAR_1->operands[VAR_3].type = VAR_16;
			VAR_1->operands[VAR_3].reg_type = VAR_17;
			VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
			if (VAR_1->operands[VAR_3].reg > 31) {
				return false;
			}
			break;
		case 'w':
			VAR_1->operands_count ++;
			VAR_1->operands[VAR_3].type = VAR_16;
			VAR_1->operands[VAR_3].reg_type = VAR_18;
			VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
			if (VAR_1->operands[VAR_3].reg > 31) {
				return false;
			}
			break;
		case 'v':
			VAR_1->operands_count ++;
			VAR_1->operands[VAR_3].type = VAR_19;
			VAR_1->operands[VAR_3].reg = r_num_math (NULL, VAR_4 + 1);
			break;
		case 's':
		case 'S':
			if (VAR_4[1] == 'P' || VAR_4 [1] == 'p') {
				int VAR_20;
				for (VAR_20 = 0; VAR_21[VAR_20].name; VAR_20++) {
					if (!r_str_ncasecmp (VAR_4, VAR_21[VAR_20].name, strlen (VAR_21[VAR_20].name))) {
						VAR_1->operands[VAR_3].sp_val = VAR_21[VAR_20].val;
						break;
					}
				}
				VAR_1->operands_count ++;
				VAR_1->operands[VAR_3].type = VAR_16;
				VAR_1->operands[VAR_3].reg_type = VAR_22 | VAR_17;
				VAR_1->operands[VAR_3].reg = 31;
				break;
			}
			VAR_7 = get_mem_option (VAR_4);
			if (VAR_7 != -1) {
				VAR_1->operands_count ++;
				VAR_1->operands[VAR_3].type = VAR_23;
				VAR_1->operands[VAR_3].mem_option = VAR_7;
			}
			break;
		case 'L':
		case 'l':
		case 'I':
		case 'i':
		case 'N':
		case 'n':
		case 'O':
		case 'o':
		case 'p':
		case 'P':
			VAR_7 = get_mem_option (VAR_4);
			if (VAR_7 != -1) {
				VAR_1->operands_count ++;
				VAR_1->operands[VAR_3].type = VAR_23;
				VAR_1->operands[VAR_3].mem_option = VAR_7;
			}
			break;
		case '-':
			VAR_1->operands[VAR_3].sign = -1;
			/* COMMENT_0 */
		default:
			VAR_1->operands_count ++;
			VAR_1->operands[VAR_3].type = VAR_24;
			VAR_1->operands[VAR_3].immediate = r_num_math (NULL, VAR_4);
			VAR_6++;
			break;
		}
		VAR_4 = VAR_8;

		VAR_3 ++;
		if (VAR_3 > VAR_9) {
			free (VAR_2);
			return false;
		}
	}
	free (VAR_2);
	return true;
}",radareorg/radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf/armass64.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,10 @@
 		}
 		while (token[0] == ' ') {
 			token++;
+		}
+		if (operand >= MAX_OPERANDS) {
+			eprintf (""Too many operands\n"");
+			return false;
 		}
 		op->operands[operand].type = ARM_NOTYPE;
 		op->operands[operand].reg_type = ARM_UNDEFINED;","{'deleted_lines': [], 'added_lines': ['\t\t}', '\t\tif (operand >= MAX_OPERANDS) {', '\t\t\teprintf (""Too many operands\\n"");', '\t\t\treturn false;']}",True,"In radare2 prior to 3.1.2, the parseOperands function in libr/asm/arch/arm/armass64.c allows attackers to cause a denial-of-service (application crash caused by stack-based buffer overflow) by crafting an input file.",5.5,MEDIUM,1,valid,2018-12-03T14:29:26Z,2
CVE-2018-19824,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"ALSA: usb-audio: Fix UAF decrement if card has no live interfaces in card.c

If a USB sound card reports 0 interfaces, an error condition is triggered
and the function usb_audio_probe errors out. In the error path, there was a
use-after-free vulnerability where the memory object of the card was first
freed, followed by a decrement of the number of active chips. Moving the
decrement above the atomic_dec fixes the UAF.

[ The original problem was introduced in 3.1 kernel, while it was
  developed in a different form.  The Fixes tag below indicates the
  original commit but it doesn't mean that the patch is applicable
  cleanly. -- tiwai ]

Fixes: 362e4e49abe5 (""ALSA: usb-audio - clear chip->probing on error exit"")
Reported-by: Hui Peng <benquike@gmail.com>
Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
Signed-off-by: Hui Peng <benquike@gmail.com>
Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",5f8cf712582617d523120df67d392059eaf2fc4b,https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b,sound/usb/card.c,usb_audio_probe,"static int usb_audio_probe(struct usb_interface *intf,
const struct usb_device_id *usb_id)
{
struct usb_device *dev = interface_to_usbdev(intf);
const struct snd_usb_audio_quirk *quirk =
(const struct snd_usb_audio_quirk *)usb_id->driver_info;
struct snd_usb_audio *chip;
int i, err;
struct usb_host_interface *alts;
int ifnum;
u32 id;
alts = &intf->altsetting[0];
ifnum = get_iface_desc(alts)->bInterfaceNumber;
id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
le16_to_cpu(dev->descriptor.idProduct));
if (get_alias_id(dev, &id))
quirk = get_alias_quirk(dev, id);
if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
return -ENXIO;
err = snd_usb_apply_boot_quirk(dev, intf, quirk, id);
if (err < 0)
return err;
chip = NULL;
mutex_lock(&register_mutex);
for (i = 0; i < SNDRV_CARDS; i++) {
if (usb_chip[i] && usb_chip[i]->dev == dev) {
if (atomic_read(&usb_chip[i]->shutdown)) {
dev_err(&dev->dev, ""USB device is in the shutdown state, cannot create a card instance\n"");
err = -EIO;
goto __error;
}
chip = usb_chip[i];
atomic_inc(&chip->active); 
break;
}
}
if (! chip) {
for (i = 0; i < SNDRV_CARDS; i++)
if (!usb_chip[i] &&
(vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
(pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
if (enable[i]) {
err = snd_usb_audio_create(intf, dev, i, quirk,
id, &chip);
if (err < 0)
goto __error;
chip->pm_intf = intf;
break;
} else if (vid[i] != -1 || pid[i] != -1) {
dev_info(&dev->dev,
""device (%04x:%04x) is disabled\n"",
USB_ID_VENDOR(id),
USB_ID_PRODUCT(id));
err = -ENOENT;
goto __error;
}
}
if (!chip) {
dev_err(&dev->dev, ""no available usb audio device\n"");
err = -ENODEV;
goto __error;
}
}
dev_set_drvdata(&dev->dev, chip);
if (!chip->ctrl_intf)
chip->ctrl_intf = alts;
chip->txfr_quirk = 0;
err = 1; 
if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);
if (err < 0)
goto __error;
}
if (err > 0) {
err = snd_usb_create_streams(chip, ifnum);
if (err < 0)
goto __error;
err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);
if (err < 0)
goto __error;
}
err = snd_card_register(chip->card);
if (err < 0)
goto __error;
usb_chip[chip->index] = chip;
chip->num_interfaces++;
usb_set_intfdata(intf, chip);
atomic_dec(&chip->active);
mutex_unlock(&register_mutex);
return 0;
__error:
if (chip) {
if (!chip->num_interfaces)
snd_card_free(chip->card);
atomic_dec(&chip->active);
}
mutex_unlock(&register_mutex);
return err;
}","static int usb_audio_probe(struct usb_interface *VAR_0,
const struct usb_device_id *VAR_1)
{
struct usb_device *VAR_2 = interface_to_usbdev(VAR_0);
const struct snd_usb_audio_quirk *VAR_3 =
(const struct snd_usb_audio_quirk *)VAR_1->driver_info;
struct snd_usb_audio *VAR_4;
int VAR_5, VAR_6;
struct usb_host_interface *VAR_7;
int VAR_8;
u32 VAR_9;
VAR_7 = &VAR_0->altsetting[0];
VAR_8 = get_iface_desc(VAR_7)->bInterfaceNumber;
VAR_9 = USB_ID(le16_to_cpu(VAR_2->descriptor.idVendor),
le16_to_cpu(VAR_2->descriptor.idProduct));
if (get_alias_id(VAR_2, &VAR_9))
VAR_3 = get_alias_quirk(VAR_2, VAR_9);
if (VAR_3 && VAR_3->ifnum >= 0 && VAR_8 != VAR_3->ifnum)
return -VAR_10;
VAR_6 = snd_usb_apply_boot_quirk(VAR_2, VAR_0, VAR_3, VAR_9);
if (VAR_6 < 0)
return VAR_6;
VAR_4 = NULL;
mutex_lock(&VAR_11);
for (VAR_5 = 0; VAR_5 < VAR_12; VAR_5++) {
if (VAR_13[VAR_5] && VAR_13[VAR_5]->dev == VAR_2) {
if (atomic_read(&VAR_13[VAR_5]->shutdown)) {
dev_err(&VAR_2->dev, ""USB device is in the shutdown state, cannot create a card instance\n"");
VAR_6 = -VAR_14;
goto __error;
}
VAR_4 = VAR_13[VAR_5];
atomic_inc(&VAR_4->active); 
break;
}
}
if (! VAR_4) {
for (VAR_5 = 0; VAR_5 < VAR_12; VAR_5++)
if (!VAR_13[VAR_5] &&
(VAR_15[VAR_5] == -1 || VAR_15[VAR_5] == USB_ID_VENDOR(VAR_9)) &&
(VAR_16[VAR_5] == -1 || VAR_16[VAR_5] == USB_ID_PRODUCT(VAR_9))) {
if (VAR_17[VAR_5]) {
VAR_6 = snd_usb_audio_create(VAR_0, VAR_2, VAR_5, VAR_3,
VAR_9, &VAR_4);
if (VAR_6 < 0)
goto __error;
VAR_4->pm_intf = VAR_0;
break;
} else if (VAR_15[VAR_5] != -1 || VAR_16[VAR_5] != -1) {
dev_info(&VAR_2->dev,
""device (%04x:%04x) is disabled\n"",
USB_ID_VENDOR(VAR_9),
USB_ID_PRODUCT(VAR_9));
VAR_6 = -VAR_18;
goto __error;
}
}
if (!VAR_4) {
dev_err(&VAR_2->dev, ""no available usb audio device\n"");
VAR_6 = -VAR_19;
goto __error;
}
}
dev_set_drvdata(&VAR_2->dev, VAR_4);
if (!VAR_4->ctrl_intf)
VAR_4->ctrl_intf = VAR_7;
VAR_4->txfr_quirk = 0;
VAR_6 = 1; 
if (VAR_3 && VAR_3->ifnum != VAR_20) {
VAR_6 = snd_usb_create_quirk(VAR_4, VAR_0, &VAR_21, VAR_3);
if (VAR_6 < 0)
goto __error;
}
if (VAR_6 > 0) {
VAR_6 = snd_usb_create_streams(VAR_4, VAR_8);
if (VAR_6 < 0)
goto __error;
VAR_6 = snd_usb_create_mixer(VAR_4, VAR_8, VAR_22);
if (VAR_6 < 0)
goto __error;
}
VAR_6 = snd_card_register(VAR_4->card);
if (VAR_6 < 0)
goto __error;
VAR_13[VAR_4->index] = VAR_4;
VAR_4->num_interfaces++;
usb_set_intfdata(VAR_0, VAR_4);
atomic_dec(&VAR_4->active);
mutex_unlock(&VAR_11);
return 0;
__error:
if (VAR_4) {
if (!VAR_4->num_interfaces)
snd_card_free(VAR_4->card);
atomic_dec(&VAR_4->active);
}
mutex_unlock(&VAR_11);
return VAR_6;
}",torvalds/linux/5f8cf712582617d523120df67d392059eaf2fc4b/card.c/vul/before/0.json,"static int usb_audio_probe(struct usb_interface *intf,
			   const struct usb_device_id *usb_id)
{
	struct usb_device *dev = interface_to_usbdev(intf);
	const struct snd_usb_audio_quirk *quirk =
		(const struct snd_usb_audio_quirk *)usb_id->driver_info;
	struct snd_usb_audio *chip;
	int i, err;
	struct usb_host_interface *alts;
	int ifnum;
	u32 id;

	alts = &intf->altsetting[0];
	ifnum = get_iface_desc(alts)->bInterfaceNumber;
	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
		    le16_to_cpu(dev->descriptor.idProduct));
	if (get_alias_id(dev, &id))
		quirk = get_alias_quirk(dev, id);
	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
		return -ENXIO;

	err = snd_usb_apply_boot_quirk(dev, intf, quirk, id);
	if (err < 0)
		return err;

	/*
	 * found a config.  now register to ALSA
	 */

	/* check whether it's already registered */
	chip = NULL;
	mutex_lock(&register_mutex);
	for (i = 0; i < SNDRV_CARDS; i++) {
		if (usb_chip[i] && usb_chip[i]->dev == dev) {
			if (atomic_read(&usb_chip[i]->shutdown)) {
				dev_err(&dev->dev, ""USB device is in the shutdown state, cannot create a card instance\n"");
				err = -EIO;
				goto __error;
			}
			chip = usb_chip[i];
			atomic_inc(&chip->active); /* avoid autopm */
			break;
		}
	}
	if (! chip) {
		/* it's a fresh one.
		 * now look for an empty slot and create a new card instance
		 */
		for (i = 0; i < SNDRV_CARDS; i++)
			if (!usb_chip[i] &&
			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
				if (enable[i]) {
					err = snd_usb_audio_create(intf, dev, i, quirk,
								   id, &chip);
					if (err < 0)
						goto __error;
					chip->pm_intf = intf;
					break;
				} else if (vid[i] != -1 || pid[i] != -1) {
					dev_info(&dev->dev,
						 ""device (%04x:%04x) is disabled\n"",
						 USB_ID_VENDOR(id),
						 USB_ID_PRODUCT(id));
					err = -ENOENT;
					goto __error;
				}
			}
		if (!chip) {
			dev_err(&dev->dev, ""no available usb audio device\n"");
			err = -ENODEV;
			goto __error;
		}
	}
	dev_set_drvdata(&dev->dev, chip);

	/*
	 * For devices with more than one control interface, we assume the
	 * first contains the audio controls. We might need a more specific
	 * check here in the future.
	 */
	if (!chip->ctrl_intf)
		chip->ctrl_intf = alts;

	chip->txfr_quirk = 0;
	err = 1; /* continue */
	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
		/* need some special handlings */
		err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);
		if (err < 0)
			goto __error;
	}

	if (err > 0) {
		/* create normal USB audio interfaces */
		err = snd_usb_create_streams(chip, ifnum);
		if (err < 0)
			goto __error;
		err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);
		if (err < 0)
			goto __error;
	}

	/* we are allowed to call snd_card_register() many times */
	err = snd_card_register(chip->card);
	if (err < 0)
		goto __error;

	usb_chip[chip->index] = chip;
	chip->num_interfaces++;
	usb_set_intfdata(intf, chip);
	atomic_dec(&chip->active);
	mutex_unlock(&register_mutex);
	return 0;

 __error:
	if (chip) {
		/* chip->active is inside the chip->card object,
		 * decrement before memory is possibly returned.
		 */
		atomic_dec(&chip->active);
		if (!chip->num_interfaces)
			snd_card_free(chip->card);
	}
	mutex_unlock(&register_mutex);
	return err;
}","static int usb_audio_probe(struct usb_interface *VAR_0,
			   const struct usb_device_id *VAR_1)
{
	struct usb_device *VAR_2 = interface_to_usbdev(VAR_0);
	const struct snd_usb_audio_quirk *VAR_3 =
		(const struct snd_usb_audio_quirk *)VAR_1->driver_info;
	struct snd_usb_audio *VAR_4;
	int VAR_5, VAR_6;
	struct usb_host_interface *VAR_7;
	int VAR_8;
	u32 VAR_9;

	VAR_7 = &VAR_0->altsetting[0];
	VAR_8 = get_iface_desc(VAR_7)->bInterfaceNumber;
	VAR_9 = USB_ID(le16_to_cpu(VAR_2->descriptor.idVendor),
		    le16_to_cpu(VAR_2->descriptor.idProduct));
	if (get_alias_id(VAR_2, &VAR_9))
		VAR_3 = get_alias_quirk(VAR_2, VAR_9);
	if (VAR_3 && VAR_3->ifnum >= 0 && VAR_8 != VAR_3->ifnum)
		return -VAR_10;

	VAR_6 = snd_usb_apply_boot_quirk(VAR_2, VAR_0, VAR_3, VAR_9);
	if (VAR_6 < 0)
		return VAR_6;

	/* COMMENT_0 */
                                         
    

	/* COMMENT_3 */
	VAR_4 = NULL;
	mutex_lock(&VAR_11);
	for (VAR_5 = 0; VAR_5 < VAR_12; VAR_5++) {
		if (VAR_13[VAR_5] && VAR_13[VAR_5]->dev == VAR_2) {
			if (atomic_read(&VAR_13[VAR_5]->shutdown)) {
				dev_err(&VAR_2->dev, ""USB device is in the shutdown state, cannot create a card instance\n"");
				VAR_6 = -VAR_14;
				goto __error;
			}
			VAR_4 = VAR_13[VAR_5];
			atomic_inc(&VAR_4->active); /* COMMENT_4 */
			break;
		}
	}
	if (! VAR_4) {
		/* COMMENT_5 */
                                                              
     
		for (VAR_5 = 0; VAR_5 < VAR_12; VAR_5++)
			if (!VAR_13[VAR_5] &&
			    (VAR_15[VAR_5] == -1 || VAR_15[VAR_5] == USB_ID_VENDOR(VAR_9)) &&
			    (VAR_16[VAR_5] == -1 || VAR_16[VAR_5] == USB_ID_PRODUCT(VAR_9))) {
				if (VAR_17[VAR_5]) {
					VAR_6 = snd_usb_audio_create(VAR_0, VAR_2, VAR_5, VAR_3,
								   VAR_9, &VAR_4);
					if (VAR_6 < 0)
						goto __error;
					VAR_4->pm_intf = VAR_0;
					break;
				} else if (VAR_15[VAR_5] != -1 || VAR_16[VAR_5] != -1) {
					dev_info(&VAR_2->dev,
						 ""device (%04x:%04x) is disabled\n"",
						 USB_ID_VENDOR(VAR_9),
						 USB_ID_PRODUCT(VAR_9));
					VAR_6 = -VAR_18;
					goto __error;
				}
			}
		if (!VAR_4) {
			dev_err(&VAR_2->dev, ""no available usb audio device\n"");
			VAR_6 = -VAR_19;
			goto __error;
		}
	}
	dev_set_drvdata(&VAR_2->dev, VAR_4);

	/* COMMENT_8 */
                                                                   
                                                                    
                             
    
	if (!VAR_4->ctrl_intf)
		VAR_4->ctrl_intf = VAR_7;

	VAR_4->txfr_quirk = 0;
	VAR_6 = 1; /* COMMENT_13 */
	if (VAR_3 && VAR_3->ifnum != VAR_20) {
		/* COMMENT_14 */
		VAR_6 = snd_usb_create_quirk(VAR_4, VAR_0, &VAR_21, VAR_3);
		if (VAR_6 < 0)
			goto __error;
	}

	if (VAR_6 > 0) {
		/* COMMENT_15 */
		VAR_6 = snd_usb_create_streams(VAR_4, VAR_8);
		if (VAR_6 < 0)
			goto __error;
		VAR_6 = snd_usb_create_mixer(VAR_4, VAR_8, VAR_22);
		if (VAR_6 < 0)
			goto __error;
	}

	/* COMMENT_16 */
	VAR_6 = snd_card_register(VAR_4->card);
	if (VAR_6 < 0)
		goto __error;

	VAR_13[VAR_4->index] = VAR_4;
	VAR_4->num_interfaces++;
	usb_set_intfdata(VAR_0, VAR_4);
	atomic_dec(&VAR_4->active);
	mutex_unlock(&VAR_11);
	return 0;

 __error:
	if (VAR_4) {
		/* COMMENT_17 */
                                                  
     
		atomic_dec(&VAR_4->active);
		if (!VAR_4->num_interfaces)
			snd_card_free(VAR_4->card);
	}
	mutex_unlock(&VAR_11);
	return VAR_6;
}",torvalds/linux/5f8cf712582617d523120df67d392059eaf2fc4b/card.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -115,9 +115,12 @@
 
  __error:
 	if (chip) {
+		/* chip->active is inside the chip->card object,
+		 * decrement before memory is possibly returned.
+		 */
+		atomic_dec(&chip->active);
 		if (!chip->num_interfaces)
 			snd_card_free(chip->card);
-		atomic_dec(&chip->active);
 	}
 	mutex_unlock(&register_mutex);
 	return err;","{'deleted_lines': ['\t\tatomic_dec(&chip->active);'], 'added_lines': ['\t\t/* chip->active is inside the chip->card object,', '\t\t * decrement before memory is possibly returned.', '\t\t */', '\t\tatomic_dec(&chip->active);']}",True,"In the Linux kernel through 4.19.6, a local user could exploit a use-after-free in the ALSA driver by supplying a malicious USB Sound device (with zero interfaces) that is mishandled in usb_audio_probe in sound/usb/card.c.",7.8,HIGH,2,valid,2018-12-03T15:09:34Z,2
CVE-2018-20004,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,michaelrsweet/mxml,Fix potential buffer overflow when writing a double (Issue #233),4f5577dd4672d228e4180f06bdbd66f343ea45e0,https://github.com/michaelrsweet/mxml/commit/4f5577dd4672d228e4180f06bdbd66f343ea45e0,mxml-file.c,mxml_write_node,"static int
mxml_write_node(mxml_node_t     *node,
void            *p,
mxml_save_cb_t  cb,
int             col,
_mxml_putc_cb_t putc_cb,
_mxml_global_t  *global)
{
mxml_node_t*current,
*next;
inti,
width;
mxml_attr_t*attr;
chars[255];
for (current = node; current; current = next)
{
switch (current->type)
{
case MXML_ELEMENT :
col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
if ((*putc_cb)('<', p) < 0)
return (-1);
if (current->value.element.name[0] == '?' ||
!strncmp(current->value.element.name, ""!--"", 3))
{
const char*ptr;
for (ptr = current->value.element.name; *ptr; ptr ++)
if ((*putc_cb)(*ptr, p) < 0)
return (-1);
}
else if (!strncmp(current->value.element.name, ""![CDATA["", 8))
{
const char*ptr;
for (ptr = current->value.element.name; *ptr; ptr ++)
if ((*putc_cb)(*ptr, p) < 0)
return (-1);
if ((*putc_cb)(']', p) < 0)
return (-1);
if ((*putc_cb)(']', p) < 0)
return (-1);
}
else if (mxml_write_name(current->value.element.name, p, putc_cb) < 0)
return (-1);
col += strlen(current->value.element.name) + 1;
for (i = current->value.element.num_attrs, attr = current->value.element.attrs;
i > 0;
i --, attr ++)
{
width = (int)strlen(attr->name);
if (attr->value)
width += strlen(attr->value) + 3;
if (global->wrap > 0 && (col + width) > global->wrap)
{
if ((*putc_cb)('\n', p) < 0)
return (-1);
col = 0;
}
else
{
if ((*putc_cb)(' ', p) < 0)
return (-1);
col ++;
}
if (mxml_write_name(attr->name, p, putc_cb) < 0)
return (-1);
if (attr->value)
{
if ((*putc_cb)('=', p) < 0)
return (-1);
if ((*putc_cb)('\""', p) < 0)
return (-1);
if (mxml_write_string(attr->value, p, putc_cb) < 0)
return (-1);
if ((*putc_cb)('\""', p) < 0)
return (-1);
}
col += width;
}
if (current->child)
{
if ((*putc_cb)('>', p) < 0)
return (-1);
else
col ++;
col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
}
else if (current->value.element.name[0] == '!' ||
current->value.element.name[0] == '?')
{
if ((*putc_cb)('>', p) < 0)
return (-1);
else
col ++;
col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
}
else
{
if ((*putc_cb)(' ', p) < 0)
return (-1);
if ((*putc_cb)('/', p) < 0)
return (-1);
if ((*putc_cb)('>', p) < 0)
return (-1);
col += 3;
col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
}
break;
case MXML_INTEGER :
if (current->prev)
{
if (global->wrap > 0 && col > global->wrap)
{
if ((*putc_cb)('\n', p) < 0)
return (-1);
col = 0;
}
else if ((*putc_cb)(' ', p) < 0)
return (-1);
else
col ++;
}
sprintf(s, ""%d"", current->value.integer);
if (mxml_write_string(s, p, putc_cb) < 0)
return (-1);
col += strlen(s);
break;
case MXML_OPAQUE :
if (mxml_write_string(current->value.opaque, p, putc_cb) < 0)
return (-1);
col += strlen(current->value.opaque);
break;
case MXML_REAL :
if (current->prev)
{
if (global->wrap > 0 && col > global->wrap)
{
if ((*putc_cb)('\n', p) < 0)
return (-1);
col = 0;
}
else if ((*putc_cb)(' ', p) < 0)
return (-1);
else
col ++;
}
sprintf(s, ""%f"", current->value.real);
if (mxml_write_string(s, p, putc_cb) < 0)
return (-1);
col += strlen(s);
break;
case MXML_TEXT :
if (current->value.text.whitespace && col > 0)
{
if (global->wrap > 0 && col > global->wrap)
{
if ((*putc_cb)('\n', p) < 0)
return (-1);
col = 0;
}
else if ((*putc_cb)(' ', p) < 0)
return (-1);
else
col ++;
}
if (mxml_write_string(current->value.text.string, p, putc_cb) < 0)
return (-1);
col += strlen(current->value.text.string);
break;
case MXML_CUSTOM :
if (global->custom_save_cb)
{
char*data;
const char*newline;
if ((data = (*global->custom_save_cb)(current)) == NULL)
return (-1);
if (mxml_write_string(data, p, putc_cb) < 0)
return (-1);
if ((newline = strrchr(data, '\n')) == NULL)
col += strlen(data);
else
col = (int)strlen(newline);
free(data);
break;
}
default : 
return (-1);
}
if ((next = current->child) == NULL)
{
if (current == node)
{
next = NULL;
}
else
{
while ((next = current->next) == NULL)
{
if (current == node || !current->parent)
break;
current = current->parent;
if (current->value.element.name[0] != '!' &&
current->value.element.name[0] != '?')
{
col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
if ((*putc_cb)('<', p) < 0)
return (-1);
if ((*putc_cb)('/', p) < 0)
return (-1);
if (mxml_write_string(current->value.element.name, p, putc_cb) < 0)
return (-1);
if ((*putc_cb)('>', p) < 0)
return (-1);
col += strlen(current->value.element.name) + 3;
col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
}
if (current == node)
break;
}
}
}
}
return (col);
}","static int
mxml_write_node(mxml_node_t     *VAR_0,
void            *VAR_1,
mxml_save_cb_t  VAR_2,
int             VAR_3,
_mxml_putc_cb_t VAR_4,
_mxml_global_t  *VAR_5)
{
mxml_node_t*VAR_6,
*VAR_7;
intVAR_8,
VAR_9;
mxml_attr_t*VAR_10;
charVAR_11[255];
for (VAR_6 = VAR_0; VAR_6; VAR_6 = VAR_7)
{
switch (VAR_6->type)
{
case VAR_12 :
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_13, VAR_3, VAR_4);
if ((*VAR_4)('<', VAR_1) < 0)
return (-1);
if (VAR_6->value.element.name[0] == '?' ||
!strncmp(VAR_6->value.element.name, ""!--"", 3))
{
const char*VAR_14;
for (VAR_14 = VAR_6->value.element.name; *VAR_14; VAR_14 ++)
if ((*VAR_4)(*VAR_14, VAR_1) < 0)
return (-1);
}
else if (!strncmp(VAR_6->value.element.name, ""![CDATA["", 8))
{
const char*VAR_14;
for (VAR_14 = VAR_6->value.element.name; *VAR_14; VAR_14 ++)
if ((*VAR_4)(*VAR_14, VAR_1) < 0)
return (-1);
if ((*VAR_4)(']', VAR_1) < 0)
return (-1);
if ((*VAR_4)(']', VAR_1) < 0)
return (-1);
}
else if (mxml_write_name(VAR_6->value.element.name, VAR_1, VAR_4) < 0)
return (-1);
VAR_3 += strlen(VAR_6->value.element.name) + 1;
for (VAR_8 = VAR_6->value.element.num_attrs, VAR_10 = VAR_6->value.element.attrs;
VAR_8 > 0;
VAR_8 --, VAR_10 ++)
{
VAR_9 = (int)strlen(VAR_10->name);
if (VAR_10->value)
VAR_9 += strlen(VAR_10->value) + 3;
if (VAR_5->wrap > 0 && (VAR_3 + VAR_9) > VAR_5->wrap)
{
if ((*VAR_4)('\n', VAR_1) < 0)
return (-1);
VAR_3 = 0;
}
else
{
if ((*VAR_4)(' ', VAR_1) < 0)
return (-1);
VAR_3 ++;
}
if (mxml_write_name(VAR_10->name, VAR_1, VAR_4) < 0)
return (-1);
if (VAR_10->value)
{
if ((*VAR_4)('=', VAR_1) < 0)
return (-1);
if ((*VAR_4)('\""', VAR_1) < 0)
return (-1);
if (mxml_write_string(VAR_10->value, VAR_1, VAR_4) < 0)
return (-1);
if ((*VAR_4)('\""', VAR_1) < 0)
return (-1);
}
VAR_3 += VAR_9;
}
if (VAR_6->child)
{
if ((*VAR_4)('>', VAR_1) < 0)
return (-1);
else
VAR_3 ++;
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
}
else if (VAR_6->value.element.name[0] == '!' ||
VAR_6->value.element.name[0] == '?')
{
if ((*VAR_4)('>', VAR_1) < 0)
return (-1);
else
VAR_3 ++;
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
}
else
{
if ((*VAR_4)(' ', VAR_1) < 0)
return (-1);
if ((*VAR_4)('/', VAR_1) < 0)
return (-1);
if ((*VAR_4)('>', VAR_1) < 0)
return (-1);
VAR_3 += 3;
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
}
break;
case VAR_16 :
if (VAR_6->prev)
{
if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
{
if ((*VAR_4)('\n', VAR_1) < 0)
return (-1);
VAR_3 = 0;
}
else if ((*VAR_4)(' ', VAR_1) < 0)
return (-1);
else
VAR_3 ++;
}
sprintf(VAR_11, ""%d"", VAR_6->value.integer);
if (mxml_write_string(VAR_11, VAR_1, VAR_4) < 0)
return (-1);
VAR_3 += strlen(VAR_11);
break;
case VAR_17 :
if (mxml_write_string(VAR_6->value.opaque, VAR_1, VAR_4) < 0)
return (-1);
VAR_3 += strlen(VAR_6->value.opaque);
break;
case VAR_18 :
if (VAR_6->prev)
{
if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
{
if ((*VAR_4)('\n', VAR_1) < 0)
return (-1);
VAR_3 = 0;
}
else if ((*VAR_4)(' ', VAR_1) < 0)
return (-1);
else
VAR_3 ++;
}
sprintf(VAR_11, ""%f"", VAR_6->value.real);
if (mxml_write_string(VAR_11, VAR_1, VAR_4) < 0)
return (-1);
VAR_3 += strlen(VAR_11);
break;
case VAR_19 :
if (VAR_6->value.text.whitespace && VAR_3 > 0)
{
if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
{
if ((*VAR_4)('\n', VAR_1) < 0)
return (-1);
VAR_3 = 0;
}
else if ((*VAR_4)(' ', VAR_1) < 0)
return (-1);
else
VAR_3 ++;
}
if (mxml_write_string(VAR_6->value.text.string, VAR_1, VAR_4) < 0)
return (-1);
VAR_3 += strlen(VAR_6->value.text.string);
break;
case VAR_20 :
if (VAR_5->custom_save_cb)
{
char*VAR_21;
const char*VAR_22;
if ((VAR_21 = (*VAR_5->custom_save_cb)(VAR_6)) == NULL)
return (-1);
if (mxml_write_string(VAR_21, VAR_1, VAR_4) < 0)
return (-1);
if ((VAR_22 = strrchr(VAR_21, '\n')) == NULL)
VAR_3 += strlen(VAR_21);
else
VAR_3 = (int)strlen(VAR_22);
free(VAR_21);
break;
}
default : 
return (-1);
}
if ((VAR_7 = VAR_6->child) == NULL)
{
if (VAR_6 == VAR_0)
{
VAR_7 = NULL;
}
else
{
while ((VAR_7 = VAR_6->next) == NULL)
{
if (VAR_6 == VAR_0 || !VAR_6->parent)
break;
VAR_6 = VAR_6->parent;
if (VAR_6->value.element.name[0] != '!' &&
VAR_6->value.element.name[0] != '?')
{
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_23, VAR_3, VAR_4);
if ((*VAR_4)('<', VAR_1) < 0)
return (-1);
if ((*VAR_4)('/', VAR_1) < 0)
return (-1);
if (mxml_write_string(VAR_6->value.element.name, VAR_1, VAR_4) < 0)
return (-1);
if ((*VAR_4)('>', VAR_1) < 0)
return (-1);
VAR_3 += strlen(VAR_6->value.element.name) + 3;
VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_24, VAR_3, VAR_4);
}
if (VAR_6 == VAR_0)
break;
}
}
}
}
return (VAR_3);
}",michaelrsweet/mxml/4f5577dd4672d228e4180f06bdbd66f343ea45e0/mxml-file.c/vul/before/0.json,"static int				/* O - Column or -1 on error */
mxml_write_node(mxml_node_t     *node,	/* I - Node to write */
                void            *p,	/* I - File to write to */
	        mxml_save_cb_t  cb,	/* I - Whitespace callback */
		int             col,	/* I - Current column */
		_mxml_putc_cb_t putc_cb,/* I - Output callback */
		_mxml_global_t  *global)/* I - Global data */
{
  mxml_node_t	*current,		/* Current node */
		*next;			/* Next node */
  int		i,			/* Looping var */
		width;			/* Width of attr + value */
  mxml_attr_t	*attr;			/* Current attribute */
  char		s[255];			/* Temporary string */


 /*
  * Loop through this node and all of its children...
  */

  for (current = node; current; current = next)
  {
   /*
    * Print the node value...
    */

    switch (current->type)
    {
      case MXML_ELEMENT :
	  col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);

	  if ((*putc_cb)('<', p) < 0)
	    return (-1);
	  if (current->value.element.name[0] == '?' ||
	      !strncmp(current->value.element.name, ""!--"", 3))
	  {
	   /*
	    * Comments and processing instructions do not use character
	    * entities.
	    */

	    const char	*ptr;		/* Pointer into name */

	    for (ptr = current->value.element.name; *ptr; ptr ++)
	      if ((*putc_cb)(*ptr, p) < 0)
		return (-1);
	  }
	  else if (!strncmp(current->value.element.name, ""![CDATA["", 8))
	  {
	   /*
	    * CDATA elements do not use character entities, but also need the
	    * ""]]"" terminator added at the end.
	    */

	    const char	*ptr;		/* Pointer into name */

	    for (ptr = current->value.element.name; *ptr; ptr ++)
	      if ((*putc_cb)(*ptr, p) < 0)
		return (-1);

            if ((*putc_cb)(']', p) < 0)
              return (-1);
            if ((*putc_cb)(']', p) < 0)
              return (-1);
	  }
	  else if (mxml_write_name(current->value.element.name, p, putc_cb) < 0)
	    return (-1);

	  col += strlen(current->value.element.name) + 1;

	  for (i = current->value.element.num_attrs, attr = current->value.element.attrs;
	       i > 0;
	       i --, attr ++)
	  {
	    width = (int)strlen(attr->name);

	    if (attr->value)
	      width += strlen(attr->value) + 3;

	    if (global->wrap > 0 && (col + width) > global->wrap)
	    {
	      if ((*putc_cb)('\n', p) < 0)
		return (-1);

	      col = 0;
	    }
	    else
	    {
	      if ((*putc_cb)(' ', p) < 0)
		return (-1);

	      col ++;
	    }

	    if (mxml_write_name(attr->name, p, putc_cb) < 0)
	      return (-1);

	    if (attr->value)
	    {
	      if ((*putc_cb)('=', p) < 0)
		return (-1);
	      if ((*putc_cb)('\""', p) < 0)
		return (-1);
	      if (mxml_write_string(attr->value, p, putc_cb) < 0)
		return (-1);
	      if ((*putc_cb)('\""', p) < 0)
		return (-1);
	    }

	    col += width;
	  }

	  if (current->child)
	  {
	   /*
	    * Write children...
	    */

	    if ((*putc_cb)('>', p) < 0)
	      return (-1);
	    else
	      col ++;

	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
	  }
	  else if (current->value.element.name[0] == '!' ||
		   current->value.element.name[0] == '?')
	  {
	   /*
	    * The ? and ! elements are special-cases...
	    */

	    if ((*putc_cb)('>', p) < 0)
	      return (-1);
	    else
	      col ++;

	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
	  }
	  else
	  {
	    if ((*putc_cb)(' ', p) < 0)
	      return (-1);
	    if ((*putc_cb)('/', p) < 0)
	      return (-1);
	    if ((*putc_cb)('>', p) < 0)
	      return (-1);

	    col += 3;

	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
	  }
	  break;

      case MXML_INTEGER :
	  if (current->prev)
	  {
	    if (global->wrap > 0 && col > global->wrap)
	    {
	      if ((*putc_cb)('\n', p) < 0)
		return (-1);

	      col = 0;
	    }
	    else if ((*putc_cb)(' ', p) < 0)
	      return (-1);
	    else
	      col ++;
	  }

	  snprintf(s, sizeof(s), ""%d"", current->value.integer);
	  if (mxml_write_string(s, p, putc_cb) < 0)
	    return (-1);

	  col += strlen(s);
	  break;

      case MXML_OPAQUE :
	  if (mxml_write_string(current->value.opaque, p, putc_cb) < 0)
	    return (-1);

	  col += strlen(current->value.opaque);
	  break;

      case MXML_REAL :
	  if (current->prev)
	  {
	    if (global->wrap > 0 && col > global->wrap)
	    {
	      if ((*putc_cb)('\n', p) < 0)
		return (-1);

	      col = 0;
	    }
	    else if ((*putc_cb)(' ', p) < 0)
	      return (-1);
	    else
	      col ++;
	  }

	  snprintf(s, sizeof(s), ""%f"", current->value.real);
	  if (mxml_write_string(s, p, putc_cb) < 0)
	    return (-1);

	  col += strlen(s);
	  break;

      case MXML_TEXT :
	  if (current->value.text.whitespace && col > 0)
	  {
	    if (global->wrap > 0 && col > global->wrap)
	    {
	      if ((*putc_cb)('\n', p) < 0)
		return (-1);

	      col = 0;
	    }
	    else if ((*putc_cb)(' ', p) < 0)
	      return (-1);
	    else
	      col ++;
	  }

	  if (mxml_write_string(current->value.text.string, p, putc_cb) < 0)
	    return (-1);

	  col += strlen(current->value.text.string);
	  break;

      case MXML_CUSTOM :
	  if (global->custom_save_cb)
	  {
	    char	*data;		/* Custom data string */
	    const char	*newline;	/* Last newline in string */


	    if ((data = (*global->custom_save_cb)(current)) == NULL)
	      return (-1);

	    if (mxml_write_string(data, p, putc_cb) < 0)
	      return (-1);

	    if ((newline = strrchr(data, '\n')) == NULL)
	      col += strlen(data);
	    else
	      col = (int)strlen(newline);

	    free(data);
	    break;
	  }

      default : /* Should never happen */
	  return (-1);
    }

   /*
    * Figure out the next node...
    */

    if ((next = current->child) == NULL)
    {
      if (current == node)
      {
       /*
        * Don't traverse to sibling node if we are at the ""root"" node...
        */

        next = NULL;
      }
      else
      {
       /*
        * Try the next sibling, and continue traversing upwards as needed...
        */

	while ((next = current->next) == NULL)
	{
	  if (current == node || !current->parent)
	    break;

	 /*
	  * The ? and ! elements are special-cases and have no end tags...
	  */

	  current = current->parent;

	  if (current->value.element.name[0] != '!' &&
	      current->value.element.name[0] != '?')
	  {
	    col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);

	    if ((*putc_cb)('<', p) < 0)
	      return (-1);
	    if ((*putc_cb)('/', p) < 0)
	      return (-1);
	    if (mxml_write_string(current->value.element.name, p, putc_cb) < 0)
	      return (-1);
	    if ((*putc_cb)('>', p) < 0)
	      return (-1);

	    col += strlen(current->value.element.name) + 3;

	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
	  }

	  if (current == node)
	    break;
	}
      }
    }
  }

  return (col);
}","static int				/* COMMENT_0 */
mxml_write_node(mxml_node_t     *VAR_0,	/* COMMENT_1 */
                void            *VAR_1,	/* COMMENT_2 */
	        mxml_save_cb_t  VAR_2,	/* COMMENT_3 */
		int             VAR_3,	/* COMMENT_4 */
		_mxml_putc_cb_t VAR_4,/* COMMENT_5 */
		_mxml_global_t  *VAR_5)/* COMMENT_6 */
{
  mxml_node_t	*VAR_6,		/* COMMENT_7 */
		*VAR_7;			/* COMMENT_8 */
  int		VAR_8,			/* COMMENT_9 */
		VAR_9;			/* COMMENT_10 */
  mxml_attr_t	*VAR_10;			/* COMMENT_11 */
  char		VAR_11[255];			/* COMMENT_12 */


 /* COMMENT_13 */
                                                     
    

  for (VAR_6 = VAR_0; VAR_6; VAR_6 = VAR_7)
  {
   /* COMMENT_16 */
                             
      

    switch (VAR_6->type)
    {
      case VAR_12 :
	  VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_13, VAR_3, VAR_4);

	  if ((*VAR_4)('<', VAR_1) < 0)
	    return (-1);
	  if (VAR_6->value.element.name[0] == '?' ||
	      !strncmp(VAR_6->value.element.name, ""!--"", 3))
	  {
	   /* COMMENT_19 */
                                                                
                
       

	    const char	*VAR_14;		/* COMMENT_23 */

	    for (VAR_14 = VAR_6->value.element.name; *VAR_14; VAR_14 ++)
	      if ((*VAR_4)(*VAR_14, VAR_1) < 0)
		return (-1);
	  }
	  else if (!strncmp(VAR_6->value.element.name, ""![CDATA["", 8))
	  {
	   /* COMMENT_24 */
                                                                      
                                        
       

	    const char	*VAR_14;		/* COMMENT_23 */

	    for (VAR_14 = VAR_6->value.element.name; *VAR_14; VAR_14 ++)
	      if ((*VAR_4)(*VAR_14, VAR_1) < 0)
		return (-1);

            if ((*VAR_4)(']', VAR_1) < 0)
              return (-1);
            if ((*VAR_4)(']', VAR_1) < 0)
              return (-1);
	  }
	  else if (mxml_write_name(VAR_6->value.element.name, VAR_1, VAR_4) < 0)
	    return (-1);

	  VAR_3 += strlen(VAR_6->value.element.name) + 1;

	  for (VAR_8 = VAR_6->value.element.num_attrs, VAR_10 = VAR_6->value.element.attrs;
	       VAR_8 > 0;
	       VAR_8 --, VAR_10 ++)
	  {
	    VAR_9 = (int)strlen(VAR_10->name);

	    if (VAR_10->value)
	      VAR_9 += strlen(VAR_10->value) + 3;

	    if (VAR_5->wrap > 0 && (VAR_3 + VAR_9) > VAR_5->wrap)
	    {
	      if ((*VAR_4)('\n', VAR_1) < 0)
		return (-1);

	      VAR_3 = 0;
	    }
	    else
	    {
	      if ((*VAR_4)(' ', VAR_1) < 0)
		return (-1);

	      VAR_3 ++;
	    }

	    if (mxml_write_name(VAR_10->name, VAR_1, VAR_4) < 0)
	      return (-1);

	    if (VAR_10->value)
	    {
	      if ((*VAR_4)('=', VAR_1) < 0)
		return (-1);
	      if ((*VAR_4)('\""', VAR_1) < 0)
		return (-1);
	      if (mxml_write_string(VAR_10->value, VAR_1, VAR_4) < 0)
		return (-1);
	      if ((*VAR_4)('\""', VAR_1) < 0)
		return (-1);
	    }

	    VAR_3 += VAR_9;
	  }

	  if (VAR_6->child)
	  {
	   /* COMMENT_28 */
                        
       

	    if ((*VAR_4)('>', VAR_1) < 0)
	      return (-1);
	    else
	      VAR_3 ++;

	    VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
	  }
	  else if (VAR_6->value.element.name[0] == '!' ||
		   VAR_6->value.element.name[0] == '?')
	  {
	   /* COMMENT_31 */
                                                
       

	    if ((*VAR_4)('>', VAR_1) < 0)
	      return (-1);
	    else
	      VAR_3 ++;

	    VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
	  }
	  else
	  {
	    if ((*VAR_4)(' ', VAR_1) < 0)
	      return (-1);
	    if ((*VAR_4)('/', VAR_1) < 0)
	      return (-1);
	    if ((*VAR_4)('>', VAR_1) < 0)
	      return (-1);

	    VAR_3 += 3;

	    VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_15, VAR_3, VAR_4);
	  }
	  break;

      case VAR_16 :
	  if (VAR_6->prev)
	  {
	    if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
	    {
	      if ((*VAR_4)('\n', VAR_1) < 0)
		return (-1);

	      VAR_3 = 0;
	    }
	    else if ((*VAR_4)(' ', VAR_1) < 0)
	      return (-1);
	    else
	      VAR_3 ++;
	  }

	  snprintf(VAR_11, sizeof(VAR_11), ""%d"", VAR_6->value.integer);
	  if (mxml_write_string(VAR_11, VAR_1, VAR_4) < 0)
	    return (-1);

	  VAR_3 += strlen(VAR_11);
	  break;

      case VAR_17 :
	  if (mxml_write_string(VAR_6->value.opaque, VAR_1, VAR_4) < 0)
	    return (-1);

	  VAR_3 += strlen(VAR_6->value.opaque);
	  break;

      case VAR_18 :
	  if (VAR_6->prev)
	  {
	    if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
	    {
	      if ((*VAR_4)('\n', VAR_1) < 0)
		return (-1);

	      VAR_3 = 0;
	    }
	    else if ((*VAR_4)(' ', VAR_1) < 0)
	      return (-1);
	    else
	      VAR_3 ++;
	  }

	  snprintf(VAR_11, sizeof(VAR_11), ""%f"", VAR_6->value.real);
	  if (mxml_write_string(VAR_11, VAR_1, VAR_4) < 0)
	    return (-1);

	  VAR_3 += strlen(VAR_11);
	  break;

      case VAR_19 :
	  if (VAR_6->value.text.whitespace && VAR_3 > 0)
	  {
	    if (VAR_5->wrap > 0 && VAR_3 > VAR_5->wrap)
	    {
	      if ((*VAR_4)('\n', VAR_1) < 0)
		return (-1);

	      VAR_3 = 0;
	    }
	    else if ((*VAR_4)(' ', VAR_1) < 0)
	      return (-1);
	    else
	      VAR_3 ++;
	  }

	  if (mxml_write_string(VAR_6->value.text.string, VAR_1, VAR_4) < 0)
	    return (-1);

	  VAR_3 += strlen(VAR_6->value.text.string);
	  break;

      case VAR_20 :
	  if (VAR_5->custom_save_cb)
	  {
	    char	*VAR_21;		/* COMMENT_34 */
	    const char	*VAR_22;	/* COMMENT_35 */


	    if ((VAR_21 = (*VAR_5->custom_save_cb)(VAR_6)) == NULL)
	      return (-1);

	    if (mxml_write_string(VAR_21, VAR_1, VAR_4) < 0)
	      return (-1);

	    if ((VAR_22 = strrchr(VAR_21, '\n')) == NULL)
	      VAR_3 += strlen(VAR_21);
	    else
	      VAR_3 = (int)strlen(VAR_22);

	    free(VAR_21);
	    break;
	  }

      default : /* COMMENT_36 */
	  return (-1);
    }

   /* COMMENT_37 */
                                 
      

    if ((VAR_7 = VAR_6->child) == NULL)
    {
      if (VAR_6 == VAR_0)
      {
       /* COMMENT_40 */
                                                                        
          

        VAR_7 = NULL;
      }
      else
      {
       /* COMMENT_43 */
                                                                            
          

	while ((VAR_7 = VAR_6->next) == NULL)
	{
	  if (VAR_6 == VAR_0 || !VAR_6->parent)
	    break;

	 /* COMMENT_46 */
                                                                   
     

	  VAR_6 = VAR_6->parent;

	  if (VAR_6->value.element.name[0] != '!' &&
	      VAR_6->value.element.name[0] != '?')
	  {
	    VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_23, VAR_3, VAR_4);

	    if ((*VAR_4)('<', VAR_1) < 0)
	      return (-1);
	    if ((*VAR_4)('/', VAR_1) < 0)
	      return (-1);
	    if (mxml_write_string(VAR_6->value.element.name, VAR_1, VAR_4) < 0)
	      return (-1);
	    if ((*VAR_4)('>', VAR_1) < 0)
	      return (-1);

	    VAR_3 += strlen(VAR_6->value.element.name) + 3;

	    VAR_3 = mxml_write_ws(VAR_6, VAR_1, VAR_2, VAR_24, VAR_3, VAR_4);
	  }

	  if (VAR_6 == VAR_0)
	    break;
	}
      }
    }
  }

  return (VAR_3);
}",michaelrsweet/mxml/4f5577dd4672d228e4180f06bdbd66f343ea45e0/mxml-file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -168,7 +168,7 @@
 	      col ++;
 	  }
 
-	  sprintf(s, ""%d"", current->value.integer);
+	  snprintf(s, sizeof(s), ""%d"", current->value.integer);
 	  if (mxml_write_string(s, p, putc_cb) < 0)
 	    return (-1);
 
@@ -198,7 +198,7 @@
 	      col ++;
 	  }
 
-	  sprintf(s, ""%f"", current->value.real);
+	  snprintf(s, sizeof(s), ""%f"", current->value.real);
 	  if (mxml_write_string(s, p, putc_cb) < 0)
 	    return (-1);
 ","{'deleted_lines': ['\t  sprintf(s, ""%d"", current->value.integer);', '\t  sprintf(s, ""%f"", current->value.real);'], 'added_lines': ['\t  snprintf(s, sizeof(s), ""%d"", current->value.integer);', '\t  snprintf(s, sizeof(s), ""%f"", current->value.real);']}",True,"An issue has been found in Mini-XML (aka mxml) 2.12. It is a stack-based buffer overflow in mxml_write_node in mxml-file.c via vectors involving a double-precision floating point number and the '<order type=""real"">' substring, as demonstrated by testmxml.",8.8,HIGH,2,valid,2018-12-03T16:21:39Z,2
CVE-2018-20145,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,eclipse/mosquitto,"Fix acl_file being ignore for default listener if with per_listener_settings

Close #1073. Thanks to Jef Driesen.

Bug: https://github.com/eclipse/mosquitto/issues/1073",9097577b49b7fdcf45d30975976dd93808ccc0c4,https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4,src/conf.c,config__parse_args,"int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])
{
int i;
int port_tmp;
for(i=1; i<argc; i++){
if(!strcmp(argv[i], ""-c"") || !strcmp(argv[i], ""--config-file"")){
if(i<argc-1){
db->config_file = argv[i+1];
if(config__read(db, config, false)){
log__printf(NULL, MOSQ_LOG_ERR, ""Error: Unable to open configuration file."");
return MOSQ_ERR_INVAL;
}
}else{
log__printf(NULL, MOSQ_LOG_ERR, ""Error: -c argument given, but no config file specified."");
return MOSQ_ERR_INVAL;
}
i++;
}else if(!strcmp(argv[i], ""-d"") || !strcmp(argv[i], ""--daemon"")){
config->daemon = true;
}else if(!strcmp(argv[i], ""-h"") || !strcmp(argv[i], ""--help"")){
print_usage();
return MOSQ_ERR_INVAL;
}else if(!strcmp(argv[i], ""-p"") || !strcmp(argv[i], ""--port"")){
if(i<argc-1){
port_tmp = atoi(argv[i+1]);
if(port_tmp<1 || port_tmp>65535){
log__printf(NULL, MOSQ_LOG_ERR, ""Error: Invalid port specified (%d)."", port_tmp);
return MOSQ_ERR_INVAL;
}else{
if(config->default_listener.port){
log__printf(NULL, MOSQ_LOG_WARNING, ""Warning: Default listener port specified multiple times. Only the latest will be used."");
}
config->default_listener.port = port_tmp;
}
}else{
log__printf(NULL, MOSQ_LOG_ERR, ""Error: -p argument given, but no port specified."");
return MOSQ_ERR_INVAL;
}
i++;
}else if(!strcmp(argv[i], ""-v"") || !strcmp(argv[i], ""--verbose"")){
db->verbose = true;
}else{
fprintf(stderr, ""Error: Unknown option '%s'.\n"",argv[i]);
print_usage();
return MOSQ_ERR_INVAL;
}
}
if(config->listener_count == 0
#ifdef WITH_TLS
|| config->default_listener.cafile
|| config->default_listener.capath
|| config->default_listener.certfile
|| config->default_listener.keyfile
|| config->default_listener.ciphers
|| config->default_listener.psk_hint
|| config->default_listener.require_certificate
|| config->default_listener.crlfile
|| config->default_listener.use_identity_as_username
|| config->default_listener.use_subject_as_username
#endif
|| config->default_listener.use_username_as_clientid
|| config->default_listener.host
|| config->default_listener.port
|| config->default_listener.max_connections != -1
|| config->default_listener.mount_point
|| config->default_listener.protocol != mp_mqtt
|| config->default_listener.socket_domain
|| config->default_listener.security_options.password_file
|| config->default_listener.security_options.psk_file
|| config->default_listener.security_options.auth_plugin_config_count
|| config->default_listener.security_options.allow_anonymous != -1
){
config->listener_count++;
config->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);
if(!config->listeners){
log__printf(NULL, MOSQ_LOG_ERR, ""Error: Out of memory."");
return MOSQ_ERR_NOMEM;
}
memset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));
if(config->default_listener.port){
config->listeners[config->listener_count-1].port = config->default_listener.port;
}else{
config->listeners[config->listener_count-1].port = 1883;
}
if(config->default_listener.host){
config->listeners[config->listener_count-1].host = config->default_listener.host;
}else{
config->listeners[config->listener_count-1].host = NULL;
}
if(config->default_listener.mount_point){
config->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;
}else{
config->listeners[config->listener_count-1].mount_point = NULL;
}
config->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;
config->listeners[config->listener_count-1].protocol = config->default_listener.protocol;
config->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;
config->listeners[config->listener_count-1].client_count = 0;
config->listeners[config->listener_count-1].socks = NULL;
config->listeners[config->listener_count-1].sock_count = 0;
config->listeners[config->listener_count-1].client_count = 0;
config->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;
#ifdef WITH_TLS
config->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;
config->listeners[config->listener_count-1].cafile = config->default_listener.cafile;
config->listeners[config->listener_count-1].capath = config->default_listener.capath;
config->listeners[config->listener_count-1].certfile = config->default_listener.certfile;
config->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;
config->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;
config->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;
config->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;
config->listeners[config->listener_count-1].ssl_ctx = NULL;
config->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;
config->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;
config->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;
#endif
config->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;
config->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;
config->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;
config->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;
config->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;
}
if(!config->user){
config->user = ""mosquitto"";
}
if(db->verbose){
config->log_type = INT_MAX;
}
return config__check(config);
}","int config__parse_args(struct mosquitto_db *VAR_0, struct mosquitto__config *VAR_1, int VAR_2, char *VAR_3[])
{
int VAR_4;
int VAR_5;
for(VAR_4=1; VAR_4<VAR_2; VAR_4++){
if(!strcmp(VAR_3[VAR_4], ""-c"") || !strcmp(VAR_3[VAR_4], ""--config-file"")){
if(VAR_4<VAR_2-1){
VAR_0->config_file = VAR_3[VAR_4+1];
if(config__read(VAR_0, VAR_1, false)){
log__printf(NULL, VAR_6, ""Error: Unable to open configuration file."");
return VAR_7;
}
}else{
log__printf(NULL, VAR_6, ""Error: -c argument given, but no config file specified."");
return VAR_7;
}
VAR_4++;
}else if(!strcmp(VAR_3[VAR_4], ""-d"") || !strcmp(VAR_3[VAR_4], ""--daemon"")){
VAR_1->daemon = true;
}else if(!strcmp(VAR_3[VAR_4], ""-h"") || !strcmp(VAR_3[VAR_4], ""--help"")){
print_usage();
return VAR_7;
}else if(!strcmp(VAR_3[VAR_4], ""-p"") || !strcmp(VAR_3[VAR_4], ""--port"")){
if(VAR_4<VAR_2-1){
VAR_5 = atoi(VAR_3[VAR_4+1]);
if(VAR_5<1 || VAR_5>65535){
log__printf(NULL, VAR_6, ""Error: Invalid port specified (%d)."", VAR_5);
return VAR_7;
}else{
if(VAR_1->default_listener.port){
log__printf(NULL, VAR_8, ""Warning: Default listener port specified multiple times. Only the latest will be used."");
}
VAR_1->default_listener.port = VAR_5;
}
}else{
log__printf(NULL, VAR_6, ""Error: -p argument given, but no port specified."");
return VAR_7;
}
VAR_4++;
}else if(!strcmp(VAR_3[VAR_4], ""-v"") || !strcmp(VAR_3[VAR_4], ""--verbose"")){
VAR_0->verbose = true;
}else{
fprintf(VAR_9, ""Error: Unknown option '%s'.\n"",VAR_3[VAR_4]);
print_usage();
return VAR_7;
}
}
if(VAR_1->listener_count == 0
#ifdef VAR_10
|| VAR_1->default_listener.cafile
|| VAR_1->default_listener.capath
|| VAR_1->default_listener.certfile
|| VAR_1->default_listener.keyfile
|| VAR_1->default_listener.ciphers
|| VAR_1->default_listener.psk_hint
|| VAR_1->default_listener.require_certificate
|| VAR_1->default_listener.crlfile
|| VAR_1->default_listener.use_identity_as_username
|| VAR_1->default_listener.use_subject_as_username
#endif
|| VAR_1->default_listener.use_username_as_clientid
|| VAR_1->default_listener.host
|| VAR_1->default_listener.port
|| VAR_1->default_listener.max_connections != -1
|| VAR_1->default_listener.mount_point
|| VAR_1->default_listener.protocol != VAR_11
|| VAR_1->default_listener.socket_domain
|| VAR_1->default_listener.security_options.password_file
|| VAR_1->default_listener.security_options.psk_file
|| VAR_1->default_listener.security_options.auth_plugin_config_count
|| VAR_1->default_listener.security_options.allow_anonymous != -1
){
VAR_1->listener_count++;
VAR_1->listeners = mosquitto__realloc(VAR_1->listeners, sizeof(struct mosquitto__listener)*VAR_1->listener_count);
if(!VAR_1->listeners){
log__printf(NULL, VAR_6, ""Error: Out of memory."");
return VAR_12;
}
memset(&VAR_1->listeners[VAR_1->listener_count-1], 0, sizeof(struct mosquitto__listener));
if(VAR_1->default_listener.port){
VAR_1->listeners[VAR_1->listener_count-1].port = VAR_1->default_listener.port;
}else{
VAR_1->listeners[VAR_1->listener_count-1].port = 1883;
}
if(VAR_1->default_listener.host){
VAR_1->listeners[VAR_1->listener_count-1].host = VAR_1->default_listener.host;
}else{
VAR_1->listeners[VAR_1->listener_count-1].host = NULL;
}
if(VAR_1->default_listener.mount_point){
VAR_1->listeners[VAR_1->listener_count-1].mount_point = VAR_1->default_listener.mount_point;
}else{
VAR_1->listeners[VAR_1->listener_count-1].mount_point = NULL;
}
VAR_1->listeners[VAR_1->listener_count-1].max_connections = VAR_1->default_listener.max_connections;
VAR_1->listeners[VAR_1->listener_count-1].protocol = VAR_1->default_listener.protocol;
VAR_1->listeners[VAR_1->listener_count-1].socket_domain = VAR_1->default_listener.socket_domain;
VAR_1->listeners[VAR_1->listener_count-1].client_count = 0;
VAR_1->listeners[VAR_1->listener_count-1].socks = NULL;
VAR_1->listeners[VAR_1->listener_count-1].sock_count = 0;
VAR_1->listeners[VAR_1->listener_count-1].client_count = 0;
VAR_1->listeners[VAR_1->listener_count-1].use_username_as_clientid = VAR_1->default_listener.use_username_as_clientid;
#ifdef VAR_10
VAR_1->listeners[VAR_1->listener_count-1].tls_version = VAR_1->default_listener.tls_version;
VAR_1->listeners[VAR_1->listener_count-1].cafile = VAR_1->default_listener.cafile;
VAR_1->listeners[VAR_1->listener_count-1].capath = VAR_1->default_listener.capath;
VAR_1->listeners[VAR_1->listener_count-1].certfile = VAR_1->default_listener.certfile;
VAR_1->listeners[VAR_1->listener_count-1].keyfile = VAR_1->default_listener.keyfile;
VAR_1->listeners[VAR_1->listener_count-1].ciphers = VAR_1->default_listener.ciphers;
VAR_1->listeners[VAR_1->listener_count-1].psk_hint = VAR_1->default_listener.psk_hint;
VAR_1->listeners[VAR_1->listener_count-1].require_certificate = VAR_1->default_listener.require_certificate;
VAR_1->listeners[VAR_1->listener_count-1].ssl_ctx = NULL;
VAR_1->listeners[VAR_1->listener_count-1].crlfile = VAR_1->default_listener.crlfile;
VAR_1->listeners[VAR_1->listener_count-1].use_identity_as_username = VAR_1->default_listener.use_identity_as_username;
VAR_1->listeners[VAR_1->listener_count-1].use_subject_as_username = VAR_1->default_listener.use_subject_as_username;
#endif
VAR_1->listeners[VAR_1->listener_count-1].security_options.password_file = VAR_1->default_listener.security_options.password_file;
VAR_1->listeners[VAR_1->listener_count-1].security_options.psk_file = VAR_1->default_listener.security_options.psk_file;
VAR_1->listeners[VAR_1->listener_count-1].security_options.auth_plugin_configs = VAR_1->default_listener.security_options.auth_plugin_configs;
VAR_1->listeners[VAR_1->listener_count-1].security_options.auth_plugin_config_count = VAR_1->default_listener.security_options.auth_plugin_config_count;
VAR_1->listeners[VAR_1->listener_count-1].security_options.allow_anonymous = VAR_1->default_listener.security_options.allow_anonymous;
}
if(!VAR_1->user){
VAR_1->user = ""mosquitto"";
}
if(VAR_0->verbose){
VAR_1->log_type = VAR_13;
}
return config__check(VAR_1);
}",eclipse/mosquitto/9097577b49b7fdcf45d30975976dd93808ccc0c4/conf.c/vul/before/0.json,"int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])
{
	int i;
	int port_tmp;

	for(i=1; i<argc; i++){
		if(!strcmp(argv[i], ""-c"") || !strcmp(argv[i], ""--config-file"")){
			if(i<argc-1){
				db->config_file = argv[i+1];

				if(config__read(db, config, false)){
					log__printf(NULL, MOSQ_LOG_ERR, ""Error: Unable to open configuration file."");
					return MOSQ_ERR_INVAL;
				}
			}else{
				log__printf(NULL, MOSQ_LOG_ERR, ""Error: -c argument given, but no config file specified."");
				return MOSQ_ERR_INVAL;
			}
			i++;
		}else if(!strcmp(argv[i], ""-d"") || !strcmp(argv[i], ""--daemon"")){
			config->daemon = true;
		}else if(!strcmp(argv[i], ""-h"") || !strcmp(argv[i], ""--help"")){
			print_usage();
			return MOSQ_ERR_INVAL;
		}else if(!strcmp(argv[i], ""-p"") || !strcmp(argv[i], ""--port"")){
			if(i<argc-1){
				port_tmp = atoi(argv[i+1]);
				if(port_tmp<1 || port_tmp>65535){
					log__printf(NULL, MOSQ_LOG_ERR, ""Error: Invalid port specified (%d)."", port_tmp);
					return MOSQ_ERR_INVAL;
				}else{
					if(config->default_listener.port){
						log__printf(NULL, MOSQ_LOG_WARNING, ""Warning: Default listener port specified multiple times. Only the latest will be used."");
					}
					config->default_listener.port = port_tmp;
				}
			}else{
				log__printf(NULL, MOSQ_LOG_ERR, ""Error: -p argument given, but no port specified."");
				return MOSQ_ERR_INVAL;
			}
			i++;
		}else if(!strcmp(argv[i], ""-v"") || !strcmp(argv[i], ""--verbose"")){
			db->verbose = true;
		}else{
			fprintf(stderr, ""Error: Unknown option '%s'.\n"",argv[i]);
			print_usage();
			return MOSQ_ERR_INVAL;
		}
	}

	if(config->listener_count == 0
#ifdef WITH_TLS
			|| config->default_listener.cafile
			|| config->default_listener.capath
			|| config->default_listener.certfile
			|| config->default_listener.keyfile
			|| config->default_listener.ciphers
			|| config->default_listener.psk_hint
			|| config->default_listener.require_certificate
			|| config->default_listener.crlfile
			|| config->default_listener.use_identity_as_username
			|| config->default_listener.use_subject_as_username
#endif
			|| config->default_listener.use_username_as_clientid
			|| config->default_listener.host
			|| config->default_listener.port
			|| config->default_listener.max_connections != -1
			|| config->default_listener.mount_point
			|| config->default_listener.protocol != mp_mqtt
			|| config->default_listener.socket_domain
			|| config->default_listener.security_options.password_file
			|| config->default_listener.security_options.psk_file
			|| config->default_listener.security_options.auth_plugin_config_count
			|| config->default_listener.security_options.allow_anonymous != -1
			){

		config->listener_count++;
		config->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);
		if(!config->listeners){
			log__printf(NULL, MOSQ_LOG_ERR, ""Error: Out of memory."");
			return MOSQ_ERR_NOMEM;
		}
		memset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));
		if(config->default_listener.port){
			config->listeners[config->listener_count-1].port = config->default_listener.port;
		}else{
			config->listeners[config->listener_count-1].port = 1883;
		}
		if(config->default_listener.host){
			config->listeners[config->listener_count-1].host = config->default_listener.host;
		}else{
			config->listeners[config->listener_count-1].host = NULL;
		}
		if(config->default_listener.mount_point){
			config->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;
		}else{
			config->listeners[config->listener_count-1].mount_point = NULL;
		}
		config->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;
		config->listeners[config->listener_count-1].protocol = config->default_listener.protocol;
		config->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;
		config->listeners[config->listener_count-1].client_count = 0;
		config->listeners[config->listener_count-1].socks = NULL;
		config->listeners[config->listener_count-1].sock_count = 0;
		config->listeners[config->listener_count-1].client_count = 0;
		config->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;
#ifdef WITH_TLS
		config->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;
		config->listeners[config->listener_count-1].cafile = config->default_listener.cafile;
		config->listeners[config->listener_count-1].capath = config->default_listener.capath;
		config->listeners[config->listener_count-1].certfile = config->default_listener.certfile;
		config->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;
		config->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;
		config->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;
		config->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;
		config->listeners[config->listener_count-1].ssl_ctx = NULL;
		config->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;
		config->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;
		config->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;
#endif
		config->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;
		config->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;
		config->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;
		config->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;
		config->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;
		config->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;
	}

	/* Default to drop to mosquitto user if we are privileged and no user specified. */
	if(!config->user){
		config->user = ""mosquitto"";
	}
	if(db->verbose){
		config->log_type = INT_MAX;
	}
	return config__check(config);
}","int config__parse_args(struct mosquitto_db *VAR_0, struct mosquitto__config *VAR_1, int VAR_2, char *VAR_3[])
{
	int VAR_4;
	int VAR_5;

	for(VAR_4=1; VAR_4<VAR_2; VAR_4++){
		if(!strcmp(VAR_3[VAR_4], ""-c"") || !strcmp(VAR_3[VAR_4], ""--config-file"")){
			if(VAR_4<VAR_2-1){
				VAR_0->config_file = VAR_3[VAR_4+1];

				if(config__read(VAR_0, VAR_1, false)){
					log__printf(NULL, VAR_6, ""Error: Unable to open configuration file."");
					return VAR_7;
				}
			}else{
				log__printf(NULL, VAR_6, ""Error: -c argument given, but no config file specified."");
				return VAR_7;
			}
			VAR_4++;
		}else if(!strcmp(VAR_3[VAR_4], ""-d"") || !strcmp(VAR_3[VAR_4], ""--daemon"")){
			VAR_1->daemon = true;
		}else if(!strcmp(VAR_3[VAR_4], ""-h"") || !strcmp(VAR_3[VAR_4], ""--help"")){
			print_usage();
			return VAR_7;
		}else if(!strcmp(VAR_3[VAR_4], ""-p"") || !strcmp(VAR_3[VAR_4], ""--port"")){
			if(VAR_4<VAR_2-1){
				VAR_5 = atoi(VAR_3[VAR_4+1]);
				if(VAR_5<1 || VAR_5>65535){
					log__printf(NULL, VAR_6, ""Error: Invalid port specified (%d)."", VAR_5);
					return VAR_7;
				}else{
					if(VAR_1->default_listener.port){
						log__printf(NULL, VAR_8, ""Warning: Default listener port specified multiple times. Only the latest will be used."");
					}
					VAR_1->default_listener.port = VAR_5;
				}
			}else{
				log__printf(NULL, VAR_6, ""Error: -p argument given, but no port specified."");
				return VAR_7;
			}
			VAR_4++;
		}else if(!strcmp(VAR_3[VAR_4], ""-v"") || !strcmp(VAR_3[VAR_4], ""--verbose"")){
			VAR_0->verbose = true;
		}else{
			fprintf(VAR_9, ""Error: Unknown option '%s'.\n"",VAR_3[VAR_4]);
			print_usage();
			return VAR_7;
		}
	}

	if(VAR_1->listener_count == 0
#ifdef VAR_10
			|| VAR_1->default_listener.cafile
			|| VAR_1->default_listener.capath
			|| VAR_1->default_listener.certfile
			|| VAR_1->default_listener.keyfile
			|| VAR_1->default_listener.ciphers
			|| VAR_1->default_listener.psk_hint
			|| VAR_1->default_listener.require_certificate
			|| VAR_1->default_listener.crlfile
			|| VAR_1->default_listener.use_identity_as_username
			|| VAR_1->default_listener.use_subject_as_username
#endif
			|| VAR_1->default_listener.use_username_as_clientid
			|| VAR_1->default_listener.host
			|| VAR_1->default_listener.port
			|| VAR_1->default_listener.max_connections != -1
			|| VAR_1->default_listener.mount_point
			|| VAR_1->default_listener.protocol != VAR_11
			|| VAR_1->default_listener.socket_domain
			|| VAR_1->default_listener.security_options.password_file
			|| VAR_1->default_listener.security_options.psk_file
			|| VAR_1->default_listener.security_options.auth_plugin_config_count
			|| VAR_1->default_listener.security_options.allow_anonymous != -1
			){

		VAR_1->listener_count++;
		VAR_1->listeners = mosquitto__realloc(VAR_1->listeners, sizeof(struct mosquitto__listener)*VAR_1->listener_count);
		if(!VAR_1->listeners){
			log__printf(NULL, VAR_6, ""Error: Out of memory."");
			return VAR_12;
		}
		memset(&VAR_1->listeners[VAR_1->listener_count-1], 0, sizeof(struct mosquitto__listener));
		if(VAR_1->default_listener.port){
			VAR_1->listeners[VAR_1->listener_count-1].port = VAR_1->default_listener.port;
		}else{
			VAR_1->listeners[VAR_1->listener_count-1].port = 1883;
		}
		if(VAR_1->default_listener.host){
			VAR_1->listeners[VAR_1->listener_count-1].host = VAR_1->default_listener.host;
		}else{
			VAR_1->listeners[VAR_1->listener_count-1].host = NULL;
		}
		if(VAR_1->default_listener.mount_point){
			VAR_1->listeners[VAR_1->listener_count-1].mount_point = VAR_1->default_listener.mount_point;
		}else{
			VAR_1->listeners[VAR_1->listener_count-1].mount_point = NULL;
		}
		VAR_1->listeners[VAR_1->listener_count-1].max_connections = VAR_1->default_listener.max_connections;
		VAR_1->listeners[VAR_1->listener_count-1].protocol = VAR_1->default_listener.protocol;
		VAR_1->listeners[VAR_1->listener_count-1].socket_domain = VAR_1->default_listener.socket_domain;
		VAR_1->listeners[VAR_1->listener_count-1].client_count = 0;
		VAR_1->listeners[VAR_1->listener_count-1].socks = NULL;
		VAR_1->listeners[VAR_1->listener_count-1].sock_count = 0;
		VAR_1->listeners[VAR_1->listener_count-1].client_count = 0;
		VAR_1->listeners[VAR_1->listener_count-1].use_username_as_clientid = VAR_1->default_listener.use_username_as_clientid;
#ifdef VAR_10
		VAR_1->listeners[VAR_1->listener_count-1].tls_version = VAR_1->default_listener.tls_version;
		VAR_1->listeners[VAR_1->listener_count-1].cafile = VAR_1->default_listener.cafile;
		VAR_1->listeners[VAR_1->listener_count-1].capath = VAR_1->default_listener.capath;
		VAR_1->listeners[VAR_1->listener_count-1].certfile = VAR_1->default_listener.certfile;
		VAR_1->listeners[VAR_1->listener_count-1].keyfile = VAR_1->default_listener.keyfile;
		VAR_1->listeners[VAR_1->listener_count-1].ciphers = VAR_1->default_listener.ciphers;
		VAR_1->listeners[VAR_1->listener_count-1].psk_hint = VAR_1->default_listener.psk_hint;
		VAR_1->listeners[VAR_1->listener_count-1].require_certificate = VAR_1->default_listener.require_certificate;
		VAR_1->listeners[VAR_1->listener_count-1].ssl_ctx = NULL;
		VAR_1->listeners[VAR_1->listener_count-1].crlfile = VAR_1->default_listener.crlfile;
		VAR_1->listeners[VAR_1->listener_count-1].use_identity_as_username = VAR_1->default_listener.use_identity_as_username;
		VAR_1->listeners[VAR_1->listener_count-1].use_subject_as_username = VAR_1->default_listener.use_subject_as_username;
#endif
		VAR_1->listeners[VAR_1->listener_count-1].security_options.acl_file = VAR_1->default_listener.security_options.acl_file;
		VAR_1->listeners[VAR_1->listener_count-1].security_options.password_file = VAR_1->default_listener.security_options.password_file;
		VAR_1->listeners[VAR_1->listener_count-1].security_options.psk_file = VAR_1->default_listener.security_options.psk_file;
		VAR_1->listeners[VAR_1->listener_count-1].security_options.auth_plugin_configs = VAR_1->default_listener.security_options.auth_plugin_configs;
		VAR_1->listeners[VAR_1->listener_count-1].security_options.auth_plugin_config_count = VAR_1->default_listener.security_options.auth_plugin_config_count;
		VAR_1->listeners[VAR_1->listener_count-1].security_options.allow_anonymous = VAR_1->default_listener.security_options.allow_anonymous;
	}

	/* COMMENT_0 */
	if(!VAR_1->user){
		VAR_1->user = ""mosquitto"";
	}
	if(VAR_0->verbose){
		VAR_1->log_type = VAR_13;
	}
	return config__check(VAR_1);
}",eclipse/mosquitto/9097577b49b7fdcf45d30975976dd93808ccc0c4/conf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -118,6 +118,7 @@
 		config->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;
 		config->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;
 #endif
+		config->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;
 		config->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;
 		config->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;
 		config->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;","{'deleted_lines': [], 'added_lines': ['\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;']}",True,"Eclipse Mosquitto 1.5.x before 1.5.5 allows ACL bypass: if the option per_listener_settings was set to true, and the default listener was in use, and the default listener specified an acl_file, then the acl file was being ignored.",7.5,HIGH,2,valid,2018-12-09T09:45:14Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c,nvkm_uvmm_mthd_map,"static int
nvkm_uvmm_mthd_map(struct nvkm_uvmm *uvmm, void *argv, u32 argc)
{
struct nvkm_client *client = uvmm->object.client;
union {
struct nvif_vmm_map_v0 v0;
} *args = argv;
u64 addr, size, handle, offset;
struct nvkm_vmm *vmm = uvmm->vmm;
struct nvkm_vma *vma;
struct nvkm_memory *memory;
int ret = -ENOSYS;
if (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, true))) {
addr = args->v0.addr;
size = args->v0.size;
handle = args->v0.memory;
offset = args->v0.offset;
} else
return ret;
memory = nvkm_umem_search(client, handle);
if (IS_ERR(memory)) {
VMM_DEBUG(vmm, ""memory %016llx %ld\n"", handle, PTR_ERR(memory));
return PTR_ERR(memory);
}
mutex_lock(&vmm->mutex);
if (ret = -ENOENT, !(vma = nvkm_vmm_node_search(vmm, addr))) {
VMM_DEBUG(vmm, ""lookup %016llx"", addr);
goto fail;
}
if (ret = -ENOENT, (!vma->user && !client->super) || vma->busy) {
VMM_DEBUG(vmm, ""denied %016llx: %d %d %d"", addr,
vma->user, !client->super, vma->busy);
goto fail;
}
if (ret = -EINVAL, vma->addr != addr || vma->size != size) {
if (addr + size > vma->addr + vma->size || vma->memory ||
(vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {
VMM_DEBUG(vmm, ""split %d %d %d ""
""%016llx %016llx %016llx %016llx"",
!!vma->memory, vma->refd, vma->mapref,
addr, size, vma->addr, (u64)vma->size);
goto fail;
}
if (vma->addr != addr) {
const u64 tail = vma->size + vma->addr - addr;
if (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))
goto fail;
vma->part = true;
nvkm_vmm_node_insert(vmm, vma);
}
if (vma->size != size) {
const u64 tail = vma->size - size;
struct nvkm_vma *tmp;
if (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {
nvkm_vmm_unmap_region(vmm, vma);
goto fail;
}
tmp->part = true;
nvkm_vmm_node_insert(vmm, tmp);
}
}
vma->busy = true;
mutex_unlock(&vmm->mutex);
ret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);
if (ret == 0) {
nvkm_memory_unref(&memory);
return 0;
}
mutex_lock(&vmm->mutex);
vma->busy = false;
nvkm_vmm_unmap_region(vmm, vma);
fail:
mutex_unlock(&vmm->mutex);
nvkm_memory_unref(&memory);
return ret;
}","static int
nvkm_uvmm_mthd_map(struct nvkm_uvmm *VAR_0, void *VAR_1, u32 VAR_2)
{
struct nvkm_client *VAR_3 = VAR_0->object.client;
union {
struct nvif_vmm_map_v0 v0;
} *VAR_4 = VAR_1;
u64 VAR_5, VAR_6, VAR_7, VAR_8;
struct nvkm_vmm *VAR_9 = VAR_0->vmm;
struct nvkm_vma *VAR_10;
struct nvkm_memory *VAR_11;
int VAR_12 = -VAR_13;
if (!(VAR_12 = nvif_unpack(VAR_12, &VAR_1, &VAR_2, VAR_4->v0, 0, 0, true))) {
VAR_5 = VAR_4->v0.addr;
VAR_6 = VAR_4->v0.size;
VAR_7 = VAR_4->v0.memory;
VAR_8 = VAR_4->v0.offset;
} else
return VAR_12;
VAR_11 = nvkm_umem_search(VAR_3, VAR_7);
if (IS_ERR(VAR_11)) {
VMM_DEBUG(VAR_9, ""memory %016llx %ld\n"", VAR_7, PTR_ERR(VAR_11));
return PTR_ERR(VAR_11);
}
mutex_lock(&VAR_9->mutex);
if (VAR_12 = -VAR_14, !(VAR_10 = nvkm_vmm_node_search(VAR_9, VAR_5))) {
VMM_DEBUG(VAR_9, ""lookup %016llx"", VAR_5);
goto fail;
}
if (VAR_12 = -VAR_14, (!VAR_10->user && !VAR_3->super) || VAR_10->busy) {
VMM_DEBUG(VAR_9, ""denied %016llx: %d %d %d"", VAR_5,
VAR_10->user, !VAR_3->super, VAR_10->busy);
goto fail;
}
if (VAR_12 = -VAR_15, VAR_10->addr != VAR_5 || VAR_10->size != VAR_6) {
if (VAR_5 + VAR_6 > VAR_10->addr + VAR_10->size || VAR_10->memory ||
(VAR_10->refd == VAR_16 && !VAR_10->mapref)) {
VMM_DEBUG(VAR_9, ""split %d %d %d ""
""%016llx %016llx %016llx %016llx"",
!!VAR_10->memory, VAR_10->refd, VAR_10->mapref,
VAR_5, VAR_6, VAR_10->addr, (u64)VAR_10->size);
goto fail;
}
if (VAR_10->addr != VAR_5) {
const u64 VAR_17 = VAR_10->size + VAR_10->addr - VAR_5;
if (VAR_12 = -VAR_18, !(VAR_10 = nvkm_vma_tail(VAR_10, VAR_17)))
goto fail;
VAR_10->part = true;
nvkm_vmm_node_insert(VAR_9, VAR_10);
}
if (VAR_10->size != VAR_6) {
const u64 VAR_17 = VAR_10->size - VAR_6;
struct nvkm_vma *VAR_19;
if (VAR_12 = -VAR_18, !(VAR_19 = nvkm_vma_tail(VAR_10, VAR_17))) {
nvkm_vmm_unmap_region(VAR_9, VAR_10);
goto fail;
}
VAR_19->part = true;
nvkm_vmm_node_insert(VAR_9, VAR_19);
}
}
VAR_10->busy = true;
mutex_unlock(&VAR_9->mutex);
VAR_12 = nvkm_memory_map(VAR_11, VAR_8, VAR_9, VAR_10, VAR_1, VAR_2);
if (VAR_12 == 0) {
nvkm_memory_unref(&VAR_11);
return 0;
}
mutex_lock(&VAR_9->mutex);
VAR_10->busy = false;
nvkm_vmm_unmap_region(VAR_9, VAR_10);
fail:
mutex_unlock(&VAR_9->mutex);
nvkm_memory_unref(&VAR_11);
return VAR_12;
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/uvmm.c/vul/before/0.json,"static int
nvkm_uvmm_mthd_map(struct nvkm_uvmm *uvmm, void *argv, u32 argc)
{
	struct nvkm_client *client = uvmm->object.client;
	union {
		struct nvif_vmm_map_v0 v0;
	} *args = argv;
	u64 addr, size, handle, offset;
	struct nvkm_vmm *vmm = uvmm->vmm;
	struct nvkm_vma *vma;
	struct nvkm_memory *memory;
	int ret = -ENOSYS;

	if (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, true))) {
		addr = args->v0.addr;
		size = args->v0.size;
		handle = args->v0.memory;
		offset = args->v0.offset;
	} else
		return ret;

	memory = nvkm_umem_search(client, handle);
	if (IS_ERR(memory)) {
		VMM_DEBUG(vmm, ""memory %016llx %ld\n"", handle, PTR_ERR(memory));
		return PTR_ERR(memory);
	}

	mutex_lock(&vmm->mutex);
	if (ret = -ENOENT, !(vma = nvkm_vmm_node_search(vmm, addr))) {
		VMM_DEBUG(vmm, ""lookup %016llx"", addr);
		goto fail;
	}

	if (ret = -ENOENT, (!vma->user && !client->super) || vma->busy) {
		VMM_DEBUG(vmm, ""denied %016llx: %d %d %d"", addr,
			  vma->user, !client->super, vma->busy);
		goto fail;
	}

	if (ret = -EINVAL, vma->addr != addr || vma->size != size) {
		if (addr + size > vma->addr + vma->size || vma->memory ||
		    (vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {
			VMM_DEBUG(vmm, ""split %d %d %d ""
				       ""%016llx %016llx %016llx %016llx"",
				  !!vma->memory, vma->refd, vma->mapref,
				  addr, size, vma->addr, (u64)vma->size);
			goto fail;
		}

		vma = nvkm_vmm_node_split(vmm, vma, addr, size);
		if (!vma) {
			ret = -ENOMEM;
			goto fail;
		}
	}
	vma->busy = true;
	mutex_unlock(&vmm->mutex);

	ret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);
	if (ret == 0) {
		/* Successful map will clear vma->busy. */
		nvkm_memory_unref(&memory);
		return 0;
	}

	mutex_lock(&vmm->mutex);
	vma->busy = false;
	nvkm_vmm_unmap_region(vmm, vma);
fail:
	mutex_unlock(&vmm->mutex);
	nvkm_memory_unref(&memory);
	return ret;
}","static int
nvkm_uvmm_mthd_map(struct nvkm_uvmm *VAR_0, void *VAR_1, u32 VAR_2)
{
	struct nvkm_client *VAR_3 = VAR_0->object.client;
	union {
		struct nvif_vmm_map_v0 v0;
	} *VAR_4 = VAR_1;
	u64 VAR_5, VAR_6, VAR_7, VAR_8;
	struct nvkm_vmm *VAR_9 = VAR_0->vmm;
	struct nvkm_vma *VAR_10;
	struct nvkm_memory *VAR_11;
	int VAR_12 = -VAR_13;

	if (!(VAR_12 = nvif_unpack(VAR_12, &VAR_1, &VAR_2, VAR_4->v0, 0, 0, true))) {
		VAR_5 = VAR_4->v0.addr;
		VAR_6 = VAR_4->v0.size;
		VAR_7 = VAR_4->v0.memory;
		VAR_8 = VAR_4->v0.offset;
	} else
		return VAR_12;

	VAR_11 = nvkm_umem_search(VAR_3, VAR_7);
	if (IS_ERR(VAR_11)) {
		VMM_DEBUG(VAR_9, ""memory %016llx %ld\n"", VAR_7, PTR_ERR(VAR_11));
		return PTR_ERR(VAR_11);
	}

	mutex_lock(&VAR_9->mutex);
	if (VAR_12 = -VAR_14, !(VAR_10 = nvkm_vmm_node_search(VAR_9, VAR_5))) {
		VMM_DEBUG(VAR_9, ""lookup %016llx"", VAR_5);
		goto fail;
	}

	if (VAR_12 = -VAR_14, (!VAR_10->user && !VAR_3->super) || VAR_10->busy) {
		VMM_DEBUG(VAR_9, ""denied %016llx: %d %d %d"", VAR_5,
			  VAR_10->user, !VAR_3->super, VAR_10->busy);
		goto fail;
	}

	if (VAR_12 = -VAR_15, VAR_10->addr != VAR_5 || VAR_10->size != VAR_6) {
		if (VAR_5 + VAR_6 > VAR_10->addr + VAR_10->size || VAR_10->memory ||
		    (VAR_10->refd == VAR_16 && !VAR_10->mapref)) {
			VMM_DEBUG(VAR_9, ""split %d %d %d ""
				       ""%016llx %016llx %016llx %016llx"",
				  !!VAR_10->memory, VAR_10->refd, VAR_10->mapref,
				  VAR_5, VAR_6, VAR_10->addr, (u64)VAR_10->size);
			goto fail;
		}

		VAR_10 = nvkm_vmm_node_split(VAR_9, VAR_10, VAR_5, VAR_6);
		if (!VAR_10) {
			VAR_12 = -VAR_17;
			goto fail;
		}
	}
	VAR_10->busy = true;
	mutex_unlock(&VAR_9->mutex);

	VAR_12 = nvkm_memory_map(VAR_11, VAR_8, VAR_9, VAR_10, VAR_1, VAR_2);
	if (VAR_12 == 0) {
		/* COMMENT_0 */
		nvkm_memory_unref(&VAR_11);
		return 0;
	}

	mutex_lock(&VAR_9->mutex);
	VAR_10->busy = false;
	nvkm_vmm_unmap_region(VAR_9, VAR_10);
fail:
	mutex_unlock(&VAR_9->mutex);
	nvkm_memory_unref(&VAR_11);
	return VAR_12;
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/uvmm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,23 +47,10 @@
 			goto fail;
 		}
 
-		if (vma->addr != addr) {
-			const u64 tail = vma->size + vma->addr - addr;
-			if (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))
-				goto fail;
-			vma->part = true;
-			nvkm_vmm_node_insert(vmm, vma);
-		}
-
-		if (vma->size != size) {
-			const u64 tail = vma->size - size;
-			struct nvkm_vma *tmp;
-			if (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {
-				nvkm_vmm_unmap_region(vmm, vma);
-				goto fail;
-			}
-			tmp->part = true;
-			nvkm_vmm_node_insert(vmm, tmp);
+		vma = nvkm_vmm_node_split(vmm, vma, addr, size);
+		if (!vma) {
+			ret = -ENOMEM;
+			goto fail;
 		}
 	}
 	vma->busy = true;","{'deleted_lines': ['\t\tif (vma->addr != addr) {', '\t\t\tconst u64 tail = vma->size + vma->addr - addr;', '\t\t\tif (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))', '\t\t\t\tgoto fail;', '\t\t\tvma->part = true;', '\t\t\tnvkm_vmm_node_insert(vmm, vma);', '\t\t}', '', '\t\tif (vma->size != size) {', '\t\t\tconst u64 tail = vma->size - size;', '\t\t\tstruct nvkm_vma *tmp;', '\t\t\tif (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {', '\t\t\t\tnvkm_vmm_unmap_region(vmm, vma);', '\t\t\t\tgoto fail;', '\t\t\t}', '\t\t\ttmp->part = true;', '\t\t\tnvkm_vmm_node_insert(vmm, tmp);'], 'added_lines': ['\t\tvma = nvkm_vmm_node_split(vmm, vma, addr, size);', '\t\tif (!vma) {', '\t\t\tret = -ENOMEM;', '\t\t\tgoto fail;']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c,nvkm_vmm_unmap_region,"void
nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
struct nvkm_vma *next;
nvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);
nvkm_memory_unref(&vma->memory);
if (vma->part) {
struct nvkm_vma *prev = node(vma, prev);
if (!prev->memory) {
prev->size += vma->size;
rb_erase(&vma->tree, &vmm->root);
list_del(&vma->head);
kfree(vma);
vma = prev;
}
}
next = node(vma, next);
if (next && next->part) {
if (!next->memory) {
vma->size += next->size;
rb_erase(&next->tree, &vmm->root);
list_del(&next->head);
kfree(next);
}
}
}","void
nvkm_vmm_unmap_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
struct nvkm_vma *VAR_2;
nvkm_memory_tags_put(VAR_1->memory, VAR_0->mmu->subdev.device, &VAR_1->tags);
nvkm_memory_unref(&VAR_1->memory);
if (VAR_1->part) {
struct nvkm_vma *VAR_3 = node(VAR_1, VAR_3);
if (!VAR_3->memory) {
VAR_3->size += VAR_1->size;
rb_erase(&VAR_1->tree, &VAR_0->root);
list_del(&VAR_1->head);
kfree(VAR_1);
VAR_1 = VAR_3;
}
}
VAR_2 = node(VAR_1, VAR_2);
if (VAR_2 && VAR_2->part) {
if (!VAR_2->memory) {
VAR_1->size += VAR_2->size;
rb_erase(&VAR_2->tree, &VAR_0->root);
list_del(&VAR_2->head);
kfree(VAR_2);
}
}
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/0.json,"void
nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
	struct nvkm_vma *next = node(vma, next);
	struct nvkm_vma *prev = NULL;

	nvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);
	nvkm_memory_unref(&vma->memory);

	if (!vma->part || ((prev = node(vma, prev)), prev->memory))
		prev = NULL;
	if (!next->part || next->memory)
		next = NULL;
	nvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);
}","void
nvkm_vmm_unmap_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
	struct nvkm_vma *VAR_2 = node(VAR_1, VAR_2);
	struct nvkm_vma *VAR_3 = NULL;

	nvkm_memory_tags_put(VAR_1->memory, VAR_0->mmu->subdev.device, &VAR_1->tags);
	nvkm_memory_unref(&VAR_1->memory);

	if (!VAR_1->part || ((VAR_3 = node(VAR_1, VAR_3)), VAR_3->memory))
		VAR_3 = NULL;
	if (!VAR_2->part || VAR_2->memory)
		VAR_2 = NULL;
	nvkm_vmm_node_merge(VAR_0, VAR_3, VAR_1, VAR_2, VAR_1->size);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,29 +1,15 @@
 void
 nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
 {
-	struct nvkm_vma *next;
+	struct nvkm_vma *next = node(vma, next);
+	struct nvkm_vma *prev = NULL;
 
 	nvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);
 	nvkm_memory_unref(&vma->memory);
 
-	if (vma->part) {
-		struct nvkm_vma *prev = node(vma, prev);
-		if (!prev->memory) {
-			prev->size += vma->size;
-			rb_erase(&vma->tree, &vmm->root);
-			list_del(&vma->head);
-			kfree(vma);
-			vma = prev;
-		}
-	}
-
-	next = node(vma, next);
-	if (next && next->part) {
-		if (!next->memory) {
-			vma->size += next->size;
-			rb_erase(&next->tree, &vmm->root);
-			list_del(&next->head);
-			kfree(next);
-		}
-	}
+	if (!vma->part || ((prev = node(vma, prev)), prev->memory))
+		prev = NULL;
+	if (!next->part || next->memory)
+		next = NULL;
+	nvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);
 }","{'deleted_lines': ['\tstruct nvkm_vma *next;', '\tif (vma->part) {', '\t\tstruct nvkm_vma *prev = node(vma, prev);', '\t\tif (!prev->memory) {', '\t\t\tprev->size += vma->size;', '\t\t\trb_erase(&vma->tree, &vmm->root);', '\t\t\tlist_del(&vma->head);', '\t\t\tkfree(vma);', '\t\t\tvma = prev;', '\t\t}', '\t}', '', '\tnext = node(vma, next);', '\tif (next && next->part) {', '\t\tif (!next->memory) {', '\t\t\tvma->size += next->size;', '\t\t\trb_erase(&next->tree, &vmm->root);', '\t\t\tlist_del(&next->head);', '\t\t\tkfree(next);', '\t\t}', '\t}'], 'added_lines': ['\tstruct nvkm_vma *next = node(vma, next);', '\tstruct nvkm_vma *prev = NULL;', '\tif (!vma->part || ((prev = node(vma, prev)), prev->memory))', '\t\tprev = NULL;', '\tif (!next->part || next->memory)', '\t\tnext = NULL;', '\tnvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c,nvkm_vmm_node_insert,"void
nvkm_vmm_node_insert(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
struct rb_node **ptr = &vmm->root.rb_node;
struct rb_node *parent = NULL;
while (*ptr) {
struct nvkm_vma *this = rb_entry(*ptr, typeof(*this), tree);
parent = *ptr;
if (vma->addr < this->addr)
ptr = &parent->rb_left;
else
if (vma->addr > this->addr)
ptr = &parent->rb_right;
else
BUG();
}
rb_link_node(&vma->tree, parent, ptr);
rb_insert_color(&vma->tree, &vmm->root);
}","void
nvkm_vmm_node_insert(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
struct rb_node **VAR_2 = &VAR_0->root.rb_node;
struct rb_node *VAR_3 = NULL;
while (*VAR_2) {
struct nvkm_vma *VAR_4 = rb_entry(*VAR_2, typeof(*VAR_4), VAR_5);
VAR_3 = *VAR_2;
if (VAR_1->addr < VAR_4->addr)
VAR_2 = &VAR_3->rb_left;
else
if (VAR_1->addr > VAR_4->addr)
VAR_2 = &VAR_3->rb_right;
else
BUG();
}
rb_link_node(&VAR_1->tree, VAR_3, VAR_2);
rb_insert_color(&VAR_1->tree, &VAR_0->root);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/1.json,"static void
nvkm_vmm_node_insert(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
	struct rb_node **ptr = &vmm->root.rb_node;
	struct rb_node *parent = NULL;

	while (*ptr) {
		struct nvkm_vma *this = rb_entry(*ptr, typeof(*this), tree);
		parent = *ptr;
		if (vma->addr < this->addr)
			ptr = &parent->rb_left;
		else
		if (vma->addr > this->addr)
			ptr = &parent->rb_right;
		else
			BUG();
	}

	rb_link_node(&vma->tree, parent, ptr);
	rb_insert_color(&vma->tree, &vmm->root);
}","static void
nvkm_vmm_node_insert(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
	struct rb_node **VAR_2 = &VAR_0->root.rb_node;
	struct rb_node *VAR_3 = NULL;

	while (*VAR_2) {
		struct nvkm_vma *VAR_4 = rb_entry(*VAR_2, typeof(*VAR_4), VAR_5);
		VAR_3 = *VAR_2;
		if (VAR_1->addr < VAR_4->addr)
			VAR_2 = &VAR_3->rb_left;
		else
		if (VAR_1->addr > VAR_4->addr)
			VAR_2 = &VAR_3->rb_right;
		else
			BUG();
	}

	rb_link_node(&VAR_1->tree, VAR_3, VAR_2);
	rb_insert_color(&VAR_1->tree, &VAR_0->root);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void
+static void
 nvkm_vmm_node_insert(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
 {
 	struct rb_node **ptr = &vmm->root.rb_node;","{'deleted_lines': ['void'], 'added_lines': ['static void']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c,nvkm_vmm_put_locked,"void
nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
const struct nvkm_vmm_page *page = vmm->func->page;
struct nvkm_vma *next = vma;
BUG_ON(vma->part);
if (vma->mapref || !vma->sparse) {
do {
const bool map = next->memory != NULL;
const u8  refd = next->refd;
const u64 addr = next->addr;
u64 size = next->size;
while ((next = node(next, next)) && next->part &&
(next->memory != NULL) == map &&
(next->refd == refd))
size += next->size;
if (map) {
nvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,
size, vma->sparse);
} else
if (refd != NVKM_VMA_PAGE_NONE) {
nvkm_vmm_ptes_put(vmm, &page[refd], addr, size);
}
} while (next && next->part);
}
next = vma;
do {
if (next->memory)
nvkm_vmm_unmap_region(vmm, next);
} while ((next = node(vma, next)) && next->part);
if (vma->sparse && !vma->mapref) {
nvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);
} else
if (vma->sparse) {
nvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);
}
rb_erase(&vma->tree, &vmm->root);
vma->page = NVKM_VMA_PAGE_NONE;
vma->refd = NVKM_VMA_PAGE_NONE;
vma->used = false;
vma->user = false;
nvkm_vmm_put_region(vmm, vma);
}","void
nvkm_vmm_put_locked(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
const struct nvkm_vmm_page *VAR_2 = VAR_0->func->page;
struct nvkm_vma *VAR_3 = VAR_1;
BUG_ON(VAR_1->part);
if (VAR_1->mapref || !VAR_1->sparse) {
do {
const bool VAR_4 = VAR_3->memory != NULL;
const u8  VAR_5 = VAR_3->refd;
const u64 VAR_6 = VAR_3->addr;
u64 VAR_7 = VAR_3->size;
while ((VAR_3 = node(VAR_3, VAR_3)) && VAR_3->part &&
(VAR_3->memory != NULL) == VAR_4 &&
(VAR_3->refd == VAR_5))
VAR_7 += VAR_3->size;
if (VAR_4) {
nvkm_vmm_ptes_unmap_put(VAR_0, &VAR_2[VAR_5], VAR_6,
VAR_7, VAR_1->sparse);
} else
if (VAR_5 != VAR_8) {
nvkm_vmm_ptes_put(VAR_0, &VAR_2[VAR_5], VAR_6, VAR_7);
}
} while (VAR_3 && VAR_3->part);
}
VAR_3 = VAR_1;
do {
if (VAR_3->memory)
nvkm_vmm_unmap_region(VAR_0, VAR_3);
} while ((VAR_3 = node(VAR_1, VAR_3)) && VAR_3->part);
if (VAR_1->sparse && !VAR_1->mapref) {
nvkm_vmm_ptes_sparse_put(VAR_0, &VAR_2[VAR_1->refd], VAR_1->addr, VAR_1->size);
} else
if (VAR_1->sparse) {
nvkm_vmm_ptes_sparse(VAR_0, VAR_1->addr, VAR_1->size, false);
}
rb_erase(&VAR_1->tree, &VAR_0->root);
VAR_1->page = VAR_8;
VAR_1->refd = VAR_8;
VAR_1->used = false;
VAR_1->user = false;
nvkm_vmm_put_region(VAR_0, VAR_1);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/2.json,"void
nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
	const struct nvkm_vmm_page *page = vmm->func->page;
	struct nvkm_vma *next = vma;

	BUG_ON(vma->part);

	if (vma->mapref || !vma->sparse) {
		do {
			const bool map = next->memory != NULL;
			const u8  refd = next->refd;
			const u64 addr = next->addr;
			u64 size = next->size;

			/* Merge regions that are in the same state. */
			while ((next = node(next, next)) && next->part &&
			       (next->memory != NULL) == map &&
			       (next->refd == refd))
				size += next->size;

			if (map) {
				/* Region(s) are mapped, merge the unmap
				 * and dereference into a single walk of
				 * the page tree.
				 */
				nvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,
							size, vma->sparse);
			} else
			if (refd != NVKM_VMA_PAGE_NONE) {
				/* Drop allocation-time PTE references. */
				nvkm_vmm_ptes_put(vmm, &page[refd], addr, size);
			}
		} while (next && next->part);
	}

	/* Merge any mapped regions that were split from the initial
	 * address-space allocation back into the allocated VMA, and
	 * release memory/compression resources.
	 */
	next = vma;
	do {
		if (next->memory)
			nvkm_vmm_unmap_region(vmm, next);
	} while ((next = node(vma, next)) && next->part);

	if (vma->sparse && !vma->mapref) {
		/* Sparse region that was allocated with a fixed page size,
		 * meaning all relevant PTEs were referenced once when the
		 * region was allocated, and remained that way, regardless
		 * of whether memory was mapped into it afterwards.
		 *
		 * The process of unmapping, unsparsing, and dereferencing
		 * PTEs can be done in a single page tree walk.
		 */
		nvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);
	} else
	if (vma->sparse) {
		/* Sparse region that wasn't allocated with a fixed page size,
		 * PTE references were taken both at allocation time (to make
		 * the GPU see the region as sparse), and when mapping memory
		 * into the region.
		 *
		 * The latter was handled above, and the remaining references
		 * are dealt with here.
		 */
		nvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);
	}

	/* Remove VMA from the list of allocated nodes. */
	nvkm_vmm_node_remove(vmm, vma);

	/* Merge VMA back into the free list. */
	vma->page = NVKM_VMA_PAGE_NONE;
	vma->refd = NVKM_VMA_PAGE_NONE;
	vma->used = false;
	vma->user = false;
	nvkm_vmm_put_region(vmm, vma);
}","void
nvkm_vmm_put_locked(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
	const struct nvkm_vmm_page *VAR_2 = VAR_0->func->page;
	struct nvkm_vma *VAR_3 = VAR_1;

	BUG_ON(VAR_1->part);

	if (VAR_1->mapref || !VAR_1->sparse) {
		do {
			const bool VAR_4 = VAR_3->memory != NULL;
			const u8  VAR_5 = VAR_3->refd;
			const u64 VAR_6 = VAR_3->addr;
			u64 VAR_7 = VAR_3->size;

			/* COMMENT_0 */
			while ((VAR_3 = node(VAR_3, VAR_3)) && VAR_3->part &&
			       (VAR_3->memory != NULL) == VAR_4 &&
			       (VAR_3->refd == VAR_5))
				VAR_7 += VAR_3->size;

			if (VAR_4) {
				/* COMMENT_1 */
                                            
                     
       
				nvkm_vmm_ptes_unmap_put(VAR_0, &VAR_2[VAR_5], VAR_6,
							VAR_7, VAR_1->sparse);
			} else
			if (VAR_5 != VAR_8) {
				/* COMMENT_5 */
				nvkm_vmm_ptes_put(VAR_0, &VAR_2[VAR_5], VAR_6, VAR_7);
			}
		} while (VAR_3 && VAR_3->part);
	}

	/* COMMENT_6 */
                                                             
                                         
    
	VAR_3 = VAR_1;
	do {
		if (VAR_3->memory)
			nvkm_vmm_unmap_region(VAR_0, VAR_3);
	} while ((VAR_3 = node(VAR_1, VAR_3)) && VAR_3->part);

	if (VAR_1->sparse && !VAR_1->mapref) {
		/* COMMENT_10 */
                                                            
                                                            
                                                     
    
                                                            
                                                 
     
		nvkm_vmm_ptes_sparse_put(VAR_0, &VAR_2[VAR_1->refd], VAR_1->addr, VAR_1->size);
	} else
	if (VAR_1->sparse) {
		/* COMMENT_18 */
                                                               
                                                               
                     
    
                                                               
                         
     
		nvkm_vmm_ptes_sparse(VAR_0, VAR_1->addr, VAR_1->size, false);
	}

	/* COMMENT_26 */
	nvkm_vmm_node_remove(VAR_0, VAR_1);

	/* COMMENT_27 */
	VAR_1->page = VAR_8;
	VAR_1->refd = VAR_8;
	VAR_1->used = false;
	VAR_1->user = false;
	nvkm_vmm_put_region(VAR_0, VAR_1);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -68,7 +68,7 @@
 	}
 
 	/* Remove VMA from the list of allocated nodes. */
-	rb_erase(&vma->tree, &vmm->root);
+	nvkm_vmm_node_remove(vmm, vma);
 
 	/* Merge VMA back into the free list. */
 	vma->page = NVKM_VMA_PAGE_NONE;","{'deleted_lines': ['\trb_erase(&vma->tree, &vmm->root);'], 'added_lines': ['\tnvkm_vmm_node_remove(vmm, vma);']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c,nvkm_vmm_put_region,"static void
nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
struct nvkm_vma *prev, *next;
if ((prev = node(vma, prev)) && !prev->used) {
rb_erase(&prev->tree, &vmm->free);
list_del(&prev->head);
vma->addr  = prev->addr;
vma->size += prev->size;
kfree(prev);
}
if ((next = node(vma, next)) && !next->used) {
rb_erase(&next->tree, &vmm->free);
list_del(&next->head);
vma->size += next->size;
kfree(next);
}
nvkm_vmm_free_insert(vmm, vma);
}","static void
nvkm_vmm_put_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
struct nvkm_vma *VAR_2, *VAR_3;
if ((VAR_2 = node(VAR_1, VAR_2)) && !VAR_2->used) {
rb_erase(&VAR_2->tree, &VAR_0->free);
list_del(&VAR_2->head);
VAR_1->addr  = VAR_2->addr;
VAR_1->size += VAR_2->size;
kfree(VAR_2);
}
if ((VAR_3 = node(VAR_1, VAR_3)) && !VAR_3->used) {
rb_erase(&VAR_3->tree, &VAR_0->free);
list_del(&VAR_3->head);
VAR_1->size += VAR_3->size;
kfree(VAR_3);
}
nvkm_vmm_free_insert(VAR_0, VAR_1);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/3.json,"static void
nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)
{
	struct nvkm_vma *prev, *next;

	if ((prev = node(vma, prev)) && !prev->used) {
		vma->addr  = prev->addr;
		vma->size += prev->size;
		nvkm_vmm_free_delete(vmm, prev);
	}

	if ((next = node(vma, next)) && !next->used) {
		vma->size += next->size;
		nvkm_vmm_free_delete(vmm, next);
	}

	nvkm_vmm_free_insert(vmm, vma);
}","static void
nvkm_vmm_put_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)
{
	struct nvkm_vma *VAR_2, *VAR_3;

	if ((VAR_2 = node(VAR_1, VAR_2)) && !VAR_2->used) {
		VAR_1->addr  = VAR_2->addr;
		VAR_1->size += VAR_2->size;
		nvkm_vmm_free_delete(VAR_0, VAR_2);
	}

	if ((VAR_3 = node(VAR_1, VAR_3)) && !VAR_3->used) {
		VAR_1->size += VAR_3->size;
		nvkm_vmm_free_delete(VAR_0, VAR_3);
	}

	nvkm_vmm_free_insert(VAR_0, VAR_1);
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -4,18 +4,14 @@
 	struct nvkm_vma *prev, *next;
 
 	if ((prev = node(vma, prev)) && !prev->used) {
-		rb_erase(&prev->tree, &vmm->free);
-		list_del(&prev->head);
 		vma->addr  = prev->addr;
 		vma->size += prev->size;
-		kfree(prev);
+		nvkm_vmm_free_delete(vmm, prev);
 	}
 
 	if ((next = node(vma, next)) && !next->used) {
-		rb_erase(&next->tree, &vmm->free);
-		list_del(&next->head);
 		vma->size += next->size;
-		kfree(next);
+		nvkm_vmm_free_delete(vmm, next);
 	}
 
 	nvkm_vmm_free_insert(vmm, vma);","{'deleted_lines': ['\t\trb_erase(&prev->tree, &vmm->free);', '\t\tlist_del(&prev->head);', '\t\tkfree(prev);', '\t\trb_erase(&next->tree, &vmm->free);', '\t\tlist_del(&next->head);', '\t\tkfree(next);'], 'added_lines': ['\t\tnvkm_vmm_free_delete(vmm, prev);', '\t\tnvkm_vmm_free_delete(vmm, next);']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2023-0030,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"drm/nouveau/mmu: add more general vmm free/node handling functions

Aside from being a nice cleanup, these will to allow the upcoming direct
page mapping interfaces to play nicely with normal mappings.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>",729eba3355674f2d9524629b73683ba1d1cd3f10,https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10,drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c,nvkm_vmm_get_locked,"int
nvkm_vmm_get_locked(struct nvkm_vmm *vmm, bool getref, bool mapref, bool sparse,
u8 shift, u8 align, u64 size, struct nvkm_vma **pvma)
{
const struct nvkm_vmm_page *page = &vmm->func->page[NVKM_VMA_PAGE_NONE];
struct rb_node *node = NULL, *temp;
struct nvkm_vma *vma = NULL, *tmp;
u64 addr, tail;
int ret;
VMM_TRACE(vmm, ""getref %d mapref %d sparse %d ""
""shift: %d align: %d size: %016llx"",
getref, mapref, sparse, shift, align, size);
if (unlikely(!size || (!getref && !mapref && sparse))) {
VMM_DEBUG(vmm, ""args %016llx %d %d %d"",
size, getref, mapref, sparse);
return -EINVAL;
}
if (unlikely((getref || vmm->func->page_block) && !shift)) {
VMM_DEBUG(vmm, ""page size required: %d %016llx"",
getref, vmm->func->page_block);
return -EINVAL;
}
if (shift) {
for (page = vmm->func->page; page->shift; page++) {
if (shift == page->shift)
break;
}
if (!page->shift || !IS_ALIGNED(size, 1ULL << page->shift)) {
VMM_DEBUG(vmm, ""page %d %016llx"", shift, size);
return -EINVAL;
}
align = max_t(u8, align, shift);
} else {
align = max_t(u8, align, 12);
}
temp = vmm->free.rb_node;
while (temp) {
struct nvkm_vma *this = rb_entry(temp, typeof(*this), tree);
if (this->size < size) {
temp = temp->rb_right;
} else {
node = temp;
temp = temp->rb_left;
}
}
if (unlikely(!node))
return -ENOSPC;
do {
struct nvkm_vma *this = rb_entry(node, typeof(*this), tree);
struct nvkm_vma *prev = node(this, prev);
struct nvkm_vma *next = node(this, next);
const int p = page - vmm->func->page;
addr = this->addr;
if (vmm->func->page_block && prev && prev->page != p)
addr = ALIGN(addr, vmm->func->page_block);
addr = ALIGN(addr, 1ULL << align);
tail = this->addr + this->size;
if (vmm->func->page_block && next && next->page != p)
tail = ALIGN_DOWN(tail, vmm->func->page_block);
if (addr <= tail && tail - addr >= size) {
rb_erase(&this->tree, &vmm->free);
vma = this;
break;
}
} while ((node = rb_next(node)));
if (unlikely(!vma))
return -ENOSPC;
if (addr != vma->addr) {
if (!(tmp = nvkm_vma_tail(vma, vma->size + vma->addr - addr))) {
nvkm_vmm_put_region(vmm, vma);
return -ENOMEM;
}
nvkm_vmm_free_insert(vmm, vma);
vma = tmp;
}
if (size != vma->size) {
if (!(tmp = nvkm_vma_tail(vma, vma->size - size))) {
nvkm_vmm_put_region(vmm, vma);
return -ENOMEM;
}
nvkm_vmm_free_insert(vmm, tmp);
}
if (sparse && getref)
ret = nvkm_vmm_ptes_sparse_get(vmm, page, vma->addr, vma->size);
else if (sparse)
ret = nvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, true);
else if (getref)
ret = nvkm_vmm_ptes_get(vmm, page, vma->addr, vma->size);
else
ret = 0;
if (ret) {
nvkm_vmm_put_region(vmm, vma);
return ret;
}
vma->mapref = mapref && !getref;
vma->sparse = sparse;
vma->page = page - vmm->func->page;
vma->refd = getref ? vma->page : NVKM_VMA_PAGE_NONE;
vma->used = true;
nvkm_vmm_node_insert(vmm, vma);
*pvma = vma;
return 0;
}","int
nvkm_vmm_get_locked(struct nvkm_vmm *VAR_0, bool VAR_1, bool VAR_2, bool VAR_3,
u8 VAR_4, u8 VAR_5, u64 VAR_6, struct nvkm_vma **VAR_7)
{
const struct nvkm_vmm_page *VAR_8 = &VAR_0->func->page[VAR_9];
struct rb_node *VAR_10 = NULL, *VAR_11;
struct nvkm_vma *VAR_12 = NULL, *VAR_13;
u64 VAR_14, VAR_15;
int VAR_16;
VMM_TRACE(VAR_0, ""getref %d mapref %d sparse %d ""
""shift: %d align: %d size: %016llx"",
VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
if (unlikely(!VAR_6 || (!VAR_1 && !VAR_2 && VAR_3))) {
VMM_DEBUG(VAR_0, ""args %016llx %d %d %d"",
VAR_6, VAR_1, VAR_2, VAR_3);
return -VAR_17;
}
if (unlikely((VAR_1 || VAR_0->func->page_block) && !VAR_4)) {
VMM_DEBUG(VAR_0, ""page size required: %d %016llx"",
VAR_1, VAR_0->func->page_block);
return -VAR_17;
}
if (VAR_4) {
for (VAR_8 = VAR_0->func->page; VAR_8->shift; VAR_8++) {
if (VAR_4 == VAR_8->shift)
break;
}
if (!VAR_8->shift || !IS_ALIGNED(VAR_6, 1ULL << VAR_8->shift)) {
VMM_DEBUG(VAR_0, ""page %d %016llx"", VAR_4, VAR_6);
return -VAR_17;
}
VAR_5 = max_t(u8, VAR_5, VAR_4);
} else {
VAR_5 = max_t(u8, VAR_5, 12);
}
VAR_11 = VAR_0->free.rb_node;
while (VAR_11) {
struct nvkm_vma *VAR_18 = rb_entry(VAR_11, typeof(*VAR_18), VAR_19);
if (VAR_18->size < VAR_6) {
VAR_11 = VAR_11->rb_right;
} else {
VAR_10 = VAR_11;
VAR_11 = VAR_11->rb_left;
}
}
if (unlikely(!VAR_10))
return -VAR_20;
do {
struct nvkm_vma *VAR_18 = rb_entry(VAR_10, typeof(*VAR_18), VAR_19);
struct nvkm_vma *VAR_21 = VAR_10(VAR_18, VAR_21);
struct nvkm_vma *VAR_22 = VAR_10(VAR_18, VAR_22);
const int VAR_23 = VAR_8 - VAR_0->func->page;
VAR_14 = VAR_18->addr;
if (VAR_0->func->page_block && VAR_21 && VAR_21->page != VAR_23)
VAR_14 = ALIGN(VAR_14, VAR_0->func->page_block);
VAR_14 = ALIGN(VAR_14, 1ULL << VAR_5);
VAR_15 = VAR_18->addr + VAR_18->size;
if (VAR_0->func->page_block && VAR_22 && VAR_22->page != VAR_23)
VAR_15 = ALIGN_DOWN(VAR_15, VAR_0->func->page_block);
if (VAR_14 <= VAR_15 && VAR_15 - VAR_14 >= VAR_6) {
rb_erase(&VAR_18->tree, &VAR_0->free);
VAR_12 = VAR_18;
break;
}
} while ((VAR_10 = rb_next(VAR_10)));
if (unlikely(!VAR_12))
return -VAR_20;
if (VAR_14 != VAR_12->addr) {
if (!(VAR_13 = nvkm_vma_tail(VAR_12, VAR_12->size + VAR_12->addr - VAR_14))) {
nvkm_vmm_put_region(VAR_0, VAR_12);
return -VAR_24;
}
nvkm_vmm_free_insert(VAR_0, VAR_12);
VAR_12 = VAR_13;
}
if (VAR_6 != VAR_12->size) {
if (!(VAR_13 = nvkm_vma_tail(VAR_12, VAR_12->size - VAR_6))) {
nvkm_vmm_put_region(VAR_0, VAR_12);
return -VAR_24;
}
nvkm_vmm_free_insert(VAR_0, VAR_13);
}
if (VAR_3 && VAR_1)
VAR_16 = nvkm_vmm_ptes_sparse_get(VAR_0, VAR_8, VAR_12->addr, VAR_12->size);
else if (VAR_3)
VAR_16 = nvkm_vmm_ptes_sparse(VAR_0, VAR_12->addr, VAR_12->size, true);
else if (VAR_1)
VAR_16 = nvkm_vmm_ptes_get(VAR_0, VAR_8, VAR_12->addr, VAR_12->size);
else
VAR_16 = 0;
if (VAR_16) {
nvkm_vmm_put_region(VAR_0, VAR_12);
return VAR_16;
}
VAR_12->mapref = VAR_2 && !VAR_1;
VAR_12->sparse = VAR_3;
VAR_12->page = VAR_8 - VAR_0->func->page;
VAR_12->refd = VAR_1 ? VAR_12->page : VAR_9;
VAR_12->used = true;
nvkm_vmm_node_insert(VAR_0, VAR_12);
*VAR_7 = VAR_12;
return 0;
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/4.json,"int
nvkm_vmm_get_locked(struct nvkm_vmm *vmm, bool getref, bool mapref, bool sparse,
		    u8 shift, u8 align, u64 size, struct nvkm_vma **pvma)
{
	const struct nvkm_vmm_page *page = &vmm->func->page[NVKM_VMA_PAGE_NONE];
	struct rb_node *node = NULL, *temp;
	struct nvkm_vma *vma = NULL, *tmp;
	u64 addr, tail;
	int ret;

	VMM_TRACE(vmm, ""getref %d mapref %d sparse %d ""
		       ""shift: %d align: %d size: %016llx"",
		  getref, mapref, sparse, shift, align, size);

	/* Zero-sized, or lazily-allocated sparse VMAs, make no sense. */
	if (unlikely(!size || (!getref && !mapref && sparse))) {
		VMM_DEBUG(vmm, ""args %016llx %d %d %d"",
			  size, getref, mapref, sparse);
		return -EINVAL;
	}

	/* Tesla-class GPUs can only select page size per-PDE, which means
	 * we're required to know the mapping granularity up-front to find
	 * a suitable region of address-space.
	 *
	 * The same goes if we're requesting up-front allocation of PTES.
	 */
	if (unlikely((getref || vmm->func->page_block) && !shift)) {
		VMM_DEBUG(vmm, ""page size required: %d %016llx"",
			  getref, vmm->func->page_block);
		return -EINVAL;
	}

	/* If a specific page size was requested, determine its index and
	 * make sure the requested size is a multiple of the page size.
	 */
	if (shift) {
		for (page = vmm->func->page; page->shift; page++) {
			if (shift == page->shift)
				break;
		}

		if (!page->shift || !IS_ALIGNED(size, 1ULL << page->shift)) {
			VMM_DEBUG(vmm, ""page %d %016llx"", shift, size);
			return -EINVAL;
		}
		align = max_t(u8, align, shift);
	} else {
		align = max_t(u8, align, 12);
	}

	/* Locate smallest block that can possibly satisfy the allocation. */
	temp = vmm->free.rb_node;
	while (temp) {
		struct nvkm_vma *this = rb_entry(temp, typeof(*this), tree);
		if (this->size < size) {
			temp = temp->rb_right;
		} else {
			node = temp;
			temp = temp->rb_left;
		}
	}

	if (unlikely(!node))
		return -ENOSPC;

	/* Take into account alignment restrictions, trying larger blocks
	 * in turn until we find a suitable free block.
	 */
	do {
		struct nvkm_vma *this = rb_entry(node, typeof(*this), tree);
		struct nvkm_vma *prev = node(this, prev);
		struct nvkm_vma *next = node(this, next);
		const int p = page - vmm->func->page;

		addr = this->addr;
		if (vmm->func->page_block && prev && prev->page != p)
			addr = ALIGN(addr, vmm->func->page_block);
		addr = ALIGN(addr, 1ULL << align);

		tail = this->addr + this->size;
		if (vmm->func->page_block && next && next->page != p)
			tail = ALIGN_DOWN(tail, vmm->func->page_block);

		if (addr <= tail && tail - addr >= size) {
			nvkm_vmm_free_remove(vmm, this);
			vma = this;
			break;
		}
	} while ((node = rb_next(node)));

	if (unlikely(!vma))
		return -ENOSPC;

	/* If the VMA we found isn't already exactly the requested size,
	 * it needs to be split, and the remaining free blocks returned.
	 */
	if (addr != vma->addr) {
		if (!(tmp = nvkm_vma_tail(vma, vma->size + vma->addr - addr))) {
			nvkm_vmm_put_region(vmm, vma);
			return -ENOMEM;
		}
		nvkm_vmm_free_insert(vmm, vma);
		vma = tmp;
	}

	if (size != vma->size) {
		if (!(tmp = nvkm_vma_tail(vma, vma->size - size))) {
			nvkm_vmm_put_region(vmm, vma);
			return -ENOMEM;
		}
		nvkm_vmm_free_insert(vmm, tmp);
	}

	/* Pre-allocate page tables and/or setup sparse mappings. */
	if (sparse && getref)
		ret = nvkm_vmm_ptes_sparse_get(vmm, page, vma->addr, vma->size);
	else if (sparse)
		ret = nvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, true);
	else if (getref)
		ret = nvkm_vmm_ptes_get(vmm, page, vma->addr, vma->size);
	else
		ret = 0;
	if (ret) {
		nvkm_vmm_put_region(vmm, vma);
		return ret;
	}

	vma->mapref = mapref && !getref;
	vma->sparse = sparse;
	vma->page = page - vmm->func->page;
	vma->refd = getref ? vma->page : NVKM_VMA_PAGE_NONE;
	vma->used = true;
	nvkm_vmm_node_insert(vmm, vma);
	*pvma = vma;
	return 0;
}","int
nvkm_vmm_get_locked(struct nvkm_vmm *VAR_0, bool VAR_1, bool VAR_2, bool VAR_3,
		    u8 VAR_4, u8 VAR_5, u64 VAR_6, struct nvkm_vma **VAR_7)
{
	const struct nvkm_vmm_page *VAR_8 = &VAR_0->func->page[VAR_9];
	struct rb_node *VAR_10 = NULL, *VAR_11;
	struct nvkm_vma *VAR_12 = NULL, *VAR_13;
	u64 VAR_14, VAR_15;
	int VAR_16;

	VMM_TRACE(VAR_0, ""getref %d mapref %d sparse %d ""
		       ""shift: %d align: %d size: %016llx"",
		  VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);

	/* COMMENT_0 */
	if (unlikely(!VAR_6 || (!VAR_1 && !VAR_2 && VAR_3))) {
		VMM_DEBUG(VAR_0, ""args %016llx %d %d %d"",
			  VAR_6, VAR_1, VAR_2, VAR_3);
		return -VAR_17;
	}

	/* COMMENT_1 */
                                                                   
                                       
   
                                                                  
    
	if (unlikely((VAR_1 || VAR_0->func->page_block) && !VAR_4)) {
		VMM_DEBUG(VAR_0, ""page size required: %d %016llx"",
			  VAR_1, VAR_0->func->page_block);
		return -VAR_17;
	}

	/* COMMENT_7 */
                                                                
    
	if (VAR_4) {
		for (VAR_8 = VAR_0->func->page; VAR_8->shift; VAR_8++) {
			if (VAR_4 == VAR_8->shift)
				break;
		}

		if (!VAR_8->shift || !IS_ALIGNED(VAR_6, 1ULL << VAR_8->shift)) {
			VMM_DEBUG(VAR_0, ""page %d %016llx"", VAR_4, VAR_6);
			return -VAR_17;
		}
		VAR_5 = max_t(u8, VAR_5, VAR_4);
	} else {
		VAR_5 = max_t(u8, VAR_5, 12);
	}

	/* COMMENT_10 */
	VAR_11 = VAR_0->free.rb_node;
	while (VAR_11) {
		struct nvkm_vma *VAR_18 = rb_entry(VAR_11, typeof(*VAR_18), VAR_19);
		if (VAR_18->size < VAR_6) {
			VAR_11 = VAR_11->rb_right;
		} else {
			VAR_10 = VAR_11;
			VAR_11 = VAR_11->rb_left;
		}
	}

	if (unlikely(!VAR_10))
		return -VAR_20;

	/* COMMENT_11 */
                                                
    
	do {
		struct nvkm_vma *VAR_18 = rb_entry(VAR_10, typeof(*VAR_18), VAR_19);
		struct nvkm_vma *VAR_21 = VAR_10(VAR_18, VAR_21);
		struct nvkm_vma *VAR_22 = VAR_10(VAR_18, VAR_22);
		const int VAR_23 = VAR_8 - VAR_0->func->page;

		VAR_14 = VAR_18->addr;
		if (VAR_0->func->page_block && VAR_21 && VAR_21->page != VAR_23)
			VAR_14 = ALIGN(VAR_14, VAR_0->func->page_block);
		VAR_14 = ALIGN(VAR_14, 1ULL << VAR_5);

		VAR_15 = VAR_18->addr + VAR_18->size;
		if (VAR_0->func->page_block && VAR_22 && VAR_22->page != VAR_23)
			VAR_15 = ALIGN_DOWN(VAR_15, VAR_0->func->page_block);

		if (VAR_14 <= VAR_15 && VAR_15 - VAR_14 >= VAR_6) {
			nvkm_vmm_free_remove(VAR_0, VAR_18);
			VAR_12 = VAR_18;
			break;
		}
	} while ((VAR_10 = rb_next(VAR_10)));

	if (unlikely(!VAR_12))
		return -VAR_20;

	/* COMMENT_14 */
                                                                 
    
	if (VAR_14 != VAR_12->addr) {
		if (!(VAR_13 = nvkm_vma_tail(VAR_12, VAR_12->size + VAR_12->addr - VAR_14))) {
			nvkm_vmm_put_region(VAR_0, VAR_12);
			return -VAR_24;
		}
		nvkm_vmm_free_insert(VAR_0, VAR_12);
		VAR_12 = VAR_13;
	}

	if (VAR_6 != VAR_12->size) {
		if (!(VAR_13 = nvkm_vma_tail(VAR_12, VAR_12->size - VAR_6))) {
			nvkm_vmm_put_region(VAR_0, VAR_12);
			return -VAR_24;
		}
		nvkm_vmm_free_insert(VAR_0, VAR_13);
	}

	/* COMMENT_17 */
	if (VAR_3 && VAR_1)
		VAR_16 = nvkm_vmm_ptes_sparse_get(VAR_0, VAR_8, VAR_12->addr, VAR_12->size);
	else if (VAR_3)
		VAR_16 = nvkm_vmm_ptes_sparse(VAR_0, VAR_12->addr, VAR_12->size, true);
	else if (VAR_1)
		VAR_16 = nvkm_vmm_ptes_get(VAR_0, VAR_8, VAR_12->addr, VAR_12->size);
	else
		VAR_16 = 0;
	if (VAR_16) {
		nvkm_vmm_put_region(VAR_0, VAR_12);
		return VAR_16;
	}

	VAR_12->mapref = VAR_2 && !VAR_1;
	VAR_12->sparse = VAR_3;
	VAR_12->page = VAR_8 - VAR_0->func->page;
	VAR_12->refd = VAR_1 ? VAR_12->page : VAR_9;
	VAR_12->used = true;
	nvkm_vmm_node_insert(VAR_0, VAR_12);
	*VAR_7 = VAR_12;
	return 0;
}",torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -83,7 +83,7 @@
 			tail = ALIGN_DOWN(tail, vmm->func->page_block);
 
 		if (addr <= tail && tail - addr >= size) {
-			rb_erase(&this->tree, &vmm->free);
+			nvkm_vmm_free_remove(vmm, this);
 			vma = this;
 			break;
 		}","{'deleted_lines': ['\t\t\trb_erase(&this->tree, &vmm->free);'], 'added_lines': ['\t\t\tnvkm_vmm_free_remove(vmm, this);']}",True,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,2018-12-11T04:50:02Z,2
CVE-2019-1010239,"['CWE-476', 'CWE-754']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,DaveGamble/cJSON,Fix crash of cJSON_GetObjectItemCaseSensitive when calling it on arrays,be749d7efa7c9021da746e685bd6dec79f9dd99b,https://github.com/DaveGamble/cJSON/commit/be749d7efa7c9021da746e685bd6dec79f9dd99b,cJSON.c,get_object_item,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
cJSON *current_element = NULL;
if ((object == NULL) || (name == NULL))
{
return NULL;
}
current_element = object->child;
if (case_sensitive)
{
while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
{
current_element = current_element->next;
}
}
else
{
while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
{
current_element = current_element->next;
}
}
return current_element;
}","static cJSON *get_object_item(const cJSON * const VAR_0, const char * const VAR_1, const cJSON_bool VAR_2)
{
cJSON *VAR_3 = NULL;
if ((VAR_0 == NULL) || (VAR_1 == NULL))
{
return NULL;
}
VAR_3 = VAR_0->child;
if (VAR_2)
{
while ((VAR_3 != NULL) && (strcmp(VAR_1, VAR_3->string) != 0))
{
VAR_3 = VAR_3->next;
}
}
else
{
while ((VAR_3 != NULL) && (case_insensitive_strcmp((const unsigned char*)VAR_1, (const unsigned char*)(VAR_3->string)) != 0))
{
VAR_3 = VAR_3->next;
}
}
return VAR_3;
}",DaveGamble/cJSON/be749d7efa7c9021da746e685bd6dec79f9dd99b/cJSON.c/vul/before/0.json,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

    current_element = object->child;
    if (case_sensitive)
    {
        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        {
            current_element = current_element->next;
        }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
        }
    }

    if ((current_element == NULL) || (current_element->string == NULL)) {
        return NULL;
    }

    return current_element;
}","static cJSON *get_object_item(const cJSON * const VAR_0, const char * const VAR_1, const cJSON_bool VAR_2)
{
    cJSON *VAR_3 = NULL;

    if ((VAR_0 == NULL) || (VAR_1 == NULL))
    {
        return NULL;
    }

    VAR_3 = VAR_0->child;
    if (VAR_2)
    {
        while ((VAR_3 != NULL) && (VAR_3->string != NULL) && (strcmp(VAR_1, VAR_3->string) != 0))
        {
            VAR_3 = VAR_3->next;
        }
    }
    else
    {
        while ((VAR_3 != NULL) && (case_insensitive_strcmp((const unsigned char*)VAR_1, (const unsigned char*)(VAR_3->string)) != 0))
        {
            VAR_3 = VAR_3->next;
        }
    }

    if ((VAR_3 == NULL) || (VAR_3->string == NULL)) {
        return NULL;
    }

    return VAR_3;
}",DaveGamble/cJSON/be749d7efa7c9021da746e685bd6dec79f9dd99b/cJSON.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
     current_element = object->child;
     if (case_sensitive)
     {
-        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
+        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
@@ -23,5 +23,9 @@
         }
     }
 
+    if ((current_element == NULL) || (current_element->string == NULL)) {
+        return NULL;
+    }
+
     return current_element;
 }","{'deleted_lines': ['        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))'], 'added_lines': ['        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))', '    if ((current_element == NULL) || (current_element->string == NULL)) {', '        return NULL;', '    }', '']}",True,"DaveGamble/cJSON cJSON 1.7.8 is affected by: Improper Check for Unusual or Exceptional Conditions. The impact is: Null dereference, so attack can cause denial of service. The component is: cJSON_GetObjectItemCaseSensitive() function. The attack vector is: crafted json file. The fixed version is: 1.7.9 and later.",7.5,HIGH,2,valid,2018-12-16T10:06:40Z,2
CVE-2019-12107,['CWE-252'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,miniupnp,upnp_event_prepare(): check the return value of snprintf(),bec6ccec63cadc95655721bc0e1dd49dac759d94,https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94,miniupnpd/upnpevents.c,upnp_event_prepare,"static void upnp_event_prepare(struct upnp_event_notify * obj)
{
static const char notifymsg[] =
""NOTIFY %s HTTP/1.1\r\n""
""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
""Content-Type: text/xml\r\n""
#else
""Content-Type: text/xml; charset=\""utf-8\""\r\n""
#endif
""Content-Length: %d\r\n""
""NT: upnp:event\r\n""
""NTS: upnp:propchange\r\n""
""SID: %s\r\n""
""SEQ: %u\r\n""
""Connection: close\r\n""
""Cache-Control: no-cache\r\n""
""\r\n""
""%.*s\r\n"";
char * xml;
int l;
if(obj->sub == NULL) {
obj->state = EError;
return;
}
switch(obj->sub->service) {
case EWanCFG:
xml = getVarsWANCfg(&l);
break;
case EWanIPC:
xml = getVarsWANIPCn(&l);
break;
#ifdef ENABLE_L3F_SERVICE
case EL3F:
xml = getVarsL3F(&l);
break;
#endif
#ifdef ENABLE_6FC_SERVICE
case E6FC:
xml = getVars6FC(&l);
break;
#endif
#ifdef ENABLE_DP_SERVICE
case EDP:
xml = getVarsDP(&l);
break;
#endif
default:
xml = NULL;
l = 0;
}
obj->buffersize = 1024;
obj->buffer = malloc(obj->buffersize);
if(!obj->buffer) {
syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
if(xml) {
free(xml);
}
obj->state = EError;
return;
}
obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
obj->path, obj->addrstr, obj->portstr, l+2,
obj->sub->uuid, obj->sub->seq,
l, xml);
if(xml) {
free(xml);
xml = NULL;
}
obj->state = ESending;
}","static void upnp_event_prepare(struct upnp_event_notify * VAR_0)
{
static const char VAR_1[] =
""NOTIFY %s HTTP/1.1\r\n""
""Host: %s%s\r\n""
#if (VAR_2 == 1) && (VAR_3 == 0)
""Content-Type: text/xml\r\n""
#else
""Content-Type: text/xml; charset=\""utf-8\""\r\n""
#endif
""Content-Length: %d\r\n""
""NT: upnp:event\r\n""
""NTS: upnp:propchange\r\n""
""SID: %s\r\n""
""SEQ: %u\r\n""
""Connection: close\r\n""
""Cache-Control: no-cache\r\n""
""\r\n""
""%.*s\r\n"";
char * VAR_4;
int VAR_5;
if(VAR_0->sub == NULL) {
VAR_0->state = VAR_6;
return;
}
switch(VAR_0->sub->service) {
case VAR_7:
VAR_4 = getVarsWANCfg(&VAR_5);
break;
case VAR_8:
VAR_4 = getVarsWANIPCn(&VAR_5);
break;
#ifdef VAR_9
case VAR_10:
VAR_4 = getVarsL3F(&VAR_5);
break;
#endif
#ifdef VAR_11
case VAR_12:
VAR_4 = getVars6FC(&VAR_5);
break;
#endif
#ifdef VAR_13
case VAR_14:
VAR_4 = getVarsDP(&VAR_5);
break;
#endif
default:
VAR_4 = NULL;
VAR_5 = 0;
}
VAR_0->buffersize = 1024;
VAR_0->buffer = malloc(VAR_0->buffersize);
if(!VAR_0->buffer) {
syslog(VAR_15, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
if(VAR_4) {
free(VAR_4);
}
VAR_0->state = VAR_6;
return;
}
VAR_0->tosend = snprintf(VAR_0->buffer, VAR_0->buffersize, VAR_1,
VAR_0->path, VAR_0->addrstr, VAR_0->portstr, VAR_5+2,
VAR_0->sub->uuid, VAR_0->sub->seq,
VAR_5, VAR_4);
if(VAR_4) {
free(VAR_4);
VAR_4 = NULL;
}
VAR_0->state = VAR_16;
}",miniupnp/bec6ccec63cadc95655721bc0e1dd49dac759d94/upnpevents.c/vul/before/0.json,"static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
		l = 0;
	}
	obj->buffersize = 1024;
	for (;;) {
		obj->buffer = malloc(obj->buffersize);
		if(!obj->buffer) {
			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		}
		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
		                       obj->path, obj->addrstr, obj->portstr, l+2,
		                       obj->sub->uuid, obj->sub->seq,
		                       l, xml);
		if (obj->tosend < 0) {
			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		} else if (obj->tosend < obj->buffersize) {
			break; /* the buffer was large enough */
		}
		/* Try again with a buffer big enough */
		free(obj->buffer);
		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
	}
	if(xml) {
		free(xml);
		xml = NULL;
	}
	obj->state = ESending;
}","static void upnp_event_prepare(struct upnp_event_notify * VAR_0)
{
	static const char VAR_1[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (VAR_2 == 1) && (VAR_3 == 0)
		""Content-Type: text/xml\r\n""	/* COMMENT_0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* COMMENT_1 */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * VAR_4;
	int VAR_5;
	if(VAR_0->sub == NULL) {
		VAR_0->state = VAR_6;
		return;
	}
	switch(VAR_0->sub->service) {
	case VAR_7:
		VAR_4 = getVarsWANCfg(&VAR_5);
		break;
	case VAR_8:
		VAR_4 = getVarsWANIPCn(&VAR_5);
		break;
#ifdef VAR_9
	case VAR_10:
		VAR_4 = getVarsL3F(&VAR_5);
		break;
#endif
#ifdef VAR_11
	case VAR_12:
		VAR_4 = getVars6FC(&VAR_5);
		break;
#endif
#ifdef VAR_13
	case VAR_14:
		VAR_4 = getVarsDP(&VAR_5);
		break;
#endif
	default:
		VAR_4 = NULL;
		VAR_5 = 0;
	}
	VAR_0->buffersize = 1024;
	for (;;) {
		VAR_0->buffer = malloc(VAR_0->buffersize);
		if(!VAR_0->buffer) {
			syslog(VAR_15, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(VAR_4) {
				free(VAR_4);
			}
			VAR_0->state = VAR_6;
			return;
		}
		VAR_0->tosend = snprintf(VAR_0->buffer, VAR_0->buffersize, VAR_1,
		                       VAR_0->path, VAR_0->addrstr, VAR_0->portstr, VAR_5+2,
		                       VAR_0->sub->uuid, VAR_0->sub->seq,
		                       VAR_5, VAR_4);
		if (VAR_0->tosend < 0) {
			syslog(VAR_15, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(VAR_4) {
				free(VAR_4);
			}
			VAR_0->state = VAR_6;
			return;
		} else if (VAR_0->tosend < VAR_0->buffersize) {
			break; /* COMMENT_2 */
		}
		/* COMMENT_3 */
		free(VAR_0->buffer);
		VAR_0->buffersize = VAR_0->tosend + 1;	/* COMMENT_4 */
	}
	if(VAR_4) {
		free(VAR_4);
		VAR_4 = NULL;
	}
	VAR_0->state = VAR_16;
}",miniupnp/bec6ccec63cadc95655721bc0e1dd49dac759d94/upnpevents.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,19 +50,34 @@
 		l = 0;
 	}
 	obj->buffersize = 1024;
-	obj->buffer = malloc(obj->buffersize);
-	if(!obj->buffer) {
-		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
-		if(xml) {
-			free(xml);
+	for (;;) {
+		obj->buffer = malloc(obj->buffersize);
+		if(!obj->buffer) {
+			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
+			if(xml) {
+				free(xml);
+			}
+			obj->state = EError;
+			return;
 		}
-		obj->state = EError;
-		return;
+		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
+		                       obj->path, obj->addrstr, obj->portstr, l+2,
+		                       obj->sub->uuid, obj->sub->seq,
+		                       l, xml);
+		if (obj->tosend < 0) {
+			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
+			if(xml) {
+				free(xml);
+			}
+			obj->state = EError;
+			return;
+		} else if (obj->tosend < obj->buffersize) {
+			break; /* the buffer was large enough */
+		}
+		/* Try again with a buffer big enough */
+		free(obj->buffer);
+		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
 	}
-	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
-	                       obj->path, obj->addrstr, obj->portstr, l+2,
-	                       obj->sub->uuid, obj->sub->seq,
-	                       l, xml);
 	if(xml) {
 		free(xml);
 		xml = NULL;","{'deleted_lines': ['\tobj->buffer = malloc(obj->buffersize);', '\tif(!obj->buffer) {', '\t\tsyslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");', '\t\tif(xml) {', '\t\t\tfree(xml);', '\t\tobj->state = EError;', '\t\treturn;', '\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,', '\t                       obj->path, obj->addrstr, obj->portstr, l+2,', '\t                       obj->sub->uuid, obj->sub->seq,', '\t                       l, xml);'], 'added_lines': ['\tfor (;;) {', '\t\tobj->buffer = malloc(obj->buffersize);', '\t\tif(!obj->buffer) {', '\t\t\tsyslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");', '\t\t\tif(xml) {', '\t\t\t\tfree(xml);', '\t\t\t}', '\t\t\tobj->state = EError;', '\t\t\treturn;', '\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,', '\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,', '\t\t                       obj->sub->uuid, obj->sub->seq,', '\t\t                       l, xml);', '\t\tif (obj->tosend < 0) {', '\t\t\tsyslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");', '\t\t\tif(xml) {', '\t\t\t\tfree(xml);', '\t\t\t}', '\t\t\tobj->state = EError;', '\t\t\treturn;', '\t\t} else if (obj->tosend < obj->buffersize) {', '\t\t\tbreak; /* the buffer was large enough */', '\t\t}', '\t\t/* Try again with a buffer big enough */', '\t\tfree(obj->buffer);', '\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */']}",True,The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.,7.5,HIGH,2,valid,2018-12-18T21:37:14Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Make the keyfile backend parameterless

Make it possible to instantiate a keyfile settings backend
without specifying parameters, by turning the arguments to
the new() function into construct-only properties. If no
filename is specified, default to
$XDG_CONFIG_HOME/glib-2.0/settings/keyfile",26c8b29ee12f20cf63866b87b9a3c41fab9153c5,https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_check_one,"static gboolean
g_keyfile_settings_backend_check_one (gpointer key,
gpointer value,
gpointer user_data)
{
WriteManyData *data = user_data;
return data->failed = !path_is_valid (data->kfsb, key);
}","static gboolean
g_keyfile_settings_backend_check_one (gpointer VAR_0,
gpointer VAR_1,
gpointer VAR_2)
{
WriteManyData *VAR_3 = VAR_2;
return VAR_3->failed = !path_is_valid (VAR_3->kfsb, VAR_0);
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/before/0.json,"static gboolean
g_keyfile_settings_backend_check_one (gpointer key,
                                      gpointer value,
                                      gpointer user_data)
{
  WriteManyData *data = user_data;

  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||
                        !path_is_valid (data->kfsb, key);
}","static gboolean
g_keyfile_settings_backend_check_one (gpointer VAR_0,
                                      gpointer VAR_1,
                                      gpointer VAR_2)
{
  WriteManyData *VAR_3 = VAR_2;

  return VAR_3->failed = g_hash_table_contains (VAR_3->kfsb->system_locks, VAR_0) ||
                        !path_is_valid (VAR_3->kfsb, VAR_0);
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,5 +5,6 @@
 {
   WriteManyData *data = user_data;
 
-  return data->failed = !path_is_valid (data->kfsb, key);
+  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||
+                        !path_is_valid (data->kfsb, key);
 }","{'deleted_lines': ['  return data->failed = !path_is_valid (data->kfsb, key);'], 'added_lines': ['  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||', '                        !path_is_valid (data->kfsb, key);']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-12-20T00:58:16Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Make the keyfile backend parameterless

Make it possible to instantiate a keyfile settings backend
without specifying parameters, by turning the arguments to
the new() function into construct-only properties. If no
filename is specified, default to
$XDG_CONFIG_HOME/glib-2.0/settings/keyfile",26c8b29ee12f20cf63866b87b9a3c41fab9153c5,https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_class_init,"static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)
{
GObjectClass *object_class = G_OBJECT_CLASS (class);
object_class->finalize = g_keyfile_settings_backend_finalize;
class->read = g_keyfile_settings_backend_read;
class->write = g_keyfile_settings_backend_write;
class->write_tree = g_keyfile_settings_backend_write_tree;
class->reset = g_keyfile_settings_backend_reset;
class->get_writable = g_keyfile_settings_backend_get_writable;
class->get_permission = g_keyfile_settings_backend_get_permission;
}","static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *VAR_0)
{
GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);
VAR_1->finalize = VAR_2;
VAR_0->read = VAR_3;
VAR_0->write = VAR_4;
VAR_0->write_tree = VAR_5;
VAR_0->reset = VAR_6;
VAR_0->get_writable = VAR_7;
VAR_0->get_permission = VAR_8;
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/before/2.json,"static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)
{
  GObjectClass *object_class = G_OBJECT_CLASS (class);

  object_class->finalize = g_keyfile_settings_backend_finalize;
  object_class->constructed = g_keyfile_settings_backend_constructed;
  object_class->get_property = g_keyfile_settings_backend_get_property;
  object_class->set_property = g_keyfile_settings_backend_set_property;

  class->read = g_keyfile_settings_backend_read;
  class->write = g_keyfile_settings_backend_write;
  class->write_tree = g_keyfile_settings_backend_write_tree;
  class->reset = g_keyfile_settings_backend_reset;
  class->get_writable = g_keyfile_settings_backend_get_writable;
  class->get_permission = g_keyfile_settings_backend_get_permission;
  /* No need to implement subscribed/unsubscribe: the only point would be to
   * stop monitoring the file when there's no GSettings anymore, which is no
   * big win.
   */

  /**
   * GKeyfileSettingsBackend:filename:
   *
   * The location where the settings are stored on disk.
   *
   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.
   */
  g_object_class_install_property (object_class,
                                   PROP_FILENAME,
                                   g_param_spec_string (""filename"",
                                                        P_(""Filename""),
                                                        P_(""The filename""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));

  /**
   * GKeyfileSettingsBackend:root-path:
   *
   * All settings read to or written from the backend must fall under the
   * path given in @root_path (which must start and end with a slash and
   * not contain two consecutive slashes).  @root_path may be ""/"".
   * 
   * Defaults to ""/"".
   */
  g_object_class_install_property (object_class,
                                   PROP_ROOT_PATH,
                                   g_param_spec_string (""root-path"",
                                                        P_(""Root path""),
                                                        P_(""The root path""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));

  /**
   * GKeyfileSettingsBackend:root-group:
   *
   * If @root_group is non-%NULL then it specifies the name of the keyfile
   * group used for keys that are written directly below the root path.
   *
   * Defaults to NULL.
   */
  g_object_class_install_property (object_class,
                                   PROP_ROOT_GROUP,
                                   g_param_spec_string (""root-group"",
                                                        P_(""Root group""),
                                                        P_(""The root group""),
                                                        NULL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));
}","static void
g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *VAR_0)
{
  GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);

  VAR_1->finalize = VAR_2;
  VAR_1->constructed = VAR_3;
  VAR_1->get_property = VAR_4;
  VAR_1->set_property = VAR_5;

  VAR_0->read = VAR_6;
  VAR_0->write = VAR_7;
  VAR_0->write_tree = VAR_8;
  VAR_0->reset = VAR_9;
  VAR_0->get_writable = VAR_10;
  VAR_0->get_permission = VAR_11;
  /* COMMENT_0 */
                                                                            
             
     

  /* COMMENT_4 */
                                      
    
                                                        
    
                                                              
     
  g_object_class_install_property (VAR_1,
                                   VAR_12,
                                   g_param_spec_string (""filename"",
                                                        P_(""Filename""),
                                                        P_(""The filename""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));

  /* COMMENT_10 */
                                       
    
                                                                         
                                                                        
                                                                  
     
                     
     
  g_object_class_install_property (VAR_1,
                                   VAR_16,
                                   g_param_spec_string (""root-path"",
                                                        P_(""Root path""),
                                                        P_(""The root path""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));

  /* COMMENT_19 */
                                        
    
                                                                          
                                                                       
    
                      
     
  g_object_class_install_property (VAR_1,
                                   VAR_17,
                                   g_param_spec_string (""root-group"",
                                                        P_(""Root group""),
                                                        P_(""The root group""),
                                                        NULL,
                                                        VAR_13 | VAR_14 |
                                                        VAR_15));
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,6 +4,9 @@
   GObjectClass *object_class = G_OBJECT_CLASS (class);
 
   object_class->finalize = g_keyfile_settings_backend_finalize;
+  object_class->constructed = g_keyfile_settings_backend_constructed;
+  object_class->get_property = g_keyfile_settings_backend_get_property;
+  object_class->set_property = g_keyfile_settings_backend_set_property;
 
   class->read = g_keyfile_settings_backend_read;
   class->write = g_keyfile_settings_backend_write;
@@ -15,4 +18,55 @@
    * stop monitoring the file when there's no GSettings anymore, which is no
    * big win.
    */
+
+  /**
+   * GKeyfileSettingsBackend:filename:
+   *
+   * The location where the settings are stored on disk.
+   *
+   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_FILENAME,
+                                   g_param_spec_string (""filename"",
+                                                        P_(""Filename""),
+                                                        P_(""The filename""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GKeyfileSettingsBackend:root-path:
+   *
+   * All settings read to or written from the backend must fall under the
+   * path given in @root_path (which must start and end with a slash and
+   * not contain two consecutive slashes).  @root_path may be ""/"".
+   * 
+   * Defaults to ""/"".
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_ROOT_PATH,
+                                   g_param_spec_string (""root-path"",
+                                                        P_(""Root path""),
+                                                        P_(""The root path""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GKeyfileSettingsBackend:root-group:
+   *
+   * If @root_group is non-%NULL then it specifies the name of the keyfile
+   * group used for keys that are written directly below the root path.
+   *
+   * Defaults to NULL.
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_ROOT_GROUP,
+                                   g_param_spec_string (""root-group"",
+                                                        P_(""Root group""),
+                                                        P_(""The root group""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
 }","{'deleted_lines': [], 'added_lines': ['  object_class->constructed = g_keyfile_settings_backend_constructed;', '  object_class->get_property = g_keyfile_settings_backend_get_property;', '  object_class->set_property = g_keyfile_settings_backend_set_property;', '', '  /**', '   * GKeyfileSettingsBackend:filename:', '   *', '   * The location where the settings are stored on disk.', '   *', '   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.', '   */', '  g_object_class_install_property (object_class,', '                                   PROP_FILENAME,', '                                   g_param_spec_string (""filename"",', '                                                        P_(""Filename""),', '                                                        P_(""The filename""),', '                                                        NULL,', '                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |', '                                                        G_PARAM_STATIC_STRINGS));', '', '  /**', '   * GKeyfileSettingsBackend:root-path:', '   *', '   * All settings read to or written from the backend must fall under the', '   * path given in @root_path (which must start and end with a slash and', '   * not contain two consecutive slashes).  @root_path may be ""/"".', '   * ', '   * Defaults to ""/"".', '   */', '  g_object_class_install_property (object_class,', '                                   PROP_ROOT_PATH,', '                                   g_param_spec_string (""root-path"",', '                                                        P_(""Root path""),', '                                                        P_(""The root path""),', '                                                        NULL,', '                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |', '                                                        G_PARAM_STATIC_STRINGS));', '', '  /**', '   * GKeyfileSettingsBackend:root-group:', '   *', '   * If @root_group is non-%NULL then it specifies the name of the keyfile', '   * group used for keys that are written directly below the root path.', '   *', '   * Defaults to NULL.', '   */', '  g_object_class_install_property (object_class,', '                                   PROP_ROOT_GROUP,', '                                   g_param_spec_string (""root-group"",', '                                                        P_(""Root group""),', '                                                        P_(""The root group""),', '                                                        NULL,', '                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |', '                                                        G_PARAM_STATIC_STRINGS));']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-12-20T00:58:16Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"settings: Make the keyfile backend parameterless

Make it possible to instantiate a keyfile settings backend
without specifying parameters, by turning the arguments to
the new() function into construct-only properties. If no
filename is specified, default to
$XDG_CONFIG_HOME/glib-2.0/settings/keyfile",26c8b29ee12f20cf63866b87b9a3c41fab9153c5,https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_new,"GSettingsBackend *
g_keyfile_settings_backend_new (const gchar *filename,
const gchar *root_path,
const gchar *root_group)
{
GKeyfileSettingsBackend *kfsb;
g_return_val_if_fail (filename != NULL, NULL);
g_return_val_if_fail (root_path != NULL, NULL);
g_return_val_if_fail (g_str_has_prefix (root_path, ""/""), NULL);
g_return_val_if_fail (g_str_has_suffix (root_path, ""/""), NULL);
g_return_val_if_fail (strstr (root_path, ""
kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);
kfsb->keyfile = g_key_file_new ();
kfsb->permission = g_simple_permission_new (TRUE);
kfsb->file = g_file_new_for_path (filename);
kfsb->dir = g_file_get_parent (kfsb->file);
g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);
kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);
kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);
kfsb->prefix_len = strlen (root_path);
kfsb->prefix = g_strdup (root_path);
if (root_group)
{
kfsb->root_group_len = strlen (root_group);
kfsb->root_group = g_strdup (root_group);
}
compute_checksum (kfsb->digest, NULL, 0);
g_signal_connect (kfsb->file_monitor, ""changed"",
G_CALLBACK (file_changed), kfsb);
g_signal_connect (kfsb->dir_monitor, ""changed"",
G_CALLBACK (dir_changed), kfsb);
g_keyfile_settings_backend_keyfile_writable (kfsb);
g_keyfile_settings_backend_keyfile_reload (kfsb);
return G_SETTINGS_BACKEND (kfsb);
}","GSettingsBackend *
g_keyfile_settings_backend_new (const gchar *VAR_0,
const gchar *VAR_1,
const gchar *VAR_2)
{
GKeyfileSettingsBackend *VAR_3;
g_return_val_if_fail (VAR_0 != NULL, NULL);
g_return_val_if_fail (VAR_1 != NULL, NULL);
g_return_val_if_fail (g_str_has_prefix (VAR_1, ""/""), NULL);
g_return_val_if_fail (g_str_has_suffix (VAR_1, ""/""), NULL);
g_return_val_if_fail (strstr (VAR_1, ""//"") == NULL, NULL);
VAR_3 = g_object_new (VAR_4, NULL);
VAR_3->keyfile = g_key_file_new ();
VAR_3->permission = g_simple_permission_new (TRUE);
VAR_3->file = g_file_new_for_path (VAR_0);
VAR_3->dir = g_file_get_parent (VAR_3->file);
g_file_make_directory_with_parents (VAR_3->dir, NULL, NULL);
VAR_3->file_monitor = g_file_monitor (VAR_3->file, 0, NULL, NULL);
VAR_3->dir_monitor = g_file_monitor (VAR_3->dir, 0, NULL, NULL);
VAR_3->prefix_len = strlen (VAR_1);
VAR_3->prefix = g_strdup (VAR_1);
if (VAR_2)
{
VAR_3->root_group_len = strlen (VAR_2);
VAR_3->root_group = g_strdup (VAR_2);
}
compute_checksum (VAR_3->digest, NULL, 0);
g_signal_connect (VAR_3->file_monitor, ""changed"",
G_CALLBACK (VAR_5), VAR_3);
g_signal_connect (VAR_3->dir_monitor, ""changed"",
G_CALLBACK (VAR_6), VAR_3);
g_keyfile_settings_backend_keyfile_writable (VAR_3);
g_keyfile_settings_backend_keyfile_reload (VAR_3);
return G_SETTINGS_BACKEND (VAR_3);
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/before/1.json,"GSettingsBackend *
g_keyfile_settings_backend_new (const gchar *filename,
                                const gchar *root_path,
                                const gchar *root_group)
{
  g_return_val_if_fail (filename != NULL, NULL);
  g_return_val_if_fail (root_path != NULL, NULL);
  g_return_val_if_fail (g_str_has_prefix (root_path, ""/""), NULL);
  g_return_val_if_fail (g_str_has_suffix (root_path, ""/""), NULL);
  g_return_val_if_fail (strstr (root_path, ""//"") == NULL, NULL);

  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,
                                           ""filename"", filename,
                                           ""root-path"", root_path,
                                           ""root-group"", root_group,
                                           NULL));
}","GSettingsBackend *
g_keyfile_settings_backend_new (const gchar *VAR_0,
                                const gchar *VAR_1,
                                const gchar *VAR_2)
{
  g_return_val_if_fail (VAR_0 != NULL, NULL);
  g_return_val_if_fail (VAR_1 != NULL, NULL);
  g_return_val_if_fail (g_str_has_prefix (VAR_1, ""/""), NULL);
  g_return_val_if_fail (g_str_has_suffix (VAR_1, ""/""), NULL);
  g_return_val_if_fail (strstr (VAR_1, ""//"") == NULL, NULL);

  return G_SETTINGS_BACKEND (g_object_new (VAR_3,
                                           ""filename"", VAR_0,
                                           ""root-path"", VAR_1,
                                           ""root-group"", VAR_2,
                                           NULL));
}",GNOME/glib/26c8b29ee12f20cf63866b87b9a3c41fab9153c5/gkeyfilesettingsbackend.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,43 +3,15 @@
                                 const gchar *root_path,
                                 const gchar *root_group)
 {
-  GKeyfileSettingsBackend *kfsb;
-
   g_return_val_if_fail (filename != NULL, NULL);
   g_return_val_if_fail (root_path != NULL, NULL);
   g_return_val_if_fail (g_str_has_prefix (root_path, ""/""), NULL);
   g_return_val_if_fail (g_str_has_suffix (root_path, ""/""), NULL);
   g_return_val_if_fail (strstr (root_path, ""//"") == NULL, NULL);
 
-  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);
-  kfsb->keyfile = g_key_file_new ();
-  kfsb->permission = g_simple_permission_new (TRUE);
-
-  kfsb->file = g_file_new_for_path (filename);
-  kfsb->dir = g_file_get_parent (kfsb->file);
-  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);
-
-  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);
-  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);
-
-  kfsb->prefix_len = strlen (root_path);
-  kfsb->prefix = g_strdup (root_path);
-
-  if (root_group)
-    {
-      kfsb->root_group_len = strlen (root_group);
-      kfsb->root_group = g_strdup (root_group);
-    }
-
-  compute_checksum (kfsb->digest, NULL, 0);
-
-  g_signal_connect (kfsb->file_monitor, ""changed"",
-                    G_CALLBACK (file_changed), kfsb);
-  g_signal_connect (kfsb->dir_monitor, ""changed"",
-                    G_CALLBACK (dir_changed), kfsb);
-
-  g_keyfile_settings_backend_keyfile_writable (kfsb);
-  g_keyfile_settings_backend_keyfile_reload (kfsb);
-
-  return G_SETTINGS_BACKEND (kfsb);
+  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,
+                                           ""filename"", filename,
+                                           ""root-path"", root_path,
+                                           ""root-group"", root_group,
+                                           NULL));
 }","{'deleted_lines': ['  GKeyfileSettingsBackend *kfsb;', '', '  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);', '  kfsb->keyfile = g_key_file_new ();', '  kfsb->permission = g_simple_permission_new (TRUE);', '', '  kfsb->file = g_file_new_for_path (filename);', '  kfsb->dir = g_file_get_parent (kfsb->file);', '  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);', '', '  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);', '  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);', '', '  kfsb->prefix_len = strlen (root_path);', '  kfsb->prefix = g_strdup (root_path);', '', '  if (root_group)', '    {', '      kfsb->root_group_len = strlen (root_group);', '      kfsb->root_group = g_strdup (root_group);', '    }', '', '  compute_checksum (kfsb->digest, NULL, 0);', '', '  g_signal_connect (kfsb->file_monitor, ""changed"",', '                    G_CALLBACK (file_changed), kfsb);', '  g_signal_connect (kfsb->dir_monitor, ""changed"",', '                    G_CALLBACK (dir_changed), kfsb);', '', '  g_keyfile_settings_backend_keyfile_writable (kfsb);', '  g_keyfile_settings_backend_keyfile_reload (kfsb);', '', '  return G_SETTINGS_BACKEND (kfsb);'], 'added_lines': ['  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,', '                                           ""filename"", filename,', '                                           ""root-path"", root_path,', '                                           ""root-group"", root_group,', '                                           NULL));']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2018-12-20T00:58:16Z,2
CVE-2019-9021,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #77247 (heap buffer overflow in phar_detect_phar_fname_ext),428d8164ffcf6f75a6cc9d4056e54bfd450dac03,https://github.com/php/php-src/commit/428d8164ffcf6f75a6cc9d4056e54bfd450dac03,ext/phar/phar.c,phar_detect_phar_fname_ext,"int phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) 
{
const char *pos, *slash;
*ext_str = NULL;
*ext_len = 0;
if (!filename_len || filename_len == 1) {
return FAILURE;
}
phar_request_initialize(TSRMLS_C);
pos = memchr(filename, '/', filename_len);
if (pos && pos != filename) {
switch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {
case SUCCESS:
return SUCCESS;
case FAILURE:
return FAILURE;
}
}
*ext_str = pos;
*ext_len = slash - pos;
switch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {
case SUCCESS:
return SUCCESS;
case FAILURE:
pos = strchr(pos + 1, '.');
if (pos) {
*ext_str = NULL;
*ext_len = 0;
}
goto next_extension;
}
return FAILURE;
}","int phar_detect_phar_fname_ext(const char *VAR_0, int VAR_1, const char **VAR_2, int *VAR_3, int VAR_4, int VAR_5, int VAR_6 TSRMLS_DC) 
{
const char *VAR_7, *VAR_8;
*VAR_2 = NULL;
*VAR_3 = 0;
if (!VAR_1 || VAR_1 == 1) {
return VAR_9;
}
phar_request_initialize(VAR_10);
VAR_7 = memchr(VAR_0, '/', VAR_1);
if (VAR_7 && VAR_7 != VAR_0) {
if (*(VAR_7 - 1) == ':' && (VAR_7 - VAR_0) < VAR_1 - 1 && *(VAR_7 + 1) == '/') {
*VAR_3 = -2;
*VAR_2 = NULL;
return VAR_9;
}
if (zend_hash_exists(&(VAR_11->phar_alias_map), (char *) VAR_0, VAR_7 - VAR_0)) {
*VAR_2 = VAR_7;
*VAR_3 = -1;
return VAR_9;
}
if (PHAR_G(VAR_12) && zend_hash_exists(&VAR_13, (char *) VAR_0, VAR_7 - VAR_0)) {
*VAR_2 = VAR_7;
*VAR_3 = -1;
return VAR_9;
}
}
if (zend_hash_num_elements(&(VAR_11->phar_fname_map)) || PHAR_G(VAR_12)) {
phar_archive_data **VAR_14;
if (VAR_6) {
if (VAR_15 == zend_hash_find(&(VAR_11->phar_fname_map), (char *) VAR_0, VAR_1, (void **)&VAR_14)) {
*VAR_2 = VAR_0 + (VAR_1 - (*VAR_14)->ext_len);
woohoo:
*VAR_3 = (*VAR_14)->ext_len;
if (VAR_4 == 2) {
return VAR_15;
}
if (VAR_4 == 1 && !(*VAR_14)->is_data) {
return VAR_15;
}
if (!VAR_4 && (*VAR_14)->is_data) {
return VAR_15;
}
return VAR_9;
}
if (PHAR_G(VAR_12) && VAR_15 == zend_hash_find(&VAR_16, (char *) VAR_0, VAR_1, (void **)&VAR_14)) {
*VAR_2 = VAR_0 + (VAR_1 - (*VAR_14)->ext_len);
goto woohoo;
}
} else {
char *VAR_17;
uint VAR_18;
ulong VAR_19;
for (zend_hash_internal_pointer_reset(&(VAR_11->phar_fname_map));
VAR_20 != zend_hash_get_current_key_ex(&(VAR_11->phar_fname_map), &VAR_17, &VAR_18, &VAR_19, 0, NULL);
zend_hash_move_forward(&(VAR_11->phar_fname_map))
) {
if (VAR_18 > (uint) VAR_1) {
continue;
}
if (!memcmp(VAR_0, VAR_17, VAR_18) && ((uint)VAR_1 == VAR_18
|| VAR_0[VAR_18] == '/' || VAR_0[VAR_18] == '\0')) {
if (VAR_9 == zend_hash_get_current_data(&(VAR_11->phar_fname_map), (void **) &VAR_14)) {
break;
}
*VAR_2 = VAR_0 + (VAR_18 - (*VAR_14)->ext_len);
goto woohoo;
}
}
if (PHAR_G(VAR_12)) {
for (zend_hash_internal_pointer_reset(&VAR_16);
VAR_20 != zend_hash_get_current_key_ex(&VAR_16, &VAR_17, &VAR_18, &VAR_19, 0, NULL);
zend_hash_move_forward(&VAR_16)
) {
if (VAR_18 > (uint) VAR_1) {
continue;
}
if (!memcmp(VAR_0, VAR_17, VAR_18) && ((uint)VAR_1 == VAR_18
|| VAR_0[VAR_18] == '/' || VAR_0[VAR_18] == '\0')) {
if (VAR_9 == zend_hash_get_current_data(&VAR_16, (void **) &VAR_14)) {
break;
}
*VAR_2 = VAR_0 + (VAR_18 - (*VAR_14)->ext_len);
goto woohoo;
}
}
}
}
}
VAR_7 = memchr(VAR_0 + 1, '.', VAR_1);
next_extension:
if (!VAR_7) {
return VAR_9;
}
while (VAR_7 != VAR_0 && (*(VAR_7 - 1) == '/' || *(VAR_7 - 1) == '\0')) {
VAR_7 = memchr(VAR_7 + 1, '.', VAR_1 - (VAR_7 - VAR_0) + 1);
if (!VAR_7) {
return VAR_9;
}
}
VAR_8 = memchr(VAR_7, '/', VAR_1 - (VAR_7 - VAR_0));
if (!VAR_8) {
*VAR_2 = VAR_7;
*VAR_3 = strlen(VAR_7);
switch (phar_check_str(VAR_0, *VAR_2, *VAR_3, VAR_4, VAR_5 VAR_21)) {
case VAR_15:
return VAR_15;
case VAR_9:
return VAR_9;
}
}
*VAR_2 = VAR_7;
*VAR_3 = VAR_8 - VAR_7;
switch (phar_check_str(VAR_0, *VAR_2, *VAR_3, VAR_4, VAR_5 VAR_21)) {
case VAR_15:
return VAR_15;
case VAR_9:
VAR_7 = strchr(VAR_7 + 1, '.');
if (VAR_7) {
*VAR_2 = NULL;
*VAR_3 = 0;
}
goto next_extension;
}
return VAR_9;
}",,"int phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) /* {{{ */
{
	const char *pos, *slash;

	*ext_str = NULL;
	*ext_len = 0;

	if (!filename_len || filename_len == 1) {
		return FAILURE;
	}

	phar_request_initialize(TSRMLS_C);
	/* first check for alias in first segment */
	pos = memchr(filename, '/', filename_len);

	if (pos && pos != filename) {
		/* check for url like http:// or phar:// */
		if (*(pos - 1) == ':' && (pos - filename) < filename_len - 1 && *(pos + 1) == '/') {
			*ext_len = -2;
			*ext_str = NULL;
			return FAILURE;
		}
		if (zend_hash_exists(&(PHAR_GLOBALS->phar_alias_map), (char *) filename, pos - filename)) {
			*ext_str = pos;
			*ext_len = -1;
			return FAILURE;
		}

		if (PHAR_G(manifest_cached) && zend_hash_exists(&cached_alias, (char *) filename, pos - filename)) {
			*ext_str = pos;
			*ext_len = -1;
			return FAILURE;
		}
	}

	if (zend_hash_num_elements(&(PHAR_GLOBALS->phar_fname_map)) || PHAR_G(manifest_cached)) {
		phar_archive_data **pphar;

		if (is_complete) {
			if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), (char *) filename, filename_len, (void **)&pphar)) {
				*ext_str = filename + (filename_len - (*pphar)->ext_len);
woohoo:
				*ext_len = (*pphar)->ext_len;

				if (executable == 2) {
					return SUCCESS;
				}

				if (executable == 1 && !(*pphar)->is_data) {
					return SUCCESS;
				}

				if (!executable && (*pphar)->is_data) {
					return SUCCESS;
				}

				return FAILURE;
			}

			if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, (char *) filename, filename_len, (void **)&pphar)) {
				*ext_str = filename + (filename_len - (*pphar)->ext_len);
				goto woohoo;
			}
		} else {
			char *str_key;
			uint keylen;
			ulong unused;

			for (zend_hash_internal_pointer_reset(&(PHAR_GLOBALS->phar_fname_map));
				HASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&(PHAR_GLOBALS->phar_fname_map), &str_key, &keylen, &unused, 0, NULL);
				zend_hash_move_forward(&(PHAR_GLOBALS->phar_fname_map))
			) {
				if (keylen > (uint) filename_len) {
					continue;
				}

				if (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen
					|| filename[keylen] == '/' || filename[keylen] == '\0')) {
					if (FAILURE == zend_hash_get_current_data(&(PHAR_GLOBALS->phar_fname_map), (void **) &pphar)) {
						break;
					}
					*ext_str = filename + (keylen - (*pphar)->ext_len);
					goto woohoo;
				}
			}

			if (PHAR_G(manifest_cached)) {
				for (zend_hash_internal_pointer_reset(&cached_phars);
					HASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&cached_phars, &str_key, &keylen, &unused, 0, NULL);
					zend_hash_move_forward(&cached_phars)
				) {
					if (keylen > (uint) filename_len) {
						continue;
					}

					if (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen
						|| filename[keylen] == '/' || filename[keylen] == '\0')) {
						if (FAILURE == zend_hash_get_current_data(&cached_phars, (void **) &pphar)) {
							break;
						}
						*ext_str = filename + (keylen - (*pphar)->ext_len);
						goto woohoo;
					}
				}
			}
		}
	}

	pos = memchr(filename + 1, '.', filename_len);
next_extension:
	if (!pos) {
		return FAILURE;
	}

	while (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\0')) {
		pos = memchr(pos + 1, '.', filename_len - (pos - filename) - 1);
		if (!pos) {
			return FAILURE;
		}
	}

	slash = memchr(pos, '/', filename_len - (pos - filename));

	if (!slash) {
		/* this is a url like ""phar://blah.phar"" with no directory */
		*ext_str = pos;
		*ext_len = strlen(pos);

		/* file extension must contain ""phar"" */
		switch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {
			case SUCCESS:
				return SUCCESS;
			case FAILURE:
				/* we are at the end of the string, so we fail */
				return FAILURE;
		}
	}

	/* we've found an extension that ends at a directory separator */
	*ext_str = pos;
	*ext_len = slash - pos;

	switch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {
		case SUCCESS:
			return SUCCESS;
		case FAILURE:
			/* look for more extensions */
			pos = strchr(pos + 1, '.');
			if (pos) {
				*ext_str = NULL;
				*ext_len = 0;
			}
			goto next_extension;
	}

	return FAILURE;
}","int phar_detect_phar_fname_ext(const char *VAR_0, int VAR_1, const char **VAR_2, int *VAR_3, int VAR_4, int VAR_5, int VAR_6 TSRMLS_DC) /* COMMENT_0 */
{
	const char *VAR_7, *VAR_8;

	*VAR_2 = NULL;
	*VAR_3 = 0;

	if (!VAR_1 || VAR_1 == 1) {
		return VAR_9;
	}

	phar_request_initialize(VAR_10);
	/* COMMENT_1 */
	VAR_7 = memchr(VAR_0, '/', VAR_1);

	if (VAR_7 && VAR_7 != VAR_0) {
		/* COMMENT_2 */
		if (*(VAR_7 - 1) == ':' && (VAR_7 - VAR_0) < VAR_1 - 1 && *(VAR_7 + 1) == '/') {
			*VAR_3 = -2;
			*VAR_2 = NULL;
			return VAR_9;
		}
		if (zend_hash_exists(&(VAR_11->phar_alias_map), (char *) VAR_0, VAR_7 - VAR_0)) {
			*VAR_2 = VAR_7;
			*VAR_3 = -1;
			return VAR_9;
		}

		if (PHAR_G(VAR_12) && zend_hash_exists(&VAR_13, (char *) VAR_0, VAR_7 - VAR_0)) {
			*VAR_2 = VAR_7;
			*VAR_3 = -1;
			return VAR_9;
		}
	}

	if (zend_hash_num_elements(&(VAR_11->phar_fname_map)) || PHAR_G(VAR_12)) {
		phar_archive_data **VAR_14;

		if (VAR_6) {
			if (VAR_15 == zend_hash_find(&(VAR_11->phar_fname_map), (char *) VAR_0, VAR_1, (void **)&VAR_14)) {
				*VAR_2 = VAR_0 + (VAR_1 - (*VAR_14)->ext_len);
woohoo:
				*VAR_3 = (*VAR_14)->ext_len;

				if (VAR_4 == 2) {
					return VAR_15;
				}

				if (VAR_4 == 1 && !(*VAR_14)->is_data) {
					return VAR_15;
				}

				if (!VAR_4 && (*VAR_14)->is_data) {
					return VAR_15;
				}

				return VAR_9;
			}

			if (PHAR_G(VAR_12) && VAR_15 == zend_hash_find(&VAR_16, (char *) VAR_0, VAR_1, (void **)&VAR_14)) {
				*VAR_2 = VAR_0 + (VAR_1 - (*VAR_14)->ext_len);
				goto woohoo;
			}
		} else {
			char *VAR_17;
			uint VAR_18;
			ulong VAR_19;

			for (zend_hash_internal_pointer_reset(&(VAR_11->phar_fname_map));
				VAR_20 != zend_hash_get_current_key_ex(&(VAR_11->phar_fname_map), &VAR_17, &VAR_18, &VAR_19, 0, NULL);
				zend_hash_move_forward(&(VAR_11->phar_fname_map))
			) {
				if (VAR_18 > (uint) VAR_1) {
					continue;
				}

				if (!memcmp(VAR_0, VAR_17, VAR_18) && ((uint)VAR_1 == VAR_18
					|| VAR_0[VAR_18] == '/' || VAR_0[VAR_18] == '\0')) {
					if (VAR_9 == zend_hash_get_current_data(&(VAR_11->phar_fname_map), (void **) &VAR_14)) {
						break;
					}
					*VAR_2 = VAR_0 + (VAR_18 - (*VAR_14)->ext_len);
					goto woohoo;
				}
			}

			if (PHAR_G(VAR_12)) {
				for (zend_hash_internal_pointer_reset(&VAR_16);
					VAR_20 != zend_hash_get_current_key_ex(&VAR_16, &VAR_17, &VAR_18, &VAR_19, 0, NULL);
					zend_hash_move_forward(&VAR_16)
				) {
					if (VAR_18 > (uint) VAR_1) {
						continue;
					}

					if (!memcmp(VAR_0, VAR_17, VAR_18) && ((uint)VAR_1 == VAR_18
						|| VAR_0[VAR_18] == '/' || VAR_0[VAR_18] == '\0')) {
						if (VAR_9 == zend_hash_get_current_data(&VAR_16, (void **) &VAR_14)) {
							break;
						}
						*VAR_2 = VAR_0 + (VAR_18 - (*VAR_14)->ext_len);
						goto woohoo;
					}
				}
			}
		}
	}

	VAR_7 = memchr(VAR_0 + 1, '.', VAR_1);
next_extension:
	if (!VAR_7) {
		return VAR_9;
	}

	while (VAR_7 != VAR_0 && (*(VAR_7 - 1) == '/' || *(VAR_7 - 1) == '\0')) {
		VAR_7 = memchr(VAR_7 + 1, '.', VAR_1 - (VAR_7 - VAR_0) - 1);
		if (!VAR_7) {
			return VAR_9;
		}
	}

	VAR_8 = memchr(VAR_7, '/', VAR_1 - (VAR_7 - VAR_0));

	if (!VAR_8) {
		/* COMMENT_3 */
		*VAR_2 = VAR_7;
		*VAR_3 = strlen(VAR_7);

		/* COMMENT_4 */
		switch (phar_check_str(VAR_0, *VAR_2, *VAR_3, VAR_4, VAR_5 VAR_21)) {
			case VAR_15:
				return VAR_15;
			case VAR_9:
				/* COMMENT_5 */
				return VAR_9;
		}
	}

	/* COMMENT_6 */
	*VAR_2 = VAR_7;
	*VAR_3 = VAR_8 - VAR_7;

	switch (phar_check_str(VAR_0, *VAR_2, *VAR_3, VAR_4, VAR_5 VAR_21)) {
		case VAR_15:
			return VAR_15;
		case VAR_9:
			/* COMMENT_7 */
			VAR_7 = strchr(VAR_7 + 1, '.');
			if (VAR_7) {
				*VAR_2 = NULL;
				*VAR_3 = 0;
			}
			goto next_extension;
	}

	return VAR_9;
}",,"--- func_before
+++ func_after
@@ -113,7 +113,7 @@
 	}
 
 	while (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\0')) {
-		pos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);
+		pos = memchr(pos + 1, '.', filename_len - (pos - filename) - 1);
 		if (!pos) {
 			return FAILURE;
 		}","{'deleted_lines': [""\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);""], 'added_lines': [""\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) - 1);""]}",True,"An issue was discovered in PHP before 5.6.40, 7.x before 7.1.26, 7.2.x before 7.2.14, and 7.3.x before 7.3.1. A heap-based buffer over-read in PHAR reading functions in the PHAR extension may allow an attacker to read allocated or unallocated memory past the actual data when trying to parse the file name, a different vulnerability than CVE-2018-20783. This is related to phar_detect_phar_fname_ext in ext/phar/phar.c.",9.8,CRITICAL,3,valid,2018-12-30T02:25:37Z,2
CVE-2018-20409,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,axiomatic-systems/Bento4,fix #345,7a0a4af171e44bdd7ca8e2a180d9368cb59e2998,https://github.com/axiomatic-systems/Bento4/commit/7a0a4af171e44bdd7ca8e2a180d9368cb59e2998,Source/C++/Core/Ap4AvccAtom.cpp,AP4_AvccAtom::Create,"AP4_AvccAtom* 
AP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)
{
unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;
AP4_DataBuffer payload_data(payload_size);
AP4_Result result = stream.Read(payload_data.UseData(), payload_size);
if (AP4_FAILED(result)) return NULL;
const AP4_UI08* payload = payload_data.GetData();
if (payload[0] != 1) {
return NULL;
}
if (payload_size < 6) return NULL;
unsigned int num_seq_params = payload[5]&31;
unsigned int cursor = 6;
for (unsigned int i=0; i<num_seq_params; i++) {
if (cursor+2 > payload_size) return NULL;
cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);
if (cursor > payload_size) return NULL;
}
unsigned int num_pic_params = payload[cursor++];
if (cursor > payload_size) return NULL;
for (unsigned int i=0; i<num_pic_params; i++) {
if (cursor+2 > payload_size) return NULL;
cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);
if (cursor > payload_size) return NULL;
}
return new AP4_AvccAtom(size, payload);
}","AP4_AvccAtom* 
AP4_AvccAtom::Create(AP4_Size VAR_0, AP4_ByteStream& VAR_1)
{
unsigned int VAR_2 = VAR_0-VAR_3;
AP4_DataBuffer payload_data(payload_size);
AP4_Result VAR_4 = VAR_1.Read(VAR_5.UseData(), payload_size);
if (AP4_FAILED(VAR_4)) return NULL;
const AP4_UI08* VAR_6 = VAR_5.GetData();
if (VAR_6[0] != 1) {
return NULL;
}
if (payload_size < 6) return NULL;
unsigned int VAR_7 = VAR_6[5]&31;
unsigned int VAR_8 = 6;
for (unsigned int VAR_9=0; VAR_9<VAR_7; VAR_9++) {
if (VAR_8+2 > payload_size) return NULL;
VAR_8 += 2+AP4_BytesToInt16BE(&VAR_6[VAR_8]);
if (VAR_8 > payload_size) return NULL;
}
unsigned int VAR_10 = VAR_6[VAR_8++];
if (VAR_8 > payload_size) return NULL;
for (unsigned int VAR_9=0; VAR_9<VAR_10; VAR_9++) {
if (VAR_8+2 > payload_size) return NULL;
VAR_8 += 2+AP4_BytesToInt16BE(&VAR_6[VAR_8]);
if (VAR_8 > payload_size) return NULL;
}
return new AP4_AvccAtom(VAR_0, VAR_6);
}",axiomatic-systems/Bento4/7a0a4af171e44bdd7ca8e2a180d9368cb59e2998/Ap4AvccAtom.cpp/vul/before/0.json,"AP4_AvccAtom* 
AP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)
{
    // read the raw bytes in a buffer
    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;
    AP4_DataBuffer payload_data(payload_size);
    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);
    if (AP4_FAILED(result)) return NULL;
    
    // check the version
    const AP4_UI08* payload = payload_data.GetData();
    if (payload[0] != 1) {
        return NULL;
    }

    // check the size
    if (payload_size < 6) return NULL;
    unsigned int num_seq_params = payload[5]&31;
    unsigned int cursor = 6;
    for (unsigned int i=0; i<num_seq_params; i++) {
        if (cursor+2 > payload_size) return NULL;
        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);
        if (cursor > payload_size) return NULL;
    }
    if (cursor+1 > payload_size) return NULL;
    unsigned int num_pic_params = payload[cursor++];
    for (unsigned int i=0; i<num_pic_params; i++) {
        if (cursor+2 > payload_size) return NULL;
        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);
        if (cursor > payload_size) return NULL;
    }
    return new AP4_AvccAtom(size, payload);
}","AP4_AvccAtom* 
AP4_AvccAtom::Create(AP4_Size VAR_0, AP4_ByteStream& VAR_1)
{
    /* COMMENT_0 */
    unsigned int VAR_2 = VAR_0-VAR_3;
    AP4_DataBuffer payload_data(payload_size);
    AP4_Result VAR_4 = VAR_1.Read(VAR_5.UseData(), payload_size);
    if (AP4_FAILED(VAR_4)) return NULL;
    
    /* COMMENT_1 */
    const AP4_UI08* VAR_6 = VAR_5.GetData();
    if (VAR_6[0] != 1) {
        return NULL;
    }

    /* COMMENT_2 */
    if (payload_size < 6) return NULL;
    unsigned int VAR_7 = VAR_6[5]&31;
    unsigned int VAR_8 = 6;
    for (unsigned int VAR_9=0; VAR_9<VAR_7; VAR_9++) {
        if (VAR_8+2 > payload_size) return NULL;
        VAR_8 += 2+AP4_BytesToInt16BE(&VAR_6[VAR_8]);
        if (VAR_8 > payload_size) return NULL;
    }
    if (VAR_8+1 > payload_size) return NULL;
    unsigned int VAR_10 = VAR_6[VAR_8++];
    for (unsigned int VAR_9=0; VAR_9<VAR_10; VAR_9++) {
        if (VAR_8+2 > payload_size) return NULL;
        VAR_8 += 2+AP4_BytesToInt16BE(&VAR_6[VAR_8]);
        if (VAR_8 > payload_size) return NULL;
    }
    return new AP4_AvccAtom(VAR_0, VAR_6);
}",axiomatic-systems/Bento4/7a0a4af171e44bdd7ca8e2a180d9368cb59e2998/Ap4AvccAtom.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,8 +22,8 @@
         cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);
         if (cursor > payload_size) return NULL;
     }
+    if (cursor+1 > payload_size) return NULL;
     unsigned int num_pic_params = payload[cursor++];
-    if (cursor > payload_size) return NULL;
     for (unsigned int i=0; i<num_pic_params; i++) {
         if (cursor+2 > payload_size) return NULL;
         cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);","{'deleted_lines': ['    if (cursor > payload_size) return NULL;'], 'added_lines': ['    if (cursor+1 > payload_size) return NULL;']}",True,"An issue was discovered in Bento4 1.5.1-627. There is a heap-based buffer over-read in AP4_AvccAtom::Create in Core/Ap4AvccAtom.cpp, as demonstrated by mp42hls.",6.5,MEDIUM,1,valid,2019-01-12T20:47:12Z,2
CVE-2018-20659,['CWE-770'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,axiomatic-systems/Bento4,fix #350,03f9fef0d8c5333557aa3b804c9bda838a846b88,https://github.com/axiomatic-systems/Bento4/commit/03f9fef0d8c5333557aa3b804c9bda838a846b88,Source/C++/Core/Ap4StcoAtom.cpp,AP4_StcoAtom::AP4_StcoAtom,"AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        size, 
AP4_UI08        version,
AP4_UI32        flags,
AP4_ByteStream& stream) :
AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)
{
stream.ReadUI32(m_EntryCount);
if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {
m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;
}
m_Entries = new AP4_UI32[m_EntryCount];
unsigned char* buffer = new unsigned char[m_EntryCount*4];
AP4_Result result = stream.Read(buffer, m_EntryCount*4);
if (AP4_FAILED(result)) {
delete[] buffer;
return;
}
for (AP4_Ordinal i=0; i<m_EntryCount; i++) {
m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);
}
delete[] buffer;
}","AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        VAR_0, 
AP4_UI08        VAR_1,
AP4_UI32        VAR_2,
AP4_ByteStream& VAR_3) :
AP4_Atom(VAR_4, VAR_0, VAR_1, VAR_2)
{
VAR_3.ReadUI32(VAR_5);
if (VAR_5 > (VAR_0-VAR_6-4)/4) {
VAR_5 = (VAR_0-VAR_6-4)/4;
}
VAR_7 = new AP4_UI32[VAR_5];
unsigned char* VAR_8 = new unsigned char[VAR_5*4];
AP4_Result VAR_9 = VAR_3.Read(VAR_8, VAR_5*4);
if (AP4_FAILED(VAR_9)) {
delete[] VAR_8;
return;
}
for (AP4_Ordinal VAR_10=0; VAR_10<VAR_5; VAR_10++) {
VAR_7[VAR_10] = AP4_BytesToUInt32BE(&VAR_8[VAR_10*4]);
}
delete[] VAR_8;
}",axiomatic-systems/Bento4/03f9fef0d8c5333557aa3b804c9bda838a846b88/Ap4StcoAtom.cpp/vul/before/0.json,"AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        size, 
                           AP4_UI08        version,
                           AP4_UI32        flags,
                           AP4_ByteStream& stream) :
    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),
    m_EntryCount(0)
{
    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {
        return;
    }
    stream.ReadUI32(m_EntryCount);
    if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {
        m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;
    }
    m_Entries = new AP4_UI32[m_EntryCount];
    unsigned char* buffer = new unsigned char[m_EntryCount*4];
    AP4_Result result = stream.Read(buffer, m_EntryCount*4);
    if (AP4_FAILED(result)) {
        delete[] buffer;
        return;
    }
    for (AP4_Ordinal i=0; i<m_EntryCount; i++) {
        m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);
    }
    delete[] buffer;
}","AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        VAR_0, 
                           AP4_UI08        VAR_1,
                           AP4_UI32        VAR_2,
                           AP4_ByteStream& VAR_3) :
    AP4_Atom(VAR_4, VAR_0, VAR_1, VAR_2),
    m_EntryCount(0)
{
    if (VAR_0 < VAR_5+4) {
        return;
    }
    VAR_3.ReadUI32(VAR_6);
    if (VAR_6 > (VAR_0-VAR_5-4)/4) {
        VAR_6 = (VAR_0-VAR_5-4)/4;
    }
    VAR_7 = new AP4_UI32[VAR_6];
    unsigned char* VAR_8 = new unsigned char[VAR_6*4];
    AP4_Result VAR_9 = VAR_3.Read(VAR_8, VAR_6*4);
    if (AP4_FAILED(VAR_9)) {
        delete[] VAR_8;
        return;
    }
    for (AP4_Ordinal VAR_10=0; VAR_10<VAR_6; VAR_10++) {
        VAR_7[VAR_10] = AP4_BytesToUInt32BE(&VAR_8[VAR_10*4]);
    }
    delete[] VAR_8;
}",axiomatic-systems/Bento4/03f9fef0d8c5333557aa3b804c9bda838a846b88/Ap4StcoAtom.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,12 @@
                            AP4_UI08        version,
                            AP4_UI32        flags,
                            AP4_ByteStream& stream) :
-    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)
+    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),
+    m_EntryCount(0)
 {
+    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {
+        return;
+    }
     stream.ReadUI32(m_EntryCount);
     if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {
         m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;","{'deleted_lines': ['    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)'], 'added_lines': ['    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),', '    m_EntryCount(0)', '    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {', '        return;', '    }']}",True,"An issue was discovered in Bento4 1.5.1-627. The AP4_StcoAtom class in Core/Ap4StcoAtom.cpp has an attempted excessive memory allocation when called from AP4_AtomFactory::CreateAtomFromStream in Core/Ap4AtomFactory.cpp, as demonstrated by mp42hls.",6.5,MEDIUM,1,valid,2019-01-12T21:14:40Z,2
CVE-2019-7395,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1451,8a43abefb38c5e29138e1c9c515b313363541c06,https://github.com/ImageMagick/ImageMagick/commit/8a43abefb38c5e29138e1c9c515b313363541c06,coders/psd.c,WritePSDChannel,"static size_t WritePSDChannel(const PSDInfo *psd_info,
const ImageInfo *image_info,Image *image,Image *next_image,
const QuantumType quantum_type, unsigned char *compact_pixels,
MagickOffsetType size_offset,const MagickBooleanType separate,
const CompressionType compression,ExceptionInfo *exception)
{
MagickBooleanType
monochrome;
QuantumInfo
*quantum_info;
register const Quantum
*p;
register ssize_t
i;
size_t
count,
length;
ssize_t
y;
unsigned char
*pixels;
#ifdef MAGICKCORE_ZLIB_DELEGATE
#define CHUNK 16384
int
flush,
level;
unsigned char
*compressed_pixels;
z_stream
stream;
compressed_pixels=(unsigned char *) NULL;
flush=Z_NO_FLUSH;
#endif
count=0;
if (separate != MagickFalse)
{
size_offset=TellBlob(image)+2;
count+=WriteCompressionStart(psd_info,image,next_image,compression,1);
}
if (next_image->depth > 8)
next_image->depth=16;
monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
MagickTrue : MagickFalse;
quantum_info=AcquireQuantumInfo(image_info,next_image);
if (quantum_info == (QuantumInfo *) NULL)
return(0);
pixels=(unsigned char *) GetQuantumPixels(quantum_info);
#ifdef MAGICKCORE_ZLIB_DELEGATE
if (compression == ZipCompression)
{
compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
sizeof(*compressed_pixels));
if (compressed_pixels == (unsigned char *) NULL)
{
quantum_info=DestroyQuantumInfo(quantum_info);
return(0);
}
memset(&stream,0,sizeof(stream));
stream.data_type=Z_BINARY;
level=Z_DEFAULT_COMPRESSION;
if ((image_info->quality > 0 && image_info->quality < 10))
level=(int) image_info->quality;
if (deflateInit(&stream,level) != Z_OK)
{
quantum_info=DestroyQuantumInfo(quantum_info);
return(0);
}
}
#endif
for (y=0; y < (ssize_t) next_image->rows; y++)
{
p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
quantum_type,pixels,exception);
if (monochrome != MagickFalse)
for (i=0; i < (ssize_t) length; i++)
pixels[i]=(~pixels[i]);
if (compression == RLECompression)
{
length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,
exception);
count+=WriteBlob(image,length,compact_pixels);
size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
}
#ifdef MAGICKCORE_ZLIB_DELEGATE
else if (compression == ZipCompression)
{
stream.avail_in=(uInt) length;
stream.next_in=(Bytef *) pixels;
if (y == (ssize_t) next_image->rows-1)
flush=Z_FINISH;
do {
stream.avail_out=(uInt) CHUNK;
stream.next_out=(Bytef *) compressed_pixels;
if (deflate(&stream,flush) == Z_STREAM_ERROR)
break;
length=(size_t) CHUNK-stream.avail_out;
if (length > 0)
count+=WriteBlob(image,length,compressed_pixels);
} while (stream.avail_out == 0);
}
#endif
else
count+=WriteBlob(image,length,pixels);
}
#ifdef MAGICKCORE_ZLIB_DELEGATE
if (compression == ZipCompression)
{
(void) deflateEnd(&stream);
compressed_pixels=(unsigned char *) RelinquishMagickMemory(
compressed_pixels);
}
#endif
quantum_info=DestroyQuantumInfo(quantum_info);
return(count);
}","static size_t WritePSDChannel(const PSDInfo *VAR_0,
const ImageInfo *VAR_1,Image *VAR_2,Image *VAR_3,
const QuantumType VAR_4, unsigned char *VAR_5,
MagickOffsetType VAR_6,const MagickBooleanType VAR_7,
const CompressionType VAR_8,ExceptionInfo *VAR_9)
{
MagickBooleanType
VAR_10;
QuantumInfo
*VAR_11;
register const Quantum
*VAR_12;
register ssize_t
VAR_13;
size_t
VAR_14,
VAR_15;
ssize_t
VAR_16;
unsigned char
*VAR_17;
#ifdef VAR_18
#define VAR_19 16384
int
VAR_20,
VAR_21;
unsigned char
*VAR_22;
z_stream
VAR_23;
VAR_22=(unsigned char *) NULL;
VAR_20=VAR_24;
#endif
VAR_14=0;
if (VAR_7 != VAR_25)
{
VAR_6=TellBlob(VAR_2)+2;
VAR_14+=WriteCompressionStart(VAR_0,VAR_2,VAR_3,VAR_8,1);
}
if (VAR_3->depth > 8)
VAR_3->depth=16;
VAR_10=IsImageMonochrome(VAR_2) && (VAR_2->depth == 1) ?
VAR_26 : VAR_25;
VAR_11=AcquireQuantumInfo(VAR_1,VAR_3);
if (VAR_11 == (QuantumInfo *) NULL)
return(0);
VAR_17=(unsigned char *) GetQuantumPixels(VAR_11);
#ifdef VAR_18
if (VAR_8 == VAR_27)
{
VAR_22=(unsigned char *) AcquireQuantumMemory(VAR_19,
sizeof(*VAR_22));
if (VAR_22 == (unsigned char *) NULL)
{
VAR_11=DestroyQuantumInfo(VAR_11);
return(0);
}
memset(&VAR_23,0,sizeof(VAR_23));
VAR_23.data_type=VAR_28;
VAR_21=VAR_29;
if ((VAR_1->quality > 0 && VAR_1->quality < 10))
VAR_21=(int) VAR_1->quality;
if (deflateInit(&VAR_23,VAR_21) != VAR_30)
{
VAR_11=DestroyQuantumInfo(VAR_11);
return(0);
}
}
#endif
for (VAR_16=0; VAR_16 < (ssize_t) VAR_3->rows; VAR_16++)
{
VAR_12=GetVirtualPixels(VAR_3,0,VAR_16,VAR_3->columns,1,VAR_9);
if (VAR_12 == (const Quantum *) NULL)
break;
VAR_15=ExportQuantumPixels(VAR_3,(CacheView *) NULL,VAR_11,
VAR_4,VAR_17,VAR_9);
if (VAR_10 != VAR_25)
for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
VAR_17[VAR_13]=(~VAR_17[VAR_13]);
if (VAR_8 == VAR_31)
{
VAR_15=PSDPackbitsEncodeImage(VAR_2,VAR_15,VAR_17,VAR_5,
VAR_9);
VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_5);
VAR_6+=WritePSDOffset(VAR_0,VAR_2,VAR_15,VAR_6);
}
#ifdef VAR_18
else if (compression == VAR_27)
{
VAR_23.avail_in=(uInt) VAR_15;
VAR_23.next_in=(Bytef *) VAR_17;
if (VAR_16 == (ssize_t) VAR_3->rows-1)
VAR_20=VAR_32;
do {
VAR_23.avail_out=(uInt) VAR_19;
VAR_23.next_out=(Bytef *) VAR_22;
if (deflate(&VAR_23,VAR_20) == VAR_33)
break;
VAR_15=(size_t) VAR_19-VAR_23.avail_out;
if (VAR_15 > 0)
VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_22);
} while (VAR_23.avail_out == 0);
}
#endif
else
VAR_14+=WriteBlob(image,length,pixels);
}
#ifdef VAR_18
if (compression == VAR_27)
{
(void) deflateEnd(&VAR_23);
VAR_22=(unsigned char *) RelinquishMagickMemory(
VAR_22);
}
#endif
VAR_11=DestroyQuantumInfo(VAR_11);
return(VAR_14);
}",ImageMagick/8a43abefb38c5e29138e1c9c515b313363541c06/psd.c/vul/before/0.json,"static size_t WritePSDChannel(const PSDInfo *psd_info,
  const ImageInfo *image_info,Image *image,Image *next_image,
  const QuantumType quantum_type, unsigned char *compact_pixels,
  MagickOffsetType size_offset,const MagickBooleanType separate,
  const CompressionType compression,ExceptionInfo *exception)
{
  MagickBooleanType
    monochrome;

  QuantumInfo
    *quantum_info;

  register const Quantum
    *p;

  register ssize_t
    i;

  size_t
    count,
    length;

  ssize_t
    y;

  unsigned char
    *pixels;

#ifdef MAGICKCORE_ZLIB_DELEGATE

#define CHUNK 16384

  int
    flush,
    level;

  unsigned char
    *compressed_pixels;

  z_stream
    stream;

  compressed_pixels=(unsigned char *) NULL;
  flush=Z_NO_FLUSH;
#endif
  count=0;
  if (separate != MagickFalse)
    {
      size_offset=TellBlob(image)+2;
      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);
    }
  if (next_image->depth > 8)
    next_image->depth=16;
  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
    MagickTrue : MagickFalse;
  quantum_info=AcquireQuantumInfo(image_info,next_image);
  if (quantum_info == (QuantumInfo *) NULL)
    return(0);
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (compression == ZipCompression)
    {
      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
        sizeof(*compressed_pixels));
      if (compressed_pixels == (unsigned char *) NULL)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          return(0);
        }
      memset(&stream,0,sizeof(stream));
      stream.data_type=Z_BINARY;
      level=Z_DEFAULT_COMPRESSION;
      if ((image_info->quality > 0 && image_info->quality < 10))
        level=(int) image_info->quality;
      if (deflateInit(&stream,level) != Z_OK)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          compressed_pixels=(unsigned char *) RelinquishMagickMemory(
            compressed_pixels);
          return(0);
        }
    }
#endif
  for (y=0; y < (ssize_t) next_image->rows; y++)
  {
    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (monochrome != MagickFalse)
      for (i=0; i < (ssize_t) length; i++)
        pixels[i]=(~pixels[i]);
    if (compression == RLECompression)
      {
        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,
          exception);
        count+=WriteBlob(image,length,compact_pixels);
        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
      }
#ifdef MAGICKCORE_ZLIB_DELEGATE
    else if (compression == ZipCompression)
      {
        stream.avail_in=(uInt) length;
        stream.next_in=(Bytef *) pixels;
        if (y == (ssize_t) next_image->rows-1)
          flush=Z_FINISH;
        do {
            stream.avail_out=(uInt) CHUNK;
            stream.next_out=(Bytef *) compressed_pixels;
            if (deflate(&stream,flush) == Z_STREAM_ERROR)
              break;
            length=(size_t) CHUNK-stream.avail_out;
            if (length > 0)
              count+=WriteBlob(image,length,compressed_pixels);
        } while (stream.avail_out == 0);
      }
#endif
    else
      count+=WriteBlob(image,length,pixels);
  }
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (compression == ZipCompression)
    {
      (void) deflateEnd(&stream);
      compressed_pixels=(unsigned char *) RelinquishMagickMemory(
        compressed_pixels);
    }
#endif
  quantum_info=DestroyQuantumInfo(quantum_info);
  return(count);
}","static size_t WritePSDChannel(const PSDInfo *VAR_0,
  const ImageInfo *VAR_1,Image *VAR_2,Image *VAR_3,
  const QuantumType VAR_4, unsigned char *VAR_5,
  MagickOffsetType VAR_6,const MagickBooleanType VAR_7,
  const CompressionType VAR_8,ExceptionInfo *VAR_9)
{
  MagickBooleanType
    VAR_10;

  QuantumInfo
    *VAR_11;

  register const Quantum
    *VAR_12;

  register ssize_t
    VAR_13;

  size_t
    VAR_14,
    VAR_15;

  ssize_t
    VAR_16;

  unsigned char
    *VAR_17;

#ifdef VAR_18

#define VAR_19 16384

  int
    VAR_20,
    VAR_21;

  unsigned char
    *VAR_22;

  z_stream
    VAR_23;

  VAR_22=(unsigned char *) NULL;
  VAR_20=VAR_24;
#endif
  VAR_14=0;
  if (VAR_7 != VAR_25)
    {
      VAR_6=TellBlob(VAR_2)+2;
      VAR_14+=WriteCompressionStart(VAR_0,VAR_2,VAR_3,VAR_8,1);
    }
  if (VAR_3->depth > 8)
    VAR_3->depth=16;
  VAR_10=IsImageMonochrome(VAR_2) && (VAR_2->depth == 1) ?
    VAR_26 : VAR_25;
  VAR_11=AcquireQuantumInfo(VAR_1,VAR_3);
  if (VAR_11 == (QuantumInfo *) NULL)
    return(0);
  VAR_17=(unsigned char *) GetQuantumPixels(VAR_11);
#ifdef VAR_18
  if (VAR_8 == VAR_27)
    {
      VAR_22=(unsigned char *) AcquireQuantumMemory(VAR_19,
        sizeof(*VAR_22));
      if (VAR_22 == (unsigned char *) NULL)
        {
          VAR_11=DestroyQuantumInfo(VAR_11);
          return(0);
        }
      memset(&VAR_23,0,sizeof(VAR_23));
      VAR_23.data_type=VAR_28;
      VAR_21=VAR_29;
      if ((VAR_1->quality > 0 && VAR_1->quality < 10))
        VAR_21=(int) VAR_1->quality;
      if (deflateInit(&VAR_23,VAR_21) != VAR_30)
        {
          VAR_11=DestroyQuantumInfo(VAR_11);
          VAR_22=(unsigned char *) RelinquishMagickMemory(
            VAR_22);
          return(0);
        }
    }
#endif
  for (VAR_16=0; VAR_16 < (ssize_t) VAR_3->rows; VAR_16++)
  {
    VAR_12=GetVirtualPixels(VAR_3,0,VAR_16,VAR_3->columns,1,VAR_9);
    if (VAR_12 == (const Quantum *) NULL)
      break;
    VAR_15=ExportQuantumPixels(VAR_3,(CacheView *) NULL,VAR_11,
      VAR_4,VAR_17,VAR_9);
    if (VAR_10 != VAR_25)
      for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
        VAR_17[VAR_13]=(~VAR_17[VAR_13]);
    if (VAR_8 == VAR_31)
      {
        VAR_15=PSDPackbitsEncodeImage(VAR_2,VAR_15,VAR_17,VAR_5,
          VAR_9);
        VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_5);
        VAR_6+=WritePSDOffset(VAR_0,VAR_2,VAR_15,VAR_6);
      }
#ifdef VAR_18
    else if (compression == VAR_27)
      {
        VAR_23.avail_in=(uInt) VAR_15;
        VAR_23.next_in=(Bytef *) VAR_17;
        if (VAR_16 == (ssize_t) VAR_3->rows-1)
          VAR_20=VAR_32;
        do {
            VAR_23.avail_out=(uInt) VAR_19;
            VAR_23.next_out=(Bytef *) VAR_22;
            if (deflate(&VAR_23,VAR_20) == VAR_33)
              break;
            VAR_15=(size_t) VAR_19-VAR_23.avail_out;
            if (VAR_15 > 0)
              VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_22);
        } while (VAR_23.avail_out == 0);
      }
#endif
    else
      VAR_14+=WriteBlob(image,length,pixels);
  }
#ifdef VAR_18
  if (compression == VAR_27)
    {
      (void) deflateEnd(&VAR_23);
      VAR_22=(unsigned char *) RelinquishMagickMemory(
        VAR_22);
    }
#endif
  VAR_11=DestroyQuantumInfo(VAR_11);
  return(VAR_14);
}",ImageMagick/8a43abefb38c5e29138e1c9c515b313363541c06/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,6 +75,8 @@
       if (deflateInit(&stream,level) != Z_OK)
         {
           quantum_info=DestroyQuantumInfo(quantum_info);
+          compressed_pixels=(unsigned char *) RelinquishMagickMemory(
+            compressed_pixels);
           return(0);
         }
     }","{'deleted_lines': [], 'added_lines': ['          compressed_pixels=(unsigned char *) RelinquishMagickMemory(', '            compressed_pixels);']}",True,"In ImageMagick before 7.0.8-25, a memory leak exists in WritePSDChannel in coders/psd.c.",7.5,HIGH,2,valid,2019-01-20T16:04:31Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"keyfile settings: Use tighter permissions

When creating directories, create them with 700 permissions,
instead of 777.

Closes: #1658",5e4da714f00f6bfb2ccd6d73d61329c6f3a08429,https://github.com/GNOME/glib/commit/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_keyfile_write,"static void
g_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)
{
gchar *contents;
gsize length;
contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);
g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,
G_FILE_CREATE_REPLACE_DESTINATION,
NULL, NULL, NULL);
compute_checksum (kfsb->digest, contents, length);
g_free (contents);
}","static void
g_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *VAR_0)
{
gchar *VAR_1;
gsize VAR_2;
VAR_1 = g_key_file_to_data (VAR_0->keyfile, &VAR_2, NULL);
g_file_replace_contents (VAR_0->file, VAR_1, VAR_2, NULL, FALSE,
VAR_3,
NULL, NULL, NULL);
compute_checksum (VAR_0->digest, VAR_1, VAR_2);
g_free (VAR_1);
}",GNOME/glib/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429/gkeyfilesettingsbackend.c/vul/before/0.json,"static void
g_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)
{
  gchar *contents;
  gsize length;

  contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);
  g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,
                           G_FILE_CREATE_REPLACE_DESTINATION |
                           G_FILE_CREATE_PRIVATE,
                           NULL, NULL, NULL);

  compute_checksum (kfsb->digest, contents, length);
  g_free (contents);
}","static void
g_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *VAR_0)
{
  gchar *VAR_1;
  gsize VAR_2;

  VAR_1 = g_key_file_to_data (VAR_0->keyfile, &VAR_2, NULL);
  g_file_replace_contents (VAR_0->file, VAR_1, VAR_2, NULL, FALSE,
                           VAR_3 |
                           VAR_4,
                           NULL, NULL, NULL);

  compute_checksum (VAR_0->digest, VAR_1, VAR_2);
  g_free (VAR_1);
}",GNOME/glib/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429/gkeyfilesettingsbackend.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,8 @@
 
   contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);
   g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,
-                           G_FILE_CREATE_REPLACE_DESTINATION,
+                           G_FILE_CREATE_REPLACE_DESTINATION |
+                           G_FILE_CREATE_PRIVATE,
                            NULL, NULL, NULL);
 
   compute_checksum (kfsb->digest, contents, length);","{'deleted_lines': ['                           G_FILE_CREATE_REPLACE_DESTINATION,'], 'added_lines': ['                           G_FILE_CREATE_REPLACE_DESTINATION |', '                           G_FILE_CREATE_PRIVATE,']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2019-01-22T18:26:31Z,2
CVE-2019-13012,['CWE-732'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/glib,"keyfile settings: Use tighter permissions

When creating directories, create them with 700 permissions,
instead of 777.

Closes: #1658",5e4da714f00f6bfb2ccd6d73d61329c6f3a08429,https://github.com/GNOME/glib/commit/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429,gio/gkeyfilesettingsbackend.c,g_keyfile_settings_backend_constructed,"static void
g_keyfile_settings_backend_constructed (GObject *object)
{
GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);
if (kfsb->file == NULL)
{
char *filename = g_build_filename (g_get_user_config_dir (),
""glib-2.0"", ""settings"", ""keyfile"",
NULL);
kfsb->file = g_file_new_for_path (filename);
g_free (filename);
}
if (kfsb->prefix == NULL)
{
kfsb->prefix = g_strdup (""/"");
kfsb->prefix_len = 1;
}
kfsb->keyfile = g_key_file_new ();
kfsb->permission = g_simple_permission_new (TRUE);
kfsb->dir = g_file_get_parent (kfsb->file);
g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);
kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);
kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);
compute_checksum (kfsb->digest, NULL, 0);
g_signal_connect (kfsb->file_monitor, ""changed"",
G_CALLBACK (file_changed), kfsb);
g_signal_connect (kfsb->dir_monitor, ""changed"",
G_CALLBACK (dir_changed), kfsb);
g_keyfile_settings_backend_keyfile_writable (kfsb);
g_keyfile_settings_backend_keyfile_reload (kfsb);
load_system_settings (kfsb);
}","static void
g_keyfile_settings_backend_constructed (GObject *VAR_0)
{
GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);
if (VAR_1->file == NULL)
{
char *VAR_2 = g_build_filename (g_get_user_config_dir (),
""glib-2.0"", ""settings"", ""keyfile"",
NULL);
VAR_1->file = g_file_new_for_path (VAR_2);
g_free (VAR_2);
}
if (VAR_1->prefix == NULL)
{
VAR_1->prefix = g_strdup (""/"");
VAR_1->prefix_len = 1;
}
VAR_1->keyfile = g_key_file_new ();
VAR_1->permission = g_simple_permission_new (TRUE);
VAR_1->dir = g_file_get_parent (VAR_1->file);
g_file_make_directory_with_parents (VAR_1->dir, NULL, NULL);
VAR_1->file_monitor = g_file_monitor (VAR_1->file, VAR_3, NULL, NULL);
VAR_1->dir_monitor = g_file_monitor (VAR_1->dir, VAR_3, NULL, NULL);
compute_checksum (VAR_1->digest, NULL, 0);
g_signal_connect (VAR_1->file_monitor, ""changed"",
G_CALLBACK (VAR_4), VAR_1);
g_signal_connect (VAR_1->dir_monitor, ""changed"",
G_CALLBACK (VAR_5), VAR_1);
g_keyfile_settings_backend_keyfile_writable (VAR_1);
g_keyfile_settings_backend_keyfile_reload (VAR_1);
load_system_settings (VAR_1);
}",GNOME/glib/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429/gkeyfilesettingsbackend.c/vul/before/1.json,"static void
g_keyfile_settings_backend_constructed (GObject *object)
{
  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);

  if (kfsb->file == NULL)
    {
      char *filename = g_build_filename (g_get_user_config_dir (),
                                         ""glib-2.0"", ""settings"", ""keyfile"",
                                         NULL);
      kfsb->file = g_file_new_for_path (filename);
      g_free (filename);
    }

  if (kfsb->prefix == NULL)
    {
      kfsb->prefix = g_strdup (""/"");
      kfsb->prefix_len = 1;
    }
  
  kfsb->keyfile = g_key_file_new ();
  kfsb->permission = g_simple_permission_new (TRUE);

  kfsb->dir = g_file_get_parent (kfsb->file);
  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);

  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);
  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);

  compute_checksum (kfsb->digest, NULL, 0);

  g_signal_connect (kfsb->file_monitor, ""changed"",
                    G_CALLBACK (file_changed), kfsb);
  g_signal_connect (kfsb->dir_monitor, ""changed"",
                    G_CALLBACK (dir_changed), kfsb);

  g_keyfile_settings_backend_keyfile_writable (kfsb);
  g_keyfile_settings_backend_keyfile_reload (kfsb);

  load_system_settings (kfsb);
}","static void
g_keyfile_settings_backend_constructed (GObject *VAR_0)
{
  GKeyfileSettingsBackend *VAR_1 = G_KEYFILE_SETTINGS_BACKEND (VAR_0);

  if (VAR_1->file == NULL)
    {
      char *VAR_2 = g_build_filename (g_get_user_config_dir (),
                                         ""glib-2.0"", ""settings"", ""keyfile"",
                                         NULL);
      VAR_1->file = g_file_new_for_path (VAR_2);
      g_free (VAR_2);
    }

  if (VAR_1->prefix == NULL)
    {
      VAR_1->prefix = g_strdup (""/"");
      VAR_1->prefix_len = 1;
    }
  
  VAR_1->keyfile = g_key_file_new ();
  VAR_1->permission = g_simple_permission_new (TRUE);

  VAR_1->dir = g_file_get_parent (VAR_1->file);
  g_mkdir_with_parents (g_file_peek_path (VAR_1->dir), 0700);

  VAR_1->file_monitor = g_file_monitor (VAR_1->file, VAR_3, NULL, NULL);
  VAR_1->dir_monitor = g_file_monitor (VAR_1->dir, VAR_3, NULL, NULL);

  compute_checksum (VAR_1->digest, NULL, 0);

  g_signal_connect (VAR_1->file_monitor, ""changed"",
                    G_CALLBACK (VAR_4), VAR_1);
  g_signal_connect (VAR_1->dir_monitor, ""changed"",
                    G_CALLBACK (VAR_5), VAR_1);

  g_keyfile_settings_backend_keyfile_writable (VAR_1);
  g_keyfile_settings_backend_keyfile_reload (VAR_1);

  load_system_settings (VAR_1);
}",GNOME/glib/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429/gkeyfilesettingsbackend.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,7 +22,7 @@
   kfsb->permission = g_simple_permission_new (TRUE);
 
   kfsb->dir = g_file_get_parent (kfsb->file);
-  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);
+  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);
 
   kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);
   kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);","{'deleted_lines': ['  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);'], 'added_lines': ['  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);']}",True,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",7.5,HIGH,2,valid,2019-01-22T18:26:31Z,2
CVE-2019-11339,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/mpeg4videodec: Clear interlaced_dct for studio profile

Fixes: Out of array access
Fixes: 13090/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_MPEG4_fuzzer-5408668986638336

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: Kieran Kunhya <kierank@obe.tv>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1f686d023b95219db933394a7704ad9aa5f01cbb,https://github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb,libavcodec/mpeg4videodec.c,decode_studio_vop_header,"static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
MpegEncContext *s = &ctx->m;
if (get_bits_left(gb) <= 32)
return 0;
s->partitioned_frame = 0;
s->decode_mb = mpeg4_decode_studio_mb;
decode_smpte_tc(ctx, gb);
skip_bits(gb, 10); 
skip_bits(gb, 2); 
s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; 
if (get_bits1(gb)) { 
skip_bits1(gb); 
skip_bits1(gb); 
s->progressive_frame = get_bits1(gb) ^ 1; 
}
if (s->pict_type == AV_PICTURE_TYPE_I) {
if (get_bits1(gb))
reset_studio_dc_predictors(s);
}
if (ctx->shape != BIN_ONLY_SHAPE) {
s->alternate_scan = get_bits1(gb);
s->frame_pred_frame_dct = get_bits1(gb);
s->dct_precision = get_bits(gb, 2);
s->intra_dc_precision = get_bits(gb, 2);
s->q_scale_type = get_bits1(gb);
}
if (s->alternate_scan) {
ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
} else {
ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
}
mpeg4_load_default_matrices(s);
next_start_code_studio(gb);
extension_and_user_data(s, gb, 4);
return 0;
}","static int decode_studio_vop_header(Mpeg4DecContext *VAR_0, GetBitContext *VAR_1)
{
MpegEncContext *VAR_2 = &VAR_0->m;
if (get_bits_left(VAR_1) <= 32)
return 0;
VAR_2->partitioned_frame = 0;
VAR_2->decode_mb = VAR_3;
decode_smpte_tc(VAR_0, VAR_1);
skip_bits(VAR_1, 10); 
skip_bits(VAR_1, 2); 
VAR_2->pict_type = get_bits(VAR_1, 2) + VAR_4; 
if (get_bits1(VAR_1)) { 
skip_bits1(VAR_1); 
skip_bits1(VAR_1); 
VAR_2->progressive_frame = get_bits1(VAR_1) ^ 1; 
}
if (VAR_2->pict_type == VAR_4) {
if (get_bits1(VAR_1))
reset_studio_dc_predictors(VAR_2);
}
if (VAR_0->shape != VAR_5) {
VAR_2->alternate_scan = get_bits1(VAR_1);
VAR_2->frame_pred_frame_dct = get_bits1(VAR_1);
VAR_2->dct_precision = get_bits(VAR_1, 2);
VAR_2->intra_dc_precision = get_bits(VAR_1, 2);
VAR_2->q_scale_type = get_bits1(VAR_1);
}
if (VAR_2->alternate_scan) {
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->inter_scantable,   VAR_6);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_scantable,   VAR_6);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_h_scantable, VAR_6);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_v_scantable, VAR_6);
} else {
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->inter_scantable,   VAR_7);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_scantable,   VAR_7);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_h_scantable, VAR_8);
ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_v_scantable, VAR_6);
}
mpeg4_load_default_matrices(VAR_2);
next_start_code_studio(VAR_1);
extension_and_user_data(VAR_2, VAR_1, 4);
return 0;
}",ffmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb/mpeg4videodec.c/vul/before/0.json,"static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;

    if (get_bits_left(gb) <= 32)
        return 0;

    s->partitioned_frame = 0;
    s->interlaced_dct = 0;
    s->decode_mb = mpeg4_decode_studio_mb;

    decode_smpte_tc(ctx, gb);

    skip_bits(gb, 10); /* temporal_reference */
    skip_bits(gb, 2); /* vop_structure */
    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */
    if (get_bits1(gb)) { /* vop_coded */
        skip_bits1(gb); /* top_field_first */
        skip_bits1(gb); /* repeat_first_field */
        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */
    }

    if (s->pict_type == AV_PICTURE_TYPE_I) {
        if (get_bits1(gb))
            reset_studio_dc_predictors(s);
    }

    if (ctx->shape != BIN_ONLY_SHAPE) {
        s->alternate_scan = get_bits1(gb);
        s->frame_pred_frame_dct = get_bits1(gb);
        s->dct_precision = get_bits(gb, 2);
        s->intra_dc_precision = get_bits(gb, 2);
        s->q_scale_type = get_bits1(gb);
    }

    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
    }

    mpeg4_load_default_matrices(s);

    next_start_code_studio(gb);
    extension_and_user_data(s, gb, 4);

    return 0;
}","static int decode_studio_vop_header(Mpeg4DecContext *VAR_0, GetBitContext *VAR_1)
{
    MpegEncContext *VAR_2 = &VAR_0->m;

    if (get_bits_left(VAR_1) <= 32)
        return 0;

    VAR_2->partitioned_frame = 0;
    VAR_2->interlaced_dct = 0;
    VAR_2->decode_mb = VAR_3;

    decode_smpte_tc(VAR_0, VAR_1);

    skip_bits(VAR_1, 10); /* COMMENT_0 */
    skip_bits(VAR_1, 2); /* COMMENT_1 */
    VAR_2->pict_type = get_bits(VAR_1, 2) + VAR_4; /* COMMENT_2 */
    if (get_bits1(VAR_1)) { /* COMMENT_3 */
        skip_bits1(VAR_1); /* COMMENT_4 */
        skip_bits1(VAR_1); /* COMMENT_5 */
        VAR_2->progressive_frame = get_bits1(VAR_1) ^ 1; /* COMMENT_6 */
    }

    if (VAR_2->pict_type == VAR_4) {
        if (get_bits1(VAR_1))
            reset_studio_dc_predictors(VAR_2);
    }

    if (VAR_0->shape != VAR_5) {
        VAR_2->alternate_scan = get_bits1(VAR_1);
        VAR_2->frame_pred_frame_dct = get_bits1(VAR_1);
        VAR_2->dct_precision = get_bits(VAR_1, 2);
        VAR_2->intra_dc_precision = get_bits(VAR_1, 2);
        VAR_2->q_scale_type = get_bits1(VAR_1);
    }

    if (VAR_2->alternate_scan) {
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->inter_scantable,   VAR_6);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_scantable,   VAR_6);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_h_scantable, VAR_6);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_v_scantable, VAR_6);
    } else {
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->inter_scantable,   VAR_7);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_scantable,   VAR_7);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_h_scantable, VAR_8);
        ff_init_scantable(VAR_2->idsp.idct_permutation, &VAR_2->intra_v_scantable, VAR_6);
    }

    mpeg4_load_default_matrices(VAR_2);

    next_start_code_studio(VAR_1);
    extension_and_user_data(VAR_2, VAR_1, 4);

    return 0;
}",ffmpeg/1f686d023b95219db933394a7704ad9aa5f01cbb/mpeg4videodec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
         return 0;
 
     s->partitioned_frame = 0;
+    s->interlaced_dct = 0;
     s->decode_mb = mpeg4_decode_studio_mb;
 
     decode_smpte_tc(ctx, gb);","{'deleted_lines': [], 'added_lines': ['    s->interlaced_dct = 0;']}",True,The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,8.8,HIGH,2,valid,2019-02-15T00:57:09Z,2
CVE-2019-11810,"['CWE-476', 'CWE-416']",AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"scsi: megaraid_sas: return error when create DMA pool failed

when create DMA pool for cmd frames failed, we should return -ENOMEM,
instead of 0.
In some case in:

    megasas_init_adapter_fusion()

    -->megasas_alloc_cmds()
       -->megasas_create_frame_pool
          create DMA pool failed,
        --> megasas_free_cmds() [1]

    -->megasas_alloc_cmds_fusion()
       failed, then goto fail_alloc_cmds.
    -->megasas_free_cmds() [2]

we will call megasas_free_cmds twice, [1] will kfree cmd_list,
[2] will use cmd_list.it will cause a problem:

Unable to handle kernel NULL pointer dereference at virtual address
00000000
pgd = ffffffc000f70000
[00000000] *pgd=0000001fbf893003, *pud=0000001fbf893003,
*pmd=0000001fbf894003, *pte=006000006d000707
Internal error: Oops: 96000005 [#1] SMP
 Modules linked in:
 CPU: 18 PID: 1 Comm: swapper/0 Not tainted
 task: ffffffdfb9290000 ti: ffffffdfb923c000 task.ti: ffffffdfb923c000
 PC is at megasas_free_cmds+0x30/0x70
 LR is at megasas_free_cmds+0x24/0x70
 ...
 Call trace:
 [<ffffffc0005b779c>] megasas_free_cmds+0x30/0x70
 [<ffffffc0005bca74>] megasas_init_adapter_fusion+0x2f4/0x4d8
 [<ffffffc0005b926c>] megasas_init_fw+0x2dc/0x760
 [<ffffffc0005b9ab0>] megasas_probe_one+0x3c0/0xcd8
 [<ffffffc0004a5abc>] local_pci_probe+0x4c/0xb4
 [<ffffffc0004a5c40>] pci_device_probe+0x11c/0x14c
 [<ffffffc00053a5e4>] driver_probe_device+0x1ec/0x430
 [<ffffffc00053a92c>] __driver_attach+0xa8/0xb0
 [<ffffffc000538178>] bus_for_each_dev+0x74/0xc8
  [<ffffffc000539e88>] driver_attach+0x28/0x34
 [<ffffffc000539a18>] bus_add_driver+0x16c/0x248
 [<ffffffc00053b234>] driver_register+0x6c/0x138
 [<ffffffc0004a5350>] __pci_register_driver+0x5c/0x6c
 [<ffffffc000ce3868>] megasas_init+0xc0/0x1a8
 [<ffffffc000082a58>] do_one_initcall+0xe8/0x1ec
 [<ffffffc000ca7be8>] kernel_init_freeable+0x1c8/0x284
 [<ffffffc0008d90b8>] kernel_init+0x1c/0xe4

Signed-off-by: Jason Yan <yanaijie@huawei.com>
Acked-by: Sumit Saxena <sumit.saxena@broadcom.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",bcf3b67d16a4c8ffae0aa79de5853435e683945c,https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c,drivers/scsi/megaraid/megaraid_sas_base.c,megasas_alloc_cmds,"int megasas_alloc_cmds(struct megasas_instance *instance)
{
int i;
int j;
u16 max_cmd;
struct megasas_cmd *cmd;
max_cmd = instance->max_mfi_cmds;
instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);
if (!instance->cmd_list) {
dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n"");
return -ENOMEM;
}
memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);
for (i = 0; i < max_cmd; i++) {
instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),
GFP_KERNEL);
if (!instance->cmd_list[i]) {
for (j = 0; j < i; j++)
kfree(instance->cmd_list[j]);
kfree(instance->cmd_list);
instance->cmd_list = NULL;
return -ENOMEM;
}
}
for (i = 0; i < max_cmd; i++) {
cmd = instance->cmd_list[i];
memset(cmd, 0, sizeof(struct megasas_cmd));
cmd->index = i;
cmd->scmd = NULL;
cmd->instance = instance;
list_add_tail(&cmd->list, &instance->cmd_pool);
}
if (megasas_create_frame_pool(instance)) {
dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
megasas_free_cmds(instance);
}
return 0;
}","int megasas_alloc_cmds(struct megasas_instance *VAR_0)
{
int VAR_1;
int VAR_2;
u16 VAR_3;
struct megasas_cmd *VAR_4;
VAR_3 = VAR_0->max_mfi_cmds;
VAR_0->cmd_list = kcalloc(VAR_3, sizeof(struct megasas_cmd*), VAR_5);
if (!VAR_0->cmd_list) {
dev_printk(VAR_6, &VAR_0->pdev->dev, ""out of memory\n"");
return -VAR_7;
}
memset(VAR_0->cmd_list, 0, sizeof(struct megasas_cmd *) *VAR_3);
for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
VAR_0->cmd_list[VAR_1] = kmalloc(sizeof(struct megasas_cmd),
VAR_5);
if (!VAR_0->cmd_list[VAR_1]) {
for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++)
kfree(VAR_0->cmd_list[VAR_2]);
kfree(VAR_0->cmd_list);
VAR_0->cmd_list = NULL;
return -VAR_7;
}
}
for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
VAR_4 = VAR_0->cmd_list[VAR_1];
memset(VAR_4, 0, sizeof(struct megasas_cmd));
VAR_4->index = VAR_1;
VAR_4->scmd = NULL;
VAR_4->instance = VAR_0;
list_add_tail(&VAR_4->list, &VAR_0->cmd_pool);
}
if (megasas_create_frame_pool(VAR_0)) {
dev_printk(VAR_6, &VAR_0->pdev->dev, ""Error creating frame DMA pool\n"");
megasas_free_cmds(VAR_0);
}
return 0;
}",torvalds/linux/bcf3b67d16a4c8ffae0aa79de5853435e683945c/megaraid_sas_base.c/vul/before/0.json,"int megasas_alloc_cmds(struct megasas_instance *instance)
{
	int i;
	int j;
	u16 max_cmd;
	struct megasas_cmd *cmd;

	max_cmd = instance->max_mfi_cmds;

	/*
	 * instance->cmd_list is an array of struct megasas_cmd pointers.
	 * Allocate the dynamic array first and then allocate individual
	 * commands.
	 */
	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);

	if (!instance->cmd_list) {
		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n"");
		return -ENOMEM;
	}

	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);

	for (i = 0; i < max_cmd; i++) {
		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),
						GFP_KERNEL);

		if (!instance->cmd_list[i]) {

			for (j = 0; j < i; j++)
				kfree(instance->cmd_list[j]);

			kfree(instance->cmd_list);
			instance->cmd_list = NULL;

			return -ENOMEM;
		}
	}

	for (i = 0; i < max_cmd; i++) {
		cmd = instance->cmd_list[i];
		memset(cmd, 0, sizeof(struct megasas_cmd));
		cmd->index = i;
		cmd->scmd = NULL;
		cmd->instance = instance;

		list_add_tail(&cmd->list, &instance->cmd_pool);
	}

	/*
	 * Create a frame pool and assign one frame to each cmd
	 */
	if (megasas_create_frame_pool(instance)) {
		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
		megasas_free_cmds(instance);
		return -ENOMEM;
	}

	return 0;
}","int megasas_alloc_cmds(struct megasas_instance *VAR_0)
{
	int VAR_1;
	int VAR_2;
	u16 VAR_3;
	struct megasas_cmd *VAR_4;

	VAR_3 = VAR_0->max_mfi_cmds;

	/* COMMENT_0 */
                                                                  
                                                                 
             
    
	VAR_0->cmd_list = kcalloc(VAR_3, sizeof(struct megasas_cmd*), VAR_5);

	if (!VAR_0->cmd_list) {
		dev_printk(VAR_6, &VAR_0->pdev->dev, ""out of memory\n"");
		return -VAR_7;
	}

	memset(VAR_0->cmd_list, 0, sizeof(struct megasas_cmd *) *VAR_3);

	for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
		VAR_0->cmd_list[VAR_1] = kmalloc(sizeof(struct megasas_cmd),
						VAR_5);

		if (!VAR_0->cmd_list[VAR_1]) {

			for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++)
				kfree(VAR_0->cmd_list[VAR_2]);

			kfree(VAR_0->cmd_list);
			VAR_0->cmd_list = NULL;

			return -VAR_7;
		}
	}

	for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
		VAR_4 = VAR_0->cmd_list[VAR_1];
		memset(VAR_4, 0, sizeof(struct megasas_cmd));
		VAR_4->index = VAR_1;
		VAR_4->scmd = NULL;
		VAR_4->instance = VAR_0;

		list_add_tail(&VAR_4->list, &VAR_0->cmd_pool);
	}

	/* COMMENT_5 */
                                                        
    
	if (megasas_create_frame_pool(VAR_0)) {
		dev_printk(VAR_6, &VAR_0->pdev->dev, ""Error creating frame DMA pool\n"");
		megasas_free_cmds(VAR_0);
		return -VAR_7;
	}

	return 0;
}",torvalds/linux/bcf3b67d16a4c8ffae0aa79de5853435e683945c/megaraid_sas_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,6 +53,7 @@
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
+		return -ENOMEM;
 	}
 
 	return 0;","{'deleted_lines': [], 'added_lines': ['\t\treturn -ENOMEM;']}",True,"An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free.",7.5,HIGH,2,valid,2019-02-15T11:50:27Z,2
CVE-2019-9214,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"rpcap: check conversation existence before dereferencing it.

Conflicts:
	epan/dissectors/packet-rpcap.c

Bug: 15536
Change-Id: I370b7f4b3f647243490cbfadc120f0198c62b09b
Reviewed-on: https://code.wireshark.org/review/32232
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 2f048c932d0c063bd53651d0fd8f31a66eede741)
Reviewed-on: https://code.wireshark.org/review/32236
Reviewed-by: Gerald Combs <gerald@wireshark.org>",c557bb0910be271e49563756411a690a1bc53ce5,https://github.com/wireshark/wireshark/commit/c557bb0910be271e49563756411a690a1bc53ce5,epan/dissectors/packet-rpcap.c,dissect_rpcap_heur_tcp,"static gboolean
dissect_rpcap_heur_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
if (check_rpcap_heur (tvb, TRUE)) {
conversation_t *conversation = find_or_create_conversation (pinfo);
conversation_set_dissector_from_frame_number (conversation,
pinfo->num,
rpcap_tcp_handle);
tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,
get_rpcap_pdu_len, dissect_rpcap, data);
return TRUE;
}
return FALSE;
}","static gboolean
dissect_rpcap_heur_tcp (tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
if (check_rpcap_heur (VAR_0, TRUE)) {
conversation_t *VAR_4 = find_or_create_conversation (VAR_1);
conversation_set_dissector_from_frame_number (VAR_4,
VAR_1->num,
VAR_5);
tcp_dissect_pdus (VAR_0, VAR_1, VAR_2, VAR_6, 8,
VAR_7, VAR_8, VAR_3);
return TRUE;
}
return FALSE;
}",wireshark/c557bb0910be271e49563756411a690a1bc53ce5/packet-rpcap.c/vul/before/0.json,"static gboolean
dissect_rpcap_heur_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
  if (check_rpcap_heur (tvb, TRUE)) {
    /*
     * This is probably a rpcap TCP packet.
     * Make the dissector for this conversation the non-heuristic
     * rpcap dissector, so that malformed rpcap packets are reported
     * as such.
     */
    conversation_t *conversation = find_or_create_conversation (pinfo);
    if (conversation)
      conversation_set_dissector_from_frame_number (conversation,
                                                  pinfo->num,
                                                  rpcap_tcp_handle);
    tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,
                      get_rpcap_pdu_len, dissect_rpcap, data);

    return TRUE;
  }

  return FALSE;
}","static gboolean
dissect_rpcap_heur_tcp (tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
  if (check_rpcap_heur (VAR_0, TRUE)) {
    /* COMMENT_0 */
                                           
                                                                 
                                                                    
               
       
    conversation_t *VAR_4 = find_or_create_conversation (VAR_1);
    if (VAR_4)
      conversation_set_dissector_from_frame_number (VAR_4,
                                                  VAR_1->num,
                                                  VAR_5);
    tcp_dissect_pdus (VAR_0, VAR_1, VAR_2, VAR_6, 8,
                      VAR_7, VAR_8, VAR_3);

    return TRUE;
  }

  return FALSE;
}",wireshark/c557bb0910be271e49563756411a690a1bc53ce5/packet-rpcap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,8 @@
      * as such.
      */
     conversation_t *conversation = find_or_create_conversation (pinfo);
-    conversation_set_dissector_from_frame_number (conversation,
+    if (conversation)
+      conversation_set_dissector_from_frame_number (conversation,
                                                   pinfo->num,
                                                   rpcap_tcp_handle);
     tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,","{'deleted_lines': ['    conversation_set_dissector_from_frame_number (conversation,'], 'added_lines': ['    if (conversation)', '      conversation_set_dissector_from_frame_number (conversation,']}",True,"In Wireshark 2.4.0 to 2.4.12 and 2.6.0 to 2.6.6, the RPCAP dissector could crash. This was addressed in epan/dissectors/packet-rpcap.c by avoiding an attempted dereference of a NULL conversation.",7.5,HIGH,2,valid,2019-02-27T14:02:01Z,2
CVE-2019-17341,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"IOMMU/x86: fix type ref-counting race upon IOMMU page table construction

When arch_iommu_populate_page_table() gets invoked for an already
running guest, simply looking at page types once isn't enough, as they
may change at any time. Add logic to re-check the type after having
mapped the page, unmapping it again if needed.

This is XSA-285.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Tentatively-Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>",1f0b0bb7773d537bcf169e021495d0986d9809fc,https://github.com/xen-project/xen/commit/1f0b0bb7773d537bcf169e021495d0986d9809fc,xen/drivers/passthrough/x86/iommu.c,arch_iommu_populate_page_table,"int arch_iommu_populate_page_table(struct domain *d)
{
struct page_info *page;
int rc = 0, n = 0;
spin_lock(&d->page_alloc_lock);
if ( unlikely(d->is_dying) )
rc = -ESRCH;
while ( !rc && (page = page_list_remove_head(&d->page_list)) )
{
if ( is_hvm_domain(d) ||
(page->u.inuse.type_info & PGT_type_mask) == PGT_writable_page )
{
unsigned long mfn = mfn_x(page_to_mfn(page));
unsigned long gfn = mfn_to_gmfn(d, mfn);
unsigned int flush_flags = 0;
if ( gfn != gfn_x(INVALID_GFN) )
{
ASSERT(!(gfn >> DEFAULT_DOMAIN_ADDRESS_WIDTH));
BUG_ON(SHARED_M2P(gfn));
rc = iommu_map(d, _dfn(gfn), _mfn(mfn), PAGE_ORDER_4K,
IOMMUF_readable | IOMMUF_writable,
&flush_flags);
}
if ( rc )
{
page_list_add(page, &d->page_list);
break;
}
}
page_list_add_tail(page, &d->arch.relmem_list);
if ( !(++n & 0xff) && !page_list_empty(&d->page_list) &&
hypercall_preempt_check() )
rc = -ERESTART;
}
if ( !rc )
{
page_list_move(&d->page_list, &d->arch.relmem_list);
while ( !page_list_empty(&d->page_list) &&
(page = page_list_first(&d->page_list),
(page->count_info & (PGC_state|PGC_broken))) )
{
page_list_del(page, &d->page_list);
page_list_add_tail(page, &d->arch.relmem_list);
}
}
spin_unlock(&d->page_alloc_lock);
if ( !rc )
rc = iommu_iotlb_flush_all(
d, IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified);
if ( rc && rc != -ERESTART )
iommu_teardown(d);
return rc;
}","int arch_iommu_populate_page_table(struct domain *VAR_0)
{
struct page_info *VAR_1;
int VAR_2 = 0, VAR_3 = 0;
spin_lock(&VAR_0->page_alloc_lock);
if ( unlikely(VAR_0->is_dying) )
VAR_2 = -VAR_4;
while ( !VAR_2 && (VAR_1 = page_list_remove_head(&VAR_0->page_list)) )
{
if ( is_hvm_domain(VAR_0) ||
(VAR_1->u.inuse.type_info & VAR_5) == VAR_6 )
{
unsigned long VAR_7 = mfn_x(page_to_mfn(VAR_1));
unsigned long VAR_8 = mfn_to_gmfn(VAR_0, VAR_7);
unsigned int VAR_9 = 0;
if ( VAR_8 != gfn_x(VAR_10) )
{
ASSERT(!(VAR_8 >> VAR_11));
BUG_ON(SHARED_M2P(VAR_8));
VAR_2 = iommu_map(VAR_0, _dfn(VAR_8), _mfn(VAR_7), VAR_12,
VAR_13 | VAR_14,
&VAR_9);
}
if ( VAR_2 )
{
page_list_add(VAR_1, &VAR_0->page_list);
break;
}
}
page_list_add_tail(VAR_1, &VAR_0->arch.relmem_list);
if ( !(++VAR_3 & 0xff) && !page_list_empty(&VAR_0->page_list) &&
hypercall_preempt_check() )
VAR_2 = -VAR_15;
}
if ( !VAR_2 )
{
page_list_move(&VAR_0->page_list, &VAR_0->arch.relmem_list);
while ( !page_list_empty(&VAR_0->page_list) &&
(VAR_1 = page_list_first(&VAR_0->page_list),
(VAR_1->count_info & (VAR_16|VAR_17))) )
{
page_list_del(VAR_1, &VAR_0->page_list);
page_list_add_tail(VAR_1, &VAR_0->arch.relmem_list);
}
}
spin_unlock(&VAR_0->page_alloc_lock);
if ( !VAR_2 )
VAR_2 = iommu_iotlb_flush_all(
VAR_0, VAR_18 | VAR_19);
if ( VAR_2 && VAR_2 != -VAR_15 )
iommu_teardown(VAR_0);
return VAR_2;
}",xen-project/xen/1f0b0bb7773d537bcf169e021495d0986d9809fc/iommu.c/vul/before/0.json,"int arch_iommu_populate_page_table(struct domain *d)
{
    struct page_info *page;
    int rc = 0, n = 0;

    spin_lock(&d->page_alloc_lock);

    if ( unlikely(d->is_dying) )
        rc = -ESRCH;

    while ( !rc && (page = page_list_remove_head(&d->page_list)) )
    {
        if ( is_hvm_domain(d) ||
            (page->u.inuse.type_info & PGT_type_mask) == PGT_writable_page )
        {
            unsigned long mfn = mfn_x(page_to_mfn(page));
            unsigned long gfn = mfn_to_gmfn(d, mfn);
            unsigned int flush_flags = 0;

            if ( gfn != gfn_x(INVALID_GFN) )
            {
                ASSERT(!(gfn >> DEFAULT_DOMAIN_ADDRESS_WIDTH));
                BUG_ON(SHARED_M2P(gfn));
                rc = iommu_map(d, _dfn(gfn), _mfn(mfn), PAGE_ORDER_4K,
                               IOMMUF_readable | IOMMUF_writable,
                               &flush_flags);

                /*
                 * We may be working behind the back of a running guest, which
                 * may change the type of a page at any time.  We can't prevent
                 * this (for instance, by bumping the type count while mapping
                 * the page) without causing legitimate guest type-change
                 * operations to fail.  So after adding the page to the IOMMU,
                 * check again to make sure this is still valid.  NB that the
                 * writable entry in the iommu is harmless until later, when
                 * the actual device gets assigned.
                 */
                if ( !rc && !is_hvm_domain(d) &&
                     ((page->u.inuse.type_info & PGT_type_mask) !=
                      PGT_writable_page) )
                {
                    rc = iommu_unmap(d, _dfn(gfn), PAGE_ORDER_4K, &flush_flags);
                    /* If the type changed yet again, simply force a retry. */
                    if ( !rc && ((page->u.inuse.type_info & PGT_type_mask) ==
                                 PGT_writable_page) )
                        rc = -ERESTART;
                }
            }
            if ( rc )
            {
                page_list_add(page, &d->page_list);
                break;
            }
        }
        page_list_add_tail(page, &d->arch.relmem_list);
        if ( !(++n & 0xff) && !page_list_empty(&d->page_list) &&
             hypercall_preempt_check() )
            rc = -ERESTART;
    }

    if ( !rc )
    {
        /*
         * The expectation here is that generally there are many normal pages
         * on relmem_list (the ones we put there) and only few being in an
         * offline/broken state. The latter ones are always at the head of the
         * list. Hence we first move the whole list, and then move back the
         * first few entries.
         */
        page_list_move(&d->page_list, &d->arch.relmem_list);
        while ( !page_list_empty(&d->page_list) &&
                (page = page_list_first(&d->page_list),
                 (page->count_info & (PGC_state|PGC_broken))) )
        {
            page_list_del(page, &d->page_list);
            page_list_add_tail(page, &d->arch.relmem_list);
        }
    }

    spin_unlock(&d->page_alloc_lock);

    if ( !rc )
        /*
         * flush_flags are not tracked across hypercall pre-emption so
         * assume a full flush is necessary.
         */
        rc = iommu_iotlb_flush_all(
            d, IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified);

    if ( rc && rc != -ERESTART )
        iommu_teardown(d);

    return rc;
}","int arch_iommu_populate_page_table(struct domain *VAR_0)
{
    struct page_info *VAR_1;
    int VAR_2 = 0, VAR_3 = 0;

    spin_lock(&VAR_0->page_alloc_lock);

    if ( unlikely(VAR_0->is_dying) )
        VAR_2 = -VAR_4;

    while ( !VAR_2 && (VAR_1 = page_list_remove_head(&VAR_0->page_list)) )
    {
        if ( is_hvm_domain(VAR_0) ||
            (VAR_1->u.inuse.type_info & VAR_5) == VAR_6 )
        {
            unsigned long VAR_7 = mfn_x(page_to_mfn(VAR_1));
            unsigned long VAR_8 = mfn_to_gmfn(VAR_0, VAR_7);
            unsigned int VAR_9 = 0;

            if ( VAR_8 != gfn_x(VAR_10) )
            {
                ASSERT(!(VAR_8 >> VAR_11));
                BUG_ON(SHARED_M2P(VAR_8));
                VAR_2 = iommu_map(VAR_0, _dfn(VAR_8), _mfn(VAR_7), VAR_12,
                               VAR_13 | VAR_14,
                               &VAR_9);

                /* COMMENT_0 */
                                                                              
                                                                               
                                                                              
                                                                         
                                                                              
                                                                             
                                                                            
                                                   
                   
                if ( !VAR_2 && !is_hvm_domain(VAR_0) &&
                     ((VAR_1->u.inuse.type_info & VAR_5) !=
                      VAR_6) )
                {
                    VAR_2 = iommu_unmap(VAR_0, _dfn(VAR_8), VAR_12, &VAR_9);
                    /* COMMENT_10 */
                    if ( !VAR_2 && ((VAR_1->u.inuse.type_info & VAR_5) ==
                                 VAR_6) )
                        VAR_2 = -VAR_15;
                }
            }
            if ( VAR_2 )
            {
                page_list_add(VAR_1, &VAR_0->page_list);
                break;
            }
        }
        page_list_add_tail(VAR_1, &VAR_0->arch.relmem_list);
        if ( !(++VAR_3 & 0xff) && !page_list_empty(&VAR_0->page_list) &&
             hypercall_preempt_check() )
            VAR_2 = -VAR_15;
    }

    if ( !VAR_2 )
    {
        /* COMMENT_11 */
                                                                             
                                                                          
                                                                              
                                                                           
                             
           
        page_list_move(&VAR_0->page_list, &VAR_0->arch.relmem_list);
        while ( !page_list_empty(&VAR_0->page_list) &&
                (VAR_1 = page_list_first(&VAR_0->page_list),
                 (VAR_1->count_info & (VAR_16|VAR_17))) )
        {
            page_list_del(VAR_1, &VAR_0->page_list);
            page_list_add_tail(VAR_1, &VAR_0->arch.relmem_list);
        }
    }

    spin_unlock(&VAR_0->page_alloc_lock);

    if ( !VAR_2 )
        /* COMMENT_18 */
                                                                      
                                            
           
        VAR_2 = iommu_iotlb_flush_all(
            VAR_0, VAR_18 | VAR_19);

    if ( VAR_2 && VAR_2 != -VAR_15 )
        iommu_teardown(VAR_0);

    return VAR_2;
}",xen-project/xen/1f0b0bb7773d537bcf169e021495d0986d9809fc/iommu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,6 +24,27 @@
                 rc = iommu_map(d, _dfn(gfn), _mfn(mfn), PAGE_ORDER_4K,
                                IOMMUF_readable | IOMMUF_writable,
                                &flush_flags);
+
+                /*
+                 * We may be working behind the back of a running guest, which
+                 * may change the type of a page at any time.  We can't prevent
+                 * this (for instance, by bumping the type count while mapping
+                 * the page) without causing legitimate guest type-change
+                 * operations to fail.  So after adding the page to the IOMMU,
+                 * check again to make sure this is still valid.  NB that the
+                 * writable entry in the iommu is harmless until later, when
+                 * the actual device gets assigned.
+                 */
+                if ( !rc && !is_hvm_domain(d) &&
+                     ((page->u.inuse.type_info & PGT_type_mask) !=
+                      PGT_writable_page) )
+                {
+                    rc = iommu_unmap(d, _dfn(gfn), PAGE_ORDER_4K, &flush_flags);
+                    /* If the type changed yet again, simply force a retry. */
+                    if ( !rc && ((page->u.inuse.type_info & PGT_type_mask) ==
+                                 PGT_writable_page) )
+                        rc = -ERESTART;
+                }
             }
             if ( rc )
             {","{'deleted_lines': [], 'added_lines': ['', '                /*', '                 * We may be working behind the back of a running guest, which', ""                 * may change the type of a page at any time.  We can't prevent"", '                 * this (for instance, by bumping the type count while mapping', '                 * the page) without causing legitimate guest type-change', '                 * operations to fail.  So after adding the page to the IOMMU,', '                 * check again to make sure this is still valid.  NB that the', '                 * writable entry in the iommu is harmless until later, when', '                 * the actual device gets assigned.', '                 */', '                if ( !rc && !is_hvm_domain(d) &&', '                     ((page->u.inuse.type_info & PGT_type_mask) !=', '                      PGT_writable_page) )', '                {', '                    rc = iommu_unmap(d, _dfn(gfn), PAGE_ORDER_4K, &flush_flags);', '                    /* If the type changed yet again, simply force a retry. */', '                    if ( !rc && ((page->u.inuse.type_info & PGT_type_mask) ==', '                                 PGT_writable_page) )', '                        rc = -ERESTART;', '                }']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges by leveraging a page-writability race condition during addition of a passed-through PCI device.,7.8,HIGH,2,valid,2019-03-05T12:47:36Z,2
CVE-2019-17345,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"x86/mm: don't retain page type reference when IOMMU operation fails

The IOMMU update in _get_page_type() happens between recording of the
new reference and validation of the page for its new type (if
necessary). If the IOMMU operation fails, there's no point in actually
carrying out validation. Furthermore, with this resulting in failure
getting indicated to the caller, the recorded type reference also needs
to be dropped again.

Note that in case of failure of alloc_page_type() there's no need to
undo the IOMMU operation: Only special types get handed to the function.
The function, upon failure, clears ->u.inuse.type_info, effectively
converting the page to PGT_none. The IOMMU mapping, however, solely
depends on whether the type is PGT_writable_page.

This is XSA-291.

Reported-by: Igor Druzhinin <igor.druzhinin@citrix.com>
Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",fad0de986220c46e70be2f83279961aad7394af0,https://github.com/xen-project/xen/commit/fad0de986220c46e70be2f83279961aad7394af0,xen/arch/x86/mm.c,_get_page_type,"static int _get_page_type(struct page_info *page, unsigned long type,
bool preemptible)
{
unsigned long nx, x, y = page->u.inuse.type_info;
int rc = 0, iommu_ret = 0;
ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
ASSERT(!in_irq());
for ( ; ; )
{
x  = y;
nx = x + 1;
if ( unlikely((nx & PGT_count_mask) == 0) )
{
gdprintk(XENLOG_WARNING,
""Type count overflow on mfn %""PRI_mfn""\n"",
mfn_x(page_to_mfn(page)));
return -EINVAL;
}
else if ( unlikely((x & PGT_count_mask) == 0) )
{
struct domain *d = page_get_owner(page);
if ( d && shadow_mode_enabled(d) )
shadow_prepare_page_type_change(d, page, type);
ASSERT(!(x & PGT_pae_xen_l2));
if ( (x & PGT_type_mask) != type )
{
cpumask_t *mask = this_cpu(scratch_cpumask);
BUG_ON(in_irq());
cpumask_copy(mask, d->dirty_cpumask);
tlbflush_filter(mask, page->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(mask)) &&
(!shadow_mode_enabled(page_get_owner(page)) ||
((nx & PGT_type_mask) == PGT_writable_page)) )
{
perfc_incr(need_flush_tlb_flush);
flush_tlb_mask(mask);
}
nx &= ~(PGT_type_mask | PGT_validated);
nx |= type;
if ( type == PGT_writable_page || type == PGT_shared_page )
nx |= PGT_validated;
}
}
else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
{
if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
(type == PGT_l1_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
(type == PGT_l2_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
(type == PGT_l3_page_table) )
return -EINVAL;
gdprintk(XENLOG_WARNING,
""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
x, type, mfn_x(page_to_mfn(page)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
return -EINVAL;
}
else if ( unlikely(!(x & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
do {
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
cpu_relax();
} while ( (y = page->u.inuse.type_info) == x );
continue;
}
ASSERT((x & PGT_count_mask) == 1);
nx = x & ~PGT_partial;
}
if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
break;
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
}
if ( unlikely((x & PGT_type_mask) != type) )
{
struct domain *d = page_get_owner(page);
if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
{
mfn_t mfn = page_to_mfn(page);
if ( (x & PGT_type_mask) == PGT_writable_page )
iommu_ret = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)),
PAGE_ORDER_4K);
else if ( type == PGT_writable_page )
iommu_ret = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn,
PAGE_ORDER_4K,
IOMMUF_readable |
IOMMUF_writable);
}
}
if ( unlikely(!(nx & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
page->nr_validated_ptes = 0;
page->partial_pte = 0;
}
page->linear_pt_count = 0;
rc = alloc_page_type(page, type, preemptible);
}
if ( (x & PGT_partial) && !(nx & PGT_partial) )
put_page(page);
if ( !rc )
rc = iommu_ret;
return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
bool VAR_2)
{
unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
int VAR_6 = 0, VAR_7 = 0;
ASSERT(!(VAR_1 & ~(VAR_8 | VAR_9)));
ASSERT(!in_irq());
for ( ; ; )
{
VAR_4  = VAR_5;
VAR_3 = VAR_4 + 1;
if ( unlikely((VAR_3 & VAR_10) == 0) )
{
gdprintk(VAR_11,
""Type count overflow on mfn %""VAR_12""\n"",
mfn_x(page_to_mfn(VAR_0)));
return -VAR_13;
}
else if ( unlikely((VAR_4 & VAR_10) == 0) )
{
struct domain *VAR_14 = page_get_owner(VAR_0);
if ( VAR_14 && shadow_mode_enabled(VAR_14) )
shadow_prepare_page_type_change(VAR_14, VAR_0, VAR_1);
ASSERT(!(VAR_4 & VAR_9));
if ( (VAR_4 & VAR_8) != VAR_1 )
{
cpumask_t *VAR_15 = this_cpu(VAR_16);
BUG_ON(in_irq());
cpumask_copy(VAR_15, VAR_14->dirty_cpumask);
tlbflush_filter(VAR_15, VAR_0->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(VAR_15)) &&
(!shadow_mode_enabled(page_get_owner(VAR_0)) ||
((VAR_3 & VAR_8) == VAR_17)) )
{
perfc_incr(VAR_18);
flush_tlb_mask(VAR_15);
}
VAR_3 &= ~(VAR_8 | VAR_19);
VAR_3 |= VAR_1;
if ( VAR_1 == VAR_17 || VAR_1 == VAR_20 )
VAR_3 |= VAR_19;
}
}
else if ( unlikely((VAR_4 & (VAR_8|VAR_9)) != VAR_1) )
{
if ( ((VAR_4 & VAR_8) == VAR_21) &&
(VAR_1 == VAR_22) )
return -VAR_13;
if ( ((VAR_4 & VAR_8) == VAR_23) &&
(VAR_1 == VAR_21) )
return -VAR_13;
if ( ((VAR_4 & VAR_8) == VAR_24) &&
(VAR_1 == VAR_23) )
return -VAR_13;
gdprintk(VAR_11,
""Bad type (saw %"" VAR_25 "" != exp %"" VAR_25 "") ""
""for mfn %"" VAR_12 "" (pfn %"" VAR_26 "")\n"",
VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
return -VAR_13;
}
else if ( unlikely(!(VAR_4 & VAR_19)) )
{
if ( !(VAR_4 & VAR_27) )
{
do {
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_28;
cpu_relax();
} while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
continue;
}
ASSERT((VAR_4 & VAR_10) == 1);
VAR_3 = VAR_4 & ~VAR_27;
}
if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
break;
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_28;
}
if ( unlikely((VAR_4 & VAR_8) != VAR_1) )
{
struct domain *VAR_14 = page_get_owner(VAR_0);
if ( VAR_14 && is_pv_domain(VAR_14) && unlikely(need_iommu_pt_sync(VAR_14)) )
{
mfn_t VAR_29 = page_to_mfn(VAR_0);
if ( (VAR_4 & VAR_8) == VAR_17 )
VAR_7 = iommu_legacy_unmap(VAR_14, _dfn(mfn_x(VAR_29)),
VAR_30);
else if ( VAR_1 == VAR_17 )
VAR_7 = iommu_legacy_map(VAR_14, _dfn(mfn_x(VAR_29)), VAR_29,
VAR_30,
VAR_31 |
VAR_32);
}
}
if ( unlikely(!(VAR_3 & VAR_19)) )
{
if ( !(VAR_4 & VAR_27) )
{
VAR_0->nr_validated_ptes = 0;
VAR_0->partial_pte = 0;
}
VAR_0->linear_pt_count = 0;
VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
}
if ( (VAR_4 & VAR_27) && !(VAR_3 & VAR_27) )
put_page(VAR_0);
if ( !VAR_6 )
VAR_6 = VAR_7;
return VAR_6;
}",xen-project/xen/fad0de986220c46e70be2f83279961aad7394af0/mm.c/vul/before/0.json,"static int _get_page_type(struct page_info *page, unsigned long type,
                          bool preemptible)
{
    unsigned long nx, x, y = page->u.inuse.type_info;
    int rc = 0, iommu_ret = 0;

    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        x  = y;
        nx = x + 1;
        if ( unlikely((nx & PGT_count_mask) == 0) )
        {
            gdprintk(XENLOG_WARNING,
                     ""Type count overflow on mfn %""PRI_mfn""\n"",
                     mfn_x(page_to_mfn(page)));
            return -EINVAL;
        }
        else if ( unlikely((x & PGT_count_mask) == 0) )
        {
            struct domain *d = page_get_owner(page);

            if ( d && shadow_mode_enabled(d) )
               shadow_prepare_page_type_change(d, page, type);

            ASSERT(!(x & PGT_pae_xen_l2));
            if ( (x & PGT_type_mask) != type )
            {
                /*
                 * On type change we check to flush stale TLB entries. It is
                 * vital that no other CPUs are left with mappings of a frame
                 * which is about to become writeable to the guest.
                 */
                cpumask_t *mask = this_cpu(scratch_cpumask);

                BUG_ON(in_irq());
                cpumask_copy(mask, d->dirty_cpumask);

                /* Don't flush if the timestamp is old enough */
                tlbflush_filter(mask, page->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(mask)) &&
                     /* Shadow mode: track only writable pages. */
                     (!shadow_mode_enabled(page_get_owner(page)) ||
                      ((nx & PGT_type_mask) == PGT_writable_page)) )
                {
                    perfc_incr(need_flush_tlb_flush);
                    flush_tlb_mask(mask);
                }

                /* We lose existing type and validity. */
                nx &= ~(PGT_type_mask | PGT_validated);
                nx |= type;

                /*
                 * No special validation needed for writable pages.
                 * Page tables and GDT/LDT need to be scanned for validity.
                 */
                if ( type == PGT_writable_page || type == PGT_shared_page )
                    nx |= PGT_validated;
            }
        }
        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
        {
            /* Don't log failure if it could be a recursive-mapping attempt. */
            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
                 (type == PGT_l1_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
                 (type == PGT_l2_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
                 (type == PGT_l3_page_table) )
                return -EINVAL;
            gdprintk(XENLOG_WARNING,
                     ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
                     ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
                     x, type, mfn_x(page_to_mfn(page)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
            return -EINVAL;
        }
        else if ( unlikely(!(x & PGT_validated)) )
        {
            if ( !(x & PGT_partial) )
            {
                /* Someone else is updating validation of this page. Wait... */
                do {
                    if ( preemptible && hypercall_preempt_check() )
                        return -EINTR;
                    cpu_relax();
                } while ( (y = page->u.inuse.type_info) == x );
                continue;
            }
            /* Type ref count was left at 1 when PGT_partial got set. */
            ASSERT((x & PGT_count_mask) == 1);
            nx = x & ~PGT_partial;
        }

        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
            break;

        if ( preemptible && hypercall_preempt_check() )
            return -EINTR;
    }

    if ( unlikely((x & PGT_type_mask) != type) )
    {
        /* Special pages should not be accessible from devices. */
        struct domain *d = page_get_owner(page);
        if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
        {
            mfn_t mfn = page_to_mfn(page);

            if ( (x & PGT_type_mask) == PGT_writable_page )
                iommu_ret = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)),
                                               PAGE_ORDER_4K);
            else if ( type == PGT_writable_page )
                iommu_ret = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn,
                                             PAGE_ORDER_4K,
                                             IOMMUF_readable |
                                             IOMMUF_writable);

            if ( unlikely(iommu_ret) )
            {
                _put_page_type(page, false, NULL);
                rc = iommu_ret;
                goto out;
            }
        }
    }

    if ( unlikely(!(nx & PGT_validated)) )
    {
        if ( !(x & PGT_partial) )
        {
            page->nr_validated_ptes = 0;
            page->partial_pte = 0;
        }
        page->linear_pt_count = 0;
        rc = alloc_page_type(page, type, preemptible);
    }

 out:
    if ( (x & PGT_partial) && !(nx & PGT_partial) )
        put_page(page);

    return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
                          bool VAR_2)
{
    unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
    int VAR_6 = 0, VAR_7 = 0;

    ASSERT(!(VAR_1 & ~(VAR_8 | VAR_9)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        VAR_4  = VAR_5;
        VAR_3 = VAR_4 + 1;
        if ( unlikely((VAR_3 & VAR_10) == 0) )
        {
            gdprintk(VAR_11,
                     ""Type count overflow on mfn %""VAR_12""\n"",
                     mfn_x(page_to_mfn(VAR_0)));
            return -VAR_13;
        }
        else if ( unlikely((VAR_4 & VAR_10) == 0) )
        {
            struct domain *VAR_14 = page_get_owner(VAR_0);

            if ( VAR_14 && shadow_mode_enabled(VAR_14) )
               shadow_prepare_page_type_change(VAR_14, VAR_0, VAR_1);

            ASSERT(!(VAR_4 & VAR_9));
            if ( (VAR_4 & VAR_8) != VAR_1 )
            {
                /* COMMENT_0 */
                                                                            
                                                                             
                                                                   
                   
                cpumask_t *VAR_15 = this_cpu(VAR_16);

                BUG_ON(in_irq());
                cpumask_copy(VAR_15, VAR_14->dirty_cpumask);

                /* COMMENT_5 */
                tlbflush_filter(VAR_15, VAR_0->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(VAR_15)) &&
                     /* COMMENT_6 */
                     (!shadow_mode_enabled(page_get_owner(VAR_0)) ||
                      ((VAR_3 & VAR_8) == VAR_17)) )
                {
                    perfc_incr(VAR_18);
                    flush_tlb_mask(VAR_15);
                }

                /* COMMENT_7 */
                VAR_3 &= ~(VAR_8 | VAR_19);
                VAR_3 |= VAR_1;

                /* COMMENT_8 */
                                                                   
                                                                           
                   
                if ( VAR_1 == VAR_17 || VAR_1 == VAR_20 )
                    VAR_3 |= VAR_19;
            }
        }
        else if ( unlikely((VAR_4 & (VAR_8|VAR_9)) != VAR_1) )
        {
            /* COMMENT_12 */
            if ( ((VAR_4 & VAR_8) == VAR_21) &&
                 (VAR_1 == VAR_22) )
                return -VAR_13;
            if ( ((VAR_4 & VAR_8) == VAR_23) &&
                 (VAR_1 == VAR_21) )
                return -VAR_13;
            if ( ((VAR_4 & VAR_8) == VAR_24) &&
                 (VAR_1 == VAR_23) )
                return -VAR_13;
            gdprintk(VAR_11,
                     ""Bad type (saw %"" VAR_25 "" != exp %"" VAR_25 "") ""
                     ""for mfn %"" VAR_12 "" (pfn %"" VAR_26 "")\n"",
                     VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
            return -VAR_13;
        }
        else if ( unlikely(!(VAR_4 & VAR_19)) )
        {
            if ( !(VAR_4 & VAR_27) )
            {
                /* COMMENT_13 */
                do {
                    if ( VAR_2 && hypercall_preempt_check() )
                        return -VAR_28;
                    cpu_relax();
                } while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
                continue;
            }
            /* COMMENT_14 */
            ASSERT((VAR_4 & VAR_10) == 1);
            VAR_3 = VAR_4 & ~VAR_27;
        }

        if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
            break;

        if ( VAR_2 && hypercall_preempt_check() )
            return -VAR_28;
    }

    if ( unlikely((VAR_4 & VAR_8) != VAR_1) )
    {
        /* COMMENT_15 */
        struct domain *VAR_14 = page_get_owner(VAR_0);
        if ( VAR_14 && is_pv_domain(VAR_14) && unlikely(need_iommu_pt_sync(VAR_14)) )
        {
            mfn_t VAR_29 = page_to_mfn(VAR_0);

            if ( (VAR_4 & VAR_8) == VAR_17 )
                VAR_7 = iommu_legacy_unmap(VAR_14, _dfn(mfn_x(VAR_29)),
                                               VAR_30);
            else if ( VAR_1 == VAR_17 )
                VAR_7 = iommu_legacy_map(VAR_14, _dfn(mfn_x(VAR_29)), VAR_29,
                                             VAR_30,
                                             VAR_31 |
                                             VAR_32);

            if ( unlikely(VAR_7) )
            {
                _put_page_type(VAR_0, false, NULL);
                VAR_6 = VAR_7;
                goto out;
            }
        }
    }

    if ( unlikely(!(VAR_3 & VAR_19)) )
    {
        if ( !(VAR_4 & VAR_27) )
        {
            VAR_0->nr_validated_ptes = 0;
            VAR_0->partial_pte = 0;
        }
        VAR_0->linear_pt_count = 0;
        VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
    }

 out:
    if ( (VAR_4 & VAR_27) && !(VAR_3 & VAR_27) )
        put_page(VAR_0);

    return VAR_6;
}",xen-project/xen/fad0de986220c46e70be2f83279961aad7394af0/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,6 +121,13 @@
                                              PAGE_ORDER_4K,
                                              IOMMUF_readable |
                                              IOMMUF_writable);
+
+            if ( unlikely(iommu_ret) )
+            {
+                _put_page_type(page, false, NULL);
+                rc = iommu_ret;
+                goto out;
+            }
         }
     }
 
@@ -135,11 +142,9 @@
         rc = alloc_page_type(page, type, preemptible);
     }
 
+ out:
     if ( (x & PGT_partial) && !(nx & PGT_partial) )
         put_page(page);
 
-    if ( !rc )
-        rc = iommu_ret;
-
     return rc;
 }","{'deleted_lines': ['    if ( !rc )', '        rc = iommu_ret;', ''], 'added_lines': ['', '            if ( unlikely(iommu_ret) )', '            {', '                _put_page_type(page, false, NULL);', '                rc = iommu_ret;', '                goto out;', '            }', ' out:']}",True,An issue was discovered in Xen 4.8.x through 4.11.x allowing x86 PV guest OS users to cause a denial of service because mishandling of failed IOMMU operations causes a bug check during the cleanup of a crashed guest.,6.5,MEDIUM,1,valid,2019-03-05T12:52:15Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Rewrite guest %cr4 handling from scratch

The PV cr4 logic is almost impossible to follow, and leaks bits into guest
context which definitely shouldn't be visible (in particular, VMXE).

The biggest problem however, and source of the complexity, is that it derives
new real and guest cr4 values from the current value in hardware - this is
context dependent and an inappropriate source of information.

Rewrite the cr4 logic to be invariant of the current value in hardware.

First of all, modify write_ptbase() to always use mmu_cr4_features for IDLE
and HVM contexts.  mmu_cr4_features *is* the correct value to use, and makes
the ASSERT() obviously redundant.

For PV guests, curr->arch.pv.ctrlreg[4] remains the guests view of cr4, but
all logic gets reworked in terms of this and mmu_cr4_features only.

Two masks are introduced; bits which the guest has control over, and bits
which are forwarded from Xen's settings.  One guest-visible change here is
that Xen's VMXE setting is no longer visible at all.

pv_make_cr4() follows fairly closely from pv_guest_cr4_to_real_cr4(), but
deliberately starts with mmu_cr4_features, and only alters the minimal subset
of bits.

The boot-time {compat_,}pv_cr4_mask variables are removed, as they are a
remnant of the pre-CPUID policy days.  pv_fixup_guest_cr4() gains a related
derivation from the policy.

Another guest visible change here is that a 32bit PV guest can now flip
FSGSBASE in its view of CR4.  While the {RD,WR}{FS,GS}BASE instructions are
unusable outside of a 64bit code segment, the ability to modify FSGSBASE
matches real hardware behaviour, and avoids the need for any 32bit/64bit
differences in the logic.

Overall, this patch shouldn't have a practical change in guest behaviour.
VMXE will disappear from view, and an inquisitive 32bit kernel can now see
FSGSBASE changing, but this new logic is otherwise bug-compatible with before.

This is part of XSA-293.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",b2dd00574a4fc87ca964177f8e752a968c27efb2,https://github.com/xen-project/xen/commit/b2dd00574a4fc87ca964177f8e752a968c27efb2,xen/arch/x86/mm.c,write_ptbase,"void write_ptbase(struct vcpu *v)
{
struct cpu_info *cpu_info = get_cpu_info();
unsigned long new_cr4;
new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))
? pv_guest_cr4_to_real_cr4(v)
: ((read_cr4() & ~(X86_CR4_PCIDE | X86_CR4_TSD)) | X86_CR4_PGE);
if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )
{
cpu_info->root_pgt_changed = true;
cpu_info->pv_cr3 = __pa(this_cpu(root_pgt));
if ( new_cr4 & X86_CR4_PCIDE )
cpu_info->pv_cr3 |= get_pcid_bits(v, true);
switch_cr3_cr4(v->arch.cr3, new_cr4);
}
else
{
cpu_info->use_pv_cr3 = false;
cpu_info->xen_cr3 = 0;
switch_cr3_cr4(v->arch.cr3, new_cr4);
cpu_info->pv_cr3 = 0;
}
ASSERT(is_pv_vcpu(v) || read_cr4() == mmu_cr4_features);
}","void write_ptbase(struct vcpu *VAR_0)
{
struct cpu_info *cpu_info = get_cpu_info();
unsigned long VAR_1;
VAR_1 = (is_pv_vcpu(VAR_0) && !is_idle_vcpu(VAR_0))
? pv_guest_cr4_to_real_cr4(VAR_0)
: ((read_cr4() & ~(VAR_2 | VAR_3)) | VAR_4);
if ( is_pv_vcpu(VAR_0) && VAR_0->domain->arch.pv.xpti )
{
cpu_info->root_pgt_changed = true;
cpu_info->pv_cr3 = __pa(this_cpu(VAR_5));
if ( VAR_1 & VAR_2 )
cpu_info->pv_cr3 |= get_pcid_bits(VAR_0, true);
switch_cr3_cr4(VAR_0->arch.cr3, VAR_1);
}
else
{
cpu_info->use_pv_cr3 = false;
cpu_info->xen_cr3 = 0;
switch_cr3_cr4(VAR_0->arch.cr3, VAR_1);
cpu_info->pv_cr3 = 0;
}
ASSERT(is_pv_vcpu(VAR_0) || read_cr4() == VAR_6);
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/mm.c/vul/before/0.json,"void write_ptbase(struct vcpu *v)
{
    struct cpu_info *cpu_info = get_cpu_info();
    unsigned long new_cr4;

    new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))
              ? pv_make_cr4(v) : mmu_cr4_features;

    if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )
    {
        cpu_info->root_pgt_changed = true;
        cpu_info->pv_cr3 = __pa(this_cpu(root_pgt));
        if ( new_cr4 & X86_CR4_PCIDE )
            cpu_info->pv_cr3 |= get_pcid_bits(v, true);
        switch_cr3_cr4(v->arch.cr3, new_cr4);
    }
    else
    {
        /* Make sure to clear use_pv_cr3 and xen_cr3 before pv_cr3. */
        cpu_info->use_pv_cr3 = false;
        cpu_info->xen_cr3 = 0;
        /* switch_cr3_cr4() serializes. */
        switch_cr3_cr4(v->arch.cr3, new_cr4);
        cpu_info->pv_cr3 = 0;
    }
}","void write_ptbase(struct vcpu *VAR_0)
{
    struct cpu_info *cpu_info = get_cpu_info();
    unsigned long VAR_1;

    VAR_1 = (is_pv_vcpu(VAR_0) && !is_idle_vcpu(VAR_0))
              ? pv_make_cr4(VAR_0) : VAR_2;

    if ( is_pv_vcpu(VAR_0) && VAR_0->domain->arch.pv.xpti )
    {
        cpu_info->root_pgt_changed = true;
        cpu_info->pv_cr3 = __pa(this_cpu(VAR_3));
        if ( VAR_1 & VAR_4 )
            cpu_info->pv_cr3 |= get_pcid_bits(VAR_0, true);
        switch_cr3_cr4(VAR_0->arch.cr3, VAR_1);
    }
    else
    {
        /* COMMENT_0 */
        cpu_info->use_pv_cr3 = false;
        cpu_info->xen_cr3 = 0;
        /* COMMENT_1 */
        switch_cr3_cr4(VAR_0->arch.cr3, VAR_1);
        cpu_info->pv_cr3 = 0;
    }
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,8 +4,7 @@
     unsigned long new_cr4;
 
     new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))
-              ? pv_guest_cr4_to_real_cr4(v)
-              : ((read_cr4() & ~(X86_CR4_PCIDE | X86_CR4_TSD)) | X86_CR4_PGE);
+              ? pv_make_cr4(v) : mmu_cr4_features;
 
     if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )
     {
@@ -24,6 +23,4 @@
         switch_cr3_cr4(v->arch.cr3, new_cr4);
         cpu_info->pv_cr3 = 0;
     }
-
-    ASSERT(is_pv_vcpu(v) || read_cr4() == mmu_cr4_features);
 }","{'deleted_lines': ['              ? pv_guest_cr4_to_real_cr4(v)', '              : ((read_cr4() & ~(X86_CR4_PCIDE | X86_CR4_TSD)) | X86_CR4_PGE);', '', '    ASSERT(is_pv_vcpu(v) || read_cr4() == mmu_cr4_features);'], 'added_lines': ['              ? pv_make_cr4(v) : mmu_cr4_features;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:53:32Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Rewrite guest %cr4 handling from scratch

The PV cr4 logic is almost impossible to follow, and leaks bits into guest
context which definitely shouldn't be visible (in particular, VMXE).

The biggest problem however, and source of the complexity, is that it derives
new real and guest cr4 values from the current value in hardware - this is
context dependent and an inappropriate source of information.

Rewrite the cr4 logic to be invariant of the current value in hardware.

First of all, modify write_ptbase() to always use mmu_cr4_features for IDLE
and HVM contexts.  mmu_cr4_features *is* the correct value to use, and makes
the ASSERT() obviously redundant.

For PV guests, curr->arch.pv.ctrlreg[4] remains the guests view of cr4, but
all logic gets reworked in terms of this and mmu_cr4_features only.

Two masks are introduced; bits which the guest has control over, and bits
which are forwarded from Xen's settings.  One guest-visible change here is
that Xen's VMXE setting is no longer visible at all.

pv_make_cr4() follows fairly closely from pv_guest_cr4_to_real_cr4(), but
deliberately starts with mmu_cr4_features, and only alters the minimal subset
of bits.

The boot-time {compat_,}pv_cr4_mask variables are removed, as they are a
remnant of the pre-CPUID policy days.  pv_fixup_guest_cr4() gains a related
derivation from the policy.

Another guest visible change here is that a 32bit PV guest can now flip
FSGSBASE in its view of CR4.  While the {RD,WR}{FS,GS}BASE instructions are
unusable outside of a 64bit code segment, the ability to modify FSGSBASE
matches real hardware behaviour, and avoids the need for any 32bit/64bit
differences in the logic.

Overall, this patch shouldn't have a practical change in guest behaviour.
VMXE will disappear from view, and an inquisitive 32bit kernel can now see
FSGSBASE changing, but this new logic is otherwise bug-compatible with before.

This is part of XSA-293.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",b2dd00574a4fc87ca964177f8e752a968c27efb2,https://github.com/xen-project/xen/commit/b2dd00574a4fc87ca964177f8e752a968c27efb2,xen/arch/x86/domain.c,arch_set_info_guest,"int arch_set_info_guest(
struct vcpu *v, vcpu_guest_context_u c)
{
struct domain *d = v->domain;
unsigned int i;
unsigned long flags;
bool compat;
#ifdef CONFIG_PV
unsigned long cr3_gfn;
struct page_info *cr3_page;
unsigned long cr4;
int rc = 0;
#endif
compat = is_pv_32bit_domain(d);
#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))
flags = c(flags);
if ( is_pv_domain(d) )
{
if ( !compat )
{
if ( !is_canonical_address(c.nat->user_regs.rip) ||
!is_canonical_address(c.nat->user_regs.rsp) ||
!is_canonical_address(c.nat->kernel_sp) ||
(c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||
!is_canonical_address(c.nat->fs_base) ||
!is_canonical_address(c.nat->gs_base_kernel) ||
!is_canonical_address(c.nat->gs_base_user) ||
!is_canonical_address(c.nat->event_callback_eip) ||
!is_canonical_address(c.nat->syscall_callback_eip) ||
!is_canonical_address(c.nat->failsafe_callback_eip) )
return -EINVAL;
fixup_guest_stack_selector(d, c.nat->user_regs.ss);
fixup_guest_stack_selector(d, c.nat->kernel_ss);
fixup_guest_code_selector(d, c.nat->user_regs.cs);
for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )
{
if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )
return -EINVAL;
fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);
}
if ( !__addr_ok(c.nat->ldt_base) )
return -EINVAL;
}
else
{
fixup_guest_stack_selector(d, c.cmp->user_regs.ss);
fixup_guest_stack_selector(d, c.cmp->kernel_ss);
fixup_guest_code_selector(d, c.cmp->user_regs.cs);
fixup_guest_code_selector(d, c.cmp->event_callback_cs);
fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);
for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )
fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);
}
if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||
(c(ldt_ents) > 8192) )
return -EINVAL;
}
v->arch.flags &= ~TF_kernel_mode;
if ( (flags & VGCF_in_kernel) || is_hvm_domain(d) )
v->arch.flags |= TF_kernel_mode;
v->arch.vgc_flags = flags;
vcpu_setup_fpu(v, v->arch.xsave_area,
flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,
FCW_DEFAULT);
if ( !compat )
{
memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));
if ( is_pv_domain(d) )
memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,
sizeof(c.nat->trap_ctxt));
}
else
{
XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);
if ( is_pv_domain(d) )
{
for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )
XLAT_trap_info(v->arch.pv.trap_ctxt + i,
c.cmp->trap_ctxt + i);
}
}
if ( is_hvm_domain(d) )
{
for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )
v->arch.dr[i] = c(debugreg[i]);
v->arch.dr6 = c(debugreg[6]);
v->arch.dr7 = c(debugreg[7]);
hvm_set_info_guest(v);
goto out;
}
#ifdef CONFIG_PV
v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;
v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;
v->arch.user_regs.eflags |= X86_EFLAGS_IF;
if ( !v->is_initialised )
{
if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )
return -EINVAL;
v->arch.pv.ldt_base = c(ldt_base);
v->arch.pv.ldt_ents = c(ldt_ents);
}
else
{
unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);
bool fail;
if ( !compat )
{
fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];
if ( pagetable_is_null(v->arch.guest_table_user) )
fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);
else
{
pfn = pagetable_get_pfn(v->arch.guest_table_user);
fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];
}
} else {
l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));
pfn = l4e_get_pfn(*l4tab);
unmap_domain_page(l4tab);
fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];
}
for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )
fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);
fail |= v->arch.pv.gdt_ents != c(gdt_ents);
fail |= v->arch.pv.ldt_base != c(ldt_base);
fail |= v->arch.pv.ldt_ents != c(ldt_ents);
if ( fail )
return -EOPNOTSUPP;
}
v->arch.pv.kernel_ss = c(kernel_ss);
v->arch.pv.kernel_sp = c(kernel_sp);
for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )
v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);
v->arch.pv.event_callback_eip = c(event_callback_eip);
v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);
if ( !compat )
{
v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;
v->arch.pv.fs_base =
!(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;
v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;
v->arch.pv.gs_base_user =
!(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;
}
else
{
v->arch.pv.event_callback_cs = c(event_callback_cs);
v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);
}
v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;
cr4 = v->arch.pv.ctrlreg[4];
v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :
real_cr4_to_pv_guest_cr4(mmu_cr4_features);
memset(v->arch.dr, 0, sizeof(v->arch.dr));
v->arch.dr6 = X86_DR6_DEFAULT;
v->arch.dr7 = X86_DR7_DEFAULT;
v->arch.pv.dr7_emul = 0;
for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )
set_debugreg(v, i, c(debugreg[i]));
set_debugreg(v, 6, c(debugreg[6]));
set_debugreg(v, 7, c(debugreg[7]));
if ( v->is_initialised )
goto out;
if ( v->vcpu_id == 0 )
{
if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&
is_pv_domain(d) && !is_pv_32bit_domain(d) &&
test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&
atomic_read(&d->arch.pv.nr_l4_pages) )
{
bool done = false;
spin_lock_recursive(&d->page_alloc_lock);
for ( i = 0; ; )
{
struct page_info *page = page_list_remove_head(&d->page_list);
if ( page_lock(page) )
{
if ( (page->u.inuse.type_info & PGT_type_mask) ==
PGT_l4_page_table )
done = !fill_ro_mpt(page_to_mfn(page));
page_unlock(page);
}
page_list_add_tail(page, &d->page_list);
if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )
break;
}
spin_unlock_recursive(&d->page_alloc_lock);
if ( !done )
return -ERESTART;
}
d->vm_assist = c(vm_assist);
}
rc = put_old_guest_table(current);
if ( rc )
return rc;
if ( !compat )
rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);
else
{
unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];
unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);
if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )
return -EINVAL;
for ( i = 0; i < nr_frames; ++i )
gdt_frames[i] = c.cmp->gdt_frames[i];
rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);
}
if ( rc != 0 )
return rc;
set_bit(_VPF_in_reset, &v->pause_flags);
if ( !compat )
cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);
else
cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);
cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);
if ( !cr3_page )
rc = -EINVAL;
else if ( paging_mode_refcounts(d) )
;
else if ( cr3_page == v->arch.old_guest_table )
{
v->arch.old_guest_table = NULL;
put_page(cr3_page);
}
else
{
if ( !compat )
rc = put_old_guest_table(v);
if ( !rc )
rc = get_page_type_preemptible(cr3_page,
!compat ? PGT_root_page_table
: PGT_l3_page_table);
switch ( rc )
{
case -EINTR:
rc = -ERESTART;
case -ERESTART:
break;
case 0:
if ( !compat && !VM_ASSIST(d, m2p_strict) &&
!paging_mode_refcounts(d) )
fill_ro_mpt(_mfn(cr3_gfn));
break;
default:
if ( cr3_page == current->arch.old_guest_table )
cr3_page = NULL;
break;
}
}
if ( rc )
;
else if ( !compat )
{
v->arch.guest_table = pagetable_from_page(cr3_page);
if ( c.nat->ctrlreg[1] )
{
cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);
cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);
if ( !cr3_page )
rc = -EINVAL;
else if ( !paging_mode_refcounts(d) )
{
rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);
switch ( rc )
{
case -EINTR:
rc = -ERESTART;
case -ERESTART:
v->arch.old_guest_ptpg = NULL;
v->arch.old_guest_table =
pagetable_get_page(v->arch.guest_table);
v->arch.guest_table = pagetable_null();
break;
default:
if ( cr3_page == current->arch.old_guest_table )
cr3_page = NULL;
break;
case 0:
if ( VM_ASSIST(d, m2p_strict) )
zap_ro_mpt(_mfn(cr3_gfn));
break;
}
}
if ( !rc )
v->arch.guest_table_user = pagetable_from_page(cr3_page);
}
}
else
{
l4_pgentry_t *l4tab;
l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));
*l4tab = l4e_from_mfn(page_to_mfn(cr3_page),
_PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);
unmap_domain_page(l4tab);
}
if ( rc )
{
if ( cr3_page )
put_page(cr3_page);
pv_destroy_gdt(v);
return rc;
}
clear_bit(_VPF_in_reset, &v->pause_flags);
if ( v->vcpu_id == 0 )
update_domain_wallclock_time(d);
v->is_initialised = 1;
if ( paging_mode_enabled(d) )
paging_update_paging_modes(v);
update_cr3(v);
#endif 
out:
if ( flags & VGCF_online )
clear_bit(_VPF_down, &v->pause_flags);
else
set_bit(_VPF_down, &v->pause_flags);
return 0;
#undef c
}","int arch_set_info_guest(
struct vcpu *VAR_0, vcpu_guest_context_u VAR_1)
{
struct domain *VAR_2 = VAR_0->domain;
unsigned int VAR_3;
unsigned long VAR_4;
bool VAR_5;
#ifdef VAR_6
unsigned long VAR_7;
struct page_info *VAR_8;
unsigned long VAR_9;
int VAR_10 = 0;
#endif
VAR_5 = is_pv_32bit_domain(VAR_2);
#define VAR_1(VAR_11) (compat ? (c.cmp->fld) : (c.nat->fld))
VAR_4 = VAR_1(VAR_4);
if ( is_pv_domain(VAR_2) )
{
if ( !VAR_5 )
{
if ( !is_canonical_address(VAR_1.nat->user_regs.rip) ||
!is_canonical_address(VAR_1.nat->user_regs.rsp) ||
!is_canonical_address(VAR_1.nat->kernel_sp) ||
(VAR_1.nat->ldt_ents && !is_canonical_address(VAR_1.nat->ldt_base)) ||
!is_canonical_address(VAR_1.nat->fs_base) ||
!is_canonical_address(VAR_1.nat->gs_base_kernel) ||
!is_canonical_address(VAR_1.nat->gs_base_user) ||
!is_canonical_address(VAR_1.nat->event_callback_eip) ||
!is_canonical_address(VAR_1.nat->syscall_callback_eip) ||
!is_canonical_address(VAR_1.nat->failsafe_callback_eip) )
return -VAR_12;
fixup_guest_stack_selector(VAR_2, VAR_1.nat->user_regs.ss);
fixup_guest_stack_selector(VAR_2, VAR_1.nat->kernel_ss);
fixup_guest_code_selector(VAR_2, VAR_1.nat->user_regs.cs);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.nat->trap_ctxt); VAR_3++ )
{
if ( !is_canonical_address(VAR_1.nat->trap_ctxt[VAR_3].address) )
return -VAR_12;
fixup_guest_code_selector(VAR_2, VAR_1.nat->trap_ctxt[VAR_3].cs);
}
if ( !__addr_ok(VAR_1.nat->ldt_base) )
return -VAR_12;
}
else
{
fixup_guest_stack_selector(VAR_2, VAR_1.cmp->user_regs.ss);
fixup_guest_stack_selector(VAR_2, VAR_1.cmp->kernel_ss);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->user_regs.cs);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->event_callback_cs);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->failsafe_callback_cs);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); VAR_3++ )
fixup_guest_code_selector(VAR_2, VAR_1.cmp->trap_ctxt[VAR_3].cs);
}
if ( ((VAR_1(VAR_13) & (VAR_14 - 1)) != 0) ||
(VAR_1(VAR_15) > 8192) )
return -VAR_12;
}
VAR_0->arch.flags &= ~VAR_16;
if ( (VAR_4 & VAR_17) || is_hvm_domain(VAR_2) )
VAR_0->arch.flags |= VAR_16;
VAR_0->arch.vgc_flags = VAR_4;
vcpu_setup_fpu(VAR_0, VAR_0->arch.xsave_area,
VAR_4 & VAR_18 ? &VAR_1.nat->fpu_ctxt : NULL,
VAR_19);
if ( !VAR_5 )
{
memcpy(&VAR_0->arch.user_regs, &VAR_1.nat->user_regs, sizeof(VAR_1.nat->user_regs));
if ( is_pv_domain(VAR_2) )
memcpy(VAR_0->arch.pv.trap_ctxt, VAR_1.nat->trap_ctxt,
sizeof(VAR_1.nat->trap_ctxt));
}
else
{
XLAT_cpu_user_regs(&VAR_0->arch.user_regs, &VAR_1.cmp->user_regs);
if ( is_pv_domain(VAR_2) )
{
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); ++VAR_3 )
XLAT_trap_info(VAR_0->arch.pv.trap_ctxt + VAR_3,
VAR_1.cmp->trap_ctxt + VAR_3);
}
}
if ( is_hvm_domain(VAR_2) )
{
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); ++VAR_3 )
VAR_0->arch.dr[VAR_3] = VAR_1(VAR_20[VAR_3]);
VAR_0->arch.dr6 = VAR_1(VAR_20[6]);
VAR_0->arch.dr7 = VAR_1(VAR_20[7]);
hvm_set_info_guest(VAR_0);
goto out;
}
#ifdef VAR_6
VAR_0->arch.pv.iopl = VAR_0->arch.user_regs.eflags & VAR_21;
VAR_0->arch.user_regs.eflags &= ~VAR_21;
VAR_0->arch.user_regs.eflags |= VAR_22;
if ( !VAR_0->is_initialised )
{
if ( !VAR_5 && !(VAR_4 & VAR_17) && !VAR_1.nat->ctrlreg[1] )
return -VAR_12;
VAR_0->arch.pv.ldt_base = VAR_1(VAR_13);
VAR_0->arch.pv.ldt_ents = VAR_1(VAR_15);
}
else
{
unsigned long VAR_23 = pagetable_get_pfn(VAR_0->arch.guest_table);
bool VAR_24;
if ( !VAR_5 )
{
VAR_24 = xen_pfn_to_cr3(VAR_23) != VAR_1.nat->ctrlreg[3];
if ( pagetable_is_null(VAR_0->arch.guest_table_user) )
VAR_24 |= VAR_1.nat->ctrlreg[1] || !(VAR_4 & VAR_17);
else
{
VAR_23 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
VAR_24 |= xen_pfn_to_cr3(VAR_23) != VAR_1.nat->ctrlreg[1];
}
} else {
l4_pgentry_t *VAR_25 = map_domain_page(_mfn(VAR_23));
VAR_23 = l4e_get_pfn(*VAR_25);
unmap_domain_page(VAR_25);
VAR_24 = compat_pfn_to_cr3(VAR_23) != VAR_1.cmp->ctrlreg[3];
}
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.gdt_frames); ++VAR_3 )
VAR_24 |= VAR_0->arch.pv.gdt_frames[VAR_3] != VAR_1(VAR_26[VAR_3]);
VAR_24 |= VAR_0->arch.pv.gdt_ents != VAR_1(VAR_27);
VAR_24 |= VAR_0->arch.pv.ldt_base != VAR_1(VAR_13);
VAR_24 |= VAR_0->arch.pv.ldt_ents != VAR_1(VAR_15);
if ( VAR_24 )
return -VAR_28;
}
VAR_0->arch.pv.kernel_ss = VAR_1(VAR_29);
VAR_0->arch.pv.kernel_sp = VAR_1(VAR_30);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.ctrlreg); ++VAR_3 )
VAR_0->arch.pv.ctrlreg[VAR_3] = VAR_1(VAR_31[VAR_3]);
VAR_0->arch.pv.event_callback_eip = VAR_1(VAR_32);
VAR_0->arch.pv.failsafe_callback_eip = VAR_1(VAR_33);
if ( !VAR_5 )
{
VAR_0->arch.pv.syscall_callback_eip = VAR_1.nat->syscall_callback_eip;
VAR_0->arch.pv.fs_base =
!(VAR_0->arch.user_regs.fs & ~3) ? VAR_1.nat->fs_base : 0;
VAR_0->arch.pv.gs_base_kernel = VAR_1.nat->gs_base_kernel;
VAR_0->arch.pv.gs_base_user =
!(VAR_0->arch.user_regs.gs & ~3) ? VAR_1.nat->gs_base_user : 0;
}
else
{
VAR_0->arch.pv.event_callback_cs = VAR_1(VAR_34);
VAR_0->arch.pv.failsafe_callback_cs = VAR_1(VAR_35);
}
VAR_0->arch.pv.ctrlreg[0] &= VAR_36;
VAR_0->arch.pv.ctrlreg[0] |= read_cr0() & ~VAR_36;
VAR_9 = VAR_0->arch.pv.ctrlreg[4];
VAR_0->arch.pv.ctrlreg[4] = VAR_9 ? pv_guest_cr4_fixup(VAR_0, VAR_9) :
real_cr4_to_pv_guest_cr4(VAR_37);
memset(VAR_0->arch.dr, 0, sizeof(VAR_0->arch.dr));
VAR_0->arch.dr6 = VAR_38;
VAR_0->arch.dr7 = VAR_39;
VAR_0->arch.pv.dr7_emul = 0;
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); VAR_3++ )
set_debugreg(VAR_0, VAR_3, VAR_1(VAR_20[VAR_3]));
set_debugreg(VAR_0, 6, VAR_1(VAR_20[6]));
set_debugreg(VAR_0, 7, VAR_1(VAR_20[7]));
if ( VAR_0->is_initialised )
goto out;
if ( VAR_0->vcpu_id == 0 )
{
if ( VAR_2 != VAR_40->domain && !VM_ASSIST(VAR_2, VAR_41) &&
is_pv_domain(VAR_2) && !is_pv_32bit_domain(VAR_2) &&
test_bit(VAR_42, &VAR_1.nat->vm_assist) &&
atomic_read(&VAR_2->arch.pv.nr_l4_pages) )
{
bool VAR_43 = false;
spin_lock_recursive(&VAR_2->page_alloc_lock);
for ( VAR_3 = 0; ; )
{
struct page_info *VAR_44 = page_list_remove_head(&VAR_2->page_list);
if ( page_lock(VAR_44) )
{
if ( (VAR_44->u.inuse.type_info & VAR_45) ==
VAR_46 )
VAR_43 = !fill_ro_mpt(page_to_mfn(VAR_44));
page_unlock(VAR_44);
}
page_list_add_tail(VAR_44, &VAR_2->page_list);
if ( VAR_43 || (!(++VAR_3 & 0xff) && hypercall_preempt_check()) )
break;
}
spin_unlock_recursive(&VAR_2->page_alloc_lock);
if ( !VAR_43 )
return -VAR_47;
}
VAR_2->vm_assist = VAR_1(VAR_48);
}
VAR_10 = put_old_guest_table(VAR_40);
if ( VAR_10 )
return VAR_10;
if ( !VAR_5 )
VAR_10 = (int)pv_set_gdt(VAR_0, VAR_1.nat->gdt_frames, VAR_1.nat->gdt_ents);
else
{
unsigned long VAR_26[ARRAY_SIZE(VAR_0->arch.pv.gdt_frames)];
unsigned int VAR_49 = DIV_ROUND_UP(VAR_1.cmp->gdt_ents, 512);
if ( VAR_49 > ARRAY_SIZE(VAR_0->arch.pv.gdt_frames) )
return -VAR_12;
for ( VAR_3 = 0; VAR_3 < VAR_49; ++VAR_3 )
VAR_26[VAR_3] = VAR_1.cmp->gdt_frames[VAR_3];
VAR_10 = (int)pv_set_gdt(VAR_0, VAR_26, VAR_1.cmp->gdt_ents);
}
if ( VAR_10 != 0 )
return VAR_10;
set_bit(VAR_50, &VAR_0->pause_flags);
if ( !VAR_5 )
VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[3]);
else
VAR_7 = compat_cr3_to_pfn(VAR_1.cmp->ctrlreg[3]);
VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_51);
if ( !VAR_8 )
VAR_10 = -VAR_12;
else if ( paging_mode_refcounts(VAR_2) )
;
else if ( VAR_8 == VAR_0->arch.old_guest_table )
{
VAR_0->arch.old_guest_table = NULL;
put_page(VAR_8);
}
else
{
if ( !VAR_5 )
VAR_10 = put_old_guest_table(VAR_0);
if ( !VAR_10 )
VAR_10 = get_page_type_preemptible(VAR_8,
!VAR_5 ? VAR_52
: VAR_53);
switch ( VAR_10 )
{
case -VAR_54:
VAR_10 = -VAR_47;
case -VAR_47:
break;
case 0:
if ( !VAR_5 && !VM_ASSIST(VAR_2, VAR_41) &&
!paging_mode_refcounts(VAR_2) )
fill_ro_mpt(_mfn(VAR_7));
break;
default:
if ( VAR_8 == VAR_40->arch.old_guest_table )
VAR_8 = NULL;
break;
}
}
if ( VAR_10 )
;
else if ( !VAR_5 )
{
VAR_0->arch.guest_table = pagetable_from_page(VAR_8);
if ( VAR_1.nat->ctrlreg[1] )
{
VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[1]);
VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_51);
if ( !VAR_8 )
VAR_10 = -VAR_12;
else if ( !paging_mode_refcounts(VAR_2) )
{
VAR_10 = get_page_type_preemptible(VAR_8, VAR_52);
switch ( VAR_10 )
{
case -VAR_54:
VAR_10 = -VAR_47;
case -VAR_47:
VAR_0->arch.old_guest_ptpg = NULL;
VAR_0->arch.old_guest_table =
pagetable_get_page(VAR_0->arch.guest_table);
VAR_0->arch.guest_table = pagetable_null();
break;
default:
if ( VAR_8 == VAR_40->arch.old_guest_table )
VAR_8 = NULL;
break;
case 0:
if ( VM_ASSIST(VAR_2, VAR_41) )
zap_ro_mpt(_mfn(VAR_7));
break;
}
}
if ( !VAR_10 )
VAR_0->arch.guest_table_user = pagetable_from_page(VAR_8);
}
}
else
{
l4_pgentry_t *VAR_25;
VAR_25 = map_domain_page(pagetable_get_mfn(VAR_0->arch.guest_table));
*VAR_25 = l4e_from_mfn(page_to_mfn(VAR_8),
VAR_55|VAR_56|VAR_57|VAR_58);
unmap_domain_page(VAR_25);
}
if ( VAR_10 )
{
if ( VAR_8 )
put_page(VAR_8);
pv_destroy_gdt(VAR_0);
return VAR_10;
}
clear_bit(VAR_50, &VAR_0->pause_flags);
if ( VAR_0->vcpu_id == 0 )
update_domain_wallclock_time(VAR_2);
VAR_0->is_initialised = 1;
if ( paging_mode_enabled(VAR_2) )
paging_update_paging_modes(VAR_0);
update_cr3(VAR_0);
#endif 
out:
if ( VAR_4 & VAR_59 )
clear_bit(VAR_60, &VAR_0->pause_flags);
else
set_bit(VAR_60, &VAR_0->pause_flags);
return 0;
#undef c
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/domain.c/vul/before/0.json,"int arch_set_info_guest(
    struct vcpu *v, vcpu_guest_context_u c)
{
    struct domain *d = v->domain;
    unsigned int i;
    unsigned long flags;
    bool compat;
#ifdef CONFIG_PV
    unsigned long cr3_gfn;
    struct page_info *cr3_page;
    int rc = 0;
#endif

    /* The context is a compat-mode one if the target domain is compat-mode;
     * we expect the tools to DTRT even in compat-mode callers. */
    compat = is_pv_32bit_domain(d);

#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))
    flags = c(flags);

    if ( is_pv_domain(d) )
    {
        if ( !compat )
        {
            if ( !is_canonical_address(c.nat->user_regs.rip) ||
                 !is_canonical_address(c.nat->user_regs.rsp) ||
                 !is_canonical_address(c.nat->kernel_sp) ||
                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||
                 !is_canonical_address(c.nat->fs_base) ||
                 !is_canonical_address(c.nat->gs_base_kernel) ||
                 !is_canonical_address(c.nat->gs_base_user) ||
                 !is_canonical_address(c.nat->event_callback_eip) ||
                 !is_canonical_address(c.nat->syscall_callback_eip) ||
                 !is_canonical_address(c.nat->failsafe_callback_eip) )
                return -EINVAL;

            fixup_guest_stack_selector(d, c.nat->user_regs.ss);
            fixup_guest_stack_selector(d, c.nat->kernel_ss);
            fixup_guest_code_selector(d, c.nat->user_regs.cs);

            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )
            {
                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )
                    return -EINVAL;
                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);
            }

            if ( !__addr_ok(c.nat->ldt_base) )
                return -EINVAL;
        }
        else
        {
            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);
            fixup_guest_stack_selector(d, c.cmp->kernel_ss);
            fixup_guest_code_selector(d, c.cmp->user_regs.cs);
            fixup_guest_code_selector(d, c.cmp->event_callback_cs);
            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);

            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )
                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);
        }

        /* LDT safety checks. */
        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||
             (c(ldt_ents) > 8192) )
            return -EINVAL;
    }

    v->arch.flags &= ~TF_kernel_mode;
    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )
        v->arch.flags |= TF_kernel_mode;

    v->arch.vgc_flags = flags;

    vcpu_setup_fpu(v, v->arch.xsave_area,
                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,
                   FCW_DEFAULT);

    if ( !compat )
    {
        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));
        if ( is_pv_domain(d) )
            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,
                   sizeof(c.nat->trap_ctxt));
    }
    else
    {
        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);
        if ( is_pv_domain(d) )
        {
            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )
                XLAT_trap_info(v->arch.pv.trap_ctxt + i,
                               c.cmp->trap_ctxt + i);
        }
    }

    if ( is_hvm_domain(d) )
    {
        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )
            v->arch.dr[i] = c(debugreg[i]);
        v->arch.dr6 = c(debugreg[6]);
        v->arch.dr7 = c(debugreg[7]);

        hvm_set_info_guest(v);
        goto out;
    }

#ifdef CONFIG_PV
    /* IOPL privileges are virtualised. */
    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;
    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;

    /* Ensure real hardware interrupts are enabled. */
    v->arch.user_regs.eflags |= X86_EFLAGS_IF;

    if ( !v->is_initialised )
    {
        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )
            return -EINVAL;

        v->arch.pv.ldt_base = c(ldt_base);
        v->arch.pv.ldt_ents = c(ldt_ents);
    }
    else
    {
        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);
        bool fail;

        if ( !compat )
        {
            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];
            if ( pagetable_is_null(v->arch.guest_table_user) )
                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);
            else
            {
                pfn = pagetable_get_pfn(v->arch.guest_table_user);
                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];
            }
        } else {
            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));

            pfn = l4e_get_pfn(*l4tab);
            unmap_domain_page(l4tab);
            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];
        }

        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )
            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);
        fail |= v->arch.pv.gdt_ents != c(gdt_ents);

        fail |= v->arch.pv.ldt_base != c(ldt_base);
        fail |= v->arch.pv.ldt_ents != c(ldt_ents);

        if ( fail )
           return -EOPNOTSUPP;
    }

    v->arch.pv.kernel_ss = c(kernel_ss);
    v->arch.pv.kernel_sp = c(kernel_sp);
    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )
        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);

    v->arch.pv.event_callback_eip = c(event_callback_eip);
    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);
    if ( !compat )
    {
        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;
        /* non-nul selector kills fs_base */
        v->arch.pv.fs_base =
            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;
        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;
        /* non-nul selector kills gs_base_user */
        v->arch.pv.gs_base_user =
            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;
    }
    else
    {
        v->arch.pv.event_callback_cs = c(event_callback_cs);
        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);
    }

    /* Only CR0.TS is modifiable by guest or admin. */
    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;

    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);

    memset(v->arch.dr, 0, sizeof(v->arch.dr));
    v->arch.dr6 = X86_DR6_DEFAULT;
    v->arch.dr7 = X86_DR7_DEFAULT;
    v->arch.pv.dr7_emul = 0;

    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )
        set_debugreg(v, i, c(debugreg[i]));
    set_debugreg(v, 6, c(debugreg[6]));
    set_debugreg(v, 7, c(debugreg[7]));

    if ( v->is_initialised )
        goto out;

    if ( v->vcpu_id == 0 )
    {
        /*
         * In the restore case we need to deal with L4 pages which got
         * initialized with m2p_strict still clear (and which hence lack the
         * correct initial RO_MPT_VIRT_{START,END} L4 entry).
         */
        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&
             is_pv_domain(d) && !is_pv_32bit_domain(d) &&
             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&
             atomic_read(&d->arch.pv.nr_l4_pages) )
        {
            bool done = false;

            spin_lock_recursive(&d->page_alloc_lock);

            for ( i = 0; ; )
            {
                struct page_info *page = page_list_remove_head(&d->page_list);

                if ( page_lock(page) )
                {
                    if ( (page->u.inuse.type_info & PGT_type_mask) ==
                         PGT_l4_page_table )
                        done = !fill_ro_mpt(page_to_mfn(page));

                    page_unlock(page);
                }

                page_list_add_tail(page, &d->page_list);

                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )
                    break;
            }

            spin_unlock_recursive(&d->page_alloc_lock);

            if ( !done )
                return -ERESTART;
        }

        d->vm_assist = c(vm_assist);
    }

    rc = put_old_guest_table(current);
    if ( rc )
        return rc;

    if ( !compat )
        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);
    else
    {
        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];
        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);

        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )
            return -EINVAL;

        for ( i = 0; i < nr_frames; ++i )
            gdt_frames[i] = c.cmp->gdt_frames[i];

        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);
    }
    if ( rc != 0 )
        return rc;

    set_bit(_VPF_in_reset, &v->pause_flags);

    if ( !compat )
        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);
    else
        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);
    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);

    if ( !cr3_page )
        rc = -EINVAL;
    else if ( paging_mode_refcounts(d) )
        /* nothing */;
    else if ( cr3_page == v->arch.old_guest_table )
    {
        v->arch.old_guest_table = NULL;
        put_page(cr3_page);
    }
    else
    {
        if ( !compat )
            rc = put_old_guest_table(v);
        if ( !rc )
            rc = get_page_type_preemptible(cr3_page,
                                           !compat ? PGT_root_page_table
                                                   : PGT_l3_page_table);
        switch ( rc )
        {
        case -EINTR:
            rc = -ERESTART;
        case -ERESTART:
            break;
        case 0:
            if ( !compat && !VM_ASSIST(d, m2p_strict) &&
                 !paging_mode_refcounts(d) )
                fill_ro_mpt(_mfn(cr3_gfn));
            break;
        default:
            if ( cr3_page == current->arch.old_guest_table )
                cr3_page = NULL;
            break;
        }
    }
    if ( rc )
        /* handled below */;
    else if ( !compat )
    {
        v->arch.guest_table = pagetable_from_page(cr3_page);
        if ( c.nat->ctrlreg[1] )
        {
            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);
            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);

            if ( !cr3_page )
                rc = -EINVAL;
            else if ( !paging_mode_refcounts(d) )
            {
                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);
                switch ( rc )
                {
                case -EINTR:
                    rc = -ERESTART;
                    /* Fallthrough */
                case -ERESTART:
                    v->arch.old_guest_ptpg = NULL;
                    v->arch.old_guest_table =
                        pagetable_get_page(v->arch.guest_table);
                    v->arch.guest_table = pagetable_null();
                    break;
                default:
                    if ( cr3_page == current->arch.old_guest_table )
                        cr3_page = NULL;
                    break;
                case 0:
                    if ( VM_ASSIST(d, m2p_strict) )
                        zap_ro_mpt(_mfn(cr3_gfn));
                    break;
                }
            }
            if ( !rc )
               v->arch.guest_table_user = pagetable_from_page(cr3_page);
        }
    }
    else
    {
        l4_pgentry_t *l4tab;

        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));
        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),
            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);
        unmap_domain_page(l4tab);
    }
    if ( rc )
    {
        if ( cr3_page )
            put_page(cr3_page);
        pv_destroy_gdt(v);
        return rc;
    }

    clear_bit(_VPF_in_reset, &v->pause_flags);

    if ( v->vcpu_id == 0 )
        update_domain_wallclock_time(d);

    /* Don't redo final setup */
    v->is_initialised = 1;

    if ( paging_mode_enabled(d) )
        paging_update_paging_modes(v);

    update_cr3(v);
#endif /* CONFIG_PV */

 out:
    if ( flags & VGCF_online )
        clear_bit(_VPF_down, &v->pause_flags);
    else
        set_bit(_VPF_down, &v->pause_flags);
    return 0;
#undef c
}","int arch_set_info_guest(
    struct vcpu *VAR_0, vcpu_guest_context_u VAR_1)
{
    struct domain *VAR_2 = VAR_0->domain;
    unsigned int VAR_3;
    unsigned long VAR_4;
    bool VAR_5;
#ifdef VAR_6
    unsigned long VAR_7;
    struct page_info *VAR_8;
    int VAR_9 = 0;
#endif

    /* COMMENT_0 */
                                                                  
    VAR_5 = is_pv_32bit_domain(VAR_2);

#define VAR_1(VAR_10) (compat ? (c.cmp->fld) : (c.nat->fld))
    VAR_4 = VAR_1(VAR_4);

    if ( is_pv_domain(VAR_2) )
    {
        if ( !VAR_5 )
        {
            if ( !is_canonical_address(VAR_1.nat->user_regs.rip) ||
                 !is_canonical_address(VAR_1.nat->user_regs.rsp) ||
                 !is_canonical_address(VAR_1.nat->kernel_sp) ||
                 (VAR_1.nat->ldt_ents && !is_canonical_address(VAR_1.nat->ldt_base)) ||
                 !is_canonical_address(VAR_1.nat->fs_base) ||
                 !is_canonical_address(VAR_1.nat->gs_base_kernel) ||
                 !is_canonical_address(VAR_1.nat->gs_base_user) ||
                 !is_canonical_address(VAR_1.nat->event_callback_eip) ||
                 !is_canonical_address(VAR_1.nat->syscall_callback_eip) ||
                 !is_canonical_address(VAR_1.nat->failsafe_callback_eip) )
                return -VAR_11;

            fixup_guest_stack_selector(VAR_2, VAR_1.nat->user_regs.ss);
            fixup_guest_stack_selector(VAR_2, VAR_1.nat->kernel_ss);
            fixup_guest_code_selector(VAR_2, VAR_1.nat->user_regs.cs);

            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.nat->trap_ctxt); VAR_3++ )
            {
                if ( !is_canonical_address(VAR_1.nat->trap_ctxt[VAR_3].address) )
                    return -VAR_11;
                fixup_guest_code_selector(VAR_2, VAR_1.nat->trap_ctxt[VAR_3].cs);
            }

            if ( !__addr_ok(VAR_1.nat->ldt_base) )
                return -VAR_11;
        }
        else
        {
            fixup_guest_stack_selector(VAR_2, VAR_1.cmp->user_regs.ss);
            fixup_guest_stack_selector(VAR_2, VAR_1.cmp->kernel_ss);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->user_regs.cs);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->event_callback_cs);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->failsafe_callback_cs);

            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); VAR_3++ )
                fixup_guest_code_selector(VAR_2, VAR_1.cmp->trap_ctxt[VAR_3].cs);
        }

        /* COMMENT_2 */
        if ( ((VAR_1(VAR_12) & (VAR_13 - 1)) != 0) ||
             (VAR_1(VAR_14) > 8192) )
            return -VAR_11;
    }

    VAR_0->arch.flags &= ~VAR_15;
    if ( (VAR_4 & VAR_16) || is_hvm_domain(VAR_2)/* COMMENT_3 */ )
        VAR_0->arch.flags |= VAR_15;

    VAR_0->arch.vgc_flags = VAR_4;

    vcpu_setup_fpu(VAR_0, VAR_0->arch.xsave_area,
                   VAR_4 & VAR_17 ? &VAR_1.nat->fpu_ctxt : NULL,
                   VAR_18);

    if ( !VAR_5 )
    {
        memcpy(&VAR_0->arch.user_regs, &VAR_1.nat->user_regs, sizeof(VAR_1.nat->user_regs));
        if ( is_pv_domain(VAR_2) )
            memcpy(VAR_0->arch.pv.trap_ctxt, VAR_1.nat->trap_ctxt,
                   sizeof(VAR_1.nat->trap_ctxt));
    }
    else
    {
        XLAT_cpu_user_regs(&VAR_0->arch.user_regs, &VAR_1.cmp->user_regs);
        if ( is_pv_domain(VAR_2) )
        {
            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); ++VAR_3 )
                XLAT_trap_info(VAR_0->arch.pv.trap_ctxt + VAR_3,
                               VAR_1.cmp->trap_ctxt + VAR_3);
        }
    }

    if ( is_hvm_domain(VAR_2) )
    {
        for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); ++VAR_3 )
            VAR_0->arch.dr[VAR_3] = VAR_1(VAR_19[VAR_3]);
        VAR_0->arch.dr6 = VAR_1(VAR_19[6]);
        VAR_0->arch.dr7 = VAR_1(VAR_19[7]);

        hvm_set_info_guest(VAR_0);
        goto out;
    }

#ifdef VAR_6
    /* COMMENT_4 */
    VAR_0->arch.pv.iopl = VAR_0->arch.user_regs.eflags & VAR_20;
    VAR_0->arch.user_regs.eflags &= ~VAR_20;

    /* COMMENT_5 */
    VAR_0->arch.user_regs.eflags |= VAR_21;

    if ( !VAR_0->is_initialised )
    {
        if ( !VAR_5 && !(VAR_4 & VAR_16) && !VAR_1.nat->ctrlreg[1] )
            return -VAR_11;

        VAR_0->arch.pv.ldt_base = VAR_1(VAR_12);
        VAR_0->arch.pv.ldt_ents = VAR_1(VAR_14);
    }
    else
    {
        unsigned long VAR_22 = pagetable_get_pfn(VAR_0->arch.guest_table);
        bool VAR_23;

        if ( !VAR_5 )
        {
            VAR_23 = xen_pfn_to_cr3(VAR_22) != VAR_1.nat->ctrlreg[3];
            if ( pagetable_is_null(VAR_0->arch.guest_table_user) )
                VAR_23 |= VAR_1.nat->ctrlreg[1] || !(VAR_4 & VAR_16);
            else
            {
                VAR_22 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
                VAR_23 |= xen_pfn_to_cr3(VAR_22) != VAR_1.nat->ctrlreg[1];
            }
        } else {
            l4_pgentry_t *VAR_24 = map_domain_page(_mfn(VAR_22));

            VAR_22 = l4e_get_pfn(*VAR_24);
            unmap_domain_page(VAR_24);
            VAR_23 = compat_pfn_to_cr3(VAR_22) != VAR_1.cmp->ctrlreg[3];
        }

        for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.gdt_frames); ++VAR_3 )
            VAR_23 |= VAR_0->arch.pv.gdt_frames[VAR_3] != VAR_1(VAR_25[VAR_3]);
        VAR_23 |= VAR_0->arch.pv.gdt_ents != VAR_1(VAR_26);

        VAR_23 |= VAR_0->arch.pv.ldt_base != VAR_1(VAR_12);
        VAR_23 |= VAR_0->arch.pv.ldt_ents != VAR_1(VAR_14);

        if ( VAR_23 )
           return -VAR_27;
    }

    VAR_0->arch.pv.kernel_ss = VAR_1(VAR_28);
    VAR_0->arch.pv.kernel_sp = VAR_1(VAR_29);
    for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.ctrlreg); ++VAR_3 )
        VAR_0->arch.pv.ctrlreg[VAR_3] = VAR_1(VAR_30[VAR_3]);

    VAR_0->arch.pv.event_callback_eip = VAR_1(VAR_31);
    VAR_0->arch.pv.failsafe_callback_eip = VAR_1(VAR_32);
    if ( !VAR_5 )
    {
        VAR_0->arch.pv.syscall_callback_eip = VAR_1.nat->syscall_callback_eip;
        /* COMMENT_6 */
        VAR_0->arch.pv.fs_base =
            !(VAR_0->arch.user_regs.fs & ~3) ? VAR_1.nat->fs_base : 0;
        VAR_0->arch.pv.gs_base_kernel = VAR_1.nat->gs_base_kernel;
        /* COMMENT_7 */
        VAR_0->arch.pv.gs_base_user =
            !(VAR_0->arch.user_regs.gs & ~3) ? VAR_1.nat->gs_base_user : 0;
    }
    else
    {
        VAR_0->arch.pv.event_callback_cs = VAR_1(VAR_33);
        VAR_0->arch.pv.failsafe_callback_cs = VAR_1(VAR_34);
    }

    /* COMMENT_8 */
    VAR_0->arch.pv.ctrlreg[0] &= VAR_35;
    VAR_0->arch.pv.ctrlreg[0] |= read_cr0() & ~VAR_35;

    VAR_0->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_0, VAR_0->arch.pv.ctrlreg[4]);

    memset(VAR_0->arch.dr, 0, sizeof(VAR_0->arch.dr));
    VAR_0->arch.dr6 = VAR_36;
    VAR_0->arch.dr7 = VAR_37;
    VAR_0->arch.pv.dr7_emul = 0;

    for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); VAR_3++ )
        set_debugreg(VAR_0, VAR_3, VAR_1(VAR_19[VAR_3]));
    set_debugreg(VAR_0, 6, VAR_1(VAR_19[6]));
    set_debugreg(VAR_0, 7, VAR_1(VAR_19[7]));

    if ( VAR_0->is_initialised )
        goto out;

    if ( VAR_0->vcpu_id == 0 )
    {
        /* COMMENT_9 */
                                                                      
                                                                            
                                                             
           
        if ( VAR_2 != VAR_38->domain && !VM_ASSIST(VAR_2, VAR_39) &&
             is_pv_domain(VAR_2) && !is_pv_32bit_domain(VAR_2) &&
             test_bit(VAR_40, &VAR_1.nat->vm_assist) &&
             atomic_read(&VAR_2->arch.pv.nr_l4_pages) )
        {
            bool VAR_41 = false;

            spin_lock_recursive(&VAR_2->page_alloc_lock);

            for ( VAR_3 = 0; ; )
            {
                struct page_info *VAR_42 = page_list_remove_head(&VAR_2->page_list);

                if ( page_lock(VAR_42) )
                {
                    if ( (VAR_42->u.inuse.type_info & VAR_43) ==
                         VAR_44 )
                        VAR_41 = !fill_ro_mpt(page_to_mfn(VAR_42));

                    page_unlock(VAR_42);
                }

                page_list_add_tail(VAR_42, &VAR_2->page_list);

                if ( VAR_41 || (!(++VAR_3 & 0xff) && hypercall_preempt_check()) )
                    break;
            }

            spin_unlock_recursive(&VAR_2->page_alloc_lock);

            if ( !VAR_41 )
                return -VAR_45;
        }

        VAR_2->vm_assist = VAR_1(VAR_46);
    }

    VAR_9 = put_old_guest_table(VAR_38);
    if ( VAR_9 )
        return VAR_9;

    if ( !VAR_5 )
        VAR_9 = (int)pv_set_gdt(VAR_0, VAR_1.nat->gdt_frames, VAR_1.nat->gdt_ents);
    else
    {
        unsigned long VAR_25[ARRAY_SIZE(VAR_0->arch.pv.gdt_frames)];
        unsigned int VAR_47 = DIV_ROUND_UP(VAR_1.cmp->gdt_ents, 512);

        if ( VAR_47 > ARRAY_SIZE(VAR_0->arch.pv.gdt_frames) )
            return -VAR_11;

        for ( VAR_3 = 0; VAR_3 < VAR_47; ++VAR_3 )
            VAR_25[VAR_3] = VAR_1.cmp->gdt_frames[VAR_3];

        VAR_9 = (int)pv_set_gdt(VAR_0, VAR_25, VAR_1.cmp->gdt_ents);
    }
    if ( VAR_9 != 0 )
        return VAR_9;

    set_bit(VAR_48, &VAR_0->pause_flags);

    if ( !VAR_5 )
        VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[3]);
    else
        VAR_7 = compat_cr3_to_pfn(VAR_1.cmp->ctrlreg[3]);
    VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_49);

    if ( !VAR_8 )
        VAR_9 = -VAR_11;
    else if ( paging_mode_refcounts(VAR_2) )
        /* COMMENT_14 */;
    else if ( VAR_8 == VAR_0->arch.old_guest_table )
    {
        VAR_0->arch.old_guest_table = NULL;
        put_page(VAR_8);
    }
    else
    {
        if ( !VAR_5 )
            VAR_9 = put_old_guest_table(VAR_0);
        if ( !VAR_9 )
            VAR_9 = get_page_type_preemptible(VAR_8,
                                           !VAR_5 ? VAR_50
                                                   : VAR_51);
        switch ( VAR_9 )
        {
        case -VAR_52:
            VAR_9 = -VAR_45;
        case -VAR_45:
            break;
        case 0:
            if ( !VAR_5 && !VM_ASSIST(VAR_2, VAR_39) &&
                 !paging_mode_refcounts(VAR_2) )
                fill_ro_mpt(_mfn(VAR_7));
            break;
        default:
            if ( VAR_8 == VAR_38->arch.old_guest_table )
                VAR_8 = NULL;
            break;
        }
    }
    if ( VAR_9 )
        /* COMMENT_15 */;
    else if ( !VAR_5 )
    {
        VAR_0->arch.guest_table = pagetable_from_page(VAR_8);
        if ( VAR_1.nat->ctrlreg[1] )
        {
            VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[1]);
            VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_49);

            if ( !VAR_8 )
                VAR_9 = -VAR_11;
            else if ( !paging_mode_refcounts(VAR_2) )
            {
                VAR_9 = get_page_type_preemptible(VAR_8, VAR_50);
                switch ( VAR_9 )
                {
                case -VAR_52:
                    VAR_9 = -VAR_45;
                    /* COMMENT_16 */
                case -VAR_45:
                    VAR_0->arch.old_guest_ptpg = NULL;
                    VAR_0->arch.old_guest_table =
                        pagetable_get_page(VAR_0->arch.guest_table);
                    VAR_0->arch.guest_table = pagetable_null();
                    break;
                default:
                    if ( VAR_8 == VAR_38->arch.old_guest_table )
                        VAR_8 = NULL;
                    break;
                case 0:
                    if ( VM_ASSIST(VAR_2, VAR_39) )
                        zap_ro_mpt(_mfn(VAR_7));
                    break;
                }
            }
            if ( !VAR_9 )
               VAR_0->arch.guest_table_user = pagetable_from_page(VAR_8);
        }
    }
    else
    {
        l4_pgentry_t *VAR_24;

        VAR_24 = map_domain_page(pagetable_get_mfn(VAR_0->arch.guest_table));
        *VAR_24 = l4e_from_mfn(page_to_mfn(VAR_8),
            VAR_53|VAR_54|VAR_55|VAR_56);
        unmap_domain_page(VAR_24);
    }
    if ( VAR_9 )
    {
        if ( VAR_8 )
            put_page(VAR_8);
        pv_destroy_gdt(VAR_0);
        return VAR_9;
    }

    clear_bit(VAR_48, &VAR_0->pause_flags);

    if ( VAR_0->vcpu_id == 0 )
        update_domain_wallclock_time(VAR_2);

    /* COMMENT_17 */
    VAR_0->is_initialised = 1;

    if ( paging_mode_enabled(VAR_2) )
        paging_update_paging_modes(VAR_0);

    update_cr3(VAR_0);
#endif /* COMMENT_18 */

 out:
    if ( VAR_4 & VAR_57 )
        clear_bit(VAR_58, &VAR_0->pause_flags);
    else
        set_bit(VAR_58, &VAR_0->pause_flags);
    return 0;
#undef c
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,6 @@
 #ifdef CONFIG_PV
     unsigned long cr3_gfn;
     struct page_info *cr3_page;
-    unsigned long cr4;
     int rc = 0;
 #endif
 
@@ -184,9 +183,7 @@
     v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
     v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;
 
-    cr4 = v->arch.pv.ctrlreg[4];
-    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :
-        real_cr4_to_pv_guest_cr4(mmu_cr4_features);
+    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);
 
     memset(v->arch.dr, 0, sizeof(v->arch.dr));
     v->arch.dr6 = X86_DR6_DEFAULT;","{'deleted_lines': ['    unsigned long cr4;', '    cr4 = v->arch.pv.ctrlreg[4];', '    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :', '        real_cr4_to_pv_guest_cr4(mmu_cr4_features);'], 'added_lines': ['    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:53:32Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Rewrite guest %cr4 handling from scratch

The PV cr4 logic is almost impossible to follow, and leaks bits into guest
context which definitely shouldn't be visible (in particular, VMXE).

The biggest problem however, and source of the complexity, is that it derives
new real and guest cr4 values from the current value in hardware - this is
context dependent and an inappropriate source of information.

Rewrite the cr4 logic to be invariant of the current value in hardware.

First of all, modify write_ptbase() to always use mmu_cr4_features for IDLE
and HVM contexts.  mmu_cr4_features *is* the correct value to use, and makes
the ASSERT() obviously redundant.

For PV guests, curr->arch.pv.ctrlreg[4] remains the guests view of cr4, but
all logic gets reworked in terms of this and mmu_cr4_features only.

Two masks are introduced; bits which the guest has control over, and bits
which are forwarded from Xen's settings.  One guest-visible change here is
that Xen's VMXE setting is no longer visible at all.

pv_make_cr4() follows fairly closely from pv_guest_cr4_to_real_cr4(), but
deliberately starts with mmu_cr4_features, and only alters the minimal subset
of bits.

The boot-time {compat_,}pv_cr4_mask variables are removed, as they are a
remnant of the pre-CPUID policy days.  pv_fixup_guest_cr4() gains a related
derivation from the policy.

Another guest visible change here is that a 32bit PV guest can now flip
FSGSBASE in its view of CR4.  While the {RD,WR}{FS,GS}BASE instructions are
unusable outside of a 64bit code segment, the ability to modify FSGSBASE
matches real hardware behaviour, and avoids the need for any 32bit/64bit
differences in the logic.

Overall, this patch shouldn't have a practical change in guest behaviour.
VMXE will disappear from view, and an inquisitive 32bit kernel can now see
FSGSBASE changing, but this new logic is otherwise bug-compatible with before.

This is part of XSA-293.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",b2dd00574a4fc87ca964177f8e752a968c27efb2,https://github.com/xen-project/xen/commit/b2dd00574a4fc87ca964177f8e752a968c27efb2,xen/arch/x86/pv/emul-priv-op.c,write_cr,"static int write_cr(unsigned int reg, unsigned long val,
struct x86_emulate_ctxt *ctxt)
{
struct vcpu *curr = current;
switch ( reg )
{
case 0: 
if ( (val ^ read_cr0()) & ~X86_CR0_TS )
{
gdprintk(XENLOG_WARNING,
""Attempt to change unmodifiable CR0 flags\n"");
break;
}
do_fpu_taskswitch(!!(val & X86_CR0_TS));
return X86EMUL_OKAY;
case 2: 
curr->arch.pv.ctrlreg[2] = val;
arch_set_cr2(curr, val);
return X86EMUL_OKAY;
case 3: 
{
struct domain *currd = curr->domain;
unsigned long gfn;
struct page_info *page;
int rc;
gfn = !is_pv_32bit_domain(currd)
? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);
page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);
if ( !page )
break;
rc = new_guest_cr3(page_to_mfn(page));
put_page(page);
switch ( rc )
{
case 0:
return X86EMUL_OKAY;
case -ERESTART: 
return X86EMUL_RETRY;
}
break;
}
case 4: 
curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);
write_cr4(pv_guest_cr4_to_real_cr4(curr));
ctxt_switch_levelling(curr);
return X86EMUL_OKAY;
}
return X86EMUL_UNHANDLEABLE;
}","static int write_cr(unsigned int VAR_0, unsigned long VAR_1,
struct x86_emulate_ctxt *VAR_2)
{
struct vcpu *VAR_3 = VAR_4;
switch ( VAR_0 )
{
case 0: 
if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )
{
gdprintk(VAR_6,
""Attempt to change unmodifiable CR0 flags\n"");
break;
}
do_fpu_taskswitch(!!(VAR_1 & VAR_5));
return VAR_7;
case 2: 
VAR_3->arch.pv.ctrlreg[2] = VAR_1;
arch_set_cr2(VAR_3, VAR_1);
return VAR_7;
case 3: 
{
struct domain *VAR_8 = VAR_3->domain;
unsigned long VAR_9;
struct page_info *VAR_10;
int VAR_11;
VAR_9 = !is_pv_32bit_domain(VAR_8)
? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);
VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);
if ( !VAR_10 )
break;
VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));
put_page(VAR_10);
switch ( VAR_11 )
{
case 0:
return VAR_7;
case -VAR_13: 
return VAR_14;
}
break;
}
case 4: 
VAR_3->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(VAR_3, VAR_1);
write_cr4(pv_guest_cr4_to_real_cr4(VAR_3));
ctxt_switch_levelling(VAR_3);
return VAR_7;
}
return VAR_15;
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/emul-priv-op.c/vul/before/0.json,"static int write_cr(unsigned int reg, unsigned long val,
                    struct x86_emulate_ctxt *ctxt)
{
    struct vcpu *curr = current;

    switch ( reg )
    {
    case 0: /* Write CR0 */
        if ( (val ^ read_cr0()) & ~X86_CR0_TS )
        {
            gdprintk(XENLOG_WARNING,
                     ""Attempt to change unmodifiable CR0 flags\n"");
            break;
        }
        do_fpu_taskswitch(!!(val & X86_CR0_TS));
        return X86EMUL_OKAY;

    case 2: /* Write CR2 */
        curr->arch.pv.ctrlreg[2] = val;
        arch_set_cr2(curr, val);
        return X86EMUL_OKAY;

    case 3: /* Write CR3 */
    {
        struct domain *currd = curr->domain;
        unsigned long gfn;
        struct page_info *page;
        int rc;

        gfn = !is_pv_32bit_domain(currd)
              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);
        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);
        if ( !page )
            break;
        rc = new_guest_cr3(page_to_mfn(page));
        put_page(page);

        switch ( rc )
        {
        case 0:
            return X86EMUL_OKAY;
        case -ERESTART: /* retry after preemption */
            return X86EMUL_RETRY;
        }
        break;
    }

    case 4: /* Write CR4 */
        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);
        write_cr4(pv_make_cr4(curr));
        ctxt_switch_levelling(curr);
        return X86EMUL_OKAY;
    }

    return X86EMUL_UNHANDLEABLE;
}","static int write_cr(unsigned int VAR_0, unsigned long VAR_1,
                    struct x86_emulate_ctxt *VAR_2)
{
    struct vcpu *VAR_3 = VAR_4;

    switch ( VAR_0 )
    {
    case 0: /* COMMENT_0 */
        if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )
        {
            gdprintk(VAR_6,
                     ""Attempt to change unmodifiable CR0 flags\n"");
            break;
        }
        do_fpu_taskswitch(!!(VAR_1 & VAR_5));
        return VAR_7;

    case 2: /* COMMENT_1 */
        VAR_3->arch.pv.ctrlreg[2] = VAR_1;
        arch_set_cr2(VAR_3, VAR_1);
        return VAR_7;

    case 3: /* COMMENT_2 */
    {
        struct domain *VAR_8 = VAR_3->domain;
        unsigned long VAR_9;
        struct page_info *VAR_10;
        int VAR_11;

        VAR_9 = !is_pv_32bit_domain(VAR_8)
              ? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);
        VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);
        if ( !VAR_10 )
            break;
        VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));
        put_page(VAR_10);

        switch ( VAR_11 )
        {
        case 0:
            return VAR_7;
        case -VAR_13: /* COMMENT_3 */
            return VAR_14;
        }
        break;
    }

    case 4: /* COMMENT_4 */
        VAR_3->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_3, VAR_1);
        write_cr4(pv_make_cr4(VAR_3));
        ctxt_switch_levelling(VAR_3);
        return VAR_7;
    }

    return VAR_15;
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/emul-priv-op.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,8 +46,8 @@
     }
 
     case 4: /* Write CR4 */
-        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);
-        write_cr4(pv_guest_cr4_to_real_cr4(curr));
+        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);
+        write_cr4(pv_make_cr4(curr));
         ctxt_switch_levelling(curr);
         return X86EMUL_OKAY;
     }","{'deleted_lines': ['        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);', '        write_cr4(pv_guest_cr4_to_real_cr4(curr));'], 'added_lines': ['        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);', '        write_cr4(pv_make_cr4(curr));']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:53:32Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Rewrite guest %cr4 handling from scratch

The PV cr4 logic is almost impossible to follow, and leaks bits into guest
context which definitely shouldn't be visible (in particular, VMXE).

The biggest problem however, and source of the complexity, is that it derives
new real and guest cr4 values from the current value in hardware - this is
context dependent and an inappropriate source of information.

Rewrite the cr4 logic to be invariant of the current value in hardware.

First of all, modify write_ptbase() to always use mmu_cr4_features for IDLE
and HVM contexts.  mmu_cr4_features *is* the correct value to use, and makes
the ASSERT() obviously redundant.

For PV guests, curr->arch.pv.ctrlreg[4] remains the guests view of cr4, but
all logic gets reworked in terms of this and mmu_cr4_features only.

Two masks are introduced; bits which the guest has control over, and bits
which are forwarded from Xen's settings.  One guest-visible change here is
that Xen's VMXE setting is no longer visible at all.

pv_make_cr4() follows fairly closely from pv_guest_cr4_to_real_cr4(), but
deliberately starts with mmu_cr4_features, and only alters the minimal subset
of bits.

The boot-time {compat_,}pv_cr4_mask variables are removed, as they are a
remnant of the pre-CPUID policy days.  pv_fixup_guest_cr4() gains a related
derivation from the policy.

Another guest visible change here is that a 32bit PV guest can now flip
FSGSBASE in its view of CR4.  While the {RD,WR}{FS,GS}BASE instructions are
unusable outside of a 64bit code segment, the ability to modify FSGSBASE
matches real hardware behaviour, and avoids the need for any 32bit/64bit
differences in the logic.

Overall, this patch shouldn't have a practical change in guest behaviour.
VMXE will disappear from view, and an inquisitive 32bit kernel can now see
FSGSBASE changing, but this new logic is otherwise bug-compatible with before.

This is part of XSA-293.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",b2dd00574a4fc87ca964177f8e752a968c27efb2,https://github.com/xen-project/xen/commit/b2dd00574a4fc87ca964177f8e752a968c27efb2,xen/arch/x86/pv/domain.c,arch_set_info_guest,"int arch_set_info_guest(
struct vcpu *v, vcpu_guest_context_u c)
{
struct domain *d = v->domain;
unsigned int i;
unsigned long flags;
bool compat;
#ifdef CONFIG_PV
unsigned long cr3_gfn;
struct page_info *cr3_page;
unsigned long cr4;
int rc = 0;
#endif
compat = is_pv_32bit_domain(d);
#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))
flags = c(flags);
if ( is_pv_domain(d) )
{
if ( !compat )
{
if ( !is_canonical_address(c.nat->user_regs.rip) ||
!is_canonical_address(c.nat->user_regs.rsp) ||
!is_canonical_address(c.nat->kernel_sp) ||
(c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||
!is_canonical_address(c.nat->fs_base) ||
!is_canonical_address(c.nat->gs_base_kernel) ||
!is_canonical_address(c.nat->gs_base_user) ||
!is_canonical_address(c.nat->event_callback_eip) ||
!is_canonical_address(c.nat->syscall_callback_eip) ||
!is_canonical_address(c.nat->failsafe_callback_eip) )
return -EINVAL;
fixup_guest_stack_selector(d, c.nat->user_regs.ss);
fixup_guest_stack_selector(d, c.nat->kernel_ss);
fixup_guest_code_selector(d, c.nat->user_regs.cs);
for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )
{
if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )
return -EINVAL;
fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);
}
if ( !__addr_ok(c.nat->ldt_base) )
return -EINVAL;
}
else
{
fixup_guest_stack_selector(d, c.cmp->user_regs.ss);
fixup_guest_stack_selector(d, c.cmp->kernel_ss);
fixup_guest_code_selector(d, c.cmp->user_regs.cs);
fixup_guest_code_selector(d, c.cmp->event_callback_cs);
fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);
for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )
fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);
}
if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||
(c(ldt_ents) > 8192) )
return -EINVAL;
}
v->arch.flags &= ~TF_kernel_mode;
if ( (flags & VGCF_in_kernel) || is_hvm_domain(d) )
v->arch.flags |= TF_kernel_mode;
v->arch.vgc_flags = flags;
vcpu_setup_fpu(v, v->arch.xsave_area,
flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,
FCW_DEFAULT);
if ( !compat )
{
memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));
if ( is_pv_domain(d) )
memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,
sizeof(c.nat->trap_ctxt));
}
else
{
XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);
if ( is_pv_domain(d) )
{
for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )
XLAT_trap_info(v->arch.pv.trap_ctxt + i,
c.cmp->trap_ctxt + i);
}
}
if ( is_hvm_domain(d) )
{
for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )
v->arch.dr[i] = c(debugreg[i]);
v->arch.dr6 = c(debugreg[6]);
v->arch.dr7 = c(debugreg[7]);
hvm_set_info_guest(v);
goto out;
}
#ifdef CONFIG_PV
v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;
v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;
v->arch.user_regs.eflags |= X86_EFLAGS_IF;
if ( !v->is_initialised )
{
if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )
return -EINVAL;
v->arch.pv.ldt_base = c(ldt_base);
v->arch.pv.ldt_ents = c(ldt_ents);
}
else
{
unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);
bool fail;
if ( !compat )
{
fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];
if ( pagetable_is_null(v->arch.guest_table_user) )
fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);
else
{
pfn = pagetable_get_pfn(v->arch.guest_table_user);
fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];
}
} else {
l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));
pfn = l4e_get_pfn(*l4tab);
unmap_domain_page(l4tab);
fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];
}
for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )
fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);
fail |= v->arch.pv.gdt_ents != c(gdt_ents);
fail |= v->arch.pv.ldt_base != c(ldt_base);
fail |= v->arch.pv.ldt_ents != c(ldt_ents);
if ( fail )
return -EOPNOTSUPP;
}
v->arch.pv.kernel_ss = c(kernel_ss);
v->arch.pv.kernel_sp = c(kernel_sp);
for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )
v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);
v->arch.pv.event_callback_eip = c(event_callback_eip);
v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);
if ( !compat )
{
v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;
v->arch.pv.fs_base =
!(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;
v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;
v->arch.pv.gs_base_user =
!(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;
}
else
{
v->arch.pv.event_callback_cs = c(event_callback_cs);
v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);
}
v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;
cr4 = v->arch.pv.ctrlreg[4];
v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :
real_cr4_to_pv_guest_cr4(mmu_cr4_features);
memset(v->arch.dr, 0, sizeof(v->arch.dr));
v->arch.dr6 = X86_DR6_DEFAULT;
v->arch.dr7 = X86_DR7_DEFAULT;
v->arch.pv.dr7_emul = 0;
for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )
set_debugreg(v, i, c(debugreg[i]));
set_debugreg(v, 6, c(debugreg[6]));
set_debugreg(v, 7, c(debugreg[7]));
if ( v->is_initialised )
goto out;
if ( v->vcpu_id == 0 )
{
if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&
is_pv_domain(d) && !is_pv_32bit_domain(d) &&
test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&
atomic_read(&d->arch.pv.nr_l4_pages) )
{
bool done = false;
spin_lock_recursive(&d->page_alloc_lock);
for ( i = 0; ; )
{
struct page_info *page = page_list_remove_head(&d->page_list);
if ( page_lock(page) )
{
if ( (page->u.inuse.type_info & PGT_type_mask) ==
PGT_l4_page_table )
done = !fill_ro_mpt(page_to_mfn(page));
page_unlock(page);
}
page_list_add_tail(page, &d->page_list);
if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )
break;
}
spin_unlock_recursive(&d->page_alloc_lock);
if ( !done )
return -ERESTART;
}
d->vm_assist = c(vm_assist);
}
rc = put_old_guest_table(current);
if ( rc )
return rc;
if ( !compat )
rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);
else
{
unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];
unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);
if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )
return -EINVAL;
for ( i = 0; i < nr_frames; ++i )
gdt_frames[i] = c.cmp->gdt_frames[i];
rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);
}
if ( rc != 0 )
return rc;
set_bit(_VPF_in_reset, &v->pause_flags);
if ( !compat )
cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);
else
cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);
cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);
if ( !cr3_page )
rc = -EINVAL;
else if ( paging_mode_refcounts(d) )
;
else if ( cr3_page == v->arch.old_guest_table )
{
v->arch.old_guest_table = NULL;
put_page(cr3_page);
}
else
{
if ( !compat )
rc = put_old_guest_table(v);
if ( !rc )
rc = get_page_type_preemptible(cr3_page,
!compat ? PGT_root_page_table
: PGT_l3_page_table);
switch ( rc )
{
case -EINTR:
rc = -ERESTART;
case -ERESTART:
break;
case 0:
if ( !compat && !VM_ASSIST(d, m2p_strict) &&
!paging_mode_refcounts(d) )
fill_ro_mpt(_mfn(cr3_gfn));
break;
default:
if ( cr3_page == current->arch.old_guest_table )
cr3_page = NULL;
break;
}
}
if ( rc )
;
else if ( !compat )
{
v->arch.guest_table = pagetable_from_page(cr3_page);
if ( c.nat->ctrlreg[1] )
{
cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);
cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);
if ( !cr3_page )
rc = -EINVAL;
else if ( !paging_mode_refcounts(d) )
{
rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);
switch ( rc )
{
case -EINTR:
rc = -ERESTART;
case -ERESTART:
v->arch.old_guest_ptpg = NULL;
v->arch.old_guest_table =
pagetable_get_page(v->arch.guest_table);
v->arch.guest_table = pagetable_null();
break;
default:
if ( cr3_page == current->arch.old_guest_table )
cr3_page = NULL;
break;
case 0:
if ( VM_ASSIST(d, m2p_strict) )
zap_ro_mpt(_mfn(cr3_gfn));
break;
}
}
if ( !rc )
v->arch.guest_table_user = pagetable_from_page(cr3_page);
}
}
else
{
l4_pgentry_t *l4tab;
l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));
*l4tab = l4e_from_mfn(page_to_mfn(cr3_page),
_PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);
unmap_domain_page(l4tab);
}
if ( rc )
{
if ( cr3_page )
put_page(cr3_page);
pv_destroy_gdt(v);
return rc;
}
clear_bit(_VPF_in_reset, &v->pause_flags);
if ( v->vcpu_id == 0 )
update_domain_wallclock_time(d);
v->is_initialised = 1;
if ( paging_mode_enabled(d) )
paging_update_paging_modes(v);
update_cr3(v);
#endif 
out:
if ( flags & VGCF_online )
clear_bit(_VPF_down, &v->pause_flags);
else
set_bit(_VPF_down, &v->pause_flags);
return 0;
#undef c
}","int arch_set_info_guest(
struct vcpu *VAR_0, vcpu_guest_context_u VAR_1)
{
struct domain *VAR_2 = VAR_0->domain;
unsigned int VAR_3;
unsigned long VAR_4;
bool VAR_5;
#ifdef VAR_6
unsigned long VAR_7;
struct page_info *VAR_8;
unsigned long VAR_9;
int VAR_10 = 0;
#endif
VAR_5 = is_pv_32bit_domain(VAR_2);
#define VAR_1(VAR_11) (compat ? (c.cmp->fld) : (c.nat->fld))
VAR_4 = VAR_1(VAR_4);
if ( is_pv_domain(VAR_2) )
{
if ( !VAR_5 )
{
if ( !is_canonical_address(VAR_1.nat->user_regs.rip) ||
!is_canonical_address(VAR_1.nat->user_regs.rsp) ||
!is_canonical_address(VAR_1.nat->kernel_sp) ||
(VAR_1.nat->ldt_ents && !is_canonical_address(VAR_1.nat->ldt_base)) ||
!is_canonical_address(VAR_1.nat->fs_base) ||
!is_canonical_address(VAR_1.nat->gs_base_kernel) ||
!is_canonical_address(VAR_1.nat->gs_base_user) ||
!is_canonical_address(VAR_1.nat->event_callback_eip) ||
!is_canonical_address(VAR_1.nat->syscall_callback_eip) ||
!is_canonical_address(VAR_1.nat->failsafe_callback_eip) )
return -VAR_12;
fixup_guest_stack_selector(VAR_2, VAR_1.nat->user_regs.ss);
fixup_guest_stack_selector(VAR_2, VAR_1.nat->kernel_ss);
fixup_guest_code_selector(VAR_2, VAR_1.nat->user_regs.cs);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.nat->trap_ctxt); VAR_3++ )
{
if ( !is_canonical_address(VAR_1.nat->trap_ctxt[VAR_3].address) )
return -VAR_12;
fixup_guest_code_selector(VAR_2, VAR_1.nat->trap_ctxt[VAR_3].cs);
}
if ( !__addr_ok(VAR_1.nat->ldt_base) )
return -VAR_12;
}
else
{
fixup_guest_stack_selector(VAR_2, VAR_1.cmp->user_regs.ss);
fixup_guest_stack_selector(VAR_2, VAR_1.cmp->kernel_ss);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->user_regs.cs);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->event_callback_cs);
fixup_guest_code_selector(VAR_2, VAR_1.cmp->failsafe_callback_cs);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); VAR_3++ )
fixup_guest_code_selector(VAR_2, VAR_1.cmp->trap_ctxt[VAR_3].cs);
}
if ( ((VAR_1(VAR_13) & (VAR_14 - 1)) != 0) ||
(VAR_1(VAR_15) > 8192) )
return -VAR_12;
}
VAR_0->arch.flags &= ~VAR_16;
if ( (VAR_4 & VAR_17) || is_hvm_domain(VAR_2) )
VAR_0->arch.flags |= VAR_16;
VAR_0->arch.vgc_flags = VAR_4;
vcpu_setup_fpu(VAR_0, VAR_0->arch.xsave_area,
VAR_4 & VAR_18 ? &VAR_1.nat->fpu_ctxt : NULL,
VAR_19);
if ( !VAR_5 )
{
memcpy(&VAR_0->arch.user_regs, &VAR_1.nat->user_regs, sizeof(VAR_1.nat->user_regs));
if ( is_pv_domain(VAR_2) )
memcpy(VAR_0->arch.pv.trap_ctxt, VAR_1.nat->trap_ctxt,
sizeof(VAR_1.nat->trap_ctxt));
}
else
{
XLAT_cpu_user_regs(&VAR_0->arch.user_regs, &VAR_1.cmp->user_regs);
if ( is_pv_domain(VAR_2) )
{
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); ++VAR_3 )
XLAT_trap_info(VAR_0->arch.pv.trap_ctxt + VAR_3,
VAR_1.cmp->trap_ctxt + VAR_3);
}
}
if ( is_hvm_domain(VAR_2) )
{
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); ++VAR_3 )
VAR_0->arch.dr[VAR_3] = VAR_1(VAR_20[VAR_3]);
VAR_0->arch.dr6 = VAR_1(VAR_20[6]);
VAR_0->arch.dr7 = VAR_1(VAR_20[7]);
hvm_set_info_guest(VAR_0);
goto out;
}
#ifdef VAR_6
VAR_0->arch.pv.iopl = VAR_0->arch.user_regs.eflags & VAR_21;
VAR_0->arch.user_regs.eflags &= ~VAR_21;
VAR_0->arch.user_regs.eflags |= VAR_22;
if ( !VAR_0->is_initialised )
{
if ( !VAR_5 && !(VAR_4 & VAR_17) && !VAR_1.nat->ctrlreg[1] )
return -VAR_12;
VAR_0->arch.pv.ldt_base = VAR_1(VAR_13);
VAR_0->arch.pv.ldt_ents = VAR_1(VAR_15);
}
else
{
unsigned long VAR_23 = pagetable_get_pfn(VAR_0->arch.guest_table);
bool VAR_24;
if ( !VAR_5 )
{
VAR_24 = xen_pfn_to_cr3(VAR_23) != VAR_1.nat->ctrlreg[3];
if ( pagetable_is_null(VAR_0->arch.guest_table_user) )
VAR_24 |= VAR_1.nat->ctrlreg[1] || !(VAR_4 & VAR_17);
else
{
VAR_23 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
VAR_24 |= xen_pfn_to_cr3(VAR_23) != VAR_1.nat->ctrlreg[1];
}
} else {
l4_pgentry_t *VAR_25 = map_domain_page(_mfn(VAR_23));
VAR_23 = l4e_get_pfn(*VAR_25);
unmap_domain_page(VAR_25);
VAR_24 = compat_pfn_to_cr3(VAR_23) != VAR_1.cmp->ctrlreg[3];
}
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.gdt_frames); ++VAR_3 )
VAR_24 |= VAR_0->arch.pv.gdt_frames[VAR_3] != VAR_1(VAR_26[VAR_3]);
VAR_24 |= VAR_0->arch.pv.gdt_ents != VAR_1(VAR_27);
VAR_24 |= VAR_0->arch.pv.ldt_base != VAR_1(VAR_13);
VAR_24 |= VAR_0->arch.pv.ldt_ents != VAR_1(VAR_15);
if ( VAR_24 )
return -VAR_28;
}
VAR_0->arch.pv.kernel_ss = VAR_1(VAR_29);
VAR_0->arch.pv.kernel_sp = VAR_1(VAR_30);
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.ctrlreg); ++VAR_3 )
VAR_0->arch.pv.ctrlreg[VAR_3] = VAR_1(VAR_31[VAR_3]);
VAR_0->arch.pv.event_callback_eip = VAR_1(VAR_32);
VAR_0->arch.pv.failsafe_callback_eip = VAR_1(VAR_33);
if ( !VAR_5 )
{
VAR_0->arch.pv.syscall_callback_eip = VAR_1.nat->syscall_callback_eip;
VAR_0->arch.pv.fs_base =
!(VAR_0->arch.user_regs.fs & ~3) ? VAR_1.nat->fs_base : 0;
VAR_0->arch.pv.gs_base_kernel = VAR_1.nat->gs_base_kernel;
VAR_0->arch.pv.gs_base_user =
!(VAR_0->arch.user_regs.gs & ~3) ? VAR_1.nat->gs_base_user : 0;
}
else
{
VAR_0->arch.pv.event_callback_cs = VAR_1(VAR_34);
VAR_0->arch.pv.failsafe_callback_cs = VAR_1(VAR_35);
}
VAR_0->arch.pv.ctrlreg[0] &= VAR_36;
VAR_0->arch.pv.ctrlreg[0] |= read_cr0() & ~VAR_36;
VAR_9 = VAR_0->arch.pv.ctrlreg[4];
VAR_0->arch.pv.ctrlreg[4] = VAR_9 ? pv_guest_cr4_fixup(VAR_0, VAR_9) :
real_cr4_to_pv_guest_cr4(VAR_37);
memset(VAR_0->arch.dr, 0, sizeof(VAR_0->arch.dr));
VAR_0->arch.dr6 = VAR_38;
VAR_0->arch.dr7 = VAR_39;
VAR_0->arch.pv.dr7_emul = 0;
for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); VAR_3++ )
set_debugreg(VAR_0, VAR_3, VAR_1(VAR_20[VAR_3]));
set_debugreg(VAR_0, 6, VAR_1(VAR_20[6]));
set_debugreg(VAR_0, 7, VAR_1(VAR_20[7]));
if ( VAR_0->is_initialised )
goto out;
if ( VAR_0->vcpu_id == 0 )
{
if ( VAR_2 != VAR_40->domain && !VM_ASSIST(VAR_2, VAR_41) &&
is_pv_domain(VAR_2) && !is_pv_32bit_domain(VAR_2) &&
test_bit(VAR_42, &VAR_1.nat->vm_assist) &&
atomic_read(&VAR_2->arch.pv.nr_l4_pages) )
{
bool VAR_43 = false;
spin_lock_recursive(&VAR_2->page_alloc_lock);
for ( VAR_3 = 0; ; )
{
struct page_info *VAR_44 = page_list_remove_head(&VAR_2->page_list);
if ( page_lock(VAR_44) )
{
if ( (VAR_44->u.inuse.type_info & VAR_45) ==
VAR_46 )
VAR_43 = !fill_ro_mpt(page_to_mfn(VAR_44));
page_unlock(VAR_44);
}
page_list_add_tail(VAR_44, &VAR_2->page_list);
if ( VAR_43 || (!(++VAR_3 & 0xff) && hypercall_preempt_check()) )
break;
}
spin_unlock_recursive(&VAR_2->page_alloc_lock);
if ( !VAR_43 )
return -VAR_47;
}
VAR_2->vm_assist = VAR_1(VAR_48);
}
VAR_10 = put_old_guest_table(VAR_40);
if ( VAR_10 )
return VAR_10;
if ( !VAR_5 )
VAR_10 = (int)pv_set_gdt(VAR_0, VAR_1.nat->gdt_frames, VAR_1.nat->gdt_ents);
else
{
unsigned long VAR_26[ARRAY_SIZE(VAR_0->arch.pv.gdt_frames)];
unsigned int VAR_49 = DIV_ROUND_UP(VAR_1.cmp->gdt_ents, 512);
if ( VAR_49 > ARRAY_SIZE(VAR_0->arch.pv.gdt_frames) )
return -VAR_12;
for ( VAR_3 = 0; VAR_3 < VAR_49; ++VAR_3 )
VAR_26[VAR_3] = VAR_1.cmp->gdt_frames[VAR_3];
VAR_10 = (int)pv_set_gdt(VAR_0, VAR_26, VAR_1.cmp->gdt_ents);
}
if ( VAR_10 != 0 )
return VAR_10;
set_bit(VAR_50, &VAR_0->pause_flags);
if ( !VAR_5 )
VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[3]);
else
VAR_7 = compat_cr3_to_pfn(VAR_1.cmp->ctrlreg[3]);
VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_51);
if ( !VAR_8 )
VAR_10 = -VAR_12;
else if ( paging_mode_refcounts(VAR_2) )
;
else if ( VAR_8 == VAR_0->arch.old_guest_table )
{
VAR_0->arch.old_guest_table = NULL;
put_page(VAR_8);
}
else
{
if ( !VAR_5 )
VAR_10 = put_old_guest_table(VAR_0);
if ( !VAR_10 )
VAR_10 = get_page_type_preemptible(VAR_8,
!VAR_5 ? VAR_52
: VAR_53);
switch ( VAR_10 )
{
case -VAR_54:
VAR_10 = -VAR_47;
case -VAR_47:
break;
case 0:
if ( !VAR_5 && !VM_ASSIST(VAR_2, VAR_41) &&
!paging_mode_refcounts(VAR_2) )
fill_ro_mpt(_mfn(VAR_7));
break;
default:
if ( VAR_8 == VAR_40->arch.old_guest_table )
VAR_8 = NULL;
break;
}
}
if ( VAR_10 )
;
else if ( !VAR_5 )
{
VAR_0->arch.guest_table = pagetable_from_page(VAR_8);
if ( VAR_1.nat->ctrlreg[1] )
{
VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[1]);
VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_51);
if ( !VAR_8 )
VAR_10 = -VAR_12;
else if ( !paging_mode_refcounts(VAR_2) )
{
VAR_10 = get_page_type_preemptible(VAR_8, VAR_52);
switch ( VAR_10 )
{
case -VAR_54:
VAR_10 = -VAR_47;
case -VAR_47:
VAR_0->arch.old_guest_ptpg = NULL;
VAR_0->arch.old_guest_table =
pagetable_get_page(VAR_0->arch.guest_table);
VAR_0->arch.guest_table = pagetable_null();
break;
default:
if ( VAR_8 == VAR_40->arch.old_guest_table )
VAR_8 = NULL;
break;
case 0:
if ( VM_ASSIST(VAR_2, VAR_41) )
zap_ro_mpt(_mfn(VAR_7));
break;
}
}
if ( !VAR_10 )
VAR_0->arch.guest_table_user = pagetable_from_page(VAR_8);
}
}
else
{
l4_pgentry_t *VAR_25;
VAR_25 = map_domain_page(pagetable_get_mfn(VAR_0->arch.guest_table));
*VAR_25 = l4e_from_mfn(page_to_mfn(VAR_8),
VAR_55|VAR_56|VAR_57|VAR_58);
unmap_domain_page(VAR_25);
}
if ( VAR_10 )
{
if ( VAR_8 )
put_page(VAR_8);
pv_destroy_gdt(VAR_0);
return VAR_10;
}
clear_bit(VAR_50, &VAR_0->pause_flags);
if ( VAR_0->vcpu_id == 0 )
update_domain_wallclock_time(VAR_2);
VAR_0->is_initialised = 1;
if ( paging_mode_enabled(VAR_2) )
paging_update_paging_modes(VAR_0);
update_cr3(VAR_0);
#endif 
out:
if ( VAR_4 & VAR_59 )
clear_bit(VAR_60, &VAR_0->pause_flags);
else
set_bit(VAR_60, &VAR_0->pause_flags);
return 0;
#undef c
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/domain.c/vul/before/0.json,"int arch_set_info_guest(
    struct vcpu *v, vcpu_guest_context_u c)
{
    struct domain *d = v->domain;
    unsigned int i;
    unsigned long flags;
    bool compat;
#ifdef CONFIG_PV
    unsigned long cr3_gfn;
    struct page_info *cr3_page;
    int rc = 0;
#endif

    /* The context is a compat-mode one if the target domain is compat-mode;
     * we expect the tools to DTRT even in compat-mode callers. */
    compat = is_pv_32bit_domain(d);

#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))
    flags = c(flags);

    if ( is_pv_domain(d) )
    {
        if ( !compat )
        {
            if ( !is_canonical_address(c.nat->user_regs.rip) ||
                 !is_canonical_address(c.nat->user_regs.rsp) ||
                 !is_canonical_address(c.nat->kernel_sp) ||
                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||
                 !is_canonical_address(c.nat->fs_base) ||
                 !is_canonical_address(c.nat->gs_base_kernel) ||
                 !is_canonical_address(c.nat->gs_base_user) ||
                 !is_canonical_address(c.nat->event_callback_eip) ||
                 !is_canonical_address(c.nat->syscall_callback_eip) ||
                 !is_canonical_address(c.nat->failsafe_callback_eip) )
                return -EINVAL;

            fixup_guest_stack_selector(d, c.nat->user_regs.ss);
            fixup_guest_stack_selector(d, c.nat->kernel_ss);
            fixup_guest_code_selector(d, c.nat->user_regs.cs);

            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )
            {
                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )
                    return -EINVAL;
                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);
            }

            if ( !__addr_ok(c.nat->ldt_base) )
                return -EINVAL;
        }
        else
        {
            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);
            fixup_guest_stack_selector(d, c.cmp->kernel_ss);
            fixup_guest_code_selector(d, c.cmp->user_regs.cs);
            fixup_guest_code_selector(d, c.cmp->event_callback_cs);
            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);

            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )
                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);
        }

        /* LDT safety checks. */
        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||
             (c(ldt_ents) > 8192) )
            return -EINVAL;
    }

    v->arch.flags &= ~TF_kernel_mode;
    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )
        v->arch.flags |= TF_kernel_mode;

    v->arch.vgc_flags = flags;

    vcpu_setup_fpu(v, v->arch.xsave_area,
                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,
                   FCW_DEFAULT);

    if ( !compat )
    {
        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));
        if ( is_pv_domain(d) )
            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,
                   sizeof(c.nat->trap_ctxt));
    }
    else
    {
        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);
        if ( is_pv_domain(d) )
        {
            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )
                XLAT_trap_info(v->arch.pv.trap_ctxt + i,
                               c.cmp->trap_ctxt + i);
        }
    }

    if ( is_hvm_domain(d) )
    {
        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )
            v->arch.dr[i] = c(debugreg[i]);
        v->arch.dr6 = c(debugreg[6]);
        v->arch.dr7 = c(debugreg[7]);

        hvm_set_info_guest(v);
        goto out;
    }

#ifdef CONFIG_PV
    /* IOPL privileges are virtualised. */
    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;
    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;

    /* Ensure real hardware interrupts are enabled. */
    v->arch.user_regs.eflags |= X86_EFLAGS_IF;

    if ( !v->is_initialised )
    {
        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )
            return -EINVAL;

        v->arch.pv.ldt_base = c(ldt_base);
        v->arch.pv.ldt_ents = c(ldt_ents);
    }
    else
    {
        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);
        bool fail;

        if ( !compat )
        {
            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];
            if ( pagetable_is_null(v->arch.guest_table_user) )
                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);
            else
            {
                pfn = pagetable_get_pfn(v->arch.guest_table_user);
                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];
            }
        } else {
            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));

            pfn = l4e_get_pfn(*l4tab);
            unmap_domain_page(l4tab);
            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];
        }

        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )
            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);
        fail |= v->arch.pv.gdt_ents != c(gdt_ents);

        fail |= v->arch.pv.ldt_base != c(ldt_base);
        fail |= v->arch.pv.ldt_ents != c(ldt_ents);

        if ( fail )
           return -EOPNOTSUPP;
    }

    v->arch.pv.kernel_ss = c(kernel_ss);
    v->arch.pv.kernel_sp = c(kernel_sp);
    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )
        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);

    v->arch.pv.event_callback_eip = c(event_callback_eip);
    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);
    if ( !compat )
    {
        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;
        /* non-nul selector kills fs_base */
        v->arch.pv.fs_base =
            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;
        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;
        /* non-nul selector kills gs_base_user */
        v->arch.pv.gs_base_user =
            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;
    }
    else
    {
        v->arch.pv.event_callback_cs = c(event_callback_cs);
        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);
    }

    /* Only CR0.TS is modifiable by guest or admin. */
    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;

    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);

    memset(v->arch.dr, 0, sizeof(v->arch.dr));
    v->arch.dr6 = X86_DR6_DEFAULT;
    v->arch.dr7 = X86_DR7_DEFAULT;
    v->arch.pv.dr7_emul = 0;

    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )
        set_debugreg(v, i, c(debugreg[i]));
    set_debugreg(v, 6, c(debugreg[6]));
    set_debugreg(v, 7, c(debugreg[7]));

    if ( v->is_initialised )
        goto out;

    if ( v->vcpu_id == 0 )
    {
        /*
         * In the restore case we need to deal with L4 pages which got
         * initialized with m2p_strict still clear (and which hence lack the
         * correct initial RO_MPT_VIRT_{START,END} L4 entry).
         */
        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&
             is_pv_domain(d) && !is_pv_32bit_domain(d) &&
             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&
             atomic_read(&d->arch.pv.nr_l4_pages) )
        {
            bool done = false;

            spin_lock_recursive(&d->page_alloc_lock);

            for ( i = 0; ; )
            {
                struct page_info *page = page_list_remove_head(&d->page_list);

                if ( page_lock(page) )
                {
                    if ( (page->u.inuse.type_info & PGT_type_mask) ==
                         PGT_l4_page_table )
                        done = !fill_ro_mpt(page_to_mfn(page));

                    page_unlock(page);
                }

                page_list_add_tail(page, &d->page_list);

                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )
                    break;
            }

            spin_unlock_recursive(&d->page_alloc_lock);

            if ( !done )
                return -ERESTART;
        }

        d->vm_assist = c(vm_assist);
    }

    rc = put_old_guest_table(current);
    if ( rc )
        return rc;

    if ( !compat )
        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);
    else
    {
        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];
        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);

        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )
            return -EINVAL;

        for ( i = 0; i < nr_frames; ++i )
            gdt_frames[i] = c.cmp->gdt_frames[i];

        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);
    }
    if ( rc != 0 )
        return rc;

    set_bit(_VPF_in_reset, &v->pause_flags);

    if ( !compat )
        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);
    else
        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);
    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);

    if ( !cr3_page )
        rc = -EINVAL;
    else if ( paging_mode_refcounts(d) )
        /* nothing */;
    else if ( cr3_page == v->arch.old_guest_table )
    {
        v->arch.old_guest_table = NULL;
        put_page(cr3_page);
    }
    else
    {
        if ( !compat )
            rc = put_old_guest_table(v);
        if ( !rc )
            rc = get_page_type_preemptible(cr3_page,
                                           !compat ? PGT_root_page_table
                                                   : PGT_l3_page_table);
        switch ( rc )
        {
        case -EINTR:
            rc = -ERESTART;
        case -ERESTART:
            break;
        case 0:
            if ( !compat && !VM_ASSIST(d, m2p_strict) &&
                 !paging_mode_refcounts(d) )
                fill_ro_mpt(_mfn(cr3_gfn));
            break;
        default:
            if ( cr3_page == current->arch.old_guest_table )
                cr3_page = NULL;
            break;
        }
    }
    if ( rc )
        /* handled below */;
    else if ( !compat )
    {
        v->arch.guest_table = pagetable_from_page(cr3_page);
        if ( c.nat->ctrlreg[1] )
        {
            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);
            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);

            if ( !cr3_page )
                rc = -EINVAL;
            else if ( !paging_mode_refcounts(d) )
            {
                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);
                switch ( rc )
                {
                case -EINTR:
                    rc = -ERESTART;
                    /* Fallthrough */
                case -ERESTART:
                    v->arch.old_guest_ptpg = NULL;
                    v->arch.old_guest_table =
                        pagetable_get_page(v->arch.guest_table);
                    v->arch.guest_table = pagetable_null();
                    break;
                default:
                    if ( cr3_page == current->arch.old_guest_table )
                        cr3_page = NULL;
                    break;
                case 0:
                    if ( VM_ASSIST(d, m2p_strict) )
                        zap_ro_mpt(_mfn(cr3_gfn));
                    break;
                }
            }
            if ( !rc )
               v->arch.guest_table_user = pagetable_from_page(cr3_page);
        }
    }
    else
    {
        l4_pgentry_t *l4tab;

        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));
        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),
            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);
        unmap_domain_page(l4tab);
    }
    if ( rc )
    {
        if ( cr3_page )
            put_page(cr3_page);
        pv_destroy_gdt(v);
        return rc;
    }

    clear_bit(_VPF_in_reset, &v->pause_flags);

    if ( v->vcpu_id == 0 )
        update_domain_wallclock_time(d);

    /* Don't redo final setup */
    v->is_initialised = 1;

    if ( paging_mode_enabled(d) )
        paging_update_paging_modes(v);

    update_cr3(v);
#endif /* CONFIG_PV */

 out:
    if ( flags & VGCF_online )
        clear_bit(_VPF_down, &v->pause_flags);
    else
        set_bit(_VPF_down, &v->pause_flags);
    return 0;
#undef c
}","int arch_set_info_guest(
    struct vcpu *VAR_0, vcpu_guest_context_u VAR_1)
{
    struct domain *VAR_2 = VAR_0->domain;
    unsigned int VAR_3;
    unsigned long VAR_4;
    bool VAR_5;
#ifdef VAR_6
    unsigned long VAR_7;
    struct page_info *VAR_8;
    int VAR_9 = 0;
#endif

    /* COMMENT_0 */
                                                                  
    VAR_5 = is_pv_32bit_domain(VAR_2);

#define VAR_1(VAR_10) (compat ? (c.cmp->fld) : (c.nat->fld))
    VAR_4 = VAR_1(VAR_4);

    if ( is_pv_domain(VAR_2) )
    {
        if ( !VAR_5 )
        {
            if ( !is_canonical_address(VAR_1.nat->user_regs.rip) ||
                 !is_canonical_address(VAR_1.nat->user_regs.rsp) ||
                 !is_canonical_address(VAR_1.nat->kernel_sp) ||
                 (VAR_1.nat->ldt_ents && !is_canonical_address(VAR_1.nat->ldt_base)) ||
                 !is_canonical_address(VAR_1.nat->fs_base) ||
                 !is_canonical_address(VAR_1.nat->gs_base_kernel) ||
                 !is_canonical_address(VAR_1.nat->gs_base_user) ||
                 !is_canonical_address(VAR_1.nat->event_callback_eip) ||
                 !is_canonical_address(VAR_1.nat->syscall_callback_eip) ||
                 !is_canonical_address(VAR_1.nat->failsafe_callback_eip) )
                return -VAR_11;

            fixup_guest_stack_selector(VAR_2, VAR_1.nat->user_regs.ss);
            fixup_guest_stack_selector(VAR_2, VAR_1.nat->kernel_ss);
            fixup_guest_code_selector(VAR_2, VAR_1.nat->user_regs.cs);

            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.nat->trap_ctxt); VAR_3++ )
            {
                if ( !is_canonical_address(VAR_1.nat->trap_ctxt[VAR_3].address) )
                    return -VAR_11;
                fixup_guest_code_selector(VAR_2, VAR_1.nat->trap_ctxt[VAR_3].cs);
            }

            if ( !__addr_ok(VAR_1.nat->ldt_base) )
                return -VAR_11;
        }
        else
        {
            fixup_guest_stack_selector(VAR_2, VAR_1.cmp->user_regs.ss);
            fixup_guest_stack_selector(VAR_2, VAR_1.cmp->kernel_ss);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->user_regs.cs);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->event_callback_cs);
            fixup_guest_code_selector(VAR_2, VAR_1.cmp->failsafe_callback_cs);

            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); VAR_3++ )
                fixup_guest_code_selector(VAR_2, VAR_1.cmp->trap_ctxt[VAR_3].cs);
        }

        /* COMMENT_2 */
        if ( ((VAR_1(VAR_12) & (VAR_13 - 1)) != 0) ||
             (VAR_1(VAR_14) > 8192) )
            return -VAR_11;
    }

    VAR_0->arch.flags &= ~VAR_15;
    if ( (VAR_4 & VAR_16) || is_hvm_domain(VAR_2)/* COMMENT_3 */ )
        VAR_0->arch.flags |= VAR_15;

    VAR_0->arch.vgc_flags = VAR_4;

    vcpu_setup_fpu(VAR_0, VAR_0->arch.xsave_area,
                   VAR_4 & VAR_17 ? &VAR_1.nat->fpu_ctxt : NULL,
                   VAR_18);

    if ( !VAR_5 )
    {
        memcpy(&VAR_0->arch.user_regs, &VAR_1.nat->user_regs, sizeof(VAR_1.nat->user_regs));
        if ( is_pv_domain(VAR_2) )
            memcpy(VAR_0->arch.pv.trap_ctxt, VAR_1.nat->trap_ctxt,
                   sizeof(VAR_1.nat->trap_ctxt));
    }
    else
    {
        XLAT_cpu_user_regs(&VAR_0->arch.user_regs, &VAR_1.cmp->user_regs);
        if ( is_pv_domain(VAR_2) )
        {
            for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_1.cmp->trap_ctxt); ++VAR_3 )
                XLAT_trap_info(VAR_0->arch.pv.trap_ctxt + VAR_3,
                               VAR_1.cmp->trap_ctxt + VAR_3);
        }
    }

    if ( is_hvm_domain(VAR_2) )
    {
        for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); ++VAR_3 )
            VAR_0->arch.dr[VAR_3] = VAR_1(VAR_19[VAR_3]);
        VAR_0->arch.dr6 = VAR_1(VAR_19[6]);
        VAR_0->arch.dr7 = VAR_1(VAR_19[7]);

        hvm_set_info_guest(VAR_0);
        goto out;
    }

#ifdef VAR_6
    /* COMMENT_4 */
    VAR_0->arch.pv.iopl = VAR_0->arch.user_regs.eflags & VAR_20;
    VAR_0->arch.user_regs.eflags &= ~VAR_20;

    /* COMMENT_5 */
    VAR_0->arch.user_regs.eflags |= VAR_21;

    if ( !VAR_0->is_initialised )
    {
        if ( !VAR_5 && !(VAR_4 & VAR_16) && !VAR_1.nat->ctrlreg[1] )
            return -VAR_11;

        VAR_0->arch.pv.ldt_base = VAR_1(VAR_12);
        VAR_0->arch.pv.ldt_ents = VAR_1(VAR_14);
    }
    else
    {
        unsigned long VAR_22 = pagetable_get_pfn(VAR_0->arch.guest_table);
        bool VAR_23;

        if ( !VAR_5 )
        {
            VAR_23 = xen_pfn_to_cr3(VAR_22) != VAR_1.nat->ctrlreg[3];
            if ( pagetable_is_null(VAR_0->arch.guest_table_user) )
                VAR_23 |= VAR_1.nat->ctrlreg[1] || !(VAR_4 & VAR_16);
            else
            {
                VAR_22 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
                VAR_23 |= xen_pfn_to_cr3(VAR_22) != VAR_1.nat->ctrlreg[1];
            }
        } else {
            l4_pgentry_t *VAR_24 = map_domain_page(_mfn(VAR_22));

            VAR_22 = l4e_get_pfn(*VAR_24);
            unmap_domain_page(VAR_24);
            VAR_23 = compat_pfn_to_cr3(VAR_22) != VAR_1.cmp->ctrlreg[3];
        }

        for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.gdt_frames); ++VAR_3 )
            VAR_23 |= VAR_0->arch.pv.gdt_frames[VAR_3] != VAR_1(VAR_25[VAR_3]);
        VAR_23 |= VAR_0->arch.pv.gdt_ents != VAR_1(VAR_26);

        VAR_23 |= VAR_0->arch.pv.ldt_base != VAR_1(VAR_12);
        VAR_23 |= VAR_0->arch.pv.ldt_ents != VAR_1(VAR_14);

        if ( VAR_23 )
           return -VAR_27;
    }

    VAR_0->arch.pv.kernel_ss = VAR_1(VAR_28);
    VAR_0->arch.pv.kernel_sp = VAR_1(VAR_29);
    for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.pv.ctrlreg); ++VAR_3 )
        VAR_0->arch.pv.ctrlreg[VAR_3] = VAR_1(VAR_30[VAR_3]);

    VAR_0->arch.pv.event_callback_eip = VAR_1(VAR_31);
    VAR_0->arch.pv.failsafe_callback_eip = VAR_1(VAR_32);
    if ( !VAR_5 )
    {
        VAR_0->arch.pv.syscall_callback_eip = VAR_1.nat->syscall_callback_eip;
        /* COMMENT_6 */
        VAR_0->arch.pv.fs_base =
            !(VAR_0->arch.user_regs.fs & ~3) ? VAR_1.nat->fs_base : 0;
        VAR_0->arch.pv.gs_base_kernel = VAR_1.nat->gs_base_kernel;
        /* COMMENT_7 */
        VAR_0->arch.pv.gs_base_user =
            !(VAR_0->arch.user_regs.gs & ~3) ? VAR_1.nat->gs_base_user : 0;
    }
    else
    {
        VAR_0->arch.pv.event_callback_cs = VAR_1(VAR_33);
        VAR_0->arch.pv.failsafe_callback_cs = VAR_1(VAR_34);
    }

    /* COMMENT_8 */
    VAR_0->arch.pv.ctrlreg[0] &= VAR_35;
    VAR_0->arch.pv.ctrlreg[0] |= read_cr0() & ~VAR_35;

    VAR_0->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_0, VAR_0->arch.pv.ctrlreg[4]);

    memset(VAR_0->arch.dr, 0, sizeof(VAR_0->arch.dr));
    VAR_0->arch.dr6 = VAR_36;
    VAR_0->arch.dr7 = VAR_37;
    VAR_0->arch.pv.dr7_emul = 0;

    for ( VAR_3 = 0; VAR_3 < ARRAY_SIZE(VAR_0->arch.dr); VAR_3++ )
        set_debugreg(VAR_0, VAR_3, VAR_1(VAR_19[VAR_3]));
    set_debugreg(VAR_0, 6, VAR_1(VAR_19[6]));
    set_debugreg(VAR_0, 7, VAR_1(VAR_19[7]));

    if ( VAR_0->is_initialised )
        goto out;

    if ( VAR_0->vcpu_id == 0 )
    {
        /* COMMENT_9 */
                                                                      
                                                                            
                                                             
           
        if ( VAR_2 != VAR_38->domain && !VM_ASSIST(VAR_2, VAR_39) &&
             is_pv_domain(VAR_2) && !is_pv_32bit_domain(VAR_2) &&
             test_bit(VAR_40, &VAR_1.nat->vm_assist) &&
             atomic_read(&VAR_2->arch.pv.nr_l4_pages) )
        {
            bool VAR_41 = false;

            spin_lock_recursive(&VAR_2->page_alloc_lock);

            for ( VAR_3 = 0; ; )
            {
                struct page_info *VAR_42 = page_list_remove_head(&VAR_2->page_list);

                if ( page_lock(VAR_42) )
                {
                    if ( (VAR_42->u.inuse.type_info & VAR_43) ==
                         VAR_44 )
                        VAR_41 = !fill_ro_mpt(page_to_mfn(VAR_42));

                    page_unlock(VAR_42);
                }

                page_list_add_tail(VAR_42, &VAR_2->page_list);

                if ( VAR_41 || (!(++VAR_3 & 0xff) && hypercall_preempt_check()) )
                    break;
            }

            spin_unlock_recursive(&VAR_2->page_alloc_lock);

            if ( !VAR_41 )
                return -VAR_45;
        }

        VAR_2->vm_assist = VAR_1(VAR_46);
    }

    VAR_9 = put_old_guest_table(VAR_38);
    if ( VAR_9 )
        return VAR_9;

    if ( !VAR_5 )
        VAR_9 = (int)pv_set_gdt(VAR_0, VAR_1.nat->gdt_frames, VAR_1.nat->gdt_ents);
    else
    {
        unsigned long VAR_25[ARRAY_SIZE(VAR_0->arch.pv.gdt_frames)];
        unsigned int VAR_47 = DIV_ROUND_UP(VAR_1.cmp->gdt_ents, 512);

        if ( VAR_47 > ARRAY_SIZE(VAR_0->arch.pv.gdt_frames) )
            return -VAR_11;

        for ( VAR_3 = 0; VAR_3 < VAR_47; ++VAR_3 )
            VAR_25[VAR_3] = VAR_1.cmp->gdt_frames[VAR_3];

        VAR_9 = (int)pv_set_gdt(VAR_0, VAR_25, VAR_1.cmp->gdt_ents);
    }
    if ( VAR_9 != 0 )
        return VAR_9;

    set_bit(VAR_48, &VAR_0->pause_flags);

    if ( !VAR_5 )
        VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[3]);
    else
        VAR_7 = compat_cr3_to_pfn(VAR_1.cmp->ctrlreg[3]);
    VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_49);

    if ( !VAR_8 )
        VAR_9 = -VAR_11;
    else if ( paging_mode_refcounts(VAR_2) )
        /* COMMENT_14 */;
    else if ( VAR_8 == VAR_0->arch.old_guest_table )
    {
        VAR_0->arch.old_guest_table = NULL;
        put_page(VAR_8);
    }
    else
    {
        if ( !VAR_5 )
            VAR_9 = put_old_guest_table(VAR_0);
        if ( !VAR_9 )
            VAR_9 = get_page_type_preemptible(VAR_8,
                                           !VAR_5 ? VAR_50
                                                   : VAR_51);
        switch ( VAR_9 )
        {
        case -VAR_52:
            VAR_9 = -VAR_45;
        case -VAR_45:
            break;
        case 0:
            if ( !VAR_5 && !VM_ASSIST(VAR_2, VAR_39) &&
                 !paging_mode_refcounts(VAR_2) )
                fill_ro_mpt(_mfn(VAR_7));
            break;
        default:
            if ( VAR_8 == VAR_38->arch.old_guest_table )
                VAR_8 = NULL;
            break;
        }
    }
    if ( VAR_9 )
        /* COMMENT_15 */;
    else if ( !VAR_5 )
    {
        VAR_0->arch.guest_table = pagetable_from_page(VAR_8);
        if ( VAR_1.nat->ctrlreg[1] )
        {
            VAR_7 = xen_cr3_to_pfn(VAR_1.nat->ctrlreg[1]);
            VAR_8 = get_page_from_gfn(VAR_2, VAR_7, NULL, VAR_49);

            if ( !VAR_8 )
                VAR_9 = -VAR_11;
            else if ( !paging_mode_refcounts(VAR_2) )
            {
                VAR_9 = get_page_type_preemptible(VAR_8, VAR_50);
                switch ( VAR_9 )
                {
                case -VAR_52:
                    VAR_9 = -VAR_45;
                    /* COMMENT_16 */
                case -VAR_45:
                    VAR_0->arch.old_guest_ptpg = NULL;
                    VAR_0->arch.old_guest_table =
                        pagetable_get_page(VAR_0->arch.guest_table);
                    VAR_0->arch.guest_table = pagetable_null();
                    break;
                default:
                    if ( VAR_8 == VAR_38->arch.old_guest_table )
                        VAR_8 = NULL;
                    break;
                case 0:
                    if ( VM_ASSIST(VAR_2, VAR_39) )
                        zap_ro_mpt(_mfn(VAR_7));
                    break;
                }
            }
            if ( !VAR_9 )
               VAR_0->arch.guest_table_user = pagetable_from_page(VAR_8);
        }
    }
    else
    {
        l4_pgentry_t *VAR_24;

        VAR_24 = map_domain_page(pagetable_get_mfn(VAR_0->arch.guest_table));
        *VAR_24 = l4e_from_mfn(page_to_mfn(VAR_8),
            VAR_53|VAR_54|VAR_55|VAR_56);
        unmap_domain_page(VAR_24);
    }
    if ( VAR_9 )
    {
        if ( VAR_8 )
            put_page(VAR_8);
        pv_destroy_gdt(VAR_0);
        return VAR_9;
    }

    clear_bit(VAR_48, &VAR_0->pause_flags);

    if ( VAR_0->vcpu_id == 0 )
        update_domain_wallclock_time(VAR_2);

    /* COMMENT_17 */
    VAR_0->is_initialised = 1;

    if ( paging_mode_enabled(VAR_2) )
        paging_update_paging_modes(VAR_0);

    update_cr3(VAR_0);
#endif /* COMMENT_18 */

 out:
    if ( VAR_4 & VAR_57 )
        clear_bit(VAR_58, &VAR_0->pause_flags);
    else
        set_bit(VAR_58, &VAR_0->pause_flags);
    return 0;
#undef c
}",xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,6 @@
 #ifdef CONFIG_PV
     unsigned long cr3_gfn;
     struct page_info *cr3_page;
-    unsigned long cr4;
     int rc = 0;
 #endif
 
@@ -184,9 +183,7 @@
     v->arch.pv.ctrlreg[0] &= X86_CR0_TS;
     v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;
 
-    cr4 = v->arch.pv.ctrlreg[4];
-    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :
-        real_cr4_to_pv_guest_cr4(mmu_cr4_features);
+    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);
 
     memset(v->arch.dr, 0, sizeof(v->arch.dr));
     v->arch.dr6 = X86_DR6_DEFAULT;","{'deleted_lines': ['    unsigned long cr4;', '    cr4 = v->arch.pv.ctrlreg[4];', '    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :', '        real_cr4_to_pv_guest_cr4(mmu_cr4_features);'], 'added_lines': ['    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:53:32Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/pv/domain.c,__context_switch,"static void __context_switch(void)
{
struct cpu_user_regs *stack_regs = guest_cpu_user_regs();
unsigned int          cpu = smp_processor_id();
struct vcpu          *p = per_cpu(curr_vcpu, cpu);
struct vcpu          *n = current;
struct domain        *pd = p->domain, *nd = n->domain;
seg_desc_t           *gdt;
struct desc_ptr       gdt_desc;
ASSERT(p != n);
ASSERT(!vcpu_cpu_dirty(n));
if ( !is_idle_domain(pd) )
{
memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);
vcpu_save_fpu(p);
pd->arch.ctxt_switch->from(p);
}
if ( pd != nd )
cpumask_set_cpu(cpu, nd->dirty_cpumask);
write_atomic(&n->dirty_cpu, cpu);
if ( !is_idle_domain(nd) )
{
memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);
if ( cpu_has_xsave )
{
u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;
if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )
BUG();
if ( cpu_has_xsaves && is_hvm_vcpu(n) )
set_msr_xss(n->arch.hvm.msr_xss);
}
vcpu_restore_fpu_nonlazy(n, false);
nd->arch.ctxt_switch->to(n);
}
psr_ctxt_switch_to(nd);
gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :
per_cpu(compat_gdt_table, cpu);
if ( need_full_gdt(nd) )
{
unsigned long mfn = virt_to_mfn(gdt);
l1_pgentry_t *pl1e = pv_gdt_ptes(n);
unsigned int i;
for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )
l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,
l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));
}
if ( need_full_gdt(pd) &&
((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )
{
gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);
lgdt(&gdt_desc);
}
write_ptbase(n);
#if defined(CONFIG_PV) && defined(CONFIG_HVM)
if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&
!cpu_has_fsgsbase && cpu_has_svm )
svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif
if ( need_full_gdt(nd) &&
((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )
{
gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
gdt_desc.base = GDT_VIRT_START(n);
lgdt(&gdt_desc);
}
if ( pd != nd )
cpumask_clear_cpu(cpu, pd->dirty_cpumask);
write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);
per_cpu(curr_vcpu, cpu) = n;
}","static void __context_switch(void)
{
struct cpu_user_regs *VAR_0 = guest_cpu_user_regs();
unsigned int          VAR_1 = smp_processor_id();
struct vcpu          *VAR_2 = per_cpu(VAR_3, VAR_1);
struct vcpu          *VAR_4 = VAR_5;
struct domain        *VAR_6 = VAR_2->domain, *VAR_7 = VAR_4->domain;
seg_desc_t           *VAR_8;
struct desc_ptr       VAR_9;
ASSERT(VAR_2 != VAR_4);
ASSERT(!vcpu_cpu_dirty(VAR_4));
if ( !is_idle_domain(VAR_6) )
{
memcpy(&VAR_2->arch.user_regs, VAR_0, VAR_10);
vcpu_save_fpu(VAR_2);
VAR_6->arch.ctxt_switch->from(VAR_2);
}
if ( VAR_6 != VAR_7 )
cpumask_set_cpu(VAR_1, VAR_7->dirty_cpumask);
write_atomic(&VAR_4->dirty_cpu, VAR_1);
if ( !is_idle_domain(VAR_7) )
{
memcpy(VAR_0, &VAR_4->arch.user_regs, VAR_10);
if ( VAR_11 )
{
u64 VAR_12 = VAR_4->arch.xcr0 ?VAR_13: VAR_14;
if ( VAR_12 != get_xcr0() && !set_xcr0(VAR_12) )
BUG();
if ( VAR_15 && is_hvm_vcpu(VAR_4) )
set_msr_xss(VAR_4->arch.hvm.msr_xss);
}
vcpu_restore_fpu_nonlazy(VAR_4, false);
VAR_7->arch.ctxt_switch->to(VAR_4);
}
psr_ctxt_switch_to(VAR_7);
VAR_8 = !is_pv_32bit_domain(VAR_7) ? per_cpu(VAR_16, VAR_1) :
per_cpu(VAR_17, VAR_1);
if ( need_full_gdt(VAR_7) )
{
unsigned long VAR_18 = virt_to_mfn(VAR_8);
l1_pgentry_t *VAR_19 = pv_gdt_ptes(VAR_4);
unsigned int VAR_20;
for ( VAR_20 = 0; VAR_20 < VAR_21; VAR_20++ )
l1e_write(VAR_19 + VAR_22 + VAR_20,
l1e_from_pfn(VAR_18 + VAR_20, VAR_23));
}
if ( need_full_gdt(VAR_6) &&
((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_7)) )
{
VAR_9.limit = VAR_24;
VAR_9.base  = (unsigned long)(VAR_8 - VAR_25);
lgdt(&VAR_9);
}
write_ptbase(VAR_4);
#if defined(VAR_26) && defined(VAR_27)
if ( is_pv_domain(VAR_7) && !is_pv_32bit_domain(VAR_7) && !is_idle_domain(VAR_7) &&
!VAR_28 && VAR_29 )
svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif
if ( need_full_gdt(VAR_7) &&
((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_6)) )
{
VAR_9.limit = VAR_24;
VAR_9.base = GDT_VIRT_START(VAR_4);
lgdt(&VAR_9);
}
if ( VAR_6 != VAR_7 )
cpumask_clear_cpu(VAR_1, VAR_6->dirty_cpumask);
write_atomic(&VAR_2->dirty_cpu, VAR_30);
per_cpu(VAR_3, VAR_1) = VAR_4;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/1.json,"static void __context_switch(void)
{
    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();
    unsigned int          cpu = smp_processor_id();
    struct vcpu          *p = per_cpu(curr_vcpu, cpu);
    struct vcpu          *n = current;
    struct domain        *pd = p->domain, *nd = n->domain;
    seg_desc_t           *gdt;
    struct desc_ptr       gdt_desc;

    ASSERT(p != n);
    ASSERT(!vcpu_cpu_dirty(n));

    if ( !is_idle_domain(pd) )
    {
        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);
        vcpu_save_fpu(p);
        pd->arch.ctxt_switch->from(p);
    }

    /*
     * Mark this CPU in next domain's dirty cpumasks before calling
     * ctxt_switch_to(). This avoids a race on things like EPT flushing,
     * which is synchronised on that function.
     */
    if ( pd != nd )
        cpumask_set_cpu(cpu, nd->dirty_cpumask);
    write_atomic(&n->dirty_cpu, cpu);

    if ( !is_idle_domain(nd) )
    {
        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);
        if ( cpu_has_xsave )
        {
            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;

            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )
                BUG();

            if ( cpu_has_xsaves && is_hvm_vcpu(n) )
                set_msr_xss(n->arch.hvm.msr_xss);
        }
        vcpu_restore_fpu_nonlazy(n, false);
        nd->arch.ctxt_switch->to(n);
    }

    psr_ctxt_switch_to(nd);

    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :
                                    per_cpu(compat_gdt_table, cpu);
    if ( need_full_gdt(nd) )
    {
        unsigned long mfn = virt_to_mfn(gdt);
        l1_pgentry_t *pl1e = pv_gdt_ptes(n);
        unsigned int i;

        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )
            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,
                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));
    }

    if ( need_full_gdt(pd) &&
         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )
    {
        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);

        lgdt(&gdt_desc);
    }

    write_ptbase(n);

#if defined(CONFIG_PV) && defined(CONFIG_HVM)
    /* Prefetch the VMCB if we expect to use it later in the context switch */
    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&
         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )
        svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif

    if ( need_full_gdt(nd) &&
         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )
    {
        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
        gdt_desc.base = GDT_VIRT_START(n);

        lgdt(&gdt_desc);
    }

    if ( pd != nd )
        cpumask_clear_cpu(cpu, pd->dirty_cpumask);
    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);

    per_cpu(curr_vcpu, cpu) = n;
}","static void __context_switch(void)
{
    struct cpu_user_regs *VAR_0 = guest_cpu_user_regs();
    unsigned int          VAR_1 = smp_processor_id();
    struct vcpu          *VAR_2 = per_cpu(VAR_3, VAR_1);
    struct vcpu          *VAR_4 = VAR_5;
    struct domain        *VAR_6 = VAR_2->domain, *VAR_7 = VAR_4->domain;
    seg_desc_t           *VAR_8;
    struct desc_ptr       VAR_9;

    ASSERT(VAR_2 != VAR_4);
    ASSERT(!vcpu_cpu_dirty(VAR_4));

    if ( !is_idle_domain(VAR_6) )
    {
        memcpy(&VAR_2->arch.user_regs, VAR_0, VAR_10);
        vcpu_save_fpu(VAR_2);
        VAR_6->arch.ctxt_switch->from(VAR_2);
    }

    /* COMMENT_0 */
                                                                   
                                                                        
                                              
       
    if ( VAR_6 != VAR_7 )
        cpumask_set_cpu(VAR_1, VAR_7->dirty_cpumask);
    write_atomic(&VAR_4->dirty_cpu, VAR_1);

    if ( !is_idle_domain(VAR_7) )
    {
        memcpy(VAR_0, &VAR_4->arch.user_regs, VAR_10);
        if ( VAR_11 )
        {
            u64 VAR_12 = VAR_4->arch.xcr0 ?VAR_13: VAR_14;

            if ( VAR_12 != get_xcr0() && !set_xcr0(VAR_12) )
                BUG();

            if ( VAR_15 && is_hvm_vcpu(VAR_4) )
                set_msr_xss(VAR_4->arch.hvm.msr_xss);
        }
        vcpu_restore_fpu_nonlazy(VAR_4, false);
        VAR_7->arch.ctxt_switch->to(VAR_4);
    }

    psr_ctxt_switch_to(VAR_7);

    VAR_8 = !is_pv_32bit_domain(VAR_7) ? per_cpu(VAR_16, VAR_1) :
                                    per_cpu(VAR_17, VAR_1);
    if ( need_full_gdt(VAR_7) )
    {
        unsigned long VAR_18 = virt_to_mfn(VAR_8);
        l1_pgentry_t *VAR_19 = pv_gdt_ptes(VAR_4);
        unsigned int VAR_20;

        for ( VAR_20 = 0; VAR_20 < VAR_21; VAR_20++ )
            l1e_write(VAR_19 + VAR_22 + VAR_20,
                      l1e_from_pfn(VAR_18 + VAR_20, VAR_23));
    }

    if ( need_full_gdt(VAR_6) &&
         ((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_7)) )
    {
        VAR_9.limit = VAR_24;
        VAR_9.base  = (unsigned long)(VAR_8 - VAR_25);

        lgdt(&VAR_9);
    }

    write_ptbase(VAR_4);

#if defined(VAR_26) && defined(VAR_27)
    /* COMMENT_5 */
    if ( VAR_28 && is_pv_domain(VAR_7) && !is_pv_32bit_domain(VAR_7) &&
         !is_idle_domain(VAR_7) && !(read_cr4() & VAR_29) )
        svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif

    if ( need_full_gdt(VAR_7) &&
         ((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_6)) )
    {
        VAR_9.limit = VAR_24;
        VAR_9.base = GDT_VIRT_START(VAR_4);

        lgdt(&VAR_9);
    }

    if ( VAR_6 != VAR_7 )
        cpumask_clear_cpu(VAR_1, VAR_6->dirty_cpumask);
    write_atomic(&VAR_2->dirty_cpu, VAR_30);

    per_cpu(VAR_3, VAR_1) = VAR_4;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -72,8 +72,8 @@
 
 #if defined(CONFIG_PV) && defined(CONFIG_HVM)
     /* Prefetch the VMCB if we expect to use it later in the context switch */
-    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&
-         !cpu_has_fsgsbase && cpu_has_svm )
+    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&
+         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )
         svm_load_segs(0, 0, 0, 0, 0, 0, 0);
 #endif
 ","{'deleted_lines': ['    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&', '         !cpu_has_fsgsbase && cpu_has_svm )'], 'added_lines': ['    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&', '         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/pv/domain.c,load_segments,"static void load_segments(struct vcpu *n)
{
struct cpu_user_regs *uregs = &n->arch.user_regs;
int all_segs_okay = 1;
unsigned int dirty_segment_mask, cpu = smp_processor_id();
bool fs_gs_done = false;
dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);
per_cpu(dirty_segment_mask, cpu) = 0;
#ifdef CONFIG_HVM
if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&
!((uregs->fs | uregs->gs) & ~3) &&
(n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )
{
unsigned long gsb = n->arch.flags & TF_kernel_mode
? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;
unsigned long gss = n->arch.flags & TF_kernel_mode
? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;
fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),
uregs->fs, n->arch.pv.fs_base,
uregs->gs, gsb, gss);
}
#endif
if ( !fs_gs_done )
load_LDT(n);
if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )
{
preload_segment(ds, uregs->ds);
all_segs_okay &= loadsegment(ds, uregs->ds);
}
if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )
{
preload_segment(es, uregs->es);
all_segs_okay &= loadsegment(es, uregs->es);
}
if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )
{
all_segs_okay &= loadsegment(fs, uregs->fs);
if ( uregs->fs & ~3 )
dirty_segment_mask &= ~DIRTY_FS_BASE;
}
if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )
{
all_segs_okay &= loadsegment(gs, uregs->gs);
if ( uregs->gs & ~3 )
dirty_segment_mask &= ~DIRTY_GS_BASE;
}
if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )
{
if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )
wrfsbase(n->arch.pv.fs_base);
wrgsshadow(n->arch.pv.gs_base_kernel);
if ( n->arch.pv.gs_base_user |
(dirty_segment_mask & DIRTY_GS_BASE) )
wrgsbase(n->arch.pv.gs_base_user);
if ( (n->arch.flags & TF_kernel_mode) )
asm volatile ( ""swapgs"" );
}
if ( unlikely(!all_segs_okay) )
{
struct pv_vcpu *pv = &n->arch.pv;
struct cpu_user_regs *regs = guest_cpu_user_regs();
unsigned long *rsp =
(unsigned long *)(((n->arch.flags & TF_kernel_mode)
? regs->rsp : pv->kernel_sp) & ~0xf);
unsigned long cs_and_mask, rflags;
rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);
rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;
if ( VM_ASSIST(n->domain, architectural_iopl) )
rflags |= n->arch.pv.iopl;
if ( is_pv_32bit_vcpu(n) )
{
unsigned int *esp = ring_1(regs) ?
(unsigned int *)regs->rsp :
(unsigned int *)pv->kernel_sp;
int ret = 0;
cs_and_mask = (unsigned short)regs->cs |
((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);
if ( !ring_1(regs) )
{
ret  = put_user(regs->ss,       esp-1);
ret |= put_user(regs->esp,      esp-2);
esp -= 2;
}
if ( ret |
put_user(rflags,              esp-1) |
put_user(cs_and_mask,         esp-2) |
put_user(regs->eip,           esp-3) |
put_user(uregs->gs,           esp-4) |
put_user(uregs->fs,           esp-5) |
put_user(uregs->es,           esp-6) |
put_user(uregs->ds,           esp-7) )
{
gprintk(XENLOG_ERR,
""error while creating compat failsafe callback frame\n"");
domain_crash(n->domain);
}
if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
vcpu_info(n, evtchn_upcall_mask) = 1;
regs->entry_vector |= TRAP_syscall;
regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|
X86_EFLAGS_IOPL|X86_EFLAGS_TF);
regs->ss            = FLAT_COMPAT_KERNEL_SS;
regs->esp           = (unsigned long)(esp-7);
regs->cs            = FLAT_COMPAT_KERNEL_CS;
regs->eip           = pv->failsafe_callback_eip;
return;
}
if ( !(n->arch.flags & TF_kernel_mode) )
toggle_guest_mode(n);
else
regs->cs &= ~3;
cs_and_mask = (unsigned long)regs->cs |
((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);
if ( put_user(regs->ss,            rsp- 1) |
put_user(regs->rsp,           rsp- 2) |
put_user(rflags,              rsp- 3) |
put_user(cs_and_mask,         rsp- 4) |
put_user(regs->rip,           rsp- 5) |
put_user(uregs->gs,           rsp- 6) |
put_user(uregs->fs,           rsp- 7) |
put_user(uregs->es,           rsp- 8) |
put_user(uregs->ds,           rsp- 9) |
put_user(regs->r11,           rsp-10) |
put_user(regs->rcx,           rsp-11) )
{
gprintk(XENLOG_ERR,
""error while creating failsafe callback frame\n"");
domain_crash(n->domain);
}
if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
vcpu_info(n, evtchn_upcall_mask) = 1;
regs->entry_vector |= TRAP_syscall;
regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|
X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);
regs->ss            = FLAT_KERNEL_SS;
regs->rsp           = (unsigned long)(rsp-11);
regs->cs            = FLAT_KERNEL_CS;
regs->rip           = pv->failsafe_callback_eip;
}
}","static void load_segments(struct vcpu *VAR_0)
{
struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
int VAR_2 = 1;
unsigned int VAR_3, VAR_4 = smp_processor_id();
bool VAR_5 = false;
VAR_3 = per_cpu(VAR_3, VAR_4);
per_cpu(VAR_3, VAR_4) = 0;
#ifdef VAR_6
if ( !is_pv_32bit_vcpu(VAR_0) && !VAR_7 && VAR_8 &&
!((VAR_1->fs | VAR_1->gs) & ~3) &&
(VAR_0->arch.pv.fs_base | VAR_0->arch.pv.gs_base_user | VAR_0->arch.pv.ldt_ents) )
{
unsigned long VAR_9 = VAR_0->arch.flags & VAR_10
? VAR_0->arch.pv.gs_base_kernel : VAR_0->arch.pv.gs_base_user;
unsigned long VAR_11 = VAR_0->arch.flags & VAR_10
? VAR_0->arch.pv.gs_base_user : VAR_0->arch.pv.gs_base_kernel;
VAR_5 = svm_load_segs(VAR_0->arch.pv.ldt_ents, LDT_VIRT_START(VAR_0),
VAR_1->fs, VAR_0->arch.pv.fs_base,
VAR_1->gs, VAR_9, VAR_11);
}
#endif
if ( !VAR_5 )
load_LDT(VAR_0);
if ( unlikely((VAR_3 & VAR_12) | VAR_1->ds) )
{
preload_segment(VAR_13, VAR_1->ds);
VAR_2 &= loadsegment(VAR_13, VAR_1->ds);
}
if ( unlikely((VAR_3 & VAR_14) | VAR_1->es) )
{
preload_segment(VAR_15, VAR_1->es);
VAR_2 &= loadsegment(VAR_15, VAR_1->es);
}
if ( unlikely((VAR_3 & VAR_16) | VAR_1->fs) && !VAR_5 )
{
VAR_2 &= loadsegment(VAR_17, VAR_1->fs);
if ( VAR_1->fs & ~3 )
VAR_3 &= ~VAR_18;
}
if ( unlikely((VAR_3 & VAR_19) | VAR_1->gs) && !VAR_5 )
{
VAR_2 &= loadsegment(VAR_20, VAR_1->gs);
if ( VAR_1->gs & ~3 )
VAR_3 &= ~VAR_21;
}
if ( !VAR_5 && !is_pv_32bit_vcpu(VAR_0) )
{
if ( VAR_0->arch.pv.fs_base | (VAR_3 & VAR_18) )
wrfsbase(VAR_0->arch.pv.fs_base);
wrgsshadow(VAR_0->arch.pv.gs_base_kernel);
if ( VAR_0->arch.pv.gs_base_user |
(VAR_3 & VAR_21) )
wrgsbase(VAR_0->arch.pv.gs_base_user);
if ( (VAR_0->arch.flags & VAR_10) )
VAR_22 volatile ( ""swapgs"" );
}
if ( unlikely(!VAR_2) )
{
struct pv_vcpu *VAR_23 = &VAR_0->arch.pv;
struct cpu_user_regs *VAR_24 = guest_cpu_user_regs();
unsigned long *VAR_25 =
(unsigned long *)(((VAR_0->arch.flags & VAR_10)
? VAR_24->rsp : VAR_23->kernel_sp) & ~0xf);
unsigned long VAR_26, VAR_27;
VAR_27  = VAR_24->rflags & ~(VAR_28|VAR_29);
VAR_27 |= !vcpu_info(VAR_0, VAR_30) << 9;
if ( VM_ASSIST(VAR_0->domain, VAR_31) )
VAR_27 |= VAR_0->arch.pv.iopl;
if ( is_pv_32bit_vcpu(VAR_0) )
{
unsigned int *VAR_32 = ring_1(VAR_24) ?
(unsigned int *)VAR_24->rsp :
(unsigned int *)VAR_23->kernel_sp;
int VAR_33 = 0;
VAR_26 = (unsigned short)VAR_24->cs |
((unsigned int)vcpu_info(VAR_0, VAR_30) << 16);
if ( !ring_1(VAR_24) )
{
VAR_33  = put_user(VAR_24->ss,       VAR_32-1);
VAR_33 |= put_user(VAR_24->esp,      VAR_32-2);
VAR_32 -= 2;
}
if ( VAR_33 |
put_user(VAR_27,              VAR_32-1) |
put_user(VAR_26,         VAR_32-2) |
put_user(VAR_24->eip,           VAR_32-3) |
put_user(VAR_1->gs,           VAR_32-4) |
put_user(VAR_1->fs,           VAR_32-5) |
put_user(VAR_1->es,           VAR_32-6) |
put_user(VAR_1->ds,           VAR_32-7) )
{
gprintk(VAR_34,
""error while creating compat failsafe callback frame\n"");
domain_crash(VAR_0->domain);
}
if ( VAR_0->arch.vgc_flags & VAR_35 )
vcpu_info(VAR_0, VAR_30) = 1;
VAR_24->entry_vector |= VAR_36;
VAR_24->eflags       &= ~(VAR_37|VAR_38|VAR_39|
VAR_29|VAR_40);
VAR_24->ss            = VAR_41;
VAR_24->esp           = (unsigned long)(VAR_32-7);
VAR_24->cs            = VAR_42;
VAR_24->eip           = VAR_23->failsafe_callback_eip;
return;
}
if ( !(VAR_0->arch.flags & VAR_10) )
toggle_guest_mode(VAR_0);
else
VAR_24->cs &= ~3;
VAR_26 = (unsigned long)VAR_24->cs |
((unsigned long)vcpu_info(VAR_0, VAR_30) << 32);
if ( put_user(VAR_24->ss,            VAR_25- 1) |
put_user(VAR_24->rsp,           VAR_25- 2) |
put_user(VAR_27,              VAR_25- 3) |
put_user(VAR_26,         VAR_25- 4) |
put_user(VAR_24->rip,           VAR_25- 5) |
put_user(VAR_1->gs,           VAR_25- 6) |
put_user(VAR_1->fs,           VAR_25- 7) |
put_user(VAR_1->es,           VAR_25- 8) |
put_user(VAR_1->ds,           VAR_25- 9) |
put_user(VAR_24->r11,           VAR_25-10) |
put_user(VAR_24->rcx,           VAR_25-11) )
{
gprintk(VAR_34,
""error while creating failsafe callback frame\n"");
domain_crash(VAR_0->domain);
}
if ( VAR_0->arch.vgc_flags & VAR_35 )
vcpu_info(VAR_0, VAR_30) = 1;
VAR_24->entry_vector |= VAR_36;
VAR_24->rflags       &= ~(VAR_43|VAR_37|VAR_38|
VAR_39|VAR_29|VAR_40);
VAR_24->ss            = VAR_44;
VAR_24->rsp           = (unsigned long)(VAR_25-11);
VAR_24->cs            = VAR_45;
VAR_24->rip           = VAR_23->failsafe_callback_eip;
}
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/0.json,"static void load_segments(struct vcpu *n)
{
    struct cpu_user_regs *uregs = &n->arch.user_regs;
    int all_segs_okay = 1;
    unsigned int dirty_segment_mask, cpu = smp_processor_id();
    bool fs_gs_done = false;

    /* Load and clear the dirty segment mask. */
    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);
    per_cpu(dirty_segment_mask, cpu) = 0;

#ifdef CONFIG_HVM
    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&
         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )
    {
        unsigned long gsb = n->arch.flags & TF_kernel_mode
            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;
        unsigned long gss = n->arch.flags & TF_kernel_mode
            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;

        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),
                                   uregs->fs, n->arch.pv.fs_base,
                                   uregs->gs, gsb, gss);
    }
#endif
    if ( !fs_gs_done )
        load_LDT(n);

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )
    {
        preload_segment(ds, uregs->ds);
        all_segs_okay &= loadsegment(ds, uregs->ds);
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )
    {
        preload_segment(es, uregs->es);
        all_segs_okay &= loadsegment(es, uregs->es);
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )
    {
        all_segs_okay &= loadsegment(fs, uregs->fs);
        /* non-nul selector updates fs_base */
        if ( uregs->fs & ~3 )
            dirty_segment_mask &= ~DIRTY_FS_BASE;
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )
    {
        all_segs_okay &= loadsegment(gs, uregs->gs);
        /* non-nul selector updates gs_base_user */
        if ( uregs->gs & ~3 )
            dirty_segment_mask &= ~DIRTY_GS_BASE;
    }

    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )
    {
        /* This can only be non-zero if selector is NULL. */
        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )
            wrfsbase(n->arch.pv.fs_base);

        /*
         * Most kernels have non-zero GS base, so don't bother testing.
         * (For old AMD hardware this is also a serialising instruction,
         * avoiding erratum #88.)
         */
        wrgsshadow(n->arch.pv.gs_base_kernel);

        /* This can only be non-zero if selector is NULL. */
        if ( n->arch.pv.gs_base_user |
             (dirty_segment_mask & DIRTY_GS_BASE) )
            wrgsbase(n->arch.pv.gs_base_user);

        /* If in kernel mode then switch the GS bases around. */
        if ( (n->arch.flags & TF_kernel_mode) )
            asm volatile ( ""swapgs"" );
    }

    if ( unlikely(!all_segs_okay) )
    {
        struct pv_vcpu *pv = &n->arch.pv;
        struct cpu_user_regs *regs = guest_cpu_user_regs();
        unsigned long *rsp =
            (unsigned long *)(((n->arch.flags & TF_kernel_mode)
                               ? regs->rsp : pv->kernel_sp) & ~0xf);
        unsigned long cs_and_mask, rflags;

        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */
        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);
        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;
        if ( VM_ASSIST(n->domain, architectural_iopl) )
            rflags |= n->arch.pv.iopl;

        if ( is_pv_32bit_vcpu(n) )
        {
            unsigned int *esp = ring_1(regs) ?
                                (unsigned int *)regs->rsp :
                                (unsigned int *)pv->kernel_sp;
            int ret = 0;

            /* CS longword also contains full evtchn_upcall_mask. */
            cs_and_mask = (unsigned short)regs->cs |
                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);

            if ( !ring_1(regs) )
            {
                ret  = put_user(regs->ss,       esp-1);
                ret |= put_user(regs->esp,      esp-2);
                esp -= 2;
            }

            if ( ret |
                 put_user(rflags,              esp-1) |
                 put_user(cs_and_mask,         esp-2) |
                 put_user(regs->eip,           esp-3) |
                 put_user(uregs->gs,           esp-4) |
                 put_user(uregs->fs,           esp-5) |
                 put_user(uregs->es,           esp-6) |
                 put_user(uregs->ds,           esp-7) )
            {
                gprintk(XENLOG_ERR,
                        ""error while creating compat failsafe callback frame\n"");
                domain_crash(n->domain);
            }

            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
                vcpu_info(n, evtchn_upcall_mask) = 1;

            regs->entry_vector |= TRAP_syscall;
            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|
                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);
            regs->ss            = FLAT_COMPAT_KERNEL_SS;
            regs->esp           = (unsigned long)(esp-7);
            regs->cs            = FLAT_COMPAT_KERNEL_CS;
            regs->eip           = pv->failsafe_callback_eip;
            return;
        }

        if ( !(n->arch.flags & TF_kernel_mode) )
            toggle_guest_mode(n);
        else
            regs->cs &= ~3;

        /* CS longword also contains full evtchn_upcall_mask. */
        cs_and_mask = (unsigned long)regs->cs |
            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);

        if ( put_user(regs->ss,            rsp- 1) |
             put_user(regs->rsp,           rsp- 2) |
             put_user(rflags,              rsp- 3) |
             put_user(cs_and_mask,         rsp- 4) |
             put_user(regs->rip,           rsp- 5) |
             put_user(uregs->gs,           rsp- 6) |
             put_user(uregs->fs,           rsp- 7) |
             put_user(uregs->es,           rsp- 8) |
             put_user(uregs->ds,           rsp- 9) |
             put_user(regs->r11,           rsp-10) |
             put_user(regs->rcx,           rsp-11) )
        {
            gprintk(XENLOG_ERR,
                    ""error while creating failsafe callback frame\n"");
            domain_crash(n->domain);
        }

        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
            vcpu_info(n, evtchn_upcall_mask) = 1;

        regs->entry_vector |= TRAP_syscall;
        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|
                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);
        regs->ss            = FLAT_KERNEL_SS;
        regs->rsp           = (unsigned long)(rsp-11);
        regs->cs            = FLAT_KERNEL_CS;
        regs->rip           = pv->failsafe_callback_eip;
    }
}","static void load_segments(struct vcpu *VAR_0)
{
    struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
    int VAR_2 = 1;
    unsigned int VAR_3, VAR_4 = smp_processor_id();
    bool VAR_5 = false;

    /* COMMENT_0 */
    VAR_3 = per_cpu(VAR_3, VAR_4);
    per_cpu(VAR_3, VAR_4) = 0;

#ifdef VAR_6
    if ( VAR_7 && !is_pv_32bit_vcpu(VAR_0) &&
         !(read_cr4() & VAR_8) && !((VAR_1->fs | VAR_1->gs) & ~3) )
    {
        unsigned long VAR_9 = VAR_0->arch.flags & VAR_10
            ? VAR_0->arch.pv.gs_base_kernel : VAR_0->arch.pv.gs_base_user;
        unsigned long VAR_11 = VAR_0->arch.flags & VAR_10
            ? VAR_0->arch.pv.gs_base_user : VAR_0->arch.pv.gs_base_kernel;

        VAR_5 = svm_load_segs(VAR_0->arch.pv.ldt_ents, LDT_VIRT_START(VAR_0),
                                   VAR_1->fs, VAR_0->arch.pv.fs_base,
                                   VAR_1->gs, VAR_9, VAR_11);
    }
#endif
    if ( !VAR_5 )
        load_LDT(VAR_0);

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_12) | VAR_1->ds) )
    {
        preload_segment(VAR_13, VAR_1->ds);
        VAR_2 &= loadsegment(VAR_13, VAR_1->ds);
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_14) | VAR_1->es) )
    {
        preload_segment(VAR_15, VAR_1->es);
        VAR_2 &= loadsegment(VAR_15, VAR_1->es);
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_16) | VAR_1->fs) && !VAR_5 )
    {
        VAR_2 &= loadsegment(VAR_17, VAR_1->fs);
        /* COMMENT_2 */
        if ( VAR_1->fs & ~3 )
            VAR_3 &= ~VAR_18;
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_19) | VAR_1->gs) && !VAR_5 )
    {
        VAR_2 &= loadsegment(VAR_20, VAR_1->gs);
        /* COMMENT_3 */
        if ( VAR_1->gs & ~3 )
            VAR_3 &= ~VAR_21;
    }

    if ( !VAR_5 && !is_pv_32bit_vcpu(VAR_0) )
    {
        /* COMMENT_4 */
        if ( VAR_0->arch.pv.fs_base | (VAR_3 & VAR_18) )
            wrfsbase(VAR_0->arch.pv.fs_base);

        /* COMMENT_5 */
                                                                       
                                                                        
                                 
           
        wrgsshadow(VAR_0->arch.pv.gs_base_kernel);

        /* COMMENT_4 */
        if ( VAR_0->arch.pv.gs_base_user |
             (VAR_3 & VAR_21) )
            wrgsbase(VAR_0->arch.pv.gs_base_user);

        /* COMMENT_10 */
        if ( (VAR_0->arch.flags & VAR_10) )
            VAR_22 volatile ( ""swapgs"" );
    }

    if ( unlikely(!VAR_2) )
    {
        struct pv_vcpu *VAR_23 = &VAR_0->arch.pv;
        struct cpu_user_regs *VAR_24 = guest_cpu_user_regs();
        unsigned long *VAR_25 =
            (unsigned long *)(((VAR_0->arch.flags & VAR_10)
                               ? VAR_24->rsp : VAR_23->kernel_sp) & ~0xf);
        unsigned long VAR_26, VAR_27;

        /* COMMENT_11 */
        VAR_27  = VAR_24->rflags & ~(VAR_28|VAR_29);
        VAR_27 |= !vcpu_info(VAR_0, VAR_30) << 9;
        if ( VM_ASSIST(VAR_0->domain, VAR_31) )
            VAR_27 |= VAR_0->arch.pv.iopl;

        if ( is_pv_32bit_vcpu(VAR_0) )
        {
            unsigned int *VAR_32 = ring_1(VAR_24) ?
                                (unsigned int *)VAR_24->rsp :
                                (unsigned int *)VAR_23->kernel_sp;
            int VAR_33 = 0;

            /* COMMENT_12 */
            VAR_26 = (unsigned short)VAR_24->cs |
                ((unsigned int)vcpu_info(VAR_0, VAR_30) << 16);

            if ( !ring_1(VAR_24) )
            {
                VAR_33  = put_user(VAR_24->ss,       VAR_32-1);
                VAR_33 |= put_user(VAR_24->esp,      VAR_32-2);
                VAR_32 -= 2;
            }

            if ( VAR_33 |
                 put_user(VAR_27,              VAR_32-1) |
                 put_user(VAR_26,         VAR_32-2) |
                 put_user(VAR_24->eip,           VAR_32-3) |
                 put_user(VAR_1->gs,           VAR_32-4) |
                 put_user(VAR_1->fs,           VAR_32-5) |
                 put_user(VAR_1->es,           VAR_32-6) |
                 put_user(VAR_1->ds,           VAR_32-7) )
            {
                gprintk(VAR_34,
                        ""error while creating compat failsafe callback frame\n"");
                domain_crash(VAR_0->domain);
            }

            if ( VAR_0->arch.vgc_flags & VAR_35 )
                vcpu_info(VAR_0, VAR_30) = 1;

            VAR_24->entry_vector |= VAR_36;
            VAR_24->eflags       &= ~(VAR_37|VAR_38|VAR_39|
                                    VAR_29|VAR_40);
            VAR_24->ss            = VAR_41;
            VAR_24->esp           = (unsigned long)(VAR_32-7);
            VAR_24->cs            = VAR_42;
            VAR_24->eip           = VAR_23->failsafe_callback_eip;
            return;
        }

        if ( !(VAR_0->arch.flags & VAR_10) )
            toggle_guest_mode(VAR_0);
        else
            VAR_24->cs &= ~3;

        /* COMMENT_12 */
        VAR_26 = (unsigned long)VAR_24->cs |
            ((unsigned long)vcpu_info(VAR_0, VAR_30) << 32);

        if ( put_user(VAR_24->ss,            VAR_25- 1) |
             put_user(VAR_24->rsp,           VAR_25- 2) |
             put_user(VAR_27,              VAR_25- 3) |
             put_user(VAR_26,         VAR_25- 4) |
             put_user(VAR_24->rip,           VAR_25- 5) |
             put_user(VAR_1->gs,           VAR_25- 6) |
             put_user(VAR_1->fs,           VAR_25- 7) |
             put_user(VAR_1->es,           VAR_25- 8) |
             put_user(VAR_1->ds,           VAR_25- 9) |
             put_user(VAR_24->r11,           VAR_25-10) |
             put_user(VAR_24->rcx,           VAR_25-11) )
        {
            gprintk(VAR_34,
                    ""error while creating failsafe callback frame\n"");
            domain_crash(VAR_0->domain);
        }

        if ( VAR_0->arch.vgc_flags & VAR_35 )
            vcpu_info(VAR_0, VAR_30) = 1;

        VAR_24->entry_vector |= VAR_36;
        VAR_24->rflags       &= ~(VAR_43|VAR_37|VAR_38|
                                VAR_39|VAR_29|VAR_40);
        VAR_24->ss            = VAR_44;
        VAR_24->rsp           = (unsigned long)(VAR_25-11);
        VAR_24->cs            = VAR_45;
        VAR_24->rip           = VAR_23->failsafe_callback_eip;
    }
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,13 +10,8 @@
     per_cpu(dirty_segment_mask, cpu) = 0;
 
 #ifdef CONFIG_HVM
-    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&
-         !((uregs->fs | uregs->gs) & ~3) &&
-         /*
-          * The remaining part is just for optimization: If only shadow GS
-          * needs loading, there's nothing to be gained here.
-          */
-         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )
+    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&
+         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )
     {
         unsigned long gsb = n->arch.flags & TF_kernel_mode
             ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;","{'deleted_lines': ['    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&', '         !((uregs->fs | uregs->gs) & ~3) &&', '         /*', '          * The remaining part is just for optimization: If only shadow GS', ""          * needs loading, there's nothing to be gained here."", '          */', '         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )'], 'added_lines': ['    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&', '         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/processor.h,write_cr4,"static inline void write_cr4(unsigned long val)
{
ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));
get_cpu_info()->cr4 = val;
asm volatile ( ""mov %0,%%cr4"" : : ""r"" (val) );
}","static inline void write_cr4(unsigned long VAR_0)
{
ASSERT(!(VAR_0 & VAR_1) || !(VAR_0 & VAR_2));
get_cpu_info()->cr4 = VAR_0;
asm volatile ( ""mov %0,%%cr4"" : : ""r"" (VAR_0) );
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/processor.h/vul/before/0.json,"static inline void write_cr4(unsigned long val)
{
    struct cpu_info *info = get_cpu_info();

    /* No global pages in case of PCIDs enabled! */
    ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));

    /*
     * On hardware supporting FSGSBASE, the value in %cr4 is the kernel's
     * choice for 64bit PV guests, which impacts whether Xen can use the
     * instructions.
     *
     * The {rd,wr}{fs,gs}base() helpers use info->cr4 to work out whether it
     * is safe to execute the {RD,WR}{FS,GS}BASE instruction, falling back to
     * the MSR path if not.  Some users require interrupt safety.
     *
     * If FSGSBASE is currently or about to become clear, reflect this in
     * info->cr4 before updating %cr4, so an interrupt which hits in the
     * middle won't observe FSGSBASE set in info->cr4 but clear in %cr4.
     */
    info->cr4 = val & (info->cr4 | ~X86_CR4_FSGSBASE);

    asm volatile ( ""mov %[val], %%cr4""
                   : ""+m"" (info->cr4) /* Force ordering without a barrier. */
                   : [val] ""r"" (val) );

    info->cr4 = val;
}","static inline void write_cr4(unsigned long VAR_0)
{
    struct cpu_info *VAR_1 = get_cpu_info();

    /* COMMENT_0 */
    ASSERT(!(VAR_0 & VAR_2) || !(VAR_0 & VAR_3));

    /* COMMENT_1 */
                                                                         
                                                                        
                    
      
                                                                            
                                                                             
                                                                 
      
                                                                         
                                                                        
                                                                        
       
    VAR_1->cr4 = VAR_0 & (VAR_1->cr4 | ~VAR_4);

    asm volatile ( ""mov %[val], %%cr4""
                   : ""+m"" (VAR_1->cr4) /* COMMENT_13 */
                   : [VAR_0] ""r"" (VAR_0) );

    VAR_1->cr4 = VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/processor.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,28 @@
 static inline void write_cr4(unsigned long val)
 {
+    struct cpu_info *info = get_cpu_info();
+
     /* No global pages in case of PCIDs enabled! */
     ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));
 
-    get_cpu_info()->cr4 = val;
-    asm volatile ( ""mov %0,%%cr4"" : : ""r"" (val) );
+    /*
+     * On hardware supporting FSGSBASE, the value in %cr4 is the kernel's
+     * choice for 64bit PV guests, which impacts whether Xen can use the
+     * instructions.
+     *
+     * The {rd,wr}{fs,gs}base() helpers use info->cr4 to work out whether it
+     * is safe to execute the {RD,WR}{FS,GS}BASE instruction, falling back to
+     * the MSR path if not.  Some users require interrupt safety.
+     *
+     * If FSGSBASE is currently or about to become clear, reflect this in
+     * info->cr4 before updating %cr4, so an interrupt which hits in the
+     * middle won't observe FSGSBASE set in info->cr4 but clear in %cr4.
+     */
+    info->cr4 = val & (info->cr4 | ~X86_CR4_FSGSBASE);
+
+    asm volatile ( ""mov %[val], %%cr4""
+                   : ""+m"" (info->cr4) /* Force ordering without a barrier. */
+                   : [val] ""r"" (val) );
+
+    info->cr4 = val;
 }","{'deleted_lines': ['    get_cpu_info()->cr4 = val;', '    asm volatile ( ""mov %0,%%cr4"" : : ""r"" (val) );'], 'added_lines': ['    struct cpu_info *info = get_cpu_info();', '', '    /*', ""     * On hardware supporting FSGSBASE, the value in %cr4 is the kernel's"", '     * choice for 64bit PV guests, which impacts whether Xen can use the', '     * instructions.', '     *', '     * The {rd,wr}{fs,gs}base() helpers use info->cr4 to work out whether it', '     * is safe to execute the {RD,WR}{FS,GS}BASE instruction, falling back to', '     * the MSR path if not.  Some users require interrupt safety.', '     *', '     * If FSGSBASE is currently or about to become clear, reflect this in', '     * info->cr4 before updating %cr4, so an interrupt which hits in the', ""     * middle won't observe FSGSBASE set in info->cr4 but clear in %cr4."", '     */', '    info->cr4 = val & (info->cr4 | ~X86_CR4_FSGSBASE);', '', '    asm volatile ( ""mov %[val], %%cr4""', '                   : ""+m"" (info->cr4) /* Force ordering without a barrier. */', '                   : [val] ""r"" (val) );', '', '    info->cr4 = val;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/domain.c,save_segments,"static void save_segments(struct vcpu *v)
{
struct cpu_user_regs *regs = &v->arch.user_regs;
unsigned int dirty_segment_mask = 0;
regs->ds = read_sreg(ds);
regs->es = read_sreg(es);
regs->fs = read_sreg(fs);
regs->gs = read_sreg(gs);
if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )
{
v->arch.pv.fs_base = __rdfsbase();
if ( v->arch.flags & TF_kernel_mode )
v->arch.pv.gs_base_kernel = __rdgsbase();
else
v->arch.pv.gs_base_user = __rdgsbase();
}
if ( regs->ds )
dirty_segment_mask |= DIRTY_DS;
if ( regs->es )
dirty_segment_mask |= DIRTY_ES;
if ( regs->fs || is_pv_32bit_vcpu(v) )
{
dirty_segment_mask |= DIRTY_FS;
if ( regs->fs & ~3 )
v->arch.pv.fs_base = 0;
}
if ( v->arch.pv.fs_base )
dirty_segment_mask |= DIRTY_FS_BASE;
if ( regs->gs || is_pv_32bit_vcpu(v) )
{
dirty_segment_mask |= DIRTY_GS;
if ( regs->gs & ~3 )
v->arch.pv.gs_base_user = 0;
}
if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel
: v->arch.pv.gs_base_user )
dirty_segment_mask |= DIRTY_GS_BASE;
this_cpu(dirty_segment_mask) = dirty_segment_mask;
}","static void save_segments(struct vcpu *VAR_0)
{
struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
unsigned int VAR_2 = 0;
VAR_1->ds = read_sreg(VAR_3);
VAR_1->es = read_sreg(VAR_4);
VAR_1->fs = read_sreg(VAR_5);
VAR_1->gs = read_sreg(VAR_6);
if ( VAR_7 && !is_pv_32bit_vcpu(VAR_0) )
{
VAR_0->arch.pv.fs_base = __rdfsbase();
if ( VAR_0->arch.flags & VAR_8 )
VAR_0->arch.pv.gs_base_kernel = __rdgsbase();
else
VAR_0->arch.pv.gs_base_user = __rdgsbase();
}
if ( VAR_1->ds )
VAR_2 |= VAR_9;
if ( VAR_1->es )
VAR_2 |= VAR_10;
if ( VAR_1->fs || is_pv_32bit_vcpu(VAR_0) )
{
VAR_2 |= VAR_11;
if ( VAR_1->fs & ~3 )
VAR_0->arch.pv.fs_base = 0;
}
if ( VAR_0->arch.pv.fs_base )
VAR_2 |= VAR_12;
if ( VAR_1->gs || is_pv_32bit_vcpu(VAR_0) )
{
VAR_2 |= VAR_13;
if ( VAR_1->gs & ~3 )
VAR_0->arch.pv.gs_base_user = 0;
}
if ( VAR_0->arch.flags & VAR_8 ? VAR_0->arch.pv.gs_base_kernel
: VAR_0->arch.pv.gs_base_user )
VAR_2 |= VAR_14;
this_cpu(VAR_2) = VAR_2;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/2.json,"static void save_segments(struct vcpu *v)
{
    struct cpu_user_regs *regs = &v->arch.user_regs;
    unsigned int dirty_segment_mask = 0;

    regs->ds = read_sreg(ds);
    regs->es = read_sreg(es);
    regs->fs = read_sreg(fs);
    regs->gs = read_sreg(gs);

    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */
    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )
    {
        v->arch.pv.fs_base = __rdfsbase();
        if ( v->arch.flags & TF_kernel_mode )
            v->arch.pv.gs_base_kernel = __rdgsbase();
        else
            v->arch.pv.gs_base_user = __rdgsbase();
    }

    if ( regs->ds )
        dirty_segment_mask |= DIRTY_DS;

    if ( regs->es )
        dirty_segment_mask |= DIRTY_ES;

    if ( regs->fs || is_pv_32bit_vcpu(v) )
    {
        dirty_segment_mask |= DIRTY_FS;
        /* non-nul selector kills fs_base */
        if ( regs->fs & ~3 )
            v->arch.pv.fs_base = 0;
    }
    if ( v->arch.pv.fs_base )
        dirty_segment_mask |= DIRTY_FS_BASE;

    if ( regs->gs || is_pv_32bit_vcpu(v) )
    {
        dirty_segment_mask |= DIRTY_GS;
        /* non-nul selector kills gs_base_user */
        if ( regs->gs & ~3 )
            v->arch.pv.gs_base_user = 0;
    }
    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel
                                        : v->arch.pv.gs_base_user )
        dirty_segment_mask |= DIRTY_GS_BASE;

    this_cpu(dirty_segment_mask) = dirty_segment_mask;
}","static void save_segments(struct vcpu *VAR_0)
{
    struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
    unsigned int VAR_2 = 0;

    VAR_1->ds = read_sreg(VAR_3);
    VAR_1->es = read_sreg(VAR_4);
    VAR_1->fs = read_sreg(VAR_5);
    VAR_1->gs = read_sreg(VAR_6);

    /* COMMENT_0 */
    if ( (read_cr4() & VAR_7) && !is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_0->arch.pv.fs_base = __rdfsbase();
        if ( VAR_0->arch.flags & VAR_8 )
            VAR_0->arch.pv.gs_base_kernel = __rdgsbase();
        else
            VAR_0->arch.pv.gs_base_user = __rdgsbase();
    }

    if ( VAR_1->ds )
        VAR_2 |= VAR_9;

    if ( VAR_1->es )
        VAR_2 |= VAR_10;

    if ( VAR_1->fs || is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_2 |= VAR_11;
        /* COMMENT_1 */
        if ( VAR_1->fs & ~3 )
            VAR_0->arch.pv.fs_base = 0;
    }
    if ( VAR_0->arch.pv.fs_base )
        VAR_2 |= VAR_12;

    if ( VAR_1->gs || is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_2 |= VAR_13;
        /* COMMENT_2 */
        if ( VAR_1->gs & ~3 )
            VAR_0->arch.pv.gs_base_user = 0;
    }
    if ( VAR_0->arch.flags & VAR_8 ? VAR_0->arch.pv.gs_base_kernel
                                        : VAR_0->arch.pv.gs_base_user )
        VAR_2 |= VAR_14;

    this_cpu(VAR_2) = VAR_2;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -8,7 +8,8 @@
     regs->fs = read_sreg(fs);
     regs->gs = read_sreg(gs);
 
-    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )
+    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */
+    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )
     {
         v->arch.pv.fs_base = __rdfsbase();
         if ( v->arch.flags & TF_kernel_mode )","{'deleted_lines': ['    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )'], 'added_lines': ['    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */', '    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/domain.c,__context_switch,"static void __context_switch(void)
{
struct cpu_user_regs *stack_regs = guest_cpu_user_regs();
unsigned int          cpu = smp_processor_id();
struct vcpu          *p = per_cpu(curr_vcpu, cpu);
struct vcpu          *n = current;
struct domain        *pd = p->domain, *nd = n->domain;
seg_desc_t           *gdt;
struct desc_ptr       gdt_desc;
ASSERT(p != n);
ASSERT(!vcpu_cpu_dirty(n));
if ( !is_idle_domain(pd) )
{
memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);
vcpu_save_fpu(p);
pd->arch.ctxt_switch->from(p);
}
if ( pd != nd )
cpumask_set_cpu(cpu, nd->dirty_cpumask);
write_atomic(&n->dirty_cpu, cpu);
if ( !is_idle_domain(nd) )
{
memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);
if ( cpu_has_xsave )
{
u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;
if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )
BUG();
if ( cpu_has_xsaves && is_hvm_vcpu(n) )
set_msr_xss(n->arch.hvm.msr_xss);
}
vcpu_restore_fpu_nonlazy(n, false);
nd->arch.ctxt_switch->to(n);
}
psr_ctxt_switch_to(nd);
gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :
per_cpu(compat_gdt_table, cpu);
if ( need_full_gdt(nd) )
{
unsigned long mfn = virt_to_mfn(gdt);
l1_pgentry_t *pl1e = pv_gdt_ptes(n);
unsigned int i;
for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )
l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,
l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));
}
if ( need_full_gdt(pd) &&
((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )
{
gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);
lgdt(&gdt_desc);
}
write_ptbase(n);
#if defined(CONFIG_PV) && defined(CONFIG_HVM)
if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&
!cpu_has_fsgsbase && cpu_has_svm )
svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif
if ( need_full_gdt(nd) &&
((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )
{
gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
gdt_desc.base = GDT_VIRT_START(n);
lgdt(&gdt_desc);
}
if ( pd != nd )
cpumask_clear_cpu(cpu, pd->dirty_cpumask);
write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);
per_cpu(curr_vcpu, cpu) = n;
}","static void __context_switch(void)
{
struct cpu_user_regs *VAR_0 = guest_cpu_user_regs();
unsigned int          VAR_1 = smp_processor_id();
struct vcpu          *VAR_2 = per_cpu(VAR_3, VAR_1);
struct vcpu          *VAR_4 = VAR_5;
struct domain        *VAR_6 = VAR_2->domain, *VAR_7 = VAR_4->domain;
seg_desc_t           *VAR_8;
struct desc_ptr       VAR_9;
ASSERT(VAR_2 != VAR_4);
ASSERT(!vcpu_cpu_dirty(VAR_4));
if ( !is_idle_domain(VAR_6) )
{
memcpy(&VAR_2->arch.user_regs, VAR_0, VAR_10);
vcpu_save_fpu(VAR_2);
VAR_6->arch.ctxt_switch->from(VAR_2);
}
if ( VAR_6 != VAR_7 )
cpumask_set_cpu(VAR_1, VAR_7->dirty_cpumask);
write_atomic(&VAR_4->dirty_cpu, VAR_1);
if ( !is_idle_domain(VAR_7) )
{
memcpy(VAR_0, &VAR_4->arch.user_regs, VAR_10);
if ( VAR_11 )
{
u64 VAR_12 = VAR_4->arch.xcr0 ?VAR_13: VAR_14;
if ( VAR_12 != get_xcr0() && !set_xcr0(VAR_12) )
BUG();
if ( VAR_15 && is_hvm_vcpu(VAR_4) )
set_msr_xss(VAR_4->arch.hvm.msr_xss);
}
vcpu_restore_fpu_nonlazy(VAR_4, false);
VAR_7->arch.ctxt_switch->to(VAR_4);
}
psr_ctxt_switch_to(VAR_7);
VAR_8 = !is_pv_32bit_domain(VAR_7) ? per_cpu(VAR_16, VAR_1) :
per_cpu(VAR_17, VAR_1);
if ( need_full_gdt(VAR_7) )
{
unsigned long VAR_18 = virt_to_mfn(VAR_8);
l1_pgentry_t *VAR_19 = pv_gdt_ptes(VAR_4);
unsigned int VAR_20;
for ( VAR_20 = 0; VAR_20 < VAR_21; VAR_20++ )
l1e_write(VAR_19 + VAR_22 + VAR_20,
l1e_from_pfn(VAR_18 + VAR_20, VAR_23));
}
if ( need_full_gdt(VAR_6) &&
((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_7)) )
{
VAR_9.limit = VAR_24;
VAR_9.base  = (unsigned long)(VAR_8 - VAR_25);
lgdt(&VAR_9);
}
write_ptbase(VAR_4);
#if defined(VAR_26) && defined(VAR_27)
if ( is_pv_domain(VAR_7) && !is_pv_32bit_domain(VAR_7) && !is_idle_domain(VAR_7) &&
!VAR_28 && VAR_29 )
svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif
if ( need_full_gdt(VAR_7) &&
((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_6)) )
{
VAR_9.limit = VAR_24;
VAR_9.base = GDT_VIRT_START(VAR_4);
lgdt(&VAR_9);
}
if ( VAR_6 != VAR_7 )
cpumask_clear_cpu(VAR_1, VAR_6->dirty_cpumask);
write_atomic(&VAR_2->dirty_cpu, VAR_30);
per_cpu(VAR_3, VAR_1) = VAR_4;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/1.json,"static void __context_switch(void)
{
    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();
    unsigned int          cpu = smp_processor_id();
    struct vcpu          *p = per_cpu(curr_vcpu, cpu);
    struct vcpu          *n = current;
    struct domain        *pd = p->domain, *nd = n->domain;
    seg_desc_t           *gdt;
    struct desc_ptr       gdt_desc;

    ASSERT(p != n);
    ASSERT(!vcpu_cpu_dirty(n));

    if ( !is_idle_domain(pd) )
    {
        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);
        vcpu_save_fpu(p);
        pd->arch.ctxt_switch->from(p);
    }

    /*
     * Mark this CPU in next domain's dirty cpumasks before calling
     * ctxt_switch_to(). This avoids a race on things like EPT flushing,
     * which is synchronised on that function.
     */
    if ( pd != nd )
        cpumask_set_cpu(cpu, nd->dirty_cpumask);
    write_atomic(&n->dirty_cpu, cpu);

    if ( !is_idle_domain(nd) )
    {
        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);
        if ( cpu_has_xsave )
        {
            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;

            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )
                BUG();

            if ( cpu_has_xsaves && is_hvm_vcpu(n) )
                set_msr_xss(n->arch.hvm.msr_xss);
        }
        vcpu_restore_fpu_nonlazy(n, false);
        nd->arch.ctxt_switch->to(n);
    }

    psr_ctxt_switch_to(nd);

    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :
                                    per_cpu(compat_gdt_table, cpu);
    if ( need_full_gdt(nd) )
    {
        unsigned long mfn = virt_to_mfn(gdt);
        l1_pgentry_t *pl1e = pv_gdt_ptes(n);
        unsigned int i;

        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )
            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,
                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));
    }

    if ( need_full_gdt(pd) &&
         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )
    {
        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);

        lgdt(&gdt_desc);
    }

    write_ptbase(n);

#if defined(CONFIG_PV) && defined(CONFIG_HVM)
    /* Prefetch the VMCB if we expect to use it later in the context switch */
    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&
         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )
        svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif

    if ( need_full_gdt(nd) &&
         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )
    {
        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;
        gdt_desc.base = GDT_VIRT_START(n);

        lgdt(&gdt_desc);
    }

    if ( pd != nd )
        cpumask_clear_cpu(cpu, pd->dirty_cpumask);
    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);

    per_cpu(curr_vcpu, cpu) = n;
}","static void __context_switch(void)
{
    struct cpu_user_regs *VAR_0 = guest_cpu_user_regs();
    unsigned int          VAR_1 = smp_processor_id();
    struct vcpu          *VAR_2 = per_cpu(VAR_3, VAR_1);
    struct vcpu          *VAR_4 = VAR_5;
    struct domain        *VAR_6 = VAR_2->domain, *VAR_7 = VAR_4->domain;
    seg_desc_t           *VAR_8;
    struct desc_ptr       VAR_9;

    ASSERT(VAR_2 != VAR_4);
    ASSERT(!vcpu_cpu_dirty(VAR_4));

    if ( !is_idle_domain(VAR_6) )
    {
        memcpy(&VAR_2->arch.user_regs, VAR_0, VAR_10);
        vcpu_save_fpu(VAR_2);
        VAR_6->arch.ctxt_switch->from(VAR_2);
    }

    /* COMMENT_0 */
                                                                   
                                                                        
                                              
       
    if ( VAR_6 != VAR_7 )
        cpumask_set_cpu(VAR_1, VAR_7->dirty_cpumask);
    write_atomic(&VAR_4->dirty_cpu, VAR_1);

    if ( !is_idle_domain(VAR_7) )
    {
        memcpy(VAR_0, &VAR_4->arch.user_regs, VAR_10);
        if ( VAR_11 )
        {
            u64 VAR_12 = VAR_4->arch.xcr0 ?VAR_13: VAR_14;

            if ( VAR_12 != get_xcr0() && !set_xcr0(VAR_12) )
                BUG();

            if ( VAR_15 && is_hvm_vcpu(VAR_4) )
                set_msr_xss(VAR_4->arch.hvm.msr_xss);
        }
        vcpu_restore_fpu_nonlazy(VAR_4, false);
        VAR_7->arch.ctxt_switch->to(VAR_4);
    }

    psr_ctxt_switch_to(VAR_7);

    VAR_8 = !is_pv_32bit_domain(VAR_7) ? per_cpu(VAR_16, VAR_1) :
                                    per_cpu(VAR_17, VAR_1);
    if ( need_full_gdt(VAR_7) )
    {
        unsigned long VAR_18 = virt_to_mfn(VAR_8);
        l1_pgentry_t *VAR_19 = pv_gdt_ptes(VAR_4);
        unsigned int VAR_20;

        for ( VAR_20 = 0; VAR_20 < VAR_21; VAR_20++ )
            l1e_write(VAR_19 + VAR_22 + VAR_20,
                      l1e_from_pfn(VAR_18 + VAR_20, VAR_23));
    }

    if ( need_full_gdt(VAR_6) &&
         ((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_7)) )
    {
        VAR_9.limit = VAR_24;
        VAR_9.base  = (unsigned long)(VAR_8 - VAR_25);

        lgdt(&VAR_9);
    }

    write_ptbase(VAR_4);

#if defined(VAR_26) && defined(VAR_27)
    /* COMMENT_5 */
    if ( VAR_28 && is_pv_domain(VAR_7) && !is_pv_32bit_domain(VAR_7) &&
         !is_idle_domain(VAR_7) && !(read_cr4() & VAR_29) )
        svm_load_segs(0, 0, 0, 0, 0, 0, 0);
#endif

    if ( need_full_gdt(VAR_7) &&
         ((VAR_2->vcpu_id != VAR_4->vcpu_id) || !need_full_gdt(VAR_6)) )
    {
        VAR_9.limit = VAR_24;
        VAR_9.base = GDT_VIRT_START(VAR_4);

        lgdt(&VAR_9);
    }

    if ( VAR_6 != VAR_7 )
        cpumask_clear_cpu(VAR_1, VAR_6->dirty_cpumask);
    write_atomic(&VAR_2->dirty_cpu, VAR_30);

    per_cpu(VAR_3, VAR_1) = VAR_4;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -72,8 +72,8 @@
 
 #if defined(CONFIG_PV) && defined(CONFIG_HVM)
     /* Prefetch the VMCB if we expect to use it later in the context switch */
-    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&
-         !cpu_has_fsgsbase && cpu_has_svm )
+    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&
+         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )
         svm_load_segs(0, 0, 0, 0, 0, 0, 0);
 #endif
 ","{'deleted_lines': ['    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&', '         !cpu_has_fsgsbase && cpu_has_svm )'], 'added_lines': ['    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&', '         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/domain.c,load_segments,"static void load_segments(struct vcpu *n)
{
struct cpu_user_regs *uregs = &n->arch.user_regs;
int all_segs_okay = 1;
unsigned int dirty_segment_mask, cpu = smp_processor_id();
bool fs_gs_done = false;
dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);
per_cpu(dirty_segment_mask, cpu) = 0;
#ifdef CONFIG_HVM
if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&
!((uregs->fs | uregs->gs) & ~3) &&
(n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )
{
unsigned long gsb = n->arch.flags & TF_kernel_mode
? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;
unsigned long gss = n->arch.flags & TF_kernel_mode
? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;
fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),
uregs->fs, n->arch.pv.fs_base,
uregs->gs, gsb, gss);
}
#endif
if ( !fs_gs_done )
load_LDT(n);
if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )
{
preload_segment(ds, uregs->ds);
all_segs_okay &= loadsegment(ds, uregs->ds);
}
if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )
{
preload_segment(es, uregs->es);
all_segs_okay &= loadsegment(es, uregs->es);
}
if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )
{
all_segs_okay &= loadsegment(fs, uregs->fs);
if ( uregs->fs & ~3 )
dirty_segment_mask &= ~DIRTY_FS_BASE;
}
if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )
{
all_segs_okay &= loadsegment(gs, uregs->gs);
if ( uregs->gs & ~3 )
dirty_segment_mask &= ~DIRTY_GS_BASE;
}
if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )
{
if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )
wrfsbase(n->arch.pv.fs_base);
wrgsshadow(n->arch.pv.gs_base_kernel);
if ( n->arch.pv.gs_base_user |
(dirty_segment_mask & DIRTY_GS_BASE) )
wrgsbase(n->arch.pv.gs_base_user);
if ( (n->arch.flags & TF_kernel_mode) )
asm volatile ( ""swapgs"" );
}
if ( unlikely(!all_segs_okay) )
{
struct pv_vcpu *pv = &n->arch.pv;
struct cpu_user_regs *regs = guest_cpu_user_regs();
unsigned long *rsp =
(unsigned long *)(((n->arch.flags & TF_kernel_mode)
? regs->rsp : pv->kernel_sp) & ~0xf);
unsigned long cs_and_mask, rflags;
rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);
rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;
if ( VM_ASSIST(n->domain, architectural_iopl) )
rflags |= n->arch.pv.iopl;
if ( is_pv_32bit_vcpu(n) )
{
unsigned int *esp = ring_1(regs) ?
(unsigned int *)regs->rsp :
(unsigned int *)pv->kernel_sp;
int ret = 0;
cs_and_mask = (unsigned short)regs->cs |
((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);
if ( !ring_1(regs) )
{
ret  = put_user(regs->ss,       esp-1);
ret |= put_user(regs->esp,      esp-2);
esp -= 2;
}
if ( ret |
put_user(rflags,              esp-1) |
put_user(cs_and_mask,         esp-2) |
put_user(regs->eip,           esp-3) |
put_user(uregs->gs,           esp-4) |
put_user(uregs->fs,           esp-5) |
put_user(uregs->es,           esp-6) |
put_user(uregs->ds,           esp-7) )
{
gprintk(XENLOG_ERR,
""error while creating compat failsafe callback frame\n"");
domain_crash(n->domain);
}
if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
vcpu_info(n, evtchn_upcall_mask) = 1;
regs->entry_vector |= TRAP_syscall;
regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|
X86_EFLAGS_IOPL|X86_EFLAGS_TF);
regs->ss            = FLAT_COMPAT_KERNEL_SS;
regs->esp           = (unsigned long)(esp-7);
regs->cs            = FLAT_COMPAT_KERNEL_CS;
regs->eip           = pv->failsafe_callback_eip;
return;
}
if ( !(n->arch.flags & TF_kernel_mode) )
toggle_guest_mode(n);
else
regs->cs &= ~3;
cs_and_mask = (unsigned long)regs->cs |
((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);
if ( put_user(regs->ss,            rsp- 1) |
put_user(regs->rsp,           rsp- 2) |
put_user(rflags,              rsp- 3) |
put_user(cs_and_mask,         rsp- 4) |
put_user(regs->rip,           rsp- 5) |
put_user(uregs->gs,           rsp- 6) |
put_user(uregs->fs,           rsp- 7) |
put_user(uregs->es,           rsp- 8) |
put_user(uregs->ds,           rsp- 9) |
put_user(regs->r11,           rsp-10) |
put_user(regs->rcx,           rsp-11) )
{
gprintk(XENLOG_ERR,
""error while creating failsafe callback frame\n"");
domain_crash(n->domain);
}
if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
vcpu_info(n, evtchn_upcall_mask) = 1;
regs->entry_vector |= TRAP_syscall;
regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|
X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);
regs->ss            = FLAT_KERNEL_SS;
regs->rsp           = (unsigned long)(rsp-11);
regs->cs            = FLAT_KERNEL_CS;
regs->rip           = pv->failsafe_callback_eip;
}
}","static void load_segments(struct vcpu *VAR_0)
{
struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
int VAR_2 = 1;
unsigned int VAR_3, VAR_4 = smp_processor_id();
bool VAR_5 = false;
VAR_3 = per_cpu(VAR_3, VAR_4);
per_cpu(VAR_3, VAR_4) = 0;
#ifdef VAR_6
if ( !is_pv_32bit_vcpu(VAR_0) && !VAR_7 && VAR_8 &&
!((VAR_1->fs | VAR_1->gs) & ~3) &&
(VAR_0->arch.pv.fs_base | VAR_0->arch.pv.gs_base_user | VAR_0->arch.pv.ldt_ents) )
{
unsigned long VAR_9 = VAR_0->arch.flags & VAR_10
? VAR_0->arch.pv.gs_base_kernel : VAR_0->arch.pv.gs_base_user;
unsigned long VAR_11 = VAR_0->arch.flags & VAR_10
? VAR_0->arch.pv.gs_base_user : VAR_0->arch.pv.gs_base_kernel;
VAR_5 = svm_load_segs(VAR_0->arch.pv.ldt_ents, LDT_VIRT_START(VAR_0),
VAR_1->fs, VAR_0->arch.pv.fs_base,
VAR_1->gs, VAR_9, VAR_11);
}
#endif
if ( !VAR_5 )
load_LDT(VAR_0);
if ( unlikely((VAR_3 & VAR_12) | VAR_1->ds) )
{
preload_segment(VAR_13, VAR_1->ds);
VAR_2 &= loadsegment(VAR_13, VAR_1->ds);
}
if ( unlikely((VAR_3 & VAR_14) | VAR_1->es) )
{
preload_segment(VAR_15, VAR_1->es);
VAR_2 &= loadsegment(VAR_15, VAR_1->es);
}
if ( unlikely((VAR_3 & VAR_16) | VAR_1->fs) && !VAR_5 )
{
VAR_2 &= loadsegment(VAR_17, VAR_1->fs);
if ( VAR_1->fs & ~3 )
VAR_3 &= ~VAR_18;
}
if ( unlikely((VAR_3 & VAR_19) | VAR_1->gs) && !VAR_5 )
{
VAR_2 &= loadsegment(VAR_20, VAR_1->gs);
if ( VAR_1->gs & ~3 )
VAR_3 &= ~VAR_21;
}
if ( !VAR_5 && !is_pv_32bit_vcpu(VAR_0) )
{
if ( VAR_0->arch.pv.fs_base | (VAR_3 & VAR_18) )
wrfsbase(VAR_0->arch.pv.fs_base);
wrgsshadow(VAR_0->arch.pv.gs_base_kernel);
if ( VAR_0->arch.pv.gs_base_user |
(VAR_3 & VAR_21) )
wrgsbase(VAR_0->arch.pv.gs_base_user);
if ( (VAR_0->arch.flags & VAR_10) )
VAR_22 volatile ( ""swapgs"" );
}
if ( unlikely(!VAR_2) )
{
struct pv_vcpu *VAR_23 = &VAR_0->arch.pv;
struct cpu_user_regs *VAR_24 = guest_cpu_user_regs();
unsigned long *VAR_25 =
(unsigned long *)(((VAR_0->arch.flags & VAR_10)
? VAR_24->rsp : VAR_23->kernel_sp) & ~0xf);
unsigned long VAR_26, VAR_27;
VAR_27  = VAR_24->rflags & ~(VAR_28|VAR_29);
VAR_27 |= !vcpu_info(VAR_0, VAR_30) << 9;
if ( VM_ASSIST(VAR_0->domain, VAR_31) )
VAR_27 |= VAR_0->arch.pv.iopl;
if ( is_pv_32bit_vcpu(VAR_0) )
{
unsigned int *VAR_32 = ring_1(VAR_24) ?
(unsigned int *)VAR_24->rsp :
(unsigned int *)VAR_23->kernel_sp;
int VAR_33 = 0;
VAR_26 = (unsigned short)VAR_24->cs |
((unsigned int)vcpu_info(VAR_0, VAR_30) << 16);
if ( !ring_1(VAR_24) )
{
VAR_33  = put_user(VAR_24->ss,       VAR_32-1);
VAR_33 |= put_user(VAR_24->esp,      VAR_32-2);
VAR_32 -= 2;
}
if ( VAR_33 |
put_user(VAR_27,              VAR_32-1) |
put_user(VAR_26,         VAR_32-2) |
put_user(VAR_24->eip,           VAR_32-3) |
put_user(VAR_1->gs,           VAR_32-4) |
put_user(VAR_1->fs,           VAR_32-5) |
put_user(VAR_1->es,           VAR_32-6) |
put_user(VAR_1->ds,           VAR_32-7) )
{
gprintk(VAR_34,
""error while creating compat failsafe callback frame\n"");
domain_crash(VAR_0->domain);
}
if ( VAR_0->arch.vgc_flags & VAR_35 )
vcpu_info(VAR_0, VAR_30) = 1;
VAR_24->entry_vector |= VAR_36;
VAR_24->eflags       &= ~(VAR_37|VAR_38|VAR_39|
VAR_29|VAR_40);
VAR_24->ss            = VAR_41;
VAR_24->esp           = (unsigned long)(VAR_32-7);
VAR_24->cs            = VAR_42;
VAR_24->eip           = VAR_23->failsafe_callback_eip;
return;
}
if ( !(VAR_0->arch.flags & VAR_10) )
toggle_guest_mode(VAR_0);
else
VAR_24->cs &= ~3;
VAR_26 = (unsigned long)VAR_24->cs |
((unsigned long)vcpu_info(VAR_0, VAR_30) << 32);
if ( put_user(VAR_24->ss,            VAR_25- 1) |
put_user(VAR_24->rsp,           VAR_25- 2) |
put_user(VAR_27,              VAR_25- 3) |
put_user(VAR_26,         VAR_25- 4) |
put_user(VAR_24->rip,           VAR_25- 5) |
put_user(VAR_1->gs,           VAR_25- 6) |
put_user(VAR_1->fs,           VAR_25- 7) |
put_user(VAR_1->es,           VAR_25- 8) |
put_user(VAR_1->ds,           VAR_25- 9) |
put_user(VAR_24->r11,           VAR_25-10) |
put_user(VAR_24->rcx,           VAR_25-11) )
{
gprintk(VAR_34,
""error while creating failsafe callback frame\n"");
domain_crash(VAR_0->domain);
}
if ( VAR_0->arch.vgc_flags & VAR_35 )
vcpu_info(VAR_0, VAR_30) = 1;
VAR_24->entry_vector |= VAR_36;
VAR_24->rflags       &= ~(VAR_43|VAR_37|VAR_38|
VAR_39|VAR_29|VAR_40);
VAR_24->ss            = VAR_44;
VAR_24->rsp           = (unsigned long)(VAR_25-11);
VAR_24->cs            = VAR_45;
VAR_24->rip           = VAR_23->failsafe_callback_eip;
}
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/0.json,"static void load_segments(struct vcpu *n)
{
    struct cpu_user_regs *uregs = &n->arch.user_regs;
    int all_segs_okay = 1;
    unsigned int dirty_segment_mask, cpu = smp_processor_id();
    bool fs_gs_done = false;

    /* Load and clear the dirty segment mask. */
    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);
    per_cpu(dirty_segment_mask, cpu) = 0;

#ifdef CONFIG_HVM
    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&
         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )
    {
        unsigned long gsb = n->arch.flags & TF_kernel_mode
            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;
        unsigned long gss = n->arch.flags & TF_kernel_mode
            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;

        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),
                                   uregs->fs, n->arch.pv.fs_base,
                                   uregs->gs, gsb, gss);
    }
#endif
    if ( !fs_gs_done )
        load_LDT(n);

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )
    {
        preload_segment(ds, uregs->ds);
        all_segs_okay &= loadsegment(ds, uregs->ds);
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )
    {
        preload_segment(es, uregs->es);
        all_segs_okay &= loadsegment(es, uregs->es);
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )
    {
        all_segs_okay &= loadsegment(fs, uregs->fs);
        /* non-nul selector updates fs_base */
        if ( uregs->fs & ~3 )
            dirty_segment_mask &= ~DIRTY_FS_BASE;
    }

    /* Either selector != 0 ==> reload. */
    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )
    {
        all_segs_okay &= loadsegment(gs, uregs->gs);
        /* non-nul selector updates gs_base_user */
        if ( uregs->gs & ~3 )
            dirty_segment_mask &= ~DIRTY_GS_BASE;
    }

    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )
    {
        /* This can only be non-zero if selector is NULL. */
        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )
            wrfsbase(n->arch.pv.fs_base);

        /*
         * Most kernels have non-zero GS base, so don't bother testing.
         * (For old AMD hardware this is also a serialising instruction,
         * avoiding erratum #88.)
         */
        wrgsshadow(n->arch.pv.gs_base_kernel);

        /* This can only be non-zero if selector is NULL. */
        if ( n->arch.pv.gs_base_user |
             (dirty_segment_mask & DIRTY_GS_BASE) )
            wrgsbase(n->arch.pv.gs_base_user);

        /* If in kernel mode then switch the GS bases around. */
        if ( (n->arch.flags & TF_kernel_mode) )
            asm volatile ( ""swapgs"" );
    }

    if ( unlikely(!all_segs_okay) )
    {
        struct pv_vcpu *pv = &n->arch.pv;
        struct cpu_user_regs *regs = guest_cpu_user_regs();
        unsigned long *rsp =
            (unsigned long *)(((n->arch.flags & TF_kernel_mode)
                               ? regs->rsp : pv->kernel_sp) & ~0xf);
        unsigned long cs_and_mask, rflags;

        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */
        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);
        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;
        if ( VM_ASSIST(n->domain, architectural_iopl) )
            rflags |= n->arch.pv.iopl;

        if ( is_pv_32bit_vcpu(n) )
        {
            unsigned int *esp = ring_1(regs) ?
                                (unsigned int *)regs->rsp :
                                (unsigned int *)pv->kernel_sp;
            int ret = 0;

            /* CS longword also contains full evtchn_upcall_mask. */
            cs_and_mask = (unsigned short)regs->cs |
                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);

            if ( !ring_1(regs) )
            {
                ret  = put_user(regs->ss,       esp-1);
                ret |= put_user(regs->esp,      esp-2);
                esp -= 2;
            }

            if ( ret |
                 put_user(rflags,              esp-1) |
                 put_user(cs_and_mask,         esp-2) |
                 put_user(regs->eip,           esp-3) |
                 put_user(uregs->gs,           esp-4) |
                 put_user(uregs->fs,           esp-5) |
                 put_user(uregs->es,           esp-6) |
                 put_user(uregs->ds,           esp-7) )
            {
                gprintk(XENLOG_ERR,
                        ""error while creating compat failsafe callback frame\n"");
                domain_crash(n->domain);
            }

            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
                vcpu_info(n, evtchn_upcall_mask) = 1;

            regs->entry_vector |= TRAP_syscall;
            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|
                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);
            regs->ss            = FLAT_COMPAT_KERNEL_SS;
            regs->esp           = (unsigned long)(esp-7);
            regs->cs            = FLAT_COMPAT_KERNEL_CS;
            regs->eip           = pv->failsafe_callback_eip;
            return;
        }

        if ( !(n->arch.flags & TF_kernel_mode) )
            toggle_guest_mode(n);
        else
            regs->cs &= ~3;

        /* CS longword also contains full evtchn_upcall_mask. */
        cs_and_mask = (unsigned long)regs->cs |
            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);

        if ( put_user(regs->ss,            rsp- 1) |
             put_user(regs->rsp,           rsp- 2) |
             put_user(rflags,              rsp- 3) |
             put_user(cs_and_mask,         rsp- 4) |
             put_user(regs->rip,           rsp- 5) |
             put_user(uregs->gs,           rsp- 6) |
             put_user(uregs->fs,           rsp- 7) |
             put_user(uregs->es,           rsp- 8) |
             put_user(uregs->ds,           rsp- 9) |
             put_user(regs->r11,           rsp-10) |
             put_user(regs->rcx,           rsp-11) )
        {
            gprintk(XENLOG_ERR,
                    ""error while creating failsafe callback frame\n"");
            domain_crash(n->domain);
        }

        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )
            vcpu_info(n, evtchn_upcall_mask) = 1;

        regs->entry_vector |= TRAP_syscall;
        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|
                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);
        regs->ss            = FLAT_KERNEL_SS;
        regs->rsp           = (unsigned long)(rsp-11);
        regs->cs            = FLAT_KERNEL_CS;
        regs->rip           = pv->failsafe_callback_eip;
    }
}","static void load_segments(struct vcpu *VAR_0)
{
    struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
    int VAR_2 = 1;
    unsigned int VAR_3, VAR_4 = smp_processor_id();
    bool VAR_5 = false;

    /* COMMENT_0 */
    VAR_3 = per_cpu(VAR_3, VAR_4);
    per_cpu(VAR_3, VAR_4) = 0;

#ifdef VAR_6
    if ( VAR_7 && !is_pv_32bit_vcpu(VAR_0) &&
         !(read_cr4() & VAR_8) && !((VAR_1->fs | VAR_1->gs) & ~3) )
    {
        unsigned long VAR_9 = VAR_0->arch.flags & VAR_10
            ? VAR_0->arch.pv.gs_base_kernel : VAR_0->arch.pv.gs_base_user;
        unsigned long VAR_11 = VAR_0->arch.flags & VAR_10
            ? VAR_0->arch.pv.gs_base_user : VAR_0->arch.pv.gs_base_kernel;

        VAR_5 = svm_load_segs(VAR_0->arch.pv.ldt_ents, LDT_VIRT_START(VAR_0),
                                   VAR_1->fs, VAR_0->arch.pv.fs_base,
                                   VAR_1->gs, VAR_9, VAR_11);
    }
#endif
    if ( !VAR_5 )
        load_LDT(VAR_0);

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_12) | VAR_1->ds) )
    {
        preload_segment(VAR_13, VAR_1->ds);
        VAR_2 &= loadsegment(VAR_13, VAR_1->ds);
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_14) | VAR_1->es) )
    {
        preload_segment(VAR_15, VAR_1->es);
        VAR_2 &= loadsegment(VAR_15, VAR_1->es);
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_16) | VAR_1->fs) && !VAR_5 )
    {
        VAR_2 &= loadsegment(VAR_17, VAR_1->fs);
        /* COMMENT_2 */
        if ( VAR_1->fs & ~3 )
            VAR_3 &= ~VAR_18;
    }

    /* COMMENT_1 */
    if ( unlikely((VAR_3 & VAR_19) | VAR_1->gs) && !VAR_5 )
    {
        VAR_2 &= loadsegment(VAR_20, VAR_1->gs);
        /* COMMENT_3 */
        if ( VAR_1->gs & ~3 )
            VAR_3 &= ~VAR_21;
    }

    if ( !VAR_5 && !is_pv_32bit_vcpu(VAR_0) )
    {
        /* COMMENT_4 */
        if ( VAR_0->arch.pv.fs_base | (VAR_3 & VAR_18) )
            wrfsbase(VAR_0->arch.pv.fs_base);

        /* COMMENT_5 */
                                                                       
                                                                        
                                 
           
        wrgsshadow(VAR_0->arch.pv.gs_base_kernel);

        /* COMMENT_4 */
        if ( VAR_0->arch.pv.gs_base_user |
             (VAR_3 & VAR_21) )
            wrgsbase(VAR_0->arch.pv.gs_base_user);

        /* COMMENT_10 */
        if ( (VAR_0->arch.flags & VAR_10) )
            VAR_22 volatile ( ""swapgs"" );
    }

    if ( unlikely(!VAR_2) )
    {
        struct pv_vcpu *VAR_23 = &VAR_0->arch.pv;
        struct cpu_user_regs *VAR_24 = guest_cpu_user_regs();
        unsigned long *VAR_25 =
            (unsigned long *)(((VAR_0->arch.flags & VAR_10)
                               ? VAR_24->rsp : VAR_23->kernel_sp) & ~0xf);
        unsigned long VAR_26, VAR_27;

        /* COMMENT_11 */
        VAR_27  = VAR_24->rflags & ~(VAR_28|VAR_29);
        VAR_27 |= !vcpu_info(VAR_0, VAR_30) << 9;
        if ( VM_ASSIST(VAR_0->domain, VAR_31) )
            VAR_27 |= VAR_0->arch.pv.iopl;

        if ( is_pv_32bit_vcpu(VAR_0) )
        {
            unsigned int *VAR_32 = ring_1(VAR_24) ?
                                (unsigned int *)VAR_24->rsp :
                                (unsigned int *)VAR_23->kernel_sp;
            int VAR_33 = 0;

            /* COMMENT_12 */
            VAR_26 = (unsigned short)VAR_24->cs |
                ((unsigned int)vcpu_info(VAR_0, VAR_30) << 16);

            if ( !ring_1(VAR_24) )
            {
                VAR_33  = put_user(VAR_24->ss,       VAR_32-1);
                VAR_33 |= put_user(VAR_24->esp,      VAR_32-2);
                VAR_32 -= 2;
            }

            if ( VAR_33 |
                 put_user(VAR_27,              VAR_32-1) |
                 put_user(VAR_26,         VAR_32-2) |
                 put_user(VAR_24->eip,           VAR_32-3) |
                 put_user(VAR_1->gs,           VAR_32-4) |
                 put_user(VAR_1->fs,           VAR_32-5) |
                 put_user(VAR_1->es,           VAR_32-6) |
                 put_user(VAR_1->ds,           VAR_32-7) )
            {
                gprintk(VAR_34,
                        ""error while creating compat failsafe callback frame\n"");
                domain_crash(VAR_0->domain);
            }

            if ( VAR_0->arch.vgc_flags & VAR_35 )
                vcpu_info(VAR_0, VAR_30) = 1;

            VAR_24->entry_vector |= VAR_36;
            VAR_24->eflags       &= ~(VAR_37|VAR_38|VAR_39|
                                    VAR_29|VAR_40);
            VAR_24->ss            = VAR_41;
            VAR_24->esp           = (unsigned long)(VAR_32-7);
            VAR_24->cs            = VAR_42;
            VAR_24->eip           = VAR_23->failsafe_callback_eip;
            return;
        }

        if ( !(VAR_0->arch.flags & VAR_10) )
            toggle_guest_mode(VAR_0);
        else
            VAR_24->cs &= ~3;

        /* COMMENT_12 */
        VAR_26 = (unsigned long)VAR_24->cs |
            ((unsigned long)vcpu_info(VAR_0, VAR_30) << 32);

        if ( put_user(VAR_24->ss,            VAR_25- 1) |
             put_user(VAR_24->rsp,           VAR_25- 2) |
             put_user(VAR_27,              VAR_25- 3) |
             put_user(VAR_26,         VAR_25- 4) |
             put_user(VAR_24->rip,           VAR_25- 5) |
             put_user(VAR_1->gs,           VAR_25- 6) |
             put_user(VAR_1->fs,           VAR_25- 7) |
             put_user(VAR_1->es,           VAR_25- 8) |
             put_user(VAR_1->ds,           VAR_25- 9) |
             put_user(VAR_24->r11,           VAR_25-10) |
             put_user(VAR_24->rcx,           VAR_25-11) )
        {
            gprintk(VAR_34,
                    ""error while creating failsafe callback frame\n"");
            domain_crash(VAR_0->domain);
        }

        if ( VAR_0->arch.vgc_flags & VAR_35 )
            vcpu_info(VAR_0, VAR_30) = 1;

        VAR_24->entry_vector |= VAR_36;
        VAR_24->rflags       &= ~(VAR_43|VAR_37|VAR_38|
                                VAR_39|VAR_29|VAR_40);
        VAR_24->ss            = VAR_44;
        VAR_24->rsp           = (unsigned long)(VAR_25-11);
        VAR_24->cs            = VAR_45;
        VAR_24->rip           = VAR_23->failsafe_callback_eip;
    }
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,13 +10,8 @@
     per_cpu(dirty_segment_mask, cpu) = 0;
 
 #ifdef CONFIG_HVM
-    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&
-         !((uregs->fs | uregs->gs) & ~3) &&
-         /*
-          * The remaining part is just for optimization: If only shadow GS
-          * needs loading, there's nothing to be gained here.
-          */
-         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )
+    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&
+         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )
     {
         unsigned long gsb = n->arch.flags & TF_kernel_mode
             ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;","{'deleted_lines': ['    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&', '         !((uregs->fs | uregs->gs) & ~3) &&', '         /*', '          * The remaining part is just for optimization: If only shadow GS', ""          * needs loading, there's nothing to be gained here."", '          */', '         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )'], 'added_lines': ['    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&', '         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/pv/emul-priv-op.c,read_msr,"static int read_msr(unsigned int reg, uint64_t *val,
struct x86_emulate_ctxt *ctxt)
{
const struct vcpu *curr = current;
const struct domain *currd = curr->domain;
bool vpmu_msr = false;
int ret;
if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )
{
if ( ret == X86EMUL_EXCEPTION )
x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);
return ret;
}
switch ( reg )
{
int rc;
case MSR_FS_BASE:
if ( is_pv_32bit_domain(currd) )
break;
*val = cpu_has_fsgsbase ? __rdfsbase() : curr->arch.pv.fs_base;
return X86EMUL_OKAY;
case MSR_GS_BASE:
if ( is_pv_32bit_domain(currd) )
break;
*val = cpu_has_fsgsbase ? __rdgsbase()
: curr->arch.pv.gs_base_kernel;
return X86EMUL_OKAY;
case MSR_SHADOW_GS_BASE:
if ( is_pv_32bit_domain(currd) )
break;
*val = curr->arch.pv.gs_base_user;
return X86EMUL_OKAY;
case MSR_IA32_TSC:
*val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();
return X86EMUL_OKAY;
case MSR_EFER:
*val = read_efer() & EFER_KNOWN_MASK & ~EFER_SVME;
if ( is_pv_32bit_domain(currd) )
*val &= ~(EFER_LME | EFER_LMA |
(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL
? EFER_SCE : 0));
return X86EMUL_OKAY;
case MSR_K7_FID_VID_CTL:
case MSR_K7_FID_VID_STATUS:
case MSR_K8_PSTATE_LIMIT:
case MSR_K8_PSTATE_CTRL:
case MSR_K8_PSTATE_STATUS:
case MSR_K8_PSTATE0:
case MSR_K8_PSTATE1:
case MSR_K8_PSTATE2:
case MSR_K8_PSTATE3:
case MSR_K8_PSTATE4:
case MSR_K8_PSTATE5:
case MSR_K8_PSTATE6:
case MSR_K8_PSTATE7:
if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )
break;
if ( unlikely(is_cpufreq_controller(currd)) )
goto normal;
*val = 0;
return X86EMUL_OKAY;
case MSR_IA32_UCODE_REV:
BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);
if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )
{
if ( wrmsr_safe(MSR_IA32_UCODE_REV, 0) )
break;
cpuid_eax(1);
}
goto normal;
case MSR_IA32_MISC_ENABLE:
rdmsrl(reg, *val);
*val = guest_misc_enable(*val);
return X86EMUL_OKAY;
case MSR_IA32_PERF_CAPABILITIES:
*val = 0;
return X86EMUL_OKAY;
case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):
case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):
case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:
case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:
if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )
{
vpmu_msr = true;
case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:
case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:
if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )
{
if ( vpmu_do_rdmsr(reg, val) )
break;
return X86EMUL_OKAY;
}
}
default:
rc = vmce_rdmsr(reg, val);
if ( rc < 0 )
break;
if ( rc )
return X86EMUL_OKAY;
normal:
if ( rdmsr_safe(reg, *val) )
break;
return X86EMUL_OKAY;
}
return X86EMUL_UNHANDLEABLE;
}","static int read_msr(unsigned int VAR_0, uint64_t *VAR_1,
struct x86_emulate_ctxt *VAR_2)
{
const struct vcpu *VAR_3 = VAR_4;
const struct domain *VAR_5 = VAR_3->domain;
bool VAR_6 = false;
int VAR_7;
if ( (VAR_7 = guest_rdmsr(VAR_3, VAR_0, VAR_1)) != VAR_8 )
{
if ( VAR_7 == VAR_9 )
x86_emul_hw_exception(VAR_10, 0, VAR_2);
return VAR_7;
}
switch ( VAR_0 )
{
int VAR_11;
case VAR_12:
if ( is_pv_32bit_domain(VAR_5) )
break;
*VAR_1 = VAR_13 ? __rdfsbase() : VAR_3->arch.pv.fs_base;
return VAR_14;
case VAR_15:
if ( is_pv_32bit_domain(VAR_5) )
break;
*VAR_1 = VAR_13 ? __rdgsbase()
: VAR_3->arch.pv.gs_base_kernel;
return VAR_14;
case VAR_16:
if ( is_pv_32bit_domain(VAR_5) )
break;
*VAR_1 = VAR_3->arch.pv.gs_base_user;
return VAR_14;
case VAR_17:
*VAR_1 = VAR_5->arch.vtsc ? pv_soft_rdtsc(VAR_3, VAR_2->regs) : rdtsc();
return VAR_14;
case VAR_18:
*VAR_1 = read_efer() & VAR_19 & ~VAR_20;
if ( is_pv_32bit_domain(VAR_5) )
*VAR_1 &= ~(VAR_21 | VAR_22 |
(VAR_23.x86_vendor == VAR_24
? VAR_25 : 0));
return VAR_14;
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
case VAR_35:
case VAR_36:
case VAR_37:
case VAR_38:
if ( VAR_23.x86_vendor != VAR_39 )
break;
if ( unlikely(is_cpufreq_controller(VAR_5)) )
goto normal;
*VAR_1 = 0;
return VAR_14;
case VAR_40:
BUILD_BUG_ON(VAR_40 != VAR_41);
if ( VAR_23.x86_vendor == VAR_24 )
{
if ( wrmsr_safe(VAR_40, 0) )
break;
cpuid_eax(1);
}
goto normal;
case VAR_42:
rdmsrl(VAR_0, *VAR_1);
*VAR_1 = guest_misc_enable(*VAR_1);
return VAR_14;
case VAR_43:
*VAR_1 = 0;
return VAR_14;
case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):
case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):
case VAR_44 ... MSR_CORE_PERF_FIXED_CTR2:
case VAR_45 ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:
if ( VAR_23.x86_vendor == VAR_24 )
{
VAR_6 = true;
case VAR_46 ... MSR_AMD_FAM15H_PERFCTR5:
case VAR_47 ... MSR_K7_PERFCTR3:
if ( VAR_6 || (VAR_23.x86_vendor == VAR_39) )
{
if ( vpmu_do_rdmsr(VAR_0, VAR_1) )
break;
return VAR_14;
}
}
default:
VAR_11 = vmce_rdmsr(VAR_0, VAR_1);
if ( VAR_11 < 0 )
break;
if ( VAR_11 )
return VAR_14;
normal:
if ( rdmsr_safe(VAR_0, *VAR_1) )
break;
return VAR_14;
}
return VAR_8;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/emul-priv-op.c/vul/before/1.json,"static int read_msr(unsigned int reg, uint64_t *val,
                    struct x86_emulate_ctxt *ctxt)
{
    const struct vcpu *curr = current;
    const struct domain *currd = curr->domain;
    bool vpmu_msr = false;
    int ret;

    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )
    {
        if ( ret == X86EMUL_EXCEPTION )
            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);

        return ret;
    }

    switch ( reg )
    {
        int rc;

    case MSR_FS_BASE:
        if ( is_pv_32bit_domain(currd) )
            break;
        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdfsbase()
                                               : curr->arch.pv.fs_base;
        return X86EMUL_OKAY;

    case MSR_GS_BASE:
        if ( is_pv_32bit_domain(currd) )
            break;
        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdgsbase()
                                               : curr->arch.pv.gs_base_kernel;
        return X86EMUL_OKAY;

    case MSR_SHADOW_GS_BASE:
        if ( is_pv_32bit_domain(currd) )
            break;
        *val = curr->arch.pv.gs_base_user;
        return X86EMUL_OKAY;

    case MSR_IA32_TSC:
        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();
        return X86EMUL_OKAY;

    case MSR_EFER:
        /* Hide unknown bits, and unconditionally hide SVME from guests. */
        *val = read_efer() & EFER_KNOWN_MASK & ~EFER_SVME;
        /*
         * Hide the 64-bit features from 32-bit guests.  SCE has
         * vendor-dependent behaviour.
         */
        if ( is_pv_32bit_domain(currd) )
            *val &= ~(EFER_LME | EFER_LMA |
                      (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL
                       ? EFER_SCE : 0));
        return X86EMUL_OKAY;

    case MSR_K7_FID_VID_CTL:
    case MSR_K7_FID_VID_STATUS:
    case MSR_K8_PSTATE_LIMIT:
    case MSR_K8_PSTATE_CTRL:
    case MSR_K8_PSTATE_STATUS:
    case MSR_K8_PSTATE0:
    case MSR_K8_PSTATE1:
    case MSR_K8_PSTATE2:
    case MSR_K8_PSTATE3:
    case MSR_K8_PSTATE4:
    case MSR_K8_PSTATE5:
    case MSR_K8_PSTATE6:
    case MSR_K8_PSTATE7:
        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )
            break;
        if ( unlikely(is_cpufreq_controller(currd)) )
            goto normal;
        *val = 0;
        return X86EMUL_OKAY;

    case MSR_IA32_UCODE_REV:
        BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);
        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )
        {
            if ( wrmsr_safe(MSR_IA32_UCODE_REV, 0) )
                break;
            /* As documented in the SDM: Do a CPUID 1 here */
            cpuid_eax(1);
        }
        goto normal;

    case MSR_IA32_MISC_ENABLE:
        rdmsrl(reg, *val);
        *val = guest_misc_enable(*val);
        return X86EMUL_OKAY;

    case MSR_IA32_PERF_CAPABILITIES:
        /* No extra capabilities are supported. */
        *val = 0;
        return X86EMUL_OKAY;

    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):
    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):
    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:
    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:
        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )
        {
            vpmu_msr = true;
            /* fall through */
    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:
    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:
            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )
            {
                if ( vpmu_do_rdmsr(reg, val) )
                    break;
                return X86EMUL_OKAY;
            }
        }
        /* fall through */
    default:
        rc = vmce_rdmsr(reg, val);
        if ( rc < 0 )
            break;
        if ( rc )
            return X86EMUL_OKAY;
        /* fall through */
    normal:
        /* Everyone can read the MSR space. */
        /* gdprintk(XENLOG_WARNING, ""Domain attempted RDMSR %08x\n"", reg); */
        if ( rdmsr_safe(reg, *val) )
            break;
        return X86EMUL_OKAY;
    }

    return X86EMUL_UNHANDLEABLE;
}","static int read_msr(unsigned int VAR_0, uint64_t *VAR_1,
                    struct x86_emulate_ctxt *VAR_2)
{
    const struct vcpu *VAR_3 = VAR_4;
    const struct domain *VAR_5 = VAR_3->domain;
    bool VAR_6 = false;
    int VAR_7;

    if ( (VAR_7 = guest_rdmsr(VAR_3, VAR_0, VAR_1)) != VAR_8 )
    {
        if ( VAR_7 == VAR_9 )
            x86_emul_hw_exception(VAR_10, 0, VAR_2);

        return VAR_7;
    }

    switch ( VAR_0 )
    {
        int VAR_11;

    case VAR_12:
        if ( is_pv_32bit_domain(VAR_5) )
            break;
        *VAR_1 = (read_cr4() & VAR_13) ? __rdfsbase()
                                               : VAR_3->arch.pv.fs_base;
        return VAR_14;

    case VAR_15:
        if ( is_pv_32bit_domain(VAR_5) )
            break;
        *VAR_1 = (read_cr4() & VAR_13) ? __rdgsbase()
                                               : VAR_3->arch.pv.gs_base_kernel;
        return VAR_14;

    case VAR_16:
        if ( is_pv_32bit_domain(VAR_5) )
            break;
        *VAR_1 = VAR_3->arch.pv.gs_base_user;
        return VAR_14;

    case VAR_17:
        *VAR_1 = VAR_5->arch.vtsc ? pv_soft_rdtsc(VAR_3, VAR_2->regs) : rdtsc();
        return VAR_14;

    case VAR_18:
        /* COMMENT_0 */
        *VAR_1 = read_efer() & VAR_19 & ~VAR_20;
        /* COMMENT_1 */
                                                                
                                      
           
        if ( is_pv_32bit_domain(VAR_5) )
            *VAR_1 &= ~(VAR_21 | VAR_22 |
                      (VAR_23.x86_vendor == VAR_24
                       ? VAR_25 : 0));
        return VAR_14;

    case VAR_26:
    case VAR_27:
    case VAR_28:
    case VAR_29:
    case VAR_30:
    case VAR_31:
    case VAR_32:
    case VAR_33:
    case VAR_34:
    case VAR_35:
    case VAR_36:
    case VAR_37:
    case VAR_38:
        if ( VAR_23.x86_vendor != VAR_39 )
            break;
        if ( unlikely(is_cpufreq_controller(VAR_5)) )
            goto normal;
        *VAR_1 = 0;
        return VAR_14;

    case VAR_40:
        BUILD_BUG_ON(VAR_40 != VAR_41);
        if ( VAR_23.x86_vendor == VAR_24 )
        {
            if ( wrmsr_safe(VAR_40, 0) )
                break;
            /* COMMENT_5 */
            cpuid_eax(1);
        }
        goto normal;

    case VAR_42:
        rdmsrl(VAR_0, *VAR_1);
        *VAR_1 = guest_misc_enable(*VAR_1);
        return VAR_14;

    case VAR_43:
        /* COMMENT_6 */
        *VAR_1 = 0;
        return VAR_14;

    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):
    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):
    case VAR_44 ... MSR_CORE_PERF_FIXED_CTR2:
    case VAR_45 ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:
        if ( VAR_23.x86_vendor == VAR_24 )
        {
            VAR_6 = true;
            /* COMMENT_7 */
    case VAR_46 ... MSR_AMD_FAM15H_PERFCTR5:
    case VAR_47 ... MSR_K7_PERFCTR3:
            if ( VAR_6 || (VAR_23.x86_vendor == VAR_39) )
            {
                if ( vpmu_do_rdmsr(VAR_0, VAR_1) )
                    break;
                return VAR_14;
            }
        }
        /* COMMENT_7 */
    default:
        VAR_11 = vmce_rdmsr(VAR_0, VAR_1);
        if ( VAR_11 < 0 )
            break;
        if ( VAR_11 )
            return VAR_14;
        /* COMMENT_7 */
    normal:
        /* COMMENT_8 */
        /* COMMENT_9 */
        if ( rdmsr_safe(VAR_0, *VAR_1) )
            break;
        return VAR_14;
    }

    return VAR_8;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/emul-priv-op.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -21,14 +21,15 @@
     case MSR_FS_BASE:
         if ( is_pv_32bit_domain(currd) )
             break;
-        *val = cpu_has_fsgsbase ? __rdfsbase() : curr->arch.pv.fs_base;
+        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdfsbase()
+                                               : curr->arch.pv.fs_base;
         return X86EMUL_OKAY;
 
     case MSR_GS_BASE:
         if ( is_pv_32bit_domain(currd) )
             break;
-        *val = cpu_has_fsgsbase ? __rdgsbase()
-                                : curr->arch.pv.gs_base_kernel;
+        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdgsbase()
+                                               : curr->arch.pv.gs_base_kernel;
         return X86EMUL_OKAY;
 
     case MSR_SHADOW_GS_BASE:","{'deleted_lines': ['        *val = cpu_has_fsgsbase ? __rdfsbase() : curr->arch.pv.fs_base;', '        *val = cpu_has_fsgsbase ? __rdgsbase()', '                                : curr->arch.pv.gs_base_kernel;'], 'added_lines': ['        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdfsbase()', '                                               : curr->arch.pv.fs_base;', '        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdgsbase()', '                                               : curr->arch.pv.gs_base_kernel;']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/pv/emul-priv-op.c,write_cr,"static int write_cr(unsigned int reg, unsigned long val,
struct x86_emulate_ctxt *ctxt)
{
struct vcpu *curr = current;
switch ( reg )
{
case 0: 
if ( (val ^ read_cr0()) & ~X86_CR0_TS )
{
gdprintk(XENLOG_WARNING,
""Attempt to change unmodifiable CR0 flags\n"");
break;
}
do_fpu_taskswitch(!!(val & X86_CR0_TS));
return X86EMUL_OKAY;
case 2: 
curr->arch.pv.ctrlreg[2] = val;
arch_set_cr2(curr, val);
return X86EMUL_OKAY;
case 3: 
{
struct domain *currd = curr->domain;
unsigned long gfn;
struct page_info *page;
int rc;
gfn = !is_pv_32bit_domain(currd)
? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);
page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);
if ( !page )
break;
rc = new_guest_cr3(page_to_mfn(page));
put_page(page);
switch ( rc )
{
case 0:
return X86EMUL_OKAY;
case -ERESTART: 
return X86EMUL_RETRY;
}
break;
}
case 4: 
curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);
write_cr4(pv_make_cr4(curr));
ctxt_switch_levelling(curr);
return X86EMUL_OKAY;
}
return X86EMUL_UNHANDLEABLE;
}","static int write_cr(unsigned int VAR_0, unsigned long VAR_1,
struct x86_emulate_ctxt *VAR_2)
{
struct vcpu *VAR_3 = VAR_4;
switch ( VAR_0 )
{
case 0: 
if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )
{
gdprintk(VAR_6,
""Attempt to change unmodifiable CR0 flags\n"");
break;
}
do_fpu_taskswitch(!!(VAR_1 & VAR_5));
return VAR_7;
case 2: 
VAR_3->arch.pv.ctrlreg[2] = VAR_1;
arch_set_cr2(VAR_3, VAR_1);
return VAR_7;
case 3: 
{
struct domain *VAR_8 = VAR_3->domain;
unsigned long VAR_9;
struct page_info *VAR_10;
int VAR_11;
VAR_9 = !is_pv_32bit_domain(VAR_8)
? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);
VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);
if ( !VAR_10 )
break;
VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));
put_page(VAR_10);
switch ( VAR_11 )
{
case 0:
return VAR_7;
case -VAR_13: 
return VAR_14;
}
break;
}
case 4: 
VAR_3->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_3, VAR_1);
write_cr4(pv_make_cr4(VAR_3));
ctxt_switch_levelling(VAR_3);
return VAR_7;
}
return VAR_15;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/emul-priv-op.c/vul/before/0.json,"static int write_cr(unsigned int reg, unsigned long val,
                    struct x86_emulate_ctxt *ctxt)
{
    struct vcpu *curr = current;

    switch ( reg )
    {
    case 0: /* Write CR0 */
        if ( (val ^ read_cr0()) & ~X86_CR0_TS )
        {
            gdprintk(XENLOG_WARNING,
                     ""Attempt to change unmodifiable CR0 flags\n"");
            break;
        }
        do_fpu_taskswitch(!!(val & X86_CR0_TS));
        return X86EMUL_OKAY;

    case 2: /* Write CR2 */
        curr->arch.pv.ctrlreg[2] = val;
        arch_set_cr2(curr, val);
        return X86EMUL_OKAY;

    case 3: /* Write CR3 */
    {
        struct domain *currd = curr->domain;
        unsigned long gfn;
        struct page_info *page;
        int rc;

        gfn = !is_pv_32bit_domain(currd)
              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);
        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);
        if ( !page )
            break;
        rc = new_guest_cr3(page_to_mfn(page));
        put_page(page);

        switch ( rc )
        {
        case 0:
            return X86EMUL_OKAY;
        case -ERESTART: /* retry after preemption */
            return X86EMUL_RETRY;
        }
        break;
    }

    case 4: /* Write CR4 */
        /*
         * If this write will disable FSGSBASE, refresh Xen's idea of the
         * guest bases now that they can no longer change.
         */
        if ( (curr->arch.pv.ctrlreg[4] & X86_CR4_FSGSBASE) &&
             !(val & X86_CR4_FSGSBASE) )
        {
            curr->arch.pv.fs_base = __rdfsbase();
            curr->arch.pv.gs_base_kernel = __rdgsbase();
        }

        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);
        write_cr4(pv_make_cr4(curr));
        ctxt_switch_levelling(curr);
        return X86EMUL_OKAY;
    }

    return X86EMUL_UNHANDLEABLE;
}","static int write_cr(unsigned int VAR_0, unsigned long VAR_1,
                    struct x86_emulate_ctxt *VAR_2)
{
    struct vcpu *VAR_3 = VAR_4;

    switch ( VAR_0 )
    {
    case 0: /* COMMENT_0 */
        if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )
        {
            gdprintk(VAR_6,
                     ""Attempt to change unmodifiable CR0 flags\n"");
            break;
        }
        do_fpu_taskswitch(!!(VAR_1 & VAR_5));
        return VAR_7;

    case 2: /* COMMENT_1 */
        VAR_3->arch.pv.ctrlreg[2] = VAR_1;
        arch_set_cr2(VAR_3, VAR_1);
        return VAR_7;

    case 3: /* COMMENT_2 */
    {
        struct domain *VAR_8 = VAR_3->domain;
        unsigned long VAR_9;
        struct page_info *VAR_10;
        int VAR_11;

        VAR_9 = !is_pv_32bit_domain(VAR_8)
              ? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);
        VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);
        if ( !VAR_10 )
            break;
        VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));
        put_page(VAR_10);

        switch ( VAR_11 )
        {
        case 0:
            return VAR_7;
        case -VAR_13: /* COMMENT_3 */
            return VAR_14;
        }
        break;
    }

    case 4: /* COMMENT_4 */
        /* COMMENT_5 */
                                                                         
                                                          
           
        if ( (VAR_3->arch.pv.ctrlreg[4] & VAR_15) &&
             !(VAR_1 & VAR_15) )
        {
            VAR_3->arch.pv.fs_base = __rdfsbase();
            VAR_3->arch.pv.gs_base_kernel = __rdgsbase();
        }

        VAR_3->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_3, VAR_1);
        write_cr4(pv_make_cr4(VAR_3));
        ctxt_switch_levelling(VAR_3);
        return VAR_7;
    }

    return VAR_16;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/emul-priv-op.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,6 +46,17 @@
     }
 
     case 4: /* Write CR4 */
+        /*
+         * If this write will disable FSGSBASE, refresh Xen's idea of the
+         * guest bases now that they can no longer change.
+         */
+        if ( (curr->arch.pv.ctrlreg[4] & X86_CR4_FSGSBASE) &&
+             !(val & X86_CR4_FSGSBASE) )
+        {
+            curr->arch.pv.fs_base = __rdfsbase();
+            curr->arch.pv.gs_base_kernel = __rdgsbase();
+        }
+
         curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);
         write_cr4(pv_make_cr4(curr));
         ctxt_switch_levelling(curr);","{'deleted_lines': [], 'added_lines': ['        /*', ""         * If this write will disable FSGSBASE, refresh Xen's idea of the"", '         * guest bases now that they can no longer change.', '         */', '        if ( (curr->arch.pv.ctrlreg[4] & X86_CR4_FSGSBASE) &&', '             !(val & X86_CR4_FSGSBASE) )', '        {', '            curr->arch.pv.fs_base = __rdfsbase();', '            curr->arch.pv.gs_base_kernel = __rdgsbase();', '        }', '']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,wrgsbase,"static inline void wrgsbase(unsigned long base)
{
if ( cpu_has_fsgsbase )
#ifdef HAVE_AS_FSGSBASE
asm volatile ( ""wrgsbase %0"" :: ""r"" (base) );
#else
asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8"" :: ""a"" (base) );
#endif
else
wrmsrl(MSR_GS_BASE, base);
}","static inline void wrgsbase(unsigned long VAR_0)
{
if ( VAR_1 )
#ifdef VAR_2
asm volatile ( ""wrgsbase %0"" :: ""r"" (VAR_0) );
#else
asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8"" :: ""a"" (VAR_0) );
#endif
else
wrmsrl(MSR_GS_BASE, base);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/5.json,"static inline void wrgsbase(unsigned long base)
{
    if ( read_cr4() & X86_CR4_FSGSBASE )
#ifdef HAVE_AS_FSGSBASE
        asm volatile ( ""wrgsbase %0"" :: ""r"" (base) );
#else
        asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8"" :: ""a"" (base) );
#endif
    else
        wrmsrl(MSR_GS_BASE, base);
}","static inline void wrgsbase(unsigned long VAR_0)
{
    if ( read_cr4() & VAR_1 )
#ifdef VAR_2
        asm volatile ( ""wrgsbase %0"" :: ""r"" (VAR_0) );
#else
        asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8"" :: ""a"" (VAR_0) );
#endif
    else
        wrmsrl(MSR_GS_BASE, base);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static inline void wrgsbase(unsigned long base)
 {
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
 #ifdef HAVE_AS_FSGSBASE
         asm volatile ( ""wrgsbase %0"" :: ""r"" (base) );
 #else","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,rdgsshadow,"static inline unsigned long rdgsshadow(void)
{
unsigned long base;
if ( cpu_has_fsgsbase )
{
asm volatile ( ""swapgs"" );
base = __rdgsbase();
asm volatile ( ""swapgs"" );
}
else
rdmsrl(MSR_SHADOW_GS_BASE, base);
return base;
}","static inline unsigned long rdgsshadow(void)
{
unsigned long VAR_0;
if ( VAR_1 )
{
asm volatile ( ""swapgs"" );
VAR_0 = __rdgsbase();
asm volatile ( ""swapgs"" );
}
else
rdmsrl(VAR_2, VAR_0);
return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/4.json,"static inline unsigned long rdgsshadow(void)
{
    unsigned long base;

    if ( read_cr4() & X86_CR4_FSGSBASE )
    {
        asm volatile ( ""swapgs"" );
        base = __rdgsbase();
        asm volatile ( ""swapgs"" );
    }
    else
        rdmsrl(MSR_SHADOW_GS_BASE, base);

    return base;
}","static inline unsigned long rdgsshadow(void)
{
    unsigned long VAR_0;

    if ( read_cr4() & VAR_1 )
    {
        asm volatile ( ""swapgs"" );
        VAR_0 = __rdgsbase();
        asm volatile ( ""swapgs"" );
    }
    else
        rdmsrl(VAR_2, VAR_0);

    return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/4.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     unsigned long base;
 
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
     {
         asm volatile ( ""swapgs"" );
         base = __rdgsbase();","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/pv/domain.c,save_segments,"static void save_segments(struct vcpu *v)
{
struct cpu_user_regs *regs = &v->arch.user_regs;
unsigned int dirty_segment_mask = 0;
regs->ds = read_sreg(ds);
regs->es = read_sreg(es);
regs->fs = read_sreg(fs);
regs->gs = read_sreg(gs);
if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )
{
v->arch.pv.fs_base = __rdfsbase();
if ( v->arch.flags & TF_kernel_mode )
v->arch.pv.gs_base_kernel = __rdgsbase();
else
v->arch.pv.gs_base_user = __rdgsbase();
}
if ( regs->ds )
dirty_segment_mask |= DIRTY_DS;
if ( regs->es )
dirty_segment_mask |= DIRTY_ES;
if ( regs->fs || is_pv_32bit_vcpu(v) )
{
dirty_segment_mask |= DIRTY_FS;
if ( regs->fs & ~3 )
v->arch.pv.fs_base = 0;
}
if ( v->arch.pv.fs_base )
dirty_segment_mask |= DIRTY_FS_BASE;
if ( regs->gs || is_pv_32bit_vcpu(v) )
{
dirty_segment_mask |= DIRTY_GS;
if ( regs->gs & ~3 )
v->arch.pv.gs_base_user = 0;
}
if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel
: v->arch.pv.gs_base_user )
dirty_segment_mask |= DIRTY_GS_BASE;
this_cpu(dirty_segment_mask) = dirty_segment_mask;
}","static void save_segments(struct vcpu *VAR_0)
{
struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
unsigned int VAR_2 = 0;
VAR_1->ds = read_sreg(VAR_3);
VAR_1->es = read_sreg(VAR_4);
VAR_1->fs = read_sreg(VAR_5);
VAR_1->gs = read_sreg(VAR_6);
if ( VAR_7 && !is_pv_32bit_vcpu(VAR_0) )
{
VAR_0->arch.pv.fs_base = __rdfsbase();
if ( VAR_0->arch.flags & VAR_8 )
VAR_0->arch.pv.gs_base_kernel = __rdgsbase();
else
VAR_0->arch.pv.gs_base_user = __rdgsbase();
}
if ( VAR_1->ds )
VAR_2 |= VAR_9;
if ( VAR_1->es )
VAR_2 |= VAR_10;
if ( VAR_1->fs || is_pv_32bit_vcpu(VAR_0) )
{
VAR_2 |= VAR_11;
if ( VAR_1->fs & ~3 )
VAR_0->arch.pv.fs_base = 0;
}
if ( VAR_0->arch.pv.fs_base )
VAR_2 |= VAR_12;
if ( VAR_1->gs || is_pv_32bit_vcpu(VAR_0) )
{
VAR_2 |= VAR_13;
if ( VAR_1->gs & ~3 )
VAR_0->arch.pv.gs_base_user = 0;
}
if ( VAR_0->arch.flags & VAR_8 ? VAR_0->arch.pv.gs_base_kernel
: VAR_0->arch.pv.gs_base_user )
VAR_2 |= VAR_14;
this_cpu(VAR_2) = VAR_2;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/before/2.json,"static void save_segments(struct vcpu *v)
{
    struct cpu_user_regs *regs = &v->arch.user_regs;
    unsigned int dirty_segment_mask = 0;

    regs->ds = read_sreg(ds);
    regs->es = read_sreg(es);
    regs->fs = read_sreg(fs);
    regs->gs = read_sreg(gs);

    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */
    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )
    {
        v->arch.pv.fs_base = __rdfsbase();
        if ( v->arch.flags & TF_kernel_mode )
            v->arch.pv.gs_base_kernel = __rdgsbase();
        else
            v->arch.pv.gs_base_user = __rdgsbase();
    }

    if ( regs->ds )
        dirty_segment_mask |= DIRTY_DS;

    if ( regs->es )
        dirty_segment_mask |= DIRTY_ES;

    if ( regs->fs || is_pv_32bit_vcpu(v) )
    {
        dirty_segment_mask |= DIRTY_FS;
        /* non-nul selector kills fs_base */
        if ( regs->fs & ~3 )
            v->arch.pv.fs_base = 0;
    }
    if ( v->arch.pv.fs_base )
        dirty_segment_mask |= DIRTY_FS_BASE;

    if ( regs->gs || is_pv_32bit_vcpu(v) )
    {
        dirty_segment_mask |= DIRTY_GS;
        /* non-nul selector kills gs_base_user */
        if ( regs->gs & ~3 )
            v->arch.pv.gs_base_user = 0;
    }
    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel
                                        : v->arch.pv.gs_base_user )
        dirty_segment_mask |= DIRTY_GS_BASE;

    this_cpu(dirty_segment_mask) = dirty_segment_mask;
}","static void save_segments(struct vcpu *VAR_0)
{
    struct cpu_user_regs *VAR_1 = &VAR_0->arch.user_regs;
    unsigned int VAR_2 = 0;

    VAR_1->ds = read_sreg(VAR_3);
    VAR_1->es = read_sreg(VAR_4);
    VAR_1->fs = read_sreg(VAR_5);
    VAR_1->gs = read_sreg(VAR_6);

    /* COMMENT_0 */
    if ( (read_cr4() & VAR_7) && !is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_0->arch.pv.fs_base = __rdfsbase();
        if ( VAR_0->arch.flags & VAR_8 )
            VAR_0->arch.pv.gs_base_kernel = __rdgsbase();
        else
            VAR_0->arch.pv.gs_base_user = __rdgsbase();
    }

    if ( VAR_1->ds )
        VAR_2 |= VAR_9;

    if ( VAR_1->es )
        VAR_2 |= VAR_10;

    if ( VAR_1->fs || is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_2 |= VAR_11;
        /* COMMENT_1 */
        if ( VAR_1->fs & ~3 )
            VAR_0->arch.pv.fs_base = 0;
    }
    if ( VAR_0->arch.pv.fs_base )
        VAR_2 |= VAR_12;

    if ( VAR_1->gs || is_pv_32bit_vcpu(VAR_0) )
    {
        VAR_2 |= VAR_13;
        /* COMMENT_2 */
        if ( VAR_1->gs & ~3 )
            VAR_0->arch.pv.gs_base_user = 0;
    }
    if ( VAR_0->arch.flags & VAR_8 ? VAR_0->arch.pv.gs_base_kernel
                                        : VAR_0->arch.pv.gs_base_user )
        VAR_2 |= VAR_14;

    this_cpu(VAR_2) = VAR_2;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/domain.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -8,7 +8,8 @@
     regs->fs = read_sreg(fs);
     regs->gs = read_sreg(gs);
 
-    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )
+    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */
+    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )
     {
         v->arch.pv.fs_base = __rdfsbase();
         if ( v->arch.flags & TF_kernel_mode )","{'deleted_lines': ['    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )'], 'added_lines': ['    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */', '    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,wrfsbase,"static inline void wrfsbase(unsigned long base)
{
if ( cpu_has_fsgsbase )
#ifdef HAVE_AS_FSGSBASE
asm volatile ( ""wrfsbase %0"" :: ""r"" (base) );
#else
asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0"" :: ""a"" (base) );
#endif
else
wrmsrl(MSR_FS_BASE, base);
}","static inline void wrfsbase(unsigned long VAR_0)
{
if ( VAR_1 )
#ifdef VAR_2
asm volatile ( ""wrfsbase %0"" :: ""r"" (VAR_0) );
#else
asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0"" :: ""a"" (VAR_0) );
#endif
else
wrmsrl(MSR_FS_BASE, base);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/0.json,"static inline void wrfsbase(unsigned long base)
{
    if ( read_cr4() & X86_CR4_FSGSBASE )
#ifdef HAVE_AS_FSGSBASE
        asm volatile ( ""wrfsbase %0"" :: ""r"" (base) );
#else
        asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0"" :: ""a"" (base) );
#endif
    else
        wrmsrl(MSR_FS_BASE, base);
}","static inline void wrfsbase(unsigned long VAR_0)
{
    if ( read_cr4() & VAR_1 )
#ifdef VAR_2
        asm volatile ( ""wrfsbase %0"" :: ""r"" (VAR_0) );
#else
        asm volatile ( "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0"" :: ""a"" (VAR_0) );
#endif
    else
        wrmsrl(MSR_FS_BASE, base);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static inline void wrfsbase(unsigned long base)
 {
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
 #ifdef HAVE_AS_FSGSBASE
         asm volatile ( ""wrfsbase %0"" :: ""r"" (base) );
 #else","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,rdfsbase,"static inline unsigned long rdfsbase(void)
{
unsigned long base;
if ( cpu_has_fsgsbase )
return __rdfsbase();
rdmsrl(MSR_FS_BASE, base);
return base;
}","static inline unsigned long rdfsbase(void)
{
unsigned long VAR_0;
if ( VAR_1 )
return __rdfsbase();
rdmsrl(VAR_2, VAR_0);
return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/1.json,"static inline unsigned long rdfsbase(void)
{
    unsigned long base;

    if ( read_cr4() & X86_CR4_FSGSBASE )
        return __rdfsbase();

    rdmsrl(MSR_FS_BASE, base);

    return base;
}","static inline unsigned long rdfsbase(void)
{
    unsigned long VAR_0;

    if ( read_cr4() & VAR_1 )
        return __rdfsbase();

    rdmsrl(VAR_2, VAR_0);

    return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     unsigned long base;
 
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
         return __rdfsbase();
 
     rdmsrl(MSR_FS_BASE, base);","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/arch/x86/hvm/svm/svm.c,svm_cpu_up_prepare,"static int svm_cpu_up_prepare(unsigned int cpu)
{
paddr_t *this_hsa = &per_cpu(hsa, cpu);
paddr_t *this_vmcb = &per_cpu(host_vmcb, cpu);
nodeid_t node = cpu_to_node(cpu);
unsigned int memflags = 0;
struct page_info *pg;
if ( node != NUMA_NO_NODE )
memflags = MEMF_node(node);
if ( !*this_hsa )
{
pg = alloc_domheap_page(NULL, memflags);
if ( !pg )
goto err;
clear_domain_page(page_to_mfn(pg));
*this_hsa = page_to_maddr(pg);
}
if ( !*this_vmcb )
{
pg = alloc_domheap_page(NULL, memflags);
if ( !pg )
goto err;
#ifdef CONFIG_PV
if ( !cpu_has_fsgsbase )
per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);
#endif
clear_domain_page(page_to_mfn(pg));
*this_vmcb = page_to_maddr(pg);
}
return 0;
err:
svm_cpu_dead(cpu);
return -ENOMEM;
}","static int svm_cpu_up_prepare(unsigned int VAR_0)
{
paddr_t *VAR_1 = &per_cpu(VAR_2, VAR_0);
paddr_t *VAR_3 = &per_cpu(VAR_4, VAR_0);
nodeid_t VAR_5 = cpu_to_node(VAR_0);
unsigned int VAR_6 = 0;
struct page_info *VAR_7;
if ( VAR_5 != VAR_8 )
VAR_6 = MEMF_node(VAR_5);
if ( !*VAR_1 )
{
VAR_7 = alloc_domheap_page(NULL, VAR_6);
if ( !VAR_7 )
goto err;
clear_domain_page(page_to_mfn(VAR_7));
*VAR_1 = page_to_maddr(VAR_7);
}
if ( !*VAR_3 )
{
VAR_7 = alloc_domheap_page(NULL, VAR_6);
if ( !VAR_7 )
goto err;
#ifdef VAR_9
if ( !VAR_10 )
per_cpu(VAR_11, VAR_0) = __map_domain_page_global(VAR_7);
#endif
clear_domain_page(page_to_mfn(VAR_7));
*VAR_3 = page_to_maddr(VAR_7);
}
return 0;
err:
svm_cpu_dead(VAR_0);
return -VAR_12;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/svm.c/vul/before/0.json,"static int svm_cpu_up_prepare(unsigned int cpu)
{
    paddr_t *this_hsa = &per_cpu(hsa, cpu);
    paddr_t *this_vmcb = &per_cpu(host_vmcb, cpu);
    nodeid_t node = cpu_to_node(cpu);
    unsigned int memflags = 0;
    struct page_info *pg;

    if ( node != NUMA_NO_NODE )
        memflags = MEMF_node(node);

    if ( !*this_hsa )
    {
        pg = alloc_domheap_page(NULL, memflags);
        if ( !pg )
            goto err;

        clear_domain_page(page_to_mfn(pg));
        *this_hsa = page_to_maddr(pg);
    }

    if ( !*this_vmcb )
    {
        pg = alloc_domheap_page(NULL, memflags);
        if ( !pg )
            goto err;

#ifdef CONFIG_PV
        per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);
#endif

        clear_domain_page(page_to_mfn(pg));
        *this_vmcb = page_to_maddr(pg);
    }

    return 0;

 err:
    svm_cpu_dead(cpu);
    return -ENOMEM;
}","static int svm_cpu_up_prepare(unsigned int VAR_0)
{
    paddr_t *VAR_1 = &per_cpu(VAR_2, VAR_0);
    paddr_t *VAR_3 = &per_cpu(VAR_4, VAR_0);
    nodeid_t VAR_5 = cpu_to_node(VAR_0);
    unsigned int VAR_6 = 0;
    struct page_info *VAR_7;

    if ( VAR_5 != VAR_8 )
        VAR_6 = MEMF_node(VAR_5);

    if ( !*VAR_1 )
    {
        VAR_7 = alloc_domheap_page(NULL, VAR_6);
        if ( !VAR_7 )
            goto err;

        clear_domain_page(page_to_mfn(VAR_7));
        *VAR_1 = page_to_maddr(VAR_7);
    }

    if ( !*VAR_3 )
    {
        VAR_7 = alloc_domheap_page(NULL, VAR_6);
        if ( !VAR_7 )
            goto err;

#ifdef VAR_9
        per_cpu(VAR_10, VAR_0) = __map_domain_page_global(VAR_7);
#endif

        clear_domain_page(page_to_mfn(VAR_7));
        *VAR_3 = page_to_maddr(VAR_7);
    }

    return 0;

 err:
    svm_cpu_dead(VAR_0);
    return -VAR_11;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/svm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,8 +26,7 @@
             goto err;
 
 #ifdef CONFIG_PV
-        if ( !cpu_has_fsgsbase )
-            per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);
+        per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);
 #endif
 
         clear_domain_page(page_to_mfn(pg));","{'deleted_lines': ['        if ( !cpu_has_fsgsbase )', '            per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);'], 'added_lines': ['        per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,wrgsshadow,"static inline void wrgsshadow(unsigned long base)
{
if ( cpu_has_fsgsbase )
{
asm volatile ( ""swapgs\n\t""
#ifdef HAVE_AS_FSGSBASE
""wrgsbase %0\n\t""
""swapgs""
:: ""r"" (base) );
#else
"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\n\t""
""swapgs""
:: ""a"" (base) );
#endif
}
else
wrmsrl(MSR_SHADOW_GS_BASE, base);
}","static inline void wrgsshadow(unsigned long VAR_0)
{
if ( VAR_1 )
{
asm volatile ( ""swapgs\n\t""
#ifdef VAR_2
""wrgsbase %0\n\t""
""swapgs""
:: ""r"" (VAR_0) );
#else
"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\n\t""
""swapgs""
:: ""a"" (VAR_0) );
#endif
}
else
wrmsrl(VAR_3, VAR_0);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/3.json,"static inline void wrgsshadow(unsigned long base)
{
    if ( read_cr4() & X86_CR4_FSGSBASE )
    {
        asm volatile ( ""swapgs\n\t""
#ifdef HAVE_AS_FSGSBASE
                       ""wrgsbase %0\n\t""
                       ""swapgs""
                       :: ""r"" (base) );
#else
                       "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\n\t""
                       ""swapgs""
                       :: ""a"" (base) );
#endif
    }
    else
        wrmsrl(MSR_SHADOW_GS_BASE, base);
}","static inline void wrgsshadow(unsigned long VAR_0)
{
    if ( read_cr4() & VAR_1 )
    {
        asm volatile ( ""swapgs\n\t""
#ifdef VAR_2
                       ""wrgsbase %0\n\t""
                       ""swapgs""
                       :: ""r"" (VAR_0) );
#else
                       "".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\n\t""
                       ""swapgs""
                       :: ""a"" (VAR_0) );
#endif
    }
    else
        wrmsrl(VAR_3, VAR_0);
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static inline void wrgsshadow(unsigned long base)
 {
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
     {
         asm volatile ( ""swapgs\n\t""
 #ifdef HAVE_AS_FSGSBASE","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-17347,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back

Currently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but
the bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable
even when the guest kernel believes that they are disabled.

The FSGSBASE feature isn't currently supported in Linux, and its context
switch path has some optimisations which rely on userspace being unable to use
the WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this
expectation.

In 64bit PV guest context, always load the guest kernels setting of FSGSBASE
into %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE
instructions.

 * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to
   check %cr4 directly.
 * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase
   is set.  Comment this property.
 * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use
   the current %cr4 value to determine which mechanism to use.
 * toggle_guest_mode() and save_segments() are update to avoid reading
   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A
   consequence of this is that the write_cr() path needs to cache the current
   bases, as subsequent context switches will skip saving the values.
 * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is
   observed in a safe way WRT the hardware setting, if an interrupt happens to
   hit in the middle.
 * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is
   unavailable, even if only gs_shadow needs updating.  As a minor perf
   improvement, check cpu_has_svm first to short circuit a context-dependent
   conditional on Intel hardware.
 * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels
   choice of FSGSBASE.

This is part of XSA-293.

Reported-by: Andy Lutomirski <luto@kernel.org>
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",eccc170053e46b4ab1d9e7485c09e210be15bbd7,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,xen/include/asm-x86/msr.h,rdgsbase,"static inline unsigned long rdgsbase(void)
{
unsigned long base;
if ( cpu_has_fsgsbase )
return __rdgsbase();
rdmsrl(MSR_GS_BASE, base);
return base;
}","static inline unsigned long rdgsbase(void)
{
unsigned long VAR_0;
if ( VAR_1 )
return __rdgsbase();
rdmsrl(VAR_2, VAR_0);
return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/before/2.json,"static inline unsigned long rdgsbase(void)
{
    unsigned long base;

    if ( read_cr4() & X86_CR4_FSGSBASE )
        return __rdgsbase();

    rdmsrl(MSR_GS_BASE, base);

    return base;
}","static inline unsigned long rdgsbase(void)
{
    unsigned long VAR_0;

    if ( read_cr4() & VAR_1 )
        return __rdgsbase();

    rdmsrl(VAR_2, VAR_0);

    return VAR_0;
}",xen-project/xen/eccc170053e46b4ab1d9e7485c09e210be15bbd7/msr.h/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     unsigned long base;
 
-    if ( cpu_has_fsgsbase )
+    if ( read_cr4() & X86_CR4_FSGSBASE )
         return __rdgsbase();
 
     rdmsrl(MSR_GS_BASE, base);","{'deleted_lines': ['    if ( cpu_has_fsgsbase )'], 'added_lines': ['    if ( read_cr4() & X86_CR4_FSGSBASE )']}",True,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,7.8,HIGH,2,valid,2019-03-05T12:54:05Z,2
CVE-2019-11498,['CWE-824'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,dbry/WavPack,issue #67: make sure sample rate is specified and non-zero in DFF files,bc6cba3f552c44565f7f1e66dc1580189addb2b4,https://github.com/dbry/WavPack/commit/bc6cba3f552c44565f7f1e66dc1580189addb2b4,cli/dsdiff.c,ParseDsdiffHeaderConfig,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
int64_t infilesize, total_samples;
DFFFileHeader dff_file_header;
DFFChunkHeader dff_chunk_header;
uint32_t bcount;
infilesize = DoGetFileSize (infile);
memcpy (&dff_file_header, fourcc, 4);
if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
!WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
error_line (""%s"", WavpackGetErrorMessage (wpc));
return WAVPACK_SOFT_ERROR;
}
#if 1       WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);
if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
return WAVPACK_SOFT_ERROR;
}
if (debug_logging_mode)
error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);
#endif
while (1) {
if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
bcount != sizeof (DFFChunkHeader)) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
!WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
error_line (""%s"", WavpackGetErrorMessage (wpc));
return WAVPACK_SOFT_ERROR;
}
WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);
if (debug_logging_mode)
error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);
if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
uint32_t version;
if (dff_chunk_header.ckDataSize != sizeof (version) ||
!DoReadFile (infile, &version, sizeof (version), &bcount) ||
bcount != sizeof (version)) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
!WavpackAddWrapper (wpc, &version, sizeof (version))) {
error_line (""%s"", WavpackGetErrorMessage (wpc));
return WAVPACK_SOFT_ERROR;
}
WavpackBigEndianToNative (&version, ""L"");
if (debug_logging_mode)
error_line (""dsdiff file version = 0x%08x"", version);
}
else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
char *prop_chunk;
if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
if (debug_logging_mode)
error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);
prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);
if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
bcount != dff_chunk_header.ckDataSize) {
error_line (""%s is not a valid .DFF file!"", infilename);
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
!WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
error_line (""%s"", WavpackGetErrorMessage (wpc));
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
if (!strncmp (prop_chunk, ""SND "", 4)) {
char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
uint16_t numChannels = 0, chansSpecified, chanMask = 0;
uint32_t sampleRate;
while (eptr - cptr >= sizeof (dff_chunk_header)) {
memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
cptr += sizeof (dff_chunk_header);
WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);
if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {
if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
memcpy (&sampleRate, cptr, sizeof (sampleRate));
WavpackBigEndianToNative (&sampleRate, ""L"");
cptr += dff_chunk_header.ckDataSize;
if (debug_logging_mode)
error_line (""got sample rate of %u Hz"", sampleRate);
}
else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
memcpy (&numChannels, cptr, sizeof (numChannels));
WavpackBigEndianToNative (&numChannels, ""S"");
cptr += sizeof (numChannels);
chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;
if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {
error_line (""%s is not a valid .DFF file!"", infilename);
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
while (chansSpecified--) {
if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
chanMask |= 0x1;
else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
chanMask |= 0x2;
else if (!strncmp (cptr, ""LS  "", 4))
chanMask |= 0x10;
else if (!strncmp (cptr, ""RS  "", 4))
chanMask |= 0x20;
else if (!strncmp (cptr, ""C   "", 4))
chanMask |= 0x4;
else if (!strncmp (cptr, ""LFE "", 4))
chanMask |= 0x8;
else
if (debug_logging_mode)
error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);
cptr += 4;
}
if (debug_logging_mode)
error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
}
else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
if (strncmp (cptr, ""DSD "", 4)) {
error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
cptr [0], cptr [1], cptr [2], cptr [3]);
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
cptr += dff_chunk_header.ckDataSize;
}
else {
if (debug_logging_mode)
error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);
cptr += dff_chunk_header.ckDataSize;
}
}
else {
error_line (""%s is not a valid .DFF file!"", infilename);
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
}
if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
error_line (""this DSDIFF file already has channel order information!"");
free (prop_chunk);
return WAVPACK_SOFT_ERROR;
}
else if (chanMask)
config->channel_mask = chanMask;
config->bits_per_sample = 8;
config->bytes_per_sample = 1;
config->num_channels = numChannels;
config->sample_rate = sampleRate / 8;
config->qmode |= QMODE_DSD_MSB_FIRST;
}
else if (debug_logging_mode)
error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);
free (prop_chunk);
}
else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
if (!config->num_channels) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
total_samples = dff_chunk_header.ckDataSize / config->num_channels;
break;
}
else {          
int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
char *buff;
if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
error_line (""%s is not a valid .DFF file!"", infilename);
return WAVPACK_SOFT_ERROR;
}
buff = malloc (bytes_to_copy);
if (debug_logging_mode)
error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);
if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
bcount != bytes_to_copy ||
(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
error_line (""%s"", WavpackGetErrorMessage (wpc));
free (buff);
return WAVPACK_SOFT_ERROR;
}
free (buff);
}
}
if (debug_logging_mode)
error_line (""setting configuration with %lld samples"", total_samples);
if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
return WAVPACK_SOFT_ERROR;
}
return WAVPACK_NO_ERROR;
}","int ParseDsdiffHeaderConfig (FILE *VAR_0, char *VAR_1, char *VAR_2, WavpackContext *VAR_3, WavpackConfig *VAR_4)
{
int64_t VAR_5, VAR_6;
DFFFileHeader VAR_7;
DFFChunkHeader VAR_8;
uint32_t VAR_9;
VAR_5 = DoGetFileSize (VAR_0);
memcpy (&VAR_7, VAR_2, 4);
if ((!DoReadFile (VAR_0, ((char *) &VAR_7) + 4, sizeof (DFFFileHeader) - 4, &VAR_9) ||
VAR_9 != sizeof (DFFFileHeader) - 4) || strncmp (VAR_7.formType, ""DSD "", 4)) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
else if (!(VAR_4->qmode & VAR_11) &&
!WavpackAddWrapper (VAR_3, &VAR_7, sizeof (DFFFileHeader))) {
error_line (""%s"", WavpackGetErrorMessage (VAR_3));
return VAR_10;
}
#if 1   
WavpackBigEndianToNative (&VAR_7, VAR_12);
if (VAR_5 && !(VAR_4->qmode & VAR_13) &&
VAR_7.ckDataSize && VAR_7.ckDataSize + 1 && VAR_7.ckDataSize + 12 != VAR_5) {
error_line (""%s is not a valid .DFF file (by total size)!"", VAR_1);
return VAR_10;
}
if (VAR_14)
error_line (""file header indicated length = %lld"", VAR_7.ckDataSize);
#endif
while (1) {
if (!DoReadFile (VAR_0, &VAR_8, sizeof (DFFChunkHeader), &VAR_9) ||
VAR_9 != sizeof (DFFChunkHeader)) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
else if (!(VAR_4->qmode & VAR_11) &&
!WavpackAddWrapper (VAR_3, &VAR_8, sizeof (DFFChunkHeader))) {
error_line (""%s"", WavpackGetErrorMessage (VAR_3));
return VAR_10;
}
WavpackBigEndianToNative (&VAR_8, VAR_15);
if (VAR_14)
error_line (""chunk header indicated length = %lld"", VAR_8.ckDataSize);
if (!strncmp (VAR_8.ckID, ""FVER"", 4)) {
uint32_t VAR_16;
if (VAR_8.ckDataSize != sizeof (VAR_16) ||
!DoReadFile (VAR_0, &VAR_16, sizeof (VAR_16), &VAR_9) ||
VAR_9 != sizeof (VAR_16)) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
else if (!(VAR_4->qmode & VAR_11) &&
!WavpackAddWrapper (VAR_3, &VAR_16, sizeof (VAR_16))) {
error_line (""%s"", WavpackGetErrorMessage (VAR_3));
return VAR_10;
}
WavpackBigEndianToNative (&VAR_16, ""L"");
if (VAR_14)
error_line (""dsdiff file version = 0x%08x"", VAR_16);
}
else if (!strncmp (VAR_8.ckID, ""PROP"", 4)) {
char *VAR_17;
if (VAR_8.ckDataSize < 4 || VAR_8.ckDataSize > 1024) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
if (VAR_14)
error_line (""got PROP chunk of %d bytes total"", (int) VAR_8.ckDataSize);
VAR_17 = malloc ((size_t) VAR_8.ckDataSize);
if (!DoReadFile (VAR_0, VAR_17, (uint32_t) VAR_8.ckDataSize, &VAR_9) ||
VAR_9 != VAR_8.ckDataSize) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
free (VAR_17);
return VAR_10;
}
else if (!(VAR_4->qmode & VAR_11) &&
!WavpackAddWrapper (VAR_3, VAR_17, (uint32_t) VAR_8.ckDataSize)) {
error_line (""%s"", WavpackGetErrorMessage (VAR_3));
free (VAR_17);
return VAR_10;
}
if (!strncmp (VAR_17, ""SND "", 4)) {
char *VAR_18 = VAR_17 + 4, *VAR_19 = VAR_17 + VAR_8.ckDataSize;
uint16_t VAR_20 = 0, VAR_21, VAR_22 = 0;
uint32_t VAR_23;
while (VAR_19 - VAR_18 >= sizeof (VAR_8)) {
memcpy (&VAR_8, VAR_18, sizeof (VAR_8));
VAR_18 += sizeof (VAR_8);
WavpackBigEndianToNative (&VAR_8, VAR_15);
if (VAR_8.ckDataSize > 0 && VAR_8.ckDataSize <= VAR_19 - VAR_18) {
if (!strncmp (VAR_8.ckID, ""FS  "", 4) && VAR_8.ckDataSize == 4) {
memcpy (&VAR_23, VAR_18, sizeof (VAR_23));
WavpackBigEndianToNative (&VAR_23, ""L"");
VAR_18 += VAR_8.ckDataSize;
if (VAR_14)
error_line (""got sample rate of %u Hz"", VAR_23);
}
else if (!strncmp (VAR_8.ckID, ""CHNL"", 4) && VAR_8.ckDataSize >= 2) {
memcpy (&VAR_20, VAR_18, sizeof (VAR_20));
WavpackBigEndianToNative (&VAR_20, ""S"");
VAR_18 += sizeof (VAR_20);
VAR_21 = (int)(VAR_8.ckDataSize - sizeof (VAR_20)) / 4;
if (VAR_20 < VAR_21 || VAR_20 < 1 || VAR_20 > 256) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
free (VAR_17);
return VAR_10;
}
while (VAR_21--) {
if (!strncmp (VAR_18, ""SLFT"", 4) || !strncmp (VAR_18, ""MLFT"", 4))
VAR_22 |= 0x1;
else if (!strncmp (VAR_18, ""SRGT"", 4) || !strncmp (VAR_18, ""MRGT"", 4))
VAR_22 |= 0x2;
else if (!strncmp (VAR_18, ""LS  "", 4))
VAR_22 |= 0x10;
else if (!strncmp (VAR_18, ""RS  "", 4))
VAR_22 |= 0x20;
else if (!strncmp (VAR_18, ""C   "", 4))
VAR_22 |= 0x4;
else if (!strncmp (VAR_18, ""LFE "", 4))
VAR_22 |= 0x8;
else
if (VAR_14)
error_line (""undefined channel ID %c%c%c%c"", VAR_18 [0], VAR_18 [1], VAR_18 [2], VAR_18 [3]);
VAR_18 += 4;
}
if (VAR_14)
error_line (""%d channels, mask = 0x%08x"", VAR_20, VAR_22);
}
else if (!strncmp (VAR_8.ckID, ""CMPR"", 4) && VAR_8.ckDataSize >= 4) {
if (strncmp (VAR_18, ""DSD "", 4)) {
error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
VAR_18 [0], VAR_18 [1], VAR_18 [2], VAR_18 [3]);
free (VAR_17);
return VAR_10;
}
VAR_18 += VAR_8.ckDataSize;
}
else {
if (VAR_14)
error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", VAR_8.ckID [0],
VAR_8.ckID [1], VAR_8.ckID [2], VAR_8.ckID [3], VAR_8.ckDataSize);
VAR_18 += VAR_8.ckDataSize;
}
}
else {
error_line (""%s is not a valid .DFF file!"", VAR_1);
free (VAR_17);
return VAR_10;
}
}
if (VAR_22 && (VAR_4->channel_mask || (VAR_4->qmode & VAR_24))) {
error_line (""this DSDIFF file already has channel order information!"");
free (VAR_17);
return VAR_10;
}
else if (VAR_22)
VAR_4->channel_mask = VAR_22;
VAR_4->bits_per_sample = 8;
VAR_4->bytes_per_sample = 1;
VAR_4->num_channels = VAR_20;
VAR_4->sample_rate = VAR_23 / 8;
VAR_4->qmode |= VAR_25;
}
else if (VAR_14)
error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
VAR_17 [0], VAR_17 [1], VAR_17 [2], VAR_17 [3], VAR_8.ckDataSize);
free (VAR_17);
}
else if (!strncmp (VAR_8.ckID, ""DSD "", 4)) {
if (!VAR_4->num_channels) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
VAR_6 = VAR_8.ckDataSize / VAR_4->num_channels;
break;
}
else {          
int VAR_26 = (int)(((VAR_8.ckDataSize) + 1) & ~(int64_t)1);
char *VAR_27;
if (VAR_26 < 0 || VAR_26 > 4194304) {
error_line (""%s is not a valid .DFF file!"", VAR_1);
return VAR_10;
}
VAR_27 = malloc (VAR_26);
if (VAR_14)
error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
VAR_8.ckID [0], VAR_8.ckID [1], VAR_8.ckID [2],
VAR_8.ckID [3], VAR_8.ckDataSize);
if (!DoReadFile (VAR_0, VAR_27, VAR_26, &VAR_9) ||
VAR_9 != VAR_26 ||
(!(VAR_4->qmode & VAR_11) &&
!WavpackAddWrapper (VAR_3, VAR_27, VAR_26))) {
error_line (""%s"", WavpackGetErrorMessage (VAR_3));
free (VAR_27);
return VAR_10;
}
free (VAR_27);
}
}
if (VAR_14)
error_line (""setting configuration with %lld samples"", VAR_6);
if (!WavpackSetConfiguration64 (VAR_3, VAR_4, VAR_6, NULL)) {
error_line (""%s: %s"", VAR_1, WavpackGetErrorMessage (VAR_3));
return VAR_10;
}
return VAR_28;
}",dbry/WavPack/bc6cba3f552c44565f7f1e66dc1580189addb2b4/dsdiff.c/vul/before/0.json,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif

    // loop through all elements of the DSDIFF header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels = 0, chansSpecified, chanMask = 0;
                uint32_t sampleRate = 0;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {
                                error_line (""%s is not a valid .DFF file!"", infilename);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {

            if (!config->num_channels || !config->sample_rate) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
        else {          // just copy unknown chunks to output file

            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}","int ParseDsdiffHeaderConfig (FILE *VAR_0, char *VAR_1, char *VAR_2, WavpackContext *VAR_3, WavpackConfig *VAR_4)
{
    int64_t VAR_5, VAR_6;
    DFFFileHeader VAR_7;
    DFFChunkHeader VAR_8;
    uint32_t VAR_9;

    VAR_5 = DoGetFileSize (VAR_0);
    memcpy (&VAR_7, VAR_2, 4);

    if ((!DoReadFile (VAR_0, ((char *) &VAR_7) + 4, sizeof (DFFFileHeader) - 4, &VAR_9) ||
        VAR_9 != sizeof (DFFFileHeader) - 4) || strncmp (VAR_7.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", VAR_1);
            return VAR_10;
    }
    else if (!(VAR_4->qmode & VAR_11) &&
        !WavpackAddWrapper (VAR_3, &VAR_7, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (VAR_3));
            return VAR_10;
    }

#if 1   /* COMMENT_0 */
    WavpackBigEndianToNative (&VAR_7, VAR_12);

    if (VAR_5 && !(VAR_4->qmode & VAR_13) &&
        VAR_7.ckDataSize && VAR_7.ckDataSize + 1 && VAR_7.ckDataSize + 12 != VAR_5) {
            error_line (""%s is not a valid .DFF file (by total size)!"", VAR_1);
            return VAR_10;
    }

    if (VAR_14)
        error_line (""file header indicated length = %lld"", VAR_7.ckDataSize);

#endif

    /* COMMENT_1 */
    /* COMMENT_2 */

    while (1) {
        if (!DoReadFile (VAR_0, &VAR_8, sizeof (DFFChunkHeader), &VAR_9) ||
            VAR_9 != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", VAR_1);
                return VAR_10;
        }
        else if (!(VAR_4->qmode & VAR_11) &&
            !WavpackAddWrapper (VAR_3, &VAR_8, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (VAR_3));
                return VAR_10;
        }

        WavpackBigEndianToNative (&VAR_8, VAR_15);

        if (VAR_14)
            error_line (""chunk header indicated length = %lld"", VAR_8.ckDataSize);

        if (!strncmp (VAR_8.ckID, ""FVER"", 4)) {
            uint32_t VAR_16;

            if (VAR_8.ckDataSize != sizeof (VAR_16) ||
                !DoReadFile (VAR_0, &VAR_16, sizeof (VAR_16), &VAR_9) ||
                VAR_9 != sizeof (VAR_16)) {
                    error_line (""%s is not a valid .DFF file!"", VAR_1);
                    return VAR_10;
            }
            else if (!(VAR_4->qmode & VAR_11) &&
                !WavpackAddWrapper (VAR_3, &VAR_16, sizeof (VAR_16))) {
                    error_line (""%s"", WavpackGetErrorMessage (VAR_3));
                    return VAR_10;
            }

            WavpackBigEndianToNative (&VAR_16, ""L"");

            if (VAR_14)
                error_line (""dsdiff file version = 0x%08x"", VAR_16);
        }
        else if (!strncmp (VAR_8.ckID, ""PROP"", 4)) {
            char *VAR_17;

            if (VAR_8.ckDataSize < 4 || VAR_8.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", VAR_1);
                return VAR_10;
            }

            if (VAR_14)
                error_line (""got PROP chunk of %d bytes total"", (int) VAR_8.ckDataSize);

            VAR_17 = malloc ((size_t) VAR_8.ckDataSize);

            if (!DoReadFile (VAR_0, VAR_17, (uint32_t) VAR_8.ckDataSize, &VAR_9) ||
                VAR_9 != VAR_8.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", VAR_1);
                    free (VAR_17);
                    return VAR_10;
            }
            else if (!(VAR_4->qmode & VAR_11) &&
                !WavpackAddWrapper (VAR_3, VAR_17, (uint32_t) VAR_8.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (VAR_3));
                    free (VAR_17);
                    return VAR_10;
            }

            if (!strncmp (VAR_17, ""SND "", 4)) {
                char *VAR_18 = VAR_17 + 4, *VAR_19 = VAR_17 + VAR_8.ckDataSize;
                uint16_t VAR_20 = 0, VAR_21, VAR_22 = 0;
                uint32_t VAR_23 = 0;

                while (VAR_19 - VAR_18 >= sizeof (VAR_8)) {
                    memcpy (&VAR_8, VAR_18, sizeof (VAR_8));
                    VAR_18 += sizeof (VAR_8);
                    WavpackBigEndianToNative (&VAR_8, VAR_15);

                    if (VAR_8.ckDataSize > 0 && VAR_8.ckDataSize <= VAR_19 - VAR_18) {
                        if (!strncmp (VAR_8.ckID, ""FS  "", 4) && VAR_8.ckDataSize == 4) {
                            memcpy (&VAR_23, VAR_18, sizeof (VAR_23));
                            WavpackBigEndianToNative (&VAR_23, ""L"");
                            VAR_18 += VAR_8.ckDataSize;

                            if (VAR_14)
                                error_line (""got sample rate of %u Hz"", VAR_23);
                        }
                        else if (!strncmp (VAR_8.ckID, ""CHNL"", 4) && VAR_8.ckDataSize >= 2) {
                            memcpy (&VAR_20, VAR_18, sizeof (VAR_20));
                            WavpackBigEndianToNative (&VAR_20, ""S"");
                            VAR_18 += sizeof (VAR_20);

                            VAR_21 = (int)(VAR_8.ckDataSize - sizeof (VAR_20)) / 4;

                            if (VAR_20 < VAR_21 || VAR_20 < 1 || VAR_20 > 256) {
                                error_line (""%s is not a valid .DFF file!"", VAR_1);
                                free (VAR_17);
                                return VAR_10;
                            }

                            while (VAR_21--) {
                                if (!strncmp (VAR_18, ""SLFT"", 4) || !strncmp (VAR_18, ""MLFT"", 4))
                                    VAR_22 |= 0x1;
                                else if (!strncmp (VAR_18, ""SRGT"", 4) || !strncmp (VAR_18, ""MRGT"", 4))
                                    VAR_22 |= 0x2;
                                else if (!strncmp (VAR_18, ""LS  "", 4))
                                    VAR_22 |= 0x10;
                                else if (!strncmp (VAR_18, ""RS  "", 4))
                                    VAR_22 |= 0x20;
                                else if (!strncmp (VAR_18, ""C   "", 4))
                                    VAR_22 |= 0x4;
                                else if (!strncmp (VAR_18, ""LFE "", 4))
                                    VAR_22 |= 0x8;
                                else
                                    if (VAR_14)
                                        error_line (""undefined channel ID %c%c%c%c"", VAR_18 [0], VAR_18 [1], VAR_18 [2], VAR_18 [3]);

                                VAR_18 += 4;
                            }

                            if (VAR_14)
                                error_line (""%d channels, mask = 0x%08x"", VAR_20, VAR_22);
                        }
                        else if (!strncmp (VAR_8.ckID, ""CMPR"", 4) && VAR_8.ckDataSize >= 4) {
                            if (strncmp (VAR_18, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    VAR_18 [0], VAR_18 [1], VAR_18 [2], VAR_18 [3]);
                                free (VAR_17);
                                return VAR_10;
                            }

                            VAR_18 += VAR_8.ckDataSize;
                        }
                        else {
                            if (VAR_14)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", VAR_8.ckID [0],
                                    VAR_8.ckID [1], VAR_8.ckID [2], VAR_8.ckID [3], VAR_8.ckDataSize);

                            VAR_18 += VAR_8.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", VAR_1);
                        free (VAR_17);
                        return VAR_10;
                    }
                }

                if (VAR_22 && (VAR_4->channel_mask || (VAR_4->qmode & VAR_24))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (VAR_17);
                    return VAR_10;
                }
                else if (VAR_22)
                    VAR_4->channel_mask = VAR_22;

                VAR_4->bits_per_sample = 8;
                VAR_4->bytes_per_sample = 1;
                VAR_4->num_channels = VAR_20;
                VAR_4->sample_rate = VAR_23 / 8;
                VAR_4->qmode |= VAR_25;
            }
            else if (VAR_14)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    VAR_17 [0], VAR_17 [1], VAR_17 [2], VAR_17 [3], VAR_8.ckDataSize);

            free (VAR_17);
        }
        else if (!strncmp (VAR_8.ckID, ""DSD "", 4)) {

            if (!VAR_4->num_channels || !VAR_4->sample_rate) {
                error_line (""%s is not a valid .DFF file!"", VAR_1);
                return VAR_10;
            }

            VAR_6 = VAR_8.ckDataSize / VAR_4->num_channels;
            break;
        }
        else {          /* COMMENT_3 */

            int VAR_26 = (int)(((VAR_8.ckDataSize) + 1) & ~(int64_t)1);
            char *VAR_27;

            if (VAR_26 < 0 || VAR_26 > 4194304) {
                error_line (""%s is not a valid .DFF file!"", VAR_1);
                return VAR_10;
            }

            VAR_27 = malloc (VAR_26);

            if (VAR_14)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    VAR_8.ckID [0], VAR_8.ckID [1], VAR_8.ckID [2],
                    VAR_8.ckID [3], VAR_8.ckDataSize);

            if (!DoReadFile (VAR_0, VAR_27, VAR_26, &VAR_9) ||
                VAR_9 != VAR_26 ||
                (!(VAR_4->qmode & VAR_11) &&
                !WavpackAddWrapper (VAR_3, VAR_27, VAR_26))) {
                    error_line (""%s"", WavpackGetErrorMessage (VAR_3));
                    free (VAR_27);
                    return VAR_10;
            }

            free (VAR_27);
        }
    }

    if (VAR_14)
        error_line (""setting configuration with %lld samples"", VAR_6);

    if (!WavpackSetConfiguration64 (VAR_3, VAR_4, VAR_6, NULL)) {
        error_line (""%s: %s"", VAR_1, WavpackGetErrorMessage (VAR_3));
        return VAR_10;
    }

    return VAR_28;
}",dbry/WavPack/bc6cba3f552c44565f7f1e66dc1580189addb2b4/dsdiff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -102,7 +102,7 @@
             if (!strncmp (prop_chunk, ""SND "", 4)) {
                 char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                 uint16_t numChannels = 0, chansSpecified, chanMask = 0;
-                uint32_t sampleRate;
+                uint32_t sampleRate = 0;
 
                 while (eptr - cptr >= sizeof (dff_chunk_header)) {
                     memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
@@ -201,7 +201,7 @@
         }
         else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
 
-            if (!config->num_channels) {
+            if (!config->num_channels || !config->sample_rate) {
                 error_line (""%s is not a valid .DFF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }","{'deleted_lines': ['                uint32_t sampleRate;', '            if (!config->num_channels) {'], 'added_lines': ['                uint32_t sampleRate = 0;', '            if (!config->num_channels || !config->sample_rate) {']}",True,"WavpackSetConfiguration64 in pack_utils.c in libwavpack.a in WavPack through 5.1.0 has a ""Conditional jump or move depends on uninitialised value"" condition, which might allow attackers to cause a denial of service (application crash) via a DFF file that lacks valid sample-rate data.",6.5,MEDIUM,1,valid,2019-03-06T05:32:27Z,2
CVE-2019-11339,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block()

Fixes: Out of array access
Fixes: 13500/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_MPEG4_fuzzer-5769760178962432

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: Kieran Kunhya <kierank@obe.tv>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",d227ed5d598340e719eff7156b1aa0a4469e9a6a,https://github.com/FFmpeg/FFmpeg/commit/d227ed5d598340e719eff7156b1aa0a4469e9a6a,libavcodec/mpeg4videodec.c,mpeg4_decode_studio_block,"static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)
{
Mpeg4DecContext *ctx = s->avctx->priv_data;
int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,
additional_code_len, sign, mismatch;
VLC *cur_vlc = &ctx->studio_intra_tab[0];
uint8_t *const scantable = s->intra_scantable.permutated;
const uint16_t *quant_matrix;
uint32_t flc;
const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));
const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);
mismatch = 1;
memset(block, 0, 64 * sizeof(int32_t));
if (n < 4) {
cc = 0;
dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
quant_matrix = s->intra_matrix;
} else {
cc = (n & 1) + 1;
if (ctx->rgb)
dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
else
dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);
quant_matrix = s->chroma_intra_matrix;
}
if (dct_dc_size < 0) {
av_log(s->avctx, AV_LOG_ERROR, ""illegal dct_dc_size vlc\n"");
return AVERROR_INVALIDDATA;
} else if (dct_dc_size == 0) {
dct_diff = 0;
} else {
dct_diff = get_xbits(&s->gb, dct_dc_size);
if (dct_dc_size > 8) {
if(!check_marker(s->avctx, &s->gb, ""dct_dc_size > 8""))
return AVERROR_INVALIDDATA;
}
}
s->last_dc[cc] += dct_diff;
if (s->mpeg_quant)
block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);
else
block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);
block[0] = av_clip(block[0], min, max);
mismatch ^= block[0];
while (1) {
group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);
if (group < 0) {
av_log(s->avctx, AV_LOG_ERROR, ""illegal ac coefficient group vlc\n"");
return AVERROR_INVALIDDATA;
}
additional_code_len = ac_state_tab[group][0];
cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];
if (group == 0) {
break;
} else if (group >= 1 && group <= 6) {
run = 1 << additional_code_len;
if (additional_code_len)
run += get_bits(&s->gb, additional_code_len);
idx += run;
continue;
} else if (group >= 7 && group <= 12) {
code = get_bits(&s->gb, additional_code_len);
sign = code & 1;
code >>= 1;
run = (1 << (additional_code_len - 1)) + code;
idx += run;
j = scantable[idx++];
block[j] = sign ? 1 : -1;
} else if (group >= 13 && group <= 20) {
j = scantable[idx++];
block[j] = get_xbits(&s->gb, additional_code_len);
} else if (group == 21) {
j = scantable[idx++];
additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;
flc = get_bits(&s->gb, additional_code_len);
if (flc >> (additional_code_len-1))
block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);
else
block[j] = flc;
}
block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;
block[j] = av_clip(block[j], min, max);
mismatch ^= block[j];
}
block[63] ^= mismatch & 1;
return 0;
}","static int mpeg4_decode_studio_block(MpegEncContext *VAR_0, int32_t VAR_1[64], int VAR_2)
{
Mpeg4DecContext *VAR_3 = VAR_0->avctx->priv_data;
int VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9 = 1, VAR_10 = 0, VAR_11 = 0,
VAR_12, VAR_13, VAR_14;
VLC *VAR_15 = &VAR_3->studio_intra_tab[0];
uint8_t *const VAR_16 = VAR_0->intra_scantable.permutated;
const uint16_t *VAR_17;
uint32_t VAR_18;
const int VAR_19 = -1 *  (1 << (VAR_0->avctx->bits_per_raw_sample + 6));
const int VAR_20 =      ((1 << (VAR_0->avctx->bits_per_raw_sample + 6)) - 1);
VAR_14 = 1;
memset(VAR_1, 0, 64 * sizeof(int32_t));
if (VAR_2 < 4) {
VAR_4 = 0;
VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_luma_dc.table, VAR_21, 2);
VAR_17 = VAR_0->intra_matrix;
} else {
VAR_4 = (VAR_2 & 1) + 1;
if (VAR_3->rgb)
VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_luma_dc.table, VAR_21, 2);
else
VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_chroma_dc.table, VAR_21, 2);
VAR_17 = VAR_0->chroma_intra_matrix;
}
if (VAR_5 < 0) {
av_log(VAR_0->avctx, VAR_22, ""illegal dct_dc_size vlc\n"");
return VAR_23;
} else if (VAR_5 == 0) {
VAR_6 = 0;
} else {
VAR_6 = get_xbits(&VAR_0->gb, VAR_5);
if (VAR_5 > 8) {
if(!check_marker(VAR_0->avctx, &VAR_0->gb, ""dct_dc_size > 8""))
return VAR_23;
}
}
VAR_0->last_dc[VAR_4] += VAR_6;
if (VAR_0->mpeg_quant)
VAR_1[0] = VAR_0->last_dc[VAR_4] * (8 >> VAR_0->intra_dc_precision);
else
VAR_1[0] = VAR_0->last_dc[VAR_4] * (8 >> VAR_0->intra_dc_precision) * (8 >> VAR_0->dct_precision);
VAR_1[0] = av_clip(VAR_1[0], VAR_19, VAR_20);
VAR_14 ^= VAR_1[0];
while (1) {
VAR_10 = get_vlc2(&VAR_0->gb, VAR_15->table, VAR_21, 2);
if (VAR_10 < 0) {
av_log(VAR_0->avctx, VAR_22, ""illegal ac coefficient group vlc\n"");
return VAR_23;
}
VAR_12 = VAR_24[VAR_10][0];
VAR_15 = &VAR_3->studio_intra_tab[VAR_24[VAR_10][1]];
if (VAR_10 == 0) {
break;
} else if (VAR_10 >= 1 && VAR_10 <= 6) {
VAR_11 = 1 << VAR_12;
if (VAR_12)
VAR_11 += get_bits(&VAR_0->gb, VAR_12);
VAR_9 += VAR_11;
continue;
} else if (VAR_10 >= 7 && VAR_10 <= 12) {
VAR_7 = get_bits(&VAR_0->gb, VAR_12);
VAR_13 = VAR_7 & 1;
VAR_7 >>= 1;
VAR_11 = (1 << (VAR_12 - 1)) + VAR_7;
VAR_9 += VAR_11;
VAR_8 = VAR_16[VAR_9++];
VAR_1[VAR_8] = VAR_13 ? 1 : -1;
} else if (VAR_10 >= 13 && VAR_10 <= 20) {
VAR_8 = VAR_16[VAR_9++];
VAR_1[VAR_8] = get_xbits(&VAR_0->gb, VAR_12);
} else if (VAR_10 == 21) {
VAR_8 = VAR_16[VAR_9++];
VAR_12 = VAR_0->avctx->bits_per_raw_sample + VAR_0->dct_precision + 4;
VAR_18 = get_bits(&VAR_0->gb, VAR_12);
if (VAR_18 >> (VAR_12-1))
VAR_1[VAR_8] = -1 * (( VAR_18 ^ ((1 << VAR_12) -1)) + 1);
else
VAR_1[VAR_8] = VAR_18;
}
VAR_1[VAR_8] = ((8 * 2 * VAR_1[VAR_8] * VAR_17[VAR_8] * VAR_0->qscale) >> VAR_0->dct_precision) / 32;
VAR_1[VAR_8] = av_clip(VAR_1[VAR_8], VAR_19, VAR_20);
VAR_14 ^= VAR_1[VAR_8];
}
VAR_1[63] ^= VAR_14 & 1;
return 0;
}",ffmpeg/d227ed5d598340e719eff7156b1aa0a4469e9a6a/mpeg4videodec.c/vul/before/0.json,"static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)
{
    Mpeg4DecContext *ctx = s->avctx->priv_data;

    int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,
        additional_code_len, sign, mismatch;
    VLC *cur_vlc = &ctx->studio_intra_tab[0];
    uint8_t *const scantable = s->intra_scantable.permutated;
    const uint16_t *quant_matrix;
    uint32_t flc;
    const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));
    const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);

    mismatch = 1;

    memset(block, 0, 64 * sizeof(int32_t));

    if (n < 4) {
        cc = 0;
        dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
        quant_matrix = s->intra_matrix;
    } else {
        cc = (n & 1) + 1;
        if (ctx->rgb)
            dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
        else
            dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);
        quant_matrix = s->chroma_intra_matrix;
    }

    if (dct_dc_size < 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""illegal dct_dc_size vlc\n"");
        return AVERROR_INVALIDDATA;
    } else if (dct_dc_size == 0) {
        dct_diff = 0;
    } else {
        dct_diff = get_xbits(&s->gb, dct_dc_size);

        if (dct_dc_size > 8) {
            if(!check_marker(s->avctx, &s->gb, ""dct_dc_size > 8""))
                return AVERROR_INVALIDDATA;
        }

    }

    s->last_dc[cc] += dct_diff;

    if (s->mpeg_quant)
        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);
    else
        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);
    /* TODO: support mpeg_quant for AC coefficients */

    block[0] = av_clip(block[0], min, max);
    mismatch ^= block[0];

    /* AC Coefficients */
    while (1) {
        group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);

        if (group < 0) {
            av_log(s->avctx, AV_LOG_ERROR, ""illegal ac coefficient group vlc\n"");
            return AVERROR_INVALIDDATA;
        }

        additional_code_len = ac_state_tab[group][0];
        cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];

        if (group == 0) {
            /* End of Block */
            break;
        } else if (group >= 1 && group <= 6) {
            /* Zero run length (Table B.47) */
            run = 1 << additional_code_len;
            if (additional_code_len)
                run += get_bits(&s->gb, additional_code_len);
            idx += run;
            continue;
        } else if (group >= 7 && group <= 12) {
            /* Zero run length and +/-1 level (Table B.48) */
            code = get_bits(&s->gb, additional_code_len);
            sign = code & 1;
            code >>= 1;
            run = (1 << (additional_code_len - 1)) + code;
            idx += run;
            if (idx > 63)
                return AVERROR_INVALIDDATA;
            j = scantable[idx++];
            block[j] = sign ? 1 : -1;
        } else if (group >= 13 && group <= 20) {
            /* Level value (Table B.49) */
            if (idx > 63)
                return AVERROR_INVALIDDATA;
            j = scantable[idx++];
            block[j] = get_xbits(&s->gb, additional_code_len);
        } else if (group == 21) {
            /* Escape */
            if (idx > 63)
                return AVERROR_INVALIDDATA;
            j = scantable[idx++];
            additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;
            flc = get_bits(&s->gb, additional_code_len);
            if (flc >> (additional_code_len-1))
                block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);
            else
                block[j] = flc;
        }
        block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;
        block[j] = av_clip(block[j], min, max);
        mismatch ^= block[j];
    }

    block[63] ^= mismatch & 1;

    return 0;
}","static int mpeg4_decode_studio_block(MpegEncContext *VAR_0, int32_t VAR_1[64], int VAR_2)
{
    Mpeg4DecContext *VAR_3 = VAR_0->avctx->priv_data;

    int VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9 = 1, VAR_10 = 0, VAR_11 = 0,
        VAR_12, VAR_13, VAR_14;
    VLC *VAR_15 = &VAR_3->studio_intra_tab[0];
    uint8_t *const VAR_16 = VAR_0->intra_scantable.permutated;
    const uint16_t *VAR_17;
    uint32_t VAR_18;
    const int VAR_19 = -1 *  (1 << (VAR_0->avctx->bits_per_raw_sample + 6));
    const int VAR_20 =      ((1 << (VAR_0->avctx->bits_per_raw_sample + 6)) - 1);

    VAR_14 = 1;

    memset(VAR_1, 0, 64 * sizeof(int32_t));

    if (VAR_2 < 4) {
        VAR_4 = 0;
        VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_luma_dc.table, VAR_21, 2);
        VAR_17 = VAR_0->intra_matrix;
    } else {
        VAR_4 = (VAR_2 & 1) + 1;
        if (VAR_3->rgb)
            VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_luma_dc.table, VAR_21, 2);
        else
            VAR_5 = get_vlc2(&VAR_0->gb, VAR_3->studio_chroma_dc.table, VAR_21, 2);
        VAR_17 = VAR_0->chroma_intra_matrix;
    }

    if (VAR_5 < 0) {
        av_log(VAR_0->avctx, VAR_22, ""illegal dct_dc_size vlc\n"");
        return VAR_23;
    } else if (VAR_5 == 0) {
        VAR_6 = 0;
    } else {
        VAR_6 = get_xbits(&VAR_0->gb, VAR_5);

        if (VAR_5 > 8) {
            if(!check_marker(VAR_0->avctx, &VAR_0->gb, ""dct_dc_size > 8""))
                return VAR_23;
        }

    }

    VAR_0->last_dc[VAR_4] += VAR_6;

    if (VAR_0->mpeg_quant)
        VAR_1[0] = VAR_0->last_dc[VAR_4] * (8 >> VAR_0->intra_dc_precision);
    else
        VAR_1[0] = VAR_0->last_dc[VAR_4] * (8 >> VAR_0->intra_dc_precision) * (8 >> VAR_0->dct_precision);
    /* COMMENT_0 */

    VAR_1[0] = av_clip(VAR_1[0], VAR_19, VAR_20);
    VAR_14 ^= VAR_1[0];

    /* COMMENT_1 */
    while (1) {
        VAR_10 = get_vlc2(&VAR_0->gb, VAR_15->table, VAR_21, 2);

        if (VAR_10 < 0) {
            av_log(VAR_0->avctx, VAR_22, ""illegal ac coefficient group vlc\n"");
            return VAR_23;
        }

        VAR_12 = VAR_24[VAR_10][0];
        VAR_15 = &VAR_3->studio_intra_tab[VAR_24[VAR_10][1]];

        if (VAR_10 == 0) {
            /* COMMENT_2 */
            break;
        } else if (VAR_10 >= 1 && VAR_10 <= 6) {
            /* COMMENT_3 */
            VAR_11 = 1 << VAR_12;
            if (VAR_12)
                VAR_11 += get_bits(&VAR_0->gb, VAR_12);
            VAR_9 += VAR_11;
            continue;
        } else if (VAR_10 >= 7 && VAR_10 <= 12) {
            /* COMMENT_4 */
            VAR_7 = get_bits(&VAR_0->gb, VAR_12);
            VAR_13 = VAR_7 & 1;
            VAR_7 >>= 1;
            VAR_11 = (1 << (VAR_12 - 1)) + VAR_7;
            VAR_9 += VAR_11;
            if (VAR_9 > 63)
                return VAR_23;
            VAR_8 = VAR_16[VAR_9++];
            VAR_1[VAR_8] = VAR_13 ? 1 : -1;
        } else if (VAR_10 >= 13 && VAR_10 <= 20) {
            /* COMMENT_5 */
            if (VAR_9 > 63)
                return VAR_23;
            VAR_8 = VAR_16[VAR_9++];
            VAR_1[VAR_8] = get_xbits(&VAR_0->gb, VAR_12);
        } else if (VAR_10 == 21) {
            /* COMMENT_6 */
            if (VAR_9 > 63)
                return VAR_23;
            VAR_8 = VAR_16[VAR_9++];
            VAR_12 = VAR_0->avctx->bits_per_raw_sample + VAR_0->dct_precision + 4;
            VAR_18 = get_bits(&VAR_0->gb, VAR_12);
            if (VAR_18 >> (VAR_12-1))
                VAR_1[VAR_8] = -1 * (( VAR_18 ^ ((1 << VAR_12) -1)) + 1);
            else
                VAR_1[VAR_8] = VAR_18;
        }
        VAR_1[VAR_8] = ((8 * 2 * VAR_1[VAR_8] * VAR_17[VAR_8] * VAR_0->qscale) >> VAR_0->dct_precision) / 32;
        VAR_1[VAR_8] = av_clip(VAR_1[VAR_8], VAR_19, VAR_20);
        VAR_14 ^= VAR_1[VAR_8];
    }

    VAR_1[63] ^= VAR_14 & 1;

    return 0;
}",ffmpeg/d227ed5d598340e719eff7156b1aa0a4469e9a6a/mpeg4videodec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -83,14 +83,20 @@
             code >>= 1;
             run = (1 << (additional_code_len - 1)) + code;
             idx += run;
+            if (idx > 63)
+                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             block[j] = sign ? 1 : -1;
         } else if (group >= 13 && group <= 20) {
             /* Level value (Table B.49) */
+            if (idx > 63)
+                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             block[j] = get_xbits(&s->gb, additional_code_len);
         } else if (group == 21) {
             /* Escape */
+            if (idx > 63)
+                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;
             flc = get_bits(&s->gb, additional_code_len);","{'deleted_lines': [], 'added_lines': ['            if (idx > 63)', '                return AVERROR_INVALIDDATA;', '            if (idx > 63)', '                return AVERROR_INVALIDDATA;', '            if (idx > 63)', '                return AVERROR_INVALIDDATA;']}",True,The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,8.8,HIGH,2,valid,2019-03-10T00:40:59Z,2
CVE-2019-12974,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1515,b4dd4d266f2d450a2996abf5294671d888991132,https://github.com/ImageMagick/ImageMagick/commit/b4dd4d266f2d450a2996abf5294671d888991132,coders/pango.c,ReadPANGOImage,"static Image *ReadPANGOImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
cairo_font_options_t
*font_options;
cairo_surface_t
*surface;
char
*caption,
*property;
cairo_t
*cairo_image;
const char
*option;
DrawInfo
*draw_info;
Image
*image;
MagickBooleanType
status;
MemoryInfo
*pixel_info;
PangoAlignment
align;
PangoContext
*context;
PangoFontDescription
*description;
PangoFontMap
*fontmap;
PangoGravity
gravity;
PangoLayout
*layout;
PangoRectangle
extent;
PixelInfo
fill_color;
RectangleInfo
page;
register unsigned char
*p;
size_t
stride;
ssize_t
y;
unsigned char
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
(void) ResetImagePage(image,""0x0+0+0"");
if ((image->columns != 0) && (image->rows != 0))
(void) SetImageBackgroundColor(image,exception);
option=GetImageOption(image_info,""filename"");
if (option == (const char *) NULL)
property=InterpretImageProperties((ImageInfo *) image_info,image,
image_info->filename,exception);
else
if (LocaleNCompare(option,""pango:"",6) == 0)
property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,
exception);
else
property=InterpretImageProperties((ImageInfo *) image_info,image,option,
exception);
(void) SetImageProperty(image,""caption"",property,exception);
property=DestroyString(property);
caption=ConstantString(GetImageProperty(image,""caption"",exception));
fontmap=pango_cairo_font_map_new();
pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),
image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);
font_options=cairo_font_options_create();
option=GetImageOption(image_info,""pango:hinting"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""none"") != 0)
cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);
if (LocaleCompare(option,""full"") != 0)
cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);
}
context=pango_font_map_create_context(fontmap);
pango_cairo_context_set_font_options(context,font_options);
cairo_font_options_destroy(font_options);
option=GetImageOption(image_info,""pango:language"");
if (option != (const char *) NULL)
pango_context_set_language(context,pango_language_from_string(option));
draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
pango_context_set_base_dir(context,draw_info->direction ==
RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);
switch (draw_info->gravity)
{
case NorthGravity:
{
gravity=PANGO_GRAVITY_NORTH;
break;
}
case NorthWestGravity:
case WestGravity:
case SouthWestGravity:
{
gravity=PANGO_GRAVITY_WEST;
break;
}
case NorthEastGravity:
case EastGravity:
case SouthEastGravity:
{
gravity=PANGO_GRAVITY_EAST;
break;
}
case SouthGravity:
{
gravity=PANGO_GRAVITY_SOUTH;
break;
}
default:
{
gravity=PANGO_GRAVITY_AUTO;
break;
}
}
pango_context_set_base_gravity(context,gravity);
option=GetImageOption(image_info,""pango:gravity-hint"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""line"") == 0)
pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);
if (LocaleCompare(option,""natural"") == 0)
pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);
if (LocaleCompare(option,""strong"") == 0)
pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);
}
layout=pango_layout_new(context);
option=GetImageOption(image_info,""pango:auto-dir"");
if (option != (const char *) NULL)
pango_layout_set_auto_dir(layout,1);
option=GetImageOption(image_info,""pango:ellipsize"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""end"") == 0)
pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);
if (LocaleCompare(option,""middle"") == 0)
pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);
if (LocaleCompare(option,""none"") == 0)
pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);
if (LocaleCompare(option,""start"") == 0)
pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);
}
option=GetImageOption(image_info,""pango:justify"");
if (IsStringTrue(option) != MagickFalse)
pango_layout_set_justify(layout,1);
option=GetImageOption(image_info,""pango:single-paragraph"");
if (IsStringTrue(option) != MagickFalse)
pango_layout_set_single_paragraph_mode(layout,1);
option=GetImageOption(image_info,""pango:wrap"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""char"") == 0)
pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);
if (LocaleCompare(option,""word"") == 0)
pango_layout_set_wrap(layout,PANGO_WRAP_WORD);
if (LocaleCompare(option,""word-char"") == 0)
pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);
}
option=GetImageOption(image_info,""pango:indent"");
if (option != (const char *) NULL)
pango_layout_set_indent(layout,(int) ((StringToLong(option)*
(image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*
PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
switch (draw_info->align)
{
case CenterAlign: align=PANGO_ALIGN_CENTER; break;
case RightAlign: align=PANGO_ALIGN_RIGHT; break;
case LeftAlign: align=PANGO_ALIGN_LEFT; break;
default:
{
if (draw_info->gravity == CenterGravity)
{
align=PANGO_ALIGN_CENTER;
break;
}
align=PANGO_ALIGN_LEFT;
break;
}
}
if ((align != PANGO_ALIGN_CENTER) &&
(draw_info->direction == RightToLeftDirection))
align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);
option=GetImageOption(image_info,""pango:align"");
if (option != (const char *) NULL)
{
if (LocaleCompare(option,""center"") == 0)
align=PANGO_ALIGN_CENTER;
if (LocaleCompare(option,""left"") == 0)
align=PANGO_ALIGN_LEFT;
if (LocaleCompare(option,""right"") == 0)
align=PANGO_ALIGN_RIGHT;
}
pango_layout_set_alignment(layout,align);
if (draw_info->font == (char *) NULL)
description=pango_font_description_new();
else
description=pango_font_description_from_string(draw_info->font);
pango_font_description_set_size(description,(int) (PANGO_SCALE*
draw_info->pointsize+0.5));
pango_layout_set_font_description(layout,description);
pango_font_description_free(description);
option=GetImageOption(image_info,""pango:markup"");
if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))
pango_layout_set_text(layout,caption,-1);
else
{
GError
*error;
error=(GError *) NULL;
if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)
(void) ThrowMagickException(exception,GetMagickModule(),CoderError,
error->message,""`%s'"",image_info->filename);
pango_layout_set_markup(layout,caption,-1);
}
pango_layout_context_changed(layout);
page.x=0;
page.y=0;
if (image_info->page != (char *) NULL)
(void) ParseAbsoluteGeometry(image_info->page,&page);
if (image->columns == 0)
{
pango_layout_get_extents(layout,NULL,&extent);
image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;
}
else
{
image->columns-=2*page.x;
pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*
(image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+
DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
}
if (image->rows == 0)
{
pango_layout_get_extents(layout,NULL,&extent);
image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;
}
else
{
image->rows-=2*page.y;
pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*
(image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+
DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,
(int) image->columns);
pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
{
draw_info=DestroyDrawInfo(draw_info);
caption=DestroyString(caption);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,
(int) image->columns,(int) image->rows,(int) stride);
cairo_image=cairo_create(surface);
cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);
cairo_paint(cairo_image);
cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);
cairo_translate(cairo_image,page.x,page.y);
cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,
QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,
QuantumScale*draw_info->fill.alpha);
pango_cairo_show_layout(cairo_image,layout);
cairo_destroy(cairo_image);
cairo_surface_destroy(surface);
g_object_unref(layout);
g_object_unref(fontmap);
(void) SetImageBackgroundColor(image,exception);
p=pixels;
GetPixelInfo(image,&fill_color);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*q;
register ssize_t
x;
q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
double
gamma;
fill_color.blue=(double) ScaleCharToQuantum(*p++);
fill_color.green=(double) ScaleCharToQuantum(*p++);
fill_color.red=(double) ScaleCharToQuantum(*p++);
fill_color.alpha=(double) ScaleCharToQuantum(*p++);
gamma=QuantumScale*fill_color.alpha;
gamma=PerceptibleReciprocal(gamma);
fill_color.blue*=gamma;
fill_color.green*=gamma;
fill_color.red*=gamma;
CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)
GetPixelAlpha(image,q),q);
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
pixel_info=RelinquishVirtualMemory(pixel_info);
draw_info=DestroyDrawInfo(draw_info);
caption=DestroyString(caption);
return(GetFirstImageInList(image));
}","static Image *ReadPANGOImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
cairo_font_options_t
*VAR_2;
cairo_surface_t
*VAR_3;
char
*VAR_4,
*VAR_5;
cairo_t
*VAR_6;
const char
*VAR_7;
DrawInfo
*VAR_8;
Image
*VAR_9;
MagickBooleanType
VAR_10;
MemoryInfo
*VAR_11;
PangoAlignment
VAR_12;
PangoContext
*VAR_13;
PangoFontDescription
*VAR_14;
PangoFontMap
*VAR_15;
PangoGravity
VAR_16;
PangoLayout
*VAR_17;
PangoRectangle
VAR_18;
PixelInfo
VAR_19;
RectangleInfo
VAR_20;
register unsigned char
*VAR_21;
size_t
VAR_22;
ssize_t
VAR_23;
unsigned char
*VAR_24;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_25);
if (VAR_0->debug != VAR_26)
(void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_25);
VAR_9=AcquireImage(VAR_0,VAR_1);
(void) ResetImagePage(VAR_9,""0x0+0+0"");
if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
(void) SetImageBackgroundColor(VAR_9,VAR_1);
VAR_7=GetImageOption(VAR_0,""filename"");
if (VAR_7 == (const char *) NULL)
VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
VAR_0->filename,VAR_1);
else
if (LocaleNCompare(VAR_7,""pango:"",6) == 0)
VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7+6,
VAR_1);
else
VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7,
VAR_1);
(void) SetImageProperty(VAR_9,""caption"",VAR_5,VAR_1);
VAR_5=DestroyString(VAR_5);
VAR_4=ConstantString(GetImageProperty(VAR_9,""caption"",VAR_1));
VAR_15=pango_cairo_font_map_new();
pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(VAR_15),
VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x);
VAR_2=cairo_font_options_create();
VAR_7=GetImageOption(VAR_0,""pango:hinting"");
if (VAR_7 != (const char *) NULL)
{
if (LocaleCompare(VAR_7,""none"") != 0)
cairo_font_options_set_hint_style(VAR_2,VAR_29);
if (LocaleCompare(VAR_7,""full"") != 0)
cairo_font_options_set_hint_style(VAR_2,VAR_30);
}
VAR_13=pango_font_map_create_context(VAR_15);
pango_cairo_context_set_font_options(VAR_13,VAR_2);
cairo_font_options_destroy(VAR_2);
VAR_7=GetImageOption(VAR_0,""pango:language"");
if (VAR_7 != (const char *) NULL)
pango_context_set_language(VAR_13,pango_language_from_string(VAR_7));
VAR_8=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
pango_context_set_base_dir(VAR_13,VAR_8->direction ==
VAR_31 ? VAR_32 : VAR_33);
switch (VAR_8->gravity)
{
case VAR_34:
{
VAR_16=VAR_35;
break;
}
case VAR_36:
case VAR_37:
case VAR_38:
{
VAR_16=VAR_39;
break;
}
case VAR_40:
case VAR_41:
case VAR_42:
{
VAR_16=VAR_43;
break;
}
case VAR_44:
{
VAR_16=VAR_45;
break;
}
default:
{
VAR_16=VAR_46;
break;
}
}
pango_context_set_base_gravity(VAR_13,VAR_16);
VAR_7=GetImageOption(VAR_0,""pango:gravity-hint"");
if (VAR_7 != (const char *) NULL)
{
if (LocaleCompare(VAR_7,""line"") == 0)
pango_context_set_gravity_hint(VAR_13,VAR_47);
if (LocaleCompare(VAR_7,""natural"") == 0)
pango_context_set_gravity_hint(VAR_13,VAR_48);
if (LocaleCompare(VAR_7,""strong"") == 0)
pango_context_set_gravity_hint(VAR_13,VAR_49);
}
VAR_17=pango_layout_new(VAR_13);
VAR_7=GetImageOption(VAR_0,""pango:auto-dir"");
if (VAR_7 != (const char *) NULL)
pango_layout_set_auto_dir(VAR_17,1);
VAR_7=GetImageOption(VAR_0,""pango:ellipsize"");
if (VAR_7 != (const char *) NULL)
{
if (LocaleCompare(VAR_7,""end"") == 0)
pango_layout_set_ellipsize(VAR_17,VAR_50);
if (LocaleCompare(VAR_7,""middle"") == 0)
pango_layout_set_ellipsize(VAR_17,VAR_51);
if (LocaleCompare(VAR_7,""none"") == 0)
pango_layout_set_ellipsize(VAR_17,VAR_52);
if (LocaleCompare(VAR_7,""start"") == 0)
pango_layout_set_ellipsize(VAR_17,VAR_53);
}
VAR_7=GetImageOption(VAR_0,""pango:justify"");
if (IsStringTrue(VAR_7) != VAR_26)
pango_layout_set_justify(VAR_17,1);
VAR_7=GetImageOption(VAR_0,""pango:single-paragraph"");
if (IsStringTrue(VAR_7) != VAR_26)
pango_layout_set_single_paragraph_mode(VAR_17,1);
VAR_7=GetImageOption(VAR_0,""pango:wrap"");
if (VAR_7 != (const char *) NULL)
{
if (LocaleCompare(VAR_7,""char"") == 0)
pango_layout_set_wrap(VAR_17,VAR_54);
if (LocaleCompare(VAR_7,""word"") == 0)
pango_layout_set_wrap(VAR_17,VAR_55);
if (LocaleCompare(VAR_7,""word-char"") == 0)
pango_layout_set_wrap(VAR_17,VAR_56);
}
VAR_7=GetImageOption(VAR_0,""pango:indent"");
if (VAR_7 != (const char *) NULL)
pango_layout_set_indent(VAR_17,(int) ((StringToLong(VAR_7)*
(VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x)*
VAR_57+VAR_28/2)/VAR_28+0.5));
switch (VAR_8->align)
{
case VAR_58: VAR_12=VAR_59; break;
case VAR_60: VAR_12=VAR_61; break;
case VAR_62: VAR_12=VAR_63; break;
default:
{
if (VAR_8->gravity == VAR_64)
{
VAR_12=VAR_59;
break;
}
VAR_12=VAR_63;
break;
}
}
if ((VAR_12 != VAR_59) &&
(VAR_8->direction == VAR_31))
VAR_12=(PangoAlignment) (VAR_63+VAR_61-VAR_12);
VAR_7=GetImageOption(VAR_0,""pango:align"");
if (VAR_7 != (const char *) NULL)
{
if (LocaleCompare(VAR_7,""center"") == 0)
VAR_12=VAR_59;
if (LocaleCompare(VAR_7,""left"") == 0)
VAR_12=VAR_63;
if (LocaleCompare(VAR_7,""right"") == 0)
VAR_12=VAR_61;
}
pango_layout_set_alignment(VAR_17,VAR_12);
if (VAR_8->font == (char *) NULL)
VAR_14=pango_font_description_new();
else
VAR_14=pango_font_description_from_string(VAR_8->font);
pango_font_description_set_size(VAR_14,(int) (VAR_57*
VAR_8->pointsize+0.5));
pango_layout_set_font_description(VAR_17,VAR_14);
pango_font_description_free(VAR_14);
VAR_7=GetImageOption(VAR_0,""pango:markup"");
if ((VAR_7 != (const char *) NULL) && (IsStringTrue(VAR_7) == VAR_26))
pango_layout_set_text(VAR_17,VAR_4,-1);
else
{
GError
*VAR_65;
VAR_65=(GError *) NULL;
if (pango_parse_markup(VAR_4,-1,0,NULL,NULL,NULL,&VAR_65) == 0)
(void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_66,
VAR_65->message,""`%s'"",VAR_0->filename);
pango_layout_set_markup(VAR_17,VAR_4,-1);
}
pango_layout_context_changed(VAR_17);
VAR_20.x=0;
VAR_20.y=0;
if (VAR_0->page != (char *) NULL)
(void) ParseAbsoluteGeometry(VAR_0->page,&VAR_20);
if (VAR_9->columns == 0)
{
pango_layout_get_extents(VAR_17,NULL,&VAR_18);
VAR_9->columns=(VAR_18.x+VAR_18.width+VAR_57/2)/VAR_57+2*VAR_20.x;
}
else
{
VAR_9->columns-=2*VAR_20.x;
pango_layout_set_width(VAR_17,(int) ((VAR_57*VAR_9->columns*
(VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x)+
VAR_28/2)/VAR_28+0.5));
}
if (VAR_9->rows == 0)
{
pango_layout_get_extents(VAR_17,NULL,&VAR_18);
VAR_9->rows=(VAR_18.y+VAR_18.height+VAR_57/2)/VAR_57+2*VAR_20.y;
}
else
{
VAR_9->rows-=2*VAR_20.y;
pango_layout_set_height(VAR_17,(int) ((VAR_57*VAR_9->rows*
(VAR_9->resolution.y == 0.0 ? VAR_28 : VAR_9->resolution.y)+
VAR_28/2)/VAR_28+0.5));
}
VAR_10=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
if (VAR_10 == VAR_26)
return(DestroyImageList(VAR_9));
VAR_22=(size_t) cairo_format_stride_for_width(VAR_67,
(int) VAR_9->columns);
VAR_11=AcquireVirtualMemory(VAR_9->rows,VAR_22*sizeof(*VAR_24));
if (VAR_11 == (MemoryInfo *) NULL)
{
VAR_8=DestroyDrawInfo(VAR_8);
VAR_4=DestroyString(VAR_4);
ThrowReaderException(VAR_68,""MemoryAllocationFailed"");
}
VAR_24=(unsigned char *) GetVirtualMemoryBlob(VAR_11);
VAR_3=cairo_image_surface_create_for_data(VAR_24,VAR_67,
(int) VAR_9->columns,(int) VAR_9->rows,(int) VAR_22);
VAR_6=cairo_create(VAR_3);
cairo_set_operator(VAR_6,VAR_69);
cairo_paint(VAR_6);
cairo_set_operator(VAR_6,VAR_70);
cairo_translate(VAR_6,VAR_20.x,VAR_20.y);
cairo_set_source_rgba(VAR_6,VAR_71*VAR_8->fill.red,
VAR_71*VAR_8->fill.green,VAR_71*VAR_8->fill.blue,
VAR_71*VAR_8->fill.alpha);
pango_cairo_show_layout(VAR_6,VAR_17);
cairo_destroy(VAR_6);
cairo_surface_destroy(VAR_3);
g_object_unref(VAR_17);
g_object_unref(VAR_15);
(void) SetImageBackgroundColor(VAR_9,VAR_1);
VAR_21=VAR_24;
GetPixelInfo(VAR_9,&VAR_19);
for (VAR_23=0; VAR_23 < (ssize_t) VAR_9->rows; VAR_23++)
{
register Quantum
*VAR_72;
register ssize_t
VAR_73;
VAR_72=GetAuthenticPixels(VAR_9,0,VAR_23,VAR_9->columns,1,VAR_1);
if (VAR_72 == (Quantum *) NULL)
break;
for (VAR_73=0; VAR_73 < (ssize_t) VAR_9->columns; VAR_73++)
{
double
VAR_74;
VAR_19.blue=(double) ScaleCharToQuantum(*VAR_21++);
VAR_19.green=(double) ScaleCharToQuantum(*VAR_21++);
VAR_19.red=(double) ScaleCharToQuantum(*VAR_21++);
VAR_19.alpha=(double) ScaleCharToQuantum(*VAR_21++);
VAR_74=VAR_71*VAR_19.alpha;
VAR_74=PerceptibleReciprocal(VAR_74);
VAR_19.blue*=VAR_74;
VAR_19.green*=VAR_74;
VAR_19.red*=VAR_74;
CompositePixelOver(VAR_9,&VAR_19,VAR_19.alpha,VAR_72,(double)
GetPixelAlpha(VAR_9,VAR_72),VAR_72);
VAR_72+=GetPixelChannels(VAR_9);
}
if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_26)
break;
if (VAR_9->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_9,VAR_75,(MagickOffsetType) VAR_23,
VAR_9->rows);
if (VAR_10 == VAR_26)
break;
}
}
VAR_11=RelinquishVirtualMemory(VAR_11);
VAR_8=DestroyDrawInfo(VAR_8);
VAR_4=DestroyString(VAR_4);
return(GetFirstImageInList(VAR_9));
}",ImageMagick/b4dd4d266f2d450a2996abf5294671d888991132/pango.c/vul/before/0.json,"static Image *ReadPANGOImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  cairo_font_options_t
    *font_options;

  cairo_surface_t
    *surface;

  char
    *caption,
    *property;

  cairo_t
    *cairo_image;

  const char
    *option;

  DrawInfo
    *draw_info;

  Image
    *image;

  MagickBooleanType
    status;

  MemoryInfo
    *pixel_info;

  PangoAlignment
    align;

  PangoContext
    *context;

  PangoFontDescription
    *description;

  PangoFontMap
    *fontmap;

  PangoGravity
    gravity;

  PangoLayout
    *layout;

  PangoRectangle
    extent;

  PixelInfo
    fill_color;

  RectangleInfo
    page;

  register unsigned char
    *p;

  size_t
    stride;

  ssize_t
    y;

  unsigned char
    *pixels;

  /*
    Initialize Image structure.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  (void) ResetImagePage(image,""0x0+0+0"");
  if ((image->columns != 0) && (image->rows != 0))
    (void) SetImageBackgroundColor(image,exception);
  /*
    Format caption.
  */
  option=GetImageOption(image_info,""filename"");
  if (option == (const char *) NULL)
    property=InterpretImageProperties((ImageInfo *) image_info,image,
      image_info->filename,exception);
  else
    if (LocaleNCompare(option,""pango:"",6) == 0)
      property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,
        exception);
    else
      property=InterpretImageProperties((ImageInfo *) image_info,image,option,
        exception);
  if (property != (char *) NULL)
    {
      (void) SetImageProperty(image,""caption"",property,exception);
      property=DestroyString(property);
    }
  caption=ConstantString(GetImageProperty(image,""caption"",exception));
  /*
    Get context.
  */
  fontmap=pango_cairo_font_map_new();
  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),
    image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);
  font_options=cairo_font_options_create();
  option=GetImageOption(image_info,""pango:hinting"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""none"") != 0)
        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);
      if (LocaleCompare(option,""full"") != 0)
        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);
    }
  context=pango_font_map_create_context(fontmap);
  pango_cairo_context_set_font_options(context,font_options);
  cairo_font_options_destroy(font_options);
  option=GetImageOption(image_info,""pango:language"");
  if (option != (const char *) NULL)
    pango_context_set_language(context,pango_language_from_string(option));
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  pango_context_set_base_dir(context,draw_info->direction ==
    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);
  switch (draw_info->gravity)
  {
    case NorthGravity:
    {
      gravity=PANGO_GRAVITY_NORTH;
      break;
    }
    case NorthWestGravity:
    case WestGravity:
    case SouthWestGravity:
    {
      gravity=PANGO_GRAVITY_WEST;
      break;
    }
    case NorthEastGravity:
    case EastGravity:
    case SouthEastGravity:
    {
      gravity=PANGO_GRAVITY_EAST;
      break;
    }
    case SouthGravity:
    {
      gravity=PANGO_GRAVITY_SOUTH;
      break;
    }
    default:
    {
      gravity=PANGO_GRAVITY_AUTO;
      break;
    }
  }
  pango_context_set_base_gravity(context,gravity);
  option=GetImageOption(image_info,""pango:gravity-hint"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""line"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);
      if (LocaleCompare(option,""natural"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);
      if (LocaleCompare(option,""strong"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);
    }
  /*
    Configure layout.
  */
  layout=pango_layout_new(context);
  option=GetImageOption(image_info,""pango:auto-dir"");
  if (option != (const char *) NULL)
    pango_layout_set_auto_dir(layout,1);
  option=GetImageOption(image_info,""pango:ellipsize"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""end"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);
      if (LocaleCompare(option,""middle"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);
      if (LocaleCompare(option,""none"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);
      if (LocaleCompare(option,""start"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);
    }
  option=GetImageOption(image_info,""pango:justify"");
  if (IsStringTrue(option) != MagickFalse)
    pango_layout_set_justify(layout,1);
  option=GetImageOption(image_info,""pango:single-paragraph"");
  if (IsStringTrue(option) != MagickFalse)
    pango_layout_set_single_paragraph_mode(layout,1);
  option=GetImageOption(image_info,""pango:wrap"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""char"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);
      if (LocaleCompare(option,""word"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);
      if (LocaleCompare(option,""word-char"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);
    }
  option=GetImageOption(image_info,""pango:indent"");
  if (option != (const char *) NULL)
    pango_layout_set_indent(layout,(int) ((StringToLong(option)*
      (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*
      PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
  switch (draw_info->align)
  {
    case CenterAlign: align=PANGO_ALIGN_CENTER; break;
    case RightAlign: align=PANGO_ALIGN_RIGHT; break;
    case LeftAlign: align=PANGO_ALIGN_LEFT; break;
    default:
    {
      if (draw_info->gravity == CenterGravity)
        {
          align=PANGO_ALIGN_CENTER;
          break;
        }
      align=PANGO_ALIGN_LEFT;
      break;
    }
  }
  if ((align != PANGO_ALIGN_CENTER) &&
      (draw_info->direction == RightToLeftDirection))
    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);
  option=GetImageOption(image_info,""pango:align"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""center"") == 0)
        align=PANGO_ALIGN_CENTER;
      if (LocaleCompare(option,""left"") == 0)
        align=PANGO_ALIGN_LEFT;
      if (LocaleCompare(option,""right"") == 0)
        align=PANGO_ALIGN_RIGHT;
    }
  pango_layout_set_alignment(layout,align);
  if (draw_info->font == (char *) NULL)
    description=pango_font_description_new();
  else
    description=pango_font_description_from_string(draw_info->font);
  pango_font_description_set_size(description,(int) (PANGO_SCALE*
    draw_info->pointsize+0.5));
  pango_layout_set_font_description(layout,description);
  pango_font_description_free(description);
  option=GetImageOption(image_info,""pango:markup"");
  if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))
    pango_layout_set_text(layout,caption,-1);
  else
    {
      GError
        *error;

      error=(GError *) NULL;
      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)
        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
          error->message,""`%s'"",image_info->filename);
      pango_layout_set_markup(layout,caption,-1);
    }
  pango_layout_context_changed(layout);
  page.x=0;
  page.y=0;
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  if (image->columns == 0)
    {
      pango_layout_get_extents(layout,NULL,&extent);
      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;
    }
  else
    {
      image->columns-=2*page.x;
      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*
        (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+
        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
    }
  if (image->rows == 0)
    {
      pango_layout_get_extents(layout,NULL,&extent);
      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;
    }
  else
    {
      image->rows-=2*page.y;
      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*
        (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+
        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Render markup.
  */
  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,
    (int) image->columns);
  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));
  if (pixel_info == (MemoryInfo *) NULL)
    {
      draw_info=DestroyDrawInfo(draw_info);
      caption=DestroyString(caption);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,
    (int) image->columns,(int) image->rows,(int) stride);
  cairo_image=cairo_create(surface);
  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);
  cairo_paint(cairo_image);
  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);
  cairo_translate(cairo_image,page.x,page.y);
  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,
    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,
    QuantumScale*draw_info->fill.alpha);
  pango_cairo_show_layout(cairo_image,layout);
  cairo_destroy(cairo_image);
  cairo_surface_destroy(surface);
  g_object_unref(layout);
  g_object_unref(fontmap);
  /*
    Convert surface to image.
  */
  (void) SetImageBackgroundColor(image,exception);
  p=pixels;
  GetPixelInfo(image,&fill_color);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *q;

    register ssize_t
      x;

    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      double
        gamma;

      fill_color.blue=(double) ScaleCharToQuantum(*p++);
      fill_color.green=(double) ScaleCharToQuantum(*p++);
      fill_color.red=(double) ScaleCharToQuantum(*p++);
      fill_color.alpha=(double) ScaleCharToQuantum(*p++);
      /*
        Disassociate alpha.
      */
      gamma=QuantumScale*fill_color.alpha;
      gamma=PerceptibleReciprocal(gamma);
      fill_color.blue*=gamma;
      fill_color.green*=gamma;
      fill_color.red*=gamma;
      CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)
        GetPixelAlpha(image,q),q);
      q+=GetPixelChannels(image);
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
        image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  /*
    Relinquish resources.
  */
  pixel_info=RelinquishVirtualMemory(pixel_info);
  draw_info=DestroyDrawInfo(draw_info);
  caption=DestroyString(caption);
  return(GetFirstImageInList(image));
}","static Image *ReadPANGOImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
  cairo_font_options_t
    *VAR_2;

  cairo_surface_t
    *VAR_3;

  char
    *VAR_4,
    *VAR_5;

  cairo_t
    *VAR_6;

  const char
    *VAR_7;

  DrawInfo
    *VAR_8;

  Image
    *VAR_9;

  MagickBooleanType
    VAR_10;

  MemoryInfo
    *VAR_11;

  PangoAlignment
    VAR_12;

  PangoContext
    *VAR_13;

  PangoFontDescription
    *VAR_14;

  PangoFontMap
    *VAR_15;

  PangoGravity
    VAR_16;

  PangoLayout
    *VAR_17;

  PangoRectangle
    VAR_18;

  PixelInfo
    VAR_19;

  RectangleInfo
    VAR_20;

  register unsigned char
    *VAR_21;

  size_t
    VAR_22;

  ssize_t
    VAR_23;

  unsigned char
    *VAR_24;

  /* COMMENT_0 */
                               
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_25);
  if (VAR_0->debug != VAR_26)
    (void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_25);
  VAR_9=AcquireImage(VAR_0,VAR_1);
  (void) ResetImagePage(VAR_9,""0x0+0+0"");
  if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
    (void) SetImageBackgroundColor(VAR_9,VAR_1);
  /* COMMENT_3 */
                   
    
  VAR_7=GetImageOption(VAR_0,""filename"");
  if (VAR_7 == (const char *) NULL)
    VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
      VAR_0->filename,VAR_1);
  else
    if (LocaleNCompare(VAR_7,""pango:"",6) == 0)
      VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7+6,
        VAR_1);
    else
      VAR_5=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7,
        VAR_1);
  if (VAR_5 != (char *) NULL)
    {
      (void) SetImageProperty(VAR_9,""caption"",VAR_5,VAR_1);
      VAR_5=DestroyString(VAR_5);
    }
  VAR_4=ConstantString(GetImageProperty(VAR_9,""caption"",VAR_1));
  /* COMMENT_6 */
                
    
  VAR_15=pango_cairo_font_map_new();
  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(VAR_15),
    VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x);
  VAR_2=cairo_font_options_create();
  VAR_7=GetImageOption(VAR_0,""pango:hinting"");
  if (VAR_7 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_7,""none"") != 0)
        cairo_font_options_set_hint_style(VAR_2,VAR_29);
      if (LocaleCompare(VAR_7,""full"") != 0)
        cairo_font_options_set_hint_style(VAR_2,VAR_30);
    }
  VAR_13=pango_font_map_create_context(VAR_15);
  pango_cairo_context_set_font_options(VAR_13,VAR_2);
  cairo_font_options_destroy(VAR_2);
  VAR_7=GetImageOption(VAR_0,""pango:language"");
  if (VAR_7 != (const char *) NULL)
    pango_context_set_language(VAR_13,pango_language_from_string(VAR_7));
  VAR_8=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
  pango_context_set_base_dir(VAR_13,VAR_8->direction ==
    VAR_31 ? VAR_32 : VAR_33);
  switch (VAR_8->gravity)
  {
    case VAR_34:
    {
      VAR_16=VAR_35;
      break;
    }
    case VAR_36:
    case VAR_37:
    case VAR_38:
    {
      VAR_16=VAR_39;
      break;
    }
    case VAR_40:
    case VAR_41:
    case VAR_42:
    {
      VAR_16=VAR_43;
      break;
    }
    case VAR_44:
    {
      VAR_16=VAR_45;
      break;
    }
    default:
    {
      VAR_16=VAR_46;
      break;
    }
  }
  pango_context_set_base_gravity(VAR_13,VAR_16);
  VAR_7=GetImageOption(VAR_0,""pango:gravity-hint"");
  if (VAR_7 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_7,""line"") == 0)
        pango_context_set_gravity_hint(VAR_13,VAR_47);
      if (LocaleCompare(VAR_7,""natural"") == 0)
        pango_context_set_gravity_hint(VAR_13,VAR_48);
      if (LocaleCompare(VAR_7,""strong"") == 0)
        pango_context_set_gravity_hint(VAR_13,VAR_49);
    }
  /* COMMENT_9 */
                     
    
  VAR_17=pango_layout_new(VAR_13);
  VAR_7=GetImageOption(VAR_0,""pango:auto-dir"");
  if (VAR_7 != (const char *) NULL)
    pango_layout_set_auto_dir(VAR_17,1);
  VAR_7=GetImageOption(VAR_0,""pango:ellipsize"");
  if (VAR_7 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_7,""end"") == 0)
        pango_layout_set_ellipsize(VAR_17,VAR_50);
      if (LocaleCompare(VAR_7,""middle"") == 0)
        pango_layout_set_ellipsize(VAR_17,VAR_51);
      if (LocaleCompare(VAR_7,""none"") == 0)
        pango_layout_set_ellipsize(VAR_17,VAR_52);
      if (LocaleCompare(VAR_7,""start"") == 0)
        pango_layout_set_ellipsize(VAR_17,VAR_53);
    }
  VAR_7=GetImageOption(VAR_0,""pango:justify"");
  if (IsStringTrue(VAR_7) != VAR_26)
    pango_layout_set_justify(VAR_17,1);
  VAR_7=GetImageOption(VAR_0,""pango:single-paragraph"");
  if (IsStringTrue(VAR_7) != VAR_26)
    pango_layout_set_single_paragraph_mode(VAR_17,1);
  VAR_7=GetImageOption(VAR_0,""pango:wrap"");
  if (VAR_7 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_7,""char"") == 0)
        pango_layout_set_wrap(VAR_17,VAR_54);
      if (LocaleCompare(VAR_7,""word"") == 0)
        pango_layout_set_wrap(VAR_17,VAR_55);
      if (LocaleCompare(VAR_7,""word-char"") == 0)
        pango_layout_set_wrap(VAR_17,VAR_56);
    }
  VAR_7=GetImageOption(VAR_0,""pango:indent"");
  if (VAR_7 != (const char *) NULL)
    pango_layout_set_indent(VAR_17,(int) ((StringToLong(VAR_7)*
      (VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x)*
      VAR_57+VAR_28/2)/VAR_28+0.5));
  switch (VAR_8->align)
  {
    case VAR_58: VAR_12=VAR_59; break;
    case VAR_60: VAR_12=VAR_61; break;
    case VAR_62: VAR_12=VAR_63; break;
    default:
    {
      if (VAR_8->gravity == VAR_64)
        {
          VAR_12=VAR_59;
          break;
        }
      VAR_12=VAR_63;
      break;
    }
  }
  if ((VAR_12 != VAR_59) &&
      (VAR_8->direction == VAR_31))
    VAR_12=(PangoAlignment) (VAR_63+VAR_61-VAR_12);
  VAR_7=GetImageOption(VAR_0,""pango:align"");
  if (VAR_7 != (const char *) NULL)
    {
      if (LocaleCompare(VAR_7,""center"") == 0)
        VAR_12=VAR_59;
      if (LocaleCompare(VAR_7,""left"") == 0)
        VAR_12=VAR_63;
      if (LocaleCompare(VAR_7,""right"") == 0)
        VAR_12=VAR_61;
    }
  pango_layout_set_alignment(VAR_17,VAR_12);
  if (VAR_8->font == (char *) NULL)
    VAR_14=pango_font_description_new();
  else
    VAR_14=pango_font_description_from_string(VAR_8->font);
  pango_font_description_set_size(VAR_14,(int) (VAR_57*
    VAR_8->pointsize+0.5));
  pango_layout_set_font_description(VAR_17,VAR_14);
  pango_font_description_free(VAR_14);
  VAR_7=GetImageOption(VAR_0,""pango:markup"");
  if ((VAR_7 != (const char *) NULL) && (IsStringTrue(VAR_7) == VAR_26))
    pango_layout_set_text(VAR_17,VAR_4,-1);
  else
    {
      GError
        *VAR_65;

      VAR_65=(GError *) NULL;
      if (pango_parse_markup(VAR_4,-1,0,NULL,NULL,NULL,&VAR_65) == 0)
        (void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_66,
          VAR_65->message,""`%s'"",VAR_0->filename);
      pango_layout_set_markup(VAR_17,VAR_4,-1);
    }
  pango_layout_context_changed(VAR_17);
  VAR_20.x=0;
  VAR_20.y=0;
  if (VAR_0->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_20);
  if (VAR_9->columns == 0)
    {
      pango_layout_get_extents(VAR_17,NULL,&VAR_18);
      VAR_9->columns=(VAR_18.x+VAR_18.width+VAR_57/2)/VAR_57+2*VAR_20.x;
    }
  else
    {
      VAR_9->columns-=2*VAR_20.x;
      pango_layout_set_width(VAR_17,(int) ((VAR_57*VAR_9->columns*
        (VAR_9->resolution.x == 0.0 ? VAR_28 : VAR_9->resolution.x)+
        VAR_28/2)/VAR_28+0.5));
    }
  if (VAR_9->rows == 0)
    {
      pango_layout_get_extents(VAR_17,NULL,&VAR_18);
      VAR_9->rows=(VAR_18.y+VAR_18.height+VAR_57/2)/VAR_57+2*VAR_20.y;
    }
  else
    {
      VAR_9->rows-=2*VAR_20.y;
      pango_layout_set_height(VAR_17,(int) ((VAR_57*VAR_9->rows*
        (VAR_9->resolution.y == 0.0 ? VAR_28 : VAR_9->resolution.y)+
        VAR_28/2)/VAR_28+0.5));
    }
  VAR_10=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
  if (VAR_10 == VAR_26)
    return(DestroyImageList(VAR_9));
  /* COMMENT_12 */
                  
    
  VAR_22=(size_t) cairo_format_stride_for_width(VAR_67,
    (int) VAR_9->columns);
  VAR_11=AcquireVirtualMemory(VAR_9->rows,VAR_22*sizeof(*VAR_24));
  if (VAR_11 == (MemoryInfo *) NULL)
    {
      VAR_8=DestroyDrawInfo(VAR_8);
      VAR_4=DestroyString(VAR_4);
      ThrowReaderException(VAR_68,""MemoryAllocationFailed"");
    }
  VAR_24=(unsigned char *) GetVirtualMemoryBlob(VAR_11);
  VAR_3=cairo_image_surface_create_for_data(VAR_24,VAR_67,
    (int) VAR_9->columns,(int) VAR_9->rows,(int) VAR_22);
  VAR_6=cairo_create(VAR_3);
  cairo_set_operator(VAR_6,VAR_69);
  cairo_paint(VAR_6);
  cairo_set_operator(VAR_6,VAR_70);
  cairo_translate(VAR_6,VAR_20.x,VAR_20.y);
  cairo_set_source_rgba(VAR_6,VAR_71*VAR_8->fill.red,
    VAR_71*VAR_8->fill.green,VAR_71*VAR_8->fill.blue,
    VAR_71*VAR_8->fill.alpha);
  pango_cairo_show_layout(VAR_6,VAR_17);
  cairo_destroy(VAR_6);
  cairo_surface_destroy(VAR_3);
  g_object_unref(VAR_17);
  g_object_unref(VAR_15);
  /* COMMENT_15 */
                             
    
  (void) SetImageBackgroundColor(VAR_9,VAR_1);
  VAR_21=VAR_24;
  GetPixelInfo(VAR_9,&VAR_19);
  for (VAR_23=0; VAR_23 < (ssize_t) VAR_9->rows; VAR_23++)
  {
    register Quantum
      *VAR_72;

    register ssize_t
      VAR_73;

    VAR_72=GetAuthenticPixels(VAR_9,0,VAR_23,VAR_9->columns,1,VAR_1);
    if (VAR_72 == (Quantum *) NULL)
      break;
    for (VAR_73=0; VAR_73 < (ssize_t) VAR_9->columns; VAR_73++)
    {
      double
        VAR_74;

      VAR_19.blue=(double) ScaleCharToQuantum(*VAR_21++);
      VAR_19.green=(double) ScaleCharToQuantum(*VAR_21++);
      VAR_19.red=(double) ScaleCharToQuantum(*VAR_21++);
      VAR_19.alpha=(double) ScaleCharToQuantum(*VAR_21++);
      /* COMMENT_18 */
                           
        
      VAR_74=VAR_71*VAR_19.alpha;
      VAR_74=PerceptibleReciprocal(VAR_74);
      VAR_19.blue*=VAR_74;
      VAR_19.green*=VAR_74;
      VAR_19.red*=VAR_74;
      CompositePixelOver(VAR_9,&VAR_19,VAR_19.alpha,VAR_72,(double)
        GetPixelAlpha(VAR_9,VAR_72),VAR_72);
      VAR_72+=GetPixelChannels(VAR_9);
    }
    if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_26)
      break;
    if (VAR_9->previous == (Image *) NULL)
      {
        VAR_10=SetImageProgress(VAR_9,VAR_75,(MagickOffsetType) VAR_23,
        VAR_9->rows);
        if (VAR_10 == VAR_26)
          break;
      }
  }
  /* COMMENT_21 */
                         
    
  VAR_11=RelinquishVirtualMemory(VAR_11);
  VAR_8=DestroyDrawInfo(VAR_8);
  VAR_4=DestroyString(VAR_4);
  return(GetFirstImageInList(VAR_9));
}",ImageMagick/b4dd4d266f2d450a2996abf5294671d888991132/pango.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -96,8 +96,11 @@
     else
       property=InterpretImageProperties((ImageInfo *) image_info,image,option,
         exception);
-  (void) SetImageProperty(image,""caption"",property,exception);
-  property=DestroyString(property);
+  if (property != (char *) NULL)
+    {
+      (void) SetImageProperty(image,""caption"",property,exception);
+      property=DestroyString(property);
+    }
   caption=ConstantString(GetImageProperty(image,""caption"",exception));
   /*
     Get context.","{'deleted_lines': ['  (void) SetImageProperty(image,""caption"",property,exception);', '  property=DestroyString(property);'], 'added_lines': ['  if (property != (char *) NULL)', '    {', '      (void) SetImageProperty(image,""caption"",property,exception);', '      property=DestroyString(property);', '    }']}",True,A NULL pointer dereference in the function ReadPANGOImage in coders/pango.c and the function ReadVIDImage in coders/vid.c in ImageMagick 7.0.8-34 allows remote attackers to cause a denial of service via a crafted image.,5.5,MEDIUM,1,valid,2019-03-23T20:18:39Z,2
CVE-2019-12974,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1515,b4dd4d266f2d450a2996abf5294671d888991132,https://github.com/ImageMagick/ImageMagick/commit/b4dd4d266f2d450a2996abf5294671d888991132,coders/vid.c,ReadVIDImage,"static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define ClientName  ""montage""
char
**filelist,
*label,
**list;
Image
*image,
*images,
*montage_image,
*next_image,
*thumbnail_image;
ImageInfo
*read_info;
int
number_files;
MagickBooleanType
status;
MontageInfo
*montage_info;
RectangleInfo
geometry;
register ssize_t
i;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
list=(char **) AcquireMagickMemory(sizeof(*filelist));
if (list == (char **) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
list[0]=ConstantString(image_info->filename);
filelist=list;
number_files=1;
status=ExpandFilenames(&number_files,&filelist);
list[0]=DestroyString(list[0]);
list=(char **) RelinquishMagickMemory(list);
if ((status == MagickFalse) || (number_files == 0))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
image=DestroyImage(image);
images=NewImageList();
read_info=CloneImageInfo(image_info);
SetImageInfoBlob(read_info,(void *) NULL,0);
(void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
(void *) NULL);
if (read_info->size == (char *) NULL)
(void) CloneString(&read_info->size,DefaultTileGeometry);
for (i=0; i < (ssize_t) number_files; i++)
{
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""name: %s"",
filelist[i]);
(void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);
filelist[i]=DestroyString(filelist[i]);
*read_info->magick='\0';
next_image=ReadImage(read_info,exception);
CatchException(exception);
if (next_image == (Image *) NULL)
break;
label=InterpretImageProperties((ImageInfo *) image_info,next_image,
DefaultTileLabel,exception);
(void) SetImageProperty(next_image,""label"",label,exception);
label=DestroyString(label);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""geometry: %.20gx%.20g"",(double) next_image->columns,(double)
next_image->rows);
SetGeometry(next_image,&geometry);
(void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,
&geometry.width,&geometry.height);
thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,
exception);
if (thumbnail_image != (Image *) NULL)
{
next_image=DestroyImage(next_image);
next_image=thumbnail_image;
}
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""thumbnail geometry: %.20gx%.20g"",(double) next_image->columns,(double)
next_image->rows);
AppendImageToList(&images,next_image);
status=SetImageProgress(images,LoadImagesTag,i,number_files);
if (status == MagickFalse)
break;
}
read_info=DestroyImageInfo(read_info);
filelist=(char **) RelinquishMagickMemory(filelist);
if (images == (Image *) NULL)
ThrowReaderException(CorruptImageError,
""ImageFileDoesNotContainAnyImageData"");
montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""creating montage"");
montage_image=MontageImageList(image_info,montage_info,
GetFirstImageInList(images),exception);
montage_info=DestroyMontageInfo(montage_info);
images=DestroyImageList(images);
return(montage_image);
}","static Image *ReadVIDImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""montage""
char
**VAR_3,
*VAR_4,
**VAR_5;
Image
*VAR_6,
*VAR_7,
*VAR_8,
*VAR_9,
*VAR_10;
ImageInfo
*VAR_11;
int
VAR_12;
MagickBooleanType
VAR_13;
MontageInfo
*VAR_14;
RectangleInfo
VAR_15;
register ssize_t
VAR_16;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
VAR_6=AcquireImage(VAR_0,VAR_1);
VAR_5=(char **) AcquireMagickMemory(sizeof(*VAR_3));
if (VAR_5 == (char **) NULL)
ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
VAR_5[0]=ConstantString(VAR_0->filename);
VAR_3=VAR_5;
VAR_12=1;
VAR_13=ExpandFilenames(&VAR_12,&VAR_3);
VAR_5[0]=DestroyString(VAR_5[0]);
VAR_5=(char **) RelinquishMagickMemory(VAR_5);
if ((VAR_13 == VAR_18) || (VAR_12 == 0))
ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
VAR_6=DestroyImage(VAR_6);
VAR_7=NewImageList();
VAR_11=CloneImageInfo(VAR_0);
SetImageInfoBlob(VAR_11,(void *) NULL,0);
(void) SetImageInfoProgressMonitor(VAR_11,(MagickProgressMonitor) NULL,
(void *) NULL);
if (VAR_11->size == (char *) NULL)
(void) CloneString(&VAR_11->size,VAR_21);
for (VAR_16=0; VAR_16 < (ssize_t) VAR_12; VAR_16++)
{
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_22,GetMagickModule(),""name: %s"",
VAR_3[VAR_16]);
(void) CopyMagickString(VAR_11->filename,VAR_3[VAR_16],VAR_23);
VAR_3[VAR_16]=DestroyString(VAR_3[VAR_16]);
*VAR_11->magick='\0';
VAR_9=ReadImage(VAR_11,VAR_1);
CatchException(VAR_1);
if (VAR_9 == (Image *) NULL)
break;
VAR_4=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
VAR_24,VAR_1);
(void) SetImageProperty(VAR_9,""label"",VAR_4,VAR_1);
VAR_4=DestroyString(VAR_4);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_22,GetMagickModule(),
""geometry: %.20gx%.20g"",(double) VAR_9->columns,(double)
VAR_9->rows);
SetGeometry(VAR_9,&VAR_15);
(void) ParseMetaGeometry(VAR_11->size,&VAR_15.x,&VAR_15.y,
&VAR_15.width,&VAR_15.height);
VAR_10=ThumbnailImage(VAR_9,VAR_15.width,VAR_15.height,
VAR_1);
if (VAR_10 != (Image *) NULL)
{
VAR_9=DestroyImage(VAR_9);
VAR_9=VAR_10;
}
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_22,GetMagickModule(),
""thumbnail geometry: %.20gx%.20g"",(double) VAR_9->columns,(double)
VAR_9->rows);
AppendImageToList(&VAR_7,VAR_9);
VAR_13=SetImageProgress(VAR_7,VAR_25,VAR_16,VAR_12);
if (VAR_13 == VAR_18)
break;
}
VAR_11=DestroyImageInfo(VAR_11);
VAR_3=(char **) RelinquishMagickMemory(VAR_3);
if (VAR_7 == (Image *) NULL)
ThrowReaderException(VAR_26,
""ImageFileDoesNotContainAnyImageData"");
VAR_14=CloneMontageInfo(VAR_0,(MontageInfo *) NULL);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_22,GetMagickModule(),""creating montage"");
VAR_8=MontageImageList(VAR_0,VAR_14,
GetFirstImageInList(VAR_7),VAR_1);
VAR_14=DestroyMontageInfo(VAR_14);
VAR_7=DestroyImageList(VAR_7);
return(VAR_8);
}",ImageMagick/b4dd4d266f2d450a2996abf5294671d888991132/vid.c/vul/before/0.json,"static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define ClientName  ""montage""

  char
    **filelist,
    *label,
    **list;

  Image
    *image,
    *images,
    *montage_image,
    *next_image,
    *thumbnail_image;

  ImageInfo
    *read_info;

  int
    number_files;

  MagickBooleanType
    status;

  MontageInfo
    *montage_info;

  RectangleInfo
    geometry;

  register ssize_t
    i;

  /*
    Expand the filename.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  list=(char **) AcquireMagickMemory(sizeof(*filelist));
  if (list == (char **) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  list[0]=ConstantString(image_info->filename);
  filelist=list;
  number_files=1;
  status=ExpandFilenames(&number_files,&filelist);
  list[0]=DestroyString(list[0]);
  list=(char **) RelinquishMagickMemory(list);
  if ((status == MagickFalse) || (number_files == 0))
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  image=DestroyImage(image);
  /*
    Read each image and convert them to a tile.
  */
  images=NewImageList();
  read_info=CloneImageInfo(image_info);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  if (read_info->size == (char *) NULL)
    (void) CloneString(&read_info->size,DefaultTileGeometry);
  for (i=0; i < (ssize_t) number_files; i++)
  {
    if (image_info->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""name: %s"",
        filelist[i]);
    (void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);
    filelist[i]=DestroyString(filelist[i]);
    *read_info->magick='\0';
    next_image=ReadImage(read_info,exception);
    CatchException(exception);
    if (next_image == (Image *) NULL)
      break;
    label=InterpretImageProperties((ImageInfo *) image_info,next_image,
      DefaultTileLabel,exception);
    if (label != (char *) NULL)
      {
        (void) SetImageProperty(next_image,""label"",label,exception);
        label=DestroyString(label);
      }
    if (image_info->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""geometry: %.20gx%.20g"",(double) next_image->columns,(double)
        next_image->rows);
    SetGeometry(next_image,&geometry);
    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,
      &geometry.width,&geometry.height);
    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,
      exception);
    if (thumbnail_image != (Image *) NULL)
      {
        next_image=DestroyImage(next_image);
        next_image=thumbnail_image;
      }
    if (image_info->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""thumbnail geometry: %.20gx%.20g"",(double) next_image->columns,(double)
        next_image->rows);
    AppendImageToList(&images,next_image);
    status=SetImageProgress(images,LoadImagesTag,i,number_files);
    if (status == MagickFalse)
      break;
  }
  read_info=DestroyImageInfo(read_info);
  filelist=(char **) RelinquishMagickMemory(filelist);
  if (images == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      ""ImageFileDoesNotContainAnyImageData"");
  /*
    Create the visual image directory.
  */
  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""creating montage"");
  montage_image=MontageImageList(image_info,montage_info,
    GetFirstImageInList(images),exception);
  montage_info=DestroyMontageInfo(montage_info);
  images=DestroyImageList(images);
  return(montage_image);
}","static Image *ReadVIDImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""montage""

  char
    **VAR_3,
    *VAR_4,
    **VAR_5;

  Image
    *VAR_6,
    *VAR_7,
    *VAR_8,
    *VAR_9,
    *VAR_10;

  ImageInfo
    *VAR_11;

  int
    VAR_12;

  MagickBooleanType
    VAR_13;

  MontageInfo
    *VAR_14;

  RectangleInfo
    VAR_15;

  register ssize_t
    VAR_16;

  /* COMMENT_0 */
                        
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  VAR_6=AcquireImage(VAR_0,VAR_1);
  VAR_5=(char **) AcquireMagickMemory(sizeof(*VAR_3));
  if (VAR_5 == (char **) NULL)
    ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
  VAR_5[0]=ConstantString(VAR_0->filename);
  VAR_3=VAR_5;
  VAR_12=1;
  VAR_13=ExpandFilenames(&VAR_12,&VAR_3);
  VAR_5[0]=DestroyString(VAR_5[0]);
  VAR_5=(char **) RelinquishMagickMemory(VAR_5);
  if ((VAR_13 == VAR_18) || (VAR_12 == 0))
    ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
  VAR_6=DestroyImage(VAR_6);
  /* COMMENT_3 */
                                               
    
  VAR_7=NewImageList();
  VAR_11=CloneImageInfo(VAR_0);
  SetImageInfoBlob(VAR_11,(void *) NULL,0);
  (void) SetImageInfoProgressMonitor(VAR_11,(MagickProgressMonitor) NULL,
    (void *) NULL);
  if (VAR_11->size == (char *) NULL)
    (void) CloneString(&VAR_11->size,VAR_21);
  for (VAR_16=0; VAR_16 < (ssize_t) VAR_12; VAR_16++)
  {
    if (VAR_0->debug != VAR_18)
      (void) LogMagickEvent(VAR_22,GetMagickModule(),""name: %s"",
        VAR_3[VAR_16]);
    (void) CopyMagickString(VAR_11->filename,VAR_3[VAR_16],VAR_23);
    VAR_3[VAR_16]=DestroyString(VAR_3[VAR_16]);
    *VAR_11->magick='\0';
    VAR_9=ReadImage(VAR_11,VAR_1);
    CatchException(VAR_1);
    if (VAR_9 == (Image *) NULL)
      break;
    VAR_4=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
      VAR_24,VAR_1);
    if (VAR_4 != (char *) NULL)
      {
        (void) SetImageProperty(VAR_9,""label"",VAR_4,VAR_1);
        VAR_4=DestroyString(VAR_4);
      }
    if (VAR_0->debug != VAR_18)
      (void) LogMagickEvent(VAR_22,GetMagickModule(),
        ""geometry: %.20gx%.20g"",(double) VAR_9->columns,(double)
        VAR_9->rows);
    SetGeometry(VAR_9,&VAR_15);
    (void) ParseMetaGeometry(VAR_11->size,&VAR_15.x,&VAR_15.y,
      &VAR_15.width,&VAR_15.height);
    VAR_10=ThumbnailImage(VAR_9,VAR_15.width,VAR_15.height,
      VAR_1);
    if (VAR_10 != (Image *) NULL)
      {
        VAR_9=DestroyImage(VAR_9);
        VAR_9=VAR_10;
      }
    if (VAR_0->debug != VAR_18)
      (void) LogMagickEvent(VAR_22,GetMagickModule(),
        ""thumbnail geometry: %.20gx%.20g"",(double) VAR_9->columns,(double)
        VAR_9->rows);
    AppendImageToList(&VAR_7,VAR_9);
    VAR_13=SetImageProgress(VAR_7,VAR_25,VAR_16,VAR_12);
    if (VAR_13 == VAR_18)
      break;
  }
  VAR_11=DestroyImageInfo(VAR_11);
  VAR_3=(char **) RelinquishMagickMemory(VAR_3);
  if (VAR_7 == (Image *) NULL)
    ThrowReaderException(VAR_26,
      ""ImageFileDoesNotContainAnyImageData"");
  /* COMMENT_6 */
                                      
    
  VAR_14=CloneMontageInfo(VAR_0,(MontageInfo *) NULL);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_22,GetMagickModule(),""creating montage"");
  VAR_8=MontageImageList(VAR_0,VAR_14,
    GetFirstImageInList(VAR_7),VAR_1);
  VAR_14=DestroyMontageInfo(VAR_14);
  VAR_7=DestroyImageList(VAR_7);
  return(VAR_8);
}",ImageMagick/b4dd4d266f2d450a2996abf5294671d888991132/vid.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -79,8 +79,11 @@
       break;
     label=InterpretImageProperties((ImageInfo *) image_info,next_image,
       DefaultTileLabel,exception);
-    (void) SetImageProperty(next_image,""label"",label,exception);
-    label=DestroyString(label);
+    if (label != (char *) NULL)
+      {
+        (void) SetImageProperty(next_image,""label"",label,exception);
+        label=DestroyString(label);
+      }
     if (image_info->debug != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""geometry: %.20gx%.20g"",(double) next_image->columns,(double)","{'deleted_lines': ['    (void) SetImageProperty(next_image,""label"",label,exception);', '    label=DestroyString(label);'], 'added_lines': ['    if (label != (char *) NULL)', '      {', '        (void) SetImageProperty(next_image,""label"",label,exception);', '        label=DestroyString(label);', '      }']}",True,A NULL pointer dereference in the function ReadPANGOImage in coders/pango.c and the function ReadVIDImage in coders/vid.c in ImageMagick 7.0.8-34 allows remote attackers to cause a denial of service via a crafted image.,5.5,MEDIUM,1,valid,2019-03-23T20:18:39Z,2
CVE-2019-10894,['CWE-617'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"GSS-API: Make sure we call a valid dissector.

Make our unknown dissector handle logic conistent with other parts of
the code.

Conflicts:
	epan/dissectors/packet-gssapi.c

Bug: 15613
Change-Id: Id0daf9bf0be14b99ec592f4f561cc8935d5cb4a6
Reviewed-on: https://code.wireshark.org/review/32576
Reviewed-by: Gerald Combs <gerald@wireshark.org>
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Dario Lombardo <lomato@gmail.com>
(cherry picked from commit 8cdc95842687feee32856afba8e7087396082158)
Reviewed-on: https://code.wireshark.org/review/32586
(cherry picked from commit ea75daa28bd6bd6911fd14a8b1734004269a18b8)
Reviewed-on: https://code.wireshark.org/review/32588",b20e5d8aae2580e29c83ddaf0b6b2e640603e4aa,https://github.com/wireshark/wireshark/commit/b20e5d8aae2580e29c83ddaf0b6b2e640603e4aa,epan/dissectors/packet-gssapi.c,dissect_gssapi_work,"static int
dissect_gssapi_work(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
gboolean is_verifier, gssapi_encrypt_info_t* encrypt_info)
{
proto_item *volatile item;
proto_tree *volatile subtree;
volatile int return_offset = 0;
gssapi_conv_info_t *volatile gss_info;
gssapi_oid_value *oidvalue;
dissector_handle_t handle;
conversation_t *conversation;
tvbuff_t *oid_tvb;
int len, start_offset, oid_start_offset;
volatile int offset;
gint8 appclass;
gboolean pc, ind_field;
gint32 tag;
guint32 len1;
const char *oid;
fragment_head *fd_head=NULL;
gssapi_frag_info_t *fi;
tvbuff_t *volatile gss_tvb=NULL;
asn1_ctx_t asn1_ctx;
start_offset=0;
offset=0;
asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);
encrypt_info->gssapi_data_encrypted = FALSE;
conversation = find_or_create_conversation(pinfo);
gss_info = (gssapi_conv_info_t *)conversation_get_proto_data(conversation, proto_gssapi);
if (!gss_info) {
gss_info = wmem_new(wmem_file_scope(), gssapi_conv_info_t);
gss_info->oid=NULL;
gss_info->do_reassembly=FALSE;
gss_info->frags=wmem_tree_new(wmem_file_scope());
conversation_add_proto_data(conversation, proto_gssapi, gss_info);
}
item = proto_tree_add_item(
tree, proto_gssapi, tvb, offset, -1, ENC_NA);
subtree = proto_item_add_subtree(item, ett_gssapi);
TRY {
gss_tvb=tvb;
if( (!pinfo->fd->flags.visited)
&&  (gss_info->do_reassembly)
&&  (gssapi_reassembly) ){
fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, gss_info->first_frame);
if(!fi){
goto done;
}
wmem_tree_insert32(gss_info->frags, pinfo->num, fi);
fd_head=fragment_add(&gssapi_reassembly_table,
tvb, 0, pinfo, fi->first_frame, NULL,
gss_info->frag_offset,
tvb_captured_length(tvb), TRUE);
gss_info->frag_offset+=tvb_captured_length(tvb);
if(!fd_head){
goto done;
}
gss_info->do_reassembly=FALSE;
fi->reassembled_in=pinfo->num;
gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);
add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI"");
}
if( (pinfo->fd->flags.visited)
&&  (gssapi_reassembly) ){
fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, pinfo->num);
if(fi){
fd_head=fragment_get(&gssapi_reassembly_table,
pinfo, fi->first_frame, NULL);
if(fd_head && (fd_head->flags&FD_DEFRAGMENTED)){
if(pinfo->num==fi->reassembled_in){
proto_item *frag_tree_item;
gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);
add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI"");
show_fragment_tree(fd_head, &gssapi_frag_items, tree, pinfo, tvb, &frag_tree_item);
} else {
proto_item *it;
it=proto_tree_add_uint(tree, hf_gssapi_reassembled_in, tvb, 0, 0, fi->reassembled_in);
PROTO_ITEM_SET_GENERATED(it);
goto done;
}
}
}
}
offset = get_ber_identifier(gss_tvb, offset, &appclass, &pc, &tag);
offset = get_ber_length(gss_tvb, offset, &len1, &ind_field);
if (!(appclass == BER_CLASS_APP && pc && tag == 0)) {
if ((tvb_captured_length_remaining(gss_tvb, start_offset)>7) && (tvb_strneql(gss_tvb, start_offset, ""NTLMSSP"", 7) == 0)) {
return_offset = call_dissector(ntlmssp_handle,
tvb_new_subset_remaining(gss_tvb, start_offset),
pinfo, subtree);
goto done;
}
if ((tvb_captured_length_remaining(gss_tvb, start_offset)>16) &&
((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) {
return_offset = call_dissector(ntlmssp_payload_handle,
tvb_new_subset_remaining(gss_tvb, start_offset),
pinfo, subtree);
encrypt_info->gssapi_data_encrypted = TRUE;
goto done;
}
if ((tvb_captured_length_remaining(gss_tvb, start_offset)==16) &&
((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) {
if( is_verifier ) {
return_offset = call_dissector(ntlmssp_verf_handle,
tvb_new_subset_remaining(gss_tvb, start_offset),
pinfo, subtree);
}
else if( encrypt_info->gssapi_encrypted_tvb ) {
return_offset = call_dissector_with_data(ntlmssp_data_only_handle,
tvb_new_subset_remaining(encrypt_info->gssapi_encrypted_tvb, 0),
pinfo, subtree, &encrypt_info->gssapi_decrypted_tvb);
encrypt_info->gssapi_data_encrypted = TRUE;
}
goto done;
}
if ((tvb_captured_length_remaining(gss_tvb, start_offset)>2) &&
((tvb_memeql(gss_tvb, start_offset, ""\04\x04"", 2) == 0) ||
(tvb_memeql(gss_tvb, start_offset, ""\05\x04"", 2) == 0))) {
return_offset = call_dissector_with_data(spnego_krb5_wrap_handle,
tvb_new_subset_remaining(gss_tvb, start_offset),
pinfo, subtree, encrypt_info);
goto done;
}
oidvalue = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0);
if (!oidvalue && !pinfo->fd->flags.visited)
{
oidvalue = gss_info->oid;
if (gss_info->oid)
p_add_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0, gss_info->oid);
}
if (!oidvalue)
{
proto_tree_add_expert_format(subtree, pinfo, &ei_gssapi_unknown_header, gss_tvb, start_offset, 0,
""Unknown header (class=%d, pc=%d, tag=%d)"",
appclass, pc, tag);
return_offset = tvb_captured_length(gss_tvb);
goto done;
} else {
tvbuff_t *oid_tvb_local;
oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
if (is_verifier)
handle = oidvalue->wrap_handle;
else
handle = oidvalue->handle;
len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
if (len == 0)
return_offset = tvb_captured_length(gss_tvb);
else
return_offset = start_offset + len;
goto done; 
}
}
oid_start_offset=offset;
offset=dissect_ber_object_identifier_str(FALSE, &asn1_ctx, subtree, gss_tvb, offset, hf_gssapi_oid, &oid);
oidvalue = gssapi_lookup_oid_str(oid);
if( (!pinfo->fd->flags.visited)
&&  (oidvalue)
&&  (tvb_captured_length(gss_tvb)==tvb_reported_length(gss_tvb))
&&  (len1>(guint32)tvb_captured_length_remaining(gss_tvb, oid_start_offset))
&&  (gssapi_reassembly) ){
fi=wmem_new(wmem_file_scope(), gssapi_frag_info_t);
fi->first_frame=pinfo->num;
fi->reassembled_in=0;
wmem_tree_insert32(gss_info->frags, pinfo->num, fi);
fragment_add(&gssapi_reassembly_table,
gss_tvb, 0, pinfo, pinfo->num, NULL,
0, tvb_captured_length(gss_tvb), TRUE);
fragment_set_tot_len(&gssapi_reassembly_table,
pinfo, pinfo->num, NULL, len1+oid_start_offset);
gss_info->do_reassembly=TRUE;
gss_info->first_frame=pinfo->num;
gss_info->frag_offset=tvb_captured_length(gss_tvb);
goto done;
}
if ((oidvalue == NULL) ||
!proto_is_protocol_enabled(oidvalue->proto)) {
proto_tree_add_item(subtree, hf_gssapi_token_object, gss_tvb, oid_start_offset, -1, ENC_NA);
return_offset = tvb_captured_length(gss_tvb);
goto done;
}
if(!gss_info->oid){
gss_info->oid=oidvalue;
}
if (is_verifier) {
handle = oidvalue->wrap_handle;
if (handle != NULL) {
oid_tvb = tvb_new_subset_remaining(gss_tvb, offset);
len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);
if (len == 0)
return_offset = tvb_captured_length(gss_tvb);
else
return_offset = offset + len;
} else {
proto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);
return_offset = tvb_captured_length(gss_tvb);
}
} else {
handle = oidvalue->handle;
if (handle != NULL) {
oid_tvb = tvb_new_subset_remaining(gss_tvb, offset);
len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);
if (len == 0)
return_offset = tvb_captured_length(gss_tvb);
else
return_offset = offset + len;
} else {
proto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);
return_offset = tvb_captured_length(gss_tvb);
}
}
done:
;
}","static int
dissect_gssapi_work(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
gboolean VAR_3, gssapi_encrypt_info_t* VAR_4)
{
proto_item *volatile VAR_5;
proto_tree *volatile VAR_6;
volatile int VAR_7 = 0;
gssapi_conv_info_t *volatile VAR_8;
gssapi_oid_value *VAR_9;
dissector_handle_t VAR_10;
conversation_t *VAR_11;
tvbuff_t *VAR_12;
int VAR_13, VAR_14, VAR_15;
volatile int VAR_16;
gint8 VAR_17;
gboolean VAR_18, VAR_19;
gint32 VAR_20;
guint32 VAR_21;
const char *VAR_22;
fragment_head *VAR_23=NULL;
gssapi_frag_info_t *VAR_24;
tvbuff_t *volatile VAR_25=NULL;
asn1_ctx_t VAR_26;
VAR_14=0;
VAR_16=0;
asn1_ctx_init(&VAR_26, VAR_27, TRUE, VAR_1);
VAR_4->gssapi_data_encrypted = FALSE;
VAR_11 = find_or_create_conversation(VAR_1);
VAR_8 = (gssapi_conv_info_t *)conversation_get_proto_data(VAR_11, VAR_28);
if (!VAR_8) {
VAR_8 = wmem_new(wmem_file_scope(), gssapi_conv_info_t);
VAR_8->oid=NULL;
VAR_8->do_reassembly=FALSE;
VAR_8->frags=wmem_tree_new(wmem_file_scope());
conversation_add_proto_data(VAR_11, VAR_28, VAR_8);
}
VAR_5 = proto_tree_add_item(
VAR_2, VAR_28, VAR_0, VAR_16, -1, VAR_29);
VAR_6 = proto_item_add_subtree(VAR_5, VAR_30);
TRY {
VAR_25=VAR_0;
if( (!VAR_1->fd->flags.visited)
&&  (VAR_8->do_reassembly)
&&  (VAR_31) ){
VAR_24=(gssapi_frag_info_t *)wmem_tree_lookup32(VAR_8->frags, VAR_8->first_frame);
if(!VAR_24){
goto done;
}
wmem_tree_insert32(VAR_8->frags, VAR_1->num, VAR_24);
VAR_23=fragment_add(&VAR_32,
VAR_0, 0, VAR_1, VAR_24->first_frame, NULL,
VAR_8->frag_offset,
tvb_captured_length(VAR_0), TRUE);
VAR_8->frag_offset+=tvb_captured_length(VAR_0);
if(!VAR_23){
goto done;
}
VAR_8->do_reassembly=FALSE;
VAR_24->reassembled_in=VAR_1->num;
VAR_25=tvb_new_chain(VAR_0, VAR_23->tvb_data);
add_new_data_source(VAR_1, VAR_25, ""Reassembled GSSAPI"");
}
if( (VAR_1->fd->flags.visited)
&&  (VAR_31) ){
VAR_24=(gssapi_frag_info_t *)wmem_tree_lookup32(VAR_8->frags, VAR_1->num);
if(VAR_24){
VAR_23=fragment_get(&VAR_32,
VAR_1, VAR_24->first_frame, NULL);
if(VAR_23 && (VAR_23->flags&VAR_33)){
if(VAR_1->num==VAR_24->reassembled_in){
proto_item *VAR_34;
VAR_25=tvb_new_chain(VAR_0, VAR_23->tvb_data);
add_new_data_source(VAR_1, VAR_25, ""Reassembled GSSAPI"");
show_fragment_tree(VAR_23, &VAR_35, VAR_2, VAR_1, VAR_0, &VAR_34);
} else {
proto_item *VAR_36;
VAR_36=proto_tree_add_uint(VAR_2, VAR_37, VAR_0, 0, 0, VAR_24->reassembled_in);
PROTO_ITEM_SET_GENERATED(VAR_36);
goto done;
}
}
}
}
VAR_16 = get_ber_identifier(VAR_25, VAR_16, &VAR_17, &VAR_18, &VAR_20);
VAR_16 = get_ber_length(VAR_25, VAR_16, &VAR_21, &VAR_19);
if (!(VAR_17 == VAR_38 && VAR_18 && VAR_20 == 0)) {
if ((tvb_captured_length_remaining(VAR_25, VAR_14)>7) && (tvb_strneql(VAR_25, VAR_14, ""NTLMSSP"", 7) == 0)) {
VAR_7 = call_dissector(VAR_39,
tvb_new_subset_remaining(VAR_25, VAR_14),
VAR_1, VAR_6);
goto done;
}
if ((tvb_captured_length_remaining(VAR_25, VAR_14)>16) &&
((tvb_memeql(VAR_25, VAR_14, ""\x01\x00\x00\x00"", 4) == 0))) {
VAR_7 = call_dissector(VAR_40,
tvb_new_subset_remaining(VAR_25, VAR_14),
VAR_1, VAR_6);
VAR_4->gssapi_data_encrypted = TRUE;
goto done;
}
if ((tvb_captured_length_remaining(VAR_25, VAR_14)==16) &&
((tvb_memeql(VAR_25, VAR_14, ""\x01\x00\x00\x00"", 4) == 0))) {
if( VAR_3 ) {
VAR_7 = call_dissector(VAR_41,
tvb_new_subset_remaining(VAR_25, VAR_14),
VAR_1, VAR_6);
}
else if( VAR_4->gssapi_encrypted_tvb ) {
VAR_7 = call_dissector_with_data(VAR_42,
tvb_new_subset_remaining(VAR_4->gssapi_encrypted_tvb, 0),
VAR_1, VAR_6, &VAR_4->gssapi_decrypted_tvb);
VAR_4->gssapi_data_encrypted = TRUE;
}
goto done;
}
if ((tvb_captured_length_remaining(VAR_25, VAR_14)>2) &&
((tvb_memeql(VAR_25, VAR_14, ""\04\x04"", 2) == 0) ||
(tvb_memeql(VAR_25, VAR_14, ""\05\x04"", 2) == 0))) {
VAR_7 = call_dissector_with_data(VAR_43,
tvb_new_subset_remaining(VAR_25, VAR_14),
VAR_1, VAR_6, VAR_4);
goto done;
}
VAR_9 = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), VAR_1, VAR_28, 0);
if (!VAR_9 && !VAR_1->fd->flags.visited)
{
VAR_9 = VAR_8->oid;
if (VAR_8->oid)
p_add_proto_data(wmem_file_scope(), VAR_1, VAR_28, 0, VAR_8->oid);
}
if (!VAR_9)
{
proto_tree_add_expert_format(VAR_6, VAR_1, &VAR_44, VAR_25, VAR_14, 0,
""Unknown header (class=%d, pc=%d, tag=%d)"",
VAR_17, VAR_18, VAR_20);
VAR_7 = tvb_captured_length(VAR_25);
goto done;
} else {
tvbuff_t *VAR_45;
VAR_45 = tvb_new_subset_remaining(VAR_25, VAR_14);
if (VAR_3)
VAR_10 = VAR_9->wrap_handle;
else
VAR_10 = VAR_9->handle;
VAR_13 = call_dissector_with_data(VAR_10, VAR_45, VAR_1, VAR_6, VAR_4);
if (VAR_13 == 0)
VAR_7 = tvb_captured_length(VAR_25);
else
VAR_7 = VAR_14 + VAR_13;
goto done; 
}
}
VAR_15=VAR_16;
VAR_16=dissect_ber_object_identifier_str(FALSE, &VAR_26, VAR_6, VAR_25, VAR_16, VAR_46, &VAR_22);
VAR_9 = gssapi_lookup_oid_str(VAR_22);
if( (!VAR_1->fd->flags.visited)
&&  (VAR_9)
&&  (tvb_captured_length(VAR_25)==tvb_reported_length(VAR_25))
&&  (VAR_21>(guint32)tvb_captured_length_remaining(VAR_25, VAR_15))
&&  (VAR_31) ){
VAR_24=wmem_new(wmem_file_scope(), gssapi_frag_info_t);
VAR_24->first_frame=VAR_1->num;
VAR_24->reassembled_in=0;
wmem_tree_insert32(VAR_8->frags, VAR_1->num, VAR_24);
fragment_add(&VAR_32,
VAR_25, 0, VAR_1, VAR_1->num, NULL,
0, tvb_captured_length(VAR_25), TRUE);
fragment_set_tot_len(&VAR_32,
VAR_1, VAR_1->num, NULL, VAR_21+VAR_15);
VAR_8->do_reassembly=TRUE;
VAR_8->first_frame=VAR_1->num;
VAR_8->frag_offset=tvb_captured_length(VAR_25);
goto done;
}
if ((VAR_9 == NULL) ||
!proto_is_protocol_enabled(VAR_9->proto)) {
proto_tree_add_item(VAR_6, VAR_47, VAR_25, VAR_15, -1, VAR_29);
VAR_7 = tvb_captured_length(VAR_25);
goto done;
}
if(!VAR_8->oid){
VAR_8->oid=VAR_9;
}
if (VAR_3) {
VAR_10 = VAR_9->wrap_handle;
if (VAR_10 != NULL) {
VAR_12 = tvb_new_subset_remaining(VAR_25, VAR_16);
VAR_13 = call_dissector_with_data(VAR_10, VAR_12, VAR_1, VAR_6, VAR_4);
if (VAR_13 == 0)
VAR_7 = tvb_captured_length(VAR_25);
else
VAR_7 = VAR_16 + VAR_13;
} else {
proto_tree_add_item(VAR_6, VAR_48, VAR_25, VAR_16, -1, VAR_29);
VAR_7 = tvb_captured_length(VAR_25);
}
} else {
VAR_10 = VAR_9->handle;
if (VAR_10 != NULL) {
VAR_12 = tvb_new_subset_remaining(VAR_25, VAR_16);
VAR_13 = call_dissector_with_data(VAR_10, VAR_12, VAR_1, VAR_6, VAR_4);
if (VAR_13 == 0)
VAR_7 = tvb_captured_length(VAR_25);
else
VAR_7 = VAR_16 + VAR_13;
} else {
proto_tree_add_item(VAR_6, VAR_49, VAR_25, VAR_16, -1, VAR_29);
VAR_7 = tvb_captured_length(VAR_25);
}
}
done:
;
}",,"static int
dissect_gssapi_work(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
		    gboolean is_verifier, gssapi_encrypt_info_t* encrypt_info)
{
	proto_item *volatile item;
	proto_tree *volatile subtree;
	volatile int return_offset = 0;
	gssapi_conv_info_t *volatile gss_info;
	gssapi_oid_value *oidvalue;
	dissector_handle_t handle;
	conversation_t *conversation;
	tvbuff_t *oid_tvb;
	int len, start_offset, oid_start_offset;
	volatile int offset;
	gint8 appclass;
	gboolean pc, ind_field;
	gint32 tag;
	guint32 len1;
	const char *oid;
	fragment_head *fd_head=NULL;
	gssapi_frag_info_t *fi;
	tvbuff_t *volatile gss_tvb=NULL;
	asn1_ctx_t asn1_ctx;

	start_offset=0;
	offset=0;
	asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);
	/*
	 * We don't know whether the data is encrypted, so say it's
	 * not, for now.  The subdissector must set gssapi_data_encrypted
	 * if it is.
	 */
	encrypt_info->gssapi_data_encrypted = FALSE;


	/*
	 * We need a conversation for later
	 */
	conversation = find_or_create_conversation(pinfo);

	gss_info = (gssapi_conv_info_t *)conversation_get_proto_data(conversation, proto_gssapi);
	if (!gss_info) {
		gss_info = wmem_new(wmem_file_scope(), gssapi_conv_info_t);
		gss_info->oid=NULL;
		gss_info->do_reassembly=FALSE;
		gss_info->frags=wmem_tree_new(wmem_file_scope());

		conversation_add_proto_data(conversation, proto_gssapi, gss_info);
	}

	item = proto_tree_add_item(
		tree, proto_gssapi, tvb, offset, -1, ENC_NA);

	subtree = proto_item_add_subtree(item, ett_gssapi);

	/*
	 * Catch the ReportedBoundsError exception; the stuff we've been
	 * handed doesn't necessarily run to the end of the packet, it's
	 * an item inside a packet, so if it happens to be malformed (or
	 * we, or a dissector we call, has a bug), so that an exception
	 * is thrown, we want to report the error, but return and let
	 * our caller dissect the rest of the packet.
	 *
	 * If it gets a BoundsError, we can stop, as there's nothing more
	 * in the packet after our blob to see, so we just re-throw the
	 * exception.
	 */
	TRY {
		gss_tvb=tvb;


		/* First of all, if it's the first time we see this packet
		 * then check whether we are in the middle of reassembly or not
		 */
		if( (!pinfo->fd->flags.visited)
		&&  (gss_info->do_reassembly)
		&&  (gssapi_reassembly) ){
			fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, gss_info->first_frame);
			if(!fi){
				goto done;
			}
			wmem_tree_insert32(gss_info->frags, pinfo->num, fi);
			fd_head=fragment_add(&gssapi_reassembly_table,
				tvb, 0, pinfo, fi->first_frame, NULL,
				gss_info->frag_offset,
				tvb_captured_length(tvb), TRUE);
			gss_info->frag_offset+=tvb_captured_length(tvb);

			/* we need more fragments */
			if(!fd_head){
				goto done;
			}

			/* this blob is now fully reassembled */
			gss_info->do_reassembly=FALSE;
			fi->reassembled_in=pinfo->num;

			gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);
			add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI"");
		}
		/* We have seen this packet before.
		 * Is this blob part of reassembly or a normal blob ?
		 */
		if( (pinfo->fd->flags.visited)
		&&  (gssapi_reassembly) ){
			fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, pinfo->num);
			if(fi){
				fd_head=fragment_get(&gssapi_reassembly_table,
					pinfo, fi->first_frame, NULL);
				if(fd_head && (fd_head->flags&FD_DEFRAGMENTED)){
					if(pinfo->num==fi->reassembled_in){
					        proto_item *frag_tree_item;
						gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);
						add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI"");
						show_fragment_tree(fd_head, &gssapi_frag_items, tree, pinfo, tvb, &frag_tree_item);
					} else {
						proto_item *it;
						it=proto_tree_add_uint(tree, hf_gssapi_reassembled_in, tvb, 0, 0, fi->reassembled_in);
					        PROTO_ITEM_SET_GENERATED(it);
						goto done;
					}
				}
			}
		}

		/* Read header */
		offset = get_ber_identifier(gss_tvb, offset, &appclass, &pc, &tag);
		offset = get_ber_length(gss_tvb, offset, &len1, &ind_field);


		if (!(appclass == BER_CLASS_APP && pc && tag == 0)) {
		  /* It could be NTLMSSP, with no OID.  This can happen
		     for anything that microsoft calls 'Negotiate' or GSS-SPNEGO */
			if ((tvb_captured_length_remaining(gss_tvb, start_offset)>7) && (tvb_strneql(gss_tvb, start_offset, ""NTLMSSP"", 7) == 0)) {
				return_offset = call_dissector(ntlmssp_handle,
							tvb_new_subset_remaining(gss_tvb, start_offset),
							pinfo, subtree);
				goto done;
			}
			/* Maybe it's new NTLMSSP payload */
			if ((tvb_captured_length_remaining(gss_tvb, start_offset)>16) &&
			   ((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) {
				return_offset = call_dissector(ntlmssp_payload_handle,
							tvb_new_subset_remaining(gss_tvb, start_offset),
							pinfo, subtree);
				encrypt_info->gssapi_data_encrypted = TRUE;
				goto done;
			}
			if ((tvb_captured_length_remaining(gss_tvb, start_offset)==16) &&
			   ((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) {
				if( is_verifier ) {
					return_offset = call_dissector(ntlmssp_verf_handle,
									tvb_new_subset_remaining(gss_tvb, start_offset),
									pinfo, subtree);
				}
				else if( encrypt_info->gssapi_encrypted_tvb ) {
					return_offset = call_dissector_with_data(ntlmssp_data_only_handle,
									tvb_new_subset_remaining(encrypt_info->gssapi_encrypted_tvb, 0),
									pinfo, subtree, &encrypt_info->gssapi_decrypted_tvb);
					encrypt_info->gssapi_data_encrypted = TRUE;
				}
		   		goto done;
		  	}

		  /* Maybe it's new GSSKRB5 CFX Wrapping */
		  if ((tvb_captured_length_remaining(gss_tvb, start_offset)>2) &&
		      ((tvb_memeql(gss_tvb, start_offset, ""\04\x04"", 2) == 0) ||
		       (tvb_memeql(gss_tvb, start_offset, ""\05\x04"", 2) == 0))) {
		    return_offset = call_dissector_with_data(spnego_krb5_wrap_handle,
						   tvb_new_subset_remaining(gss_tvb, start_offset),
						   pinfo, subtree, encrypt_info);
		    goto done;
		  }

		  /*
		   * If we do not recognise an Application class,
		   * then we are probably dealing with an inner context
		   * token or a wrap token, and we should retrieve the
		   * gssapi_oid_value pointer from the per-frame data or,
		   * if there is no per-frame data (as would be the case
		   * the first time we dissect this frame), from the
		   * conversation that exists or that we created from
		   * pinfo (and then make it per-frame data).
		   * We need to make it per-frame data as there can be
		   * more than one GSS-API negotiation in a conversation.
		   *
		   * Note! We ""cheat"". Since we only need the pointer,
		   * we store that as the data.  (That's not really
		   * ""cheating"" - the per-frame data and per-conversation
		   * data code doesn't care what you supply as a data
		   * pointer; it just treats it as an opaque pointer, it
		   * doesn't dereference it or free what it points to.)
		   */
		  oidvalue = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0);
		  if (!oidvalue && !pinfo->fd->flags.visited)
		  {
		    /* No handle attached to this frame, but it's the first */
		    /* pass, so it'd be attached to the conversation. */
		    oidvalue = gss_info->oid;
		    if (gss_info->oid)
		      p_add_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0, gss_info->oid);
		  }
		  if (!oidvalue)
		  {
			  proto_tree_add_expert_format(subtree, pinfo, &ei_gssapi_unknown_header, gss_tvb, start_offset, 0,
					      ""Unknown header (class=%d, pc=%d, tag=%d)"",
					      appclass, pc, tag);
		    return_offset = tvb_captured_length(gss_tvb);
		    goto done;
		  } else {
			tvbuff_t *oid_tvb_local;

			if (is_verifier) {
				handle = oidvalue->wrap_handle;
				if (handle != NULL) {
					oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
					len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
					if (len == 0)
						return_offset = tvb_captured_length(gss_tvb);
					else
						return_offset = start_offset + len;
				} else {
					proto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);
					return_offset = tvb_captured_length(gss_tvb);
				}
			} else {
				handle = oidvalue->handle;
				if (handle != NULL) {
					oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
					len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
					if (len == 0)
						return_offset = tvb_captured_length(gss_tvb);
					else
						return_offset = start_offset + len;
				} else {
					proto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);
					return_offset = tvb_captured_length(gss_tvb);
				}
			}
			goto done; /* We are finished here */
		  }
		}

		/* Read oid */
		oid_start_offset=offset;
		offset=dissect_ber_object_identifier_str(FALSE, &asn1_ctx, subtree, gss_tvb, offset, hf_gssapi_oid, &oid);
		oidvalue = gssapi_lookup_oid_str(oid);


		/* Check if we need reassembly of this blob.
		 * Only try reassembly for OIDs we recognize
		 * and when we have the entire tvb
		 *
		 * SMB will sometimes split one large GSSAPI blob
		 * across multiple SMB/SessionSetup commands.
		 * While we should look at the uid returned in the response
		 * to the first SessionSetup and use that as a key
		 * instead for simplicity we assume there will not be several
		 * such authentication at once on a single tcp session
		 */
		if( (!pinfo->fd->flags.visited)
		&&  (oidvalue)
		&&  (tvb_captured_length(gss_tvb)==tvb_reported_length(gss_tvb))
		&&  (len1>(guint32)tvb_captured_length_remaining(gss_tvb, oid_start_offset))
		&&  (gssapi_reassembly) ){
			fi=wmem_new(wmem_file_scope(), gssapi_frag_info_t);
			fi->first_frame=pinfo->num;
			fi->reassembled_in=0;
			wmem_tree_insert32(gss_info->frags, pinfo->num, fi);

			fragment_add(&gssapi_reassembly_table,
				gss_tvb, 0, pinfo, pinfo->num, NULL,
				0, tvb_captured_length(gss_tvb), TRUE);
			fragment_set_tot_len(&gssapi_reassembly_table,
				pinfo, pinfo->num, NULL, len1+oid_start_offset);

			gss_info->do_reassembly=TRUE;
			gss_info->first_frame=pinfo->num;
			gss_info->frag_offset=tvb_captured_length(gss_tvb);
			goto done;
		}


		/*
		 * Hand off to subdissector.
		 */

		if ((oidvalue == NULL) ||
		    !proto_is_protocol_enabled(oidvalue->proto)) {
			/* No dissector for this oid */
			proto_tree_add_item(subtree, hf_gssapi_token_object, gss_tvb, oid_start_offset, -1, ENC_NA);

			return_offset = tvb_captured_length(gss_tvb);
			goto done;
		}

		/* Save a pointer to the data for the OID for the
		 * GSSAPI protocol for this conversation.
		 */

		/*
		 * Now add the proto data ...
		 * but only if it is not already there.
		 */
		if(!gss_info->oid){
		  gss_info->oid=oidvalue;
		}

		if (is_verifier) {
			handle = oidvalue->wrap_handle;
			if (handle != NULL) {
				oid_tvb = tvb_new_subset_remaining(gss_tvb, offset);
				len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);
				if (len == 0)
					return_offset = tvb_captured_length(gss_tvb);
				else
					return_offset = offset + len;
			} else {
				proto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);
				return_offset = tvb_captured_length(gss_tvb);
			}
		} else {
			handle = oidvalue->handle;
			if (handle != NULL) {
				oid_tvb = tvb_new_subset_remaining(gss_tvb, offset);
				len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);
				if (len == 0)
					return_offset = tvb_captured_length(gss_tvb);
				else
					return_offset = offset + len;
			} else {
				proto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);
				return_offset = tvb_captured_length(gss_tvb);
			}
		}

	 done:
		;
	}","static int
dissect_gssapi_work(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
		    gboolean VAR_3, gssapi_encrypt_info_t* VAR_4)
{
	proto_item *volatile VAR_5;
	proto_tree *volatile VAR_6;
	volatile int VAR_7 = 0;
	gssapi_conv_info_t *volatile VAR_8;
	gssapi_oid_value *VAR_9;
	dissector_handle_t VAR_10;
	conversation_t *VAR_11;
	tvbuff_t *VAR_12;
	int VAR_13, VAR_14, VAR_15;
	volatile int VAR_16;
	gint8 VAR_17;
	gboolean VAR_18, VAR_19;
	gint32 VAR_20;
	guint32 VAR_21;
	const char *VAR_22;
	fragment_head *VAR_23=NULL;
	gssapi_frag_info_t *VAR_24;
	tvbuff_t *volatile VAR_25=NULL;
	asn1_ctx_t VAR_26;

	VAR_14=0;
	VAR_16=0;
	asn1_ctx_init(&VAR_26, VAR_27, TRUE, VAR_1);
	/* COMMENT_0 */
                                                            
                                                                  
             
    
	VAR_4->gssapi_data_encrypted = FALSE;


	/* COMMENT_5 */
                                    
    
	VAR_11 = find_or_create_conversation(VAR_1);

	VAR_8 = (gssapi_conv_info_t *)conversation_get_proto_data(VAR_11, VAR_28);
	if (!VAR_8) {
		VAR_8 = wmem_new(wmem_file_scope(), gssapi_conv_info_t);
		VAR_8->oid=NULL;
		VAR_8->do_reassembly=FALSE;
		VAR_8->frags=wmem_tree_new(wmem_file_scope());

		conversation_add_proto_data(VAR_11, VAR_28, VAR_8);
	}

	VAR_5 = proto_tree_add_item(
		VAR_2, VAR_28, VAR_0, VAR_16, -1, VAR_29);

	VAR_6 = proto_item_add_subtree(VAR_5, VAR_30);

	/* COMMENT_8 */
                                                                 
                                                                 
                                                                 
                                                                
                                                              
                                              
   
                                                                  
                                                                
              
    
	TRY {
		VAR_25=VAR_0;


		/* COMMENT_20 */
                                                                 
     
		if( (!VAR_1->fd->flags.visited)
		&&  (VAR_8->do_reassembly)
		&&  (VAR_31) ){
			VAR_24=(gssapi_frag_info_t *)wmem_tree_lookup32(VAR_8->frags, VAR_8->first_frame);
			if(!VAR_24){
				goto done;
			}
			wmem_tree_insert32(VAR_8->frags, VAR_1->num, VAR_24);
			VAR_23=fragment_add(&VAR_32,
				VAR_0, 0, VAR_1, VAR_24->first_frame, NULL,
				VAR_8->frag_offset,
				tvb_captured_length(VAR_0), TRUE);
			VAR_8->frag_offset+=tvb_captured_length(VAR_0);

			/* COMMENT_23 */
			if(!VAR_23){
				goto done;
			}

			/* COMMENT_24 */
			VAR_8->do_reassembly=FALSE;
			VAR_24->reassembled_in=VAR_1->num;

			VAR_25=tvb_new_chain(VAR_0, VAR_23->tvb_data);
			add_new_data_source(VAR_1, VAR_25, ""Reassembled GSSAPI"");
		}
		/* COMMENT_25 */
                                                       
     
		if( (VAR_1->fd->flags.visited)
		&&  (VAR_31) ){
			VAR_24=(gssapi_frag_info_t *)wmem_tree_lookup32(VAR_8->frags, VAR_1->num);
			if(VAR_24){
				VAR_23=fragment_get(&VAR_32,
					VAR_1, VAR_24->first_frame, NULL);
				if(VAR_23 && (VAR_23->flags&VAR_33)){
					if(VAR_1->num==VAR_24->reassembled_in){
					        proto_item *VAR_34;
						VAR_25=tvb_new_chain(VAR_0, VAR_23->tvb_data);
						add_new_data_source(VAR_1, VAR_25, ""Reassembled GSSAPI"");
						show_fragment_tree(VAR_23, &VAR_35, VAR_2, VAR_1, VAR_0, &VAR_34);
					} else {
						proto_item *VAR_36;
						VAR_36=proto_tree_add_uint(VAR_2, VAR_37, VAR_0, 0, 0, VAR_24->reassembled_in);
					        PROTO_ITEM_SET_GENERATED(VAR_36);
						goto done;
					}
				}
			}
		}

		/* COMMENT_28 */
		VAR_16 = get_ber_identifier(VAR_25, VAR_16, &VAR_17, &VAR_18, &VAR_20);
		VAR_16 = get_ber_length(VAR_25, VAR_16, &VAR_21, &VAR_19);


		if (!(VAR_17 == VAR_38 && VAR_18 && VAR_20 == 0)) {
		  /* COMMENT_29 */
                                                                     
			if ((tvb_captured_length_remaining(VAR_25, VAR_14)>7) && (tvb_strneql(VAR_25, VAR_14, ""NTLMSSP"", 7) == 0)) {
				VAR_7 = call_dissector(VAR_39,
							tvb_new_subset_remaining(VAR_25, VAR_14),
							VAR_1, VAR_6);
				goto done;
			}
			/* COMMENT_31 */
			if ((tvb_captured_length_remaining(VAR_25, VAR_14)>16) &&
			   ((tvb_memeql(VAR_25, VAR_14, ""\x01\x00\x00\x00"", 4) == 0))) {
				VAR_7 = call_dissector(VAR_40,
							tvb_new_subset_remaining(VAR_25, VAR_14),
							VAR_1, VAR_6);
				VAR_4->gssapi_data_encrypted = TRUE;
				goto done;
			}
			if ((tvb_captured_length_remaining(VAR_25, VAR_14)==16) &&
			   ((tvb_memeql(VAR_25, VAR_14, ""\x01\x00\x00\x00"", 4) == 0))) {
				if( VAR_3 ) {
					VAR_7 = call_dissector(VAR_41,
									tvb_new_subset_remaining(VAR_25, VAR_14),
									VAR_1, VAR_6);
				}
				else if( VAR_4->gssapi_encrypted_tvb ) {
					VAR_7 = call_dissector_with_data(VAR_42,
									tvb_new_subset_remaining(VAR_4->gssapi_encrypted_tvb, 0),
									VAR_1, VAR_6, &VAR_4->gssapi_decrypted_tvb);
					VAR_4->gssapi_data_encrypted = TRUE;
				}
		   		goto done;
		  	}

		  /* COMMENT_32 */
		  if ((tvb_captured_length_remaining(VAR_25, VAR_14)>2) &&
		      ((tvb_memeql(VAR_25, VAR_14, ""\04\x04"", 2) == 0) ||
		       (tvb_memeql(VAR_25, VAR_14, ""\05\x04"", 2) == 0))) {
		    VAR_7 = call_dissector_with_data(VAR_43,
						   tvb_new_subset_remaining(VAR_25, VAR_14),
						   VAR_1, VAR_6, VAR_4);
		    goto done;
		  }

		  /* COMMENT_33 */
                                                   
                                                         
                                                        
                                                           
                                                          
                                                      
                                                       
                                               
                                                        
                                                           
      
                                                        
                                                     
                                                           
                                                       
                                                          
                                                         
       
		  VAR_9 = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), VAR_1, VAR_28, 0);
		  if (!VAR_9 && !VAR_1->fd->flags.visited)
		  {
		    /* COMMENT_52 */
		    /* COMMENT_53 */
		    VAR_9 = VAR_8->oid;
		    if (VAR_8->oid)
		      p_add_proto_data(wmem_file_scope(), VAR_1, VAR_28, 0, VAR_8->oid);
		  }
		  if (!VAR_9)
		  {
			  proto_tree_add_expert_format(VAR_6, VAR_1, &VAR_44, VAR_25, VAR_14, 0,
					      ""Unknown header (class=%d, pc=%d, tag=%d)"",
					      VAR_17, VAR_18, VAR_20);
		    VAR_7 = tvb_captured_length(VAR_25);
		    goto done;
		  } else {
			tvbuff_t *VAR_45;

			if (VAR_3) {
				VAR_10 = VAR_9->wrap_handle;
				if (VAR_10 != NULL) {
					VAR_45 = tvb_new_subset_remaining(VAR_25, VAR_14);
					VAR_13 = call_dissector_with_data(VAR_10, VAR_45, VAR_1, VAR_6, VAR_4);
					if (VAR_13 == 0)
						VAR_7 = tvb_captured_length(VAR_25);
					else
						VAR_7 = VAR_14 + VAR_13;
				} else {
					proto_tree_add_item(VAR_6, VAR_46, VAR_25, VAR_16, -1, VAR_29);
					VAR_7 = tvb_captured_length(VAR_25);
				}
			} else {
				VAR_10 = VAR_9->handle;
				if (VAR_10 != NULL) {
					VAR_45 = tvb_new_subset_remaining(VAR_25, VAR_14);
					VAR_13 = call_dissector_with_data(VAR_10, VAR_45, VAR_1, VAR_6, VAR_4);
					if (VAR_13 == 0)
						VAR_7 = tvb_captured_length(VAR_25);
					else
						VAR_7 = VAR_14 + VAR_13;
				} else {
					proto_tree_add_item(VAR_6, VAR_47, VAR_25, VAR_16, -1, VAR_29);
					VAR_7 = tvb_captured_length(VAR_25);
				}
			}
			goto done; /* COMMENT_54 */
		  }
		}

		/* COMMENT_55 */
		VAR_15=VAR_16;
		VAR_16=dissect_ber_object_identifier_str(FALSE, &VAR_26, VAR_6, VAR_25, VAR_16, VAR_48, &VAR_22);
		VAR_9 = gssapi_lookup_oid_str(VAR_22);


		/* COMMENT_56 */
                                              
                                    
    
                                                   
                                               
                                                             
                                                    
                                                               
                                                        
     
		if( (!VAR_1->fd->flags.visited)
		&&  (VAR_9)
		&&  (tvb_captured_length(VAR_25)==tvb_reported_length(VAR_25))
		&&  (VAR_21>(guint32)tvb_captured_length_remaining(VAR_25, VAR_15))
		&&  (VAR_31) ){
			VAR_24=wmem_new(wmem_file_scope(), gssapi_frag_info_t);
			VAR_24->first_frame=VAR_1->num;
			VAR_24->reassembled_in=0;
			wmem_tree_insert32(VAR_8->frags, VAR_1->num, VAR_24);

			fragment_add(&VAR_32,
				VAR_25, 0, VAR_1, VAR_1->num, NULL,
				0, tvb_captured_length(VAR_25), TRUE);
			fragment_set_tot_len(&VAR_32,
				VAR_1, VAR_1->num, NULL, VAR_21+VAR_15);

			VAR_8->do_reassembly=TRUE;
			VAR_8->first_frame=VAR_1->num;
			VAR_8->frag_offset=tvb_captured_length(VAR_25);
			goto done;
		}


		/* COMMENT_67 */
                              
     

		if ((VAR_9 == NULL) ||
		    !proto_is_protocol_enabled(VAR_9->proto)) {
			/* COMMENT_70 */
			proto_tree_add_item(VAR_6, VAR_49, VAR_25, VAR_15, -1, VAR_29);

			VAR_7 = tvb_captured_length(VAR_25);
			goto done;
		}

		/* COMMENT_71 */
                                           
     

		/* COMMENT_74 */
                               
                                         
     
		if(!VAR_8->oid){
		  VAR_8->oid=VAR_9;
		}

		if (VAR_3) {
			VAR_10 = VAR_9->wrap_handle;
			if (VAR_10 != NULL) {
				VAR_12 = tvb_new_subset_remaining(VAR_25, VAR_16);
				VAR_13 = call_dissector_with_data(VAR_10, VAR_12, VAR_1, VAR_6, VAR_4);
				if (VAR_13 == 0)
					VAR_7 = tvb_captured_length(VAR_25);
				else
					VAR_7 = VAR_16 + VAR_13;
			} else {
				proto_tree_add_item(VAR_6, VAR_46, VAR_25, VAR_16, -1, VAR_29);
				VAR_7 = tvb_captured_length(VAR_25);
			}
		} else {
			VAR_10 = VAR_9->handle;
			if (VAR_10 != NULL) {
				VAR_12 = tvb_new_subset_remaining(VAR_25, VAR_16);
				VAR_13 = call_dissector_with_data(VAR_10, VAR_12, VAR_1, VAR_6, VAR_4);
				if (VAR_13 == 0)
					VAR_7 = tvb_captured_length(VAR_25);
				else
					VAR_7 = VAR_16 + VAR_13;
			} else {
				proto_tree_add_item(VAR_6, VAR_47, VAR_25, VAR_16, -1, VAR_29);
				VAR_7 = tvb_captured_length(VAR_25);
			}
		}

	 done:
		;
	}",,"--- func_before
+++ func_after
@@ -208,19 +208,36 @@
 		    return_offset = tvb_captured_length(gss_tvb);
 		    goto done;
 		  } else {
-		    tvbuff_t *oid_tvb_local;
-
-		    oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
-		    if (is_verifier)
-			handle = oidvalue->wrap_handle;
-		    else
-			handle = oidvalue->handle;
-		    len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
-		    if (len == 0)
-			return_offset = tvb_captured_length(gss_tvb);
-		    else
-			return_offset = start_offset + len;
-		    goto done; /* We are finished here */
+			tvbuff_t *oid_tvb_local;
+
+			if (is_verifier) {
+				handle = oidvalue->wrap_handle;
+				if (handle != NULL) {
+					oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
+					len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
+					if (len == 0)
+						return_offset = tvb_captured_length(gss_tvb);
+					else
+						return_offset = start_offset + len;
+				} else {
+					proto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);
+					return_offset = tvb_captured_length(gss_tvb);
+				}
+			} else {
+				handle = oidvalue->handle;
+				if (handle != NULL) {
+					oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);
+					len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);
+					if (len == 0)
+						return_offset = tvb_captured_length(gss_tvb);
+					else
+						return_offset = start_offset + len;
+				} else {
+					proto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);
+					return_offset = tvb_captured_length(gss_tvb);
+				}
+			}
+			goto done; /* We are finished here */
 		  }
 		}
 ","{'deleted_lines': ['\t\t    tvbuff_t *oid_tvb_local;', '', '\t\t    oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);', '\t\t    if (is_verifier)', '\t\t\thandle = oidvalue->wrap_handle;', '\t\t    else', '\t\t\thandle = oidvalue->handle;', '\t\t    len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);', '\t\t    if (len == 0)', '\t\t\treturn_offset = tvb_captured_length(gss_tvb);', '\t\t    else', '\t\t\treturn_offset = start_offset + len;', '\t\t    goto done; /* We are finished here */'], 'added_lines': ['\t\t\ttvbuff_t *oid_tvb_local;', '', '\t\t\tif (is_verifier) {', '\t\t\t\thandle = oidvalue->wrap_handle;', '\t\t\t\tif (handle != NULL) {', '\t\t\t\t\toid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);', '\t\t\t\t\tlen = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);', '\t\t\t\t\tif (len == 0)', '\t\t\t\t\t\treturn_offset = tvb_captured_length(gss_tvb);', '\t\t\t\t\telse', '\t\t\t\t\t\treturn_offset = start_offset + len;', '\t\t\t\t} else {', '\t\t\t\t\tproto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);', '\t\t\t\t\treturn_offset = tvb_captured_length(gss_tvb);', '\t\t\t\t}', '\t\t\t} else {', '\t\t\t\thandle = oidvalue->handle;', '\t\t\t\tif (handle != NULL) {', '\t\t\t\t\toid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);', '\t\t\t\t\tlen = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);', '\t\t\t\t\tif (len == 0)', '\t\t\t\t\t\treturn_offset = tvb_captured_length(gss_tvb);', '\t\t\t\t\telse', '\t\t\t\t\t\treturn_offset = start_offset + len;', '\t\t\t\t} else {', '\t\t\t\t\tproto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);', '\t\t\t\t\treturn_offset = tvb_captured_length(gss_tvb);', '\t\t\t\t}', '\t\t\t}', '\t\t\tgoto done; /* We are finished here */']}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the GSS-API dissector could crash. This was addressed in epan/dissectors/packet-gssapi.c by ensuring that a valid dissector is called.",7.5,HIGH,2,valid,2019-03-25T16:56:56Z,2
CVE-2019-15920,['CWE-416'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,torvalds/linux,"cifs: Fix use-after-free in SMB2_read

There is a KASAN use-after-free:
BUG: KASAN: use-after-free in SMB2_read+0x1136/0x1190
Read of size 8 at addr ffff8880b4e45e50 by task ln/1009

Should not release the 'req' because it will use in the trace.

Fixes: eccb4422cf97 (""smb3: Add ftrace tracepoints for improved SMB3 debugging"")

Signed-off-by: ZhangXiaoxu <zhangxiaoxu5@huawei.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
CC: Stable <stable@vger.kernel.org> 4.18+
Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>",088aaf17aa79300cab14dbee2569c58cfafd7d6e,https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e,fs/cifs/smb2pdu.c,SMB2_read,"int
SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,
unsigned int *nbytes, char **buf, int *buf_type)
{
struct smb_rqst rqst;
int resp_buftype, rc = -EACCES;
struct smb2_read_plain_req *req = NULL;
struct smb2_read_rsp *rsp = NULL;
struct kvec iov[1];
struct kvec rsp_iov;
unsigned int total_len;
int flags = CIFS_LOG_ERROR;
struct cifs_ses *ses = io_parms->tcon->ses;
*nbytes = 0;
rc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);
if (rc)
return rc;
if (smb3_encryption_required(io_parms->tcon))
flags |= CIFS_TRANSFORM_REQ;
iov[0].iov_base = (char *)req;
iov[0].iov_len = total_len;
memset(&rqst, 0, sizeof(struct smb_rqst));
rqst.rq_iov = iov;
rqst.rq_nvec = 1;
rc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);
cifs_small_buf_release(req);
rsp = (struct smb2_read_rsp *)rsp_iov.iov_base;
if (rc) {
if (rc != -ENODATA) {
cifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);
cifs_dbg(VFS, ""Send error in read = %d\n"", rc);
trace_smb3_read_err(xid, req->PersistentFileId,
io_parms->tcon->tid, ses->Suid,
io_parms->offset, io_parms->length,
rc);
} else
trace_smb3_read_done(xid, req->PersistentFileId,
io_parms->tcon->tid, ses->Suid,
io_parms->offset, 0);
free_rsp_buf(resp_buftype, rsp_iov.iov_base);
return rc == -ENODATA ? 0 : rc;
} else
trace_smb3_read_done(xid, req->PersistentFileId,
io_parms->tcon->tid, ses->Suid,
io_parms->offset, io_parms->length);
*nbytes = le32_to_cpu(rsp->DataLength);
if ((*nbytes > CIFS_MAX_MSGSIZE) ||
(*nbytes > io_parms->length)) {
cifs_dbg(FYI, ""bad length %d for count %d\n"",
*nbytes, io_parms->length);
rc = -EIO;
*nbytes = 0;
}
if (*buf) {
memcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);
free_rsp_buf(resp_buftype, rsp_iov.iov_base);
} else if (resp_buftype != CIFS_NO_BUFFER) {
*buf = rsp_iov.iov_base;
if (resp_buftype == CIFS_SMALL_BUFFER)
*buf_type = CIFS_SMALL_BUFFER;
else if (resp_buftype == CIFS_LARGE_BUFFER)
*buf_type = CIFS_LARGE_BUFFER;
}
return rc;
}","int
SMB2_read(const unsigned int VAR_0, struct cifs_io_parms *VAR_1,
unsigned int *VAR_2, char **VAR_3, int *VAR_4)
{
struct smb_rqst VAR_5;
int VAR_6, VAR_7 = -VAR_8;
struct smb2_read_plain_req *VAR_9 = NULL;
struct smb2_read_rsp *VAR_10 = NULL;
struct kvec VAR_11[1];
struct kvec VAR_12;
unsigned int VAR_13;
int VAR_14 = VAR_15;
struct cifs_ses *VAR_16 = VAR_1->tcon->ses;
*VAR_2 = 0;
VAR_7 = smb2_new_read_req((void **)&VAR_9, &VAR_13, VAR_1, NULL, 0, 0);
if (VAR_7)
return VAR_7;
if (smb3_encryption_required(VAR_1->tcon))
VAR_14 |= VAR_17;
VAR_11[0].iov_base = (char *)VAR_9;
VAR_11[0].iov_len = VAR_13;
memset(&VAR_5, 0, sizeof(struct smb_rqst));
VAR_5.rq_iov = VAR_11;
VAR_5.rq_nvec = 1;
VAR_7 = cifs_send_recv(VAR_0, VAR_16, &VAR_5, &VAR_6, VAR_14, &VAR_12);
cifs_small_buf_release(VAR_9);
VAR_10 = (struct smb2_read_rsp *)VAR_12.iov_base;
if (VAR_7) {
if (VAR_7 != -VAR_18) {
cifs_stats_fail_inc(VAR_1->tcon, VAR_19);
cifs_dbg(VAR_20, ""Send error in read = %d\n"", VAR_7);
trace_smb3_read_err(VAR_0, VAR_9->PersistentFileId,
VAR_1->tcon->tid, VAR_16->Suid,
VAR_1->offset, VAR_1->length,
VAR_7);
} else
trace_smb3_read_done(VAR_0, VAR_9->PersistentFileId,
VAR_1->tcon->tid, VAR_16->Suid,
VAR_1->offset, 0);
free_rsp_buf(VAR_6, VAR_12.iov_base);
return VAR_7 == -VAR_18 ? 0 : VAR_7;
} else
trace_smb3_read_done(VAR_0, VAR_9->PersistentFileId,
VAR_1->tcon->tid, VAR_16->Suid,
VAR_1->offset, VAR_1->length);
*VAR_2 = le32_to_cpu(VAR_10->DataLength);
if ((*VAR_2 > VAR_21) ||
(*VAR_2 > VAR_1->length)) {
cifs_dbg(VAR_22, ""bad length %d for count %d\n"",
*VAR_2, VAR_1->length);
VAR_7 = -VAR_23;
*VAR_2 = 0;
}
if (*VAR_3) {
memcpy(*VAR_3, (char *)VAR_10 + VAR_10->DataOffset, *VAR_2);
free_rsp_buf(VAR_6, VAR_12.iov_base);
} else if (VAR_6 != VAR_24) {
*VAR_3 = VAR_12.iov_base;
if (VAR_6 == VAR_25)
*VAR_4 = VAR_25;
else if (VAR_6 == VAR_26)
*VAR_4 = VAR_26;
}
return VAR_7;
}",torvalds/linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e/smb2pdu.c/vul/before/0.json,"int
SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,
	  unsigned int *nbytes, char **buf, int *buf_type)
{
	struct smb_rqst rqst;
	int resp_buftype, rc = -EACCES;
	struct smb2_read_plain_req *req = NULL;
	struct smb2_read_rsp *rsp = NULL;
	struct kvec iov[1];
	struct kvec rsp_iov;
	unsigned int total_len;
	int flags = CIFS_LOG_ERROR;
	struct cifs_ses *ses = io_parms->tcon->ses;

	*nbytes = 0;
	rc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);
	if (rc)
		return rc;

	if (smb3_encryption_required(io_parms->tcon))
		flags |= CIFS_TRANSFORM_REQ;

	iov[0].iov_base = (char *)req;
	iov[0].iov_len = total_len;

	memset(&rqst, 0, sizeof(struct smb_rqst));
	rqst.rq_iov = iov;
	rqst.rq_nvec = 1;

	rc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);
	rsp = (struct smb2_read_rsp *)rsp_iov.iov_base;

	if (rc) {
		if (rc != -ENODATA) {
			cifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);
			cifs_dbg(VFS, ""Send error in read = %d\n"", rc);
			trace_smb3_read_err(xid, req->PersistentFileId,
					    io_parms->tcon->tid, ses->Suid,
					    io_parms->offset, io_parms->length,
					    rc);
		} else
			trace_smb3_read_done(xid, req->PersistentFileId,
				    io_parms->tcon->tid, ses->Suid,
				    io_parms->offset, 0);
		free_rsp_buf(resp_buftype, rsp_iov.iov_base);
		return rc == -ENODATA ? 0 : rc;
	} else
		trace_smb3_read_done(xid, req->PersistentFileId,
				    io_parms->tcon->tid, ses->Suid,
				    io_parms->offset, io_parms->length);

	cifs_small_buf_release(req);

	*nbytes = le32_to_cpu(rsp->DataLength);
	if ((*nbytes > CIFS_MAX_MSGSIZE) ||
	    (*nbytes > io_parms->length)) {
		cifs_dbg(FYI, ""bad length %d for count %d\n"",
			 *nbytes, io_parms->length);
		rc = -EIO;
		*nbytes = 0;
	}

	if (*buf) {
		memcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);
		free_rsp_buf(resp_buftype, rsp_iov.iov_base);
	} else if (resp_buftype != CIFS_NO_BUFFER) {
		*buf = rsp_iov.iov_base;
		if (resp_buftype == CIFS_SMALL_BUFFER)
			*buf_type = CIFS_SMALL_BUFFER;
		else if (resp_buftype == CIFS_LARGE_BUFFER)
			*buf_type = CIFS_LARGE_BUFFER;
	}
	return rc;
}","int
SMB2_read(const unsigned int VAR_0, struct cifs_io_parms *VAR_1,
	  unsigned int *VAR_2, char **VAR_3, int *VAR_4)
{
	struct smb_rqst VAR_5;
	int VAR_6, VAR_7 = -VAR_8;
	struct smb2_read_plain_req *VAR_9 = NULL;
	struct smb2_read_rsp *VAR_10 = NULL;
	struct kvec VAR_11[1];
	struct kvec VAR_12;
	unsigned int VAR_13;
	int VAR_14 = VAR_15;
	struct cifs_ses *VAR_16 = VAR_1->tcon->ses;

	*VAR_2 = 0;
	VAR_7 = smb2_new_read_req((void **)&VAR_9, &VAR_13, VAR_1, NULL, 0, 0);
	if (VAR_7)
		return VAR_7;

	if (smb3_encryption_required(VAR_1->tcon))
		VAR_14 |= VAR_17;

	VAR_11[0].iov_base = (char *)VAR_9;
	VAR_11[0].iov_len = VAR_13;

	memset(&VAR_5, 0, sizeof(struct smb_rqst));
	VAR_5.rq_iov = VAR_11;
	VAR_5.rq_nvec = 1;

	VAR_7 = cifs_send_recv(VAR_0, VAR_16, &VAR_5, &VAR_6, VAR_14, &VAR_12);
	VAR_10 = (struct smb2_read_rsp *)VAR_12.iov_base;

	if (VAR_7) {
		if (VAR_7 != -VAR_18) {
			cifs_stats_fail_inc(VAR_1->tcon, VAR_19);
			cifs_dbg(VAR_20, ""Send error in read = %d\n"", VAR_7);
			trace_smb3_read_err(VAR_0, VAR_9->PersistentFileId,
					    VAR_1->tcon->tid, VAR_16->Suid,
					    VAR_1->offset, VAR_1->length,
					    VAR_7);
		} else
			trace_smb3_read_done(VAR_0, VAR_9->PersistentFileId,
				    VAR_1->tcon->tid, VAR_16->Suid,
				    VAR_1->offset, 0);
		free_rsp_buf(VAR_6, VAR_12.iov_base);
		return VAR_7 == -VAR_18 ? 0 : VAR_7;
	} else
		trace_smb3_read_done(VAR_0, VAR_9->PersistentFileId,
				    VAR_1->tcon->tid, VAR_16->Suid,
				    VAR_1->offset, VAR_1->length);

	cifs_small_buf_release(VAR_9);

	*VAR_2 = le32_to_cpu(VAR_10->DataLength);
	if ((*VAR_2 > VAR_21) ||
	    (*VAR_2 > VAR_1->length)) {
		cifs_dbg(VAR_22, ""bad length %d for count %d\n"",
			 *VAR_2, VAR_1->length);
		VAR_7 = -VAR_23;
		*VAR_2 = 0;
	}

	if (*VAR_3) {
		memcpy(*VAR_3, (char *)VAR_10 + VAR_10->DataOffset, *VAR_2);
		free_rsp_buf(VAR_6, VAR_12.iov_base);
	} else if (VAR_6 != VAR_24) {
		*VAR_3 = VAR_12.iov_base;
		if (VAR_6 == VAR_25)
			*VAR_4 = VAR_25;
		else if (VAR_6 == VAR_26)
			*VAR_4 = VAR_26;
	}
	return VAR_7;
}",torvalds/linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e/smb2pdu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,8 +28,6 @@
 	rqst.rq_nvec = 1;
 
 	rc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);
-	cifs_small_buf_release(req);
-
 	rsp = (struct smb2_read_rsp *)rsp_iov.iov_base;
 
 	if (rc) {
@@ -50,6 +48,8 @@
 		trace_smb3_read_done(xid, req->PersistentFileId,
 				    io_parms->tcon->tid, ses->Suid,
 				    io_parms->offset, io_parms->length);
+
+	cifs_small_buf_release(req);
 
 	*nbytes = le32_to_cpu(rsp->DataLength);
 	if ((*nbytes > CIFS_MAX_MSGSIZE) ||","{'deleted_lines': ['\tcifs_small_buf_release(req);', ''], 'added_lines': ['', '\tcifs_small_buf_release(req);']}",True,"An issue was discovered in the Linux kernel before 5.0.10. SMB2_read in fs/cifs/smb2pdu.c has a use-after-free. NOTE: this was not fixed correctly in 5.0.10; see the 5.0.11 ChangeLog, which documents a memory leak.",4.3,MEDIUM,1,valid,2019-04-06T07:47:39Z,2
CVE-2019-11372,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,MediaArea/MediaInfoLib,"x B1101, AVI: fix crash with some invalid streams",716747fdde2c8dd6d0fca1223362ae5ce533ae38,https://github.com/MediaArea/MediaInfoLib/commit/716747fdde2c8dd6d0fca1223362ae5ce533ae38,Source/MediaInfo/Multiple/File_Riff_Elements.cpp,File_Riff::Data_Parse,"void File_Riff::Data_Parse()
{
Element_Size-=Alignement_ExtraByte;
DATA_BEGIN
LIST(AIFC)
ATOM_BEGIN
ATOM(AIFC_COMM)
ATOM(AIFC_COMT)
ATOM(AIFC_FVER)
ATOM(AIFC_SSND)
ATOM_DEFAULT(AIFC_xxxx)
ATOM_END_DEFAULT
LIST(AIFF)
ATOM_BEGIN
ATOM(AIFF_COMM)
ATOM(AIFF_COMT)
ATOM(AIFF_ID3_)
LIST_SKIP(AIFF_SSND)
ATOM_DEFAULT(AIFF_xxxx)
ATOM_END_DEFAULT
LIST(AVI_)
ATOM_BEGIN
ATOM(AVI__Cr8r);
ATOM(AVI__cset)
LIST(AVI__exif)
ATOM_DEFAULT_ALONE(AVI__exif_xxxx)
LIST(AVI__goog)
ATOM_BEGIN
ATOM(AVI__goog_GDAT)
ATOM_END
ATOM(AVI__GMET)
LIST(AVI__hdlr)
ATOM_BEGIN
ATOM(AVI__hdlr_avih)
ATOM(AVI__hdlr_JUNK)
LIST(AVI__hdlr_strl)
ATOM_BEGIN
ATOM(AVI__hdlr_strl_indx)
ATOM(AVI__hdlr_strl_JUNK)
ATOM(AVI__hdlr_strl_strd)
ATOM(AVI__hdlr_strl_strf)
ATOM(AVI__hdlr_strl_strh)
ATOM(AVI__hdlr_strl_strn)
ATOM(AVI__hdlr_strl_vprp)
ATOM_END
LIST(AVI__hdlr_odml)
ATOM_BEGIN
ATOM(AVI__hdlr_odml_dmlh)
ATOM_END
ATOM(AVI__hdlr_ON2h)
LIST(AVI__INFO)
ATOM_BEGIN
ATOM(AVI__INFO_IID3)
ATOM(AVI__INFO_ILYC)
ATOM(AVI__INFO_IMP3)
ATOM(AVI__INFO_JUNK)
ATOM_DEFAULT(AVI__INFO_xxxx)
ATOM_END_DEFAULT
ATOM_DEFAULT(AVI__hdlr_xxxx)
ATOM_END_DEFAULT
ATOM(AVI__idx1)
LIST(AVI__INFO)
ATOM_BEGIN
ATOM(AVI__INFO_IID3)
ATOM(AVI__INFO_ILYC)
ATOM(AVI__INFO_IMP3)
ATOM(AVI__INFO_JUNK)
ATOM_DEFAULT(AVI__INFO_xxxx)
ATOM_END_DEFAULT
ATOM(AVI__JUNK)
ATOM(AVI__MD5_)
LIST(AVI__movi)
ATOM_BEGIN
LIST(AVI__movi_rec_)
ATOM_DEFAULT_ALONE(AVI__movi_xxxx)
ATOM_DEFAULT(AVI__movi_xxxx)
ATOM_END_DEFAULT
ATOM(AVI__PrmA);
LIST(AVI__Tdat)
ATOM_BEGIN
ATOM(AVI__Tdat_rn_A)
ATOM(AVI__Tdat_rn_O)
ATOM(AVI__Tdat_tc_A)
ATOM(AVI__Tdat_tc_O)
ATOM_END
ATOM_DEFAULT(AVI__xxxx)
ATOM_END_DEFAULT
LIST(AVIX)         ATOM_BEGIN
ATOM(AVIX_idx1)
LIST(AVIX_movi)
ATOM_BEGIN
LIST(AVIX_movi_rec_)
ATOM_DEFAULT_ALONE(AVIX_movi_xxxx)
ATOM_DEFAULT(AVIX_movi_xxxx)
ATOM_END_DEFAULT
ATOM_END
ATOM_PARTIAL(CADP)
LIST(CDDA)
ATOM_BEGIN
ATOM(CDDA_fmt_)
ATOM_END
ATOM_PARTIAL(CMJP)
ATOM(CMP4)
ATOM(IDVX)
LIST(INDX)
ATOM_DEFAULT_ALONE(INDX_xxxx)
LIST_SKIP(JUNK)
LIST_SKIP(menu)
ATOM(MThd)
LIST_SKIP(MTrk)
LIST_SKIP(PAL_)
LIST(QLCM)
ATOM_BEGIN
ATOM(QLCM_fmt_)
ATOM_END
#if defined(MEDIAINFO_GXF_YES)
LIST(rcrd)
ATOM_BEGIN
ATOM(rcrd_desc)
LIST(rcrd_fld_)
ATOM_BEGIN
LIST(rcrd_fld__anc_)
ATOM_BEGIN
ATOM(rcrd_fld__anc__pos_)
ATOM(rcrd_fld__anc__pyld)
ATOM_END
ATOM(rcrd_fld__finf)
ATOM_END
ATOM_END
#endif     LIST_SKIP(RDIB)
LIST_SKIP(RMID)
LIST_SKIP(RMMP)
LIST(RMP3)
ATOM_BEGIN
LIST(RMP3_data)
break;
LIST(RMP3_INFO)
ATOM_BEGIN
ATOM(RMP3_INFO_IID3)
ATOM(RMP3_INFO_ILYC)
ATOM(RMP3_INFO_IMP3)
ATOM(RMP3_INFO_JUNK)
ATOM_DEFAULT(RMP3_INFO_xxxx)
ATOM_END_DEFAULT
ATOM_END
ATOM(SMV0)
ATOM(SMV0_xxxx)
ATOM(W3DI)
LIST(WAVE)
ATOM_BEGIN
ATOM(WAVE__pmx)
ATOM(WAVE_aXML)
ATOM(WAVE_bext)
LIST(WAVE_data)
break;
ATOM(WAVE_cue_)
ATOM(WAVE_ds64)
ATOM(WAVE_fact)
ATOM(WAVE_fmt_)
ATOM(WAVE_ID3_)
ATOM(WAVE_id3_)
LIST(WAVE_INFO)
ATOM_DEFAULT_ALONE(WAVE_INFO_xxxx)
ATOM(WAVE_iXML)
ATOM(WAVE_mext)
ATOM_END
LIST(wave)
ATOM_BEGIN
LIST(wave_data)
break;
ATOM(wave_fmt_)
ATOM_END
DATA_END
if (Alignement_ExtraByte)
{
Element_Size+=Alignement_ExtraByte;
if (Element_Offset+Alignement_ExtraByte==Element_Size)
Skip_XX(Alignement_ExtraByte,                       ""Alignement"");
}
}","void File_Riff::Data_Parse()
{
VAR_0-=VAR_1;
DATA_BEGIN
VAR_2(VAR_3)
ATOM_BEGIN
VAR_4(VAR_5)
VAR_4(VAR_6)
VAR_4(VAR_7)
VAR_4(VAR_8)
ATOM_DEFAULT(VAR_9)
ATOM_END_DEFAULT
VAR_2(VAR_10)
ATOM_BEGIN
VAR_4(VAR_11)
VAR_4(VAR_12)
VAR_4(VAR_13)
LIST_SKIP(VAR_14)
ATOM_DEFAULT(VAR_15)
ATOM_END_DEFAULT
VAR_2(VAR_16)
ATOM_BEGIN
ATOM(AVI__Cr8r);
VAR_4(VAR_17)
VAR_2(VAR_18)
ATOM_DEFAULT_ALONE(VAR_19)
VAR_2(VAR_20)
ATOM_BEGIN
VAR_4(VAR_21)
ATOM_END
VAR_4(VAR_22)
VAR_2(VAR_23)
ATOM_BEGIN
VAR_4(VAR_24)
VAR_4(VAR_25)
VAR_2(VAR_26)
ATOM_BEGIN
VAR_4(VAR_27)
VAR_4(VAR_28)
VAR_4(VAR_29)
VAR_4(VAR_30)
VAR_4(VAR_31)
VAR_4(VAR_32)
VAR_4(VAR_33)
ATOM_END
VAR_2(VAR_34)
ATOM_BEGIN
VAR_4(VAR_35)
ATOM_END
VAR_4(VAR_36)
VAR_2(VAR_37)
ATOM_BEGIN
VAR_4(VAR_38)
VAR_4(VAR_39)
VAR_4(VAR_40)
VAR_4(VAR_41)
ATOM_DEFAULT(VAR_42)
ATOM_END_DEFAULT
VAR_43(VAR_44)
ATOM_END_DEFAULT
VAR_4(VAR_45)
VAR_2(VAR_37)
ATOM_BEGIN
VAR_4(VAR_38)
VAR_4(VAR_39)
VAR_4(VAR_40)
VAR_4(VAR_41)
VAR_43(VAR_42)
ATOM_END_DEFAULT
VAR_4(VAR_46)
VAR_4(VAR_47)
VAR_2(VAR_48)
ATOM_BEGIN
VAR_2(VAR_49)
ATOM_DEFAULT_ALONE(VAR_50)
VAR_43(VAR_50)
ATOM_END_DEFAULT
ATOM(AVI__PrmA);
VAR_2(VAR_51)
ATOM_BEGIN
VAR_4(VAR_52)
VAR_4(VAR_53)
VAR_4(VAR_54)
VAR_4(VAR_55)
ATOM_END
VAR_43(VAR_56)
ATOM_END_DEFAULT
VAR_2(VAR_57) 
ATOM_BEGIN
VAR_4(VAR_58)
VAR_2(VAR_59)
ATOM_BEGIN
VAR_2(VAR_60)
ATOM_DEFAULT_ALONE(VAR_61)
VAR_43(VAR_61)
ATOM_END_DEFAULT
ATOM_END
VAR_62(VAR_63)
VAR_2(VAR_64)
ATOM_BEGIN
VAR_4(VAR_65)
ATOM_END
VAR_62(VAR_66)
VAR_4(VAR_67)
VAR_4(VAR_68)
VAR_2(VAR_69)
ATOM_DEFAULT_ALONE(VAR_70)
LIST_SKIP(VAR_71)
LIST_SKIP(VAR_72)
VAR_4(VAR_73)
LIST_SKIP(VAR_74)
LIST_SKIP(VAR_75)
VAR_2(VAR_76)
ATOM_BEGIN
VAR_4(VAR_77)
ATOM_END
#if defined(VAR_78)
VAR_2(VAR_79)
ATOM_BEGIN
VAR_4(VAR_80)
VAR_2(VAR_81)
ATOM_BEGIN
VAR_2(VAR_82)
ATOM_BEGIN
VAR_4(VAR_83)
VAR_4(VAR_84)
ATOM_END
VAR_4(VAR_85)
ATOM_END
ATOM_END
#endif 
LIST_SKIP(VAR_86)
LIST_SKIP(VAR_87)
LIST_SKIP(VAR_88)
VAR_2(VAR_89)
ATOM_BEGIN
VAR_2(VAR_90)
break;
VAR_2(VAR_91)
ATOM_BEGIN
VAR_4(VAR_92)
VAR_4(VAR_93)
VAR_4(VAR_94)
VAR_4(VAR_95)
VAR_43(VAR_96)
ATOM_END_DEFAULT
ATOM_END
VAR_4(VAR_97)
VAR_4(VAR_98)
VAR_4(VAR_99)
VAR_2(VAR_100)
ATOM_BEGIN
VAR_4(VAR_101)
VAR_4(VAR_102)
VAR_4(VAR_103)
VAR_2(VAR_104)
break;
VAR_4(VAR_105)
VAR_4(VAR_106)
VAR_4(VAR_107)
VAR_4(VAR_108)
VAR_4(VAR_109)
VAR_4(VAR_110)
VAR_2(VAR_111)
ATOM_DEFAULT_ALONE(VAR_112)
VAR_4(VAR_113)
VAR_4(VAR_114)
ATOM_END
VAR_2(VAR_115)
ATOM_BEGIN
VAR_2(VAR_116)
break;
VAR_4(VAR_117)
ATOM_END
DATA_END
if (Alignement_ExtraByte)
{
VAR_0+=Alignement_ExtraByte;
if (VAR_118+Alignement_ExtraByte==VAR_0)
Skip_XX(Alignement_ExtraByte,                       ""Alignement"");
}
}",MediaArea/MediaInfoLib/716747fdde2c8dd6d0fca1223362ae5ce533ae38/File_Riff_Elements.cpp/vul/before/0.json,"void File_Riff::Data_Parse()
{
    //Alignement specific
    if (Alignement_ExtraByte<=Element_Size)
        Element_Size-=Alignement_ExtraByte;

    DATA_BEGIN
    LIST(AIFC)
        ATOM_BEGIN
        ATOM(AIFC_COMM)
        ATOM(AIFC_COMT)
        ATOM(AIFC_FVER)
        ATOM(AIFC_SSND)
        ATOM_DEFAULT(AIFC_xxxx)
        ATOM_END_DEFAULT
    LIST(AIFF)
        ATOM_BEGIN
        ATOM(AIFF_COMM)
        ATOM(AIFF_COMT)
        ATOM(AIFF_ID3_)
        LIST_SKIP(AIFF_SSND)
        ATOM_DEFAULT(AIFF_xxxx)
        ATOM_END_DEFAULT
    LIST(AVI_)
        ATOM_BEGIN
        ATOM(AVI__Cr8r);
        ATOM(AVI__cset)
        LIST(AVI__exif)
            ATOM_DEFAULT_ALONE(AVI__exif_xxxx)
        LIST(AVI__goog)
            ATOM_BEGIN
            ATOM(AVI__goog_GDAT)
            ATOM_END
        ATOM(AVI__GMET)
        LIST(AVI__hdlr)
            ATOM_BEGIN
            ATOM(AVI__hdlr_avih)
            ATOM(AVI__hdlr_JUNK)
            LIST(AVI__hdlr_strl)
                ATOM_BEGIN
                ATOM(AVI__hdlr_strl_indx)
                ATOM(AVI__hdlr_strl_JUNK)
                ATOM(AVI__hdlr_strl_strd)
                ATOM(AVI__hdlr_strl_strf)
                ATOM(AVI__hdlr_strl_strh)
                ATOM(AVI__hdlr_strl_strn)
                ATOM(AVI__hdlr_strl_vprp)
                ATOM_END
            LIST(AVI__hdlr_odml)
                ATOM_BEGIN
                ATOM(AVI__hdlr_odml_dmlh)
                ATOM_END
            ATOM(AVI__hdlr_ON2h)
            LIST(AVI__INFO)
                ATOM_BEGIN
                ATOM(AVI__INFO_IID3)
                ATOM(AVI__INFO_ILYC)
                ATOM(AVI__INFO_IMP3)
                ATOM(AVI__INFO_JUNK)
                ATOM_DEFAULT(AVI__INFO_xxxx)
                ATOM_END_DEFAULT
            ATOM_DEFAULT(AVI__hdlr_xxxx)
            ATOM_END_DEFAULT
        ATOM(AVI__idx1)
        LIST(AVI__INFO)
            ATOM_BEGIN
            ATOM(AVI__INFO_IID3)
            ATOM(AVI__INFO_ILYC)
            ATOM(AVI__INFO_IMP3)
            ATOM(AVI__INFO_JUNK)
            ATOM_DEFAULT(AVI__INFO_xxxx)
            ATOM_END_DEFAULT
        ATOM(AVI__JUNK)
        ATOM(AVI__MD5_)
        LIST(AVI__movi)
            ATOM_BEGIN
            LIST(AVI__movi_rec_)
                ATOM_DEFAULT_ALONE(AVI__movi_xxxx)
            ATOM_DEFAULT(AVI__movi_xxxx)
            ATOM_END_DEFAULT
        ATOM(AVI__PrmA);
        LIST(AVI__Tdat)
            ATOM_BEGIN
            ATOM(AVI__Tdat_rn_A)
            ATOM(AVI__Tdat_rn_O)
            ATOM(AVI__Tdat_tc_A)
            ATOM(AVI__Tdat_tc_O)
            ATOM_END
        ATOM_DEFAULT(AVI__xxxx)
        ATOM_END_DEFAULT
    LIST(AVIX) //OpenDML
        ATOM_BEGIN
        ATOM(AVIX_idx1)
        LIST(AVIX_movi)
            ATOM_BEGIN
            LIST(AVIX_movi_rec_)
                ATOM_DEFAULT_ALONE(AVIX_movi_xxxx)
            ATOM_DEFAULT(AVIX_movi_xxxx)
            ATOM_END_DEFAULT
        ATOM_END
    ATOM_PARTIAL(CADP)
    LIST(CDDA)
        ATOM_BEGIN
        ATOM(CDDA_fmt_)
        ATOM_END
    ATOM_PARTIAL(CMJP)
    ATOM(CMP4)
    ATOM(IDVX)
    LIST(INDX)
        ATOM_DEFAULT_ALONE(INDX_xxxx)
    LIST_SKIP(JUNK)
    LIST_SKIP(menu)
    ATOM(MThd)
    LIST_SKIP(MTrk)
    LIST_SKIP(PAL_)
    LIST(QLCM)
        ATOM_BEGIN
        ATOM(QLCM_fmt_)
        ATOM_END
    #if defined(MEDIAINFO_GXF_YES)
    LIST(rcrd)
        ATOM_BEGIN
        ATOM(rcrd_desc)
        LIST(rcrd_fld_)
            ATOM_BEGIN
            LIST(rcrd_fld__anc_)
                ATOM_BEGIN
                ATOM(rcrd_fld__anc__pos_)
                ATOM(rcrd_fld__anc__pyld)
                ATOM_END
            ATOM(rcrd_fld__finf)
            ATOM_END
        ATOM_END
    #endif //defined(MEDIAINFO_GXF_YES)
    LIST_SKIP(RDIB)
    LIST_SKIP(RMID)
    LIST_SKIP(RMMP)
    LIST(RMP3)
        ATOM_BEGIN
        LIST(RMP3_data)
            break;
        LIST(RMP3_INFO)
            ATOM_BEGIN
            ATOM(RMP3_INFO_IID3)
            ATOM(RMP3_INFO_ILYC)
            ATOM(RMP3_INFO_IMP3)
            ATOM(RMP3_INFO_JUNK)
            ATOM_DEFAULT(RMP3_INFO_xxxx)
            ATOM_END_DEFAULT
        ATOM_END
    ATOM(SMV0)
    ATOM(SMV0_xxxx)
    ATOM(W3DI)
    LIST(WAVE)
        ATOM_BEGIN
        ATOM(WAVE__pmx)
        ATOM(WAVE_aXML)
        ATOM(WAVE_bext)
        LIST(WAVE_data)
            break;
        ATOM(WAVE_cue_)
        ATOM(WAVE_ds64)
        ATOM(WAVE_fact)
        ATOM(WAVE_fmt_)
        ATOM(WAVE_ID3_)
        ATOM(WAVE_id3_)
        LIST(WAVE_INFO)
            ATOM_DEFAULT_ALONE(WAVE_INFO_xxxx)
        ATOM(WAVE_iXML)
        ATOM(WAVE_mext)
        ATOM_END
    LIST(wave)
        ATOM_BEGIN
        LIST(wave_data)
            break;
        ATOM(wave_fmt_)
        ATOM_END
    DATA_END

    if (Alignement_ExtraByte)
    {
        Element_Size+=Alignement_ExtraByte;
        if (Element_Offset+Alignement_ExtraByte==Element_Size)
            Skip_XX(Alignement_ExtraByte,                       ""Alignement"");
    }
}","void File_Riff::Data_Parse()
{
    /* COMMENT_0 */
    if (VAR_0<=VAR_1)
        VAR_1-=VAR_0;

    DATA_BEGIN
    VAR_2(VAR_3)
        ATOM_BEGIN
        VAR_4(VAR_5)
        VAR_4(VAR_6)
        VAR_4(VAR_7)
        VAR_4(VAR_8)
        ATOM_DEFAULT(VAR_9)
        ATOM_END_DEFAULT
    VAR_2(VAR_10)
        ATOM_BEGIN
        VAR_4(VAR_11)
        VAR_4(VAR_12)
        VAR_4(VAR_13)
        LIST_SKIP(VAR_14)
        ATOM_DEFAULT(VAR_15)
        ATOM_END_DEFAULT
    VAR_2(VAR_16)
        ATOM_BEGIN
        ATOM(AVI__Cr8r);
        VAR_4(VAR_17)
        VAR_2(VAR_18)
            ATOM_DEFAULT_ALONE(VAR_19)
        VAR_2(VAR_20)
            ATOM_BEGIN
            VAR_4(VAR_21)
            ATOM_END
        VAR_4(VAR_22)
        VAR_2(VAR_23)
            ATOM_BEGIN
            VAR_4(VAR_24)
            VAR_4(VAR_25)
            VAR_2(VAR_26)
                ATOM_BEGIN
                VAR_4(VAR_27)
                VAR_4(VAR_28)
                VAR_4(VAR_29)
                VAR_4(VAR_30)
                VAR_4(VAR_31)
                VAR_4(VAR_32)
                VAR_4(VAR_33)
                ATOM_END
            VAR_2(VAR_34)
                ATOM_BEGIN
                VAR_4(VAR_35)
                ATOM_END
            VAR_4(VAR_36)
            VAR_2(VAR_37)
                ATOM_BEGIN
                VAR_4(VAR_38)
                VAR_4(VAR_39)
                VAR_4(VAR_40)
                VAR_4(VAR_41)
                ATOM_DEFAULT(VAR_42)
                ATOM_END_DEFAULT
            VAR_43(VAR_44)
            ATOM_END_DEFAULT
        VAR_4(VAR_45)
        VAR_2(VAR_37)
            ATOM_BEGIN
            VAR_4(VAR_38)
            VAR_4(VAR_39)
            VAR_4(VAR_40)
            VAR_4(VAR_41)
            VAR_43(VAR_42)
            ATOM_END_DEFAULT
        VAR_4(VAR_46)
        VAR_4(VAR_47)
        VAR_2(VAR_48)
            ATOM_BEGIN
            VAR_2(VAR_49)
                ATOM_DEFAULT_ALONE(VAR_50)
            VAR_43(VAR_50)
            ATOM_END_DEFAULT
        ATOM(AVI__PrmA);
        VAR_2(VAR_51)
            ATOM_BEGIN
            VAR_4(VAR_52)
            VAR_4(VAR_53)
            VAR_4(VAR_54)
            VAR_4(VAR_55)
            ATOM_END
        VAR_43(VAR_56)
        ATOM_END_DEFAULT
    VAR_2(VAR_57) /* COMMENT_1 */
        ATOM_BEGIN
        VAR_4(VAR_58)
        VAR_2(VAR_59)
            ATOM_BEGIN
            VAR_2(VAR_60)
                ATOM_DEFAULT_ALONE(VAR_61)
            VAR_43(VAR_61)
            ATOM_END_DEFAULT
        ATOM_END
    VAR_62(VAR_63)
    VAR_2(VAR_64)
        ATOM_BEGIN
        VAR_4(VAR_65)
        ATOM_END
    VAR_62(VAR_66)
    VAR_4(VAR_67)
    VAR_4(VAR_68)
    VAR_2(VAR_69)
        ATOM_DEFAULT_ALONE(VAR_70)
    LIST_SKIP(VAR_71)
    LIST_SKIP(VAR_72)
    VAR_4(VAR_73)
    LIST_SKIP(VAR_74)
    LIST_SKIP(VAR_75)
    VAR_2(VAR_76)
        ATOM_BEGIN
        VAR_4(VAR_77)
        ATOM_END
    #if defined(VAR_78)
    VAR_2(VAR_79)
        ATOM_BEGIN
        VAR_4(VAR_80)
        VAR_2(VAR_81)
            ATOM_BEGIN
            VAR_2(VAR_82)
                ATOM_BEGIN
                VAR_4(VAR_83)
                VAR_4(VAR_84)
                ATOM_END
            VAR_4(VAR_85)
            ATOM_END
        ATOM_END
    #endif /* COMMENT_2 */
    LIST_SKIP(VAR_86)
    LIST_SKIP(VAR_87)
    LIST_SKIP(VAR_88)
    VAR_2(VAR_89)
        ATOM_BEGIN
        VAR_2(VAR_90)
            break;
        VAR_2(VAR_91)
            ATOM_BEGIN
            VAR_4(VAR_92)
            VAR_4(VAR_93)
            VAR_4(VAR_94)
            VAR_4(VAR_95)
            VAR_43(VAR_96)
            ATOM_END_DEFAULT
        ATOM_END
    VAR_4(VAR_97)
    VAR_4(VAR_98)
    VAR_4(VAR_99)
    VAR_2(VAR_100)
        ATOM_BEGIN
        VAR_4(VAR_101)
        VAR_4(VAR_102)
        VAR_4(VAR_103)
        VAR_2(VAR_104)
            break;
        VAR_4(VAR_105)
        VAR_4(VAR_106)
        VAR_4(VAR_107)
        VAR_4(VAR_108)
        VAR_4(VAR_109)
        VAR_4(VAR_110)
        VAR_2(VAR_111)
            ATOM_DEFAULT_ALONE(VAR_112)
        VAR_4(VAR_113)
        VAR_4(VAR_114)
        ATOM_END
    VAR_2(VAR_115)
        ATOM_BEGIN
        VAR_2(VAR_116)
            break;
        VAR_4(VAR_117)
        ATOM_END
    DATA_END

    if (Alignement_ExtraByte)
    {
        VAR_1+=Alignement_ExtraByte;
        if (VAR_118+Alignement_ExtraByte==VAR_1)
            Skip_XX(Alignement_ExtraByte,                       ""Alignement"");
    }
}",MediaArea/MediaInfoLib/716747fdde2c8dd6d0fca1223362ae5ce533ae38/File_Riff_Elements.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,8 @@
 void File_Riff::Data_Parse()
 {
     //Alignement specific
-    Element_Size-=Alignement_ExtraByte;
+    if (Alignement_ExtraByte<=Element_Size)
+        Element_Size-=Alignement_ExtraByte;
 
     DATA_BEGIN
     LIST(AIFC)","{'deleted_lines': ['    Element_Size-=Alignement_ExtraByte;'], 'added_lines': ['    if (Alignement_ExtraByte<=Element_Size)', '        Element_Size-=Alignement_ExtraByte;']}",True,An out-of-bounds read in MediaInfoLib::File__Tags_Helper::Synched_Test in Tag/File__Tags.cpp in MediaInfoLib in MediaArea MediaInfo 18.12 leads to a crash.,6.5,MEDIUM,1,valid,2019-04-11T10:39:13Z,2
CVE-2019-11372,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,MediaArea/MediaInfoLib,"x B1101, AVI: fix crash with some invalid streams",716747fdde2c8dd6d0fca1223362ae5ce533ae38,https://github.com/MediaArea/MediaInfoLib/commit/716747fdde2c8dd6d0fca1223362ae5ce533ae38,Source/MediaInfo/Multiple/File_Riff.cpp,File_Riff::Header_Parse,"void File_Riff::Header_Parse()
{
if (Element_Level==2 && File_Offset+Buffer_Size==File_Size && Buffer_Size>8)
{
if (CC4(Buffer+Buffer_Size-4)==Elements::W3DI)
{
int32u Size=LittleEndian2int32u(Buffer+Buffer_Size-8);
if (Size>8 && Size<=Buffer_Size && Buffer_Offset+Size==Buffer_Size)
{
Header_Fill_Code(Elements::W3DI, ""W3DI"");
Header_Fill_Size(Size);
return;
}
}
}
if (SMV_BlockSize)
{
Header_Fill_Code(Elements::SMV0_xxxx, ""SMV Block"");
Header_Fill_Size(SMV_BlockSize);
return;
}
int32u Size, Name;
Get_C4 (Name,                                               ""Name"");
if (Name==Elements::SMV0)
{
Header_Fill_Code(Elements::SMV0, ""SMV header"");
Header_Fill_Size(51);
return;
}
if (Name==Elements::riff)
IsWave64=true;
if (IsWave64)
{
int64u Size_Complete;
Skip_XX(12,                                             ""Name (GUID)"");
Get_L8 (Size_Complete,                                  ""Size"");
if (Name!=Elements::riff && Size_Complete%8)
{
Alignement_ExtraByte=Size_Complete%8;
Size_Complete+=Alignement_ExtraByte;         }
else
Alignement_ExtraByte=0;
if (Name==Elements::riff)
{
Get_C4 (Name,                                       ""Real Name"");
Skip_XX(12,                                         ""Real Name (GUID)"");
}
if (Name==Elements::WAVE_data)
{
Buffer_DataToParse_Begin=File_Offset+Buffer_Offset;
if (Size_Complete)
Buffer_DataToParse_End=File_Offset+Buffer_Offset+Size_Complete;
else
Buffer_DataToParse_End=File_Size;             Size_Complete=Element_Offset;
}
Header_Fill_Code(Name, Ztring().From_CC4(Name));
Header_Fill_Size(Size_Complete);
return;
}
if (Name==Elements::FORM
|| Name==Elements::MThd)
IsBigEndian=true;     if (IsBigEndian)
Get_B4 (Size,                                           ""Size"");
else
{
Get_L4 (Size,                                           ""Size"");
if (!IsNotWordAligned_Tested && Size%2)
{
if (File_Offset+Buffer_Offset+8+Size==File_Size)
IsNotWordAligned=true;
#if defined(MEDIAINFO_FILE_YES)             else if (!File_Name.empty())
{
File F(File_Name);
F.GoTo(File_Offset+Buffer_Offset+8+Size);
int8u Temp;
if (F.Read(&Temp, 1))
{
if (!((Temp<'A' || Temp>'z') && Temp!=' '))
IsNotWordAligned=true;
}
}
#endif             IsNotWordAligned_Tested=true;
}
}
int64u Size_Complete=Size;
if (Size==0 && Name==Elements::RIFF)
Size_Complete=File_Size-8;
else if (Size==0xFFFFFFFF)
{
if (Element_Size<0x1C)
{
Element_WaitForMoreData();
return;
}
if (Name==Elements::RF64 && CC4(Buffer+Buffer_Offset+0x0C)==Elements::WAVE_ds64)
{
Size_Complete=LittleEndian2int64u(Buffer+Buffer_Offset+0x14);
Param_Info1(Size_Complete);
}
else if (Name==Elements::WAVE_data)
{
Size_Complete=WAVE_data_Size;
Param_Info1(Size_Complete);
}
}
if (Stream_Structure_Temp!=Stream_Structure.end() && Stream_Structure_Temp->second.Size==0)
{
Name=(int32u)-1;
Size_Complete=0;     }
if (File_Offset+Buffer_Offset+8+Size_Complete>File_Size)
{
Size_Complete=File_Size-(File_Offset+Buffer_Offset+8);
if (Element_Level<=2)             Fill(Stream_General, 0, ""IsTruncated"", ""Yes"");
}
if (Size_Complete%2 && !IsNotWordAligned)
{
Size_Complete++;         Alignement_ExtraByte=1;
}
else
Alignement_ExtraByte=0;
if (Name==Elements::LIST
|| Name==Elements::RIFF
|| Name==Elements::RF64
|| Name==Elements::ON2_
|| Name==Elements::FORM)
{
if (Name==Elements::RF64)
IsRIFF64=true;
Get_C4 (Name,                                           ""Real Name"");
if (Size_Complete>=8 && Size_Complete<12)         {
Size_Complete=Element_TotalSize_Get()-8;
Fill(Stream_General, 0, ""BuggyHeader"", Ztring().From_CC4(Name));
}
}
if (Name==0x00000000)
{
Header_Fill_Code(0, ""Junk"");
Header_Fill_Size(File_Size-(File_Offset+Buffer_Offset));
Alignement_ExtraByte=0;
return;
}
if (Name==Elements::ON2f)
Name=Elements::AVI_;
if (Element_Level==2 && Name==Elements::WAVE && !IsRIFF64 && File_Size>0xFFFFFFFF)
IsWaveBroken=true;     if (IsWaveBroken && (Name==Elements::WAVE || Name==Elements::WAVE_data))
Size_Complete=File_Size-(File_Offset+Buffer_Offset+8);     if (movi_Size && Size_Complete>movi_Size/2 && 8+Size_Complete>1024*1024 && !((Name&0xFFFF0000)==0x69780000 || (Name&0x0000FFFF)==0x00006978) && Element_Level==(rec__Present?(size_t)5:(size_t)4) && Buffer_Offset+8+Size_Complete>Buffer_Size)
{
Buffer_DataToParse_End=File_Offset+Buffer_Offset+8+Size_Complete;
Size_Complete=Buffer_Size-(Buffer_Offset+8);
}
if ((Name==Elements::WAVE_data || Name==Elements::AIFF_SSND))
{
Buffer_DataToParse_Begin=File_Offset+Buffer_Offset+8;
if (Size_Complete)
Buffer_DataToParse_End=File_Offset+Buffer_Offset+8+Size_Complete;
else
Buffer_DataToParse_End=File_Size;         Size_Complete=(Name==Elements::AIFF_SSND?8:0);
}
Header_Fill_Code(Name, Ztring().From_CC4(Name));
Header_Fill_Size(Size_Complete+8);
}","void File_Riff::Header_Parse()
{
if (VAR_0==2 && VAR_1+VAR_2==VAR_3 && VAR_2>8)
{
if (CC4(VAR_4+VAR_2-4)==Elements::W3DI)
{
int32u VAR_5=LittleEndian2int32u(VAR_4+VAR_2-8);
if (VAR_5>8 && VAR_5<=VAR_2 && VAR_6+VAR_5==VAR_2)
{
Header_Fill_Code(Elements::W3DI, ""W3DI"");
Header_Fill_Size(VAR_5);
return;
}
}
}
if (VAR_7)
{
Header_Fill_Code(Elements::SMV0_xxxx, ""SMV Block"");
Header_Fill_Size(VAR_7);
return;
}
int32u VAR_5, VAR_8;
Get_C4 (VAR_8,                                               ""Name"");
if (VAR_8==Elements::SMV0)
{
Header_Fill_Code(Elements::SMV0, ""SMV header"");
Header_Fill_Size(51);
return;
}
if (VAR_8==Elements::riff)
VAR_9=true;
if (VAR_9)
{
int64u VAR_10;
Skip_XX(12,                                             ""Name (GUID)"");
Get_L8 (VAR_10,                                  ""Size"");
if (VAR_8!=Elements::riff && VAR_10%8)
{
VAR_11=VAR_10%8;
VAR_10+=VAR_11; 
}
else
VAR_11=0;
if (VAR_8==Elements::riff)
{
Get_C4 (VAR_8,                                       ""Real Name"");
Skip_XX(12,                                         ""Real Name (GUID)"");
}
if (VAR_8==Elements::WAVE_data)
{
VAR_12=VAR_1+VAR_6;
if (VAR_10)
VAR_13=VAR_1+VAR_6+VAR_10;
else
VAR_13=VAR_3; 
VAR_10=VAR_14;
}
Header_Fill_Code(VAR_8, Ztring().From_CC4(VAR_8));
Header_Fill_Size(VAR_10);
return;
}
if (VAR_8==Elements::FORM
|| VAR_8==Elements::MThd)
VAR_15=true; 
if (VAR_15)
Get_B4 (VAR_5,                                           ""Size"");
else
{
Get_L4 (VAR_5,                                           ""Size"");
if (!VAR_16 && VAR_5%2)
{
if (VAR_1+VAR_6+8+VAR_5==VAR_3)
VAR_17=true;
#if defined(VAR_18) 
else if (!VAR_19.empty())
{
File F(File_Name);
VAR_20.GoTo(VAR_1+VAR_6+8+VAR_5);
int8u VAR_21;
if (VAR_20.Read(&VAR_21, 1))
{
if (!((VAR_21<'A' || VAR_21>'z') && VAR_21!=' '))
VAR_17=true;
}
}
#endif 
VAR_16=true;
}
}
int64u VAR_10=VAR_5;
if (VAR_5==0 && VAR_8==Elements::RIFF)
VAR_10=VAR_3-8;
else if (VAR_5==0xFFFFFFFF)
{
if (VAR_22<0x1C)
{
Element_WaitForMoreData();
return;
}
if (VAR_8==Elements::RF64 && CC4(VAR_4+VAR_6+0x0C)==Elements::WAVE_ds64)
{
VAR_10=LittleEndian2int64u(VAR_4+VAR_6+0x14);
Param_Info1(VAR_10);
}
else if (VAR_8==Elements::WAVE_data)
{
VAR_10=VAR_23;
Param_Info1(VAR_10);
}
}
if (VAR_24!=VAR_25.end() && VAR_24->second.Size==0)
{
VAR_8=(int32u)-1;
VAR_10=0; 
}
if (VAR_1+VAR_6+8+VAR_10>VAR_3)
{
VAR_10=VAR_3-(VAR_1+VAR_6+8);
if (VAR_0<=2) 
Fill(VAR_26, 0, ""IsTruncated"", ""Yes"");
}
if (VAR_10%2 && !VAR_17)
{
VAR_10++; 
VAR_11=1;
}
else
VAR_11=0;
if (VAR_8==Elements::LIST
|| VAR_8==Elements::RIFF
|| VAR_8==Elements::RF64
|| VAR_8==Elements::ON2_
|| VAR_8==Elements::FORM)
{
if (VAR_8==Elements::RF64)
VAR_27=true;
Get_C4 (VAR_8,                                           ""Real Name"");
if (VAR_10>=8 && VAR_10<12) 
{
VAR_10=Element_TotalSize_Get()-8;
Fill(VAR_26, 0, ""BuggyHeader"", Ztring().From_CC4(VAR_8));
}
}
if (VAR_8==0x00000000)
{
Header_Fill_Code(0, ""Junk"");
Header_Fill_Size(VAR_3-(VAR_1+VAR_6));
VAR_11=0;
return;
}
if (VAR_8==Elements::ON2f)
VAR_8=Elements::AVI_;
if (VAR_0==2 && VAR_8==Elements::WAVE && !VAR_27 && VAR_3>0xFFFFFFFF)
VAR_28=true; 
if (VAR_28 && (VAR_8==Elements::WAVE || VAR_8==Elements::WAVE_data))
VAR_10=VAR_3-(VAR_1+VAR_6+8); 
if (VAR_29 && VAR_10>VAR_29/2 && 8+VAR_10>1024*1024 && !((VAR_8&0xFFFF0000)==0x69780000 || (VAR_8&0x0000FFFF)==0x00006978) && VAR_0==(VAR_30?(size_t)5:(size_t)4) && VAR_6+8+VAR_10>VAR_2)
{
VAR_13=VAR_1+VAR_6+8+VAR_10;
VAR_10=VAR_2-(VAR_6+8);
}
if ((VAR_8==Elements::WAVE_data || VAR_8==Elements::AIFF_SSND))
{
VAR_12=VAR_1+VAR_6+8;
if (VAR_10)
VAR_13=VAR_1+VAR_6+8+VAR_10;
else
VAR_13=VAR_3; 
VAR_10=(VAR_8==Elements::AIFF_SSND?8:0);
}
Header_Fill_Code(VAR_8, Ztring().From_CC4(VAR_8));
Header_Fill_Size(VAR_10+8);
}",MediaArea/MediaInfoLib/716747fdde2c8dd6d0fca1223362ae5ce533ae38/File_Riff.cpp/vul/before/0.json,"void File_Riff::Header_Parse()
{
    //Special case : W3DI tags (unknown format!) are at the end of the file
    if (Element_Level==2 && File_Offset+Buffer_Size==File_Size && Buffer_Size>8)
    {
        if (CC4(Buffer+Buffer_Size-4)==Elements::W3DI)
        {
            int32u Size=LittleEndian2int32u(Buffer+Buffer_Size-8);
            if (Size>8 && Size<=Buffer_Size && Buffer_Offset+Size==Buffer_Size)
            {
                //Filling
                Header_Fill_Code(Elements::W3DI, ""W3DI"");
                Header_Fill_Size(Size);
                return;
            }
        }
    }

    //Special case : SMV file detected
    if (SMV_BlockSize)
    {
        //Filling
        Header_Fill_Code(Elements::SMV0_xxxx, ""SMV Block"");
        Header_Fill_Size(SMV_BlockSize);
        return;
    }

    //Parsing
    int32u Size, Name;
    Get_C4 (Name,                                               ""Name"");
    if (Name==Elements::SMV0)
    {
        //SMV specific
        //Filling
        Header_Fill_Code(Elements::SMV0, ""SMV header"");
        Header_Fill_Size(51);
        return;
    }
    if (Name==Elements::riff)
        IsWave64=true;
    if (IsWave64)
    {
        //Wave64 specific
        int64u Size_Complete;
        Skip_XX(12,                                             ""Name (GUID)"");
        Get_L8 (Size_Complete,                                  ""Size"");

        //Alignment
        if (Name!=Elements::riff && Size_Complete%8)
        {
            Alignement_ExtraByte=Size_Complete%8;
            Size_Complete+=Alignement_ExtraByte; //Always 8-byte aligned
        }
        else
            Alignement_ExtraByte=0;

        //Top level chunks
        if (Name==Elements::riff)
        {
            Get_C4 (Name,                                       ""Real Name"");
            Skip_XX(12,                                         ""Real Name (GUID)"");
        }

        //Special case: we don't need the full data
        if (Name==Elements::WAVE_data)
        {
            Buffer_DataToParse_Begin=File_Offset+Buffer_Offset;
            if (Size_Complete)
                Buffer_DataToParse_End=File_Offset+Buffer_Offset+Size_Complete;
            else
                Buffer_DataToParse_End=File_Size; //Found one file with 0 as size of data part
            Size_Complete=Element_Offset;
        }

        //Filling
        Header_Fill_Code(Name, Ztring().From_CC4(Name));
        Header_Fill_Size(Size_Complete);
        return;
    }
    if (Name==Elements::FORM
     || Name==Elements::MThd)
        IsBigEndian=true; //Swap from Little to Big Endian for ""FORM"" files (AIFF...)
    if (IsBigEndian)
        Get_B4 (Size,                                           ""Size"");
    else
    {
        Get_L4 (Size,                                           ""Size"");

        //Testing malformed (not word aligned)
        if (!IsNotWordAligned_Tested && Size%2)
        {
            if (File_Offset+Buffer_Offset+8+Size==File_Size)
                IsNotWordAligned=true;
            #if defined(MEDIAINFO_FILE_YES) //TODO: seek if file API is not available
            else if (!File_Name.empty())
            {
                File F(File_Name);
                F.GoTo(File_Offset+Buffer_Offset+8+Size);
                int8u Temp;
                if (F.Read(&Temp, 1))
                {
                    if (!((Temp<'A' || Temp>'z') && Temp!=' '))
                        IsNotWordAligned=true;
                }
            }
            #endif //defined(MEDIAINFO_FILE_YES)
            IsNotWordAligned_Tested=true;
        }
    }

    //RF64
    int64u Size_Complete=Size;
    if (Size==0 && Name==Elements::RIFF)
        Size_Complete=File_Size-8;
    else if (Size==0xFFFFFFFF)
    {
        if (Element_Size<0x1C)
        {
            Element_WaitForMoreData();
            return;
        }
        if (Name==Elements::RF64 && CC4(Buffer+Buffer_Offset+0x0C)==Elements::WAVE_ds64)
        {
            Size_Complete=LittleEndian2int64u(Buffer+Buffer_Offset+0x14);
            Param_Info1(Size_Complete);
        }
        else if (Name==Elements::WAVE_data)
        {
            Size_Complete=WAVE_data_Size;
            Param_Info1(Size_Complete);
        }
    }

    //Coherency
    if (Stream_Structure_Temp!=Stream_Structure.end() && Stream_Structure_Temp->second.Size==0)
    {
        Name=(int32u)-1;
        Size_Complete=0; //Hack in some indexes with Size==0 (why?), ignoring content of header
    }
    if (File_Offset+Buffer_Offset+8+Size_Complete>File_Size)
    {
        Size_Complete=File_Size-(File_Offset+Buffer_Offset+8);
        if (Element_Level<=2) //Incoherencies info only at the top level chunk
            Fill(Stream_General, 0, ""IsTruncated"", ""Yes"");
    }

    //Alignment
    if (Size_Complete%2 && !IsNotWordAligned && File_Offset+Buffer_Offset+Element_Offset+Size_Complete<File_Size)
    {
        Size_Complete++; //Always 2-byte aligned
        Alignement_ExtraByte=1;
    }
    else
        Alignement_ExtraByte=0;

    //Top level chunks
    if (Name==Elements::LIST
     || Name==Elements::RIFF
     || Name==Elements::RF64
     || Name==Elements::ON2_
     || Name==Elements::FORM)
    {
        if (Name==Elements::RF64)
            IsRIFF64=true;
        Get_C4 (Name,                                           ""Real Name"");

        //Handling buggy files
        if (Size_Complete>=8 && Size_Complete<12) //Not possible (would contain only the name of the RIFF block + the name of the sub-element, no size)
        {
            Size_Complete=Element_TotalSize_Get()-8;
            Fill(Stream_General, 0, ""BuggyHeader"", Ztring().From_CC4(Name));
        }
    }

    //Integrity
    if (Name==0x00000000)
    {
        //Filling
        Header_Fill_Code(0, ""Junk"");
        Header_Fill_Size(File_Size-(File_Offset+Buffer_Offset));
        Alignement_ExtraByte=0;
        return;
    }

    //Specific
    if (Name==Elements::ON2f)
        Name=Elements::AVI_;

    //Tests
    if (Element_Level==2 && Name==Elements::WAVE && !IsRIFF64 && File_Size>0xFFFFFFFF)
        IsWaveBroken=true; //Non standard big files detection
    if (IsWaveBroken && (Name==Elements::WAVE || Name==Elements::WAVE_data))
        Size_Complete=File_Size-(File_Offset+Buffer_Offset+8); //Non standard big files detection
    if (movi_Size && Size_Complete>movi_Size/2 && 8+Size_Complete>1024*1024 && !((Name&0xFFFF0000)==0x69780000 || (Name&0x0000FFFF)==0x00006978) && Element_Level==(rec__Present?(size_t)5:(size_t)4) && Buffer_Offset+8+Size_Complete>Buffer_Size)
    {
        Buffer_DataToParse_End=File_Offset+Buffer_Offset+8+Size_Complete;
        Size_Complete=Buffer_Size-(Buffer_Offset+8);
    }
    if ((Name==Elements::WAVE_data || Name==Elements::AIFF_SSND))
    {
        Buffer_DataToParse_Begin=File_Offset+Buffer_Offset+8;
        if (Size_Complete)
            Buffer_DataToParse_End=File_Offset+Buffer_Offset+8+Size_Complete;
        else
            Buffer_DataToParse_End=File_Size; //Found one file with 0 as size of data part
        Size_Complete=(Name==Elements::AIFF_SSND?8:0);
    }

    //Filling
    Header_Fill_Code(Name, Ztring().From_CC4(Name));
    Header_Fill_Size(Size_Complete+8);
}","void File_Riff::Header_Parse()
{
    /* COMMENT_0 */
    if (VAR_0==2 && VAR_1+VAR_2==VAR_3 && VAR_2>8)
    {
        if (CC4(VAR_4+VAR_2-4)==Elements::W3DI)
        {
            int32u VAR_5=LittleEndian2int32u(VAR_4+VAR_2-8);
            if (VAR_5>8 && VAR_5<=VAR_2 && VAR_6+VAR_5==VAR_2)
            {
                /* COMMENT_1 */
                Header_Fill_Code(Elements::W3DI, ""W3DI"");
                Header_Fill_Size(VAR_5);
                return;
            }
        }
    }

    /* COMMENT_2 */
    if (VAR_7)
    {
        /* COMMENT_1 */
        Header_Fill_Code(Elements::SMV0_xxxx, ""SMV Block"");
        Header_Fill_Size(VAR_7);
        return;
    }

    /* COMMENT_3 */
    int32u VAR_5, VAR_8;
    Get_C4 (VAR_8,                                               ""Name"");
    if (VAR_8==Elements::SMV0)
    {
        /* COMMENT_4 */
        /* COMMENT_1 */
        Header_Fill_Code(Elements::SMV0, ""SMV header"");
        Header_Fill_Size(51);
        return;
    }
    if (VAR_8==Elements::riff)
        VAR_9=true;
    if (VAR_9)
    {
        /* COMMENT_5 */
        int64u VAR_10;
        Skip_XX(12,                                             ""Name (GUID)"");
        Get_L8 (VAR_10,                                  ""Size"");

        /* COMMENT_6 */
        if (VAR_8!=Elements::riff && VAR_10%8)
        {
            VAR_11=VAR_10%8;
            VAR_10+=VAR_11; /* COMMENT_7 */
        }
        else
            VAR_11=0;

        /* COMMENT_8 */
        if (VAR_8==Elements::riff)
        {
            Get_C4 (VAR_8,                                       ""Real Name"");
            Skip_XX(12,                                         ""Real Name (GUID)"");
        }

        /* COMMENT_9 */
        if (VAR_8==Elements::WAVE_data)
        {
            VAR_12=VAR_1+VAR_6;
            if (VAR_10)
                VAR_13=VAR_1+VAR_6+VAR_10;
            else
                VAR_13=VAR_3; /* COMMENT_10 */
            VAR_10=VAR_14;
        }

        /* COMMENT_1 */
        Header_Fill_Code(VAR_8, Ztring().From_CC4(VAR_8));
        Header_Fill_Size(VAR_10);
        return;
    }
    if (VAR_8==Elements::FORM
     || VAR_8==Elements::MThd)
        VAR_15=true; /* COMMENT_11 */
    if (VAR_15)
        Get_B4 (VAR_5,                                           ""Size"");
    else
    {
        Get_L4 (VAR_5,                                           ""Size"");

        /* COMMENT_12 */
        if (!VAR_16 && VAR_5%2)
        {
            if (VAR_1+VAR_6+8+VAR_5==VAR_3)
                VAR_17=true;
            #if defined(VAR_18) /* COMMENT_13 */
            else if (!VAR_19.empty())
            {
                File F(File_Name);
                VAR_20.GoTo(VAR_1+VAR_6+8+VAR_5);
                int8u VAR_21;
                if (VAR_20.Read(&VAR_21, 1))
                {
                    if (!((VAR_21<'A' || VAR_21>'z') && VAR_21!=' '))
                        VAR_17=true;
                }
            }
            #endif /* COMMENT_14 */
            VAR_16=true;
        }
    }

    /* COMMENT_15 */
    int64u VAR_10=VAR_5;
    if (VAR_5==0 && VAR_8==Elements::RIFF)
        VAR_10=VAR_3-8;
    else if (VAR_5==0xFFFFFFFF)
    {
        if (VAR_22<0x1C)
        {
            Element_WaitForMoreData();
            return;
        }
        if (VAR_8==Elements::RF64 && CC4(VAR_4+VAR_6+0x0C)==Elements::WAVE_ds64)
        {
            VAR_10=LittleEndian2int64u(VAR_4+VAR_6+0x14);
            Param_Info1(VAR_10);
        }
        else if (VAR_8==Elements::WAVE_data)
        {
            VAR_10=VAR_23;
            Param_Info1(VAR_10);
        }
    }

    /* COMMENT_16 */
    if (VAR_24!=VAR_25.end() && VAR_24->second.Size==0)
    {
        VAR_8=(int32u)-1;
        VAR_10=0; /* COMMENT_17 */
    }
    if (VAR_1+VAR_6+8+VAR_10>VAR_3)
    {
        VAR_10=VAR_3-(VAR_1+VAR_6+8);
        if (VAR_0<=2) /* COMMENT_18 */
            Fill(VAR_26, 0, ""IsTruncated"", ""Yes"");
    }

    /* COMMENT_6 */
    if (VAR_10%2 && !VAR_17 && VAR_1+VAR_6+VAR_14+VAR_10<VAR_3)
    {
        VAR_10++; /* COMMENT_19 */
        VAR_11=1;
    }
    else
        VAR_11=0;

    /* COMMENT_8 */
    if (VAR_8==Elements::LIST
     || VAR_8==Elements::RIFF
     || VAR_8==Elements::RF64
     || VAR_8==Elements::ON2_
     || VAR_8==Elements::FORM)
    {
        if (VAR_8==Elements::RF64)
            VAR_27=true;
        Get_C4 (VAR_8,                                           ""Real Name"");

        /* COMMENT_20 */
        if (VAR_10>=8 && VAR_10<12) /* COMMENT_21 */
        {
            VAR_10=Element_TotalSize_Get()-8;
            Fill(VAR_26, 0, ""BuggyHeader"", Ztring().From_CC4(VAR_8));
        }
    }

    /* COMMENT_22 */
    if (VAR_8==0x00000000)
    {
        /* COMMENT_1 */
        Header_Fill_Code(0, ""Junk"");
        Header_Fill_Size(VAR_3-(VAR_1+VAR_6));
        VAR_11=0;
        return;
    }

    /* COMMENT_23 */
    if (VAR_8==Elements::ON2f)
        VAR_8=Elements::AVI_;

    /* COMMENT_24 */
    if (VAR_0==2 && VAR_8==Elements::WAVE && !VAR_27 && VAR_3>0xFFFFFFFF)
        VAR_28=true; /* COMMENT_25 */
    if (VAR_28 && (VAR_8==Elements::WAVE || VAR_8==Elements::WAVE_data))
        VAR_10=VAR_3-(VAR_1+VAR_6+8); /* COMMENT_25 */
    if (VAR_29 && VAR_10>VAR_29/2 && 8+VAR_10>1024*1024 && !((VAR_8&0xFFFF0000)==0x69780000 || (VAR_8&0x0000FFFF)==0x00006978) && VAR_0==(VAR_30?(size_t)5:(size_t)4) && VAR_6+8+VAR_10>VAR_2)
    {
        VAR_13=VAR_1+VAR_6+8+VAR_10;
        VAR_10=VAR_2-(VAR_6+8);
    }
    if ((VAR_8==Elements::WAVE_data || VAR_8==Elements::AIFF_SSND))
    {
        VAR_12=VAR_1+VAR_6+8;
        if (VAR_10)
            VAR_13=VAR_1+VAR_6+8+VAR_10;
        else
            VAR_13=VAR_3; /* COMMENT_10 */
        VAR_10=(VAR_8==Elements::AIFF_SSND?8:0);
    }

    /* COMMENT_1 */
    Header_Fill_Code(VAR_8, Ztring().From_CC4(VAR_8));
    Header_Fill_Size(VAR_10+8);
}",MediaArea/MediaInfoLib/716747fdde2c8dd6d0fca1223362ae5ce533ae38/File_Riff.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -145,7 +145,7 @@
     }
 
     //Alignment
-    if (Size_Complete%2 && !IsNotWordAligned)
+    if (Size_Complete%2 && !IsNotWordAligned && File_Offset+Buffer_Offset+Element_Offset+Size_Complete<File_Size)
     {
         Size_Complete++; //Always 2-byte aligned
         Alignement_ExtraByte=1;","{'deleted_lines': ['    if (Size_Complete%2 && !IsNotWordAligned)'], 'added_lines': ['    if (Size_Complete%2 && !IsNotWordAligned && File_Offset+Buffer_Offset+Element_Offset+Size_Complete<File_Size)']}",True,An out-of-bounds read in MediaInfoLib::File__Tags_Helper::Synched_Test in Tag/File__Tags.cpp in MediaInfoLib in MediaArea MediaInfo 18.12 leads to a crash.,6.5,MEDIUM,1,valid,2019-04-11T10:39:13Z,2
CVE-2019-3563,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/wangle,"Peek for \n in LineBasedFrameDecoder.

Summary:
Previously this could underflow if there was not a following \n.

CVE-2019-3563

Reviewed By: siyengar

Differential Revision: D14935715

fbshipit-source-id: 25c3eecf373f89efa1232456aeeb092f13b7fa06",5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6,https://github.com/facebook/wangle/commit/5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6,wangle/codec/LineBasedFrameDecoder.cpp,LineBasedFrameDecoder::findEndOfLine,"int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {
Cursor c(buf.front());
for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {
auto b = c.read<char>();
if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
return i;
} else if (terminatorType_ != TerminatorType::NEWLINE &&
b == '\r' && !c.isAtEnd() && c.read<char>() == '\n') {
return i;
}
}
return -1;
}","int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& VAR_0) {
Cursor VAR_1(VAR_0.front());
for (uint32_t VAR_2 = 0; VAR_2 < VAR_3 && VAR_2 < VAR_0.chainLength(); VAR_2++) {
auto VAR_4 = VAR_1.read<char>();
if (VAR_4 == '\n' && VAR_5 != TerminatorType::CARRIAGENEWLINE) {
return VAR_2;
} else if (VAR_5 != TerminatorType::NEWLINE &&
VAR_4 == '\r' && !VAR_1.isAtEnd() && VAR_1.read<char>() == '\n') {
return VAR_2;
}
}
return -1;
}",facebook/wangle/5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6/LineBasedFrameDecoder.cpp/vul/before/0.json,"int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {
  Cursor c(buf.front());
  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {
    auto b = c.read<char>();
    if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
      return i;
    } else if (
        terminatorType_ != TerminatorType::NEWLINE && b == '\r' &&
        !c.isAtEnd() && *c.peekBytes().data() == '\n') {
      return i;
    }
  }

  return -1;
}","int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& VAR_0) {
  Cursor VAR_1(VAR_0.front());
  for (uint32_t VAR_2 = 0; VAR_2 < VAR_3 && VAR_2 < VAR_0.chainLength(); VAR_2++) {
    auto VAR_4 = VAR_1.read<char>();
    if (VAR_4 == '\n' && VAR_5 != TerminatorType::CARRIAGENEWLINE) {
      return VAR_2;
    } else if (
        VAR_5 != TerminatorType::NEWLINE && VAR_4 == '\r' &&
        !VAR_1.isAtEnd() && *VAR_1.peekBytes().data() == '\n') {
      return VAR_2;
    }
  }

  return -1;
}",facebook/wangle/5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6/LineBasedFrameDecoder.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,8 +4,9 @@
     auto b = c.read<char>();
     if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
       return i;
-    } else if (terminatorType_ != TerminatorType::NEWLINE &&
-               b == '\r' && !c.isAtEnd() && c.read<char>() == '\n') {
+    } else if (
+        terminatorType_ != TerminatorType::NEWLINE && b == '\r' &&
+        !c.isAtEnd() && *c.peekBytes().data() == '\n') {
       return i;
     }
   }","{'deleted_lines': ['    } else if (terminatorType_ != TerminatorType::NEWLINE &&', ""               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {""], 'added_lines': ['    } else if (', ""        terminatorType_ != TerminatorType::NEWLINE && b == '\\r' &&"", ""        !c.isAtEnd() && *c.peekBytes().data() == '\\n') {""]}",True,"Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00",9.8,CRITICAL,3,valid,2019-04-16T16:20:51Z,2
CVE-2019-13109,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Exiv2/exiv2,"Avoid negative integer overflow when `iccOffset > chunkLength`.

This fixes #790.

(cherry picked from commit 6fa2e31206127bd8bcac0269311f3775a8d6ea21)",491c3ebe3b3faa6d8f75fb28146186792c2439da,https://github.com/Exiv2/exiv2/commit/491c3ebe3b3faa6d8f75fb28146186792c2439da,src/pngimage.cpp,PngImage::readMetadata,"void PngImage::readMetadata()
{
#ifdef DEBUG
std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << io_->path() << std::endl;
#endif
if (io_->open() != 0) {
throw Error(kerDataSourceOpenFailed, io_->path(), strError());
}
IoCloser closer(*io_);
if (!isPngType(*io_, true)) {
throw Error(kerNotAnImage, ""PNG"");
}
clearMetadata();
const long imgSize = (long)io_->size();
DataBuf cheaderBuf(8);  
while (!io_->eof()) {
std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);
readChunk(cheaderBuf, *io_);  
uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
long pos = io_->tell();
if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {
throw Exiv2::Error(kerFailedToReadImageData);
}
std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);
#ifdef DEBUG
std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << chunkType << "" length: "" << chunkLength
<< std::endl;
#endif
if (chunkType == ""IEND"" || chunkType == ""IHDR"" || chunkType == ""tEXt"" || chunkType == ""zTXt"" ||
chunkType == ""iTXt"" || chunkType == ""iCCP"") {
DataBuf chunkData(chunkLength);
readChunk(chunkData, *io_);  
if (chunkType == ""IEND"") {
return;                  } else if (chunkType == ""IHDR"" && chunkData.size_ >= 8) {
Internal::PngImageHeader header;
PngChunk::decodeIHDRChunk(chunkData, header);
pixelWidth_ = header.width;
pixelHeight_ = header.height;
} else if (chunkType == ""tEXt"") {
PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);
} else if (chunkType == ""zTXt"") {
PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);
} else if (chunkType == ""iTXt"") {
PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);
} else if (chunkType == ""iCCP"") {
uint32_t iccOffset = 0;
while (iccOffset < 80 && iccOffset < chunkLength) {
if (chunkData.pData_[iccOffset++] == 0x00) {
break;
}
}
profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);
++iccOffset;  
zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);
#ifdef DEBUG
std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << profileName_ << std::endl;
std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : ""
<< iccProfile_.size_ << std::endl;
#endif
}
chunkLength = 0;
}
#ifdef DEBUG
std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl;
#endif
io_->seek(chunkLength + 4, BasicIo::cur);
if (io_->error() || io_->eof()) {
throw Error(kerFailedToReadImageData);
}
}
}","void PngImage::readMetadata()
{
#ifdef VAR_0
std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << VAR_1->path() << std::endl;
#endif
if (VAR_1->open() != 0) {
throw Error(VAR_2, VAR_1->path(), strError());
}
IoCloser VAR_3(*VAR_1);
if (!isPngType(*VAR_1, true)) {
throw Error(VAR_4, ""PNG"");
}
clearMetadata();
const long VAR_5 = (long)VAR_1->size();
DataBuf VAR_6(8);  
while (!VAR_1->eof()) {
std::memset(VAR_6.pData_, 0x0, VAR_6.size_);
readChunk(VAR_6, *VAR_1);  
uint32_t VAR_7 = Exiv2::getULong(VAR_6.pData_, Exiv2::bigEndian);
long VAR_8 = VAR_1->tell();
if (VAR_8 == -1 || VAR_7 > uint32_t(0x7FFFFFFF) || VAR_9<long>(VAR_7) > VAR_5 - VAR_8) {
throw Exiv2::Error(VAR_10);
}
std::string VAR_11(VAR_12<char*>(VAR_6.pData_) + 4, 4);
#ifdef VAR_0
std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << VAR_11 << "" length: "" << VAR_7
<< std::endl;
#endif
if (VAR_11 == ""IEND"" || VAR_11 == ""IHDR"" || VAR_11 == ""tEXt"" || VAR_11 == ""zTXt"" ||
VAR_11 == ""iTXt"" || VAR_11 == ""iCCP"") {
DataBuf chunkData(chunkLength);
readChunk(VAR_13, *VAR_1);  
if (VAR_11 == ""IEND"") {
return;  
} else if (VAR_11 == ""IHDR"" && VAR_13.size_ >= 8) {
Internal::PngImageHeader VAR_14;
PngChunk::decodeIHDRChunk(VAR_13, VAR_14);
VAR_15 = VAR_14.width;
VAR_16 = VAR_14.height;
} else if (VAR_11 == ""tEXt"") {
PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::tEXt_Chunk);
} else if (VAR_11 == ""zTXt"") {
PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::zTXt_Chunk);
} else if (VAR_11 == ""iTXt"") {
PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::iTXt_Chunk);
} else if (VAR_11 == ""iCCP"") {
uint32_t VAR_17 = 0;
while (VAR_17 < 80 && VAR_17 < chunkLength) {
if (VAR_13.pData_[VAR_17++] == 0x00) {
break;
}
}
VAR_18 = std::string(VAR_12<char*>(VAR_13.pData_), VAR_17 - 1);
++VAR_17;  
zlibToDataBuf(VAR_13.pData_ + VAR_17, chunkLength - VAR_17, VAR_19);
#ifdef VAR_0
std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << VAR_18 << std::endl;
std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : ""
<< VAR_19.size_ << std::endl;
#endif
}
chunkLength = 0;
}
#ifdef VAR_0
std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl;
#endif
VAR_1->seek(chunkLength + 4, BasicIo::cur);
if (VAR_1->error() || VAR_1->eof()) {
throw Error(VAR_10);
}
}
}",Exiv2/exiv2/491c3ebe3b3faa6d8f75fb28146186792c2439da/pngimage.cpp/vul/before/0.json,"void PngImage::readMetadata()
    {
#ifdef DEBUG
        std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << io_->path() << std::endl;
#endif
        if (io_->open() != 0) {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        if (!isPngType(*io_, true)) {
            throw Error(kerNotAnImage, ""PNG"");
        }
        clearMetadata();

        const long imgSize = (long)io_->size();
        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).

        while (!io_->eof()) {
            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);
            readChunk(cheaderBuf, *io_);  // Read chunk header.

            // Decode chunk data length.
            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
            long pos = io_->tell();
            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {
                throw Exiv2::Error(kerFailedToReadImageData);
            }

            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);
#ifdef DEBUG
            std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << chunkType << "" length: "" << chunkLength
                      << std::endl;
#endif

            /// \todo analyse remaining chunks of the standard
            // Perform a chunk triage for item that we need.
            if (chunkType == ""IEND"" || chunkType == ""IHDR"" || chunkType == ""tEXt"" || chunkType == ""zTXt"" ||
                chunkType == ""iTXt"" || chunkType == ""iCCP"") {
                DataBuf chunkData(chunkLength);
                readChunk(chunkData, *io_);  // Extract chunk data.

                if (chunkType == ""IEND"") {
                    return;  // Last chunk found: we stop parsing.
                } else if (chunkType == ""IHDR"" && chunkData.size_ >= 8) {
                    Internal::PngImageHeader header;
                    PngChunk::decodeIHDRChunk(chunkData, header);
                    pixelWidth_ = header.width;
                    pixelHeight_ = header.height;
                    /// \todo handle rest of data
                } else if (chunkType == ""tEXt"") {
                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);
                } else if (chunkType == ""zTXt"") {
                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);
                } else if (chunkType == ""iTXt"") {
                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);
                } else if (chunkType == ""iCCP"") {
                    // The ICC profile name can vary from 1-79 characters.
                    uint32_t iccOffset = 0;
                    while (iccOffset < 80 && iccOffset < chunkLength) {
                        if (chunkData.pData_[iccOffset++] == 0x00) {
                            break;
                        }
                    }
                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);
                    ++iccOffset;  // +1 = 'compressed' flag
                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);

                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);
#ifdef DEBUG
                    std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << profileName_ << std::endl;
                    std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : ""
                              << iccProfile_.size_ << std::endl;
#endif
                }

                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the
                // file to the next chunk position.
                chunkLength = 0;
            }

            // Move to the next chunk: chunk data size + 4 CRC bytes.
#ifdef DEBUG
            std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl;
#endif
            io_->seek(chunkLength + 4, BasicIo::cur);
            if (io_->error() || io_->eof()) {
                throw Error(kerFailedToReadImageData);
            }
        }
    }","void PngImage::readMetadata()
    {
#ifdef VAR_0
        std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << VAR_1->path() << std::endl;
#endif
        if (VAR_1->open() != 0) {
            throw Error(VAR_2, VAR_1->path(), strError());
        }
        IoCloser VAR_3(*VAR_1);
        if (!isPngType(*VAR_1, true)) {
            throw Error(VAR_4, ""PNG"");
        }
        clearMetadata();

        const long VAR_5 = (long)VAR_1->size();
        DataBuf VAR_6(8);  /* COMMENT_0 */

        while (!VAR_1->eof()) {
            std::memset(VAR_6.pData_, 0x0, VAR_6.size_);
            readChunk(VAR_6, *VAR_1);  /* COMMENT_1 */

            /* COMMENT_2 */
            uint32_t VAR_7 = Exiv2::getULong(VAR_6.pData_, Exiv2::bigEndian);
            long VAR_8 = VAR_1->tell();
            if (VAR_8 == -1 || VAR_7 > uint32_t(0x7FFFFFFF) || VAR_9<long>(VAR_7) > VAR_5 - VAR_8) {
                throw Exiv2::Error(VAR_10);
            }

            std::string VAR_11(VAR_12<char*>(VAR_6.pData_) + 4, 4);
#ifdef VAR_0
            std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << VAR_11 << "" length: "" << VAR_7
                      << std::endl;
#endif

            /* COMMENT_3 */
            /* COMMENT_4 */
            if (VAR_11 == ""IEND"" || VAR_11 == ""IHDR"" || VAR_11 == ""tEXt"" || VAR_11 == ""zTXt"" ||
                VAR_11 == ""iTXt"" || VAR_11 == ""iCCP"") {
                DataBuf chunkData(chunkLength);
                readChunk(VAR_13, *VAR_1);  /* COMMENT_5 */

                if (VAR_11 == ""IEND"") {
                    return;  /* COMMENT_6 */
                } else if (VAR_11 == ""IHDR"" && VAR_13.size_ >= 8) {
                    Internal::PngImageHeader VAR_14;
                    PngChunk::decodeIHDRChunk(VAR_13, VAR_14);
                    VAR_15 = VAR_14.width;
                    VAR_16 = VAR_14.height;
                    /* COMMENT_7 */
                } else if (VAR_11 == ""tEXt"") {
                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::tEXt_Chunk);
                } else if (VAR_11 == ""zTXt"") {
                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::zTXt_Chunk);
                } else if (VAR_11 == ""iTXt"") {
                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::iTXt_Chunk);
                } else if (VAR_11 == ""iCCP"") {
                    /* COMMENT_8 */
                    uint32_t VAR_17 = 0;
                    while (VAR_17 < 80 && VAR_17 < chunkLength) {
                        if (VAR_13.pData_[VAR_17++] == 0x00) {
                            break;
                        }
                    }
                    VAR_18 = std::string(VAR_12<char*>(VAR_13.pData_), VAR_17 - 1);
                    ++VAR_17;  /* COMMENT_9 */
                    enforce(VAR_17 <= chunkLength, Exiv2::kerCorruptedMetadata);

                    zlibToDataBuf(VAR_13.pData_ + VAR_17, chunkLength - VAR_17, VAR_19);
#ifdef VAR_0
                    std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << VAR_18 << std::endl;
                    std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : ""
                              << VAR_19.size_ << std::endl;
#endif
                }

                /* COMMENT_10 */
                /* COMMENT_11 */
                chunkLength = 0;
            }

            /* COMMENT_12 */
#ifdef VAR_0
            std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl;
#endif
            VAR_1->seek(chunkLength + 4, BasicIo::cur);
            if (VAR_1->error() || VAR_1->eof()) {
                throw Error(VAR_10);
            }
        }
    }",Exiv2/exiv2/491c3ebe3b3faa6d8f75fb28146186792c2439da/pngimage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -63,6 +63,7 @@
                     }
                     profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);
                     ++iccOffset;  // +1 = 'compressed' flag
+                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);
 
                     zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);
 #ifdef DEBUG","{'deleted_lines': [], 'added_lines': ['                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);']}",True,"An integer overflow in Exiv2 through 0.27.1 allows an attacker to cause a denial of service (SIGSEGV) via a crafted PNG image file, because PngImage::readMetadata mishandles a chunkLength - iccOffset subtraction.",6.5,MEDIUM,1,valid,2019-04-25T20:31:50Z,2
CVE-2019-20391,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"resolve BUGFIX handle yet unresolved if-features

Fixes #772",bdb596ddc07596fa212f231135b87d0b9178f6f8,https://github.com/CESNET/libyang/commit/bdb596ddc07596fa212f231135b87d0b9178f6f8,src/resolve.c,resolve_iffeature,"int
resolve_iffeature(struct lys_iffeature *expr)
{
int index_e = 0, index_f = 0;
if (expr->expr) {
return resolve_iffeature_recursive(expr, &index_e, &index_f);
}
return 0;
}","int
resolve_iffeature(struct lys_iffeature *VAR_0)
{
int VAR_1 = 0, VAR_2 = 0;
if (VAR_0->expr) {
return resolve_iffeature_recursive(VAR_0, &VAR_1, &VAR_2);
}
return 0;
}",CESNET/libyang/bdb596ddc07596fa212f231135b87d0b9178f6f8/resolve.c/vul/before/0.json,"int
resolve_iffeature(struct lys_iffeature *expr)
{
    int index_e = 0, index_f = 0;

    if (expr->expr && expr->features[0]) {
        return resolve_iffeature_recursive(expr, &index_e, &index_f);
    }
    return 0;
}","int
resolve_iffeature(struct lys_iffeature *VAR_0)
{
    int VAR_1 = 0, VAR_2 = 0;

    if (VAR_0->expr && VAR_0->features[0]) {
        return resolve_iffeature_recursive(VAR_0, &VAR_1, &VAR_2);
    }
    return 0;
}",CESNET/libyang/bdb596ddc07596fa212f231135b87d0b9178f6f8/resolve.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
     int index_e = 0, index_f = 0;
 
-    if (expr->expr) {
+    if (expr->expr && expr->features[0]) {
         return resolve_iffeature_recursive(expr, &index_e, &index_f);
     }
     return 0;","{'deleted_lines': ['    if (expr->expr) {'], 'added_lines': ['    if (expr->expr && expr->features[0]) {']}",True,An invalid memory access flaw is present in libyang before v1.0-r3 in the function resolve_feature_value() when an if-feature statement is used inside a bit. Applications that use libyang to parse untrusted input yang files may crash.,6.5,MEDIUM,1,valid,2019-04-29T06:59:30Z,2
CVE-2019-11838,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,nginx/njs,"Fixed arrays expansion.

There were two problems with njs_array_expand():

 1. It checked that the requred size with the appended elements wasn't bigger
    then the array size and then did nothing.  If there were elements removed
    from the beggining (by shift() operation), then ""size <= array->size"" can
    be true even if there wasn't enought free space after the array.

 2. After allocating more space to prepend elements, it set array->size without
    counting those elements.

Probably, the original idea was to decrement array->size while removing
elements from the beginning, but it wasn't done right.  Even if so, the
new version of the function looks cleaner.

This closes #152 and closes #153 issues on Github.",b0f23dbc4d4713f65470272768ef79b7cb47db78,https://github.com/nginx/njs/commit/b0f23dbc4d4713f65470272768ef79b7cb47db78,njs/njs_array.c,njs_array_prototype_unshift,"static njs_ret_t
njs_array_prototype_unshift(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs,
njs_index_t unused)
{
njs_ret_t    ret;
nxt_uint_t   n;
njs_array_t  *array;
if (njs_is_array(&args[0])) {
array = args[0].data.u.array;
n = nargs - 1;
if (n != 0) {
if ((intptr_t) n > (array->start - array->data)) {
ret = njs_array_expand(vm, array, n, 0);
if (nxt_slow_path(ret != NXT_OK)) {
return ret;
}
}
array->length += n;
n = nargs;
do {
n--;
array->start--;
array->start[0] = args[n];
} while (n > 1);
}
njs_value_number_set(&vm->retval, array->length);
}
return NXT_OK;
}","static njs_ret_t
njs_array_prototype_unshift(njs_vm_t *VAR_0, njs_value_t *VAR_1, nxt_uint_t VAR_2,
njs_index_t VAR_3)
{
njs_ret_t    VAR_4;
nxt_uint_t   VAR_5;
njs_array_t  *VAR_6;
if (njs_is_array(&VAR_1[0])) {
VAR_6 = VAR_1[0].data.u.array;
VAR_5 = VAR_2 - 1;
if (VAR_5 != 0) {
if ((intptr_t) VAR_5 > (VAR_6->start - VAR_6->data)) {
VAR_4 = njs_array_expand(VAR_0, VAR_6, VAR_5, 0);
if (nxt_slow_path(VAR_4 != VAR_7)) {
return VAR_4;
}
}
VAR_6->length += VAR_5;
VAR_5 = VAR_2;
do {
VAR_5--;
VAR_6->start--;
VAR_6->start[0] = VAR_1[VAR_5];
} while (VAR_5 > 1);
}
njs_value_number_set(&VAR_0->retval, VAR_6->length);
}
return VAR_7;
}",nginx/njs/b0f23dbc4d4713f65470272768ef79b7cb47db78/njs_array.c/vul/before/1.json,"static njs_ret_t
njs_array_prototype_unshift(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs,
    njs_index_t unused)
{
    njs_ret_t    ret;
    nxt_uint_t   n;
    njs_array_t  *array;

    if (njs_is_array(&args[0])) {
        array = args[0].data.u.array;
        n = nargs - 1;

        if (n != 0) {
            ret = njs_array_expand(vm, array, n, 0);
            if (nxt_slow_path(ret != NXT_OK)) {
                return ret;
            }

            array->length += n;
            n = nargs;

            do {
                n--;
                /* GC: njs_retain(&args[n]); */
                array->start--;
                array->start[0] = args[n];
            } while (n > 1);
        }

        njs_value_number_set(&vm->retval, array->length);
    }

    return NXT_OK;
}","static njs_ret_t
njs_array_prototype_unshift(njs_vm_t *VAR_0, njs_value_t *VAR_1, nxt_uint_t VAR_2,
    njs_index_t VAR_3)
{
    njs_ret_t    VAR_4;
    nxt_uint_t   VAR_5;
    njs_array_t  *VAR_6;

    if (njs_is_array(&VAR_1[0])) {
        VAR_6 = VAR_1[0].data.u.array;
        VAR_5 = VAR_2 - 1;

        if (VAR_5 != 0) {
            VAR_4 = njs_array_expand(VAR_0, VAR_6, VAR_5, 0);
            if (nxt_slow_path(VAR_4 != VAR_7)) {
                return VAR_4;
            }

            VAR_6->length += VAR_5;
            VAR_5 = VAR_2;

            do {
                VAR_5--;
                /* COMMENT_0 */
                VAR_6->start--;
                VAR_6->start[0] = VAR_1[VAR_5];
            } while (VAR_5 > 1);
        }

        njs_value_number_set(&VAR_0->retval, VAR_6->length);
    }

    return VAR_7;
}",nginx/njs/b0f23dbc4d4713f65470272768ef79b7cb47db78/njs_array.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,11 +11,9 @@
         n = nargs - 1;
 
         if (n != 0) {
-            if ((intptr_t) n > (array->start - array->data)) {
-                ret = njs_array_expand(vm, array, n, 0);
-                if (nxt_slow_path(ret != NXT_OK)) {
-                    return ret;
-                }
+            ret = njs_array_expand(vm, array, n, 0);
+            if (nxt_slow_path(ret != NXT_OK)) {
+                return ret;
             }
 
             array->length += n;","{'deleted_lines': ['            if ((intptr_t) n > (array->start - array->data)) {', '                ret = njs_array_expand(vm, array, n, 0);', '                if (nxt_slow_path(ret != NXT_OK)) {', '                    return ret;', '                }'], 'added_lines': ['            ret = njs_array_expand(vm, array, n, 0);', '            if (nxt_slow_path(ret != NXT_OK)) {', '                return ret;']}",True,"njs through 0.3.1, used in NGINX, has a heap-based buffer overflow in Array.prototype.splice after a resize, related to njs_array_prototype_splice in njs/njs_array.c, because of njs_array_expand size mishandling.",9.8,CRITICAL,3,valid,2019-05-08T16:09:10Z,2
CVE-2019-11838,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,nginx/njs,"Fixed arrays expansion.

There were two problems with njs_array_expand():

 1. It checked that the requred size with the appended elements wasn't bigger
    then the array size and then did nothing.  If there were elements removed
    from the beggining (by shift() operation), then ""size <= array->size"" can
    be true even if there wasn't enought free space after the array.

 2. After allocating more space to prepend elements, it set array->size without
    counting those elements.

Probably, the original idea was to decrement array->size while removing
elements from the beginning, but it wasn't done right.  Even if so, the
new version of the function looks cleaner.

This closes #152 and closes #153 issues on Github.",b0f23dbc4d4713f65470272768ef79b7cb47db78,https://github.com/nginx/njs/commit/b0f23dbc4d4713f65470272768ef79b7cb47db78,njs/njs_array.c,njs_array_expand,"njs_ret_t
njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,
uint32_t append)
{
uint64_t     size;
njs_value_t  *start, *old;
size = (uint64_t) append + array->length;
if (nxt_fast_path(size <= array->size && prepend == 0)) {
return NXT_OK;
}
if (size < 16) {
size *= 2;
} else {
size += size / 2;
}
if (nxt_slow_path((prepend + size) > NJS_ARRAY_MAX_LENGTH)) {
goto memory_error;
}
start = nxt_mp_align(vm->mem_pool, sizeof(njs_value_t),
(prepend + size) * sizeof(njs_value_t));
if (nxt_slow_path(start == NULL)) {
goto memory_error;
}
array->size = size;
old = array->data;
array->data = start;
start += prepend;
memcpy(start, array->start, array->length * sizeof(njs_value_t));
array->start = start;
nxt_mp_free(vm->mem_pool, old);
return NXT_OK;
memory_error:
njs_memory_error(vm);
return NXT_ERROR;
}","njs_ret_t
njs_array_expand(njs_vm_t *VAR_0, njs_array_t *VAR_1, uint32_t VAR_2,
uint32_t VAR_3)
{
uint64_t     VAR_4;
njs_value_t  *VAR_5, *VAR_6;
VAR_4 = (uint64_t) VAR_3 + VAR_1->length;
if (nxt_fast_path(VAR_4 <= VAR_1->size && VAR_2 == 0)) {
return VAR_7;
}
if (VAR_4 < 16) {
VAR_4 *= 2;
} else {
VAR_4 += VAR_4 / 2;
}
if (nxt_slow_path((VAR_2 + VAR_4) > VAR_8)) {
goto memory_error;
}
VAR_5 = nxt_mp_align(VAR_0->mem_pool, sizeof(njs_value_t),
(VAR_2 + VAR_4) * sizeof(njs_value_t));
if (nxt_slow_path(VAR_5 == NULL)) {
goto memory_error;
}
VAR_1->size = VAR_4;
VAR_6 = VAR_1->data;
VAR_1->data = VAR_5;
VAR_5 += VAR_2;
memcpy(VAR_5, VAR_1->start, VAR_1->length * sizeof(njs_value_t));
VAR_1->start = VAR_5;
nxt_mp_free(VAR_0->mem_pool, VAR_6);
return VAR_7;
memory_error:
njs_memory_error(VAR_0);
return VAR_9;
}",nginx/njs/b0f23dbc4d4713f65470272768ef79b7cb47db78/njs_array.c/vul/before/0.json,"njs_ret_t
njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,
    uint32_t append)
{
    uint32_t     free_before, free_after;
    uint64_t     size;
    njs_value_t  *start, *old;

    free_before = array->start - array->data;
    free_after = array->size - array->length - free_before;

    if (nxt_fast_path(free_before >= prepend && free_after >= append)) {
        return NXT_OK;
    }

    size = (uint64_t) prepend + array->length + append;

    if (size < 16) {
        size *= 2;

    } else {
        size += size / 2;
    }

    if (nxt_slow_path(size > NJS_ARRAY_MAX_LENGTH)) {
        goto memory_error;
    }

    start = nxt_mp_align(vm->mem_pool, sizeof(njs_value_t),
                         size * sizeof(njs_value_t));
    if (nxt_slow_path(start == NULL)) {
        goto memory_error;
    }

    array->size = size;

    old = array->data;
    array->data = start;
    start += prepend;

    memcpy(start, array->start, array->length * sizeof(njs_value_t));

    array->start = start;

    nxt_mp_free(vm->mem_pool, old);

    return NXT_OK;

memory_error:

    njs_memory_error(vm);

    return NXT_ERROR;
}","njs_ret_t
njs_array_expand(njs_vm_t *VAR_0, njs_array_t *VAR_1, uint32_t VAR_2,
    uint32_t VAR_3)
{
    uint32_t     VAR_4, VAR_5;
    uint64_t     VAR_6;
    njs_value_t  *VAR_7, *VAR_8;

    VAR_4 = VAR_1->start - VAR_1->data;
    VAR_5 = VAR_1->size - VAR_1->length - VAR_4;

    if (nxt_fast_path(VAR_4 >= VAR_2 && VAR_5 >= VAR_3)) {
        return VAR_9;
    }

    VAR_6 = (uint64_t) VAR_2 + VAR_1->length + VAR_3;

    if (VAR_6 < 16) {
        VAR_6 *= 2;

    } else {
        VAR_6 += VAR_6 / 2;
    }

    if (nxt_slow_path(VAR_6 > VAR_10)) {
        goto memory_error;
    }

    VAR_7 = nxt_mp_align(VAR_0->mem_pool, sizeof(njs_value_t),
                         VAR_6 * sizeof(njs_value_t));
    if (nxt_slow_path(VAR_7 == NULL)) {
        goto memory_error;
    }

    VAR_1->size = VAR_6;

    VAR_8 = VAR_1->data;
    VAR_1->data = VAR_7;
    VAR_7 += VAR_2;

    memcpy(VAR_7, VAR_1->start, VAR_1->length * sizeof(njs_value_t));

    VAR_1->start = VAR_7;

    nxt_mp_free(VAR_0->mem_pool, VAR_8);

    return VAR_9;

memory_error:

    njs_memory_error(VAR_0);

    return VAR_11;
}",nginx/njs/b0f23dbc4d4713f65470272768ef79b7cb47db78/njs_array.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,14 +2,18 @@
 njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,
     uint32_t append)
 {
+    uint32_t     free_before, free_after;
     uint64_t     size;
     njs_value_t  *start, *old;
 
-    size = (uint64_t) append + array->length;
+    free_before = array->start - array->data;
+    free_after = array->size - array->length - free_before;
 
-    if (nxt_fast_path(size <= array->size && prepend == 0)) {
+    if (nxt_fast_path(free_before >= prepend && free_after >= append)) {
         return NXT_OK;
     }
+
+    size = (uint64_t) prepend + array->length + append;
 
     if (size < 16) {
         size *= 2;
@@ -18,12 +22,12 @@
         size += size / 2;
     }
 
-    if (nxt_slow_path((prepend + size) > NJS_ARRAY_MAX_LENGTH)) {
+    if (nxt_slow_path(size > NJS_ARRAY_MAX_LENGTH)) {
         goto memory_error;
     }
 
     start = nxt_mp_align(vm->mem_pool, sizeof(njs_value_t),
-                         (prepend + size) * sizeof(njs_value_t));
+                         size * sizeof(njs_value_t));
     if (nxt_slow_path(start == NULL)) {
         goto memory_error;
     }","{'deleted_lines': ['    size = (uint64_t) append + array->length;', '    if (nxt_fast_path(size <= array->size && prepend == 0)) {', '    if (nxt_slow_path((prepend + size) > NJS_ARRAY_MAX_LENGTH)) {', '                         (prepend + size) * sizeof(njs_value_t));'], 'added_lines': ['    uint32_t     free_before, free_after;', '    free_before = array->start - array->data;', '    free_after = array->size - array->length - free_before;', '    if (nxt_fast_path(free_before >= prepend && free_after >= append)) {', '', '    size = (uint64_t) prepend + array->length + append;', '    if (nxt_slow_path(size > NJS_ARRAY_MAX_LENGTH)) {', '                         size * sizeof(njs_value_t));']}",True,"njs through 0.3.1, used in NGINX, has a heap-based buffer overflow in Array.prototype.splice after a resize, related to njs_array_prototype_splice in njs/njs_array.c, because of njs_array_expand size mishandling.",9.8,CRITICAL,3,valid,2019-05-08T16:09:10Z,2
CVE-2019-12450,"['CWE-362', 'CWE-276']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,GNOME/glib,"gfile: Limit access to files when copying

file_copy_fallback creates new files with default permissions and
set the correct permissions after the operation is finished. This
might cause that the files can be accessible by more users during
the operation than expected. Use G_FILE_CREATE_PRIVATE for the new
files to limit access to those files.",d8f8f4d637ce43f8699ba94c9b7648beda0ca174,https://github.com/GNOME/glib/commit/d8f8f4d637ce43f8699ba94c9b7648beda0ca174,gio/gfile.c,file_copy_fallback,"static gboolean
file_copy_fallback (GFile                  *source,
GFile                  *destination,
GFileCopyFlags          flags,
GCancellable           *cancellable,
GFileProgressCallback   progress_callback,
gpointer                progress_callback_data,
GError                **error)
{
gboolean ret = FALSE;
GFileInputStream *file_in = NULL;
GInputStream *in = NULL;
GOutputStream *out = NULL;
GFileInfo *info = NULL;
const char *target;
char *attrs_to_read;
gboolean do_set_attributes = FALSE;
info = g_file_query_info (source,
G_FILE_ATTRIBUTE_STANDARD_TYPE "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
cancellable,
error);
if (!info)
goto out;
if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&
g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)
{
target = g_file_info_get_symlink_target (info);
if (target)
{
if (!copy_symlink (destination, flags, cancellable, target, error))
goto out;
ret = TRUE;
goto out;
}
}
else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)
{
g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
_(""Cant copy special file""));
goto out;
}
file_in = open_source_for_copy (source, destination, flags, cancellable, error);
if (!file_in)
goto out;
in = G_INPUT_STREAM (file_in);
if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,
cancellable, error))
goto out;
if (attrs_to_read != NULL)
{
GError *tmp_error = NULL;
g_object_unref (info);
info = g_file_input_stream_query_info (file_in, attrs_to_read,
cancellable, &tmp_error);
if (!info)
{
if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
{
g_clear_error (&tmp_error);
info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
cancellable, error);
}
else
{
g_free (attrs_to_read);
g_propagate_error (error, tmp_error);
goto out;
}
}
g_free (attrs_to_read);
if (!info)
goto out;
do_set_attributes = TRUE;
}
if (G_IS_LOCAL_FILE (destination))
{
if (flags & G_FILE_COPY_OVERWRITE)
out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
FALSE, NULL,
flags & G_FILE_COPY_BACKUP,
G_FILE_CREATE_REPLACE_DESTINATION,
info,
cancellable, error);
else
out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
FALSE, 0, info,
cancellable, error);
}
else if (flags & G_FILE_COPY_OVERWRITE)
{
out = (GOutputStream *)g_file_replace (destination,
NULL,
flags & G_FILE_COPY_BACKUP,
G_FILE_CREATE_REPLACE_DESTINATION,
cancellable, error);
}
else
{
out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);
}
if (!out)
goto out;
#ifdef __linux__
if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))
{
GError *reflink_err = NULL;
if (!btrfs_reflink_with_progress (in, out, info, cancellable,
progress_callback, progress_callback_data,
&reflink_err))
{
if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
{
g_clear_error (&reflink_err);
}
else
{
g_propagate_error (error, reflink_err);
goto out;
}
}
else
{
ret = TRUE;
goto out;
}
}
#endif
#ifdef HAVE_SPLICE
if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))
{
GError *splice_err = NULL;
if (!splice_stream_with_progress (in, out, cancellable,
progress_callback, progress_callback_data,
&splice_err))
{
if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
{
g_clear_error (&splice_err);
}
else
{
g_propagate_error (error, splice_err);
goto out;
}
}
else
{
ret = TRUE;
goto out;
}
}
#endif
if (!copy_stream_with_progress (in, out, source, cancellable,
progress_callback, progress_callback_data,
error))
goto out;
ret = TRUE;
out:
if (in)
{
(void) g_input_stream_close (in, cancellable, NULL);
g_object_unref (in);
}
if (out)
{
if (!g_output_stream_close (out, cancellable, ret ? error : NULL))
ret = FALSE;
g_object_unref (out);
}
if (ret && do_set_attributes)
{
g_file_set_attributes_from_info (destination,
info,
G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
cancellable,
NULL);
}
g_clear_object (&info);
return ret;
}","static gboolean
file_copy_fallback (GFile                  *VAR_0,
GFile                  *VAR_1,
GFileCopyFlags          VAR_2,
GCancellable           *VAR_3,
GFileProgressCallback   VAR_4,
gpointer                VAR_5,
GError                **VAR_6)
{
gboolean VAR_7 = FALSE;
GFileInputStream *VAR_8 = NULL;
GInputStream *VAR_9 = NULL;
GOutputStream *VAR_10 = NULL;
GFileInfo *VAR_11 = NULL;
const char *VAR_12;
char *VAR_13;
gboolean VAR_14 = FALSE;
VAR_11 = g_file_query_info (VAR_0,
VAR_15 "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
VAR_16,
VAR_3,
VAR_6);
if (!VAR_11)
goto out;
if ((VAR_2 & VAR_17) &&
g_file_info_get_file_type (VAR_11) == VAR_18)
{
VAR_12 = g_file_info_get_symlink_target (VAR_11);
if (VAR_12)
{
if (!copy_symlink (VAR_1, VAR_2, VAR_3, VAR_12, VAR_6))
goto out;
VAR_7 = TRUE;
goto out;
}
}
else if (g_file_info_get_file_type (VAR_11) == VAR_19)
{
g_set_error_literal (VAR_6, VAR_20, VAR_21,
_(""Cant copy special file""));
goto out;
}
VAR_8 = open_source_for_copy (VAR_0, VAR_1, VAR_2, VAR_3, VAR_6);
if (!VAR_8)
goto out;
VAR_9 = G_INPUT_STREAM (VAR_8);
if (!build_attribute_list_for_copy (VAR_1, VAR_2, &VAR_13,
VAR_3, VAR_6))
goto out;
if (VAR_13 != NULL)
{
GError *VAR_22 = NULL;
g_object_unref (VAR_11);
VAR_11 = g_file_input_stream_query_info (VAR_8, VAR_13,
VAR_3, &VAR_22);
if (!VAR_11)
{
if (g_error_matches (VAR_22, VAR_20, VAR_21))
{
g_clear_error (&VAR_22);
VAR_11 = g_file_query_info (VAR_0, VAR_13, VAR_16,
VAR_3, VAR_6);
}
else
{
g_free (VAR_13);
g_propagate_error (VAR_6, VAR_22);
goto out;
}
}
g_free (VAR_13);
if (!VAR_11)
goto out;
VAR_14 = TRUE;
}
if (G_IS_LOCAL_FILE (VAR_1))
{
if (VAR_2 & VAR_23)
VAR_10 = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (VAR_1)),
FALSE, NULL,
VAR_2 & VAR_24,
VAR_25,
VAR_11,
VAR_3, VAR_6);
else
VAR_10 = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (VAR_1)),
FALSE, 0, VAR_11,
VAR_3, VAR_6);
}
else if (VAR_2 & VAR_23)
{
VAR_10 = (GOutputStream *)g_file_replace (VAR_1,
NULL,
VAR_2 & VAR_24,
VAR_25,
VAR_3, VAR_6);
}
else
{
VAR_10 = (GOutputStream *)g_file_create (VAR_1, 0, VAR_3, VAR_6);
}
if (!VAR_10)
goto out;
#ifdef VAR_26
if (G_IS_FILE_DESCRIPTOR_BASED (VAR_9) && G_IS_FILE_DESCRIPTOR_BASED (VAR_10))
{
GError *VAR_27 = NULL;
if (!btrfs_reflink_with_progress (VAR_9, VAR_10, VAR_11, VAR_3,
VAR_4, VAR_5,
&VAR_27))
{
if (g_error_matches (VAR_27, VAR_20, VAR_21))
{
g_clear_error (&VAR_27);
}
else
{
g_propagate_error (VAR_6, VAR_27);
goto out;
}
}
else
{
VAR_7 = TRUE;
goto out;
}
}
#endif
#ifdef VAR_28
if (G_IS_FILE_DESCRIPTOR_BASED (VAR_9) && G_IS_FILE_DESCRIPTOR_BASED (VAR_10))
{
GError *VAR_29 = NULL;
if (!splice_stream_with_progress (VAR_9, VAR_10, VAR_3,
VAR_4, VAR_5,
&VAR_29))
{
if (g_error_matches (VAR_29, VAR_20, VAR_21))
{
g_clear_error (&VAR_29);
}
else
{
g_propagate_error (VAR_6, VAR_29);
goto out;
}
}
else
{
VAR_7 = TRUE;
goto out;
}
}
#endif
if (!copy_stream_with_progress (VAR_9, VAR_10, VAR_0, VAR_3,
VAR_4, VAR_5,
VAR_6))
goto out;
VAR_7 = TRUE;
out:
if (VAR_9)
{
(void) g_input_stream_close (VAR_9, VAR_3, NULL);
g_object_unref (VAR_9);
}
if (VAR_10)
{
if (!g_output_stream_close (VAR_10, VAR_3, VAR_7 ? VAR_6 : NULL))
VAR_7 = FALSE;
g_object_unref (VAR_10);
}
if (VAR_7 && VAR_14)
{
g_file_set_attributes_from_info (VAR_1,
VAR_11,
VAR_16,
VAR_3,
NULL);
}
g_clear_object (&VAR_11);
return VAR_7;
}",GNOME/glib/d8f8f4d637ce43f8699ba94c9b7648beda0ca174/gfile.c/vul/before/0.json,"static gboolean
file_copy_fallback (GFile                  *source,
                    GFile                  *destination,
                    GFileCopyFlags          flags,
                    GCancellable           *cancellable,
                    GFileProgressCallback   progress_callback,
                    gpointer                progress_callback_data,
                    GError                **error)
{
  gboolean ret = FALSE;
  GFileInputStream *file_in = NULL;
  GInputStream *in = NULL;
  GOutputStream *out = NULL;
  GFileInfo *info = NULL;
  const char *target;
  char *attrs_to_read;
  gboolean do_set_attributes = FALSE;

  /* need to know the file type */
  info = g_file_query_info (source,
                            G_FILE_ATTRIBUTE_STANDARD_TYPE "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                            cancellable,
                            error);
  if (!info)
    goto out;

  /* Maybe copy the symlink? */
  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&
      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)
    {
      target = g_file_info_get_symlink_target (info);
      if (target)
        {
          if (!copy_symlink (destination, flags, cancellable, target, error))
            goto out;

          ret = TRUE;
          goto out;
        }
        /* ... else fall back on a regular file copy */
    }
  /* Handle ""special"" files (pipes, device nodes, ...)? */
  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)
    {
      /* FIXME: could try to recreate device nodes and others? */
      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                           _(""Cant copy special file""));
      goto out;
    }

  /* Everything else should just fall back on a regular copy. */

  file_in = open_source_for_copy (source, destination, flags, cancellable, error);
  if (!file_in)
    goto out;
  in = G_INPUT_STREAM (file_in);

  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,
                                      cancellable, error))
    goto out;

  if (attrs_to_read != NULL)
    {
      GError *tmp_error = NULL;

      /* Ok, ditch the previous lightweight info (on Unix we just
       * called lstat()); at this point we gather all the information
       * we need about the source from the opened file descriptor.
       */
      g_object_unref (info);

      info = g_file_input_stream_query_info (file_in, attrs_to_read,
                                             cancellable, &tmp_error);
      if (!info)
        {
          /* Not all gvfs backends implement query_info_on_read(), we
           * can just fall back to the pathname again.
           * https://bugzilla.gnome.org/706254
           */
          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
            {
              g_clear_error (&tmp_error);
              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                        cancellable, error);
            }
          else
            {
              g_free (attrs_to_read);
              g_propagate_error (error, tmp_error);
              goto out;
            }
        }
      g_free (attrs_to_read);
      if (!info)
        goto out;

      do_set_attributes = TRUE;
    }

  /* In the local file path, we pass down the source info which
   * includes things like unix::mode, to ensure that the target file
   * is not created with different permissions from the source file.
   *
   * If a future API like g_file_replace_with_info() is added, switch
   * this code to use that.
   */
  if (G_IS_LOCAL_FILE (destination))
    {
      if (flags & G_FILE_COPY_OVERWRITE)
        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
                                                                   FALSE, NULL,
                                                                   flags & G_FILE_COPY_BACKUP,
                                                                   G_FILE_CREATE_REPLACE_DESTINATION |
                                                                   G_FILE_CREATE_PRIVATE, info,
                                                                   cancellable, error);
      else
        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,
                                                                  cancellable, error);
    }
  else if (flags & G_FILE_COPY_OVERWRITE)
    {
      out = (GOutputStream *)g_file_replace (destination,
                                             NULL,
                                             flags & G_FILE_COPY_BACKUP,
                                             G_FILE_CREATE_REPLACE_DESTINATION |
                                             G_FILE_CREATE_PRIVATE,
                                             cancellable, error);
    }
  else
    {
      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);
    }

  if (!out)
    goto out;

#ifdef __linux__
  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))
    {
      GError *reflink_err = NULL;

      if (!btrfs_reflink_with_progress (in, out, info, cancellable,
                                        progress_callback, progress_callback_data,
                                        &reflink_err))
        {
          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
            {
              g_clear_error (&reflink_err);
            }
          else
            {
              g_propagate_error (error, reflink_err);
              goto out;
            }
        }
      else
        {
          ret = TRUE;
          goto out;
        }
    }
#endif

#ifdef HAVE_SPLICE
  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))
    {
      GError *splice_err = NULL;

      if (!splice_stream_with_progress (in, out, cancellable,
                                        progress_callback, progress_callback_data,
                                        &splice_err))
        {
          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
            {
              g_clear_error (&splice_err);
            }
          else
            {
              g_propagate_error (error, splice_err);
              goto out;
            }
        }
      else
        {
          ret = TRUE;
          goto out;
        }
    }

#endif

  /* A plain read/write loop */
  if (!copy_stream_with_progress (in, out, source, cancellable,
                                  progress_callback, progress_callback_data,
                                  error))
    goto out;

  ret = TRUE;
 out:
  if (in)
    {
      /* Don't care about errors in source here */
      (void) g_input_stream_close (in, cancellable, NULL);
      g_object_unref (in);
    }

  if (out)
    {
      /* But write errors on close are bad! */
      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))
        ret = FALSE;
      g_object_unref (out);
    }

  /* Ignore errors here. Failure to copy metadata is not a hard error */
  /* TODO: set these attributes /before/ we do the rename() on Unix */
  if (ret && do_set_attributes)
    {
      g_file_set_attributes_from_info (destination,
                                       info,
                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                       cancellable,
                                       NULL);
    }

  g_clear_object (&info);

  return ret;
}","static gboolean
file_copy_fallback (GFile                  *VAR_0,
                    GFile                  *VAR_1,
                    GFileCopyFlags          VAR_2,
                    GCancellable           *VAR_3,
                    GFileProgressCallback   VAR_4,
                    gpointer                VAR_5,
                    GError                **VAR_6)
{
  gboolean VAR_7 = FALSE;
  GFileInputStream *VAR_8 = NULL;
  GInputStream *VAR_9 = NULL;
  GOutputStream *VAR_10 = NULL;
  GFileInfo *VAR_11 = NULL;
  const char *VAR_12;
  char *VAR_13;
  gboolean VAR_14 = FALSE;

  /* COMMENT_0 */
  VAR_11 = g_file_query_info (VAR_0,
                            VAR_15 "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
                            VAR_16,
                            VAR_3,
                            VAR_6);
  if (!VAR_11)
    goto out;

  /* COMMENT_1 */
  if ((VAR_2 & VAR_17) &&
      g_file_info_get_file_type (VAR_11) == VAR_18)
    {
      VAR_12 = g_file_info_get_symlink_target (VAR_11);
      if (VAR_12)
        {
          if (!copy_symlink (VAR_1, VAR_2, VAR_3, VAR_12, VAR_6))
            goto out;

          VAR_7 = TRUE;
          goto out;
        }
        /* COMMENT_2 */
    }
  /* COMMENT_3 */
  else if (g_file_info_get_file_type (VAR_11) == VAR_19)
    {
      /* COMMENT_4 */
      g_set_error_literal (VAR_6, VAR_20, VAR_21,
                           _(""Cant copy special file""));
      goto out;
    }

  /* COMMENT_5 */

  VAR_8 = open_source_for_copy (VAR_0, VAR_1, VAR_2, VAR_3, VAR_6);
  if (!VAR_8)
    goto out;
  VAR_9 = G_INPUT_STREAM (VAR_8);

  if (!build_attribute_list_for_copy (VAR_1, VAR_2, &VAR_13,
                                      VAR_3, VAR_6))
    goto out;

  if (VAR_13 != NULL)
    {
      GError *VAR_22 = NULL;

      /* COMMENT_6 */
                                                                     
                                                                  
         
      g_object_unref (VAR_11);

      VAR_11 = g_file_input_stream_query_info (VAR_8, VAR_13,
                                             VAR_3, &VAR_22);
      if (!VAR_11)
        {
          /* COMMENT_10 */
                                                      
                                              
             
          if (g_error_matches (VAR_22, VAR_20, VAR_21))
            {
              g_clear_error (&VAR_22);
              VAR_11 = g_file_query_info (VAR_0, VAR_13, VAR_16,
                                        VAR_3, VAR_6);
            }
          else
            {
              g_free (VAR_13);
              g_propagate_error (VAR_6, VAR_22);
              goto out;
            }
        }
      g_free (VAR_13);
      if (!VAR_11)
        goto out;

      VAR_14 = TRUE;
    }

  /* COMMENT_14 */
                                                                    
                                                                    
    
                                                                     
                           
     
  if (G_IS_LOCAL_FILE (VAR_1))
    {
      if (VAR_2 & VAR_23)
        VAR_10 = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (VAR_1)),
                                                                   FALSE, NULL,
                                                                   VAR_2 & VAR_24,
                                                                   VAR_25 |
                                                                   VAR_26, VAR_11,
                                                                   VAR_3, VAR_6);
      else
        VAR_10 = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (VAR_1)),
                                                                  FALSE, VAR_26, VAR_11,
                                                                  VAR_3, VAR_6);
    }
  else if (VAR_2 & VAR_23)
    {
      VAR_10 = (GOutputStream *)g_file_replace (VAR_1,
                                             NULL,
                                             VAR_2 & VAR_24,
                                             VAR_25 |
                                             VAR_26,
                                             VAR_3, VAR_6);
    }
  else
    {
      VAR_10 = (GOutputStream *)g_file_create (VAR_1, VAR_26, VAR_3, VAR_6);
    }

  if (!VAR_10)
    goto out;

#ifdef VAR_27
  if (G_IS_FILE_DESCRIPTOR_BASED (VAR_9) && G_IS_FILE_DESCRIPTOR_BASED (VAR_10))
    {
      GError *VAR_28 = NULL;

      if (!btrfs_reflink_with_progress (VAR_9, VAR_10, VAR_11, VAR_3,
                                        VAR_4, VAR_5,
                                        &VAR_28))
        {
          if (g_error_matches (VAR_28, VAR_20, VAR_21))
            {
              g_clear_error (&VAR_28);
            }
          else
            {
              g_propagate_error (VAR_6, VAR_28);
              goto out;
            }
        }
      else
        {
          VAR_7 = TRUE;
          goto out;
        }
    }
#endif

#ifdef VAR_29
  if (G_IS_FILE_DESCRIPTOR_BASED (VAR_9) && G_IS_FILE_DESCRIPTOR_BASED (VAR_10))
    {
      GError *VAR_30 = NULL;

      if (!splice_stream_with_progress (VAR_9, VAR_10, VAR_3,
                                        VAR_4, VAR_5,
                                        &VAR_30))
        {
          if (g_error_matches (VAR_30, VAR_20, VAR_21))
            {
              g_clear_error (&VAR_30);
            }
          else
            {
              g_propagate_error (VAR_6, VAR_30);
              goto out;
            }
        }
      else
        {
          VAR_7 = TRUE;
          goto out;
        }
    }

#endif

  /* COMMENT_21 */
  if (!copy_stream_with_progress (VAR_9, VAR_10, VAR_0, VAR_3,
                                  VAR_4, VAR_5,
                                  VAR_6))
    goto out;

  VAR_7 = TRUE;
 out:
  if (VAR_9)
    {
      /* COMMENT_22 */
      (void) g_input_stream_close (VAR_9, VAR_3, NULL);
      g_object_unref (VAR_9);
    }

  if (VAR_10)
    {
      /* COMMENT_23 */
      if (!g_output_stream_close (VAR_10, VAR_3, VAR_7 ? VAR_6 : NULL))
        VAR_7 = FALSE;
      g_object_unref (VAR_10);
    }

  /* COMMENT_24 */
  /* COMMENT_25 */
  if (VAR_7 && VAR_14)
    {
      g_file_set_attributes_from_info (VAR_1,
                                       VAR_11,
                                       VAR_16,
                                       VAR_3,
                                       NULL);
    }

  g_clear_object (&VAR_11);

  return VAR_7;
}",GNOME/glib/d8f8f4d637ce43f8699ba94c9b7648beda0ca174/gfile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -111,12 +111,12 @@
         out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
                                                                    FALSE, NULL,
                                                                    flags & G_FILE_COPY_BACKUP,
-                                                                   G_FILE_CREATE_REPLACE_DESTINATION,
-                                                                   info,
+                                                                   G_FILE_CREATE_REPLACE_DESTINATION |
+                                                                   G_FILE_CREATE_PRIVATE, info,
                                                                    cancellable, error);
       else
         out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),
-                                                                  FALSE, 0, info,
+                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,
                                                                   cancellable, error);
     }
   else if (flags & G_FILE_COPY_OVERWRITE)
@@ -124,12 +124,13 @@
       out = (GOutputStream *)g_file_replace (destination,
                                              NULL,
                                              flags & G_FILE_COPY_BACKUP,
-                                             G_FILE_CREATE_REPLACE_DESTINATION,
+                                             G_FILE_CREATE_REPLACE_DESTINATION |
+                                             G_FILE_CREATE_PRIVATE,
                                              cancellable, error);
     }
   else
     {
-      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);
+      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);
     }
 
   if (!out)","{'deleted_lines': ['                                                                   G_FILE_CREATE_REPLACE_DESTINATION,', '                                                                   info,', '                                                                  FALSE, 0, info,', '                                             G_FILE_CREATE_REPLACE_DESTINATION,', '      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);'], 'added_lines': ['                                                                   G_FILE_CREATE_REPLACE_DESTINATION |', '                                                                   G_FILE_CREATE_PRIVATE, info,', '                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,', '                                             G_FILE_CREATE_REPLACE_DESTINATION |', '                                             G_FILE_CREATE_PRIVATE,', '      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);']}",True,"file_copy_fallback in gio/gfile.c in GNOME GLib 2.15.0 through 2.61.1 does not properly restrict file permissions while a copy operation is in progress. Instead, default permissions are used.",9.8,CRITICAL,3,valid,2019-05-23T08:41:53Z,2
CVE-2019-25104,['CWE-404'],AV:A/AC:L/Au:S/C:N/I:N/A:P,0,rtcwcoop,"fixed exploit where server crash by spamming team command

********************
ERROR: G_Alloc: failed on allocation of 27248 bytes
********************
----- Server Shutdown (Server crashed: G_Alloc: failed on allocation of 27248 bytes) -----

replaced G_Alloc -> trap_Alloc

anyway POOLSIZE for G_Alloc will fill up quickly just changing team in game menu",f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac,https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac,code/game/ai_cast_script.c,AICast_ScriptLoad,"void AICast_ScriptLoad( void ) {
char filename[MAX_QPATH];
vmCvar_t mapname;
fileHandle_t f;
int len;
level.scriptAI = NULL;
trap_Cvar_VariableStringBuffer( ""ai_scriptName"", filename, sizeof( filename ) );
if ( strlen( filename ) > 0 ) {
trap_Cvar_Register( &mapname, ""ai_scriptName"", """", CVAR_ROM );
} else {
trap_Cvar_Register( &mapname, ""mapname"", """", CVAR_SERVERINFO | CVAR_ROM );
}
Q_strncpyz( filename, ""maps/"", sizeof( filename ) );
Q_strcat( filename, sizeof( filename ), mapname.string );
if ( g_gametype.integer <= GT_COOP ) {
Q_strcat( filename, sizeof( filename ), "".coop.ai"" );
} else {
Q_strcat( filename, sizeof( filename ), "".ai"" );
}
len = trap_FS_FOpenFile( filename, &f, FS_READ );
G_Printf( ""Loading: %s\n"", filename );
if ( len < 0 ) {
return;
}
level.scriptAI = G_Alloc( len );
trap_FS_Read( level.scriptAI, len, f );
trap_FS_FCloseFile( f );
return;
}","void AICast_ScriptLoad( void ) {
char VAR_0[VAR_1];
vmCvar_t VAR_2;
fileHandle_t VAR_3;
int VAR_4;
VAR_5.scriptAI = NULL;
trap_Cvar_VariableStringBuffer( ""ai_scriptName"", VAR_0, sizeof( VAR_0 ) );
if ( strlen( VAR_0 ) > 0 ) {
trap_Cvar_Register( &VAR_2, ""ai_scriptName"", """", VAR_6 );
} else {
trap_Cvar_Register( &VAR_2, ""mapname"", """", VAR_7 | VAR_6 );
}
Q_strncpyz( VAR_0, ""maps/"", sizeof( VAR_0 ) );
Q_strcat( VAR_0, sizeof( VAR_0 ), VAR_2.string );
if ( VAR_8.integer <= VAR_9 ) {
Q_strcat( VAR_0, sizeof( VAR_0 ), "".coop.ai"" );
} else {
Q_strcat( VAR_0, sizeof( VAR_0 ), "".ai"" );
}
VAR_4 = trap_FS_FOpenFile( VAR_0, &VAR_3, VAR_10 );
G_Printf( ""Loading: %s\n"", VAR_0 );
if ( VAR_4 < 0 ) {
return;
}
VAR_5.scriptAI = G_Alloc( VAR_4 );
trap_FS_Read( VAR_5.scriptAI, VAR_4, VAR_3 );
trap_FS_FCloseFile( VAR_3 );
return;
}",rtcwcoop/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac/ai_cast_script.c/vul/before/1.json,"void AICast_ScriptLoad( void ) {
	char filename[MAX_QPATH];
	vmCvar_t mapname;
	fileHandle_t f;
	int len;

	level.scriptAI = NULL;

	trap_Cvar_VariableStringBuffer( ""ai_scriptName"", filename, sizeof( filename ) );
	if ( strlen( filename ) > 0 ) {
		trap_Cvar_Register( &mapname, ""ai_scriptName"", """", CVAR_ROM );
	} else {
		trap_Cvar_Register( &mapname, ""mapname"", """", CVAR_SERVERINFO | CVAR_ROM );
	}
	Q_strncpyz( filename, ""maps/"", sizeof( filename ) );
	Q_strcat( filename, sizeof( filename ), mapname.string );
	if ( g_gametype.integer <= GT_COOP ) {
		Q_strcat( filename, sizeof( filename ), "".coop.ai"" );
	} else {
		Q_strcat( filename, sizeof( filename ), "".ai"" );
	}

	len = trap_FS_FOpenFile( filename, &f, FS_READ );

	G_Printf( ""Loading: %s\n"", filename );

	if ( len < 0 ) {
		return;
	}

	level.scriptAI = trap_Alloc( len );
	trap_FS_Read( level.scriptAI, len, f );

	trap_FS_FCloseFile( f );

	return;
}","void AICast_ScriptLoad( void ) {
	char VAR_0[VAR_1];
	vmCvar_t VAR_2;
	fileHandle_t VAR_3;
	int VAR_4;

	VAR_5.scriptAI = NULL;

	trap_Cvar_VariableStringBuffer( ""ai_scriptName"", VAR_0, sizeof( VAR_0 ) );
	if ( strlen( VAR_0 ) > 0 ) {
		trap_Cvar_Register( &VAR_2, ""ai_scriptName"", """", VAR_6 );
	} else {
		trap_Cvar_Register( &VAR_2, ""mapname"", """", VAR_7 | VAR_6 );
	}
	Q_strncpyz( VAR_0, ""maps/"", sizeof( VAR_0 ) );
	Q_strcat( VAR_0, sizeof( VAR_0 ), VAR_2.string );
	if ( VAR_8.integer <= VAR_9 ) {
		Q_strcat( VAR_0, sizeof( VAR_0 ), "".coop.ai"" );
	} else {
		Q_strcat( VAR_0, sizeof( VAR_0 ), "".ai"" );
	}

	VAR_4 = trap_FS_FOpenFile( VAR_0, &VAR_3, VAR_10 );

	G_Printf( ""Loading: %s\n"", VAR_0 );

	if ( VAR_4 < 0 ) {
		return;
	}

	VAR_5.scriptAI = trap_Alloc( VAR_4 );
	trap_FS_Read( VAR_5.scriptAI, VAR_4, VAR_3 );

	trap_FS_FCloseFile( VAR_3 );

	return;
}",rtcwcoop/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac/ai_cast_script.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,7 +28,7 @@
 		return;
 	}
 
-	level.scriptAI = G_Alloc( len );
+	level.scriptAI = trap_Alloc( len );
 	trap_FS_Read( level.scriptAI, len, f );
 
 	trap_FS_FCloseFile( f );","{'deleted_lines': ['\tlevel.scriptAI = G_Alloc( len );'], 'added_lines': ['\tlevel.scriptAI = trap_Alloc( len );']}",True,A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.,7.5,HIGH,2,valid,2019-05-27T15:59:38Z,2
CVE-2019-25104,['CWE-404'],AV:A/AC:L/Au:S/C:N/I:N/A:P,0,rtcwcoop,"fixed exploit where server crash by spamming team command

********************
ERROR: G_Alloc: failed on allocation of 27248 bytes
********************
----- Server Shutdown (Server crashed: G_Alloc: failed on allocation of 27248 bytes) -----

replaced G_Alloc -> trap_Alloc

anyway POOLSIZE for G_Alloc will fill up quickly just changing team in game menu",f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac,https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac,code/game/ai_cast_script.c,AICast_ScriptParse,"void AICast_ScriptParse( cast_state_t *cs ) {
gentity_t   *ent;
char        *pScript;
char        *token;
qboolean wantName;
qboolean inScript;
int eventNum;
int numEventItems;
cast_script_event_t *curEvent;
char params[MAX_QPATH];
cast_script_stack_action_t  *action;
int i;
int bracketLevel;
qboolean buildScript;       
if ( !level.scriptAI ) {
return;
}
ent = &g_entities[cs->entityNum];
if ( !ent->aiName ) {
return;
}
buildScript = qtrue;
pScript = level.scriptAI;
wantName = qtrue;
inScript = qfalse;
COM_BeginParseSession( ""AICast_ScriptParse"" );
bracketLevel = 0;
numEventItems = 0;
memset( cast_temp_events, 0, sizeof( cast_temp_events ) );
while ( 1 )
{
token = COM_Parse( &pScript );
if ( !token[0] ) {
if ( !wantName ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
break;
}
if ( token[0] == '}' ) {
if ( inScript ) {
break;
}
if ( wantName ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\n"", COM_GetCurrentParseLine() );
}
wantName = qtrue;
} else if ( token[0] == '{' )    {
if ( wantName ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\n"", COM_GetCurrentParseLine() );
}
} else if ( wantName )   {
if ( !Q_strcasecmp( ent->aiName, token ) ) {
inScript = qtrue;
numEventItems = 0;
}
wantName = qfalse;
} else if ( inScript )   {
if ( !Q_strcasecmp( token, ""attributes"" ) ) {
AICast_CheckLevelAttributes( cs, ent, &pScript );
continue;
}
eventNum = AICast_EventForString( token );
if ( eventNum < 0 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown event: %s.\n"", COM_GetCurrentParseLine(), token );
}
if ( numEventItems >= MAX_SCRIPT_EVENTS ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\n"", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );
}
if ( !Q_stricmp( token, ""friendlysightcorpse"" ) ) {
cs->aiFlags &= ~AIFL_CORPSESIGHTING;
}
curEvent = &cast_temp_events[numEventItems];
curEvent->eventNum = eventNum;
memset( params, 0, sizeof( params ) );
while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )
{
if ( !token[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
if ( eventNum == 13 ) {   if ( strlen( token ) > 1 ) {
if ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\n"", COM_GetCurrentParseLine(), token );
}
}
}
if ( strlen( params ) ) { Q_strcat( params, sizeof( params ), "" "" );
}
Q_strcat( params, sizeof( params ), token );
}
if ( strlen( params ) ) { curEvent->params = G_Alloc( strlen( params ) + 1 );
Q_strncpyz( curEvent->params, params, strlen( params ) + 1 );
}
while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )
{
if ( !token[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
action = AICast_ActionForString( cs, token );
if ( !action ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown action: %s.\n"", COM_GetCurrentParseLine(), token );
}
curEvent->stack.items[curEvent->stack.numItems].action = action;
memset( params, 0, sizeof( params ) );
token = COM_ParseExt( &pScript, qfalse );
for ( i = 0; token[0]; i++ )
{
if ( strlen( params ) ) { Q_strcat( params, sizeof( params ), "" "" );
}
if ( i == 0 ) {
if ( !Q_stricmp( action->actionString, ""playsound"" ) ) {
G_SoundIndex( token );
}
if (    buildScript && (
!Q_stricmp( action->actionString, ""mu_start"" ) ||
!Q_stricmp( action->actionString, ""mu_play"" ) ||
!Q_stricmp( action->actionString, ""mu_queue"" ) ||
!Q_stricmp( action->actionString, ""startcam"" ) ||
!Q_stricmp( action->actionString, ""startcamblack"" ) )
) {
if ( strlen( token ) ) { trap_SendServerCommand( cs->entityNum, va( ""addToBuild %s\n"", token ) );
}
}
if ( !Q_stricmp( action->actionString, ""giveweapon"" ) ) { gitem_t *weap = BG_FindItem2( token );    RegisterItem( weap );   }
if ( !Q_stricmp( action->actionString, ""changelevel"" ) ) {
Q_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );
trap_Cvar_Set( ""nextmap"", level.nextMap );
}
}
if ( strrchr( token,' ' ) ) { Q_strcat( params, sizeof( params ), ""\"""" );
}
Q_strcat( params, sizeof( params ), token );
if ( strrchr( token,' ' ) ) { Q_strcat( params, sizeof( params ), ""\"""" );
}
token = COM_ParseExt( &pScript, qfalse );
}
if ( strlen( params ) ) { curEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );
Q_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );
}
curEvent->stack.numItems++;
if ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {
G_Error( ""AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\n"", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );
}
}
numEventItems++;
} else    {
while ( ( token = COM_Parse( &pScript ) ) )
{
if ( !token[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
} else if ( token[0] == '{' ) {
bracketLevel++;
} else if ( token[0] == '}' ) {
if ( !--bracketLevel ) {
break;
}
}
}
}
}
if ( numEventItems > 0 ) {
cs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );
memcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );
cs->numCastScriptEvents = numEventItems;
cs->castScriptStatus.castScriptEventIndex = -1;
}
}","void AICast_ScriptParse( cast_state_t *VAR_0 ) {
gentity_t   *VAR_1;
char        *VAR_2;
char        *VAR_3;
qboolean VAR_4;
qboolean VAR_5;
int VAR_6;
int VAR_7;
cast_script_event_t *VAR_8;
char VAR_9[VAR_10];
cast_script_stack_action_t  *VAR_11;
int VAR_12;
int VAR_13;
qboolean VAR_14;       
if ( !VAR_15.scriptAI ) {
return;
}
VAR_1 = &VAR_16[VAR_0->entityNum];
if ( !VAR_1->aiName ) {
return;
}
VAR_14 = VAR_17;
VAR_2 = VAR_15.scriptAI;
VAR_4 = VAR_17;
VAR_5 = VAR_18;
COM_BeginParseSession( ""AICast_ScriptParse"" );
VAR_13 = 0;
VAR_7 = 0;
memset( VAR_19, 0, sizeof( VAR_19 ) );
while ( 1 )
{
VAR_3 = COM_Parse( &VAR_2 );
if ( !VAR_3[0] ) {
if ( !VAR_4 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
break;
}
if ( VAR_3[0] == '}' ) {
if ( VAR_5 ) {
break;
}
if ( VAR_4 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\n"", COM_GetCurrentParseLine() );
}
VAR_4 = VAR_17;
} else if ( VAR_3[0] == '{' )    {
if ( VAR_4 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\n"", COM_GetCurrentParseLine() );
}
} else if ( VAR_4 )   {
if ( !Q_strcasecmp( VAR_1->aiName, VAR_3 ) ) {
VAR_5 = VAR_17;
VAR_7 = 0;
}
VAR_4 = VAR_18;
} else if ( VAR_5 )   {
if ( !Q_strcasecmp( VAR_3, ""attributes"" ) ) {
AICast_CheckLevelAttributes( VAR_0, VAR_1, &VAR_2 );
continue;
}
VAR_6 = AICast_EventForString( VAR_3 );
if ( VAR_6 < 0 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown event: %s.\n"", COM_GetCurrentParseLine(), VAR_3 );
}
if ( VAR_7 >= VAR_20 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\n"", COM_GetCurrentParseLine(), VAR_20 );
}
if ( !Q_stricmp( VAR_3, ""friendlysightcorpse"" ) ) {
VAR_0->aiFlags &= ~VAR_21;
}
VAR_8 = &VAR_19[VAR_7];
VAR_8->eventNum = VAR_6;
memset( VAR_9, 0, sizeof( VAR_9 ) );
while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) && ( VAR_3[0] != '{' ) )
{
if ( !VAR_3[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
if ( VAR_6 == 13 ) {   
if ( strlen( VAR_3 ) > 1 ) {
if ( BG_IndexForString( VAR_3, VAR_22, VAR_17 ) < 0 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\n"", COM_GetCurrentParseLine(), VAR_3 );
}
}
}
if ( strlen( VAR_9 ) ) { 
Q_strcat( VAR_9, sizeof( VAR_9 ), "" "" );
}
Q_strcat( VAR_9, sizeof( VAR_9 ), VAR_3 );
}
if ( strlen( VAR_9 ) ) { 
VAR_8->params = G_Alloc( strlen( VAR_9 ) + 1 );
Q_strncpyz( VAR_8->params, VAR_9, strlen( VAR_9 ) + 1 );
}
while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) && ( VAR_3[0] != '}' ) )
{
if ( !VAR_3[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
}
VAR_11 = AICast_ActionForString( VAR_0, VAR_3 );
if ( !VAR_11 ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): unknown action: %s.\n"", COM_GetCurrentParseLine(), VAR_3 );
}
VAR_8->stack.items[VAR_8->stack.numItems].action = VAR_11;
memset( VAR_9, 0, sizeof( VAR_9 ) );
VAR_3 = COM_ParseExt( &VAR_2, VAR_18 );
for ( VAR_12 = 0; VAR_3[0]; VAR_12++ )
{
if ( strlen( VAR_9 ) ) { 
Q_strcat( VAR_9, sizeof( VAR_9 ), "" "" );
}
if ( VAR_12 == 0 ) {
if ( !Q_stricmp( VAR_11->actionString, ""playsound"" ) ) {
G_SoundIndex( VAR_3 );
}
if (    VAR_14 && (
!Q_stricmp( VAR_11->actionString, ""mu_start"" ) ||
!Q_stricmp( VAR_11->actionString, ""mu_play"" ) ||
!Q_stricmp( VAR_11->actionString, ""mu_queue"" ) ||
!Q_stricmp( VAR_11->actionString, ""startcam"" ) ||
!Q_stricmp( VAR_11->actionString, ""startcamblack"" ) )
) {
if ( strlen( VAR_3 ) ) { 
trap_SendServerCommand( VAR_0->entityNum, va( ""addToBuild %s\n"", VAR_3 ) );
}
}
if ( !Q_stricmp( VAR_11->actionString, ""giveweapon"" ) ) { 
gitem_t *VAR_23 = BG_FindItem2( VAR_3 );    
RegisterItem( VAR_23 );   
}
if ( !Q_stricmp( VAR_11->actionString, ""changelevel"" ) ) {
Q_strncpyz( VAR_15.nextMap, VAR_3, sizeof( VAR_15.nextMap ) );
trap_Cvar_Set( ""nextmap"", VAR_15.nextMap );
}
}
if ( strrchr( VAR_3,' ' ) ) { 
Q_strcat( VAR_9, sizeof( VAR_9 ), ""\"""" );
}
Q_strcat( VAR_9, sizeof( VAR_9 ), VAR_3 );
if ( strrchr( VAR_3,' ' ) ) { 
Q_strcat( VAR_9, sizeof( VAR_9 ), ""\"""" );
}
VAR_3 = COM_ParseExt( &VAR_2, VAR_18 );
}
if ( strlen( VAR_9 ) ) { 
VAR_8->stack.items[VAR_8->stack.numItems].params = G_Alloc( strlen( VAR_9 ) + 1 );
Q_strncpyz( VAR_8->stack.items[VAR_8->stack.numItems].params, VAR_9, strlen( VAR_9 ) + 1 );
}
VAR_8->stack.numItems++;
if ( VAR_8->stack.numItems >= VAR_24 ) {
G_Error( ""AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\n"", VAR_24, COM_GetCurrentParseLine() );
}
}
VAR_7++;
} else    
{
while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) )
{
if ( !VAR_3[0] ) {
G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
} else if ( VAR_3[0] == '{' ) {
VAR_13++;
} else if ( VAR_3[0] == '}' ) {
if ( !--VAR_13 ) {
break;
}
}
}
}
}
if ( VAR_7 > 0 ) {
VAR_0->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * VAR_7 );
memcpy( VAR_0->castScriptEvents, VAR_19, sizeof( cast_script_event_t ) * VAR_7 );
VAR_0->numCastScriptEvents = VAR_7;
VAR_0->castScriptStatus.castScriptEventIndex = -1;
}
}",rtcwcoop/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac/ai_cast_script.c/vul/before/0.json,"void AICast_ScriptParse( cast_state_t *cs ) {
	gentity_t   *ent;
	char        *pScript;
	char        *token;
	qboolean wantName;
	qboolean inScript;
	int eventNum;
	int numEventItems;
	cast_script_event_t *curEvent;
	char params[MAX_QPATH];
	cast_script_stack_action_t  *action;
	int i;
	int bracketLevel;
	qboolean buildScript;       //----(SA)	added

	if ( !level.scriptAI ) {
		return;
	}

	ent = &g_entities[cs->entityNum];
	if ( !ent->aiName ) {
		return;
	}

	buildScript = qtrue;

	pScript = level.scriptAI;
	wantName = qtrue;
	inScript = qfalse;
	COM_BeginParseSession( ""AICast_ScriptParse"" );
	bracketLevel = 0;
	numEventItems = 0;

	memset( cast_temp_events, 0, sizeof( cast_temp_events ) );

	while ( 1 )
	{
		token = COM_Parse( &pScript );

		if ( !token[0] ) {
			if ( !wantName ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
			}
			break;
		}

		// end of script
		if ( token[0] == '}' ) {
			if ( inScript ) {
				break;
			}
			if ( wantName ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\n"", COM_GetCurrentParseLine() );
			}
			wantName = qtrue;
		} else if ( token[0] == '{' )    {
			if ( wantName ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\n"", COM_GetCurrentParseLine() );
			}
		} else if ( wantName )   {
			if ( !Q_strcasecmp( ent->aiName, token ) ) {
				inScript = qtrue;
				numEventItems = 0;
			}
			wantName = qfalse;
		} else if ( inScript )   {
			if ( !Q_strcasecmp( token, ""attributes"" ) ) {
				// read in all the attributes
				AICast_CheckLevelAttributes( cs, ent, &pScript );
				continue;
			}
			eventNum = AICast_EventForString( token );
			if ( eventNum < 0 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): unknown event: %s.\n"", COM_GetCurrentParseLine(), token );
			}
			if ( numEventItems >= MAX_SCRIPT_EVENTS ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\n"", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );
			}

			// if this is a ""friendlysightcorpse"" event, then disable corpse vis sharing
			if ( !Q_stricmp( token, ""friendlysightcorpse"" ) ) {
				cs->aiFlags &= ~AIFL_CORPSESIGHTING;
			}

			curEvent = &cast_temp_events[numEventItems];
			curEvent->eventNum = eventNum;
			memset( params, 0, sizeof( params ) );

			// parse any event params before the start of this event's actions
			while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )
			{
				if ( !token[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				}

				if ( eventNum == 13 ) {   // statechange event, check params
					if ( strlen( token ) > 1 ) {
						if ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {
							G_Error( ""AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\n"", COM_GetCurrentParseLine(), token );
						}
					}
				}

				if ( strlen( params ) ) { // add a space between each param
					Q_strcat( params, sizeof( params ), "" "" );
				}
				Q_strcat( params, sizeof( params ), token );
			}

			if ( strlen( params ) ) { // copy the params into the event
				curEvent->params = trap_Alloc( strlen( params ) + 1 );
				Q_strncpyz( curEvent->params, params, strlen( params ) + 1 );
			}

			// parse the actions for this event
			while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )
			{
				if ( !token[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				}

				action = AICast_ActionForString( cs, token );
				if ( !action ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): unknown action: %s.\n"", COM_GetCurrentParseLine(), token );
				}

				curEvent->stack.items[curEvent->stack.numItems].action = action;

				memset( params, 0, sizeof( params ) );
				token = COM_ParseExt( &pScript, qfalse );
				for ( i = 0; token[0]; i++ )
				{
					if ( strlen( params ) ) { // add a space between each param
						Q_strcat( params, sizeof( params ), "" "" );
					}

					if ( i == 0 ) {
						// Special case: playsound's need to be cached on startup to prevent in-game pauses
						if ( !Q_stricmp( action->actionString, ""playsound"" ) ) {
							G_SoundIndex( token );
						}

//----(SA)	added a bit more
						if (    buildScript && (
									!Q_stricmp( action->actionString, ""mu_start"" ) ||
									!Q_stricmp( action->actionString, ""mu_play"" ) ||
									!Q_stricmp( action->actionString, ""mu_queue"" ) ||
									!Q_stricmp( action->actionString, ""startcam"" ) ||
									!Q_stricmp( action->actionString, ""startcamblack"" ) )
								) {
							if ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'
								trap_SendServerCommand( cs->entityNum, va( ""addToBuild %s\n"", token ) );
							}
						}

						if ( !Q_stricmp( action->actionString, ""giveweapon"" ) ) { // register weapon for client pre-loading
							gitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'
//							if(weap)
							RegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu
						}

						// need to get this for callvote nextmap
						if ( !Q_stricmp( action->actionString, ""changelevel"" ) ) {
							Q_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );
							trap_Cvar_Set( ""nextmap"", level.nextMap );
						}
//----(SA)	end
					}

					if ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word
						Q_strcat( params, sizeof( params ), ""\"""" );
					}

					Q_strcat( params, sizeof( params ), token );

					if ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word
						Q_strcat( params, sizeof( params ), ""\"""" );
					}

					token = COM_ParseExt( &pScript, qfalse );
				}

				if ( strlen( params ) ) { // copy the params into the event
					curEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );
					Q_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );
				}

				curEvent->stack.numItems++;

				if ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {
					G_Error( ""AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\n"", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );
				}
			}

			numEventItems++;
		} else    // skip this character completely
		{

			while ( ( token = COM_Parse( &pScript ) ) )
			{
				if ( !token[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				} else if ( token[0] == '{' ) {
					bracketLevel++;
				} else if ( token[0] == '}' ) {
					if ( !--bracketLevel ) {
						break;
					}
				}
			}
		}
	}

	// alloc and copy the events into the cast_state_t for this cast
	if ( numEventItems > 0 ) {
		cs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );
		memcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );
		cs->numCastScriptEvents = numEventItems;

		cs->castScriptStatus.castScriptEventIndex = -1;
	}
}","void AICast_ScriptParse( cast_state_t *VAR_0 ) {
	gentity_t   *VAR_1;
	char        *VAR_2;
	char        *VAR_3;
	qboolean VAR_4;
	qboolean VAR_5;
	int VAR_6;
	int VAR_7;
	cast_script_event_t *VAR_8;
	char VAR_9[VAR_10];
	cast_script_stack_action_t  *VAR_11;
	int VAR_12;
	int VAR_13;
	qboolean VAR_14;       /* COMMENT_0 */

	if ( !VAR_15.scriptAI ) {
		return;
	}

	VAR_1 = &VAR_16[VAR_0->entityNum];
	if ( !VAR_1->aiName ) {
		return;
	}

	VAR_14 = VAR_17;

	VAR_2 = VAR_15.scriptAI;
	VAR_4 = VAR_17;
	VAR_5 = VAR_18;
	COM_BeginParseSession( ""AICast_ScriptParse"" );
	VAR_13 = 0;
	VAR_7 = 0;

	memset( VAR_19, 0, sizeof( VAR_19 ) );

	while ( 1 )
	{
		VAR_3 = COM_Parse( &VAR_2 );

		if ( !VAR_3[0] ) {
			if ( !VAR_4 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
			}
			break;
		}

		/* COMMENT_1 */
		if ( VAR_3[0] == '}' ) {
			if ( VAR_5 ) {
				break;
			}
			if ( VAR_4 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\n"", COM_GetCurrentParseLine() );
			}
			VAR_4 = VAR_17;
		} else if ( VAR_3[0] == '{' )    {
			if ( VAR_4 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\n"", COM_GetCurrentParseLine() );
			}
		} else if ( VAR_4 )   {
			if ( !Q_strcasecmp( VAR_1->aiName, VAR_3 ) ) {
				VAR_5 = VAR_17;
				VAR_7 = 0;
			}
			VAR_4 = VAR_18;
		} else if ( VAR_5 )   {
			if ( !Q_strcasecmp( VAR_3, ""attributes"" ) ) {
				/* COMMENT_2 */
				AICast_CheckLevelAttributes( VAR_0, VAR_1, &VAR_2 );
				continue;
			}
			VAR_6 = AICast_EventForString( VAR_3 );
			if ( VAR_6 < 0 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): unknown event: %s.\n"", COM_GetCurrentParseLine(), VAR_3 );
			}
			if ( VAR_7 >= VAR_20 ) {
				G_Error( ""AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\n"", COM_GetCurrentParseLine(), VAR_20 );
			}

			/* COMMENT_3 */
			if ( !Q_stricmp( VAR_3, ""friendlysightcorpse"" ) ) {
				VAR_0->aiFlags &= ~VAR_21;
			}

			VAR_8 = &VAR_19[VAR_7];
			VAR_8->eventNum = VAR_6;
			memset( VAR_9, 0, sizeof( VAR_9 ) );

			/* COMMENT_4 */
			while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) && ( VAR_3[0] != '{' ) )
			{
				if ( !VAR_3[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				}

				if ( VAR_6 == 13 ) {   /* COMMENT_5 */
					if ( strlen( VAR_3 ) > 1 ) {
						if ( BG_IndexForString( VAR_3, VAR_22, VAR_17 ) < 0 ) {
							G_Error( ""AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\n"", COM_GetCurrentParseLine(), VAR_3 );
						}
					}
				}

				if ( strlen( VAR_9 ) ) { /* COMMENT_6 */
					Q_strcat( VAR_9, sizeof( VAR_9 ), "" "" );
				}
				Q_strcat( VAR_9, sizeof( VAR_9 ), VAR_3 );
			}

			if ( strlen( VAR_9 ) ) { /* COMMENT_7 */
				VAR_8->params = trap_Alloc( strlen( VAR_9 ) + 1 );
				Q_strncpyz( VAR_8->params, VAR_9, strlen( VAR_9 ) + 1 );
			}

			/* COMMENT_8 */
			while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) && ( VAR_3[0] != '}' ) )
			{
				if ( !VAR_3[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				}

				VAR_11 = AICast_ActionForString( VAR_0, VAR_3 );
				if ( !VAR_11 ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): unknown action: %s.\n"", COM_GetCurrentParseLine(), VAR_3 );
				}

				VAR_8->stack.items[VAR_8->stack.numItems].action = VAR_11;

				memset( VAR_9, 0, sizeof( VAR_9 ) );
				VAR_3 = COM_ParseExt( &VAR_2, VAR_18 );
				for ( VAR_12 = 0; VAR_3[0]; VAR_12++ )
				{
					if ( strlen( VAR_9 ) ) { /* COMMENT_6 */
						Q_strcat( VAR_9, sizeof( VAR_9 ), "" "" );
					}

					if ( VAR_12 == 0 ) {
						/* COMMENT_9 */
						if ( !Q_stricmp( VAR_11->actionString, ""playsound"" ) ) {
							G_SoundIndex( VAR_3 );
						}

/* COMMENT_10 */
						if (    VAR_14 && (
									!Q_stricmp( VAR_11->actionString, ""mu_start"" ) ||
									!Q_stricmp( VAR_11->actionString, ""mu_play"" ) ||
									!Q_stricmp( VAR_11->actionString, ""mu_queue"" ) ||
									!Q_stricmp( VAR_11->actionString, ""startcam"" ) ||
									!Q_stricmp( VAR_11->actionString, ""startcamblack"" ) )
								) {
							if ( strlen( VAR_3 ) ) { /* COMMENT_11 */
								trap_SendServerCommand( VAR_0->entityNum, va( ""addToBuild %s\n"", VAR_3 ) );
							}
						}

						if ( !Q_stricmp( VAR_11->actionString, ""giveweapon"" ) ) { /* COMMENT_12 */
							gitem_t *VAR_23 = BG_FindItem2( VAR_3 );    /* COMMENT_13 */
/* COMMENT_14 */
							RegisterItem( VAR_23 );   /* COMMENT_15 */
						}

						/* COMMENT_16 */
						if ( !Q_stricmp( VAR_11->actionString, ""changelevel"" ) ) {
							Q_strncpyz( VAR_15.nextMap, VAR_3, sizeof( VAR_15.nextMap ) );
							trap_Cvar_Set( ""nextmap"", VAR_15.nextMap );
						}
/* COMMENT_17 */
					}

					if ( strrchr( VAR_3,' ' ) ) { /* COMMENT_18 */
						Q_strcat( VAR_9, sizeof( VAR_9 ), ""\"""" );
					}

					Q_strcat( VAR_9, sizeof( VAR_9 ), VAR_3 );

					if ( strrchr( VAR_3,' ' ) ) { /* COMMENT_18 */
						Q_strcat( VAR_9, sizeof( VAR_9 ), ""\"""" );
					}

					VAR_3 = COM_ParseExt( &VAR_2, VAR_18 );
				}

				if ( strlen( VAR_9 ) ) { /* COMMENT_7 */
					VAR_8->stack.items[VAR_8->stack.numItems].params = trap_Alloc( strlen( VAR_9 ) + 1 );
					Q_strncpyz( VAR_8->stack.items[VAR_8->stack.numItems].params, VAR_9, strlen( VAR_9 ) + 1 );
				}

				VAR_8->stack.numItems++;

				if ( VAR_8->stack.numItems >= VAR_24 ) {
					G_Error( ""AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\n"", VAR_24, COM_GetCurrentParseLine() );
				}
			}

			VAR_7++;
		} else    /* COMMENT_19 */
		{

			while ( ( VAR_3 = COM_Parse( &VAR_2 ) ) )
			{
				if ( !VAR_3[0] ) {
					G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() );
				} else if ( VAR_3[0] == '{' ) {
					VAR_13++;
				} else if ( VAR_3[0] == '}' ) {
					if ( !--VAR_13 ) {
						break;
					}
				}
			}
		}
	}

	/* COMMENT_20 */
	if ( VAR_7 > 0 ) {
		VAR_0->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * VAR_7 );
		memcpy( VAR_0->castScriptEvents, VAR_19, sizeof( cast_script_event_t ) * VAR_7 );
		VAR_0->numCastScriptEvents = VAR_7;

		VAR_0->castScriptStatus.castScriptEventIndex = -1;
	}
}",rtcwcoop/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac/ai_cast_script.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -108,7 +108,7 @@
 			}
 
 			if ( strlen( params ) ) { // copy the params into the event
-				curEvent->params = G_Alloc( strlen( params ) + 1 );
+				curEvent->params = trap_Alloc( strlen( params ) + 1 );
 				Q_strncpyz( curEvent->params, params, strlen( params ) + 1 );
 			}
 
@@ -181,7 +181,7 @@
 				}
 
 				if ( strlen( params ) ) { // copy the params into the event
-					curEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );
+					curEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );
 					Q_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );
 				}
 
@@ -213,7 +213,7 @@
 
 	// alloc and copy the events into the cast_state_t for this cast
 	if ( numEventItems > 0 ) {
-		cs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );
+		cs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );
 		memcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );
 		cs->numCastScriptEvents = numEventItems;
 ","{'deleted_lines': ['\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );', '\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );', '\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );'], 'added_lines': ['\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );', '\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );', '\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );']}",True,A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.,7.5,HIGH,2,valid,2019-05-27T15:59:38Z,2
CVE-2020-19609,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/mupdf,Bug 701176: Handle TIFFs with alpha that have more than 8 bits per sample.,b7892cdc7fae62aa57d63ae62144e1f11b5f9275,https://github.com/ArtifexSoftware/mupdf/commit/b7892cdc7fae62aa57d63ae62144e1f11b5f9275,source/fitz/load-tiff.c,tiff_expand_colormap,"static void
tiff_expand_colormap(fz_context *ctx, struct tiff *tiff)
{
int maxval = 1 << tiff->bitspersample;
unsigned char *samples;
unsigned char *src, *dst;
unsigned int x, y;
unsigned int stride;
if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2)
fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of samples for RGBPal"");
if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16)
fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of bits for RGBPal"");
if (tiff->colormaplen < (unsigned)maxval * 3)
fz_throw(ctx, FZ_ERROR_GENERIC, ""insufficient colormap data"");
if (tiff->imagelength > UINT_MAX / tiff->imagewidth / (tiff->samplesperpixel + 2))
fz_throw(ctx, FZ_ERROR_GENERIC, ""image too large"");
stride = tiff->imagewidth * (tiff->samplesperpixel + 2);
samples = fz_malloc(ctx, stride * tiff->imagelength);
for (y = 0; y < tiff->imagelength; y++)
{
src = tiff->samples + (unsigned int)(tiff->stride * y);
dst = samples + (unsigned int)(stride * y);
for (x = 0; x < tiff->imagewidth; x++)
{
if (tiff->extrasamples)
{
int c = tiff_getcomp(src, x * 2, tiff->bitspersample);
int a = tiff_getcomp(src, x * 2 + 1, tiff->bitspersample);
*dst++ = tiff->colormap[c + 0] >> 8;
*dst++ = tiff->colormap[c + maxval] >> 8;
*dst++ = tiff->colormap[c + maxval * 2] >> 8;
*dst++ = a << (8 - tiff->bitspersample);
}
else
{
int c = tiff_getcomp(src, x, tiff->bitspersample);
*dst++ = tiff->colormap[c + 0] >> 8;
*dst++ = tiff->colormap[c + maxval] >> 8;
*dst++ = tiff->colormap[c + maxval * 2] >> 8;
}
}
}
tiff->samplesperpixel += 2;
tiff->bitspersample = 8;
tiff->stride = stride;
fz_free(ctx, tiff->samples);
tiff->samples = samples;
}","static void
tiff_expand_colormap(fz_context *VAR_0, struct tiff *tiff)
{
int VAR_1 = 1 << tiff->bitspersample;
unsigned char *VAR_2;
unsigned char *VAR_3, *VAR_4;
unsigned int VAR_5, VAR_6;
unsigned int VAR_7;
if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2)
fz_throw(VAR_0, VAR_8, ""invalid number of samples for RGBPal"");
if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16)
fz_throw(VAR_0, VAR_8, ""invalid number of bits for RGBPal"");
if (tiff->colormaplen < (unsigned)VAR_1 * 3)
fz_throw(VAR_0, VAR_8, ""insufficient colormap data"");
if (tiff->imagelength > VAR_9 / tiff->imagewidth / (tiff->samplesperpixel + 2))
fz_throw(VAR_0, VAR_8, ""image too large"");
VAR_7 = tiff->imagewidth * (tiff->samplesperpixel + 2);
VAR_2 = fz_malloc(VAR_0, VAR_7 * tiff->imagelength);
for (VAR_6 = 0; VAR_6 < tiff->imagelength; VAR_6++)
{
VAR_3 = tiff->samples + (unsigned int)(tiff->stride * VAR_6);
VAR_4 = VAR_2 + (unsigned int)(VAR_7 * VAR_6);
for (VAR_5 = 0; VAR_5 < tiff->imagewidth; VAR_5++)
{
if (tiff->extrasamples)
{
int VAR_10 = tiff_getcomp(VAR_3, VAR_5 * 2, tiff->bitspersample);
int VAR_11 = tiff_getcomp(VAR_3, VAR_5 * 2 + 1, tiff->bitspersample);
*VAR_4++ = tiff->colormap[VAR_10 + 0] >> 8;
*VAR_4++ = tiff->colormap[VAR_10 + VAR_1] >> 8;
*VAR_4++ = tiff->colormap[VAR_10 + VAR_1 * 2] >> 8;
*VAR_4++ = VAR_11 << (8 - tiff->bitspersample);
}
else
{
int VAR_10 = tiff_getcomp(VAR_3, VAR_5, tiff->bitspersample);
*VAR_4++ = tiff->colormap[VAR_10 + 0] >> 8;
*VAR_4++ = tiff->colormap[VAR_10 + VAR_1] >> 8;
*VAR_4++ = tiff->colormap[VAR_10 + VAR_1 * 2] >> 8;
}
}
}
tiff->samplesperpixel += 2;
tiff->bitspersample = 8;
tiff->stride = VAR_7;
fz_free(VAR_0, tiff->samples);
tiff->samples = VAR_2;
}",ArtifexSoftware/mupdf/b7892cdc7fae62aa57d63ae62144e1f11b5f9275/load-tiff.c/vul/before/0.json,"static void
tiff_expand_colormap(fz_context *ctx, struct tiff *tiff)
{
	int maxval = 1 << tiff->bitspersample;
	unsigned char *samples;
	unsigned char *src, *dst;
	unsigned int x, y;
	unsigned int stride;

	/* colormap has first all red, then all green, then all blue values */
	/* colormap values are 0..65535, bits is 4 or 8 */
	/* image can be with or without extrasamples: comps is 1 or 2 */

	if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of samples for RGBPal"");

	if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of bits for RGBPal"");

	if (tiff->colormaplen < (unsigned)maxval * 3)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""insufficient colormap data"");

	if (tiff->imagelength > UINT_MAX / tiff->imagewidth / (tiff->samplesperpixel + 2))
		fz_throw(ctx, FZ_ERROR_GENERIC, ""image too large"");

	stride = tiff->imagewidth * (tiff->samplesperpixel + 2);

	samples = fz_malloc(ctx, stride * tiff->imagelength);

	for (y = 0; y < tiff->imagelength; y++)
	{
		src = tiff->samples + (unsigned int)(tiff->stride * y);
		dst = samples + (unsigned int)(stride * y);

		for (x = 0; x < tiff->imagewidth; x++)
		{
			if (tiff->extrasamples)
			{
				int c = tiff_getcomp(src, x * 2, tiff->bitspersample);
				int a = tiff_getcomp(src, x * 2 + 1, tiff->bitspersample);
				*dst++ = tiff->colormap[c + 0] >> 8;
				*dst++ = tiff->colormap[c + maxval] >> 8;
				*dst++ = tiff->colormap[c + maxval * 2] >> 8;
				if (tiff->bitspersample <= 8)
					*dst++ = a << (8 - tiff->bitspersample);
				else
					*dst++ = a >> (tiff->bitspersample - 8);
			}
			else
			{
				int c = tiff_getcomp(src, x, tiff->bitspersample);
				*dst++ = tiff->colormap[c + 0] >> 8;
				*dst++ = tiff->colormap[c + maxval] >> 8;
				*dst++ = tiff->colormap[c + maxval * 2] >> 8;
			}
		}
	}

	tiff->samplesperpixel += 2;
	tiff->bitspersample = 8;
	tiff->stride = stride;
	fz_free(ctx, tiff->samples);
	tiff->samples = samples;
}","static void
tiff_expand_colormap(fz_context *VAR_0, struct tiff *tiff)
{
	int VAR_1 = 1 << tiff->bitspersample;
	unsigned char *VAR_2;
	unsigned char *VAR_3, *VAR_4;
	unsigned int VAR_5, VAR_6;
	unsigned int VAR_7;

	/* COMMENT_0 */
	/* COMMENT_1 */
	/* COMMENT_2 */

	if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2)
		fz_throw(VAR_0, VAR_8, ""invalid number of samples for RGBPal"");

	if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16)
		fz_throw(VAR_0, VAR_8, ""invalid number of bits for RGBPal"");

	if (tiff->colormaplen < (unsigned)VAR_1 * 3)
		fz_throw(VAR_0, VAR_8, ""insufficient colormap data"");

	if (tiff->imagelength > VAR_9 / tiff->imagewidth / (tiff->samplesperpixel + 2))
		fz_throw(VAR_0, VAR_8, ""image too large"");

	VAR_7 = tiff->imagewidth * (tiff->samplesperpixel + 2);

	VAR_2 = fz_malloc(VAR_0, VAR_7 * tiff->imagelength);

	for (VAR_6 = 0; VAR_6 < tiff->imagelength; VAR_6++)
	{
		VAR_3 = tiff->samples + (unsigned int)(tiff->stride * VAR_6);
		VAR_4 = VAR_2 + (unsigned int)(VAR_7 * VAR_6);

		for (VAR_5 = 0; VAR_5 < tiff->imagewidth; VAR_5++)
		{
			if (tiff->extrasamples)
			{
				int VAR_10 = tiff_getcomp(VAR_3, VAR_5 * 2, tiff->bitspersample);
				int VAR_11 = tiff_getcomp(VAR_3, VAR_5 * 2 + 1, tiff->bitspersample);
				*VAR_4++ = tiff->colormap[VAR_10 + 0] >> 8;
				*VAR_4++ = tiff->colormap[VAR_10 + VAR_1] >> 8;
				*VAR_4++ = tiff->colormap[VAR_10 + VAR_1 * 2] >> 8;
				if (tiff->bitspersample <= 8)
					*VAR_4++ = VAR_11 << (8 - tiff->bitspersample);
				else
					*VAR_4++ = VAR_11 >> (tiff->bitspersample - 8);
			}
			else
			{
				int VAR_10 = tiff_getcomp(VAR_3, VAR_5, tiff->bitspersample);
				*VAR_4++ = tiff->colormap[VAR_10 + 0] >> 8;
				*VAR_4++ = tiff->colormap[VAR_10 + VAR_1] >> 8;
				*VAR_4++ = tiff->colormap[VAR_10 + VAR_1 * 2] >> 8;
			}
		}
	}

	tiff->samplesperpixel += 2;
	tiff->bitspersample = 8;
	tiff->stride = VAR_7;
	fz_free(VAR_0, tiff->samples);
	tiff->samples = VAR_2;
}",ArtifexSoftware/mupdf/b7892cdc7fae62aa57d63ae62144e1f11b5f9275/load-tiff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,7 +41,10 @@
 				*dst++ = tiff->colormap[c + 0] >> 8;
 				*dst++ = tiff->colormap[c + maxval] >> 8;
 				*dst++ = tiff->colormap[c + maxval * 2] >> 8;
-				*dst++ = a << (8 - tiff->bitspersample);
+				if (tiff->bitspersample <= 8)
+					*dst++ = a << (8 - tiff->bitspersample);
+				else
+					*dst++ = a >> (tiff->bitspersample - 8);
 			}
 			else
 			{","{'deleted_lines': ['\t\t\t\t*dst++ = a << (8 - tiff->bitspersample);'], 'added_lines': ['\t\t\t\tif (tiff->bitspersample <= 8)', '\t\t\t\t\t*dst++ = a << (8 - tiff->bitspersample);', '\t\t\t\telse', '\t\t\t\t\t*dst++ = a >> (tiff->bitspersample - 8);']}",True,Artifex MuPDF before 1.18.0 has a heap based buffer over-write in tiff_expand_colormap() function when parsing TIFF files allowing attackers to cause a denial of service.,5.5,MEDIUM,1,valid,2019-06-10T11:58:28Z,2
CVE-2019-15296,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,knik0/faad2,"Fix a couple buffer overflows

https://hackerone.com/reports/502816
https://hackerone.com/reports/507858

https://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-overflows.patch",942c3e0aee748ea6fe97cb2c1aa5893225316174,https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174,libfaad/syntax.c,excluded_channels,"static uint8_t excluded_channels(bitfile *ld, drc_info *drc)
{
uint8_t i, n = 0;
uint8_t num_excl_chan = 7;
for (i = 0; i < 7; i++)
{
drc->exclude_mask[i] = faad_get1bit(ld
DEBUGVAR(1,103,""excluded_channels(): exclude_mask""));
}
n++;
while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld
DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
{
for (i = num_excl_chan; i < num_excl_chan+7; i++)
{
drc->exclude_mask[i] = faad_get1bit(ld
DEBUGVAR(1,105,""excluded_channels(): exclude_mask""));
}
n++;
num_excl_chan += 7;
}
return n;
}","static uint8_t excluded_channels(bitfile *VAR_0, drc_info *VAR_1)
{
uint8_t VAR_2, VAR_3 = 0;
uint8_t VAR_4 = 7;
for (VAR_2 = 0; VAR_2 < 7; VAR_2++)
{
VAR_1->exclude_mask[VAR_2] = faad_get1bit(VAR_0
DEBUGVAR(1,103,""excluded_channels(): exclude_mask""));
}
VAR_3++;
while ((VAR_1->additional_excluded_chns[VAR_3-1] = faad_get1bit(VAR_0
DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
{
for (VAR_2 = VAR_4; VAR_2 < VAR_4+7; VAR_2++)
{
VAR_1->exclude_mask[VAR_2] = faad_get1bit(VAR_0
DEBUGVAR(1,105,""excluded_channels(): exclude_mask""));
}
VAR_3++;
VAR_4 += 7;
}
return VAR_3;
}",knik0/faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174/syntax.c/vul/before/0.json,"static uint8_t excluded_channels(bitfile *ld, drc_info *drc)
{
    uint8_t i, n = 0;
    uint8_t num_excl_chan = 7;

    for (i = 0; i < 7; i++)
    {
        drc->exclude_mask[i] = faad_get1bit(ld
            DEBUGVAR(1,103,""excluded_channels(): exclude_mask""));
    }
    n++;

    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld
        DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
    {
        if (i >= MAX_CHANNELS - num_excl_chan - 7)
            return n;
        for (i = num_excl_chan; i < num_excl_chan+7; i++)
        {
            drc->exclude_mask[i] = faad_get1bit(ld
                DEBUGVAR(1,105,""excluded_channels(): exclude_mask""));
        }
        n++;
        num_excl_chan += 7;
    }

    return n;
}","static uint8_t excluded_channels(bitfile *VAR_0, drc_info *VAR_1)
{
    uint8_t VAR_2, VAR_3 = 0;
    uint8_t VAR_4 = 7;

    for (VAR_2 = 0; VAR_2 < 7; VAR_2++)
    {
        VAR_1->exclude_mask[VAR_2] = faad_get1bit(VAR_0
            DEBUGVAR(1,103,""excluded_channels(): exclude_mask""));
    }
    VAR_3++;

    while ((VAR_1->additional_excluded_chns[VAR_3-1] = faad_get1bit(VAR_0
        DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
    {
        if (VAR_2 >= VAR_5 - VAR_4 - 7)
            return VAR_3;
        for (VAR_2 = VAR_4; VAR_2 < VAR_4+7; VAR_2++)
        {
            VAR_1->exclude_mask[VAR_2] = faad_get1bit(VAR_0
                DEBUGVAR(1,105,""excluded_channels(): exclude_mask""));
        }
        VAR_3++;
        VAR_4 += 7;
    }

    return VAR_3;
}",knik0/faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174/syntax.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,8 @@
     while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld
         DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
     {
+        if (i >= MAX_CHANNELS - num_excl_chan - 7)
+            return n;
         for (i = num_excl_chan; i < num_excl_chan+7; i++)
         {
             drc->exclude_mask[i] = faad_get1bit(ld","{'deleted_lines': [], 'added_lines': ['        if (i >= MAX_CHANNELS - num_excl_chan - 7)', '            return n;']}",True,"An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left).",7.8,HIGH,2,valid,2019-06-10T11:58:40Z,2
CVE-2019-15296,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,knik0/faad2,"Fix a couple buffer overflows

https://hackerone.com/reports/502816
https://hackerone.com/reports/507858

https://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-overflows.patch",942c3e0aee748ea6fe97cb2c1aa5893225316174,https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174,libfaad/bits.c,faad_resetbits,"void faad_resetbits(bitfile *ld, int bits)
{
uint32_t tmp;
int words = bits >> 5;
int remainder = bits & 0x1F;
ld->bytes_left = ld->buffer_size - words*4;
if (ld->bytes_left >= 4)
{
tmp = getdword(&ld->start[words]);
ld->bytes_left -= 4;
} else {
tmp = getdword_n(&ld->start[words], ld->bytes_left);
ld->bytes_left = 0;
}
ld->bufa = tmp;
if (ld->bytes_left >= 4)
{
tmp = getdword(&ld->start[words+1]);
ld->bytes_left -= 4;
} else {
tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
ld->bytes_left = 0;
}
ld->bufb = tmp;
ld->bits_left = 32 - remainder;
ld->tail = &ld->start[words+2];
ld->error = 0;
}","void faad_resetbits(bitfile *VAR_0, int VAR_1)
{
uint32_t VAR_2;
int VAR_3 = VAR_1 >> 5;
int VAR_4 = VAR_1 & 0x1F;
VAR_0->bytes_left = VAR_0->buffer_size - VAR_3*4;
if (VAR_0->bytes_left >= 4)
{
VAR_2 = getdword(&VAR_0->start[VAR_3]);
VAR_0->bytes_left -= 4;
} else {
VAR_2 = getdword_n(&VAR_0->start[VAR_3], VAR_0->bytes_left);
VAR_0->bytes_left = 0;
}
VAR_0->bufa = VAR_2;
if (VAR_0->bytes_left >= 4)
{
VAR_2 = getdword(&VAR_0->start[VAR_3+1]);
VAR_0->bytes_left -= 4;
} else {
VAR_2 = getdword_n(&VAR_0->start[VAR_3+1], VAR_0->bytes_left);
VAR_0->bytes_left = 0;
}
VAR_0->bufb = VAR_2;
VAR_0->bits_left = 32 - VAR_4;
VAR_0->tail = &VAR_0->start[VAR_3+2];
VAR_0->error = 0;
}",knik0/faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174/bits.c/vul/before/0.json,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    if (ld->buffer_size < words * 4)
        ld->bytes_left = 0;
    else
        ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}","void faad_resetbits(bitfile *VAR_0, int VAR_1)
{
    uint32_t VAR_2;
    int VAR_3 = VAR_1 >> 5;
    int VAR_4 = VAR_1 & 0x1F;

    if (VAR_0->buffer_size < VAR_3 * 4)
        VAR_0->bytes_left = 0;
    else
        VAR_0->bytes_left = VAR_0->buffer_size - VAR_3*4;

    if (VAR_0->bytes_left >= 4)
    {
        VAR_2 = getdword(&VAR_0->start[VAR_3]);
        VAR_0->bytes_left -= 4;
    } else {
        VAR_2 = getdword_n(&VAR_0->start[VAR_3], VAR_0->bytes_left);
        VAR_0->bytes_left = 0;
    }
    VAR_0->bufa = VAR_2;

    if (VAR_0->bytes_left >= 4)
    {
        VAR_2 = getdword(&VAR_0->start[VAR_3+1]);
        VAR_0->bytes_left -= 4;
    } else {
        VAR_2 = getdword_n(&VAR_0->start[VAR_3+1], VAR_0->bytes_left);
        VAR_0->bytes_left = 0;
    }
    VAR_0->bufb = VAR_2;

    VAR_0->bits_left = 32 - VAR_4;
    VAR_0->tail = &VAR_0->start[VAR_3+2];

    /* COMMENT_0 */
    VAR_0->error = 0;
/* COMMENT_1 */
/* COMMENT_2 */
/* COMMENT_3 */
/* COMMENT_4 */
}",knik0/faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174/bits.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,10 @@
     int words = bits >> 5;
     int remainder = bits & 0x1F;
 
-    ld->bytes_left = ld->buffer_size - words*4;
+    if (ld->buffer_size < words * 4)
+        ld->bytes_left = 0;
+    else
+        ld->bytes_left = ld->buffer_size - words*4;
 
     if (ld->bytes_left >= 4)
     {","{'deleted_lines': ['    ld->bytes_left = ld->buffer_size - words*4;'], 'added_lines': ['    if (ld->buffer_size < words * 4)', '        ld->bytes_left = 0;', '    else', '        ld->bytes_left = ld->buffer_size - words*4;']}",True,"An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left).",7.8,HIGH,2,valid,2019-06-10T11:58:40Z,2
CVE-2019-13301,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1589,f595a1985233c399a05c0c37cc41de16a90dd025,https://github.com/ImageMagick/ImageMagick/commit/f595a1985233c399a05c0c37cc41de16a90dd025,MagickCore/annotate.c,AnnotateImage,"MagickExport MagickBooleanType AnnotateImage(Image *image,
const DrawInfo *draw_info,ExceptionInfo *exception)
{
char
*p,
primitive[MagickPathExtent],
*text,
**textlist;
DrawInfo
*annotate,
*annotate_info;
GeometryInfo
geometry_info;
MagickBooleanType
status;
PointInfo
offset;
RectangleInfo
geometry;
register ssize_t
i;
TypeMetric
metrics;
size_t
height,
number_lines;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(draw_info != (DrawInfo *) NULL);
assert(draw_info->signature == MagickCoreSignature);
if (draw_info->text == (char *) NULL)
return(MagickFalse);
if (*draw_info->text == '\0')
return(MagickTrue);
annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);
text=annotate->text;
annotate->text=(char *) NULL;
annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
number_lines=1;
for (p=text; *p != '\0'; p++)
if (*p == '\n')
number_lines++;
textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
if (textlist == (char **) NULL)
return(MagickFalse);
p=text;
for (i=0; i < number_lines; i++)
{
char
*q;
textlist[i]=p;
for (q=p; *q != '\0'; q++)
if ((*q == '\r') || (*q == '\n'))
break;
if (*q == '\r')
{
*q='\0';
q++;
}
*q='\0';
p=q+1;
}
textlist[i]=(char *) NULL;
SetGeometry(image,&geometry);
SetGeometryInfo(&geometry_info);
if (annotate_info->geometry != (char *) NULL)
{
(void) ParsePageGeometry(image,annotate_info->geometry,&geometry,
exception);
(void) ParseGeometry(annotate_info->geometry,&geometry_info);
}
if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
return(MagickFalse);
if (IsGrayColorspace(image->colorspace) != MagickFalse)
(void) SetImageColorspace(image,sRGBColorspace,exception);
status=MagickTrue;
(void) memset(&metrics,0,sizeof(metrics));
for (i=0; textlist[i] != (char *) NULL; i++)
{
if (*textlist[i] == '\0')
continue;
annotate_info->affine.tx=geometry_info.xi-image->page.x;
annotate_info->affine.ty=geometry_info.psi-image->page.y;
(void) CloneString(&annotate->text,textlist[i]);
if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))
(void) GetTypeMetrics(image,annotate,&metrics,exception);
height=(ssize_t) (metrics.ascent-metrics.descent+
draw_info->interline_spacing+0.5);
switch (annotate->gravity)
{
case UndefinedGravity:
default:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
break;
}
case NorthWestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height+annotate_info->affine.ry*
(metrics.ascent+metrics.descent);
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent;
break;
}
case NorthGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
(metrics.ascent+metrics.descent);
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;
break;
}
case NorthEastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*
(metrics.ascent+metrics.descent)-1.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent-annotate_info->affine.rx*metrics.width;
break;
}
case WestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height+annotate_info->affine.ry*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height+
annotate_info->affine.sy*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0;
break;
}
case CenterGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
break;
}
case EastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width+
annotate_info->affine.ry*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0-1.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width+
annotate_info->affine.sy*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0;
break;
}
case SouthWestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height-annotate_info->affine.ry*
(number_lines-1.0)*height;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
case SouthGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0-
annotate_info->affine.ry*(number_lines-1.0)*height/2.0;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
case SouthEastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width-
annotate_info->affine.ry*(number_lines-1.0)*height-1.0;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
}
switch (annotate->align)
{
case LeftAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
break;
}
case CenterAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0;
break;
}
case RightAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width;
break;
}
default:
break;
}
if (draw_info->undercolor.alpha != TransparentAlpha)
{
DrawInfo
*undercolor_info;
undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
undercolor_info->fill=draw_info->undercolor;
undercolor_info->affine=draw_info->affine;
undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;
undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;
(void) FormatLocaleString(primitive,MagickPathExtent,
""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height);
(void) CloneString(&undercolor_info->primitive,primitive);
(void) DrawImage(image,undercolor_info,exception);
(void) DestroyDrawInfo(undercolor_info);
}
annotate_info->affine.tx=offset.x;
annotate_info->affine.ty=offset.y;
(void) FormatLocaleString(primitive,MagickPathExtent,""stroke-width %g ""
""line 0,0 %g,0"",metrics.underline_thickness,metrics.width);
if (annotate->decorate == OverlineDecoration)
{
annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+
metrics.descent-metrics.underline_position));
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
}
else
if (annotate->decorate == UnderlineDecoration)
{
annotate_info->affine.ty-=(draw_info->affine.sy*
metrics.underline_position);
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
}
status=RenderType(image,annotate,&offset,&metrics,exception);
if (status == MagickFalse)
break;
if (annotate->decorate == LineThroughDecoration)
{
annotate_info->affine.ty-=(draw_info->affine.sy*(height+
metrics.underline_position+metrics.descent)/2.0);
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
}
}
annotate_info=DestroyDrawInfo(annotate_info);
annotate=DestroyDrawInfo(annotate);
textlist=(char **) RelinquishMagickMemory(textlist);
return(status);
}","MagickExport VAR_0 AnnotateImage(Image *VAR_1,
const DrawInfo *VAR_2,ExceptionInfo *VAR_3)
{
char
*VAR_4,
VAR_5[VAR_6],
*VAR_7,
**VAR_8;
DrawInfo
*VAR_9,
*VAR_10;
GeometryInfo
VAR_11;
MagickBooleanType
VAR_12;
PointInfo
VAR_13;
RectangleInfo
VAR_14;
register ssize_t
VAR_15;
TypeMetric
VAR_16;
size_t
VAR_17,
VAR_18;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_19);
if (VAR_1->debug != VAR_20)
(void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (DrawInfo *) NULL);
assert(VAR_2->signature == VAR_19);
if (VAR_2->text == (char *) NULL)
return(VAR_20);
if (*VAR_2->text == '\0')
return(VAR_22);
VAR_9=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_7=VAR_9->text;
VAR_9->text=(char *) NULL;
VAR_10=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_18=1;
for (VAR_4=VAR_7; *VAR_4 != '\0'; VAR_4++)
if (*VAR_4 == '\n')
VAR_18++;
VAR_8=AcquireQuantumMemory(VAR_18+1,sizeof(*VAR_8));
if (VAR_8 == (char **) NULL)
return(VAR_20);
VAR_4=VAR_7;
for (VAR_15=0; VAR_15 < VAR_18; VAR_15++)
{
char
*VAR_23;
VAR_8[VAR_15]=VAR_4;
for (VAR_23=VAR_4; *VAR_23 != '\0'; VAR_23++)
if ((*VAR_23 == '\r') || (*VAR_23 == '\n'))
break;
if (*VAR_23 == '\r')
{
*VAR_23='\0';
VAR_23++;
}
*VAR_23='\0';
VAR_4=VAR_23+1;
}
VAR_8[VAR_15]=(char *) NULL;
SetGeometry(VAR_1,&VAR_14);
SetGeometryInfo(&VAR_11);
if (VAR_10->geometry != (char *) NULL)
{
(void) ParsePageGeometry(VAR_1,VAR_10->geometry,&VAR_14,
VAR_3);
(void) ParseGeometry(VAR_10->geometry,&VAR_11);
}
if (SetImageStorageClass(VAR_1,VAR_24,VAR_3) == VAR_20)
return(VAR_20);
if (IsGrayColorspace(VAR_1->colorspace) != VAR_20)
(void) SetImageColorspace(VAR_1,VAR_25,VAR_3);
VAR_12=VAR_22;
(void) memset(&VAR_16,0,sizeof(VAR_16));
for (VAR_15=0; VAR_8[VAR_15] != (char *) NULL; VAR_15++)
{
if (*VAR_8[VAR_15] == '\0')
continue;
VAR_10->affine.tx=VAR_11.xi-VAR_1->page.x;
VAR_10->affine.ty=VAR_11.psi-VAR_1->page.y;
(void) CloneString(&VAR_9->text,VAR_8[VAR_15]);
if ((VAR_16.width == 0) || (VAR_9->gravity != VAR_26))
(void) GetTypeMetrics(VAR_1,VAR_9,&VAR_16,VAR_3);
VAR_17=(ssize_t) (VAR_16.ascent-VAR_16.descent+
VAR_2->interline_spacing+0.5);
switch (VAR_9->gravity)
{
case VAR_27:
default:
{
VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17;
VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17;
break;
}
case VAR_26:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
VAR_10->affine.ry*VAR_17+VAR_10->affine.ry*
(VAR_16.ascent+VAR_16.descent);
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
VAR_16.ascent;
break;
}
case VAR_28:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width/2.0+VAR_10->affine.ry*
(VAR_16.ascent+VAR_16.descent);
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
VAR_16.ascent-VAR_10->affine.rx*VAR_16.width/2.0;
break;
}
case VAR_29:
{
VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width+VAR_10->affine.ry*
(VAR_16.ascent+VAR_16.descent)-1.0;
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
VAR_16.ascent-VAR_10->affine.rx*VAR_16.width;
break;
}
case VAR_30:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
VAR_10->affine.ry*VAR_17+VAR_10->affine.ry*
(VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17+
VAR_10->affine.sy*(VAR_16.ascent+VAR_16.descent-
(VAR_18-1.0)*VAR_17)/2.0;
break;
}
case VAR_31:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width/2.0+VAR_10->affine.ry*
(VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width/2.0+VAR_10->affine.sy*
(VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
break;
}
case VAR_32:
{
VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width+
VAR_10->affine.ry*(VAR_16.ascent+VAR_16.descent-
(VAR_18-1.0)*VAR_17)/2.0-1.0;
VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width+
VAR_10->affine.sy*(VAR_16.ascent+VAR_16.descent-
(VAR_18-1.0)*VAR_17)/2.0;
break;
}
case VAR_33:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
VAR_10->affine.ry*VAR_17-VAR_10->affine.ry*
(VAR_18-1.0)*VAR_17;
VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
break;
}
case VAR_34:
{
VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width/2.0-
VAR_10->affine.ry*(VAR_18-1.0)*VAR_17/2.0;
VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width/2.0-
VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
break;
}
case VAR_35:
{
VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width-
VAR_10->affine.ry*(VAR_18-1.0)*VAR_17-1.0;
VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width-
VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
break;
}
}
switch (VAR_9->align)
{
case VAR_36:
{
VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17;
VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17;
break;
}
case VAR_37:
{
VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width/2.0;
VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width/2.0;
break;
}
case VAR_38:
{
VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17-
VAR_10->affine.sx*VAR_16.width;
VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17-
VAR_10->affine.rx*VAR_16.width;
break;
}
default:
break;
}
if (VAR_2->undercolor.alpha != VAR_39)
{
DrawInfo
*VAR_40;
VAR_40=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
VAR_40->fill=VAR_2->undercolor;
VAR_40->affine=VAR_2->affine;
VAR_40->affine.tx=VAR_13.x-VAR_2->affine.ry*VAR_16.ascent;
VAR_40->affine.ty=VAR_13.y-VAR_2->affine.sy*VAR_16.ascent;
(void) FormatLocaleString(VAR_5,VAR_6,
""rectangle 0.0,0.0 %g,%g"",VAR_16.origin.x,(double) VAR_17);
(void) CloneString(&VAR_40->primitive,VAR_5);
(void) DrawImage(VAR_1,VAR_40,VAR_3);
(void) DestroyDrawInfo(VAR_40);
}
VAR_10->affine.tx=VAR_13.x;
VAR_10->affine.ty=VAR_13.y;
(void) FormatLocaleString(VAR_5,VAR_6,""stroke-width %g ""
""line 0,0 %g,0"",VAR_16.underline_thickness,VAR_16.width);
if (VAR_9->decorate == VAR_41)
{
VAR_10->affine.ty-=(VAR_2->affine.sy*(VAR_16.ascent+
VAR_16.descent-VAR_16.underline_position));
(void) CloneString(&VAR_10->primitive,VAR_5);
(void) DrawImage(VAR_1,VAR_10,VAR_3);
}
else
if (VAR_9->decorate == VAR_42)
{
VAR_10->affine.ty-=(VAR_2->affine.sy*
VAR_16.underline_position);
(void) CloneString(&VAR_10->primitive,VAR_5);
(void) DrawImage(VAR_1,VAR_10,VAR_3);
}
VAR_12=RenderType(VAR_1,VAR_9,&VAR_13,&VAR_16,VAR_3);
if (VAR_12 == VAR_20)
break;
if (VAR_9->decorate == VAR_43)
{
VAR_10->affine.ty-=(VAR_2->affine.sy*(VAR_17+
VAR_16.underline_position+VAR_16.descent)/2.0);
(void) CloneString(&VAR_10->primitive,VAR_5);
(void) DrawImage(VAR_1,VAR_10,VAR_3);
}
}
VAR_10=DestroyDrawInfo(VAR_10);
VAR_9=DestroyDrawInfo(VAR_9);
VAR_8=(char **) RelinquishMagickMemory(VAR_8);
return(VAR_12);
}",,"MagickExport MagickBooleanType AnnotateImage(Image *image,
  const DrawInfo *draw_info,ExceptionInfo *exception)
{
  char
    *p,
    primitive[MagickPathExtent],
    *text,
    **textlist;

  DrawInfo
    *annotate,
    *annotate_info;

  GeometryInfo
    geometry_info;

  MagickBooleanType
    status;

  PointInfo
    offset;

  RectangleInfo
    geometry;

  register ssize_t
    i;

  TypeMetric
    metrics;

  size_t
    height,
    number_lines;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(draw_info != (DrawInfo *) NULL);
  assert(draw_info->signature == MagickCoreSignature);
  if (draw_info->text == (char *) NULL)
    return(MagickFalse);
  if (*draw_info->text == '\0')
    return(MagickTrue);
  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  text=annotate->text;
  annotate->text=(char *) NULL;
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  number_lines=1;
  for (p=text; *p != '\0'; p++)
    if (*p == '\n')
      number_lines++;
  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
  if (textlist == (char **) NULL)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      return(MagickFalse);
    }
  p=text;
  for (i=0; i < number_lines; i++)
  {
    char
      *q;

    textlist[i]=p;
    for (q=p; *q != '\0'; q++)
      if ((*q == '\r') || (*q == '\n'))
        break;
    if (*q == '\r')
      {
        *q='\0';
        q++;
      }
    *q='\0';
    p=q+1;
  }
  textlist[i]=(char *) NULL;
  SetGeometry(image,&geometry);
  SetGeometryInfo(&geometry_info);
  if (annotate_info->geometry != (char *) NULL)
    {
      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,
        exception);
      (void) ParseGeometry(annotate_info->geometry,&geometry_info);
    }
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      textlist=(char **) RelinquishMagickMemory(textlist);
      return(MagickFalse);
    }
  if (IsGrayColorspace(image->colorspace) != MagickFalse)
    (void) SetImageColorspace(image,sRGBColorspace,exception);
  status=MagickTrue;
  (void) memset(&metrics,0,sizeof(metrics));
  for (i=0; textlist[i] != (char *) NULL; i++)
  {
    if (*textlist[i] == '\0')
      continue;
    /*
      Position text relative to image.
    */
    annotate_info->affine.tx=geometry_info.xi-image->page.x;
    annotate_info->affine.ty=geometry_info.psi-image->page.y;
    (void) CloneString(&annotate->text,textlist[i]);
    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))
      (void) GetTypeMetrics(image,annotate,&metrics,exception);
    height=(ssize_t) (metrics.ascent-metrics.descent+
      draw_info->interline_spacing+0.5);
    switch (annotate->gravity)
    {
      case UndefinedGravity:
      default:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
        break;
      }
      case NorthWestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent);
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent;
        break;
      }
      case NorthGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent);
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;
        break;
      }
      case NorthEastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent)-1.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent-annotate_info->affine.rx*metrics.width;
        break;
      }
      case WestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height+
          annotate_info->affine.sy*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0;
        break;
      }
      case CenterGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        break;
      }
      case EastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width+
          annotate_info->affine.ry*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0-1.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width+
          annotate_info->affine.sy*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0;
        break;
      }
      case SouthWestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height-annotate_info->affine.ry*
          (number_lines-1.0)*height;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
      case SouthGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0-
          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
      case SouthEastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width-
          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
    }
    switch (annotate->align)
    {
      case LeftAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
        break;
      }
      case CenterAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0;
        break;
      }
      case RightAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width;
        break;
      }
      default:
        break;
    }
    if (draw_info->undercolor.alpha != TransparentAlpha)
      {
        DrawInfo
          *undercolor_info;

        /*
          Text box.
        */
        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
        undercolor_info->fill=draw_info->undercolor;
        undercolor_info->affine=draw_info->affine;
        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;
        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;
        (void) FormatLocaleString(primitive,MagickPathExtent,
          ""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height);
        (void) CloneString(&undercolor_info->primitive,primitive);
        (void) DrawImage(image,undercolor_info,exception);
        (void) DestroyDrawInfo(undercolor_info);
      }
    annotate_info->affine.tx=offset.x;
    annotate_info->affine.ty=offset.y;
    (void) FormatLocaleString(primitive,MagickPathExtent,""stroke-width %g ""
      ""line 0,0 %g,0"",metrics.underline_thickness,metrics.width);
    if (annotate->decorate == OverlineDecoration)
      {
        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+
          metrics.descent-metrics.underline_position));
        (void) CloneString(&annotate_info->primitive,primitive);
        (void) DrawImage(image,annotate_info,exception);
      }
    else
      if (annotate->decorate == UnderlineDecoration)
        {
          annotate_info->affine.ty-=(draw_info->affine.sy*
            metrics.underline_position);
          (void) CloneString(&annotate_info->primitive,primitive);
          (void) DrawImage(image,annotate_info,exception);
        }
    /*
      Annotate image with text.
    */
    status=RenderType(image,annotate,&offset,&metrics,exception);
    if (status == MagickFalse)
      break;
    if (annotate->decorate == LineThroughDecoration)
      {
        annotate_info->affine.ty-=(draw_info->affine.sy*(height+
          metrics.underline_position+metrics.descent)/2.0);
        (void) CloneString(&annotate_info->primitive,primitive);
        (void) DrawImage(image,annotate_info,exception);
      }
  }
  /*
    Relinquish resources.
  */
  annotate_info=DestroyDrawInfo(annotate_info);
  annotate=DestroyDrawInfo(annotate);
  textlist=(char **) RelinquishMagickMemory(textlist);
  return(status);
}","MagickExport VAR_0 AnnotateImage(Image *VAR_1,
  const DrawInfo *VAR_2,ExceptionInfo *VAR_3)
{
  char
    *VAR_4,
    VAR_5[VAR_6],
    *VAR_7,
    **VAR_8;

  DrawInfo
    *VAR_9,
    *VAR_10;

  GeometryInfo
    VAR_11;

  MagickBooleanType
    VAR_12;

  PointInfo
    VAR_13;

  RectangleInfo
    VAR_14;

  register ssize_t
    VAR_15;

  TypeMetric
    VAR_16;

  size_t
    VAR_17,
    VAR_18;

  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_19);
  if (VAR_1->debug != VAR_20)
    (void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (DrawInfo *) NULL);
  assert(VAR_2->signature == VAR_19);
  if (VAR_2->text == (char *) NULL)
    return(VAR_20);
  if (*VAR_2->text == '\0')
    return(VAR_22);
  VAR_9=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
  VAR_7=VAR_9->text;
  VAR_9->text=(char *) NULL;
  VAR_10=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
  VAR_18=1;
  for (VAR_4=VAR_7; *VAR_4 != '\0'; VAR_4++)
    if (*VAR_4 == '\n')
      VAR_18++;
  VAR_8=AcquireQuantumMemory(VAR_18+1,sizeof(*VAR_8));
  if (VAR_8 == (char **) NULL)
    {
      VAR_10=DestroyDrawInfo(VAR_10);
      VAR_9=DestroyDrawInfo(VAR_9);
      return(VAR_20);
    }
  VAR_4=VAR_7;
  for (VAR_15=0; VAR_15 < VAR_18; VAR_15++)
  {
    char
      *VAR_23;

    VAR_8[VAR_15]=VAR_4;
    for (VAR_23=VAR_4; *VAR_23 != '\0'; VAR_23++)
      if ((*VAR_23 == '\r') || (*VAR_23 == '\n'))
        break;
    if (*VAR_23 == '\r')
      {
        *VAR_23='\0';
        VAR_23++;
      }
    *VAR_23='\0';
    VAR_4=VAR_23+1;
  }
  VAR_8[VAR_15]=(char *) NULL;
  SetGeometry(VAR_1,&VAR_14);
  SetGeometryInfo(&VAR_11);
  if (VAR_10->geometry != (char *) NULL)
    {
      (void) ParsePageGeometry(VAR_1,VAR_10->geometry,&VAR_14,
        VAR_3);
      (void) ParseGeometry(VAR_10->geometry,&VAR_11);
    }
  if (SetImageStorageClass(VAR_1,VAR_24,VAR_3) == VAR_20)
    {
      VAR_10=DestroyDrawInfo(VAR_10);
      VAR_9=DestroyDrawInfo(VAR_9);
      VAR_8=(char **) RelinquishMagickMemory(VAR_8);
      return(VAR_20);
    }
  if (IsGrayColorspace(VAR_1->colorspace) != VAR_20)
    (void) SetImageColorspace(VAR_1,VAR_25,VAR_3);
  VAR_12=VAR_22;
  (void) memset(&VAR_16,0,sizeof(VAR_16));
  for (VAR_15=0; VAR_8[VAR_15] != (char *) NULL; VAR_15++)
  {
    if (*VAR_8[VAR_15] == '\0')
      continue;
    /* COMMENT_0 */
                                      
      
    VAR_10->affine.tx=VAR_11.xi-VAR_1->page.x;
    VAR_10->affine.ty=VAR_11.psi-VAR_1->page.y;
    (void) CloneString(&VAR_9->text,VAR_8[VAR_15]);
    if ((VAR_16.width == 0) || (VAR_9->gravity != VAR_26))
      (void) GetTypeMetrics(VAR_1,VAR_9,&VAR_16,VAR_3);
    VAR_17=(ssize_t) (VAR_16.ascent-VAR_16.descent+
      VAR_2->interline_spacing+0.5);
    switch (VAR_9->gravity)
    {
      case VAR_27:
      default:
      {
        VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17;
        VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17;
        break;
      }
      case VAR_26:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
          VAR_10->affine.ry*VAR_17+VAR_10->affine.ry*
          (VAR_16.ascent+VAR_16.descent);
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
          VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
          VAR_16.ascent;
        break;
      }
      case VAR_28:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
          VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width/2.0+VAR_10->affine.ry*
          (VAR_16.ascent+VAR_16.descent);
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
          VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
          VAR_16.ascent-VAR_10->affine.rx*VAR_16.width/2.0;
        break;
      }
      case VAR_29:
      {
        VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
          VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width+VAR_10->affine.ry*
          (VAR_16.ascent+VAR_16.descent)-1.0;
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+VAR_15*
          VAR_10->affine.sy*VAR_17+VAR_10->affine.sy*
          VAR_16.ascent-VAR_10->affine.rx*VAR_16.width;
        break;
      }
      case VAR_30:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
          VAR_10->affine.ry*VAR_17+VAR_10->affine.ry*
          (VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
          VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17+
          VAR_10->affine.sy*(VAR_16.ascent+VAR_16.descent-
          (VAR_18-1.0)*VAR_17)/2.0;
        break;
      }
      case VAR_31:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
          VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width/2.0+VAR_10->affine.ry*
          (VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
          VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width/2.0+VAR_10->affine.sy*
          (VAR_16.ascent+VAR_16.descent-(VAR_18-1.0)*VAR_17)/2.0;
        break;
      }
      case VAR_32:
      {
        VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
          VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width+
          VAR_10->affine.ry*(VAR_16.ascent+VAR_16.descent-
          (VAR_18-1.0)*VAR_17)/2.0-1.0;
        VAR_13.y=(VAR_14.height == 0 ? -1.0 : 1.0)*VAR_10->affine.ty+
          VAR_14.height/2.0+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width+
          VAR_10->affine.sy*(VAR_16.ascent+VAR_16.descent-
          (VAR_18-1.0)*VAR_17)/2.0;
        break;
      }
      case VAR_33:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+VAR_15*
          VAR_10->affine.ry*VAR_17-VAR_10->affine.ry*
          (VAR_18-1.0)*VAR_17;
        VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
          VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
        break;
      }
      case VAR_34:
      {
        VAR_13.x=(VAR_14.width == 0 ? -1.0 : 1.0)*VAR_10->affine.tx+
          VAR_14.width/2.0+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width/2.0-
          VAR_10->affine.ry*(VAR_18-1.0)*VAR_17/2.0;
        VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
          VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width/2.0-
          VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
        break;
      }
      case VAR_35:
      {
        VAR_13.x=(VAR_14.width == 0 ? 1.0 : -1.0)*VAR_10->affine.tx+
          VAR_14.width+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width-
          VAR_10->affine.ry*(VAR_18-1.0)*VAR_17-1.0;
        VAR_13.y=(VAR_14.height == 0 ? 1.0 : -1.0)*VAR_10->affine.ty+
          VAR_14.height+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width-
          VAR_10->affine.sy*(VAR_18-1.0)*VAR_17+VAR_16.descent;
        break;
      }
    }
    switch (VAR_9->align)
    {
      case VAR_36:
      {
        VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17;
        VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17;
        break;
      }
      case VAR_37:
      {
        VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width/2.0;
        VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width/2.0;
        break;
      }
      case VAR_38:
      {
        VAR_13.x=VAR_10->affine.tx+VAR_15*VAR_10->affine.ry*VAR_17-
          VAR_10->affine.sx*VAR_16.width;
        VAR_13.y=VAR_10->affine.ty+VAR_15*VAR_10->affine.sy*VAR_17-
          VAR_10->affine.rx*VAR_16.width;
        break;
      }
      default:
        break;
    }
    if (VAR_2->undercolor.alpha != VAR_39)
      {
        DrawInfo
          *VAR_40;

        /* COMMENT_3 */
                   
          
        VAR_40=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
        VAR_40->fill=VAR_2->undercolor;
        VAR_40->affine=VAR_2->affine;
        VAR_40->affine.tx=VAR_13.x-VAR_2->affine.ry*VAR_16.ascent;
        VAR_40->affine.ty=VAR_13.y-VAR_2->affine.sy*VAR_16.ascent;
        (void) FormatLocaleString(VAR_5,VAR_6,
          ""rectangle 0.0,0.0 %g,%g"",VAR_16.origin.x,(double) VAR_17);
        (void) CloneString(&VAR_40->primitive,VAR_5);
        (void) DrawImage(VAR_1,VAR_40,VAR_3);
        (void) DestroyDrawInfo(VAR_40);
      }
    VAR_10->affine.tx=VAR_13.x;
    VAR_10->affine.ty=VAR_13.y;
    (void) FormatLocaleString(VAR_5,VAR_6,""stroke-width %g ""
      ""line 0,0 %g,0"",VAR_16.underline_thickness,VAR_16.width);
    if (VAR_9->decorate == VAR_41)
      {
        VAR_10->affine.ty-=(VAR_2->affine.sy*(VAR_16.ascent+
          VAR_16.descent-VAR_16.underline_position));
        (void) CloneString(&VAR_10->primitive,VAR_5);
        (void) DrawImage(VAR_1,VAR_10,VAR_3);
      }
    else
      if (VAR_9->decorate == VAR_42)
        {
          VAR_10->affine.ty-=(VAR_2->affine.sy*
            VAR_16.underline_position);
          (void) CloneString(&VAR_10->primitive,VAR_5);
          (void) DrawImage(VAR_1,VAR_10,VAR_3);
        }
    /* COMMENT_6 */
                               
      
    VAR_12=RenderType(VAR_1,VAR_9,&VAR_13,&VAR_16,VAR_3);
    if (VAR_12 == VAR_20)
      break;
    if (VAR_9->decorate == VAR_43)
      {
        VAR_10->affine.ty-=(VAR_2->affine.sy*(VAR_17+
          VAR_16.underline_position+VAR_16.descent)/2.0);
        (void) CloneString(&VAR_10->primitive,VAR_5);
        (void) DrawImage(VAR_1,VAR_10,VAR_3);
      }
  }
  /* COMMENT_9 */
                         
    
  VAR_10=DestroyDrawInfo(VAR_10);
  VAR_9=DestroyDrawInfo(VAR_9);
  VAR_8=(char **) RelinquishMagickMemory(VAR_8);
  return(VAR_12);
}",,"--- func_before
+++ func_after
@@ -53,7 +53,11 @@
       number_lines++;
   textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
   if (textlist == (char **) NULL)
-    return(MagickFalse);
+    {
+      annotate_info=DestroyDrawInfo(annotate_info);
+      annotate=DestroyDrawInfo(annotate);
+      return(MagickFalse);
+    }
   p=text;
   for (i=0; i < number_lines; i++)
   {
@@ -82,7 +86,12 @@
       (void) ParseGeometry(annotate_info->geometry,&geometry_info);
     }
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
-    return(MagickFalse);
+    {
+      annotate_info=DestroyDrawInfo(annotate_info);
+      annotate=DestroyDrawInfo(annotate);
+      textlist=(char **) RelinquishMagickMemory(textlist);
+      return(MagickFalse);
+    }
   if (IsGrayColorspace(image->colorspace) != MagickFalse)
     (void) SetImageColorspace(image,sRGBColorspace,exception);
   status=MagickTrue;","{'deleted_lines': ['    return(MagickFalse);', '    return(MagickFalse);'], 'added_lines': ['    {', '      annotate_info=DestroyDrawInfo(annotate_info);', '      annotate=DestroyDrawInfo(annotate);', '      return(MagickFalse);', '    }', '    {', '      annotate_info=DestroyDrawInfo(annotate_info);', '      annotate=DestroyDrawInfo(annotate);', '      textlist=(char **) RelinquishMagickMemory(textlist);', '      return(MagickFalse);', '    }']}",True,ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error.,6.5,MEDIUM,1,valid,2019-06-16T02:02:18Z,2
CVE-2019-12865,['CWE-415'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,Fix #14334 - Double-free in ms command,40453029179d230cf02ffed205f2d63e33981b8f,https://github.com/radareorg/radare2/commit/40453029179d230cf02ffed205f2d63e33981b8f,libr/core/cmd_mount.c,cmd_mount,"static int cmd_mount(void *data, const char *_input) {
ut64 off = 0;
char *input, *oinput, *ptr, *ptr2;
RList *list;
RListIter *iter;
RFSFile *file;
RFSRoot *root;
RFSPlugin *plug;
RFSPartition *part;
RCore *core = (RCore *)data;
if (!strncmp (""kdir"", _input, 4)) {
return cmd_mkdir (data, _input);
}
if (!strncmp (""v"", _input, 1)) {
return cmd_mv (data, _input);
}
input = oinput = strdup (_input);
switch (*input) {
case ' ':
input = (char *)r_str_trim_ro (input + 1);
ptr = strchr (input, ' ');
if (ptr) {
*ptr = 0;
ptr = (char *)r_str_trim_ro (ptr + 1);
ptr2 = strchr (ptr, ' ');
if (ptr2) {
*ptr2 = 0;
off = r_num_math (core->num, ptr2+1);
}
input = (char *)r_str_trim_ro (input);
ptr = (char*)r_str_trim_ro (ptr);
if (!r_fs_mount (core->fs, input, ptr, off)) {
if (!r_fs_mount (core->fs, ptr, input, off)) {
eprintf (""Cannot mount %s\n"", input);
}
}
} else {
if (!(ptr = r_fs_name (core->fs, core->offset))) {
eprintf (""Unknown filesystem type\n"");
}
if (!r_fs_mount (core->fs, ptr, input, core->offset)) {
eprintf (""Cannot mount %s\n"", input);
}
free (ptr);
}
break;
case '-':
r_fs_umount (core->fs, input+1);
break;
case 'j':
{
PJ *pj = pj_new ();
pj_o (pj);
pj_k (pj, ""mountpoints"");
pj_a (pj);
r_list_foreach (core->fs->roots, iter, root) {
pj_o (pj);
pj_ks (pj, ""path"", root->path);
pj_ks (pj, ""plugin"", root->p->name);
pj_kn (pj, ""offset"", root->delta);
pj_end (pj);
}
pj_end (pj);
pj_k (pj, ""plugins"");
pj_a (pj);
r_list_foreach (core->fs->plugins, iter, plug) {
pj_o (pj);
pj_ks (pj, ""name"", plug->name);
pj_ks (pj, ""description"", plug->desc);
pj_end (pj);
}
pj_end (pj);
pj_end (pj);
r_cons_printf (""%s\n"", pj_string (pj));
pj_free (pj);
}
break;
case '*':
r_list_foreach (core->fs->roots, iter, root) {
r_cons_printf (""m %s %s 0x%""PFMT64x""\n"",
root-> path, root->p->name, root->delta);
}
break;
case '\0':
r_list_foreach (core->fs->roots, iter, root) {
r_cons_printf (""%s\t0x%""PFMT64x""\t%s\n"",
root->p->name, root->delta, root->path);
}
break;
case 'L': r_list_foreach (core->fs->plugins, iter, plug) {
r_cons_printf (""%10s  %s\n"", plug->name, plug->desc);
}
break;
case 'l': case 'd': cmd_mount_ls (core, input + 1);
break;
case 'p':
input++;
if (*input == ' ') {
input++;
}
ptr = strchr (input, ' ');
if (ptr) {
*ptr = 0;
off = r_num_math (core->num, ptr+1);
}
list = r_fs_partitions (core->fs, input, off);
if (list) {
r_list_foreach (list, iter, part) {
r_cons_printf (""%d %02x 0x%010""PFMT64x"" 0x%010""PFMT64x""\n"",
part->number, part->type,
part->start, part->start+part->length);
}
r_list_free (list);
} else {
eprintf (""Cannot read partition\n"");
}
break;
case 'o': input++;
if (input[0]==' ') {
input++;
}
file = r_fs_open (core->fs, input, false);
if (file) {
r_fs_read (core->fs, file, 0, file->size);
char *uri = r_str_newf (""malloc:RIODesc *fd = r_io_open (core->io, uri, R_PERM_RW, 0);
if (fd) {
r_io_desc_write (fd, file->data, file->size);
}
} else {
eprintf (""Cannot open file\n"");
}
break;
case 'i':
input++;
if (input[0]==' ') {
input++;
}
file = r_fs_open (core->fs, input, false);
if (file) {
r_fs_read (core->fs, file, 0, file->size);
r_cons_printf (""f file %d 0x%08""PFMT64x""\n"", file->size, file->off);
r_fs_close (core->fs, file);
} else {
eprintf (""Cannot open file\n"");
}
break;
case 'c': input++;
if (*input == ' ') {
input++;
}
ptr = strchr (input, ' ');
if (ptr) {
*ptr++ = 0;
} else {
ptr = ""./"";
}
file = r_fs_open (core->fs, input, false);
if (file) {
r_fs_read (core->fs, file, 0, file->size);
r_cons_memcat ((const char *)file->data, file->size);
r_fs_close (core->fs, file);
r_cons_memcat (""\n"", 1);
} else if (!r_fs_dir_dump (core->fs, input, ptr)) {
eprintf (""Cannot open file\n"");
}
break;
case 'g': input++;
if (*input == ' ') {
input++;
}
ptr = strchr (input, ' ');
if (ptr) {
*ptr++ = 0;
} else {
ptr = ""./"";
}
file = r_fs_open (core->fs, input, false);
if (file) {
char *localFile = strdup (input);
char *slash = (char *)r_str_rchr (localFile, NULL, '/');
if (slash) {
memmove (localFile, slash + 1, strlen (slash));
}
r_fs_read (core->fs, file, 0, file->size);
r_file_dump (localFile, file->data, file->size, false);
r_fs_close (core->fs, file);
eprintf (""File '%s' created.\n"", localFile);
free (localFile);
} else if (!r_fs_dir_dump (core->fs, input, ptr)) {
eprintf (""Cannot open file\n"");
}
break;
case 'f':
input++;
switch (*input) {
case '?':
r_cons_printf (
""Usage: mf[no] [...]\n""
"" mfn /foo *.c       ; search files by name in /foo path\n""
"" mfo /foo 0x5e91    ; search files by offset in /foo path\n""
);
break;
case 'n':
input++;
if (*input == ' ')
input++;
ptr = strchr (input, ' ');
if (ptr) {
*ptr++ = 0;
list = r_fs_find_name (core->fs, input, ptr);
r_list_foreach (list, iter, ptr) {
r_str_trim_path (ptr);
printf (""%s\n"", ptr);
}
} else eprintf (""Unknown store path\n"");
break;
case 'o':
input++;
if (*input == ' ')
input++;
ptr = strchr (input, ' ');
if (ptr) {
*ptr++ = 0;
ut64 off = r_num_math (core->num, ptr);
list = r_fs_find_off (core->fs, input, off);
r_list_foreach (list, iter, ptr) {
r_str_trim_path (ptr);
printf (""%s\n"", ptr);
}
} else eprintf (""Unknown store path\n"");
break;
}
break;
case 's': if (core->http_up) {
free (oinput);
return false;
}
input++;
if (input[0] == ' ') {
input++;
}
r_cons_set_raw (false);
{
RFSShell shell = {
.cwd = &cwd,
.set_prompt = r_line_set_prompt,
.readline = r_line_readline,
.hist_add = r_line_hist_add
};
RLine *rli = r_line_singleton ();
RLineCompletion c;
memcpy (&c, &rli->completion, sizeof (c));
r_pvector_init (&rli->completion.args, free);  rli->completion.run = ms_autocomplete;
rli->completion.run_user = rli->user;
r_line_completion_set (&rli->completion, ms_argc, ms_argv);
r_fs_shell_prompt (&shell, core->fs, input);
free (cwd);
r_pvector_clear (&rli->completion.args);
memcpy (&rli->completion, &c, sizeof (c));
}
break;
case 'w':
if (input[1] == ' ') {
char *args = r_str_trim_dup (input + 1);
char *arg = strchr (args, ' ');
if (arg) {
data = arg + 1;
} else {
data = """";
}
RFSFile *f = r_fs_open (core->fs, args, true);
if (f) {
r_fs_write (core->fs, f, 0, (const ut8 *)data, strlen (data));
r_fs_close (core->fs, f);
r_fs_file_free (f);
free (args);
}
} else {
eprintf (""Usage: mw [file] ([data])\n"");
}
break;
case 'y':
eprintf (""TODO\n"");
break;
case '?':
r_core_cmd_help (core, help_msg_m);
break;
}
free (oinput);
return 0;
}","static int cmd_mount(void *VAR_0, const char *VAR_1) {
ut64 VAR_2 = 0;
char *VAR_3, *VAR_4, *VAR_5, *VAR_6;
RList *VAR_7;
RListIter *VAR_8;
RFSFile *VAR_9;
RFSRoot *VAR_10;
RFSPlugin *VAR_11;
RFSPartition *VAR_12;
RCore *VAR_13 = (RCore *)VAR_0;
if (!strncmp (""kdir"", VAR_1, 4)) {
return cmd_mkdir (VAR_0, VAR_1);
}
if (!strncmp (""v"", VAR_1, 1)) {
return cmd_mv (VAR_0, VAR_1);
}
VAR_3 = VAR_4 = strdup (VAR_1);
switch (*VAR_3) {
case ' ':
VAR_3 = (char *)r_str_trim_ro (VAR_3 + 1);
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5 = 0;
VAR_5 = (char *)r_str_trim_ro (VAR_5 + 1);
VAR_6 = strchr (VAR_5, ' ');
if (VAR_6) {
*VAR_6 = 0;
VAR_2 = r_num_math (VAR_13->num, VAR_6+1);
}
VAR_3 = (char *)r_str_trim_ro (VAR_3);
VAR_5 = (char*)r_str_trim_ro (VAR_5);
if (!r_fs_mount (VAR_13->fs, VAR_3, VAR_5, VAR_2)) {
if (!r_fs_mount (VAR_13->fs, VAR_5, VAR_3, VAR_2)) {
eprintf (""Cannot mount %s\n"", VAR_3);
}
}
} else {
if (!(VAR_5 = r_fs_name (VAR_13->fs, VAR_13->offset))) {
eprintf (""Unknown filesystem type\n"");
}
if (!r_fs_mount (VAR_13->fs, VAR_5, VAR_3, VAR_13->offset)) {
eprintf (""Cannot mount %s\n"", VAR_3);
}
free (VAR_5);
}
break;
case '-':
r_fs_umount (VAR_13->fs, VAR_3+1);
break;
case 'j':
{
PJ *VAR_14 = pj_new ();
pj_o (VAR_14);
pj_k (VAR_14, ""mountpoints"");
pj_a (VAR_14);
r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
pj_o (VAR_14);
pj_ks (VAR_14, ""path"", VAR_10->path);
pj_ks (VAR_14, ""plugin"", VAR_10->p->name);
pj_kn (VAR_14, ""offset"", VAR_10->delta);
pj_end (VAR_14);
}
pj_end (VAR_14);
pj_k (VAR_14, ""plugins"");
pj_a (VAR_14);
r_list_foreach (VAR_13->fs->plugins, VAR_8, VAR_11) {
pj_o (VAR_14);
pj_ks (VAR_14, ""name"", VAR_11->name);
pj_ks (VAR_14, ""description"", VAR_11->desc);
pj_end (VAR_14);
}
pj_end (VAR_14);
pj_end (VAR_14);
r_cons_printf (""%s\n"", pj_string (VAR_14));
pj_free (VAR_14);
}
break;
case '*':
r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
r_cons_printf (""m %s %s 0x%""VAR_15""\n"",
VAR_10-> path, VAR_10->p->name, VAR_10->delta);
}
break;
case '\0':
r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
r_cons_printf (""%s\t0x%""VAR_15""\t%s\n"",
VAR_10->p->name, VAR_10->delta, VAR_10->path);
}
break;
case 'L': 
r_list_foreach (VAR_13->fs->plugins, VAR_8, VAR_11) {
r_cons_printf (""%10s  %s\n"", VAR_11->name, VAR_11->desc);
}
break;
case 'l': 
case 'd': 
cmd_mount_ls (VAR_13, VAR_3 + 1);
break;
case 'p':
VAR_3++;
if (*VAR_3 == ' ') {
VAR_3++;
}
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5 = 0;
VAR_2 = r_num_math (VAR_13->num, VAR_5+1);
}
VAR_7 = r_fs_partitions (VAR_13->fs, VAR_3, VAR_2);
if (VAR_7) {
r_list_foreach (VAR_7, VAR_8, VAR_12) {
r_cons_printf (""%d %02x 0x%010""VAR_15"" 0x%010""VAR_15""\n"",
VAR_12->number, VAR_12->type,
VAR_12->start, VAR_12->start+VAR_12->length);
}
r_list_free (VAR_7);
} else {
eprintf (""Cannot read partition\n"");
}
break;
case 'o': 
VAR_3++;
if (VAR_3[0]==' ') {
VAR_3++;
}
VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
if (VAR_9) {
r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
char *VAR_16 = r_str_newf (""malloc://%d"", VAR_9->size);
RIODesc *VAR_17 = r_io_open (VAR_13->io, VAR_16, VAR_18, 0);
if (VAR_17) {
r_io_desc_write (VAR_17, VAR_9->data, VAR_9->size);
}
} else {
eprintf (""Cannot open file\n"");
}
break;
case 'i':
VAR_3++;
if (VAR_3[0]==' ') {
VAR_3++;
}
VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
if (VAR_9) {
r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
r_cons_printf (""f file %d 0x%08""VAR_15""\n"", VAR_9->size, VAR_9->off);
r_fs_close (VAR_13->fs, VAR_9);
} else {
eprintf (""Cannot open file\n"");
}
break;
case 'c': 
VAR_3++;
if (*VAR_3 == ' ') {
VAR_3++;
}
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5++ = 0;
} else {
VAR_5 = ""./"";
}
VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
if (VAR_9) {
r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
r_cons_memcat ((const char *)VAR_9->data, VAR_9->size);
r_fs_close (VAR_13->fs, VAR_9);
r_cons_memcat (""\n"", 1);
} else if (!r_fs_dir_dump (VAR_13->fs, VAR_3, VAR_5)) {
eprintf (""Cannot open file\n"");
}
break;
case 'g': 
VAR_3++;
if (*VAR_3 == ' ') {
VAR_3++;
}
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5++ = 0;
} else {
VAR_5 = ""./"";
}
VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
if (VAR_9) {
char *VAR_19 = strdup (VAR_3);
char *VAR_20 = (char *)r_str_rchr (VAR_19, NULL, '/');
if (VAR_20) {
memmove (VAR_19, VAR_20 + 1, strlen (VAR_20));
}
r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
r_file_dump (VAR_19, VAR_9->data, VAR_9->size, false);
r_fs_close (VAR_13->fs, VAR_9);
eprintf (""File '%s' created.\n"", VAR_19);
free (VAR_19);
} else if (!r_fs_dir_dump (VAR_13->fs, VAR_3, VAR_5)) {
eprintf (""Cannot open file\n"");
}
break;
case 'f':
VAR_3++;
switch (*VAR_3) {
case '?':
r_cons_printf (
""Usage: mf[no] [...]\n""
"" mfn /foo *.c       ; search files by name in /foo path\n""
"" mfo /foo 0x5e91    ; search files by offset in /foo path\n""
);
break;
case 'n':
VAR_3++;
if (*VAR_3 == ' ')
VAR_3++;
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5++ = 0;
VAR_7 = r_fs_find_name (VAR_13->fs, VAR_3, VAR_5);
r_list_foreach (VAR_7, VAR_8, VAR_5) {
r_str_trim_path (VAR_5);
printf (""%s\n"", VAR_5);
}
} else eprintf (""Unknown store path\n"");
break;
case 'o':
VAR_3++;
if (*VAR_3 == ' ')
VAR_3++;
VAR_5 = strchr (VAR_3, ' ');
if (VAR_5) {
*VAR_5++ = 0;
ut64 VAR_2 = r_num_math (VAR_13->num, VAR_5);
VAR_7 = r_fs_find_off (VAR_13->fs, VAR_3, VAR_2);
r_list_foreach (VAR_7, VAR_8, VAR_5) {
r_str_trim_path (VAR_5);
printf (""%s\n"", VAR_5);
}
} else eprintf (""Unknown store path\n"");
break;
}
break;
case 's': 
if (VAR_13->http_up) {
free (VAR_4);
return false;
}
VAR_3++;
if (VAR_3[0] == ' ') {
VAR_3++;
}
r_cons_set_raw (false);
{
RFSShell VAR_21 = {
.cwd = &VAR_22,
.set_prompt = VAR_23,
.readline = VAR_24,
.hist_add = VAR_25
};
RLine *VAR_26 = r_line_singleton ();
RLineCompletion VAR_27;
memcpy (&VAR_27, &VAR_26->completion, sizeof (VAR_27));
r_pvector_init (&VAR_26->completion.args, VAR_28);  
VAR_26->completion.run = VAR_29;
VAR_26->completion.run_user = VAR_26->user;
r_line_completion_set (&VAR_26->completion, VAR_30, VAR_31);
r_fs_shell_prompt (&VAR_21, VAR_13->fs, VAR_3);
VAR_28 (VAR_22);
r_pvector_clear (&VAR_26->completion.args);
memcpy (&VAR_26->completion, &VAR_27, sizeof (VAR_27));
}
break;
case 'w':
if (VAR_3[1] == ' ') {
char *VAR_32 = r_str_trim_dup (VAR_3 + 1);
char *VAR_33 = strchr (VAR_32, ' ');
if (VAR_33) {
VAR_0 = VAR_33 + 1;
} else {
VAR_0 = """";
}
RFSFile *VAR_34 = r_fs_open (VAR_13->fs, VAR_32, true);
if (VAR_34) {
r_fs_write (VAR_13->fs, VAR_34, 0, (const ut8 *)VAR_0, strlen (VAR_0));
r_fs_close (VAR_13->fs, VAR_34);
r_fs_file_free (VAR_34);
VAR_28 (VAR_32);
}
} else {
eprintf (""Usage: mw [file] ([data])\n"");
}
break;
case 'y':
eprintf (""TODO\n"");
break;
case '?':
r_core_cmd_help (VAR_13, VAR_35);
break;
}
VAR_28 (VAR_4);
return 0;
}",radareorg/radare2/40453029179d230cf02ffed205f2d63e33981b8f/cmd_mount.c/vul/before/0.json,"static int cmd_mount(void *data, const char *_input) {
	ut64 off = 0;
	char *input, *oinput, *ptr, *ptr2;
	RList *list;
	RListIter *iter;
	RFSFile *file;
	RFSRoot *root;
	RFSPlugin *plug;
	RFSPartition *part;
	RCore *core = (RCore *)data;

	if (!strncmp (""kdir"", _input, 4)) {
		return cmd_mkdir (data, _input);
	}
	if (!strncmp (""v"", _input, 1)) {
		return cmd_mv (data, _input);
	}
	input = oinput = strdup (_input);

	switch (*input) {
	case ' ':
		input = (char *)r_str_trim_ro (input + 1);
		ptr = strchr (input, ' ');
		if (ptr) {
			*ptr = 0;
			ptr = (char *)r_str_trim_ro (ptr + 1);
			ptr2 = strchr (ptr, ' ');
			if (ptr2) {
				*ptr2 = 0;
				off = r_num_math (core->num, ptr2+1);
			}
			input = (char *)r_str_trim_ro (input);
			ptr = (char*)r_str_trim_ro (ptr);
			if (!r_fs_mount (core->fs, input, ptr, off)) {
				if (!r_fs_mount (core->fs, ptr, input, off)) {
					eprintf (""Cannot mount %s\n"", input);
				}
			}
		} else {
			if (!(ptr = r_fs_name (core->fs, core->offset))) {
				eprintf (""Unknown filesystem type\n"");
			}
			if (!r_fs_mount (core->fs, ptr, input, core->offset)) {
				eprintf (""Cannot mount %s\n"", input);
			}
			free (ptr);
		}
		break;
	case '-':
		r_fs_umount (core->fs, input+1);
		break;
	case 'j':
		{
			PJ *pj = pj_new ();
			pj_o (pj);
			pj_k (pj, ""mountpoints"");
			pj_a (pj);
			r_list_foreach (core->fs->roots, iter, root) {
				pj_o (pj);
				pj_ks (pj, ""path"", root->path);
				pj_ks (pj, ""plugin"", root->p->name);
				pj_kn (pj, ""offset"", root->delta);
				pj_end (pj);
			}
			pj_end (pj);
//
			pj_k (pj, ""plugins"");
			pj_a (pj);
			r_list_foreach (core->fs->plugins, iter, plug) {
				pj_o (pj);
				pj_ks (pj, ""name"", plug->name);
				pj_ks (pj, ""description"", plug->desc);
				pj_end (pj);
			}

			pj_end (pj);
			pj_end (pj);
			r_cons_printf (""%s\n"", pj_string (pj));
			pj_free (pj);
		}
		break;
	case '*':
		r_list_foreach (core->fs->roots, iter, root) {
			r_cons_printf (""m %s %s 0x%""PFMT64x""\n"",
				root-> path, root->p->name, root->delta);
		}
		break;
	case '\0':
		r_list_foreach (core->fs->roots, iter, root) {
			r_cons_printf (""%s\t0x%""PFMT64x""\t%s\n"",
				root->p->name, root->delta, root->path);
		}
		break;
	case 'L': // ""mL"" list of plugins
		r_list_foreach (core->fs->plugins, iter, plug) {
			r_cons_printf (""%10s  %s\n"", plug->name, plug->desc);
		}
		break;
	case 'l': // ""ml""
	case 'd': // ""md"" // should be deprecated. ls is better than dir :P
		cmd_mount_ls (core, input + 1);
		break;
	case 'p':
		input++;
		if (*input == ' ') {
			input++;
		}
		ptr = strchr (input, ' ');
		if (ptr) {
			*ptr = 0;
			off = r_num_math (core->num, ptr+1);
		}
		list = r_fs_partitions (core->fs, input, off);
		if (list) {
			r_list_foreach (list, iter, part) {
				r_cons_printf (""%d %02x 0x%010""PFMT64x"" 0x%010""PFMT64x""\n"",
					part->number, part->type,
					part->start, part->start+part->length);
			}
			r_list_free (list);
		} else {
			eprintf (""Cannot read partition\n"");
		}
		break;
	case 'o': //""mo""
		input++;
		if (input[0]==' ') {
			input++;
		}
		file = r_fs_open (core->fs, input, false);
		if (file) {
			r_fs_read (core->fs, file, 0, file->size);
			char *uri = r_str_newf (""malloc://%d"", file->size);
			RIODesc *fd = r_io_open (core->io, uri, R_PERM_RW, 0);
			if (fd) {
				r_io_desc_write (fd, file->data, file->size);
			}
		} else {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'i':
		input++;
		if (input[0]==' ') {
			input++;
		}
		file = r_fs_open (core->fs, input, false);
		if (file) {
			// XXX: dump to file or just pipe?
			r_fs_read (core->fs, file, 0, file->size);
			r_cons_printf (""f file %d 0x%08""PFMT64x""\n"", file->size, file->off);
			r_fs_close (core->fs, file);
		} else {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'c': // ""mc""
		input++;
		if (*input == ' ') {
			input++;
		}
		ptr = strchr (input, ' ');
		if (ptr) {
			*ptr++ = 0;
		} else {
			ptr = ""./"";
		}
		file = r_fs_open (core->fs, input, false);
		if (file) {
			r_fs_read (core->fs, file, 0, file->size);
			r_cons_memcat ((const char *)file->data, file->size);
			r_fs_close (core->fs, file);
			r_cons_memcat (""\n"", 1);
		} else if (!r_fs_dir_dump (core->fs, input, ptr)) {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'g': // ""mg""
		input++;
		if (*input == ' ') {
			input++;
		}
		ptr = strchr (input, ' ');
		if (ptr) {
			*ptr++ = 0;
		} else {
			ptr = ""./"";
		}
		file = r_fs_open (core->fs, input, false);
		if (file) {
			char *localFile = strdup (input);
			char *slash = (char *)r_str_rchr (localFile, NULL, '/');
			if (slash) {
				memmove (localFile, slash + 1, strlen (slash));
			}
			r_fs_read (core->fs, file, 0, file->size);
			r_file_dump (localFile, file->data, file->size, false);
			r_fs_close (core->fs, file);
			eprintf (""File '%s' created.\n"", localFile);
			free (localFile);
		} else if (!r_fs_dir_dump (core->fs, input, ptr)) {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'f':
		input++;
		switch (*input) {
		case '?':
			r_cons_printf (
			""Usage: mf[no] [...]\n""
			"" mfn /foo *.c       ; search files by name in /foo path\n""
			"" mfo /foo 0x5e91    ; search files by offset in /foo path\n""
			);
			break;
		case 'n':
			input++;
			if (*input == ' ')
				input++;
			ptr = strchr (input, ' ');
			if (ptr) {
				*ptr++ = 0;
				list = r_fs_find_name (core->fs, input, ptr);
				r_list_foreach (list, iter, ptr) {
					r_str_trim_path (ptr);
					printf (""%s\n"", ptr);
				}
				//XXX: r_list_purge (list);
			} else eprintf (""Unknown store path\n"");
			break;
		case 'o':
			input++;
			if (*input == ' ')
				input++;
			ptr = strchr (input, ' ');
			if (ptr) {
				*ptr++ = 0;
				ut64 off = r_num_math (core->num, ptr);
				list = r_fs_find_off (core->fs, input, off);
				r_list_foreach (list, iter, ptr) {
					r_str_trim_path (ptr);
					printf (""%s\n"", ptr);
				}
				//XXX: r_list_purge (list);
			} else eprintf (""Unknown store path\n"");
			break;
		}
		break;
	case 's': // ""ms""
		if (core->http_up) {
			free (oinput);
			return false;
		}
		input++;
		if (input[0] == ' ') {
			input++;
		}
		r_cons_set_raw (false);
		{
			RFSShell shell = {
				.cwd = &cwd,
				.set_prompt = r_line_set_prompt,
				.readline = r_line_readline,
				.hist_add = r_line_hist_add
			};
			RLine *rli = r_line_singleton ();
			RLineCompletion c;
			memcpy (&c, &rli->completion, sizeof (c));
			r_pvector_init (&rli->completion.args, free);  // UGLY HACK
			rli->completion.run = ms_autocomplete;
			rli->completion.run_user = rli->user;
			r_line_completion_set (&rli->completion, ms_argc, ms_argv);
			r_fs_shell_prompt (&shell, core->fs, input);
			R_FREE (cwd);
			r_pvector_clear (&rli->completion.args);
			memcpy (&rli->completion, &c, sizeof (c));
		}
		break;
	case 'w':
		if (input[1] == ' ') {
			char *args = r_str_trim_dup (input + 1);
			char *arg = strchr (args, ' ');
			if (arg) {
				data = arg + 1;
			} else {
				data = """";
				// touch and truncate
			}
			RFSFile *f = r_fs_open (core->fs, args, true);
			if (f) {
				r_fs_write (core->fs, f, 0, (const ut8 *)data, strlen (data));
				r_fs_close (core->fs, f);
				r_fs_file_free (f);
				free (args);
			}
		} else {
			eprintf (""Usage: mw [file] ([data])\n"");
		}
		break;
	case 'y':
		eprintf (""TODO\n"");
		break;
	case '?':
		r_core_cmd_help (core, help_msg_m);
		break;
	}
	free (oinput);
	return 0;
}","static int cmd_mount(void *VAR_0, const char *VAR_1) {
	ut64 VAR_2 = 0;
	char *VAR_3, *VAR_4, *VAR_5, *VAR_6;
	RList *VAR_7;
	RListIter *VAR_8;
	RFSFile *VAR_9;
	RFSRoot *VAR_10;
	RFSPlugin *VAR_11;
	RFSPartition *VAR_12;
	RCore *VAR_13 = (RCore *)VAR_0;

	if (!strncmp (""kdir"", VAR_1, 4)) {
		return cmd_mkdir (VAR_0, VAR_1);
	}
	if (!strncmp (""v"", VAR_1, 1)) {
		return cmd_mv (VAR_0, VAR_1);
	}
	VAR_3 = VAR_4 = strdup (VAR_1);

	switch (*VAR_3) {
	case ' ':
		VAR_3 = (char *)r_str_trim_ro (VAR_3 + 1);
		VAR_5 = strchr (VAR_3, ' ');
		if (VAR_5) {
			*VAR_5 = 0;
			VAR_5 = (char *)r_str_trim_ro (VAR_5 + 1);
			VAR_6 = strchr (VAR_5, ' ');
			if (VAR_6) {
				*VAR_6 = 0;
				VAR_2 = r_num_math (VAR_13->num, VAR_6+1);
			}
			VAR_3 = (char *)r_str_trim_ro (VAR_3);
			VAR_5 = (char*)r_str_trim_ro (VAR_5);
			if (!r_fs_mount (VAR_13->fs, VAR_3, VAR_5, VAR_2)) {
				if (!r_fs_mount (VAR_13->fs, VAR_5, VAR_3, VAR_2)) {
					eprintf (""Cannot mount %s\n"", VAR_3);
				}
			}
		} else {
			if (!(VAR_5 = r_fs_name (VAR_13->fs, VAR_13->offset))) {
				eprintf (""Unknown filesystem type\n"");
			}
			if (!r_fs_mount (VAR_13->fs, VAR_5, VAR_3, VAR_13->offset)) {
				eprintf (""Cannot mount %s\n"", VAR_3);
			}
			free (VAR_5);
		}
		break;
	case '-':
		r_fs_umount (VAR_13->fs, VAR_3+1);
		break;
	case 'j':
		{
			PJ *VAR_14 = pj_new ();
			pj_o (VAR_14);
			pj_k (VAR_14, ""mountpoints"");
			pj_a (VAR_14);
			r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
				pj_o (VAR_14);
				pj_ks (VAR_14, ""path"", VAR_10->path);
				pj_ks (VAR_14, ""plugin"", VAR_10->p->name);
				pj_kn (VAR_14, ""offset"", VAR_10->delta);
				pj_end (VAR_14);
			}
			pj_end (VAR_14);
/* COMMENT_0 */
			pj_k (VAR_14, ""plugins"");
			pj_a (VAR_14);
			r_list_foreach (VAR_13->fs->plugins, VAR_8, VAR_11) {
				pj_o (VAR_14);
				pj_ks (VAR_14, ""name"", VAR_11->name);
				pj_ks (VAR_14, ""description"", VAR_11->desc);
				pj_end (VAR_14);
			}

			pj_end (VAR_14);
			pj_end (VAR_14);
			r_cons_printf (""%s\n"", pj_string (VAR_14));
			pj_free (VAR_14);
		}
		break;
	case '*':
		r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
			r_cons_printf (""m %s %s 0x%""VAR_15""\n"",
				VAR_10-> path, VAR_10->p->name, VAR_10->delta);
		}
		break;
	case '\0':
		r_list_foreach (VAR_13->fs->roots, VAR_8, VAR_10) {
			r_cons_printf (""%s\t0x%""VAR_15""\t%s\n"",
				VAR_10->p->name, VAR_10->delta, VAR_10->path);
		}
		break;
	case 'L': /* COMMENT_1 */
		r_list_foreach (VAR_13->fs->plugins, VAR_8, VAR_11) {
			r_cons_printf (""%10s  %s\n"", VAR_11->name, VAR_11->desc);
		}
		break;
	case 'l': /* COMMENT_2 */
	case 'd': /* COMMENT_3 */
		cmd_mount_ls (VAR_13, VAR_3 + 1);
		break;
	case 'p':
		VAR_3++;
		if (*VAR_3 == ' ') {
			VAR_3++;
		}
		VAR_5 = strchr (VAR_3, ' ');
		if (VAR_5) {
			*VAR_5 = 0;
			VAR_2 = r_num_math (VAR_13->num, VAR_5+1);
		}
		VAR_7 = r_fs_partitions (VAR_13->fs, VAR_3, VAR_2);
		if (VAR_7) {
			r_list_foreach (VAR_7, VAR_8, VAR_12) {
				r_cons_printf (""%d %02x 0x%010""VAR_15"" 0x%010""VAR_15""\n"",
					VAR_12->number, VAR_12->type,
					VAR_12->start, VAR_12->start+VAR_12->length);
			}
			r_list_free (VAR_7);
		} else {
			eprintf (""Cannot read partition\n"");
		}
		break;
	case 'o': /* COMMENT_4 */
		VAR_3++;
		if (VAR_3[0]==' ') {
			VAR_3++;
		}
		VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
		if (VAR_9) {
			r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
			char *VAR_16 = r_str_newf (""malloc://%d"", VAR_9->size);
			RIODesc *VAR_17 = r_io_open (VAR_13->io, VAR_16, VAR_18, 0);
			if (VAR_17) {
				r_io_desc_write (VAR_17, VAR_9->data, VAR_9->size);
			}
		} else {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'i':
		VAR_3++;
		if (VAR_3[0]==' ') {
			VAR_3++;
		}
		VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
		if (VAR_9) {
			/* COMMENT_5 */
			r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
			r_cons_printf (""f file %d 0x%08""VAR_15""\n"", VAR_9->size, VAR_9->off);
			r_fs_close (VAR_13->fs, VAR_9);
		} else {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'c': /* COMMENT_6 */
		VAR_3++;
		if (*VAR_3 == ' ') {
			VAR_3++;
		}
		VAR_5 = strchr (VAR_3, ' ');
		if (VAR_5) {
			*VAR_5++ = 0;
		} else {
			VAR_5 = ""./"";
		}
		VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
		if (VAR_9) {
			r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
			r_cons_memcat ((const char *)VAR_9->data, VAR_9->size);
			r_fs_close (VAR_13->fs, VAR_9);
			r_cons_memcat (""\n"", 1);
		} else if (!r_fs_dir_dump (VAR_13->fs, VAR_3, VAR_5)) {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'g': /* COMMENT_7 */
		VAR_3++;
		if (*VAR_3 == ' ') {
			VAR_3++;
		}
		VAR_5 = strchr (VAR_3, ' ');
		if (VAR_5) {
			*VAR_5++ = 0;
		} else {
			VAR_5 = ""./"";
		}
		VAR_9 = r_fs_open (VAR_13->fs, VAR_3, false);
		if (VAR_9) {
			char *VAR_19 = strdup (VAR_3);
			char *VAR_20 = (char *)r_str_rchr (VAR_19, NULL, '/');
			if (VAR_20) {
				memmove (VAR_19, VAR_20 + 1, strlen (VAR_20));
			}
			r_fs_read (VAR_13->fs, VAR_9, 0, VAR_9->size);
			r_file_dump (VAR_19, VAR_9->data, VAR_9->size, false);
			r_fs_close (VAR_13->fs, VAR_9);
			eprintf (""File '%s' created.\n"", VAR_19);
			free (VAR_19);
		} else if (!r_fs_dir_dump (VAR_13->fs, VAR_3, VAR_5)) {
			eprintf (""Cannot open file\n"");
		}
		break;
	case 'f':
		VAR_3++;
		switch (*VAR_3) {
		case '?':
			r_cons_printf (
			""Usage: mf[no] [...]\n""
			"" mfn /foo *.c       ; search files by name in /foo path\n""
			"" mfo /foo 0x5e91    ; search files by offset in /foo path\n""
			);
			break;
		case 'n':
			VAR_3++;
			if (*VAR_3 == ' ')
				VAR_3++;
			VAR_5 = strchr (VAR_3, ' ');
			if (VAR_5) {
				*VAR_5++ = 0;
				VAR_7 = r_fs_find_name (VAR_13->fs, VAR_3, VAR_5);
				r_list_foreach (VAR_7, VAR_8, VAR_5) {
					r_str_trim_path (VAR_5);
					printf (""%s\n"", VAR_5);
				}
				/* COMMENT_8 */
			} else eprintf (""Unknown store path\n"");
			break;
		case 'o':
			VAR_3++;
			if (*VAR_3 == ' ')
				VAR_3++;
			VAR_5 = strchr (VAR_3, ' ');
			if (VAR_5) {
				*VAR_5++ = 0;
				ut64 VAR_2 = r_num_math (VAR_13->num, VAR_5);
				VAR_7 = r_fs_find_off (VAR_13->fs, VAR_3, VAR_2);
				r_list_foreach (VAR_7, VAR_8, VAR_5) {
					r_str_trim_path (VAR_5);
					printf (""%s\n"", VAR_5);
				}
				/* COMMENT_8 */
			} else eprintf (""Unknown store path\n"");
			break;
		}
		break;
	case 's': /* COMMENT_9 */
		if (VAR_13->http_up) {
			free (VAR_4);
			return false;
		}
		VAR_3++;
		if (VAR_3[0] == ' ') {
			VAR_3++;
		}
		r_cons_set_raw (false);
		{
			RFSShell VAR_21 = {
				.cwd = &VAR_22,
				.set_prompt = VAR_23,
				.readline = VAR_24,
				.hist_add = VAR_25
			};
			RLine *VAR_26 = r_line_singleton ();
			RLineCompletion VAR_27;
			memcpy (&VAR_27, &VAR_26->completion, sizeof (VAR_27));
			r_pvector_init (&VAR_26->completion.args, VAR_28);  /* COMMENT_10 */
			VAR_26->completion.run = VAR_29;
			VAR_26->completion.run_user = VAR_26->user;
			r_line_completion_set (&VAR_26->completion, VAR_30, VAR_31);
			r_fs_shell_prompt (&VAR_21, VAR_13->fs, VAR_3);
			R_FREE (VAR_22);
			r_pvector_clear (&VAR_26->completion.args);
			memcpy (&VAR_26->completion, &VAR_27, sizeof (VAR_27));
		}
		break;
	case 'w':
		if (VAR_3[1] == ' ') {
			char *VAR_32 = r_str_trim_dup (VAR_3 + 1);
			char *VAR_33 = strchr (VAR_32, ' ');
			if (VAR_33) {
				VAR_0 = VAR_33 + 1;
			} else {
				VAR_0 = """";
				/* COMMENT_11 */
			}
			RFSFile *VAR_34 = r_fs_open (VAR_13->fs, VAR_32, true);
			if (VAR_34) {
				r_fs_write (VAR_13->fs, VAR_34, 0, (const ut8 *)VAR_0, strlen (VAR_0));
				r_fs_close (VAR_13->fs, VAR_34);
				r_fs_file_free (VAR_34);
				VAR_28 (VAR_32);
			}
		} else {
			eprintf (""Usage: mw [file] ([data])\n"");
		}
		break;
	case 'y':
		eprintf (""TODO\n"");
		break;
	case '?':
		r_core_cmd_help (VAR_13, VAR_35);
		break;
	}
	VAR_28 (VAR_4);
	return 0;
}",radareorg/radare2/40453029179d230cf02ffed205f2d63e33981b8f/cmd_mount.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -270,7 +270,7 @@
 			rli->completion.run_user = rli->user;
 			r_line_completion_set (&rli->completion, ms_argc, ms_argv);
 			r_fs_shell_prompt (&shell, core->fs, input);
-			free (cwd);
+			R_FREE (cwd);
 			r_pvector_clear (&rli->completion.args);
 			memcpy (&rli->completion, &c, sizeof (c));
 		}","{'deleted_lines': ['\t\t\tfree (cwd);'], 'added_lines': ['\t\t\tR_FREE (cwd);']}",True,"In radare2 through 3.5.1, cmd_mount in libr/core/cmd_mount.c has a double free for the ms command.",5.5,MEDIUM,1,valid,2019-06-17T09:34:49Z,2
CVE-2019-13136,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1602,fe5f4b85e6b1b54d3b4588a77133c06ade46d891,https://github.com/ImageMagick/ImageMagick/commit/fe5f4b85e6b1b54d3b4588a77133c06ade46d891,coders/tiff.c,TIFFSeekCustomStream,"static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,
const int whence,void *user_data)
{
PhotoshopProfile
*profile;
profile=(PhotoshopProfile *) user_data;
switch (whence)
{
case SEEK_SET:
default:
{
if (offset < 0)
return(-1);
profile->offset=offset;
break;
}
case SEEK_CUR:
{
if ((profile->offset+offset) < 0)
return(-1);
profile->offset+=offset;
break;
}
case SEEK_END:
{
if (((MagickOffsetType) profile->length+offset) < 0)
return(-1);
profile->offset=profile->length+offset;
break;
}
}
return(profile->offset);
}","static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType VAR_0,
const int VAR_1,void *VAR_2)
{
PhotoshopProfile
*VAR_3;
VAR_3=(PhotoshopProfile *) VAR_2;
switch (VAR_1)
{
case VAR_4:
default:
{
if (VAR_0 < 0)
return(-1);
VAR_3->offset=VAR_0;
break;
}
case VAR_5:
{
if ((VAR_3->offset+VAR_0) < 0)
return(-1);
VAR_3->offset+=VAR_0;
break;
}
case VAR_6:
{
if (((MagickOffsetType) VAR_3->length+VAR_0) < 0)
return(-1);
VAR_3->offset=VAR_3->length+VAR_0;
break;
}
}
return(VAR_3->offset);
}",ImageMagick/fe5f4b85e6b1b54d3b4588a77133c06ade46d891/tiff.c/vul/before/0.json,"static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,
  const int whence,void *user_data)
{
  PhotoshopProfile
    *profile;

  profile=(PhotoshopProfile *) user_data;
  switch (whence)
  {
    case SEEK_SET:
    default:
    {
      if (offset < 0)
        return(-1);
      profile->offset=offset;
      break;
    }
    case SEEK_CUR:
    {
      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||
          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))
        {
          errno=EOVERFLOW;
          return(-1);
        }
      if ((profile->offset+offset) < 0)
        return(-1);
      profile->offset+=offset;
      break;
    }
    case SEEK_END:
    {
      if (((MagickOffsetType) profile->length+offset) < 0)
        return(-1);
      profile->offset=profile->length+offset;
      break;
    }
  }

  return(profile->offset);
}","static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType VAR_0,
  const int VAR_1,void *VAR_2)
{
  PhotoshopProfile
    *VAR_3;

  VAR_3=(PhotoshopProfile *) VAR_2;
  switch (VAR_1)
  {
    case VAR_4:
    default:
    {
      if (VAR_0 < 0)
        return(-1);
      VAR_3->offset=VAR_0;
      break;
    }
    case VAR_5:
    {
      if (((VAR_0 > 0) && (VAR_3->offset > (VAR_6-VAR_0))) ||
          ((VAR_0 < 0) && (VAR_3->offset < (-VAR_6-VAR_0))))
        {
          VAR_7=VAR_8;
          return(-1);
        }
      if ((VAR_3->offset+VAR_0) < 0)
        return(-1);
      VAR_3->offset+=VAR_0;
      break;
    }
    case VAR_9:
    {
      if (((MagickOffsetType) VAR_3->length+VAR_0) < 0)
        return(-1);
      VAR_3->offset=VAR_3->length+VAR_0;
      break;
    }
  }

  return(VAR_3->offset);
}",ImageMagick/fe5f4b85e6b1b54d3b4588a77133c06ade46d891/tiff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,12 @@
     }
     case SEEK_CUR:
     {
+      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||
+          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))
+        {
+          errno=EOVERFLOW;
+          return(-1);
+        }
       if ((profile->offset+offset) < 0)
         return(-1);
       profile->offset+=offset;","{'deleted_lines': [], 'added_lines': ['      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||', '          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))', '        {', '          errno=EOVERFLOW;', '          return(-1);', '        }']}",True,ImageMagick before 7.0.8-50 has an integer overflow vulnerability in the function TIFFSeekCustomStream in coders/tiff.c.,7.8,HIGH,2,valid,2019-06-18T15:57:54Z,2
CVE-2019-13298,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1611,d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,https://github.com/ImageMagick/ImageMagick/commit/d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,MagickCore/pixel-accessor.h,GetPixelChannel,"static inline Quantum GetPixelChannel(const Image *magick_restrict image,
const PixelChannel channel,const Quantum *magick_restrict pixel)
{
if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)
return((Quantum) 0);
return(pixel[image->channel_map[channel].offset]);
}","static inline Quantum GetPixelChannel(const Image *magick_restrict VAR_0,
const PixelChannel VAR_1,const Quantum *magick_restrict VAR_2)
{
if (VAR_0->channel_map[VAR_0->channel_map[VAR_1].offset].traits == VAR_3)
return((Quantum) 0);
return(VAR_2[VAR_0->channel_map[VAR_1].offset]);
}",,"static inline Quantum GetPixelChannel(const Image *magick_restrict image,
  const PixelChannel channel,const Quantum *magick_restrict pixel)
{
  if (image->channel_map[channel].traits == UndefinedPixelTrait)
    return((Quantum) 0);
  return(pixel[image->channel_map[channel].offset]);
}","static inline Quantum GetPixelChannel(const Image *magick_restrict VAR_0,
  const PixelChannel VAR_1,const Quantum *magick_restrict VAR_2)
{
  if (VAR_0->channel_map[VAR_1].traits == VAR_3)
    return((Quantum) 0);
  return(VAR_2[VAR_0->channel_map[VAR_1].offset]);
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static inline Quantum GetPixelChannel(const Image *magick_restrict image,
   const PixelChannel channel,const Quantum *magick_restrict pixel)
 {
-  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)
+  if (image->channel_map[channel].traits == UndefinedPixelTrait)
     return((Quantum) 0);
   return(pixel[image->channel_map[channel].offset]);
 }","{'deleted_lines': ['  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)'], 'added_lines': ['  if (image->channel_map[channel].traits == UndefinedPixelTrait)']}",True,ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/pixel-accessor.h in SetPixelViaPixelInfo because of a MagickCore/enhance.c error.,8.8,HIGH,2,valid,2019-06-22T00:41:29Z,2
CVE-2019-13298,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1611,d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,https://github.com/ImageMagick/ImageMagick/commit/d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,MagickCore/enhance.c,EnhanceImage,"MagickExport Image *EnhanceImage(const Image *image,ExceptionInfo *exception)
{
#define EnhanceImageTag  ""Enhance/Image""
#define EnhancePixel(weight) \
mean=QuantumScale*((double) GetPixelRed(image,r)+pixel.red)/2.0; \
distance=QuantumScale*((double) GetPixelRed(image,r)-pixel.red); \
distance_squared=(4.0+mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelGreen(image,r)+pixel.green)/2.0; \
distance=QuantumScale*((double) GetPixelGreen(image,r)-pixel.green); \
distance_squared+=(7.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelBlue(image,r)+pixel.blue)/2.0; \
distance=QuantumScale*((double) GetPixelBlue(image,r)-pixel.blue); \
distance_squared+=(5.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelBlack(image,r)+pixel.black)/2.0; \
distance=QuantumScale*((double) GetPixelBlack(image,r)-pixel.black); \
distance_squared+=(5.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelAlpha(image,r)+pixel.alpha)/2.0; \
distance=QuantumScale*((double) GetPixelAlpha(image,r)-pixel.alpha); \
distance_squared+=(5.0-mean)*distance*distance; \
if (distance_squared < 0.069) \
{ \
aggregate.red+=(weight)*GetPixelRed(image,r); \
aggregate.green+=(weight)*GetPixelGreen(image,r); \
aggregate.blue+=(weight)*GetPixelBlue(image,r); \
aggregate.black+=(weight)*GetPixelBlack(image,r); \
aggregate.alpha+=(weight)*GetPixelAlpha(image,r); \
total_weight+=(weight); \
} \
r+=GetPixelChannels(image);
CacheView
*enhance_view,
*image_view;
Image
*enhance_image;
MagickBooleanType
status;
MagickOffsetType
progress;
ssize_t
y;
assert(image != (const Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
enhance_image=CloneImage(image,0,0,MagickTrue,
exception);
if (enhance_image == (Image *) NULL)
return((Image *) NULL);
if (SetImageStorageClass(enhance_image,DirectClass,exception) == MagickFalse)
{
enhance_image=DestroyImage(enhance_image);
return((Image *) NULL);
}
status=MagickTrue;
progress=0;
image_view=AcquireVirtualCacheView(image,exception);
enhance_view=AcquireAuthenticCacheView(enhance_image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static) shared(progress,status) \
magick_number_threads(image,enhance_image,image->rows,1)
#endif
for (y=0; y < (ssize_t) image->rows; y++)
{
PixelInfo
pixel;
register const Quantum
*magick_restrict p;
register Quantum
*magick_restrict q;
register ssize_t
x;
ssize_t
center;
if (status == MagickFalse)
continue;
p=GetCacheViewVirtualPixels(image_view,-2,y-2,image->columns+4,5,exception);
q=QueueCacheViewAuthenticPixels(enhance_view,0,y,enhance_image->columns,1,
exception);
if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
{
status=MagickFalse;
continue;
}
center=(ssize_t) GetPixelChannels(image)*(2*(image->columns+4)+2);
GetPixelInfo(image,&pixel);
for (x=0; x < (ssize_t) image->columns; x++)
{
double
distance,
distance_squared,
mean,
total_weight;
PixelInfo
aggregate;
register const Quantum
*magick_restrict r;
GetPixelInfo(image,&aggregate);
total_weight=0.0;
GetPixelInfoPixel(image,p+center,&pixel);
r=p;
EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
EnhancePixel(8.0); EnhancePixel(5.0);
r=p+GetPixelChannels(image)*(image->columns+4);
EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
EnhancePixel(20.0); EnhancePixel(8.0);
r=p+2*GetPixelChannels(image)*(image->columns+4);
EnhancePixel(10.0); EnhancePixel(40.0); EnhancePixel(80.0);
EnhancePixel(40.0); EnhancePixel(10.0);
r=p+3*GetPixelChannels(image)*(image->columns+4);
EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
EnhancePixel(20.0); EnhancePixel(8.0);
r=p+4*GetPixelChannels(image)*(image->columns+4);
EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
EnhancePixel(8.0); EnhancePixel(5.0);
if (total_weight > MagickEpsilon)
{
pixel.red=((aggregate.red+total_weight/2.0)/total_weight);
pixel.green=((aggregate.green+total_weight/2.0)/total_weight);
pixel.blue=((aggregate.blue+total_weight/2.0)/total_weight);
pixel.black=((aggregate.black+total_weight/2.0)/total_weight);
pixel.alpha=((aggregate.alpha+total_weight/2.0)/total_weight);
}
SetPixelViaPixelInfo(image,&pixel,q);
p+=GetPixelChannels(image);
q+=GetPixelChannels(enhance_image);
}
if (SyncCacheViewAuthenticPixels(enhance_view,exception) == MagickFalse)
status=MagickFalse;
if (image->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
proceed;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp atomic
#endif
progress++;
proceed=SetImageProgress(image,EnhanceImageTag,progress,image->rows);
if (proceed == MagickFalse)
status=MagickFalse;
}
}
enhance_view=DestroyCacheView(enhance_view);
image_view=DestroyCacheView(image_view);
if (status == MagickFalse)
enhance_image=DestroyImage(enhance_image);
return(enhance_image);
}","MagickExport VAR_0 *EnhanceImage(const Image *VAR_1,ExceptionInfo *VAR_2)
{
#define VAR_3  ""Enhance/Image""
#define EnhancePixel(VAR_4) \
mean=QuantumScale*((double) GetPixelRed(image,r)+pixel.red)/2.0; \
distance=QuantumScale*((double) GetPixelRed(image,r)-pixel.red); \
distance_squared=(4.0+mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelGreen(image,r)+pixel.green)/2.0; \
distance=QuantumScale*((double) GetPixelGreen(image,r)-pixel.green); \
distance_squared+=(7.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelBlue(image,r)+pixel.blue)/2.0; \
distance=QuantumScale*((double) GetPixelBlue(image,r)-pixel.blue); \
distance_squared+=(5.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelBlack(image,r)+pixel.black)/2.0; \
distance=QuantumScale*((double) GetPixelBlack(image,r)-pixel.black); \
distance_squared+=(5.0-mean)*distance*distance; \
mean=QuantumScale*((double) GetPixelAlpha(image,r)+pixel.alpha)/2.0; \
distance=QuantumScale*((double) GetPixelAlpha(image,r)-pixel.alpha); \
distance_squared+=(5.0-mean)*distance*distance; \
if (distance_squared < 0.069) \
{ \
aggregate.red+=(weight)*GetPixelRed(image,r); \
aggregate.green+=(weight)*GetPixelGreen(image,r); \
aggregate.blue+=(weight)*GetPixelBlue(image,r); \
aggregate.black+=(weight)*GetPixelBlack(image,r); \
aggregate.alpha+=(weight)*GetPixelAlpha(image,r); \
total_weight+=(weight); \
} \
r+=GetPixelChannels(image);
CacheView
*VAR_5,
*VAR_6;
Image
*VAR_7;
MagickBooleanType
VAR_8;
MagickOffsetType
VAR_9;
ssize_t
VAR_10;
assert(VAR_1 != (const Image *) NULL);
assert(VAR_1->signature == VAR_11);
if (VAR_1->debug != VAR_12)
(void) LogMagickEvent(VAR_13,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_11);
VAR_7=CloneImage(VAR_1,0,0,VAR_14,
VAR_2);
if (VAR_7 == (Image *) NULL)
return((Image *) NULL);
if (SetImageStorageClass(VAR_7,VAR_15,VAR_2) == VAR_12)
{
VAR_7=DestroyImage(VAR_7);
return((Image *) NULL);
}
VAR_8=VAR_14;
VAR_9=0;
VAR_6=AcquireVirtualCacheView(VAR_1,VAR_2);
VAR_5=AcquireAuthenticCacheView(VAR_7,VAR_2);
#if defined(VAR_16)
#pragma omp parallel for schedule(static) shared(progress,status) \
magick_number_threads(image,enhance_image,image->rows,1)
#endif
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
{
PixelInfo
VAR_17;
register const Quantum
*magick_restrict VAR_18;
register Quantum
*magick_restrict VAR_19;
register ssize_t
VAR_20;
ssize_t
VAR_21;
if (VAR_8 == VAR_12)
continue;
VAR_18=GetCacheViewVirtualPixels(VAR_6,-2,VAR_10-2,VAR_1->columns+4,5,VAR_2);
VAR_19=QueueCacheViewAuthenticPixels(VAR_5,0,VAR_10,VAR_7->columns,1,
VAR_2);
if ((VAR_18 == (const Quantum *) NULL) || (VAR_19 == (Quantum *) NULL))
{
VAR_8=VAR_12;
continue;
}
VAR_21=(ssize_t) GetPixelChannels(VAR_1)*(2*(VAR_1->columns+4)+2);
GetPixelInfo(VAR_1,&VAR_17);
for (VAR_20=0; VAR_20 < (ssize_t) VAR_1->columns; VAR_20++)
{
double
VAR_22,
VAR_23,
VAR_24,
VAR_25;
PixelInfo
VAR_26;
register const Quantum
*magick_restrict VAR_27;
GetPixelInfo(VAR_1,&VAR_26);
VAR_25=0.0;
GetPixelInfoPixel(VAR_1,VAR_18+VAR_21,&VAR_17);
VAR_27=VAR_18;
EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
EnhancePixel(8.0); EnhancePixel(5.0);
VAR_27=VAR_18+GetPixelChannels(VAR_1)*(VAR_1->columns+4);
EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
EnhancePixel(20.0); EnhancePixel(8.0);
VAR_27=VAR_18+2*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
EnhancePixel(10.0); EnhancePixel(40.0); EnhancePixel(80.0);
EnhancePixel(40.0); EnhancePixel(10.0);
VAR_27=VAR_18+3*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
EnhancePixel(20.0); EnhancePixel(8.0);
VAR_27=VAR_18+4*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
EnhancePixel(8.0); EnhancePixel(5.0);
if (VAR_25 > VAR_28)
{
VAR_17.red=((VAR_26.red+VAR_25/2.0)/VAR_25);
VAR_17.green=((VAR_26.green+VAR_25/2.0)/VAR_25);
VAR_17.blue=((VAR_26.blue+VAR_25/2.0)/VAR_25);
VAR_17.black=((VAR_26.black+VAR_25/2.0)/VAR_25);
VAR_17.alpha=((VAR_26.alpha+VAR_25/2.0)/VAR_25);
}
SetPixelViaPixelInfo(VAR_1,&VAR_17,VAR_19);
VAR_18+=GetPixelChannels(VAR_1);
VAR_19+=GetPixelChannels(VAR_7);
}
if (SyncCacheViewAuthenticPixels(VAR_5,VAR_2) == VAR_12)
VAR_8=VAR_12;
if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
VAR_29;
#if defined(VAR_16)
#pragma omp atomic
#endif
VAR_9++;
VAR_29=SetImageProgress(VAR_1,VAR_3,VAR_9,VAR_1->rows);
if (VAR_29 == VAR_12)
VAR_8=VAR_12;
}
}
VAR_5=DestroyCacheView(VAR_5);
VAR_6=DestroyCacheView(VAR_6);
if (VAR_8 == VAR_12)
VAR_7=DestroyImage(VAR_7);
return(VAR_7);
}",,"MagickExport Image *EnhanceImage(const Image *image,ExceptionInfo *exception)
{
#define EnhanceImageTag  ""Enhance/Image""
#define EnhancePixel(weight) \
  mean=QuantumScale*((double) GetPixelRed(image,r)+pixel.red)/2.0; \
  distance=QuantumScale*((double) GetPixelRed(image,r)-pixel.red); \
  distance_squared=(4.0+mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelGreen(image,r)+pixel.green)/2.0; \
  distance=QuantumScale*((double) GetPixelGreen(image,r)-pixel.green); \
  distance_squared+=(7.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelBlue(image,r)+pixel.blue)/2.0; \
  distance=QuantumScale*((double) GetPixelBlue(image,r)-pixel.blue); \
  distance_squared+=(5.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelBlack(image,r)+pixel.black)/2.0; \
  distance=QuantumScale*((double) GetPixelBlack(image,r)-pixel.black); \
  distance_squared+=(5.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelAlpha(image,r)+pixel.alpha)/2.0; \
  distance=QuantumScale*((double) GetPixelAlpha(image,r)-pixel.alpha); \
  distance_squared+=(5.0-mean)*distance*distance; \
  if (distance_squared < 0.069) \
    { \
      aggregate.red+=(weight)*GetPixelRed(image,r); \
      aggregate.green+=(weight)*GetPixelGreen(image,r); \
      aggregate.blue+=(weight)*GetPixelBlue(image,r); \
      aggregate.black+=(weight)*GetPixelBlack(image,r); \
      aggregate.alpha+=(weight)*GetPixelAlpha(image,r); \
      total_weight+=(weight); \
    } \
  r+=GetPixelChannels(image);

  CacheView
    *enhance_view,
    *image_view;

  Image
    *enhance_image;

  MagickBooleanType
    status;

  MagickOffsetType
    progress;

  ssize_t
    y;

  /*
    Initialize enhanced image attributes.
  */
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  enhance_image=CloneImage(image,0,0,MagickTrue,
    exception);
  if (enhance_image == (Image *) NULL)
    return((Image *) NULL);
  if (SetImageStorageClass(enhance_image,DirectClass,exception) == MagickFalse)
    {
      enhance_image=DestroyImage(enhance_image);
      return((Image *) NULL);
    }
  /*
    Enhance image.
  */
  status=MagickTrue;
  progress=0;
  image_view=AcquireVirtualCacheView(image,exception);
  enhance_view=AcquireAuthenticCacheView(enhance_image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static) shared(progress,status) \
    magick_number_threads(image,enhance_image,image->rows,1)
#endif
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    PixelInfo
      pixel;

    register const Quantum
      *magick_restrict p;

    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    ssize_t
      center;

    if (status == MagickFalse)
      continue;
    p=GetCacheViewVirtualPixels(image_view,-2,y-2,image->columns+4,5,exception);
    q=QueueCacheViewAuthenticPixels(enhance_view,0,y,enhance_image->columns,1,
      exception);
    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
      {
        status=MagickFalse;
        continue;
      }
    center=(ssize_t) GetPixelChannels(image)*(2*(image->columns+4)+2);
    GetPixelInfo(image,&pixel);
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      double
        distance,
        distance_squared,
        mean,
        total_weight;

      PixelInfo
        aggregate;

      register const Quantum
        *magick_restrict r;

      GetPixelInfo(image,&aggregate);
      total_weight=0.0;
      GetPixelInfoPixel(image,p+center,&pixel);
      r=p;
      EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
        EnhancePixel(8.0); EnhancePixel(5.0);
      r=p+GetPixelChannels(image)*(image->columns+4);
      EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
        EnhancePixel(20.0); EnhancePixel(8.0);
      r=p+2*GetPixelChannels(image)*(image->columns+4);
      EnhancePixel(10.0); EnhancePixel(40.0); EnhancePixel(80.0);
        EnhancePixel(40.0); EnhancePixel(10.0);
      r=p+3*GetPixelChannels(image)*(image->columns+4);
      EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
        EnhancePixel(20.0); EnhancePixel(8.0);
      r=p+4*GetPixelChannels(image)*(image->columns+4);
      EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
        EnhancePixel(8.0); EnhancePixel(5.0);
      if (total_weight > MagickEpsilon)
        {
          pixel.red=((aggregate.red+total_weight/2.0)/total_weight);
          pixel.green=((aggregate.green+total_weight/2.0)/total_weight);
          pixel.blue=((aggregate.blue+total_weight/2.0)/total_weight);
          pixel.black=((aggregate.black+total_weight/2.0)/total_weight);
          pixel.alpha=((aggregate.alpha+total_weight/2.0)/total_weight);
        }
      SetPixelViaPixelInfo(enhance_image,&pixel,q);
      p+=GetPixelChannels(image);
      q+=GetPixelChannels(enhance_image);
    }
    if (SyncCacheViewAuthenticPixels(enhance_view,exception) == MagickFalse)
      status=MagickFalse;
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          proceed;

#if defined(MAGICKCORE_OPENMP_SUPPORT)
        #pragma omp atomic
#endif
        progress++;
        proceed=SetImageProgress(image,EnhanceImageTag,progress,image->rows);
        if (proceed == MagickFalse)
          status=MagickFalse;
      }
  }
  enhance_view=DestroyCacheView(enhance_view);
  image_view=DestroyCacheView(image_view);
  if (status == MagickFalse)
    enhance_image=DestroyImage(enhance_image);
  return(enhance_image);
}","MagickExport VAR_0 *EnhanceImage(const Image *VAR_1,ExceptionInfo *VAR_2)
{
#define VAR_3  ""Enhance/Image""
#define EnhancePixel(VAR_4) \
  mean=QuantumScale*((double) GetPixelRed(image,r)+pixel.red)/2.0; \
  distance=QuantumScale*((double) GetPixelRed(image,r)-pixel.red); \
  distance_squared=(4.0+mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelGreen(image,r)+pixel.green)/2.0; \
  distance=QuantumScale*((double) GetPixelGreen(image,r)-pixel.green); \
  distance_squared+=(7.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelBlue(image,r)+pixel.blue)/2.0; \
  distance=QuantumScale*((double) GetPixelBlue(image,r)-pixel.blue); \
  distance_squared+=(5.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelBlack(image,r)+pixel.black)/2.0; \
  distance=QuantumScale*((double) GetPixelBlack(image,r)-pixel.black); \
  distance_squared+=(5.0-mean)*distance*distance; \
  mean=QuantumScale*((double) GetPixelAlpha(image,r)+pixel.alpha)/2.0; \
  distance=QuantumScale*((double) GetPixelAlpha(image,r)-pixel.alpha); \
  distance_squared+=(5.0-mean)*distance*distance; \
  if (distance_squared < 0.069) \
    { \
      aggregate.red+=(weight)*GetPixelRed(image,r); \
      aggregate.green+=(weight)*GetPixelGreen(image,r); \
      aggregate.blue+=(weight)*GetPixelBlue(image,r); \
      aggregate.black+=(weight)*GetPixelBlack(image,r); \
      aggregate.alpha+=(weight)*GetPixelAlpha(image,r); \
      total_weight+=(weight); \
    } \
  r+=GetPixelChannels(image);

  CacheView
    *VAR_5,
    *VAR_6;

  Image
    *VAR_7;

  MagickBooleanType
    VAR_8;

  MagickOffsetType
    VAR_9;

  ssize_t
    VAR_10;

  /* COMMENT_0 */
                                         
    
  assert(VAR_1 != (const Image *) NULL);
  assert(VAR_1->signature == VAR_11);
  if (VAR_1->debug != VAR_12)
    (void) LogMagickEvent(VAR_13,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_11);
  VAR_7=CloneImage(VAR_1,0,0,VAR_14,
    VAR_2);
  if (VAR_7 == (Image *) NULL)
    return((Image *) NULL);
  if (SetImageStorageClass(VAR_7,VAR_15,VAR_2) == VAR_12)
    {
      VAR_7=DestroyImage(VAR_7);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                  
    
  VAR_8=VAR_14;
  VAR_9=0;
  VAR_6=AcquireVirtualCacheView(VAR_1,VAR_2);
  VAR_5=AcquireAuthenticCacheView(VAR_7,VAR_2);
#if defined(VAR_16)
  #pragma omp parallel for schedule(static) shared(progress,status) \
    magick_number_threads(image,enhance_image,image->rows,1)
#endif
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->rows; VAR_10++)
  {
    PixelInfo
      VAR_17;

    register const Quantum
      *magick_restrict VAR_18;

    register Quantum
      *magick_restrict VAR_19;

    register ssize_t
      VAR_20;

    ssize_t
      VAR_21;

    if (VAR_8 == VAR_12)
      continue;
    VAR_18=GetCacheViewVirtualPixels(VAR_6,-2,VAR_10-2,VAR_1->columns+4,5,VAR_2);
    VAR_19=QueueCacheViewAuthenticPixels(VAR_5,0,VAR_10,VAR_7->columns,1,
      VAR_2);
    if ((VAR_18 == (const Quantum *) NULL) || (VAR_19 == (Quantum *) NULL))
      {
        VAR_8=VAR_12;
        continue;
      }
    VAR_21=(ssize_t) GetPixelChannels(VAR_1)*(2*(VAR_1->columns+4)+2);
    GetPixelInfo(VAR_1,&VAR_17);
    for (VAR_20=0; VAR_20 < (ssize_t) VAR_1->columns; VAR_20++)
    {
      double
        VAR_22,
        VAR_23,
        VAR_24,
        VAR_25;

      PixelInfo
        VAR_26;

      register const Quantum
        *magick_restrict VAR_27;

      GetPixelInfo(VAR_1,&VAR_26);
      VAR_25=0.0;
      GetPixelInfoPixel(VAR_1,VAR_18+VAR_21,&VAR_17);
      VAR_27=VAR_18;
      EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
        EnhancePixel(8.0); EnhancePixel(5.0);
      VAR_27=VAR_18+GetPixelChannels(VAR_1)*(VAR_1->columns+4);
      EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
        EnhancePixel(20.0); EnhancePixel(8.0);
      VAR_27=VAR_18+2*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
      EnhancePixel(10.0); EnhancePixel(40.0); EnhancePixel(80.0);
        EnhancePixel(40.0); EnhancePixel(10.0);
      VAR_27=VAR_18+3*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
      EnhancePixel(8.0); EnhancePixel(20.0); EnhancePixel(40.0);
        EnhancePixel(20.0); EnhancePixel(8.0);
      VAR_27=VAR_18+4*GetPixelChannels(VAR_1)*(VAR_1->columns+4);
      EnhancePixel(5.0); EnhancePixel(8.0); EnhancePixel(10.0);
        EnhancePixel(8.0); EnhancePixel(5.0);
      if (VAR_25 > VAR_28)
        {
          VAR_17.red=((VAR_26.red+VAR_25/2.0)/VAR_25);
          VAR_17.green=((VAR_26.green+VAR_25/2.0)/VAR_25);
          VAR_17.blue=((VAR_26.blue+VAR_25/2.0)/VAR_25);
          VAR_17.black=((VAR_26.black+VAR_25/2.0)/VAR_25);
          VAR_17.alpha=((VAR_26.alpha+VAR_25/2.0)/VAR_25);
        }
      SetPixelViaPixelInfo(VAR_7,&VAR_17,VAR_19);
      VAR_18+=GetPixelChannels(VAR_1);
      VAR_19+=GetPixelChannels(VAR_7);
    }
    if (SyncCacheViewAuthenticPixels(VAR_5,VAR_2) == VAR_12)
      VAR_8=VAR_12;
    if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          VAR_29;

#if defined(VAR_16)
        #pragma omp atomic
#endif
        VAR_9++;
        VAR_29=SetImageProgress(VAR_1,VAR_3,VAR_9,VAR_1->rows);
        if (VAR_29 == VAR_12)
          VAR_8=VAR_12;
      }
  }
  VAR_5=DestroyCacheView(VAR_5);
  VAR_6=DestroyCacheView(VAR_6);
  if (VAR_8 == VAR_12)
    VAR_7=DestroyImage(VAR_7);
  return(VAR_7);
}",,"--- func_before
+++ func_after
@@ -142,7 +142,7 @@
           pixel.black=((aggregate.black+total_weight/2.0)/total_weight);
           pixel.alpha=((aggregate.alpha+total_weight/2.0)/total_weight);
         }
-      SetPixelViaPixelInfo(image,&pixel,q);
+      SetPixelViaPixelInfo(enhance_image,&pixel,q);
       p+=GetPixelChannels(image);
       q+=GetPixelChannels(enhance_image);
     }","{'deleted_lines': ['      SetPixelViaPixelInfo(image,&pixel,q);'], 'added_lines': ['      SetPixelViaPixelInfo(enhance_image,&pixel,q);']}",True,ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/pixel-accessor.h in SetPixelViaPixelInfo because of a MagickCore/enhance.c error.,8.8,HIGH,2,valid,2019-06-22T00:41:29Z,2
CVE-2019-13618,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gpac,fixed heap buffer overflow in gf_m2ts_sync #1250,c23d54ed15a70b4543e3191e6ead5097cda0878b,https://github.com/gpac/gpac/commit/c23d54ed15a70b4543e3191e6ead5097cda0878b,src/media_tools/mpegts.c,gf_m2ts_sync,"static u32 gf_m2ts_sync(GF_M2TS_Demuxer *ts, Bool simple_check)
{
u32 i=0;
if (simple_check && (ts->buffer[i]==0x47)) return 0;
while (i<ts->buffer_size) {
if (i+188>ts->buffer_size) return ts->buffer_size;
if ((ts->buffer[i]==0x47) && (ts->buffer[i+188]==0x47))
break;
if ((ts->buffer[i]==0x47) && (ts->buffer[i+192]==0x47)) {
ts->prefix_present = 1;
break;
}
i++;
}
if (i) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] re-sync skipped %d bytes\n"", i) );
}
return i;
}","static u32 gf_m2ts_sync(GF_M2TS_Demuxer *VAR_0, Bool VAR_1)
{
u32 VAR_2=0;
if (VAR_1 && (VAR_0->buffer[VAR_2]==0x47)) return 0;
while (VAR_2<VAR_0->buffer_size) {
if (VAR_2+188>VAR_0->buffer_size) return VAR_0->buffer_size;
if ((VAR_0->buffer[VAR_2]==0x47) && (VAR_0->buffer[VAR_2+188]==0x47))
break;
if ((VAR_0->buffer[VAR_2]==0x47) && (VAR_0->buffer[VAR_2+192]==0x47)) {
VAR_0->prefix_present = 1;
break;
}
VAR_2++;
}
if (VAR_2) {
GF_LOG(VAR_3, VAR_4, (""[MPEG-2 TS] re-sync skipped %d bytes\n"", VAR_2) );
}
return VAR_2;
}",gpac/c23d54ed15a70b4543e3191e6ead5097cda0878b/mpegts.c/vul/before/0.json,"static u32 gf_m2ts_sync(GF_M2TS_Demuxer *ts, Bool simple_check)
{
	u32 i=0;
	/*if first byte is sync assume we're sync*/
	if (simple_check && (ts->buffer[i]==0x47)) return 0;

	while (i<ts->buffer_size) {
		if (i+188>=ts->buffer_size) return ts->buffer_size;
		if ((ts->buffer[i]==0x47) && (ts->buffer[i+188]==0x47))
			break;
		if (i+192>=ts->buffer_size) return ts->buffer_size;
		if ((ts->buffer[i]==0x47) && (ts->buffer[i+192]==0x47)) {
			ts->prefix_present = 1;
			break;
		}
		i++;
	}
	if (i) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] re-sync skipped %d bytes\n"", i) );
	}
	return i;
}","static u32 gf_m2ts_sync(GF_M2TS_Demuxer *VAR_0, Bool VAR_1)
{
	u32 VAR_2=0;
	/* COMMENT_0 */
	if (VAR_1 && (VAR_0->buffer[VAR_2]==0x47)) return 0;

	while (VAR_2<VAR_0->buffer_size) {
		if (VAR_2+188>=VAR_0->buffer_size) return VAR_0->buffer_size;
		if ((VAR_0->buffer[VAR_2]==0x47) && (VAR_0->buffer[VAR_2+188]==0x47))
			break;
		if (VAR_2+192>=VAR_0->buffer_size) return VAR_0->buffer_size;
		if ((VAR_0->buffer[VAR_2]==0x47) && (VAR_0->buffer[VAR_2+192]==0x47)) {
			VAR_0->prefix_present = 1;
			break;
		}
		VAR_2++;
	}
	if (VAR_2) {
		GF_LOG(VAR_3, VAR_4, (""[MPEG-2 TS] re-sync skipped %d bytes\n"", VAR_2) );
	}
	return VAR_2;
}",gpac/c23d54ed15a70b4543e3191e6ead5097cda0878b/mpegts.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,9 +5,10 @@
 	if (simple_check && (ts->buffer[i]==0x47)) return 0;
 
 	while (i<ts->buffer_size) {
-		if (i+188>ts->buffer_size) return ts->buffer_size;
+		if (i+188>=ts->buffer_size) return ts->buffer_size;
 		if ((ts->buffer[i]==0x47) && (ts->buffer[i+188]==0x47))
 			break;
+		if (i+192>=ts->buffer_size) return ts->buffer_size;
 		if ((ts->buffer[i]==0x47) && (ts->buffer[i+192]==0x47)) {
 			ts->prefix_present = 1;
 			break;","{'deleted_lines': ['\t\tif (i+188>ts->buffer_size) return ts->buffer_size;'], 'added_lines': ['\t\tif (i+188>=ts->buffer_size) return ts->buffer_size;', '\t\tif (i+192>=ts->buffer_size) return ts->buffer_size;']}",True,"In GPAC before 0.8.0, isomedia/isom_read.c in libgpac.a has a heap-based buffer over-read, as demonstrated by a crash in gf_m2ts_sync in media_tools/mpegts.c.",7.5,HIGH,2,valid,2019-06-24T15:03:56Z,2
CVE-2019-13618,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gpac,fixed heap buffer overflow in gf_m2ts_sync #1250,c23d54ed15a70b4543e3191e6ead5097cda0878b,https://github.com/gpac/gpac/commit/c23d54ed15a70b4543e3191e6ead5097cda0878b,src/isomedia/isom_read.c,gf_isom_write,"GF_EXPORT
GF_Err gf_isom_write(GF_ISOFile *movie) {
GF_Err e;
if (movie == NULL) return GF_ISOM_INVALID_FILE;
e = GF_OK;
#ifndef GPAC_DISABLE_ISOM_WRITE
if (movie->openMode != GF_ISOM_OPEN_READ) {
gf_isom_get_duration(movie);
#ifndefGPAC_DISABLE_ISOM_FRAGMENTS
if ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {
e = gf_isom_close_fragments(movie);
if (e) return e;
if (movie->mfra) {
if (!movie->mfra->mfro)
movie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_MFRO);
e = gf_isom_box_size((GF_Box *)movie->mfra);
if (e) return e;
movie->mfra->mfro->container_size = (u32) movie->mfra->size;
e = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);
}
} else
#endif
e = WriteToFile(movie);
}
#endif 
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
if (movie->moov) {
u32 i;
for (i=0; i<gf_list_count(movie->moov->trackList); i++) {
GF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);
if (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))
gf_isom_datamap_del(trak->Media->information->scalableDataHandler);
}
}
#endif
return e;
}","GF_EXPORT
VAR_0 gf_isom_write(GF_ISOFile *VAR_1) {
GF_Err VAR_2;
if (VAR_1 == NULL) return VAR_3;
VAR_2 = VAR_4;
#ifndef VAR_5
if (VAR_1->openMode != VAR_6) {
gf_isom_get_duration(VAR_1);
#ifndefVAR_7
if ( (VAR_1->openMode == VAR_8) && (VAR_1->FragmentsFlags & VAR_9) ) {
VAR_2 = gf_isom_close_fragments(VAR_1);
if (VAR_2) return VAR_2;
if (VAR_1->mfra) {
if (!VAR_1->mfra->mfro)
VAR_1->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new(VAR_10);
VAR_2 = gf_isom_box_size((GF_Box *)VAR_1->mfra);
if (VAR_2) return VAR_2;
VAR_1->mfra->mfro->container_size = (u32) VAR_1->mfra->size;
VAR_2 = gf_isom_box_write((GF_Box *)VAR_1->mfra, VAR_1->editFileMap->bs);
}
} else
#endif
VAR_2 = WriteToFile(VAR_1);
}
#endif 
#ifndef VAR_7
if (VAR_1->moov) {
u32 VAR_11;
for (VAR_11=0; VAR_11<gf_list_count(VAR_1->moov->trackList); VAR_11++) {
GF_TrackBox *VAR_12 = (GF_TrackBox*)gf_list_get(VAR_1->moov->trackList, VAR_11);
if (VAR_12->Media && VAR_12->Media->information && VAR_12->Media->information->scalableDataHandler && (VAR_12->Media->information->scalableDataHandler != VAR_1->movieFileMap))
gf_isom_datamap_del(VAR_12->Media->information->scalableDataHandler);
}
}
#endif
return VAR_2;
}",,"GF_EXPORT
GF_Err gf_isom_write(GF_ISOFile *movie) {
	GF_Err e;
	if (movie == NULL) return GF_ISOM_INVALID_FILE;
	e = GF_OK;

#ifndef GPAC_DISABLE_ISOM_WRITE
	//write our movie to the file
	if (movie->openMode != GF_ISOM_OPEN_READ) {
		gf_isom_get_duration(movie);
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
		//movie fragment mode, just store the fragment
		if ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {
			e = gf_isom_close_fragments(movie);
			if (e) return e;
			//in case of mfra box usage -> create mfro, calculate box sizes and write it out
			if (movie->mfra) {
				if (!movie->mfra->mfro)
					movie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_MFRO);

				e = gf_isom_box_size((GF_Box *)movie->mfra);
				if (e) return e;
				movie->mfra->mfro->container_size = (u32) movie->mfra->size;
				//write mfra
				e = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);
			}
		} else
#endif
			e = WriteToFile(movie);
	}
#endif /*GPAC_DISABLE_ISOM_WRITE*/

#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
	if (movie->moov) {
		u32 i;
		for (i=0; i<gf_list_count(movie->moov->trackList); i++) {
			GF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);
			/*delete any pending dataHandler of scalable enhancements*/
			if (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))
				gf_isom_datamap_del(trak->Media->information->scalableDataHandler);
		}
	}
#endif

	return e;
}","GF_EXPORT
VAR_0 gf_isom_write(GF_ISOFile *VAR_1) {
	GF_Err VAR_2;
	if (VAR_1 == NULL) return VAR_3;
	VAR_2 = VAR_4;

#ifndef VAR_5
	/* COMMENT_0 */
	if (VAR_1->openMode != VAR_6) {
		gf_isom_get_duration(VAR_1);
#ifndef	VAR_7
		/* COMMENT_1 */
		if ( (VAR_1->openMode == VAR_8) && (VAR_1->FragmentsFlags & VAR_9) ) {
			VAR_2 = gf_isom_close_fragments(VAR_1);
			if (VAR_2) return VAR_2;
			/* COMMENT_2 */
			if (VAR_1->mfra) {
				if (!VAR_1->mfra->mfro)
					VAR_1->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new(VAR_10);

				VAR_2 = gf_isom_box_size((GF_Box *)VAR_1->mfra);
				if (VAR_2) return VAR_2;
				VAR_1->mfra->mfro->container_size = (u32) VAR_1->mfra->size;
				/* COMMENT_3 */
				VAR_2 = gf_isom_box_write((GF_Box *)VAR_1->mfra, VAR_1->editFileMap->bs);
			}
		} else
#endif
			VAR_2 = WriteToFile(VAR_1);
	}
#endif /* COMMENT_4 */

#ifndef VAR_7
	if (VAR_1->moov) {
		u32 VAR_11;
		for (VAR_11=0; VAR_11<gf_list_count(VAR_1->moov->trackList); VAR_11++) {
			GF_TrackBox *VAR_12 = (GF_TrackBox*)gf_list_get(VAR_1->moov->trackList, VAR_11);
			/* COMMENT_5 */
			if (VAR_12->Media && VAR_12->Media->information && VAR_12->Media->information->scalableDataHandler && (VAR_12->Media->information->scalableDataHandler != VAR_1->movieFileMap))
				gf_isom_datamap_del(VAR_12->Media->information->scalableDataHandler);
		}
	}
#endif

	return VAR_2;
}",,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
 			if (movie->mfra) {
 				if (!movie->mfra->mfro)
 					movie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_MFRO);
-				
+
 				e = gf_isom_box_size((GF_Box *)movie->mfra);
 				if (e) return e;
 				movie->mfra->mfro->container_size = (u32) movie->mfra->size;","{'deleted_lines': ['\t\t\t\t'], 'added_lines': ['']}",True,"In GPAC before 0.8.0, isomedia/isom_read.c in libgpac.a has a heap-based buffer over-read, as demonstrated by a crash in gf_m2ts_sync in media_tools/mpegts.c.",7.5,HIGH,2,valid,2019-06-24T15:03:56Z,2
CVE-2019-13618,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gpac,fixed heap buffer overflow in gf_m2ts_sync #1250,c23d54ed15a70b4543e3191e6ead5097cda0878b,https://github.com/gpac/gpac/commit/c23d54ed15a70b4543e3191e6ead5097cda0878b,src/isomedia/isom_read.c,gf_isom_probe_file,"GF_EXPORT
u32 gf_isom_probe_file(const char *fileName)
{
u32 type = 0;
if (!strncmp(fileName, ""gmem:u32 size;
u8 *mem_address;
if (sscanf(fileName, ""gmem:return 0;
}
if (size>8)
type = GF_4CC(mem_address[4], mem_address[5], mem_address[6], mem_address[7]);
} else {
unsigned char data[4];
FILE *f = gf_fopen(fileName, ""rb"");
if (!f) return 0;
type = 0;
if (fread(data, 1, 4, f) == 4) {
if (fread(data, 1, 4, f) == 4) {
type = GF_4CC(data[0], data[1], data[2], data[3]);
}
}
gf_fclose(f);
}
switch (type) {
case GF_ISOM_BOX_TYPE_FTYP:
case GF_ISOM_BOX_TYPE_MOOV:
return 2;
#ifndefGPAC_DISABLE_ISOM_FRAGMENTS
case GF_ISOM_BOX_TYPE_MOOF:
case GF_ISOM_BOX_TYPE_STYP:
case GF_ISOM_BOX_TYPE_SIDX:
return 3;
#ifndef GPAC_DISABLE_ISOM_ADOBE
case GF_ISOM_BOX_TYPE_AFRA:
case GF_ISOM_BOX_TYPE_ABST:
#endif
#endif
case GF_ISOM_BOX_TYPE_MDAT:
case GF_ISOM_BOX_TYPE_FREE:
case GF_ISOM_BOX_TYPE_SKIP:
case GF_ISOM_BOX_TYPE_UDTA:
case GF_ISOM_BOX_TYPE_META:
case GF_ISOM_BOX_TYPE_VOID:
case GF_ISOM_BOX_TYPE_JP:
case GF_QT_BOX_TYPE_WIDE:
return 1;
default:
return 0;
}
}","GF_EXPORT
VAR_0 gf_isom_probe_file(const char *VAR_1)
{
u32 VAR_2 = 0;
if (!strncmp(VAR_1, ""gmem://"", 7)) {
u32 VAR_3;
u8 *VAR_4;
if (sscanf(VAR_1, ""gmem://%d@%p"", &VAR_3, &VAR_4) != 2) {
return 0;
}
if (VAR_3>8)
VAR_2 = GF_4CC(VAR_4[4], VAR_4[5], VAR_4[6], VAR_4[7]);
} else {
unsigned char VAR_5[4];
FILE *VAR_6 = gf_fopen(VAR_1, ""rb"");
if (!VAR_6) return 0;
VAR_2 = 0;
if (fread(VAR_5, 1, 4, VAR_6) == 4) {
if (fread(VAR_5, 1, 4, VAR_6) == 4) {
VAR_2 = GF_4CC(VAR_5[0], VAR_5[1], VAR_5[2], VAR_5[3]);
}
}
gf_fclose(VAR_6);
}
switch (VAR_2) {
case VAR_7:
case VAR_8:
return 2;
#ifndefVAR_9
case VAR_10:
case VAR_11:
case VAR_12:
return 3;
#ifndef VAR_13
case VAR_14:
case VAR_15:
#endif
#endif
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
return 1;
default:
return 0;
}
}",,"GF_EXPORT
u32 gf_isom_probe_file(const char *fileName)
{
	u32 type = 0;

	if (!strncmp(fileName, ""gmem://"", 7)) {
		u32 size;
		u8 *mem_address;
		if (sscanf(fileName, ""gmem://%d@%p"", &size, &mem_address) != 2) {
			return 0;
		}
		if (size>8)
			type = GF_4CC(mem_address[4], mem_address[5], mem_address[6], mem_address[7]);
	} else {
		unsigned char data[4];
		FILE *f = gf_fopen(fileName, ""rb"");
		if (!f) return 0;
		type = 0;
		if (fread(data, 1, 4, f) == 4) {
			if (fread(data, 1, 4, f) == 4) {
				type = GF_4CC((u32)data[0], (u8)data[1], (u8)data[2], (u8)data[3]);
			}
		}
		gf_fclose(f);
	}
	switch (type) {
	case GF_ISOM_BOX_TYPE_FTYP:
	case GF_ISOM_BOX_TYPE_MOOV:
		return 2;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
	case GF_ISOM_BOX_TYPE_MOOF:
	case GF_ISOM_BOX_TYPE_STYP:
	case GF_ISOM_BOX_TYPE_SIDX:
		return 3;
#ifndef GPAC_DISABLE_ISOM_ADOBE
	/*Adobe specific*/
	case GF_ISOM_BOX_TYPE_AFRA:
	case GF_ISOM_BOX_TYPE_ABST:
#endif
#endif
	case GF_ISOM_BOX_TYPE_MDAT:
	case GF_ISOM_BOX_TYPE_FREE:
	case GF_ISOM_BOX_TYPE_SKIP:
	case GF_ISOM_BOX_TYPE_UDTA:
	case GF_ISOM_BOX_TYPE_META:
	case GF_ISOM_BOX_TYPE_VOID:
	case GF_ISOM_BOX_TYPE_JP:
	case GF_QT_BOX_TYPE_WIDE:
		return 1;
	default:
		return 0;
	}
}","GF_EXPORT
VAR_0 gf_isom_probe_file(const char *VAR_1)
{
	u32 VAR_2 = 0;

	if (!strncmp(VAR_1, ""gmem://"", 7)) {
		u32 VAR_3;
		u8 *VAR_4;
		if (sscanf(VAR_1, ""gmem://%d@%p"", &VAR_3, &VAR_4) != 2) {
			return 0;
		}
		if (VAR_3>8)
			VAR_2 = GF_4CC(VAR_4[4], VAR_4[5], VAR_4[6], VAR_4[7]);
	} else {
		unsigned char VAR_5[4];
		FILE *VAR_6 = gf_fopen(VAR_1, ""rb"");
		if (!VAR_6) return 0;
		VAR_2 = 0;
		if (fread(VAR_5, 1, 4, VAR_6) == 4) {
			if (fread(VAR_5, 1, 4, VAR_6) == 4) {
				VAR_2 = GF_4CC((u32)VAR_5[0], (u8)VAR_5[1], (u8)VAR_5[2], (u8)VAR_5[3]);
			}
		}
		gf_fclose(VAR_6);
	}
	switch (VAR_2) {
	case VAR_7:
	case VAR_8:
		return 2;
#ifndef	VAR_9
	case VAR_10:
	case VAR_11:
	case VAR_12:
		return 3;
#ifndef VAR_13
	/* COMMENT_0 */
	case VAR_14:
	case VAR_15:
#endif
#endif
	case VAR_16:
	case VAR_17:
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
	case VAR_22:
	case VAR_23:
		return 1;
	default:
		return 0;
	}
}",,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
 		type = 0;
 		if (fread(data, 1, 4, f) == 4) {
 			if (fread(data, 1, 4, f) == 4) {
-				type = GF_4CC(data[0], data[1], data[2], data[3]);
+				type = GF_4CC((u32)data[0], (u8)data[1], (u8)data[2], (u8)data[3]);
 			}
 		}
 		gf_fclose(f);","{'deleted_lines': ['\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);'], 'added_lines': ['\t\t\t\ttype = GF_4CC((u32)data[0], (u8)data[1], (u8)data[2], (u8)data[3]);']}",True,"In GPAC before 0.8.0, isomedia/isom_read.c in libgpac.a has a heap-based buffer over-read, as demonstrated by a crash in gf_m2ts_sync in media_tools/mpegts.c.",7.5,HIGH,2,valid,2019-06-24T15:03:56Z,2
CVE-2019-14452,['CWE-22'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,Sigil-Ebook/Sigil,do not allow zip files to have upward relative path sections,369eebe936e4a8c83cc54662a3412ce8bef189e4,https://github.com/Sigil-Ebook/Sigil/commit/369eebe936e4a8c83cc54662a3412ce8bef189e4,src/Importers/ImportEPUB.cpp,ImportEPUB::ExtractContainer,"void ImportEPUB::ExtractContainer()
{
int res = 0;
if (!cp437) {
cp437 = new QCodePage437Codec();
}
#ifdef Q_OS_WIN32
zlib_filefunc64_def ffunc;
fill_win32_filefunc64W(&ffunc);
unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);
#else
unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());
#endif
if (zfile == NULL) {
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
}
res = unzGoToFirstFile(zfile);
if (res == UNZ_OK) {
do {
char file_name[MAX_PATH] = {0};
unz_file_info64 file_info;
unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
QString qfile_name;
QString cp437_file_name;
qfile_name = QString::fromUtf8(file_name);
if (!(file_info.flag & (1<<11))) {
cp437_file_name = cp437->toUnicode(file_name);
}
if (!qfile_name.isEmpty()) {
QDir dir(m_ExtractedFolderPath);
QString file_path = m_ExtractedFolderPath + ""/"" + qfile_name;
QFileInfo qfile_info(file_path);
if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
dir.mkpath(qfile_name);
continue;
} else {
dir.mkpath(qfile_info.path());
if (cp437_file_name.isEmpty()) {
m_ZipFilePaths << qfile_name;
} else {
m_ZipFilePaths << cp437_file_name;
}
}
if (unzOpenCurrentFile(zfile) != UNZ_OK) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
QFile entry(file_path);
if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
char buff[BUFF_SIZE] = {0};
int read = 0;
while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
entry.write(buff, read);
}
entry.close();
if (read < 0) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
QString cp437_file_path = m_ExtractedFolderPath + ""/"" + cp437_file_name;
QFile::copy(file_path, cp437_file_path);
}
}
} while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
}
if (res != UNZ_END_OF_LIST_OF_FILE) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
}
unzClose(zfile);
}","void ImportEPUB::ExtractContainer()
{
int VAR_0 = 0;
if (!VAR_1) {
VAR_1 = new QCodePage437Codec();
}
#ifdef VAR_2
zlib_filefunc64_def VAR_3;
fill_win32_filefunc64W(&VAR_3);
unzFile VAR_4 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_5)).c_str(), &VAR_3);
#else
unzFile VAR_4 = unzOpen64(QDir::toNativeSeparators(VAR_5).toUtf8().constData());
#endif
if (VAR_4 == NULL) {
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
}
VAR_0 = unzGoToFirstFile(VAR_4);
if (VAR_0 == VAR_6) {
do {
char VAR_7[VAR_8] = {0};
unz_file_info64 VAR_9;
unzGetCurrentFileInfo64(VAR_4, &VAR_9, VAR_7, VAR_8, NULL, 0, NULL, 0);
QString VAR_10;
QString VAR_11;
VAR_10 = QString::fromUtf8(VAR_7);
if (!(VAR_9.flag & (1<<11))) {
VAR_11 = VAR_1->toUnicode(VAR_7);
}
if (!VAR_10.isEmpty()) {
QDir dir(m_ExtractedFolderPath);
QString VAR_12 = m_ExtractedFolderPath + ""/"" + VAR_10;
QFileInfo qfile_info(file_path);
if (VAR_9.uncompressed_size == 0 && VAR_10.endsWith('/')) {
VAR_13.mkpath(VAR_10);
continue;
} else {
VAR_13.mkpath(VAR_14.path());
if (VAR_11.isEmpty()) {
VAR_15 << VAR_10;
} else {
VAR_15 << VAR_11;
}
}
if (unzOpenCurrentFile(VAR_4) != VAR_6) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
QFile entry(file_path);
if (!VAR_16.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(VAR_4);
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
char VAR_17[VAR_18] = {0};
int VAR_19 = 0;
while ((VAR_19 = unzReadCurrentFile(VAR_4, VAR_17, VAR_18)) > 0) {
VAR_16.write(VAR_17, VAR_19);
}
VAR_16.close();
if (VAR_19 < 0) {
unzCloseCurrentFile(VAR_4);
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
if (unzCloseCurrentFile(VAR_4) == VAR_20) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
if (!VAR_11.isEmpty() && VAR_11 != VAR_10) {
QString VAR_21 = m_ExtractedFolderPath + ""/"" + VAR_11;
QFile::copy(file_path, VAR_21);
}
}
} while ((VAR_0 = unzGoToNextFile(VAR_4)) == VAR_6);
}
if (VAR_0 != VAR_22) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
}
unzClose(VAR_4);
}",Sigil-Ebook/Sigil/369eebe936e4a8c83cc54662a3412ce8bef189e4/ImportEPUB.cpp/vul/before/0.json,"void ImportEPUB::ExtractContainer()
{
    int res = 0;
    if (!cp437) {
        cp437 = new QCodePage437Codec();
    }
#ifdef Q_OS_WIN32
    zlib_filefunc64_def ffunc;
    fill_win32_filefunc64W(&ffunc);
    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);
#else
    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());
#endif

    if (zfile == NULL) {
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
    }

    res = unzGoToFirstFile(zfile);

    if (res == UNZ_OK) {
        do {
            // Get the name of the file in the archive.
            char file_name[MAX_PATH] = {0};
            unz_file_info64 file_info;
            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
            QString qfile_name;
            QString cp437_file_name;
            qfile_name = QString::fromUtf8(file_name);
            if (!(file_info.flag & (1<<11))) {
                // General purpose bit 11 says the filename is utf-8 encoded. If not set then
                // IBM 437 encoding might be used.
                cp437_file_name = cp437->toUnicode(file_name);
            }

            // If there is no file name then we can't do anything with it.
            if (!qfile_name.isEmpty()) {

	        // for security reasons we need the file path to always be inside the 
                // target folder and not outside, so we will remove all relative upward 
                // paths segments "".."" from the file path before prepending the target 
                // folder to create the final target path
	        qfile_name = qfile_name.replace(""../"","""");
                cp437_file_name = cp437_file_name.replace(""../"","""");

                // We use the dir object to create the path in the temporary directory.
                // Unfortunately, we need a dir ojbect to do this as it's not a static function.
                QDir dir(m_ExtractedFolderPath);
                // Full file path in the temporary directory.
                QString file_path = m_ExtractedFolderPath + ""/"" + qfile_name;
                QFileInfo qfile_info(file_path);

                // Is this entry a directory?
                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
                    dir.mkpath(qfile_name);
                    continue;
                } else {
                    dir.mkpath(qfile_info.path());
		    // add it to the list of files found inside the zip
		    if (cp437_file_name.isEmpty()) {
		        m_ZipFilePaths << qfile_name;
		    } else {
                        m_ZipFilePaths << cp437_file_name;
		    }
                }

                // Open the file entry in the archive for reading.
                if (unzOpenCurrentFile(zfile) != UNZ_OK) {
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // Open the file on disk to write the entry in the archive to.
                QFile entry(file_path);

                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // Buffered reading and writing.
                char buff[BUFF_SIZE] = {0};
                int read = 0;

                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
                    entry.write(buff, read);
                }

                entry.close();

                // Read errors are marked by a negative read amount.
                if (read < 0) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // The file was read but the CRC did not match.
                // We don't check the read file size vs the uncompressed file size
                // because if they're different there should be a CRC error.
                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }
                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
                    QString cp437_file_path = m_ExtractedFolderPath + ""/"" + cp437_file_name;
                    QFile::copy(file_path, cp437_file_path);
                }
            }
        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
    }

    if (res != UNZ_END_OF_LIST_OF_FILE) {
        unzClose(zfile);
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
    }

    unzClose(zfile);
}","void ImportEPUB::ExtractContainer()
{
    int VAR_0 = 0;
    if (!VAR_1) {
        VAR_1 = new QCodePage437Codec();
    }
#ifdef VAR_2
    zlib_filefunc64_def VAR_3;
    fill_win32_filefunc64W(&VAR_3);
    unzFile VAR_4 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_5)).c_str(), &VAR_3);
#else
    unzFile VAR_4 = unzOpen64(QDir::toNativeSeparators(VAR_5).toUtf8().constData());
#endif

    if (VAR_4 == NULL) {
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
    }

    VAR_0 = unzGoToFirstFile(VAR_4);

    if (VAR_0 == VAR_6) {
        do {
            /* COMMENT_0 */
            char VAR_7[VAR_8] = {0};
            unz_file_info64 VAR_9;
            unzGetCurrentFileInfo64(VAR_4, &VAR_9, VAR_7, VAR_8, NULL, 0, NULL, 0);
            QString VAR_10;
            QString VAR_11;
            VAR_10 = QString::fromUtf8(VAR_7);
            if (!(VAR_9.flag & (1<<11))) {
                /* COMMENT_1 */
                /* COMMENT_2 */
                VAR_11 = VAR_1->toUnicode(VAR_7);
            }

            /* COMMENT_3 */
            if (!VAR_10.isEmpty()) {

	        /* COMMENT_4 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                /* COMMENT_7 */
	        VAR_10 = VAR_10.replace(""../"","""");
                VAR_11 = VAR_11.replace(""../"","""");

                /* COMMENT_8 */
                /* COMMENT_9 */
                QDir dir(m_ExtractedFolderPath);
                /* COMMENT_10 */
                QString VAR_12 = m_ExtractedFolderPath + ""/"" + VAR_10;
                QFileInfo qfile_info(file_path);

                /* COMMENT_11 */
                if (VAR_9.uncompressed_size == 0 && VAR_10.endsWith('/')) {
                    VAR_13.mkpath(VAR_10);
                    continue;
                } else {
                    VAR_13.mkpath(VAR_14.path());
		    /* COMMENT_12 */
		    if (VAR_11.isEmpty()) {
		        VAR_15 << VAR_10;
		    } else {
                        VAR_15 << VAR_11;
		    }
                }

                /* COMMENT_13 */
                if (unzOpenCurrentFile(VAR_4) != VAR_6) {
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_14 */
                QFile entry(file_path);

                if (!VAR_16.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(VAR_4);
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_15 */
                char VAR_17[VAR_18] = {0};
                int VAR_19 = 0;

                while ((VAR_19 = unzReadCurrentFile(VAR_4, VAR_17, VAR_18)) > 0) {
                    VAR_16.write(VAR_17, VAR_19);
                }

                VAR_16.close();

                /* COMMENT_16 */
                if (VAR_19 < 0) {
                    unzCloseCurrentFile(VAR_4);
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_17 */
                /* COMMENT_18 */
                /* COMMENT_19 */
                if (unzCloseCurrentFile(VAR_4) == VAR_20) {
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }
                if (!VAR_11.isEmpty() && VAR_11 != VAR_10) {
                    QString VAR_21 = m_ExtractedFolderPath + ""/"" + VAR_11;
                    QFile::copy(file_path, VAR_21);
                }
            }
        } while ((VAR_0 = unzGoToNextFile(VAR_4)) == VAR_6);
    }

    if (VAR_0 != VAR_22) {
        unzClose(VAR_4);
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
    }

    unzClose(VAR_4);
}",Sigil-Ebook/Sigil/369eebe936e4a8c83cc54662a3412ce8bef189e4/ImportEPUB.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,14 @@
 
             // If there is no file name then we can't do anything with it.
             if (!qfile_name.isEmpty()) {
+
+	        // for security reasons we need the file path to always be inside the 
+                // target folder and not outside, so we will remove all relative upward 
+                // paths segments "".."" from the file path before prepending the target 
+                // folder to create the final target path
+	        qfile_name = qfile_name.replace(""../"","""");
+                cp437_file_name = cp437_file_name.replace(""../"","""");
+
                 // We use the dir object to create the path in the temporary directory.
                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.
                 QDir dir(m_ExtractedFolderPath);","{'deleted_lines': [], 'added_lines': ['', '\t        // for security reasons we need the file path to always be inside the ', '                // target folder and not outside, so we will remove all relative upward ', '                // paths segments "".."" from the file path before prepending the target ', '                // folder to create the final target path', '\t        qfile_name = qfile_name.replace(""../"","""");', '                cp437_file_name = cp437_file_name.replace(""../"","""");', '']}",True,"Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",7.5,HIGH,2,valid,2019-06-26T18:33:01Z,2
CVE-2019-14452,['CWE-22'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,Sigil-Ebook/Sigil,further harden against malicious epubs and produce error message,04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4,https://github.com/Sigil-Ebook/Sigil/commit/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4,src/Importers/ImportEPUB.cpp,ImportEPUB::ExtractContainer,"void ImportEPUB::ExtractContainer()
{
int res = 0;
if (!cp437) {
cp437 = new QCodePage437Codec();
}
#ifdef Q_OS_WIN32
zlib_filefunc64_def ffunc;
fill_win32_filefunc64W(&ffunc);
unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);
#else
unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());
#endif
if (zfile == NULL) {
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
}
res = unzGoToFirstFile(zfile);
if (res == UNZ_OK) {
do {
char file_name[MAX_PATH] = {0};
unz_file_info64 file_info;
unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
QString qfile_name;
QString cp437_file_name;
qfile_name = QString::fromUtf8(file_name);
if (!(file_info.flag & (1<<11))) {
cp437_file_name = cp437->toUnicode(file_name);
}
if (!qfile_name.isEmpty()) {
qfile_name = qfile_name.replace(""../"","""");
cp437_file_name = cp437_file_name.replace(""../"","""");
QDir dir(m_ExtractedFolderPath);
QString file_path = m_ExtractedFolderPath + ""/"" + qfile_name;
QFileInfo qfile_info(file_path);
if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
dir.mkpath(qfile_name);
continue;
} else {
dir.mkpath(qfile_info.path());
if (cp437_file_name.isEmpty()) {
m_ZipFilePaths << qfile_name;
} else {
m_ZipFilePaths << cp437_file_name;
}
}
if (unzOpenCurrentFile(zfile) != UNZ_OK) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
QFile entry(file_path);
if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
char buff[BUFF_SIZE] = {0};
int read = 0;
while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
entry.write(buff, read);
}
entry.close();
if (read < 0) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
}
if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
QString cp437_file_path = m_ExtractedFolderPath + ""/"" + cp437_file_name;
QFile::copy(file_path, cp437_file_path);
}
}
} while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
}
if (res != UNZ_END_OF_LIST_OF_FILE) {
unzClose(zfile);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
}
unzClose(zfile);
}","void ImportEPUB::ExtractContainer()
{
int VAR_0 = 0;
if (!VAR_1) {
VAR_1 = new QCodePage437Codec();
}
#ifdef VAR_2
zlib_filefunc64_def VAR_3;
fill_win32_filefunc64W(&VAR_3);
unzFile VAR_4 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_5)).c_str(), &VAR_3);
#else
unzFile VAR_4 = unzOpen64(QDir::toNativeSeparators(VAR_5).toUtf8().constData());
#endif
if (VAR_4 == NULL) {
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
}
VAR_0 = unzGoToFirstFile(VAR_4);
if (VAR_0 == VAR_6) {
do {
char VAR_7[VAR_8] = {0};
unz_file_info64 VAR_9;
unzGetCurrentFileInfo64(VAR_4, &VAR_9, VAR_7, VAR_8, NULL, 0, NULL, 0);
QString VAR_10;
QString VAR_11;
VAR_10 = QString::fromUtf8(VAR_7);
if (!(VAR_9.flag & (1<<11))) {
VAR_11 = VAR_1->toUnicode(VAR_7);
}
if (!VAR_10.isEmpty()) {
VAR_10 = VAR_10.replace(""../"","""");
VAR_11 = VAR_11.replace(""../"","""");
QDir dir(m_ExtractedFolderPath);
QString VAR_12 = m_ExtractedFolderPath + ""/"" + VAR_10;
QFileInfo qfile_info(file_path);
if (VAR_9.uncompressed_size == 0 && VAR_10.endsWith('/')) {
VAR_13.mkpath(VAR_10);
continue;
} else {
VAR_13.mkpath(VAR_14.path());
if (VAR_11.isEmpty()) {
VAR_15 << VAR_10;
} else {
VAR_15 << VAR_11;
}
}
if (unzOpenCurrentFile(VAR_4) != VAR_6) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
QFile entry(file_path);
if (!VAR_16.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(VAR_4);
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
char VAR_17[VAR_18] = {0};
int VAR_19 = 0;
while ((VAR_19 = unzReadCurrentFile(VAR_4, VAR_17, VAR_18)) > 0) {
VAR_16.write(VAR_17, VAR_19);
}
VAR_16.close();
if (VAR_19 < 0) {
unzCloseCurrentFile(VAR_4);
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
if (unzCloseCurrentFile(VAR_4) == VAR_20) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
}
if (!VAR_11.isEmpty() && VAR_11 != VAR_10) {
QString VAR_21 = m_ExtractedFolderPath + ""/"" + VAR_11;
QFile::copy(file_path, VAR_21);
}
}
} while ((VAR_0 = unzGoToNextFile(VAR_4)) == VAR_6);
}
if (VAR_0 != VAR_22) {
unzClose(VAR_4);
throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
}
unzClose(VAR_4);
}",Sigil-Ebook/Sigil/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4/ImportEPUB.cpp/vul/before/0.json,"void ImportEPUB::ExtractContainer()
{
    int res = 0;
    if (!cp437) {
        cp437 = new QCodePage437Codec();
    }
#ifdef Q_OS_WIN32
    zlib_filefunc64_def ffunc;
    fill_win32_filefunc64W(&ffunc);
    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);
#else
    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());
#endif

    if (zfile == NULL) {
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
    }

    res = unzGoToFirstFile(zfile);

    if (res == UNZ_OK) {
        do {
            // Get the name of the file in the archive.
            char file_name[MAX_PATH] = {0};
            unz_file_info64 file_info;
            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
            QString qfile_name;
            QString cp437_file_name;
            qfile_name = QString::fromUtf8(file_name);
            if (!(file_info.flag & (1<<11))) {
                // General purpose bit 11 says the filename is utf-8 encoded. If not set then
                // IBM 437 encoding might be used.
                cp437_file_name = cp437->toUnicode(file_name);
            }

            // If there is no file name then we can't do anything with it.
            if (!qfile_name.isEmpty()) {

	        // for security reasons against maliciously crafted zip archives
                // we need the file path to always be inside the target folder 
                // and not outside, so we will remove all illegal backslashes
                // and all relative upward paths segments ""/../"" from the zip's local 
                // file name/path before prepending the target folder to create 
                // the final path

	        QString original_path = qfile_name;
	        bool evil_or_corrupt_epub = false;

                if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");

                if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        qfile_name = qfile_name.replace(""/../"",""/"");

                while(qfile_name.startsWith(""/"")) { 
		    qfile_name = qfile_name.remove(0,1);
		}

                if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
                cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");

                if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");

                while(cp437_file_name.startsWith(""/"")) { 
		    cp437_file_name = cp437_file_name.remove(0,1);
		}

                if (evil_or_corrupt_epub) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Possible evil or corrupt epub file name: %1"")).arg(original_path).toStdString()));
                }

                // We use the dir object to create the path in the temporary directory.
                // Unfortunately, we need a dir ojbect to do this as it's not a static function.
                QDir dir(m_ExtractedFolderPath);
                // Full file path in the temporary directory.
                QString file_path = m_ExtractedFolderPath + ""/"" + qfile_name;
                QFileInfo qfile_info(file_path);

                // Is this entry a directory?
                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
                    dir.mkpath(qfile_name);
                    continue;
                } else {
                    dir.mkpath(qfile_info.path());
		    // add it to the list of files found inside the zip
		    if (cp437_file_name.isEmpty()) {
		        m_ZipFilePaths << qfile_name;
		    } else {
                        m_ZipFilePaths << cp437_file_name;
		    }
                }

                // Open the file entry in the archive for reading.
                if (unzOpenCurrentFile(zfile) != UNZ_OK) {
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // Open the file on disk to write the entry in the archive to.
                QFile entry(file_path);

                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // Buffered reading and writing.
                char buff[BUFF_SIZE] = {0};
                int read = 0;

                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
                    entry.write(buff, read);
                }

                entry.close();

                // Read errors are marked by a negative read amount.
                if (read < 0) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }

                // The file was read but the CRC did not match.
                // We don't check the read file size vs the uncompressed file size
                // because if they're different there should be a CRC error.
                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString()));
                }
                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
                    QString cp437_file_path = m_ExtractedFolderPath + ""/"" + cp437_file_name;
                    QFile::copy(file_path, cp437_file_path);
                }
            }
        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
    }

    if (res != UNZ_END_OF_LIST_OF_FILE) {
        unzClose(zfile);
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));
    }

    unzClose(zfile);
}","void ImportEPUB::ExtractContainer()
{
    int VAR_0 = 0;
    if (!VAR_1) {
        VAR_1 = new QCodePage437Codec();
    }
#ifdef VAR_2
    zlib_filefunc64_def VAR_3;
    fill_win32_filefunc64W(&VAR_3);
    unzFile VAR_4 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_5)).c_str(), &VAR_3);
#else
    unzFile VAR_4 = unzOpen64(QDir::toNativeSeparators(VAR_5).toUtf8().constData());
#endif

    if (VAR_4 == NULL) {
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
    }

    VAR_0 = unzGoToFirstFile(VAR_4);

    if (VAR_0 == VAR_6) {
        do {
            /* COMMENT_0 */
            char VAR_7[VAR_8] = {0};
            unz_file_info64 VAR_9;
            unzGetCurrentFileInfo64(VAR_4, &VAR_9, VAR_7, VAR_8, NULL, 0, NULL, 0);
            QString VAR_10;
            QString VAR_11;
            VAR_10 = QString::fromUtf8(VAR_7);
            if (!(VAR_9.flag & (1<<11))) {
                /* COMMENT_1 */
                /* COMMENT_2 */
                VAR_11 = VAR_1->toUnicode(VAR_7);
            }

            /* COMMENT_3 */
            if (!VAR_10.isEmpty()) {

	        /* COMMENT_4 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                /* COMMENT_7 */
                /* COMMENT_8 */
                /* COMMENT_9 */

	        QString VAR_12 = VAR_10;
	        bool VAR_13 = false;

                if (VAR_10.contains(""\\"")) VAR_13 = true; 
	        VAR_10 = ""/"" + VAR_10.replace(""\\"","""");

                if (VAR_10.contains(""/../"")) VAR_13 = true;
	        VAR_10 = VAR_10.replace(""/../"",""/"");

                while(VAR_10.startsWith(""/"")) { 
		    VAR_10 = VAR_10.remove(0,1);
		}

                if (VAR_11.contains(""\\"")) VAR_13 = true; 
                VAR_11 = ""/"" + VAR_11.replace(""\\"","""");

                if (VAR_11.contains(""/../"")) VAR_13 = true;
	        VAR_11 = VAR_11.replace(""/../"",""/"");

                while(VAR_11.startsWith(""/"")) { 
		    VAR_11 = VAR_11.remove(0,1);
		}

                if (VAR_13) {
                    unzCloseCurrentFile(VAR_4);
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Possible evil or corrupt epub file name: %1"")).arg(VAR_12).toStdString()));
                }

                /* COMMENT_10 */
                /* COMMENT_11 */
                QDir dir(m_ExtractedFolderPath);
                /* COMMENT_12 */
                QString VAR_14 = m_ExtractedFolderPath + ""/"" + VAR_10;
                QFileInfo qfile_info(file_path);

                /* COMMENT_13 */
                if (VAR_9.uncompressed_size == 0 && VAR_10.endsWith('/')) {
                    VAR_15.mkpath(VAR_10);
                    continue;
                } else {
                    VAR_15.mkpath(VAR_16.path());
		    /* COMMENT_14 */
		    if (VAR_11.isEmpty()) {
		        VAR_17 << VAR_10;
		    } else {
                        VAR_17 << VAR_11;
		    }
                }

                /* COMMENT_15 */
                if (unzOpenCurrentFile(VAR_4) != VAR_6) {
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_16 */
                QFile entry(file_path);

                if (!VAR_18.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(VAR_4);
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_17 */
                char VAR_19[VAR_20] = {0};
                int VAR_21 = 0;

                while ((VAR_21 = unzReadCurrentFile(VAR_4, VAR_19, VAR_20)) > 0) {
                    VAR_18.write(VAR_19, VAR_21);
                }

                VAR_18.close();

                /* COMMENT_18 */
                if (VAR_21 < 0) {
                    unzCloseCurrentFile(VAR_4);
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }

                /* COMMENT_19 */
                /* COMMENT_20 */
                /* COMMENT_21 */
                if (unzCloseCurrentFile(VAR_4) == VAR_22) {
                    unzClose(VAR_4);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(VAR_10).toStdString()));
                }
                if (!VAR_11.isEmpty() && VAR_11 != VAR_10) {
                    QString VAR_23 = m_ExtractedFolderPath + ""/"" + VAR_11;
                    QFile::copy(file_path, VAR_23);
                }
            }
        } while ((VAR_0 = unzGoToNextFile(VAR_4)) == VAR_6);
    }

    if (VAR_0 != VAR_24) {
        unzClose(VAR_4);
        throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(VAR_5)).toStdString()));
    }

    unzClose(VAR_4);
}",Sigil-Ebook/Sigil/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4/ImportEPUB.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,12 +36,41 @@
             // If there is no file name then we can't do anything with it.
             if (!qfile_name.isEmpty()) {
 
-	        // for security reasons we need the file path to always be inside the 
-                // target folder and not outside, so we will remove all relative upward 
-                // paths segments "".."" from the file path before prepending the target 
-                // folder to create the final target path
-	        qfile_name = qfile_name.replace(""../"","""");
-                cp437_file_name = cp437_file_name.replace(""../"","""");
+	        // for security reasons against maliciously crafted zip archives
+                // we need the file path to always be inside the target folder 
+                // and not outside, so we will remove all illegal backslashes
+                // and all relative upward paths segments ""/../"" from the zip's local 
+                // file name/path before prepending the target folder to create 
+                // the final path
+
+	        QString original_path = qfile_name;
+	        bool evil_or_corrupt_epub = false;
+
+                if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
+	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");
+
+                if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
+	        qfile_name = qfile_name.replace(""/../"",""/"");
+
+                while(qfile_name.startsWith(""/"")) { 
+		    qfile_name = qfile_name.remove(0,1);
+		}
+
+                if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
+                cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");
+
+                if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
+	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");
+
+                while(cp437_file_name.startsWith(""/"")) { 
+		    cp437_file_name = cp437_file_name.remove(0,1);
+		}
+
+                if (evil_or_corrupt_epub) {
+                    unzCloseCurrentFile(zfile);
+                    unzClose(zfile);
+                    throw (EPUBLoadParseError(QString(QObject::tr(""Possible evil or corrupt epub file name: %1"")).arg(original_path).toStdString()));
+                }
 
                 // We use the dir object to create the path in the temporary directory.
                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.","{'deleted_lines': ['\t        // for security reasons we need the file path to always be inside the ', '                // target folder and not outside, so we will remove all relative upward ', '                // paths segments "".."" from the file path before prepending the target ', '                // folder to create the final target path', '\t        qfile_name = qfile_name.replace(""../"","""");', '                cp437_file_name = cp437_file_name.replace(""../"","""");'], 'added_lines': ['\t        // for security reasons against maliciously crafted zip archives', '                // we need the file path to always be inside the target folder ', '                // and not outside, so we will remove all illegal backslashes', '                // and all relative upward paths segments ""/../"" from the zip\'s local ', '                // file name/path before prepending the target folder to create ', '                // the final path', '', '\t        QString original_path = qfile_name;', '\t        bool evil_or_corrupt_epub = false;', '', '                if (qfile_name.contains(""\\\\"")) evil_or_corrupt_epub = true; ', '\t        qfile_name = ""/"" + qfile_name.replace(""\\\\"","""");', '', '                if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;', '\t        qfile_name = qfile_name.replace(""/../"",""/"");', '', '                while(qfile_name.startsWith(""/"")) { ', '\t\t    qfile_name = qfile_name.remove(0,1);', '\t\t}', '', '                if (cp437_file_name.contains(""\\\\"")) evil_or_corrupt_epub = true; ', '                cp437_file_name = ""/"" + cp437_file_name.replace(""\\\\"","""");', '', '                if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;', '\t        cp437_file_name = cp437_file_name.replace(""/../"",""/"");', '', '                while(cp437_file_name.startsWith(""/"")) { ', '\t\t    cp437_file_name = cp437_file_name.remove(0,1);', '\t\t}', '', '                if (evil_or_corrupt_epub) {', '                    unzCloseCurrentFile(zfile);', '                    unzClose(zfile);', '                    throw (EPUBLoadParseError(QString(QObject::tr(""Possible evil or corrupt epub file name: %1"")).arg(original_path).toStdString()));', '                }']}",True,"Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",7.5,HIGH,2,valid,2019-06-27T15:47:42Z,2
CVE-2019-13272,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME

Fix two issues:

When called for PTRACE_TRACEME, ptrace_link() would obtain an RCU
reference to the parent's objective credentials, then give that pointer
to get_cred().  However, the object lifetime rules for things like
struct cred do not permit unconditionally turning an RCU reference into
a stable reference.

PTRACE_TRACEME records the parent's credentials as if the parent was
acting as the subject, but that's not the case.  If a malicious
unprivileged child uses PTRACE_TRACEME and the parent is privileged, and
at a later point, the parent process becomes attacker-controlled
(because it drops privileges and calls execve()), the attacker ends up
with control over two processes with a privileged ptrace relationship,
which can be abused to ptrace a suid binary and obtain root privileges.

Fix both of these by always recording the credentials of the process
that is requesting the creation of the ptrace relationship:
current_cred() can't change under us, and current is the proper subject
for access control.

This change is theoretically userspace-visible, but I am not aware of
any code that it will actually break.

Fixes: 64b875f7ac8a (""ptrace: Capture the ptracer's creds not PT_PTRACE_CAP"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",6994eefb0053799d2e07cd140df6c2ea106c41ee,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,kernel/ptrace.c,ptrace_link,"static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
{
rcu_read_lock();
__ptrace_link(child, new_parent, __task_cred(new_parent));
rcu_read_unlock();
}","static void ptrace_link(struct task_struct *VAR_0, struct task_struct *VAR_1)
{
rcu_read_lock();
__ptrace_link(VAR_0, VAR_1, __task_cred(VAR_1));
rcu_read_unlock();
}",torvalds/linux/6994eefb0053799d2e07cd140df6c2ea106c41ee/ptrace.c/vul/before/0.json,"static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
{
	__ptrace_link(child, new_parent, current_cred());
}","static void ptrace_link(struct task_struct *VAR_0, struct task_struct *VAR_1)
{
	__ptrace_link(VAR_0, VAR_1, current_cred());
}",torvalds/linux/6994eefb0053799d2e07cd140df6c2ea106c41ee/ptrace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,4 @@
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-	rcu_read_lock();
-	__ptrace_link(child, new_parent, __task_cred(new_parent));
-	rcu_read_unlock();
+	__ptrace_link(child, new_parent, current_cred());
 }","{'deleted_lines': ['\trcu_read_lock();', '\t__ptrace_link(child, new_parent, __task_cred(new_parent));', '\trcu_read_unlock();'], 'added_lines': ['\t__ptrace_link(child, new_parent, current_cred());']}",True,"In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments.",7.8,HIGH,2,valid,2019-07-04T15:32:23Z,2
CVE-2019-20629,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed potential crash in TS - cf #1264,2320eb73afba753b39b7147be91f7be7afc0eeb7,https://github.com/gpac/gpac/commit/2320eb73afba753b39b7147be91f7be7afc0eeb7,src/media_tools/mpegts.c,gf_m2ts_process_pmt,"static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
u32 info_length, pos, desc_len, evt_type, nb_es,i;
u32 nb_sections;
u32 data_size;
u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;
unsigned char *data;
GF_M2TS_Section *section;
GF_Err e = GF_OK;
if (!(status&GF_M2TS_TABLE_END)) return;
nb_es = 0;
if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
return;
}
if (pmt->sec->demux_restarted) {
pmt->sec->demux_restarted = 0;
return;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PMT Found or updated\n""));
nb_sections = gf_list_count(sections);
if (nb_sections > 1) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PMT on multiple sections not supported\n""));
}
section = (GF_M2TS_Section *)gf_list_get(sections, 0);
data = section->data;
data_size = section->data_size;
pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];
info_length = ((data[2]&0xf)<<8) | data[3];
if (info_length != 0) {
u8 tag, len;
u32 first_loop_len = 0;
tag = data[4];
len = data[5];
while (info_length > first_loop_len) {
if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {
u32 size;
GF_BitStream *iod_bs;
iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);
if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);
gf_bs_del(iod_bs );
if (e==GF_OK) {
if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;
if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {
gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
pmt->program->pmt_iod = NULL;
}
}
} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {
GF_BitStream *metadatapd_bs;
GF_M2TS_MetadataPointerDescriptor *metapd;
metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);
metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);
gf_bs_del(metadatapd_bs);
if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&
metapd->format_identifier == GF_M2TS_META_ID3 &&
metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {
pmt->program->metadata_pointer_descriptor = metapd;
} else {
gf_m2ts_metadata_pointer_descriptor_del(metapd);
}
} else {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", tag));
}
first_loop_len += 2 + len;
}
}
if (data_size <= 4 + info_length) return;
data += 4 + info_length;
data_size -= 4 + info_length;
pos = 0;
for(i=0; i<gf_list_count(ts->programs); i++) {
GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);
if(prog->pmt_pid == pmt->pid) {
break;
}
}
nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;
while (pos<data_size) {
GF_M2TS_PES *pes = NULL;
GF_M2TS_SECTION_ES *ses = NULL;
GF_M2TS_ES *es = NULL;
Bool inherit_pcr = 0;
u32 pid, stream_type, reg_desc_format;
stream_type = data[0];
pid = ((data[1] & 0x1f) << 8) | data[2];
desc_len = ((data[3] & 0xf) << 8) | data[4];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""stream_type :%d \n"",stream_type));
switch (stream_type) {
case GF_M2TS_VIDEO_MPEG1:
case GF_M2TS_VIDEO_MPEG2:
case GF_M2TS_VIDEO_DCII:
case GF_M2TS_VIDEO_MPEG4:
case GF_M2TS_SYSTEMS_MPEG4_PES:
case GF_M2TS_VIDEO_H264:
case GF_M2TS_VIDEO_SVC:
case GF_M2TS_VIDEO_MVCD:
case GF_M2TS_VIDEO_HEVC:
case GF_M2TS_VIDEO_HEVC_MCTS:
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
case GF_M2TS_VIDEO_SHVC:
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
case GF_M2TS_VIDEO_MHVC:
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
inherit_pcr = 1;
case GF_M2TS_AUDIO_MPEG1:
case GF_M2TS_AUDIO_MPEG2:
case GF_M2TS_AUDIO_AAC:
case GF_M2TS_AUDIO_LATM_AAC:
case GF_M2TS_AUDIO_AC3:
case GF_M2TS_AUDIO_DTS:
case GF_M2TS_MHAS_MAIN:
case GF_M2TS_MHAS_AUX:
case GF_M2TS_SUBTITLE_DVB:
case GF_M2TS_METADATA_PES:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
if (inherit_pcr)
pes->flags |= GF_M2TS_INHERIT_PCR;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_PRIVATE_DATA:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {
ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);
if (!pmt->program->additional_ods) {
pmt->program->additional_ods = gf_list_new();
ts->has_4on2 = 1;
}
}
break;
case GF_M2TS_13818_6_ANNEX_A:
case GF_M2TS_13818_6_ANNEX_B:
case GF_M2TS_13818_6_ANNEX_C:
case GF_M2TS_13818_6_ANNEX_D:
case GF_M2TS_PRIVATE_SECTION:
case GF_M2TS_QUALITY_SEC:
case GF_M2TS_MORE_SEC:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
es->pid = pid;
es->service_id = pmt->program->number;
if (stream_type == GF_M2TS_PRIVATE_SECTION) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""AIT sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_QUALITY_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Quality metadata sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_MORE_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""MORE sections on pid %d\n"", pid));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type DSM CC user private sections on pid %d \n"", pid));
}
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
break;
case GF_M2TS_MPE_SECTIONS:
if (! ts->prefix_present) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type MPE found : pid = %d \n"", pid));
#ifdef GPAC_ENABLE_MPE
es = gf_dvb_mpe_section_new();
if (es->flags & GF_M2TS_ES_IS_SECTION) {
((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);
}
#endif
break;
}
default:
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
break;
}
if (es) {
es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;
es->program = pmt->program;
es->pid = pid;
es->component_tag = -1;
}
pos += 5;
data += 5;
while (desc_len) {
u8 tag = data[0];
u32 len = data[1];
if (es) {
switch (tag) {
case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:
if (pes)
pes->lang = GF_4CC(' ', data[2], data[3], data[4]);
break;
case GF_M2TS_MPEG4_SL_DESCRIPTOR:
es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];
es->flags |= GF_M2TS_ES_IS_SL;
break;
case GF_M2TS_REGISTRATION_DESCRIPTOR:
reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);
gf_bs_read_int(hbs, 16);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 4);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_del(hbs);
pes->depends_on_pid = 1+hierarchy_embedded_layer_index;
}
break;
case GF_M2TS_METADATA_DESCRIPTOR:
{
GF_BitStream *metadatad_bs;
GF_M2TS_MetadataDescriptor *metad;
metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);
metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);
gf_bs_del(metadatad_bs);
if (metad->application_format_identifier == GF_M2TS_META_ID3 &&
metad->format_identifier == GF_M2TS_META_ID3) {
if (pes) {
pes->metadata_descriptor = metad;
pes->stream_type = GF_M2TS_METADATA_ID3_HLS;
}
} else {
gf_m2ts_metadata_descriptor_del(metad);
}
}
break;
default:
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", tag));
break;
}
}
data += len+2;
pos += len+2;
if (desc_len < len+2) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", pid ) );
break;
}
desc_len-=len+2;
}
if (es && !es->stream_type) {
gf_free(es);
es = NULL;
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
}
if (!es) continue;
if (ts->ess[pid]) {
if (status & GF_M2TS_TABLE_FOUND) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", pid, ts->ess[pid]->program->number, es->program->number ) );
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
es = NULL;
}
else {
GF_M2TS_ES *o_es = ts->ess[es->pid];
if ((o_es->stream_type == es->stream_type)
&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))
&& (o_es->mpeg4_es_id == es->mpeg4_es_id)
&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)
) {
gf_free(es);
es = NULL;
} else {
gf_m2ts_es_del(o_es, ts);
ts->ess[es->pid] = NULL;
}
}
}
if (es) {
ts->ess[es->pid] = es;
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
}
if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
}
if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (es->depends_on_pid) continue;
switch (es->stream_type) {
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
es->depends_on_pid = 1;
break;
case GF_M2TS_VIDEO_SHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
es->depends_on_pid = 3;
break;
case GF_M2TS_VIDEO_MHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
if (!nb_hevc_temp) es->depends_on_pid = 2;
else es->depends_on_pid = 3;
break;
}
}
}
if (nb_es) {
u32 i;
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *an_es = NULL;
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (!es->depends_on_pid) continue;
an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);
if (an_es) {
es->depends_on_pid = an_es->pid;
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
es->depends_on_pid = 0;
}
}
evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;
if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);
} else {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
}
}","static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *VAR_0, GF_M2TS_SECTION_ES *VAR_1, GF_List *VAR_2, u8 VAR_3, u16 VAR_4, u8 VAR_5, u8 VAR_6, u32 VAR_7)
{
u32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12,VAR_13;
u32 VAR_14;
u32 VAR_15;
u32 VAR_16, VAR_17, VAR_18, VAR_19, VAR_20, VAR_21;
unsigned char *VAR_22;
GF_M2TS_Section *VAR_23;
GF_Err VAR_24 = VAR_25;
if (!(VAR_7&VAR_26)) return;
VAR_12 = 0;
if ((VAR_7&VAR_27) && !(VAR_7&VAR_28))  {
if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_29, VAR_1->program);
return;
}
if (VAR_1->sec->demux_restarted) {
VAR_1->sec->demux_restarted = 0;
return;
}
GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] PMT Found or updated\n""));
VAR_14 = gf_list_count(VAR_2);
if (VAR_14 > 1) {
GF_LOG(VAR_32, VAR_31, (""PMT on multiple sections not supported\n""));
}
VAR_23 = (GF_M2TS_Section *)gf_list_get(VAR_2, 0);
VAR_22 = VAR_23->data;
VAR_15 = VAR_23->data_size;
VAR_1->program->pcr_pid = ((VAR_22[0] & 0x1f) << 8) | VAR_22[1];
VAR_8 = ((VAR_22[2]&0xf)<<8) | VAR_22[3];
if (VAR_8 != 0) {
u8 VAR_33, VAR_34;
u32 VAR_35 = 0;
VAR_33 = VAR_22[4];
VAR_34 = VAR_22[5];
while (VAR_8 > VAR_35) {
if (VAR_33 == VAR_36) {
u32 VAR_37;
GF_BitStream *VAR_38;
VAR_38 = gf_bs_new((char *)VAR_22+8, VAR_34-2, VAR_39);
if (VAR_1->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)VAR_1->program->pmt_iod);
VAR_24 = gf_odf_parse_descriptor(VAR_38 , (GF_Descriptor **) &VAR_1->program->pmt_iod, &VAR_37);
gf_bs_del(VAR_38 );
if (VAR_24==VAR_25) {
if (VAR_1->program->pmt_iod) VAR_1->program->pmt_iod->ServiceID = VAR_1->program->number;
if (!gf_list_count(VAR_1->program->pmt_iod->ESDescriptors)) {
gf_odf_desc_del((GF_Descriptor *)VAR_1->program->pmt_iod);
VAR_1->program->pmt_iod = NULL;
}
}
} else if (VAR_33 == VAR_40) {
GF_BitStream *VAR_41;
GF_M2TS_MetadataPointerDescriptor *VAR_42;
VAR_41 = gf_bs_new((char *)VAR_22+6, VAR_34, VAR_39);
VAR_42 = gf_m2ts_read_metadata_pointer_descriptor(VAR_41, VAR_34);
gf_bs_del(VAR_41);
if (VAR_42->application_format_identifier == VAR_43 &&
VAR_42->format_identifier == VAR_43 &&
VAR_42->carriage_flag == VAR_44) {
VAR_1->program->metadata_pointer_descriptor = VAR_42;
} else {
gf_m2ts_metadata_pointer_descriptor_del(VAR_42);
}
} else {
GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", VAR_33));
}
VAR_35 += 2 + VAR_34;
}
}
if (VAR_15 <= 4 + VAR_8) return;
VAR_22 += 4 + VAR_8;
VAR_15 -= 4 + VAR_8;
VAR_9 = 0;
for(VAR_13=0; VAR_13<gf_list_count(VAR_0->programs); VAR_13++) {
GF_M2TS_Program *VAR_45 = (GF_M2TS_Program *)gf_list_get(VAR_0->programs,VAR_13);
if(VAR_45->pmt_pid == VAR_1->pid) {
break;
}
}
VAR_16 = VAR_17 = VAR_18 = VAR_19 = VAR_20 = VAR_21 = 0;
while (VAR_9<VAR_15) {
GF_M2TS_PES *VAR_46 = NULL;
GF_M2TS_SECTION_ES *VAR_47 = NULL;
GF_M2TS_ES *VAR_48 = NULL;
Bool VAR_49 = 0;
u32 VAR_50, VAR_51, VAR_52;
VAR_51 = VAR_22[0];
VAR_50 = ((VAR_22[1] & 0x1f) << 8) | VAR_22[2];
VAR_10 = ((VAR_22[3] & 0xf) << 8) | VAR_22[4];
GF_LOG(VAR_30, VAR_31, (""stream_type :%d \n"",VAR_51));
switch (VAR_51) {
case VAR_53:
case VAR_54:
case VAR_55:
case VAR_56:
case VAR_57:
case VAR_58:
case VAR_59:
case VAR_60:
case VAR_61:
case VAR_62:
case VAR_63:
case VAR_64:
case VAR_65:
case VAR_66:
case VAR_67:
VAR_49 = 1;
case VAR_68:
case VAR_69:
case VAR_70:
case VAR_71:
case VAR_72:
case VAR_73:
case VAR_74:
case VAR_75:
case VAR_76:
case VAR_77:
GF_SAFEALLOC(VAR_46, GF_M2TS_PES);
if (!VAR_46) {
GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
return;
}
VAR_46->cc = -1;
VAR_46->flags = VAR_79;
if (VAR_49)
VAR_46->flags |= VAR_80;
VAR_48 = (GF_M2TS_ES *)VAR_46;
break;
case VAR_81:
GF_SAFEALLOC(VAR_46, GF_M2TS_PES);
if (!VAR_46) {
GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
return;
}
VAR_46->cc = -1;
VAR_46->flags = VAR_79;
VAR_48 = (GF_M2TS_ES *)VAR_46;
break;
case VAR_82:
GF_SAFEALLOC(VAR_47, GF_M2TS_SECTION_ES);
if (!VAR_47) {
GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
return;
}
VAR_48 = (GF_M2TS_ES *)VAR_47;
VAR_48->flags |= VAR_83;
if (VAR_51 == VAR_82) {
VAR_47->sec = gf_m2ts_section_filter_new(VAR_84, 0);
if (!VAR_1->program->additional_ods) {
VAR_1->program->additional_ods = gf_list_new();
VAR_0->has_4on2 = 1;
}
}
break;
case VAR_85:
case VAR_86:
case VAR_87:
case VAR_88:
case VAR_89:
case VAR_90:
case VAR_91:
GF_SAFEALLOC(VAR_47, GF_M2TS_SECTION_ES);
if (!VAR_47) {
GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
return;
}
VAR_48 = (GF_M2TS_ES *)VAR_47;
VAR_48->flags |= VAR_83;
VAR_48->pid = VAR_50;
VAR_48->service_id = VAR_1->program->number;
if (VAR_51 == VAR_89) {
GF_LOG(VAR_92, VAR_31, (""AIT sections on pid %d\n"", VAR_50));
} else if (VAR_51 == VAR_90) {
GF_LOG(VAR_92, VAR_31, (""Quality metadata sections on pid %d\n"", VAR_50));
} else if (VAR_51 == VAR_91) {
GF_LOG(VAR_92, VAR_31, (""MORE sections on pid %d\n"", VAR_50));
} else {
GF_LOG(VAR_92, VAR_31, (""stream type DSM CC user private sections on pid %d \n"", VAR_50));
}
VAR_47->sec = gf_m2ts_section_filter_new(NULL, 1);
break;
case VAR_93:
if (! VAR_0->prefix_present) {
GF_LOG(VAR_92, VAR_31, (""stream type MPE found : pid = %d \n"", VAR_50));
#ifdef VAR_94
VAR_48 = gf_dvb_mpe_section_new();
if (VAR_48->flags & VAR_83) {
((GF_M2TS_SECTION_ES*)VAR_48)->sec = gf_m2ts_section_filter_new(NULL, 1);
}
#endif
break;
}
default:
GF_LOG(VAR_32, VAR_31, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", VAR_51, VAR_50 ) );
break;
}
if (VAR_48) {
VAR_48->stream_type = (VAR_51==VAR_81) ? 0 : VAR_51;
VAR_48->program = VAR_1->program;
VAR_48->pid = VAR_50;
VAR_48->component_tag = -1;
}
VAR_9 += 5;
VAR_22 += 5;
while (VAR_10) {
u8 VAR_33 = VAR_22[0];
u32 VAR_34 = VAR_22[1];
if (VAR_48) {
switch (VAR_33) {
case VAR_95:
if (VAR_46)
VAR_46->lang = GF_4CC(' ', VAR_22[2], VAR_22[3], VAR_22[4]);
break;
case VAR_96:
VAR_48->mpeg4_es_id = ( (u32) VAR_22[2] & 0x1f) << 8  | VAR_22[3];
VAR_48->flags |= VAR_97;
break;
case VAR_98:
VAR_52 = GF_4CC(VAR_22[2], VAR_22[3], VAR_22[4], VAR_22[5]);
switch (VAR_52) {
case VAR_99:
VAR_48->stream_type = VAR_72;
break;
case VAR_100:
VAR_48->stream_type = VAR_101;
break;
case VAR_102:
if (VAR_34==8) {
VAR_48->stream_type = GF_4CC(VAR_22[6], VAR_22[7], VAR_22[8], VAR_22[9]);
VAR_48->flags |= VAR_103;
break;
}
default:
GF_LOG(VAR_92, VAR_31, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(VAR_52) ));
break;
}
break;
case VAR_104:
VAR_48->stream_type = VAR_105;
break;
case VAR_106:
{
u32 VAR_107 = VAR_22[2]<<8 | VAR_22[3];
if ((VAR_107 == 0xB) && VAR_47 && !VAR_47->sec) {
VAR_47->sec = gf_m2ts_section_filter_new(NULL, 1);
}
}
break;
case VAR_108:
if (VAR_46) {
VAR_46->sub.language[0] = VAR_22[2];
VAR_46->sub.language[1] = VAR_22[3];
VAR_46->sub.language[2] = VAR_22[4];
VAR_46->sub.type = VAR_22[5];
VAR_46->sub.composition_page_id = (VAR_22[6]<<8) | VAR_22[7];
VAR_46->sub.ancillary_page_id = (VAR_22[8]<<8) | VAR_22[9];
}
VAR_48->stream_type = VAR_109;
break;
case VAR_110:
{
VAR_48->component_tag = VAR_22[2];
GF_LOG(VAR_30, VAR_31, (""Component Tag: %d on Program %d\n"", VAR_48->component_tag, VAR_48->program->number));
}
break;
case VAR_111:
VAR_48->stream_type = VAR_112;
break;
case VAR_113:
VAR_48->stream_type = VAR_114;
break;
case VAR_115:
if (VAR_46) {
u8 VAR_116;
GF_BitStream *VAR_117 = gf_bs_new((const char *)VAR_22, VAR_15, VAR_39);
gf_bs_read_int(VAR_117, 16);
gf_bs_read_int(VAR_117, 1);
gf_bs_read_int(VAR_117, 1);
gf_bs_read_int(VAR_117, 1);
gf_bs_read_int(VAR_117, 1);
gf_bs_read_int(VAR_117, 4);
gf_bs_read_int(VAR_117, 2);
gf_bs_read_int(VAR_117, 6);
gf_bs_read_int(VAR_117, 1);
gf_bs_read_int(VAR_117, 1);
VAR_116 = gf_bs_read_int(VAR_117, 6);
gf_bs_read_int(VAR_117, 2);
gf_bs_read_int(VAR_117, 6);
gf_bs_del(VAR_117);
VAR_46->depends_on_pid = 1+VAR_116;
}
break;
case VAR_118:
{
GF_BitStream *VAR_119;
GF_M2TS_MetadataDescriptor *VAR_120;
VAR_119 = gf_bs_new((char *)VAR_22+2, VAR_34, VAR_39);
VAR_120 = gf_m2ts_read_metadata_descriptor(VAR_119, VAR_34);
gf_bs_del(VAR_119);
if (VAR_120->application_format_identifier == VAR_43 &&
VAR_120->format_identifier == VAR_43) {
if (VAR_46) {
VAR_46->metadata_descriptor = VAR_120;
VAR_46->stream_type = VAR_121;
}
} else {
gf_m2ts_metadata_descriptor_del(VAR_120);
}
}
break;
default:
GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", VAR_33));
break;
}
}
VAR_22 += VAR_34+2;
VAR_9 += VAR_34+2;
if (VAR_10 < VAR_34+2) {
GF_LOG(VAR_78, VAR_31, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", VAR_50 ) );
break;
}
VAR_10-=VAR_34+2;
}
if (VAR_48 && !VAR_48->stream_type) {
gf_free(VAR_48);
VAR_48 = NULL;
GF_LOG(VAR_78, VAR_31, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", VAR_51, VAR_50 ) );
}
if (!VAR_48) continue;
if (VAR_0->ess[VAR_50]) {
if (VAR_7 & VAR_122) {
GF_LOG(VAR_92, VAR_31, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", VAR_50, VAR_0->ess[VAR_50]->program->number, VAR_48->program->number ) );
gf_list_add(VAR_1->program->streams, VAR_48);
if (!(VAR_48->flags & VAR_83) ) gf_m2ts_set_pes_framing(VAR_46, VAR_123);
VAR_12++;
VAR_48 = NULL;
}
else {
GF_M2TS_ES *VAR_124 = VAR_0->ess[VAR_48->pid];
if ((VAR_124->stream_type == VAR_48->stream_type)
&& ((VAR_124->flags & VAR_125) == (VAR_48->flags & VAR_125))
&& (VAR_124->mpeg4_es_id == VAR_48->mpeg4_es_id)
&& ((VAR_124->flags & VAR_83) || ((GF_M2TS_PES *)VAR_124)->lang == ((GF_M2TS_PES *)VAR_48)->lang)
) {
gf_free(VAR_48);
VAR_48 = NULL;
} else {
gf_m2ts_es_del(VAR_124, VAR_0);
VAR_0->ess[VAR_48->pid] = NULL;
}
}
}
if (VAR_48) {
VAR_0->ess[VAR_48->pid] = VAR_48;
gf_list_add(VAR_1->program->streams, VAR_48);
if (!(VAR_48->flags & VAR_83) ) gf_m2ts_set_pes_framing(VAR_46, VAR_123);
VAR_12++;
}
if (VAR_48->stream_type == VAR_61) VAR_16++;
else if (VAR_48->stream_type == VAR_63) VAR_17++;
else if (VAR_48->stream_type == VAR_64) VAR_18++;
else if (VAR_48->stream_type == VAR_65) VAR_19++;
else if (VAR_48->stream_type == VAR_66) VAR_20++;
else if (VAR_48->stream_type == VAR_67) VAR_21++;
}
if (VAR_17 + VAR_18 + VAR_19 + VAR_20+ VAR_21) {
for (VAR_13=0; VAR_13<gf_list_count(VAR_1->program->streams); VAR_13++) {
GF_M2TS_PES *VAR_48 = (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_13);
if ( !(VAR_48->flags & VAR_79)) continue;
if (VAR_48->depends_on_pid) continue;
switch (VAR_48->stream_type) {
case VAR_63:
VAR_48->depends_on_pid = 1;
break;
case VAR_64:
if (!VAR_17) VAR_48->depends_on_pid = 1;
else VAR_48->depends_on_pid = 2;
break;
case VAR_65:
VAR_48->depends_on_pid = 3;
break;
case VAR_66:
if (!VAR_17) VAR_48->depends_on_pid = 1;
else VAR_48->depends_on_pid = 2;
break;
case VAR_67:
if (!VAR_17) VAR_48->depends_on_pid = 2;
else VAR_48->depends_on_pid = 3;
break;
}
}
}
if (VAR_12) {
u32 VAR_13;
for (VAR_13=0; VAR_13<gf_list_count(VAR_1->program->streams); VAR_13++) {
GF_M2TS_PES *VAR_126 = NULL;
GF_M2TS_PES *VAR_48 = (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_13);
if ( !(VAR_48->flags & VAR_79)) continue;
if (!VAR_48->depends_on_pid) continue;
VAR_126 =  (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_48->depends_on_pid);
if (VAR_126) {
VAR_48->depends_on_pid = VAR_126->pid;
} else {
GF_LOG(VAR_32, VAR_31, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
VAR_48->depends_on_pid = 0;
}
}
VAR_11 = (VAR_7&VAR_122) ? VAR_127 : VAR_128;
if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_11, VAR_1->program);
} else {
if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_29, VAR_1->program);
}
}",gpac/2320eb73afba753b39b7147be91f7be7afc0eeb7/mpegts.c/vul/before/0.json,"static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
	u32 info_length, pos, desc_len, evt_type, nb_es,i;
	u32 nb_sections;
	u32 data_size;
	u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;
	unsigned char *data;
	GF_M2TS_Section *section;
	GF_Err e = GF_OK;

	/*wait for the last section */
	if (!(status&GF_M2TS_TABLE_END)) return;

	nb_es = 0;

	/*skip if already received but no update detected (eg same data) */
	if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {
		if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
		return;
	}

	if (pmt->sec->demux_restarted) {
		pmt->sec->demux_restarted = 0;
		return;
	}
	GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PMT Found or updated\n""));

	nb_sections = gf_list_count(sections);
	if (nb_sections > 1) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PMT on multiple sections not supported\n""));
	}

	section = (GF_M2TS_Section *)gf_list_get(sections, 0);
	data = section->data;
	data_size = section->data_size;

	pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];

	info_length = ((data[2]&0xf)<<8) | data[3];
	if (info_length != 0) {
		/* ...Read Descriptors ... */
		u8 tag, len;
		u32 first_loop_len = 0;
		tag = data[4];
		len = data[5];
		while (info_length > first_loop_len) {
			if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {
				u32 size;
				GF_BitStream *iod_bs;
				iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);
				if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
				e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);
				gf_bs_del(iod_bs );
				if (e==GF_OK) {
					/*remember program number for service/program selection*/
					if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;
					/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/
					if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {
						gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
						pmt->program->pmt_iod = NULL;
					}
				}
			} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {
				GF_BitStream *metadatapd_bs;
				GF_M2TS_MetadataPointerDescriptor *metapd;
				metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);
				metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);
				gf_bs_del(metadatapd_bs);
				if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&
				        metapd->format_identifier == GF_M2TS_META_ID3 &&
				        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {
					/*HLS ID3 Metadata */
					pmt->program->metadata_pointer_descriptor = metapd;
				} else {
					/* don't know what to do with it for now, delete */
					gf_m2ts_metadata_pointer_descriptor_del(metapd);
				}
			} else {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", tag));
			}
			first_loop_len += 2 + len;
		}
	}
	if (data_size <= 4 + info_length) return;
	data += 4 + info_length;
	data_size -= 4 + info_length;
	pos = 0;

	/* count de number of program related PMT received */
	for(i=0; i<gf_list_count(ts->programs); i++) {
		GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);
		if(prog->pmt_pid == pmt->pid) {
			break;
		}
	}

	nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;
	while (pos<data_size) {
		GF_M2TS_PES *pes = NULL;
		GF_M2TS_SECTION_ES *ses = NULL;
		GF_M2TS_ES *es = NULL;
		Bool inherit_pcr = 0;
		u32 pid, stream_type, reg_desc_format;

		stream_type = data[0];
		pid = ((data[1] & 0x1f) << 8) | data[2];
		desc_len = ((data[3] & 0xf) << 8) | data[4];

		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""stream_type :%d \n"",stream_type));
		switch (stream_type) {

		/* PES */
		case GF_M2TS_VIDEO_MPEG1:
		case GF_M2TS_VIDEO_MPEG2:
		case GF_M2TS_VIDEO_DCII:
		case GF_M2TS_VIDEO_MPEG4:
		case GF_M2TS_SYSTEMS_MPEG4_PES:
		case GF_M2TS_VIDEO_H264:
		case GF_M2TS_VIDEO_SVC:
		case GF_M2TS_VIDEO_MVCD:
		case GF_M2TS_VIDEO_HEVC:
		case GF_M2TS_VIDEO_HEVC_MCTS:
		case GF_M2TS_VIDEO_HEVC_TEMPORAL:
		case GF_M2TS_VIDEO_SHVC:
		case GF_M2TS_VIDEO_SHVC_TEMPORAL:
		case GF_M2TS_VIDEO_MHVC:
		case GF_M2TS_VIDEO_MHVC_TEMPORAL:
			inherit_pcr = 1;
		case GF_M2TS_AUDIO_MPEG1:
		case GF_M2TS_AUDIO_MPEG2:
		case GF_M2TS_AUDIO_AAC:
		case GF_M2TS_AUDIO_LATM_AAC:
		case GF_M2TS_AUDIO_AC3:
		case GF_M2TS_AUDIO_DTS:
		case GF_M2TS_MHAS_MAIN:
		case GF_M2TS_MHAS_AUX:
		case GF_M2TS_SUBTITLE_DVB:
		case GF_M2TS_METADATA_PES:
			GF_SAFEALLOC(pes, GF_M2TS_PES);
			if (!pes) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
				return;
			}
			pes->cc = -1;
			pes->flags = GF_M2TS_ES_IS_PES;
			if (inherit_pcr)
				pes->flags |= GF_M2TS_INHERIT_PCR;
			es = (GF_M2TS_ES *)pes;
			break;
		case GF_M2TS_PRIVATE_DATA:
			GF_SAFEALLOC(pes, GF_M2TS_PES);
			if (!pes) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
				return;
			}
			pes->cc = -1;
			pes->flags = GF_M2TS_ES_IS_PES;
			es = (GF_M2TS_ES *)pes;
			break;
		/* Sections */
		case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:
			GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
			if (!ses) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
				return;
			}
			es = (GF_M2TS_ES *)ses;
			es->flags |= GF_M2TS_ES_IS_SECTION;
			/* carriage of ISO_IEC_14496 data in sections */
			if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {
				/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost
				one SL packet in the AU so we must wait for the complete section again*/
				ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);
				/*create OD container*/
				if (!pmt->program->additional_ods) {
					pmt->program->additional_ods = gf_list_new();
					ts->has_4on2 = 1;
				}
			}
			break;

		case GF_M2TS_13818_6_ANNEX_A:
		case GF_M2TS_13818_6_ANNEX_B:
		case GF_M2TS_13818_6_ANNEX_C:
		case GF_M2TS_13818_6_ANNEX_D:
		case GF_M2TS_PRIVATE_SECTION:
		case GF_M2TS_QUALITY_SEC:
		case GF_M2TS_MORE_SEC:
			GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
			if (!ses) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
				return;
			}
			es = (GF_M2TS_ES *)ses;
			es->flags |= GF_M2TS_ES_IS_SECTION;
			es->pid = pid;
			es->service_id = pmt->program->number;
			if (stream_type == GF_M2TS_PRIVATE_SECTION) {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""AIT sections on pid %d\n"", pid));
			} else if (stream_type == GF_M2TS_QUALITY_SEC) {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Quality metadata sections on pid %d\n"", pid));
			} else if (stream_type == GF_M2TS_MORE_SEC) {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""MORE sections on pid %d\n"", pid));
			} else {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type DSM CC user private sections on pid %d \n"", pid));
			}
			/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */
			ses->sec = gf_m2ts_section_filter_new(NULL, 1);
			//ses->sec->service_id = pmt->program->number;
			break;

		case GF_M2TS_MPE_SECTIONS:
			if (! ts->prefix_present) {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type MPE found : pid = %d \n"", pid));
#ifdef GPAC_ENABLE_MPE
				es = gf_dvb_mpe_section_new();
				if (es->flags & GF_M2TS_ES_IS_SECTION) {
					/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */
					((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);
				}
#endif
				break;
			}

		default:
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
			//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
			break;
		}

		if (es) {
			es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;
			es->program = pmt->program;
			es->pid = pid;
			es->component_tag = -1;
		}

		pos += 5;
		data += 5;

		while (desc_len) {
			u8 tag = data[0];
			u32 len = data[1];
			if (es) {
				switch (tag) {
				case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:
					if (pes)
						pes->lang = GF_4CC(' ', data[2], data[3], data[4]);
					break;
				case GF_M2TS_MPEG4_SL_DESCRIPTOR:
					es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];
					es->flags |= GF_M2TS_ES_IS_SL;
					break;
				case GF_M2TS_REGISTRATION_DESCRIPTOR:
					reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);
					/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/
					switch (reg_desc_format) {
					case GF_M2TS_RA_STREAM_AC3:
						es->stream_type = GF_M2TS_AUDIO_AC3;
						break;
					case GF_M2TS_RA_STREAM_VC1:
						es->stream_type = GF_M2TS_VIDEO_VC1;
						break;
					case GF_M2TS_RA_STREAM_GPAC:
						if (len==8) {
							es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);
							es->flags |= GF_M2TS_GPAC_CODEC_ID;
							break;
						}
					default:
						GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(reg_desc_format) ));
						break;
					}
					break;
				case GF_M2TS_DVB_EAC3_DESCRIPTOR:
					es->stream_type = GF_M2TS_AUDIO_EC3;
					break;
				case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:
				{
					u32 id = data[2]<<8 | data[3];
					if ((id == 0xB) && ses && !ses->sec) {
						ses->sec = gf_m2ts_section_filter_new(NULL, 1);
					}
				}
				break;
				case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:
					if (pes) {
						pes->sub.language[0] = data[2];
						pes->sub.language[1] = data[3];
						pes->sub.language[2] = data[4];
						pes->sub.type = data[5];
						pes->sub.composition_page_id = (data[6]<<8) | data[7];
						pes->sub.ancillary_page_id = (data[8]<<8) | data[9];
					}
					es->stream_type = GF_M2TS_DVB_SUBTITLE;
					break;
				case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:
				{
					es->component_tag = data[2];
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""Component Tag: %d on Program %d\n"", es->component_tag, es->program->number));
				}
				break;
				case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:
					es->stream_type = GF_M2TS_DVB_TELETEXT;
					break;
				case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:
					es->stream_type = GF_M2TS_DVB_VBI;
					break;
				case GF_M2TS_HIERARCHY_DESCRIPTOR:
					if (pes) {
						u8 hierarchy_embedded_layer_index;
						GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);
						/*u32 skip = */gf_bs_read_int(hbs, 16);
						/*u8 res1 = */gf_bs_read_int(hbs, 1);
						/*u8 temp_scal = */gf_bs_read_int(hbs, 1);
						/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);
						/*u8 quality_scal = */gf_bs_read_int(hbs, 1);
						/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);
						/*u8 res2 = */gf_bs_read_int(hbs, 2);
						/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);
						/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);
						/*u8 res3 = */gf_bs_read_int(hbs, 1);
						hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);
						/*u8 res4 = */gf_bs_read_int(hbs, 2);
						/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);
						gf_bs_del(hbs);

						pes->depends_on_pid = 1+hierarchy_embedded_layer_index;
					}
					break;
				case GF_M2TS_METADATA_DESCRIPTOR:
				{
					GF_BitStream *metadatad_bs;
					GF_M2TS_MetadataDescriptor *metad;
					metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);
					metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);
					gf_bs_del(metadatad_bs);
					if (metad->application_format_identifier == GF_M2TS_META_ID3 &&
					        metad->format_identifier == GF_M2TS_META_ID3) {
						/*HLS ID3 Metadata */
						if (pes) {
							pes->metadata_descriptor = metad;
							pes->stream_type = GF_M2TS_METADATA_ID3_HLS;
						}
					} else {
						/* don't know what to do with it for now, delete */
						gf_m2ts_metadata_descriptor_del(metad);
					}
				}
				break;

				default:
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", tag));
					break;
				}
			}

			data += len+2;
			pos += len+2;
			if (desc_len < len+2) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", pid ) );
				break;
			}
			desc_len-=len+2;
		}

		if (es && !es->stream_type) {
			gf_free(es);
			es = NULL;
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
		}

		if (!es) continue;

		if (ts->ess[pid]) {
			//this is component reuse across programs, overwrite the previously declared stream ...
			if (status & GF_M2TS_TABLE_FOUND) {
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", pid, ts->ess[pid]->program->number, es->program->number ) );

				//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)
				gf_list_add(pmt->program->streams, es);
				if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);

				nb_es++;
				//skip assignment below
				es = NULL;
			}
			/*watchout for pmt update - FIXME this likely won't work in most cases*/
			else {

				GF_M2TS_ES *o_es = ts->ess[es->pid];

				if ((o_es->stream_type == es->stream_type)
				        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))
				        && (o_es->mpeg4_es_id == es->mpeg4_es_id)
				        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)
				   ) {
					gf_free(es);
					es = NULL;
				} else {
					gf_m2ts_es_del(o_es, ts);
					ts->ess[es->pid] = NULL;
				}
			}
		}

		if (es) {
			ts->ess[es->pid] = es;
			gf_list_add(pmt->program->streams, es);
			if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);

			nb_es++;

			if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
			else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
			else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
			else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
			else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
			else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
		}
	}

	//Table 2-139, implied hierarchy indexes
	if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {
		for (i=0; i<gf_list_count(pmt->program->streams); i++) {
			GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
			if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
			if (es->depends_on_pid) continue;

			switch (es->stream_type) {
			case GF_M2TS_VIDEO_HEVC_TEMPORAL:
				es->depends_on_pid = 1;
				break;
			case GF_M2TS_VIDEO_SHVC:
				if (!nb_hevc_temp) es->depends_on_pid = 1;
				else es->depends_on_pid = 2;
				break;
			case GF_M2TS_VIDEO_SHVC_TEMPORAL:
				es->depends_on_pid = 3;
				break;
			case GF_M2TS_VIDEO_MHVC:
				if (!nb_hevc_temp) es->depends_on_pid = 1;
				else es->depends_on_pid = 2;
				break;
			case GF_M2TS_VIDEO_MHVC_TEMPORAL:
				if (!nb_hevc_temp) es->depends_on_pid = 2;
				else es->depends_on_pid = 3;
				break;
			}
		}
	}

	if (nb_es) {
		u32 i;

		//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC
		for (i=0; i<gf_list_count(pmt->program->streams); i++) {
			GF_M2TS_PES *an_es = NULL;
			GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
			if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
			if (!es->depends_on_pid) continue;

			//fixeme we are not always assured that hierarchy_layer_index matches the stream index...
			//+1 is because our first stream is the PMT
			an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);
			if (an_es) {
				es->depends_on_pid = an_es->pid;
			} else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
				es->depends_on_pid = 0;
			}
		}

		evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;
		if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);
	} else {
		/* if we found no new ES it's simply a repeat of the PMT */
		if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
	}
}","static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *VAR_0, GF_M2TS_SECTION_ES *VAR_1, GF_List *VAR_2, u8 VAR_3, u16 VAR_4, u8 VAR_5, u8 VAR_6, u32 VAR_7)
{
	u32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12,VAR_13;
	u32 VAR_14;
	u32 VAR_15;
	u32 VAR_16, VAR_17, VAR_18, VAR_19, VAR_20, VAR_21;
	unsigned char *VAR_22;
	GF_M2TS_Section *VAR_23;
	GF_Err VAR_24 = VAR_25;

	/* COMMENT_0 */
	if (!(VAR_7&VAR_26)) return;

	VAR_12 = 0;

	/* COMMENT_1 */
	if ((VAR_7&VAR_27) && !(VAR_7&VAR_28))  {
		if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_29, VAR_1->program);
		return;
	}

	if (VAR_1->sec->demux_restarted) {
		VAR_1->sec->demux_restarted = 0;
		return;
	}
	GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] PMT Found or updated\n""));

	VAR_14 = gf_list_count(VAR_2);
	if (VAR_14 > 1) {
		GF_LOG(VAR_32, VAR_31, (""PMT on multiple sections not supported\n""));
	}

	VAR_23 = (GF_M2TS_Section *)gf_list_get(VAR_2, 0);
	VAR_22 = VAR_23->data;
	VAR_15 = VAR_23->data_size;

	VAR_1->program->pcr_pid = ((VAR_22[0] & 0x1f) << 8) | VAR_22[1];

	VAR_8 = ((VAR_22[2]&0xf)<<8) | VAR_22[3];
	if (VAR_8 != 0) {
		/* COMMENT_2 */
		u8 VAR_33, VAR_34;
		u32 VAR_35 = 0;
		VAR_33 = VAR_22[4];
		VAR_34 = VAR_22[5];
		while (VAR_8 > VAR_35) {
			if (VAR_33 == VAR_36) {
				u32 VAR_37;
				GF_BitStream *VAR_38;
				VAR_38 = gf_bs_new((char *)VAR_22+8, VAR_34-2, VAR_39);
				if (VAR_1->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)VAR_1->program->pmt_iod);
				VAR_24 = gf_odf_parse_descriptor(VAR_38 , (GF_Descriptor **) &VAR_1->program->pmt_iod, &VAR_37);
				gf_bs_del(VAR_38 );
				if (VAR_24==VAR_25) {
					/* COMMENT_3 */
					if (VAR_1->program->pmt_iod) VAR_1->program->pmt_iod->ServiceID = VAR_1->program->number;
					/* COMMENT_4 */
					if (!gf_list_count(VAR_1->program->pmt_iod->ESDescriptors)) {
						gf_odf_desc_del((GF_Descriptor *)VAR_1->program->pmt_iod);
						VAR_1->program->pmt_iod = NULL;
					}
				}
			} else if (VAR_33 == VAR_40) {
				GF_BitStream *VAR_41;
				GF_M2TS_MetadataPointerDescriptor *VAR_42;
				VAR_41 = gf_bs_new((char *)VAR_22+6, VAR_34, VAR_39);
				VAR_42 = gf_m2ts_read_metadata_pointer_descriptor(VAR_41, VAR_34);
				gf_bs_del(VAR_41);
				if (VAR_42->application_format_identifier == VAR_43 &&
				        VAR_42->format_identifier == VAR_43 &&
				        VAR_42->carriage_flag == VAR_44) {
					/* COMMENT_5 */
					VAR_1->program->metadata_pointer_descriptor = VAR_42;
				} else {
					/* COMMENT_6 */
					gf_m2ts_metadata_pointer_descriptor_del(VAR_42);
				}
			} else {
				GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", VAR_33));
			}
			VAR_35 += 2 + VAR_34;
		}
	}
	if (VAR_15 <= 4 + VAR_8) return;
	VAR_22 += 4 + VAR_8;
	VAR_15 -= 4 + VAR_8;
	VAR_9 = 0;

	/* COMMENT_7 */
	for(VAR_13=0; VAR_13<gf_list_count(VAR_0->programs); VAR_13++) {
		GF_M2TS_Program *VAR_45 = (GF_M2TS_Program *)gf_list_get(VAR_0->programs,VAR_13);
		if(VAR_45->pmt_pid == VAR_1->pid) {
			break;
		}
	}

	VAR_16 = VAR_17 = VAR_18 = VAR_19 = VAR_20 = VAR_21 = 0;
	while (VAR_9<VAR_15) {
		GF_M2TS_PES *VAR_46 = NULL;
		GF_M2TS_SECTION_ES *VAR_47 = NULL;
		GF_M2TS_ES *VAR_48 = NULL;
		Bool VAR_49 = 0;
		u32 VAR_50, VAR_51, VAR_52;

		VAR_51 = VAR_22[0];
		VAR_50 = ((VAR_22[1] & 0x1f) << 8) | VAR_22[2];
		VAR_10 = ((VAR_22[3] & 0xf) << 8) | VAR_22[4];

		GF_LOG(VAR_30, VAR_31, (""stream_type :%d \n"",VAR_51));
		switch (VAR_51) {

		/* COMMENT_8 */
		case VAR_53:
		case VAR_54:
		case VAR_55:
		case VAR_56:
		case VAR_57:
		case VAR_58:
		case VAR_59:
		case VAR_60:
		case VAR_61:
		case VAR_62:
		case VAR_63:
		case VAR_64:
		case VAR_65:
		case VAR_66:
		case VAR_67:
			VAR_49 = 1;
		case VAR_68:
		case VAR_69:
		case VAR_70:
		case VAR_71:
		case VAR_72:
		case VAR_73:
		case VAR_74:
		case VAR_75:
		case VAR_76:
		case VAR_77:
			GF_SAFEALLOC(VAR_46, GF_M2TS_PES);
			if (!VAR_46) {
				GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
				return;
			}
			VAR_46->cc = -1;
			VAR_46->flags = VAR_79;
			if (VAR_49)
				VAR_46->flags |= VAR_80;
			VAR_48 = (GF_M2TS_ES *)VAR_46;
			break;
		case VAR_81:
			GF_SAFEALLOC(VAR_46, GF_M2TS_PES);
			if (!VAR_46) {
				GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
				return;
			}
			VAR_46->cc = -1;
			VAR_46->flags = VAR_79;
			VAR_48 = (GF_M2TS_ES *)VAR_46;
			break;
		/* COMMENT_9 */
		case VAR_82:
			GF_SAFEALLOC(VAR_47, GF_M2TS_SECTION_ES);
			if (!VAR_47) {
				GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
				return;
			}
			VAR_48 = (GF_M2TS_ES *)VAR_47;
			VAR_48->flags |= VAR_83;
			/* COMMENT_10 */
			if (VAR_51 == VAR_82) {
				/* COMMENT_11 */
                                                                            
				VAR_47->sec = gf_m2ts_section_filter_new(VAR_84, 0);
				/* COMMENT_13 */
				if (!VAR_1->program->additional_ods) {
					VAR_1->program->additional_ods = gf_list_new();
					VAR_0->has_4on2 = 1;
				}
			}
			break;

		case VAR_85:
		case VAR_86:
		case VAR_87:
		case VAR_88:
		case VAR_89:
		case VAR_90:
		case VAR_91:
			GF_SAFEALLOC(VAR_47, GF_M2TS_SECTION_ES);
			if (!VAR_47) {
				GF_LOG(VAR_78, VAR_31, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", VAR_50));
				return;
			}
			VAR_48 = (GF_M2TS_ES *)VAR_47;
			VAR_48->flags |= VAR_83;
			VAR_48->pid = VAR_50;
			VAR_48->service_id = VAR_1->program->number;
			if (VAR_51 == VAR_89) {
				GF_LOG(VAR_92, VAR_31, (""AIT sections on pid %d\n"", VAR_50));
			} else if (VAR_51 == VAR_90) {
				GF_LOG(VAR_92, VAR_31, (""Quality metadata sections on pid %d\n"", VAR_50));
			} else if (VAR_51 == VAR_91) {
				GF_LOG(VAR_92, VAR_31, (""MORE sections on pid %d\n"", VAR_50));
			} else {
				GF_LOG(VAR_92, VAR_31, (""stream type DSM CC user private sections on pid %d \n"", VAR_50));
			}
			/* COMMENT_14 */
			VAR_47->sec = gf_m2ts_section_filter_new(NULL, 1);
			/* COMMENT_15 */
			break;

		case VAR_93:
			if (! VAR_0->prefix_present) {
				GF_LOG(VAR_92, VAR_31, (""stream type MPE found : pid = %d \n"", VAR_50));
#ifdef VAR_94
				VAR_48 = gf_dvb_mpe_section_new();
				if (VAR_48->flags & VAR_83) {
					/* COMMENT_14 */
					((GF_M2TS_SECTION_ES*)VAR_48)->sec = gf_m2ts_section_filter_new(NULL, 1);
				}
#endif
				break;
			}

		default:
			GF_LOG(VAR_32, VAR_31, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", VAR_51, VAR_50 ) );
			/* COMMENT_16 */
			break;
		}

		if (VAR_48) {
			VAR_48->stream_type = (VAR_51==VAR_81) ? 0 : VAR_51;
			VAR_48->program = VAR_1->program;
			VAR_48->pid = VAR_50;
			VAR_48->component_tag = -1;
		}

		VAR_9 += 5;
		VAR_22 += 5;

		while (VAR_10) {
			u8 VAR_33 = VAR_22[0];
			u32 VAR_34 = VAR_22[1];
			if (VAR_48) {
				switch (VAR_33) {
				case VAR_95:
					if (VAR_46)
						VAR_46->lang = GF_4CC(' ', VAR_22[2], VAR_22[3], VAR_22[4]);
					break;
				case VAR_96:
					VAR_48->mpeg4_es_id = ( (u32) VAR_22[2] & 0x1f) << 8  | VAR_22[3];
					VAR_48->flags |= VAR_97;
					break;
				case VAR_98:
					VAR_52 = GF_4CC(VAR_22[2], VAR_22[3], VAR_22[4], VAR_22[5]);
					/* COMMENT_17 */
					switch (VAR_52) {
					case VAR_99:
						VAR_48->stream_type = VAR_72;
						break;
					case VAR_100:
						VAR_48->stream_type = VAR_101;
						break;
					case VAR_102:
						if (VAR_34==8) {
							VAR_48->stream_type = GF_4CC(VAR_22[6], VAR_22[7], VAR_22[8], VAR_22[9]);
							VAR_48->flags |= VAR_103;
							break;
						}
					default:
						GF_LOG(VAR_92, VAR_31, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(VAR_52) ));
						break;
					}
					break;
				case VAR_104:
					VAR_48->stream_type = VAR_105;
					break;
				case VAR_106:
				{
					u32 VAR_107 = VAR_22[2]<<8 | VAR_22[3];
					if ((VAR_107 == 0xB) && VAR_47 && !VAR_47->sec) {
						VAR_47->sec = gf_m2ts_section_filter_new(NULL, 1);
					}
				}
				break;
				case VAR_108:
					if (VAR_46) {
						VAR_46->sub.language[0] = VAR_22[2];
						VAR_46->sub.language[1] = VAR_22[3];
						VAR_46->sub.language[2] = VAR_22[4];
						VAR_46->sub.type = VAR_22[5];
						VAR_46->sub.composition_page_id = (VAR_22[6]<<8) | VAR_22[7];
						VAR_46->sub.ancillary_page_id = (VAR_22[8]<<8) | VAR_22[9];
					}
					VAR_48->stream_type = VAR_109;
					break;
				case VAR_110:
				{
					VAR_48->component_tag = VAR_22[2];
					GF_LOG(VAR_30, VAR_31, (""Component Tag: %d on Program %d\n"", VAR_48->component_tag, VAR_48->program->number));
				}
				break;
				case VAR_111:
					VAR_48->stream_type = VAR_112;
					break;
				case VAR_113:
					VAR_48->stream_type = VAR_114;
					break;
				case VAR_115:
					if (VAR_46) {
						u8 VAR_116;
						GF_BitStream *VAR_117 = gf_bs_new((const char *)VAR_22, VAR_15, VAR_39);
						/* COMMENT_18 */gf_bs_read_int(VAR_117, 16);
						/* COMMENT_19 */gf_bs_read_int(VAR_117, 1);
						/* COMMENT_20 */gf_bs_read_int(VAR_117, 1);
						/* COMMENT_21 */gf_bs_read_int(VAR_117, 1);
						/* COMMENT_22 */gf_bs_read_int(VAR_117, 1);
						/* COMMENT_23 */gf_bs_read_int(VAR_117, 4);
						/* COMMENT_24 */gf_bs_read_int(VAR_117, 2);
						/* COMMENT_25 */gf_bs_read_int(VAR_117, 6);
						/* COMMENT_26 */gf_bs_read_int(VAR_117, 1);
						/* COMMENT_27 */gf_bs_read_int(VAR_117, 1);
						VAR_116 = gf_bs_read_int(VAR_117, 6);
						/* COMMENT_28 */gf_bs_read_int(VAR_117, 2);
						/* COMMENT_29 */gf_bs_read_int(VAR_117, 6);
						gf_bs_del(VAR_117);

						VAR_46->depends_on_pid = 1+VAR_116;
					}
					break;
				case VAR_118:
				{
					GF_BitStream *VAR_119;
					GF_M2TS_MetadataDescriptor *VAR_120;
					VAR_119 = gf_bs_new((char *)VAR_22+2, VAR_34, VAR_39);
					VAR_120 = gf_m2ts_read_metadata_descriptor(VAR_119, VAR_34);
					gf_bs_del(VAR_119);
					if (VAR_120->application_format_identifier == VAR_43 &&
					        VAR_120->format_identifier == VAR_43) {
						/* COMMENT_5 */
						if (VAR_46) {
							VAR_46->metadata_descriptor = VAR_120;
							VAR_46->stream_type = VAR_121;
						}
					} else {
						/* COMMENT_6 */
						gf_m2ts_metadata_descriptor_del(VAR_120);
					}
				}
				break;

				default:
					GF_LOG(VAR_30, VAR_31, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", VAR_33));
					break;
				}
			}

			VAR_22 += VAR_34+2;
			VAR_9 += VAR_34+2;
			if (VAR_10 < VAR_34+2) {
				GF_LOG(VAR_78, VAR_31, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", VAR_50 ) );
				break;
			}
			VAR_10-=VAR_34+2;
		}

		if (VAR_48 && !VAR_48->stream_type) {
			gf_free(VAR_48);
			VAR_48 = NULL;
			GF_LOG(VAR_78, VAR_31, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", VAR_51, VAR_50 ) );
		}

		if (!VAR_48) continue;

		if (VAR_0->ess[VAR_50]) {
			/* COMMENT_30 */
			if (VAR_7 & VAR_122) {
				GF_LOG(VAR_92, VAR_31, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", VAR_50, VAR_0->ess[VAR_50]->program->number, VAR_48->program->number ) );

				/* COMMENT_31 */
				gf_list_add(VAR_1->program->streams, VAR_48);
				if (!(VAR_48->flags & VAR_83) ) gf_m2ts_set_pes_framing(VAR_46, VAR_123);

				VAR_12++;
				/* COMMENT_32 */
				VAR_48 = NULL;
			}
			/* COMMENT_33 */
			else {

				GF_M2TS_ES *VAR_124 = VAR_0->ess[VAR_48->pid];

				if ((VAR_124->stream_type == VAR_48->stream_type)
				        && ((VAR_124->flags & VAR_125) == (VAR_48->flags & VAR_125))
				        && (VAR_124->mpeg4_es_id == VAR_48->mpeg4_es_id)
				        && ((VAR_124->flags & VAR_83) || ((GF_M2TS_PES *)VAR_124)->lang == ((GF_M2TS_PES *)VAR_48)->lang)
				   ) {
					gf_free(VAR_48);
					VAR_48 = NULL;
				} else {
					gf_m2ts_es_del(VAR_124, VAR_0);
					VAR_0->ess[VAR_48->pid] = NULL;
				}
			}
		}

		if (VAR_48) {
			VAR_0->ess[VAR_48->pid] = VAR_48;
			gf_list_add(VAR_1->program->streams, VAR_48);
			if (!(VAR_48->flags & VAR_83) ) gf_m2ts_set_pes_framing(VAR_46, VAR_123);

			VAR_12++;

			if (VAR_48->stream_type == VAR_61) VAR_16++;
			else if (VAR_48->stream_type == VAR_63) VAR_17++;
			else if (VAR_48->stream_type == VAR_64) VAR_18++;
			else if (VAR_48->stream_type == VAR_65) VAR_19++;
			else if (VAR_48->stream_type == VAR_66) VAR_20++;
			else if (VAR_48->stream_type == VAR_67) VAR_21++;
		}
	}

	/* COMMENT_34 */
	if (VAR_17 + VAR_18 + VAR_19 + VAR_20+ VAR_21) {
		for (VAR_13=0; VAR_13<gf_list_count(VAR_1->program->streams); VAR_13++) {
			GF_M2TS_PES *VAR_48 = (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_13);
			if ( !(VAR_48->flags & VAR_79)) continue;
			if (VAR_48->depends_on_pid) continue;

			switch (VAR_48->stream_type) {
			case VAR_63:
				VAR_48->depends_on_pid = 1;
				break;
			case VAR_64:
				if (!VAR_17) VAR_48->depends_on_pid = 1;
				else VAR_48->depends_on_pid = 2;
				break;
			case VAR_65:
				VAR_48->depends_on_pid = 3;
				break;
			case VAR_66:
				if (!VAR_17) VAR_48->depends_on_pid = 1;
				else VAR_48->depends_on_pid = 2;
				break;
			case VAR_67:
				if (!VAR_17) VAR_48->depends_on_pid = 2;
				else VAR_48->depends_on_pid = 3;
				break;
			}
		}
	}

	if (VAR_12) {
		u32 VAR_13;

		/* COMMENT_35 */
		for (VAR_13=0; VAR_13<gf_list_count(VAR_1->program->streams); VAR_13++) {
			GF_M2TS_PES *VAR_126 = NULL;
			GF_M2TS_PES *VAR_48 = (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_13);
			if ( !(VAR_48->flags & VAR_79)) continue;
			if (!VAR_48->depends_on_pid) continue;

			/* COMMENT_36 */
			/* COMMENT_37 */
			VAR_126 =  (GF_M2TS_PES *)gf_list_get(VAR_1->program->streams, VAR_48->depends_on_pid);
			if (VAR_126) {
				VAR_48->depends_on_pid = VAR_126->pid;
			} else {
				GF_LOG(VAR_32, VAR_31, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
				VAR_48->depends_on_pid = 0;
			}
		}

		VAR_11 = (VAR_7&VAR_122) ? VAR_127 : VAR_128;
		if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_11, VAR_1->program);
	} else {
		/* COMMENT_38 */
		if (VAR_0->on_event) VAR_0->on_event(VAR_0, VAR_29, VAR_1->program);
	}
}",gpac/2320eb73afba753b39b7147be91f7be7afc0eeb7/mpegts.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -410,14 +410,14 @@
 			if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
 
 			nb_es++;
-		}
-
-		if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
-		else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
-		else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
-		else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
-		else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
-		else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
+
+			if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
+			else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
+			else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
+			else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
+			else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
+			else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
+		}
 	}
 
 	//Table 2-139, implied hierarchy indexes","{'deleted_lines': ['\t\t}', '', '\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;', '\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;', '\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;', '\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;', '\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;', '\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;'], 'added_lines': ['', '\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;', '\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;', '\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;', '\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;', '\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;', '\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;', '\t\t}']}",True,"An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in gf_m2ts_process_pmt in media_tools/mpegts.c that can cause a denial of service via a crafted MP4 file.",5.5,MEDIUM,1,valid,2019-07-07T14:55:12Z,2
CVE-2019-8460,['CWE-1049'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openbsd/src,"Received SACK options are managed by a linked list at the TCP socket.
There is a global tunable limit net.inet.tcp.sackholelimit, default
is 32768.  If an attacker manages to attach all these sack holes
to a few TCP connections, the lists may grow long.  Traversing them
might cause higher CPU consumption on the victim machine.  In
practice such a situation is hard to create as the TCP retransmit
and 2*msl timer flush the list periodically.  For additional
protection, enforce a per connection limit of 128 SACK holes in the
list.
reported by Reuven Plevinsky and Tal Vainshtein
discussed with claudio@ and procter@; OK deraadt@",ed8fdce754a5d8d14c09e989d8877707bd43906f,https://github.com/openbsd/src/commit/ed8fdce754a5d8d14c09e989d8877707bd43906f,sys/netinet/tcp_input.c,tcp_sack_option,"void
tcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)
{
int tmp_olen;
u_char *tmp_cp;
struct sackhole *cur, *p, *temp;
if (!tp->sack_enable)
return;
if ((th->th_flags & TH_ACK) == 0)
return;
if (SEQ_LT(th->th_ack, tp->snd_una) ||
SEQ_GT(th->th_ack, tp->snd_max))
return;
if (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)
return;
tmp_cp = cp + 2;
tmp_olen = optlen - 2;
tcpstat_inc(tcps_sack_rcv_opts);
if (tp->snd_numholes < 0)
tp->snd_numholes = 0;
if (tp->t_maxseg == 0)
panic(""tcp_sack_option""); 
while (tmp_olen > 0) {
struct sackblk sack;
memcpy(&sack.start, tmp_cp, sizeof(tcp_seq));
sack.start = ntohl(sack.start);
memcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));
sack.end = ntohl(sack.end);
tmp_olen -= TCPOLEN_SACK;
tmp_cp += TCPOLEN_SACK;
if (SEQ_LEQ(sack.end, sack.start))
continue; 
if (SEQ_LEQ(sack.end, tp->snd_una))
continue; 
if (SEQ_GT(th->th_ack, tp->snd_una)) {
if (SEQ_LT(sack.start, th->th_ack))
continue;
}
if (SEQ_GT(sack.end, tp->snd_max))
continue;
if (tp->snd_holes == NULL) { 
tp->snd_holes = (struct sackhole *)
pool_get(&sackhl_pool, PR_NOWAIT);
if (tp->snd_holes == NULL) {
goto done;
}
cur = tp->snd_holes;
cur->start = th->th_ack;
cur->end = sack.start;
cur->rxmit = cur->start;
cur->next = NULL;
tp->snd_numholes = 1;
tp->rcv_lastsack = sack.end;
cur->dups = min(tcprexmtthresh,
((sack.end - cur->end)/tp->t_maxseg));
if (cur->dups < 1)
cur->dups = 1;
continue; 
}
p = cur = tp->snd_holes;
while (cur) {
if (SEQ_LEQ(sack.end, cur->start))
break; 
if (SEQ_GEQ(sack.start, cur->end)) {
cur->dups++;
if (((sack.end - cur->end)/tp->t_maxseg) >=
tcprexmtthresh)
cur->dups = tcprexmtthresh;
p = cur;
cur = cur->next;
continue;
}
if (SEQ_LEQ(sack.start, cur->start)) {
if (SEQ_GEQ(sack.end, cur->end)) {
if (p != cur) {
p->next = cur->next;
pool_put(&sackhl_pool, cur);
cur = p->next;
} else {
cur = cur->next;
pool_put(&sackhl_pool, p);
p = cur;
tp->snd_holes = p;
}
tp->snd_numholes--;
continue;
}
cur->start = sack.end;
cur->rxmit = SEQ_MAX(cur->rxmit, cur->start);
p = cur;
cur = cur->next;
continue;
}
if (SEQ_GEQ(sack.end, cur->end)) {
cur->end = sack.start;
cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);
cur->dups++;
if (((sack.end - cur->end)/tp->t_maxseg) >=
tcprexmtthresh)
cur->dups = tcprexmtthresh;
p = cur;
cur = cur->next;
continue;
}
if (SEQ_LT(cur->start, sack.start) &&
SEQ_GT(cur->end, sack.end)) {
temp = (struct sackhole *)
pool_get(&sackhl_pool, PR_NOWAIT);
if (temp == NULL)
goto done; 
temp->next = cur->next;
temp->start = sack.end;
temp->end = cur->end;
temp->dups = cur->dups;
temp->rxmit = SEQ_MAX(cur->rxmit, temp->start);
cur->end = sack.start;
cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);
cur->dups++;
if (((sack.end - cur->end)/tp->t_maxseg) >=
tcprexmtthresh)
cur->dups = tcprexmtthresh;
cur->next = temp;
p = temp;
cur = p->next;
tp->snd_numholes++;
}
}
if (SEQ_LT(tp->rcv_lastsack, sack.start)) {
temp = (struct sackhole *)
pool_get(&sackhl_pool, PR_NOWAIT);
if (temp == NULL)
goto done; 
temp->start = tp->rcv_lastsack;
temp->end = sack.start;
temp->dups = min(tcprexmtthresh,
((sack.end - sack.start)/tp->t_maxseg));
if (temp->dups < 1)
temp->dups = 1;
temp->rxmit = temp->start;
temp->next = 0;
p->next = temp;
tp->rcv_lastsack = sack.end;
tp->snd_numholes++;
}
}
done:
return;
}","void
tcp_sack_option(struct tcpcb *VAR_0, struct tcphdr *VAR_1, u_char *VAR_2, int VAR_3)
{
int VAR_4;
u_char *VAR_5;
struct sackhole *VAR_6, *VAR_7, *VAR_8;
if (!VAR_0->sack_enable)
return;
if ((VAR_1->th_flags & VAR_9) == 0)
return;
if (SEQ_LT(VAR_1->th_ack, VAR_0->snd_una) ||
SEQ_GT(VAR_1->th_ack, VAR_0->snd_max))
return;
if (VAR_3 <= 2 || (VAR_3 - 2) % VAR_10 != 0)
return;
VAR_5 = VAR_2 + 2;
VAR_4 = VAR_3 - 2;
tcpstat_inc(VAR_11);
if (VAR_0->snd_numholes < 0)
VAR_0->snd_numholes = 0;
if (VAR_0->t_maxseg == 0)
panic(""tcp_sack_option""); 
while (VAR_4 > 0) {
struct sackblk VAR_12;
memcpy(&VAR_12.start, VAR_5, sizeof(VAR_13));
VAR_12.start = ntohl(VAR_12.start);
memcpy(&VAR_12.end, VAR_5 + sizeof(VAR_13), sizeof(VAR_13));
VAR_12.end = ntohl(VAR_12.end);
VAR_4 -= VAR_10;
VAR_5 += VAR_10;
if (SEQ_LEQ(VAR_12.end, VAR_12.start))
continue; 
if (SEQ_LEQ(VAR_12.end, VAR_0->snd_una))
continue; 
if (SEQ_GT(VAR_1->th_ack, VAR_0->snd_una)) {
if (SEQ_LT(VAR_12.start, VAR_1->th_ack))
continue;
}
if (SEQ_GT(VAR_12.end, VAR_0->snd_max))
continue;
if (VAR_0->snd_holes == NULL) { 
VAR_0->snd_holes = (struct sackhole *)
pool_get(&VAR_14, VAR_15);
if (VAR_0->snd_holes == NULL) {
goto done;
}
VAR_6 = VAR_0->snd_holes;
VAR_6->start = VAR_1->th_ack;
VAR_6->end = VAR_12.start;
VAR_6->rxmit = VAR_6->start;
VAR_6->next = NULL;
VAR_0->snd_numholes = 1;
VAR_0->rcv_lastsack = VAR_12.end;
VAR_6->dups = min(VAR_16,
((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg));
if (VAR_6->dups < 1)
VAR_6->dups = 1;
continue; 
}
VAR_7 = VAR_6 = VAR_0->snd_holes;
while (VAR_6) {
if (SEQ_LEQ(VAR_12.end, VAR_6->start))
break; 
if (SEQ_GEQ(VAR_12.start, VAR_6->end)) {
VAR_6->dups++;
if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
VAR_16)
VAR_6->dups = VAR_16;
VAR_7 = VAR_6;
VAR_6 = VAR_6->next;
continue;
}
if (SEQ_LEQ(VAR_12.start, VAR_6->start)) {
if (SEQ_GEQ(VAR_12.end, VAR_6->end)) {
if (VAR_7 != VAR_6) {
VAR_7->next = VAR_6->next;
pool_put(&VAR_14, VAR_6);
VAR_6 = VAR_7->next;
} else {
VAR_6 = VAR_6->next;
pool_put(&VAR_14, VAR_7);
VAR_7 = VAR_6;
VAR_0->snd_holes = VAR_7;
}
VAR_0->snd_numholes--;
continue;
}
VAR_6->start = VAR_12.end;
VAR_6->rxmit = SEQ_MAX(VAR_6->rxmit, VAR_6->start);
VAR_7 = VAR_6;
VAR_6 = VAR_6->next;
continue;
}
if (SEQ_GEQ(VAR_12.end, VAR_6->end)) {
VAR_6->end = VAR_12.start;
VAR_6->rxmit = SEQ_MIN(VAR_6->rxmit, VAR_6->end);
VAR_6->dups++;
if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
VAR_16)
VAR_6->dups = VAR_16;
VAR_7 = VAR_6;
VAR_6 = VAR_6->next;
continue;
}
if (SEQ_LT(VAR_6->start, VAR_12.start) &&
SEQ_GT(VAR_6->end, VAR_12.end)) {
VAR_8 = (struct sackhole *)
pool_get(&VAR_14, VAR_15);
if (VAR_8 == NULL)
goto done; 
VAR_8->next = VAR_6->next;
VAR_8->start = VAR_12.end;
VAR_8->end = VAR_6->end;
VAR_8->dups = VAR_6->dups;
VAR_8->rxmit = SEQ_MAX(VAR_6->rxmit, VAR_8->start);
VAR_6->end = VAR_12.start;
VAR_6->rxmit = SEQ_MIN(VAR_6->rxmit, VAR_6->end);
VAR_6->dups++;
if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
VAR_16)
VAR_6->dups = VAR_16;
VAR_6->next = VAR_8;
VAR_7 = VAR_8;
VAR_6 = VAR_7->next;
VAR_0->snd_numholes++;
}
}
if (SEQ_LT(VAR_0->rcv_lastsack, VAR_12.start)) {
VAR_8 = (struct sackhole *)
pool_get(&VAR_14, VAR_15);
if (VAR_8 == NULL)
goto done; 
VAR_8->start = VAR_0->rcv_lastsack;
VAR_8->end = VAR_12.start;
VAR_8->dups = min(VAR_16,
((VAR_12.end - VAR_12.start)/VAR_0->t_maxseg));
if (VAR_8->dups < 1)
VAR_8->dups = 1;
VAR_8->rxmit = VAR_8->start;
VAR_8->next = 0;
VAR_7->next = VAR_8;
VAR_0->rcv_lastsack = VAR_12.end;
VAR_0->snd_numholes++;
}
}
done:
return;
}",openbsd/src/ed8fdce754a5d8d14c09e989d8877707bd43906f/tcp_input.c/vul/before/0.json,"void
tcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)
{
	int tmp_olen;
	u_char *tmp_cp;
	struct sackhole *cur, *p, *temp;

	if (!tp->sack_enable)
		return;
	/* SACK without ACK doesn't make sense. */
	if ((th->th_flags & TH_ACK) == 0)
	       return;
	/* Make sure the ACK on this segment is in [snd_una, snd_max]. */
	if (SEQ_LT(th->th_ack, tp->snd_una) ||
	    SEQ_GT(th->th_ack, tp->snd_max))
		return;
	/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */
	if (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)
		return;
	/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */
	tmp_cp = cp + 2;
	tmp_olen = optlen - 2;
	tcpstat_inc(tcps_sack_rcv_opts);
	if (tp->snd_numholes < 0)
		tp->snd_numholes = 0;
	if (tp->t_maxseg == 0)
		panic(""tcp_sack_option""); /* Should never happen */
	while (tmp_olen > 0) {
		struct sackblk sack;

		memcpy(&sack.start, tmp_cp, sizeof(tcp_seq));
		sack.start = ntohl(sack.start);
		memcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));
		sack.end = ntohl(sack.end);
		tmp_olen -= TCPOLEN_SACK;
		tmp_cp += TCPOLEN_SACK;
		if (SEQ_LEQ(sack.end, sack.start))
			continue; /* bad SACK fields */
		if (SEQ_LEQ(sack.end, tp->snd_una))
			continue; /* old block */
		if (SEQ_GT(th->th_ack, tp->snd_una)) {
			if (SEQ_LT(sack.start, th->th_ack))
				continue;
		}
		if (SEQ_GT(sack.end, tp->snd_max))
			continue;
		if (tp->snd_holes == NULL) { /* first hole */
			tp->snd_holes = (struct sackhole *)
			    pool_get(&sackhl_pool, PR_NOWAIT);
			if (tp->snd_holes == NULL) {
				/* ENOBUFS, so ignore SACKed block for now*/
				goto done;
			}
			cur = tp->snd_holes;
			cur->start = th->th_ack;
			cur->end = sack.start;
			cur->rxmit = cur->start;
			cur->next = NULL;
			tp->snd_numholes = 1;
			tp->rcv_lastsack = sack.end;
			/*
			 * dups is at least one.  If more data has been
			 * SACKed, it can be greater than one.
			 */
			cur->dups = min(tcprexmtthresh,
			    ((sack.end - cur->end)/tp->t_maxseg));
			if (cur->dups < 1)
				cur->dups = 1;
			continue; /* with next sack block */
		}
		/* Go thru list of holes:  p = previous,  cur = current */
		p = cur = tp->snd_holes;
		while (cur) {
			if (SEQ_LEQ(sack.end, cur->start))
				/* SACKs data before the current hole */
				break; /* no use going through more holes */
			if (SEQ_GEQ(sack.start, cur->end)) {
				/* SACKs data beyond the current hole */
				cur->dups++;
				if (((sack.end - cur->end)/tp->t_maxseg) >=
				    tcprexmtthresh)
					cur->dups = tcprexmtthresh;
				p = cur;
				cur = cur->next;
				continue;
			}
			if (SEQ_LEQ(sack.start, cur->start)) {
				/* Data acks at least the beginning of hole */
				if (SEQ_GEQ(sack.end, cur->end)) {
					/* Acks entire hole, so delete hole */
					if (p != cur) {
						p->next = cur->next;
						pool_put(&sackhl_pool, cur);
						cur = p->next;
					} else {
						cur = cur->next;
						pool_put(&sackhl_pool, p);
						p = cur;
						tp->snd_holes = p;
					}
					tp->snd_numholes--;
					continue;
				}
				/* otherwise, move start of hole forward */
				cur->start = sack.end;
				cur->rxmit = SEQ_MAX(cur->rxmit, cur->start);
				p = cur;
				cur = cur->next;
				continue;
			}
			/* move end of hole backward */
			if (SEQ_GEQ(sack.end, cur->end)) {
				cur->end = sack.start;
				cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);
				cur->dups++;
				if (((sack.end - cur->end)/tp->t_maxseg) >=
				    tcprexmtthresh)
					cur->dups = tcprexmtthresh;
				p = cur;
				cur = cur->next;
				continue;
			}
			if (SEQ_LT(cur->start, sack.start) &&
			    SEQ_GT(cur->end, sack.end)) {
				/*
				 * ACKs some data in middle of a hole; need to
				 * split current hole
				 */
				if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)
					goto done;
				temp = (struct sackhole *)
				    pool_get(&sackhl_pool, PR_NOWAIT);
				if (temp == NULL)
					goto done; /* ENOBUFS */
				temp->next = cur->next;
				temp->start = sack.end;
				temp->end = cur->end;
				temp->dups = cur->dups;
				temp->rxmit = SEQ_MAX(cur->rxmit, temp->start);
				cur->end = sack.start;
				cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);
				cur->dups++;
				if (((sack.end - cur->end)/tp->t_maxseg) >=
					tcprexmtthresh)
					cur->dups = tcprexmtthresh;
				cur->next = temp;
				p = temp;
				cur = p->next;
				tp->snd_numholes++;
			}
		}
		/* At this point, p points to the last hole on the list */
		if (SEQ_LT(tp->rcv_lastsack, sack.start)) {
			/*
			 * Need to append new hole at end.
			 * Last hole is p (and it's not NULL).
			 */
			if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)
				goto done;
			temp = (struct sackhole *)
			    pool_get(&sackhl_pool, PR_NOWAIT);
			if (temp == NULL)
				goto done; /* ENOBUFS */
			temp->start = tp->rcv_lastsack;
			temp->end = sack.start;
			temp->dups = min(tcprexmtthresh,
			    ((sack.end - sack.start)/tp->t_maxseg));
			if (temp->dups < 1)
				temp->dups = 1;
			temp->rxmit = temp->start;
			temp->next = 0;
			p->next = temp;
			tp->rcv_lastsack = sack.end;
			tp->snd_numholes++;
		}
	}
done:
	return;
}","void
tcp_sack_option(struct tcpcb *VAR_0, struct tcphdr *VAR_1, u_char *VAR_2, int VAR_3)
{
	int VAR_4;
	u_char *VAR_5;
	struct sackhole *VAR_6, *VAR_7, *VAR_8;

	if (!VAR_0->sack_enable)
		return;
	/* COMMENT_0 */
	if ((VAR_1->th_flags & VAR_9) == 0)
	       return;
	/* COMMENT_1 */
	if (SEQ_LT(VAR_1->th_ack, VAR_0->snd_una) ||
	    SEQ_GT(VAR_1->th_ack, VAR_0->snd_max))
		return;
	/* COMMENT_2 */
	if (VAR_3 <= 2 || (VAR_3 - 2) % VAR_10 != 0)
		return;
	/* COMMENT_2 */
	VAR_5 = VAR_2 + 2;
	VAR_4 = VAR_3 - 2;
	tcpstat_inc(VAR_11);
	if (VAR_0->snd_numholes < 0)
		VAR_0->snd_numholes = 0;
	if (VAR_0->t_maxseg == 0)
		panic(""tcp_sack_option""); /* COMMENT_3 */
	while (VAR_4 > 0) {
		struct sackblk VAR_12;

		memcpy(&VAR_12.start, VAR_5, sizeof(VAR_13));
		VAR_12.start = ntohl(VAR_12.start);
		memcpy(&VAR_12.end, VAR_5 + sizeof(VAR_13), sizeof(VAR_13));
		VAR_12.end = ntohl(VAR_12.end);
		VAR_4 -= VAR_10;
		VAR_5 += VAR_10;
		if (SEQ_LEQ(VAR_12.end, VAR_12.start))
			continue; /* COMMENT_4 */
		if (SEQ_LEQ(VAR_12.end, VAR_0->snd_una))
			continue; /* COMMENT_5 */
		if (SEQ_GT(VAR_1->th_ack, VAR_0->snd_una)) {
			if (SEQ_LT(VAR_12.start, VAR_1->th_ack))
				continue;
		}
		if (SEQ_GT(VAR_12.end, VAR_0->snd_max))
			continue;
		if (VAR_0->snd_holes == NULL) { /* COMMENT_6 */
			VAR_0->snd_holes = (struct sackhole *)
			    pool_get(&VAR_14, VAR_15);
			if (VAR_0->snd_holes == NULL) {
				/* COMMENT_7 */
				goto done;
			}
			VAR_6 = VAR_0->snd_holes;
			VAR_6->start = VAR_1->th_ack;
			VAR_6->end = VAR_12.start;
			VAR_6->rxmit = VAR_6->start;
			VAR_6->next = NULL;
			VAR_0->snd_numholes = 1;
			VAR_0->rcv_lastsack = VAR_12.end;
			/* COMMENT_8 */
                                                  
                                         
      
			VAR_6->dups = min(VAR_16,
			    ((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg));
			if (VAR_6->dups < 1)
				VAR_6->dups = 1;
			continue; /* COMMENT_12 */
		}
		/* COMMENT_13 */
		VAR_7 = VAR_6 = VAR_0->snd_holes;
		while (VAR_6) {
			if (SEQ_LEQ(VAR_12.end, VAR_6->start))
				/* COMMENT_14 */
				break; /* COMMENT_15 */
			if (SEQ_GEQ(VAR_12.start, VAR_6->end)) {
				/* COMMENT_16 */
				VAR_6->dups++;
				if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
				    VAR_16)
					VAR_6->dups = VAR_16;
				VAR_7 = VAR_6;
				VAR_6 = VAR_6->next;
				continue;
			}
			if (SEQ_LEQ(VAR_12.start, VAR_6->start)) {
				/* COMMENT_17 */
				if (SEQ_GEQ(VAR_12.end, VAR_6->end)) {
					/* COMMENT_18 */
					if (VAR_7 != VAR_6) {
						VAR_7->next = VAR_6->next;
						pool_put(&VAR_14, VAR_6);
						VAR_6 = VAR_7->next;
					} else {
						VAR_6 = VAR_6->next;
						pool_put(&VAR_14, VAR_7);
						VAR_7 = VAR_6;
						VAR_0->snd_holes = VAR_7;
					}
					VAR_0->snd_numholes--;
					continue;
				}
				/* COMMENT_19 */
				VAR_6->start = VAR_12.end;
				VAR_6->rxmit = SEQ_MAX(VAR_6->rxmit, VAR_6->start);
				VAR_7 = VAR_6;
				VAR_6 = VAR_6->next;
				continue;
			}
			/* COMMENT_20 */
			if (SEQ_GEQ(VAR_12.end, VAR_6->end)) {
				VAR_6->end = VAR_12.start;
				VAR_6->rxmit = SEQ_MIN(VAR_6->rxmit, VAR_6->end);
				VAR_6->dups++;
				if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
				    VAR_16)
					VAR_6->dups = VAR_16;
				VAR_7 = VAR_6;
				VAR_6 = VAR_6->next;
				continue;
			}
			if (SEQ_LT(VAR_6->start, VAR_12.start) &&
			    SEQ_GT(VAR_6->end, VAR_12.end)) {
				/* COMMENT_21 */
                                                  
                         
       
				if (VAR_0->snd_numholes >= VAR_17)
					goto done;
				VAR_8 = (struct sackhole *)
				    pool_get(&VAR_14, VAR_15);
				if (VAR_8 == NULL)
					goto done; /* COMMENT_25 */
				VAR_8->next = VAR_6->next;
				VAR_8->start = VAR_12.end;
				VAR_8->end = VAR_6->end;
				VAR_8->dups = VAR_6->dups;
				VAR_8->rxmit = SEQ_MAX(VAR_6->rxmit, VAR_8->start);
				VAR_6->end = VAR_12.start;
				VAR_6->rxmit = SEQ_MIN(VAR_6->rxmit, VAR_6->end);
				VAR_6->dups++;
				if (((VAR_12.end - VAR_6->end)/VAR_0->t_maxseg) >=
					VAR_16)
					VAR_6->dups = VAR_16;
				VAR_6->next = VAR_8;
				VAR_7 = VAR_8;
				VAR_6 = VAR_7->next;
				VAR_0->snd_numholes++;
			}
		}
		/* COMMENT_26 */
		if (SEQ_LT(VAR_0->rcv_lastsack, VAR_12.start)) {
			/* COMMENT_27 */
                                     
                                         
      
			if (VAR_0->snd_numholes >= VAR_17)
				goto done;
			VAR_8 = (struct sackhole *)
			    pool_get(&VAR_14, VAR_15);
			if (VAR_8 == NULL)
				goto done; /* COMMENT_25 */
			VAR_8->start = VAR_0->rcv_lastsack;
			VAR_8->end = VAR_12.start;
			VAR_8->dups = min(VAR_16,
			    ((VAR_12.end - VAR_12.start)/VAR_0->t_maxseg));
			if (VAR_8->dups < 1)
				VAR_8->dups = 1;
			VAR_8->rxmit = VAR_8->start;
			VAR_8->next = 0;
			VAR_7->next = VAR_8;
			VAR_0->rcv_lastsack = VAR_12.end;
			VAR_0->snd_numholes++;
		}
	}
done:
	return;
}",openbsd/src/ed8fdce754a5d8d14c09e989d8877707bd43906f/tcp_input.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -126,6 +126,8 @@
 				 * ACKs some data in middle of a hole; need to
 				 * split current hole
 				 */
+				if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)
+					goto done;
 				temp = (struct sackhole *)
 				    pool_get(&sackhl_pool, PR_NOWAIT);
 				if (temp == NULL)
@@ -153,6 +155,8 @@
 			 * Need to append new hole at end.
 			 * Last hole is p (and it's not NULL).
 			 */
+			if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)
+				goto done;
 			temp = (struct sackhole *)
 			    pool_get(&sackhl_pool, PR_NOWAIT);
 			if (temp == NULL)","{'deleted_lines': [], 'added_lines': ['\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)', '\t\t\t\t\tgoto done;', '\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)', '\t\t\t\tgoto done;']}",True,OpenBSD kernel version <= 6.5 can be forced to create long chains of TCP SACK holes that causes very expensive calls to tcp_sack_option() for every incoming SACK packet which can lead to a denial of service.,7.5,HIGH,2,valid,2019-07-10T18:45:31Z,2
CVE-2019-1010238,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,GNOME/pango,"bidi: Be safer against bad input

Don't run off the end of an array that we
allocated to certain length.

Closes: https://gitlab.gnome.org/GNOME/pango/issues/342",490f8979a260c16b1df055eab386345da18a2d54,https://github.com/GNOME/pango/commit/490f8979a260c16b1df055eab386345da18a2d54,pango/pango-bidi-type.c,pango_log2vis_get_embedding_levels,"guint8 *
pango_log2vis_get_embedding_levels (const gchar    *text,
int             length,
PangoDirection *pbase_dir)
{
glong n_chars, i;
guint8 *embedding_levels_list;
const gchar *p;
FriBidiParType fribidi_base_dir;
FriBidiCharType *bidi_types;
#ifdef USE_FRIBIDI_EX_API
FriBidiBracketType *bracket_types;
#endif
FriBidiLevel max_level;
FriBidiCharType ored_types = 0;
FriBidiCharType anded_strongs = FRIBIDI_TYPE_RLE;
G_STATIC_ASSERT (sizeof (FriBidiLevel) == sizeof (guint8));
G_STATIC_ASSERT (sizeof (FriBidiChar) == sizeof (gunichar));
switch (*pbase_dir)
{
case PANGO_DIRECTION_LTR:
case PANGO_DIRECTION_TTB_RTL:
fribidi_base_dir = FRIBIDI_PAR_LTR;
break;
case PANGO_DIRECTION_RTL:
case PANGO_DIRECTION_TTB_LTR:
fribidi_base_dir = FRIBIDI_PAR_RTL;
break;
case PANGO_DIRECTION_WEAK_RTL:
fribidi_base_dir = FRIBIDI_PAR_WRTL;
break;
case PANGO_DIRECTION_WEAK_LTR:
case PANGO_DIRECTION_NEUTRAL:
default:
fribidi_base_dir = FRIBIDI_PAR_WLTR;
break;
}
if (length < 0)
length = strlen (text);
n_chars = g_utf8_strlen (text, length);
bidi_types = g_new (FriBidiCharType, n_chars);
#ifdef USE_FRIBIDI_EX_API
bracket_types = g_new (FriBidiBracketType, n_chars);
#endif
embedding_levels_list = g_new (guint8, n_chars);
for (i = 0, p = text; p < text + length; p = g_utf8_next_char(p), i++)
{
gunichar ch = g_utf8_get_char (p);
FriBidiCharType char_type;
char_type = fribidi_get_bidi_type (ch);
bidi_types[i] = char_type;
ored_types |= char_type;
if (FRIBIDI_IS_STRONG (char_type))
anded_strongs &= char_type;
#ifdef USE_FRIBIDI_EX_API
if (G_UNLIKELY(bidi_types[i] == FRIBIDI_TYPE_ON))
bracket_types[i] = fribidi_get_bracket (ch);
else
bracket_types[i] = FRIBIDI_NO_BRACKET;
#endif
}
#ifndef FRIBIDI_IS_ISOLATE
#define FRIBIDI_IS_ISOLATE(x) 0
#endif
if (!FRIBIDI_IS_ISOLATE (ored_types) &&
!FRIBIDI_IS_RTL (ored_types) &&
!FRIBIDI_IS_ARABIC (ored_types) &&
(!FRIBIDI_IS_RTL (fribidi_base_dir) ||
(FRIBIDI_IS_WEAK (fribidi_base_dir) &&
FRIBIDI_IS_LETTER (ored_types))
))
{
fribidi_base_dir = FRIBIDI_PAR_LTR;
memset (embedding_levels_list, 0, n_chars);
goto resolved;
}
else if (!FRIBIDI_IS_ISOLATE (ored_types) &&
!FRIBIDI_IS_NUMBER (ored_types) &&
FRIBIDI_IS_RTL (anded_strongs) &&
(FRIBIDI_IS_RTL (fribidi_base_dir) ||
(FRIBIDI_IS_WEAK (fribidi_base_dir) &&
FRIBIDI_IS_LETTER (ored_types))
))
{
fribidi_base_dir = FRIBIDI_PAR_RTL;
memset (embedding_levels_list, 1, n_chars);
goto resolved;
}
#ifdef USE_FRIBIDI_EX_API
max_level = fribidi_get_par_embedding_levels_ex (bidi_types, bracket_types, n_chars,
&fribidi_base_dir,
(FriBidiLevel*)embedding_levels_list);
#else
max_level = fribidi_get_par_embedding_levels (bidi_types, n_chars,
&fribidi_base_dir,
(FriBidiLevel*)embedding_levels_list);
#endif
if (G_UNLIKELY(max_level == 0))
{
memset (embedding_levels_list, 0, length);
}
resolved:
g_free (bidi_types);
#ifdef USE_FRIBIDI_EX_API
g_free (bracket_types);
#endif
*pbase_dir = (fribidi_base_dir == FRIBIDI_PAR_LTR) ?  PANGO_DIRECTION_LTR : PANGO_DIRECTION_RTL;
return embedding_levels_list;
}","guint8 *
pango_log2vis_get_embedding_levels (const gchar    *VAR_0,
int             VAR_1,
PangoDirection *VAR_2)
{
glong VAR_3, VAR_4;
guint8 *VAR_5;
const gchar *VAR_6;
FriBidiParType VAR_7;
FriBidiCharType *VAR_8;
#ifdef VAR_9
FriBidiBracketType *VAR_10;
#endif
FriBidiLevel VAR_11;
FriBidiCharType VAR_12 = 0;
FriBidiCharType VAR_13 = VAR_14;
G_STATIC_ASSERT (sizeof (FriBidiLevel) == sizeof (guint8));
G_STATIC_ASSERT (sizeof (VAR_15) == sizeof (VAR_16));
switch (*VAR_2)
{
case VAR_17:
case VAR_18:
VAR_7 = VAR_19;
break;
case VAR_20:
case VAR_21:
VAR_7 = VAR_22;
break;
case VAR_23:
VAR_7 = VAR_24;
break;
case VAR_25:
case VAR_26:
default:
VAR_7 = VAR_27;
break;
}
if (VAR_1 < 0)
VAR_1 = strlen (VAR_0);
VAR_3 = g_utf8_strlen (VAR_0, VAR_1);
VAR_8 = g_new (FriBidiCharType, VAR_3);
#ifdef VAR_9
VAR_10 = g_new (FriBidiBracketType, VAR_3);
#endif
VAR_5 = g_new (guint8, VAR_3);
for (VAR_4 = 0, VAR_6 = VAR_0; VAR_6 < VAR_0 + VAR_1; VAR_6 = g_utf8_next_char(VAR_6), VAR_4++)
{
gunichar VAR_28 = g_utf8_get_char (VAR_6);
FriBidiCharType VAR_29;
VAR_29 = fribidi_get_bidi_type (VAR_28);
VAR_8[VAR_4] = VAR_29;
VAR_12 |= VAR_29;
if (FRIBIDI_IS_STRONG (VAR_29))
VAR_13 &= VAR_29;
#ifdef VAR_9
if (G_UNLIKELY(VAR_8[VAR_4] == VAR_30))
VAR_10[VAR_4] = fribidi_get_bracket (VAR_28);
else
VAR_10[VAR_4] = VAR_31;
#endif
}
#ifndef VAR_32
#define VAR_32(VAR_33) 0
#endif
if (!VAR_32 (VAR_12) &&
!FRIBIDI_IS_RTL (VAR_12) &&
!FRIBIDI_IS_ARABIC (VAR_12) &&
(!FRIBIDI_IS_RTL (VAR_7) ||
(FRIBIDI_IS_WEAK (VAR_7) &&
FRIBIDI_IS_LETTER (VAR_12))
))
{
VAR_7 = VAR_19;
memset (VAR_5, 0, VAR_3);
goto resolved;
}
else if (!VAR_32 (VAR_12) &&
!FRIBIDI_IS_NUMBER (VAR_12) &&
FRIBIDI_IS_RTL (VAR_13) &&
(FRIBIDI_IS_RTL (VAR_7) ||
(FRIBIDI_IS_WEAK (VAR_7) &&
FRIBIDI_IS_LETTER (VAR_12))
))
{
VAR_7 = VAR_22;
memset (VAR_5, 1, VAR_3);
goto resolved;
}
#ifdef VAR_9
VAR_11 = fribidi_get_par_embedding_levels_ex (VAR_8, VAR_10, VAR_3,
&VAR_7,
(FriBidiLevel*)VAR_5);
#else
VAR_11 = fribidi_get_par_embedding_levels (VAR_8, VAR_3,
&VAR_7,
(FriBidiLevel*)VAR_5);
#endif
if (G_UNLIKELY(VAR_11 == 0))
{
memset (VAR_5, 0, VAR_1);
}
resolved:
g_free (VAR_8);
#ifdef VAR_9
g_free (VAR_10);
#endif
*VAR_2 = (VAR_7 == VAR_19) ?  VAR_17 : VAR_20;
return VAR_5;
}",GNOME/pango/490f8979a260c16b1df055eab386345da18a2d54/pango-bidi-type.c/vul/before/0.json,"guint8 *
pango_log2vis_get_embedding_levels (const gchar    *text,
				    int             length,
				    PangoDirection *pbase_dir)
{
  glong n_chars, i;
  guint8 *embedding_levels_list;
  const gchar *p;
  FriBidiParType fribidi_base_dir;
  FriBidiCharType *bidi_types;
#ifdef USE_FRIBIDI_EX_API
  FriBidiBracketType *bracket_types;
#endif
  FriBidiLevel max_level;
  FriBidiCharType ored_types = 0;
  FriBidiCharType anded_strongs = FRIBIDI_TYPE_RLE;

  G_STATIC_ASSERT (sizeof (FriBidiLevel) == sizeof (guint8));
  G_STATIC_ASSERT (sizeof (FriBidiChar) == sizeof (gunichar));

  switch (*pbase_dir)
    {
    case PANGO_DIRECTION_LTR:
    case PANGO_DIRECTION_TTB_RTL:
      fribidi_base_dir = FRIBIDI_PAR_LTR;
      break;
    case PANGO_DIRECTION_RTL:
    case PANGO_DIRECTION_TTB_LTR:
      fribidi_base_dir = FRIBIDI_PAR_RTL;
      break;
    case PANGO_DIRECTION_WEAK_RTL:
      fribidi_base_dir = FRIBIDI_PAR_WRTL;
      break;
    case PANGO_DIRECTION_WEAK_LTR:
    case PANGO_DIRECTION_NEUTRAL:
    default:
      fribidi_base_dir = FRIBIDI_PAR_WLTR;
      break;
    }

  if (length < 0)
    length = strlen (text);

  n_chars = g_utf8_strlen (text, length);

  bidi_types = g_new (FriBidiCharType, n_chars);
#ifdef USE_FRIBIDI_EX_API
  bracket_types = g_new (FriBidiBracketType, n_chars);
#endif
  embedding_levels_list = g_new (guint8, n_chars);

  for (i = 0, p = text; p < text + length; p = g_utf8_next_char(p), i++)
    {
      gunichar ch = g_utf8_get_char (p);
      FriBidiCharType char_type = fribidi_get_bidi_type (ch);

      if (i == n_chars)
        break;

      bidi_types[i] = char_type;
      ored_types |= char_type;
      if (FRIBIDI_IS_STRONG (char_type))
        anded_strongs &= char_type;
#ifdef USE_FRIBIDI_EX_API
      if (G_UNLIKELY(bidi_types[i] == FRIBIDI_TYPE_ON))
        bracket_types[i] = fribidi_get_bracket (ch);
      else
        bracket_types[i] = FRIBIDI_NO_BRACKET;
#endif
    }

    /* Short-circuit (malloc-expensive) FriBidi call for unidirectional
     * text.
     *
     * For details see:
     * https://bugzilla.gnome.org/show_bug.cgi?id=590183
     */

#ifndef FRIBIDI_IS_ISOLATE
#define FRIBIDI_IS_ISOLATE(x) 0
#endif
    /* The case that all resolved levels will be ltr.
     * No isolates, all strongs be LTR, there should be no Arabic numbers
     * (or letters for that matter), and one of the following:
     *
     * o base_dir doesn't have an RTL taste.
     * o there are letters, and base_dir is weak.
     */
    if (!FRIBIDI_IS_ISOLATE (ored_types) &&
	!FRIBIDI_IS_RTL (ored_types) &&
	!FRIBIDI_IS_ARABIC (ored_types) &&
	(!FRIBIDI_IS_RTL (fribidi_base_dir) ||
	  (FRIBIDI_IS_WEAK (fribidi_base_dir) &&
	   FRIBIDI_IS_LETTER (ored_types))
	))
      {
        /* all LTR */
	fribidi_base_dir = FRIBIDI_PAR_LTR;
	memset (embedding_levels_list, 0, n_chars);
	goto resolved;
      }
    /* The case that all resolved levels will be RTL is much more complex.
     * No isolates, no numbers, all strongs are RTL, and one of
     * the following:
     *
     * o base_dir has an RTL taste (may be weak).
     * o there are letters, and base_dir is weak.
     */
    else if (!FRIBIDI_IS_ISOLATE (ored_types) &&
	     !FRIBIDI_IS_NUMBER (ored_types) &&
	     FRIBIDI_IS_RTL (anded_strongs) &&
	     (FRIBIDI_IS_RTL (fribidi_base_dir) ||
	       (FRIBIDI_IS_WEAK (fribidi_base_dir) &&
		FRIBIDI_IS_LETTER (ored_types))
	     ))
      {
        /* all RTL */
	fribidi_base_dir = FRIBIDI_PAR_RTL;
	memset (embedding_levels_list, 1, n_chars);
	goto resolved;
      }


#ifdef USE_FRIBIDI_EX_API
  max_level = fribidi_get_par_embedding_levels_ex (bidi_types, bracket_types, n_chars,
						   &fribidi_base_dir,
						   (FriBidiLevel*)embedding_levels_list);
#else
  max_level = fribidi_get_par_embedding_levels (bidi_types, n_chars,
						&fribidi_base_dir,
						(FriBidiLevel*)embedding_levels_list);
#endif

  if (G_UNLIKELY(max_level == 0))
    {
      /* fribidi_get_par_embedding_levels() failed. */
      memset (embedding_levels_list, 0, length);
    }

resolved:
  g_free (bidi_types);

#ifdef USE_FRIBIDI_EX_API
  g_free (bracket_types);
#endif

  *pbase_dir = (fribidi_base_dir == FRIBIDI_PAR_LTR) ?  PANGO_DIRECTION_LTR : PANGO_DIRECTION_RTL;

  return embedding_levels_list;
}","guint8 *
pango_log2vis_get_embedding_levels (const gchar    *VAR_0,
				    int             VAR_1,
				    PangoDirection *VAR_2)
{
  glong VAR_3, VAR_4;
  guint8 *VAR_5;
  const gchar *VAR_6;
  FriBidiParType VAR_7;
  FriBidiCharType *VAR_8;
#ifdef VAR_9
  FriBidiBracketType *VAR_10;
#endif
  FriBidiLevel VAR_11;
  FriBidiCharType VAR_12 = 0;
  FriBidiCharType VAR_13 = VAR_14;

  G_STATIC_ASSERT (sizeof (FriBidiLevel) == sizeof (guint8));
  G_STATIC_ASSERT (sizeof (VAR_15) == sizeof (VAR_16));

  switch (*VAR_2)
    {
    case VAR_17:
    case VAR_18:
      VAR_7 = VAR_19;
      break;
    case VAR_20:
    case VAR_21:
      VAR_7 = VAR_22;
      break;
    case VAR_23:
      VAR_7 = VAR_24;
      break;
    case VAR_25:
    case VAR_26:
    default:
      VAR_7 = VAR_27;
      break;
    }

  if (VAR_1 < 0)
    VAR_1 = strlen (VAR_0);

  VAR_3 = g_utf8_strlen (VAR_0, VAR_1);

  VAR_8 = g_new (FriBidiCharType, VAR_3);
#ifdef VAR_9
  VAR_10 = g_new (FriBidiBracketType, VAR_3);
#endif
  VAR_5 = g_new (guint8, VAR_3);

  for (VAR_4 = 0, VAR_6 = VAR_0; VAR_6 < VAR_0 + VAR_1; VAR_6 = g_utf8_next_char(VAR_6), VAR_4++)
    {
      gunichar VAR_28 = g_utf8_get_char (VAR_6);
      FriBidiCharType VAR_29 = fribidi_get_bidi_type (VAR_28);

      if (VAR_4 == VAR_3)
        break;

      VAR_8[VAR_4] = VAR_29;
      VAR_12 |= VAR_29;
      if (FRIBIDI_IS_STRONG (VAR_29))
        VAR_13 &= VAR_29;
#ifdef VAR_9
      if (G_UNLIKELY(VAR_8[VAR_4] == VAR_30))
        VAR_10[VAR_4] = fribidi_get_bracket (VAR_28);
      else
        VAR_10[VAR_4] = VAR_31;
#endif
    }

    /* COMMENT_0 */
            
      
                       
                                                        
       

#ifndef VAR_32
#define VAR_32(VAR_33) 0
#endif
    /* COMMENT_6 */
                                                                         
                                                              
      
                                            
                                                 
       
    if (!VAR_32 (VAR_12) &&
	!FRIBIDI_IS_RTL (VAR_12) &&
	!FRIBIDI_IS_ARABIC (VAR_12) &&
	(!FRIBIDI_IS_RTL (VAR_7) ||
	  (FRIBIDI_IS_WEAK (VAR_7) &&
	   FRIBIDI_IS_LETTER (VAR_12))
	))
      {
        /* COMMENT_13 */
	VAR_7 = VAR_19;
	memset (VAR_5, 0, VAR_3);
	goto resolved;
      }
    /* COMMENT_14 */
                                                               
                     
      
                                                 
                                                 
       
    else if (!VAR_32 (VAR_12) &&
	     !FRIBIDI_IS_NUMBER (VAR_12) &&
	     FRIBIDI_IS_RTL (VAR_13) &&
	     (FRIBIDI_IS_RTL (VAR_7) ||
	       (FRIBIDI_IS_WEAK (VAR_7) &&
		FRIBIDI_IS_LETTER (VAR_12))
	     ))
      {
        /* COMMENT_21 */
	VAR_7 = VAR_22;
	memset (VAR_5, 1, VAR_3);
	goto resolved;
      }


#ifdef VAR_9
  VAR_11 = fribidi_get_par_embedding_levels_ex (VAR_8, VAR_10, VAR_3,
						   &VAR_7,
						   (FriBidiLevel*)VAR_5);
#else
  VAR_11 = fribidi_get_par_embedding_levels (VAR_8, VAR_3,
						&VAR_7,
						(FriBidiLevel*)VAR_5);
#endif

  if (G_UNLIKELY(VAR_11 == 0))
    {
      /* COMMENT_22 */
      memset (VAR_5, 0, VAR_1);
    }

resolved:
  g_free (VAR_8);

#ifdef VAR_9
  g_free (VAR_10);
#endif

  *VAR_2 = (VAR_7 == VAR_19) ?  VAR_17 : VAR_20;

  return VAR_5;
}",GNOME/pango/490f8979a260c16b1df055eab386345da18a2d54/pango-bidi-type.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -52,8 +52,11 @@
   for (i = 0, p = text; p < text + length; p = g_utf8_next_char(p), i++)
     {
       gunichar ch = g_utf8_get_char (p);
-      FriBidiCharType char_type;
-      char_type = fribidi_get_bidi_type (ch);
+      FriBidiCharType char_type = fribidi_get_bidi_type (ch);
+
+      if (i == n_chars)
+        break;
+
       bidi_types[i] = char_type;
       ored_types |= char_type;
       if (FRIBIDI_IS_STRONG (char_type))","{'deleted_lines': ['      FriBidiCharType char_type;', '      char_type = fribidi_get_bidi_type (ch);'], 'added_lines': ['      FriBidiCharType char_type = fribidi_get_bidi_type (ch);', '', '      if (i == n_chars)', '        break;', '']}",True,"Gnome Pango 1.42 and later is affected by: Buffer Overflow. The impact is: The heap based buffer overflow can be used to get code execution. The component is: function name: pango_log2vis_get_embedding_levels, assignment of nchars and the loop condition. The attack vector is: Bug can be used when application pass invalid utf-8 strings to functions like pango_itemize.",9.8,CRITICAL,3,valid,2019-07-11T00:26:23Z,2
CVE-2019-14452,['CWE-22'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,Sigil-Ebook/Sigil,harden plugin unzipping to zip-slip attacks,0979ba8d10c96ebca330715bfd4494ea0e019a8f,https://github.com/Sigil-Ebook/Sigil/commit/0979ba8d10c96ebca330715bfd4494ea0e019a8f,src/Misc/Utility.cpp,Utility::UnZip,"bool Utility::UnZip(const QString &zippath, const QString &destpath)
{
int res = 0;
QDir dir(destpath);
if (!cp437) {
cp437 = new QCodePage437Codec();
}
#ifdef Q_OS_WIN32
zlib_filefunc64_def ffunc;
fill_win32_filefunc64W(&ffunc);
unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);
#else
unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());
#endif
if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {
return false;
}
res = unzGoToFirstFile(zfile);
if (res == UNZ_OK) {
do {
char file_name[MAX_PATH] = {0};
unz_file_info64 file_info;
unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
QString qfile_name;
QString cp437_file_name;
qfile_name = QString::fromUtf8(file_name);
if (!(file_info.flag & (1<<11))) {
cp437_file_name = cp437->toUnicode(file_name);
}
if (!qfile_name.isEmpty()) {
QString file_path = destpath + ""/"" + qfile_name;
QFileInfo qfile_info(file_path);
if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
dir.mkpath(qfile_name);
continue;
} else {
dir.mkpath(qfile_info.path());
}
if (unzOpenCurrentFile(zfile) != UNZ_OK) {
unzClose(zfile);
return false;
}
QFile entry(file_path);
if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
return false;
}
char buff[BUFF_SIZE] = {0};
int read = 0;
while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
entry.write(buff, read);
}
entry.close();
if (read < 0) {
unzCloseCurrentFile(zfile);
unzClose(zfile);
return false;
}
if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
unzClose(zfile);
return false;
}
if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
QString cp437_file_path = destpath + ""/"" + cp437_file_name;
QFile::copy(file_path, cp437_file_path);
}
}
} while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
}
if (res != UNZ_END_OF_LIST_OF_FILE) {
unzClose(zfile);
return false;
}
unzClose(zfile);
return true;
}","bool Utility::UnZip(const QString &VAR_0, const QString &VAR_1)
{
int VAR_2 = 0;
QDir dir(destpath);
if (!VAR_3) {
VAR_3 = new QCodePage437Codec();
}
#ifdef VAR_4
zlib_filefunc64_def VAR_5;
fill_win32_filefunc64W(&VAR_5);
unzFile VAR_6 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_0)).c_str(), &VAR_5);
#else
unzFile VAR_6 = unzOpen64(QDir::toNativeSeparators(VAR_0).toUtf8().constData());
#endif
if ((VAR_6 == NULL) || (!IsFileReadable(VAR_0)) || (!VAR_7.exists())) {
return false;
}
VAR_2 = unzGoToFirstFile(VAR_6);
if (VAR_2 == VAR_8) {
do {
char VAR_9[VAR_10] = {0};
unz_file_info64 VAR_11;
unzGetCurrentFileInfo64(VAR_6, &VAR_11, VAR_9, VAR_10, NULL, 0, NULL, 0);
QString VAR_12;
QString VAR_13;
VAR_12 = QString::fromUtf8(VAR_9);
if (!(VAR_11.flag & (1<<11))) {
VAR_13 = VAR_3->toUnicode(VAR_9);
}
if (!VAR_12.isEmpty()) {
QString VAR_14 = destpath + ""/"" + VAR_12;
QFileInfo qfile_info(file_path);
if (VAR_11.uncompressed_size == 0 && VAR_12.endsWith('/')) {
VAR_7.mkpath(VAR_12);
continue;
} else {
VAR_7.mkpath(VAR_15.path());
}
if (unzOpenCurrentFile(VAR_6) != VAR_8) {
unzClose(VAR_6);
return false;
}
QFile entry(file_path);
if (!VAR_16.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
unzCloseCurrentFile(VAR_6);
unzClose(VAR_6);
return false;
}
char VAR_17[VAR_18] = {0};
int VAR_19 = 0;
while ((VAR_19 = unzReadCurrentFile(VAR_6, VAR_17, VAR_18)) > 0) {
VAR_16.write(VAR_17, VAR_19);
}
VAR_16.close();
if (VAR_19 < 0) {
unzCloseCurrentFile(VAR_6);
unzClose(VAR_6);
return false;
}
if (unzCloseCurrentFile(VAR_6) == VAR_20) {
unzClose(VAR_6);
return false;
}
if (!VAR_13.isEmpty() && VAR_13 != VAR_12) {
QString VAR_21 = destpath + ""/"" + VAR_13;
QFile::copy(file_path, VAR_21);
}
}
} while ((VAR_2 = unzGoToNextFile(VAR_6)) == VAR_8);
}
if (VAR_2 != VAR_22) {
unzClose(VAR_6);
return false;
}
unzClose(VAR_6);
return true;
}",Sigil-Ebook/Sigil/0979ba8d10c96ebca330715bfd4494ea0e019a8f/Utility.cpp/vul/before/0.json,"bool Utility::UnZip(const QString &zippath, const QString &destpath)
{
    int res = 0;
    QDir dir(destpath);
    if (!cp437) {
        cp437 = new QCodePage437Codec();
    }
#ifdef Q_OS_WIN32
    zlib_filefunc64_def ffunc;
    fill_win32_filefunc64W(&ffunc);
    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);
#else
    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());
#endif

    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {
        return false;
    }

    res = unzGoToFirstFile(zfile);

    if (res == UNZ_OK) {
        do {
            // Get the name of the file in the archive.
            char file_name[MAX_PATH] = {0};
            unz_file_info64 file_info;
            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
            QString qfile_name;
            QString cp437_file_name;
            qfile_name = QString::fromUtf8(file_name);
            if (!(file_info.flag & (1<<11))) {
                // General purpose bit 11 says the filename is utf-8 encoded. If not set then
                // IBM 437 encoding might be used.
                cp437_file_name = cp437->toUnicode(file_name);
            }

            // If there is no file name then we can't do anything with it.
            if (!qfile_name.isEmpty()) {

	        // for security reasons against maliciously crafted zip archives
	        // we need the file path to always be inside the target folder 
	        // and not outside, so we will remove all illegal backslashes
	        // and all relative upward paths segments ""/../"" from the zip's local 
	        // file name/path before prepending the target folder to create 
	        // the final path

	        QString original_path = qfile_name;
	        bool evil_or_corrupt_epub = false;

	        if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");

	        if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        qfile_name = qfile_name.replace(""/../"",""/"");

	        while(qfile_name.startsWith(""/"")) { 
		  qfile_name = qfile_name.remove(0,1);
	        }
                
	        if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");

	        if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");

	        while(cp437_file_name.startsWith(""/"")) { 
		  cp437_file_name = cp437_file_name.remove(0,1);
	        }

	        if (evil_or_corrupt_epub) {
		    unzCloseCurrentFile(zfile);
		    unzClose(zfile);
		    // throw (UNZIPLoadParseError(QString(QObject::tr(""Possible evil or corrupt zip file name: %1"")).arg(original_path).toStdString()));
                    return false;
	        }

                // We use the dir object to create the path in the temporary directory.
                // Unfortunately, we need a dir ojbect to do this as it's not a static function.
                // Full file path in the temporary directory.
                QString file_path = destpath + ""/"" + qfile_name;
                QFileInfo qfile_info(file_path);

                // Is this entry a directory?
                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
                    dir.mkpath(qfile_name);
                    continue;
                } else {
                    dir.mkpath(qfile_info.path());
                }

                // Open the file entry in the archive for reading.
                if (unzOpenCurrentFile(zfile) != UNZ_OK) {
                    unzClose(zfile);
                    return false;
                }

                // Open the file on disk to write the entry in the archive to.
                QFile entry(file_path);

                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    return false;
                }

                // Buffered reading and writing.
                char buff[BUFF_SIZE] = {0};
                int read = 0;

                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
                    entry.write(buff, read);
                }

                entry.close();

                // Read errors are marked by a negative read amount.
                if (read < 0) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    return false;
                }

                // The file was read but the CRC did not match.
                // We don't check the read file size vs the uncompressed file size
                // because if they're different there should be a CRC error.
                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
                    unzClose(zfile);
                    return false;
                }

                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {
                    QString cp437_file_path = destpath + ""/"" + cp437_file_name;
                    QFile::copy(file_path, cp437_file_path);
                }
            }
        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
    }

    if (res != UNZ_END_OF_LIST_OF_FILE) {
        unzClose(zfile);
        return false;
    }

    unzClose(zfile);
    return true;
}","bool Utility::UnZip(const QString &VAR_0, const QString &VAR_1)
{
    int VAR_2 = 0;
    QDir dir(destpath);
    if (!VAR_3) {
        VAR_3 = new QCodePage437Codec();
    }
#ifdef VAR_4
    zlib_filefunc64_def VAR_5;
    fill_win32_filefunc64W(&VAR_5);
    unzFile VAR_6 = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(VAR_0)).c_str(), &VAR_5);
#else
    unzFile VAR_6 = unzOpen64(QDir::toNativeSeparators(VAR_0).toUtf8().constData());
#endif

    if ((VAR_6 == NULL) || (!IsFileReadable(VAR_0)) || (!VAR_7.exists())) {
        return false;
    }

    VAR_2 = unzGoToFirstFile(VAR_6);

    if (VAR_2 == VAR_8) {
        do {
            /* COMMENT_0 */
            char VAR_9[VAR_10] = {0};
            unz_file_info64 VAR_11;
            unzGetCurrentFileInfo64(VAR_6, &VAR_11, VAR_9, VAR_10, NULL, 0, NULL, 0);
            QString VAR_12;
            QString VAR_13;
            VAR_12 = QString::fromUtf8(VAR_9);
            if (!(VAR_11.flag & (1<<11))) {
                /* COMMENT_1 */
                /* COMMENT_2 */
                VAR_13 = VAR_3->toUnicode(VAR_9);
            }

            /* COMMENT_3 */
            if (!VAR_12.isEmpty()) {

	        /* COMMENT_4 */
	        /* COMMENT_5 */
	        /* COMMENT_6 */
	        /* COMMENT_7 */
	        /* COMMENT_8 */
	        /* COMMENT_9 */

	        QString VAR_14 = VAR_12;
	        bool VAR_15 = false;

	        if (VAR_12.contains(""\\"")) VAR_15 = true; 
	        VAR_12 = ""/"" + VAR_12.replace(""\\"","""");

	        if (VAR_12.contains(""/../"")) VAR_15 = true;
	        VAR_12 = VAR_12.replace(""/../"",""/"");

	        while(VAR_12.startsWith(""/"")) { 
		  VAR_12 = VAR_12.remove(0,1);
	        }
                
	        if (VAR_13.contains(""\\"")) VAR_15 = true; 
	        VAR_13 = ""/"" + VAR_13.replace(""\\"","""");

	        if (VAR_13.contains(""/../"")) VAR_15 = true;
	        VAR_13 = VAR_13.replace(""/../"",""/"");

	        while(VAR_13.startsWith(""/"")) { 
		  VAR_13 = VAR_13.remove(0,1);
	        }

	        if (VAR_15) {
		    unzCloseCurrentFile(VAR_6);
		    unzClose(VAR_6);
		    /* COMMENT_10 */
                    return false;
	        }

                /* COMMENT_11 */
                /* COMMENT_12 */
                /* COMMENT_13 */
                QString VAR_16 = destpath + ""/"" + VAR_12;
                QFileInfo qfile_info(file_path);

                /* COMMENT_14 */
                if (VAR_11.uncompressed_size == 0 && VAR_12.endsWith('/')) {
                    VAR_7.mkpath(VAR_12);
                    continue;
                } else {
                    VAR_7.mkpath(VAR_17.path());
                }

                /* COMMENT_15 */
                if (unzOpenCurrentFile(VAR_6) != VAR_8) {
                    unzClose(VAR_6);
                    return false;
                }

                /* COMMENT_16 */
                QFile entry(file_path);

                if (!VAR_18.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
                    unzCloseCurrentFile(VAR_6);
                    unzClose(VAR_6);
                    return false;
                }

                /* COMMENT_17 */
                char VAR_19[VAR_20] = {0};
                int VAR_21 = 0;

                while ((VAR_21 = unzReadCurrentFile(VAR_6, VAR_19, VAR_20)) > 0) {
                    VAR_18.write(VAR_19, VAR_21);
                }

                VAR_18.close();

                /* COMMENT_18 */
                if (VAR_21 < 0) {
                    unzCloseCurrentFile(VAR_6);
                    unzClose(VAR_6);
                    return false;
                }

                /* COMMENT_19 */
                /* COMMENT_20 */
                /* COMMENT_21 */
                if (unzCloseCurrentFile(VAR_6) == VAR_22) {
                    unzClose(VAR_6);
                    return false;
                }

                if (!VAR_13.isEmpty() && VAR_13 != VAR_12) {
                    QString VAR_23 = destpath + ""/"" + VAR_13;
                    QFile::copy(file_path, VAR_23);
                }
            }
        } while ((VAR_2 = unzGoToNextFile(VAR_6)) == VAR_8);
    }

    if (VAR_2 != VAR_24) {
        unzClose(VAR_6);
        return false;
    }

    unzClose(VAR_6);
    return true;
}",Sigil-Ebook/Sigil/0979ba8d10c96ebca330715bfd4494ea0e019a8f/Utility.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,44 @@
 
             // If there is no file name then we can't do anything with it.
             if (!qfile_name.isEmpty()) {
+
+	        // for security reasons against maliciously crafted zip archives
+	        // we need the file path to always be inside the target folder 
+	        // and not outside, so we will remove all illegal backslashes
+	        // and all relative upward paths segments ""/../"" from the zip's local 
+	        // file name/path before prepending the target folder to create 
+	        // the final path
+
+	        QString original_path = qfile_name;
+	        bool evil_or_corrupt_epub = false;
+
+	        if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
+	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");
+
+	        if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
+	        qfile_name = qfile_name.replace(""/../"",""/"");
+
+	        while(qfile_name.startsWith(""/"")) { 
+		  qfile_name = qfile_name.remove(0,1);
+	        }
+                
+	        if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
+	        cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");
+
+	        if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
+	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");
+
+	        while(cp437_file_name.startsWith(""/"")) { 
+		  cp437_file_name = cp437_file_name.remove(0,1);
+	        }
+
+	        if (evil_or_corrupt_epub) {
+		    unzCloseCurrentFile(zfile);
+		    unzClose(zfile);
+		    // throw (UNZIPLoadParseError(QString(QObject::tr(""Possible evil or corrupt zip file name: %1"")).arg(original_path).toStdString()));
+                    return false;
+	        }
+
                 // We use the dir object to create the path in the temporary directory.
                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.
                 // Full file path in the temporary directory.","{'deleted_lines': [], 'added_lines': ['', '\t        // for security reasons against maliciously crafted zip archives', '\t        // we need the file path to always be inside the target folder ', '\t        // and not outside, so we will remove all illegal backslashes', '\t        // and all relative upward paths segments ""/../"" from the zip\'s local ', '\t        // file name/path before prepending the target folder to create ', '\t        // the final path', '', '\t        QString original_path = qfile_name;', '\t        bool evil_or_corrupt_epub = false;', '', '\t        if (qfile_name.contains(""\\\\"")) evil_or_corrupt_epub = true; ', '\t        qfile_name = ""/"" + qfile_name.replace(""\\\\"","""");', '', '\t        if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;', '\t        qfile_name = qfile_name.replace(""/../"",""/"");', '', '\t        while(qfile_name.startsWith(""/"")) { ', '\t\t  qfile_name = qfile_name.remove(0,1);', '\t        }', '                ', '\t        if (cp437_file_name.contains(""\\\\"")) evil_or_corrupt_epub = true; ', '\t        cp437_file_name = ""/"" + cp437_file_name.replace(""\\\\"","""");', '', '\t        if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;', '\t        cp437_file_name = cp437_file_name.replace(""/../"",""/"");', '', '\t        while(cp437_file_name.startsWith(""/"")) { ', '\t\t  cp437_file_name = cp437_file_name.remove(0,1);', '\t        }', '', '\t        if (evil_or_corrupt_epub) {', '\t\t    unzCloseCurrentFile(zfile);', '\t\t    unzClose(zfile);', '\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(""Possible evil or corrupt zip file name: %1"")).arg(original_path).toStdString()));', '                    return false;', '\t        }', '']}",True,"Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",7.5,HIGH,2,valid,2019-07-12T18:08:44Z,2
CVE-2019-13640,['CWE-78'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,qbittorrent/qBittorrent,"Prevent command injection via ""Run external program"" function

Closes #10925.",a610c8567e55516231d199b551e0e7e2dca70cbf,https://github.com/qbittorrent/qBittorrent/commit/a610c8567e55516231d199b551e0e7e2dca70cbf,src/app/application.cpp,Application::runExternalProgram,"void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const
{
QString program = Preferences::instance()->getAutoRunProgram().trimmed();
program.replace(""%N"", torrent->name());
program.replace(""%L"", torrent->category());
QStringList tags = torrent->tags().toList();
std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);
program.replace(""%G"", tags.join(','));
#if defined(Q_OS_WIN)
const auto chopPathSep = [](const QString &str) -> QString
{
if (str.endsWith('\\'))
return str.mid(0, (str.length() -1));
return str;
};
program.replace(""%F"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));
program.replace(""%R"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));
program.replace(""%D"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));
#else
program.replace(""%F"", Utils::Fs::toNativePath(torrent->contentPath()));
program.replace(""%R"", Utils::Fs::toNativePath(torrent->rootPath()));
program.replace(""%D"", Utils::Fs::toNativePath(torrent->savePath()));
#endif
program.replace(""%C"", QString::number(torrent->filesCount()));
program.replace(""%Z"", QString::number(torrent->totalSize()));
program.replace(""%T"", torrent->currentTracker());
program.replace(""%I"", torrent->hash());
Logger *logger = Logger::instance();
logger->addMessage(tr(""Torrent: %1, running external program, command: %2"").arg(torrent->name(), program));
#if defined(Q_OS_WIN)
std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});
program.toWCharArray(programWchar.get());
int argCount = 0;
LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);
QStringList argList;
for (int i = 1; i < argCount; ++i)
argList += QString::fromWCharArray(args[i]);
QProcess::startDetached(QString::fromWCharArray(args[0]), argList);
::LocalFree(args);
#else
QProcess::startDetached(QLatin1String(""/bin/sh""), {QLatin1String(""-c""), program});
#endif
}","void Application::runExternalProgram(const BitTorrent::TorrentHandle *VAR_0) const
{
QString VAR_1 = Preferences::instance()->getAutoRunProgram().trimmed();
VAR_1.replace(""%N"", VAR_0->name());
VAR_1.replace(""%L"", VAR_0->category());
QStringList VAR_2 = VAR_0->tags().toList();
std::sort(VAR_2.begin(), VAR_2.end(), Utils::String::VAR_3<Qt::CaseInsensitive>);
VAR_1.replace(""%G"", VAR_2.join(','));
#if defined(VAR_4)
const auto VAR_5 = [](const QString &VAR_6) -> QString
{
if (VAR_6.endsWith('\\'))
return VAR_6.mid(0, (VAR_6.length() -1));
return VAR_6;
};
VAR_1.replace(""%F"", VAR_5(Utils::Fs::toNativePath(VAR_0->contentPath())));
VAR_1.replace(""%R"", VAR_5(Utils::Fs::toNativePath(VAR_0->rootPath())));
VAR_1.replace(""%D"", VAR_5(Utils::Fs::toNativePath(VAR_0->savePath())));
#else
VAR_1.replace(""%F"", Utils::Fs::toNativePath(VAR_0->contentPath()));
VAR_1.replace(""%R"", Utils::Fs::toNativePath(VAR_0->rootPath()));
VAR_1.replace(""%D"", Utils::Fs::toNativePath(VAR_0->savePath()));
#endif
VAR_1.replace(""%C"", QString::number(VAR_0->filesCount()));
VAR_1.replace(""%Z"", QString::number(VAR_0->totalSize()));
VAR_1.replace(""%T"", VAR_0->currentTracker());
VAR_1.replace(""%I"", VAR_0->hash());
Logger *VAR_7 = Logger::instance();
VAR_7->addMessage(tr(""Torrent: %1, running external program, command: %2"").arg(VAR_0->name(), VAR_1));
#if defined(VAR_4)
std::unique_ptr<wchar_t[]> VAR_8(new wchar_t[VAR_1.length() + 1] {});
VAR_1.toWCharArray(VAR_8.get());
int VAR_9 = 0;
LPWSTR *VAR_10 = ::CommandLineToArgvW(VAR_8.get(), &VAR_9);
QStringList VAR_11;
for (int VAR_12 = 1; VAR_12 < VAR_9; ++VAR_12)
VAR_11 += QString::fromWCharArray(VAR_10[VAR_12]);
QProcess::startDetached(QString::fromWCharArray(VAR_10[0]), VAR_11);
::LocalFree(VAR_10);
#else
QProcess::startDetached(QLatin1String(""/bin/sh""), {QLatin1String(""-c""), VAR_1});
#endif
}",qbittorrent/qBittorrent/a610c8567e55516231d199b551e0e7e2dca70cbf/application.cpp/vul/before/0.json,"void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const
{
    QString program = Preferences::instance()->getAutoRunProgram().trimmed();
    program.replace(""%N"", torrent->name());
    program.replace(""%L"", torrent->category());

    QStringList tags = torrent->tags().toList();
    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);
    program.replace(""%G"", tags.join(','));

#if defined(Q_OS_WIN)
    const auto chopPathSep = [](const QString &str) -> QString
    {
        if (str.endsWith('\\'))
            return str.mid(0, (str.length() -1));
        return str;
    };
    program.replace(""%F"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));
    program.replace(""%R"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));
    program.replace(""%D"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));
#else
    program.replace(""%F"", Utils::Fs::toNativePath(torrent->contentPath()));
    program.replace(""%R"", Utils::Fs::toNativePath(torrent->rootPath()));
    program.replace(""%D"", Utils::Fs::toNativePath(torrent->savePath()));
#endif
    program.replace(""%C"", QString::number(torrent->filesCount()));
    program.replace(""%Z"", QString::number(torrent->totalSize()));
    program.replace(""%T"", torrent->currentTracker());
    program.replace(""%I"", torrent->hash());

    Logger *logger = Logger::instance();
    logger->addMessage(tr(""Torrent: %1, running external program, command: %2"").arg(torrent->name(), program));

#if defined(Q_OS_WIN)
    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});
    program.toWCharArray(programWchar.get());

    // Need to split arguments manually because QProcess::startDetached(QString)
    // will strip off empty parameters.
    // E.g. `python.exe ""1"" """" ""3""` will become `python.exe ""1"" ""3""`
    int argCount = 0;
    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);

    QStringList argList;
    for (int i = 1; i < argCount; ++i)
        argList += QString::fromWCharArray(args[i]);

    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);

    ::LocalFree(args);
#else
    // Cannot give users shell environment by default, as doing so could
    // enable command injection via torrent name and other arguments
    // (especially when some automated download mechanism has been setup).
    // See: https://github.com/qbittorrent/qBittorrent/issues/10925
    QProcess::startDetached(program);
#endif
}","void Application::runExternalProgram(const BitTorrent::TorrentHandle *VAR_0) const
{
    QString VAR_1 = Preferences::instance()->getAutoRunProgram().trimmed();
    VAR_1.replace(""%N"", VAR_0->name());
    VAR_1.replace(""%L"", VAR_0->category());

    QStringList VAR_2 = VAR_0->tags().toList();
    std::sort(VAR_2.begin(), VAR_2.end(), Utils::String::VAR_3<Qt::CaseInsensitive>);
    VAR_1.replace(""%G"", VAR_2.join(','));

#if defined(VAR_4)
    const auto VAR_5 = [](const QString &VAR_6) -> QString
    {
        if (VAR_6.endsWith('\\'))
            return VAR_6.mid(0, (VAR_6.length() -1));
        return VAR_6;
    };
    VAR_1.replace(""%F"", VAR_5(Utils::Fs::toNativePath(VAR_0->contentPath())));
    VAR_1.replace(""%R"", VAR_5(Utils::Fs::toNativePath(VAR_0->rootPath())));
    VAR_1.replace(""%D"", VAR_5(Utils::Fs::toNativePath(VAR_0->savePath())));
#else
    VAR_1.replace(""%F"", Utils::Fs::toNativePath(VAR_0->contentPath()));
    VAR_1.replace(""%R"", Utils::Fs::toNativePath(VAR_0->rootPath()));
    VAR_1.replace(""%D"", Utils::Fs::toNativePath(VAR_0->savePath()));
#endif
    VAR_1.replace(""%C"", QString::number(VAR_0->filesCount()));
    VAR_1.replace(""%Z"", QString::number(VAR_0->totalSize()));
    VAR_1.replace(""%T"", VAR_0->currentTracker());
    VAR_1.replace(""%I"", VAR_0->hash());

    Logger *VAR_7 = Logger::instance();
    VAR_7->addMessage(tr(""Torrent: %1, running external program, command: %2"").arg(VAR_0->name(), VAR_1));

#if defined(VAR_4)
    std::unique_ptr<wchar_t[]> VAR_8(new wchar_t[VAR_1.length() + 1] {});
    VAR_1.toWCharArray(VAR_8.get());

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    int VAR_9 = 0;
    LPWSTR *VAR_10 = ::CommandLineToArgvW(VAR_8.get(), &VAR_9);

    QStringList VAR_11;
    for (int VAR_12 = 1; VAR_12 < VAR_9; ++VAR_12)
        VAR_11 += QString::fromWCharArray(VAR_10[VAR_12]);

    QProcess::startDetached(QString::fromWCharArray(VAR_10[0]), VAR_11);

    ::LocalFree(VAR_10);
#else
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    QProcess::startDetached(VAR_1);
#endif
}",qbittorrent/qBittorrent/a610c8567e55516231d199b551e0e7e2dca70cbf/application.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,6 +49,10 @@
 
     ::LocalFree(args);
 #else
-    QProcess::startDetached(QLatin1String(""/bin/sh""), {QLatin1String(""-c""), program});
+    // Cannot give users shell environment by default, as doing so could
+    // enable command injection via torrent name and other arguments
+    // (especially when some automated download mechanism has been setup).
+    // See: https://github.com/qbittorrent/qBittorrent/issues/10925
+    QProcess::startDetached(program);
 #endif
 }","{'deleted_lines': ['    QProcess::startDetached(QLatin1String(""/bin/sh""), {QLatin1String(""-c""), program});'], 'added_lines': ['    // Cannot give users shell environment by default, as doing so could', '    // enable command injection via torrent name and other arguments', '    // (especially when some automated download mechanism has been setup).', '    // See: https://github.com/qbittorrent/qBittorrent/issues/10925', '    QProcess::startDetached(program);']}",True,"In qBittorrent before 4.1.7, the function Application::runExternalProgram() located in app/application.cpp allows command injection via shell metacharacters in the torrent name parameter or current tracker parameter, as demonstrated by remote command execution via a crafted name within an RSS feed.",9.8,CRITICAL,3,valid,2019-07-18T14:36:40Z,2
CVE-2019-14296,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,upx,"Ignore malformed ElfXX_Shdr in search for .text or .note

https://github.com/upx/upx/issues/287
	modified:   p_vmlinx.cpp",276b748aa6021c38a2dc699153f61b10e76bc3d2,https://github.com/upx/upx/commit/276b748aa6021c38a2dc699153f61b10e76bc3d2,src/p_vmlinx.cpp,PackVmlinuxBase<T>::canUnpack,"int PackVmlinuxBase<T>::canUnpack()
{
fi->seek(0, SEEK_SET);
fi->readx(&ehdri, sizeof(ehdri));
if (memcmp(&ehdri, ""\x7f\x45\x4c\x46"", 4)
||  ehdri.e_ident[Ehdr::EI_CLASS] != my_elfclass
||  ehdri.e_ident[Ehdr::EI_DATA] != my_elfdata
||  ehdri.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT
||  !memcmp(&ehdri.e_ident[8], ""FreeBSD"", 7)      ||  ehdri.e_machine != my_e_machine
||  ehdri.e_version != 1      ||  ehdri.e_ehsize != sizeof(ehdri)      )
return false;
if (ehdri.e_type != Ehdr::ET_REL
||  ehdri.e_shentsize!=sizeof(Shdr)
||  ehdri.e_shnum < 4
||  (unsigned)file_size < (ehdri.e_shnum * sizeof(Shdr) + ehdri.e_shoff)
)
return false;
Shdr const *const shstrsec = getElfSections();
if (0==shstrsec) {
return false;
}
p_note0 = p_note1 = p_text = 0;
int j;
Shdr *p;
for (p= shdri, j= ehdri.e_shnum; --j>=0; ++p) {
if ((unsigned)file_size < (p->sh_size + p->sh_offset)
||  shstrsec->sh_size < (5+ p->sh_name) ) {
continue;
}
if (0==strcmp("".text"", shstrtab + p->sh_name)) {
p_text = p;
}
if (0==strcmp("".note"", shstrtab + p->sh_name)) {
if (0==p_note0) {
p_note0 = p;
} else
if (0==p_note1) {
p_note1 = p;
}
}
}
if (0==p_text || 0==p_note0 || 0==p_note1) {
return false;
}
char buf[1024];
fi->seek(p_text->sh_offset + p_text->sh_size - sizeof(buf), SEEK_SET);
fi->readx(buf, sizeof(buf));
if (!getPackHeader(buf, sizeof(buf)))
return -1; 
return true;
}","int PackVmlinuxBase<T>::canUnpack()
{
VAR_0->seek(0, VAR_1);
VAR_0->readx(&VAR_2, sizeof(VAR_2));
if (memcmp(&VAR_2, ""\x7f\x45\x4c\x46"", 4)
||  VAR_2.e_ident[Ehdr::EI_CLASS] != VAR_3
||  VAR_2.e_ident[Ehdr::EI_DATA] != VAR_4
||  VAR_2.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT
||  !memcmp(&VAR_2.e_ident[8], ""FreeBSD"", 7)  
||  VAR_2.e_machine != VAR_5
||  VAR_2.e_version != 1  
||  VAR_2.e_ehsize != sizeof(VAR_2)  
)
return false;
if (VAR_2.e_type != Ehdr::ET_REL
||  VAR_2.e_shentsize!=sizeof(VAR_6)
||  VAR_2.e_shnum < 4
||  (unsigned)VAR_7 < (VAR_2.e_shnum * sizeof(VAR_6) + VAR_2.e_shoff)
)
return false;
Shdr const *const VAR_8 = getElfSections();
if (0==VAR_8) {
return false;
}
VAR_9 = VAR_10 = VAR_11 = 0;
int VAR_12;
Shdr *VAR_13;
for (VAR_13= VAR_14, VAR_12= VAR_2.e_shnum; --VAR_12>=0; ++VAR_13) {
if ((unsigned)VAR_7 < (VAR_13->sh_size + VAR_13->sh_offset)
||  VAR_8->sh_size < (5+ VAR_13->sh_name) ) {
continue;
}
if (0==strcmp("".text"", VAR_15 + VAR_13->sh_name)) {
VAR_11 = VAR_13;
}
if (0==strcmp("".note"", VAR_15 + VAR_13->sh_name)) {
if (0==VAR_9) {
VAR_9 = VAR_13;
} else
if (0==VAR_10) {
VAR_10 = VAR_13;
}
}
}
if (0==VAR_11 || 0==VAR_9 || 0==VAR_10) {
return false;
}
char VAR_16[1024];
VAR_0->seek(VAR_11->sh_offset + VAR_11->sh_size - sizeof(VAR_16), VAR_1);
VAR_0->readx(VAR_16, sizeof(VAR_16));
if (!getPackHeader(VAR_16, sizeof(VAR_16)))
return -1; 
return true;
}",upx/276b748aa6021c38a2dc699153f61b10e76bc3d2/p_vmlinx.cpp/vul/before/0.json,"int PackVmlinuxBase<T>::canUnpack()
{
    fi->seek(0, SEEK_SET);
    fi->readx(&ehdri, sizeof(ehdri));

    // now check the ELF header
    if (memcmp(&ehdri, ""\x7f\x45\x4c\x46"", 4)
    ||  ehdri.e_ident[Ehdr::EI_CLASS] != my_elfclass
    ||  ehdri.e_ident[Ehdr::EI_DATA] != my_elfdata
    ||  ehdri.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT
    ||  !memcmp(&ehdri.e_ident[8], ""FreeBSD"", 7)  // branded
    ||  ehdri.e_machine != my_e_machine
    ||  ehdri.e_version != 1  // version
    ||  ehdri.e_ehsize != sizeof(ehdri)  // different <elf.h> ?
    )
        return false;

    if (ehdri.e_type != Ehdr::ET_REL
    //i386 fails  ||  ehdri.e_shoff != sizeof(ehdri)  // Shdr not contiguous with Ehdr
    ||  ehdri.e_shentsize!=sizeof(Shdr)
    ||  ehdri.e_shnum < 4
    ||  (unsigned)file_size < (ehdri.e_shnum * sizeof(Shdr) + ehdri.e_shoff)
    )
        return false;

    // find the .shstrtab section
    Shdr const *const shstrsec = getElfSections();
    if (0==shstrsec) {
        return false;
    }

    // check for .text .note .note  and sane (.sh_size + .sh_offset)
    p_note0 = p_note1 = p_text = 0;
    int j;
    Shdr *p;
    for (p= shdri, j= ehdri.e_shnum; --j>=0; ++p) {
        if ((unsigned)file_size < (p->sh_size + p->sh_offset)
        || (5+ p->sh_name) < p->sh_name  // wrap: ignore malformed
        ||  shstrsec->sh_size < (5+ p->sh_name) ) {
            continue;
        }
        if (0==strcmp("".text"", shstrtab + p->sh_name)) {
            p_text = p;
        }
        if (0==strcmp("".note"", shstrtab + p->sh_name)) {
            if (0==p_note0) {
                p_note0 = p;
            } else
            if (0==p_note1) {
                p_note1 = p;
            }
        }
    }
    if (0==p_text || 0==p_note0 || 0==p_note1) {
        return false;
    }

    char buf[1024];
    fi->seek(p_text->sh_offset + p_text->sh_size - sizeof(buf), SEEK_SET);
    fi->readx(buf, sizeof(buf));
    if (!getPackHeader(buf, sizeof(buf)))
        return -1; // format is known, but definitely is not packed

    return true;
}","int PackVmlinuxBase<T>::canUnpack()
{
    VAR_0->seek(0, VAR_1);
    VAR_0->readx(&VAR_2, sizeof(VAR_2));

    /* COMMENT_0 */
    if (memcmp(&VAR_2, ""\x7f\x45\x4c\x46"", 4)
    ||  VAR_2.e_ident[Ehdr::EI_CLASS] != VAR_3
    ||  VAR_2.e_ident[Ehdr::EI_DATA] != VAR_4
    ||  VAR_2.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT
    ||  !memcmp(&VAR_2.e_ident[8], ""FreeBSD"", 7)  /* COMMENT_1 */
    ||  VAR_2.e_machine != VAR_5
    ||  VAR_2.e_version != 1  /* COMMENT_2 */
    ||  VAR_2.e_ehsize != sizeof(VAR_2)  /* COMMENT_3 */
    )
        return false;

    if (VAR_2.e_type != Ehdr::ET_REL
    /* COMMENT_4 */
    ||  VAR_2.e_shentsize!=sizeof(VAR_6)
    ||  VAR_2.e_shnum < 4
    ||  (unsigned)VAR_7 < (VAR_2.e_shnum * sizeof(VAR_6) + VAR_2.e_shoff)
    )
        return false;

    /* COMMENT_5 */
    Shdr const *const VAR_8 = getElfSections();
    if (0==VAR_8) {
        return false;
    }

    /* COMMENT_6 */
    VAR_9 = VAR_10 = VAR_11 = 0;
    int VAR_12;
    Shdr *VAR_13;
    for (VAR_13= VAR_14, VAR_12= VAR_2.e_shnum; --VAR_12>=0; ++VAR_13) {
        if ((unsigned)VAR_7 < (VAR_13->sh_size + VAR_13->sh_offset)
        || (5+ VAR_13->sh_name) < VAR_13->sh_name  /* COMMENT_7 */
        ||  VAR_8->sh_size < (5+ VAR_13->sh_name) ) {
            continue;
        }
        if (0==strcmp("".text"", VAR_15 + VAR_13->sh_name)) {
            VAR_11 = VAR_13;
        }
        if (0==strcmp("".note"", VAR_15 + VAR_13->sh_name)) {
            if (0==VAR_9) {
                VAR_9 = VAR_13;
            } else
            if (0==VAR_10) {
                VAR_10 = VAR_13;
            }
        }
    }
    if (0==VAR_11 || 0==VAR_9 || 0==VAR_10) {
        return false;
    }

    char VAR_16[1024];
    VAR_0->seek(VAR_11->sh_offset + VAR_11->sh_size - sizeof(VAR_16), VAR_1);
    VAR_0->readx(VAR_16, sizeof(VAR_16));
    if (!getPackHeader(VAR_16, sizeof(VAR_16)))
        return -1; /* COMMENT_8 */

    return true;
}",upx/276b748aa6021c38a2dc699153f61b10e76bc3d2/p_vmlinx.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,7 @@
     Shdr *p;
     for (p= shdri, j= ehdri.e_shnum; --j>=0; ++p) {
         if ((unsigned)file_size < (p->sh_size + p->sh_offset)
+        || (5+ p->sh_name) < p->sh_name  // wrap: ignore malformed
         ||  shstrsec->sh_size < (5+ p->sh_name) ) {
             continue;
         }","{'deleted_lines': [], 'added_lines': ['        || (5+ p->sh_name) < p->sh_name  // wrap: ignore malformed']}",True,"canUnpack in p_vmlinx.cpp in UPX 3.95 allows remote attackers to cause a denial of service (SEGV or buffer overflow, and application crash) or possibly have unspecified other impact via a crafted UPX packed file.",7.8,HIGH,2,valid,2019-07-21T14:40:21Z,2
CVE-2019-14462,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,stephane/libmodbus,"Fix VD-1301 and VD-1302 vulnerabilities

This patch was contributed by Maor Vermucht and Or Peles from
VDOO Connected Trust.",5ccdf5ef79d742640355d1132fa9e2abc7fbaefc,https://github.com/stephane/libmodbus/commit/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc,src/modbus.c,modbus_reply,"int modbus_reply(modbus_t *ctx, const uint8_t *req,
int req_length, modbus_mapping_t *mb_mapping)
{
int offset;
int slave;
int function;
uint16_t address;
uint8_t rsp[MAX_MESSAGE_LENGTH];
int rsp_length = 0;
sft_t sft;
if (ctx == NULL) {
errno = EINVAL;
return -1;
}
offset = ctx->backend->header_length;
slave = req[offset - 1];
function = req[offset];
address = (req[offset + 1] << 8) + req[offset + 2];
sft.slave = slave;
sft.function = function;
sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);
switch (function) {
case MODBUS_FC_READ_COILS:
case MODBUS_FC_READ_DISCRETE_INPUTS: {
unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);
int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;
int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;
uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;
const char * const name = is_input ? ""read_input_bits"" : ""read_bits"";
int nb = (req[offset + 3] << 8) + req[offset + 4];
int mapping_address = address - start_bits;
if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
""Illegal nb of values %d in %s (max %d)\n"",
nb, name, MODBUS_MAX_READ_BITS);
} else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {
rsp_length = response_exception(
ctx, &sft,
MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in %s\n"",
mapping_address < 0 ? address : address + nb, name);
} else {
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
rsp_length = response_io_status(tab_bits, mapping_address, nb,
rsp, rsp_length);
}
}
break;
case MODBUS_FC_READ_HOLDING_REGISTERS:
case MODBUS_FC_READ_INPUT_REGISTERS: {
unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);
int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;
int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;
uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;
const char * const name = is_input ? ""read_input_registers"" : ""read_registers"";
int nb = (req[offset + 3] << 8) + req[offset + 4];
int mapping_address = address - start_registers;
if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
""Illegal nb of values %d in %s (max %d)\n"",
nb, name, MODBUS_MAX_READ_REGISTERS);
} else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in %s\n"",
mapping_address < 0 ? address : address + nb, name);
} else {
int i;
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
rsp[rsp_length++] = nb << 1;
for (i = mapping_address; i < mapping_address + nb; i++) {
rsp[rsp_length++] = tab_registers[i] >> 8;
rsp[rsp_length++] = tab_registers[i] & 0xFF;
}
}
}
break;
case MODBUS_FC_WRITE_SINGLE_COIL: {
int mapping_address = address - mb_mapping->start_bits;
if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in write_bit\n"",
address);
} else {
int data = (req[offset + 3] << 8) + req[offset + 4];
if (data == 0xFF00 || data == 0x0) {
mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;
memcpy(rsp, req, req_length);
rsp_length = req_length;
} else {
rsp_length = response_exception(
ctx, &sft,
MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,
""Illegal data value 0x%0X in write_bit request at address %0X\n"",
data, address);
}
}
}
break;
case MODBUS_FC_WRITE_SINGLE_REGISTER: {
int mapping_address = address - mb_mapping->start_registers;
if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
rsp_length = response_exception(
ctx, &sft,
MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in write_register\n"",
address);
} else {
int data = (req[offset + 3] << 8) + req[offset + 4];
mb_mapping->tab_registers[mapping_address] = data;
memcpy(rsp, req, req_length);
rsp_length = req_length;
}
}
break;
case MODBUS_FC_WRITE_MULTIPLE_COILS: {
int nb = (req[offset + 3] << 8) + req[offset + 4];
int mapping_address = address - mb_mapping->start_bits;
if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
""Illegal number of values %d in write_bits (max %d)\n"",
nb, MODBUS_MAX_WRITE_BITS);
} else if (mapping_address < 0 ||
(mapping_address + nb) > mb_mapping->nb_bits) {
rsp_length = response_exception(
ctx, &sft,
MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in write_bits\n"",
mapping_address < 0 ? address : address + nb);
} else {
modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,
&req[offset + 6]);
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
memcpy(rsp + rsp_length, req + rsp_length, 4);
rsp_length += 4;
}
}
break;
case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
int nb = (req[offset + 3] << 8) + req[offset + 4];
int mapping_address = address - mb_mapping->start_registers;
if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
""Illegal number of values %d in write_registers (max %d)\n"",
nb, MODBUS_MAX_WRITE_REGISTERS);
} else if (mapping_address < 0 ||
(mapping_address + nb) > mb_mapping->nb_registers) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in write_registers\n"",
mapping_address < 0 ? address : address + nb);
} else {
int i, j;
for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {
mb_mapping->tab_registers[i] =
(req[offset + j] << 8) + req[offset + j + 1];
}
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
memcpy(rsp + rsp_length, req + rsp_length, 4);
rsp_length += 4;
}
}
break;
case MODBUS_FC_REPORT_SLAVE_ID: {
int str_len;
int byte_count_pos;
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
byte_count_pos = rsp_length++;
rsp[rsp_length++] = _REPORT_SLAVE_ID;
rsp[rsp_length++] = 0xFF;
str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
memcpy(rsp + rsp_length, ""LMB"" LIBMODBUS_VERSION_STRING, str_len);
rsp_length += str_len;
rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
}
break;
case MODBUS_FC_READ_EXCEPTION_STATUS:
if (ctx->debug) {
fprintf(stderr, ""FIXME Not implemented\n"");
}
errno = ENOPROTOOPT;
return -1;
break;
case MODBUS_FC_MASK_WRITE_REGISTER: {
int mapping_address = address - mb_mapping->start_registers;
if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data address 0x%0X in write_register\n"",
address);
} else {
uint16_t data = mb_mapping->tab_registers[mapping_address];
uint16_t and = (req[offset + 3] << 8) + req[offset + 4];
uint16_t or = (req[offset + 5] << 8) + req[offset + 6];
data = (data & and) | (or & (~and));
mb_mapping->tab_registers[mapping_address] = data;
memcpy(rsp, req, req_length);
rsp_length = req_length;
}
}
break;
case MODBUS_FC_WRITE_AND_READ_REGISTERS: {
int nb = (req[offset + 3] << 8) + req[offset + 4];
uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
int nb_write = (req[offset + 7] << 8) + req[offset + 8];
int nb_write_bytes = req[offset + 9];
int mapping_address = address - mb_mapping->start_registers;
int mapping_address_write = address_write - mb_mapping->start_registers;
if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||
nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||
nb_write_bytes != nb_write * 2) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"",
nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);
} else if (mapping_address < 0 ||
(mapping_address + nb) > mb_mapping->nb_registers ||
mapping_address < 0 ||
(mapping_address_write + nb_write) > mb_mapping->nb_registers) {
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"",
mapping_address < 0 ? address : address + nb,
mapping_address_write < 0 ? address_write : address_write + nb_write);
} else {
int i, j;
rsp_length = ctx->backend->build_response_basis(&sft, rsp);
rsp[rsp_length++] = nb << 1;
for (i = mapping_address_write, j = 10;
i < mapping_address_write + nb_write; i++, j += 2) {
mb_mapping->tab_registers[i] =
(req[offset + j] << 8) + req[offset + j + 1];
}
for (i = mapping_address; i < mapping_address + nb; i++) {
rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
}
}
}
break;
default:
rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,
""Unknown Modbus function code: 0x%0X\n"", function);
break;
}
return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&
slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);
}","int modbus_reply(modbus_t *VAR_0, const uint8_t *VAR_1,
int VAR_2, modbus_mapping_t *VAR_3)
{
int VAR_4;
int VAR_5;
int VAR_6;
uint16_t VAR_7;
uint8_t VAR_8[VAR_9];
int VAR_10 = 0;
sft_t VAR_11;
if (VAR_0 == NULL) {
VAR_12 = VAR_13;
return -1;
}
VAR_4 = VAR_0->backend->header_length;
VAR_5 = VAR_1[VAR_4 - 1];
VAR_6 = VAR_1[VAR_4];
VAR_7 = (VAR_1[VAR_4 + 1] << 8) + VAR_1[VAR_4 + 2];
VAR_11.slave = VAR_5;
VAR_11.function = VAR_6;
VAR_11.t_id = VAR_0->backend->prepare_response_tid(VAR_1, &VAR_2);
switch (VAR_6) {
case VAR_14:
case VAR_15: {
unsigned int VAR_16 = (VAR_6 == VAR_15);
int VAR_17 = VAR_16 ? VAR_3->start_input_bits : VAR_3->start_bits;
int VAR_18 = VAR_16 ? VAR_3->nb_input_bits : VAR_3->nb_bits;
uint8_t *VAR_19 = VAR_16 ? VAR_3->tab_input_bits : VAR_3->tab_bits;
const char * const VAR_20 = VAR_16 ? ""read_input_bits"" : ""read_bits"";
int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
int VAR_22 = VAR_7 - VAR_17;
if (VAR_21 < 1 || VAR_23 < VAR_21) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
""Illegal nb of values %d in %s (max %d)\n"",
VAR_21, VAR_20, VAR_23);
} else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_18) {
VAR_10 = response_exception(
VAR_0, &VAR_11,
VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in %s\n"",
VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);
} else {
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
VAR_8[VAR_10++] = (VAR_21 / 8) + ((VAR_21 % 8) ? 1 : 0);
VAR_10 = response_io_status(VAR_19, VAR_22, VAR_21,
VAR_8, VAR_10);
}
}
break;
case VAR_26:
case VAR_27: {
unsigned int VAR_16 = (VAR_6 == VAR_27);
int VAR_28 = VAR_16 ? VAR_3->start_input_registers : VAR_3->start_registers;
int VAR_29 = VAR_16 ? VAR_3->nb_input_registers : VAR_3->nb_registers;
uint16_t *VAR_30 = VAR_16 ? VAR_3->tab_input_registers : VAR_3->tab_registers;
const char * const VAR_20 = VAR_16 ? ""read_input_registers"" : ""read_registers"";
int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
int VAR_22 = VAR_7 - VAR_28;
if (VAR_21 < 1 || VAR_31 < VAR_21) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
""Illegal nb of values %d in %s (max %d)\n"",
VAR_21, VAR_20, VAR_31);
} else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_29) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in %s\n"",
VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);
} else {
int VAR_32;
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
VAR_8[VAR_10++] = VAR_21 << 1;
for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {
VAR_8[VAR_10++] = VAR_30[VAR_32] >> 8;
VAR_8[VAR_10++] = VAR_30[VAR_32] & 0xFF;
}
}
}
break;
case VAR_33: {
int VAR_22 = VAR_7 - VAR_3->start_bits;
if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_bits) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in write_bit\n"",
VAR_7);
} else {
int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
if (VAR_34 == 0xFF00 || VAR_34 == 0x0) {
VAR_3->tab_bits[VAR_22] = VAR_34 ? VAR_35 : VAR_36;
memcpy(VAR_8, VAR_1, VAR_2);
VAR_10 = VAR_2;
} else {
VAR_10 = response_exception(
VAR_0, &VAR_11,
VAR_24, VAR_8, FALSE,
""Illegal data value 0x%0X in write_bit request at address %0X\n"",
VAR_34, VAR_7);
}
}
}
break;
case VAR_37: {
int VAR_22 = VAR_7 - VAR_3->start_registers;
if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {
VAR_10 = response_exception(
VAR_0, &VAR_11,
VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in write_register\n"",
VAR_7);
} else {
int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
VAR_3->tab_registers[VAR_22] = VAR_34;
memcpy(VAR_8, VAR_1, VAR_2);
VAR_10 = VAR_2;
}
}
break;
case VAR_38: {
int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
int VAR_22 = VAR_7 - VAR_3->start_bits;
if (VAR_21 < 1 || VAR_39 < VAR_21) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
""Illegal number of values %d in write_bits (max %d)\n"",
VAR_21, VAR_39);
} else if (VAR_22 < 0 ||
(VAR_22 + VAR_21) > VAR_3->nb_bits) {
VAR_10 = response_exception(
VAR_0, &VAR_11,
VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in write_bits\n"",
VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);
} else {
modbus_set_bits_from_bytes(VAR_3->tab_bits, VAR_22, VAR_21,
&VAR_1[VAR_4 + 6]);
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);
VAR_10 += 4;
}
}
break;
case VAR_40: {
int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
int VAR_22 = VAR_7 - VAR_3->start_registers;
if (VAR_21 < 1 || VAR_41 < VAR_21) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
""Illegal number of values %d in write_registers (max %d)\n"",
VAR_21, VAR_41);
} else if (VAR_22 < 0 ||
(VAR_22 + VAR_21) > VAR_3->nb_registers) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in write_registers\n"",
VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);
} else {
int VAR_32, VAR_42;
for (VAR_32 = VAR_22, VAR_42 = 6; VAR_32 < VAR_22 + VAR_21; VAR_32++, VAR_42 += 2) {
VAR_3->tab_registers[VAR_32] =
(VAR_1[VAR_4 + VAR_42] << 8) + VAR_1[VAR_4 + VAR_42 + 1];
}
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);
VAR_10 += 4;
}
}
break;
case VAR_43: {
int VAR_44;
int VAR_45;
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
VAR_45 = VAR_10++;
VAR_8[VAR_10++] = VAR_46;
VAR_8[VAR_10++] = 0xFF;
VAR_44 = 3 + strlen(VAR_47);
memcpy(VAR_8 + VAR_10, ""LMB"" VAR_47, VAR_44);
VAR_10 += VAR_44;
VAR_8[VAR_45] = VAR_10 - VAR_45 - 1;
}
break;
case VAR_48:
if (VAR_0->debug) {
fprintf(VAR_49, ""FIXME Not implemented\n"");
}
VAR_12 = VAR_50;
return -1;
break;
case VAR_51: {
int VAR_22 = VAR_7 - VAR_3->start_registers;
if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
""Illegal data address 0x%0X in write_register\n"",
VAR_7);
} else {
uint16_t VAR_34 = VAR_3->tab_registers[VAR_22];
uint16_t VAR_52 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
uint16_t VAR_53 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];
VAR_34 = (VAR_34 & VAR_52) | (VAR_53 & (~VAR_52));
VAR_3->tab_registers[VAR_22] = VAR_34;
memcpy(VAR_8, VAR_1, VAR_2);
VAR_10 = VAR_2;
}
}
break;
case VAR_54: {
int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
uint16_t VAR_55 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];
int VAR_56 = (VAR_1[VAR_4 + 7] << 8) + VAR_1[VAR_4 + 8];
int VAR_57 = VAR_1[VAR_4 + 9];
int VAR_22 = VAR_7 - VAR_3->start_registers;
int VAR_58 = VAR_55 - VAR_3->start_registers;
if (VAR_56 < 1 || VAR_59 < VAR_56 ||
VAR_21 < 1 || VAR_60 < VAR_21 ||
VAR_57 != VAR_56 * 2) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"",
VAR_56, VAR_21, VAR_59, VAR_60);
} else if (VAR_22 < 0 ||
(VAR_22 + VAR_21) > VAR_3->nb_registers ||
VAR_22 < 0 ||
(VAR_58 + VAR_56) > VAR_3->nb_registers) {
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"",
VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21,
VAR_58 < 0 ? VAR_55 : VAR_55 + VAR_56);
} else {
int VAR_32, VAR_42;
VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
VAR_8[VAR_10++] = VAR_21 << 1;
for (VAR_32 = VAR_58, VAR_42 = 10;
VAR_32 < VAR_58 + VAR_56; VAR_32++, VAR_42 += 2) {
VAR_3->tab_registers[VAR_32] =
(VAR_1[VAR_4 + VAR_42] << 8) + VAR_1[VAR_4 + VAR_42 + 1];
}
for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {
VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] >> 8;
VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] & 0xFF;
}
}
}
break;
default:
VAR_10 = response_exception(
VAR_0, &VAR_11, VAR_61, VAR_8, TRUE,
""Unknown Modbus function code: 0x%0X\n"", VAR_6);
break;
}
return (VAR_0->backend->backend_type == VAR_62 &&
VAR_5 == VAR_63) ? 0 : send_msg(VAR_0, VAR_8, VAR_10);
}",stephane/libmodbus/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc/modbus.c/vul/before/0.json,"int modbus_reply(modbus_t *ctx, const uint8_t *req,
                 int req_length, modbus_mapping_t *mb_mapping)
{
    int offset;
    int slave;
    int function;
    uint16_t address;
    uint8_t rsp[MAX_MESSAGE_LENGTH];
    int rsp_length = 0;
    sft_t sft;

    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    offset = ctx->backend->header_length;
    slave = req[offset - 1];
    function = req[offset];
    address = (req[offset + 1] << 8) + req[offset + 2];

    sft.slave = slave;
    sft.function = function;
    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);

    /* Data are flushed on illegal number of values errors. */
    switch (function) {
    case MODBUS_FC_READ_COILS:
    case MODBUS_FC_READ_DISCRETE_INPUTS: {
        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);
        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;
        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;
        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;
        const char * const name = is_input ? ""read_input_bits"" : ""read_bits"";
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        /* The mapping can be shifted to reduce memory consumption and it
           doesn't always start at address zero. */
        int mapping_address = address - start_bits;

        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                nb, name, MODBUS_MAX_READ_BITS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                mapping_address < 0 ? address : address + nb, name);
        } else {
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
            rsp_length = response_io_status(tab_bits, mapping_address, nb,
                                            rsp, rsp_length);
        }
    }
        break;
    case MODBUS_FC_READ_HOLDING_REGISTERS:
    case MODBUS_FC_READ_INPUT_REGISTERS: {
        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);
        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;
        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;
        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;
        const char * const name = is_input ? ""read_input_registers"" : ""read_registers"";
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        /* The mapping can be shifted to reduce memory consumption and it
           doesn't always start at address zero. */
        int mapping_address = address - start_registers;

        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                nb, name, MODBUS_MAX_READ_REGISTERS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                mapping_address < 0 ? address : address + nb, name);
        } else {
            int i;

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = tab_registers[i] >> 8;
                rsp[rsp_length++] = tab_registers[i] & 0xFF;
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_COIL: {
        int mapping_address = address - mb_mapping->start_bits;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_bit\n"",
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            if (data == 0xFF00 || data == 0x0) {
                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;
                memcpy(rsp, req, req_length);
                rsp_length = req_length;
            } else {
                rsp_length = response_exception(
                    ctx, &sft,
                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,
                    ""Illegal data value 0x%0X in write_bit request at address %0X\n"",
                    data, address);
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
        break;
    case MODBUS_FC_WRITE_MULTIPLE_COILS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bits = req[offset + 5];
        int mapping_address = address - mb_mapping->start_bits;

        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {
            /* May be the indication has been truncated on reading because of
             * invalid address (eg. nb is 0 but the request contains values to
             * write) so it's necessary to flush. */
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal number of values %d in write_bits (max %d)\n"",
                nb, MODBUS_MAX_WRITE_BITS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_bits\n"",
                mapping_address < 0 ? address : address + nb);
        } else {
            /* 6 = byte count */
            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,
                                       &req[offset + 6]);

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            /* 4 to copy the bit address (2) and the quantity of bits */
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
        break;
    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bytes = req[offset + 5];
        int mapping_address = address - mb_mapping->start_registers;

        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal number of values %d in write_registers (max %d)\n"",
                nb, MODBUS_MAX_WRITE_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_registers\n"",
                mapping_address < 0 ? address : address + nb);
        } else {
            int i, j;
            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {
                /* 6 and 7 = first value */
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            /* 4 to copy the address (2) and the no. of registers */
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
        break;
    case MODBUS_FC_REPORT_SLAVE_ID: {
        int str_len;
        int byte_count_pos;

        rsp_length = ctx->backend->build_response_basis(&sft, rsp);
        /* Skip byte count for now */
        byte_count_pos = rsp_length++;
        rsp[rsp_length++] = _REPORT_SLAVE_ID;
        /* Run indicator status to ON */
        rsp[rsp_length++] = 0xFF;
        /* LMB + length of LIBMODBUS_VERSION_STRING */
        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
        memcpy(rsp + rsp_length, ""LMB"" LIBMODBUS_VERSION_STRING, str_len);
        rsp_length += str_len;
        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
    }
        break;
    case MODBUS_FC_READ_EXCEPTION_STATUS:
        if (ctx->debug) {
            fprintf(stderr, ""FIXME Not implemented\n"");
        }
        errno = ENOPROTOOPT;
        return -1;
        break;
    case MODBUS_FC_MASK_WRITE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                address);
        } else {
            uint16_t data = mb_mapping->tab_registers[mapping_address];
            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];
            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];

            data = (data & and) | (or & (~and));
            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
        break;
    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
        int nb_write = (req[offset + 7] << 8) + req[offset + 8];
        int nb_write_bytes = req[offset + 9];
        int mapping_address = address - mb_mapping->start_registers;
        int mapping_address_write = address_write - mb_mapping->start_registers;

        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||
            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||
            nb_write_bytes != nb_write * 2) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"",
                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers ||
                   mapping_address < 0 ||
                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"",
                mapping_address < 0 ? address : address + nb,
                mapping_address_write < 0 ? address_write : address_write + nb_write);
        } else {
            int i, j;
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;

            /* Write first.
               10 and 11 are the offset of the first values to write */
            for (i = mapping_address_write, j = 10;
                 i < mapping_address_write + nb_write; i++, j += 2) {
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            /* and read the data for the response */
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
            }
        }
    }
        break;

    default:
        rsp_length = response_exception(
            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,
            ""Unknown Modbus function code: 0x%0X\n"", function);
        break;
    }

    /* Suppress any responses when the request was a broadcast */
    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&
            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);
}","int modbus_reply(modbus_t *VAR_0, const uint8_t *VAR_1,
                 int VAR_2, modbus_mapping_t *VAR_3)
{
    int VAR_4;
    int VAR_5;
    int VAR_6;
    uint16_t VAR_7;
    uint8_t VAR_8[VAR_9];
    int VAR_10 = 0;
    sft_t VAR_11;

    if (VAR_0 == NULL) {
        VAR_12 = VAR_13;
        return -1;
    }

    VAR_4 = VAR_0->backend->header_length;
    VAR_5 = VAR_1[VAR_4 - 1];
    VAR_6 = VAR_1[VAR_4];
    VAR_7 = (VAR_1[VAR_4 + 1] << 8) + VAR_1[VAR_4 + 2];

    VAR_11.slave = VAR_5;
    VAR_11.function = VAR_6;
    VAR_11.t_id = VAR_0->backend->prepare_response_tid(VAR_1, &VAR_2);

    /* COMMENT_0 */
    switch (VAR_6) {
    case VAR_14:
    case VAR_15: {
        unsigned int VAR_16 = (VAR_6 == VAR_15);
        int VAR_17 = VAR_16 ? VAR_3->start_input_bits : VAR_3->start_bits;
        int VAR_18 = VAR_16 ? VAR_3->nb_input_bits : VAR_3->nb_bits;
        uint8_t *VAR_19 = VAR_16 ? VAR_3->tab_input_bits : VAR_3->tab_bits;
        const char * const VAR_20 = VAR_16 ? ""read_input_bits"" : ""read_bits"";
        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
        /* COMMENT_1 */
                                                   
        int VAR_22 = VAR_7 - VAR_17;

        if (VAR_21 < 1 || VAR_23 < VAR_21) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                VAR_21, VAR_20, VAR_23);
        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_18) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11,
                VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);
        } else {
            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
            VAR_8[VAR_10++] = (VAR_21 / 8) + ((VAR_21 % 8) ? 1 : 0);
            VAR_10 = response_io_status(VAR_19, VAR_22, VAR_21,
                                            VAR_8, VAR_10);
        }
    }
        break;
    case VAR_26:
    case VAR_27: {
        unsigned int VAR_16 = (VAR_6 == VAR_27);
        int VAR_28 = VAR_16 ? VAR_3->start_input_registers : VAR_3->start_registers;
        int VAR_29 = VAR_16 ? VAR_3->nb_input_registers : VAR_3->nb_registers;
        uint16_t *VAR_30 = VAR_16 ? VAR_3->tab_input_registers : VAR_3->tab_registers;
        const char * const VAR_20 = VAR_16 ? ""read_input_registers"" : ""read_registers"";
        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
        /* COMMENT_3 */
                                                   
        int VAR_22 = VAR_7 - VAR_28;

        if (VAR_21 < 1 || VAR_31 < VAR_21) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                VAR_21, VAR_20, VAR_31);
        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_29) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);
        } else {
            int VAR_32;

            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
            VAR_8[VAR_10++] = VAR_21 << 1;
            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {
                VAR_8[VAR_10++] = VAR_30[VAR_32] >> 8;
                VAR_8[VAR_10++] = VAR_30[VAR_32] & 0xFF;
            }
        }
    }
        break;
    case VAR_33: {
        int VAR_22 = VAR_7 - VAR_3->start_bits;

        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_bits) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in write_bit\n"",
                VAR_7);
        } else {
            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];

            if (VAR_34 == 0xFF00 || VAR_34 == 0x0) {
                VAR_3->tab_bits[VAR_22] = VAR_34 ? VAR_35 : VAR_36;
                memcpy(VAR_8, VAR_1, VAR_2);
                VAR_10 = VAR_2;
            } else {
                VAR_10 = response_exception(
                    VAR_0, &VAR_11,
                    VAR_24, VAR_8, FALSE,
                    ""Illegal data value 0x%0X in write_bit request at address %0X\n"",
                    VAR_34, VAR_7);
            }
        }
    }
        break;
    case VAR_37: {
        int VAR_22 = VAR_7 - VAR_3->start_registers;

        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11,
                VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                VAR_7);
        } else {
            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];

            VAR_3->tab_registers[VAR_22] = VAR_34;
            memcpy(VAR_8, VAR_1, VAR_2);
            VAR_10 = VAR_2;
        }
    }
        break;
    case VAR_38: {
        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
        int VAR_18 = VAR_1[VAR_4 + 5];
        int VAR_22 = VAR_7 - VAR_3->start_bits;

        if (VAR_21 < 1 || VAR_39 < VAR_21 || VAR_18 * 8 < VAR_21) {
            /* COMMENT_5 */
                                                                              
                                                    
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
                ""Illegal number of values %d in write_bits (max %d)\n"",
                VAR_21, VAR_39);
        } else if (VAR_22 < 0 ||
                   (VAR_22 + VAR_21) > VAR_3->nb_bits) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11,
                VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in write_bits\n"",
                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);
        } else {
            /* COMMENT_8 */
            modbus_set_bits_from_bytes(VAR_3->tab_bits, VAR_22, VAR_21,
                                       &VAR_1[VAR_4 + 6]);

            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
            /* COMMENT_9 */
            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);
            VAR_10 += 4;
        }
    }
        break;
    case VAR_40: {
        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
        int VAR_41 = VAR_1[VAR_4 + 5];
        int VAR_22 = VAR_7 - VAR_3->start_registers;

        if (VAR_21 < 1 || VAR_42 < VAR_21 || VAR_41 * 8 < VAR_21) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
                ""Illegal number of values %d in write_registers (max %d)\n"",
                VAR_21, VAR_42);
        } else if (VAR_22 < 0 ||
                   (VAR_22 + VAR_21) > VAR_3->nb_registers) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in write_registers\n"",
                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);
        } else {
            int VAR_32, VAR_43;
            for (VAR_32 = VAR_22, VAR_43 = 6; VAR_32 < VAR_22 + VAR_21; VAR_32++, VAR_43 += 2) {
                /* COMMENT_10 */
                VAR_3->tab_registers[VAR_32] =
                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];
            }

            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
            /* COMMENT_11 */
            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);
            VAR_10 += 4;
        }
    }
        break;
    case VAR_44: {
        int VAR_45;
        int VAR_46;

        VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
        /* COMMENT_12 */
        VAR_46 = VAR_10++;
        VAR_8[VAR_10++] = VAR_47;
        /* COMMENT_13 */
        VAR_8[VAR_10++] = 0xFF;
        /* COMMENT_14 */
        VAR_45 = 3 + strlen(VAR_48);
        memcpy(VAR_8 + VAR_10, ""LMB"" VAR_48, VAR_45);
        VAR_10 += VAR_45;
        VAR_8[VAR_46] = VAR_10 - VAR_46 - 1;
    }
        break;
    case VAR_49:
        if (VAR_0->debug) {
            fprintf(VAR_50, ""FIXME Not implemented\n"");
        }
        VAR_12 = VAR_51;
        return -1;
        break;
    case VAR_52: {
        int VAR_22 = VAR_7 - VAR_3->start_registers;

        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                VAR_7);
        } else {
            uint16_t VAR_34 = VAR_3->tab_registers[VAR_22];
            uint16_t VAR_53 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
            uint16_t VAR_54 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];

            VAR_34 = (VAR_34 & VAR_53) | (VAR_54 & (~VAR_53));
            VAR_3->tab_registers[VAR_22] = VAR_34;
            memcpy(VAR_8, VAR_1, VAR_2);
            VAR_10 = VAR_2;
        }
    }
        break;
    case VAR_55: {
        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];
        uint16_t VAR_56 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];
        int VAR_57 = (VAR_1[VAR_4 + 7] << 8) + VAR_1[VAR_4 + 8];
        int VAR_58 = VAR_1[VAR_4 + 9];
        int VAR_22 = VAR_7 - VAR_3->start_registers;
        int VAR_59 = VAR_56 - VAR_3->start_registers;

        if (VAR_57 < 1 || VAR_60 < VAR_57 ||
            VAR_21 < 1 || VAR_61 < VAR_21 ||
            VAR_58 != VAR_57 * 2) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,
                ""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"",
                VAR_57, VAR_21, VAR_60, VAR_61);
        } else if (VAR_22 < 0 ||
                   (VAR_22 + VAR_21) > VAR_3->nb_registers ||
                   VAR_22 < 0 ||
                   (VAR_59 + VAR_57) > VAR_3->nb_registers) {
            VAR_10 = response_exception(
                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,
                ""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"",
                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21,
                VAR_59 < 0 ? VAR_56 : VAR_56 + VAR_57);
        } else {
            int VAR_32, VAR_43;
            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);
            VAR_8[VAR_10++] = VAR_21 << 1;

            /* COMMENT_15 */
                                                                       
            for (VAR_32 = VAR_59, VAR_43 = 10;
                 VAR_32 < VAR_59 + VAR_57; VAR_32++, VAR_43 += 2) {
                VAR_3->tab_registers[VAR_32] =
                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];
            }

            /* COMMENT_17 */
            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {
                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] >> 8;
                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] & 0xFF;
            }
        }
    }
        break;

    default:
        VAR_10 = response_exception(
            VAR_0, &VAR_11, VAR_62, VAR_8, TRUE,
            ""Unknown Modbus function code: 0x%0X\n"", VAR_6);
        break;
    }

    /* COMMENT_18 */
    return (VAR_0->backend->backend_type == VAR_63 &&
            VAR_5 == VAR_64) ? 0 : send_msg(VAR_0, VAR_8, VAR_10);
}",stephane/libmodbus/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc/modbus.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -135,9 +135,10 @@
         break;
     case MODBUS_FC_WRITE_MULTIPLE_COILS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
+        int nb_bits = req[offset + 5];
         int mapping_address = address - mb_mapping->start_bits;
 
-        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {
+        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {
             /* May be the indication has been truncated on reading because of
              * invalid address (eg. nb is 0 but the request contains values to
              * write) so it's necessary to flush. */
@@ -166,9 +167,10 @@
         break;
     case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
-        int mapping_address = address - mb_mapping->start_registers;
-
-        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {
+        int nb_bytes = req[offset + 5];
+        int mapping_address = address - mb_mapping->start_registers;
+
+        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {
             rsp_length = response_exception(
                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                 ""Illegal number of values %d in write_registers (max %d)\n"",","{'deleted_lines': ['        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {', '        int mapping_address = address - mb_mapping->start_registers;', '', '        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {'], 'added_lines': ['        int nb_bits = req[offset + 5];', '        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {', '        int nb_bytes = req[offset + 5];', '        int mapping_address = address - mb_mapping->start_registers;', '', '        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {']}",True,"An issue was discovered in libmodbus before 3.0.7 and 3.1.x before 3.1.5. There is an out-of-bounds read for the MODBUS_FC_WRITE_MULTIPLE_COILS case, aka VD-1302.",9.1,CRITICAL,3,valid,2019-07-26T14:00:06Z,2
CVE-2019-11924,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,facebookincubator/fizz,"Reject zero length handshake records.

Summary:
Zero length (all padding) handshake are forbidden by RFC. Allowing
these was a regression in D13754697 (2c6f78a).

This is a partial fix for CVE-2019-11924

Reviewed By: xybu

Differential Revision: D16285100

fbshipit-source-id: 05a19d31ad74601ce89156a0e59517aaad8dd928",6bf67137ef1ee5cd70c842b014c322b7deaf994b,https://github.com/facebookincubator/fizz/commit/6bf67137ef1ee5cd70c842b014c322b7deaf994b,fizz/record/EncryptedRecordLayer.cpp,EncryptedReadRecordLayer::read,"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
folly::IOBufQueue& buf) {
auto decryptedBuf = getDecryptedBuf(buf);
if (!decryptedBuf) {
return folly::none;
}
TLSMessage msg;
auto currentBuf = decryptedBuf->get();
bool nonZeroFound = false;
do {
currentBuf = currentBuf->prev();
size_t i = currentBuf->length();
while (i > 0 && !nonZeroFound) {
nonZeroFound = (currentBuf->data()[i - 1] != 0);
i--;
}
if (nonZeroFound) {
msg.type = static_cast<ContentType>(currentBuf->data()[i]);
}
currentBuf->trimEnd(currentBuf->length() - i);
} while (!nonZeroFound && currentBuf != decryptedBuf->get());
if (!nonZeroFound) {
throw std::runtime_error(""No content type found"");
}
msg.fragment = std::move(*decryptedBuf);
switch (msg.type) {
case ContentType::handshake:
case ContentType::alert:
case ContentType::application_data:
break;
default:
throw std::runtime_error(folly::to<std::string>(
""received encrypted content type "",
static_cast<ContentTypeType>(msg.type)));
}
if (!msg.fragment) {
if (msg.type == ContentType::application_data) {
msg.fragment = folly::IOBuf::create(0);
} else {
throw std::runtime_error(""received empty fragment"");
}
}
return msg;
}","folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
folly::IOBufQueue& VAR_0) {
auto VAR_1 = getDecryptedBuf(VAR_0);
if (!VAR_1) {
return folly::none;
}
TLSMessage VAR_2;
auto VAR_3 = VAR_1->get();
bool VAR_4 = false;
do {
VAR_3 = VAR_3->prev();
size_t VAR_5 = VAR_3->length();
while (VAR_5 > 0 && !VAR_4) {
VAR_4 = (VAR_3->data()[VAR_5 - 1] != 0);
VAR_5--;
}
if (VAR_4) {
VAR_2.type = VAR_6<ContentType>(VAR_3->data()[VAR_5]);
}
VAR_3->trimEnd(VAR_3->length() - VAR_5);
} while (!VAR_4 && VAR_3 != VAR_1->get());
if (!VAR_4) {
throw std::runtime_error(""No content type found"");
}
VAR_2.fragment = std::move(*VAR_1);
switch (VAR_2.type) {
case ContentType::handshake:
case ContentType::alert:
case ContentType::application_data:
break;
default:
throw std::runtime_error(folly::VAR_7<std::string>(
""received encrypted content type "",
VAR_6<ContentTypeType>(VAR_2.type)));
}
if (!VAR_2.fragment) {
if (VAR_2.type == ContentType::application_data) {
VAR_2.fragment = folly::IOBuf::create(0);
} else {
throw std::runtime_error(""received empty fragment"");
}
}
return VAR_2;
}",facebookincubator/fizz/6bf67137ef1ee5cd70c842b014c322b7deaf994b/EncryptedRecordLayer.cpp/vul/before/0.json,"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
    folly::IOBufQueue& buf) {
  auto decryptedBuf = getDecryptedBuf(buf);
  if (!decryptedBuf) {
    return folly::none;
  }

  TLSMessage msg;
  // Iterate over the buffers while trying to find
  // the first non-zero octet. This is much faster than
  // first iterating and then trimming.
  auto currentBuf = decryptedBuf->get();
  bool nonZeroFound = false;
  do {
    currentBuf = currentBuf->prev();
    size_t i = currentBuf->length();
    while (i > 0 && !nonZeroFound) {
      nonZeroFound = (currentBuf->data()[i - 1] != 0);
      i--;
    }
    if (nonZeroFound) {
      msg.type = static_cast<ContentType>(currentBuf->data()[i]);
    }
    currentBuf->trimEnd(currentBuf->length() - i);
  } while (!nonZeroFound && currentBuf != decryptedBuf->get());
  if (!nonZeroFound) {
    throw std::runtime_error(""No content type found"");
  }
  msg.fragment = std::move(*decryptedBuf);

  switch (msg.type) {
    case ContentType::handshake:
    case ContentType::alert:
    case ContentType::application_data:
      break;
    default:
      throw std::runtime_error(folly::to<std::string>(
          ""received encrypted content type "",
          static_cast<ContentTypeType>(msg.type)));
  }

  if (!msg.fragment || msg.fragment->empty()) {
    if (msg.type == ContentType::application_data) {
      msg.fragment = folly::IOBuf::create(0);
    } else {
      throw std::runtime_error(""received empty fragment"");
    }
  }

  return msg;
}","folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
    folly::IOBufQueue& VAR_0) {
  auto VAR_1 = getDecryptedBuf(VAR_0);
  if (!VAR_1) {
    return folly::none;
  }

  TLSMessage VAR_2;
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  auto VAR_3 = VAR_1->get();
  bool VAR_4 = false;
  do {
    VAR_3 = VAR_3->prev();
    size_t VAR_5 = VAR_3->length();
    while (VAR_5 > 0 && !VAR_4) {
      VAR_4 = (VAR_3->data()[VAR_5 - 1] != 0);
      VAR_5--;
    }
    if (VAR_4) {
      VAR_2.type = VAR_6<ContentType>(VAR_3->data()[VAR_5]);
    }
    VAR_3->trimEnd(VAR_3->length() - VAR_5);
  } while (!VAR_4 && VAR_3 != VAR_1->get());
  if (!VAR_4) {
    throw std::runtime_error(""No content type found"");
  }
  VAR_2.fragment = std::move(*VAR_1);

  switch (VAR_2.type) {
    case ContentType::handshake:
    case ContentType::alert:
    case ContentType::application_data:
      break;
    default:
      throw std::runtime_error(folly::VAR_7<std::string>(
          ""received encrypted content type "",
          VAR_6<ContentTypeType>(VAR_2.type)));
  }

  if (!VAR_2.fragment || VAR_2.fragment->empty()) {
    if (VAR_2.type == ContentType::application_data) {
      VAR_2.fragment = folly::IOBuf::create(0);
    } else {
      throw std::runtime_error(""received empty fragment"");
    }
  }

  return VAR_2;
}",facebookincubator/fizz/6bf67137ef1ee5cd70c842b014c322b7deaf994b/EncryptedRecordLayer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,7 +39,7 @@
           static_cast<ContentTypeType>(msg.type)));
   }
 
-  if (!msg.fragment) {
+  if (!msg.fragment || msg.fragment->empty()) {
     if (msg.type == ContentType::application_data) {
       msg.fragment = folly::IOBuf::create(0);
     } else {","{'deleted_lines': ['  if (!msg.fragment) {'], 'added_lines': ['  if (!msg.fragment || msg.fragment->empty()) {']}",True,"A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",7.5,HIGH,2,valid,2019-08-08T18:38:29Z,2
CVE-2019-11924,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,facebookincubator/fizz,"Coalesce handshake buffers

Summary:
It is possible that a peer might send us records in a manner such
that there is a 16KB record and only 1 byte of handshake message in
each record. Since we normally just trim the IOBuf, we would end up
holding 16K of data per actual byte of data. To prevent this we allocate a contiguous
buffer to copy over these bytes for handshake messages for now.

This is a partial fix for CVE-2019-11924

Reviewed By: ngoyal

Differential Revision: D16478044

fbshipit-source-id: 464bc68eaefda065d9a327818100427377293fbd",3eaddb33619eaaf74a760872850c550ad8f5c52f,https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f,fizz/record/EncryptedRecordLayer.cpp,EncryptedReadRecordLayer::read,"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
folly::IOBufQueue& buf) {
auto decryptedBuf = getDecryptedBuf(buf);
if (!decryptedBuf) {
return folly::none;
}
TLSMessage msg;
auto currentBuf = decryptedBuf->get();
bool nonZeroFound = false;
do {
currentBuf = currentBuf->prev();
size_t i = currentBuf->length();
while (i > 0 && !nonZeroFound) {
nonZeroFound = (currentBuf->data()[i - 1] != 0);
i--;
}
if (nonZeroFound) {
msg.type = static_cast<ContentType>(currentBuf->data()[i]);
}
currentBuf->trimEnd(currentBuf->length() - i);
} while (!nonZeroFound && currentBuf != decryptedBuf->get());
if (!nonZeroFound) {
throw std::runtime_error(""No content type found"");
}
msg.fragment = std::move(*decryptedBuf);
switch (msg.type) {
case ContentType::handshake:
case ContentType::alert:
case ContentType::application_data:
break;
default:
throw std::runtime_error(folly::to<std::string>(
""received encrypted content type "",
static_cast<ContentTypeType>(msg.type)));
}
if (!msg.fragment || msg.fragment->empty()) {
if (msg.type == ContentType::application_data) {
msg.fragment = folly::IOBuf::create(0);
} else {
throw std::runtime_error(""received empty fragment"");
}
}
return msg;
}","folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
folly::IOBufQueue& VAR_0) {
auto VAR_1 = getDecryptedBuf(VAR_0);
if (!VAR_1) {
return folly::none;
}
TLSMessage VAR_2;
auto VAR_3 = VAR_1->get();
bool VAR_4 = false;
do {
VAR_3 = VAR_3->prev();
size_t VAR_5 = VAR_3->length();
while (VAR_5 > 0 && !VAR_4) {
VAR_4 = (VAR_3->data()[VAR_5 - 1] != 0);
VAR_5--;
}
if (VAR_4) {
VAR_2.type = VAR_6<ContentType>(VAR_3->data()[VAR_5]);
}
VAR_3->trimEnd(VAR_3->length() - VAR_5);
} while (!VAR_4 && VAR_3 != VAR_1->get());
if (!VAR_4) {
throw std::runtime_error(""No content type found"");
}
VAR_2.fragment = std::move(*VAR_1);
switch (VAR_2.type) {
case ContentType::handshake:
case ContentType::alert:
case ContentType::application_data:
break;
default:
throw std::runtime_error(folly::VAR_7<std::string>(
""received encrypted content type "",
VAR_6<ContentTypeType>(VAR_2.type)));
}
if (!VAR_2.fragment || VAR_2.fragment->empty()) {
if (VAR_2.type == ContentType::application_data) {
VAR_2.fragment = folly::IOBuf::create(0);
} else {
throw std::runtime_error(""received empty fragment"");
}
}
return VAR_2;
}",facebookincubator/fizz/3eaddb33619eaaf74a760872850c550ad8f5c52f/EncryptedRecordLayer.cpp/vul/before/0.json,"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
    folly::IOBufQueue& buf) {
  auto decryptedBuf = getDecryptedBuf(buf);
  if (!decryptedBuf) {
    return folly::none;
  }

  TLSMessage msg{};
  // Iterate over the buffers while trying to find
  // the first non-zero octet. This is much faster than
  // first iterating and then trimming.
  auto currentBuf = decryptedBuf->get();
  bool nonZeroFound = false;
  do {
    currentBuf = currentBuf->prev();
    size_t i = currentBuf->length();
    while (i > 0 && !nonZeroFound) {
      nonZeroFound = (currentBuf->data()[i - 1] != 0);
      i--;
    }
    if (nonZeroFound) {
      msg.type = static_cast<ContentType>(currentBuf->data()[i]);
    }
    currentBuf->trimEnd(currentBuf->length() - i);
  } while (!nonZeroFound && currentBuf != decryptedBuf->get());
  if (!nonZeroFound) {
    throw std::runtime_error(""No content type found"");
  }
  msg.fragment = std::move(*decryptedBuf);

  switch (msg.type) {
    case ContentType::handshake:
    case ContentType::alert:
    case ContentType::application_data:
      break;
    default:
      throw std::runtime_error(folly::to<std::string>(
          ""received encrypted content type "",
          static_cast<ContentTypeType>(msg.type)));
  }

  if (!msg.fragment || msg.fragment->empty()) {
    if (msg.type == ContentType::application_data) {
      msg.fragment = folly::IOBuf::create(0);
    } else {
      throw std::runtime_error(""received empty fragment"");
    }
  }

  return msg;
}","folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
    folly::IOBufQueue& VAR_0) {
  auto VAR_1 = getDecryptedBuf(VAR_0);
  if (!VAR_1) {
    return folly::none;
  }

  TLSMessage VAR_2{};
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  auto VAR_3 = VAR_1->get();
  bool VAR_4 = false;
  do {
    VAR_3 = VAR_3->prev();
    size_t VAR_5 = VAR_3->length();
    while (VAR_5 > 0 && !VAR_4) {
      VAR_4 = (VAR_3->data()[VAR_5 - 1] != 0);
      VAR_5--;
    }
    if (VAR_4) {
      VAR_2.type = VAR_6<ContentType>(VAR_3->data()[VAR_5]);
    }
    VAR_3->trimEnd(VAR_3->length() - VAR_5);
  } while (!VAR_4 && VAR_3 != VAR_1->get());
  if (!VAR_4) {
    throw std::runtime_error(""No content type found"");
  }
  VAR_2.fragment = std::move(*VAR_1);

  switch (VAR_2.type) {
    case ContentType::handshake:
    case ContentType::alert:
    case ContentType::application_data:
      break;
    default:
      throw std::runtime_error(folly::VAR_7<std::string>(
          ""received encrypted content type "",
          VAR_6<ContentTypeType>(VAR_2.type)));
  }

  if (!VAR_2.fragment || VAR_2.fragment->empty()) {
    if (VAR_2.type == ContentType::application_data) {
      VAR_2.fragment = folly::IOBuf::create(0);
    } else {
      throw std::runtime_error(""received empty fragment"");
    }
  }

  return VAR_2;
}",facebookincubator/fizz/3eaddb33619eaaf74a760872850c550ad8f5c52f/EncryptedRecordLayer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     return folly::none;
   }
 
-  TLSMessage msg;
+  TLSMessage msg{};
   // Iterate over the buffers while trying to find
   // the first non-zero octet. This is much faster than
   // first iterating and then trimming.","{'deleted_lines': ['  TLSMessage msg;'], 'added_lines': ['  TLSMessage msg{};']}",True,"A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",7.5,HIGH,2,valid,2019-08-08T18:38:29Z,2
CVE-2019-11924,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,facebookincubator/fizz,"Coalesce handshake buffers

Summary:
It is possible that a peer might send us records in a manner such
that there is a 16KB record and only 1 byte of handshake message in
each record. Since we normally just trim the IOBuf, we would end up
holding 16K of data per actual byte of data. To prevent this we allocate a contiguous
buffer to copy over these bytes for handshake messages for now.

This is a partial fix for CVE-2019-11924

Reviewed By: ngoyal

Differential Revision: D16478044

fbshipit-source-id: 464bc68eaefda065d9a327818100427377293fbd",3eaddb33619eaaf74a760872850c550ad8f5c52f,https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f,fizz/record/RecordLayer.cpp,ReadRecordLayer::readEvent,"folly::Optional<Param> ReadRecordLayer::readEvent(
folly::IOBufQueue& socketBuf) {
if (!unparsedHandshakeData_.empty()) {
auto param = decodeHandshakeMessage(unparsedHandshakeData_);
if (param) {
VLOG(8) << ""Received handshake message ""
<< toString(boost::apply_visitor(EventVisitor(), *param));
return param;
}
}
while (true) {
auto message = read(socketBuf);
if (!message) {
return folly::none;
}
if (!unparsedHandshakeData_.empty() &&
message->type != ContentType::handshake) {
throw std::runtime_error(""spliced handshake data"");
}
switch (message->type) {
case ContentType::alert: {
auto alert = decode<Alert>(std::move(message->fragment));
if (alert.description == AlertDescription::close_notify) {
return Param(CloseNotify(socketBuf.move()));
} else {
return Param(std::move(alert));
}
}
case ContentType::handshake: {
unparsedHandshakeData_.append(std::move(message->fragment));
auto param = decodeHandshakeMessage(unparsedHandshakeData_);
if (param) {
VLOG(8) << ""Received handshake message ""
<< toString(boost::apply_visitor(EventVisitor(), *param));
return param;
} else {
continue;
}
}
case ContentType::application_data:
return Param(AppData(std::move(message->fragment)));
default:
throw std::runtime_error(""unknown content type"");
}
}
}","folly::Optional<Param> ReadRecordLayer::readEvent(
folly::IOBufQueue& VAR_0) {
if (!VAR_1.empty()) {
auto VAR_2 = decodeHandshakeMessage(VAR_1);
if (VAR_2) {
VLOG(8) << ""Received handshake message ""
<< toString(boost::apply_visitor(EventVisitor(), *VAR_2));
return VAR_2;
}
}
while (true) {
auto VAR_3 = read(VAR_0);
if (!VAR_3) {
return folly::none;
}
if (!VAR_1.empty() &&
VAR_3->type != ContentType::handshake) {
throw std::runtime_error(""spliced handshake data"");
}
switch (VAR_3->type) {
case ContentType::alert: {
auto VAR_4 = VAR_5<Alert>(std::move(VAR_3->fragment));
if (VAR_4.description == AlertDescription::close_notify) {
return Param(CloseNotify(VAR_0.move()));
} else {
return Param(std::move(VAR_4));
}
}
case ContentType::handshake: {
VAR_1.append(std::move(VAR_3->fragment));
auto VAR_2 = decodeHandshakeMessage(VAR_1);
if (VAR_2) {
VLOG(8) << ""Received handshake message ""
<< toString(boost::apply_visitor(EventVisitor(), *VAR_2));
return VAR_2;
} else {
continue;
}
}
case ContentType::application_data:
return Param(AppData(std::move(VAR_3->fragment)));
default:
throw std::runtime_error(""unknown content type"");
}
}
}",facebookincubator/fizz/3eaddb33619eaaf74a760872850c550ad8f5c52f/RecordLayer.cpp/vul/before/0.json,"folly::Optional<Param> ReadRecordLayer::readEvent(
    folly::IOBufQueue& socketBuf) {
  if (!unparsedHandshakeData_.empty()) {
    auto param = decodeHandshakeMessage(unparsedHandshakeData_);
    if (param) {
      VLOG(8) << ""Received handshake message ""
              << toString(boost::apply_visitor(EventVisitor(), *param));
      return param;
    }
  }

  while (true) {
    // Read one record. We read one record at a time since records could cause
    // a change in the record layer.
    auto message = read(socketBuf);
    if (!message) {
      return folly::none;
    }

    if (!unparsedHandshakeData_.empty() &&
        message->type != ContentType::handshake) {
      throw std::runtime_error(""spliced handshake data"");
    }

    switch (message->type) {
      case ContentType::alert: {
        auto alert = decode<Alert>(std::move(message->fragment));
        if (alert.description == AlertDescription::close_notify) {
          return Param(CloseNotify(socketBuf.move()));
        } else {
          return Param(std::move(alert));
        }
      }
      case ContentType::handshake: {
        std::unique_ptr<folly::IOBuf> handshakeMessage =
            unparsedHandshakeData_.move();
        // It is possible that a peer might send us records in a manner such
        // that there is a 16KB record and only 1 byte of handshake message in
        // each record. Since we normally just trim the IOBuf, we would end up
        // holding 16K of data. To prevent this we allocate a contiguous
        // buffer to copy over these bytes. We supply kExtraAlloc bytes in
        // order to avoid needing to re-allocate a lot of times if we receive
        // a lot of small messages. There might be more optimal reallocation
        // policies, but this should be fine.
        message->fragment->coalesce();
        constexpr size_t kExtraAlloc = 1024;
        if (!handshakeMessage) {
          handshakeMessage =
              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);
        } else if (handshakeMessage->tailroom() < message->fragment->length()) {
          handshakeMessage->reserve(
              0, message->fragment->length() + kExtraAlloc);
        }
        memcpy(
            handshakeMessage->writableTail(),
            message->fragment->data(),
            message->fragment->length());
        handshakeMessage->append(message->fragment->length());
        unparsedHandshakeData_.append(std::move(handshakeMessage));
        auto param = decodeHandshakeMessage(unparsedHandshakeData_);
        if (param) {
          VLOG(8) << ""Received handshake message ""
                  << toString(boost::apply_visitor(EventVisitor(), *param));
          return param;
        } else {
          // If we read handshake data but didn't have enough to get a full
          // message we immediately try to read another record.
          // TODO: add limits on number of records we buffer
          continue;
        }
      }
      case ContentType::application_data:
        return Param(AppData(std::move(message->fragment)));
      default:
        throw std::runtime_error(""unknown content type"");
    }
  }
}","folly::Optional<Param> ReadRecordLayer::readEvent(
    folly::IOBufQueue& VAR_0) {
  if (!VAR_1.empty()) {
    auto VAR_2 = decodeHandshakeMessage(VAR_1);
    if (VAR_2) {
      VLOG(8) << ""Received handshake message ""
              << toString(boost::apply_visitor(EventVisitor(), *VAR_2));
      return VAR_2;
    }
  }

  while (true) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    auto VAR_3 = read(VAR_0);
    if (!VAR_3) {
      return folly::none;
    }

    if (!VAR_1.empty() &&
        VAR_3->type != ContentType::handshake) {
      throw std::runtime_error(""spliced handshake data"");
    }

    switch (VAR_3->type) {
      case ContentType::alert: {
        auto VAR_4 = VAR_5<Alert>(std::move(VAR_3->fragment));
        if (VAR_4.description == AlertDescription::close_notify) {
          return Param(CloseNotify(VAR_0.move()));
        } else {
          return Param(std::move(VAR_4));
        }
      }
      case ContentType::handshake: {
        std::unique_ptr<folly::IOBuf> VAR_6 =
            VAR_1.move();
        /* COMMENT_2 */
        /* COMMENT_3 */
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        /* COMMENT_7 */
        /* COMMENT_8 */
        /* COMMENT_9 */
        VAR_3->fragment->coalesce();
        constexpr size_t VAR_7 = 1024;
        if (!VAR_6) {
          VAR_6 =
              folly::IOBuf::create(VAR_3->fragment->length() + VAR_7);
        } else if (VAR_6->tailroom() < VAR_3->fragment->length()) {
          VAR_6->reserve(
              0, VAR_3->fragment->length() + VAR_7);
        }
        memcpy(
            VAR_6->writableTail(),
            VAR_3->fragment->data(),
            VAR_3->fragment->length());
        VAR_6->append(VAR_3->fragment->length());
        VAR_1.append(std::move(VAR_6));
        auto VAR_2 = decodeHandshakeMessage(VAR_1);
        if (VAR_2) {
          VLOG(8) << ""Received handshake message ""
                  << toString(boost::apply_visitor(EventVisitor(), *VAR_2));
          return VAR_2;
        } else {
          /* COMMENT_10 */
          /* COMMENT_11 */
          /* COMMENT_12 */
          continue;
        }
      }
      case ContentType::application_data:
        return Param(AppData(std::move(VAR_3->fragment)));
      default:
        throw std::runtime_error(""unknown content type"");
    }
  }
}",facebookincubator/fizz/3eaddb33619eaaf74a760872850c550ad8f5c52f/RecordLayer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,7 +32,31 @@
         }
       }
       case ContentType::handshake: {
-        unparsedHandshakeData_.append(std::move(message->fragment));
+        std::unique_ptr<folly::IOBuf> handshakeMessage =
+            unparsedHandshakeData_.move();
+        // It is possible that a peer might send us records in a manner such
+        // that there is a 16KB record and only 1 byte of handshake message in
+        // each record. Since we normally just trim the IOBuf, we would end up
+        // holding 16K of data. To prevent this we allocate a contiguous
+        // buffer to copy over these bytes. We supply kExtraAlloc bytes in
+        // order to avoid needing to re-allocate a lot of times if we receive
+        // a lot of small messages. There might be more optimal reallocation
+        // policies, but this should be fine.
+        message->fragment->coalesce();
+        constexpr size_t kExtraAlloc = 1024;
+        if (!handshakeMessage) {
+          handshakeMessage =
+              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);
+        } else if (handshakeMessage->tailroom() < message->fragment->length()) {
+          handshakeMessage->reserve(
+              0, message->fragment->length() + kExtraAlloc);
+        }
+        memcpy(
+            handshakeMessage->writableTail(),
+            message->fragment->data(),
+            message->fragment->length());
+        handshakeMessage->append(message->fragment->length());
+        unparsedHandshakeData_.append(std::move(handshakeMessage));
         auto param = decodeHandshakeMessage(unparsedHandshakeData_);
         if (param) {
           VLOG(8) << ""Received handshake message ""","{'deleted_lines': ['        unparsedHandshakeData_.append(std::move(message->fragment));'], 'added_lines': ['        std::unique_ptr<folly::IOBuf> handshakeMessage =', '            unparsedHandshakeData_.move();', '        // It is possible that a peer might send us records in a manner such', '        // that there is a 16KB record and only 1 byte of handshake message in', '        // each record. Since we normally just trim the IOBuf, we would end up', '        // holding 16K of data. To prevent this we allocate a contiguous', '        // buffer to copy over these bytes. We supply kExtraAlloc bytes in', '        // order to avoid needing to re-allocate a lot of times if we receive', '        // a lot of small messages. There might be more optimal reallocation', '        // policies, but this should be fine.', '        message->fragment->coalesce();', '        constexpr size_t kExtraAlloc = 1024;', '        if (!handshakeMessage) {', '          handshakeMessage =', '              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);', '        } else if (handshakeMessage->tailroom() < message->fragment->length()) {', '          handshakeMessage->reserve(', '              0, message->fragment->length() + kExtraAlloc);', '        }', '        memcpy(', '            handshakeMessage->writableTail(),', '            message->fragment->data(),', '            message->fragment->length());', '        handshakeMessage->append(message->fragment->length());', '        unparsedHandshakeData_.append(std::move(handshakeMessage));']}",True,"A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",7.5,HIGH,2,valid,2019-08-08T18:38:29Z,2
CVE-2019-11932,['CWE-415'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,koral--/android-gif-drawable,"Do not realloc array if new raster size is 0.

if realloc() is called with 0 size it may return NULL and this will be incorrectly handled
as not enough memory and (also) rasterBits will be freed by realloc but we will not update
it.",4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9,https://github.com/koral--/android-gif-drawable/commit/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9,android-gif-drawable/src/main/c/decoding.c,DDGifSlurp,"void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {
GifRecordType RecordType;
GifByteType *ExtData;
int ExtFunction;
GifFileType *gifFilePtr;
gifFilePtr = info->gifFilePtr;
uint_fast32_t lastAllocatedGCBIndex = 0;
do {
if (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {
break;
}
bool isInitialPass = !decode && !exitAfterFrame;
switch (RecordType) {
case IMAGE_DESC_RECORD_TYPE:
if (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {
break;
}
if (isInitialPass) {
int_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;
int_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;
if (widthOverflow > 0 || heightOverflow > 0) {
gifFilePtr->SWidth += widthOverflow;
gifFilePtr->SHeight += heightOverflow;
}
SavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];
int_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;
if (topOverflow > 0) {
sp->ImageDesc.Top -= topOverflow;
}
int_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;
if (leftOverflow > 0) {
sp->ImageDesc.Left -= leftOverflow;
}
if (!updateGCB(info, &lastAllocatedGCBIndex)) {
break;
}
}
if (decode) {
int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;
const uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;
if (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {
void *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));
if (tmpRasterBits == NULL) {
gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
break;
}
info->rasterBits = tmpRasterBits;
info->rasterSize = newRasterSize;
}
if (gifFilePtr->Image.Interlace) {
uint_fast16_t i, j;
uint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};
uint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};
for (i = 0; i < 4; i++)
for (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {
if (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)
break;
}
} else {
if (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {
break;
}
}
if (info->sampleSize > 1) {
unsigned char *dst = info->rasterBits;
unsigned char *src = info->rasterBits;
unsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;
do {
unsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;
unsigned char *const srcEndLine = src + gifFilePtr->Image.Width;
unsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;
do {
*dst = *src;
dst++;
src += info->sampleSize;
} while (src < srcEndLine);
dst = dstEndLine;
src = srcNextLineStart;
} while (src < srcEndImage);
}
return;
} else {
do {
if (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {
break;
}
} while (ExtData != NULL);
if (exitAfterFrame) {
return;
}
}
break;
case EXTENSION_RECORD_TYPE:
if (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {
break;
}
if (isInitialPass) {
updateGCB(info, &lastAllocatedGCBIndex);
if (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {
break;
}
}
while (ExtData != NULL) {
if (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {
break;
}
if (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {
break;
}
}
break;
case TERMINATE_RECORD_TYPE:
break;
default: 
break;
}
} while (RecordType != TERMINATE_RECORD_TYPE);
info->rewindFunction(info);
}","void DDGifSlurp(GifInfo *VAR_0, bool VAR_1, bool VAR_2) {
GifRecordType VAR_3;
GifByteType *VAR_4;
int VAR_5;
GifFileType *VAR_6;
VAR_6 = VAR_0->gifFilePtr;
uint_fast32_t VAR_7 = 0;
do {
if (DGifGetRecordType(VAR_6, &VAR_3) == VAR_8) {
break;
}
bool VAR_9 = !VAR_1 && !VAR_2;
switch (VAR_3) {
case VAR_10:
if (DGifGetImageDesc(VAR_6, VAR_9) == VAR_8) {
break;
}
if (VAR_9) {
int_fast32_t VAR_11 = VAR_6->Image.Width - VAR_6->SWidth;
int_fast32_t VAR_12 = VAR_6->Image.Height - VAR_6->SHeight;
if (VAR_11 > 0 || VAR_12 > 0) {
VAR_6->SWidth += VAR_11;
VAR_6->SHeight += VAR_12;
}
SavedImage *VAR_13 = &VAR_6->SavedImages[VAR_6->ImageCount - 1];
int_fast32_t VAR_14 = VAR_6->Image.Top + VAR_6->Image.Height - VAR_6->SHeight;
if (VAR_14 > 0) {
VAR_13->ImageDesc.Top -= VAR_14;
}
int_fast32_t VAR_15 = VAR_6->Image.Left + VAR_6->Image.Width - VAR_6->SWidth;
if (VAR_15 > 0) {
VAR_13->ImageDesc.Left -= VAR_15;
}
if (!updateGCB(VAR_0, &VAR_7)) {
break;
}
}
if (VAR_1) {
int_fast32_t VAR_11 = VAR_6->Image.Width - VAR_0->originalWidth;
int_fast32_t VAR_12 = VAR_6->Image.Height - VAR_0->originalHeight;
const uint_fast32_t VAR_16 = VAR_6->Image.Width * VAR_6->Image.Height;
if (VAR_16 > VAR_0->rasterSize || VAR_11 > 0 || VAR_12 > 0) {
void *VAR_17 = reallocarray(VAR_0->rasterBits, VAR_16, sizeof(VAR_18));
if (VAR_17 == NULL) {
VAR_6->Error = VAR_19;
break;
}
VAR_0->rasterBits = VAR_17;
VAR_0->rasterSize = VAR_16;
}
if (VAR_6->Image.Interlace) {
uint_fast16_t VAR_20, VAR_21;
uint_fast8_t VAR_22[] = {0, 4, 2, 1};
uint_fast8_t VAR_23[] = {8, 8, 4, 2};
for (VAR_20 = 0; VAR_20 < 4; VAR_20++)
for (VAR_21 = VAR_22[VAR_20]; VAR_21 < VAR_6->Image.Height; VAR_21 += VAR_23[VAR_20]) {
if (DGifGetLine(VAR_6, VAR_0->rasterBits + VAR_21 * VAR_6->Image.Width, VAR_6->Image.Width) == VAR_8)
break;
}
} else {
if (DGifGetLine(VAR_6, VAR_0->rasterBits, VAR_6->Image.Width * VAR_6->Image.Height) == VAR_8) {
break;
}
}
if (VAR_0->sampleSize > 1) {
unsigned char *VAR_24 = VAR_0->rasterBits;
unsigned char *VAR_25 = VAR_0->rasterBits;
unsigned char *const VAR_26 = VAR_0->rasterBits + VAR_6->Image.Width * VAR_6->Image.Height;
do {
unsigned char *VAR_27 = VAR_25 + VAR_6->Image.Width * VAR_0->sampleSize;
unsigned char *const VAR_28 = VAR_25 + VAR_6->Image.Width;
unsigned char *VAR_29 = VAR_24 + VAR_6->Image.Width / VAR_0->sampleSize;
do {
*VAR_24 = *VAR_25;
VAR_24++;
VAR_25 += VAR_0->sampleSize;
} while (VAR_25 < VAR_28);
VAR_24 = VAR_29;
VAR_25 = VAR_27;
} while (VAR_25 < VAR_26);
}
return;
} else {
do {
if (DGifGetCodeNext(VAR_6, &VAR_4) == VAR_8) {
break;
}
} while (VAR_4 != NULL);
if (VAR_2) {
return;
}
}
break;
case VAR_30:
if (DGifGetExtension(VAR_6, &VAR_5, &VAR_4) == VAR_8) {
break;
}
if (VAR_9) {
updateGCB(VAR_0, &VAR_7);
if (readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {
break;
}
}
while (VAR_4 != NULL) {
if (DGifGetExtensionNext(VAR_6, &VAR_4) == VAR_8) {
break;
}
if (VAR_9 && readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {
break;
}
}
break;
case VAR_31:
break;
default: 
break;
}
} while (VAR_3 != VAR_31);
VAR_0->rewindFunction(VAR_0);
}",koral--/android-gif-drawable/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9/decoding.c/vul/before/0.json,"void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {
	GifRecordType RecordType;
	GifByteType *ExtData;
	int ExtFunction;
	GifFileType *gifFilePtr;
	gifFilePtr = info->gifFilePtr;
	uint_fast32_t lastAllocatedGCBIndex = 0;
	do {
		if (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {
			break;
		}
		bool isInitialPass = !decode && !exitAfterFrame;
		switch (RecordType) {
			case IMAGE_DESC_RECORD_TYPE:

				if (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {
					break;
				}

				if (isInitialPass) {
					int_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;
					int_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;
					if (widthOverflow > 0 || heightOverflow > 0) {
						gifFilePtr->SWidth += widthOverflow;
						gifFilePtr->SHeight += heightOverflow;
					}
					SavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];
					int_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;
					if (topOverflow > 0) {
						sp->ImageDesc.Top -= topOverflow;
					}

					int_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;
					if (leftOverflow > 0) {
						sp->ImageDesc.Left -= leftOverflow;
					}
					if (!updateGCB(info, &lastAllocatedGCBIndex)) {
						break;
					}
				}

				if (decode) {
					const uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;
					if (newRasterSize == 0) {
						free(info->rasterBits);
						info->rasterBits = NULL;
						info->rasterSize = newRasterSize;
						return;
					}
					const int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
					const int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;
					if (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {
						void *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));
						if (tmpRasterBits == NULL) {
							gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
							break;
						}
						info->rasterBits = tmpRasterBits;
						info->rasterSize = newRasterSize;
					}
					if (gifFilePtr->Image.Interlace) {
						uint_fast16_t i, j;
						/*
						 * The way an interlaced image should be read -
						 * offsets and jumps...
						 */
						uint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};
						uint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};
						/* Need to perform 4 passes on the image */
						for (i = 0; i < 4; i++)
							for (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {
								if (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)
									break;
							}
					} else {
						if (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {
							break;
						}
					}

					if (info->sampleSize > 1) {
						unsigned char *dst = info->rasterBits;
						unsigned char *src = info->rasterBits;
						unsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;
						do {
							unsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;
							unsigned char *const srcEndLine = src + gifFilePtr->Image.Width;
							unsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;
							do {
								*dst = *src;
								dst++;
								src += info->sampleSize;
							} while (src < srcEndLine);
							dst = dstEndLine;
							src = srcNextLineStart;
						} while (src < srcEndImage);
					}
					return;
				} else {
					do {
						if (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {
							break;
						}
					} while (ExtData != NULL);
					if (exitAfterFrame) {
						return;
					}
				}
				break;

			case EXTENSION_RECORD_TYPE:
				if (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {
					break;
				}
				if (isInitialPass) {
					updateGCB(info, &lastAllocatedGCBIndex);
					if (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {
						break;
					}
				}
				while (ExtData != NULL) {
					if (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {
						break;
					}
					if (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {
						break;
					}
				}
				break;

			case TERMINATE_RECORD_TYPE:
				break;

			default: /* Should be trapped by DGifGetRecordType */
				break;
		}
	} while (RecordType != TERMINATE_RECORD_TYPE);

	info->rewindFunction(info);
}","void DDGifSlurp(GifInfo *VAR_0, bool VAR_1, bool VAR_2) {
	GifRecordType VAR_3;
	GifByteType *VAR_4;
	int VAR_5;
	GifFileType *VAR_6;
	VAR_6 = VAR_0->gifFilePtr;
	uint_fast32_t VAR_7 = 0;
	do {
		if (DGifGetRecordType(VAR_6, &VAR_3) == VAR_8) {
			break;
		}
		bool VAR_9 = !VAR_1 && !VAR_2;
		switch (VAR_3) {
			case VAR_10:

				if (DGifGetImageDesc(VAR_6, VAR_9) == VAR_8) {
					break;
				}

				if (VAR_9) {
					int_fast32_t VAR_11 = VAR_6->Image.Width - VAR_6->SWidth;
					int_fast32_t VAR_12 = VAR_6->Image.Height - VAR_6->SHeight;
					if (VAR_11 > 0 || VAR_12 > 0) {
						VAR_6->SWidth += VAR_11;
						VAR_6->SHeight += VAR_12;
					}
					SavedImage *VAR_13 = &VAR_6->SavedImages[VAR_6->ImageCount - 1];
					int_fast32_t VAR_14 = VAR_6->Image.Top + VAR_6->Image.Height - VAR_6->SHeight;
					if (VAR_14 > 0) {
						VAR_13->ImageDesc.Top -= VAR_14;
					}

					int_fast32_t VAR_15 = VAR_6->Image.Left + VAR_6->Image.Width - VAR_6->SWidth;
					if (VAR_15 > 0) {
						VAR_13->ImageDesc.Left -= VAR_15;
					}
					if (!updateGCB(VAR_0, &VAR_7)) {
						break;
					}
				}

				if (VAR_1) {
					const uint_fast32_t VAR_16 = VAR_6->Image.Width * VAR_6->Image.Height;
					if (VAR_16 == 0) {
						free(VAR_0->rasterBits);
						VAR_0->rasterBits = NULL;
						VAR_0->rasterSize = VAR_16;
						return;
					}
					const int_fast32_t VAR_11 = VAR_6->Image.Width - VAR_0->originalWidth;
					const int_fast32_t VAR_12 = VAR_6->Image.Height - VAR_0->originalHeight;
					if (VAR_16 > VAR_0->rasterSize || VAR_11 > 0 || VAR_12 > 0) {
						void *VAR_17 = reallocarray(VAR_0->rasterBits, VAR_16, sizeof(VAR_18));
						if (VAR_17 == NULL) {
							VAR_6->Error = VAR_19;
							break;
						}
						VAR_0->rasterBits = VAR_17;
						VAR_0->rasterSize = VAR_16;
					}
					if (VAR_6->Image.Interlace) {
						uint_fast16_t VAR_20, VAR_21;
						/* COMMENT_0 */
                                                     
                             
         
						uint_fast8_t VAR_22[] = {0, 4, 2, 1};
						uint_fast8_t VAR_23[] = {8, 8, 4, 2};
						/* COMMENT_4 */
						for (VAR_20 = 0; VAR_20 < 4; VAR_20++)
							for (VAR_21 = VAR_22[VAR_20]; VAR_21 < VAR_6->Image.Height; VAR_21 += VAR_23[VAR_20]) {
								if (DGifGetLine(VAR_6, VAR_0->rasterBits + VAR_21 * VAR_6->Image.Width, VAR_6->Image.Width) == VAR_8)
									break;
							}
					} else {
						if (DGifGetLine(VAR_6, VAR_0->rasterBits, VAR_6->Image.Width * VAR_6->Image.Height) == VAR_8) {
							break;
						}
					}

					if (VAR_0->sampleSize > 1) {
						unsigned char *VAR_24 = VAR_0->rasterBits;
						unsigned char *VAR_25 = VAR_0->rasterBits;
						unsigned char *const VAR_26 = VAR_0->rasterBits + VAR_6->Image.Width * VAR_6->Image.Height;
						do {
							unsigned char *VAR_27 = VAR_25 + VAR_6->Image.Width * VAR_0->sampleSize;
							unsigned char *const VAR_28 = VAR_25 + VAR_6->Image.Width;
							unsigned char *VAR_29 = VAR_24 + VAR_6->Image.Width / VAR_0->sampleSize;
							do {
								*VAR_24 = *VAR_25;
								VAR_24++;
								VAR_25 += VAR_0->sampleSize;
							} while (VAR_25 < VAR_28);
							VAR_24 = VAR_29;
							VAR_25 = VAR_27;
						} while (VAR_25 < VAR_26);
					}
					return;
				} else {
					do {
						if (DGifGetCodeNext(VAR_6, &VAR_4) == VAR_8) {
							break;
						}
					} while (VAR_4 != NULL);
					if (VAR_2) {
						return;
					}
				}
				break;

			case VAR_30:
				if (DGifGetExtension(VAR_6, &VAR_5, &VAR_4) == VAR_8) {
					break;
				}
				if (VAR_9) {
					updateGCB(VAR_0, &VAR_7);
					if (readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {
						break;
					}
				}
				while (VAR_4 != NULL) {
					if (DGifGetExtensionNext(VAR_6, &VAR_4) == VAR_8) {
						break;
					}
					if (VAR_9 && readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {
						break;
					}
				}
				break;

			case VAR_31:
				break;

			default: /* COMMENT_5 */
				break;
		}
	} while (VAR_3 != VAR_31);

	VAR_0->rewindFunction(VAR_0);
}",koral--/android-gif-drawable/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9/decoding.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,9 +40,15 @@
 				}
 
 				if (decode) {
-					int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
-					int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;
 					const uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;
+					if (newRasterSize == 0) {
+						free(info->rasterBits);
+						info->rasterBits = NULL;
+						info->rasterSize = newRasterSize;
+						return;
+					}
+					const int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
+					const int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;
 					if (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {
 						void *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));
 						if (tmpRasterBits == NULL) {","{'deleted_lines': ['\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;', '\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;'], 'added_lines': ['\t\t\t\t\tif (newRasterSize == 0) {', '\t\t\t\t\t\tfree(info->rasterBits);', '\t\t\t\t\t\tinfo->rasterBits = NULL;', '\t\t\t\t\t\tinfo->rasterSize = newRasterSize;', '\t\t\t\t\t\treturn;', '\t\t\t\t\t}', '\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;', '\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;']}",True,"A double free vulnerability in the DDGifSlurp function in decoding.c in the android-gif-drawable library before version 1.2.18, as used in WhatsApp for Android before version 2.19.244 and many other Android applications, allows remote attackers to execute arbitrary code or cause a denial of service when the library is used to parse a specially crafted GIF image.",8.8,HIGH,2,valid,2019-08-10T07:03:08Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,"[core] Fixed sender list to reallocate on insert
if required",47e589072c44350b0305c05066c224d1cbda992d,https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d,srtcore/queue.cpp,CSndUList::pop,"int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
{
CGuard listguard(m_ListLock);
if (-1 == m_iLastEntry)
return -1;
uint64_t ts;
CTimer::rdtsc(ts);
if (ts < m_pHeap[0]->m_llTimeStamp_tk)
return -1;
CUDT* u = m_pHeap[0]->m_pUDT;
remove_(u);
#define UST(field) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""
HLOGC(mglog.Debug, log << ""SND:pop: requesting packet from @"" << u->socketID()
<< "" STATUS: ""
<< UST(Listening)
<< UST(Connecting)
<< UST(Connected)
<< UST(Closing)
<< UST(Shutdown)
<< UST(Broken)
<< UST(PeerHealth)
<< UST(Opened)
);
#undef UST
if (!u->m_bConnected || u->m_bBroken)
return -1;
if (u->packData(pkt, ts) <= 0)
return -1;
addr = u->m_pPeerAddr;
if (ts > 0)
insert_(ts, u);
return 1;
}","int CSndUList::pop(sockaddr*& VAR_0, CPacket& VAR_1)
{
CGuard listguard(m_ListLock);
if (-1 == VAR_2)
return -1;
uint64_t VAR_3;
CTimer::rdtsc(VAR_3);
if (VAR_3 < VAR_4[0]->m_llTimeStamp_tk)
return -1;
CUDT* VAR_5 = VAR_4[0]->m_pUDT;
remove_(VAR_5);
#define UST(VAR_6) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""
HLOGC(VAR_7.Debug, VAR_8 << ""SND:pop: requesting packet from @"" << VAR_5->socketID()
<< "" STATUS: ""
<< UST(VAR_9)
<< UST(VAR_10)
<< UST(VAR_11)
<< UST(VAR_12)
<< UST(VAR_13)
<< UST(VAR_14)
<< UST(VAR_15)
<< UST(VAR_16)
);
#undef UST
if (!VAR_5->m_bConnected || VAR_5->m_bBroken)
return -1;
if (VAR_5->packData(VAR_1, VAR_3) <= 0)
return -1;
VAR_0 = VAR_5->m_pPeerAddr;
if (VAR_3 > 0)
insert_(VAR_3, VAR_5);
return 1;
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/before/2.json,"int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
{
   CGuard listguard(m_ListLock);

   if (-1 == m_iLastEntry)
      return -1;

   // no pop until the next schedulled time
   uint64_t ts;
   CTimer::rdtsc(ts);
   if (ts < m_pHeap[0]->m_llTimeStamp_tk)
      return -1;

   CUDT* u = m_pHeap[0]->m_pUDT;
   remove_(u);

#define UST(field) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""

   HLOGC(mglog.Debug, log << ""SND:pop: requesting packet from @"" << u->socketID()
           << "" STATUS: ""
           << UST(Listening)
           << UST(Connecting)
           << UST(Connected)
           << UST(Closing)
           << UST(Shutdown)
           << UST(Broken)
           << UST(PeerHealth)
           << UST(Opened)
        );
#undef UST

   if (!u->m_bConnected || u->m_bBroken)
      return -1;

   // pack a packet from the socket
   if (u->packData(pkt, ts) <= 0)
      return -1;

   addr = u->m_pPeerAddr;

   // insert a new entry, ts is the next processing time
   if (ts > 0)
      insert_norealloc(ts, u);

   return 1;
}","int CSndUList::pop(sockaddr*& VAR_0, CPacket& VAR_1)
{
   CGuard listguard(m_ListLock);

   if (-1 == VAR_2)
      return -1;

   /* COMMENT_0 */
   uint64_t VAR_3;
   CTimer::rdtsc(VAR_3);
   if (VAR_3 < VAR_4[0]->m_llTimeStamp_tk)
      return -1;

   CUDT* VAR_5 = VAR_4[0]->m_pUDT;
   remove_(VAR_5);

#define UST(VAR_6) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""

   HLOGC(VAR_7.Debug, VAR_8 << ""SND:pop: requesting packet from @"" << VAR_5->socketID()
           << "" STATUS: ""
           << UST(VAR_9)
           << UST(VAR_10)
           << UST(VAR_11)
           << UST(VAR_12)
           << UST(VAR_13)
           << UST(VAR_14)
           << UST(VAR_15)
           << UST(VAR_16)
        );
#undef UST

   if (!VAR_5->m_bConnected || VAR_5->m_bBroken)
      return -1;

   /* COMMENT_1 */
   if (VAR_5->packData(VAR_1, VAR_3) <= 0)
      return -1;

   VAR_0 = VAR_5->m_pPeerAddr;

   /* COMMENT_2 */
   if (VAR_3 > 0)
      insert_norealloc(VAR_3, VAR_5);

   return 1;
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -40,7 +40,7 @@
 
    // insert a new entry, ts is the next processing time
    if (ts > 0)
-      insert_(ts, u);
+      insert_norealloc(ts, u);
 
    return 1;
 }","{'deleted_lines': ['      insert_(ts, u);'], 'added_lines': ['      insert_norealloc(ts, u);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:35:27Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,"[core] Fixed sender list to reallocate on insert
if required",47e589072c44350b0305c05066c224d1cbda992d,https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d,srtcore/queue.cpp,CSndUList::update,"void CSndUList::update(const CUDT* u, EReschedule reschedule)
{
CGuard listguard(m_ListLock);
CSNode* n = u->m_pSNode;
if (n->m_iHeapLoc >= 0)
{
if (!reschedule)          return;
if (n->m_iHeapLoc == 0)
{
n->m_llTimeStamp_tk = 1;
m_pTimer->interrupt();
return;
}
remove_(u);
}
insert_(1, u);
}","void CSndUList::update(const CUDT* VAR_0, EReschedule VAR_1)
{
CGuard listguard(m_ListLock);
CSNode* VAR_2 = VAR_0->m_pSNode;
if (VAR_2->m_iHeapLoc >= 0)
{
if (!VAR_1) 
return;
if (VAR_2->m_iHeapLoc == 0)
{
VAR_2->m_llTimeStamp_tk = 1;
VAR_3->interrupt();
return;
}
remove_(VAR_0);
}
insert_(1, VAR_0);
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/before/1.json,"void CSndUList::update(const CUDT* u, EReschedule reschedule)
{
   CGuard listguard(m_ListLock);

   CSNode* n = u->m_pSNode;

   if (n->m_iHeapLoc >= 0)
   {
      if (!reschedule) // EReschedule to bool conversion, predicted.
         return;

      if (n->m_iHeapLoc == 0)
      {
         n->m_llTimeStamp_tk = 1;
         m_pTimer->interrupt();
         return;
      }

      remove_(u);
      insert_norealloc(1, u);
      return;
   }

   insert_(1, u);
}","void CSndUList::update(const CUDT* VAR_0, EReschedule VAR_1)
{
   CGuard listguard(m_ListLock);

   CSNode* VAR_2 = VAR_0->m_pSNode;

   if (VAR_2->m_iHeapLoc >= 0)
   {
      if (!VAR_1) /* COMMENT_0 */
         return;

      if (VAR_2->m_iHeapLoc == 0)
      {
         VAR_2->m_llTimeStamp_tk = 1;
         VAR_3->interrupt();
         return;
      }

      remove_(VAR_0);
      insert_norealloc(1, VAR_0);
      return;
   }

   insert_(1, VAR_0);
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,6 +17,8 @@
       }
 
       remove_(u);
+      insert_norealloc(1, u);
+      return;
    }
 
    insert_(1, u);","{'deleted_lines': [], 'added_lines': ['      insert_norealloc(1, u);', '      return;']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:35:27Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,"[core] Fixed sender list to reallocate on insert
if required",47e589072c44350b0305c05066c224d1cbda992d,https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d,srtcore/queue.cpp,CSndUList::insert_,"void CSndUList::insert_(int64_t ts, const CUDT* u)
{
CSNode* n = u->m_pSNode;
if (n->m_iHeapLoc >= 0)
return;
m_iLastEntry ++;
m_pHeap[m_iLastEntry] = n;
n->m_llTimeStamp_tk = ts;
int q = m_iLastEntry;
int p = q;
while (p != 0)
{
p = (q - 1) >> 1;
if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)
{
CSNode* t = m_pHeap[p];
m_pHeap[p] = m_pHeap[q];
m_pHeap[q] = t;
t->m_iHeapLoc = q;
q = p;
}
else
break;
}
n->m_iHeapLoc = q;
if (n->m_iHeapLoc == 0)
m_pTimer->interrupt();
if (0 == m_iLastEntry)
{
pthread_mutex_lock(m_pWindowLock);
pthread_cond_signal(m_pWindowCond);
pthread_mutex_unlock(m_pWindowLock);
}
}","void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)
{
CSNode* VAR_2 = VAR_1->m_pSNode;
if (VAR_2->m_iHeapLoc >= 0)
return;
VAR_3 ++;
VAR_4[VAR_3] = VAR_2;
VAR_2->m_llTimeStamp_tk = VAR_0;
int VAR_5 = VAR_3;
int VAR_6 = VAR_5;
while (VAR_6 != 0)
{
VAR_6 = (VAR_5 - 1) >> 1;
if (VAR_4[VAR_6]->m_llTimeStamp_tk > VAR_4[VAR_5]->m_llTimeStamp_tk)
{
CSNode* VAR_7 = VAR_4[VAR_6];
VAR_4[VAR_6] = VAR_4[VAR_5];
VAR_4[VAR_5] = VAR_7;
VAR_7->m_iHeapLoc = VAR_5;
VAR_5 = VAR_6;
}
else
break;
}
VAR_2->m_iHeapLoc = VAR_5;
if (VAR_2->m_iHeapLoc == 0)
VAR_8->interrupt();
if (0 == VAR_3)
{
pthread_mutex_lock(VAR_9);
pthread_cond_signal(VAR_10);
pthread_mutex_unlock(VAR_9);
}
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/before/0.json,"void CSndUList::insert_(int64_t ts, const CUDT* u)
{
    // increase the heap array size if necessary
    if (m_iLastEntry == m_iArrayLength - 1)
        realloc_();

    insert_norealloc(ts, u);
}","void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)
{
    /* COMMENT_0 */
    if (VAR_2 == VAR_3 - 1)
        realloc_();

    insert_norealloc(VAR_0, VAR_1);
}",Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,43 +1,8 @@
 void CSndUList::insert_(int64_t ts, const CUDT* u)
 {
-   CSNode* n = u->m_pSNode;
+    // increase the heap array size if necessary
+    if (m_iLastEntry == m_iArrayLength - 1)
+        realloc_();
 
-   // do not insert repeated node
-   if (n->m_iHeapLoc >= 0)
-      return;
-
-   m_iLastEntry ++;
-   m_pHeap[m_iLastEntry] = n;
-   n->m_llTimeStamp_tk = ts;
-
-   int q = m_iLastEntry;
-   int p = q;
-   while (p != 0)
-   {
-      p = (q - 1) >> 1;
-      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)
-      {
-         CSNode* t = m_pHeap[p];
-         m_pHeap[p] = m_pHeap[q];
-         m_pHeap[q] = t;
-         t->m_iHeapLoc = q;
-         q = p;
-      }
-      else
-         break;
-   }
-
-   n->m_iHeapLoc = q;
-
-   // an earlier event has been inserted, wake up sending worker
-   if (n->m_iHeapLoc == 0)
-      m_pTimer->interrupt();
-
-   // first entry, activate the sending queue
-   if (0 == m_iLastEntry)
-   {
-       pthread_mutex_lock(m_pWindowLock);
-       pthread_cond_signal(m_pWindowCond);
-       pthread_mutex_unlock(m_pWindowLock);
-   }
+    insert_norealloc(ts, u);
 }","{'deleted_lines': ['   CSNode* n = u->m_pSNode;', '   // do not insert repeated node', '   if (n->m_iHeapLoc >= 0)', '      return;', '', '   m_iLastEntry ++;', '   m_pHeap[m_iLastEntry] = n;', '   n->m_llTimeStamp_tk = ts;', '', '   int q = m_iLastEntry;', '   int p = q;', '   while (p != 0)', '   {', '      p = (q - 1) >> 1;', '      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)', '      {', '         CSNode* t = m_pHeap[p];', '         m_pHeap[p] = m_pHeap[q];', '         m_pHeap[q] = t;', '         t->m_iHeapLoc = q;', '         q = p;', '      }', '      else', '         break;', '   }', '', '   n->m_iHeapLoc = q;', '', '   // an earlier event has been inserted, wake up sending worker', '   if (n->m_iHeapLoc == 0)', '      m_pTimer->interrupt();', '', '   // first entry, activate the sending queue', '   if (0 == m_iLastEntry)', '   {', '       pthread_mutex_lock(m_pWindowLock);', '       pthread_cond_signal(m_pWindowCond);', '       pthread_mutex_unlock(m_pWindowLock);', '   }'], 'added_lines': ['    // increase the heap array size if necessary', '    if (m_iLastEntry == m_iArrayLength - 1)', '        realloc_();', '    insert_norealloc(ts, u);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:35:27Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::pop,"int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
{
CGuard listguard(m_ListLock);
if (-1 == m_iLastEntry)
return -1;
uint64_t ts;
CTimer::rdtsc(ts);
if (ts < m_pHeap[0]->m_llTimeStamp_tk)
return -1;
CUDT* u = m_pHeap[0]->m_pUDT;
remove_(u);
#define UST(field) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""
HLOGC(mglog.Debug, log << ""SND:pop: requesting packet from @"" << u->socketID()
<< "" STATUS: ""
<< UST(Listening)
<< UST(Connecting)
<< UST(Connected)
<< UST(Closing)
<< UST(Shutdown)
<< UST(Broken)
<< UST(PeerHealth)
<< UST(Opened)
);
#undef UST
if (!u->m_bConnected || u->m_bBroken)
return -1;
if (u->packData(pkt, ts) <= 0)
return -1;
addr = u->m_pPeerAddr;
if (ts > 0)
insert_norealloc(ts, u);
return 1;
}","int CSndUList::pop(sockaddr*& VAR_0, CPacket& VAR_1)
{
CGuard listguard(m_ListLock);
if (-1 == VAR_2)
return -1;
uint64_t VAR_3;
CTimer::rdtsc(VAR_3);
if (VAR_3 < VAR_4[0]->m_llTimeStamp_tk)
return -1;
CUDT* VAR_5 = VAR_4[0]->m_pUDT;
remove_(VAR_5);
#define UST(VAR_6) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""
HLOGC(VAR_7.Debug, VAR_8 << ""SND:pop: requesting packet from @"" << VAR_5->socketID()
<< "" STATUS: ""
<< UST(VAR_9)
<< UST(VAR_10)
<< UST(VAR_11)
<< UST(VAR_12)
<< UST(VAR_13)
<< UST(VAR_14)
<< UST(VAR_15)
<< UST(VAR_16)
);
#undef UST
if (!VAR_5->m_bConnected || VAR_5->m_bBroken)
return -1;
if (VAR_5->packData(VAR_1, VAR_3) <= 0)
return -1;
VAR_0 = VAR_5->m_pPeerAddr;
if (VAR_3 > 0)
insert_norealloc(VAR_3, VAR_5);
return 1;
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/before/5.json,"int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
{
   CGuard listguard(m_ListLock);

   if (-1 == m_iLastEntry)
      return -1;

   // no pop until the next schedulled time
   uint64_t ts;
   CTimer::rdtsc(ts);
   if (ts < m_pHeap[0]->m_llTimeStamp_tk)
      return -1;

   CUDT* u = m_pHeap[0]->m_pUDT;
   remove_(u);

#define UST(field) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""

   HLOGC(mglog.Debug, log << ""SND:pop: requesting packet from @"" << u->socketID()
           << "" STATUS: ""
           << UST(Listening)
           << UST(Connecting)
           << UST(Connected)
           << UST(Closing)
           << UST(Shutdown)
           << UST(Broken)
           << UST(PeerHealth)
           << UST(Opened)
        );
#undef UST

   if (!u->m_bConnected || u->m_bBroken)
      return -1;

   // pack a packet from the socket
   if (u->packData(pkt, ts) <= 0)
      return -1;

   addr = u->m_pPeerAddr;

   // insert a new entry, ts is the next processing time
   if (ts > 0)
      insert_norealloc_(ts, u);

   return 1;
}","int CSndUList::pop(sockaddr*& VAR_0, CPacket& VAR_1)
{
   CGuard listguard(m_ListLock);

   if (-1 == VAR_2)
      return -1;

   /* COMMENT_0 */
   uint64_t VAR_3;
   CTimer::rdtsc(VAR_3);
   if (VAR_3 < VAR_4[0]->m_llTimeStamp_tk)
      return -1;

   CUDT* VAR_5 = VAR_4[0]->m_pUDT;
   remove_(VAR_5);

#define UST(VAR_6) ( (u->m_b##field) ? ""+"" : ""-"" ) << #field << "" ""

   HLOGC(VAR_7.Debug, VAR_8 << ""SND:pop: requesting packet from @"" << VAR_5->socketID()
           << "" STATUS: ""
           << UST(VAR_9)
           << UST(VAR_10)
           << UST(VAR_11)
           << UST(VAR_12)
           << UST(VAR_13)
           << UST(VAR_14)
           << UST(VAR_15)
           << UST(VAR_16)
        );
#undef UST

   if (!VAR_5->m_bConnected || VAR_5->m_bBroken)
      return -1;

   /* COMMENT_1 */
   if (VAR_5->packData(VAR_1, VAR_3) <= 0)
      return -1;

   VAR_0 = VAR_5->m_pPeerAddr;

   /* COMMENT_2 */
   if (VAR_3 > 0)
      insert_norealloc_(VAR_3, VAR_5);

   return 1;
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -40,7 +40,7 @@
 
    // insert a new entry, ts is the next processing time
    if (ts > 0)
-      insert_norealloc(ts, u);
+      insert_norealloc_(ts, u);
 
    return 1;
 }","{'deleted_lines': ['      insert_norealloc(ts, u);'], 'added_lines': ['      insert_norealloc_(ts, u);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::realloc_,"void CSndUList::realloc_()
{
CSNode** temp = NULL;
try
{
temp = new CSNode * [m_iArrayLength * 2];
}
catch (...)
{
return;
}
memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);
m_iArrayLength *= 2;
delete[] m_pHeap;
m_pHeap = temp;
}","void CSndUList::realloc_()
{
CSNode** VAR_0 = NULL;
try
{
VAR_0 = new CSNode * [VAR_1 * 2];
}
catch (...)
{
return;
}
memcpy(VAR_0, VAR_2, sizeof(CSNode*) * VAR_1);
VAR_1 *= 2;
delete[] VAR_2;
VAR_2 = VAR_0;
}",,"void CSndUList::realloc_()
{
   CSNode** temp = NULL;

   try
   {
       temp = new CSNode *[2 * m_iArrayLength];
   }
   catch (...)
   {
       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);
   }

   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);
   m_iArrayLength *= 2;
   delete[] m_pHeap;
   m_pHeap = temp;
}","void CSndUList::realloc_()
{
   CSNode** VAR_0 = NULL;

   try
   {
       VAR_0 = new CSNode *[2 * VAR_1];
   }
   catch (...)
   {
       throw CUDTException(VAR_2, VAR_3, 0);
   }

   memcpy(VAR_0, VAR_4, sizeof(CSNode*) * VAR_1);
   VAR_1 *= 2;
   delete[] VAR_4;
   VAR_4 = VAR_0;
}",,"--- func_before
+++ func_after
@@ -4,11 +4,11 @@
 
    try
    {
-       temp = new CSNode * [m_iArrayLength * 2];
+       temp = new CSNode *[2 * m_iArrayLength];
    }
    catch (...)
    {
-       return;
+       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);
    }
 
    memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);","{'deleted_lines': ['       temp = new CSNode * [m_iArrayLength * 2];', '       return;'], 'added_lines': ['       temp = new CSNode *[2 * m_iArrayLength];', '       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::insert_,"void CSndUList::insert_(int64_t ts, const CUDT* u)
{
if (m_iLastEntry == m_iArrayLength - 1)
realloc_();
insert_norealloc(ts, u);
}","void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)
{
if (VAR_2 == VAR_3 - 1)
realloc_();
insert_norealloc(VAR_0, VAR_1);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/before/2.json,"void CSndUList::insert_(int64_t ts, const CUDT* u)
{
    // increase the heap array size if necessary
    if (m_iLastEntry == m_iArrayLength - 1)
        realloc_();

    insert_norealloc_(ts, u);
}","void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)
{
    /* COMMENT_0 */
    if (VAR_2 == VAR_3 - 1)
        realloc_();

    insert_norealloc_(VAR_0, VAR_1);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
     if (m_iLastEntry == m_iArrayLength - 1)
         realloc_();
 
-    insert_norealloc(ts, u);
+    insert_norealloc_(ts, u);
 }","{'deleted_lines': ['    insert_norealloc(ts, u);'], 'added_lines': ['    insert_norealloc_(ts, u);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::update,"void CSndUList::update(const CUDT* u, EReschedule reschedule)
{
CGuard listguard(m_ListLock);
CSNode* n = u->m_pSNode;
if (n->m_iHeapLoc >= 0)
{
if (!reschedule)          return;
if (n->m_iHeapLoc == 0)
{
n->m_llTimeStamp_tk = 1;
m_pTimer->interrupt();
return;
}
remove_(u);
insert_norealloc(1, u);
return;
}
insert_(1, u);
}","void CSndUList::update(const CUDT* VAR_0, EReschedule VAR_1)
{
CGuard listguard(m_ListLock);
CSNode* VAR_2 = VAR_0->m_pSNode;
if (VAR_2->m_iHeapLoc >= 0)
{
if (!VAR_1) 
return;
if (VAR_2->m_iHeapLoc == 0)
{
VAR_2->m_llTimeStamp_tk = 1;
VAR_3->interrupt();
return;
}
remove_(VAR_0);
insert_norealloc(1, VAR_0);
return;
}
insert_(1, VAR_0);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/before/4.json,"void CSndUList::update(const CUDT* u, EReschedule reschedule)
{
   CGuard listguard(m_ListLock);

   CSNode* n = u->m_pSNode;

   if (n->m_iHeapLoc >= 0)
   {
      if (!reschedule) // EReschedule to bool conversion, predicted.
         return;

      if (n->m_iHeapLoc == 0)
      {
         n->m_llTimeStamp_tk = 1;
         m_pTimer->interrupt();
         return;
      }

      remove_(u);
      insert_norealloc_(1, u);
      return;
   }

   insert_(1, u);
}","void CSndUList::update(const CUDT* VAR_0, EReschedule VAR_1)
{
   CGuard listguard(m_ListLock);

   CSNode* VAR_2 = VAR_0->m_pSNode;

   if (VAR_2->m_iHeapLoc >= 0)
   {
      if (!VAR_1) /* COMMENT_0 */
         return;

      if (VAR_2->m_iHeapLoc == 0)
      {
         VAR_2->m_llTimeStamp_tk = 1;
         VAR_3->interrupt();
         return;
      }

      remove_(VAR_0);
      insert_norealloc_(1, VAR_0);
      return;
   }

   insert_(1, VAR_0);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
       }
 
       remove_(u);
-      insert_norealloc(1, u);
+      insert_norealloc_(1, u);
       return;
    }
 ","{'deleted_lines': ['      insert_norealloc(1, u);'], 'added_lines': ['      insert_norealloc_(1, u);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::remove_,"void CSndUList::remove_(const CUDT* u)
{
CSNode* n = u->m_pSNode;
if (n->m_iHeapLoc >= 0)
{
m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];
m_iLastEntry --;
m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;
int q = n->m_iHeapLoc;
int p = q * 2 + 1;
while (p <= m_iLastEntry)
{
if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))
p ++;
if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)
{
CSNode* t = m_pHeap[p];
m_pHeap[p] = m_pHeap[q];
m_pHeap[p]->m_iHeapLoc = p;
m_pHeap[q] = t;
m_pHeap[q]->m_iHeapLoc = q;
q = p;
p = q * 2 + 1;
}
else
break;
}
n->m_iHeapLoc = -1;
}
if (0 == m_iLastEntry)
m_pTimer->interrupt();
}","void CSndUList::remove_(const CUDT* VAR_0)
{
CSNode* VAR_1 = VAR_0->m_pSNode;
if (VAR_1->m_iHeapLoc >= 0)
{
VAR_2[VAR_1->m_iHeapLoc] = VAR_2[VAR_3];
VAR_3 --;
VAR_2[VAR_1->m_iHeapLoc]->m_iHeapLoc = VAR_1->m_iHeapLoc;
int VAR_4 = VAR_1->m_iHeapLoc;
int VAR_5 = VAR_4 * 2 + 1;
while (VAR_5 <= VAR_3)
{
if ((VAR_5 + 1 <= VAR_3) && (VAR_2[VAR_5]->m_llTimeStamp_tk > VAR_2[VAR_5 + 1]->m_llTimeStamp_tk))
VAR_5 ++;
if (VAR_2[VAR_4]->m_llTimeStamp_tk > VAR_2[VAR_5]->m_llTimeStamp_tk)
{
CSNode* VAR_6 = VAR_2[VAR_5];
VAR_2[VAR_5] = VAR_2[VAR_4];
VAR_2[VAR_5]->m_iHeapLoc = VAR_5;
VAR_2[VAR_4] = VAR_6;
VAR_2[VAR_4]->m_iHeapLoc = VAR_4;
VAR_4 = VAR_5;
VAR_5 = VAR_4 * 2 + 1;
}
else
break;
}
VAR_1->m_iHeapLoc = -1;
}
if (0 == VAR_3)
VAR_7->interrupt();
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/before/3.json,"void CSndUList::remove_(const CUDT* u)
{
   CSNode* n = u->m_pSNode;

   if (n->m_iHeapLoc >= 0)
   {
      // remove the node from heap
      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];
      m_iLastEntry --;
      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;

      int q = n->m_iHeapLoc;
      int p = q * 2 + 1;
      while (p <= m_iLastEntry)
      {
         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))
            p ++;

         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)
         {
            swap(m_pHeap[p], m_pHeap[q]);
            m_pHeap[p]->m_iHeapLoc = p;
            m_pHeap[q]->m_iHeapLoc = q;

            q = p;
            p = q * 2 + 1;
         }
         else
            break;
      }

      n->m_iHeapLoc = -1;
   }

   // the only event has been deleted, wake up immediately
   if (0 == m_iLastEntry)
      m_pTimer->interrupt();
}","void CSndUList::remove_(const CUDT* VAR_0)
{
   CSNode* VAR_1 = VAR_0->m_pSNode;

   if (VAR_1->m_iHeapLoc >= 0)
   {
      /* COMMENT_0 */
      VAR_2[VAR_1->m_iHeapLoc] = VAR_2[VAR_3];
      VAR_3 --;
      VAR_2[VAR_1->m_iHeapLoc]->m_iHeapLoc = VAR_1->m_iHeapLoc;

      int VAR_4 = VAR_1->m_iHeapLoc;
      int VAR_5 = VAR_4 * 2 + 1;
      while (VAR_5 <= VAR_3)
      {
         if ((VAR_5 + 1 <= VAR_3) && (VAR_2[VAR_5]->m_llTimeStamp_tk > VAR_2[VAR_5 + 1]->m_llTimeStamp_tk))
            VAR_5 ++;

         if (VAR_2[VAR_4]->m_llTimeStamp_tk > VAR_2[VAR_5]->m_llTimeStamp_tk)
         {
            swap(VAR_2[VAR_5], VAR_2[VAR_4]);
            VAR_2[VAR_5]->m_iHeapLoc = VAR_5;
            VAR_2[VAR_4]->m_iHeapLoc = VAR_4;

            VAR_4 = VAR_5;
            VAR_5 = VAR_4 * 2 + 1;
         }
         else
            break;
      }

      VAR_1->m_iHeapLoc = -1;
   }

   /* COMMENT_1 */
   if (0 == VAR_3)
      VAR_6->interrupt();
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -18,10 +18,8 @@
 
          if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)
          {
-            CSNode* t = m_pHeap[p];
-            m_pHeap[p] = m_pHeap[q];
+            swap(m_pHeap[p], m_pHeap[q]);
             m_pHeap[p]->m_iHeapLoc = p;
-            m_pHeap[q] = t;
             m_pHeap[q]->m_iHeapLoc = q;
 
             q = p;","{'deleted_lines': ['            CSNode* t = m_pHeap[p];', '            m_pHeap[p] = m_pHeap[q];', '            m_pHeap[q] = t;'], 'added_lines': ['            swap(m_pHeap[p], m_pHeap[q]);']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15784,['CWE-129'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Haivision/srt,[core] CSndUList initial size is reduced to 512 elements,64875fa98ff6afd2f21a9727970fb4333efe95de,https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de,srtcore/queue.cpp,CSndUList::CSndUList,"CSndUList::CSndUList():
m_pHeap(NULL),
m_iArrayLength(4096),
m_iLastEntry(-1),
m_ListLock(),
m_pWindowLock(NULL),
m_pWindowCond(NULL),
m_pTimer(NULL)
{
m_pHeap = new CSNode*[m_iArrayLength];
pthread_mutex_init(&m_ListLock, NULL);
}","CSndUList::CSndUList():
m_pHeap(NULL),
m_iArrayLength(4096),
m_iLastEntry(-1),
m_ListLock(),
m_pWindowLock(NULL),
m_pWindowCond(NULL),
m_pTimer(NULL)
{
VAR_0 = new CSNode*[VAR_1];
pthread_mutex_init(&VAR_2, NULL);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/before/0.json,"CSndUList::CSndUList():
    m_pHeap(NULL),
    m_iArrayLength(512),
    m_iLastEntry(-1),
    m_ListLock(),
    m_pWindowLock(NULL),
    m_pWindowCond(NULL),
    m_pTimer(NULL)
{
    m_pHeap = new CSNode*[m_iArrayLength];
    pthread_mutex_init(&m_ListLock, NULL);
}","CSndUList::CSndUList():
    m_pHeap(NULL),
    m_iArrayLength(512),
    m_iLastEntry(-1),
    m_ListLock(),
    m_pWindowLock(NULL),
    m_pWindowCond(NULL),
    m_pTimer(NULL)
{
    VAR_0 = new CSNode*[VAR_1];
    pthread_mutex_init(&VAR_2, NULL);
}",Haivision/srt/64875fa98ff6afd2f21a9727970fb4333efe95de/queue.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 CSndUList::CSndUList():
     m_pHeap(NULL),
-    m_iArrayLength(4096),
+    m_iArrayLength(512),
     m_iLastEntry(-1),
     m_ListLock(),
     m_pWindowLock(NULL),","{'deleted_lines': ['    m_iArrayLength(4096),'], 'added_lines': ['    m_iArrayLength(512),']}",True,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,9.8,CRITICAL,3,valid,2019-08-13T10:36:20Z,2
CVE-2019-15785,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,fontforge," Warn users before discarding their unsaved scripts (#3852)

* Warn users before discarding their unsaved scripts

This closes #3846.",626f751752875a0ddd74b9e217b6f4828713573c,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,gdraw/gtextfield.c,GTextFieldSave,"static void GTextFieldSave(GTextField *gt,int utf8) {
unichar_t *ret;
char *cret;
FILE *file;
unichar_t *pt;
if ( _ggadget_use_gettext ) {
char *temp = GWidgetOpenFile8(_(""Save""),NULL,""*.{txt,py}"",NULL,NULL);
ret = utf82u_copy(temp);
free(temp);
} else
ret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,
txt,NULL,NULL);
if ( ret==NULL )
return;
cret = u2def_copy(ret);
free(ret);
file = fopen(cret,""w"");
if ( file==NULL ) {
if ( _ggadget_use_gettext )
GWidgetError8(_(""Could not open file""), _(""Could not open %.100s""),cret);
else
GWidgetError(errort,error,cret);
free(cret);
return;
}
free(cret);
if ( utf8 ) {
putc(0xef,file);
putc(0xbb,file);
putc(0xbf,file);
for ( pt = gt->text ; *pt; ++pt ) {
if ( *pt<0x80 )
putc(*pt,file);
else if ( *pt<0x800 ) {
putc(0xc0 | (*pt>>6), file);
putc(0x80 | (*pt&0x3f), file);
} else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {
int u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);
putc( 0xf0 | (u>>2),file );
putc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );
putc( 0x80 | y,file );
putc( 0x80 | (pt[1]&0x3f),file );
} else {
putc( 0xe0 | (*pt>>12),file );
putc( 0x80 | ((*pt>>6)&0x3f),file );
putc( 0x80 | (*pt&0x3f),file );
}
}
} else {
putc(0xfeff>>8,file);
putc(0xfeff&0xff,file);
for ( pt = gt->text ; *pt; ++pt ) {
putc(*pt>>8,file);
putc(*pt&0xff,file);
}
}
fclose(file);
}","static void GTextFieldSave(GTextField *VAR_0,int VAR_1) {
unichar_t *VAR_2;
char *VAR_3;
FILE *VAR_4;
unichar_t *VAR_5;
if ( VAR_6 ) {
char *VAR_7 = GWidgetOpenFile8(_(""Save""),NULL,""*.{txt,py}"",NULL,NULL);
VAR_2 = utf82u_copy(VAR_7);
free(VAR_7);
} else
VAR_2 = GWidgetSaveAsFile(GStringGetResource(VAR_8,NULL),NULL,
VAR_9,NULL,NULL);
if ( VAR_2==NULL )
return;
VAR_3 = u2def_copy(VAR_2);
free(VAR_2);
VAR_4 = fopen(VAR_3,""w"");
if ( VAR_4==NULL ) {
if ( VAR_6 )
GWidgetError8(_(""Could not open file""), _(""Could not open %.100s""),VAR_3);
else
GWidgetError(VAR_10,VAR_11,VAR_3);
free(VAR_3);
return;
}
free(VAR_3);
if ( VAR_1 ) {
putc(0xef,VAR_4);
putc(0xbb,VAR_4);
putc(0xbf,VAR_4);
for ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {
if ( *VAR_5<0x80 )
putc(*VAR_5,VAR_4);
else if ( *VAR_5<0x800 ) {
putc(0xc0 | (*VAR_5>>6), VAR_4);
putc(0x80 | (*VAR_5&0x3f), VAR_4);
} else if ( *VAR_5>=0xd800 && *VAR_5<0xdc00 && VAR_5[1]>=0xdc00 && VAR_5[1]<0xe000 ) {
int VAR_12 = ((*VAR_5>>6)&0xf)+1, VAR_13 = ((*VAR_5&3)<<4) | ((VAR_5[1]>>6)&0xf);
putc( 0xf0 | (VAR_12>>2),VAR_4 );
putc( 0x80 | ((VAR_12&3)<<4) | ((*VAR_5>>2)&0xf),VAR_4 );
putc( 0x80 | VAR_13,VAR_4 );
putc( 0x80 | (VAR_5[1]&0x3f),VAR_4 );
} else {
putc( 0xe0 | (*VAR_5>>12),VAR_4 );
putc( 0x80 | ((*VAR_5>>6)&0x3f),VAR_4 );
putc( 0x80 | (*VAR_5&0x3f),VAR_4 );
}
}
} else {
putc(0xfeff>>8,VAR_4);
putc(0xfeff&0xff,VAR_4);
for ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {
putc(*VAR_5>>8,VAR_4);
putc(*VAR_5&0xff,VAR_4);
}
}
fclose(VAR_4);
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/gtextfield.c/vul/before/0.json,"static void GTextFieldSave(GTextField *gt,int utf8) {
    unichar_t *ret;
    char *cret;
    FILE *file;
    unichar_t *pt;

    if ( _ggadget_use_gettext ) {
	char *temp = GWidgetOpenFile8(_(""Save""),NULL,""*.{txt,py}"",NULL,NULL);
	ret = utf82u_copy(temp);
	free(temp);
    } else
	ret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,
		txt,NULL,NULL);

    if ( ret==NULL )
return;
    cret = u2def_copy(ret);
    free(ret);
    file = fopen(cret,""w"");
    if ( file==NULL ) {
	if ( _ggadget_use_gettext )
	    GWidgetError8(_(""Could not open file""), _(""Could not open %.100s""),cret);
	else
	    GWidgetError(errort,error,cret);
	free(cret);
return;
    }
    free(cret);

    if ( utf8 ) {
	putc(0xef,file);		/* Zero width something or other. Marks this as unicode, utf8 */
	putc(0xbb,file);
	putc(0xbf,file);
	for ( pt = gt->text ; *pt; ++pt ) {
	    if ( *pt<0x80 )
		putc(*pt,file);
	    else if ( *pt<0x800 ) {
		putc(0xc0 | (*pt>>6), file);
		putc(0x80 | (*pt&0x3f), file);
	    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {
		int u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);
		putc( 0xf0 | (u>>2),file );
		putc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );
		putc( 0x80 | y,file );
		putc( 0x80 | (pt[1]&0x3f),file );
	    } else {
		putc( 0xe0 | (*pt>>12),file );
		putc( 0x80 | ((*pt>>6)&0x3f),file );
		putc( 0x80 | (*pt&0x3f),file );
	    }
	}
    } else {
	putc(0xfeff>>8,file);		/* Zero width something or other. Marks this as unicode */
	putc(0xfeff&0xff,file);
	for ( pt = gt->text ; *pt; ++pt ) {
	    putc(*pt>>8,file);
	    putc(*pt&0xff,file);
	}
    }
    fclose(file);
    GTextFieldSaved(gt);
}","static void GTextFieldSave(GTextField *VAR_0,int VAR_1) {
    unichar_t *VAR_2;
    char *VAR_3;
    FILE *VAR_4;
    unichar_t *VAR_5;

    if ( VAR_6 ) {
	char *VAR_7 = GWidgetOpenFile8(_(""Save""),NULL,""*.{txt,py}"",NULL,NULL);
	VAR_2 = utf82u_copy(VAR_7);
	free(VAR_7);
    } else
	VAR_2 = GWidgetSaveAsFile(GStringGetResource(VAR_8,NULL),NULL,
		VAR_9,NULL,NULL);

    if ( VAR_2==NULL )
return;
    VAR_3 = u2def_copy(VAR_2);
    free(VAR_2);
    VAR_4 = fopen(VAR_3,""w"");
    if ( VAR_4==NULL ) {
	if ( VAR_6 )
	    GWidgetError8(_(""Could not open file""), _(""Could not open %.100s""),VAR_3);
	else
	    GWidgetError(VAR_10,VAR_11,VAR_3);
	free(VAR_3);
return;
    }
    free(VAR_3);

    if ( VAR_1 ) {
	putc(0xef,VAR_4);		/* COMMENT_0 */
	putc(0xbb,VAR_4);
	putc(0xbf,VAR_4);
	for ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {
	    if ( *VAR_5<0x80 )
		putc(*VAR_5,VAR_4);
	    else if ( *VAR_5<0x800 ) {
		putc(0xc0 | (*VAR_5>>6), VAR_4);
		putc(0x80 | (*VAR_5&0x3f), VAR_4);
	    } else if ( *VAR_5>=0xd800 && *VAR_5<0xdc00 && VAR_5[1]>=0xdc00 && VAR_5[1]<0xe000 ) {
		int VAR_12 = ((*VAR_5>>6)&0xf)+1, VAR_13 = ((*VAR_5&3)<<4) | ((VAR_5[1]>>6)&0xf);
		putc( 0xf0 | (VAR_12>>2),VAR_4 );
		putc( 0x80 | ((VAR_12&3)<<4) | ((*VAR_5>>2)&0xf),VAR_4 );
		putc( 0x80 | VAR_13,VAR_4 );
		putc( 0x80 | (VAR_5[1]&0x3f),VAR_4 );
	    } else {
		putc( 0xe0 | (*VAR_5>>12),VAR_4 );
		putc( 0x80 | ((*VAR_5>>6)&0x3f),VAR_4 );
		putc( 0x80 | (*VAR_5&0x3f),VAR_4 );
	    }
	}
    } else {
	putc(0xfeff>>8,VAR_4);		/* COMMENT_1 */
	putc(0xfeff&0xff,VAR_4);
	for ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {
	    putc(*VAR_5>>8,VAR_4);
	    putc(*VAR_5&0xff,VAR_4);
	}
    }
    fclose(VAR_4);
    GTextFieldSaved(VAR_0);
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/gtextfield.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,4 +58,5 @@
 	}
     }
     fclose(file);
+    GTextFieldSaved(gt);
 }","{'deleted_lines': [], 'added_lines': ['    GTextFieldSaved(gt);']}",True,FontForge 20190813 through 20190820 has a buffer overflow in PrefsUI_LoadPrefs in prefs.c.,9.8,CRITICAL,3,valid,2019-08-13T11:09:59Z,2
CVE-2019-15785,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,fontforge," Warn users before discarding their unsaved scripts (#3852)

* Warn users before discarding their unsaved scripts

This closes #3846.",626f751752875a0ddd74b9e217b6f4828713573c,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,fontforgeexe/scriptingdlg.c,sd_e_h,"static int sd_e_h(GWindow gw, GEvent *event) {
struct sd_data *sd = GDrawGetUserData(gw);
if ( sd==NULL )
return( true );
if ( event->type==et_close ) {
SD_DoCancel( sd );
} else if ( event->type==et_char ) {
if ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {
help(""scripting.html"");
return( true );
}
return( false );
} else if ( event->type == et_map )
GDrawRaise(gw);
else if ( event->type == et_resize )
GDrawRequestExpose(gw,NULL,false);
return( true );
}","static int sd_e_h(GWindow VAR_0, GEvent *VAR_1) {
struct sd_data *VAR_2 = GDrawGetUserData(VAR_0);
if ( VAR_2==NULL )
return( true );
if ( VAR_1->type==VAR_3 ) {
SD_DoCancel( VAR_2 );
} else if ( VAR_1->type==VAR_4 ) {
if ( VAR_1->u.chr.keysym == VAR_5 || VAR_1->u.chr.keysym == VAR_6 ) {
help(""scripting.html"");
return( true );
}
return( false );
} else if ( VAR_1->type == VAR_7 )
GDrawRaise(VAR_0);
else if ( VAR_1->type == VAR_8 )
GDrawRequestExpose(VAR_0,NULL,false);
return( true );
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/scriptingdlg.c/vul/before/0.json,"static int sd_e_h(GWindow gw, GEvent *event) {
    struct sd_data *sd = GDrawGetUserData(gw);

    if ( sd==NULL )
return( true );
    
    if ( event->type==et_close ) {
	SD_DoCancel( sd );
    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {
    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));
    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {
    sd->fv->script_unsaved = false;
    } else if ( event->type==et_char ) {
	if ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {
	    help(""scripting.html"");
return( true );
	}
return( false );
    } else if ( event->type == et_map )	/* Above palettes */
	GDrawRaise(gw);
    else if ( event->type == et_resize )
	GDrawRequestExpose(gw,NULL,false);
return( true );
}","static int sd_e_h(GWindow VAR_0, GEvent *VAR_1) {
    struct sd_data *VAR_2 = GDrawGetUserData(VAR_0);

    if ( VAR_2==NULL )
return( true );
    
    if ( VAR_1->type==VAR_3 ) {
	SD_DoCancel( VAR_2 );
    } else if ( VAR_1->type==VAR_4 && VAR_1->u.control.subtype==VAR_5 ) {
    VAR_2->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(VAR_2->gw,VAR_6));
    } else if ( VAR_1->type==VAR_4 && VAR_1->u.control.subtype==VAR_7 ) {
    VAR_2->fv->script_unsaved = false;
    } else if ( VAR_1->type==VAR_8 ) {
	if ( VAR_1->u.chr.keysym == VAR_9 || VAR_1->u.chr.keysym == VAR_10 ) {
	    help(""scripting.html"");
return( true );
	}
return( false );
    } else if ( VAR_1->type == VAR_11 )	/* COMMENT_0 */
	GDrawRaise(VAR_0);
    else if ( VAR_1->type == VAR_12 )
	GDrawRequestExpose(VAR_0,NULL,false);
return( true );
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/scriptingdlg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,10 @@
     
     if ( event->type==et_close ) {
 	SD_DoCancel( sd );
+    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {
+    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));
+    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {
+    sd->fv->script_unsaved = false;
     } else if ( event->type==et_char ) {
 	if ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {
 	    help(""scripting.html"");","{'deleted_lines': [], 'added_lines': ['    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {', '    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));', '    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {', '    sd->fv->script_unsaved = false;']}",True,FontForge 20190813 through 20190820 has a buffer overflow in PrefsUI_LoadPrefs in prefs.c.,9.8,CRITICAL,3,valid,2019-08-13T11:09:59Z,2
CVE-2019-15785,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,fontforge," Warn users before discarding their unsaved scripts (#3852)

* Warn users before discarding their unsaved scripts

This closes #3846.",626f751752875a0ddd74b9e217b6f4828713573c,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,fontforgeexe/fontview.c,_FVMenuClose,"static int _FVMenuClose(FontView *fv) {
int i;
SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;
if ( !SFCloseAllInstrs(fv->b.sf) )
return( false );
if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {
} else if ( SFAnyChanged(sf) ) {
i = AskChanged(fv->b.sf);
if ( i==2 )
return( false );
if ( i==0 && !_FVMenuSave(fv))
return(false);
else
SFClearAutoSave(sf);
}
_FVCloseWindows(fv);
if ( sf->filename!=NULL )
RecentFilesRemember(sf->filename);
else if ( sf->origname!=NULL )
RecentFilesRemember(sf->origname);
GDrawDestroyWindow(fv->gw);
return( true );
}","static int _FVMenuClose(FontView *VAR_0) {
int VAR_1;
SplineFont *VAR_2 = VAR_0->b.cidmaster?VAR_0->b.cidmaster:VAR_0->b.sf;
if ( !SFCloseAllInstrs(VAR_0->b.sf) )
return( false );
if ( VAR_0->b.nextsame!=NULL || VAR_0->b.sf->fv!=&VAR_0->b ) {
} else if ( SFAnyChanged(VAR_2) ) {
VAR_1 = AskChanged(VAR_0->b.sf);
if ( VAR_1==2 )
return( false );
if ( VAR_1==0 && !_FVMenuSave(VAR_0))
return(false);
else
SFClearAutoSave(VAR_2);
}
_FVCloseWindows(VAR_0);
if ( VAR_2->filename!=NULL )
RecentFilesRemember(VAR_2->filename);
else if ( VAR_2->origname!=NULL )
RecentFilesRemember(VAR_2->origname);
GDrawDestroyWindow(VAR_0->gw);
return( true );
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/fontview.c/vul/before/0.json,"static int _FVMenuClose(FontView *fv) {
    int i;
    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;

    if ( !SFCloseAllInstrs(fv->b.sf) )
return( false );

    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {
	/* There's another view, can close this one with no problems */
    } else if ( warn_script_unsaved && fv->script_unsaved && 
                AskScriptChanged()==2 ) {
        return false;
    } else if ( SFAnyChanged(sf) ) {
	i = AskChanged(fv->b.sf);
	if ( i==2 )	/* Cancel */
return( false );
	if ( i==0 && !_FVMenuSave(fv))		/* Save */
return(false);
	else
	    SFClearAutoSave(sf);		/* if they didn't save it, remove change record */
    }
    _FVCloseWindows(fv);
    if ( sf->filename!=NULL )
	RecentFilesRemember(sf->filename);
    else if ( sf->origname!=NULL )
	RecentFilesRemember(sf->origname);
    GDrawDestroyWindow(fv->gw);
return( true );
}","static int _FVMenuClose(FontView *VAR_0) {
    int VAR_1;
    SplineFont *VAR_2 = VAR_0->b.cidmaster?VAR_0->b.cidmaster:VAR_0->b.sf;

    if ( !SFCloseAllInstrs(VAR_0->b.sf) )
return( false );

    if ( VAR_0->b.nextsame!=NULL || VAR_0->b.sf->fv!=&VAR_0->b ) {
	/* COMMENT_0 */
    } else if ( VAR_3 && VAR_0->script_unsaved && 
                AskScriptChanged()==2 ) {
        return false;
    } else if ( SFAnyChanged(VAR_2) ) {
	VAR_1 = AskChanged(VAR_0->b.sf);
	if ( VAR_1==2 )	/* COMMENT_1 */
return( false );
	if ( VAR_1==0 && !_FVMenuSave(VAR_0))		/* COMMENT_2 */
return(false);
	else
	    SFClearAutoSave(VAR_2);		/* COMMENT_3 */
    }
    _FVCloseWindows(VAR_0);
    if ( VAR_2->filename!=NULL )
	RecentFilesRemember(VAR_2->filename);
    else if ( VAR_2->origname!=NULL )
	RecentFilesRemember(VAR_2->origname);
    GDrawDestroyWindow(VAR_0->gw);
return( true );
}",fontforge/626f751752875a0ddd74b9e217b6f4828713573c/fontview.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,9 @@
 
     if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {
 	/* There's another view, can close this one with no problems */
+    } else if ( warn_script_unsaved && fv->script_unsaved && 
+                AskScriptChanged()==2 ) {
+        return false;
     } else if ( SFAnyChanged(sf) ) {
 	i = AskChanged(fv->b.sf);
 	if ( i==2 )	/* Cancel */","{'deleted_lines': [], 'added_lines': ['    } else if ( warn_script_unsaved && fv->script_unsaved && ', '                AskScriptChanged()==2 ) {', '        return false;']}",True,FontForge 20190813 through 20190820 has a buffer overflow in PrefsUI_LoadPrefs in prefs.c.,9.8,CRITICAL,3,valid,2019-08-13T11:09:59Z,2
