cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2014-125017,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
rpza: limit the number of blocks to the total remaining blocks in the frame

Fixes invalid writes.

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
CC:libav-stable@libav.org
",77bb0004bbe18f1498cfecdc68db5f10808b6599,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=77bb0004bbe18f1498cfecdc68db5f10808b6599,libavcodec/rpza.c,rpza_decode_stream,"static void rpza_decode_stream(RpzaContext *s)
{
int width = s->avctx->width;
int stride = s->frame->linesize[0] / 2;
int row_inc = stride - 4;
int chunk_size;
uint16_t colorA = 0, colorB;
uint16_t color4[4];
uint16_t ta, tb;
uint16_t *pixels = (uint16_t *)s->frame->data[0];
int row_ptr = 0;
int pixel_ptr = 0;
int block_ptr;
int pixel_x, pixel_y;
int total_blocks;
if (bytestream2_peek_byte(&s->gb) != 0xe1)
av_log(s->avctx, AV_LOG_ERROR, ""First chunk byte is 0x%02x instead of 0xe1\n"",
bytestream2_peek_byte(&s->gb));
chunk_size = bytestream2_get_be32(&s->gb) & 0x00FFFFFF;
if (chunk_size != bytestream2_get_bytes_left(&s->gb) - 4)
av_log(s->avctx, AV_LOG_WARNING, ""MOV chunk size != encoded chunk size\n"");
total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);
while (bytestream2_get_bytes_left(&s->gb)) {
uint8_t opcode = bytestream2_get_byte(&s->gb); 
int n_blocks = (opcode & 0x1f) + 1; 
if ((opcode & 0x80) == 0) {
colorA = (opcode << 8) | bytestream2_get_byte(&s->gb);
opcode = 0;
if ((bytestream2_peek_byte(&s->gb) & 0x80) != 0) {
opcode = 0x20;
n_blocks = 1;
}
}
switch (opcode & 0xe0) {
case 0x80:
while (n_blocks--) {
ADVANCE_BLOCK();
}
break;
case 0xa0:
colorA = bytestream2_get_be16(&s->gb);
while (n_blocks--) {
block_ptr = row_ptr + pixel_ptr;
for (pixel_y = 0; pixel_y < 4; pixel_y++) {
for (pixel_x = 0; pixel_x < 4; pixel_x++){
pixels[block_ptr] = colorA;
block_ptr++;
}
block_ptr += row_inc;
}
ADVANCE_BLOCK();
}
break;
case 0xc0:
colorA = bytestream2_get_be16(&s->gb);
case 0x20:
colorB = bytestream2_get_be16(&s->gb);
color4[0] = colorB;
color4[1] = 0;
color4[2] = 0;
color4[3] = colorA;
ta = (colorA >> 10) & 0x1F;
tb = (colorB >> 10) & 0x1F;
color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;
color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;
ta = (colorA >> 5) & 0x1F;
tb = (colorB >> 5) & 0x1F;
color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;
color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;
ta = colorA & 0x1F;
tb = colorB & 0x1F;
color4[1] |= ((11 * ta + 21 * tb) >> 5);
color4[2] |= ((21 * ta + 11 * tb) >> 5);
if (bytestream2_get_bytes_left(&s->gb) < n_blocks * 4)
return;
while (n_blocks--) {
block_ptr = row_ptr + pixel_ptr;
for (pixel_y = 0; pixel_y < 4; pixel_y++) {
uint8_t index = bytestream2_get_byteu(&s->gb);
for (pixel_x = 0; pixel_x < 4; pixel_x++){
uint8_t idx = (index >> (2 * (3 - pixel_x))) & 0x03;
pixels[block_ptr] = color4[idx];
block_ptr++;
}
block_ptr += row_inc;
}
ADVANCE_BLOCK();
}
break;
case 0x00:
if (bytestream2_get_bytes_left(&s->gb) < 30)
return;
block_ptr = row_ptr + pixel_ptr;
for (pixel_y = 0; pixel_y < 4; pixel_y++) {
for (pixel_x = 0; pixel_x < 4; pixel_x++){
if ((pixel_y != 0) || (pixel_x != 0))
colorA = bytestream2_get_be16u(&s->gb);
pixels[block_ptr] = colorA;
block_ptr++;
}
block_ptr += row_inc;
}
ADVANCE_BLOCK();
break;
default:
av_log(s->avctx, AV_LOG_ERROR, ""Unknown opcode %d in rpza chunk.""
"" Skip remaining %d bytes of chunk data.\n"", opcode,
bytestream2_get_bytes_left(&s->gb));
return;
} 
}
}","static void rpza_decode_stream(RpzaContext *VAR_0)
{
int VAR_1 = VAR_0->avctx->width;
int VAR_2 = VAR_0->frame->linesize[0] / 2;
int VAR_3 = VAR_2 - 4;
int VAR_4;
uint16_t VAR_5 = 0, VAR_6;
uint16_t VAR_7[4];
uint16_t VAR_8, VAR_9;
uint16_t *VAR_10 = (uint16_t *)VAR_0->frame->data[0];
int VAR_11 = 0;
int VAR_12 = 0;
int VAR_13;
int VAR_14, VAR_15;
int VAR_16;
if (bytestream2_peek_byte(&VAR_0->gb) != 0xe1)
av_log(VAR_0->avctx, VAR_17, ""First chunk byte is 0x%02x instead of 0xe1\n"",
bytestream2_peek_byte(&VAR_0->gb));
VAR_4 = bytestream2_get_be32(&VAR_0->gb) & 0x00FFFFFF;
if (VAR_4 != bytestream2_get_bytes_left(&VAR_0->gb) - 4)
av_log(VAR_0->avctx, VAR_18, ""MOV chunk size != encoded chunk size\n"");
VAR_16 = ((VAR_0->avctx->width + 3) / 4) * ((VAR_0->avctx->height + 3) / 4);
while (bytestream2_get_bytes_left(&VAR_0->gb)) {
uint8_t VAR_19 = bytestream2_get_byte(&VAR_0->gb); 
int VAR_20 = (VAR_19 & 0x1f) + 1; 
if ((VAR_19 & 0x80) == 0) {
VAR_5 = (VAR_19 << 8) | bytestream2_get_byte(&VAR_0->gb);
VAR_19 = 0;
if ((bytestream2_peek_byte(&VAR_0->gb) & 0x80) != 0) {
VAR_19 = 0x20;
VAR_20 = 1;
}
}
switch (VAR_19 & 0xe0) {
case 0x80:
while (VAR_20--) {
ADVANCE_BLOCK();
}
break;
case 0xa0:
VAR_5 = bytestream2_get_be16(&VAR_0->gb);
while (VAR_20--) {
VAR_13 = VAR_11 + VAR_12;
for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
VAR_10[VAR_13] = VAR_5;
VAR_13++;
}
VAR_13 += VAR_3;
}
ADVANCE_BLOCK();
}
break;
case 0xc0:
VAR_5 = bytestream2_get_be16(&VAR_0->gb);
case 0x20:
VAR_6 = bytestream2_get_be16(&VAR_0->gb);
VAR_7[0] = VAR_6;
VAR_7[1] = 0;
VAR_7[2] = 0;
VAR_7[3] = VAR_5;
VAR_8 = (VAR_5 >> 10) & 0x1F;
VAR_9 = (VAR_6 >> 10) & 0x1F;
VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5) << 10;
VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5) << 10;
VAR_8 = (VAR_5 >> 5) & 0x1F;
VAR_9 = (VAR_6 >> 5) & 0x1F;
VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5) << 5;
VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5) << 5;
VAR_8 = VAR_5 & 0x1F;
VAR_9 = VAR_6 & 0x1F;
VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5);
VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5);
if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_20 * 4)
return;
while (VAR_20--) {
VAR_13 = VAR_11 + VAR_12;
for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
uint8_t VAR_21 = bytestream2_get_byteu(&VAR_0->gb);
for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
uint8_t VAR_22 = (VAR_21 >> (2 * (3 - VAR_14))) & 0x03;
VAR_10[VAR_13] = VAR_7[VAR_22];
VAR_13++;
}
VAR_13 += VAR_3;
}
ADVANCE_BLOCK();
}
break;
case 0x00:
if (bytestream2_get_bytes_left(&VAR_0->gb) < 30)
return;
VAR_13 = VAR_11 + VAR_12;
for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
if ((VAR_15 != 0) || (VAR_14 != 0))
VAR_5 = bytestream2_get_be16u(&VAR_0->gb);
VAR_10[VAR_13] = VAR_5;
VAR_13++;
}
VAR_13 += VAR_3;
}
ADVANCE_BLOCK();
break;
default:
av_log(VAR_0->avctx, VAR_17, ""Unknown opcode %d in rpza chunk.""
"" Skip remaining %d bytes of chunk data.\n"", VAR_19,
bytestream2_get_bytes_left(&VAR_0->gb));
return;
} 
}
}",ffmpeg/77bb0004bbe18f1498cfecdc68db5f10808b6599/rpza.c/vul/before/0.json,"static void rpza_decode_stream(RpzaContext *s)
{
    int width = s->avctx->width;
    int stride = s->frame->linesize[0] / 2;
    int row_inc = stride - 4;
    int chunk_size;
    uint16_t colorA = 0, colorB;
    uint16_t color4[4];
    uint16_t ta, tb;
    uint16_t *pixels = (uint16_t *)s->frame->data[0];

    int row_ptr = 0;
    int pixel_ptr = 0;
    int block_ptr;
    int pixel_x, pixel_y;
    int total_blocks;

    /* First byte is always 0xe1. Warn if it's different */
    if (bytestream2_peek_byte(&s->gb) != 0xe1)
        av_log(s->avctx, AV_LOG_ERROR, ""First chunk byte is 0x%02x instead of 0xe1\n"",
               bytestream2_peek_byte(&s->gb));

    /* Get chunk size, ingnoring first byte */
    chunk_size = bytestream2_get_be32(&s->gb) & 0x00FFFFFF;

    /* If length mismatch use size from MOV file and try to decode anyway */
    if (chunk_size != bytestream2_get_bytes_left(&s->gb) - 4)
        av_log(s->avctx, AV_LOG_WARNING, ""MOV chunk size != encoded chunk size\n"");

    /* Number of 4x4 blocks in frame. */
    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);

    /* Process chunk data */
    while (bytestream2_get_bytes_left(&s->gb)) {
        uint8_t opcode = bytestream2_get_byte(&s->gb); /* Get opcode */

        int n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */

        /* If opcode MSbit is 0, we need more data to decide what to do */
        if ((opcode & 0x80) == 0) {
            colorA = (opcode << 8) | bytestream2_get_byte(&s->gb);
            opcode = 0;
            if ((bytestream2_peek_byte(&s->gb) & 0x80) != 0) {
                /* Must behave as opcode 110xxxxx, using colorA computed
                 * above. Use fake opcode 0x20 to enter switch block at
                 * the right place */
                opcode = 0x20;
                n_blocks = 1;
            }
        }

        n_blocks = FFMIN(n_blocks, total_blocks);

        switch (opcode & 0xe0) {

        /* Skip blocks */
        case 0x80:
            while (n_blocks--) {
              ADVANCE_BLOCK();
            }
            break;

        /* Fill blocks with one color */
        case 0xa0:
            colorA = bytestream2_get_be16(&s->gb);
            while (n_blocks--) {
                block_ptr = row_ptr + pixel_ptr;
                for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                    for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        pixels[block_ptr] = colorA;
                        block_ptr++;
                    }
                    block_ptr += row_inc;
                }
                ADVANCE_BLOCK();
            }
            break;

        /* Fill blocks with 4 colors */
        case 0xc0:
            colorA = bytestream2_get_be16(&s->gb);
        case 0x20:
            colorB = bytestream2_get_be16(&s->gb);

            /* sort out the colors */
            color4[0] = colorB;
            color4[1] = 0;
            color4[2] = 0;
            color4[3] = colorA;

            /* red components */
            ta = (colorA >> 10) & 0x1F;
            tb = (colorB >> 10) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;

            /* green components */
            ta = (colorA >> 5) & 0x1F;
            tb = (colorB >> 5) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;

            /* blue components */
            ta = colorA & 0x1F;
            tb = colorB & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5);
            color4[2] |= ((21 * ta + 11 * tb) >> 5);

            if (bytestream2_get_bytes_left(&s->gb) < n_blocks * 4)
                return;
            while (n_blocks--) {
                block_ptr = row_ptr + pixel_ptr;
                for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                    uint8_t index = bytestream2_get_byteu(&s->gb);
                    for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        uint8_t idx = (index >> (2 * (3 - pixel_x))) & 0x03;
                        pixels[block_ptr] = color4[idx];
                        block_ptr++;
                    }
                    block_ptr += row_inc;
                }
                ADVANCE_BLOCK();
            }
            break;

        /* Fill block with 16 colors */
        case 0x00:
            if (bytestream2_get_bytes_left(&s->gb) < 30)
                return;
            block_ptr = row_ptr + pixel_ptr;
            for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                for (pixel_x = 0; pixel_x < 4; pixel_x++){
                    /* We already have color of upper left pixel */
                    if ((pixel_y != 0) || (pixel_x != 0))
                        colorA = bytestream2_get_be16u(&s->gb);
                    pixels[block_ptr] = colorA;
                    block_ptr++;
                }
                block_ptr += row_inc;
            }
            ADVANCE_BLOCK();
            break;

        /* Unknown opcode */
        default:
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown opcode %d in rpza chunk.""
                 "" Skip remaining %d bytes of chunk data.\n"", opcode,
                 bytestream2_get_bytes_left(&s->gb));
            return;
        } /* Opcode switch */
    }
}","static void rpza_decode_stream(RpzaContext *VAR_0)
{
    int VAR_1 = VAR_0->avctx->width;
    int VAR_2 = VAR_0->frame->linesize[0] / 2;
    int VAR_3 = VAR_2 - 4;
    int VAR_4;
    uint16_t VAR_5 = 0, VAR_6;
    uint16_t VAR_7[4];
    uint16_t VAR_8, VAR_9;
    uint16_t *VAR_10 = (uint16_t *)VAR_0->frame->data[0];

    int VAR_11 = 0;
    int VAR_12 = 0;
    int VAR_13;
    int VAR_14, VAR_15;
    int VAR_16;

    /* COMMENT_0 */
    if (bytestream2_peek_byte(&VAR_0->gb) != 0xe1)
        av_log(VAR_0->avctx, VAR_17, ""First chunk byte is 0x%02x instead of 0xe1\n"",
               bytestream2_peek_byte(&VAR_0->gb));

    /* COMMENT_1 */
    VAR_4 = bytestream2_get_be32(&VAR_0->gb) & 0x00FFFFFF;

    /* COMMENT_2 */
    if (VAR_4 != bytestream2_get_bytes_left(&VAR_0->gb) - 4)
        av_log(VAR_0->avctx, VAR_18, ""MOV chunk size != encoded chunk size\n"");

    /* COMMENT_3 */
    VAR_16 = ((VAR_0->avctx->width + 3) / 4) * ((VAR_0->avctx->height + 3) / 4);

    /* COMMENT_4 */
    while (bytestream2_get_bytes_left(&VAR_0->gb)) {
        uint8_t VAR_19 = bytestream2_get_byte(&VAR_0->gb); /* COMMENT_5 */

        int VAR_20 = (VAR_19 & 0x1f) + 1; /* COMMENT_6 */

        /* COMMENT_7 */
        if ((VAR_19 & 0x80) == 0) {
            VAR_5 = (VAR_19 << 8) | bytestream2_get_byte(&VAR_0->gb);
            VAR_19 = 0;
            if ((bytestream2_peek_byte(&VAR_0->gb) & 0x80) != 0) {
                /* COMMENT_8 */
                                                                       
                                     
                VAR_19 = 0x20;
                VAR_20 = 1;
            }
        }

        VAR_20 = FFMIN(VAR_20, VAR_16);

        switch (VAR_19 & 0xe0) {

        /* COMMENT_11 */
        case 0x80:
            while (VAR_20--) {
              ADVANCE_BLOCK();
            }
            break;

        /* COMMENT_12 */
        case 0xa0:
            VAR_5 = bytestream2_get_be16(&VAR_0->gb);
            while (VAR_20--) {
                VAR_13 = VAR_11 + VAR_12;
                for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
                    for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
                        VAR_10[VAR_13] = VAR_5;
                        VAR_13++;
                    }
                    VAR_13 += VAR_3;
                }
                ADVANCE_BLOCK();
            }
            break;

        /* COMMENT_13 */
        case 0xc0:
            VAR_5 = bytestream2_get_be16(&VAR_0->gb);
        case 0x20:
            VAR_6 = bytestream2_get_be16(&VAR_0->gb);

            /* COMMENT_14 */
            VAR_7[0] = VAR_6;
            VAR_7[1] = 0;
            VAR_7[2] = 0;
            VAR_7[3] = VAR_5;

            /* COMMENT_15 */
            VAR_8 = (VAR_5 >> 10) & 0x1F;
            VAR_9 = (VAR_6 >> 10) & 0x1F;
            VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5) << 10;
            VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5) << 10;

            /* COMMENT_16 */
            VAR_8 = (VAR_5 >> 5) & 0x1F;
            VAR_9 = (VAR_6 >> 5) & 0x1F;
            VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5) << 5;
            VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5) << 5;

            /* COMMENT_17 */
            VAR_8 = VAR_5 & 0x1F;
            VAR_9 = VAR_6 & 0x1F;
            VAR_7[1] |= ((11 * VAR_8 + 21 * VAR_9) >> 5);
            VAR_7[2] |= ((21 * VAR_8 + 11 * VAR_9) >> 5);

            if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_20 * 4)
                return;
            while (VAR_20--) {
                VAR_13 = VAR_11 + VAR_12;
                for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
                    uint8_t VAR_21 = bytestream2_get_byteu(&VAR_0->gb);
                    for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
                        uint8_t VAR_22 = (VAR_21 >> (2 * (3 - VAR_14))) & 0x03;
                        VAR_10[VAR_13] = VAR_7[VAR_22];
                        VAR_13++;
                    }
                    VAR_13 += VAR_3;
                }
                ADVANCE_BLOCK();
            }
            break;

        /* COMMENT_18 */
        case 0x00:
            if (bytestream2_get_bytes_left(&VAR_0->gb) < 30)
                return;
            VAR_13 = VAR_11 + VAR_12;
            for (VAR_15 = 0; VAR_15 < 4; VAR_15++) {
                for (VAR_14 = 0; VAR_14 < 4; VAR_14++){
                    /* COMMENT_19 */
                    if ((VAR_15 != 0) || (VAR_14 != 0))
                        VAR_5 = bytestream2_get_be16u(&VAR_0->gb);
                    VAR_10[VAR_13] = VAR_5;
                    VAR_13++;
                }
                VAR_13 += VAR_3;
            }
            ADVANCE_BLOCK();
            break;

        /* COMMENT_20 */
        default:
            av_log(VAR_0->avctx, VAR_17, ""Unknown opcode %d in rpza chunk.""
                 "" Skip remaining %d bytes of chunk data.\n"", VAR_19,
                 bytestream2_get_bytes_left(&VAR_0->gb));
            return;
        } /* COMMENT_21 */
    }
}",ffmpeg/77bb0004bbe18f1498cfecdc68db5f10808b6599/rpza.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -48,6 +48,8 @@
                 n_blocks = 1;
             }
         }
+
+        n_blocks = FFMIN(n_blocks, total_blocks);
 
         switch (opcode & 0xe0) {
 ","{'deleted_lines': [], 'added_lines': ['', '        n_blocks = FFMIN(n_blocks, total_blocks);']}",True,A vulnerability classified as critical was found in FFmpeg 2.0. This vulnerability affects the function rpza_decode_stream. The manipulation leads to memory corruption. The attack can be initiated remotely. The name of the patch is Fixes Invalid Writes. It is recommended to apply a patch to fix this issue.,7.8,HIGH,2,valid,,5
CVE-2014-125022,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
shorten: pad the internal bitstream buffer

Fixes invalid reads.

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
CC:libav-stable@libav.org
",1713eec29add37b654ec6bf262b843d139c1ffc6,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=1713eec29a,libavcodec/shorten.c,shorten_decode_frame,"static int shorten_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt)
{
AVFrame *frame     = data;
const uint8_t *buf = avpkt->data;
int buf_size       = avpkt->size;
ShortenContext *s  = avctx->priv_data;
int i, input_buf_size = 0;
int ret;
if (s->max_framesize == 0) {
void *tmp_ptr;
s->max_framesize = 1024;         tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,
s->max_framesize);
if (!tmp_ptr) {
av_log(avctx, AV_LOG_ERROR, ""error allocating bitstream buffer\n"");
return AVERROR(ENOMEM);
}
s->bitstream = tmp_ptr;
}
if (1 && s->max_framesize) {         buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);
input_buf_size = buf_size;
if (s->bitstream_index + s->bitstream_size + buf_size >
s->allocated_bitstream_size) {
memmove(s->bitstream, &s->bitstream[s->bitstream_index],
s->bitstream_size);
s->bitstream_index = 0;
}
if (buf)
memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,
buf_size);
buf               = &s->bitstream[s->bitstream_index];
buf_size         += s->bitstream_size;
s->bitstream_size = buf_size;
if (buf_size < s->max_framesize && avpkt->data) {
*got_frame_ptr = 0;
return input_buf_size;
}
}
init_get_bits(&s->gb, buf, buf_size * 8);
skip_bits(&s->gb, s->bitindex);
if (!s->got_header) {
if ((ret = read_header(s)) < 0)
return ret;
*got_frame_ptr = 0;
goto finish_frame;
}
if (s->got_quit_command) {
*got_frame_ptr = 0;
return avpkt->size;
}
s->cur_chan = 0;
while (s->cur_chan < s->channels) {
unsigned cmd;
int len;
if (get_bits_left(&s->gb) < 3 + FNSIZE) {
*got_frame_ptr = 0;
break;
}
cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);
if (cmd > FN_VERBATIM) {
av_log(avctx, AV_LOG_ERROR, ""unknown shorten function %d\n"", cmd);
*got_frame_ptr = 0;
break;
}
if (!is_audio_command[cmd]) {
switch (cmd) {
case FN_VERBATIM:
len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);
while (len--)
get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);
break;
case FN_BITSHIFT:
s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);
break;
case FN_BLOCKSIZE: {
unsigned blocksize = get_uint(s, av_log2(s->blocksize));
if (blocksize > s->blocksize) {
av_log(avctx, AV_LOG_ERROR,
""Increasing block size is not supported\n"");
return AVERROR_PATCHWELCOME;
}
if (!blocksize || blocksize > MAX_BLOCKSIZE) {
av_log(avctx, AV_LOG_ERROR, ""invalid or unsupported ""
""block size: %d\n"", blocksize);
return AVERROR(EINVAL);
}
s->blocksize = blocksize;
break;
}
case FN_QUIT:
s->got_quit_command = 1;
break;
}
if (cmd == FN_BLOCKSIZE || cmd == FN_QUIT) {
*got_frame_ptr = 0;
break;
}
} else {
int residual_size = 0;
int channel = s->cur_chan;
int32_t coffset;
if (cmd != FN_ZERO) {
residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);
if (s->version == 0)
residual_size--;
}
if (s->nmean == 0)
coffset = s->offset[channel][0];
else {
int32_t sum = (s->version < 2) ? 0 : s->nmean / 2;
for (i = 0; i < s->nmean; i++)
sum += s->offset[channel][i];
coffset = sum / s->nmean;
if (s->version >= 2)
coffset >>= FFMIN(1, s->bitshift);
}
if (cmd == FN_ZERO) {
for (i = 0; i < s->blocksize; i++)
s->decoded[channel][i] = 0;
} else {
if ((ret = decode_subframe_lpc(s, cmd, channel,
residual_size, coffset)) < 0)
return ret;
}
if (s->nmean > 0) {
int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2;
for (i = 0; i < s->blocksize; i++)
sum += s->decoded[channel][i];
for (i = 1; i < s->nmean; i++)
s->offset[channel][i - 1] = s->offset[channel][i];
if (s->version < 2)
s->offset[channel][s->nmean - 1] = sum / s->blocksize;
else
s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift;
}
for (i = -s->nwrap; i < 0; i++)
s->decoded[channel][i] = s->decoded[channel][i + s->blocksize];
fix_bitshift(s, s->decoded[channel]);
s->cur_chan++;
if (s->cur_chan == s->channels) {
frame->nb_samples = s->blocksize;
if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
return ret;
}
output_buffer((int16_t **)frame->extended_data, s->channels,
s->blocksize, s->decoded);
*got_frame_ptr = 1;
}
}
}
if (s->cur_chan < s->channels)
*got_frame_ptr = 0;
finish_frame:
s->bitindex = get_bits_count(&s->gb) - 8 * (get_bits_count(&s->gb) / 8);
i           = get_bits_count(&s->gb) / 8;
if (i > buf_size) {
av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size);
s->bitstream_size  = 0;
s->bitstream_index = 0;
return AVERROR_INVALIDDATA;
}
if (s->bitstream_size) {
s->bitstream_index += i;
s->bitstream_size  -= i;
return input_buf_size;
} else
return i;
}","static int shorten_decode_frame(AVCodecContext *VAR_0, void *VAR_1,
int *VAR_2, AVPacket *VAR_3)
{
AVFrame *VAR_4     = VAR_1;
const uint8_t *VAR_5 = VAR_3->data;
int VAR_6       = VAR_3->size;
ShortenContext *VAR_7  = VAR_0->priv_data;
int VAR_8, VAR_9 = 0;
int VAR_10;
if (VAR_7->max_framesize == 0) {
void *VAR_11;
VAR_7->max_framesize = 1024; 
VAR_11 = av_fast_realloc(VAR_7->bitstream, &VAR_7->allocated_bitstream_size,
VAR_7->max_framesize);
if (!VAR_11) {
av_log(VAR_0, VAR_12, ""error allocating bitstream buffer\n"");
return AVERROR(VAR_13);
}
VAR_7->bitstream = VAR_11;
}
if (1 && VAR_7->max_framesize) { 
VAR_6       = FFMIN(VAR_6, VAR_7->max_framesize - VAR_7->bitstream_size);
VAR_9 = VAR_6;
if (VAR_7->bitstream_index + VAR_7->bitstream_size + VAR_6 >
VAR_7->allocated_bitstream_size) {
memmove(VAR_7->bitstream, &VAR_7->bitstream[VAR_7->bitstream_index],
VAR_7->bitstream_size);
VAR_7->bitstream_index = 0;
}
if (VAR_5)
memcpy(&VAR_7->bitstream[VAR_7->bitstream_index + VAR_7->bitstream_size], VAR_5,
VAR_6);
VAR_5               = &VAR_7->bitstream[VAR_7->bitstream_index];
VAR_6         += VAR_7->bitstream_size;
VAR_7->bitstream_size = VAR_6;
if (VAR_6 < VAR_7->max_framesize && VAR_3->data) {
*VAR_2 = 0;
return VAR_9;
}
}
init_get_bits(&VAR_7->gb, VAR_5, VAR_6 * 8);
skip_bits(&VAR_7->gb, VAR_7->bitindex);
if (!VAR_7->got_header) {
if ((VAR_10 = read_header(VAR_7)) < 0)
return VAR_10;
*VAR_2 = 0;
goto finish_frame;
}
if (VAR_7->got_quit_command) {
*VAR_2 = 0;
return VAR_3->size;
}
VAR_7->cur_chan = 0;
while (VAR_7->cur_chan < VAR_7->channels) {
unsigned VAR_14;
int VAR_15;
if (get_bits_left(&VAR_7->gb) < 3 + VAR_16) {
*VAR_2 = 0;
break;
}
VAR_14 = get_ur_golomb_shorten(&VAR_7->gb, VAR_16);
if (VAR_14 > VAR_17) {
av_log(VAR_0, VAR_12, ""unknown shorten function %d\n"", VAR_14);
*VAR_2 = 0;
break;
}
if (!VAR_18[VAR_14]) {
switch (VAR_14) {
case VAR_17:
VAR_15 = get_ur_golomb_shorten(&VAR_7->gb, VAR_19);
while (VAR_15--)
get_ur_golomb_shorten(&VAR_7->gb, VAR_20);
break;
case VAR_21:
VAR_7->bitshift = get_ur_golomb_shorten(&VAR_7->gb, VAR_22);
break;
case VAR_23: {
unsigned VAR_24 = get_uint(VAR_7, av_log2(VAR_7->blocksize));
if (VAR_24 > VAR_7->blocksize) {
av_log(VAR_0, VAR_12,
""Increasing block size is not supported\n"");
return VAR_25;
}
if (!VAR_24 || VAR_24 > VAR_26) {
av_log(VAR_0, VAR_12, ""invalid or unsupported ""
""block size: %d\n"", VAR_24);
return AVERROR(VAR_27);
}
VAR_7->blocksize = VAR_24;
break;
}
case VAR_28:
VAR_7->got_quit_command = 1;
break;
}
if (VAR_14 == VAR_23 || VAR_14 == VAR_28) {
*VAR_2 = 0;
break;
}
} else {
int VAR_29 = 0;
int VAR_30 = VAR_7->cur_chan;
int32_t VAR_31;
if (VAR_14 != VAR_32) {
VAR_29 = get_ur_golomb_shorten(&VAR_7->gb, VAR_33);
if (VAR_7->version == 0)
VAR_29--;
}
if (VAR_7->nmean == 0)
VAR_31 = VAR_7->offset[VAR_30][0];
else {
int32_t VAR_34 = (VAR_7->version < 2) ? 0 : VAR_7->nmean / 2;
for (VAR_8 = 0; VAR_8 < VAR_7->nmean; VAR_8++)
VAR_34 += VAR_7->offset[VAR_30][VAR_8];
VAR_31 = VAR_34 / VAR_7->nmean;
if (VAR_7->version >= 2)
VAR_31 >>= FFMIN(1, VAR_7->bitshift);
}
if (VAR_14 == VAR_32) {
for (VAR_8 = 0; VAR_8 < VAR_7->blocksize; VAR_8++)
VAR_7->decoded[VAR_30][VAR_8] = 0;
} else {
if ((VAR_10 = decode_subframe_lpc(VAR_7, VAR_14, VAR_30,
VAR_29, VAR_31)) < 0)
return VAR_10;
}
if (VAR_7->nmean > 0) {
int32_t VAR_34 = (VAR_7->version < 2) ? 0 : VAR_7->blocksize / 2;
for (VAR_8 = 0; VAR_8 < VAR_7->blocksize; VAR_8++)
VAR_34 += VAR_7->decoded[VAR_30][VAR_8];
for (VAR_8 = 1; VAR_8 < VAR_7->nmean; VAR_8++)
VAR_7->offset[VAR_30][VAR_8 - 1] = VAR_7->offset[VAR_30][VAR_8];
if (VAR_7->version < 2)
VAR_7->offset[VAR_30][VAR_7->nmean - 1] = VAR_34 / VAR_7->blocksize;
else
VAR_7->offset[VAR_30][VAR_7->nmean - 1] = (VAR_34 / VAR_7->blocksize) << VAR_7->bitshift;
}
for (VAR_8 = -VAR_7->nwrap; VAR_8 < 0; VAR_8++)
VAR_7->decoded[VAR_30][VAR_8] = VAR_7->decoded[VAR_30][VAR_8 + VAR_7->blocksize];
fix_bitshift(VAR_7, VAR_7->decoded[VAR_30]);
VAR_7->cur_chan++;
if (VAR_7->cur_chan == VAR_7->channels) {
VAR_4->nb_samples = VAR_7->blocksize;
if ((VAR_10 = ff_get_buffer(VAR_0, VAR_4, 0)) < 0) {
av_log(VAR_0, VAR_12, ""get_buffer() failed\n"");
return VAR_10;
}
output_buffer((int16_t **)VAR_4->extended_data, VAR_7->channels,
VAR_7->blocksize, VAR_7->decoded);
*VAR_2 = 1;
}
}
}
if (VAR_7->cur_chan < VAR_7->channels)
*VAR_2 = 0;
finish_frame:
VAR_7->bitindex = get_bits_count(&VAR_7->gb) - 8 * (get_bits_count(&VAR_7->gb) / 8);
VAR_8           = get_bits_count(&VAR_7->gb) / 8;
if (VAR_8 > VAR_6) {
av_log(VAR_7->avctx, VAR_12, ""overread: %d\n"", VAR_8 - VAR_6);
VAR_7->bitstream_size  = 0;
VAR_7->bitstream_index = 0;
return VAR_35;
}
if (VAR_7->bitstream_size) {
VAR_7->bitstream_index += VAR_8;
VAR_7->bitstream_size  -= VAR_8;
return VAR_9;
} else
return VAR_8;
}",ffmpeg/1713eec29add37b654ec6bf262b843d139c1ffc6/shorten.c/vul/before/0.json,"static int shorten_decode_frame(AVCodecContext *avctx, void *data,
                                int *got_frame_ptr, AVPacket *avpkt)
{
    AVFrame *frame     = data;
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    ShortenContext *s  = avctx->priv_data;
    int i, input_buf_size = 0;
    int ret;

    /* allocate internal bitstream buffer */
    if (s->max_framesize == 0) {
        void *tmp_ptr;
        s->max_framesize = 1024; // should hopefully be enough for the first header
        tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,
                                  s->max_framesize + FF_INPUT_BUFFER_PADDING_SIZE);
        if (!tmp_ptr) {
            av_log(avctx, AV_LOG_ERROR, ""error allocating bitstream buffer\n"");
            return AVERROR(ENOMEM);
        }
        s->bitstream = tmp_ptr;
    }

    /* append current packet data to bitstream buffer */
    if (1 && s->max_framesize) { //FIXME truncated
        buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);
        input_buf_size = buf_size;

        if (s->bitstream_index + s->bitstream_size + buf_size >
            s->allocated_bitstream_size) {
            memmove(s->bitstream, &s->bitstream[s->bitstream_index],
                    s->bitstream_size);
            s->bitstream_index = 0;
        }
        if (buf)
            memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,
                   buf_size);
        buf               = &s->bitstream[s->bitstream_index];
        buf_size         += s->bitstream_size;
        s->bitstream_size = buf_size;

        /* do not decode until buffer has at least max_framesize bytes or
         * the end of the file has been reached */
        if (buf_size < s->max_framesize && avpkt->data) {
            *got_frame_ptr = 0;
            return input_buf_size;
        }
    }
    /* init and position bitstream reader */
    init_get_bits(&s->gb, buf, buf_size * 8);
    skip_bits(&s->gb, s->bitindex);

    /* process header or next subblock */
    if (!s->got_header) {
        if ((ret = read_header(s)) < 0)
            return ret;
        *got_frame_ptr = 0;
        goto finish_frame;
    }

    /* if quit command was read previously, don't decode anything */
    if (s->got_quit_command) {
        *got_frame_ptr = 0;
        return avpkt->size;
    }

    s->cur_chan = 0;
    while (s->cur_chan < s->channels) {
        unsigned cmd;
        int len;

        if (get_bits_left(&s->gb) < 3 + FNSIZE) {
            *got_frame_ptr = 0;
            break;
        }

        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);

        if (cmd > FN_VERBATIM) {
            av_log(avctx, AV_LOG_ERROR, ""unknown shorten function %d\n"", cmd);
            *got_frame_ptr = 0;
            break;
        }

        if (!is_audio_command[cmd]) {
            /* process non-audio command */
            switch (cmd) {
            case FN_VERBATIM:
                len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);
                while (len--)
                    get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);
                break;
            case FN_BITSHIFT:
                s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);
                break;
            case FN_BLOCKSIZE: {
                unsigned blocksize = get_uint(s, av_log2(s->blocksize));
                if (blocksize > s->blocksize) {
                    av_log(avctx, AV_LOG_ERROR,
                           ""Increasing block size is not supported\n"");
                    return AVERROR_PATCHWELCOME;
                }
                if (!blocksize || blocksize > MAX_BLOCKSIZE) {
                    av_log(avctx, AV_LOG_ERROR, ""invalid or unsupported ""
                                                ""block size: %d\n"", blocksize);
                    return AVERROR(EINVAL);
                }
                s->blocksize = blocksize;
                break;
            }
            case FN_QUIT:
                s->got_quit_command = 1;
                break;
            }
            if (cmd == FN_BLOCKSIZE || cmd == FN_QUIT) {
                *got_frame_ptr = 0;
                break;
            }
        } else {
            /* process audio command */
            int residual_size = 0;
            int channel = s->cur_chan;
            int32_t coffset;

            /* get Rice code for residual decoding */
            if (cmd != FN_ZERO) {
                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);
                /* This is a hack as version 0 differed in the definition
                 * of get_sr_golomb_shorten(). */
                if (s->version == 0)
                    residual_size--;
            }

            /* calculate sample offset using means from previous blocks */
            if (s->nmean == 0)
                coffset = s->offset[channel][0];
            else {
                int32_t sum = (s->version < 2) ? 0 : s->nmean / 2;
                for (i = 0; i < s->nmean; i++)
                    sum += s->offset[channel][i];
                coffset = sum / s->nmean;
                if (s->version >= 2)
                    coffset >>= FFMIN(1, s->bitshift);
            }

            /* decode samples for this channel */
            if (cmd == FN_ZERO) {
                for (i = 0; i < s->blocksize; i++)
                    s->decoded[channel][i] = 0;
            } else {
                if ((ret = decode_subframe_lpc(s, cmd, channel,
                                               residual_size, coffset)) < 0)
                    return ret;
            }

            /* update means with info from the current block */
            if (s->nmean > 0) {
                int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2;
                for (i = 0; i < s->blocksize; i++)
                    sum += s->decoded[channel][i];

                for (i = 1; i < s->nmean; i++)
                    s->offset[channel][i - 1] = s->offset[channel][i];

                if (s->version < 2)
                    s->offset[channel][s->nmean - 1] = sum / s->blocksize;
                else
                    s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift;
            }

            /* copy wrap samples for use with next block */
            for (i = -s->nwrap; i < 0; i++)
                s->decoded[channel][i] = s->decoded[channel][i + s->blocksize];

            /* shift samples to add in unused zero bits which were removed
             * during encoding */
            fix_bitshift(s, s->decoded[channel]);

            /* if this is the last channel in the block, output the samples */
            s->cur_chan++;
            if (s->cur_chan == s->channels) {
                /* get output buffer */
                frame->nb_samples = s->blocksize;
                if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
                    av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
                    return ret;
                }
                /* interleave output */
                output_buffer((int16_t **)frame->extended_data, s->channels,
                              s->blocksize, s->decoded);

                *got_frame_ptr = 1;
            }
        }
    }
    if (s->cur_chan < s->channels)
        *got_frame_ptr = 0;

finish_frame:
    s->bitindex = get_bits_count(&s->gb) - 8 * (get_bits_count(&s->gb) / 8);
    i           = get_bits_count(&s->gb) / 8;
    if (i > buf_size) {
        av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size);
        s->bitstream_size  = 0;
        s->bitstream_index = 0;
        return AVERROR_INVALIDDATA;
    }
    if (s->bitstream_size) {
        s->bitstream_index += i;
        s->bitstream_size  -= i;
        return input_buf_size;
    } else
        return i;
}","static int shorten_decode_frame(AVCodecContext *VAR_0, void *VAR_1,
                                int *VAR_2, AVPacket *VAR_3)
{
    AVFrame *VAR_4     = VAR_1;
    const uint8_t *VAR_5 = VAR_3->data;
    int VAR_6       = VAR_3->size;
    ShortenContext *VAR_7  = VAR_0->priv_data;
    int VAR_8, VAR_9 = 0;
    int VAR_10;

    /* COMMENT_0 */
    if (VAR_7->max_framesize == 0) {
        void *VAR_11;
        VAR_7->max_framesize = 1024; /* COMMENT_1 */
        VAR_11 = av_fast_realloc(VAR_7->bitstream, &VAR_7->allocated_bitstream_size,
                                  VAR_7->max_framesize + VAR_12);
        if (!VAR_11) {
            av_log(VAR_0, VAR_13, ""error allocating bitstream buffer\n"");
            return AVERROR(VAR_14);
        }
        VAR_7->bitstream = VAR_11;
    }

    /* COMMENT_2 */
    if (1 && VAR_7->max_framesize) { /* COMMENT_3 */
        VAR_6       = FFMIN(VAR_6, VAR_7->max_framesize - VAR_7->bitstream_size);
        VAR_9 = VAR_6;

        if (VAR_7->bitstream_index + VAR_7->bitstream_size + VAR_6 >
            VAR_7->allocated_bitstream_size) {
            memmove(VAR_7->bitstream, &VAR_7->bitstream[VAR_7->bitstream_index],
                    VAR_7->bitstream_size);
            VAR_7->bitstream_index = 0;
        }
        if (VAR_5)
            memcpy(&VAR_7->bitstream[VAR_7->bitstream_index + VAR_7->bitstream_size], VAR_5,
                   VAR_6);
        VAR_5               = &VAR_7->bitstream[VAR_7->bitstream_index];
        VAR_6         += VAR_7->bitstream_size;
        VAR_7->bitstream_size = VAR_6;

        /* COMMENT_4 */
                                                  
        if (VAR_6 < VAR_7->max_framesize && VAR_3->data) {
            *VAR_2 = 0;
            return VAR_9;
        }
    }
    /* COMMENT_6 */
    init_get_bits(&VAR_7->gb, VAR_5, VAR_6 * 8);
    skip_bits(&VAR_7->gb, VAR_7->bitindex);

    /* COMMENT_7 */
    if (!VAR_7->got_header) {
        if ((VAR_10 = read_header(VAR_7)) < 0)
            return VAR_10;
        *VAR_2 = 0;
        goto finish_frame;
    }

    /* COMMENT_8 */
    if (VAR_7->got_quit_command) {
        *VAR_2 = 0;
        return VAR_3->size;
    }

    VAR_7->cur_chan = 0;
    while (VAR_7->cur_chan < VAR_7->channels) {
        unsigned VAR_15;
        int VAR_16;

        if (get_bits_left(&VAR_7->gb) < 3 + VAR_17) {
            *VAR_2 = 0;
            break;
        }

        VAR_15 = get_ur_golomb_shorten(&VAR_7->gb, VAR_17);

        if (VAR_15 > VAR_18) {
            av_log(VAR_0, VAR_13, ""unknown shorten function %d\n"", VAR_15);
            *VAR_2 = 0;
            break;
        }

        if (!VAR_19[VAR_15]) {
            /* COMMENT_9 */
            switch (VAR_15) {
            case VAR_18:
                VAR_16 = get_ur_golomb_shorten(&VAR_7->gb, VAR_20);
                while (VAR_16--)
                    get_ur_golomb_shorten(&VAR_7->gb, VAR_21);
                break;
            case VAR_22:
                VAR_7->bitshift = get_ur_golomb_shorten(&VAR_7->gb, VAR_23);
                break;
            case VAR_24: {
                unsigned VAR_25 = get_uint(VAR_7, av_log2(VAR_7->blocksize));
                if (VAR_25 > VAR_7->blocksize) {
                    av_log(VAR_0, VAR_13,
                           ""Increasing block size is not supported\n"");
                    return VAR_26;
                }
                if (!VAR_25 || VAR_25 > VAR_27) {
                    av_log(VAR_0, VAR_13, ""invalid or unsupported ""
                                                ""block size: %d\n"", VAR_25);
                    return AVERROR(VAR_28);
                }
                VAR_7->blocksize = VAR_25;
                break;
            }
            case VAR_29:
                VAR_7->got_quit_command = 1;
                break;
            }
            if (VAR_15 == VAR_24 || VAR_15 == VAR_29) {
                *VAR_2 = 0;
                break;
            }
        } else {
            /* COMMENT_10 */
            int VAR_30 = 0;
            int VAR_31 = VAR_7->cur_chan;
            int32_t VAR_32;

            /* COMMENT_11 */
            if (VAR_15 != VAR_33) {
                VAR_30 = get_ur_golomb_shorten(&VAR_7->gb, VAR_34);
                /* COMMENT_12 */
                                                 
                if (VAR_7->version == 0)
                    VAR_30--;
            }

            /* COMMENT_14 */
            if (VAR_7->nmean == 0)
                VAR_32 = VAR_7->offset[VAR_31][0];
            else {
                int32_t VAR_35 = (VAR_7->version < 2) ? 0 : VAR_7->nmean / 2;
                for (VAR_8 = 0; VAR_8 < VAR_7->nmean; VAR_8++)
                    VAR_35 += VAR_7->offset[VAR_31][VAR_8];
                VAR_32 = VAR_35 / VAR_7->nmean;
                if (VAR_7->version >= 2)
                    VAR_32 >>= FFMIN(1, VAR_7->bitshift);
            }

            /* COMMENT_15 */
            if (VAR_15 == VAR_33) {
                for (VAR_8 = 0; VAR_8 < VAR_7->blocksize; VAR_8++)
                    VAR_7->decoded[VAR_31][VAR_8] = 0;
            } else {
                if ((VAR_10 = decode_subframe_lpc(VAR_7, VAR_15, VAR_31,
                                               VAR_30, VAR_32)) < 0)
                    return VAR_10;
            }

            /* COMMENT_16 */
            if (VAR_7->nmean > 0) {
                int32_t VAR_35 = (VAR_7->version < 2) ? 0 : VAR_7->blocksize / 2;
                for (VAR_8 = 0; VAR_8 < VAR_7->blocksize; VAR_8++)
                    VAR_35 += VAR_7->decoded[VAR_31][VAR_8];

                for (VAR_8 = 1; VAR_8 < VAR_7->nmean; VAR_8++)
                    VAR_7->offset[VAR_31][VAR_8 - 1] = VAR_7->offset[VAR_31][VAR_8];

                if (VAR_7->version < 2)
                    VAR_7->offset[VAR_31][VAR_7->nmean - 1] = VAR_35 / VAR_7->blocksize;
                else
                    VAR_7->offset[VAR_31][VAR_7->nmean - 1] = (VAR_35 / VAR_7->blocksize) << VAR_7->bitshift;
            }

            /* COMMENT_17 */
            for (VAR_8 = -VAR_7->nwrap; VAR_8 < 0; VAR_8++)
                VAR_7->decoded[VAR_31][VAR_8] = VAR_7->decoded[VAR_31][VAR_8 + VAR_7->blocksize];

            /* COMMENT_18 */
                                 
            fix_bitshift(VAR_7, VAR_7->decoded[VAR_31]);

            /* COMMENT_20 */
            VAR_7->cur_chan++;
            if (VAR_7->cur_chan == VAR_7->channels) {
                /* COMMENT_21 */
                VAR_4->nb_samples = VAR_7->blocksize;
                if ((VAR_10 = ff_get_buffer(VAR_0, VAR_4, 0)) < 0) {
                    av_log(VAR_0, VAR_13, ""get_buffer() failed\n"");
                    return VAR_10;
                }
                /* COMMENT_22 */
                output_buffer((int16_t **)VAR_4->extended_data, VAR_7->channels,
                              VAR_7->blocksize, VAR_7->decoded);

                *VAR_2 = 1;
            }
        }
    }
    if (VAR_7->cur_chan < VAR_7->channels)
        *VAR_2 = 0;

finish_frame:
    VAR_7->bitindex = get_bits_count(&VAR_7->gb) - 8 * (get_bits_count(&VAR_7->gb) / 8);
    VAR_8           = get_bits_count(&VAR_7->gb) / 8;
    if (VAR_8 > VAR_6) {
        av_log(VAR_7->avctx, VAR_13, ""overread: %d\n"", VAR_8 - VAR_6);
        VAR_7->bitstream_size  = 0;
        VAR_7->bitstream_index = 0;
        return VAR_36;
    }
    if (VAR_7->bitstream_size) {
        VAR_7->bitstream_index += VAR_8;
        VAR_7->bitstream_size  -= VAR_8;
        return VAR_9;
    } else
        return VAR_8;
}",ffmpeg/1713eec29add37b654ec6bf262b843d139c1ffc6/shorten.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
         void *tmp_ptr;
         s->max_framesize = 1024; // should hopefully be enough for the first header
         tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,
-                                  s->max_framesize);
+                                  s->max_framesize + FF_INPUT_BUFFER_PADDING_SIZE);
         if (!tmp_ptr) {
             av_log(avctx, AV_LOG_ERROR, ""error allocating bitstream buffer\n"");
             return AVERROR(ENOMEM);","{'deleted_lines': ['                                  s->max_framesize);'], 'added_lines': ['                                  s->max_framesize + FF_INPUT_BUFFER_PADDING_SIZE);']}",True,A vulnerability was found in FFmpeg 2.0. It has been classified as problematic. Affected is the function shorten_decode_frame of the component Bitstream Buffer. The manipulation leads to memory corruption. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue.,5.5,MEDIUM,1,valid,,5
CVE-2019-11478,['CWE-400'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,kernel/git/netdev/net,"Jonathan Looney reported that a malicious peer can force a sender
to fragment its retransmit queue into tiny skbs, inflating memory
usage and/or overflow 32bit counters.

TCP allows an application to queue up to sk_sndbuf bytes,
so we need to give some allowance for non malicious splitting
of retransmit queue.

A new SNMP counter is added to monitor how many times TCP
did not allow to split an skb if the allowance was exceeded.

Note that this counter might increase in the case applications
use SO_SNDBUF socket option to lower sk_sndbuf.

CVE-2019-11478 : tcp_fragment, prevent fragmenting a packet when the
	socket is already using more than half the allowed space

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Jonathan Looney <jtl@netflix.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Acked-by: Yuchung Cheng <ycheng@google.com>
Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
Cc: Bruce Curtis <brucec@netflix.com>
Cc: Jonathan Lemon <jonathan.lemon@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",f070ef2ac66716357066b683fb0baf55f8191a2e,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=f070ef2ac66716357066b683fb0baf55f8191a2e,net/ipv4/tcp_output.c,tcp_fragment,"int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,
struct sk_buff *skb, u32 len,
unsigned int mss_now, gfp_t gfp)
{
struct tcp_sock *tp = tcp_sk(sk);
struct sk_buff *buff;
int nsize, old_factor;
int nlen;
u8 flags;
if (WARN_ON(len > skb->len))
return -EINVAL;
nsize = skb_headlen(skb) - len;
if (nsize < 0)
nsize = 0;
if (skb_unclone(skb, gfp))
return -ENOMEM;
buff = sk_stream_alloc_skb(sk, nsize, gfp, true);
if (!buff)
return -ENOMEM; 
sk->sk_wmem_queued += buff->truesize;
sk_mem_charge(sk, buff->truesize);
nlen = skb->len - len - nsize;
buff->truesize += nlen;
skb->truesize -= nlen;
TCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;
TCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;
TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;
flags = TCP_SKB_CB(skb)->tcp_flags;
TCP_SKB_CB(skb)->tcp_flags = flags & ~(TCPHDR_FIN | TCPHDR_PSH);
TCP_SKB_CB(buff)->tcp_flags = flags;
TCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked;
tcp_skb_fragment_eor(skb, buff);
skb_split(skb, buff, len);
buff->ip_summed = CHECKSUM_PARTIAL;
buff->tstamp = skb->tstamp;
tcp_fragment_tstamp(skb, buff);
old_factor = tcp_skb_pcount(skb);
tcp_set_skb_tso_segs(skb, mss_now);
tcp_set_skb_tso_segs(buff, mss_now);
TCP_SKB_CB(buff)->tx = TCP_SKB_CB(skb)->tx;
if (!before(tp->snd_nxt, TCP_SKB_CB(buff)->end_seq)) {
int diff = old_factor - tcp_skb_pcount(skb) -
tcp_skb_pcount(buff);
if (diff)
tcp_adjust_pcount(sk, skb, diff);
}
__skb_header_release(buff);
tcp_insert_write_queue_after(skb, buff, sk, tcp_queue);
if (tcp_queue == TCP_FRAG_IN_RTX_QUEUE)
list_add(&buff->tcp_tsorted_anchor, &skb->tcp_tsorted_anchor);
return 0;
}","int tcp_fragment(struct sock *VAR_0, enum tcp_queue tcp_queue,
struct sk_buff *VAR_1, u32 VAR_2,
unsigned int VAR_3, gfp_t VAR_4)
{
struct tcp_sock *VAR_5 = tcp_sk(VAR_0);
struct sk_buff *VAR_6;
int VAR_7, VAR_8;
int VAR_9;
u8 VAR_10;
if (WARN_ON(VAR_2 > VAR_1->len))
return -VAR_11;
VAR_7 = skb_headlen(VAR_1) - VAR_2;
if (VAR_7 < 0)
VAR_7 = 0;
if (skb_unclone(VAR_1, VAR_4))
return -VAR_12;
VAR_6 = sk_stream_alloc_skb(VAR_0, VAR_7, VAR_4, true);
if (!VAR_6)
return -VAR_12; 
VAR_0->sk_wmem_queued += VAR_6->truesize;
sk_mem_charge(VAR_0, VAR_6->truesize);
VAR_9 = VAR_1->len - VAR_2 - VAR_7;
VAR_6->truesize += VAR_9;
VAR_1->truesize -= VAR_9;
TCP_SKB_CB(VAR_6)->seq = TCP_SKB_CB(VAR_1)->seq + VAR_2;
TCP_SKB_CB(VAR_6)->end_seq = TCP_SKB_CB(VAR_1)->end_seq;
TCP_SKB_CB(VAR_1)->end_seq = TCP_SKB_CB(VAR_6)->seq;
VAR_10 = TCP_SKB_CB(VAR_1)->tcp_flags;
TCP_SKB_CB(VAR_1)->tcp_flags = VAR_10 & ~(VAR_13 | VAR_14);
TCP_SKB_CB(VAR_6)->tcp_flags = VAR_10;
TCP_SKB_CB(VAR_6)->sacked = TCP_SKB_CB(VAR_1)->sacked;
tcp_skb_fragment_eor(VAR_1, VAR_6);
skb_split(VAR_1, VAR_6, VAR_2);
VAR_6->ip_summed = VAR_15;
VAR_6->tstamp = VAR_1->tstamp;
tcp_fragment_tstamp(VAR_1, VAR_6);
VAR_8 = tcp_skb_pcount(VAR_1);
tcp_set_skb_tso_segs(VAR_1, VAR_3);
tcp_set_skb_tso_segs(VAR_6, VAR_3);
TCP_SKB_CB(VAR_6)->tx = TCP_SKB_CB(VAR_1)->tx;
if (!before(VAR_5->snd_nxt, TCP_SKB_CB(VAR_6)->end_seq)) {
int VAR_16 = VAR_8 - tcp_skb_pcount(VAR_1) -
tcp_skb_pcount(VAR_6);
if (VAR_16)
tcp_adjust_pcount(VAR_0, VAR_1, VAR_16);
}
__skb_header_release(VAR_6);
tcp_insert_write_queue_after(VAR_1, VAR_6, VAR_0, tcp_queue);
if (tcp_queue == VAR_17)
list_add(&VAR_6->tcp_tsorted_anchor, &VAR_1->tcp_tsorted_anchor);
return 0;
}",kernel/git/netdev/net/f070ef2ac66716357066b683fb0baf55f8191a2e/tcp_output.c/vul/before/0.json,"int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,
		 struct sk_buff *skb, u32 len,
		 unsigned int mss_now, gfp_t gfp)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct sk_buff *buff;
	int nsize, old_factor;
	int nlen;
	u8 flags;

	if (WARN_ON(len > skb->len))
		return -EINVAL;

	nsize = skb_headlen(skb) - len;
	if (nsize < 0)
		nsize = 0;

	if (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf)) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);
		return -ENOMEM;
	}

	if (skb_unclone(skb, gfp))
		return -ENOMEM;

	/* Get a new skb... force flag on. */
	buff = sk_stream_alloc_skb(sk, nsize, gfp, true);
	if (!buff)
		return -ENOMEM; /* We'll just try again later. */

	sk->sk_wmem_queued += buff->truesize;
	sk_mem_charge(sk, buff->truesize);
	nlen = skb->len - len - nsize;
	buff->truesize += nlen;
	skb->truesize -= nlen;

	/* Correct the sequence numbers. */
	TCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;
	TCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;
	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;

	/* PSH and FIN should only be set in the second packet. */
	flags = TCP_SKB_CB(skb)->tcp_flags;
	TCP_SKB_CB(skb)->tcp_flags = flags & ~(TCPHDR_FIN | TCPHDR_PSH);
	TCP_SKB_CB(buff)->tcp_flags = flags;
	TCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked;
	tcp_skb_fragment_eor(skb, buff);

	skb_split(skb, buff, len);

	buff->ip_summed = CHECKSUM_PARTIAL;

	buff->tstamp = skb->tstamp;
	tcp_fragment_tstamp(skb, buff);

	old_factor = tcp_skb_pcount(skb);

	/* Fix up tso_factor for both original and new SKB.  */
	tcp_set_skb_tso_segs(skb, mss_now);
	tcp_set_skb_tso_segs(buff, mss_now);

	/* Update delivered info for the new segment */
	TCP_SKB_CB(buff)->tx = TCP_SKB_CB(skb)->tx;

	/* If this packet has been sent out already, we must
	 * adjust the various packet counters.
	 */
	if (!before(tp->snd_nxt, TCP_SKB_CB(buff)->end_seq)) {
		int diff = old_factor - tcp_skb_pcount(skb) -
			tcp_skb_pcount(buff);

		if (diff)
			tcp_adjust_pcount(sk, skb, diff);
	}

	/* Link BUFF into the send queue. */
	__skb_header_release(buff);
	tcp_insert_write_queue_after(skb, buff, sk, tcp_queue);
	if (tcp_queue == TCP_FRAG_IN_RTX_QUEUE)
		list_add(&buff->tcp_tsorted_anchor, &skb->tcp_tsorted_anchor);

	return 0;
}","int tcp_fragment(struct sock *VAR_0, enum tcp_queue tcp_queue,
		 struct sk_buff *VAR_1, u32 VAR_2,
		 unsigned int VAR_3, gfp_t VAR_4)
{
	struct tcp_sock *VAR_5 = tcp_sk(VAR_0);
	struct sk_buff *VAR_6;
	int VAR_7, VAR_8;
	int VAR_9;
	u8 VAR_10;

	if (WARN_ON(VAR_2 > VAR_1->len))
		return -VAR_11;

	VAR_7 = skb_headlen(VAR_1) - VAR_2;
	if (VAR_7 < 0)
		VAR_7 = 0;

	if (unlikely((VAR_0->sk_wmem_queued >> 1) > VAR_0->sk_sndbuf)) {
		NET_INC_STATS(sock_net(VAR_0), VAR_12);
		return -VAR_13;
	}

	if (skb_unclone(VAR_1, VAR_4))
		return -VAR_13;

	/* COMMENT_0 */
	VAR_6 = sk_stream_alloc_skb(VAR_0, VAR_7, VAR_4, true);
	if (!VAR_6)
		return -VAR_13; /* COMMENT_1 */

	VAR_0->sk_wmem_queued += VAR_6->truesize;
	sk_mem_charge(VAR_0, VAR_6->truesize);
	VAR_9 = VAR_1->len - VAR_2 - VAR_7;
	VAR_6->truesize += VAR_9;
	VAR_1->truesize -= VAR_9;

	/* COMMENT_2 */
	TCP_SKB_CB(VAR_6)->seq = TCP_SKB_CB(VAR_1)->seq + VAR_2;
	TCP_SKB_CB(VAR_6)->end_seq = TCP_SKB_CB(VAR_1)->end_seq;
	TCP_SKB_CB(VAR_1)->end_seq = TCP_SKB_CB(VAR_6)->seq;

	/* COMMENT_3 */
	VAR_10 = TCP_SKB_CB(VAR_1)->tcp_flags;
	TCP_SKB_CB(VAR_1)->tcp_flags = VAR_10 & ~(VAR_14 | VAR_15);
	TCP_SKB_CB(VAR_6)->tcp_flags = VAR_10;
	TCP_SKB_CB(VAR_6)->sacked = TCP_SKB_CB(VAR_1)->sacked;
	tcp_skb_fragment_eor(VAR_1, VAR_6);

	skb_split(VAR_1, VAR_6, VAR_2);

	VAR_6->ip_summed = VAR_16;

	VAR_6->tstamp = VAR_1->tstamp;
	tcp_fragment_tstamp(VAR_1, VAR_6);

	VAR_8 = tcp_skb_pcount(VAR_1);

	/* COMMENT_4 */
	tcp_set_skb_tso_segs(VAR_1, VAR_3);
	tcp_set_skb_tso_segs(VAR_6, VAR_3);

	/* COMMENT_5 */
	TCP_SKB_CB(VAR_6)->tx = TCP_SKB_CB(VAR_1)->tx;

	/* COMMENT_6 */
                                       
    
	if (!before(VAR_5->snd_nxt, TCP_SKB_CB(VAR_6)->end_seq)) {
		int VAR_17 = VAR_8 - tcp_skb_pcount(VAR_1) -
			tcp_skb_pcount(VAR_6);

		if (VAR_17)
			tcp_adjust_pcount(VAR_0, VAR_1, VAR_17);
	}

	/* COMMENT_9 */
	__skb_header_release(VAR_6);
	tcp_insert_write_queue_after(VAR_1, VAR_6, VAR_0, tcp_queue);
	if (tcp_queue == VAR_18)
		list_add(&VAR_6->tcp_tsorted_anchor, &VAR_1->tcp_tsorted_anchor);

	return 0;
}",kernel/git/netdev/net/f070ef2ac66716357066b683fb0baf55f8191a2e/tcp_output.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,11 @@
 	nsize = skb_headlen(skb) - len;
 	if (nsize < 0)
 		nsize = 0;
+
+	if (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf)) {
+		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);
+		return -ENOMEM;
+	}
 
 	if (skb_unclone(skb, gfp))
 		return -ENOMEM;","{'deleted_lines': [], 'added_lines': ['', '\tif (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf)) {', '\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);', '\t\treturn -ENOMEM;', '\t}']}",True,"Jonathan Looney discovered that the TCP retransmission queue implementation in tcp_fragment in the Linux kernel could be fragmented when handling certain TCP Selective Acknowledgment (SACK) sequences. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commit f070ef2ac66716357066b683fb0baf55f8191a2e.",5.3,MEDIUM,1,valid,,5
CVE-2019-15221,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"LINE6 drivers allocate the buffers based on the value returned from
usb_maxpacket() calls.  The manipulated device may return zero for
this, and this results in the kmalloc() with zero size (and it may
succeed) while the other part of the driver code writes the packet
data with the fixed size -- which eventually overwrites.

This patch adds a simple sanity check for the invalid buffer size for
avoiding that problem.

Reported-by: syzbot+219f00fb49874dcaea17@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",3450121997ce872eb7f1248417225827ea249710,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3450121997ce872eb7f1248417225827ea249710,sound/usb/line6/pcm.c,line6_init_pcm,"int line6_init_pcm(struct usb_line6 *line6,
struct line6_pcm_properties *properties)
{
int i, err;
unsigned ep_read = line6->properties->ep_audio_r;
unsigned ep_write = line6->properties->ep_audio_w;
struct snd_pcm *pcm;
struct snd_line6_pcm *line6pcm;
if (!(line6->properties->capabilities & LINE6_CAP_PCM))
return 0;
err = snd_line6_new_pcm(line6, &pcm);
if (err < 0)
return err;
line6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);
if (!line6pcm)
return -ENOMEM;
mutex_init(&line6pcm->state_mutex);
line6pcm->pcm = pcm;
line6pcm->properties = properties;
line6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;
line6pcm->volume_monitor = 255;
line6pcm->line6 = line6;
line6pcm->max_packet_size_in =
usb_maxpacket(line6->usbdev,
usb_rcvisocpipe(line6->usbdev, ep_read), 0);
line6pcm->max_packet_size_out =
usb_maxpacket(line6->usbdev,
usb_sndisocpipe(line6->usbdev, ep_write), 1);
spin_lock_init(&line6pcm->out.lock);
spin_lock_init(&line6pcm->in.lock);
line6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;
line6->line6pcm = line6pcm;
pcm->private_data = line6pcm;
pcm->private_free = line6_cleanup_pcm;
err = line6_create_audio_out_urbs(line6pcm);
if (err < 0)
return err;
err = line6_create_audio_in_urbs(line6pcm);
if (err < 0)
return err;
for (i = 0; i < ARRAY_SIZE(line6_controls); i++) {
err = snd_ctl_add(line6->card,
snd_ctl_new1(&line6_controls[i], line6pcm));
if (err < 0)
return err;
}
return 0;
}","int line6_init_pcm(struct usb_line6 *VAR_0,
struct line6_pcm_properties *VAR_1)
{
int VAR_2, VAR_3;
unsigned VAR_4 = VAR_0->properties->ep_audio_r;
unsigned VAR_5 = VAR_0->properties->ep_audio_w;
struct snd_pcm *VAR_6;
struct snd_line6_pcm *VAR_7;
if (!(VAR_0->properties->capabilities & VAR_8))
return 0;
VAR_3 = snd_line6_new_pcm(VAR_0, &VAR_6);
if (VAR_3 < 0)
return VAR_3;
VAR_7 = kzalloc(sizeof(*VAR_7), VAR_9);
if (!VAR_7)
return -VAR_10;
mutex_init(&VAR_7->state_mutex);
VAR_7->pcm = VAR_6;
VAR_7->properties = VAR_1;
VAR_7->volume_playback[0] = VAR_7->volume_playback[1] = 255;
VAR_7->volume_monitor = 255;
VAR_7->line6 = VAR_0;
VAR_7->max_packet_size_in =
usb_maxpacket(VAR_0->usbdev,
usb_rcvisocpipe(VAR_0->usbdev, VAR_4), 0);
VAR_7->max_packet_size_out =
usb_maxpacket(VAR_0->usbdev,
usb_sndisocpipe(VAR_0->usbdev, VAR_5), 1);
spin_lock_init(&VAR_7->out.lock);
spin_lock_init(&VAR_7->in.lock);
VAR_7->impulse_period = VAR_11;
VAR_0->line6pcm = VAR_7;
VAR_6->private_data = VAR_7;
VAR_6->private_free = VAR_12;
VAR_3 = line6_create_audio_out_urbs(VAR_7);
if (VAR_3 < 0)
return VAR_3;
VAR_3 = line6_create_audio_in_urbs(VAR_7);
if (VAR_3 < 0)
return VAR_3;
for (VAR_2 = 0; VAR_2 < ARRAY_SIZE(VAR_13); VAR_2++) {
VAR_3 = snd_ctl_add(VAR_0->card,
snd_ctl_new1(&VAR_13[VAR_2], VAR_7));
if (VAR_3 < 0)
return VAR_3;
}
return 0;
}",torvalds/linux/3450121997ce872eb7f1248417225827ea249710/pcm.c/vul/before/0.json,"int line6_init_pcm(struct usb_line6 *line6,
		   struct line6_pcm_properties *properties)
{
	int i, err;
	unsigned ep_read = line6->properties->ep_audio_r;
	unsigned ep_write = line6->properties->ep_audio_w;
	struct snd_pcm *pcm;
	struct snd_line6_pcm *line6pcm;

	if (!(line6->properties->capabilities & LINE6_CAP_PCM))
		return 0;	/* skip PCM initialization and report success */

	err = snd_line6_new_pcm(line6, &pcm);
	if (err < 0)
		return err;

	line6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);
	if (!line6pcm)
		return -ENOMEM;

	mutex_init(&line6pcm->state_mutex);
	line6pcm->pcm = pcm;
	line6pcm->properties = properties;
	line6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;
	line6pcm->volume_monitor = 255;
	line6pcm->line6 = line6;

	line6pcm->max_packet_size_in =
		usb_maxpacket(line6->usbdev,
			usb_rcvisocpipe(line6->usbdev, ep_read), 0);
	line6pcm->max_packet_size_out =
		usb_maxpacket(line6->usbdev,
			usb_sndisocpipe(line6->usbdev, ep_write), 1);
	if (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {
		dev_err(line6pcm->line6->ifcdev,
			""cannot get proper max packet size\n"");
		return -EINVAL;
	}

	spin_lock_init(&line6pcm->out.lock);
	spin_lock_init(&line6pcm->in.lock);
	line6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;

	line6->line6pcm = line6pcm;

	pcm->private_data = line6pcm;
	pcm->private_free = line6_cleanup_pcm;

	err = line6_create_audio_out_urbs(line6pcm);
	if (err < 0)
		return err;

	err = line6_create_audio_in_urbs(line6pcm);
	if (err < 0)
		return err;

	/* mixer: */
	for (i = 0; i < ARRAY_SIZE(line6_controls); i++) {
		err = snd_ctl_add(line6->card,
				  snd_ctl_new1(&line6_controls[i], line6pcm));
		if (err < 0)
			return err;
	}

	return 0;
}","int line6_init_pcm(struct usb_line6 *VAR_0,
		   struct line6_pcm_properties *VAR_1)
{
	int VAR_2, VAR_3;
	unsigned VAR_4 = VAR_0->properties->ep_audio_r;
	unsigned VAR_5 = VAR_0->properties->ep_audio_w;
	struct snd_pcm *VAR_6;
	struct snd_line6_pcm *VAR_7;

	if (!(VAR_0->properties->capabilities & VAR_8))
		return 0;	/* COMMENT_0 */

	VAR_3 = snd_line6_new_pcm(VAR_0, &VAR_6);
	if (VAR_3 < 0)
		return VAR_3;

	VAR_7 = kzalloc(sizeof(*VAR_7), VAR_9);
	if (!VAR_7)
		return -VAR_10;

	mutex_init(&VAR_7->state_mutex);
	VAR_7->pcm = VAR_6;
	VAR_7->properties = VAR_1;
	VAR_7->volume_playback[0] = VAR_7->volume_playback[1] = 255;
	VAR_7->volume_monitor = 255;
	VAR_7->line6 = VAR_0;

	VAR_7->max_packet_size_in =
		usb_maxpacket(VAR_0->usbdev,
			usb_rcvisocpipe(VAR_0->usbdev, VAR_4), 0);
	VAR_7->max_packet_size_out =
		usb_maxpacket(VAR_0->usbdev,
			usb_sndisocpipe(VAR_0->usbdev, VAR_5), 1);
	if (!VAR_7->max_packet_size_in || !VAR_7->max_packet_size_out) {
		dev_err(VAR_7->line6->ifcdev,
			""cannot get proper max packet size\n"");
		return -VAR_11;
	}

	spin_lock_init(&VAR_7->out.lock);
	spin_lock_init(&VAR_7->in.lock);
	VAR_7->impulse_period = VAR_12;

	VAR_0->line6pcm = VAR_7;

	VAR_6->private_data = VAR_7;
	VAR_6->private_free = VAR_13;

	VAR_3 = line6_create_audio_out_urbs(VAR_7);
	if (VAR_3 < 0)
		return VAR_3;

	VAR_3 = line6_create_audio_in_urbs(VAR_7);
	if (VAR_3 < 0)
		return VAR_3;

	/* COMMENT_1 */
	for (VAR_2 = 0; VAR_2 < ARRAY_SIZE(VAR_14); VAR_2++) {
		VAR_3 = snd_ctl_add(VAR_0->card,
				  snd_ctl_new1(&VAR_14[VAR_2], VAR_7));
		if (VAR_3 < 0)
			return VAR_3;
	}

	return 0;
}",torvalds/linux/3450121997ce872eb7f1248417225827ea249710/pcm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,6 +31,11 @@
 	line6pcm->max_packet_size_out =
 		usb_maxpacket(line6->usbdev,
 			usb_sndisocpipe(line6->usbdev, ep_write), 1);
+	if (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {
+		dev_err(line6pcm->line6->ifcdev,
+			""cannot get proper max packet size\n"");
+		return -EINVAL;
+	}
 
 	spin_lock_init(&line6pcm->out.lock);
 	spin_lock_init(&line6pcm->in.lock);","{'deleted_lines': [], 'added_lines': ['\tif (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {', '\t\tdev_err(line6pcm->line6->ifcdev,', '\t\t\t""cannot get proper max packet size\\n"");', '\t\treturn -EINVAL;', '\t}']}",True,An issue was discovered in the Linux kernel before 5.1.17. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/pcm.c driver.,4.6,MEDIUM,1,valid,,5
CVE-2017-18595,['CWE-415'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Jing Xia and Chunyan Zhang reported that on failing to allocate part of the
tracing buffer, memory is freed, but the pointers that point to them are not
initialized back to NULL, and later paths may try to free the freed memory
again. Jing and Chunyan fixed one of the locations that does this, but
missed a spot.

Link: http://lkml.kernel.org/r/20171226071253.8968-1-chunyan.zhang@spreadtrum.com

Cc: stable@vger.kernel.org
Fixes: 737223fbca3b1 (""tracing: Consolidate buffer allocation code"")
Reported-by: Jing Xia <jing.xia@spreadtrum.com>
Reported-by: Chunyan Zhang <chunyan.zhang@spreadtrum.com>
Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
",4397f04575c44e1440ec2e49b6302785c95fd2f8,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=4397f04575c44e1440ec2e49b6302785c95fd2f8,kernel/trace/trace.c,allocate_trace_buffer,"static int
allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)
{
enum ring_buffer_flags rb_flags;
rb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;
buf->tr = tr;
buf->buffer = ring_buffer_alloc(size, rb_flags);
if (!buf->buffer)
return -ENOMEM;
buf->data = alloc_percpu(struct trace_array_cpu);
if (!buf->data) {
ring_buffer_free(buf->buffer);
return -ENOMEM;
}
set_buffer_entries(&tr->trace_buffer,
ring_buffer_size(tr->trace_buffer.buffer, 0));
return 0;
}","static int
allocate_trace_buffer(struct trace_array *VAR_0, struct trace_buffer *VAR_1, int VAR_2)
{
enum ring_buffer_flags VAR_3;
VAR_3 = VAR_0->trace_flags & VAR_4 ? VAR_5 : 0;
VAR_1->tr = VAR_0;
VAR_1->buffer = ring_buffer_alloc(VAR_2, VAR_3);
if (!VAR_1->buffer)
return -VAR_6;
VAR_1->data = alloc_percpu(struct VAR_7);
if (!VAR_1->data) {
ring_buffer_free(VAR_1->buffer);
return -VAR_6;
}
set_buffer_entries(&VAR_0->trace_buffer,
ring_buffer_size(VAR_0->trace_buffer.buffer, 0));
return 0;
}",torvalds/linux/4397f04575c44e1440ec2e49b6302785c95fd2f8/trace.c/vul/before/0.json,"static int
allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)
{
	enum ring_buffer_flags rb_flags;

	rb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;

	buf->tr = tr;

	buf->buffer = ring_buffer_alloc(size, rb_flags);
	if (!buf->buffer)
		return -ENOMEM;

	buf->data = alloc_percpu(struct trace_array_cpu);
	if (!buf->data) {
		ring_buffer_free(buf->buffer);
		buf->buffer = NULL;
		return -ENOMEM;
	}

	/* Allocate the first page for all buffers */
	set_buffer_entries(&tr->trace_buffer,
			   ring_buffer_size(tr->trace_buffer.buffer, 0));

	return 0;
}","static int
allocate_trace_buffer(struct trace_array *VAR_0, struct trace_buffer *VAR_1, int VAR_2)
{
	enum ring_buffer_flags VAR_3;

	VAR_3 = VAR_0->trace_flags & VAR_4 ? VAR_5 : 0;

	VAR_1->tr = VAR_0;

	VAR_1->buffer = ring_buffer_alloc(VAR_2, VAR_3);
	if (!VAR_1->buffer)
		return -VAR_6;

	VAR_1->data = alloc_percpu(struct VAR_7);
	if (!VAR_1->data) {
		ring_buffer_free(VAR_1->buffer);
		VAR_1->buffer = NULL;
		return -VAR_6;
	}

	/* COMMENT_0 */
	set_buffer_entries(&VAR_0->trace_buffer,
			   ring_buffer_size(VAR_0->trace_buffer.buffer, 0));

	return 0;
}",torvalds/linux/4397f04575c44e1440ec2e49b6302785c95fd2f8/trace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 	buf->data = alloc_percpu(struct trace_array_cpu);
 	if (!buf->data) {
 		ring_buffer_free(buf->buffer);
+		buf->buffer = NULL;
 		return -ENOMEM;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\tbuf->buffer = NULL;']}",True,An issue was discovered in the Linux kernel before 4.14.11. A double free may be caused by the function allocate_trace_buffer in the file kernel/trace/trace.c.,7.8,HIGH,2,valid,,5
CVE-2019-17055,['CWE-862'],AV:L/AC:L/Au:N/C:N/I:P/A:N,0,torvalds/linux,"When creating a raw AF_ISDN socket, CAP_NET_RAW needs to be checked
first.

Signed-off-by: Ori Nimron <orinimron123@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: David S. Miller <davem@davemloft.net>
",b91ee4aa2a2199ba4d4650706c272985a5a32d80,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b91ee4aa2a2199ba4d4650706c272985a5a32d80,drivers/isdn/mISDN/socket.c,base_sock_create,"static int
base_sock_create(struct net *net, struct socket *sock, int protocol, int kern)
{
struct sock *sk;
if (sock->type != SOCK_RAW)
return -ESOCKTNOSUPPORT;
sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
if (!sk)
return -ENOMEM;
sock_init_data(sock, sk);
sock->ops = &base_sock_ops;
sock->state = SS_UNCONNECTED;
sock_reset_flag(sk, SOCK_ZAPPED);
sk->sk_protocol = protocol;
sk->sk_state    = MISDN_OPEN;
mISDN_sock_link(&base_sockets, sk);
return 0;
}","static int
base_sock_create(struct net *net, struct socket *VAR_0, int VAR_1, int VAR_2)
{
struct sock *VAR_3;
if (sock->type != VAR_4)
return -VAR_5;
VAR_3 = sk_alloc(net, VAR_6, VAR_7, &VAR_8, VAR_2);
if (!VAR_3)
return -VAR_9;
sock_init_data(sock, VAR_3);
sock->ops = &VAR_10;
sock->state = VAR_11;
sock_reset_flag(VAR_3, VAR_12);
VAR_3->sk_protocol = VAR_1;
VAR_3->sk_state    = VAR_13;
mISDN_sock_link(&VAR_14, VAR_3);
return 0;
}",torvalds/linux/b91ee4aa2a2199ba4d4650706c272985a5a32d80/socket.c/vul/before/0.json,"static int
base_sock_create(struct net *net, struct socket *sock, int protocol, int kern)
{
	struct sock *sk;

	if (sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;
	if (!capable(CAP_NET_RAW))
		return -EPERM;

	sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
	if (!sk)
		return -ENOMEM;

	sock_init_data(sock, sk);
	sock->ops = &base_sock_ops;
	sock->state = SS_UNCONNECTED;
	sock_reset_flag(sk, SOCK_ZAPPED);
	sk->sk_protocol = protocol;
	sk->sk_state    = MISDN_OPEN;
	mISDN_sock_link(&base_sockets, sk);

	return 0;
}","static int
base_sock_create(struct net *net, struct socket *VAR_0, int VAR_1, int VAR_2)
{
	struct sock *VAR_3;

	if (sock->type != VAR_4)
		return -VAR_5;
	if (!capable(VAR_6))
		return -VAR_7;

	VAR_3 = sk_alloc(net, VAR_8, VAR_9, &VAR_10, VAR_2);
	if (!VAR_3)
		return -VAR_11;

	sock_init_data(sock, VAR_3);
	sock->ops = &VAR_12;
	sock->state = VAR_13;
	sock_reset_flag(VAR_3, VAR_14);
	VAR_3->sk_protocol = VAR_1;
	VAR_3->sk_state    = VAR_15;
	mISDN_sock_link(&VAR_16, VAR_3);

	return 0;
}",torvalds/linux/b91ee4aa2a2199ba4d4650706c272985a5a32d80/socket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,8 @@
 
 	if (sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
 
 	sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
 	if (!sk)","{'deleted_lines': [], 'added_lines': ['\tif (!capable(CAP_NET_RAW))', '\t\treturn -EPERM;']}",True,"base_sock_create in drivers/isdn/mISDN/socket.c in the AF_ISDN network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-b91ee4aa2a21.",3.3,LOW,0,valid,,5
CVE-2021-4154,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The following sequence can be used to trigger a UAF:

    int fscontext_fd = fsopen(""cgroup"");
    int fd_null = open(""/dev/null, O_RDONLY);
    int fsconfig(fscontext_fd, FSCONFIG_SET_FD, ""source"", fd_null);
    close_range(3, ~0U, 0);

The cgroup v1 specific fs parser expects a string for the ""source""
parameter.  However, it is perfectly legitimate to e.g.  specify a file
descriptor for the ""source"" parameter.  The fs parser doesn't know what
a filesystem allows there.  So it's a bug to assume that ""source"" is
always of type fs_value_is_string when it can reasonably also be
fs_value_is_file.

This assumption in the cgroup code causes a UAF because struct
fs_parameter uses a union for the actual value.  Access to that union is
guarded by the param->type member.  Since the cgroup paramter parser
didn't check param->type but unconditionally moved param->string into
fc->source a close on the fscontext_fd would trigger a UAF during
put_fs_context() which frees fc->source thereby freeing the file stashed
in param->file causing a UAF during a close of the fd_null.

Fix this by verifying that param->type is actually a string and report
an error if not.

In follow up patches I'll add a new generic helper that can be used here
and by other filesystems instead of this error-prone copy-pasta fix.
But fixing it in here first makes backporting a it to stable a lot
easier.

Fixes: 8d2451f4994f (""cgroup1: switch to option-by-option parsing"")
Reported-by: syzbot+283ce5a46486d6acdbaf@syzkaller.appspotmail.com
Cc: Christoph Hellwig <hch@lst.de>
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: <stable@kernel.org>
Cc: syzkaller-bugs <syzkaller-bugs@googlegroups.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",3b0462726e7ef281c35a7a4ae33e93ee2bc9975b,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3b0462726e7ef281c35a7a4ae33e93ee2bc9975b,kernel/cgroup/cgroup-v1.c,cgroup1_parse_param,"int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
struct cgroup_subsys *ss;
struct fs_parse_result result;
int opt, i;
opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
if (opt == -ENOPARAM) {
if (strcmp(param->key, ""source"") == 0) {
if (fc->source)
return invalf(fc, ""Multiple sources not supported"");
fc->source = param->string;
param->string = NULL;
return 0;
}
for_each_subsys(ss, i) {
if (strcmp(param->key, ss->legacy_name))
continue;
if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))
return invalfc(fc, ""Disabled controller '%s'"",
param->key);
ctx->subsys_mask |= (1 << i);
return 0;
}
return invalfc(fc, ""Unknown subsys name '%s'"", param->key);
}
if (opt < 0)
return opt;
switch (opt) {
case Opt_none:
ctx->none = true;
break;
case Opt_all:
ctx->all_ss = true;
break;
case Opt_noprefix:
ctx->flags |= CGRP_ROOT_NOPREFIX;
break;
case Opt_clone_children:
ctx->cpuset_clone_children = true;
break;
case Opt_cpuset_v2_mode:
ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
break;
case Opt_xattr:
ctx->flags |= CGRP_ROOT_XATTR;
break;
case Opt_release_agent:
if (ctx->release_agent)
return invalfc(fc, ""release_agent respecified"");
ctx->release_agent = param->string;
param->string = NULL;
break;
case Opt_name:
if (cgroup_no_v1_named)
return -ENOENT;
if (!param->size)
return invalfc(fc, ""Empty name"");
if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
return invalfc(fc, ""Name too long"");
for (i = 0; i < param->size; i++) {
char c = param->string[i];
if (isalnum(c))
continue;
if ((c == '.') || (c == '-') || (c == '_'))
continue;
return invalfc(fc, ""Invalid name"");
}
if (ctx->name)
return invalfc(fc, ""name respecified"");
ctx->name = param->string;
param->string = NULL;
break;
}
return 0;
}","int cgroup1_parse_param(struct fs_context *VAR_0, struct fs_parameter *VAR_1)
{
struct cgroup_fs_context *VAR_2 = cgroup_fc2context(VAR_0);
struct cgroup_subsys *VAR_3;
struct fs_parse_result VAR_4;
int VAR_5, VAR_6;
VAR_5 = fs_parse(VAR_0, VAR_7, VAR_1, &VAR_4);
if (VAR_5 == -VAR_8) {
if (strcmp(VAR_1->key, ""source"") == 0) {
if (VAR_0->source)
return invalf(VAR_0, ""Multiple sources not supported"");
VAR_0->source = VAR_1->string;
VAR_1->string = NULL;
return 0;
}
for_each_subsys(VAR_3, VAR_6) {
if (strcmp(VAR_1->key, VAR_3->legacy_name))
continue;
if (!cgroup_ssid_enabled(VAR_6) || cgroup1_ssid_disabled(VAR_6))
return invalfc(VAR_0, ""Disabled controller '%s'"",
VAR_1->key);
VAR_2->subsys_mask |= (1 << VAR_6);
return 0;
}
return invalfc(VAR_0, ""Unknown subsys name '%s'"", VAR_1->key);
}
if (VAR_5 < 0)
return VAR_5;
switch (VAR_5) {
case VAR_9:
VAR_2->none = true;
break;
case VAR_10:
VAR_2->all_ss = true;
break;
case VAR_11:
VAR_2->flags |= VAR_12;
break;
case VAR_13:
VAR_2->cpuset_clone_children = true;
break;
case VAR_14:
VAR_2->flags |= VAR_15;
break;
case VAR_16:
VAR_2->flags |= VAR_17;
break;
case VAR_18:
if (VAR_2->release_agent)
return invalfc(VAR_0, ""release_agent respecified"");
VAR_2->release_agent = VAR_1->string;
VAR_1->string = NULL;
break;
case VAR_19:
if (VAR_20)
return -VAR_21;
if (!VAR_1->size)
return invalfc(VAR_0, ""Empty name"");
if (VAR_1->size > VAR_22 - 1)
return invalfc(VAR_0, ""Name too long"");
for (VAR_6 = 0; VAR_6 < VAR_1->size; VAR_6++) {
char VAR_23 = VAR_1->string[VAR_6];
if (isalnum(VAR_23))
continue;
if ((VAR_23 == '.') || (VAR_23 == '-') || (VAR_23 == '_'))
continue;
return invalfc(VAR_0, ""Invalid name"");
}
if (VAR_2->name)
return invalfc(VAR_0, ""name respecified"");
VAR_2->name = VAR_1->string;
VAR_1->string = NULL;
break;
}
return 0;
}",torvalds/linux/3b0462726e7ef281c35a7a4ae33e93ee2bc9975b/cgroup-v1.c/vul/before/0.json,"int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
	struct cgroup_subsys *ss;
	struct fs_parse_result result;
	int opt, i;

	opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
	if (opt == -ENOPARAM) {
		if (strcmp(param->key, ""source"") == 0) {
			if (param->type != fs_value_is_string)
				return invalf(fc, ""Non-string source"");
			if (fc->source)
				return invalf(fc, ""Multiple sources not supported"");
			fc->source = param->string;
			param->string = NULL;
			return 0;
		}
		for_each_subsys(ss, i) {
			if (strcmp(param->key, ss->legacy_name))
				continue;
			if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))
				return invalfc(fc, ""Disabled controller '%s'"",
					       param->key);
			ctx->subsys_mask |= (1 << i);
			return 0;
		}
		return invalfc(fc, ""Unknown subsys name '%s'"", param->key);
	}
	if (opt < 0)
		return opt;

	switch (opt) {
	case Opt_none:
		/* Explicitly have no subsystems */
		ctx->none = true;
		break;
	case Opt_all:
		ctx->all_ss = true;
		break;
	case Opt_noprefix:
		ctx->flags |= CGRP_ROOT_NOPREFIX;
		break;
	case Opt_clone_children:
		ctx->cpuset_clone_children = true;
		break;
	case Opt_cpuset_v2_mode:
		ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
		break;
	case Opt_xattr:
		ctx->flags |= CGRP_ROOT_XATTR;
		break;
	case Opt_release_agent:
		/* Specifying two release agents is forbidden */
		if (ctx->release_agent)
			return invalfc(fc, ""release_agent respecified"");
		ctx->release_agent = param->string;
		param->string = NULL;
		break;
	case Opt_name:
		/* blocked by boot param? */
		if (cgroup_no_v1_named)
			return -ENOENT;
		/* Can't specify an empty name */
		if (!param->size)
			return invalfc(fc, ""Empty name"");
		if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
			return invalfc(fc, ""Name too long"");
		/* Must match [\w.-]+ */
		for (i = 0; i < param->size; i++) {
			char c = param->string[i];
			if (isalnum(c))
				continue;
			if ((c == '.') || (c == '-') || (c == '_'))
				continue;
			return invalfc(fc, ""Invalid name"");
		}
		/* Specifying two names is forbidden */
		if (ctx->name)
			return invalfc(fc, ""name respecified"");
		ctx->name = param->string;
		param->string = NULL;
		break;
	}
	return 0;
}","int cgroup1_parse_param(struct fs_context *VAR_0, struct fs_parameter *VAR_1)
{
	struct cgroup_fs_context *VAR_2 = cgroup_fc2context(VAR_0);
	struct cgroup_subsys *VAR_3;
	struct fs_parse_result VAR_4;
	int VAR_5, VAR_6;

	VAR_5 = fs_parse(VAR_0, VAR_7, VAR_1, &VAR_4);
	if (VAR_5 == -VAR_8) {
		if (strcmp(VAR_1->key, ""source"") == 0) {
			if (VAR_1->type != VAR_9)
				return invalf(VAR_0, ""Non-string source"");
			if (VAR_0->source)
				return invalf(VAR_0, ""Multiple sources not supported"");
			VAR_0->source = VAR_1->string;
			VAR_1->string = NULL;
			return 0;
		}
		for_each_subsys(VAR_3, VAR_6) {
			if (strcmp(VAR_1->key, VAR_3->legacy_name))
				continue;
			if (!cgroup_ssid_enabled(VAR_6) || cgroup1_ssid_disabled(VAR_6))
				return invalfc(VAR_0, ""Disabled controller '%s'"",
					       VAR_1->key);
			VAR_2->subsys_mask |= (1 << VAR_6);
			return 0;
		}
		return invalfc(VAR_0, ""Unknown subsys name '%s'"", VAR_1->key);
	}
	if (VAR_5 < 0)
		return VAR_5;

	switch (VAR_5) {
	case VAR_10:
		/* COMMENT_0 */
		VAR_2->none = true;
		break;
	case VAR_11:
		VAR_2->all_ss = true;
		break;
	case VAR_12:
		VAR_2->flags |= VAR_13;
		break;
	case VAR_14:
		VAR_2->cpuset_clone_children = true;
		break;
	case VAR_15:
		VAR_2->flags |= VAR_16;
		break;
	case VAR_17:
		VAR_2->flags |= VAR_18;
		break;
	case VAR_19:
		/* COMMENT_1 */
		if (VAR_2->release_agent)
			return invalfc(VAR_0, ""release_agent respecified"");
		VAR_2->release_agent = VAR_1->string;
		VAR_1->string = NULL;
		break;
	case VAR_20:
		/* COMMENT_2 */
		if (VAR_21)
			return -VAR_22;
		/* COMMENT_3 */
		if (!VAR_1->size)
			return invalfc(VAR_0, ""Empty name"");
		if (VAR_1->size > VAR_23 - 1)
			return invalfc(VAR_0, ""Name too long"");
		/* COMMENT_4 */
		for (VAR_6 = 0; VAR_6 < VAR_1->size; VAR_6++) {
			char VAR_24 = VAR_1->string[VAR_6];
			if (isalnum(VAR_24))
				continue;
			if ((VAR_24 == '.') || (VAR_24 == '-') || (VAR_24 == '_'))
				continue;
			return invalfc(VAR_0, ""Invalid name"");
		}
		/* COMMENT_5 */
		if (VAR_2->name)
			return invalfc(VAR_0, ""name respecified"");
		VAR_2->name = VAR_1->string;
		VAR_1->string = NULL;
		break;
	}
	return 0;
}",torvalds/linux/3b0462726e7ef281c35a7a4ae33e93ee2bc9975b/cgroup-v1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
 	opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
 	if (opt == -ENOPARAM) {
 		if (strcmp(param->key, ""source"") == 0) {
+			if (param->type != fs_value_is_string)
+				return invalf(fc, ""Non-string source"");
 			if (fc->source)
 				return invalf(fc, ""Multiple sources not supported"");
 			fc->source = param->string;","{'deleted_lines': [], 'added_lines': ['\t\t\tif (param->type != fs_value_is_string)', '\t\t\t\treturn invalf(fc, ""Non-string source"");']}",True,A use-after-free flaw was found in cgroup1_parse_param in kernel/cgroup/cgroup-v1.c in the Linux kernel's cgroup v1 parser. A local attacker with a user privilege could cause a privilege escalation by exploiting the fsconfig syscall parameter leading to a container breakout and a denial of service on the system.,8.8,HIGH,2,valid,,5
CVE-2022-0561,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libtiff,"TIFFReadDirectory(): avoid calling memcpy() with a null source pointer and size of zero (fixes #362)
",561599c99f987dc32ae110370cfdd7df7975586b,https://gitlab.com/libtiff/libtiff/-/commit/561599c99f987dc32ae110370cfdd7df7975586b,libtiff/tif_dirread.c,TIFFReadDirectory,"int
TIFFReadDirectory(TIFF* tif)
{
static const char module[] = ""TIFFReadDirectory"";
TIFFDirEntry* dir;
uint16_t dircount;
TIFFDirEntry* dp;
uint16_t di;
const TIFFField* fip;
uint32_t fii=FAILED_FII;
toff_t nextdiroff;
int bitspersample_read = FALSE;
int color_channels;
tif->tif_diroff=tif->tif_nextdiroff;
if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
return 0;           
(*tif->tif_cleanup)(tif);   
tif->tif_curdir++;
nextdiroff = tif->tif_nextdiroff;
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
if (!dircount)
{
TIFFErrorExt(tif->tif_clientdata,module,
""Failed to read directory at offset %"" PRIu64, nextdiroff);
return 0;
}
TIFFReadDirectoryCheckOrder(tif,dir,dircount);
{
TIFFDirEntry* ma;
uint16_t mb;
for (ma=dir, mb=0; mb<dircount; ma++, mb++)
{
TIFFDirEntry* na;
uint16_t nb;
for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
{
if (ma->tdir_tag == na->tdir_tag) {
na->tdir_ignore = TRUE;
}
}
}
}
tif->tif_flags &= ~TIFF_BEENWRITING;    
tif->tif_flags &= ~TIFF_BUF4WRITE;      
tif->tif_flags &= ~TIFF_CHOPPEDUPARRAYS;
TIFFFreeDirectory(tif);
TIFFDefaultDirectory(tif);
TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
if (dp)
{
if (!TIFFFetchNormalTag(tif,dp,0))
goto bad;
dp->tdir_ignore = TRUE;
}
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
if (dp)
{
uint16_t value;
enum TIFFReadDirEntryErr err;
err=TIFFReadDirEntryShort(tif,dp,&value);
if (err==TIFFReadDirEntryErrCount)
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
if (err!=TIFFReadDirEntryErrOk)
{
TIFFReadDirEntryOutputErr(tif,err,module,""Compression"",0);
goto bad;
}
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))
goto bad;
dp->tdir_ignore = TRUE;
}
else
{
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))
goto bad;
}
for (di=0, dp=dir; di<dircount; di++, dp++)
{
if (!dp->tdir_ignore)
{
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
if (fii == FAILED_FII)
{
TIFFWarningExt(tif->tif_clientdata, module,
""Unknown field with tag %""PRIu16"" (0x%""PRIx16"") encountered"",
dp->tdir_tag,dp->tdir_tag);
if (!_TIFFMergeFields(tif,
_TIFFCreateAnonField(tif,
dp->tdir_tag,
(TIFFDataType) dp->tdir_type),
1)) {
TIFFWarningExt(tif->tif_clientdata,
module,
""Registering anonymous field with tag %""PRIu16"" (0x%""PRIx16"") failed"",
dp->tdir_tag,
dp->tdir_tag);
dp->tdir_ignore = TRUE;
} else {
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
assert(fii != FAILED_FII);
}
}
}
if (!dp->tdir_ignore)
{
fip=tif->tif_fields[fii];
if (fip->field_bit==FIELD_IGNORE)
dp->tdir_ignore = TRUE;
else
{
switch (dp->tdir_tag)
{
case TIFFTAG_STRIPOFFSETS:
case TIFFTAG_STRIPBYTECOUNTS:
case TIFFTAG_TILEOFFSETS:
case TIFFTAG_TILEBYTECOUNTS:
TIFFSetFieldBit(tif,fip->field_bit);
break;
case TIFFTAG_IMAGEWIDTH:
case TIFFTAG_IMAGELENGTH:
case TIFFTAG_IMAGEDEPTH:
case TIFFTAG_TILELENGTH:
case TIFFTAG_TILEWIDTH:
case TIFFTAG_TILEDEPTH:
case TIFFTAG_PLANARCONFIG:
case TIFFTAG_ROWSPERSTRIP:
case TIFFTAG_EXTRASAMPLES:
if (!TIFFFetchNormalTag(tif,dp,0))
goto bad;
dp->tdir_ignore = TRUE;
break;
default:
if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )
dp->tdir_ignore = TRUE;
break;
}
}
}
}
if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&
(tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))
{
if (!_TIFFFillStriles(tif))
goto bad;
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
if ((dp!=0)&&(dp->tdir_count==1))
{
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,
TIFFTAG_STRIPBYTECOUNTS);
if ((dp!=0)&&(dp->tdir_count==1))
{
tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
TIFFWarningExt(tif->tif_clientdata,module,
""Planarconfig tag value assumed incorrect, ""
""assuming data is contig instead of chunky"");
}
}
}
if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
{
MissingRequired(tif,""ImageLength"");
goto bad;
}
for (di=0, dp=dir; di<dircount; di++, dp++)
{
if (!dp->tdir_ignore) {
switch (dp->tdir_tag) 
{
case TIFFTAG_MINSAMPLEVALUE:
case TIFFTAG_MAXSAMPLEVALUE:
case TIFFTAG_BITSPERSAMPLE:
case TIFFTAG_DATATYPE:
case TIFFTAG_SAMPLEFORMAT:
{
uint16_t value;
enum TIFFReadDirEntryErr err;
err=TIFFReadDirEntryShort(tif,dp,&value);
if (err==TIFFReadDirEntryErrCount)
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
if (err!=TIFFReadDirEntryErrOk)
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
goto bad;
}
if (!TIFFSetField(tif,dp->tdir_tag,value))
goto bad;
if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
bitspersample_read = TRUE;
}
break;
case TIFFTAG_SMINSAMPLEVALUE:
case TIFFTAG_SMAXSAMPLEVALUE:
{
double *data = NULL;
enum TIFFReadDirEntryErr err;
uint32_t saved_flags;
int m;
if (dp->tdir_count != (uint64_t)tif->tif_dir.td_samplesperpixel)
err = TIFFReadDirEntryErrCount;
else
err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
if (err!=TIFFReadDirEntryErrOk)
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
goto bad;
}
saved_flags = tif->tif_flags;
tif->tif_flags |= TIFF_PERSAMPLE;
m = TIFFSetField(tif,dp->tdir_tag,data);
tif->tif_flags = saved_flags;
_TIFFfree(data);
if (!m)
goto bad;
}
break;
case TIFFTAG_STRIPOFFSETS:
case TIFFTAG_TILEOFFSETS:
switch( dp->tdir_type )
{
case TIFF_SHORT:
case TIFF_LONG:
case TIFF_LONG8:
break;
default:
if( !(tif->tif_mode == O_RDWR &&
dp->tdir_count == 0 &&
dp->tdir_type == 0 &&
dp->tdir_offset.toff_long8 == 0) )
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,module,
""Invalid data type for tag %s"",
fip ? fip->field_name : ""unknown tagname"");
}
break;
}
_TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
dp, sizeof(TIFFDirEntry) );
break;
case TIFFTAG_STRIPBYTECOUNTS:
case TIFFTAG_TILEBYTECOUNTS:
switch( dp->tdir_type )
{
case TIFF_SHORT:
case TIFF_LONG:
case TIFF_LONG8:
break;
default:
if( !(tif->tif_mode == O_RDWR &&
dp->tdir_count == 0 &&
dp->tdir_type == 0 &&
dp->tdir_offset.toff_long8 == 0) )
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,module,
""Invalid data type for tag %s"",
fip ? fip->field_name : ""unknown tagname"");
}
break;
}
_TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
dp, sizeof(TIFFDirEntry) );
break;
case TIFFTAG_COLORMAP:
case TIFFTAG_TRANSFERFUNCTION:
{
enum TIFFReadDirEntryErr err;
uint32_t countpersample;
uint32_t countrequired;
uint32_t incrementpersample;
uint16_t* value=NULL;
if( !bitspersample_read )
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,module,
""Ignoring %s since BitsPerSample tag not found"",
fip ? fip->field_name : ""unknown tagname"");
continue;
}
if (tif->tif_dir.td_bitspersample > 24)
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,module,
""Ignoring %s because BitsPerSample=%""PRIu16"">24"",
fip ? fip->field_name : ""unknown tagname"",
tif->tif_dir.td_bitspersample);
continue;
}
countpersample=(1U<<tif->tif_dir.td_bitspersample);
if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64_t)countpersample))
{
countrequired=countpersample;
incrementpersample=0;
}
else
{
countrequired=3*countpersample;
incrementpersample=countpersample;
}
if (dp->tdir_count!=(uint64_t)countrequired)
err=TIFFReadDirEntryErrCount;
else
err=TIFFReadDirEntryShortArray(tif,dp,&value);
if (err!=TIFFReadDirEntryErrOk)
{
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",1);
}
else
{
TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
_TIFFfree(value);
}
}
break;
case TIFFTAG_OSUBFILETYPE:
{
uint16_t valueo;
uint32_t value;
if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
{
switch (valueo)
{
case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;
case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;
default: value=0; break;
}
if (value!=0)
TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
}
}
break;
default:
(void) TIFFFetchNormalTag(tif, dp, TRUE);
break;
}
} 
} 
if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)
{
if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
{
TIFFWarningExt(tif->tif_clientdata, module,
""Photometric tag is missing, assuming data is YCbCr"");
if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
goto bad;
}
else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
{
tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
TIFFWarningExt(tif->tif_clientdata, module,
""Photometric tag value assumed incorrect, ""
""assuming data is YCbCr instead of RGB"");
}
if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
{
TIFFWarningExt(tif->tif_clientdata,module,
""BitsPerSample tag is missing, assuming 8 bits per sample"");
if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
goto bad;
}
if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
{
if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
{
TIFFWarningExt(tif->tif_clientdata,module,
""SamplesPerPixel tag is missing, ""
""assuming correct SamplesPerPixel value is 3"");
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
goto bad;
}
if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)
{
TIFFWarningExt(tif->tif_clientdata,module,
""SamplesPerPixel tag is missing, ""
""applying correct SamplesPerPixel value of 3"");
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
goto bad;
}
else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
|| (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))
{
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
goto bad;
}
}
}
if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  
tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
tif->tif_flags &= ~TIFF_ISTILED;
} else {
tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
tif->tif_flags |= TIFF_ISTILED;
}
if (!tif->tif_dir.td_nstrips) {
TIFFErrorExt(tif->tif_clientdata, module,
""Cannot handle zero number of %s"",
isTiled(tif) ? ""tiles"" : ""strips"");
goto bad;
}
tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)
tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
#ifdef OJPEG_SUPPORT
if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&
(isTiled(tif)==0) &&
(tif->tif_dir.td_nstrips==1)) {
TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
} else
#endif
{
MissingRequired(tif,
isTiled(tif) ? ""TileOffsets"" : ""StripOffsets"");
goto bad;
}
}
if( tif->tif_mode == O_RDWR &&
tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&
tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&
tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&
tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&
tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&
tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&
tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&
tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0 )
{
TIFFSetupStrips(tif);
}
else if( !(tif->tif_flags&TIFF_DEFERSTRILELOAD) )
{
if( tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 )
{
if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripoffset_entry),
tif->tif_dir.td_nstrips,
&tif->tif_dir.td_stripoffset_p))
{
goto bad;
}
}
if( tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )
{
if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripbytecount_entry),
tif->tif_dir.td_nstrips,
&tif->tif_dir.td_stripbytecount_p))
{
goto bad;
}
}
}
color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {
uint16_t old_extrasamples;
uint16_t *new_sampleinfo;
TIFFWarningExt(tif->tif_clientdata,module, ""Sum of Photometric type-related ""
""color channels and ExtraSamples doesn't match SamplesPerPixel. ""
""Defining non-color channels as ExtraSamples."");
old_extrasamples = tif->tif_dir.td_extrasamples;
tif->tif_dir.td_extrasamples = (uint16_t) (tif->tif_dir.td_samplesperpixel - color_channels);
new_sampleinfo = (uint16_t*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16_t));
if (!new_sampleinfo) {
TIFFErrorExt(tif->tif_clientdata, module, ""Failed to allocate memory for ""
""temporary new sampleinfo array ""
""(%""PRIu16"" 16 bit elements)"",
tif->tif_dir.td_extrasamples);
goto bad;
}
memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));
_TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
_TIFFfree(new_sampleinfo);
}
if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&
!TIFFFieldSet(tif, FIELD_COLORMAP)) {
if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)
tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
else if (tif->tif_dir.td_bitspersample>=8)
tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
else {
MissingRequired(tif, ""Colormap"");
goto bad;
}
}
if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)
{
if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
tif->tif_dir.td_nstrips > 1) ||
(tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
tif->tif_dir.td_nstrips != (uint32_t)tif->tif_dir.td_samplesperpixel)) {
MissingRequired(tif, ""StripByteCounts"");
goto bad;
}
TIFFWarningExt(tif->tif_clientdata, module,
""TIFF directory is missing required ""
""\""StripByteCounts\"" field, calculating from imagelength"");
if (EstimateStripByteCounts(tif, dir, dircount) < 0)
goto bad;
} else if (tif->tif_dir.td_nstrips == 1
&& !(tif->tif_flags&TIFF_ISTILED)
&& ByteCountLooksBad(tif)) {
TIFFWarningExt(tif->tif_clientdata, module,
""Bogus \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
if(EstimateStripByteCounts(tif, dir, dircount) < 0)
goto bad;
} else if (!(tif->tif_flags&TIFF_DEFERSTRILELOAD)
&& tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
&& tif->tif_dir.td_nstrips > 2
&& tif->tif_dir.td_compression == COMPRESSION_NONE
&& TIFFGetStrileByteCount(tif, 0) != TIFFGetStrileByteCount(tif, 1)
&& TIFFGetStrileByteCount(tif, 0) != 0
&& TIFFGetStrileByteCount(tif, 1) != 0 ) {
TIFFWarningExt(tif->tif_clientdata, module,
""Wrong \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
if (EstimateStripByteCounts(tif, dir, dircount) < 0)
goto bad;
}
}
if (dir)
{
_TIFFfree(dir);
dir=NULL;
}
if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
{
if (tif->tif_dir.td_bitspersample>=16)
tif->tif_dir.td_maxsamplevalue=0xFFFF;
else
tif->tif_dir.td_maxsamplevalue = (uint16_t)((1L << tif->tif_dir.td_bitspersample) - 1);
}
#ifdef STRIPBYTECOUNTSORTED_UNUSED
if (!(tif->tif_flags&TIFF_DEFERSTRILELOAD) && tif->tif_dir.td_nstrips > 1) {
uint32_t strip;
tif->tif_dir.td_stripbytecountsorted = 1;
for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
if (TIFFGetStrileOffset(tif, strip - 1) >
TIFFGetStrileOffset(tif, strip)) {
tif->tif_dir.td_stripbytecountsorted = 0;
break;
}
}
}
#endif
(*tif->tif_fixuptags)(tif);
if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&
(tif->tif_dir.td_nstrips==1)&&
(tif->tif_dir.td_compression==COMPRESSION_NONE)&&  
((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))
{
ChopUpSingleUncompressedStrip(tif);
}
if( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
tif->tif_dir.td_compression == COMPRESSION_NONE &&
(tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP &&
TIFFStripSize64(tif) > 0x7FFFFFFFUL )
{
TryChopUpUncompressedBigTiff(tif);
}
tif->tif_flags &= ~TIFF_DIRTYDIRECT;
tif->tif_flags &= ~TIFF_DIRTYSTRIP;
tif->tif_row = (uint32_t) -1;
tif->tif_curstrip = (uint32_t) -1;
tif->tif_col = (uint32_t) -1;
tif->tif_curtile = (uint32_t) -1;
tif->tif_tilesize = (tmsize_t) -1;
tif->tif_scanlinesize = TIFFScanlineSize(tif);
if (!tif->tif_scanlinesize) {
TIFFErrorExt(tif->tif_clientdata, module,
""Cannot handle zero scanline size"");
return (0);
}
if (isTiled(tif)) {
tif->tif_tilesize = TIFFTileSize(tif);
if (!tif->tif_tilesize) {
TIFFErrorExt(tif->tif_clientdata, module,
""Cannot handle zero tile size"");
return (0);
}
} else {
if (!TIFFStripSize(tif)) {
TIFFErrorExt(tif->tif_clientdata, module,
""Cannot handle zero strip size"");
return (0);
}
}
return (1);
bad:
if (dir)
_TIFFfree(dir);
return (0);
}","int
TIFFReadDirectory(TIFF* VAR_0)
{
static const char VAR_1[] = ""TIFFReadDirectory"";
TIFFDirEntry* VAR_2;
uint16_t VAR_3;
TIFFDirEntry* VAR_4;
uint16_t VAR_5;
const TIFFField* VAR_6;
uint32_t VAR_7=VAR_8;
toff_t VAR_9;
int VAR_10 = FALSE;
int VAR_11;
VAR_0->tif_diroff=VAR_0->tif_nextdiroff;
if (!TIFFCheckDirOffset(VAR_0,VAR_0->tif_nextdiroff))
return 0;           
(*VAR_0->tif_cleanup)(VAR_0);   
VAR_0->tif_curdir++;
VAR_9 = VAR_0->tif_nextdiroff;
VAR_3=TIFFFetchDirectory(VAR_0,VAR_9,&VAR_2,&VAR_0->tif_nextdiroff);
if (!VAR_3)
{
TIFFErrorExt(VAR_0->tif_clientdata,VAR_1,
""Failed to read directory at offset %"" VAR_12, VAR_9);
return 0;
}
TIFFReadDirectoryCheckOrder(VAR_0,VAR_2,VAR_3);
{
TIFFDirEntry* VAR_13;
uint16_t VAR_14;
for (VAR_13=VAR_2, VAR_14=0; VAR_14<VAR_3; VAR_13++, VAR_14++)
{
TIFFDirEntry* VAR_15;
uint16_t VAR_16;
for (VAR_15=VAR_13+1, VAR_16=VAR_14+1; VAR_16<VAR_3; VAR_15++, VAR_16++)
{
if (VAR_13->tdir_tag == VAR_15->tdir_tag) {
VAR_15->tdir_ignore = TRUE;
}
}
}
}
VAR_0->tif_flags &= ~VAR_17;    
VAR_0->tif_flags &= ~VAR_18;      
VAR_0->tif_flags &= ~VAR_19;
TIFFFreeDirectory(VAR_0);
TIFFDefaultDirectory(VAR_0);
TIFFSetField(VAR_0,VAR_20,VAR_21);
VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_22);
if (VAR_4)
{
if (!TIFFFetchNormalTag(VAR_0,VAR_4,0))
goto bad;
VAR_4->tdir_ignore = TRUE;
}
VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_23);
if (VAR_4)
{
uint16_t VAR_24;
enum TIFFReadDirEntryErr VAR_25;
VAR_25=TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_24);
if (VAR_25==VAR_26)
VAR_25=TIFFReadDirEntryPersampleShort(VAR_0,VAR_4,&VAR_24);
if (VAR_25!=VAR_27)
{
TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,""Compression"",0);
goto bad;
}
if (!TIFFSetField(VAR_0,VAR_23,VAR_24))
goto bad;
VAR_4->tdir_ignore = TRUE;
}
else
{
if (!TIFFSetField(VAR_0,VAR_23,VAR_28))
goto bad;
}
for (VAR_5=0, VAR_4=VAR_2; VAR_5<VAR_3; VAR_5++, VAR_4++)
{
if (!VAR_4->tdir_ignore)
{
TIFFReadDirectoryFindFieldInfo(VAR_0,VAR_4->tdir_tag,&VAR_7);
if (VAR_7 == VAR_8)
{
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""Unknown field with tag %""VAR_29"" (0x%""VAR_30"") encountered"",
VAR_4->tdir_tag,VAR_4->tdir_tag);
if (!_TIFFMergeFields(VAR_0,
_TIFFCreateAnonField(VAR_0,
VAR_4->tdir_tag,
(TIFFDataType) VAR_4->tdir_type),
1)) {
TIFFWarningExt(VAR_0->tif_clientdata,
VAR_1,
""Registering anonymous field with tag %""VAR_29"" (0x%""VAR_30"") failed"",
VAR_4->tdir_tag,
VAR_4->tdir_tag);
VAR_4->tdir_ignore = TRUE;
} else {
TIFFReadDirectoryFindFieldInfo(VAR_0,VAR_4->tdir_tag,&VAR_7);
assert(VAR_7 != VAR_8);
}
}
}
if (!VAR_4->tdir_ignore)
{
VAR_6=VAR_0->tif_fields[VAR_7];
if (VAR_6->field_bit==VAR_31)
VAR_4->tdir_ignore = TRUE;
else
{
switch (VAR_4->tdir_tag)
{
case VAR_32:
case VAR_33:
case VAR_34:
case VAR_35:
TIFFSetFieldBit(VAR_0,VAR_6->field_bit);
break;
case VAR_36:
case VAR_37:
case VAR_38:
case VAR_39:
case VAR_40:
case VAR_41:
case VAR_20:
case VAR_42:
case VAR_43:
if (!TIFFFetchNormalTag(VAR_0,VAR_4,0))
goto bad;
VAR_4->tdir_ignore = TRUE;
break;
default:
if( !_TIFFCheckFieldIsValidForCodec(VAR_0, VAR_4->tdir_tag) )
VAR_4->tdir_ignore = TRUE;
break;
}
}
}
}
if ((VAR_0->tif_dir.td_compression==VAR_44)&&
(VAR_0->tif_dir.td_planarconfig==VAR_45))
{
if (!_TIFFFillStriles(VAR_0))
goto bad;
VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_32);
if ((VAR_4!=0)&&(VAR_4->tdir_count==1))
{
VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,
VAR_33);
if ((VAR_4!=0)&&(VAR_4->tdir_count==1))
{
VAR_0->tif_dir.td_planarconfig=VAR_21;
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""Planarconfig tag value assumed incorrect, ""
""assuming data is contig instead of chunky"");
}
}
}
if (!TIFFFieldSet(VAR_0,VAR_46))
{
MissingRequired(VAR_0,""ImageLength"");
goto bad;
}
for (VAR_5=0, VAR_4=VAR_2; VAR_5<VAR_3; VAR_5++, VAR_4++)
{
if (!VAR_4->tdir_ignore) {
switch (VAR_4->tdir_tag) 
{
case VAR_47:
case VAR_48:
case VAR_49:
case VAR_50:
case VAR_51:
{
uint16_t VAR_24;
enum TIFFReadDirEntryErr VAR_25;
VAR_25=TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_24);
if (VAR_25==VAR_26)
VAR_25=TIFFReadDirEntryPersampleShort(VAR_0,VAR_4,&VAR_24);
if (VAR_25!=VAR_27)
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",0);
goto bad;
}
if (!TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_24))
goto bad;
if( VAR_4->tdir_tag == VAR_49 )
VAR_10 = TRUE;
}
break;
case VAR_52:
case VAR_53:
{
double *VAR_54 = NULL;
enum TIFFReadDirEntryErr VAR_25;
uint32_t VAR_55;
int VAR_56;
if (VAR_4->tdir_count != (uint64_t)VAR_0->tif_dir.td_samplesperpixel)
VAR_25 = VAR_26;
else
VAR_25 = TIFFReadDirEntryDoubleArray(VAR_0, VAR_4, &VAR_54);
if (VAR_25!=VAR_27)
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",0);
goto bad;
}
VAR_55 = VAR_0->tif_flags;
VAR_0->tif_flags |= VAR_57;
VAR_56 = TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_54);
VAR_0->tif_flags = VAR_55;
_TIFFfree(VAR_54);
if (!VAR_56)
goto bad;
}
break;
case VAR_32:
case VAR_34:
switch( VAR_4->tdir_type )
{
case VAR_58:
case VAR_59:
case VAR_60:
break;
default:
if( !(VAR_0->tif_mode == VAR_61 &&
VAR_4->tdir_count == 0 &&
VAR_4->tdir_type == 0 &&
VAR_4->tdir_offset.toff_long8 == 0) )
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""Invalid data type for tag %s"",
VAR_6 ? VAR_6->field_name : ""unknown tagname"");
}
break;
}
_TIFFmemcpy( &(VAR_0->tif_dir.td_stripoffset_entry),
VAR_4, sizeof(TIFFDirEntry) );
break;
case VAR_33:
case VAR_35:
switch( VAR_4->tdir_type )
{
case VAR_58:
case VAR_59:
case VAR_60:
break;
default:
if( !(VAR_0->tif_mode == VAR_61 &&
VAR_4->tdir_count == 0 &&
VAR_4->tdir_type == 0 &&
VAR_4->tdir_offset.toff_long8 == 0) )
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""Invalid data type for tag %s"",
VAR_6 ? VAR_6->field_name : ""unknown tagname"");
}
break;
}
_TIFFmemcpy( &(VAR_0->tif_dir.td_stripbytecount_entry),
VAR_4, sizeof(TIFFDirEntry) );
break;
case VAR_62:
case VAR_63:
{
enum TIFFReadDirEntryErr VAR_25;
uint32_t VAR_64;
uint32_t VAR_65;
uint32_t VAR_66;
uint16_t* VAR_24=NULL;
if( !VAR_10 )
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""Ignoring %s since BitsPerSample tag not found"",
VAR_6 ? VAR_6->field_name : ""unknown tagname"");
continue;
}
if (VAR_0->tif_dir.td_bitspersample > 24)
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""Ignoring %s because BitsPerSample=%""VAR_29"">24"",
VAR_6 ? VAR_6->field_name : ""unknown tagname"",
VAR_0->tif_dir.td_bitspersample);
continue;
}
VAR_64=(1U<<VAR_0->tif_dir.td_bitspersample);
if ((VAR_4->tdir_tag==VAR_63)&&(VAR_4->tdir_count==(uint64_t)VAR_64))
{
VAR_65=VAR_64;
VAR_66=0;
}
else
{
VAR_65=3*VAR_64;
VAR_66=VAR_64;
}
if (VAR_4->tdir_count!=(uint64_t)VAR_65)
VAR_25=VAR_26;
else
VAR_25=TIFFReadDirEntryShortArray(VAR_0,VAR_4,&VAR_24);
if (VAR_25!=VAR_27)
{
VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",1);
}
else
{
TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_24,VAR_24+VAR_66,VAR_24+2*VAR_66);
_TIFFfree(VAR_24);
}
}
break;
case VAR_67:
{
uint16_t VAR_68;
uint32_t VAR_24;
if (TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_68)==VAR_27)
{
switch (VAR_68)
{
case VAR_69: VAR_24=VAR_70; break;
case VAR_71: VAR_24=VAR_72; break;
default: VAR_24=0; break;
}
if (VAR_24!=0)
TIFFSetField(VAR_0,VAR_73,VAR_24);
}
}
break;
default:
(void) TIFFFetchNormalTag(VAR_0, VAR_4, TRUE);
break;
}
} 
} 
if (VAR_0->tif_dir.td_compression==VAR_44)
{
if (!TIFFFieldSet(VAR_0,VAR_74))
{
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""Photometric tag is missing, assuming data is YCbCr"");
if (!TIFFSetField(VAR_0,VAR_75,VAR_76))
goto bad;
}
else if (VAR_0->tif_dir.td_photometric==VAR_77)
{
VAR_0->tif_dir.td_photometric=VAR_76;
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""Photometric tag value assumed incorrect, ""
""assuming data is YCbCr instead of RGB"");
}
if (!TIFFFieldSet(VAR_0,VAR_78))
{
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""BitsPerSample tag is missing, assuming 8 bits per sample"");
if (!TIFFSetField(VAR_0,VAR_49,8))
goto bad;
}
if (!TIFFFieldSet(VAR_0,VAR_79))
{
if (VAR_0->tif_dir.td_photometric==VAR_77)
{
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""SamplesPerPixel tag is missing, ""
""assuming correct SamplesPerPixel value is 3"");
if (!TIFFSetField(VAR_0,VAR_22,3))
goto bad;
}
if (VAR_0->tif_dir.td_photometric==VAR_76)
{
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
""SamplesPerPixel tag is missing, ""
""applying correct SamplesPerPixel value of 3"");
if (!TIFFSetField(VAR_0,VAR_22,3))
goto bad;
}
else if ((VAR_0->tif_dir.td_photometric==VAR_80)
|| (VAR_0->tif_dir.td_photometric==VAR_81))
{
if (!TIFFSetField(VAR_0,VAR_22,1))
goto bad;
}
}
}
if (!TIFFFieldSet(VAR_0, VAR_82)) {
VAR_0->tif_dir.td_nstrips = TIFFNumberOfStrips(VAR_0);  
VAR_0->tif_dir.td_tilewidth = VAR_0->tif_dir.td_imagewidth;
VAR_0->tif_dir.td_tilelength = VAR_0->tif_dir.td_rowsperstrip;
VAR_0->tif_dir.td_tiledepth = VAR_0->tif_dir.td_imagedepth;
VAR_0->tif_flags &= ~VAR_83;
} else {
VAR_0->tif_dir.td_nstrips = TIFFNumberOfTiles(VAR_0);
VAR_0->tif_flags |= VAR_83;
}
if (!VAR_0->tif_dir.td_nstrips) {
TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
""Cannot handle zero number of %s"",
isTiled(VAR_0) ? ""tiles"" : ""strips"");
goto bad;
}
VAR_0->tif_dir.td_stripsperimage = VAR_0->tif_dir.td_nstrips;
if (VAR_0->tif_dir.td_planarconfig == VAR_45)
VAR_0->tif_dir.td_stripsperimage /= VAR_0->tif_dir.td_samplesperpixel;
if (!TIFFFieldSet(VAR_0, VAR_84)) {
#ifdef VAR_85
if ((VAR_0->tif_dir.td_compression==VAR_44) &&
(isTiled(VAR_0)==0) &&
(VAR_0->tif_dir.td_nstrips==1)) {
TIFFSetFieldBit(VAR_0, VAR_84);
} else
#endif
{
MissingRequired(VAR_0,
isTiled(VAR_0) ? ""TileOffsets"" : ""StripOffsets"");
goto bad;
}
}
if( VAR_0->tif_mode == VAR_61 &&
VAR_0->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&
VAR_0->tif_dir.td_stripoffset_entry.tdir_count == 0 &&
VAR_0->tif_dir.td_stripoffset_entry.tdir_type == 0 &&
VAR_0->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&
VAR_0->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&
VAR_0->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&
VAR_0->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&
VAR_0->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0 )
{
TIFFSetupStrips(VAR_0);
}
else if( !(VAR_0->tif_flags&VAR_86) )
{
if( VAR_0->tif_dir.td_stripoffset_entry.tdir_tag != 0 )
{
if (!TIFFFetchStripThing(VAR_0,&(VAR_0->tif_dir.td_stripoffset_entry),
VAR_0->tif_dir.td_nstrips,
&VAR_0->tif_dir.td_stripoffset_p))
{
goto bad;
}
}
if( VAR_0->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )
{
if (!TIFFFetchStripThing(VAR_0,&(VAR_0->tif_dir.td_stripbytecount_entry),
VAR_0->tif_dir.td_nstrips,
&VAR_0->tif_dir.td_stripbytecount_p))
{
goto bad;
}
}
}
VAR_11 = _TIFFGetMaxColorChannels(VAR_0->tif_dir.td_photometric);
if (VAR_11 && VAR_0->tif_dir.td_samplesperpixel - VAR_0->tif_dir.td_extrasamples > VAR_11) {
uint16_t VAR_87;
uint16_t *VAR_88;
TIFFWarningExt(VAR_0->tif_clientdata,VAR_1, ""Sum of Photometric type-related ""
""color channels and ExtraSamples doesn't match SamplesPerPixel. ""
""Defining non-color channels as ExtraSamples."");
VAR_87 = VAR_0->tif_dir.td_extrasamples;
VAR_0->tif_dir.td_extrasamples = (uint16_t) (VAR_0->tif_dir.td_samplesperpixel - VAR_11);
VAR_88 = (uint16_t*) _TIFFcalloc(VAR_0->tif_dir.td_extrasamples, sizeof(uint16_t));
if (!VAR_88) {
TIFFErrorExt(VAR_0->tif_clientdata, VAR_1, ""Failed to allocate memory for ""
""temporary new sampleinfo array ""
""(%""VAR_29"" 16 bit elements)"",
VAR_0->tif_dir.td_extrasamples);
goto bad;
}
memcpy(VAR_88, VAR_0->tif_dir.td_sampleinfo, VAR_87 * sizeof(uint16_t));
_TIFFsetShortArray(&VAR_0->tif_dir.td_sampleinfo, VAR_88, VAR_0->tif_dir.td_extrasamples);
_TIFFfree(VAR_88);
}
if (VAR_0->tif_dir.td_photometric == VAR_89 &&
!TIFFFieldSet(VAR_0, VAR_90)) {
if ( VAR_0->tif_dir.td_bitspersample>=8 && VAR_0->tif_dir.td_samplesperpixel==3)
VAR_0->tif_dir.td_photometric = VAR_77;
else if (VAR_0->tif_dir.td_bitspersample>=8)
VAR_0->tif_dir.td_photometric = VAR_81;
else {
MissingRequired(VAR_0, ""Colormap"");
goto bad;
}
}
if (VAR_0->tif_dir.td_compression!=VAR_44)
{
if (!TIFFFieldSet(VAR_0, VAR_91)) {
if ((VAR_0->tif_dir.td_planarconfig == VAR_21 &&
VAR_0->tif_dir.td_nstrips > 1) ||
(VAR_0->tif_dir.td_planarconfig == VAR_45 &&
VAR_0->tif_dir.td_nstrips != (uint32_t)VAR_0->tif_dir.td_samplesperpixel)) {
MissingRequired(VAR_0, ""StripByteCounts"");
goto bad;
}
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""TIFF directory is missing required ""
""\""StripByteCounts\"" field, calculating from imagelength"");
if (EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
goto bad;
} else if (VAR_0->tif_dir.td_nstrips == 1
&& !(VAR_0->tif_flags&VAR_83)
&& ByteCountLooksBad(VAR_0)) {
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""Bogus \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
if(EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
goto bad;
} else if (!(VAR_0->tif_flags&VAR_86)
&& VAR_0->tif_dir.td_planarconfig == VAR_21
&& VAR_0->tif_dir.td_nstrips > 2
&& VAR_0->tif_dir.td_compression == VAR_28
&& TIFFGetStrileByteCount(VAR_0, 0) != TIFFGetStrileByteCount(VAR_0, 1)
&& TIFFGetStrileByteCount(VAR_0, 0) != 0
&& TIFFGetStrileByteCount(VAR_0, 1) != 0 ) {
TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
""Wrong \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
if (EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
goto bad;
}
}
if (VAR_2)
{
_TIFFfree(VAR_2);
VAR_2=NULL;
}
if (!TIFFFieldSet(VAR_0, VAR_92))
{
if (VAR_0->tif_dir.td_bitspersample>=16)
VAR_0->tif_dir.td_maxsamplevalue=0xFFFF;
else
VAR_0->tif_dir.td_maxsamplevalue = (uint16_t)((1L << VAR_0->tif_dir.td_bitspersample) - 1);
}
#ifdef VAR_93
if (!(VAR_0->tif_flags&VAR_86) && VAR_0->tif_dir.td_nstrips > 1) {
uint32_t VAR_94;
VAR_0->tif_dir.td_stripbytecountsorted = 1;
for (VAR_94 = 1; VAR_94 < VAR_0->tif_dir.td_nstrips; VAR_94++) {
if (TIFFGetStrileOffset(VAR_0, VAR_94 - 1) >
TIFFGetStrileOffset(VAR_0, VAR_94)) {
VAR_0->tif_dir.td_stripbytecountsorted = 0;
break;
}
}
}
#endif
(*VAR_0->tif_fixuptags)(VAR_0);
if ((VAR_0->tif_dir.td_planarconfig==VAR_21)&&
(VAR_0->tif_dir.td_nstrips==1)&&
(VAR_0->tif_dir.td_compression==VAR_28)&&  
((VAR_0->tif_flags&(VAR_95|VAR_83))==VAR_95))
{
ChopUpSingleUncompressedStrip(VAR_0);
}
if( VAR_0->tif_dir.td_planarconfig == VAR_21 &&
VAR_0->tif_dir.td_compression == VAR_28 &&
(VAR_0->tif_flags&(VAR_95|VAR_83)) == VAR_95 &&
TIFFStripSize64(VAR_0) > 0x7FFFFFFFUL )
{
TryChopUpUncompressedBigTiff(VAR_0);
}
VAR_0->tif_flags &= ~VAR_96;
VAR_0->tif_flags &= ~VAR_97;
VAR_0->tif_row = (uint32_t) -1;
VAR_0->tif_curstrip = (uint32_t) -1;
VAR_0->tif_col = (uint32_t) -1;
VAR_0->tif_curtile = (uint32_t) -1;
VAR_0->tif_tilesize = (VAR_98) -1;
VAR_0->tif_scanlinesize = TIFFScanlineSize(VAR_0);
if (!VAR_0->tif_scanlinesize) {
TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
""Cannot handle zero scanline size"");
return (0);
}
if (isTiled(VAR_0)) {
VAR_0->tif_tilesize = TIFFTileSize(VAR_0);
if (!VAR_0->tif_tilesize) {
TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
""Cannot handle zero tile size"");
return (0);
}
} else {
if (!TIFFStripSize(VAR_0)) {
TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
""Cannot handle zero strip size"");
return (0);
}
}
return (1);
bad:
if (VAR_2)
_TIFFfree(VAR_2);
return (0);
}",libtiff/561599c99f987dc32ae110370cfdd7df7975586b/tif_dirread.c/vul/before/0.json,"int
TIFFReadDirectory(TIFF* tif)
{
	static const char module[] = ""TIFFReadDirectory"";
	TIFFDirEntry* dir;
	uint16_t dircount;
	TIFFDirEntry* dp;
	uint16_t di;
	const TIFFField* fip;
	uint32_t fii=FAILED_FII;
        toff_t nextdiroff;
    int bitspersample_read = FALSE;
        int color_channels;

	tif->tif_diroff=tif->tif_nextdiroff;
	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
		return 0;           /* last offset or bad offset (IFD looping) */
	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
	tif->tif_curdir++;
        nextdiroff = tif->tif_nextdiroff;
	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
	if (!dircount)
	{
		TIFFErrorExt(tif->tif_clientdata,module,
		    ""Failed to read directory at offset %"" PRIu64, nextdiroff);
		return 0;
	}
	TIFFReadDirectoryCheckOrder(tif,dir,dircount);

        /*
         * Mark duplicates of any tag to be ignored (bugzilla 1994)
         * to avoid certain pathological problems.
         */
	{
		TIFFDirEntry* ma;
		uint16_t mb;
		for (ma=dir, mb=0; mb<dircount; ma++, mb++)
		{
			TIFFDirEntry* na;
			uint16_t nb;
			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
			{
				if (ma->tdir_tag == na->tdir_tag) {
					na->tdir_ignore = TRUE;
				}
			}
		}
	}
        
	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */
	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */
	tif->tif_flags &= ~TIFF_CHOPPEDUPARRAYS;

	/* free any old stuff and reinit */
	TIFFFreeDirectory(tif);
	TIFFDefaultDirectory(tif);
	/*
	 * Electronic Arts writes gray-scale TIFF files
	 * without a PlanarConfiguration directory entry.
	 * Thus we setup a default value here, even though
	 * the TIFF spec says there is no default value.
	 */
	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
	/*
	 * Setup default value and then make a pass over
	 * the fields to check type and tag information,
	 * and to extract info required to size data
	 * structures.  A second pass is made afterwards
	 * to read in everything not taken in the first pass.
	 * But we must process the Compression tag first
	 * in order to merge in codec-private tag definitions (otherwise
	 * we may get complaints about unknown tags).  However, the
	 * Compression tag may be dependent on the SamplesPerPixel
	 * tag value because older TIFF specs permitted Compression
	 * to be written as a SamplesPerPixel-count tag entry.
	 * Thus if we don't first figure out the correct SamplesPerPixel
	 * tag value then we may end up ignoring the Compression tag
	 * value because it has an incorrect count value (if the
	 * true value of SamplesPerPixel is not 1).
	 */
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
	if (dp)
	{
		if (!TIFFFetchNormalTag(tif,dp,0))
			goto bad;
		dp->tdir_ignore = TRUE;
	}
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
	if (dp)
	{
		/*
		 * The 5.0 spec says the Compression tag has one value, while
		 * earlier specs say it has one value per sample.  Because of
		 * this, we accept the tag if one value is supplied with either
		 * count.
		 */
		uint16_t value;
		enum TIFFReadDirEntryErr err;
		err=TIFFReadDirEntryShort(tif,dp,&value);
		if (err==TIFFReadDirEntryErrCount)
			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
		if (err!=TIFFReadDirEntryErrOk)
		{
			TIFFReadDirEntryOutputErr(tif,err,module,""Compression"",0);
			goto bad;
		}
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))
			goto bad;
		dp->tdir_ignore = TRUE;
	}
	else
	{
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))
			goto bad;
	}
	/*
	 * First real pass over the directory.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		if (!dp->tdir_ignore)
		{
			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
			if (fii == FAILED_FII)
			{
				TIFFWarningExt(tif->tif_clientdata, module,
				    ""Unknown field with tag %""PRIu16"" (0x%""PRIx16"") encountered"",
				    dp->tdir_tag,dp->tdir_tag);
				/* the following knowingly leaks the 
				   anonymous field structure */
				if (!_TIFFMergeFields(tif,
					_TIFFCreateAnonField(tif,
						dp->tdir_tag,
						(TIFFDataType) dp->tdir_type),
					1)) {
					TIFFWarningExt(tif->tif_clientdata,
					    module,
					    ""Registering anonymous field with tag %""PRIu16"" (0x%""PRIx16"") failed"",
					    dp->tdir_tag,
					    dp->tdir_tag);
					dp->tdir_ignore = TRUE;
				} else {
					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
					assert(fii != FAILED_FII);
				}
			}
		}
		if (!dp->tdir_ignore)
		{
			fip=tif->tif_fields[fii];
			if (fip->field_bit==FIELD_IGNORE)
				dp->tdir_ignore = TRUE;
			else
			{
				switch (dp->tdir_tag)
				{
					case TIFFTAG_STRIPOFFSETS:
					case TIFFTAG_STRIPBYTECOUNTS:
					case TIFFTAG_TILEOFFSETS:
					case TIFFTAG_TILEBYTECOUNTS:
						TIFFSetFieldBit(tif,fip->field_bit);
						break;
					case TIFFTAG_IMAGEWIDTH:
					case TIFFTAG_IMAGELENGTH:
					case TIFFTAG_IMAGEDEPTH:
					case TIFFTAG_TILELENGTH:
					case TIFFTAG_TILEWIDTH:
					case TIFFTAG_TILEDEPTH:
					case TIFFTAG_PLANARCONFIG:
					case TIFFTAG_ROWSPERSTRIP:
					case TIFFTAG_EXTRASAMPLES:
						if (!TIFFFetchNormalTag(tif,dp,0))
							goto bad;
						dp->tdir_ignore = TRUE;
						break;
					default:
						if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )
							dp->tdir_ignore = TRUE;
						break;
				}
			}
		}
	}
	/*
	 * XXX: OJPEG hack.
	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,
	 * c) strip offsets/bytecounts tag are both present and
	 * d) both contain exactly one value, then we consistently find
	 * that the buggy implementation of the buggy compression scheme
	 * matches contig planarconfig best. So we 'fix-up' the tag here
	 */
	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&
	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))
	{
		if (!_TIFFFillStriles(tif))
		    goto bad;
		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
		if ((dp!=0)&&(dp->tdir_count==1))
		{
			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,
			    TIFFTAG_STRIPBYTECOUNTS);
			if ((dp!=0)&&(dp->tdir_count==1))
			{
				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
				TIFFWarningExt(tif->tif_clientdata,module,
				    ""Planarconfig tag value assumed incorrect, ""
				    ""assuming data is contig instead of chunky"");
			}
		}
	}
	/*
	 * Allocate directory structure and setup defaults.
	 */
	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
	{
		MissingRequired(tif,""ImageLength"");
		goto bad;
	}

	/*
	 * Second pass: extract other information.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		if (!dp->tdir_ignore) {
			switch (dp->tdir_tag) 
			{
				case TIFFTAG_MINSAMPLEVALUE:
				case TIFFTAG_MAXSAMPLEVALUE:
				case TIFFTAG_BITSPERSAMPLE:
				case TIFFTAG_DATATYPE:
				case TIFFTAG_SAMPLEFORMAT:
					/*
					 * The MinSampleValue, MaxSampleValue, BitsPerSample
					 * DataType and SampleFormat tags are supposed to be
					 * written as one value/sample, but some vendors
					 * incorrectly write one value only -- so we accept
					 * that as well (yuck). Other vendors write correct
					 * value for NumberOfSamples, but incorrect one for
					 * BitsPerSample and friends, and we will read this
					 * too.
					 */
					{
						uint16_t value;
						enum TIFFReadDirEntryErr err;
						err=TIFFReadDirEntryShort(tif,dp,&value);
						if (err==TIFFReadDirEntryErrCount)
							err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
						if (err!=TIFFReadDirEntryErrOk)
						{
							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
							TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
							goto bad;
						}
						if (!TIFFSetField(tif,dp->tdir_tag,value))
							goto bad;
						if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
						    bitspersample_read = TRUE;
					}
					break;
				case TIFFTAG_SMINSAMPLEVALUE:
				case TIFFTAG_SMAXSAMPLEVALUE:
					{

						double *data = NULL;
						enum TIFFReadDirEntryErr err;
						uint32_t saved_flags;
						int m;
						if (dp->tdir_count != (uint64_t)tif->tif_dir.td_samplesperpixel)
							err = TIFFReadDirEntryErrCount;
						else
							err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
						if (err!=TIFFReadDirEntryErrOk)
						{
							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
							TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
							goto bad;
						}
						saved_flags = tif->tif_flags;
						tif->tif_flags |= TIFF_PERSAMPLE;
						m = TIFFSetField(tif,dp->tdir_tag,data);
						tif->tif_flags = saved_flags;
						_TIFFfree(data);
						if (!m)
							goto bad;
					}
					break;
				case TIFFTAG_STRIPOFFSETS:
				case TIFFTAG_TILEOFFSETS:
					switch( dp->tdir_type )
					{
					    case TIFF_SHORT:
					    case TIFF_LONG:
					    case TIFF_LONG8:
					        break;
					    default:
                                                /* Warn except if directory typically created with TIFFDeferStrileArrayWriting() */
                                                if( !(tif->tif_mode == O_RDWR &&
                                                      dp->tdir_count == 0 &&
                                                      dp->tdir_type == 0 &&
                                                      dp->tdir_offset.toff_long8 == 0) )
                                                {
                                                    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
                                                    TIFFWarningExt(tif->tif_clientdata,module,
                                                                   ""Invalid data type for tag %s"",
                                                                   fip ? fip->field_name : ""unknown tagname"");
                                                }
                                                break;
                                        }
					_TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
					   dp, sizeof(TIFFDirEntry) );
					break;
				case TIFFTAG_STRIPBYTECOUNTS:
				case TIFFTAG_TILEBYTECOUNTS:
					switch( dp->tdir_type )
					{
					    case TIFF_SHORT:
					    case TIFF_LONG:
					    case TIFF_LONG8:
					        break;
					    default:
						/* Warn except if directory typically created with TIFFDeferStrileArrayWriting() */
                                                if( !(tif->tif_mode == O_RDWR &&
                                                      dp->tdir_count == 0 &&
                                                      dp->tdir_type == 0 &&
                                                      dp->tdir_offset.toff_long8 == 0) )
                                                {
                                                    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
                                                    TIFFWarningExt(tif->tif_clientdata,module,
                                                                   ""Invalid data type for tag %s"",
                                                                   fip ? fip->field_name : ""unknown tagname"");
                                                }
                                                break;
                                        }
					_TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
					   dp, sizeof(TIFFDirEntry) );
					break;
				case TIFFTAG_COLORMAP:
				case TIFFTAG_TRANSFERFUNCTION:
					{
						enum TIFFReadDirEntryErr err;
						uint32_t countpersample;
						uint32_t countrequired;
						uint32_t incrementpersample;
						uint16_t* value=NULL;
						/* It would be dangerous to instantiate those tag values */
						/* since if td_bitspersample has not yet been read (due to */
						/* unordered tags), it could be read afterwards with a */
						/* values greater than the default one (1), which may cause */
						/* crashes in user code */
						if( !bitspersample_read )
						{
							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
							TIFFWarningExt(tif->tif_clientdata,module,
								""Ignoring %s since BitsPerSample tag not found"",
								fip ? fip->field_name : ""unknown tagname"");
							continue;
						}
						/* ColorMap or TransferFunction for high bit */
						/* depths do not make much sense and could be */
						/* used as a denial of service vector */
						if (tif->tif_dir.td_bitspersample > 24)
						{
							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
							TIFFWarningExt(tif->tif_clientdata,module,
								""Ignoring %s because BitsPerSample=%""PRIu16"">24"",
								fip ? fip->field_name : ""unknown tagname"",
								tif->tif_dir.td_bitspersample);
							continue;
						}
						countpersample=(1U<<tif->tif_dir.td_bitspersample);
						if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64_t)countpersample))
						{
							countrequired=countpersample;
							incrementpersample=0;
						}
						else
						{
							countrequired=3*countpersample;
							incrementpersample=countpersample;
						}
						if (dp->tdir_count!=(uint64_t)countrequired)
							err=TIFFReadDirEntryErrCount;
						else
							err=TIFFReadDirEntryShortArray(tif,dp,&value);
						if (err!=TIFFReadDirEntryErrOk)
						{
							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
							TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",1);
						}
						else
						{
							TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
							_TIFFfree(value);
						}
					}
					break;
/* BEGIN REV 4.0 COMPATIBILITY */
				case TIFFTAG_OSUBFILETYPE:
					{
						uint16_t valueo;
						uint32_t value;
						if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
						{
							switch (valueo)
							{
								case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;
								case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;
								default: value=0; break;
							}
							if (value!=0)
								TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
						}
					}
					break;
/* END REV 4.0 COMPATIBILITY */
				default:
					(void) TIFFFetchNormalTag(tif, dp, TRUE);
					break;
				}
			} /* -- if (!dp->tdir_ignore) */
		} /* -- for-loop -- */

	/*
	 * OJPEG hack:
	 * - If a) compression is OJPEG, and b) photometric tag is missing,
	 * then we consistently find that photometric should be YCbCr
	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,
	 * then we consistently find that the buggy implementation of the
	 * buggy compression scheme matches photometric YCbCr instead.
	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,
	 * then we consistently find bitspersample should be 8.
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is RGB or YCbCr, then we consistently find
	 * samplesperpixel should be 3
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently
	 * find samplesperpixel should be 3
	 */
	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)
	{
		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
		{
			TIFFWarningExt(tif->tif_clientdata, module,
			    ""Photometric tag is missing, assuming data is YCbCr"");
			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
				goto bad;
		}
		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
		{
			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
			TIFFWarningExt(tif->tif_clientdata, module,
			    ""Photometric tag value assumed incorrect, ""
			    ""assuming data is YCbCr instead of RGB"");
		}
		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
		{
			TIFFWarningExt(tif->tif_clientdata,module,
			    ""BitsPerSample tag is missing, assuming 8 bits per sample"");
			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
				goto bad;
		}
		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
		{
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    ""SamplesPerPixel tag is missing, ""
				    ""assuming correct SamplesPerPixel value is 3"");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    ""SamplesPerPixel tag is missing, ""
				    ""applying correct SamplesPerPixel value of 3"");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))
			{
				/*
				 * SamplesPerPixel tag is missing, but is not required
				 * by spec.  Assume correct SamplesPerPixel value of 1.
				 */
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
					goto bad;
			}
		}
	}

	/*
	 * Setup appropriate structures (by strip or by tile)
	 * We do that only after the above OJPEG hack which alters SamplesPerPixel
	 * and thus influences the number of strips in the separate planarconfig.
	 */
	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  
		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
		tif->tif_flags &= ~TIFF_ISTILED;
	} else {
		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
		tif->tif_flags |= TIFF_ISTILED;
	}
	if (!tif->tif_dir.td_nstrips) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Cannot handle zero number of %s"",
		    isTiled(tif) ? ""tiles"" : ""strips"");
		goto bad;
	}
	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)
		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
#ifdef OJPEG_SUPPORT
		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&
		    (isTiled(tif)==0) &&
		    (tif->tif_dir.td_nstrips==1)) {
			/*
			 * XXX: OJPEG hack.
			 * If a) compression is OJPEG, b) it's not a tiled TIFF,
			 * and c) the number of strips is 1,
			 * then we tolerate the absence of stripoffsets tag,
			 * because, presumably, all required data is in the
			 * JpegInterchangeFormat stream.
			 */
			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
		} else
#endif
        {
			MissingRequired(tif,
				isTiled(tif) ? ""TileOffsets"" : ""StripOffsets"");
			goto bad;
		}
	}

        if( tif->tif_mode == O_RDWR &&
            tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&
            tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&
            tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&
            tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&
            tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&
            tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&
            tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&
            tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0 )
        {
            /* Directory typically created with TIFFDeferStrileArrayWriting() */
            TIFFSetupStrips(tif);
        }
        else if( !(tif->tif_flags&TIFF_DEFERSTRILELOAD) )
        {
            if( tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 )
            {
                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripoffset_entry),
                                         tif->tif_dir.td_nstrips,
                                         &tif->tif_dir.td_stripoffset_p))
                {
                    goto bad;
                }
            }
            if( tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )
            {
                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripbytecount_entry),
                                         tif->tif_dir.td_nstrips,
                                         &tif->tif_dir.td_stripbytecount_p))
                {
                    goto bad;
                }
            }
        }

	/*
	 * Make sure all non-color channels are extrasamples.
	 * If it's not the case, define them as such.
	 */
        color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
        if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {
                uint16_t old_extrasamples;
                uint16_t *new_sampleinfo;

                TIFFWarningExt(tif->tif_clientdata,module, ""Sum of Photometric type-related ""
                    ""color channels and ExtraSamples doesn't match SamplesPerPixel. ""
                    ""Defining non-color channels as ExtraSamples."");

                old_extrasamples = tif->tif_dir.td_extrasamples;
                tif->tif_dir.td_extrasamples = (uint16_t) (tif->tif_dir.td_samplesperpixel - color_channels);

                // sampleinfo should contain information relative to these new extra samples
                new_sampleinfo = (uint16_t*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16_t));
                if (!new_sampleinfo) {
                    TIFFErrorExt(tif->tif_clientdata, module, ""Failed to allocate memory for ""
                                                              ""temporary new sampleinfo array ""
                                                              ""(%""PRIu16"" 16 bit elements)"",
                                tif->tif_dir.td_extrasamples);
                    goto bad;
                }

                if (old_extrasamples > 0)
                    memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));
                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
                _TIFFfree(new_sampleinfo);
        }

	/*
	 * Verify Palette image has a Colormap.
	 */
	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&
	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)
			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
		else if (tif->tif_dir.td_bitspersample>=8)
			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
		else {
			MissingRequired(tif, ""Colormap"");
			goto bad;
		}
	}
	/*
	 * OJPEG hack:
	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG
	 * TIFFs
	 */
	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)
	{
		/*
		 * Attempt to deal with a missing StripByteCounts tag.
		 */
		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
			/*
			 * Some manufacturers violate the spec by not giving
			 * the size of the strips.  In this case, assume there
			 * is one uncompressed strip of data.
			 */
			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
			    tif->tif_dir.td_nstrips > 1) ||
			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
			     tif->tif_dir.td_nstrips != (uint32_t)tif->tif_dir.td_samplesperpixel)) {
			    MissingRequired(tif, ""StripByteCounts"");
			    goto bad;
			}
			TIFFWarningExt(tif->tif_clientdata, module,
				""TIFF directory is missing required ""
				""\""StripByteCounts\"" field, calculating from imagelength"");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;

		} else if (tif->tif_dir.td_nstrips == 1
                           && !(tif->tif_flags&TIFF_ISTILED)
			   && ByteCountLooksBad(tif)) {
			/*
			 * XXX: Plexus (and others) sometimes give a value of
			 * zero for a tag when they don't know what the
			 * correct value is!  Try and handle the simple case
			 * of estimating the size of a one strip image.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    ""Bogus \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
			if(EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;

		} else if (!(tif->tif_flags&TIFF_DEFERSTRILELOAD)
			   && tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
			   && tif->tif_dir.td_nstrips > 2
			   && tif->tif_dir.td_compression == COMPRESSION_NONE
			   && TIFFGetStrileByteCount(tif, 0) != TIFFGetStrileByteCount(tif, 1)
			   && TIFFGetStrileByteCount(tif, 0) != 0
			   && TIFFGetStrileByteCount(tif, 1) != 0 ) {
			/*
			 * XXX: Some vendors fill StripByteCount array with
			 * absolutely wrong values (it can be equal to
			 * StripOffset array, for example). Catch this case
			 * here.
                         *
                         * We avoid this check if deferring strile loading
                         * as it would always force us to load the strip/tile
                         * information.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    ""Wrong \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;
		}
	}
	if (dir)
	{
		_TIFFfree(dir);
		dir=NULL;
	}
	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
	{
		if (tif->tif_dir.td_bitspersample>=16)
			tif->tif_dir.td_maxsamplevalue=0xFFFF;
		else
			tif->tif_dir.td_maxsamplevalue = (uint16_t)((1L << tif->tif_dir.td_bitspersample) - 1);
	}

#ifdef STRIPBYTECOUNTSORTED_UNUSED
	/*
	 * XXX: We can optimize checking for the strip bounds using the sorted
	 * bytecounts array. See also comments for TIFFAppendToStrip()
	 * function in tif_write.c.
	 */
	if (!(tif->tif_flags&TIFF_DEFERSTRILELOAD) && tif->tif_dir.td_nstrips > 1) {
		uint32_t strip;

		tif->tif_dir.td_stripbytecountsorted = 1;
		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
			if (TIFFGetStrileOffset(tif, strip - 1) >
			    TIFFGetStrileOffset(tif, strip)) {
				tif->tif_dir.td_stripbytecountsorted = 0;
				break;
			}
		}
	}
#endif

	/*
	 * An opportunity for compression mode dependent tag fixup
	 */
	(*tif->tif_fixuptags)(tif);

	/*
	 * Some manufacturers make life difficult by writing
	 * large amounts of uncompressed data as a single strip.
	 * This is contrary to the recommendations of the spec.
	 * The following makes an attempt at breaking such images
	 * into strips closer to the recommended 8k bytes.  A
	 * side effect, however, is that the RowsPerStrip tag
	 * value may be changed.
	 */
	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&
	    (tif->tif_dir.td_nstrips==1)&&
	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  
	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))
        {
            ChopUpSingleUncompressedStrip(tif);
        }

        /* There are also uncompressed striped files with strips larger than */
        /* 2 GB, which make them unfriendly with a lot of code. If possible, */
        /* try to expose smaller ""virtual"" strips. */
        if( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
            tif->tif_dir.td_compression == COMPRESSION_NONE &&
            (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP &&
            TIFFStripSize64(tif) > 0x7FFFFFFFUL )
        {
            TryChopUpUncompressedBigTiff(tif);
        }

        /*
         * Clear the dirty directory flag. 
         */
	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
	tif->tif_flags &= ~TIFF_DIRTYSTRIP;

	/*
	 * Reinitialize i/o since we are starting on a new directory.
	 */
	tif->tif_row = (uint32_t) -1;
	tif->tif_curstrip = (uint32_t) -1;
	tif->tif_col = (uint32_t) -1;
	tif->tif_curtile = (uint32_t) -1;
	tif->tif_tilesize = (tmsize_t) -1;

	tif->tif_scanlinesize = TIFFScanlineSize(tif);
	if (!tif->tif_scanlinesize) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Cannot handle zero scanline size"");
		return (0);
	}

	if (isTiled(tif)) {
		tif->tif_tilesize = TIFFTileSize(tif);
		if (!tif->tif_tilesize) {
			TIFFErrorExt(tif->tif_clientdata, module,
			     ""Cannot handle zero tile size"");
			return (0);
		}
	} else {
		if (!TIFFStripSize(tif)) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Cannot handle zero strip size"");
			return (0);
		}
	}
	return (1);
bad:
	if (dir)
		_TIFFfree(dir);
	return (0);
}","int
TIFFReadDirectory(TIFF* VAR_0)
{
	static const char VAR_1[] = ""TIFFReadDirectory"";
	TIFFDirEntry* VAR_2;
	uint16_t VAR_3;
	TIFFDirEntry* VAR_4;
	uint16_t VAR_5;
	const TIFFField* VAR_6;
	uint32_t VAR_7=VAR_8;
        toff_t VAR_9;
    int VAR_10 = FALSE;
        int VAR_11;

	VAR_0->tif_diroff=VAR_0->tif_nextdiroff;
	if (!TIFFCheckDirOffset(VAR_0,VAR_0->tif_nextdiroff))
		return 0;           /* COMMENT_0 */
	(*VAR_0->tif_cleanup)(VAR_0);   /* COMMENT_1 */
	VAR_0->tif_curdir++;
        VAR_9 = VAR_0->tif_nextdiroff;
	VAR_3=TIFFFetchDirectory(VAR_0,VAR_9,&VAR_2,&VAR_0->tif_nextdiroff);
	if (!VAR_3)
	{
		TIFFErrorExt(VAR_0->tif_clientdata,VAR_1,
		    ""Failed to read directory at offset %"" VAR_12, VAR_9);
		return 0;
	}
	TIFFReadDirectoryCheckOrder(VAR_0,VAR_2,VAR_3);

        /* COMMENT_2 */
                                                                   
                                                  
           
	{
		TIFFDirEntry* VAR_13;
		uint16_t VAR_14;
		for (VAR_13=VAR_2, VAR_14=0; VAR_14<VAR_3; VAR_13++, VAR_14++)
		{
			TIFFDirEntry* VAR_15;
			uint16_t VAR_16;
			for (VAR_15=VAR_13+1, VAR_16=VAR_14+1; VAR_16<VAR_3; VAR_15++, VAR_16++)
			{
				if (VAR_13->tdir_tag == VAR_15->tdir_tag) {
					VAR_15->tdir_ignore = TRUE;
				}
			}
		}
	}
        
	VAR_0->tif_flags &= ~VAR_17;    /* COMMENT_6 */
	VAR_0->tif_flags &= ~VAR_18;      /* COMMENT_6 */
	VAR_0->tif_flags &= ~VAR_19;

	/* COMMENT_7 */
	TIFFFreeDirectory(VAR_0);
	TIFFDefaultDirectory(VAR_0);
	/* COMMENT_8 */
                                                
                                                  
                                                   
                                                 
    
	TIFFSetField(VAR_0,VAR_20,VAR_21);
	/* COMMENT_14 */
                                                 
                                                 
                                             
                                                 
                                                      
                                                 
                                                                 
                                                            
                                                           
                                                            
                                                       
                                                                 
                                                             
                                                         
                                            
    
	VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_22);
	if (VAR_4)
	{
		if (!TIFFFetchNormalTag(VAR_0,VAR_4,0))
			goto bad;
		VAR_4->tdir_ignore = TRUE;
	}
	VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_23);
	if (VAR_4)
	{
		/* COMMENT_31 */
                                                               
                                                               
                                                                 
           
     
		uint16_t VAR_24;
		enum TIFFReadDirEntryErr VAR_25;
		VAR_25=TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_24);
		if (VAR_25==VAR_26)
			VAR_25=TIFFReadDirEntryPersampleShort(VAR_0,VAR_4,&VAR_24);
		if (VAR_25!=VAR_27)
		{
			TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,""Compression"",0);
			goto bad;
		}
		if (!TIFFSetField(VAR_0,VAR_23,VAR_24))
			goto bad;
		VAR_4->tdir_ignore = TRUE;
	}
	else
	{
		if (!TIFFSetField(VAR_0,VAR_23,VAR_28))
			goto bad;
	}
	/* COMMENT_37 */
                                       
    
	for (VAR_5=0, VAR_4=VAR_2; VAR_5<VAR_3; VAR_5++, VAR_4++)
	{
		if (!VAR_4->tdir_ignore)
		{
			TIFFReadDirectoryFindFieldInfo(VAR_0,VAR_4->tdir_tag,&VAR_7);
			if (VAR_7 == VAR_8)
			{
				TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
				    ""Unknown field with tag %""VAR_29"" (0x%""VAR_30"") encountered"",
				    VAR_4->tdir_tag,VAR_4->tdir_tag);
				/* COMMENT_40 */
                                   
				if (!_TIFFMergeFields(VAR_0,
					_TIFFCreateAnonField(VAR_0,
						VAR_4->tdir_tag,
						(TIFFDataType) VAR_4->tdir_type),
					1)) {
					TIFFWarningExt(VAR_0->tif_clientdata,
					    VAR_1,
					    ""Registering anonymous field with tag %""VAR_29"" (0x%""VAR_30"") failed"",
					    VAR_4->tdir_tag,
					    VAR_4->tdir_tag);
					VAR_4->tdir_ignore = TRUE;
				} else {
					TIFFReadDirectoryFindFieldInfo(VAR_0,VAR_4->tdir_tag,&VAR_7);
					assert(VAR_7 != VAR_8);
				}
			}
		}
		if (!VAR_4->tdir_ignore)
		{
			VAR_6=VAR_0->tif_fields[VAR_7];
			if (VAR_6->field_bit==VAR_31)
				VAR_4->tdir_ignore = TRUE;
			else
			{
				switch (VAR_4->tdir_tag)
				{
					case VAR_32:
					case VAR_33:
					case VAR_34:
					case VAR_35:
						TIFFSetFieldBit(VAR_0,VAR_6->field_bit);
						break;
					case VAR_36:
					case VAR_37:
					case VAR_38:
					case VAR_39:
					case VAR_40:
					case VAR_41:
					case VAR_20:
					case VAR_42:
					case VAR_43:
						if (!TIFFFetchNormalTag(VAR_0,VAR_4,0))
							goto bad;
						VAR_4->tdir_ignore = TRUE;
						break;
					default:
						if( !_TIFFCheckFieldIsValidForCodec(VAR_0, VAR_4->tdir_tag) )
							VAR_4->tdir_ignore = TRUE;
						break;
				}
			}
		}
	}
	/* COMMENT_42 */
                    
                                                                       
                                                        
                                                                
                                                                 
                                                                 
    
	if ((VAR_0->tif_dir.td_compression==VAR_44)&&
	    (VAR_0->tif_dir.td_planarconfig==VAR_45))
	{
		if (!_TIFFFillStriles(VAR_0))
		    goto bad;
		VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,VAR_32);
		if ((VAR_4!=0)&&(VAR_4->tdir_count==1))
		{
			VAR_4=TIFFReadDirectoryFindEntry(VAR_0,VAR_2,VAR_3,
			    VAR_33);
			if ((VAR_4!=0)&&(VAR_4->tdir_count==1))
			{
				VAR_0->tif_dir.td_planarconfig=VAR_21;
				TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
				    ""Planarconfig tag value assumed incorrect, ""
				    ""assuming data is contig instead of chunky"");
			}
		}
	}
	/* COMMENT_50 */
                                                    
    
	if (!TIFFFieldSet(VAR_0,VAR_46))
	{
		MissingRequired(VAR_0,""ImageLength"");
		goto bad;
	}

	/* COMMENT_53 */
                                           
    
	for (VAR_5=0, VAR_4=VAR_2; VAR_5<VAR_3; VAR_5++, VAR_4++)
	{
		if (!VAR_4->tdir_ignore) {
			switch (VAR_4->tdir_tag) 
			{
				case VAR_47:
				case VAR_48:
				case VAR_49:
				case VAR_50:
				case VAR_51:
					/* COMMENT_56 */
                                                         
                                                         
                                                     
                                                        
                                                        
                                                        
                                                        
            
        
					{
						uint16_t VAR_24;
						enum TIFFReadDirEntryErr VAR_25;
						VAR_25=TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_24);
						if (VAR_25==VAR_26)
							VAR_25=TIFFReadDirEntryPersampleShort(VAR_0,VAR_4,&VAR_24);
						if (VAR_25!=VAR_27)
						{
							VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
							TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",0);
							goto bad;
						}
						if (!TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_24))
							goto bad;
						if( VAR_4->tdir_tag == VAR_49 )
						    VAR_10 = TRUE;
					}
					break;
				case VAR_52:
				case VAR_53:
					{

						double *VAR_54 = NULL;
						enum TIFFReadDirEntryErr VAR_25;
						uint32_t VAR_55;
						int VAR_56;
						if (VAR_4->tdir_count != (uint64_t)VAR_0->tif_dir.td_samplesperpixel)
							VAR_25 = VAR_26;
						else
							VAR_25 = TIFFReadDirEntryDoubleArray(VAR_0, VAR_4, &VAR_54);
						if (VAR_25!=VAR_27)
						{
							VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
							TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",0);
							goto bad;
						}
						VAR_55 = VAR_0->tif_flags;
						VAR_0->tif_flags |= VAR_57;
						VAR_56 = TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_54);
						VAR_0->tif_flags = VAR_55;
						_TIFFfree(VAR_54);
						if (!VAR_56)
							goto bad;
					}
					break;
				case VAR_32:
				case VAR_34:
					switch( VAR_4->tdir_type )
					{
					    case VAR_58:
					    case VAR_59:
					    case VAR_60:
					        break;
					    default:
                                                /* COMMENT_66 */
                                                if( !(VAR_0->tif_mode == VAR_61 &&
                                                      VAR_4->tdir_count == 0 &&
                                                      VAR_4->tdir_type == 0 &&
                                                      VAR_4->tdir_offset.toff_long8 == 0) )
                                                {
                                                    VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
                                                    TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
                                                                   ""Invalid data type for tag %s"",
                                                                   VAR_6 ? VAR_6->field_name : ""unknown tagname"");
                                                }
                                                break;
                                        }
					_TIFFmemcpy( &(VAR_0->tif_dir.td_stripoffset_entry),
					   VAR_4, sizeof(TIFFDirEntry) );
					break;
				case VAR_33:
				case VAR_35:
					switch( VAR_4->tdir_type )
					{
					    case VAR_58:
					    case VAR_59:
					    case VAR_60:
					        break;
					    default:
						/* COMMENT_66 */
                                                if( !(VAR_0->tif_mode == VAR_61 &&
                                                      VAR_4->tdir_count == 0 &&
                                                      VAR_4->tdir_type == 0 &&
                                                      VAR_4->tdir_offset.toff_long8 == 0) )
                                                {
                                                    VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
                                                    TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
                                                                   ""Invalid data type for tag %s"",
                                                                   VAR_6 ? VAR_6->field_name : ""unknown tagname"");
                                                }
                                                break;
                                        }
					_TIFFmemcpy( &(VAR_0->tif_dir.td_stripbytecount_entry),
					   VAR_4, sizeof(TIFFDirEntry) );
					break;
				case VAR_62:
				case VAR_63:
					{
						enum TIFFReadDirEntryErr VAR_25;
						uint32_t VAR_64;
						uint32_t VAR_65;
						uint32_t VAR_66;
						uint16_t* VAR_24=NULL;
						/* COMMENT_67 */
						/* COMMENT_68 */
						/* COMMENT_69 */
						/* COMMENT_70 */
						/* COMMENT_71 */
						if( !VAR_10 )
						{
							VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
							TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
								""Ignoring %s since BitsPerSample tag not found"",
								VAR_6 ? VAR_6->field_name : ""unknown tagname"");
							continue;
						}
						/* COMMENT_72 */
						/* COMMENT_73 */
						/* COMMENT_74 */
						if (VAR_0->tif_dir.td_bitspersample > 24)
						{
							VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
							TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
								""Ignoring %s because BitsPerSample=%""VAR_29"">24"",
								VAR_6 ? VAR_6->field_name : ""unknown tagname"",
								VAR_0->tif_dir.td_bitspersample);
							continue;
						}
						VAR_64=(1U<<VAR_0->tif_dir.td_bitspersample);
						if ((VAR_4->tdir_tag==VAR_63)&&(VAR_4->tdir_count==(uint64_t)VAR_64))
						{
							VAR_65=VAR_64;
							VAR_66=0;
						}
						else
						{
							VAR_65=3*VAR_64;
							VAR_66=VAR_64;
						}
						if (VAR_4->tdir_count!=(uint64_t)VAR_65)
							VAR_25=VAR_26;
						else
							VAR_25=TIFFReadDirEntryShortArray(VAR_0,VAR_4,&VAR_24);
						if (VAR_25!=VAR_27)
						{
							VAR_6 = TIFFFieldWithTag(VAR_0,VAR_4->tdir_tag);
							TIFFReadDirEntryOutputErr(VAR_0,VAR_25,VAR_1,VAR_6 ? VAR_6->field_name : ""unknown tagname"",1);
						}
						else
						{
							TIFFSetField(VAR_0,VAR_4->tdir_tag,VAR_24,VAR_24+VAR_66,VAR_24+2*VAR_66);
							_TIFFfree(VAR_24);
						}
					}
					break;
/* COMMENT_75 */
				case VAR_67:
					{
						uint16_t VAR_68;
						uint32_t VAR_24;
						if (TIFFReadDirEntryShort(VAR_0,VAR_4,&VAR_68)==VAR_27)
						{
							switch (VAR_68)
							{
								case VAR_69: VAR_24=VAR_70; break;
								case VAR_71: VAR_24=VAR_72; break;
								default: VAR_24=0; break;
							}
							if (VAR_24!=0)
								TIFFSetField(VAR_0,VAR_73,VAR_24);
						}
					}
					break;
/* COMMENT_76 */
				default:
					(void) TIFFFetchNormalTag(VAR_0, VAR_4, TRUE);
					break;
				}
			} /* COMMENT_77 */
		} /* COMMENT_78 */

	/* COMMENT_79 */
               
                                                                    
                                                              
                                                                       
                                                                  
                                                               
                                                                      
                                                        
                                                                    
                                                                 
                               
                                                                    
                                                                        
                                    
    
	if (VAR_0->tif_dir.td_compression==VAR_44)
	{
		if (!TIFFFieldSet(VAR_0,VAR_74))
		{
			TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
			    ""Photometric tag is missing, assuming data is YCbCr"");
			if (!TIFFSetField(VAR_0,VAR_75,VAR_76))
				goto bad;
		}
		else if (VAR_0->tif_dir.td_photometric==VAR_77)
		{
			VAR_0->tif_dir.td_photometric=VAR_76;
			TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
			    ""Photometric tag value assumed incorrect, ""
			    ""assuming data is YCbCr instead of RGB"");
		}
		if (!TIFFFieldSet(VAR_0,VAR_78))
		{
			TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
			    ""BitsPerSample tag is missing, assuming 8 bits per sample"");
			if (!TIFFSetField(VAR_0,VAR_49,8))
				goto bad;
		}
		if (!TIFFFieldSet(VAR_0,VAR_79))
		{
			if (VAR_0->tif_dir.td_photometric==VAR_77)
			{
				TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
				    ""SamplesPerPixel tag is missing, ""
				    ""assuming correct SamplesPerPixel value is 3"");
				if (!TIFFSetField(VAR_0,VAR_22,3))
					goto bad;
			}
			if (VAR_0->tif_dir.td_photometric==VAR_76)
			{
				TIFFWarningExt(VAR_0->tif_clientdata,VAR_1,
				    ""SamplesPerPixel tag is missing, ""
				    ""applying correct SamplesPerPixel value of 3"");
				if (!TIFFSetField(VAR_0,VAR_22,3))
					goto bad;
			}
			else if ((VAR_0->tif_dir.td_photometric==VAR_80)
				 || (VAR_0->tif_dir.td_photometric==VAR_81))
			{
				/* COMMENT_94 */
                                                          
                                                           
       
				if (!TIFFSetField(VAR_0,VAR_22,1))
					goto bad;
			}
		}
	}

	/* COMMENT_98 */
                                                      
                                                                           
                                                                          
    
	if (!TIFFFieldSet(VAR_0, VAR_82)) {
		VAR_0->tif_dir.td_nstrips = TIFFNumberOfStrips(VAR_0);  
		VAR_0->tif_dir.td_tilewidth = VAR_0->tif_dir.td_imagewidth;
		VAR_0->tif_dir.td_tilelength = VAR_0->tif_dir.td_rowsperstrip;
		VAR_0->tif_dir.td_tiledepth = VAR_0->tif_dir.td_imagedepth;
		VAR_0->tif_flags &= ~VAR_83;
	} else {
		VAR_0->tif_dir.td_nstrips = TIFFNumberOfTiles(VAR_0);
		VAR_0->tif_flags |= VAR_83;
	}
	if (!VAR_0->tif_dir.td_nstrips) {
		TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
		    ""Cannot handle zero number of %s"",
		    isTiled(VAR_0) ? ""tiles"" : ""strips"");
		goto bad;
	}
	VAR_0->tif_dir.td_stripsperimage = VAR_0->tif_dir.td_nstrips;
	if (VAR_0->tif_dir.td_planarconfig == VAR_45)
		VAR_0->tif_dir.td_stripsperimage /= VAR_0->tif_dir.td_samplesperpixel;
	if (!TIFFFieldSet(VAR_0, VAR_84)) {
#ifdef VAR_85
		if ((VAR_0->tif_dir.td_compression==VAR_44) &&
		    (isTiled(VAR_0)==0) &&
		    (VAR_0->tif_dir.td_nstrips==1)) {
			/* COMMENT_103 */
                      
                                                           
                                       
                                                       
                                                      
                                   
      
			TIFFSetFieldBit(VAR_0, VAR_84);
		} else
#endif
        {
			MissingRequired(VAR_0,
				isTiled(VAR_0) ? ""TileOffsets"" : ""StripOffsets"");
			goto bad;
		}
	}

        if( VAR_0->tif_mode == VAR_61 &&
            VAR_0->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&
            VAR_0->tif_dir.td_stripoffset_entry.tdir_count == 0 &&
            VAR_0->tif_dir.td_stripoffset_entry.tdir_type == 0 &&
            VAR_0->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&
            VAR_0->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&
            VAR_0->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&
            VAR_0->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&
            VAR_0->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0 )
        {
            /* COMMENT_111 */
            TIFFSetupStrips(VAR_0);
        }
        else if( !(VAR_0->tif_flags&VAR_86) )
        {
            if( VAR_0->tif_dir.td_stripoffset_entry.tdir_tag != 0 )
            {
                if (!TIFFFetchStripThing(VAR_0,&(VAR_0->tif_dir.td_stripoffset_entry),
                                         VAR_0->tif_dir.td_nstrips,
                                         &VAR_0->tif_dir.td_stripoffset_p))
                {
                    goto bad;
                }
            }
            if( VAR_0->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )
            {
                if (!TIFFFetchStripThing(VAR_0,&(VAR_0->tif_dir.td_stripbytecount_entry),
                                         VAR_0->tif_dir.td_nstrips,
                                         &VAR_0->tif_dir.td_stripbytecount_p))
                {
                    goto bad;
                }
            }
        }

	/* COMMENT_112 */
                                                      
                                              
    
        VAR_11 = _TIFFGetMaxColorChannels(VAR_0->tif_dir.td_photometric);
        if (VAR_11 && VAR_0->tif_dir.td_samplesperpixel - VAR_0->tif_dir.td_extrasamples > VAR_11) {
                uint16_t VAR_87;
                uint16_t *VAR_88;

                TIFFWarningExt(VAR_0->tif_clientdata,VAR_1, ""Sum of Photometric type-related ""
                    ""color channels and ExtraSamples doesn't match SamplesPerPixel. ""
                    ""Defining non-color channels as ExtraSamples."");

                VAR_87 = VAR_0->tif_dir.td_extrasamples;
                VAR_0->tif_dir.td_extrasamples = (uint16_t) (VAR_0->tif_dir.td_samplesperpixel - VAR_11);

                /* COMMENT_116 */
                VAR_88 = (uint16_t*) _TIFFcalloc(VAR_0->tif_dir.td_extrasamples, sizeof(uint16_t));
                if (!VAR_88) {
                    TIFFErrorExt(VAR_0->tif_clientdata, VAR_1, ""Failed to allocate memory for ""
                                                              ""temporary new sampleinfo array ""
                                                              ""(%""VAR_29"" 16 bit elements)"",
                                VAR_0->tif_dir.td_extrasamples);
                    goto bad;
                }

                if (VAR_87 > 0)
                    memcpy(VAR_88, VAR_0->tif_dir.td_sampleinfo, VAR_87 * sizeof(uint16_t));
                _TIFFsetShortArray(&VAR_0->tif_dir.td_sampleinfo, VAR_88, VAR_0->tif_dir.td_extrasamples);
                _TIFFfree(VAR_88);
        }

	/* COMMENT_117 */
                                        
    
	if (VAR_0->tif_dir.td_photometric == VAR_89 &&
	    !TIFFFieldSet(VAR_0, VAR_90)) {
		if ( VAR_0->tif_dir.td_bitspersample>=8 && VAR_0->tif_dir.td_samplesperpixel==3)
			VAR_0->tif_dir.td_photometric = VAR_77;
		else if (VAR_0->tif_dir.td_bitspersample>=8)
			VAR_0->tif_dir.td_photometric = VAR_81;
		else {
			MissingRequired(VAR_0, ""Colormap"");
			goto bad;
		}
	}
	/* COMMENT_120 */
               
                                                                        
         
    
	if (VAR_0->tif_dir.td_compression!=VAR_44)
	{
		/* COMMENT_125 */
                                                        
     
		if (!TIFFFieldSet(VAR_0, VAR_91)) {
			/* COMMENT_128 */
                                                       
                                                         
                                        
      
			if ((VAR_0->tif_dir.td_planarconfig == VAR_21 &&
			    VAR_0->tif_dir.td_nstrips > 1) ||
			    (VAR_0->tif_dir.td_planarconfig == VAR_45 &&
			     VAR_0->tif_dir.td_nstrips != (uint32_t)VAR_0->tif_dir.td_samplesperpixel)) {
			    MissingRequired(VAR_0, ""StripByteCounts"");
			    goto bad;
			}
			TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
				""TIFF directory is missing required ""
				""\""StripByteCounts\"" field, calculating from imagelength"");
			if (EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
			    goto bad;

		} else if (VAR_0->tif_dir.td_nstrips == 1
                           && !(VAR_0->tif_flags&VAR_83)
			   && ByteCountLooksBad(VAR_0)) {
			/* COMMENT_133 */
                                                        
                                                  
                                                       
                                                  
      
			TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
			    ""Bogus \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
			if(EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
			    goto bad;

		} else if (!(VAR_0->tif_flags&VAR_86)
			   && VAR_0->tif_dir.td_planarconfig == VAR_21
			   && VAR_0->tif_dir.td_nstrips > 2
			   && VAR_0->tif_dir.td_compression == VAR_28
			   && TIFFGetStrileByteCount(VAR_0, 0) != TIFFGetStrileByteCount(VAR_0, 1)
			   && TIFFGetStrileByteCount(VAR_0, 0) != 0
			   && TIFFGetStrileByteCount(VAR_0, 1) != 0 ) {
			/* COMMENT_139 */
                                                      
                                                 
                                                      
           
                          
                                                                          
                                                                             
                                       
      
			TIFFWarningExt(VAR_0->tif_clientdata, VAR_1,
			    ""Wrong \""StripByteCounts\"" field, ignoring and calculating from imagelength"");
			if (EstimateStripByteCounts(VAR_0, VAR_2, VAR_3) < 0)
			    goto bad;
		}
	}
	if (VAR_2)
	{
		_TIFFfree(VAR_2);
		VAR_2=NULL;
	}
	if (!TIFFFieldSet(VAR_0, VAR_92))
	{
		if (VAR_0->tif_dir.td_bitspersample>=16)
			VAR_0->tif_dir.td_maxsamplevalue=0xFFFF;
		else
			VAR_0->tif_dir.td_maxsamplevalue = (uint16_t)((1L << VAR_0->tif_dir.td_bitspersample) - 1);
	}

#ifdef VAR_93
	/* COMMENT_149 */
                                                                       
                                                               
                            
    
	if (!(VAR_0->tif_flags&VAR_86) && VAR_0->tif_dir.td_nstrips > 1) {
		uint32_t VAR_94;

		VAR_0->tif_dir.td_stripbytecountsorted = 1;
		for (VAR_94 = 1; VAR_94 < VAR_0->tif_dir.td_nstrips; VAR_94++) {
			if (TIFFGetStrileOffset(VAR_0, VAR_94 - 1) >
			    TIFFGetStrileOffset(VAR_0, VAR_94)) {
				VAR_0->tif_dir.td_stripbytecountsorted = 0;
				break;
			}
		}
	}
#endif

	/* COMMENT_154 */
                                                           
    
	(*VAR_0->tif_fixuptags)(VAR_0);

	/* COMMENT_157 */
                                                     
                                                         
                                                        
                                                          
                                                      
                                                      
                         
    
	if ((VAR_0->tif_dir.td_planarconfig==VAR_21)&&
	    (VAR_0->tif_dir.td_nstrips==1)&&
	    (VAR_0->tif_dir.td_compression==VAR_28)&&  
	    ((VAR_0->tif_flags&(VAR_95|VAR_83))==VAR_95))
        {
            ChopUpSingleUncompressedStrip(VAR_0);
        }

        /* COMMENT_166 */
        /* COMMENT_167 */
        /* COMMENT_168 */
        if( VAR_0->tif_dir.td_planarconfig == VAR_21 &&
            VAR_0->tif_dir.td_compression == VAR_28 &&
            (VAR_0->tif_flags&(VAR_95|VAR_83)) == VAR_95 &&
            TIFFStripSize64(VAR_0) > 0x7FFFFFFFUL )
        {
            TryChopUpUncompressedBigTiff(VAR_0);
        }

        /* COMMENT_169 */
                                           
           
	VAR_0->tif_flags &= ~VAR_96;
	VAR_0->tif_flags &= ~VAR_97;

	/* COMMENT_172 */
                                                              
    
	VAR_0->tif_row = (uint32_t) -1;
	VAR_0->tif_curstrip = (uint32_t) -1;
	VAR_0->tif_col = (uint32_t) -1;
	VAR_0->tif_curtile = (uint32_t) -1;
	VAR_0->tif_tilesize = (VAR_98) -1;

	VAR_0->tif_scanlinesize = TIFFScanlineSize(VAR_0);
	if (!VAR_0->tif_scanlinesize) {
		TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
		    ""Cannot handle zero scanline size"");
		return (0);
	}

	if (isTiled(VAR_0)) {
		VAR_0->tif_tilesize = TIFFTileSize(VAR_0);
		if (!VAR_0->tif_tilesize) {
			TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
			     ""Cannot handle zero tile size"");
			return (0);
		}
	} else {
		if (!TIFFStripSize(VAR_0)) {
			TIFFErrorExt(VAR_0->tif_clientdata, VAR_1,
			    ""Cannot handle zero strip size"");
			return (0);
		}
	}
	return (1);
bad:
	if (VAR_2)
		_TIFFfree(VAR_2);
	return (0);
}",libtiff/561599c99f987dc32ae110370cfdd7df7975586b/tif_dirread.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -599,7 +599,8 @@
                     goto bad;
                 }
 
-                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));
+                if (old_extrasamples > 0)
+                    memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));
                 _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
                 _TIFFfree(new_sampleinfo);
         }","{'deleted_lines': ['                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));'], 'added_lines': ['                if (old_extrasamples > 0)', '                    memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));']}",True,"Null source pointer passed as an argument to memcpy() function within TIFFFetchStripThing() in tif_dirread.c in libtiff versions from 3.9.0 to 4.3.0 could lead to Denial of Service via crafted TIFF file. For users that compile libtiff from sources, the fix is available with commit eecb0712.",5.5,MEDIUM,1,valid,,5
CVE-2022-0561,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libtiff,"TIFFFetchStripThing(): avoid calling memcpy() with a null source pointer and size of zero (fixes #362)
",eecb0712f4c3a5b449f70c57988260a667ddbdef,https://gitlab.com/libtiff/libtiff/-/commit/eecb0712f4c3a5b449f70c57988260a667ddbdef,libtiff/tif_dirread.c,TIFFFetchStripThing,"static int
TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32_t nstrips, uint64_t** lpp)
{
static const char module[] = ""TIFFFetchStripThing"";
enum TIFFReadDirEntryErr err;
uint64_t* data;
err=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);
if (err!=TIFFReadDirEntryErrOk)
{
const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); 
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
return(0);
}
if (dir->tdir_count<(uint64_t)nstrips)
{
uint64_t* resizeddata;
const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag);
const char* pszMax = getenv(""LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT"");
uint32_t max_nstrips = 1000000;
if( pszMax )
max_nstrips = (uint32_t) atoi(pszMax);
TIFFReadDirEntryOutputErr(tif,TIFFReadDirEntryErrCount,
module,
fip ? fip->field_name : ""unknown tagname"",
( nstrips <= max_nstrips ) );
if( nstrips > max_nstrips )
{
_TIFFfree(data);
return(0);
}
resizeddata=(uint64_t*)_TIFFCheckMalloc(tif, nstrips, sizeof(uint64_t), ""for strip array"");
if (resizeddata==0) {
_TIFFfree(data);
return(0);
}
_TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));
_TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));
_TIFFfree(data);
data=resizeddata;
}
*lpp=data;
return(1);
}","static int
TIFFFetchStripThing(TIFF* VAR_0, TIFFDirEntry* VAR_1, uint32_t VAR_2, uint64_t** VAR_3)
{
static const char VAR_4[] = ""TIFFFetchStripThing"";
enum TIFFReadDirEntryErr VAR_5;
uint64_t* VAR_6;
VAR_5=TIFFReadDirEntryLong8ArrayWithLimit(VAR_0,VAR_1,&VAR_6,VAR_2);
if (VAR_5!=VAR_7)
{
const TIFFField* VAR_8 = TIFFFieldWithTag(VAR_0,VAR_1->tdir_tag); 
TIFFReadDirEntryOutputErr(VAR_0,VAR_5,VAR_4,VAR_8 ? VAR_8->field_name : ""unknown tagname"",0);
return(0);
}
if (VAR_1->tdir_count<(uint64_t)VAR_2)
{
uint64_t* VAR_9;
const TIFFField* VAR_8 = TIFFFieldWithTag(VAR_0,VAR_1->tdir_tag);
const char* VAR_10 = getenv(""LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT"");
uint32_t VAR_11 = 1000000;
if( VAR_10 )
VAR_11 = (uint32_t) atoi(VAR_10);
TIFFReadDirEntryOutputErr(VAR_0,VAR_12,
VAR_4,
VAR_8 ? VAR_8->field_name : ""unknown tagname"",
( VAR_2 <= VAR_11 ) );
if( VAR_2 > VAR_11 )
{
_TIFFfree(VAR_6);
return(0);
}
VAR_9=(uint64_t*)_TIFFCheckMalloc(VAR_0, VAR_2, sizeof(uint64_t), ""for strip array"");
if (VAR_9==0) {
_TIFFfree(VAR_6);
return(0);
}
_TIFFmemcpy(VAR_9,VAR_6, (uint32_t)VAR_1->tdir_count * sizeof(uint64_t));
_TIFFmemset(VAR_9+(uint32_t)VAR_1->tdir_count, 0, (VAR_2 - (uint32_t)VAR_1->tdir_count) * sizeof(uint64_t));
_TIFFfree(VAR_6);
VAR_6=VAR_9;
}
*VAR_3=VAR_6;
return(1);
}",libtiff/eecb0712f4c3a5b449f70c57988260a667ddbdef/tif_dirread.c/vul/before/0.json,"static int
TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32_t nstrips, uint64_t** lpp)
{
	static const char module[] = ""TIFFFetchStripThing"";
	enum TIFFReadDirEntryErr err;
	uint64_t* data;
	err=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);
	if (err!=TIFFReadDirEntryErrOk)
	{
		const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); 
		TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : ""unknown tagname"",0);
		return(0);
	}
	if (dir->tdir_count<(uint64_t)nstrips)
	{
		uint64_t* resizeddata;
		const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag);
		const char* pszMax = getenv(""LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT"");
		uint32_t max_nstrips = 1000000;
		if( pszMax )
			max_nstrips = (uint32_t) atoi(pszMax);
		TIFFReadDirEntryOutputErr(tif,TIFFReadDirEntryErrCount,
		            module,
		            fip ? fip->field_name : ""unknown tagname"",
		            ( nstrips <= max_nstrips ) );

		if( nstrips > max_nstrips )
		{
			_TIFFfree(data);
			return(0);
		}

		resizeddata=(uint64_t*)_TIFFCheckMalloc(tif, nstrips, sizeof(uint64_t), ""for strip array"");
		if (resizeddata==0) {
			_TIFFfree(data);
			return(0);
		}
		if( dir->tdir_count )
			_TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));
		_TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));
		_TIFFfree(data);
		data=resizeddata;
	}
	*lpp=data;
	return(1);
}","static int
TIFFFetchStripThing(TIFF* VAR_0, TIFFDirEntry* VAR_1, uint32_t VAR_2, uint64_t** VAR_3)
{
	static const char VAR_4[] = ""TIFFFetchStripThing"";
	enum TIFFReadDirEntryErr VAR_5;
	uint64_t* VAR_6;
	VAR_5=TIFFReadDirEntryLong8ArrayWithLimit(VAR_0,VAR_1,&VAR_6,VAR_2);
	if (VAR_5!=VAR_7)
	{
		const TIFFField* VAR_8 = TIFFFieldWithTag(VAR_0,VAR_1->tdir_tag); 
		TIFFReadDirEntryOutputErr(VAR_0,VAR_5,VAR_4,VAR_8 ? VAR_8->field_name : ""unknown tagname"",0);
		return(0);
	}
	if (VAR_1->tdir_count<(uint64_t)VAR_2)
	{
		uint64_t* VAR_9;
		const TIFFField* VAR_8 = TIFFFieldWithTag(VAR_0,VAR_1->tdir_tag);
		const char* VAR_10 = getenv(""LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT"");
		uint32_t VAR_11 = 1000000;
		if( VAR_10 )
			VAR_11 = (uint32_t) atoi(VAR_10);
		TIFFReadDirEntryOutputErr(VAR_0,VAR_12,
		            VAR_4,
		            VAR_8 ? VAR_8->field_name : ""unknown tagname"",
		            ( VAR_2 <= VAR_11 ) );

		if( VAR_2 > VAR_11 )
		{
			_TIFFfree(VAR_6);
			return(0);
		}

		VAR_9=(uint64_t*)_TIFFCheckMalloc(VAR_0, VAR_2, sizeof(uint64_t), ""for strip array"");
		if (VAR_9==0) {
			_TIFFfree(VAR_6);
			return(0);
		}
		if( VAR_1->tdir_count )
			_TIFFmemcpy(VAR_9,VAR_6, (uint32_t)VAR_1->tdir_count * sizeof(uint64_t));
		_TIFFmemset(VAR_9+(uint32_t)VAR_1->tdir_count, 0, (VAR_2 - (uint32_t)VAR_1->tdir_count) * sizeof(uint64_t));
		_TIFFfree(VAR_6);
		VAR_6=VAR_9;
	}
	*VAR_3=VAR_6;
	return(1);
}",libtiff/eecb0712f4c3a5b449f70c57988260a667ddbdef/tif_dirread.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,8 +35,9 @@
 			_TIFFfree(data);
 			return(0);
 		}
-                _TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));
-                _TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));
+		if( dir->tdir_count )
+			_TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));
+		_TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));
 		_TIFFfree(data);
 		data=resizeddata;
 	}","{'deleted_lines': ['                _TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));', '                _TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));'], 'added_lines': ['\t\tif( dir->tdir_count )', '\t\t\t_TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));', '\t\t_TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));']}",True,"Null source pointer passed as an argument to memcpy() function within TIFFFetchStripThing() in tif_dirread.c in libtiff versions from 3.9.0 to 4.3.0 could lead to Denial of Service via crafted TIFF file. For users that compile libtiff from sources, the fix is available with commit eecb0712.",5.5,MEDIUM,1,valid,,5
CVE-2022-0480,['CWE-770'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"User can create file locks for each open file and force kernel to allocate
small but long-living objects per each open file.

It makes sense to account for these objects to limit the host's memory
consumption from inside the memcg-limited container.

Link: https://lkml.kernel.org/r/b009f4c7-f0ab-c0ec-8e83-918f47d677da@virtuozzo.com
Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
Reviewed-by: Shakeel Butt <shakeelb@google.com>
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: Andrei Vagin <avagin@gmail.com>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Borislav Petkov <bp@suse.de>
Cc: Christian Brauner <christian.brauner@ubuntu.com>
Cc: Dmitry Safonov <0x7f454c46@gmail.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: ""J. Bruce Fields"" <bfields@fieldses.org>
Cc: Jeff Layton <jlayton@kernel.org>
Cc: Jens Axboe <axboe@kernel.dk>
Cc: Jiri Slaby <jirislaby@kernel.org>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
Cc: Michal Hocko <mhocko@kernel.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Roman Gushchin <guro@fb.com>
Cc: Serge Hallyn <serge@hallyn.com>
Cc: Tejun Heo <tj@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
Cc: Yutian Yang <nglaive@gmail.com>
Cc: Zefan Li <lizefan.x@bytedance.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",0f12156dff2862ac54235fc72703f18770769042,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0f12156dff2862ac54235fc72703f18770769042,fs/locks.c,filelock_init,"static int __init filelock_init(void)
{
int i;
flctx_cache = kmem_cache_create(""file_lock_ctx"",
sizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);
filelock_cache = kmem_cache_create(""file_lock_cache"",
sizeof(struct file_lock), 0, SLAB_PANIC, NULL);
for_each_possible_cpu(i) {
struct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);
spin_lock_init(&fll->lock);
INIT_HLIST_HEAD(&fll->hlist);
}
lease_notifier_chain_init();
return 0;
}","static int __init filelock_init(void)
{
int VAR_0;
VAR_1 = kmem_cache_create(""file_lock_ctx"",
sizeof(struct file_lock_context), 0, VAR_2, NULL);
VAR_3 = kmem_cache_create(""file_lock_cache"",
sizeof(struct file_lock), 0, VAR_2, NULL);
for_each_possible_cpu(VAR_0) {
struct file_lock_list_struct *VAR_4 = per_cpu_ptr(&VAR_5, VAR_0);
spin_lock_init(&VAR_4->lock);
INIT_HLIST_HEAD(&VAR_4->hlist);
}
lease_notifier_chain_init();
return 0;
}",,"static int __init filelock_init(void)
{
	int i;

	flctx_cache = kmem_cache_create(""file_lock_ctx"",
			sizeof(struct file_lock_context), 0,
			SLAB_PANIC | SLAB_ACCOUNT, NULL);

	filelock_cache = kmem_cache_create(""file_lock_cache"",
			sizeof(struct file_lock), 0,
			SLAB_PANIC | SLAB_ACCOUNT, NULL);

	for_each_possible_cpu(i) {
		struct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);

		spin_lock_init(&fll->lock);
		INIT_HLIST_HEAD(&fll->hlist);
	}

	lease_notifier_chain_init();
	return 0;
}","static int __init filelock_init(void)
{
	int VAR_0;

	VAR_1 = kmem_cache_create(""file_lock_ctx"",
			sizeof(struct file_lock_context), 0,
			VAR_2 | VAR_3, NULL);

	VAR_4 = kmem_cache_create(""file_lock_cache"",
			sizeof(struct file_lock), 0,
			VAR_2 | VAR_3, NULL);

	for_each_possible_cpu(VAR_0) {
		struct file_lock_list_struct *VAR_5 = per_cpu_ptr(&VAR_6, VAR_0);

		spin_lock_init(&VAR_5->lock);
		INIT_HLIST_HEAD(&VAR_5->hlist);
	}

	lease_notifier_chain_init();
	return 0;
}",,"--- func_before
+++ func_after
@@ -3,10 +3,12 @@
 	int i;
 
 	flctx_cache = kmem_cache_create(""file_lock_ctx"",
-			sizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);
+			sizeof(struct file_lock_context), 0,
+			SLAB_PANIC | SLAB_ACCOUNT, NULL);
 
 	filelock_cache = kmem_cache_create(""file_lock_cache"",
-			sizeof(struct file_lock), 0, SLAB_PANIC, NULL);
+			sizeof(struct file_lock), 0,
+			SLAB_PANIC | SLAB_ACCOUNT, NULL);
 
 	for_each_possible_cpu(i) {
 		struct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);","{'deleted_lines': ['\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);', '\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);'], 'added_lines': ['\t\t\tsizeof(struct file_lock_context), 0,', '\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);', '\t\t\tsizeof(struct file_lock), 0,', '\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);']}",True,A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.,5.5,MEDIUM,1,valid,,5
CVE-2022-2953,"['CWE-415', 'CWE-131', 'CWE-763', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"According to Richard Nolde https://gitlab.com/libtiff/libtiff/-/issues/401#note_877637400 the tiffcrop option -S is also mutually exclusive to the other crop options (-X|-Y), -Z and -z.

This is now checked and ends tiffcrop if those arguments are not mutually exclusive.

This MR will fix the following tiffcrop issues: #349, #414, #422, #423, #424
",8fe3735942ea1d90d8cef843b55b3efe8ab6feaf,https://gitlab.com/libtiff/libtiff/-/commit/8fe3735942ea1d90d8cef843b55b3efe8ab6feaf,tools/tiffcrop.c,process_command_opts,"void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,
uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,
uint32_t *deftilelength, uint32_t *defrowsperstrip,
struct crop_mask *crop_data, struct pagedef *page,
struct dump_opts *dump,
unsigned int     *imagelist, unsigned int   *image_count )
{
int   c, good_args = 0;
char *opt_offset   = NULL;    
char *opt_ptr      = NULL;    
char *sep          = NULL;    
unsigned int  i, j, start, end;
#if !HAVE_DECL_OPTARG
extern int   optind;
extern char* optarg;
#endif
*mp++ = 'w';
*mp = '\0';
while ((c = getopt(argc, argv,
""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
{
good_args++;
switch (c) {
case 'a': mode[0] = 'a';
break;
case 'c':if (!processCompressOptions(optarg)) 
{
TIFFError (""Unknown compression option"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'd':start = strtoul(optarg, NULL, 0); 
if (start == 0)
{
TIFFError ("""",""Directory offset must be greater than zero"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
*dirnum = start - 1;
break;
case 'e': switch (tolower((int) optarg[0])) 
{
case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;
crop_data->img_mode = COMPOSITE_IMAGES;
break; 
case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;
crop_data->img_mode = COMPOSITE_IMAGES;
break; 
case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
case 's': crop_data->exp_mode = FILE_PER_SELECTION;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
default:  TIFFError (""Unknown export mode"",""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'f':if (streq(optarg, ""lsb2msb""))   
*deffillorder = FILLORDER_LSB2MSB;
else if (streq(optarg, ""msb2lsb""))
*deffillorder = FILLORDER_MSB2LSB;
else
{
TIFFError (""Unknown fill order"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'h':usage(EXIT_SUCCESS);
break;
case 'i':ignore = TRUE;
break;
case 'k':maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;
break;
case 'l':outtiled = TRUE; 
*deftilelength = atoi(optarg);
break;
case 'p': 
if (streq(optarg, ""separate""))
*defconfig = PLANARCONFIG_SEPARATE;
else if (streq(optarg, ""contig""))
*defconfig = PLANARCONFIG_CONTIG;
else
{
TIFFError (""Unknown planar configuration"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'r':
*defrowsperstrip = atol(optarg);
break;
case 's':
outtiled = FALSE;
break;
case 't':
outtiled = TRUE;
break;
case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
printf(""Tiffcrop version: %s, last updated: %s\n"",
tiffcrop_version_id, tiffcrop_rev_date);
printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
exit (EXIT_SUCCESS);
break;
case 'w':
outtiled = TRUE;
*deftilewidth = atoi(optarg);
break;
case 'z': 
crop_data->crop_mode |= CROP_REGIONS;
for (i = 0, opt_ptr = strtok (optarg, "":"");
((opt_ptr != NULL) &&  (i < MAX_REGIONS));
(opt_ptr = strtok (NULL, "":"")), i++)
{
crop_data->regions++;
if (sscanf(opt_ptr, ""%lf,%lf,%lf,%lf"",
&crop_data->corners[i].X1, &crop_data->corners[i].Y1,
&crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)
{
TIFFError (""Unable to parse coordinates for region"", ""%u %s"", i, optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
{
TIFFError (""Region list exceeds limit of"", ""%d regions %s"", MAX_REGIONS, optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);;
}
break;
case 'B': *mp++ = 'b'; *mp = '\0';
break;
case 'L': *mp++ = 'l'; *mp = '\0';
break;
case 'M': *mp++ = 'm'; *mp = '\0';
break;
case 'C': *mp++ = 'c'; *mp = '\0';
break;
case 'D': for (i = 0, opt_ptr = strtok (optarg, "","");
(opt_ptr != NULL);
(opt_ptr = strtok (NULL, "","")), i++)
{
opt_offset = strpbrk(opt_ptr, "":="");
if (opt_offset == NULL)
{
TIFFError(""Invalid dump option"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
*opt_offset = '\0';
end = strlen (opt_ptr);
for (i = 0; i < end; i++)
*(opt_ptr + i) = tolower((int) *(opt_ptr + i));
if (strncmp(opt_ptr, ""for"", 3) == 0)
{
end = strlen (opt_offset + 1);
for (i = 1; i <= end; i++)
*(opt_offset + i) = tolower((int) *(opt_offset + i));
if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
{
dump->format = DUMP_TEXT;
strcpy (dump->mode, ""w"");
}
else
{
if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
{
dump->format = DUMP_RAW;
strcpy (dump->mode, ""wb"");
}
else
{
TIFFError(""parse_command_opts"", ""Unknown dump format %s"", opt_offset + 1);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
}
else
{ 
if (strncmp (opt_ptr, ""lev"", 3) == 0)
dump->level = atoi(opt_offset + 1);
if (strncmp (opt_ptr, ""in"", 2) == 0)
{
strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);
dump->infilename[PATH_MAX - 20] = '\0';
}
if (strncmp (opt_ptr, ""out"", 3) == 0)
{
strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);
dump->outfilename[PATH_MAX - 20] = '\0';
}
if (strncmp (opt_ptr, ""deb"", 3) == 0)
dump->debug = atoi(opt_offset + 1);
}
}
if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))
{
if (dump->level == 1)
TIFFError("""",""Defaulting to dump level 1, no data."");
if (dump->format == DUMP_NONE)
{
TIFFError("""", ""You must specify a dump format for dump files"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
break;
case 'm': 
crop_data->crop_mode |= CROP_MARGINS;
for (i = 0, opt_ptr = strtok (optarg, "",:"");
((opt_ptr != NULL) &&  (i < 4));
(opt_ptr = strtok (NULL, "",:"")), i++)
{
crop_data->margins[i] = atof(opt_ptr);
}
break;
case 'E':
switch (tolower((int) optarg[0]))
{
case 't': crop_data->edge_ref = EDGE_TOP;
break;
case 'b': crop_data->edge_ref = EDGE_BOTTOM;
break;
case 'l': crop_data->edge_ref = EDGE_LEFT;
break;
case 'r': crop_data->edge_ref = EDGE_RIGHT;
break;
default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'F': 
crop_data->crop_mode |= CROP_MIRROR;
switch (tolower((int) optarg[0]))
{
case  'h': crop_data->mirror = MIRROR_HORIZ;
break;
case  'v': crop_data->mirror = MIRROR_VERT;
break;
case  'b': crop_data->mirror = MIRROR_BOTH;
break;
default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'H': 
page->hres = atof (optarg);
page->mode |= PAGE_MODE_RESOLUTION;
break;
case 'I': 
crop_data->crop_mode |= CROP_INVERT;
if (streq(optarg, ""black""))
{
crop_data->photometric = PHOTOMETRIC_MINISBLACK;
continue;
}
if (streq(optarg, ""white""))
{
crop_data->photometric = PHOTOMETRIC_MINISWHITE;
continue;
}
if (streq(optarg, ""data"")) 
{
crop_data->photometric = INVERT_DATA_ONLY;
continue;
}
if (streq(optarg, ""both""))
{
crop_data->photometric = INVERT_DATA_AND_TAG;
continue;
}
TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
break;
case 'J': 
page->hmargin = atof(optarg);
page->mode |= PAGE_MODE_MARGINS;
break;
case 'K': 
page->vmargin = atof(optarg);
page->mode |= PAGE_MODE_MARGINS;
break;
case 'N':
for (i = 0, opt_ptr = strtok (optarg, "","");
((opt_ptr != NULL) &&  (i < MAX_IMAGES));
(opt_ptr = strtok (NULL, "","")))
{ 
if (streq(opt_ptr, ""odd""))
{
for (j = 1; j <= MAX_IMAGES; j += 2)
imagelist[i++] = j;
*image_count = (MAX_IMAGES - 1) / 2;
break;
}
else
{
if (streq(opt_ptr, ""even""))
{
for (j = 2; j <= MAX_IMAGES; j += 2)
imagelist[i++] = j;
*image_count = MAX_IMAGES / 2;
break;
}
else
{
if (streq(opt_ptr, ""last""))
imagelist[i++] = MAX_IMAGES;
else  
{
sep = strpbrk(opt_ptr, "":-"");
if (!sep)
imagelist[i++] = atoi(opt_ptr);
else
{
*sep = '\0';
start = atoi (opt_ptr);
if (!strcmp((sep + 1), ""last""))
end = MAX_IMAGES;
else
end = atoi (sep + 1);
for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)
imagelist[i++] = j;
}
}
}
}
}
*image_count = i;
break;
case 'O':  
switch (tolower((int) optarg[0]))
{
case  'a': page->orient = ORIENTATION_AUTO;
break;
case  'p': page->orient = ORIENTATION_PORTRAIT;
break;
case  'l': page->orient = ORIENTATION_LANDSCAPE;
break;
default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'P':  
if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
{
strcpy (page->name, ""Custom""); 
page->mode |= PAGE_MODE_PAPERSIZE;
break;
}
if (get_page_geometry (optarg, page))
{
if (!strcmp(optarg, ""list""))
{
TIFFError("""", ""Name            Width   Length (in inches)"");
for (i = 0; i < MAX_PAPERNAMES - 1; i++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
PaperTable[i].name, PaperTable[i].width, 
PaperTable[i].length);
exit (EXIT_FAILURE);
}
TIFFError (""Invalid paper size"", ""%s"", optarg);
TIFFError ("""", ""Select one of:"");
TIFFError("""", ""Name            Width   Length (in inches)"");
for (i = 0; i < MAX_PAPERNAMES - 1; i++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
PaperTable[i].name, PaperTable[i].width, 
PaperTable[i].length);
exit (EXIT_FAILURE);
}
else
{
page->mode |= PAGE_MODE_PAPERSIZE;
}
break;
case 'R': 
crop_data->crop_mode |= CROP_ROTATE;
switch (strtoul(optarg, NULL, 0))
{
case  90:  crop_data->rotation = (uint16_t)90;
break;
case  180: crop_data->rotation = (uint16_t)180;
break;
case  270: crop_data->rotation = (uint16_t)270;
break;
default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'S':
sep = strpbrk(optarg, "",:"");
if (sep)
{
*sep = '\0';
page->cols = atoi(optarg);
page->rows = atoi(sep +1);
}
else
{
page->cols = atoi(optarg);
page->rows = atoi(optarg);
}
if ((page->cols * page->rows) > MAX_SECTIONS)
{
TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", MAX_SECTIONS);
exit (EXIT_FAILURE);
}
page->mode |= PAGE_MODE_ROWSCOLS;
break;
case 'U':
if (streq(optarg, ""in""))
{
crop_data->res_unit = RESUNIT_INCH;
page->res_unit = RESUNIT_INCH;
}
else if (streq(optarg, ""cm""))
{
crop_data->res_unit = RESUNIT_CENTIMETER;
page->res_unit = RESUNIT_CENTIMETER;
}
else if (streq(optarg, ""px""))
{
crop_data->res_unit = RESUNIT_NONE;
page->res_unit = RESUNIT_NONE;
}
else
{
TIFFError (""Illegal unit of measure"",""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'V': 
page->vres = atof (optarg);
page->mode |= PAGE_MODE_RESOLUTION;
break;
case 'X':
crop_data->crop_mode |= CROP_WIDTH;
crop_data->width = atof(optarg);
break;
case 'Y':
crop_data->crop_mode |= CROP_LENGTH;
crop_data->length = atof(optarg);
break;
case 'Z': 
crop_data->crop_mode |= CROP_ZONES;
for (i = 0, opt_ptr = strtok (optarg, "","");
((opt_ptr != NULL) &&  (i < MAX_REGIONS));
(opt_ptr = strtok (NULL, "","")), i++)
{
crop_data->zones++;
opt_offset = strchr(opt_ptr, ':');
if (!opt_offset) {
TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
exit(EXIT_FAILURE);
}
*opt_offset = '\0';
crop_data->zonelist[i].position = atoi(opt_ptr);
crop_data->zonelist[i].total    = atoi(opt_offset + 1);
}
if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
{
TIFFError(""Zone list exceeds region limit"", ""%d"",  MAX_REGIONS);
exit (EXIT_FAILURE);
}
break;
case '?':TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
char XY, Z, R;
XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));
Z = (crop_data->crop_mode & CROP_ZONES);
R = (crop_data->crop_mode & CROP_REGIONS);
if ((XY && Z) || (XY && R) || (Z && R)) {
TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit"");
exit(EXIT_FAILURE);
}
}","void  process_command_opts (int VAR_0, char *VAR_1[], char *VAR_2, char *VAR_3, uint32_t *VAR_4,
uint16_t *VAR_5, uint16_t *VAR_6, uint32_t *VAR_7,
uint32_t *VAR_8, uint32_t *VAR_9,
struct crop_mask *VAR_10, struct pagedef *VAR_11,
struct dump_opts *VAR_12,
unsigned int     *VAR_13, unsigned int   *VAR_14 )
{
int   VAR_15, VAR_16 = 0;
char *VAR_17   = NULL;    
char *VAR_18      = NULL;    
char *VAR_19          = NULL;    
unsigned int  VAR_20, VAR_21, VAR_22, VAR_23;
#if !VAR_24
extern int   VAR_25;
extern char* VAR_26;
#endif
*VAR_2++ = 'w';
*VAR_2 = '\0';
while ((VAR_15 = getopt(VAR_0, VAR_1,
""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
{
VAR_16++;
switch (VAR_15) {
case 'a': VAR_3[0] = 'a';
break;
case 'c':if (!processCompressOptions(VAR_26)) 
{
TIFFError (""Unknown compression option"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'd':VAR_22 = strtoul(VAR_26, NULL, 0); 
if (VAR_22 == 0)
{
TIFFError ("""",""Directory offset must be greater than zero"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
*VAR_4 = VAR_22 - 1;
break;
case 'e': switch (tolower((int) VAR_26[0])) 
{
case 'c': VAR_10->exp_mode = VAR_28;
VAR_10->img_mode = VAR_29;
break; 
case 'd': VAR_10->exp_mode = VAR_30;
VAR_10->img_mode = VAR_31;
break; 
case 'i': VAR_10->exp_mode = VAR_32;
VAR_10->img_mode = VAR_29;
break; 
case 'm': VAR_10->exp_mode = VAR_33;
VAR_10->img_mode = VAR_31;
break; 
case 's': VAR_10->exp_mode = VAR_34;
VAR_10->img_mode = VAR_31;
break; 
default:  TIFFError (""Unknown export mode"",""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'f':if (streq(VAR_26, ""lsb2msb""))   
*VAR_6 = VAR_35;
else if (streq(VAR_26, ""msb2lsb""))
*VAR_6 = VAR_36;
else
{
TIFFError (""Unknown fill order"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'h':usage(VAR_37);
break;
case 'i':VAR_38 = TRUE;
break;
case 'k':VAR_39 = (tmsize_t)strtoul(VAR_26, NULL, 0) << 20;
break;
case 'l':VAR_40 = TRUE; 
*VAR_8 = atoi(VAR_26);
break;
case 'p': 
if (streq(VAR_26, ""separate""))
*VAR_5 = VAR_41;
else if (streq(VAR_26, ""contig""))
*VAR_5 = VAR_42;
else
{
TIFFError (""Unknown planar configuration"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'r':
*VAR_9 = atol(VAR_26);
break;
case 's':
VAR_40 = FALSE;
break;
case 't':
VAR_40 = TRUE;
break;
case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
printf(""Tiffcrop version: %s, last updated: %s\n"",
VAR_43, VAR_44);
printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
exit (VAR_37);
break;
case 'w':
VAR_40 = TRUE;
*VAR_7 = atoi(VAR_26);
break;
case 'z': 
VAR_10->crop_mode |= VAR_45;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "":"");
((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
(VAR_18 = strtok (NULL, "":"")), VAR_20++)
{
VAR_10->regions++;
if (sscanf(VAR_18, ""%lf,%lf,%lf,%lf"",
&VAR_10->corners[VAR_20].X1, &VAR_10->corners[VAR_20].Y1,
&VAR_10->corners[VAR_20].X2, &VAR_10->corners[VAR_20].Y2) != 4)
{
TIFFError (""Unable to parse coordinates for region"", ""%u %s"", VAR_20, VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
{
TIFFError (""Region list exceeds limit of"", ""%d regions %s"", VAR_46, VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);;
}
break;
case 'B': *VAR_2++ = 'b'; *VAR_2 = '\0';
break;
case 'L': *VAR_2++ = 'l'; *VAR_2 = '\0';
break;
case 'M': *VAR_2++ = 'm'; *VAR_2 = '\0';
break;
case 'C': *VAR_2++ = 'c'; *VAR_2 = '\0';
break;
case 'D': for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
(VAR_18 != NULL);
(VAR_18 = strtok (NULL, "","")), VAR_20++)
{
VAR_17 = strpbrk(VAR_18, "":="");
if (VAR_17 == NULL)
{
TIFFError(""Invalid dump option"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
*VAR_17 = '\0';
VAR_23 = strlen (VAR_18);
for (VAR_20 = 0; VAR_20 < VAR_23; VAR_20++)
*(VAR_18 + VAR_20) = tolower((int) *(VAR_18 + VAR_20));
if (strncmp(VAR_18, ""for"", 3) == 0)
{
VAR_23 = strlen (VAR_17 + 1);
for (VAR_20 = 1; VAR_20 <= VAR_23; VAR_20++)
*(VAR_17 + VAR_20) = tolower((int) *(VAR_17 + VAR_20));
if (strncmp (VAR_17 + 1, ""txt"", 3) == 0)
{
VAR_12->format = VAR_47;
strcpy (VAR_12->mode, ""w"");
}
else
{
if (strncmp(VAR_17 + 1, ""raw"", 3) == 0)
{
VAR_12->format = VAR_48;
strcpy (VAR_12->mode, ""wb"");
}
else
{
TIFFError(""parse_command_opts"", ""Unknown dump format %s"", VAR_17 + 1);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
}
else
{ 
if (strncmp (VAR_18, ""lev"", 3) == 0)
VAR_12->level = atoi(VAR_17 + 1);
if (strncmp (VAR_18, ""in"", 2) == 0)
{
strncpy (VAR_12->infilename, VAR_17 + 1, VAR_49 - 20);
VAR_12->infilename[VAR_49 - 20] = '\0';
}
if (strncmp (VAR_18, ""out"", 3) == 0)
{
strncpy (VAR_12->outfilename, VAR_17 + 1, VAR_49 - 20);
VAR_12->outfilename[VAR_49 - 20] = '\0';
}
if (strncmp (VAR_18, ""deb"", 3) == 0)
VAR_12->debug = atoi(VAR_17 + 1);
}
}
if ((strlen(VAR_12->infilename)) || (strlen(VAR_12->outfilename)))
{
if (VAR_12->level == 1)
TIFFError("""",""Defaulting to dump level 1, no data."");
if (VAR_12->format == VAR_50)
{
TIFFError("""", ""You must specify a dump format for dump files"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
break;
case 'm': 
VAR_10->crop_mode |= VAR_51;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "",:"");
((VAR_18 != NULL) &&  (VAR_20 < 4));
(VAR_18 = strtok (NULL, "",:"")), VAR_20++)
{
VAR_10->margins[VAR_20] = atof(VAR_18);
}
break;
case 'E':
switch (tolower((int) VAR_26[0]))
{
case 't': VAR_10->edge_ref = VAR_52;
break;
case 'b': VAR_10->edge_ref = VAR_53;
break;
case 'l': VAR_10->edge_ref = VAR_54;
break;
case 'r': VAR_10->edge_ref = VAR_55;
break;
default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'F': 
VAR_10->crop_mode |= VAR_56;
switch (tolower((int) VAR_26[0]))
{
case  'h': VAR_10->mirror = VAR_57;
break;
case  'v': VAR_10->mirror = VAR_58;
break;
case  'b': VAR_10->mirror = VAR_59;
break;
default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'H': 
VAR_11->hres = atof (VAR_26);
VAR_11->mode |= VAR_60;
break;
case 'I': 
VAR_10->crop_mode |= VAR_61;
if (streq(VAR_26, ""black""))
{
VAR_10->photometric = VAR_62;
continue;
}
if (streq(VAR_26, ""white""))
{
VAR_10->photometric = VAR_63;
continue;
}
if (streq(VAR_26, ""data"")) 
{
VAR_10->photometric = VAR_64;
continue;
}
if (streq(VAR_26, ""both""))
{
VAR_10->photometric = VAR_65;
continue;
}
TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
break;
case 'J': 
VAR_11->hmargin = atof(VAR_26);
VAR_11->mode |= VAR_66;
break;
case 'K': 
VAR_11->vmargin = atof(VAR_26);
VAR_11->mode |= VAR_66;
break;
case 'N':
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
((VAR_18 != NULL) &&  (VAR_20 < VAR_67));
(VAR_18 = strtok (NULL, "","")))
{ 
if (streq(VAR_18, ""odd""))
{
for (VAR_21 = 1; VAR_21 <= VAR_67; VAR_21 += 2)
VAR_13[VAR_20++] = VAR_21;
*VAR_14 = (VAR_67 - 1) / 2;
break;
}
else
{
if (streq(VAR_18, ""even""))
{
for (VAR_21 = 2; VAR_21 <= VAR_67; VAR_21 += 2)
VAR_13[VAR_20++] = VAR_21;
*VAR_14 = VAR_67 / 2;
break;
}
else
{
if (streq(VAR_18, ""last""))
VAR_13[VAR_20++] = VAR_67;
else  
{
VAR_19 = strpbrk(VAR_18, "":-"");
if (!VAR_19)
VAR_13[VAR_20++] = atoi(VAR_18);
else
{
*VAR_19 = '\0';
VAR_22 = atoi (VAR_18);
if (!strcmp((VAR_19 + 1), ""last""))
VAR_23 = VAR_67;
else
VAR_23 = atoi (VAR_19 + 1);
for (VAR_21 = VAR_22; VAR_21 <= VAR_23 && VAR_21 - VAR_22 + VAR_20 < VAR_67; VAR_21++)
VAR_13[VAR_20++] = VAR_21;
}
}
}
}
}
*VAR_14 = VAR_20;
break;
case 'O':  
switch (tolower((int) VAR_26[0]))
{
case  'a': VAR_11->orient = VAR_68;
break;
case  'p': VAR_11->orient = VAR_69;
break;
case  'l': VAR_11->orient = VAR_70;
break;
default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'P':  
if (sscanf(VAR_26, ""%lfx%lf"", &VAR_11->width, &VAR_11->length) == 2)
{
strcpy (VAR_11->name, ""Custom""); 
VAR_11->mode |= VAR_71;
break;
}
if (get_page_geometry (VAR_26, VAR_11))
{
if (!strcmp(VAR_26, ""list""))
{
TIFFError("""", ""Name            Width   Length (in inches)"");
for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
VAR_73[VAR_20].length);
exit (VAR_27);
}
TIFFError (""Invalid paper size"", ""%s"", VAR_26);
TIFFError ("""", ""Select one of:"");
TIFFError("""", ""Name            Width   Length (in inches)"");
for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
VAR_73[VAR_20].length);
exit (VAR_27);
}
else
{
VAR_11->mode |= VAR_71;
}
break;
case 'R': 
VAR_10->crop_mode |= VAR_74;
switch (strtoul(VAR_26, NULL, 0))
{
case  90:  VAR_10->rotation = (uint16_t)90;
break;
case  180: VAR_10->rotation = (uint16_t)180;
break;
case  270: VAR_10->rotation = (uint16_t)270;
break;
default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'S':
VAR_19 = strpbrk(VAR_26, "",:"");
if (VAR_19)
{
*VAR_19 = '\0';
VAR_11->cols = atoi(VAR_26);
VAR_11->rows = atoi(VAR_19 +1);
}
else
{
VAR_11->cols = atoi(VAR_26);
VAR_11->rows = atoi(VAR_26);
}
if ((VAR_11->cols * VAR_11->rows) > VAR_75)
{
TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", VAR_75);
exit (VAR_27);
}
VAR_11->mode |= VAR_76;
break;
case 'U':
if (streq(VAR_26, ""in""))
{
VAR_10->res_unit = VAR_77;
VAR_11->res_unit = VAR_77;
}
else if (streq(VAR_26, ""cm""))
{
VAR_10->res_unit = VAR_78;
VAR_11->res_unit = VAR_78;
}
else if (streq(VAR_26, ""px""))
{
VAR_10->res_unit = VAR_79;
VAR_11->res_unit = VAR_79;
}
else
{
TIFFError (""Illegal unit of measure"",""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'V': 
VAR_11->vres = atof (VAR_26);
VAR_11->mode |= VAR_60;
break;
case 'X':
VAR_10->crop_mode |= VAR_80;
VAR_10->width = atof(VAR_26);
break;
case 'Y':
VAR_10->crop_mode |= VAR_81;
VAR_10->length = atof(VAR_26);
break;
case 'Z': 
VAR_10->crop_mode |= VAR_82;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
(VAR_18 = strtok (NULL, "","")), VAR_20++)
{
VAR_10->zones++;
VAR_17 = strchr(VAR_18, ':');
if (!VAR_17) {
TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
exit(VAR_27);
}
*VAR_17 = '\0';
VAR_10->zonelist[VAR_20].position = atoi(VAR_18);
VAR_10->zonelist[VAR_20].total    = atoi(VAR_17 + 1);
}
if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
{
TIFFError(""Zone list exceeds region limit"", ""%d"",  VAR_46);
exit (VAR_27);
}
break;
case '?':TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
char VAR_83, VAR_84, VAR_85;
VAR_83 = ((VAR_10->crop_mode & VAR_80) || (VAR_10->crop_mode & VAR_81));
VAR_84 = (VAR_10->crop_mode & VAR_82);
VAR_85 = (VAR_10->crop_mode & VAR_45);
if ((VAR_83 && VAR_84) || (VAR_83 && VAR_85) || (VAR_84 && VAR_85)) {
TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit"");
exit(VAR_27);
}
}",libtiff/8fe3735942ea1d90d8cef843b55b3efe8ab6feaf/tiffcrop.c/vul/before/0.json,"void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,
                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,
                            uint32_t *deftilelength, uint32_t *defrowsperstrip,
                            struct crop_mask *crop_data, struct pagedef *page,
                            struct dump_opts *dump,
                            unsigned int     *imagelist, unsigned int   *image_count )
    {
    int   c, good_args = 0;
    char *opt_offset   = NULL;    /* Position in string of value sought */
    char *opt_ptr      = NULL;    /* Pointer to next token in option set */
    char *sep          = NULL;    /* Pointer to a token separator */
    unsigned int  i, j, start, end;
#if !HAVE_DECL_OPTARG
    extern int   optind;
    extern char* optarg;
#endif

    *mp++ = 'w';
    *mp = '\0';
    while ((c = getopt(argc, argv,
       ""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
      {
    good_args++;
    switch (c) {
      case 'a': mode[0] = 'a';	/* append to output */
		break;
      case 'c':	if (!processCompressOptions(optarg)) /* compression scheme */
		  {
		  TIFFError (""Unknown compression option"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'd':	start = strtoul(optarg, NULL, 0); /* initial IFD offset */
	        if (start == 0)
                  {
		  TIFFError ("""",""Directory offset must be greater than zero"");
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
		  }
	        *dirnum = start - 1;
		break;
      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/
                  {
		  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;
 		            crop_data->img_mode = COMPOSITE_IMAGES;
		            break; /* Composite */
		  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Divided */
		  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;
 		            crop_data->img_mode = COMPOSITE_IMAGES;
		            break; /* Image */
		  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Multiple */
		  case 's': crop_data->exp_mode = FILE_PER_SELECTION;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Sections */
		  default:  TIFFError (""Unknown export mode"",""%s"", optarg);
                            TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
                  }
	        break;
      case 'f':	if (streq(optarg, ""lsb2msb""))	   /* fill order */
		  *deffillorder = FILLORDER_LSB2MSB;
		else if (streq(optarg, ""msb2lsb""))
		  *deffillorder = FILLORDER_MSB2LSB;
		else
		  {
		  TIFFError (""Unknown fill order"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'h':	usage(EXIT_SUCCESS);
		break;
      case 'i':	ignore = TRUE;		/* ignore errors */
		break;
      case 'k':	maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;
		break;
      case 'l':	outtiled = TRUE;	 /* tile length */
		*deftilelength = atoi(optarg);
		break;
      case 'p': /* planar configuration */
		if (streq(optarg, ""separate""))
		  *defconfig = PLANARCONFIG_SEPARATE;
		else if (streq(optarg, ""contig""))
		  *defconfig = PLANARCONFIG_CONTIG;
		else
		  {
		  TIFFError (""Unknown planar configuration"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'r':	/* rows/strip */
		*defrowsperstrip = atol(optarg);
		break;
      case 's':	/* generate stripped output */
		outtiled = FALSE;
		break;
      case 't':	/* generate tiled output */
		outtiled = TRUE;
		break;
      case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
                printf(""Tiffcrop version: %s, last updated: %s\n"",
			   tiffcrop_version_id, tiffcrop_rev_date);
	        printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
		printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
                printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
	        exit (EXIT_SUCCESS);
		break;
      case 'w':	/* tile width */
		outtiled = TRUE;
		*deftilewidth = atoi(optarg);
		break;
      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */
	        crop_data->crop_mode |= CROP_REGIONS;
		for (i = 0, opt_ptr = strtok (optarg, "":"");
                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));
                    (opt_ptr = strtok (NULL, "":"")), i++)
                    {
		    crop_data->regions++;
                    if (sscanf(opt_ptr, ""%lf,%lf,%lf,%lf"",
			       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,
			       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)
                      {
                      TIFFError (""Unable to parse coordinates for region"", ""%u %s"", i, optarg);
		      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (EXIT_FAILURE);
		      }
                    }
                /*  check for remaining elements over MAX_REGIONS */
                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
                  {
		  TIFFError (""Region list exceeds limit of"", ""%d regions %s"", MAX_REGIONS, optarg);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);;
                  }
		break;
      /* options for file open modes */
      case 'B': *mp++ = 'b'; *mp = '\0';
		break;
      case 'L': *mp++ = 'l'; *mp = '\0';
		break;
      case 'M': *mp++ = 'm'; *mp = '\0';
		break;
      case 'C': *mp++ = 'c'; *mp = '\0';
		break;
      /* options for Debugging / data dump */
      case 'D': for (i = 0, opt_ptr = strtok (optarg, "","");
                    (opt_ptr != NULL);
                    (opt_ptr = strtok (NULL, "","")), i++)
                    {
		    opt_offset = strpbrk(opt_ptr, "":="");
                    if (opt_offset == NULL)
                      {
                      TIFFError(""Invalid dump option"", ""%s"", optarg);
                      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (EXIT_FAILURE);
		      }
                      
                    *opt_offset = '\0';
                    /* convert option to lowercase */
                    end = strlen (opt_ptr);
                    for (i = 0; i < end; i++)
                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));
                    /* Look for dump format specification */
                    if (strncmp(opt_ptr, ""for"", 3) == 0)
                      {
		      /* convert value to lowercase */
                      end = strlen (opt_offset + 1);
                      for (i = 1; i <= end; i++)
                        *(opt_offset + i) = tolower((int) *(opt_offset + i));
                      /* check dump format value */
		      if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
                        {
                        dump->format = DUMP_TEXT;
                        strcpy (dump->mode, ""w"");
                        }
                      else
                        {
		        if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
                          {
                          dump->format = DUMP_RAW;
                          strcpy (dump->mode, ""wb"");
                          }
                        else
                          {
                          TIFFError(""parse_command_opts"", ""Unknown dump format %s"", opt_offset + 1);
                          TIFFError (""For valid options type"", ""tiffcrop -h"");
                          exit (EXIT_FAILURE);
		          }
			}
                      }
		    else
                      { /* Look for dump level specification */
                      if (strncmp (opt_ptr, ""lev"", 3) == 0)
                        dump->level = atoi(opt_offset + 1);
                        /* Look for input data dump file name */
                      if (strncmp (opt_ptr, ""in"", 2) == 0)
		        {
                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);
                        dump->infilename[PATH_MAX - 20] = '\0';
                        }
                        /* Look for output data dump file name */
                      if (strncmp (opt_ptr, ""out"", 3) == 0)
			{
                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);
                        dump->outfilename[PATH_MAX - 20] = '\0';
                        }
                      if (strncmp (opt_ptr, ""deb"", 3) == 0)
			dump->debug = atoi(opt_offset + 1);
		      }
                    }
	        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))
                  {
		  if (dump->level == 1)
                    TIFFError("""",""Defaulting to dump level 1, no data."");
	          if (dump->format == DUMP_NONE)
                    {
		    TIFFError("""", ""You must specify a dump format for dump files"");
		    TIFFError (""For valid options type"", ""tiffcrop -h"");
		    exit (EXIT_FAILURE);
		    }
                  }
	        break;

      /* image manipulation routine options */
      case 'm': /* margins to exclude from selection, uppercase M was already used */
		/* order of values must be TOP, LEFT, BOTTOM, RIGHT */
		crop_data->crop_mode |= CROP_MARGINS;
                for (i = 0, opt_ptr = strtok (optarg, "",:"");
                    ((opt_ptr != NULL) &&  (i < 4));
                     (opt_ptr = strtok (NULL, "",:"")), i++)
                    {
		    crop_data->margins[i] = atof(opt_ptr);
                    }
		break;
      case 'E':	/* edge reference */
		switch (tolower((int) optarg[0]))
                  {
		  case 't': crop_data->edge_ref = EDGE_TOP;
                            break;
                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;
                             break;
                  case 'l': crop_data->edge_ref = EDGE_LEFT;
                            break;
                  case 'r': crop_data->edge_ref = EDGE_RIGHT;
                            break;
		  default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", optarg);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
		  }
		break;
      case 'F': /* flip eg mirror image or cropped segment, M was already used */
		crop_data->crop_mode |= CROP_MIRROR;
		switch (tolower((int) optarg[0]))
                  {
		  case  'h': crop_data->mirror = MIRROR_HORIZ;
                             break;
                  case  'v': crop_data->mirror = MIRROR_VERT;
                             break;
                  case  'b': crop_data->mirror = MIRROR_BOTH;
                             break;
		  default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", optarg);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (EXIT_FAILURE);
		  }
		break;
      case 'H': /* set horizontal resolution to new value */
		page->hres = atof (optarg);
                page->mode |= PAGE_MODE_RESOLUTION;
		break;
      case 'I': /* invert the color space, eg black to white */
		crop_data->crop_mode |= CROP_INVERT;
                /* The PHOTOMETIC_INTERPRETATION tag may be updated */
                if (streq(optarg, ""black""))
                  {
		  crop_data->photometric = PHOTOMETRIC_MINISBLACK;
		  continue;
                  }
                if (streq(optarg, ""white""))
                  {
		  crop_data->photometric = PHOTOMETRIC_MINISWHITE;
                  continue;
                  }
                if (streq(optarg, ""data"")) 
                  {
		  crop_data->photometric = INVERT_DATA_ONLY;
                  continue;
                  }
                if (streq(optarg, ""both""))
                  {
		  crop_data->photometric = INVERT_DATA_AND_TAG;
                  continue;
                  }

		TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", optarg);
		TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (EXIT_FAILURE);
		break;
      case 'J': /* horizontal margin for sectioned output pages */
		page->hmargin = atof(optarg);
                page->mode |= PAGE_MODE_MARGINS;
		break;
      case 'K': /* vertical margin for sectioned output pages*/
                page->vmargin = atof(optarg);
                page->mode |= PAGE_MODE_MARGINS;
		break;
      case 'N':	/* list of images to process */
                for (i = 0, opt_ptr = strtok (optarg, "","");
                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));
                     (opt_ptr = strtok (NULL, "","")))
                     { /* We do not know how many images are in file yet 
			* so we build a list to include the maximum allowed
                        * and follow it until we hit the end of the file.
                        * Image count is not accurate for odd, even, last
                        * so page numbers won't be valid either.
                        */
		     if (streq(opt_ptr, ""odd""))
                       {
		       for (j = 1; j <= MAX_IMAGES; j += 2)
			 imagelist[i++] = j;
                       *image_count = (MAX_IMAGES - 1) / 2;
                       break;
		       }
		     else
                       {
		       if (streq(opt_ptr, ""even""))
                         {
			 for (j = 2; j <= MAX_IMAGES; j += 2)
			   imagelist[i++] = j;
                         *image_count = MAX_IMAGES / 2;
                         break;
			 }
		       else
                         {
			 if (streq(opt_ptr, ""last""))
			   imagelist[i++] = MAX_IMAGES;
			 else  /* single value between commas */
			   {
			   sep = strpbrk(opt_ptr, "":-"");
			   if (!sep)
			     imagelist[i++] = atoi(opt_ptr);
                           else
                             {
			     *sep = '\0';
                             start = atoi (opt_ptr);
                             if (!strcmp((sep + 1), ""last""))
			       end = MAX_IMAGES;
                             else
                               end = atoi (sep + 1);
                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)
			       imagelist[i++] = j;
			     }
			   }
			 }
		      }
		    }
                *image_count = i;
		break;
      case 'O': /* page orientation */ 
		switch (tolower((int) optarg[0]))
                  {
		  case  'a': page->orient = ORIENTATION_AUTO;
                             break;
		  case  'p': page->orient = ORIENTATION_PORTRAIT;
                             break;
		  case  'l': page->orient = ORIENTATION_LANDSCAPE;
                             break;
		  default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", optarg);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
		  }
		break;
      case 'P': /* page size selection */ 
	        if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
                  {
                  strcpy (page->name, ""Custom""); 
                  page->mode |= PAGE_MODE_PAPERSIZE;
                  break;
                  }
                if (get_page_geometry (optarg, page))
                  {
		  if (!strcmp(optarg, ""list""))
                    {
		    TIFFError("""", ""Name            Width   Length (in inches)"");
                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)
                      TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       PaperTable[i].name, PaperTable[i].width, 
                               PaperTable[i].length);
		    exit (EXIT_FAILURE);
                    }
     
		  TIFFError (""Invalid paper size"", ""%s"", optarg);
                  TIFFError ("""", ""Select one of:"");
		  TIFFError("""", ""Name            Width   Length (in inches)"");
                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)
                    TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       PaperTable[i].name, PaperTable[i].width, 
                               PaperTable[i].length);
		  exit (EXIT_FAILURE);
		  }
		else
                  {
                  page->mode |= PAGE_MODE_PAPERSIZE;
		  }
		break;
      case 'R': /* rotate image or cropped segment */
		crop_data->crop_mode |= CROP_ROTATE;
		switch (strtoul(optarg, NULL, 0))
                  {
		  case  90:  crop_data->rotation = (uint16_t)90;
                             break;
                  case  180: crop_data->rotation = (uint16_t)180;
                             break;
                  case  270: crop_data->rotation = (uint16_t)270;
                             break;
		  default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", optarg);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (EXIT_FAILURE);
		  }
		break;
      case 'S':	/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */
		sep = strpbrk(optarg, "",:"");
		if (sep)
                  {
                  *sep = '\0';
                  page->cols = atoi(optarg);
                  page->rows = atoi(sep +1);
		  }
                else
                  {
                  page->cols = atoi(optarg);
                  page->rows = atoi(optarg);
		  }
                if ((page->cols * page->rows) > MAX_SECTIONS)
                  {
		  TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", MAX_SECTIONS);
		  exit (EXIT_FAILURE);
                  }
                page->mode |= PAGE_MODE_ROWSCOLS;
		break;
      case 'U':	/* units for measurements and offsets */
		if (streq(optarg, ""in""))
                  {
		  crop_data->res_unit = RESUNIT_INCH;
		  page->res_unit = RESUNIT_INCH;
		  }
		else if (streq(optarg, ""cm""))
		  {
		  crop_data->res_unit = RESUNIT_CENTIMETER;
		  page->res_unit = RESUNIT_CENTIMETER;
		  }
		else if (streq(optarg, ""px""))
		  {
		  crop_data->res_unit = RESUNIT_NONE;
		  page->res_unit = RESUNIT_NONE;
		  }
		else
                  {
		  TIFFError (""Illegal unit of measure"",""%s"", optarg);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
		  }
		break;
      case 'V': /* set vertical resolution to new value */
		page->vres = atof (optarg);
                page->mode |= PAGE_MODE_RESOLUTION;
		break;
      case 'X':	/* selection width */
		crop_data->crop_mode |= CROP_WIDTH;
		crop_data->width = atof(optarg);
		break;
      case 'Y':	/* selection length */
		crop_data->crop_mode |= CROP_LENGTH;
		crop_data->length = atof(optarg);
		break;
      case 'Z': /* zones of an image X:Y read as zone X of Y */
		crop_data->crop_mode |= CROP_ZONES;
		for (i = 0, opt_ptr = strtok (optarg, "","");
                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));
                    (opt_ptr = strtok (NULL, "","")), i++)
                    {
		    crop_data->zones++;
		    opt_offset = strchr(opt_ptr, ':');
		    if (!opt_offset) {
			TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
			exit(EXIT_FAILURE);
		    }
                    *opt_offset = '\0';
                    crop_data->zonelist[i].position = atoi(opt_ptr);
                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);
                    }
                /*  check for remaining elements over MAX_REGIONS */
                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
                  {
		  TIFFError(""Zone list exceeds region limit"", ""%d"",  MAX_REGIONS);
		  exit (EXIT_FAILURE);
                  }
		break;
    case '?':	TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (EXIT_FAILURE);
		/*NOTREACHED*/
      }
    }
    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/
    char XY, Z, R, S;
    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));
    Z = (crop_data->crop_mode & CROP_ZONES);
    R = (crop_data->crop_mode & CROP_REGIONS);
    S = (page->mode & PAGE_MODE_ROWSCOLS);
    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {
        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
        exit(EXIT_FAILURE);
    }
  }","void  process_command_opts (int VAR_0, char *VAR_1[], char *VAR_2, char *VAR_3, uint32_t *VAR_4,
                            uint16_t *VAR_5, uint16_t *VAR_6, uint32_t *VAR_7,
                            uint32_t *VAR_8, uint32_t *VAR_9,
                            struct crop_mask *VAR_10, struct pagedef *VAR_11,
                            struct dump_opts *VAR_12,
                            unsigned int     *VAR_13, unsigned int   *VAR_14 )
    {
    int   VAR_15, VAR_16 = 0;
    char *VAR_17   = NULL;    /* COMMENT_0 */
    char *VAR_18      = NULL;    /* COMMENT_1 */
    char *VAR_19          = NULL;    /* COMMENT_2 */
    unsigned int  VAR_20, VAR_21, VAR_22, VAR_23;
#if !VAR_24
    extern int   VAR_25;
    extern char* VAR_26;
#endif

    *VAR_2++ = 'w';
    *VAR_2 = '\0';
    while ((VAR_15 = getopt(VAR_0, VAR_1,
       ""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
      {
    VAR_16++;
    switch (VAR_15) {
      case 'a': VAR_3[0] = 'a';	/* COMMENT_3 */
		break;
      case 'c':	if (!processCompressOptions(VAR_26)) /* COMMENT_4 */
		  {
		  TIFFError (""Unknown compression option"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'd':	VAR_22 = strtoul(VAR_26, NULL, 0); /* COMMENT_5 */
	        if (VAR_22 == 0)
                  {
		  TIFFError ("""",""Directory offset must be greater than zero"");
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
		  }
	        *VAR_4 = VAR_22 - 1;
		break;
      case 'e': switch (tolower((int) VAR_26[0])) /* COMMENT_6 */
                  {
		  case 'c': VAR_10->exp_mode = VAR_28;
 		            VAR_10->img_mode = VAR_29;
		            break; /* COMMENT_7 */
		  case 'd': VAR_10->exp_mode = VAR_30;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_8 */
		  case 'i': VAR_10->exp_mode = VAR_32;
 		            VAR_10->img_mode = VAR_29;
		            break; /* COMMENT_9 */
		  case 'm': VAR_10->exp_mode = VAR_33;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_10 */
		  case 's': VAR_10->exp_mode = VAR_34;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_11 */
		  default:  TIFFError (""Unknown export mode"",""%s"", VAR_26);
                            TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
                  }
	        break;
      case 'f':	if (streq(VAR_26, ""lsb2msb""))	   /* COMMENT_12 */
		  *VAR_6 = VAR_35;
		else if (streq(VAR_26, ""msb2lsb""))
		  *VAR_6 = VAR_36;
		else
		  {
		  TIFFError (""Unknown fill order"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'h':	usage(VAR_37);
		break;
      case 'i':	VAR_38 = TRUE;		/* COMMENT_13 */
		break;
      case 'k':	VAR_39 = (tmsize_t)strtoul(VAR_26, NULL, 0) << 20;
		break;
      case 'l':	VAR_40 = TRUE;	 /* COMMENT_14 */
		*VAR_8 = atoi(VAR_26);
		break;
      case 'p': /* COMMENT_15 */
		if (streq(VAR_26, ""separate""))
		  *VAR_5 = VAR_41;
		else if (streq(VAR_26, ""contig""))
		  *VAR_5 = VAR_42;
		else
		  {
		  TIFFError (""Unknown planar configuration"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'r':	/* COMMENT_16 */
		*VAR_9 = atol(VAR_26);
		break;
      case 's':	/* COMMENT_17 */
		VAR_40 = FALSE;
		break;
      case 't':	/* COMMENT_18 */
		VAR_40 = TRUE;
		break;
      case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
                printf(""Tiffcrop version: %s, last updated: %s\n"",
			   VAR_43, VAR_44);
	        printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
		printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
                printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
	        exit (VAR_37);
		break;
      case 'w':	/* COMMENT_19 */
		VAR_40 = TRUE;
		*VAR_7 = atoi(VAR_26);
		break;
      case 'z': /* COMMENT_20 */
	        VAR_10->crop_mode |= VAR_45;
		for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "":"");
                   ((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
                    (VAR_18 = strtok (NULL, "":"")), VAR_20++)
                    {
		    VAR_10->regions++;
                    if (sscanf(VAR_18, ""%lf,%lf,%lf,%lf"",
			       &VAR_10->corners[VAR_20].X1, &VAR_10->corners[VAR_20].Y1,
			       &VAR_10->corners[VAR_20].X2, &VAR_10->corners[VAR_20].Y2) != 4)
                      {
                      TIFFError (""Unable to parse coordinates for region"", ""%u %s"", VAR_20, VAR_26);
		      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (VAR_27);
		      }
                    }
                /* COMMENT_21 */
                if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
                  {
		  TIFFError (""Region list exceeds limit of"", ""%d regions %s"", VAR_46, VAR_26);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);;
                  }
		break;
      /* COMMENT_22 */
      case 'B': *VAR_2++ = 'b'; *VAR_2 = '\0';
		break;
      case 'L': *VAR_2++ = 'l'; *VAR_2 = '\0';
		break;
      case 'M': *VAR_2++ = 'm'; *VAR_2 = '\0';
		break;
      case 'C': *VAR_2++ = 'c'; *VAR_2 = '\0';
		break;
      /* COMMENT_23 */
      case 'D': for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                    (VAR_18 != NULL);
                    (VAR_18 = strtok (NULL, "","")), VAR_20++)
                    {
		    VAR_17 = strpbrk(VAR_18, "":="");
                    if (VAR_17 == NULL)
                      {
                      TIFFError(""Invalid dump option"", ""%s"", VAR_26);
                      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (VAR_27);
		      }
                      
                    *VAR_17 = '\0';
                    /* COMMENT_24 */
                    VAR_23 = strlen (VAR_18);
                    for (VAR_20 = 0; VAR_20 < VAR_23; VAR_20++)
                      *(VAR_18 + VAR_20) = tolower((int) *(VAR_18 + VAR_20));
                    /* COMMENT_25 */
                    if (strncmp(VAR_18, ""for"", 3) == 0)
                      {
		      /* COMMENT_26 */
                      VAR_23 = strlen (VAR_17 + 1);
                      for (VAR_20 = 1; VAR_20 <= VAR_23; VAR_20++)
                        *(VAR_17 + VAR_20) = tolower((int) *(VAR_17 + VAR_20));
                      /* COMMENT_27 */
		      if (strncmp (VAR_17 + 1, ""txt"", 3) == 0)
                        {
                        VAR_12->format = VAR_47;
                        strcpy (VAR_12->mode, ""w"");
                        }
                      else
                        {
		        if (strncmp(VAR_17 + 1, ""raw"", 3) == 0)
                          {
                          VAR_12->format = VAR_48;
                          strcpy (VAR_12->mode, ""wb"");
                          }
                        else
                          {
                          TIFFError(""parse_command_opts"", ""Unknown dump format %s"", VAR_17 + 1);
                          TIFFError (""For valid options type"", ""tiffcrop -h"");
                          exit (VAR_27);
		          }
			}
                      }
		    else
                      { /* COMMENT_28 */
                      if (strncmp (VAR_18, ""lev"", 3) == 0)
                        VAR_12->level = atoi(VAR_17 + 1);
                        /* COMMENT_29 */
                      if (strncmp (VAR_18, ""in"", 2) == 0)
		        {
                        strncpy (VAR_12->infilename, VAR_17 + 1, VAR_49 - 20);
                        VAR_12->infilename[VAR_49 - 20] = '\0';
                        }
                        /* COMMENT_30 */
                      if (strncmp (VAR_18, ""out"", 3) == 0)
			{
                        strncpy (VAR_12->outfilename, VAR_17 + 1, VAR_49 - 20);
                        VAR_12->outfilename[VAR_49 - 20] = '\0';
                        }
                      if (strncmp (VAR_18, ""deb"", 3) == 0)
			VAR_12->debug = atoi(VAR_17 + 1);
		      }
                    }
	        if ((strlen(VAR_12->infilename)) || (strlen(VAR_12->outfilename)))
                  {
		  if (VAR_12->level == 1)
                    TIFFError("""",""Defaulting to dump level 1, no data."");
	          if (VAR_12->format == VAR_50)
                    {
		    TIFFError("""", ""You must specify a dump format for dump files"");
		    TIFFError (""For valid options type"", ""tiffcrop -h"");
		    exit (VAR_27);
		    }
                  }
	        break;

      /* COMMENT_31 */
      case 'm': /* COMMENT_32 */
		/* COMMENT_33 */
		VAR_10->crop_mode |= VAR_51;
                for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "",:"");
                    ((VAR_18 != NULL) &&  (VAR_20 < 4));
                     (VAR_18 = strtok (NULL, "",:"")), VAR_20++)
                    {
		    VAR_10->margins[VAR_20] = atof(VAR_18);
                    }
		break;
      case 'E':	/* COMMENT_34 */
		switch (tolower((int) VAR_26[0]))
                  {
		  case 't': VAR_10->edge_ref = VAR_52;
                            break;
                  case 'b': VAR_10->edge_ref = VAR_53;
                             break;
                  case 'l': VAR_10->edge_ref = VAR_54;
                            break;
                  case 'r': VAR_10->edge_ref = VAR_55;
                            break;
		  default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", VAR_26);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
		  }
		break;
      case 'F': /* COMMENT_35 */
		VAR_10->crop_mode |= VAR_56;
		switch (tolower((int) VAR_26[0]))
                  {
		  case  'h': VAR_10->mirror = VAR_57;
                             break;
                  case  'v': VAR_10->mirror = VAR_58;
                             break;
                  case  'b': VAR_10->mirror = VAR_59;
                             break;
		  default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", VAR_26);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (VAR_27);
		  }
		break;
      case 'H': /* COMMENT_36 */
		VAR_11->hres = atof (VAR_26);
                VAR_11->mode |= VAR_60;
		break;
      case 'I': /* COMMENT_37 */
		VAR_10->crop_mode |= VAR_61;
                /* COMMENT_38 */
                if (streq(VAR_26, ""black""))
                  {
		  VAR_10->photometric = VAR_62;
		  continue;
                  }
                if (streq(VAR_26, ""white""))
                  {
		  VAR_10->photometric = VAR_63;
                  continue;
                  }
                if (streq(VAR_26, ""data"")) 
                  {
		  VAR_10->photometric = VAR_64;
                  continue;
                  }
                if (streq(VAR_26, ""both""))
                  {
		  VAR_10->photometric = VAR_65;
                  continue;
                  }

		TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", VAR_26);
		TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (VAR_27);
		break;
      case 'J': /* COMMENT_39 */
		VAR_11->hmargin = atof(VAR_26);
                VAR_11->mode |= VAR_66;
		break;
      case 'K': /* COMMENT_40 */
                VAR_11->vmargin = atof(VAR_26);
                VAR_11->mode |= VAR_66;
		break;
      case 'N':	/* COMMENT_41 */
                for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                    ((VAR_18 != NULL) &&  (VAR_20 < VAR_67));
                     (VAR_18 = strtok (NULL, "","")))
                     { /* COMMENT_42 */
                                                      
                                                                         
                                                                         
                                                                
                          
		     if (streq(VAR_18, ""odd""))
                       {
		       for (VAR_21 = 1; VAR_21 <= VAR_67; VAR_21 += 2)
			 VAR_13[VAR_20++] = VAR_21;
                       *VAR_14 = (VAR_67 - 1) / 2;
                       break;
		       }
		     else
                       {
		       if (streq(VAR_18, ""even""))
                         {
			 for (VAR_21 = 2; VAR_21 <= VAR_67; VAR_21 += 2)
			   VAR_13[VAR_20++] = VAR_21;
                         *VAR_14 = VAR_67 / 2;
                         break;
			 }
		       else
                         {
			 if (streq(VAR_18, ""last""))
			   VAR_13[VAR_20++] = VAR_67;
			 else  /* COMMENT_48 */
			   {
			   VAR_19 = strpbrk(VAR_18, "":-"");
			   if (!VAR_19)
			     VAR_13[VAR_20++] = atoi(VAR_18);
                           else
                             {
			     *VAR_19 = '\0';
                             VAR_22 = atoi (VAR_18);
                             if (!strcmp((VAR_19 + 1), ""last""))
			       VAR_23 = VAR_67;
                             else
                               VAR_23 = atoi (VAR_19 + 1);
                             for (VAR_21 = VAR_22; VAR_21 <= VAR_23 && VAR_21 - VAR_22 + VAR_20 < VAR_67; VAR_21++)
			       VAR_13[VAR_20++] = VAR_21;
			     }
			   }
			 }
		      }
		    }
                *VAR_14 = VAR_20;
		break;
      case 'O': /* COMMENT_49 */ 
		switch (tolower((int) VAR_26[0]))
                  {
		  case  'a': VAR_11->orient = VAR_68;
                             break;
		  case  'p': VAR_11->orient = VAR_69;
                             break;
		  case  'l': VAR_11->orient = VAR_70;
                             break;
		  default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", VAR_26);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
		  }
		break;
      case 'P': /* COMMENT_50 */ 
	        if (sscanf(VAR_26, ""%lfx%lf"", &VAR_11->width, &VAR_11->length) == 2)
                  {
                  strcpy (VAR_11->name, ""Custom""); 
                  VAR_11->mode |= VAR_71;
                  break;
                  }
                if (get_page_geometry (VAR_26, VAR_11))
                  {
		  if (!strcmp(VAR_26, ""list""))
                    {
		    TIFFError("""", ""Name            Width   Length (in inches)"");
                    for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
                      TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
                               VAR_73[VAR_20].length);
		    exit (VAR_27);
                    }
     
		  TIFFError (""Invalid paper size"", ""%s"", VAR_26);
                  TIFFError ("""", ""Select one of:"");
		  TIFFError("""", ""Name            Width   Length (in inches)"");
                  for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
                    TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
                               VAR_73[VAR_20].length);
		  exit (VAR_27);
		  }
		else
                  {
                  VAR_11->mode |= VAR_71;
		  }
		break;
      case 'R': /* COMMENT_51 */
		VAR_10->crop_mode |= VAR_74;
		switch (strtoul(VAR_26, NULL, 0))
                  {
		  case  90:  VAR_10->rotation = (uint16_t)90;
                             break;
                  case  180: VAR_10->rotation = (uint16_t)180;
                             break;
                  case  270: VAR_10->rotation = (uint16_t)270;
                             break;
		  default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", VAR_26);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (VAR_27);
		  }
		break;
      case 'S':	/* COMMENT_52 */
		VAR_19 = strpbrk(VAR_26, "",:"");
		if (VAR_19)
                  {
                  *VAR_19 = '\0';
                  VAR_11->cols = atoi(VAR_26);
                  VAR_11->rows = atoi(VAR_19 +1);
		  }
                else
                  {
                  VAR_11->cols = atoi(VAR_26);
                  VAR_11->rows = atoi(VAR_26);
		  }
                if ((VAR_11->cols * VAR_11->rows) > VAR_75)
                  {
		  TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", VAR_75);
		  exit (VAR_27);
                  }
                VAR_11->mode |= VAR_76;
		break;
      case 'U':	/* COMMENT_53 */
		if (streq(VAR_26, ""in""))
                  {
		  VAR_10->res_unit = VAR_77;
		  VAR_11->res_unit = VAR_77;
		  }
		else if (streq(VAR_26, ""cm""))
		  {
		  VAR_10->res_unit = VAR_78;
		  VAR_11->res_unit = VAR_78;
		  }
		else if (streq(VAR_26, ""px""))
		  {
		  VAR_10->res_unit = VAR_79;
		  VAR_11->res_unit = VAR_79;
		  }
		else
                  {
		  TIFFError (""Illegal unit of measure"",""%s"", VAR_26);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
		  }
		break;
      case 'V': /* COMMENT_54 */
		VAR_11->vres = atof (VAR_26);
                VAR_11->mode |= VAR_60;
		break;
      case 'X':	/* COMMENT_55 */
		VAR_10->crop_mode |= VAR_80;
		VAR_10->width = atof(VAR_26);
		break;
      case 'Y':	/* COMMENT_56 */
		VAR_10->crop_mode |= VAR_81;
		VAR_10->length = atof(VAR_26);
		break;
      case 'Z': /* COMMENT_57 */
		VAR_10->crop_mode |= VAR_82;
		for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                   ((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
                    (VAR_18 = strtok (NULL, "","")), VAR_20++)
                    {
		    VAR_10->zones++;
		    VAR_17 = strchr(VAR_18, ':');
		    if (!VAR_17) {
			TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
			exit(VAR_27);
		    }
                    *VAR_17 = '\0';
                    VAR_10->zonelist[VAR_20].position = atoi(VAR_18);
                    VAR_10->zonelist[VAR_20].total    = atoi(VAR_17 + 1);
                    }
                /* COMMENT_21 */
                if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
                  {
		  TIFFError(""Zone list exceeds region limit"", ""%d"",  VAR_46);
		  exit (VAR_27);
                  }
		break;
    case '?':	TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (VAR_27);
		/* COMMENT_58 */
      }
    }
    /* COMMENT_59 */
    char VAR_83, VAR_84, VAR_85, VAR_86;
    VAR_83 = ((VAR_10->crop_mode & VAR_80) || (VAR_10->crop_mode & VAR_81));
    VAR_84 = (VAR_10->crop_mode & VAR_82);
    VAR_85 = (VAR_10->crop_mode & VAR_45);
    VAR_86 = (VAR_11->mode & VAR_76);
    if ((VAR_83 && VAR_84) || (VAR_83 && VAR_85) || (VAR_83 && VAR_86) || (VAR_84 && VAR_85) || (VAR_84 && VAR_86) || (VAR_85 && VAR_86)) {
        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
        exit(VAR_27);
    }
  }",libtiff/8fe3735942ea1d90d8cef843b55b3efe8ab6feaf/tiffcrop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -506,13 +506,14 @@
 		/*NOTREACHED*/
       }
     }
-    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/
-    char XY, Z, R;
+    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/
+    char XY, Z, R, S;
     XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));
     Z = (crop_data->crop_mode & CROP_ZONES);
     R = (crop_data->crop_mode & CROP_REGIONS);
-    if ((XY && Z) || (XY && R) || (Z && R)) {
-        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit"");
+    S = (page->mode & PAGE_MODE_ROWSCOLS);
+    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {
+        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
         exit(EXIT_FAILURE);
     }
   }","{'deleted_lines': ['    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/', '    char XY, Z, R;', '    if ((XY && Z) || (XY && R) || (Z && R)) {', '        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit"");'], 'added_lines': ['    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/', '    char XY, Z, R, S;', '    S = (page->mode & PAGE_MODE_ROWSCOLS);', '    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {', '        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",5.5,MEDIUM,1,valid,,5
CVE-2022-2953,"['CWE-415', 'CWE-131', 'CWE-763', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop -S option: Make decision simpler.
",bad48e90b410df32172006c7876da449ba62cdba,https://gitlab.com/libtiff/libtiff/-/commit/bad48e90b410df32172006c7876da449ba62cdba,tools/tiffcrop.c,process_command_opts,"void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,
uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,
uint32_t *deftilelength, uint32_t *defrowsperstrip,
struct crop_mask *crop_data, struct pagedef *page,
struct dump_opts *dump,
unsigned int     *imagelist, unsigned int   *image_count )
{
int   c, good_args = 0;
char *opt_offset   = NULL;    
char *opt_ptr      = NULL;    
char *sep          = NULL;    
unsigned int  i, j, start, end;
#if !HAVE_DECL_OPTARG
extern int   optind;
extern char* optarg;
#endif
*mp++ = 'w';
*mp = '\0';
while ((c = getopt(argc, argv,
""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
{
good_args++;
switch (c) {
case 'a': mode[0] = 'a';
break;
case 'c':if (!processCompressOptions(optarg)) 
{
TIFFError (""Unknown compression option"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'd':start = strtoul(optarg, NULL, 0); 
if (start == 0)
{
TIFFError ("""",""Directory offset must be greater than zero"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
*dirnum = start - 1;
break;
case 'e': switch (tolower((int) optarg[0])) 
{
case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;
crop_data->img_mode = COMPOSITE_IMAGES;
break; 
case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;
crop_data->img_mode = COMPOSITE_IMAGES;
break; 
case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
case 's': crop_data->exp_mode = FILE_PER_SELECTION;
crop_data->img_mode = SEPARATED_IMAGES;
break; 
default:  TIFFError (""Unknown export mode"",""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'f':if (streq(optarg, ""lsb2msb""))   
*deffillorder = FILLORDER_LSB2MSB;
else if (streq(optarg, ""msb2lsb""))
*deffillorder = FILLORDER_MSB2LSB;
else
{
TIFFError (""Unknown fill order"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'h':usage(EXIT_SUCCESS);
break;
case 'i':ignore = TRUE;
break;
case 'k':maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;
break;
case 'l':outtiled = TRUE; 
*deftilelength = atoi(optarg);
break;
case 'p': 
if (streq(optarg, ""separate""))
*defconfig = PLANARCONFIG_SEPARATE;
else if (streq(optarg, ""contig""))
*defconfig = PLANARCONFIG_CONTIG;
else
{
TIFFError (""Unknown planar configuration"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'r':
*defrowsperstrip = atol(optarg);
break;
case 's':
outtiled = FALSE;
break;
case 't':
outtiled = TRUE;
break;
case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
printf(""Tiffcrop version: %s, last updated: %s\n"",
tiffcrop_version_id, tiffcrop_rev_date);
printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
exit (EXIT_SUCCESS);
break;
case 'w':
outtiled = TRUE;
*deftilewidth = atoi(optarg);
break;
case 'z': 
crop_data->crop_mode |= CROP_REGIONS;
for (i = 0, opt_ptr = strtok (optarg, "":"");
((opt_ptr != NULL) &&  (i < MAX_REGIONS));
(opt_ptr = strtok (NULL, "":"")), i++)
{
crop_data->regions++;
if (sscanf(opt_ptr, ""%lf,%lf,%lf,%lf"",
&crop_data->corners[i].X1, &crop_data->corners[i].Y1,
&crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)
{
TIFFError (""Unable to parse coordinates for region"", ""%u %s"", i, optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
{
TIFFError (""Region list exceeds limit of"", ""%d regions %s"", MAX_REGIONS, optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);;
}
break;
case 'B': *mp++ = 'b'; *mp = '\0';
break;
case 'L': *mp++ = 'l'; *mp = '\0';
break;
case 'M': *mp++ = 'm'; *mp = '\0';
break;
case 'C': *mp++ = 'c'; *mp = '\0';
break;
case 'D': for (i = 0, opt_ptr = strtok (optarg, "","");
(opt_ptr != NULL);
(opt_ptr = strtok (NULL, "","")), i++)
{
opt_offset = strpbrk(opt_ptr, "":="");
if (opt_offset == NULL)
{
TIFFError(""Invalid dump option"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
*opt_offset = '\0';
end = strlen (opt_ptr);
for (i = 0; i < end; i++)
*(opt_ptr + i) = tolower((int) *(opt_ptr + i));
if (strncmp(opt_ptr, ""for"", 3) == 0)
{
end = strlen (opt_offset + 1);
for (i = 1; i <= end; i++)
*(opt_offset + i) = tolower((int) *(opt_offset + i));
if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
{
dump->format = DUMP_TEXT;
strcpy (dump->mode, ""w"");
}
else
{
if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
{
dump->format = DUMP_RAW;
strcpy (dump->mode, ""wb"");
}
else
{
TIFFError(""parse_command_opts"", ""Unknown dump format %s"", opt_offset + 1);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
}
else
{ 
if (strncmp (opt_ptr, ""lev"", 3) == 0)
dump->level = atoi(opt_offset + 1);
if (strncmp (opt_ptr, ""in"", 2) == 0)
{
strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);
dump->infilename[PATH_MAX - 20] = '\0';
}
if (strncmp (opt_ptr, ""out"", 3) == 0)
{
strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);
dump->outfilename[PATH_MAX - 20] = '\0';
}
if (strncmp (opt_ptr, ""deb"", 3) == 0)
dump->debug = atoi(opt_offset + 1);
}
}
if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))
{
if (dump->level == 1)
TIFFError("""",""Defaulting to dump level 1, no data."");
if (dump->format == DUMP_NONE)
{
TIFFError("""", ""You must specify a dump format for dump files"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
break;
case 'm': 
crop_data->crop_mode |= CROP_MARGINS;
for (i = 0, opt_ptr = strtok (optarg, "",:"");
((opt_ptr != NULL) &&  (i < 4));
(opt_ptr = strtok (NULL, "",:"")), i++)
{
crop_data->margins[i] = atof(opt_ptr);
}
break;
case 'E':
switch (tolower((int) optarg[0]))
{
case 't': crop_data->edge_ref = EDGE_TOP;
break;
case 'b': crop_data->edge_ref = EDGE_BOTTOM;
break;
case 'l': crop_data->edge_ref = EDGE_LEFT;
break;
case 'r': crop_data->edge_ref = EDGE_RIGHT;
break;
default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'F': 
crop_data->crop_mode |= CROP_MIRROR;
switch (tolower((int) optarg[0]))
{
case  'h': crop_data->mirror = MIRROR_HORIZ;
break;
case  'v': crop_data->mirror = MIRROR_VERT;
break;
case  'b': crop_data->mirror = MIRROR_BOTH;
break;
default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'H': 
page->hres = atof (optarg);
page->mode |= PAGE_MODE_RESOLUTION;
break;
case 'I': 
crop_data->crop_mode |= CROP_INVERT;
if (streq(optarg, ""black""))
{
crop_data->photometric = PHOTOMETRIC_MINISBLACK;
continue;
}
if (streq(optarg, ""white""))
{
crop_data->photometric = PHOTOMETRIC_MINISWHITE;
continue;
}
if (streq(optarg, ""data"")) 
{
crop_data->photometric = INVERT_DATA_ONLY;
continue;
}
if (streq(optarg, ""both""))
{
crop_data->photometric = INVERT_DATA_AND_TAG;
continue;
}
TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
break;
case 'J': 
page->hmargin = atof(optarg);
page->mode |= PAGE_MODE_MARGINS;
break;
case 'K': 
page->vmargin = atof(optarg);
page->mode |= PAGE_MODE_MARGINS;
break;
case 'N':
for (i = 0, opt_ptr = strtok (optarg, "","");
((opt_ptr != NULL) &&  (i < MAX_IMAGES));
(opt_ptr = strtok (NULL, "","")))
{ 
if (streq(opt_ptr, ""odd""))
{
for (j = 1; j <= MAX_IMAGES; j += 2)
imagelist[i++] = j;
*image_count = (MAX_IMAGES - 1) / 2;
break;
}
else
{
if (streq(opt_ptr, ""even""))
{
for (j = 2; j <= MAX_IMAGES; j += 2)
imagelist[i++] = j;
*image_count = MAX_IMAGES / 2;
break;
}
else
{
if (streq(opt_ptr, ""last""))
imagelist[i++] = MAX_IMAGES;
else  
{
sep = strpbrk(opt_ptr, "":-"");
if (!sep)
imagelist[i++] = atoi(opt_ptr);
else
{
*sep = '\0';
start = atoi (opt_ptr);
if (!strcmp((sep + 1), ""last""))
end = MAX_IMAGES;
else
end = atoi (sep + 1);
for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)
imagelist[i++] = j;
}
}
}
}
}
*image_count = i;
break;
case 'O':  
switch (tolower((int) optarg[0]))
{
case  'a': page->orient = ORIENTATION_AUTO;
break;
case  'p': page->orient = ORIENTATION_PORTRAIT;
break;
case  'l': page->orient = ORIENTATION_LANDSCAPE;
break;
default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'P':  
if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
{
strcpy (page->name, ""Custom""); 
page->mode |= PAGE_MODE_PAPERSIZE;
break;
}
if (get_page_geometry (optarg, page))
{
if (!strcmp(optarg, ""list""))
{
TIFFError("""", ""Name            Width   Length (in inches)"");
for (i = 0; i < MAX_PAPERNAMES - 1; i++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
PaperTable[i].name, PaperTable[i].width, 
PaperTable[i].length);
exit (EXIT_FAILURE);
}
TIFFError (""Invalid paper size"", ""%s"", optarg);
TIFFError ("""", ""Select one of:"");
TIFFError("""", ""Name            Width   Length (in inches)"");
for (i = 0; i < MAX_PAPERNAMES - 1; i++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
PaperTable[i].name, PaperTable[i].width, 
PaperTable[i].length);
exit (EXIT_FAILURE);
}
else
{
page->mode |= PAGE_MODE_PAPERSIZE;
}
break;
case 'R': 
crop_data->crop_mode |= CROP_ROTATE;
switch (strtoul(optarg, NULL, 0))
{
case  90:  crop_data->rotation = (uint16_t)90;
break;
case  180: crop_data->rotation = (uint16_t)180;
break;
case  270: crop_data->rotation = (uint16_t)270;
break;
default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'S':
sep = strpbrk(optarg, "",:"");
if (sep)
{
*sep = '\0';
page->cols = atoi(optarg);
page->rows = atoi(sep +1);
}
else
{
page->cols = atoi(optarg);
page->rows = atoi(optarg);
}
if ((page->cols * page->rows) > MAX_SECTIONS)
{
TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", MAX_SECTIONS);
exit (EXIT_FAILURE);
}
page->mode |= PAGE_MODE_ROWSCOLS;
break;
case 'U':
if (streq(optarg, ""in""))
{
crop_data->res_unit = RESUNIT_INCH;
page->res_unit = RESUNIT_INCH;
}
else if (streq(optarg, ""cm""))
{
crop_data->res_unit = RESUNIT_CENTIMETER;
page->res_unit = RESUNIT_CENTIMETER;
}
else if (streq(optarg, ""px""))
{
crop_data->res_unit = RESUNIT_NONE;
page->res_unit = RESUNIT_NONE;
}
else
{
TIFFError (""Illegal unit of measure"",""%s"", optarg);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
break;
case 'V': 
page->vres = atof (optarg);
page->mode |= PAGE_MODE_RESOLUTION;
break;
case 'X':
crop_data->crop_mode |= CROP_WIDTH;
crop_data->width = atof(optarg);
break;
case 'Y':
crop_data->crop_mode |= CROP_LENGTH;
crop_data->length = atof(optarg);
break;
case 'Z': 
crop_data->crop_mode |= CROP_ZONES;
for (i = 0, opt_ptr = strtok (optarg, "","");
((opt_ptr != NULL) &&  (i < MAX_REGIONS));
(opt_ptr = strtok (NULL, "","")), i++)
{
crop_data->zones++;
opt_offset = strchr(opt_ptr, ':');
if (!opt_offset) {
TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
exit(EXIT_FAILURE);
}
*opt_offset = '\0';
crop_data->zonelist[i].position = atoi(opt_ptr);
crop_data->zonelist[i].total    = atoi(opt_offset + 1);
}
if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
{
TIFFError(""Zone list exceeds region limit"", ""%d"",  MAX_REGIONS);
exit (EXIT_FAILURE);
}
break;
case '?':TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (EXIT_FAILURE);
}
}
char XY, Z, R, S;
XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));
Z = (crop_data->crop_mode & CROP_ZONES);
R = (crop_data->crop_mode & CROP_REGIONS);
S = (page->mode & PAGE_MODE_ROWSCOLS);
if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {
TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
exit(EXIT_FAILURE);
}
}","void  process_command_opts (int VAR_0, char *VAR_1[], char *VAR_2, char *VAR_3, uint32_t *VAR_4,
uint16_t *VAR_5, uint16_t *VAR_6, uint32_t *VAR_7,
uint32_t *VAR_8, uint32_t *VAR_9,
struct crop_mask *VAR_10, struct pagedef *VAR_11,
struct dump_opts *VAR_12,
unsigned int     *VAR_13, unsigned int   *VAR_14 )
{
int   VAR_15, VAR_16 = 0;
char *VAR_17   = NULL;    
char *VAR_18      = NULL;    
char *VAR_19          = NULL;    
unsigned int  VAR_20, VAR_21, VAR_22, VAR_23;
#if !VAR_24
extern int   VAR_25;
extern char* VAR_26;
#endif
*VAR_2++ = 'w';
*VAR_2 = '\0';
while ((VAR_15 = getopt(VAR_0, VAR_1,
""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
{
VAR_16++;
switch (VAR_15) {
case 'a': VAR_3[0] = 'a';
break;
case 'c':if (!processCompressOptions(VAR_26)) 
{
TIFFError (""Unknown compression option"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'd':VAR_22 = strtoul(VAR_26, NULL, 0); 
if (VAR_22 == 0)
{
TIFFError ("""",""Directory offset must be greater than zero"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
*VAR_4 = VAR_22 - 1;
break;
case 'e': switch (tolower((int) VAR_26[0])) 
{
case 'c': VAR_10->exp_mode = VAR_28;
VAR_10->img_mode = VAR_29;
break; 
case 'd': VAR_10->exp_mode = VAR_30;
VAR_10->img_mode = VAR_31;
break; 
case 'i': VAR_10->exp_mode = VAR_32;
VAR_10->img_mode = VAR_29;
break; 
case 'm': VAR_10->exp_mode = VAR_33;
VAR_10->img_mode = VAR_31;
break; 
case 's': VAR_10->exp_mode = VAR_34;
VAR_10->img_mode = VAR_31;
break; 
default:  TIFFError (""Unknown export mode"",""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'f':if (streq(VAR_26, ""lsb2msb""))   
*VAR_6 = VAR_35;
else if (streq(VAR_26, ""msb2lsb""))
*VAR_6 = VAR_36;
else
{
TIFFError (""Unknown fill order"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'h':usage(VAR_37);
break;
case 'i':VAR_38 = TRUE;
break;
case 'k':VAR_39 = (tmsize_t)strtoul(VAR_26, NULL, 0) << 20;
break;
case 'l':VAR_40 = TRUE; 
*VAR_8 = atoi(VAR_26);
break;
case 'p': 
if (streq(VAR_26, ""separate""))
*VAR_5 = VAR_41;
else if (streq(VAR_26, ""contig""))
*VAR_5 = VAR_42;
else
{
TIFFError (""Unknown planar configuration"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'r':
*VAR_9 = atol(VAR_26);
break;
case 's':
VAR_40 = FALSE;
break;
case 't':
VAR_40 = TRUE;
break;
case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
printf(""Tiffcrop version: %s, last updated: %s\n"",
VAR_43, VAR_44);
printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
exit (VAR_37);
break;
case 'w':
VAR_40 = TRUE;
*VAR_7 = atoi(VAR_26);
break;
case 'z': 
VAR_10->crop_mode |= VAR_45;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "":"");
((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
(VAR_18 = strtok (NULL, "":"")), VAR_20++)
{
VAR_10->regions++;
if (sscanf(VAR_18, ""%lf,%lf,%lf,%lf"",
&VAR_10->corners[VAR_20].X1, &VAR_10->corners[VAR_20].Y1,
&VAR_10->corners[VAR_20].X2, &VAR_10->corners[VAR_20].Y2) != 4)
{
TIFFError (""Unable to parse coordinates for region"", ""%u %s"", VAR_20, VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
{
TIFFError (""Region list exceeds limit of"", ""%d regions %s"", VAR_46, VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);;
}
break;
case 'B': *VAR_2++ = 'b'; *VAR_2 = '\0';
break;
case 'L': *VAR_2++ = 'l'; *VAR_2 = '\0';
break;
case 'M': *VAR_2++ = 'm'; *VAR_2 = '\0';
break;
case 'C': *VAR_2++ = 'c'; *VAR_2 = '\0';
break;
case 'D': for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
(VAR_18 != NULL);
(VAR_18 = strtok (NULL, "","")), VAR_20++)
{
VAR_17 = strpbrk(VAR_18, "":="");
if (VAR_17 == NULL)
{
TIFFError(""Invalid dump option"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
*VAR_17 = '\0';
VAR_23 = strlen (VAR_18);
for (VAR_20 = 0; VAR_20 < VAR_23; VAR_20++)
*(VAR_18 + VAR_20) = tolower((int) *(VAR_18 + VAR_20));
if (strncmp(VAR_18, ""for"", 3) == 0)
{
VAR_23 = strlen (VAR_17 + 1);
for (VAR_20 = 1; VAR_20 <= VAR_23; VAR_20++)
*(VAR_17 + VAR_20) = tolower((int) *(VAR_17 + VAR_20));
if (strncmp (VAR_17 + 1, ""txt"", 3) == 0)
{
VAR_12->format = VAR_47;
strcpy (VAR_12->mode, ""w"");
}
else
{
if (strncmp(VAR_17 + 1, ""raw"", 3) == 0)
{
VAR_12->format = VAR_48;
strcpy (VAR_12->mode, ""wb"");
}
else
{
TIFFError(""parse_command_opts"", ""Unknown dump format %s"", VAR_17 + 1);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
}
else
{ 
if (strncmp (VAR_18, ""lev"", 3) == 0)
VAR_12->level = atoi(VAR_17 + 1);
if (strncmp (VAR_18, ""in"", 2) == 0)
{
strncpy (VAR_12->infilename, VAR_17 + 1, VAR_49 - 20);
VAR_12->infilename[VAR_49 - 20] = '\0';
}
if (strncmp (VAR_18, ""out"", 3) == 0)
{
strncpy (VAR_12->outfilename, VAR_17 + 1, VAR_49 - 20);
VAR_12->outfilename[VAR_49 - 20] = '\0';
}
if (strncmp (VAR_18, ""deb"", 3) == 0)
VAR_12->debug = atoi(VAR_17 + 1);
}
}
if ((strlen(VAR_12->infilename)) || (strlen(VAR_12->outfilename)))
{
if (VAR_12->level == 1)
TIFFError("""",""Defaulting to dump level 1, no data."");
if (VAR_12->format == VAR_50)
{
TIFFError("""", ""You must specify a dump format for dump files"");
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
break;
case 'm': 
VAR_10->crop_mode |= VAR_51;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "",:"");
((VAR_18 != NULL) &&  (VAR_20 < 4));
(VAR_18 = strtok (NULL, "",:"")), VAR_20++)
{
VAR_10->margins[VAR_20] = atof(VAR_18);
}
break;
case 'E':
switch (tolower((int) VAR_26[0]))
{
case 't': VAR_10->edge_ref = VAR_52;
break;
case 'b': VAR_10->edge_ref = VAR_53;
break;
case 'l': VAR_10->edge_ref = VAR_54;
break;
case 'r': VAR_10->edge_ref = VAR_55;
break;
default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'F': 
VAR_10->crop_mode |= VAR_56;
switch (tolower((int) VAR_26[0]))
{
case  'h': VAR_10->mirror = VAR_57;
break;
case  'v': VAR_10->mirror = VAR_58;
break;
case  'b': VAR_10->mirror = VAR_59;
break;
default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'H': 
VAR_11->hres = atof (VAR_26);
VAR_11->mode |= VAR_60;
break;
case 'I': 
VAR_10->crop_mode |= VAR_61;
if (streq(VAR_26, ""black""))
{
VAR_10->photometric = VAR_62;
continue;
}
if (streq(VAR_26, ""white""))
{
VAR_10->photometric = VAR_63;
continue;
}
if (streq(VAR_26, ""data"")) 
{
VAR_10->photometric = VAR_64;
continue;
}
if (streq(VAR_26, ""both""))
{
VAR_10->photometric = VAR_65;
continue;
}
TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
break;
case 'J': 
VAR_11->hmargin = atof(VAR_26);
VAR_11->mode |= VAR_66;
break;
case 'K': 
VAR_11->vmargin = atof(VAR_26);
VAR_11->mode |= VAR_66;
break;
case 'N':
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
((VAR_18 != NULL) &&  (VAR_20 < VAR_67));
(VAR_18 = strtok (NULL, "","")))
{ 
if (streq(VAR_18, ""odd""))
{
for (VAR_21 = 1; VAR_21 <= VAR_67; VAR_21 += 2)
VAR_13[VAR_20++] = VAR_21;
*VAR_14 = (VAR_67 - 1) / 2;
break;
}
else
{
if (streq(VAR_18, ""even""))
{
for (VAR_21 = 2; VAR_21 <= VAR_67; VAR_21 += 2)
VAR_13[VAR_20++] = VAR_21;
*VAR_14 = VAR_67 / 2;
break;
}
else
{
if (streq(VAR_18, ""last""))
VAR_13[VAR_20++] = VAR_67;
else  
{
VAR_19 = strpbrk(VAR_18, "":-"");
if (!VAR_19)
VAR_13[VAR_20++] = atoi(VAR_18);
else
{
*VAR_19 = '\0';
VAR_22 = atoi (VAR_18);
if (!strcmp((VAR_19 + 1), ""last""))
VAR_23 = VAR_67;
else
VAR_23 = atoi (VAR_19 + 1);
for (VAR_21 = VAR_22; VAR_21 <= VAR_23 && VAR_21 - VAR_22 + VAR_20 < VAR_67; VAR_21++)
VAR_13[VAR_20++] = VAR_21;
}
}
}
}
}
*VAR_14 = VAR_20;
break;
case 'O':  
switch (tolower((int) VAR_26[0]))
{
case  'a': VAR_11->orient = VAR_68;
break;
case  'p': VAR_11->orient = VAR_69;
break;
case  'l': VAR_11->orient = VAR_70;
break;
default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'P':  
if (sscanf(VAR_26, ""%lfx%lf"", &VAR_11->width, &VAR_11->length) == 2)
{
strcpy (VAR_11->name, ""Custom""); 
VAR_11->mode |= VAR_71;
break;
}
if (get_page_geometry (VAR_26, VAR_11))
{
if (!strcmp(VAR_26, ""list""))
{
TIFFError("""", ""Name            Width   Length (in inches)"");
for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
VAR_73[VAR_20].length);
exit (VAR_27);
}
TIFFError (""Invalid paper size"", ""%s"", VAR_26);
TIFFError ("""", ""Select one of:"");
TIFFError("""", ""Name            Width   Length (in inches)"");
for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
VAR_73[VAR_20].length);
exit (VAR_27);
}
else
{
VAR_11->mode |= VAR_71;
}
break;
case 'R': 
VAR_10->crop_mode |= VAR_74;
switch (strtoul(VAR_26, NULL, 0))
{
case  90:  VAR_10->rotation = (uint16_t)90;
break;
case  180: VAR_10->rotation = (uint16_t)180;
break;
case  270: VAR_10->rotation = (uint16_t)270;
break;
default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'S':
VAR_19 = strpbrk(VAR_26, "",:"");
if (VAR_19)
{
*VAR_19 = '\0';
VAR_11->cols = atoi(VAR_26);
VAR_11->rows = atoi(VAR_19 +1);
}
else
{
VAR_11->cols = atoi(VAR_26);
VAR_11->rows = atoi(VAR_26);
}
if ((VAR_11->cols * VAR_11->rows) > VAR_75)
{
TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", VAR_75);
exit (VAR_27);
}
VAR_11->mode |= VAR_76;
break;
case 'U':
if (streq(VAR_26, ""in""))
{
VAR_10->res_unit = VAR_77;
VAR_11->res_unit = VAR_77;
}
else if (streq(VAR_26, ""cm""))
{
VAR_10->res_unit = VAR_78;
VAR_11->res_unit = VAR_78;
}
else if (streq(VAR_26, ""px""))
{
VAR_10->res_unit = VAR_79;
VAR_11->res_unit = VAR_79;
}
else
{
TIFFError (""Illegal unit of measure"",""%s"", VAR_26);
TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
break;
case 'V': 
VAR_11->vres = atof (VAR_26);
VAR_11->mode |= VAR_60;
break;
case 'X':
VAR_10->crop_mode |= VAR_80;
VAR_10->width = atof(VAR_26);
break;
case 'Y':
VAR_10->crop_mode |= VAR_81;
VAR_10->length = atof(VAR_26);
break;
case 'Z': 
VAR_10->crop_mode |= VAR_82;
for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
(VAR_18 = strtok (NULL, "","")), VAR_20++)
{
VAR_10->zones++;
VAR_17 = strchr(VAR_18, ':');
if (!VAR_17) {
TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
exit(VAR_27);
}
*VAR_17 = '\0';
VAR_10->zonelist[VAR_20].position = atoi(VAR_18);
VAR_10->zonelist[VAR_20].total    = atoi(VAR_17 + 1);
}
if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
{
TIFFError(""Zone list exceeds region limit"", ""%d"",  VAR_46);
exit (VAR_27);
}
break;
case '?':TIFFError (""For valid options type"", ""tiffcrop -h"");
exit (VAR_27);
}
}
char VAR_83, VAR_84, VAR_85, VAR_86;
VAR_83 = ((VAR_10->crop_mode & VAR_80) || (VAR_10->crop_mode & VAR_81));
VAR_84 = (VAR_10->crop_mode & VAR_82);
VAR_85 = (VAR_10->crop_mode & VAR_45);
VAR_86 = (VAR_11->mode & VAR_76);
if ((VAR_83 && VAR_84) || (VAR_83 && VAR_85) || (VAR_83 && VAR_86) || (VAR_84 && VAR_85) || (VAR_84 && VAR_86) || (VAR_85 && VAR_86)) {
TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
exit(VAR_27);
}
}",libtiff/bad48e90b410df32172006c7876da449ba62cdba/tiffcrop.c/vul/before/0.json,"void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,
                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,
                            uint32_t *deftilelength, uint32_t *defrowsperstrip,
                            struct crop_mask *crop_data, struct pagedef *page,
                            struct dump_opts *dump,
                            unsigned int     *imagelist, unsigned int   *image_count )
    {
    int   c, good_args = 0;
    char *opt_offset   = NULL;    /* Position in string of value sought */
    char *opt_ptr      = NULL;    /* Pointer to next token in option set */
    char *sep          = NULL;    /* Pointer to a token separator */
    unsigned int  i, j, start, end;
#if !HAVE_DECL_OPTARG
    extern int   optind;
    extern char* optarg;
#endif

    *mp++ = 'w';
    *mp = '\0';
    while ((c = getopt(argc, argv,
       ""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
      {
    good_args++;
    switch (c) {
      case 'a': mode[0] = 'a';	/* append to output */
		break;
      case 'c':	if (!processCompressOptions(optarg)) /* compression scheme */
		  {
		  TIFFError (""Unknown compression option"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'd':	start = strtoul(optarg, NULL, 0); /* initial IFD offset */
	        if (start == 0)
                  {
		  TIFFError ("""",""Directory offset must be greater than zero"");
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
		  }
	        *dirnum = start - 1;
		break;
      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/
                  {
		  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;
 		            crop_data->img_mode = COMPOSITE_IMAGES;
		            break; /* Composite */
		  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Divided */
		  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;
 		            crop_data->img_mode = COMPOSITE_IMAGES;
		            break; /* Image */
		  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Multiple */
		  case 's': crop_data->exp_mode = FILE_PER_SELECTION;
 		            crop_data->img_mode = SEPARATED_IMAGES;
		            break; /* Sections */
		  default:  TIFFError (""Unknown export mode"",""%s"", optarg);
                            TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
                  }
	        break;
      case 'f':	if (streq(optarg, ""lsb2msb""))	   /* fill order */
		  *deffillorder = FILLORDER_LSB2MSB;
		else if (streq(optarg, ""msb2lsb""))
		  *deffillorder = FILLORDER_MSB2LSB;
		else
		  {
		  TIFFError (""Unknown fill order"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'h':	usage(EXIT_SUCCESS);
		break;
      case 'i':	ignore = TRUE;		/* ignore errors */
		break;
      case 'k':	maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;
		break;
      case 'l':	outtiled = TRUE;	 /* tile length */
		*deftilelength = atoi(optarg);
		break;
      case 'p': /* planar configuration */
		if (streq(optarg, ""separate""))
		  *defconfig = PLANARCONFIG_SEPARATE;
		else if (streq(optarg, ""contig""))
		  *defconfig = PLANARCONFIG_CONTIG;
		else
		  {
		  TIFFError (""Unknown planar configuration"", ""%s"", optarg);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
                  }
		break;
      case 'r':	/* rows/strip */
		*defrowsperstrip = atol(optarg);
		break;
      case 's':	/* generate stripped output */
		outtiled = FALSE;
		break;
      case 't':	/* generate tiled output */
		outtiled = TRUE;
		break;
      case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
                printf(""Tiffcrop version: %s, last updated: %s\n"",
			   tiffcrop_version_id, tiffcrop_rev_date);
	        printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
		printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
                printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
	        exit (EXIT_SUCCESS);
		break;
      case 'w':	/* tile width */
		outtiled = TRUE;
		*deftilewidth = atoi(optarg);
		break;
      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */
	        crop_data->crop_mode |= CROP_REGIONS;
		for (i = 0, opt_ptr = strtok (optarg, "":"");
                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));
                    (opt_ptr = strtok (NULL, "":"")), i++)
                    {
		    crop_data->regions++;
                    if (sscanf(opt_ptr, ""%lf,%lf,%lf,%lf"",
			       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,
			       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)
                      {
                      TIFFError (""Unable to parse coordinates for region"", ""%u %s"", i, optarg);
		      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (EXIT_FAILURE);
		      }
                    }
                /*  check for remaining elements over MAX_REGIONS */
                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
                  {
		  TIFFError (""Region list exceeds limit of"", ""%d regions %s"", MAX_REGIONS, optarg);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);;
                  }
		break;
      /* options for file open modes */
      case 'B': *mp++ = 'b'; *mp = '\0';
		break;
      case 'L': *mp++ = 'l'; *mp = '\0';
		break;
      case 'M': *mp++ = 'm'; *mp = '\0';
		break;
      case 'C': *mp++ = 'c'; *mp = '\0';
		break;
      /* options for Debugging / data dump */
      case 'D': for (i = 0, opt_ptr = strtok (optarg, "","");
                    (opt_ptr != NULL);
                    (opt_ptr = strtok (NULL, "","")), i++)
                    {
		    opt_offset = strpbrk(opt_ptr, "":="");
                    if (opt_offset == NULL)
                      {
                      TIFFError(""Invalid dump option"", ""%s"", optarg);
                      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (EXIT_FAILURE);
		      }
                      
                    *opt_offset = '\0';
                    /* convert option to lowercase */
                    end = strlen (opt_ptr);
                    for (i = 0; i < end; i++)
                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));
                    /* Look for dump format specification */
                    if (strncmp(opt_ptr, ""for"", 3) == 0)
                      {
		      /* convert value to lowercase */
                      end = strlen (opt_offset + 1);
                      for (i = 1; i <= end; i++)
                        *(opt_offset + i) = tolower((int) *(opt_offset + i));
                      /* check dump format value */
		      if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
                        {
                        dump->format = DUMP_TEXT;
                        strcpy (dump->mode, ""w"");
                        }
                      else
                        {
		        if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
                          {
                          dump->format = DUMP_RAW;
                          strcpy (dump->mode, ""wb"");
                          }
                        else
                          {
                          TIFFError(""parse_command_opts"", ""Unknown dump format %s"", opt_offset + 1);
                          TIFFError (""For valid options type"", ""tiffcrop -h"");
                          exit (EXIT_FAILURE);
		          }
			}
                      }
		    else
                      { /* Look for dump level specification */
                      if (strncmp (opt_ptr, ""lev"", 3) == 0)
                        dump->level = atoi(opt_offset + 1);
                        /* Look for input data dump file name */
                      if (strncmp (opt_ptr, ""in"", 2) == 0)
		        {
                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);
                        dump->infilename[PATH_MAX - 20] = '\0';
                        }
                        /* Look for output data dump file name */
                      if (strncmp (opt_ptr, ""out"", 3) == 0)
			{
                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);
                        dump->outfilename[PATH_MAX - 20] = '\0';
                        }
                      if (strncmp (opt_ptr, ""deb"", 3) == 0)
			dump->debug = atoi(opt_offset + 1);
		      }
                    }
	        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))
                  {
		  if (dump->level == 1)
                    TIFFError("""",""Defaulting to dump level 1, no data."");
	          if (dump->format == DUMP_NONE)
                    {
		    TIFFError("""", ""You must specify a dump format for dump files"");
		    TIFFError (""For valid options type"", ""tiffcrop -h"");
		    exit (EXIT_FAILURE);
		    }
                  }
	        break;

      /* image manipulation routine options */
      case 'm': /* margins to exclude from selection, uppercase M was already used */
		/* order of values must be TOP, LEFT, BOTTOM, RIGHT */
		crop_data->crop_mode |= CROP_MARGINS;
                for (i = 0, opt_ptr = strtok (optarg, "",:"");
                    ((opt_ptr != NULL) &&  (i < 4));
                     (opt_ptr = strtok (NULL, "",:"")), i++)
                    {
		    crop_data->margins[i] = atof(opt_ptr);
                    }
		break;
      case 'E':	/* edge reference */
		switch (tolower((int) optarg[0]))
                  {
		  case 't': crop_data->edge_ref = EDGE_TOP;
                            break;
                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;
                             break;
                  case 'l': crop_data->edge_ref = EDGE_LEFT;
                            break;
                  case 'r': crop_data->edge_ref = EDGE_RIGHT;
                            break;
		  default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", optarg);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
		  }
		break;
      case 'F': /* flip eg mirror image or cropped segment, M was already used */
		crop_data->crop_mode |= CROP_MIRROR;
		switch (tolower((int) optarg[0]))
                  {
		  case  'h': crop_data->mirror = MIRROR_HORIZ;
                             break;
                  case  'v': crop_data->mirror = MIRROR_VERT;
                             break;
                  case  'b': crop_data->mirror = MIRROR_BOTH;
                             break;
		  default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", optarg);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (EXIT_FAILURE);
		  }
		break;
      case 'H': /* set horizontal resolution to new value */
		page->hres = atof (optarg);
                page->mode |= PAGE_MODE_RESOLUTION;
		break;
      case 'I': /* invert the color space, eg black to white */
		crop_data->crop_mode |= CROP_INVERT;
                /* The PHOTOMETIC_INTERPRETATION tag may be updated */
                if (streq(optarg, ""black""))
                  {
		  crop_data->photometric = PHOTOMETRIC_MINISBLACK;
		  continue;
                  }
                if (streq(optarg, ""white""))
                  {
		  crop_data->photometric = PHOTOMETRIC_MINISWHITE;
                  continue;
                  }
                if (streq(optarg, ""data"")) 
                  {
		  crop_data->photometric = INVERT_DATA_ONLY;
                  continue;
                  }
                if (streq(optarg, ""both""))
                  {
		  crop_data->photometric = INVERT_DATA_AND_TAG;
                  continue;
                  }

		TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", optarg);
		TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (EXIT_FAILURE);
		break;
      case 'J': /* horizontal margin for sectioned output pages */
		page->hmargin = atof(optarg);
                page->mode |= PAGE_MODE_MARGINS;
		break;
      case 'K': /* vertical margin for sectioned output pages*/
                page->vmargin = atof(optarg);
                page->mode |= PAGE_MODE_MARGINS;
		break;
      case 'N':	/* list of images to process */
                for (i = 0, opt_ptr = strtok (optarg, "","");
                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));
                     (opt_ptr = strtok (NULL, "","")))
                     { /* We do not know how many images are in file yet 
			* so we build a list to include the maximum allowed
                        * and follow it until we hit the end of the file.
                        * Image count is not accurate for odd, even, last
                        * so page numbers won't be valid either.
                        */
		     if (streq(opt_ptr, ""odd""))
                       {
		       for (j = 1; j <= MAX_IMAGES; j += 2)
			 imagelist[i++] = j;
                       *image_count = (MAX_IMAGES - 1) / 2;
                       break;
		       }
		     else
                       {
		       if (streq(opt_ptr, ""even""))
                         {
			 for (j = 2; j <= MAX_IMAGES; j += 2)
			   imagelist[i++] = j;
                         *image_count = MAX_IMAGES / 2;
                         break;
			 }
		       else
                         {
			 if (streq(opt_ptr, ""last""))
			   imagelist[i++] = MAX_IMAGES;
			 else  /* single value between commas */
			   {
			   sep = strpbrk(opt_ptr, "":-"");
			   if (!sep)
			     imagelist[i++] = atoi(opt_ptr);
                           else
                             {
			     *sep = '\0';
                             start = atoi (opt_ptr);
                             if (!strcmp((sep + 1), ""last""))
			       end = MAX_IMAGES;
                             else
                               end = atoi (sep + 1);
                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)
			       imagelist[i++] = j;
			     }
			   }
			 }
		      }
		    }
                *image_count = i;
		break;
      case 'O': /* page orientation */ 
		switch (tolower((int) optarg[0]))
                  {
		  case  'a': page->orient = ORIENTATION_AUTO;
                             break;
		  case  'p': page->orient = ORIENTATION_PORTRAIT;
                             break;
		  case  'l': page->orient = ORIENTATION_LANDSCAPE;
                             break;
		  default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", optarg);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (EXIT_FAILURE);
		  }
		break;
      case 'P': /* page size selection */ 
	        if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
                  {
                  strcpy (page->name, ""Custom""); 
                  page->mode |= PAGE_MODE_PAPERSIZE;
                  break;
                  }
                if (get_page_geometry (optarg, page))
                  {
		  if (!strcmp(optarg, ""list""))
                    {
		    TIFFError("""", ""Name            Width   Length (in inches)"");
                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)
                      TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       PaperTable[i].name, PaperTable[i].width, 
                               PaperTable[i].length);
		    exit (EXIT_FAILURE);
                    }
     
		  TIFFError (""Invalid paper size"", ""%s"", optarg);
                  TIFFError ("""", ""Select one of:"");
		  TIFFError("""", ""Name            Width   Length (in inches)"");
                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)
                    TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       PaperTable[i].name, PaperTable[i].width, 
                               PaperTable[i].length);
		  exit (EXIT_FAILURE);
		  }
		else
                  {
                  page->mode |= PAGE_MODE_PAPERSIZE;
		  }
		break;
      case 'R': /* rotate image or cropped segment */
		crop_data->crop_mode |= CROP_ROTATE;
		switch (strtoul(optarg, NULL, 0))
                  {
		  case  90:  crop_data->rotation = (uint16_t)90;
                             break;
                  case  180: crop_data->rotation = (uint16_t)180;
                             break;
                  case  270: crop_data->rotation = (uint16_t)270;
                             break;
		  default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", optarg);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (EXIT_FAILURE);
		  }
		break;
      case 'S':	/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */
		sep = strpbrk(optarg, "",:"");
		if (sep)
                  {
                  *sep = '\0';
                  page->cols = atoi(optarg);
                  page->rows = atoi(sep +1);
		  }
                else
                  {
                  page->cols = atoi(optarg);
                  page->rows = atoi(optarg);
		  }
                if ((page->cols * page->rows) > MAX_SECTIONS)
                  {
		  TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", MAX_SECTIONS);
		  exit (EXIT_FAILURE);
                  }
                page->mode |= PAGE_MODE_ROWSCOLS;
		break;
      case 'U':	/* units for measurements and offsets */
		if (streq(optarg, ""in""))
                  {
		  crop_data->res_unit = RESUNIT_INCH;
		  page->res_unit = RESUNIT_INCH;
		  }
		else if (streq(optarg, ""cm""))
		  {
		  crop_data->res_unit = RESUNIT_CENTIMETER;
		  page->res_unit = RESUNIT_CENTIMETER;
		  }
		else if (streq(optarg, ""px""))
		  {
		  crop_data->res_unit = RESUNIT_NONE;
		  page->res_unit = RESUNIT_NONE;
		  }
		else
                  {
		  TIFFError (""Illegal unit of measure"",""%s"", optarg);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (EXIT_FAILURE);
		  }
		break;
      case 'V': /* set vertical resolution to new value */
		page->vres = atof (optarg);
                page->mode |= PAGE_MODE_RESOLUTION;
		break;
      case 'X':	/* selection width */
		crop_data->crop_mode |= CROP_WIDTH;
		crop_data->width = atof(optarg);
		break;
      case 'Y':	/* selection length */
		crop_data->crop_mode |= CROP_LENGTH;
		crop_data->length = atof(optarg);
		break;
      case 'Z': /* zones of an image X:Y read as zone X of Y */
		crop_data->crop_mode |= CROP_ZONES;
		for (i = 0, opt_ptr = strtok (optarg, "","");
                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));
                    (opt_ptr = strtok (NULL, "","")), i++)
                    {
		    crop_data->zones++;
		    opt_offset = strchr(opt_ptr, ':');
		    if (!opt_offset) {
			TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
			exit(EXIT_FAILURE);
		    }
                    *opt_offset = '\0';
                    crop_data->zonelist[i].position = atoi(opt_ptr);
                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);
                    }
                /*  check for remaining elements over MAX_REGIONS */
                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))
                  {
		  TIFFError(""Zone list exceeds region limit"", ""%d"",  MAX_REGIONS);
		  exit (EXIT_FAILURE);
                  }
		break;
    case '?':	TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (EXIT_FAILURE);
		/*NOTREACHED*/
      }
    }
    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/
    char XY, Z, R, S;
    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;
    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;
    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;
    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;
    if (XY + Z + R + S > 1) {
        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
        exit(EXIT_FAILURE);
    }
  }","void  process_command_opts (int VAR_0, char *VAR_1[], char *VAR_2, char *VAR_3, uint32_t *VAR_4,
                            uint16_t *VAR_5, uint16_t *VAR_6, uint32_t *VAR_7,
                            uint32_t *VAR_8, uint32_t *VAR_9,
                            struct crop_mask *VAR_10, struct pagedef *VAR_11,
                            struct dump_opts *VAR_12,
                            unsigned int     *VAR_13, unsigned int   *VAR_14 )
    {
    int   VAR_15, VAR_16 = 0;
    char *VAR_17   = NULL;    /* COMMENT_0 */
    char *VAR_18      = NULL;    /* COMMENT_1 */
    char *VAR_19          = NULL;    /* COMMENT_2 */
    unsigned int  VAR_20, VAR_21, VAR_22, VAR_23;
#if !VAR_24
    extern int   VAR_25;
    extern char* VAR_26;
#endif

    *VAR_2++ = 'w';
    *VAR_2 = '\0';
    while ((VAR_15 = getopt(VAR_0, VAR_1,
       ""ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:"")) != -1)
      {
    VAR_16++;
    switch (VAR_15) {
      case 'a': VAR_3[0] = 'a';	/* COMMENT_3 */
		break;
      case 'c':	if (!processCompressOptions(VAR_26)) /* COMMENT_4 */
		  {
		  TIFFError (""Unknown compression option"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'd':	VAR_22 = strtoul(VAR_26, NULL, 0); /* COMMENT_5 */
	        if (VAR_22 == 0)
                  {
		  TIFFError ("""",""Directory offset must be greater than zero"");
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
		  }
	        *VAR_4 = VAR_22 - 1;
		break;
      case 'e': switch (tolower((int) VAR_26[0])) /* COMMENT_6 */
                  {
		  case 'c': VAR_10->exp_mode = VAR_28;
 		            VAR_10->img_mode = VAR_29;
		            break; /* COMMENT_7 */
		  case 'd': VAR_10->exp_mode = VAR_30;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_8 */
		  case 'i': VAR_10->exp_mode = VAR_32;
 		            VAR_10->img_mode = VAR_29;
		            break; /* COMMENT_9 */
		  case 'm': VAR_10->exp_mode = VAR_33;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_10 */
		  case 's': VAR_10->exp_mode = VAR_34;
 		            VAR_10->img_mode = VAR_31;
		            break; /* COMMENT_11 */
		  default:  TIFFError (""Unknown export mode"",""%s"", VAR_26);
                            TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
                  }
	        break;
      case 'f':	if (streq(VAR_26, ""lsb2msb""))	   /* COMMENT_12 */
		  *VAR_6 = VAR_35;
		else if (streq(VAR_26, ""msb2lsb""))
		  *VAR_6 = VAR_36;
		else
		  {
		  TIFFError (""Unknown fill order"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'h':	usage(VAR_37);
		break;
      case 'i':	VAR_38 = TRUE;		/* COMMENT_13 */
		break;
      case 'k':	VAR_39 = (tmsize_t)strtoul(VAR_26, NULL, 0) << 20;
		break;
      case 'l':	VAR_40 = TRUE;	 /* COMMENT_14 */
		*VAR_8 = atoi(VAR_26);
		break;
      case 'p': /* COMMENT_15 */
		if (streq(VAR_26, ""separate""))
		  *VAR_5 = VAR_41;
		else if (streq(VAR_26, ""contig""))
		  *VAR_5 = VAR_42;
		else
		  {
		  TIFFError (""Unknown planar configuration"", ""%s"", VAR_26);
                  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
                  }
		break;
      case 'r':	/* COMMENT_16 */
		*VAR_9 = atol(VAR_26);
		break;
      case 's':	/* COMMENT_17 */
		VAR_40 = FALSE;
		break;
      case 't':	/* COMMENT_18 */
		VAR_40 = TRUE;
		break;
      case 'v': printf(""Library Release: %s\n"", TIFFGetVersion());
                printf(""Tiffcrop version: %s, last updated: %s\n"",
			   VAR_43, VAR_44);
	        printf(""Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\n"");
		printf(""           : Copyright (c) 1991-1997 Silicon Graphics, Inc\n"");
                printf(""Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\n"");
	        exit (VAR_37);
		break;
      case 'w':	/* COMMENT_19 */
		VAR_40 = TRUE;
		*VAR_7 = atoi(VAR_26);
		break;
      case 'z': /* COMMENT_20 */
	        VAR_10->crop_mode |= VAR_45;
		for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "":"");
                   ((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
                    (VAR_18 = strtok (NULL, "":"")), VAR_20++)
                    {
		    VAR_10->regions++;
                    if (sscanf(VAR_18, ""%lf,%lf,%lf,%lf"",
			       &VAR_10->corners[VAR_20].X1, &VAR_10->corners[VAR_20].Y1,
			       &VAR_10->corners[VAR_20].X2, &VAR_10->corners[VAR_20].Y2) != 4)
                      {
                      TIFFError (""Unable to parse coordinates for region"", ""%u %s"", VAR_20, VAR_26);
		      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (VAR_27);
		      }
                    }
                /* COMMENT_21 */
                if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
                  {
		  TIFFError (""Region list exceeds limit of"", ""%d regions %s"", VAR_46, VAR_26);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);;
                  }
		break;
      /* COMMENT_22 */
      case 'B': *VAR_2++ = 'b'; *VAR_2 = '\0';
		break;
      case 'L': *VAR_2++ = 'l'; *VAR_2 = '\0';
		break;
      case 'M': *VAR_2++ = 'm'; *VAR_2 = '\0';
		break;
      case 'C': *VAR_2++ = 'c'; *VAR_2 = '\0';
		break;
      /* COMMENT_23 */
      case 'D': for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                    (VAR_18 != NULL);
                    (VAR_18 = strtok (NULL, "","")), VAR_20++)
                    {
		    VAR_17 = strpbrk(VAR_18, "":="");
                    if (VAR_17 == NULL)
                      {
                      TIFFError(""Invalid dump option"", ""%s"", VAR_26);
                      TIFFError (""For valid options type"", ""tiffcrop -h"");
                      exit (VAR_27);
		      }
                      
                    *VAR_17 = '\0';
                    /* COMMENT_24 */
                    VAR_23 = strlen (VAR_18);
                    for (VAR_20 = 0; VAR_20 < VAR_23; VAR_20++)
                      *(VAR_18 + VAR_20) = tolower((int) *(VAR_18 + VAR_20));
                    /* COMMENT_25 */
                    if (strncmp(VAR_18, ""for"", 3) == 0)
                      {
		      /* COMMENT_26 */
                      VAR_23 = strlen (VAR_17 + 1);
                      for (VAR_20 = 1; VAR_20 <= VAR_23; VAR_20++)
                        *(VAR_17 + VAR_20) = tolower((int) *(VAR_17 + VAR_20));
                      /* COMMENT_27 */
		      if (strncmp (VAR_17 + 1, ""txt"", 3) == 0)
                        {
                        VAR_12->format = VAR_47;
                        strcpy (VAR_12->mode, ""w"");
                        }
                      else
                        {
		        if (strncmp(VAR_17 + 1, ""raw"", 3) == 0)
                          {
                          VAR_12->format = VAR_48;
                          strcpy (VAR_12->mode, ""wb"");
                          }
                        else
                          {
                          TIFFError(""parse_command_opts"", ""Unknown dump format %s"", VAR_17 + 1);
                          TIFFError (""For valid options type"", ""tiffcrop -h"");
                          exit (VAR_27);
		          }
			}
                      }
		    else
                      { /* COMMENT_28 */
                      if (strncmp (VAR_18, ""lev"", 3) == 0)
                        VAR_12->level = atoi(VAR_17 + 1);
                        /* COMMENT_29 */
                      if (strncmp (VAR_18, ""in"", 2) == 0)
		        {
                        strncpy (VAR_12->infilename, VAR_17 + 1, VAR_49 - 20);
                        VAR_12->infilename[VAR_49 - 20] = '\0';
                        }
                        /* COMMENT_30 */
                      if (strncmp (VAR_18, ""out"", 3) == 0)
			{
                        strncpy (VAR_12->outfilename, VAR_17 + 1, VAR_49 - 20);
                        VAR_12->outfilename[VAR_49 - 20] = '\0';
                        }
                      if (strncmp (VAR_18, ""deb"", 3) == 0)
			VAR_12->debug = atoi(VAR_17 + 1);
		      }
                    }
	        if ((strlen(VAR_12->infilename)) || (strlen(VAR_12->outfilename)))
                  {
		  if (VAR_12->level == 1)
                    TIFFError("""",""Defaulting to dump level 1, no data."");
	          if (VAR_12->format == VAR_50)
                    {
		    TIFFError("""", ""You must specify a dump format for dump files"");
		    TIFFError (""For valid options type"", ""tiffcrop -h"");
		    exit (VAR_27);
		    }
                  }
	        break;

      /* COMMENT_31 */
      case 'm': /* COMMENT_32 */
		/* COMMENT_33 */
		VAR_10->crop_mode |= VAR_51;
                for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "",:"");
                    ((VAR_18 != NULL) &&  (VAR_20 < 4));
                     (VAR_18 = strtok (NULL, "",:"")), VAR_20++)
                    {
		    VAR_10->margins[VAR_20] = atof(VAR_18);
                    }
		break;
      case 'E':	/* COMMENT_34 */
		switch (tolower((int) VAR_26[0]))
                  {
		  case 't': VAR_10->edge_ref = VAR_52;
                            break;
                  case 'b': VAR_10->edge_ref = VAR_53;
                             break;
                  case 'l': VAR_10->edge_ref = VAR_54;
                            break;
                  case 'r': VAR_10->edge_ref = VAR_55;
                            break;
		  default:  TIFFError (""Edge reference must be top, bottom, left, or right"", ""%s"", VAR_26);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
		  }
		break;
      case 'F': /* COMMENT_35 */
		VAR_10->crop_mode |= VAR_56;
		switch (tolower((int) VAR_26[0]))
                  {
		  case  'h': VAR_10->mirror = VAR_57;
                             break;
                  case  'v': VAR_10->mirror = VAR_58;
                             break;
                  case  'b': VAR_10->mirror = VAR_59;
                             break;
		  default:   TIFFError (""Flip mode must be horiz, vert, or both"", ""%s"", VAR_26);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (VAR_27);
		  }
		break;
      case 'H': /* COMMENT_36 */
		VAR_11->hres = atof (VAR_26);
                VAR_11->mode |= VAR_60;
		break;
      case 'I': /* COMMENT_37 */
		VAR_10->crop_mode |= VAR_61;
                /* COMMENT_38 */
                if (streq(VAR_26, ""black""))
                  {
		  VAR_10->photometric = VAR_62;
		  continue;
                  }
                if (streq(VAR_26, ""white""))
                  {
		  VAR_10->photometric = VAR_63;
                  continue;
                  }
                if (streq(VAR_26, ""data"")) 
                  {
		  VAR_10->photometric = VAR_64;
                  continue;
                  }
                if (streq(VAR_26, ""both""))
                  {
		  VAR_10->photometric = VAR_65;
                  continue;
                  }

		TIFFError(""Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION"", ""%s"", VAR_26);
		TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (VAR_27);
		break;
      case 'J': /* COMMENT_39 */
		VAR_11->hmargin = atof(VAR_26);
                VAR_11->mode |= VAR_66;
		break;
      case 'K': /* COMMENT_40 */
                VAR_11->vmargin = atof(VAR_26);
                VAR_11->mode |= VAR_66;
		break;
      case 'N':	/* COMMENT_41 */
                for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                    ((VAR_18 != NULL) &&  (VAR_20 < VAR_67));
                     (VAR_18 = strtok (NULL, "","")))
                     { /* COMMENT_42 */
                                                      
                                                                         
                                                                         
                                                                
                          
		     if (streq(VAR_18, ""odd""))
                       {
		       for (VAR_21 = 1; VAR_21 <= VAR_67; VAR_21 += 2)
			 VAR_13[VAR_20++] = VAR_21;
                       *VAR_14 = (VAR_67 - 1) / 2;
                       break;
		       }
		     else
                       {
		       if (streq(VAR_18, ""even""))
                         {
			 for (VAR_21 = 2; VAR_21 <= VAR_67; VAR_21 += 2)
			   VAR_13[VAR_20++] = VAR_21;
                         *VAR_14 = VAR_67 / 2;
                         break;
			 }
		       else
                         {
			 if (streq(VAR_18, ""last""))
			   VAR_13[VAR_20++] = VAR_67;
			 else  /* COMMENT_48 */
			   {
			   VAR_19 = strpbrk(VAR_18, "":-"");
			   if (!VAR_19)
			     VAR_13[VAR_20++] = atoi(VAR_18);
                           else
                             {
			     *VAR_19 = '\0';
                             VAR_22 = atoi (VAR_18);
                             if (!strcmp((VAR_19 + 1), ""last""))
			       VAR_23 = VAR_67;
                             else
                               VAR_23 = atoi (VAR_19 + 1);
                             for (VAR_21 = VAR_22; VAR_21 <= VAR_23 && VAR_21 - VAR_22 + VAR_20 < VAR_67; VAR_21++)
			       VAR_13[VAR_20++] = VAR_21;
			     }
			   }
			 }
		      }
		    }
                *VAR_14 = VAR_20;
		break;
      case 'O': /* COMMENT_49 */ 
		switch (tolower((int) VAR_26[0]))
                  {
		  case  'a': VAR_11->orient = VAR_68;
                             break;
		  case  'p': VAR_11->orient = VAR_69;
                             break;
		  case  'l': VAR_11->orient = VAR_70;
                             break;
		  default:  TIFFError (""Orientation must be portrait, landscape, or auto."", ""%s"", VAR_26);
			    TIFFError (""For valid options type"", ""tiffcrop -h"");
                            exit (VAR_27);
		  }
		break;
      case 'P': /* COMMENT_50 */ 
	        if (sscanf(VAR_26, ""%lfx%lf"", &VAR_11->width, &VAR_11->length) == 2)
                  {
                  strcpy (VAR_11->name, ""Custom""); 
                  VAR_11->mode |= VAR_71;
                  break;
                  }
                if (get_page_geometry (VAR_26, VAR_11))
                  {
		  if (!strcmp(VAR_26, ""list""))
                    {
		    TIFFError("""", ""Name            Width   Length (in inches)"");
                    for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
                      TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
                               VAR_73[VAR_20].length);
		    exit (VAR_27);
                    }
     
		  TIFFError (""Invalid paper size"", ""%s"", VAR_26);
                  TIFFError ("""", ""Select one of:"");
		  TIFFError("""", ""Name            Width   Length (in inches)"");
                  for (VAR_20 = 0; VAR_20 < VAR_72 - 1; VAR_20++)
                    TIFFError ("""", ""%-15.15s %5.2f   %5.2f"", 
			       VAR_73[VAR_20].name, VAR_73[VAR_20].width, 
                               VAR_73[VAR_20].length);
		  exit (VAR_27);
		  }
		else
                  {
                  VAR_11->mode |= VAR_71;
		  }
		break;
      case 'R': /* COMMENT_51 */
		VAR_10->crop_mode |= VAR_74;
		switch (strtoul(VAR_26, NULL, 0))
                  {
		  case  90:  VAR_10->rotation = (uint16_t)90;
                             break;
                  case  180: VAR_10->rotation = (uint16_t)180;
                             break;
                  case  270: VAR_10->rotation = (uint16_t)270;
                             break;
		  default:   TIFFError (""Rotation must be 90, 180, or 270 degrees clockwise"", ""%s"", VAR_26);
			     TIFFError (""For valid options type"", ""tiffcrop -h"");
                             exit (VAR_27);
		  }
		break;
      case 'S':	/* COMMENT_52 */
		VAR_19 = strpbrk(VAR_26, "",:"");
		if (VAR_19)
                  {
                  *VAR_19 = '\0';
                  VAR_11->cols = atoi(VAR_26);
                  VAR_11->rows = atoi(VAR_19 +1);
		  }
                else
                  {
                  VAR_11->cols = atoi(VAR_26);
                  VAR_11->rows = atoi(VAR_26);
		  }
                if ((VAR_11->cols * VAR_11->rows) > VAR_75)
                  {
		  TIFFError (""Limit for subdivisions, ie rows x columns, exceeded"", ""%d"", VAR_75);
		  exit (VAR_27);
                  }
                VAR_11->mode |= VAR_76;
		break;
      case 'U':	/* COMMENT_53 */
		if (streq(VAR_26, ""in""))
                  {
		  VAR_10->res_unit = VAR_77;
		  VAR_11->res_unit = VAR_77;
		  }
		else if (streq(VAR_26, ""cm""))
		  {
		  VAR_10->res_unit = VAR_78;
		  VAR_11->res_unit = VAR_78;
		  }
		else if (streq(VAR_26, ""px""))
		  {
		  VAR_10->res_unit = VAR_79;
		  VAR_11->res_unit = VAR_79;
		  }
		else
                  {
		  TIFFError (""Illegal unit of measure"",""%s"", VAR_26);
		  TIFFError (""For valid options type"", ""tiffcrop -h"");
                  exit (VAR_27);
		  }
		break;
      case 'V': /* COMMENT_54 */
		VAR_11->vres = atof (VAR_26);
                VAR_11->mode |= VAR_60;
		break;
      case 'X':	/* COMMENT_55 */
		VAR_10->crop_mode |= VAR_80;
		VAR_10->width = atof(VAR_26);
		break;
      case 'Y':	/* COMMENT_56 */
		VAR_10->crop_mode |= VAR_81;
		VAR_10->length = atof(VAR_26);
		break;
      case 'Z': /* COMMENT_57 */
		VAR_10->crop_mode |= VAR_82;
		for (VAR_20 = 0, VAR_18 = strtok (VAR_26, "","");
                   ((VAR_18 != NULL) &&  (VAR_20 < VAR_46));
                    (VAR_18 = strtok (NULL, "","")), VAR_20++)
                    {
		    VAR_10->zones++;
		    VAR_17 = strchr(VAR_18, ':');
		    if (!VAR_17) {
			TIFFError(""Wrong parameter syntax for -Z"", ""tiffcrop -h"");
			exit(VAR_27);
		    }
                    *VAR_17 = '\0';
                    VAR_10->zonelist[VAR_20].position = atoi(VAR_18);
                    VAR_10->zonelist[VAR_20].total    = atoi(VAR_17 + 1);
                    }
                /* COMMENT_21 */
                if ((VAR_18 != NULL) && (VAR_20 >= VAR_46))
                  {
		  TIFFError(""Zone list exceeds region limit"", ""%d"",  VAR_46);
		  exit (VAR_27);
                  }
		break;
    case '?':	TIFFError (""For valid options type"", ""tiffcrop -h"");
                exit (VAR_27);
		/* COMMENT_58 */
      }
    }
    /* COMMENT_59 */
    char VAR_83, VAR_84, VAR_85, VAR_86;
    VAR_83 = ((VAR_10->crop_mode & VAR_80) || (VAR_10->crop_mode & VAR_81)) ? 1 : 0;
    VAR_84 = (VAR_10->crop_mode & VAR_82) ? 1 : 0;
    VAR_85 = (VAR_10->crop_mode & VAR_45) ? 1 : 0;
    VAR_86 = (VAR_11->mode & VAR_76) ? 1 : 0;
    if (VAR_83 + VAR_84 + VAR_85 + VAR_86 > 1) {
        TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
        exit(VAR_27);
    }
  }",libtiff/bad48e90b410df32172006c7876da449ba62cdba/tiffcrop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -508,11 +508,11 @@
     }
     /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/
     char XY, Z, R, S;
-    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));
-    Z = (crop_data->crop_mode & CROP_ZONES);
-    R = (crop_data->crop_mode & CROP_REGIONS);
-    S = (page->mode & PAGE_MODE_ROWSCOLS);
-    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {
+    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;
+    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;
+    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;
+    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;
+    if (XY + Z + R + S > 1) {
         TIFFError(""tiffcrop input error"", ""The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit"");
         exit(EXIT_FAILURE);
     }","{'deleted_lines': ['    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));', '    Z = (crop_data->crop_mode & CROP_ZONES);', '    R = (crop_data->crop_mode & CROP_REGIONS);', '    S = (page->mode & PAGE_MODE_ROWSCOLS);', '    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {'], 'added_lines': ['    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;', '    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;', '    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;', '    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;', '    if (XY + Z + R + S > 1) {']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",5.5,MEDIUM,1,valid,,5
CVE-2022-3190,['CWE-835'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,wireshark,"f5ethtrailer: Improve ""old-style"" heuristic

Remove a chance for an infinate loop in the disection heuristic.
",0f27a83c5692b2afebe6e6934c1051f76aa2ecf9,https://gitlab.com/wireshark/wireshark/-/commit/0f27a83c5692b2afebe6e6934c1051f76aa2ecf9,epan/dissectors/packet-f5ethtrailer.c,dissect_old_trailer,"static gint
dissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
proto_tree *type_tree   = NULL;
proto_item *ti          = NULL;
guint offset            = 0;
guint processed         = 0;
f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;
guint8 type;
guint8 len;
guint8 ver;
while (tvb_reported_length_remaining(tvb, offset)) {
type = tvb_get_guint8(tvb, offset);
len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;
ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);
if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW
&& type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE
&& ver <= F5TRAILER_VER_MAX) {
switch (type) {
case F5TYPE_LOW:
ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);
type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);
processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
if (processed > 0) {
tdata->trailer_len += processed;
tdata->noise_low = 1;
}
break;
case F5TYPE_MED:
ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);
type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);
processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
if (processed > 0) {
tdata->trailer_len += processed;
tdata->noise_med = 1;
}
break;
case F5TYPE_HIGH:
ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);
type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);
processed =
dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
if (processed > 0) {
tdata->trailer_len += processed;
tdata->noise_high = 1;
}
break;
}
if (processed == 0) {
proto_item_set_len(ti, 1);
return offset;
}
}
offset += processed;
}
return offset;
}","static gint
dissect_old_trailer(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
proto_tree *VAR_4   = NULL;
proto_item *VAR_5          = NULL;
guint VAR_6            = 0;
guint VAR_7         = 0;
f5eth_tap_data_t *VAR_8 = (f5eth_tap_data_t *)VAR_3;
guint8 VAR_9;
guint8 VAR_10;
guint8 VAR_11;
while (tvb_reported_length_remaining(VAR_0, VAR_6)) {
VAR_9 = tvb_get_guint8(VAR_0, VAR_6);
VAR_10 = tvb_get_guint8(VAR_0, VAR_6 + VAR_12) + VAR_13;
VAR_11 = tvb_get_guint8(VAR_0, VAR_6 + VAR_13);
if (VAR_10 <= tvb_reported_length_remaining(VAR_0, VAR_6) && VAR_9 >= VAR_14
&& VAR_9 <= VAR_15 && VAR_10 >= VAR_16 && VAR_10 <= VAR_17
&& VAR_11 <= VAR_18) {
switch (VAR_9) {
case VAR_14:
VAR_5        = proto_tree_add_item(VAR_2, VAR_19, VAR_0, VAR_6, VAR_10, VAR_20);
VAR_4 = proto_item_add_subtree(VAR_5, VAR_21);
VAR_7 = dissect_low_trailer(VAR_0, VAR_1, VAR_4, VAR_6, VAR_10, VAR_11, VAR_8);
if (VAR_7 > 0) {
VAR_8->trailer_len += VAR_7;
VAR_8->noise_low = 1;
}
break;
case VAR_22:
VAR_5        = proto_tree_add_item(VAR_2, VAR_23, VAR_0, VAR_6, VAR_10, VAR_20);
VAR_4 = proto_item_add_subtree(VAR_5, VAR_24);
VAR_7 = dissect_med_trailer(VAR_0, VAR_1, VAR_4, VAR_6, VAR_10, VAR_11, VAR_8);
if (VAR_7 > 0) {
VAR_8->trailer_len += VAR_7;
VAR_8->noise_med = 1;
}
break;
case VAR_15:
VAR_5        = proto_tree_add_item(VAR_2, VAR_25, VAR_0, VAR_6, VAR_10, VAR_20);
VAR_4 = proto_item_add_subtree(VAR_5, VAR_26);
VAR_7 =
dissect_high_trailer(VAR_0, VAR_1, VAR_4, VAR_6, VAR_10, VAR_11, VAR_8);
if (VAR_7 > 0) {
VAR_8->trailer_len += VAR_7;
VAR_8->noise_high = 1;
}
break;
}
if (VAR_7 == 0) {
proto_item_set_len(VAR_5, 1);
return VAR_6;
}
}
VAR_6 += VAR_7;
}
return VAR_6;
}",wireshark/0f27a83c5692b2afebe6e6934c1051f76aa2ecf9/packet-f5ethtrailer.c/vul/before/0.json,"static gint
dissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    guint offset            = 0;

    /* While we still have data in the trailer.  For old format trailers, this needs
     * type, length, version (3 bytes) and for new format trailers, the magic header (4 bytes).
     * All old format trailers are at least 4 bytes long, so just check for length of magic.
     */
    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {
        /* length field does not include the type and length bytes.  Add them back in */
        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;
        if (len > tvb_reported_length_remaining(tvb, offset)
            || len < F5_MIN_SANE || len > F5_MAX_SANE) {
            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */
            return offset;
        }
        guint8 type = tvb_get_guint8(tvb, offset);
        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);

        /* Parse out the specified trailer. */
        proto_tree *type_tree   = NULL;
        proto_item *ti          = NULL;
        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;
        guint processed = 0;

        switch (type) {
        case F5TYPE_LOW:
            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);
            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);

            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
            if (processed > 0) {
                tdata->trailer_len += processed;
                tdata->noise_low = 1;
            }
            break;
        case F5TYPE_MED:
            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);
            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);

            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
            if (processed > 0) {
                tdata->trailer_len += processed;
                tdata->noise_med = 1;
            }
            break;
        case F5TYPE_HIGH:
            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);
            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);

            processed =
                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
            if (processed > 0) {
                tdata->trailer_len += processed;
                tdata->noise_high = 1;
            }
            break;
        default:
            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/
            return offset;
        }
        if (processed == 0) {
            /* couldn't process trailer - bali out */
            proto_item_set_len(ti, 1);
            return offset;
        }
        offset += processed;
    }
    return offset;
}","static gint
dissect_old_trailer(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
    guint VAR_4            = 0;

    /* COMMENT_0 */
                                                                                               
                                                                                            
       
    while (tvb_reported_length_remaining(VAR_0, VAR_4) >= VAR_5) {
        /* COMMENT_4 */
        guint8 VAR_6 = tvb_get_guint8(VAR_0, VAR_4 + VAR_7) + VAR_8;
        if (VAR_6 > tvb_reported_length_remaining(VAR_0, VAR_4)
            || VAR_6 < VAR_5 || VAR_6 > VAR_9) {
            /* COMMENT_5 */
            return VAR_4;
        }
        guint8 VAR_10 = tvb_get_guint8(VAR_0, VAR_4);
        guint8 VAR_11 = tvb_get_guint8(VAR_0, VAR_4 + VAR_8);

        /* COMMENT_6 */
        proto_tree *VAR_12   = NULL;
        proto_item *VAR_13          = NULL;
        f5eth_tap_data_t *VAR_14 = (f5eth_tap_data_t *)VAR_3;
        guint VAR_15 = 0;

        switch (VAR_10) {
        case VAR_16:
            VAR_13        = proto_tree_add_item(VAR_2, VAR_17, VAR_0, VAR_4, VAR_6, VAR_18);
            VAR_12 = proto_item_add_subtree(VAR_13, VAR_19);

            VAR_15 = dissect_low_trailer(VAR_0, VAR_1, VAR_12, VAR_4, VAR_6, VAR_11, VAR_14);
            if (VAR_15 > 0) {
                VAR_14->trailer_len += VAR_15;
                VAR_14->noise_low = 1;
            }
            break;
        case VAR_20:
            VAR_13        = proto_tree_add_item(VAR_2, VAR_21, VAR_0, VAR_4, VAR_6, VAR_18);
            VAR_12 = proto_item_add_subtree(VAR_13, VAR_22);

            VAR_15 = dissect_med_trailer(VAR_0, VAR_1, VAR_12, VAR_4, VAR_6, VAR_11, VAR_14);
            if (VAR_15 > 0) {
                VAR_14->trailer_len += VAR_15;
                VAR_14->noise_med = 1;
            }
            break;
        case VAR_23:
            VAR_13        = proto_tree_add_item(VAR_2, VAR_24, VAR_0, VAR_4, VAR_6, VAR_18);
            VAR_12 = proto_item_add_subtree(VAR_13, VAR_25);

            VAR_15 =
                dissect_high_trailer(VAR_0, VAR_1, VAR_12, VAR_4, VAR_6, VAR_11, VAR_14);
            if (VAR_15 > 0) {
                VAR_14->trailer_len += VAR_15;
                VAR_14->noise_high = 1;
            }
            break;
        default:
            /* COMMENT_7 */
            return VAR_4;
        }
        if (VAR_15 == 0) {
            /* COMMENT_8 */
            proto_item_set_len(VAR_13, 1);
            return VAR_4;
        }
        VAR_4 += VAR_15;
    }
    return VAR_4;
}",wireshark/0f27a83c5692b2afebe6e6934c1051f76aa2ecf9/packet-f5ethtrailer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,67 +1,71 @@
 static gint
 dissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
 {
-    proto_tree *type_tree   = NULL;
-    proto_item *ti          = NULL;
     guint offset            = 0;
-    guint processed         = 0;
-    f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;
-    guint8 type;
-    guint8 len;
-    guint8 ver;
 
     /* While we still have data in the trailer.  For old format trailers, this needs
      * type, length, version (3 bytes) and for new format trailers, the magic header (4 bytes).
      * All old format trailers are at least 4 bytes long, so just check for length of magic.
      */
-    while (tvb_reported_length_remaining(tvb, offset)) {
-        type = tvb_get_guint8(tvb, offset);
-        len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;
-        ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);
+    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {
+        /* length field does not include the type and length bytes.  Add them back in */
+        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;
+        if (len > tvb_reported_length_remaining(tvb, offset)
+            || len < F5_MIN_SANE || len > F5_MAX_SANE) {
+            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */
+            return offset;
+        }
+        guint8 type = tvb_get_guint8(tvb, offset);
+        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);
 
-        if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW
-            && type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE
-            && ver <= F5TRAILER_VER_MAX) {
-            /* Parse out the specified trailer. */
-            switch (type) {
-            case F5TYPE_LOW:
-                ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);
-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);
+        /* Parse out the specified trailer. */
+        proto_tree *type_tree   = NULL;
+        proto_item *ti          = NULL;
+        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;
+        guint processed = 0;
 
-                processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
-                if (processed > 0) {
-                    tdata->trailer_len += processed;
-                    tdata->noise_low = 1;
-                }
-                break;
-            case F5TYPE_MED:
-                ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);
-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);
+        switch (type) {
+        case F5TYPE_LOW:
+            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);
+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);
 
-                processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
-                if (processed > 0) {
-                    tdata->trailer_len += processed;
-                    tdata->noise_med = 1;
-                }
-                break;
-            case F5TYPE_HIGH:
-                ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);
-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);
+            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
+            if (processed > 0) {
+                tdata->trailer_len += processed;
+                tdata->noise_low = 1;
+            }
+            break;
+        case F5TYPE_MED:
+            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);
+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);
 
-                processed =
-                    dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
-                if (processed > 0) {
-                    tdata->trailer_len += processed;
-                    tdata->noise_high = 1;
-                }
-                break;
+            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
+            if (processed > 0) {
+                tdata->trailer_len += processed;
+                tdata->noise_med = 1;
             }
-            if (processed == 0) {
-                proto_item_set_len(ti, 1);
-                return offset;
+            break;
+        case F5TYPE_HIGH:
+            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);
+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);
+
+            processed =
+                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);
+            if (processed > 0) {
+                tdata->trailer_len += processed;
+                tdata->noise_high = 1;
             }
+            break;
+        default:
+            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/
+            return offset;
+        }
+        if (processed == 0) {
+            /* couldn't process trailer - bali out */
+            proto_item_set_len(ti, 1);
+            return offset;
         }
         offset += processed;
     }
-return offset;
+    return offset;
 }","{'deleted_lines': ['    proto_tree *type_tree   = NULL;', '    proto_item *ti          = NULL;', '    guint processed         = 0;', '    f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;', '    guint8 type;', '    guint8 len;', '    guint8 ver;', '    while (tvb_reported_length_remaining(tvb, offset)) {', '        type = tvb_get_guint8(tvb, offset);', '        len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;', '        ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);', '        if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW', '            && type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE', '            && ver <= F5TRAILER_VER_MAX) {', '            /* Parse out the specified trailer. */', '            switch (type) {', '            case F5TYPE_LOW:', '                ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);', '                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);', '                processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '                if (processed > 0) {', '                    tdata->trailer_len += processed;', '                    tdata->noise_low = 1;', '                }', '                break;', '            case F5TYPE_MED:', '                ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);', '                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);', '                processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '                if (processed > 0) {', '                    tdata->trailer_len += processed;', '                    tdata->noise_med = 1;', '                }', '                break;', '            case F5TYPE_HIGH:', '                ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);', '                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);', '                processed =', '                    dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '                if (processed > 0) {', '                    tdata->trailer_len += processed;', '                    tdata->noise_high = 1;', '                }', '                break;', '            if (processed == 0) {', '                proto_item_set_len(ti, 1);', '                return offset;', 'return offset;'], 'added_lines': ['    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {', '        /* length field does not include the type and length bytes.  Add them back in */', '        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;', '        if (len > tvb_reported_length_remaining(tvb, offset)', '            || len < F5_MIN_SANE || len > F5_MAX_SANE) {', '            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */', '            return offset;', '        }', '        guint8 type = tvb_get_guint8(tvb, offset);', '        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);', '        /* Parse out the specified trailer. */', '        proto_tree *type_tree   = NULL;', '        proto_item *ti          = NULL;', '        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;', '        guint processed = 0;', '        switch (type) {', '        case F5TYPE_LOW:', '            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);', '            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);', '            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '            if (processed > 0) {', '                tdata->trailer_len += processed;', '                tdata->noise_low = 1;', '            }', '            break;', '        case F5TYPE_MED:', '            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);', '            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);', '            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '            if (processed > 0) {', '                tdata->trailer_len += processed;', '                tdata->noise_med = 1;', '            break;', '        case F5TYPE_HIGH:', '            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);', '            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);', '', '            processed =', '                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);', '            if (processed > 0) {', '                tdata->trailer_len += processed;', '                tdata->noise_high = 1;', '            break;', '        default:', '            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/', '            return offset;', '        }', '        if (processed == 0) {', ""            /* couldn't process trailer - bali out */"", '            proto_item_set_len(ti, 1);', '            return offset;', '    return offset;']}",True,Infinite loop in the F5 Ethernet Trailer protocol dissector in Wireshark 3.6.0 to 3.6.7 and 3.4.0 to 3.4.15 allows denial of service via packet injection or crafted capture file,5.5,MEDIUM,1,valid,,5
CVE-2022-41849,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"A race condition may occur if the user physically removes the
USB device while calling open() for this device node.

This is a race condition between the ufx_ops_open() function and
the ufx_usb_disconnect() function, which may eventually result in UAF.

So, add a mutex to the ufx_ops_open() and ufx_usb_disconnect() functions
to avoid race contidion of krefs.

Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Cc: stable@vger.kernel.org
Signed-off-by: Helge Deller <deller@gmx.de>
",5610bcfe8693c02e2e4c8b31427f1bdbdecc839c,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5610bcfe8693c02e2e4c8b31427f1bdbdecc839c,drivers/video/fbdev/smscufx.c,ufx_ops_open,"static int ufx_ops_open(struct fb_info *info, int user)
{
struct ufx_data *dev = info->par;
if (user == 0 && !console)
return -EBUSY;
if (dev->virtualized)
return -ENODEV;
dev->fb_count++;
kref_get(&dev->kref);
if (fb_defio && (info->fbdefio == NULL)) {
struct fb_deferred_io *fbdefio;
fbdefio = kzalloc(sizeof(*fbdefio), GFP_KERNEL);
if (fbdefio) {
fbdefio->delay = UFX_DEFIO_WRITE_DELAY;
fbdefio->deferred_io = ufx_dpy_deferred_io;
}
info->fbdefio = fbdefio;
fb_deferred_io_init(info);
}
pr_debug(""open /dev/fb%d user=%d fb_info=%p count=%d"",
info->node, user, info, dev->fb_count);
return 0;
}","static int ufx_ops_open(struct fb_info *VAR_0, int VAR_1)
{
struct ufx_data *VAR_2 = VAR_0->par;
if (VAR_1 == 0 && !VAR_3)
return -VAR_4;
if (VAR_2->virtualized)
return -VAR_5;
VAR_2->fb_count++;
kref_get(&VAR_2->kref);
if (VAR_6 && (VAR_0->fbdefio == NULL)) {
struct fb_deferred_io *VAR_7;
VAR_7 = kzalloc(sizeof(*VAR_7), VAR_8);
if (VAR_7) {
VAR_7->delay = VAR_9;
VAR_7->deferred_io = VAR_10;
}
VAR_0->fbdefio = VAR_7;
fb_deferred_io_init(VAR_0);
}
pr_debug(""open /dev/fb%d user=%d fb_info=%p count=%d"",
VAR_0->node, VAR_1, VAR_0, VAR_2->fb_count);
return 0;
}",torvalds/linux/5610bcfe8693c02e2e4c8b31427f1bdbdecc839c/smscufx.c/vul/before/0.json,"static int ufx_ops_open(struct fb_info *info, int user)
{
	struct ufx_data *dev = info->par;

	/* fbcon aggressively connects to first framebuffer it finds,
	 * preventing other clients (X) from working properly. Usually
	 * not what the user wants. Fail by default with option to enable. */
	if (user == 0 && !console)
		return -EBUSY;

	mutex_lock(&disconnect_mutex);

	/* If the USB device is gone, we don't accept new opens */
	if (dev->virtualized) {
		mutex_unlock(&disconnect_mutex);
		return -ENODEV;
	}

	dev->fb_count++;

	kref_get(&dev->kref);

	if (fb_defio && (info->fbdefio == NULL)) {
		/* enable defio at last moment if not disabled by client */

		struct fb_deferred_io *fbdefio;

		fbdefio = kzalloc(sizeof(*fbdefio), GFP_KERNEL);
		if (fbdefio) {
			fbdefio->delay = UFX_DEFIO_WRITE_DELAY;
			fbdefio->deferred_io = ufx_dpy_deferred_io;
		}

		info->fbdefio = fbdefio;
		fb_deferred_io_init(info);
	}

	pr_debug(""open /dev/fb%d user=%d fb_info=%p count=%d"",
		info->node, user, info, dev->fb_count);

	mutex_unlock(&disconnect_mutex);

	return 0;
}","static int ufx_ops_open(struct fb_info *VAR_0, int VAR_1)
{
	struct ufx_data *VAR_2 = VAR_0->par;

	/* COMMENT_0 */
                                                               
                                                                      
	if (VAR_1 == 0 && !VAR_3)
		return -VAR_4;

	mutex_lock(&VAR_5);

	/* COMMENT_3 */
	if (VAR_2->virtualized) {
		mutex_unlock(&VAR_5);
		return -VAR_6;
	}

	VAR_2->fb_count++;

	kref_get(&VAR_2->kref);

	if (VAR_7 && (VAR_0->fbdefio == NULL)) {
		/* COMMENT_4 */

		struct fb_deferred_io *VAR_8;

		VAR_8 = kzalloc(sizeof(*VAR_8), VAR_9);
		if (VAR_8) {
			VAR_8->delay = VAR_10;
			VAR_8->deferred_io = VAR_11;
		}

		VAR_0->fbdefio = VAR_8;
		fb_deferred_io_init(VAR_0);
	}

	pr_debug(""open /dev/fb%d user=%d fb_info=%p count=%d"",
		VAR_0->node, VAR_1, VAR_0, VAR_2->fb_count);

	mutex_unlock(&VAR_5);

	return 0;
}",torvalds/linux/5610bcfe8693c02e2e4c8b31427f1bdbdecc839c/smscufx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,9 +8,13 @@
 	if (user == 0 && !console)
 		return -EBUSY;
 
+	mutex_lock(&disconnect_mutex);
+
 	/* If the USB device is gone, we don't accept new opens */
-	if (dev->virtualized)
+	if (dev->virtualized) {
+		mutex_unlock(&disconnect_mutex);
 		return -ENODEV;
+	}
 
 	dev->fb_count++;
 
@@ -34,5 +38,7 @@
 	pr_debug(""open /dev/fb%d user=%d fb_info=%p count=%d"",
 		info->node, user, info, dev->fb_count);
 
+	mutex_unlock(&disconnect_mutex);
+
 	return 0;
 }","{'deleted_lines': ['\tif (dev->virtualized)'], 'added_lines': ['\tmutex_lock(&disconnect_mutex);', '', '\tif (dev->virtualized) {', '\t\tmutex_unlock(&disconnect_mutex);', '\t}', '\tmutex_unlock(&disconnect_mutex);', '']}",True,"drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",4.2,MEDIUM,1,valid,,5
CVE-2022-41849,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"A race condition may occur if the user physically removes the
USB device while calling open() for this device node.

This is a race condition between the ufx_ops_open() function and
the ufx_usb_disconnect() function, which may eventually result in UAF.

So, add a mutex to the ufx_ops_open() and ufx_usb_disconnect() functions
to avoid race contidion of krefs.

Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Cc: stable@vger.kernel.org
Signed-off-by: Helge Deller <deller@gmx.de>
",5610bcfe8693c02e2e4c8b31427f1bdbdecc839c,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5610bcfe8693c02e2e4c8b31427f1bdbdecc839c,drivers/video/fbdev/smscufx.c,ufx_usb_disconnect,"static void ufx_usb_disconnect(struct usb_interface *interface)
{
struct ufx_data *dev;
dev = usb_get_intfdata(interface);
pr_debug(""USB disconnect starting\n"");
dev->virtualized = true;
atomic_set(&dev->usb_active, 0);
usb_set_intfdata(interface, NULL);
if (dev->fb_count == 0)
schedule_delayed_work(&dev->free_framebuffer_work, 0);
kref_put(&dev->kref, ufx_free);
}","static void ufx_usb_disconnect(struct usb_interface *VAR_0)
{
struct ufx_data *VAR_1;
VAR_1 = usb_get_intfdata(VAR_0);
pr_debug(""USB disconnect starting\n"");
VAR_1->virtualized = true;
atomic_set(&VAR_1->usb_active, 0);
usb_set_intfdata(VAR_0, NULL);
if (VAR_1->fb_count == 0)
schedule_delayed_work(&VAR_1->free_framebuffer_work, 0);
kref_put(&VAR_1->kref, VAR_2);
}",torvalds/linux/5610bcfe8693c02e2e4c8b31427f1bdbdecc839c/smscufx.c/vul/before/1.json,"static void ufx_usb_disconnect(struct usb_interface *interface)
{
	struct ufx_data *dev;

	mutex_lock(&disconnect_mutex);

	dev = usb_get_intfdata(interface);

	pr_debug(""USB disconnect starting\n"");

	/* we virtualize until all fb clients release. Then we free */
	dev->virtualized = true;

	/* When non-active we'll update virtual framebuffer, but no new urbs */
	atomic_set(&dev->usb_active, 0);

	usb_set_intfdata(interface, NULL);

	/* if clients still have us open, will be freed on last close */
	if (dev->fb_count == 0)
		schedule_delayed_work(&dev->free_framebuffer_work, 0);

	/* release reference taken by kref_init in probe() */
	kref_put(&dev->kref, ufx_free);

	/* consider ufx_data freed */

	mutex_unlock(&disconnect_mutex);
}","static void ufx_usb_disconnect(struct usb_interface *VAR_0)
{
	struct ufx_data *VAR_1;

	mutex_lock(&VAR_2);

	VAR_1 = usb_get_intfdata(VAR_0);

	pr_debug(""USB disconnect starting\n"");

	/* COMMENT_0 */
	VAR_1->virtualized = true;

	/* COMMENT_1 */
	atomic_set(&VAR_1->usb_active, 0);

	usb_set_intfdata(VAR_0, NULL);

	/* COMMENT_2 */
	if (VAR_1->fb_count == 0)
		schedule_delayed_work(&VAR_1->free_framebuffer_work, 0);

	/* COMMENT_3 */
	kref_put(&VAR_1->kref, VAR_3);

	/* COMMENT_4 */

	mutex_unlock(&VAR_2);
}",torvalds/linux/5610bcfe8693c02e2e4c8b31427f1bdbdecc839c/smscufx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 static void ufx_usb_disconnect(struct usb_interface *interface)
 {
 	struct ufx_data *dev;
+
+	mutex_lock(&disconnect_mutex);
 
 	dev = usb_get_intfdata(interface);
 
@@ -22,4 +24,6 @@
 	kref_put(&dev->kref, ufx_free);
 
 	/* consider ufx_data freed */
+
+	mutex_unlock(&disconnect_mutex);
 }","{'deleted_lines': [], 'added_lines': ['', '\tmutex_lock(&disconnect_mutex);', '', '\tmutex_unlock(&disconnect_mutex);']}",True,"drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",4.2,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,kvmppc_h_svm_page_out,"unsigned long
kvmppc_h_svm_page_out(struct kvm *kvm, unsigned long gpa,
unsigned long flags, unsigned long page_shift)
{
unsigned long gfn = gpa >> page_shift;
unsigned long start, end;
struct vm_area_struct *vma;
int srcu_idx;
int ret;
if (!(kvm->arch.secure_guest & KVMPPC_SECURE_INIT_START))
return H_UNSUPPORTED;
if (page_shift != PAGE_SHIFT)
return H_P3;
if (flags)
return H_P2;
ret = H_PARAMETER;
srcu_idx = srcu_read_lock(&kvm->srcu);
mmap_read_lock(kvm->mm);
start = gfn_to_hva(kvm, gfn);
if (kvm_is_error_hva(start))
goto out;
end = start + (1UL << page_shift);
vma = find_vma_intersection(kvm->mm, start, end);
if (!vma || vma->vm_start > start || vma->vm_end < end)
goto out;
if (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa))
ret = H_SUCCESS;
out:
mmap_read_unlock(kvm->mm);
srcu_read_unlock(&kvm->srcu, srcu_idx);
return ret;
}","unsigned long
kvmppc_h_svm_page_out(struct kvm *kvm, unsigned long VAR_0,
unsigned long VAR_1, unsigned long VAR_2)
{
unsigned long VAR_3 = VAR_0 >> VAR_2;
unsigned long VAR_4, VAR_5;
struct vm_area_struct *VAR_6;
int VAR_7;
int VAR_8;
if (!(kvm->arch.secure_guest & VAR_9))
return VAR_10;
if (VAR_2 != VAR_11)
return VAR_12;
if (VAR_1)
return VAR_13;
VAR_8 = VAR_14;
VAR_7 = srcu_read_lock(&kvm->srcu);
mmap_read_lock(kvm->mm);
VAR_4 = gfn_to_hva(kvm, VAR_3);
if (kvm_is_error_hva(VAR_4))
goto out;
VAR_5 = VAR_4 + (1UL << VAR_2);
VAR_6 = find_vma_intersection(kvm->mm, VAR_4, VAR_5);
if (!VAR_6 || VAR_6->vm_start > VAR_4 || VAR_6->vm_end < VAR_5)
goto out;
if (!kvmppc_svm_page_out(VAR_6, VAR_4, VAR_5, VAR_2, kvm, VAR_0))
VAR_8 = VAR_15;
out:
mmap_read_unlock(kvm->mm);
srcu_read_unlock(&kvm->srcu, VAR_7);
return VAR_8;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/0.json,"unsigned long
kvmppc_h_svm_page_out(struct kvm *kvm, unsigned long gpa,
		      unsigned long flags, unsigned long page_shift)
{
	unsigned long gfn = gpa >> page_shift;
	unsigned long start, end;
	struct vm_area_struct *vma;
	int srcu_idx;
	int ret;

	if (!(kvm->arch.secure_guest & KVMPPC_SECURE_INIT_START))
		return H_UNSUPPORTED;

	if (page_shift != PAGE_SHIFT)
		return H_P3;

	if (flags)
		return H_P2;

	ret = H_PARAMETER;
	srcu_idx = srcu_read_lock(&kvm->srcu);
	mmap_read_lock(kvm->mm);
	start = gfn_to_hva(kvm, gfn);
	if (kvm_is_error_hva(start))
		goto out;

	end = start + (1UL << page_shift);
	vma = find_vma_intersection(kvm->mm, start, end);
	if (!vma || vma->vm_start > start || vma->vm_end < end)
		goto out;

	if (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa, NULL))
		ret = H_SUCCESS;
out:
	mmap_read_unlock(kvm->mm);
	srcu_read_unlock(&kvm->srcu, srcu_idx);
	return ret;
}","unsigned long
kvmppc_h_svm_page_out(struct kvm *kvm, unsigned long VAR_0,
		      unsigned long VAR_1, unsigned long VAR_2)
{
	unsigned long VAR_3 = VAR_0 >> VAR_2;
	unsigned long VAR_4, VAR_5;
	struct vm_area_struct *VAR_6;
	int VAR_7;
	int VAR_8;

	if (!(kvm->arch.secure_guest & VAR_9))
		return VAR_10;

	if (VAR_2 != VAR_11)
		return VAR_12;

	if (VAR_1)
		return VAR_13;

	VAR_8 = VAR_14;
	VAR_7 = srcu_read_lock(&kvm->srcu);
	mmap_read_lock(kvm->mm);
	VAR_4 = gfn_to_hva(kvm, VAR_3);
	if (kvm_is_error_hva(VAR_4))
		goto out;

	VAR_5 = VAR_4 + (1UL << VAR_2);
	VAR_6 = find_vma_intersection(kvm->mm, VAR_4, VAR_5);
	if (!VAR_6 || VAR_6->vm_start > VAR_4 || VAR_6->vm_end < VAR_5)
		goto out;

	if (!kvmppc_svm_page_out(VAR_6, VAR_4, VAR_5, VAR_2, kvm, VAR_0, NULL))
		VAR_8 = VAR_15;
out:
	mmap_read_unlock(kvm->mm);
	srcu_read_unlock(&kvm->srcu, VAR_7);
	return VAR_8;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,7 +29,7 @@
 	if (!vma || vma->vm_start > start || vma->vm_end < end)
 		goto out;
 
-	if (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa))
+	if (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa, NULL))
 		ret = H_SUCCESS;
 out:
 	mmap_read_unlock(kvm->mm);","{'deleted_lines': ['\tif (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa))'], 'added_lines': ['\tif (!kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa, NULL))']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,kvmppc_uvmem_drop_pages,"void kvmppc_uvmem_drop_pages(const struct kvm_memory_slot *slot,
struct kvm *kvm, bool skip_page_out)
{
int i;
struct kvmppc_uvmem_page_pvt *pvt;
struct page *uvmem_page;
struct vm_area_struct *vma = NULL;
unsigned long uvmem_pfn, gfn;
unsigned long addr;
mmap_read_lock(kvm->mm);
addr = slot->userspace_addr;
gfn = slot->base_gfn;
for (i = slot->npages; i; --i, ++gfn, addr += PAGE_SIZE) {
if (!vma || addr >= vma->vm_end) {
vma = vma_lookup(kvm->mm, addr);
if (!vma) {
pr_err(""Can't find VMA for gfn:0x%lx\n"", gfn);
break;
}
}
mutex_lock(&kvm->arch.uvmem_lock);
if (kvmppc_gfn_is_uvmem_pfn(gfn, kvm, &uvmem_pfn)) {
uvmem_page = pfn_to_page(uvmem_pfn);
pvt = uvmem_page->zone_device_data;
pvt->skip_page_out = skip_page_out;
pvt->remove_gfn = true;
if (__kvmppc_svm_page_out(vma, addr, addr + PAGE_SIZE,
PAGE_SHIFT, kvm, pvt->gpa))
pr_err(""Can't page out gpa:0x%lx addr:0x%lx\n"",
pvt->gpa, addr);
} else {
kvmppc_gfn_remove(gfn, kvm);
}
mutex_unlock(&kvm->arch.uvmem_lock);
}
mmap_read_unlock(kvm->mm);
}","void kvmppc_uvmem_drop_pages(const struct kvm_memory_slot *VAR_0,
struct kvm *kvm, bool VAR_1)
{
int VAR_2;
struct kvmppc_uvmem_page_pvt *VAR_3;
struct page *VAR_4;
struct vm_area_struct *VAR_5 = NULL;
unsigned long VAR_6, VAR_7;
unsigned long VAR_8;
mmap_read_lock(kvm->mm);
VAR_8 = VAR_0->userspace_addr;
VAR_7 = VAR_0->base_gfn;
for (VAR_2 = VAR_0->npages; VAR_2; --VAR_2, ++VAR_7, VAR_8 += VAR_9) {
if (!VAR_5 || VAR_8 >= VAR_5->vm_end) {
VAR_5 = vma_lookup(kvm->mm, VAR_8);
if (!VAR_5) {
pr_err(""Can't find VMA for gfn:0x%lx\n"", VAR_7);
break;
}
}
mutex_lock(&kvm->arch.uvmem_lock);
if (kvmppc_gfn_is_uvmem_pfn(VAR_7, kvm, &VAR_6)) {
VAR_4 = pfn_to_page(VAR_6);
VAR_3 = VAR_4->zone_device_data;
VAR_3->skip_page_out = VAR_1;
VAR_3->remove_gfn = true;
if (__kvmppc_svm_page_out(VAR_5, VAR_8, VAR_8 + VAR_9,
VAR_10, kvm, VAR_3->gpa))
pr_err(""Can't page out gpa:0x%lx addr:0x%lx\n"",
VAR_3->gpa, VAR_8);
} else {
kvmppc_gfn_remove(VAR_7, kvm);
}
mutex_unlock(&kvm->arch.uvmem_lock);
}
mmap_read_unlock(kvm->mm);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/1.json,"void kvmppc_uvmem_drop_pages(const struct kvm_memory_slot *slot,
			     struct kvm *kvm, bool skip_page_out)
{
	int i;
	struct kvmppc_uvmem_page_pvt *pvt;
	struct page *uvmem_page;
	struct vm_area_struct *vma = NULL;
	unsigned long uvmem_pfn, gfn;
	unsigned long addr;

	mmap_read_lock(kvm->mm);

	addr = slot->userspace_addr;

	gfn = slot->base_gfn;
	for (i = slot->npages; i; --i, ++gfn, addr += PAGE_SIZE) {

		/* Fetch the VMA if addr is not in the latest fetched one */
		if (!vma || addr >= vma->vm_end) {
			vma = vma_lookup(kvm->mm, addr);
			if (!vma) {
				pr_err(""Can't find VMA for gfn:0x%lx\n"", gfn);
				break;
			}
		}

		mutex_lock(&kvm->arch.uvmem_lock);

		if (kvmppc_gfn_is_uvmem_pfn(gfn, kvm, &uvmem_pfn)) {
			uvmem_page = pfn_to_page(uvmem_pfn);
			pvt = uvmem_page->zone_device_data;
			pvt->skip_page_out = skip_page_out;
			pvt->remove_gfn = true;

			if (__kvmppc_svm_page_out(vma, addr, addr + PAGE_SIZE,
						  PAGE_SHIFT, kvm, pvt->gpa, NULL))
				pr_err(""Can't page out gpa:0x%lx addr:0x%lx\n"",
				       pvt->gpa, addr);
		} else {
			/* Remove the shared flag if any */
			kvmppc_gfn_remove(gfn, kvm);
		}

		mutex_unlock(&kvm->arch.uvmem_lock);
	}

	mmap_read_unlock(kvm->mm);
}","void kvmppc_uvmem_drop_pages(const struct kvm_memory_slot *VAR_0,
			     struct kvm *kvm, bool VAR_1)
{
	int VAR_2;
	struct kvmppc_uvmem_page_pvt *VAR_3;
	struct page *VAR_4;
	struct vm_area_struct *VAR_5 = NULL;
	unsigned long VAR_6, VAR_7;
	unsigned long VAR_8;

	mmap_read_lock(kvm->mm);

	VAR_8 = VAR_0->userspace_addr;

	VAR_7 = VAR_0->base_gfn;
	for (VAR_2 = VAR_0->npages; VAR_2; --VAR_2, ++VAR_7, VAR_8 += VAR_9) {

		/* COMMENT_0 */
		if (!VAR_5 || VAR_8 >= VAR_5->vm_end) {
			VAR_5 = vma_lookup(kvm->mm, VAR_8);
			if (!VAR_5) {
				pr_err(""Can't find VMA for gfn:0x%lx\n"", VAR_7);
				break;
			}
		}

		mutex_lock(&kvm->arch.uvmem_lock);

		if (kvmppc_gfn_is_uvmem_pfn(VAR_7, kvm, &VAR_6)) {
			VAR_4 = pfn_to_page(VAR_6);
			VAR_3 = VAR_4->zone_device_data;
			VAR_3->skip_page_out = VAR_1;
			VAR_3->remove_gfn = true;

			if (__kvmppc_svm_page_out(VAR_5, VAR_8, VAR_8 + VAR_9,
						  VAR_10, kvm, VAR_3->gpa, NULL))
				pr_err(""Can't page out gpa:0x%lx addr:0x%lx\n"",
				       VAR_3->gpa, VAR_8);
		} else {
			/* COMMENT_1 */
			kvmppc_gfn_remove(VAR_7, kvm);
		}

		mutex_unlock(&kvm->arch.uvmem_lock);
	}

	mmap_read_unlock(kvm->mm);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,7 +33,7 @@
 			pvt->remove_gfn = true;
 
 			if (__kvmppc_svm_page_out(vma, addr, addr + PAGE_SIZE,
-						  PAGE_SHIFT, kvm, pvt->gpa))
+						  PAGE_SHIFT, kvm, pvt->gpa, NULL))
 				pr_err(""Can't page out gpa:0x%lx addr:0x%lx\n"",
 				       pvt->gpa, addr);
 		} else {","{'deleted_lines': ['\t\t\t\t\t\t  PAGE_SHIFT, kvm, pvt->gpa))'], 'added_lines': ['\t\t\t\t\t\t  PAGE_SHIFT, kvm, pvt->gpa, NULL))']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,__kvmppc_svm_page_out,"static int __kvmppc_svm_page_out(struct vm_area_struct *vma,
unsigned long start,
unsigned long end, unsigned long page_shift,
struct kvm *kvm, unsigned long gpa)
{
unsigned long src_pfn, dst_pfn = 0;
struct migrate_vma mig;
struct page *dpage, *spage;
struct kvmppc_uvmem_page_pvt *pvt;
unsigned long pfn;
int ret = U_SUCCESS;
memset(&mig, 0, sizeof(mig));
mig.vma = vma;
mig.start = start;
mig.end = end;
mig.src = &src_pfn;
mig.dst = &dst_pfn;
mig.pgmap_owner = &kvmppc_uvmem_pgmap;
mig.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;
if (!kvmppc_gfn_is_uvmem_pfn(gpa >> page_shift, kvm, NULL))
return ret;
ret = migrate_vma_setup(&mig);
if (ret)
return -1;
spage = migrate_pfn_to_page(*mig.src);
if (!spage || !(*mig.src & MIGRATE_PFN_MIGRATE))
goto out_finalize;
if (!is_zone_device_page(spage))
goto out_finalize;
dpage = alloc_page_vma(GFP_HIGHUSER, vma, start);
if (!dpage) {
ret = -1;
goto out_finalize;
}
lock_page(dpage);
pvt = spage->zone_device_data;
pfn = page_to_pfn(dpage);
if (!pvt->skip_page_out)
ret = uv_page_out(kvm->arch.lpid, pfn << page_shift,
gpa, 0, page_shift);
if (ret == U_SUCCESS)
*mig.dst = migrate_pfn(pfn);
else {
unlock_page(dpage);
__free_page(dpage);
goto out_finalize;
}
migrate_vma_pages(&mig);
out_finalize:
migrate_vma_finalize(&mig);
return ret;
}","static int __kvmppc_svm_page_out(struct vm_area_struct *VAR_0,
unsigned long VAR_1,
unsigned long VAR_2, unsigned long VAR_3,
struct kvm *kvm, unsigned long VAR_4)
{
unsigned long VAR_5, VAR_6 = 0;
struct migrate_vma VAR_7;
struct page *VAR_8, *VAR_9;
struct kvmppc_uvmem_page_pvt *VAR_10;
unsigned long VAR_11;
int VAR_12 = VAR_13;
memset(&VAR_7, 0, sizeof(VAR_7));
VAR_7.vma = VAR_0;
VAR_7.start = VAR_1;
VAR_7.end = VAR_2;
VAR_7.src = &VAR_5;
VAR_7.dst = &VAR_6;
VAR_7.pgmap_owner = &VAR_14;
VAR_7.flags = VAR_15;
if (!kvmppc_gfn_is_uvmem_pfn(VAR_4 >> VAR_3, kvm, NULL))
return VAR_12;
VAR_12 = migrate_vma_setup(&VAR_7);
if (VAR_12)
return -1;
VAR_9 = migrate_pfn_to_page(*VAR_7.src);
if (!VAR_9 || !(*VAR_7.src & VAR_16))
goto out_finalize;
if (!is_zone_device_page(VAR_9))
goto out_finalize;
VAR_8 = alloc_page_vma(VAR_17, VAR_0, VAR_1);
if (!VAR_8) {
VAR_12 = -1;
goto out_finalize;
}
lock_page(VAR_8);
VAR_10 = VAR_9->zone_device_data;
VAR_11 = page_to_pfn(VAR_8);
if (!VAR_10->skip_page_out)
VAR_12 = uv_page_out(kvm->arch.lpid, VAR_11 << VAR_3,
VAR_4, 0, VAR_3);
if (VAR_12 == VAR_13)
*VAR_7.dst = migrate_pfn(VAR_11);
else {
unlock_page(VAR_8);
__free_page(VAR_8);
goto out_finalize;
}
migrate_vma_pages(&VAR_7);
out_finalize:
migrate_vma_finalize(&VAR_7);
return VAR_12;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/2.json,"static int __kvmppc_svm_page_out(struct vm_area_struct *vma,
		unsigned long start,
		unsigned long end, unsigned long page_shift,
		struct kvm *kvm, unsigned long gpa, struct page *fault_page)
{
	unsigned long src_pfn, dst_pfn = 0;
	struct migrate_vma mig = { 0 };
	struct page *dpage, *spage;
	struct kvmppc_uvmem_page_pvt *pvt;
	unsigned long pfn;
	int ret = U_SUCCESS;

	memset(&mig, 0, sizeof(mig));
	mig.vma = vma;
	mig.start = start;
	mig.end = end;
	mig.src = &src_pfn;
	mig.dst = &dst_pfn;
	mig.pgmap_owner = &kvmppc_uvmem_pgmap;
	mig.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;
	mig.fault_page = fault_page;

	/* The requested page is already paged-out, nothing to do */
	if (!kvmppc_gfn_is_uvmem_pfn(gpa >> page_shift, kvm, NULL))
		return ret;

	ret = migrate_vma_setup(&mig);
	if (ret)
		return -1;

	spage = migrate_pfn_to_page(*mig.src);
	if (!spage || !(*mig.src & MIGRATE_PFN_MIGRATE))
		goto out_finalize;

	if (!is_zone_device_page(spage))
		goto out_finalize;

	dpage = alloc_page_vma(GFP_HIGHUSER, vma, start);
	if (!dpage) {
		ret = -1;
		goto out_finalize;
	}

	lock_page(dpage);
	pvt = spage->zone_device_data;
	pfn = page_to_pfn(dpage);

	/*
	 * This function is used in two cases:
	 * - When HV touches a secure page, for which we do UV_PAGE_OUT
	 * - When a secure page is converted to shared page, we *get*
	 *   the page to essentially unmap the device page. In this
	 *   case we skip page-out.
	 */
	if (!pvt->skip_page_out)
		ret = uv_page_out(kvm->arch.lpid, pfn << page_shift,
				  gpa, 0, page_shift);

	if (ret == U_SUCCESS)
		*mig.dst = migrate_pfn(pfn);
	else {
		unlock_page(dpage);
		__free_page(dpage);
		goto out_finalize;
	}

	migrate_vma_pages(&mig);

out_finalize:
	migrate_vma_finalize(&mig);
	return ret;
}","static int __kvmppc_svm_page_out(struct vm_area_struct *VAR_0,
		unsigned long VAR_1,
		unsigned long VAR_2, unsigned long VAR_3,
		struct kvm *kvm, unsigned long VAR_4, struct page *VAR_5)
{
	unsigned long VAR_6, VAR_7 = 0;
	struct migrate_vma VAR_8 = { 0 };
	struct page *VAR_9, *VAR_10;
	struct kvmppc_uvmem_page_pvt *VAR_11;
	unsigned long VAR_12;
	int VAR_13 = VAR_14;

	memset(&VAR_8, 0, sizeof(VAR_8));
	VAR_8.vma = VAR_0;
	VAR_8.start = VAR_1;
	VAR_8.end = VAR_2;
	VAR_8.src = &VAR_6;
	VAR_8.dst = &VAR_7;
	VAR_8.pgmap_owner = &VAR_15;
	VAR_8.flags = VAR_16;
	VAR_8.fault_page = VAR_5;

	/* COMMENT_0 */
	if (!kvmppc_gfn_is_uvmem_pfn(VAR_4 >> VAR_3, kvm, NULL))
		return VAR_13;

	VAR_13 = migrate_vma_setup(&VAR_8);
	if (VAR_13)
		return -1;

	VAR_10 = migrate_pfn_to_page(*VAR_8.src);
	if (!VAR_10 || !(*VAR_8.src & VAR_17))
		goto out_finalize;

	if (!is_zone_device_page(VAR_10))
		goto out_finalize;

	VAR_9 = alloc_page_vma(VAR_18, VAR_0, VAR_1);
	if (!VAR_9) {
		VAR_13 = -1;
		goto out_finalize;
	}

	lock_page(VAR_9);
	VAR_11 = VAR_10->zone_device_data;
	VAR_12 = page_to_pfn(VAR_9);

	/* COMMENT_1 */
                                       
                                                                
                                                              
                                                            
                            
    
	if (!VAR_11->skip_page_out)
		VAR_13 = uv_page_out(kvm->arch.lpid, VAR_12 << VAR_3,
				  VAR_4, 0, VAR_3);

	if (VAR_13 == VAR_14)
		*VAR_8.dst = migrate_pfn(VAR_12);
	else {
		unlock_page(VAR_9);
		__free_page(VAR_9);
		goto out_finalize;
	}

	migrate_vma_pages(&VAR_8);

out_finalize:
	migrate_vma_finalize(&VAR_8);
	return VAR_13;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,10 +1,10 @@
 static int __kvmppc_svm_page_out(struct vm_area_struct *vma,
 		unsigned long start,
 		unsigned long end, unsigned long page_shift,
-		struct kvm *kvm, unsigned long gpa)
+		struct kvm *kvm, unsigned long gpa, struct page *fault_page)
 {
 	unsigned long src_pfn, dst_pfn = 0;
-	struct migrate_vma mig;
+	struct migrate_vma mig = { 0 };
 	struct page *dpage, *spage;
 	struct kvmppc_uvmem_page_pvt *pvt;
 	unsigned long pfn;
@@ -18,6 +18,7 @@
 	mig.dst = &dst_pfn;
 	mig.pgmap_owner = &kvmppc_uvmem_pgmap;
 	mig.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;
+	mig.fault_page = fault_page;
 
 	/* The requested page is already paged-out, nothing to do */
 	if (!kvmppc_gfn_is_uvmem_pfn(gpa >> page_shift, kvm, NULL))","{'deleted_lines': ['\t\tstruct kvm *kvm, unsigned long gpa)', '\tstruct migrate_vma mig;'], 'added_lines': ['\t\tstruct kvm *kvm, unsigned long gpa, struct page *fault_page)', '\tstruct migrate_vma mig = { 0 };', '\tmig.fault_page = fault_page;']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,kvmppc_svm_page_out,"static inline int kvmppc_svm_page_out(struct vm_area_struct *vma,
unsigned long start, unsigned long end,
unsigned long page_shift,
struct kvm *kvm, unsigned long gpa)
{
int ret;
mutex_lock(&kvm->arch.uvmem_lock);
ret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa);
mutex_unlock(&kvm->arch.uvmem_lock);
return ret;
}","static inline int kvmppc_svm_page_out(struct vm_area_struct *VAR_0,
unsigned long VAR_1, unsigned long VAR_2,
unsigned long VAR_3,
struct kvm *kvm, unsigned long VAR_4)
{
int VAR_5;
mutex_lock(&kvm->arch.uvmem_lock);
VAR_5 = __kvmppc_svm_page_out(VAR_0, VAR_1, VAR_2, VAR_3, kvm, VAR_4);
mutex_unlock(&kvm->arch.uvmem_lock);
return VAR_5;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/3.json,"static inline int kvmppc_svm_page_out(struct vm_area_struct *vma,
				      unsigned long start, unsigned long end,
				      unsigned long page_shift,
				      struct kvm *kvm, unsigned long gpa,
				      struct page *fault_page)
{
	int ret;

	mutex_lock(&kvm->arch.uvmem_lock);
	ret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa,
				fault_page);
	mutex_unlock(&kvm->arch.uvmem_lock);

	return ret;
}","static inline int kvmppc_svm_page_out(struct vm_area_struct *VAR_0,
				      unsigned long VAR_1, unsigned long VAR_2,
				      unsigned long VAR_3,
				      struct kvm *kvm, unsigned long VAR_4,
				      struct page *VAR_5)
{
	int VAR_6;

	mutex_lock(&kvm->arch.uvmem_lock);
	VAR_6 = __kvmppc_svm_page_out(VAR_0, VAR_1, VAR_2, VAR_3, kvm, VAR_4,
				VAR_5);
	mutex_unlock(&kvm->arch.uvmem_lock);

	return VAR_6;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,12 +1,14 @@
 static inline int kvmppc_svm_page_out(struct vm_area_struct *vma,
 				      unsigned long start, unsigned long end,
 				      unsigned long page_shift,
-				      struct kvm *kvm, unsigned long gpa)
+				      struct kvm *kvm, unsigned long gpa,
+				      struct page *fault_page)
 {
 	int ret;
 
 	mutex_lock(&kvm->arch.uvmem_lock);
-	ret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa);
+	ret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa,
+				fault_page);
 	mutex_unlock(&kvm->arch.uvmem_lock);
 
 	return ret;","{'deleted_lines': ['\t\t\t\t      struct kvm *kvm, unsigned long gpa)', '\tret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa);'], 'added_lines': ['\t\t\t\t      struct kvm *kvm, unsigned long gpa,', '\t\t\t\t      struct page *fault_page)', '\tret = __kvmppc_svm_page_out(vma, start, end, page_shift, kvm, gpa,', '\t\t\t\tfault_page);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,kvmppc_svm_page_in,"static int kvmppc_svm_page_in(struct vm_area_struct *vma,
unsigned long start,
unsigned long end, unsigned long gpa, struct kvm *kvm,
unsigned long page_shift,
bool pagein)
{
unsigned long src_pfn, dst_pfn = 0;
struct migrate_vma mig;
struct page *spage;
unsigned long pfn;
struct page *dpage;
int ret = 0;
memset(&mig, 0, sizeof(mig));
mig.vma = vma;
mig.start = start;
mig.end = end;
mig.src = &src_pfn;
mig.dst = &dst_pfn;
mig.flags = MIGRATE_VMA_SELECT_SYSTEM;
ret = migrate_vma_setup(&mig);
if (ret)
return ret;
if (!(*mig.src & MIGRATE_PFN_MIGRATE)) {
ret = -1;
goto out_finalize;
}
dpage = kvmppc_uvmem_get_page(gpa, kvm);
if (!dpage) {
ret = -1;
goto out_finalize;
}
if (pagein) {
pfn = *mig.src >> MIGRATE_PFN_SHIFT;
spage = migrate_pfn_to_page(*mig.src);
if (spage) {
ret = uv_page_in(kvm->arch.lpid, pfn << page_shift,
gpa, 0, page_shift);
if (ret)
goto out_finalize;
}
}
*mig.dst = migrate_pfn(page_to_pfn(dpage));
migrate_vma_pages(&mig);
out_finalize:
migrate_vma_finalize(&mig);
return ret;
}","static int kvmppc_svm_page_in(struct vm_area_struct *VAR_0,
unsigned long VAR_1,
unsigned long VAR_2, unsigned long VAR_3, struct kvm *kvm,
unsigned long VAR_4,
bool VAR_5)
{
unsigned long VAR_6, VAR_7 = 0;
struct migrate_vma VAR_8;
struct page *VAR_9;
unsigned long VAR_10;
struct page *VAR_11;
int VAR_12 = 0;
memset(&VAR_8, 0, sizeof(VAR_8));
VAR_8.vma = VAR_0;
VAR_8.start = VAR_1;
VAR_8.end = VAR_2;
VAR_8.src = &VAR_6;
VAR_8.dst = &VAR_7;
VAR_8.flags = VAR_13;
VAR_12 = migrate_vma_setup(&VAR_8);
if (VAR_12)
return VAR_12;
if (!(*VAR_8.src & VAR_14)) {
VAR_12 = -1;
goto out_finalize;
}
VAR_11 = kvmppc_uvmem_get_page(VAR_3, kvm);
if (!VAR_11) {
VAR_12 = -1;
goto out_finalize;
}
if (VAR_5) {
VAR_10 = *VAR_8.src >> VAR_15;
VAR_9 = migrate_pfn_to_page(*VAR_8.src);
if (VAR_9) {
VAR_12 = uv_page_in(kvm->arch.lpid, VAR_10 << VAR_4,
VAR_3, 0, VAR_4);
if (VAR_12)
goto out_finalize;
}
}
*VAR_8.dst = migrate_pfn(page_to_pfn(VAR_11));
migrate_vma_pages(&VAR_8);
out_finalize:
migrate_vma_finalize(&VAR_8);
return VAR_12;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/4.json,"static int kvmppc_svm_page_in(struct vm_area_struct *vma,
		unsigned long start,
		unsigned long end, unsigned long gpa, struct kvm *kvm,
		unsigned long page_shift,
		bool pagein)
{
	unsigned long src_pfn, dst_pfn = 0;
	struct migrate_vma mig = { 0 };
	struct page *spage;
	unsigned long pfn;
	struct page *dpage;
	int ret = 0;

	memset(&mig, 0, sizeof(mig));
	mig.vma = vma;
	mig.start = start;
	mig.end = end;
	mig.src = &src_pfn;
	mig.dst = &dst_pfn;
	mig.flags = MIGRATE_VMA_SELECT_SYSTEM;

	ret = migrate_vma_setup(&mig);
	if (ret)
		return ret;

	if (!(*mig.src & MIGRATE_PFN_MIGRATE)) {
		ret = -1;
		goto out_finalize;
	}

	dpage = kvmppc_uvmem_get_page(gpa, kvm);
	if (!dpage) {
		ret = -1;
		goto out_finalize;
	}

	if (pagein) {
		pfn = *mig.src >> MIGRATE_PFN_SHIFT;
		spage = migrate_pfn_to_page(*mig.src);
		if (spage) {
			ret = uv_page_in(kvm->arch.lpid, pfn << page_shift,
					gpa, 0, page_shift);
			if (ret)
				goto out_finalize;
		}
	}

	*mig.dst = migrate_pfn(page_to_pfn(dpage));
	migrate_vma_pages(&mig);
out_finalize:
	migrate_vma_finalize(&mig);
	return ret;
}","static int kvmppc_svm_page_in(struct vm_area_struct *VAR_0,
		unsigned long VAR_1,
		unsigned long VAR_2, unsigned long VAR_3, struct kvm *kvm,
		unsigned long VAR_4,
		bool VAR_5)
{
	unsigned long VAR_6, VAR_7 = 0;
	struct migrate_vma VAR_8 = { 0 };
	struct page *VAR_9;
	unsigned long VAR_10;
	struct page *VAR_11;
	int VAR_12 = 0;

	memset(&VAR_8, 0, sizeof(VAR_8));
	VAR_8.vma = VAR_0;
	VAR_8.start = VAR_1;
	VAR_8.end = VAR_2;
	VAR_8.src = &VAR_6;
	VAR_8.dst = &VAR_7;
	VAR_8.flags = VAR_13;

	VAR_12 = migrate_vma_setup(&VAR_8);
	if (VAR_12)
		return VAR_12;

	if (!(*VAR_8.src & VAR_14)) {
		VAR_12 = -1;
		goto out_finalize;
	}

	VAR_11 = kvmppc_uvmem_get_page(VAR_3, kvm);
	if (!VAR_11) {
		VAR_12 = -1;
		goto out_finalize;
	}

	if (VAR_5) {
		VAR_10 = *VAR_8.src >> VAR_15;
		VAR_9 = migrate_pfn_to_page(*VAR_8.src);
		if (VAR_9) {
			VAR_12 = uv_page_in(kvm->arch.lpid, VAR_10 << VAR_4,
					VAR_3, 0, VAR_4);
			if (VAR_12)
				goto out_finalize;
		}
	}

	*VAR_8.dst = migrate_pfn(page_to_pfn(VAR_11));
	migrate_vma_pages(&VAR_8);
out_finalize:
	migrate_vma_finalize(&VAR_8);
	return VAR_12;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 		bool pagein)
 {
 	unsigned long src_pfn, dst_pfn = 0;
-	struct migrate_vma mig;
+	struct migrate_vma mig = { 0 };
 	struct page *spage;
 	unsigned long pfn;
 	struct page *dpage;","{'deleted_lines': ['\tstruct migrate_vma mig;'], 'added_lines': ['\tstruct migrate_vma mig = { 0 };']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,arch/powerpc/kvm/book3s_hv_uvmem.c,kvmppc_uvmem_migrate_to_ram,"static vm_fault_t kvmppc_uvmem_migrate_to_ram(struct vm_fault *vmf)
{
struct kvmppc_uvmem_page_pvt *pvt = vmf->page->zone_device_data;
if (kvmppc_svm_page_out(vmf->vma, vmf->address,
vmf->address + PAGE_SIZE, PAGE_SHIFT,
pvt->kvm, pvt->gpa))
return VM_FAULT_SIGBUS;
else
return 0;
}","static vm_fault_t kvmppc_uvmem_migrate_to_ram(struct vm_fault *VAR_0)
{
struct kvmppc_uvmem_page_pvt *VAR_1 = VAR_0->page->zone_device_data;
if (kvmppc_svm_page_out(VAR_0->vma, VAR_0->address,
VAR_0->address + VAR_2, VAR_3,
VAR_1->kvm, VAR_1->gpa))
return VAR_4;
else
return 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/before/5.json,"static vm_fault_t kvmppc_uvmem_migrate_to_ram(struct vm_fault *vmf)
{
	struct kvmppc_uvmem_page_pvt *pvt = vmf->page->zone_device_data;

	if (kvmppc_svm_page_out(vmf->vma, vmf->address,
				vmf->address + PAGE_SIZE, PAGE_SHIFT,
				pvt->kvm, pvt->gpa, vmf->page))
		return VM_FAULT_SIGBUS;
	else
		return 0;
}","static vm_fault_t kvmppc_uvmem_migrate_to_ram(struct vm_fault *VAR_0)
{
	struct kvmppc_uvmem_page_pvt *VAR_1 = VAR_0->page->zone_device_data;

	if (kvmppc_svm_page_out(VAR_0->vma, VAR_0->address,
				VAR_0->address + VAR_2, VAR_3,
				VAR_1->kvm, VAR_1->gpa, VAR_0->page))
		return VAR_4;
	else
		return 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/book3s_hv_uvmem.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 
 	if (kvmppc_svm_page_out(vmf->vma, vmf->address,
 				vmf->address + PAGE_SIZE, PAGE_SHIFT,
-				pvt->kvm, pvt->gpa))
+				pvt->kvm, pvt->gpa, vmf->page))
 		return VM_FAULT_SIGBUS;
 	else
 		return 0;","{'deleted_lines': ['\t\t\t\tpvt->kvm, pvt->gpa))'], 'added_lines': ['\t\t\t\tpvt->kvm, pvt->gpa, vmf->page))']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/migrate.c,migrate_folio,"int migrate_folio(struct address_space *mapping, struct folio *dst,
struct folio *src, enum migrate_mode mode)
{
int rc;
BUG_ON(folio_test_writeback(src));
rc = folio_migrate_mapping(mapping, dst, src, 0);
if (rc != MIGRATEPAGE_SUCCESS)
return rc;
if (mode != MIGRATE_SYNC_NO_COPY)
folio_migrate_copy(dst, src);
else
folio_migrate_flags(dst, src);
return MIGRATEPAGE_SUCCESS;
}","int migrate_folio(struct address_space *VAR_0, struct folio *VAR_1,
struct folio *VAR_2, enum migrate_mode VAR_3)
{
int VAR_4;
BUG_ON(folio_test_writeback(VAR_2));
VAR_4 = folio_migrate_mapping(VAR_0, VAR_1, VAR_2, 0);
if (VAR_4 != VAR_5)
return VAR_4;
if (VAR_3 != VAR_6)
folio_migrate_copy(VAR_1, VAR_2);
else
folio_migrate_flags(VAR_1, VAR_2);
return VAR_5;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate.c/vul/before/0.json,"int migrate_folio(struct address_space *mapping, struct folio *dst,
		struct folio *src, enum migrate_mode mode)
{
	return migrate_folio_extra(mapping, dst, src, mode, 0);
}","int migrate_folio(struct address_space *VAR_0, struct folio *VAR_1,
		struct folio *VAR_2, enum migrate_mode VAR_3)
{
	return migrate_folio_extra(VAR_0, VAR_1, VAR_2, VAR_3, 0);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,18 +1,5 @@
 int migrate_folio(struct address_space *mapping, struct folio *dst,
 		struct folio *src, enum migrate_mode mode)
 {
-	int rc;
-
-	BUG_ON(folio_test_writeback(src));	/* Writeback must be complete */
-
-	rc = folio_migrate_mapping(mapping, dst, src, 0);
-
-	if (rc != MIGRATEPAGE_SUCCESS)
-		return rc;
-
-	if (mode != MIGRATE_SYNC_NO_COPY)
-		folio_migrate_copy(dst, src);
-	else
-		folio_migrate_flags(dst, src);
-	return MIGRATEPAGE_SUCCESS;
+	return migrate_folio_extra(mapping, dst, src, mode, 0);
 }","{'deleted_lines': ['\tint rc;', '', '\tBUG_ON(folio_test_writeback(src));\t/* Writeback must be complete */', '', '\trc = folio_migrate_mapping(mapping, dst, src, 0);', '', '\tif (rc != MIGRATEPAGE_SUCCESS)', '\t\treturn rc;', '', '\tif (mode != MIGRATE_SYNC_NO_COPY)', '\t\tfolio_migrate_copy(dst, src);', '\telse', '\t\tfolio_migrate_flags(dst, src);', '\treturn MIGRATEPAGE_SUCCESS;'], 'added_lines': ['\treturn migrate_folio_extra(mapping, dst, src, mode, 0);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_svm.c,svm_range_evict_svm_bo_worker,"static void svm_range_evict_svm_bo_worker(struct work_struct *work)
{
struct svm_range_bo *svm_bo;
struct mm_struct *mm;
int r = 0;
svm_bo = container_of(work, struct svm_range_bo, eviction_work);
if (!svm_bo_ref_unless_zero(svm_bo))
return; 
if (mmget_not_zero(svm_bo->eviction_fence->mm)) {
mm = svm_bo->eviction_fence->mm;
} else {
svm_range_bo_unref(svm_bo);
return;
}
mmap_read_lock(mm);
spin_lock(&svm_bo->list_lock);
while (!list_empty(&svm_bo->range_list) && !r) {
struct svm_range *prange =
list_first_entry(&svm_bo->range_list,
struct svm_range, svm_bo_list);
int retries = 3;
list_del_init(&prange->svm_bo_list);
spin_unlock(&svm_bo->list_lock);
pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", prange->svms,
prange->start, prange->last);
mutex_lock(&prange->migrate_mutex);
do {
r = svm_migrate_vram_to_ram(prange, mm,
KFD_MIGRATE_TRIGGER_TTM_EVICTION);
} while (!r && prange->actual_loc && --retries);
if (!r && prange->actual_loc)
pr_info_once(""Migration failed during eviction"");
if (!prange->actual_loc) {
mutex_lock(&prange->lock);
prange->svm_bo = NULL;
mutex_unlock(&prange->lock);
}
mutex_unlock(&prange->migrate_mutex);
spin_lock(&svm_bo->list_lock);
}
spin_unlock(&svm_bo->list_lock);
mmap_read_unlock(mm);
mmput(mm);
dma_fence_signal(&svm_bo->eviction_fence->base);
WARN_ONCE(!r && kref_read(&svm_bo->kref) != 1, ""This was not the last reference\n"");
svm_range_bo_unref(svm_bo);
}","static void svm_range_evict_svm_bo_worker(struct work_struct *VAR_0)
{
struct svm_range_bo *VAR_1;
struct mm_struct *VAR_2;
int VAR_3 = 0;
VAR_1 = container_of(VAR_0, struct svm_range_bo, VAR_4);
if (!svm_bo_ref_unless_zero(VAR_1))
return; 
if (mmget_not_zero(VAR_1->eviction_fence->mm)) {
VAR_2 = VAR_1->eviction_fence->mm;
} else {
svm_range_bo_unref(VAR_1);
return;
}
mmap_read_lock(VAR_2);
spin_lock(&VAR_1->list_lock);
while (!list_empty(&VAR_1->range_list) && !VAR_3) {
struct svm_range *VAR_5 =
list_first_entry(&VAR_1->range_list,
struct svm_range, VAR_6);
int VAR_7 = 3;
list_del_init(&VAR_5->svm_bo_list);
spin_unlock(&VAR_1->list_lock);
pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", VAR_5->svms,
VAR_5->start, VAR_5->last);
mutex_lock(&VAR_5->migrate_mutex);
do {
VAR_3 = svm_migrate_vram_to_ram(VAR_5, VAR_2,
VAR_8);
} while (!VAR_3 && VAR_5->actual_loc && --VAR_7);
if (!VAR_3 && VAR_5->actual_loc)
pr_info_once(""Migration failed during eviction"");
if (!VAR_5->actual_loc) {
mutex_lock(&VAR_5->lock);
VAR_5->svm_bo = NULL;
mutex_unlock(&VAR_5->lock);
}
mutex_unlock(&VAR_5->migrate_mutex);
spin_lock(&VAR_1->list_lock);
}
spin_unlock(&VAR_1->list_lock);
mmap_read_unlock(VAR_2);
mmput(VAR_2);
dma_fence_signal(&VAR_1->eviction_fence->base);
WARN_ONCE(!VAR_3 && kref_read(&VAR_1->kref) != 1, ""This was not the last reference\n"");
svm_range_bo_unref(VAR_1);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/before/0.json,"static void svm_range_evict_svm_bo_worker(struct work_struct *work)
{
	struct svm_range_bo *svm_bo;
	struct mm_struct *mm;
	int r = 0;

	svm_bo = container_of(work, struct svm_range_bo, eviction_work);
	if (!svm_bo_ref_unless_zero(svm_bo))
		return; /* svm_bo was freed while eviction was pending */

	if (mmget_not_zero(svm_bo->eviction_fence->mm)) {
		mm = svm_bo->eviction_fence->mm;
	} else {
		svm_range_bo_unref(svm_bo);
		return;
	}

	mmap_read_lock(mm);
	spin_lock(&svm_bo->list_lock);
	while (!list_empty(&svm_bo->range_list) && !r) {
		struct svm_range *prange =
				list_first_entry(&svm_bo->range_list,
						struct svm_range, svm_bo_list);
		int retries = 3;

		list_del_init(&prange->svm_bo_list);
		spin_unlock(&svm_bo->list_lock);

		pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", prange->svms,
			 prange->start, prange->last);

		mutex_lock(&prange->migrate_mutex);
		do {
			r = svm_migrate_vram_to_ram(prange, mm,
					KFD_MIGRATE_TRIGGER_TTM_EVICTION, NULL);
		} while (!r && prange->actual_loc && --retries);

		if (!r && prange->actual_loc)
			pr_info_once(""Migration failed during eviction"");

		if (!prange->actual_loc) {
			mutex_lock(&prange->lock);
			prange->svm_bo = NULL;
			mutex_unlock(&prange->lock);
		}
		mutex_unlock(&prange->migrate_mutex);

		spin_lock(&svm_bo->list_lock);
	}
	spin_unlock(&svm_bo->list_lock);
	mmap_read_unlock(mm);
	mmput(mm);

	dma_fence_signal(&svm_bo->eviction_fence->base);

	/* This is the last reference to svm_bo, after svm_range_vram_node_free
	 * has been called in svm_migrate_vram_to_ram
	 */
	WARN_ONCE(!r && kref_read(&svm_bo->kref) != 1, ""This was not the last reference\n"");
	svm_range_bo_unref(svm_bo);
}","static void svm_range_evict_svm_bo_worker(struct work_struct *VAR_0)
{
	struct svm_range_bo *VAR_1;
	struct mm_struct *VAR_2;
	int VAR_3 = 0;

	VAR_1 = container_of(VAR_0, struct svm_range_bo, VAR_4);
	if (!svm_bo_ref_unless_zero(VAR_1))
		return; /* COMMENT_0 */

	if (mmget_not_zero(VAR_1->eviction_fence->mm)) {
		VAR_2 = VAR_1->eviction_fence->mm;
	} else {
		svm_range_bo_unref(VAR_1);
		return;
	}

	mmap_read_lock(VAR_2);
	spin_lock(&VAR_1->list_lock);
	while (!list_empty(&VAR_1->range_list) && !VAR_3) {
		struct svm_range *VAR_5 =
				list_first_entry(&VAR_1->range_list,
						struct svm_range, VAR_6);
		int VAR_7 = 3;

		list_del_init(&VAR_5->svm_bo_list);
		spin_unlock(&VAR_1->list_lock);

		pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", VAR_5->svms,
			 VAR_5->start, VAR_5->last);

		mutex_lock(&VAR_5->migrate_mutex);
		do {
			VAR_3 = svm_migrate_vram_to_ram(VAR_5, VAR_2,
					VAR_8, NULL);
		} while (!VAR_3 && VAR_5->actual_loc && --VAR_7);

		if (!VAR_3 && VAR_5->actual_loc)
			pr_info_once(""Migration failed during eviction"");

		if (!VAR_5->actual_loc) {
			mutex_lock(&VAR_5->lock);
			VAR_5->svm_bo = NULL;
			mutex_unlock(&VAR_5->lock);
		}
		mutex_unlock(&VAR_5->migrate_mutex);

		spin_lock(&VAR_1->list_lock);
	}
	spin_unlock(&VAR_1->list_lock);
	mmap_read_unlock(VAR_2);
	mmput(VAR_2);

	dma_fence_signal(&VAR_1->eviction_fence->base);

	/* COMMENT_1 */
                                              
    
	WARN_ONCE(!VAR_3 && kref_read(&VAR_1->kref) != 1, ""This was not the last reference\n"");
	svm_range_bo_unref(VAR_1);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,7 +32,7 @@
 		mutex_lock(&prange->migrate_mutex);
 		do {
 			r = svm_migrate_vram_to_ram(prange, mm,
-						KFD_MIGRATE_TRIGGER_TTM_EVICTION);
+					KFD_MIGRATE_TRIGGER_TTM_EVICTION, NULL);
 		} while (!r && prange->actual_loc && --retries);
 
 		if (!r && prange->actual_loc)","{'deleted_lines': ['\t\t\t\t\t\tKFD_MIGRATE_TRIGGER_TTM_EVICTION);'], 'added_lines': ['\t\t\t\t\tKFD_MIGRATE_TRIGGER_TTM_EVICTION, NULL);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_svm.c,svm_range_trigger_migration,"static int
svm_range_trigger_migration(struct mm_struct *mm, struct svm_range *prange,
bool *migrated)
{
uint32_t best_loc;
int r = 0;
*migrated = false;
best_loc = svm_range_best_prefetch_location(prange);
if (best_loc == KFD_IOCTL_SVM_LOCATION_UNDEFINED ||
best_loc == prange->actual_loc)
return 0;
if (!best_loc) {
r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PREFETCH);
*migrated = !r;
return r;
}
r = svm_migrate_to_vram(prange, best_loc, mm, KFD_MIGRATE_TRIGGER_PREFETCH);
*migrated = !r;
return r;
}","static int
svm_range_trigger_migration(struct mm_struct *VAR_0, struct svm_range *VAR_1,
bool *VAR_2)
{
uint32_t VAR_3;
int VAR_4 = 0;
*VAR_2 = false;
VAR_3 = svm_range_best_prefetch_location(VAR_1);
if (VAR_3 == VAR_5 ||
VAR_3 == VAR_1->actual_loc)
return 0;
if (!VAR_3) {
VAR_4 = svm_migrate_vram_to_ram(VAR_1, VAR_0, VAR_6);
*VAR_2 = !VAR_4;
return VAR_4;
}
VAR_4 = svm_migrate_to_vram(VAR_1, VAR_3, VAR_0, VAR_6);
*VAR_2 = !VAR_4;
return VAR_4;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/before/1.json,"static int
svm_range_trigger_migration(struct mm_struct *mm, struct svm_range *prange,
			    bool *migrated)
{
	uint32_t best_loc;
	int r = 0;

	*migrated = false;
	best_loc = svm_range_best_prefetch_location(prange);

	if (best_loc == KFD_IOCTL_SVM_LOCATION_UNDEFINED ||
	    best_loc == prange->actual_loc)
		return 0;

	if (!best_loc) {
		r = svm_migrate_vram_to_ram(prange, mm,
					KFD_MIGRATE_TRIGGER_PREFETCH, NULL);
		*migrated = !r;
		return r;
	}

	r = svm_migrate_to_vram(prange, best_loc, mm, KFD_MIGRATE_TRIGGER_PREFETCH);
	*migrated = !r;

	return r;
}","static int
svm_range_trigger_migration(struct mm_struct *VAR_0, struct svm_range *VAR_1,
			    bool *VAR_2)
{
	uint32_t VAR_3;
	int VAR_4 = 0;

	*VAR_2 = false;
	VAR_3 = svm_range_best_prefetch_location(VAR_1);

	if (VAR_3 == VAR_5 ||
	    VAR_3 == VAR_1->actual_loc)
		return 0;

	if (!VAR_3) {
		VAR_4 = svm_migrate_vram_to_ram(VAR_1, VAR_0,
					VAR_6, NULL);
		*VAR_2 = !VAR_4;
		return VAR_4;
	}

	VAR_4 = svm_migrate_to_vram(VAR_1, VAR_3, VAR_0, VAR_6);
	*VAR_2 = !VAR_4;

	return VAR_4;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -13,7 +13,8 @@
 		return 0;
 
 	if (!best_loc) {
-		r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PREFETCH);
+		r = svm_migrate_vram_to_ram(prange, mm,
+					KFD_MIGRATE_TRIGGER_PREFETCH, NULL);
 		*migrated = !r;
 		return r;
 	}","{'deleted_lines': ['\t\tr = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PREFETCH);'], 'added_lines': ['\t\tr = svm_migrate_vram_to_ram(prange, mm,', '\t\t\t\t\tKFD_MIGRATE_TRIGGER_PREFETCH, NULL);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_svm.c,svm_range_restore_pages,"int
svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,
uint64_t addr, bool write_fault)
{
struct mm_struct *mm = NULL;
struct svm_range_list *svms;
struct svm_range *prange;
struct kfd_process *p;
ktime_t timestamp = ktime_get_boottime();
int32_t best_loc;
int32_t gpuidx = MAX_GPU_INSTANCE;
bool write_locked = false;
struct vm_area_struct *vma;
bool migration = false;
int r = 0;
if (!KFD_IS_SVM_API_SUPPORTED(adev->kfd.dev)) {
pr_debug(""device does not support SVM\n"");
return -EFAULT;
}
p = kfd_lookup_process_by_pasid(pasid);
if (!p) {
pr_debug(""kfd process not founded pasid 0x%x\n"", pasid);
return 0;
}
svms = &p->svms;
pr_debug(""restoring svms 0x%p fault address 0x%llx\n"", svms, addr);
if (atomic_read(&svms->drain_pagefaults)) {
pr_debug(""draining retry fault, drop fault 0x%llx\n"", addr);
r = 0;
goto out;
}
if (!p->xnack_enabled) {
pr_debug(""XNACK not enabled for pasid 0x%x\n"", pasid);
r = -EFAULT;
goto out;
}
mm = get_task_mm(p->lead_thread);
if (!mm) {
pr_debug(""svms 0x%p failed to get mm\n"", svms);
r = 0;
goto out;
}
mmap_read_lock(mm);
retry_write_locked:
mutex_lock(&svms->lock);
prange = svm_range_from_addr(svms, addr, NULL);
if (!prange) {
pr_debug(""failed to find prange svms 0x%p address [0x%llx]\n"",
svms, addr);
if (!write_locked) {
mutex_unlock(&svms->lock);
mmap_read_unlock(mm);
mmap_write_lock(mm);
write_locked = true;
goto retry_write_locked;
}
prange = svm_range_create_unregistered_range(adev, p, mm, addr);
if (!prange) {
pr_debug(""failed to create unregistered range svms 0x%p address [0x%llx]\n"",
svms, addr);
mmap_write_downgrade(mm);
r = -EFAULT;
goto out_unlock_svms;
}
}
if (write_locked)
mmap_write_downgrade(mm);
mutex_lock(&prange->migrate_mutex);
if (svm_range_skip_recover(prange)) {
amdgpu_gmc_filter_faults_remove(adev, addr, pasid);
r = 0;
goto out_unlock_range;
}
if (ktime_before(timestamp, ktime_add_ns(prange->validate_timestamp,
AMDGPU_SVM_RANGE_RETRY_FAULT_PENDING))) {
pr_debug(""svms 0x%p [0x%lx %lx] already restored\n"",
svms, prange->start, prange->last);
r = 0;
goto out_unlock_range;
}
vma = find_vma(mm, addr << PAGE_SHIFT);
if (!vma || (addr << PAGE_SHIFT) < vma->vm_start) {
pr_debug(""address 0x%llx VMA is removed\n"", addr);
r = 0;
goto out_unlock_range;
}
if (!svm_fault_allowed(vma, write_fault)) {
pr_debug(""fault addr 0x%llx no %s permission\n"", addr,
write_fault ? ""write"" : ""read"");
r = -EPERM;
goto out_unlock_range;
}
best_loc = svm_range_best_restore_location(prange, adev, &gpuidx);
if (best_loc == -1) {
pr_debug(""svms %p failed get best restore loc [0x%lx 0x%lx]\n"",
svms, prange->start, prange->last);
r = -EACCES;
goto out_unlock_range;
}
pr_debug(""svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\n"",
svms, prange->start, prange->last, best_loc,
prange->actual_loc);
kfd_smi_event_page_fault_start(adev->kfd.dev, p->lead_thread->pid, addr,
write_fault, timestamp);
if (prange->actual_loc != best_loc) {
migration = true;
if (best_loc) {
r = svm_migrate_to_vram(prange, best_loc, mm,
KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
if (r) {
pr_debug(""svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\n"",
r, addr);
if (prange->actual_loc)
r = svm_migrate_vram_to_ram(prange, mm,
KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
else
r = 0;
}
} else {
r = svm_migrate_vram_to_ram(prange, mm,
KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
}
if (r) {
pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"",
r, svms, prange->start, prange->last);
goto out_unlock_range;
}
}
r = svm_range_validate_and_map(mm, prange, gpuidx, false, false, false);
if (r)
pr_debug(""failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\n"",
r, svms, prange->start, prange->last);
kfd_smi_event_page_fault_end(adev->kfd.dev, p->lead_thread->pid, addr,
migration);
out_unlock_range:
mutex_unlock(&prange->migrate_mutex);
out_unlock_svms:
mutex_unlock(&svms->lock);
mmap_read_unlock(mm);
svm_range_count_fault(adev, p, gpuidx);
mmput(mm);
out:
kfd_unref_process(p);
if (r == -EAGAIN) {
pr_debug(""recover vm fault later\n"");
amdgpu_gmc_filter_faults_remove(adev, addr, pasid);
r = 0;
}
return r;
}","int
svm_range_restore_pages(struct amdgpu_device *VAR_0, unsigned int VAR_1,
uint64_t VAR_2, bool VAR_3)
{
struct mm_struct *VAR_4 = NULL;
struct svm_range_list *VAR_5;
struct svm_range *VAR_6;
struct kfd_process *VAR_7;
ktime_t VAR_8 = ktime_get_boottime();
int32_t VAR_9;
int32_t VAR_10 = VAR_11;
bool VAR_12 = false;
struct vm_area_struct *VAR_13;
bool VAR_14 = false;
int VAR_15 = 0;
if (!KFD_IS_SVM_API_SUPPORTED(VAR_0->kfd.dev)) {
pr_debug(""device does not support SVM\n"");
return -VAR_16;
}
VAR_7 = kfd_lookup_process_by_pasid(VAR_1);
if (!VAR_7) {
pr_debug(""kfd process not founded pasid 0x%x\n"", VAR_1);
return 0;
}
VAR_5 = &VAR_7->svms;
pr_debug(""restoring svms 0x%p fault address 0x%llx\n"", VAR_5, VAR_2);
if (atomic_read(&VAR_5->drain_pagefaults)) {
pr_debug(""draining retry fault, drop fault 0x%llx\n"", VAR_2);
VAR_15 = 0;
goto out;
}
if (!VAR_7->xnack_enabled) {
pr_debug(""XNACK not enabled for pasid 0x%x\n"", VAR_1);
VAR_15 = -VAR_16;
goto out;
}
VAR_4 = get_task_mm(VAR_7->lead_thread);
if (!VAR_4) {
pr_debug(""svms 0x%p failed to get mm\n"", VAR_5);
VAR_15 = 0;
goto out;
}
mmap_read_lock(VAR_4);
retry_write_locked:
mutex_lock(&VAR_5->lock);
VAR_6 = svm_range_from_addr(VAR_5, VAR_2, NULL);
if (!VAR_6) {
pr_debug(""failed to find prange svms 0x%p address [0x%llx]\n"",
VAR_5, VAR_2);
if (!VAR_12) {
mutex_unlock(&VAR_5->lock);
mmap_read_unlock(VAR_4);
mmap_write_lock(VAR_4);
VAR_12 = true;
goto retry_write_locked;
}
VAR_6 = svm_range_create_unregistered_range(VAR_0, VAR_7, VAR_4, VAR_2);
if (!VAR_6) {
pr_debug(""failed to create unregistered range svms 0x%p address [0x%llx]\n"",
VAR_5, VAR_2);
mmap_write_downgrade(VAR_4);
VAR_15 = -VAR_16;
goto out_unlock_svms;
}
}
if (VAR_12)
mmap_write_downgrade(VAR_4);
mutex_lock(&VAR_6->migrate_mutex);
if (svm_range_skip_recover(VAR_6)) {
amdgpu_gmc_filter_faults_remove(VAR_0, VAR_2, VAR_1);
VAR_15 = 0;
goto out_unlock_range;
}
if (ktime_before(VAR_8, ktime_add_ns(VAR_6->validate_timestamp,
VAR_17))) {
pr_debug(""svms 0x%p [0x%lx %lx] already restored\n"",
VAR_5, VAR_6->start, VAR_6->last);
VAR_15 = 0;
goto out_unlock_range;
}
VAR_13 = find_vma(VAR_4, VAR_2 << VAR_18);
if (!VAR_13 || (VAR_2 << VAR_18) < VAR_13->vm_start) {
pr_debug(""address 0x%llx VMA is removed\n"", VAR_2);
VAR_15 = 0;
goto out_unlock_range;
}
if (!svm_fault_allowed(VAR_13, VAR_3)) {
pr_debug(""fault addr 0x%llx no %s permission\n"", VAR_2,
VAR_3 ? ""write"" : ""read"");
VAR_15 = -VAR_19;
goto out_unlock_range;
}
VAR_9 = svm_range_best_restore_location(VAR_6, VAR_0, &VAR_10);
if (VAR_9 == -1) {
pr_debug(""svms %p failed get best restore loc [0x%lx 0x%lx]\n"",
VAR_5, VAR_6->start, VAR_6->last);
VAR_15 = -VAR_20;
goto out_unlock_range;
}
pr_debug(""svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\n"",
VAR_5, VAR_6->start, VAR_6->last, VAR_9,
VAR_6->actual_loc);
kfd_smi_event_page_fault_start(VAR_0->kfd.dev, VAR_7->lead_thread->pid, VAR_2,
VAR_3, VAR_8);
if (VAR_6->actual_loc != VAR_9) {
VAR_14 = true;
if (VAR_9) {
VAR_15 = svm_migrate_to_vram(VAR_6, VAR_9, VAR_4,
VAR_21);
if (VAR_15) {
pr_debug(""svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\n"",
VAR_15, VAR_2);
if (VAR_6->actual_loc)
VAR_15 = svm_migrate_vram_to_ram(VAR_6, VAR_4,
VAR_21);
else
VAR_15 = 0;
}
} else {
VAR_15 = svm_migrate_vram_to_ram(VAR_6, VAR_4,
VAR_21);
}
if (VAR_15) {
pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"",
VAR_15, VAR_5, VAR_6->start, VAR_6->last);
goto out_unlock_range;
}
}
VAR_15 = svm_range_validate_and_map(VAR_4, VAR_6, VAR_10, false, false, false);
if (VAR_15)
pr_debug(""failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\n"",
VAR_15, VAR_5, VAR_6->start, VAR_6->last);
kfd_smi_event_page_fault_end(VAR_0->kfd.dev, VAR_7->lead_thread->pid, VAR_2,
VAR_14);
out_unlock_range:
mutex_unlock(&VAR_6->migrate_mutex);
out_unlock_svms:
mutex_unlock(&VAR_5->lock);
mmap_read_unlock(VAR_4);
svm_range_count_fault(VAR_0, VAR_7, VAR_10);
mmput(VAR_4);
out:
kfd_unref_process(VAR_7);
if (VAR_15 == -VAR_22) {
pr_debug(""recover vm fault later\n"");
amdgpu_gmc_filter_faults_remove(VAR_0, VAR_2, VAR_1);
VAR_15 = 0;
}
return VAR_15;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/before/2.json,"int
svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,
			uint64_t addr, bool write_fault)
{
	struct mm_struct *mm = NULL;
	struct svm_range_list *svms;
	struct svm_range *prange;
	struct kfd_process *p;
	ktime_t timestamp = ktime_get_boottime();
	int32_t best_loc;
	int32_t gpuidx = MAX_GPU_INSTANCE;
	bool write_locked = false;
	struct vm_area_struct *vma;
	bool migration = false;
	int r = 0;

	if (!KFD_IS_SVM_API_SUPPORTED(adev->kfd.dev)) {
		pr_debug(""device does not support SVM\n"");
		return -EFAULT;
	}

	p = kfd_lookup_process_by_pasid(pasid);
	if (!p) {
		pr_debug(""kfd process not founded pasid 0x%x\n"", pasid);
		return 0;
	}
	svms = &p->svms;

	pr_debug(""restoring svms 0x%p fault address 0x%llx\n"", svms, addr);

	if (atomic_read(&svms->drain_pagefaults)) {
		pr_debug(""draining retry fault, drop fault 0x%llx\n"", addr);
		r = 0;
		goto out;
	}

	if (!p->xnack_enabled) {
		pr_debug(""XNACK not enabled for pasid 0x%x\n"", pasid);
		r = -EFAULT;
		goto out;
	}

	/* p->lead_thread is available as kfd_process_wq_release flush the work
	 * before releasing task ref.
	 */
	mm = get_task_mm(p->lead_thread);
	if (!mm) {
		pr_debug(""svms 0x%p failed to get mm\n"", svms);
		r = 0;
		goto out;
	}

	mmap_read_lock(mm);
retry_write_locked:
	mutex_lock(&svms->lock);
	prange = svm_range_from_addr(svms, addr, NULL);
	if (!prange) {
		pr_debug(""failed to find prange svms 0x%p address [0x%llx]\n"",
			 svms, addr);
		if (!write_locked) {
			/* Need the write lock to create new range with MMU notifier.
			 * Also flush pending deferred work to make sure the interval
			 * tree is up to date before we add a new range
			 */
			mutex_unlock(&svms->lock);
			mmap_read_unlock(mm);
			mmap_write_lock(mm);
			write_locked = true;
			goto retry_write_locked;
		}
		prange = svm_range_create_unregistered_range(adev, p, mm, addr);
		if (!prange) {
			pr_debug(""failed to create unregistered range svms 0x%p address [0x%llx]\n"",
				 svms, addr);
			mmap_write_downgrade(mm);
			r = -EFAULT;
			goto out_unlock_svms;
		}
	}
	if (write_locked)
		mmap_write_downgrade(mm);

	mutex_lock(&prange->migrate_mutex);

	if (svm_range_skip_recover(prange)) {
		amdgpu_gmc_filter_faults_remove(adev, addr, pasid);
		r = 0;
		goto out_unlock_range;
	}

	/* skip duplicate vm fault on different pages of same range */
	if (ktime_before(timestamp, ktime_add_ns(prange->validate_timestamp,
				AMDGPU_SVM_RANGE_RETRY_FAULT_PENDING))) {
		pr_debug(""svms 0x%p [0x%lx %lx] already restored\n"",
			 svms, prange->start, prange->last);
		r = 0;
		goto out_unlock_range;
	}

	/* __do_munmap removed VMA, return success as we are handling stale
	 * retry fault.
	 */
	vma = find_vma(mm, addr << PAGE_SHIFT);
	if (!vma || (addr << PAGE_SHIFT) < vma->vm_start) {
		pr_debug(""address 0x%llx VMA is removed\n"", addr);
		r = 0;
		goto out_unlock_range;
	}

	if (!svm_fault_allowed(vma, write_fault)) {
		pr_debug(""fault addr 0x%llx no %s permission\n"", addr,
			write_fault ? ""write"" : ""read"");
		r = -EPERM;
		goto out_unlock_range;
	}

	best_loc = svm_range_best_restore_location(prange, adev, &gpuidx);
	if (best_loc == -1) {
		pr_debug(""svms %p failed get best restore loc [0x%lx 0x%lx]\n"",
			 svms, prange->start, prange->last);
		r = -EACCES;
		goto out_unlock_range;
	}

	pr_debug(""svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\n"",
		 svms, prange->start, prange->last, best_loc,
		 prange->actual_loc);

	kfd_smi_event_page_fault_start(adev->kfd.dev, p->lead_thread->pid, addr,
				       write_fault, timestamp);

	if (prange->actual_loc != best_loc) {
		migration = true;
		if (best_loc) {
			r = svm_migrate_to_vram(prange, best_loc, mm,
					KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
			if (r) {
				pr_debug(""svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\n"",
					 r, addr);
				/* Fallback to system memory if migration to
				 * VRAM failed
				 */
				if (prange->actual_loc)
					r = svm_migrate_vram_to_ram(prange, mm,
					   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,
					   NULL);
				else
					r = 0;
			}
		} else {
			r = svm_migrate_vram_to_ram(prange, mm,
					KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,
					NULL);
		}
		if (r) {
			pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"",
				 r, svms, prange->start, prange->last);
			goto out_unlock_range;
		}
	}

	r = svm_range_validate_and_map(mm, prange, gpuidx, false, false, false);
	if (r)
		pr_debug(""failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\n"",
			 r, svms, prange->start, prange->last);

	kfd_smi_event_page_fault_end(adev->kfd.dev, p->lead_thread->pid, addr,
				     migration);

out_unlock_range:
	mutex_unlock(&prange->migrate_mutex);
out_unlock_svms:
	mutex_unlock(&svms->lock);
	mmap_read_unlock(mm);

	svm_range_count_fault(adev, p, gpuidx);

	mmput(mm);
out:
	kfd_unref_process(p);

	if (r == -EAGAIN) {
		pr_debug(""recover vm fault later\n"");
		amdgpu_gmc_filter_faults_remove(adev, addr, pasid);
		r = 0;
	}
	return r;
}","int
svm_range_restore_pages(struct amdgpu_device *VAR_0, unsigned int VAR_1,
			uint64_t VAR_2, bool VAR_3)
{
	struct mm_struct *VAR_4 = NULL;
	struct svm_range_list *VAR_5;
	struct svm_range *VAR_6;
	struct kfd_process *VAR_7;
	ktime_t VAR_8 = ktime_get_boottime();
	int32_t VAR_9;
	int32_t VAR_10 = VAR_11;
	bool VAR_12 = false;
	struct vm_area_struct *VAR_13;
	bool VAR_14 = false;
	int VAR_15 = 0;

	if (!KFD_IS_SVM_API_SUPPORTED(VAR_0->kfd.dev)) {
		pr_debug(""device does not support SVM\n"");
		return -VAR_16;
	}

	VAR_7 = kfd_lookup_process_by_pasid(VAR_1);
	if (!VAR_7) {
		pr_debug(""kfd process not founded pasid 0x%x\n"", VAR_1);
		return 0;
	}
	VAR_5 = &VAR_7->svms;

	pr_debug(""restoring svms 0x%p fault address 0x%llx\n"", VAR_5, VAR_2);

	if (atomic_read(&VAR_5->drain_pagefaults)) {
		pr_debug(""draining retry fault, drop fault 0x%llx\n"", VAR_2);
		VAR_15 = 0;
		goto out;
	}

	if (!VAR_7->xnack_enabled) {
		pr_debug(""XNACK not enabled for pasid 0x%x\n"", VAR_1);
		VAR_15 = -VAR_16;
		goto out;
	}

	/* COMMENT_0 */
                              
    
	VAR_4 = get_task_mm(VAR_7->lead_thread);
	if (!VAR_4) {
		pr_debug(""svms 0x%p failed to get mm\n"", VAR_5);
		VAR_15 = 0;
		goto out;
	}

	mmap_read_lock(VAR_4);
retry_write_locked:
	mutex_lock(&VAR_5->lock);
	VAR_6 = svm_range_from_addr(VAR_5, VAR_2, NULL);
	if (!VAR_6) {
		pr_debug(""failed to find prange svms 0x%p address [0x%llx]\n"",
			 VAR_5, VAR_2);
		if (!VAR_12) {
			/* COMMENT_3 */
                                                                
                                                  
      
			mutex_unlock(&VAR_5->lock);
			mmap_read_unlock(VAR_4);
			mmap_write_lock(VAR_4);
			VAR_12 = true;
			goto retry_write_locked;
		}
		VAR_6 = svm_range_create_unregistered_range(VAR_0, VAR_7, VAR_4, VAR_2);
		if (!VAR_6) {
			pr_debug(""failed to create unregistered range svms 0x%p address [0x%llx]\n"",
				 VAR_5, VAR_2);
			mmap_write_downgrade(VAR_4);
			VAR_15 = -VAR_16;
			goto out_unlock_svms;
		}
	}
	if (VAR_12)
		mmap_write_downgrade(VAR_4);

	mutex_lock(&VAR_6->migrate_mutex);

	if (svm_range_skip_recover(VAR_6)) {
		amdgpu_gmc_filter_faults_remove(VAR_0, VAR_2, VAR_1);
		VAR_15 = 0;
		goto out_unlock_range;
	}

	/* COMMENT_7 */
	if (ktime_before(VAR_8, ktime_add_ns(VAR_6->validate_timestamp,
				VAR_17))) {
		pr_debug(""svms 0x%p [0x%lx %lx] already restored\n"",
			 VAR_5, VAR_6->start, VAR_6->last);
		VAR_15 = 0;
		goto out_unlock_range;
	}

	/* COMMENT_8 */
                
    
	VAR_13 = find_vma(VAR_4, VAR_2 << VAR_18);
	if (!VAR_13 || (VAR_2 << VAR_18) < VAR_13->vm_start) {
		pr_debug(""address 0x%llx VMA is removed\n"", VAR_2);
		VAR_15 = 0;
		goto out_unlock_range;
	}

	if (!svm_fault_allowed(VAR_13, VAR_3)) {
		pr_debug(""fault addr 0x%llx no %s permission\n"", VAR_2,
			VAR_3 ? ""write"" : ""read"");
		VAR_15 = -VAR_19;
		goto out_unlock_range;
	}

	VAR_9 = svm_range_best_restore_location(VAR_6, VAR_0, &VAR_10);
	if (VAR_9 == -1) {
		pr_debug(""svms %p failed get best restore loc [0x%lx 0x%lx]\n"",
			 VAR_5, VAR_6->start, VAR_6->last);
		VAR_15 = -VAR_20;
		goto out_unlock_range;
	}

	pr_debug(""svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\n"",
		 VAR_5, VAR_6->start, VAR_6->last, VAR_9,
		 VAR_6->actual_loc);

	kfd_smi_event_page_fault_start(VAR_0->kfd.dev, VAR_7->lead_thread->pid, VAR_2,
				       VAR_3, VAR_8);

	if (VAR_6->actual_loc != VAR_9) {
		VAR_14 = true;
		if (VAR_9) {
			VAR_15 = svm_migrate_to_vram(VAR_6, VAR_9, VAR_4,
					VAR_21);
			if (VAR_15) {
				pr_debug(""svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\n"",
					 VAR_15, VAR_2);
				/* COMMENT_11 */
                  
       
				if (VAR_6->actual_loc)
					VAR_15 = svm_migrate_vram_to_ram(VAR_6, VAR_4,
					   VAR_21,
					   NULL);
				else
					VAR_15 = 0;
			}
		} else {
			VAR_15 = svm_migrate_vram_to_ram(VAR_6, VAR_4,
					VAR_21,
					NULL);
		}
		if (VAR_15) {
			pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"",
				 VAR_15, VAR_5, VAR_6->start, VAR_6->last);
			goto out_unlock_range;
		}
	}

	VAR_15 = svm_range_validate_and_map(VAR_4, VAR_6, VAR_10, false, false, false);
	if (VAR_15)
		pr_debug(""failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\n"",
			 VAR_15, VAR_5, VAR_6->start, VAR_6->last);

	kfd_smi_event_page_fault_end(VAR_0->kfd.dev, VAR_7->lead_thread->pid, VAR_2,
				     VAR_14);

out_unlock_range:
	mutex_unlock(&VAR_6->migrate_mutex);
out_unlock_svms:
	mutex_unlock(&VAR_5->lock);
	mmap_read_unlock(VAR_4);

	svm_range_count_fault(VAR_0, VAR_7, VAR_10);

	mmput(VAR_4);
out:
	kfd_unref_process(VAR_7);

	if (VAR_15 == -VAR_22) {
		pr_debug(""recover vm fault later\n"");
		amdgpu_gmc_filter_faults_remove(VAR_0, VAR_2, VAR_1);
		VAR_15 = 0;
	}
	return VAR_15;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_svm.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -142,13 +142,15 @@
 				 */
 				if (prange->actual_loc)
 					r = svm_migrate_vram_to_ram(prange, mm,
-					   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
+					   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,
+					   NULL);
 				else
 					r = 0;
 			}
 		} else {
 			r = svm_migrate_vram_to_ram(prange, mm,
-					KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);
+					KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,
+					NULL);
 		}
 		if (r) {
 			pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"",","{'deleted_lines': ['\t\t\t\t\t   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);', '\t\t\t\t\tKFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);'], 'added_lines': ['\t\t\t\t\t   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,', '\t\t\t\t\t   NULL);', '\t\t\t\t\tKFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,', '\t\t\t\t\tNULL);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_migrate.c,svm_migrate_vma_to_ram,"static long
svm_migrate_vma_to_ram(struct amdgpu_device *adev, struct svm_range *prange,
struct vm_area_struct *vma, uint64_t start, uint64_t end,
uint32_t trigger)
{
struct kfd_process *p = container_of(prange->svms, struct kfd_process, svms);
uint64_t npages = (end - start) >> PAGE_SHIFT;
unsigned long upages = npages;
unsigned long cpages = 0;
struct kfd_process_device *pdd;
struct dma_fence *mfence = NULL;
struct migrate_vma migrate;
dma_addr_t *scratch;
void *buf;
int r = -ENOMEM;
memset(&migrate, 0, sizeof(migrate));
migrate.vma = vma;
migrate.start = start;
migrate.end = end;
migrate.pgmap_owner = SVM_ADEV_PGMAP_OWNER(adev);
if (adev->gmc.xgmi.connected_to_cpu)
migrate.flags = MIGRATE_VMA_SELECT_DEVICE_COHERENT;
else
migrate.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;
buf = kvcalloc(npages,
2 * sizeof(*migrate.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
GFP_KERNEL);
if (!buf)
goto out;
migrate.src = buf;
migrate.dst = migrate.src + npages;
scratch = (dma_addr_t *)(migrate.dst + npages);
kfd_smi_event_migration_start(adev->kfd.dev, p->lead_thread->pid,
start >> PAGE_SHIFT, end >> PAGE_SHIFT,
adev->kfd.dev->id, 0, prange->prefetch_loc,
prange->preferred_loc, trigger);
r = migrate_vma_setup(&migrate);
if (r) {
dev_err(adev->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
__func__, r, prange->start, prange->last);
goto out_free;
}
cpages = migrate.cpages;
if (!cpages) {
pr_debug(""failed collect migrate device pages [0x%lx 0x%lx]\n"",
prange->start, prange->last);
upages = svm_migrate_unsuccessful_pages(&migrate);
goto out_free;
}
if (cpages != npages)
pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
cpages, npages);
else
pr_debug(""0x%lx pages migrated\n"", cpages);
r = svm_migrate_copy_to_ram(adev, prange, &migrate, &mfence,
scratch, npages);
migrate_vma_pages(&migrate);
upages = svm_migrate_unsuccessful_pages(&migrate);
pr_debug(""unsuccessful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
upages, cpages, migrate.npages);
svm_migrate_copy_done(adev, mfence);
migrate_vma_finalize(&migrate);
kfd_smi_event_migration_end(adev->kfd.dev, p->lead_thread->pid,
start >> PAGE_SHIFT, end >> PAGE_SHIFT,
adev->kfd.dev->id, 0, trigger);
svm_range_dma_unmap(adev->dev, scratch, 0, npages);
out_free:
kvfree(buf);
out:
if (!r && cpages) {
pdd = svm_range_get_pdd_by_adev(prange, adev);
if (pdd)
WRITE_ONCE(pdd->page_out, pdd->page_out + cpages);
}
return r ? r : upages;
}","static long
svm_migrate_vma_to_ram(struct amdgpu_device *VAR_0, struct svm_range *VAR_1,
struct vm_area_struct *VAR_2, uint64_t VAR_3, uint64_t VAR_4,
uint32_t VAR_5)
{
struct kfd_process *VAR_6 = container_of(VAR_1->svms, struct kfd_process, VAR_7);
uint64_t VAR_8 = (VAR_4 - VAR_3) >> VAR_9;
unsigned long VAR_10 = VAR_8;
unsigned long VAR_11 = 0;
struct kfd_process_device *VAR_12;
struct dma_fence *VAR_13 = NULL;
struct migrate_vma VAR_14;
dma_addr_t *VAR_15;
void *VAR_16;
int VAR_17 = -VAR_18;
memset(&VAR_14, 0, sizeof(VAR_14));
VAR_14.vma = VAR_2;
VAR_14.start = VAR_3;
VAR_14.end = VAR_4;
VAR_14.pgmap_owner = SVM_ADEV_PGMAP_OWNER(VAR_0);
if (VAR_0->gmc.xgmi.connected_to_cpu)
VAR_14.flags = VAR_19;
else
VAR_14.flags = VAR_20;
VAR_16 = kvcalloc(VAR_8,
2 * sizeof(*VAR_14.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
VAR_21);
if (!VAR_16)
goto out;
VAR_14.src = VAR_16;
VAR_14.dst = VAR_14.src + VAR_8;
VAR_15 = (dma_addr_t *)(VAR_14.dst + VAR_8);
kfd_smi_event_migration_start(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
VAR_3 >> VAR_9, VAR_4 >> VAR_9,
VAR_0->kfd.dev->id, 0, VAR_1->prefetch_loc,
VAR_1->preferred_loc, VAR_5);
VAR_17 = migrate_vma_setup(&VAR_14);
if (VAR_17) {
dev_err(VAR_0->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
VAR_22, VAR_17, VAR_1->start, VAR_1->last);
goto out_free;
}
VAR_11 = VAR_14.cpages;
if (!VAR_11) {
pr_debug(""failed collect migrate device pages [0x%lx 0x%lx]\n"",
VAR_1->start, VAR_1->last);
VAR_10 = svm_migrate_unsuccessful_pages(&VAR_14);
goto out_free;
}
if (VAR_11 != VAR_8)
pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
VAR_11, VAR_8);
else
pr_debug(""0x%lx pages migrated\n"", VAR_11);
VAR_17 = svm_migrate_copy_to_ram(VAR_0, VAR_1, &VAR_14, &VAR_13,
VAR_15, VAR_8);
migrate_vma_pages(&VAR_14);
VAR_10 = svm_migrate_unsuccessful_pages(&VAR_14);
pr_debug(""unsuccessful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
VAR_10, VAR_11, VAR_14.npages);
svm_migrate_copy_done(VAR_0, VAR_13);
migrate_vma_finalize(&VAR_14);
kfd_smi_event_migration_end(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
VAR_3 >> VAR_9, VAR_4 >> VAR_9,
VAR_0->kfd.dev->id, 0, VAR_5);
svm_range_dma_unmap(VAR_0->dev, VAR_15, 0, VAR_8);
out_free:
kvfree(VAR_16);
out:
if (!VAR_17 && VAR_11) {
VAR_12 = svm_range_get_pdd_by_adev(VAR_1, VAR_0);
if (VAR_12)
WRITE_ONCE(VAR_12->page_out, VAR_12->page_out + VAR_11);
}
return VAR_17 ? VAR_17 : VAR_10;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/before/0.json,"static long
svm_migrate_vma_to_ram(struct amdgpu_device *adev, struct svm_range *prange,
		       struct vm_area_struct *vma, uint64_t start, uint64_t end,
		       uint32_t trigger, struct page *fault_page)
{
	struct kfd_process *p = container_of(prange->svms, struct kfd_process, svms);
	uint64_t npages = (end - start) >> PAGE_SHIFT;
	unsigned long upages = npages;
	unsigned long cpages = 0;
	struct kfd_process_device *pdd;
	struct dma_fence *mfence = NULL;
	struct migrate_vma migrate = { 0 };
	dma_addr_t *scratch;
	void *buf;
	int r = -ENOMEM;

	memset(&migrate, 0, sizeof(migrate));
	migrate.vma = vma;
	migrate.start = start;
	migrate.end = end;
	migrate.pgmap_owner = SVM_ADEV_PGMAP_OWNER(adev);
	if (adev->gmc.xgmi.connected_to_cpu)
		migrate.flags = MIGRATE_VMA_SELECT_DEVICE_COHERENT;
	else
		migrate.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;

	buf = kvcalloc(npages,
		       2 * sizeof(*migrate.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
		       GFP_KERNEL);
	if (!buf)
		goto out;

	migrate.src = buf;
	migrate.dst = migrate.src + npages;
	migrate.fault_page = fault_page;
	scratch = (dma_addr_t *)(migrate.dst + npages);

	kfd_smi_event_migration_start(adev->kfd.dev, p->lead_thread->pid,
				      start >> PAGE_SHIFT, end >> PAGE_SHIFT,
				      adev->kfd.dev->id, 0, prange->prefetch_loc,
				      prange->preferred_loc, trigger);

	r = migrate_vma_setup(&migrate);
	if (r) {
		dev_err(adev->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
			__func__, r, prange->start, prange->last);
		goto out_free;
	}

	cpages = migrate.cpages;
	if (!cpages) {
		pr_debug(""failed collect migrate device pages [0x%lx 0x%lx]\n"",
			 prange->start, prange->last);
		upages = svm_migrate_unsuccessful_pages(&migrate);
		goto out_free;
	}
	if (cpages != npages)
		pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
			 cpages, npages);
	else
		pr_debug(""0x%lx pages migrated\n"", cpages);

	r = svm_migrate_copy_to_ram(adev, prange, &migrate, &mfence,
				    scratch, npages);
	migrate_vma_pages(&migrate);

	upages = svm_migrate_unsuccessful_pages(&migrate);
	pr_debug(""unsuccessful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
		 upages, cpages, migrate.npages);

	svm_migrate_copy_done(adev, mfence);
	migrate_vma_finalize(&migrate);

	kfd_smi_event_migration_end(adev->kfd.dev, p->lead_thread->pid,
				    start >> PAGE_SHIFT, end >> PAGE_SHIFT,
				    adev->kfd.dev->id, 0, trigger);

	svm_range_dma_unmap(adev->dev, scratch, 0, npages);

out_free:
	kvfree(buf);
out:
	if (!r && cpages) {
		pdd = svm_range_get_pdd_by_adev(prange, adev);
		if (pdd)
			WRITE_ONCE(pdd->page_out, pdd->page_out + cpages);
	}
	return r ? r : upages;
}","static long
svm_migrate_vma_to_ram(struct amdgpu_device *VAR_0, struct svm_range *VAR_1,
		       struct vm_area_struct *VAR_2, uint64_t VAR_3, uint64_t VAR_4,
		       uint32_t VAR_5, struct page *VAR_6)
{
	struct kfd_process *VAR_7 = container_of(VAR_1->svms, struct kfd_process, VAR_8);
	uint64_t VAR_9 = (VAR_4 - VAR_3) >> VAR_10;
	unsigned long VAR_11 = VAR_9;
	unsigned long VAR_12 = 0;
	struct kfd_process_device *VAR_13;
	struct dma_fence *VAR_14 = NULL;
	struct migrate_vma VAR_15 = { 0 };
	dma_addr_t *VAR_16;
	void *VAR_17;
	int VAR_18 = -VAR_19;

	memset(&VAR_15, 0, sizeof(VAR_15));
	VAR_15.vma = VAR_2;
	VAR_15.start = VAR_3;
	VAR_15.end = VAR_4;
	VAR_15.pgmap_owner = SVM_ADEV_PGMAP_OWNER(VAR_0);
	if (VAR_0->gmc.xgmi.connected_to_cpu)
		VAR_15.flags = VAR_20;
	else
		VAR_15.flags = VAR_21;

	VAR_17 = kvcalloc(VAR_9,
		       2 * sizeof(*VAR_15.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
		       VAR_22);
	if (!VAR_17)
		goto out;

	VAR_15.src = VAR_17;
	VAR_15.dst = VAR_15.src + VAR_9;
	VAR_15.fault_page = VAR_6;
	VAR_16 = (dma_addr_t *)(VAR_15.dst + VAR_9);

	kfd_smi_event_migration_start(VAR_0->kfd.dev, VAR_7->lead_thread->pid,
				      VAR_3 >> VAR_10, VAR_4 >> VAR_10,
				      VAR_0->kfd.dev->id, 0, VAR_1->prefetch_loc,
				      VAR_1->preferred_loc, VAR_5);

	VAR_18 = migrate_vma_setup(&VAR_15);
	if (VAR_18) {
		dev_err(VAR_0->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
			VAR_23, VAR_18, VAR_1->start, VAR_1->last);
		goto out_free;
	}

	VAR_12 = VAR_15.cpages;
	if (!VAR_12) {
		pr_debug(""failed collect migrate device pages [0x%lx 0x%lx]\n"",
			 VAR_1->start, VAR_1->last);
		VAR_11 = svm_migrate_unsuccessful_pages(&VAR_15);
		goto out_free;
	}
	if (VAR_12 != VAR_9)
		pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
			 VAR_12, VAR_9);
	else
		pr_debug(""0x%lx pages migrated\n"", VAR_12);

	VAR_18 = svm_migrate_copy_to_ram(VAR_0, VAR_1, &VAR_15, &VAR_14,
				    VAR_16, VAR_9);
	migrate_vma_pages(&VAR_15);

	VAR_11 = svm_migrate_unsuccessful_pages(&VAR_15);
	pr_debug(""unsuccessful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
		 VAR_11, VAR_12, VAR_15.npages);

	svm_migrate_copy_done(VAR_0, VAR_14);
	migrate_vma_finalize(&VAR_15);

	kfd_smi_event_migration_end(VAR_0->kfd.dev, VAR_7->lead_thread->pid,
				    VAR_3 >> VAR_10, VAR_4 >> VAR_10,
				    VAR_0->kfd.dev->id, 0, VAR_5);

	svm_range_dma_unmap(VAR_0->dev, VAR_16, 0, VAR_9);

out_free:
	kvfree(VAR_17);
out:
	if (!VAR_18 && VAR_12) {
		VAR_13 = svm_range_get_pdd_by_adev(VAR_1, VAR_0);
		if (VAR_13)
			WRITE_ONCE(VAR_13->page_out, VAR_13->page_out + VAR_12);
	}
	return VAR_18 ? VAR_18 : VAR_11;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static long
 svm_migrate_vma_to_ram(struct amdgpu_device *adev, struct svm_range *prange,
 		       struct vm_area_struct *vma, uint64_t start, uint64_t end,
-		       uint32_t trigger)
+		       uint32_t trigger, struct page *fault_page)
 {
 	struct kfd_process *p = container_of(prange->svms, struct kfd_process, svms);
 	uint64_t npages = (end - start) >> PAGE_SHIFT;
@@ -9,7 +9,7 @@
 	unsigned long cpages = 0;
 	struct kfd_process_device *pdd;
 	struct dma_fence *mfence = NULL;
-	struct migrate_vma migrate;
+	struct migrate_vma migrate = { 0 };
 	dma_addr_t *scratch;
 	void *buf;
 	int r = -ENOMEM;
@@ -32,6 +32,7 @@
 
 	migrate.src = buf;
 	migrate.dst = migrate.src + npages;
+	migrate.fault_page = fault_page;
 	scratch = (dma_addr_t *)(migrate.dst + npages);
 
 	kfd_smi_event_migration_start(adev->kfd.dev, p->lead_thread->pid,","{'deleted_lines': ['\t\t       uint32_t trigger)', '\tstruct migrate_vma migrate;'], 'added_lines': ['\t\t       uint32_t trigger, struct page *fault_page)', '\tstruct migrate_vma migrate = { 0 };', '\tmigrate.fault_page = fault_page;']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_migrate.c,svm_migrate_vram_to_ram,"int svm_migrate_vram_to_ram(struct svm_range *prange, struct mm_struct *mm,
uint32_t trigger)
{
struct amdgpu_device *adev;
struct vm_area_struct *vma;
unsigned long addr;
unsigned long start;
unsigned long end;
unsigned long upages = 0;
long r = 0;
if (!prange->actual_loc) {
pr_debug(""[0x%lx 0x%lx] already migrated to ram\n"",
prange->start, prange->last);
return 0;
}
adev = svm_range_get_adev_by_id(prange, prange->actual_loc);
if (!adev) {
pr_debug(""failed to get device by id 0x%x\n"",
prange->actual_loc);
return -ENODEV;
}
pr_debug(""svms 0x%p prange 0x%p [0x%lx 0x%lx] from gpu 0x%x to ram\n"",
prange->svms, prange, prange->start, prange->last,
prange->actual_loc);
start = prange->start << PAGE_SHIFT;
end = (prange->last + 1) << PAGE_SHIFT;
for (addr = start; addr < end;) {
unsigned long next;
vma = find_vma(mm, addr);
if (!vma || addr < vma->vm_start) {
pr_debug(""failed to find vma for prange %p\n"", prange);
r = -EFAULT;
break;
}
next = min(vma->vm_end, end);
r = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger);
if (r < 0) {
pr_debug(""failed %ld to migrate prange %p\n"", r, prange);
break;
} else {
upages += r;
}
addr = next;
}
if (r >= 0 && !upages) {
svm_range_vram_node_free(prange);
prange->actual_loc = 0;
}
return r < 0 ? r : 0;
}","int svm_migrate_vram_to_ram(struct svm_range *VAR_0, struct mm_struct *VAR_1,
uint32_t VAR_2)
{
struct amdgpu_device *VAR_3;
struct vm_area_struct *VAR_4;
unsigned long VAR_5;
unsigned long VAR_6;
unsigned long VAR_7;
unsigned long VAR_8 = 0;
long VAR_9 = 0;
if (!VAR_0->actual_loc) {
pr_debug(""[0x%lx 0x%lx] already migrated to ram\n"",
VAR_0->start, VAR_0->last);
return 0;
}
VAR_3 = svm_range_get_adev_by_id(VAR_0, VAR_0->actual_loc);
if (!VAR_3) {
pr_debug(""failed to get device by id 0x%x\n"",
VAR_0->actual_loc);
return -VAR_10;
}
pr_debug(""svms 0x%p prange 0x%p [0x%lx 0x%lx] from gpu 0x%x to ram\n"",
VAR_0->svms, VAR_0, VAR_0->start, VAR_0->last,
VAR_0->actual_loc);
VAR_6 = VAR_0->start << VAR_11;
VAR_7 = (VAR_0->last + 1) << VAR_11;
for (VAR_5 = VAR_6; VAR_5 < VAR_7;) {
unsigned long VAR_12;
VAR_4 = find_vma(VAR_1, VAR_5);
if (!VAR_4 || VAR_5 < VAR_4->vm_start) {
pr_debug(""failed to find vma for prange %p\n"", VAR_0);
VAR_9 = -VAR_13;
break;
}
VAR_12 = min(VAR_4->vm_end, VAR_7);
VAR_9 = svm_migrate_vma_to_ram(VAR_3, VAR_0, VAR_4, VAR_5, VAR_12, VAR_2);
if (VAR_9 < 0) {
pr_debug(""failed %ld to migrate prange %p\n"", VAR_9, VAR_0);
break;
} else {
VAR_8 += VAR_9;
}
VAR_5 = VAR_12;
}
if (VAR_9 >= 0 && !VAR_8) {
svm_range_vram_node_free(VAR_0);
VAR_0->actual_loc = 0;
}
return VAR_9 < 0 ? VAR_9 : 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/before/1.json,"int svm_migrate_vram_to_ram(struct svm_range *prange, struct mm_struct *mm,
			    uint32_t trigger, struct page *fault_page)
{
	struct amdgpu_device *adev;
	struct vm_area_struct *vma;
	unsigned long addr;
	unsigned long start;
	unsigned long end;
	unsigned long upages = 0;
	long r = 0;

	if (!prange->actual_loc) {
		pr_debug(""[0x%lx 0x%lx] already migrated to ram\n"",
			 prange->start, prange->last);
		return 0;
	}

	adev = svm_range_get_adev_by_id(prange, prange->actual_loc);
	if (!adev) {
		pr_debug(""failed to get device by id 0x%x\n"",
			 prange->actual_loc);
		return -ENODEV;
	}

	pr_debug(""svms 0x%p prange 0x%p [0x%lx 0x%lx] from gpu 0x%x to ram\n"",
		 prange->svms, prange, prange->start, prange->last,
		 prange->actual_loc);

	start = prange->start << PAGE_SHIFT;
	end = (prange->last + 1) << PAGE_SHIFT;

	for (addr = start; addr < end;) {
		unsigned long next;

		vma = find_vma(mm, addr);
		if (!vma || addr < vma->vm_start) {
			pr_debug(""failed to find vma for prange %p\n"", prange);
			r = -EFAULT;
			break;
		}

		next = min(vma->vm_end, end);
		r = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger,
			fault_page);
		if (r < 0) {
			pr_debug(""failed %ld to migrate prange %p\n"", r, prange);
			break;
		} else {
			upages += r;
		}
		addr = next;
	}

	if (r >= 0 && !upages) {
		svm_range_vram_node_free(prange);
		prange->actual_loc = 0;
	}

	return r < 0 ? r : 0;
}","int svm_migrate_vram_to_ram(struct svm_range *VAR_0, struct mm_struct *VAR_1,
			    uint32_t VAR_2, struct page *VAR_3)
{
	struct amdgpu_device *VAR_4;
	struct vm_area_struct *VAR_5;
	unsigned long VAR_6;
	unsigned long VAR_7;
	unsigned long VAR_8;
	unsigned long VAR_9 = 0;
	long VAR_10 = 0;

	if (!VAR_0->actual_loc) {
		pr_debug(""[0x%lx 0x%lx] already migrated to ram\n"",
			 VAR_0->start, VAR_0->last);
		return 0;
	}

	VAR_4 = svm_range_get_adev_by_id(VAR_0, VAR_0->actual_loc);
	if (!VAR_4) {
		pr_debug(""failed to get device by id 0x%x\n"",
			 VAR_0->actual_loc);
		return -VAR_11;
	}

	pr_debug(""svms 0x%p prange 0x%p [0x%lx 0x%lx] from gpu 0x%x to ram\n"",
		 VAR_0->svms, VAR_0, VAR_0->start, VAR_0->last,
		 VAR_0->actual_loc);

	VAR_7 = VAR_0->start << VAR_12;
	VAR_8 = (VAR_0->last + 1) << VAR_12;

	for (VAR_6 = VAR_7; VAR_6 < VAR_8;) {
		unsigned long VAR_13;

		VAR_5 = find_vma(VAR_1, VAR_6);
		if (!VAR_5 || VAR_6 < VAR_5->vm_start) {
			pr_debug(""failed to find vma for prange %p\n"", VAR_0);
			VAR_10 = -VAR_14;
			break;
		}

		VAR_13 = min(VAR_5->vm_end, VAR_8);
		VAR_10 = svm_migrate_vma_to_ram(VAR_4, VAR_0, VAR_5, VAR_6, VAR_13, VAR_2,
			VAR_3);
		if (VAR_10 < 0) {
			pr_debug(""failed %ld to migrate prange %p\n"", VAR_10, VAR_0);
			break;
		} else {
			VAR_9 += VAR_10;
		}
		VAR_6 = VAR_13;
	}

	if (VAR_10 >= 0 && !VAR_9) {
		svm_range_vram_node_free(VAR_0);
		VAR_0->actual_loc = 0;
	}

	return VAR_10 < 0 ? VAR_10 : 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 int svm_migrate_vram_to_ram(struct svm_range *prange, struct mm_struct *mm,
-			    uint32_t trigger)
+			    uint32_t trigger, struct page *fault_page)
 {
 	struct amdgpu_device *adev;
 	struct vm_area_struct *vma;
@@ -40,7 +40,8 @@
 		}
 
 		next = min(vma->vm_end, end);
-		r = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger);
+		r = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger,
+			fault_page);
 		if (r < 0) {
 			pr_debug(""failed %ld to migrate prange %p\n"", r, prange);
 			break;","{'deleted_lines': ['\t\t\t    uint32_t trigger)', '\t\tr = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger);'], 'added_lines': ['\t\t\t    uint32_t trigger, struct page *fault_page)', '\t\tr = svm_migrate_vma_to_ram(adev, prange, vma, addr, next, trigger,', '\t\t\tfault_page);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_migrate.c,svm_migrate_vma_to_vram,"static long
svm_migrate_vma_to_vram(struct amdgpu_device *adev, struct svm_range *prange,
struct vm_area_struct *vma, uint64_t start,
uint64_t end, uint32_t trigger)
{
struct kfd_process *p = container_of(prange->svms, struct kfd_process, svms);
uint64_t npages = (end - start) >> PAGE_SHIFT;
struct kfd_process_device *pdd;
struct dma_fence *mfence = NULL;
struct migrate_vma migrate;
unsigned long cpages = 0;
dma_addr_t *scratch;
void *buf;
int r = -ENOMEM;
memset(&migrate, 0, sizeof(migrate));
migrate.vma = vma;
migrate.start = start;
migrate.end = end;
migrate.flags = MIGRATE_VMA_SELECT_SYSTEM;
migrate.pgmap_owner = SVM_ADEV_PGMAP_OWNER(adev);
buf = kvcalloc(npages,
2 * sizeof(*migrate.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
GFP_KERNEL);
if (!buf)
goto out;
migrate.src = buf;
migrate.dst = migrate.src + npages;
scratch = (dma_addr_t *)(migrate.dst + npages);
kfd_smi_event_migration_start(adev->kfd.dev, p->lead_thread->pid,
start >> PAGE_SHIFT, end >> PAGE_SHIFT,
0, adev->kfd.dev->id, prange->prefetch_loc,
prange->preferred_loc, trigger);
r = migrate_vma_setup(&migrate);
if (r) {
dev_err(adev->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
__func__, r, prange->start, prange->last);
goto out_free;
}
cpages = migrate.cpages;
if (!cpages) {
pr_debug(""failed collect migrate sys pages [0x%lx 0x%lx]\n"",
prange->start, prange->last);
goto out_free;
}
if (cpages != npages)
pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
cpages, npages);
else
pr_debug(""0x%lx pages migrated\n"", cpages);
r = svm_migrate_copy_to_vram(adev, prange, &migrate, &mfence, scratch);
migrate_vma_pages(&migrate);
pr_debug(""successful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
svm_migrate_successful_pages(&migrate), cpages, migrate.npages);
svm_migrate_copy_done(adev, mfence);
migrate_vma_finalize(&migrate);
kfd_smi_event_migration_end(adev->kfd.dev, p->lead_thread->pid,
start >> PAGE_SHIFT, end >> PAGE_SHIFT,
0, adev->kfd.dev->id, trigger);
svm_range_dma_unmap(adev->dev, scratch, 0, npages);
svm_range_free_dma_mappings(prange);
out_free:
kvfree(buf);
out:
if (!r && cpages) {
pdd = svm_range_get_pdd_by_adev(prange, adev);
if (pdd)
WRITE_ONCE(pdd->page_in, pdd->page_in + cpages);
return cpages;
}
return r;
}","static long
svm_migrate_vma_to_vram(struct amdgpu_device *VAR_0, struct svm_range *VAR_1,
struct vm_area_struct *VAR_2, uint64_t VAR_3,
uint64_t VAR_4, uint32_t VAR_5)
{
struct kfd_process *VAR_6 = container_of(VAR_1->svms, struct kfd_process, VAR_7);
uint64_t VAR_8 = (VAR_4 - VAR_3) >> VAR_9;
struct kfd_process_device *VAR_10;
struct dma_fence *VAR_11 = NULL;
struct migrate_vma VAR_12;
unsigned long VAR_13 = 0;
dma_addr_t *VAR_14;
void *VAR_15;
int VAR_16 = -VAR_17;
memset(&VAR_12, 0, sizeof(VAR_12));
VAR_12.vma = VAR_2;
VAR_12.start = VAR_3;
VAR_12.end = VAR_4;
VAR_12.flags = VAR_18;
VAR_12.pgmap_owner = SVM_ADEV_PGMAP_OWNER(VAR_0);
VAR_15 = kvcalloc(VAR_8,
2 * sizeof(*VAR_12.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
VAR_19);
if (!VAR_15)
goto out;
VAR_12.src = VAR_15;
VAR_12.dst = VAR_12.src + VAR_8;
VAR_14 = (dma_addr_t *)(VAR_12.dst + VAR_8);
kfd_smi_event_migration_start(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
VAR_3 >> VAR_9, VAR_4 >> VAR_9,
0, VAR_0->kfd.dev->id, VAR_1->prefetch_loc,
VAR_1->preferred_loc, VAR_5);
VAR_16 = migrate_vma_setup(&VAR_12);
if (VAR_16) {
dev_err(VAR_0->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
VAR_20, VAR_16, VAR_1->start, VAR_1->last);
goto out_free;
}
VAR_13 = VAR_12.cpages;
if (!VAR_13) {
pr_debug(""failed collect migrate sys pages [0x%lx 0x%lx]\n"",
VAR_1->start, VAR_1->last);
goto out_free;
}
if (VAR_13 != VAR_8)
pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
VAR_13, VAR_8);
else
pr_debug(""0x%lx pages migrated\n"", VAR_13);
VAR_16 = svm_migrate_copy_to_vram(VAR_0, VAR_1, &VAR_12, &VAR_11, VAR_14);
migrate_vma_pages(&VAR_12);
pr_debug(""successful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
svm_migrate_successful_pages(&VAR_12), VAR_13, VAR_12.npages);
svm_migrate_copy_done(VAR_0, VAR_11);
migrate_vma_finalize(&VAR_12);
kfd_smi_event_migration_end(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
VAR_3 >> VAR_9, VAR_4 >> VAR_9,
0, VAR_0->kfd.dev->id, VAR_5);
svm_range_dma_unmap(VAR_0->dev, VAR_14, 0, VAR_8);
svm_range_free_dma_mappings(VAR_1);
out_free:
kvfree(VAR_15);
out:
if (!VAR_16 && VAR_13) {
VAR_10 = svm_range_get_pdd_by_adev(VAR_1, VAR_0);
if (VAR_10)
WRITE_ONCE(VAR_10->page_in, VAR_10->page_in + VAR_13);
return VAR_13;
}
return VAR_16;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/before/2.json,"static long
svm_migrate_vma_to_vram(struct amdgpu_device *adev, struct svm_range *prange,
			struct vm_area_struct *vma, uint64_t start,
			uint64_t end, uint32_t trigger)
{
	struct kfd_process *p = container_of(prange->svms, struct kfd_process, svms);
	uint64_t npages = (end - start) >> PAGE_SHIFT;
	struct kfd_process_device *pdd;
	struct dma_fence *mfence = NULL;
	struct migrate_vma migrate = { 0 };
	unsigned long cpages = 0;
	dma_addr_t *scratch;
	void *buf;
	int r = -ENOMEM;

	memset(&migrate, 0, sizeof(migrate));
	migrate.vma = vma;
	migrate.start = start;
	migrate.end = end;
	migrate.flags = MIGRATE_VMA_SELECT_SYSTEM;
	migrate.pgmap_owner = SVM_ADEV_PGMAP_OWNER(adev);

	buf = kvcalloc(npages,
		       2 * sizeof(*migrate.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
		       GFP_KERNEL);
	if (!buf)
		goto out;

	migrate.src = buf;
	migrate.dst = migrate.src + npages;
	scratch = (dma_addr_t *)(migrate.dst + npages);

	kfd_smi_event_migration_start(adev->kfd.dev, p->lead_thread->pid,
				      start >> PAGE_SHIFT, end >> PAGE_SHIFT,
				      0, adev->kfd.dev->id, prange->prefetch_loc,
				      prange->preferred_loc, trigger);

	r = migrate_vma_setup(&migrate);
	if (r) {
		dev_err(adev->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
			__func__, r, prange->start, prange->last);
		goto out_free;
	}

	cpages = migrate.cpages;
	if (!cpages) {
		pr_debug(""failed collect migrate sys pages [0x%lx 0x%lx]\n"",
			 prange->start, prange->last);
		goto out_free;
	}
	if (cpages != npages)
		pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
			 cpages, npages);
	else
		pr_debug(""0x%lx pages migrated\n"", cpages);

	r = svm_migrate_copy_to_vram(adev, prange, &migrate, &mfence, scratch);
	migrate_vma_pages(&migrate);

	pr_debug(""successful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
		svm_migrate_successful_pages(&migrate), cpages, migrate.npages);

	svm_migrate_copy_done(adev, mfence);
	migrate_vma_finalize(&migrate);

	kfd_smi_event_migration_end(adev->kfd.dev, p->lead_thread->pid,
				    start >> PAGE_SHIFT, end >> PAGE_SHIFT,
				    0, adev->kfd.dev->id, trigger);

	svm_range_dma_unmap(adev->dev, scratch, 0, npages);
	svm_range_free_dma_mappings(prange);

out_free:
	kvfree(buf);
out:
	if (!r && cpages) {
		pdd = svm_range_get_pdd_by_adev(prange, adev);
		if (pdd)
			WRITE_ONCE(pdd->page_in, pdd->page_in + cpages);

		return cpages;
	}
	return r;
}","static long
svm_migrate_vma_to_vram(struct amdgpu_device *VAR_0, struct svm_range *VAR_1,
			struct vm_area_struct *VAR_2, uint64_t VAR_3,
			uint64_t VAR_4, uint32_t VAR_5)
{
	struct kfd_process *VAR_6 = container_of(VAR_1->svms, struct kfd_process, VAR_7);
	uint64_t VAR_8 = (VAR_4 - VAR_3) >> VAR_9;
	struct kfd_process_device *VAR_10;
	struct dma_fence *VAR_11 = NULL;
	struct migrate_vma VAR_12 = { 0 };
	unsigned long VAR_13 = 0;
	dma_addr_t *VAR_14;
	void *VAR_15;
	int VAR_16 = -VAR_17;

	memset(&VAR_12, 0, sizeof(VAR_12));
	VAR_12.vma = VAR_2;
	VAR_12.start = VAR_3;
	VAR_12.end = VAR_4;
	VAR_12.flags = VAR_18;
	VAR_12.pgmap_owner = SVM_ADEV_PGMAP_OWNER(VAR_0);

	VAR_15 = kvcalloc(VAR_8,
		       2 * sizeof(*VAR_12.src) + sizeof(uint64_t) + sizeof(dma_addr_t),
		       VAR_19);
	if (!VAR_15)
		goto out;

	VAR_12.src = VAR_15;
	VAR_12.dst = VAR_12.src + VAR_8;
	VAR_14 = (dma_addr_t *)(VAR_12.dst + VAR_8);

	kfd_smi_event_migration_start(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
				      VAR_3 >> VAR_9, VAR_4 >> VAR_9,
				      0, VAR_0->kfd.dev->id, VAR_1->prefetch_loc,
				      VAR_1->preferred_loc, VAR_5);

	VAR_16 = migrate_vma_setup(&VAR_12);
	if (VAR_16) {
		dev_err(VAR_0->dev, ""%s: vma setup fail %d range [0x%lx 0x%lx]\n"",
			VAR_20, VAR_16, VAR_1->start, VAR_1->last);
		goto out_free;
	}

	VAR_13 = VAR_12.cpages;
	if (!VAR_13) {
		pr_debug(""failed collect migrate sys pages [0x%lx 0x%lx]\n"",
			 VAR_1->start, VAR_1->last);
		goto out_free;
	}
	if (VAR_13 != VAR_8)
		pr_debug(""partial migration, 0x%lx/0x%llx pages migrated\n"",
			 VAR_13, VAR_8);
	else
		pr_debug(""0x%lx pages migrated\n"", VAR_13);

	VAR_16 = svm_migrate_copy_to_vram(VAR_0, VAR_1, &VAR_12, &VAR_11, VAR_14);
	migrate_vma_pages(&VAR_12);

	pr_debug(""successful/cpages/npages 0x%lx/0x%lx/0x%lx\n"",
		svm_migrate_successful_pages(&VAR_12), VAR_13, VAR_12.npages);

	svm_migrate_copy_done(VAR_0, VAR_11);
	migrate_vma_finalize(&VAR_12);

	kfd_smi_event_migration_end(VAR_0->kfd.dev, VAR_6->lead_thread->pid,
				    VAR_3 >> VAR_9, VAR_4 >> VAR_9,
				    0, VAR_0->kfd.dev->id, VAR_5);

	svm_range_dma_unmap(VAR_0->dev, VAR_14, 0, VAR_8);
	svm_range_free_dma_mappings(VAR_1);

out_free:
	kvfree(VAR_15);
out:
	if (!VAR_16 && VAR_13) {
		VAR_10 = svm_range_get_pdd_by_adev(VAR_1, VAR_0);
		if (VAR_10)
			WRITE_ONCE(VAR_10->page_in, VAR_10->page_in + VAR_13);

		return VAR_13;
	}
	return VAR_16;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	uint64_t npages = (end - start) >> PAGE_SHIFT;
 	struct kfd_process_device *pdd;
 	struct dma_fence *mfence = NULL;
-	struct migrate_vma migrate;
+	struct migrate_vma migrate = { 0 };
 	unsigned long cpages = 0;
 	dma_addr_t *scratch;
 	void *buf;","{'deleted_lines': ['\tstruct migrate_vma migrate;'], 'added_lines': ['\tstruct migrate_vma migrate = { 0 };']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_migrate.c,svm_migrate_vram_to_vram,"static int
svm_migrate_vram_to_vram(struct svm_range *prange, uint32_t best_loc,
struct mm_struct *mm, uint32_t trigger)
{
int r, retries = 3;
pr_debug(""from gpu 0x%x to gpu 0x%x\n"", prange->actual_loc, best_loc);
do {
r = svm_migrate_vram_to_ram(prange, mm, trigger);
if (r)
return r;
} while (prange->actual_loc && --retries);
if (prange->actual_loc)
return -EDEADLK;
return svm_migrate_ram_to_vram(prange, best_loc, mm, trigger);
}","static int
svm_migrate_vram_to_vram(struct svm_range *VAR_0, uint32_t VAR_1,
struct mm_struct *VAR_2, uint32_t VAR_3)
{
int VAR_4, VAR_5 = 3;
pr_debug(""from gpu 0x%x to gpu 0x%x\n"", VAR_0->actual_loc, VAR_1);
do {
VAR_4 = svm_migrate_vram_to_ram(VAR_0, VAR_2, VAR_3);
if (VAR_4)
return VAR_4;
} while (VAR_0->actual_loc && --VAR_5);
if (VAR_0->actual_loc)
return -VAR_6;
return svm_migrate_ram_to_vram(VAR_0, VAR_1, VAR_2, VAR_3);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/before/3.json,"static int
svm_migrate_vram_to_vram(struct svm_range *prange, uint32_t best_loc,
			 struct mm_struct *mm, uint32_t trigger)
{
	int r, retries = 3;

	/*
	 * TODO: for both devices with PCIe large bar or on same xgmi hive, skip
	 * system memory as migration bridge
	 */

	pr_debug(""from gpu 0x%x to gpu 0x%x\n"", prange->actual_loc, best_loc);

	do {
		r = svm_migrate_vram_to_ram(prange, mm, trigger, NULL);
		if (r)
			return r;
	} while (prange->actual_loc && --retries);

	if (prange->actual_loc)
		return -EDEADLK;

	return svm_migrate_ram_to_vram(prange, best_loc, mm, trigger);
}","static int
svm_migrate_vram_to_vram(struct svm_range *VAR_0, uint32_t VAR_1,
			 struct mm_struct *VAR_2, uint32_t VAR_3)
{
	int VAR_4, VAR_5 = 3;

	/* COMMENT_0 */
                                                                         
                                     
    

	pr_debug(""from gpu 0x%x to gpu 0x%x\n"", VAR_0->actual_loc, VAR_1);

	do {
		VAR_4 = svm_migrate_vram_to_ram(VAR_0, VAR_2, VAR_3, NULL);
		if (VAR_4)
			return VAR_4;
	} while (VAR_0->actual_loc && --VAR_5);

	if (VAR_0->actual_loc)
		return -VAR_6;

	return svm_migrate_ram_to_vram(VAR_0, VAR_1, VAR_2, VAR_3);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 	pr_debug(""from gpu 0x%x to gpu 0x%x\n"", prange->actual_loc, best_loc);
 
 	do {
-		r = svm_migrate_vram_to_ram(prange, mm, trigger);
+		r = svm_migrate_vram_to_ram(prange, mm, trigger, NULL);
 		if (r)
 			return r;
 	} while (prange->actual_loc && --retries);","{'deleted_lines': ['\t\tr = svm_migrate_vram_to_ram(prange, mm, trigger);'], 'added_lines': ['\t\tr = svm_migrate_vram_to_ram(prange, mm, trigger, NULL);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,drivers/gpu/drm/amd/amdkfd/kfd_migrate.c,svm_migrate_to_ram,"static vm_fault_t svm_migrate_to_ram(struct vm_fault *vmf)
{
unsigned long addr = vmf->address;
struct vm_area_struct *vma;
enum svm_work_list_ops op;
struct svm_range *parent;
struct svm_range *prange;
struct kfd_process *p;
struct mm_struct *mm;
int r = 0;
vma = vmf->vma;
mm = vma->vm_mm;
p = kfd_lookup_process_by_mm(vma->vm_mm);
if (!p) {
pr_debug(""failed find process at fault address 0x%lx\n"", addr);
return VM_FAULT_SIGBUS;
}
if (READ_ONCE(p->svms.faulting_task) == current) {
pr_debug(""skipping ram migration\n"");
kfd_unref_process(p);
return 0;
}
addr >>= PAGE_SHIFT;
pr_debug(""CPU page fault svms 0x%p address 0x%lx\n"", &p->svms, addr);
mutex_lock(&p->svms.lock);
prange = svm_range_from_addr(&p->svms, addr, &parent);
if (!prange) {
pr_debug(""cannot find svm range at 0x%lx\n"", addr);
r = -EFAULT;
goto out;
}
mutex_lock(&parent->migrate_mutex);
if (prange != parent)
mutex_lock_nested(&prange->migrate_mutex, 1);
if (!prange->actual_loc)
goto out_unlock_prange;
svm_range_lock(parent);
if (prange != parent)
mutex_lock_nested(&prange->lock, 1);
r = svm_range_split_by_granularity(p, mm, addr, parent, prange);
if (prange != parent)
mutex_unlock(&prange->lock);
svm_range_unlock(parent);
if (r) {
pr_debug(""failed %d to split range by granularity\n"", r);
goto out_unlock_prange;
}
r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU);
if (r)
pr_debug(""failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n"", r,
prange, prange->start, prange->last);
if (p->xnack_enabled && parent == prange)
op = SVM_OP_UPDATE_RANGE_NOTIFIER_AND_MAP;
else
op = SVM_OP_UPDATE_RANGE_NOTIFIER;
svm_range_add_list_work(&p->svms, parent, mm, op);
schedule_deferred_list_work(&p->svms);
out_unlock_prange:
if (prange != parent)
mutex_unlock(&prange->migrate_mutex);
mutex_unlock(&parent->migrate_mutex);
out:
mutex_unlock(&p->svms.lock);
kfd_unref_process(p);
pr_debug(""CPU fault svms 0x%p address 0x%lx done\n"", &p->svms, addr);
return r ? VM_FAULT_SIGBUS : 0;
}","static vm_fault_t svm_migrate_to_ram(struct vm_fault *VAR_0)
{
unsigned long VAR_1 = VAR_0->address;
struct vm_area_struct *VAR_2;
enum svm_work_list_ops VAR_3;
struct svm_range *VAR_4;
struct svm_range *VAR_5;
struct kfd_process *VAR_6;
struct mm_struct *VAR_7;
int VAR_8 = 0;
VAR_2 = VAR_0->vma;
VAR_7 = VAR_2->vm_mm;
VAR_6 = kfd_lookup_process_by_mm(VAR_2->vm_mm);
if (!VAR_6) {
pr_debug(""failed find process at fault address 0x%lx\n"", VAR_1);
return VAR_9;
}
if (READ_ONCE(VAR_6->svms.faulting_task) == VAR_10) {
pr_debug(""skipping ram migration\n"");
kfd_unref_process(VAR_6);
return 0;
}
VAR_1 >>= VAR_11;
pr_debug(""CPU page fault svms 0x%p address 0x%lx\n"", &VAR_6->svms, VAR_1);
mutex_lock(&VAR_6->svms.lock);
VAR_5 = svm_range_from_addr(&VAR_6->svms, VAR_1, &VAR_4);
if (!VAR_5) {
pr_debug(""cannot find svm range at 0x%lx\n"", VAR_1);
VAR_8 = -VAR_12;
goto out;
}
mutex_lock(&VAR_4->migrate_mutex);
if (VAR_5 != VAR_4)
mutex_lock_nested(&VAR_5->migrate_mutex, 1);
if (!VAR_5->actual_loc)
goto out_unlock_prange;
svm_range_lock(VAR_4);
if (VAR_5 != VAR_4)
mutex_lock_nested(&VAR_5->lock, 1);
VAR_8 = svm_range_split_by_granularity(VAR_6, VAR_7, VAR_1, VAR_4, VAR_5);
if (VAR_5 != VAR_4)
mutex_unlock(&VAR_5->lock);
svm_range_unlock(VAR_4);
if (VAR_8) {
pr_debug(""failed %d to split range by granularity\n"", VAR_8);
goto out_unlock_prange;
}
VAR_8 = svm_migrate_vram_to_ram(VAR_5, VAR_7, VAR_13);
if (VAR_8)
pr_debug(""failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n"", VAR_8,
VAR_5, VAR_5->start, VAR_5->last);
if (VAR_6->xnack_enabled && VAR_4 == VAR_5)
VAR_3 = VAR_14;
else
VAR_3 = VAR_15;
svm_range_add_list_work(&VAR_6->svms, VAR_4, VAR_7, VAR_3);
schedule_deferred_list_work(&VAR_6->svms);
out_unlock_prange:
if (VAR_5 != VAR_4)
mutex_unlock(&VAR_5->migrate_mutex);
mutex_unlock(&VAR_4->migrate_mutex);
out:
mutex_unlock(&VAR_6->svms.lock);
kfd_unref_process(VAR_6);
pr_debug(""CPU fault svms 0x%p address 0x%lx done\n"", &VAR_6->svms, VAR_1);
return VAR_8 ? VAR_9 : 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/before/4.json,"static vm_fault_t svm_migrate_to_ram(struct vm_fault *vmf)
{
	unsigned long addr = vmf->address;
	struct vm_area_struct *vma;
	enum svm_work_list_ops op;
	struct svm_range *parent;
	struct svm_range *prange;
	struct kfd_process *p;
	struct mm_struct *mm;
	int r = 0;

	vma = vmf->vma;
	mm = vma->vm_mm;

	p = kfd_lookup_process_by_mm(vma->vm_mm);
	if (!p) {
		pr_debug(""failed find process at fault address 0x%lx\n"", addr);
		return VM_FAULT_SIGBUS;
	}
	if (READ_ONCE(p->svms.faulting_task) == current) {
		pr_debug(""skipping ram migration\n"");
		kfd_unref_process(p);
		return 0;
	}
	addr >>= PAGE_SHIFT;
	pr_debug(""CPU page fault svms 0x%p address 0x%lx\n"", &p->svms, addr);

	mutex_lock(&p->svms.lock);

	prange = svm_range_from_addr(&p->svms, addr, &parent);
	if (!prange) {
		pr_debug(""cannot find svm range at 0x%lx\n"", addr);
		r = -EFAULT;
		goto out;
	}

	mutex_lock(&parent->migrate_mutex);
	if (prange != parent)
		mutex_lock_nested(&prange->migrate_mutex, 1);

	if (!prange->actual_loc)
		goto out_unlock_prange;

	svm_range_lock(parent);
	if (prange != parent)
		mutex_lock_nested(&prange->lock, 1);
	r = svm_range_split_by_granularity(p, mm, addr, parent, prange);
	if (prange != parent)
		mutex_unlock(&prange->lock);
	svm_range_unlock(parent);
	if (r) {
		pr_debug(""failed %d to split range by granularity\n"", r);
		goto out_unlock_prange;
	}

	r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU,
				vmf->page);
	if (r)
		pr_debug(""failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n"", r,
			 prange, prange->start, prange->last);

	/* xnack on, update mapping on GPUs with ACCESS_IN_PLACE */
	if (p->xnack_enabled && parent == prange)
		op = SVM_OP_UPDATE_RANGE_NOTIFIER_AND_MAP;
	else
		op = SVM_OP_UPDATE_RANGE_NOTIFIER;
	svm_range_add_list_work(&p->svms, parent, mm, op);
	schedule_deferred_list_work(&p->svms);

out_unlock_prange:
	if (prange != parent)
		mutex_unlock(&prange->migrate_mutex);
	mutex_unlock(&parent->migrate_mutex);
out:
	mutex_unlock(&p->svms.lock);
	kfd_unref_process(p);

	pr_debug(""CPU fault svms 0x%p address 0x%lx done\n"", &p->svms, addr);

	return r ? VM_FAULT_SIGBUS : 0;
}","static vm_fault_t svm_migrate_to_ram(struct vm_fault *VAR_0)
{
	unsigned long VAR_1 = VAR_0->address;
	struct vm_area_struct *VAR_2;
	enum svm_work_list_ops VAR_3;
	struct svm_range *VAR_4;
	struct svm_range *VAR_5;
	struct kfd_process *VAR_6;
	struct mm_struct *VAR_7;
	int VAR_8 = 0;

	VAR_2 = VAR_0->vma;
	VAR_7 = VAR_2->vm_mm;

	VAR_6 = kfd_lookup_process_by_mm(VAR_2->vm_mm);
	if (!VAR_6) {
		pr_debug(""failed find process at fault address 0x%lx\n"", VAR_1);
		return VAR_9;
	}
	if (READ_ONCE(VAR_6->svms.faulting_task) == VAR_10) {
		pr_debug(""skipping ram migration\n"");
		kfd_unref_process(VAR_6);
		return 0;
	}
	VAR_1 >>= VAR_11;
	pr_debug(""CPU page fault svms 0x%p address 0x%lx\n"", &VAR_6->svms, VAR_1);

	mutex_lock(&VAR_6->svms.lock);

	VAR_5 = svm_range_from_addr(&VAR_6->svms, VAR_1, &VAR_4);
	if (!VAR_5) {
		pr_debug(""cannot find svm range at 0x%lx\n"", VAR_1);
		VAR_8 = -VAR_12;
		goto out;
	}

	mutex_lock(&VAR_4->migrate_mutex);
	if (VAR_5 != VAR_4)
		mutex_lock_nested(&VAR_5->migrate_mutex, 1);

	if (!VAR_5->actual_loc)
		goto out_unlock_prange;

	svm_range_lock(VAR_4);
	if (VAR_5 != VAR_4)
		mutex_lock_nested(&VAR_5->lock, 1);
	VAR_8 = svm_range_split_by_granularity(VAR_6, VAR_7, VAR_1, VAR_4, VAR_5);
	if (VAR_5 != VAR_4)
		mutex_unlock(&VAR_5->lock);
	svm_range_unlock(VAR_4);
	if (VAR_8) {
		pr_debug(""failed %d to split range by granularity\n"", VAR_8);
		goto out_unlock_prange;
	}

	VAR_8 = svm_migrate_vram_to_ram(VAR_5, VAR_7, VAR_13,
				VAR_0->page);
	if (VAR_8)
		pr_debug(""failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n"", VAR_8,
			 VAR_5, VAR_5->start, VAR_5->last);

	/* COMMENT_0 */
	if (VAR_6->xnack_enabled && VAR_4 == VAR_5)
		VAR_3 = VAR_14;
	else
		VAR_3 = VAR_15;
	svm_range_add_list_work(&VAR_6->svms, VAR_4, VAR_7, VAR_3);
	schedule_deferred_list_work(&VAR_6->svms);

out_unlock_prange:
	if (VAR_5 != VAR_4)
		mutex_unlock(&VAR_5->migrate_mutex);
	mutex_unlock(&VAR_4->migrate_mutex);
out:
	mutex_unlock(&VAR_6->svms.lock);
	kfd_unref_process(VAR_6);

	pr_debug(""CPU fault svms 0x%p address 0x%lx done\n"", &VAR_6->svms, VAR_1);

	return VAR_8 ? VAR_9 : 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/kfd_migrate.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -53,7 +53,8 @@
 		goto out_unlock_prange;
 	}
 
-	r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU);
+	r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU,
+				vmf->page);
 	if (r)
 		pr_debug(""failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n"", r,
 			 prange, prange->start, prange->last);","{'deleted_lines': ['\tr = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU);'], 'added_lines': ['\tr = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_CPU,', '\t\t\t\tvmf->page);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/memory.c,do_swap_page,"vm_fault_t do_swap_page(struct vm_fault *vmf)
{
struct vm_area_struct *vma = vmf->vma;
struct folio *swapcache, *folio = NULL;
struct page *page;
struct swap_info_struct *si = NULL;
rmap_t rmap_flags = RMAP_NONE;
bool exclusive = false;
swp_entry_t entry;
pte_t pte;
int locked;
vm_fault_t ret = 0;
void *shadow = NULL;
if (!pte_unmap_same(vmf))
goto out;
entry = pte_to_swp_entry(vmf->orig_pte);
if (unlikely(non_swap_entry(entry))) {
if (is_migration_entry(entry)) {
migration_entry_wait(vma->vm_mm, vmf->pmd,
vmf->address);
} else if (is_device_exclusive_entry(entry)) {
vmf->page = pfn_swap_entry_to_page(entry);
ret = remove_device_exclusive_entry(vmf);
} else if (is_device_private_entry(entry)) {
vmf->page = pfn_swap_entry_to_page(entry);
ret = vmf->page->pgmap->ops->migrate_to_ram(vmf);
} else if (is_hwpoison_entry(entry)) {
ret = VM_FAULT_HWPOISON;
} else if (is_swapin_error_entry(entry)) {
ret = VM_FAULT_SIGBUS;
} else if (is_pte_marker_entry(entry)) {
ret = handle_pte_marker(vmf);
} else {
print_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);
ret = VM_FAULT_SIGBUS;
}
goto out;
}
si = get_swap_device(entry);
if (unlikely(!si))
goto out;
folio = swap_cache_get_folio(entry, vma, vmf->address);
if (folio)
page = folio_file_page(folio, swp_offset(entry));
swapcache = folio;
if (!folio) {
if (data_race(si->flags & SWP_SYNCHRONOUS_IO) &&
__swap_count(entry) == 1) {
folio = vma_alloc_folio(GFP_HIGHUSER_MOVABLE, 0,
vma, vmf->address, false);
page = &folio->page;
if (folio) {
__folio_set_locked(folio);
__folio_set_swapbacked(folio);
if (mem_cgroup_swapin_charge_folio(folio,
vma->vm_mm, GFP_KERNEL,
entry)) {
ret = VM_FAULT_OOM;
goto out_page;
}
mem_cgroup_swapin_uncharge_swap(entry);
shadow = get_shadow_from_swap_cache(entry);
if (shadow)
workingset_refault(folio, shadow);
folio_add_lru(folio);
folio_set_swap_entry(folio, entry);
swap_readpage(page, true, NULL);
folio->private = NULL;
}
} else {
page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,
vmf);
if (page)
folio = page_folio(page);
swapcache = folio;
}
if (!folio) {
vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,
vmf->address, &vmf->ptl);
if (likely(pte_same(*vmf->pte, vmf->orig_pte)))
ret = VM_FAULT_OOM;
goto unlock;
}
ret = VM_FAULT_MAJOR;
count_vm_event(PGMAJFAULT);
count_memcg_event_mm(vma->vm_mm, PGMAJFAULT);
} else if (PageHWPoison(page)) {
ret = VM_FAULT_HWPOISON;
goto out_release;
}
locked = folio_lock_or_retry(folio, vma->vm_mm, vmf->flags);
if (!locked) {
ret |= VM_FAULT_RETRY;
goto out_release;
}
if (swapcache) {
if (unlikely(!folio_test_swapcache(folio) ||
page_private(page) != entry.val))
goto out_page;
page = ksm_might_need_to_copy(page, vma, vmf->address);
if (unlikely(!page)) {
ret = VM_FAULT_OOM;
goto out_page;
}
folio = page_folio(page);
if ((vmf->flags & FAULT_FLAG_WRITE) && folio == swapcache &&
!folio_test_ksm(folio) && !folio_test_lru(folio))
lru_add_drain();
}
cgroup_throttle_swaprate(page, GFP_KERNEL);
vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,
&vmf->ptl);
if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))
goto out_nomap;
if (unlikely(!folio_test_uptodate(folio))) {
ret = VM_FAULT_SIGBUS;
goto out_nomap;
}
BUG_ON(!folio_test_anon(folio) && folio_test_mappedtodisk(folio));
BUG_ON(folio_test_anon(folio) && PageAnonExclusive(page));
if (!folio_test_ksm(folio)) {
exclusive = pte_swp_exclusive(vmf->orig_pte);
if (folio != swapcache) {
exclusive = true;
} else if (exclusive && folio_test_writeback(folio) &&
data_race(si->flags & SWP_STABLE_WRITES)) {
exclusive = false;
}
}
swap_free(entry);
if (should_try_to_free_swap(folio, vma, vmf->flags))
folio_free_swap(folio);
inc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);
dec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);
pte = mk_pte(page, vma->vm_page_prot);
if (!folio_test_ksm(folio) &&
(exclusive || folio_ref_count(folio) == 1)) {
if (vmf->flags & FAULT_FLAG_WRITE) {
pte = maybe_mkwrite(pte_mkdirty(pte), vma);
vmf->flags &= ~FAULT_FLAG_WRITE;
ret |= VM_FAULT_WRITE;
}
rmap_flags |= RMAP_EXCLUSIVE;
}
flush_icache_page(vma, page);
if (pte_swp_soft_dirty(vmf->orig_pte))
pte = pte_mksoft_dirty(pte);
if (pte_swp_uffd_wp(vmf->orig_pte)) {
pte = pte_mkuffd_wp(pte);
pte = pte_wrprotect(pte);
}
vmf->orig_pte = pte;
if (unlikely(folio != swapcache && swapcache)) {
page_add_new_anon_rmap(page, vma, vmf->address);
folio_add_lru_vma(folio, vma);
} else {
page_add_anon_rmap(page, vma, vmf->address, rmap_flags);
}
VM_BUG_ON(!folio_test_anon(folio) ||
(pte_write(pte) && !PageAnonExclusive(page)));
set_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);
arch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);
folio_unlock(folio);
if (folio != swapcache && swapcache) {
folio_unlock(swapcache);
folio_put(swapcache);
}
if (vmf->flags & FAULT_FLAG_WRITE) {
ret |= do_wp_page(vmf);
if (ret & VM_FAULT_ERROR)
ret &= VM_FAULT_ERROR;
goto out;
}
update_mmu_cache(vma, vmf->address, vmf->pte);
unlock:
pte_unmap_unlock(vmf->pte, vmf->ptl);
out:
if (si)
put_swap_device(si);
return ret;
out_nomap:
pte_unmap_unlock(vmf->pte, vmf->ptl);
out_page:
folio_unlock(folio);
out_release:
folio_put(folio);
if (folio != swapcache && swapcache) {
folio_unlock(swapcache);
folio_put(swapcache);
}
if (si)
put_swap_device(si);
return ret;
}","vm_fault_t do_swap_page(struct vm_fault *VAR_0)
{
struct vm_area_struct *VAR_1 = VAR_0->vma;
struct folio *VAR_2, *folio = NULL;
struct page *page;
struct swap_info_struct *VAR_3 = NULL;
rmap_t VAR_4 = VAR_5;
bool VAR_6 = false;
swp_entry_t VAR_7;
pte_t VAR_8;
int VAR_9;
vm_fault_t VAR_10 = 0;
void *VAR_11 = NULL;
if (!pte_unmap_same(VAR_0))
goto out;
VAR_7 = pte_to_swp_entry(VAR_0->orig_pte);
if (unlikely(non_swap_entry(VAR_7))) {
if (is_migration_entry(VAR_7)) {
migration_entry_wait(VAR_1->vm_mm, VAR_0->pmd,
VAR_0->address);
} else if (is_device_exclusive_entry(VAR_7)) {
VAR_0->page = pfn_swap_entry_to_page(VAR_7);
VAR_10 = remove_device_exclusive_entry(VAR_0);
} else if (is_device_private_entry(VAR_7)) {
VAR_0->page = pfn_swap_entry_to_page(VAR_7);
VAR_10 = VAR_0->page->pgmap->ops->migrate_to_ram(VAR_0);
} else if (is_hwpoison_entry(VAR_7)) {
VAR_10 = VAR_12;
} else if (is_swapin_error_entry(VAR_7)) {
VAR_10 = VAR_13;
} else if (is_pte_marker_entry(VAR_7)) {
VAR_10 = handle_pte_marker(VAR_0);
} else {
print_bad_pte(VAR_1, VAR_0->address, VAR_0->orig_pte, NULL);
VAR_10 = VAR_13;
}
goto out;
}
VAR_3 = get_swap_device(VAR_7);
if (unlikely(!VAR_3))
goto out;
folio = swap_cache_get_folio(VAR_7, VAR_1, VAR_0->address);
if (folio)
page = folio_file_page(folio, swp_offset(VAR_7));
VAR_2 = folio;
if (!folio) {
if (data_race(VAR_3->flags & VAR_14) &&
__swap_count(VAR_7) == 1) {
folio = vma_alloc_folio(VAR_15, 0,
VAR_1, VAR_0->address, false);
page = &folio->page;
if (folio) {
__folio_set_locked(folio);
__folio_set_swapbacked(folio);
if (mem_cgroup_swapin_charge_folio(folio,
VAR_1->vm_mm, VAR_16,
VAR_7)) {
VAR_10 = VAR_17;
goto out_page;
}
mem_cgroup_swapin_uncharge_swap(VAR_7);
VAR_11 = get_shadow_from_swap_cache(VAR_7);
if (VAR_11)
workingset_refault(folio, VAR_11);
folio_add_lru(folio);
folio_set_swap_entry(folio, VAR_7);
swap_readpage(page, true, NULL);
folio->private = NULL;
}
} else {
page = swapin_readahead(VAR_7, VAR_15,
VAR_0);
if (page)
folio = page_folio(page);
VAR_2 = folio;
}
if (!folio) {
VAR_0->pte = pte_offset_map_lock(VAR_1->vm_mm, VAR_0->pmd,
VAR_0->address, &VAR_0->ptl);
if (likely(pte_same(*VAR_0->pte, VAR_0->orig_pte)))
VAR_10 = VAR_17;
goto unlock;
}
VAR_10 = VAR_18;
count_vm_event(VAR_19);
count_memcg_event_mm(VAR_1->vm_mm, VAR_19);
} else if (PageHWPoison(page)) {
VAR_10 = VAR_12;
goto out_release;
}
VAR_9 = folio_lock_or_retry(folio, VAR_1->vm_mm, VAR_0->flags);
if (!VAR_9) {
VAR_10 |= VAR_20;
goto out_release;
}
if (VAR_2) {
if (unlikely(!folio_test_swapcache(folio) ||
page_private(page) != VAR_7.val))
goto out_page;
page = ksm_might_need_to_copy(page, VAR_1, VAR_0->address);
if (unlikely(!page)) {
VAR_10 = VAR_17;
goto out_page;
}
folio = page_folio(page);
if ((VAR_0->flags & VAR_21) && folio == VAR_2 &&
!folio_test_ksm(folio) && !folio_test_lru(folio))
lru_add_drain();
}
cgroup_throttle_swaprate(page, VAR_16);
VAR_0->pte = pte_offset_map_lock(VAR_1->vm_mm, VAR_0->pmd, VAR_0->address,
&VAR_0->ptl);
if (unlikely(!pte_same(*VAR_0->pte, VAR_0->orig_pte)))
goto out_nomap;
if (unlikely(!folio_test_uptodate(folio))) {
VAR_10 = VAR_13;
goto out_nomap;
}
BUG_ON(!folio_test_anon(folio) && folio_test_mappedtodisk(folio));
BUG_ON(folio_test_anon(folio) && PageAnonExclusive(page));
if (!folio_test_ksm(folio)) {
VAR_6 = pte_swp_exclusive(VAR_0->orig_pte);
if (folio != VAR_2) {
VAR_6 = true;
} else if (VAR_6 && folio_test_writeback(folio) &&
data_race(VAR_3->flags & VAR_22)) {
VAR_6 = false;
}
}
swap_free(VAR_7);
if (should_try_to_free_swap(folio, VAR_1, VAR_0->flags))
folio_free_swap(folio);
inc_mm_counter_fast(VAR_1->vm_mm, VAR_23);
dec_mm_counter_fast(VAR_1->vm_mm, VAR_24);
VAR_8 = mk_pte(page, VAR_1->vm_page_prot);
if (!folio_test_ksm(folio) &&
(VAR_6 || folio_ref_count(folio) == 1)) {
if (VAR_0->flags & VAR_21) {
VAR_8 = maybe_mkwrite(pte_mkdirty(VAR_8), VAR_1);
VAR_0->flags &= ~VAR_21;
VAR_10 |= VAR_25;
}
VAR_4 |= VAR_26;
}
flush_icache_page(VAR_1, page);
if (pte_swp_soft_dirty(VAR_0->orig_pte))
VAR_8 = pte_mksoft_dirty(VAR_8);
if (pte_swp_uffd_wp(VAR_0->orig_pte)) {
VAR_8 = pte_mkuffd_wp(VAR_8);
VAR_8 = pte_wrprotect(VAR_8);
}
VAR_0->orig_pte = VAR_8;
if (unlikely(folio != VAR_2 && VAR_2)) {
page_add_new_anon_rmap(page, VAR_1, VAR_0->address);
folio_add_lru_vma(folio, VAR_1);
} else {
page_add_anon_rmap(page, VAR_1, VAR_0->address, VAR_4);
}
VM_BUG_ON(!folio_test_anon(folio) ||
(pte_write(VAR_8) && !PageAnonExclusive(page)));
set_pte_at(VAR_1->vm_mm, VAR_0->address, VAR_0->pte, VAR_8);
arch_do_swap_page(VAR_1->vm_mm, VAR_1, VAR_0->address, VAR_8, VAR_0->orig_pte);
folio_unlock(folio);
if (folio != VAR_2 && VAR_2) {
folio_unlock(VAR_2);
folio_put(VAR_2);
}
if (VAR_0->flags & VAR_21) {
VAR_10 |= do_wp_page(VAR_0);
if (VAR_10 & VAR_27)
VAR_10 &= VAR_27;
goto out;
}
update_mmu_cache(VAR_1, VAR_0->address, VAR_0->pte);
unlock:
pte_unmap_unlock(VAR_0->pte, VAR_0->ptl);
out:
if (VAR_3)
put_swap_device(VAR_3);
return VAR_10;
out_nomap:
pte_unmap_unlock(VAR_0->pte, VAR_0->ptl);
out_page:
folio_unlock(folio);
out_release:
folio_put(folio);
if (folio != VAR_2 && VAR_2) {
folio_unlock(VAR_2);
folio_put(VAR_2);
}
if (VAR_3)
put_swap_device(VAR_3);
return VAR_10;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/memory.c/vul/before/0.json,"vm_fault_t do_swap_page(struct vm_fault *vmf)
{
	struct vm_area_struct *vma = vmf->vma;
	struct folio *swapcache, *folio = NULL;
	struct page *page;
	struct swap_info_struct *si = NULL;
	rmap_t rmap_flags = RMAP_NONE;
	bool exclusive = false;
	swp_entry_t entry;
	pte_t pte;
	int locked;
	vm_fault_t ret = 0;
	void *shadow = NULL;

	if (!pte_unmap_same(vmf))
		goto out;

	entry = pte_to_swp_entry(vmf->orig_pte);
	if (unlikely(non_swap_entry(entry))) {
		if (is_migration_entry(entry)) {
			migration_entry_wait(vma->vm_mm, vmf->pmd,
					     vmf->address);
		} else if (is_device_exclusive_entry(entry)) {
			vmf->page = pfn_swap_entry_to_page(entry);
			ret = remove_device_exclusive_entry(vmf);
		} else if (is_device_private_entry(entry)) {
			vmf->page = pfn_swap_entry_to_page(entry);
			vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,
					vmf->address, &vmf->ptl);
			if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {
				spin_unlock(vmf->ptl);
				goto out;
			}

			/*
			 * Get a page reference while we know the page can't be
			 * freed.
			 */
			get_page(vmf->page);
			pte_unmap_unlock(vmf->pte, vmf->ptl);
			vmf->page->pgmap->ops->migrate_to_ram(vmf);
			put_page(vmf->page);
		} else if (is_hwpoison_entry(entry)) {
			ret = VM_FAULT_HWPOISON;
		} else if (is_swapin_error_entry(entry)) {
			ret = VM_FAULT_SIGBUS;
		} else if (is_pte_marker_entry(entry)) {
			ret = handle_pte_marker(vmf);
		} else {
			print_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);
			ret = VM_FAULT_SIGBUS;
		}
		goto out;
	}

	/* Prevent swapoff from happening to us. */
	si = get_swap_device(entry);
	if (unlikely(!si))
		goto out;

	folio = swap_cache_get_folio(entry, vma, vmf->address);
	if (folio)
		page = folio_file_page(folio, swp_offset(entry));
	swapcache = folio;

	if (!folio) {
		if (data_race(si->flags & SWP_SYNCHRONOUS_IO) &&
		    __swap_count(entry) == 1) {
			/* skip swapcache */
			folio = vma_alloc_folio(GFP_HIGHUSER_MOVABLE, 0,
						vma, vmf->address, false);
			page = &folio->page;
			if (folio) {
				__folio_set_locked(folio);
				__folio_set_swapbacked(folio);

				if (mem_cgroup_swapin_charge_folio(folio,
							vma->vm_mm, GFP_KERNEL,
							entry)) {
					ret = VM_FAULT_OOM;
					goto out_page;
				}
				mem_cgroup_swapin_uncharge_swap(entry);

				shadow = get_shadow_from_swap_cache(entry);
				if (shadow)
					workingset_refault(folio, shadow);

				folio_add_lru(folio);

				/* To provide entry to swap_readpage() */
				folio_set_swap_entry(folio, entry);
				swap_readpage(page, true, NULL);
				folio->private = NULL;
			}
		} else {
			page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,
						vmf);
			if (page)
				folio = page_folio(page);
			swapcache = folio;
		}

		if (!folio) {
			/*
			 * Back out if somebody else faulted in this pte
			 * while we released the pte lock.
			 */
			vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,
					vmf->address, &vmf->ptl);
			if (likely(pte_same(*vmf->pte, vmf->orig_pte)))
				ret = VM_FAULT_OOM;
			goto unlock;
		}

		/* Had to read the page from swap area: Major fault */
		ret = VM_FAULT_MAJOR;
		count_vm_event(PGMAJFAULT);
		count_memcg_event_mm(vma->vm_mm, PGMAJFAULT);
	} else if (PageHWPoison(page)) {
		/*
		 * hwpoisoned dirty swapcache pages are kept for killing
		 * owner processes (which may be unknown at hwpoison time)
		 */
		ret = VM_FAULT_HWPOISON;
		goto out_release;
	}

	locked = folio_lock_or_retry(folio, vma->vm_mm, vmf->flags);

	if (!locked) {
		ret |= VM_FAULT_RETRY;
		goto out_release;
	}

	if (swapcache) {
		/*
		 * Make sure folio_free_swap() or swapoff did not release the
		 * swapcache from under us.  The page pin, and pte_same test
		 * below, are not enough to exclude that.  Even if it is still
		 * swapcache, we need to check that the page's swap has not
		 * changed.
		 */
		if (unlikely(!folio_test_swapcache(folio) ||
			     page_private(page) != entry.val))
			goto out_page;

		/*
		 * KSM sometimes has to copy on read faults, for example, if
		 * page->index of !PageKSM() pages would be nonlinear inside the
		 * anon VMA -- PageKSM() is lost on actual swapout.
		 */
		page = ksm_might_need_to_copy(page, vma, vmf->address);
		if (unlikely(!page)) {
			ret = VM_FAULT_OOM;
			goto out_page;
		}
		folio = page_folio(page);

		/*
		 * If we want to map a page that's in the swapcache writable, we
		 * have to detect via the refcount if we're really the exclusive
		 * owner. Try removing the extra reference from the local LRU
		 * pagevecs if required.
		 */
		if ((vmf->flags & FAULT_FLAG_WRITE) && folio == swapcache &&
		    !folio_test_ksm(folio) && !folio_test_lru(folio))
			lru_add_drain();
	}

	cgroup_throttle_swaprate(page, GFP_KERNEL);

	/*
	 * Back out if somebody else already faulted in this pte.
	 */
	vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,
			&vmf->ptl);
	if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))
		goto out_nomap;

	if (unlikely(!folio_test_uptodate(folio))) {
		ret = VM_FAULT_SIGBUS;
		goto out_nomap;
	}

	/*
	 * PG_anon_exclusive reuses PG_mappedtodisk for anon pages. A swap pte
	 * must never point at an anonymous page in the swapcache that is
	 * PG_anon_exclusive. Sanity check that this holds and especially, that
	 * no filesystem set PG_mappedtodisk on a page in the swapcache. Sanity
	 * check after taking the PT lock and making sure that nobody
	 * concurrently faulted in this page and set PG_anon_exclusive.
	 */
	BUG_ON(!folio_test_anon(folio) && folio_test_mappedtodisk(folio));
	BUG_ON(folio_test_anon(folio) && PageAnonExclusive(page));

	/*
	 * Check under PT lock (to protect against concurrent fork() sharing
	 * the swap entry concurrently) for certainly exclusive pages.
	 */
	if (!folio_test_ksm(folio)) {
		/*
		 * Note that pte_swp_exclusive() == false for architectures
		 * without __HAVE_ARCH_PTE_SWP_EXCLUSIVE.
		 */
		exclusive = pte_swp_exclusive(vmf->orig_pte);
		if (folio != swapcache) {
			/*
			 * We have a fresh page that is not exposed to the
			 * swapcache -> certainly exclusive.
			 */
			exclusive = true;
		} else if (exclusive && folio_test_writeback(folio) &&
			  data_race(si->flags & SWP_STABLE_WRITES)) {
			/*
			 * This is tricky: not all swap backends support
			 * concurrent page modifications while under writeback.
			 *
			 * So if we stumble over such a page in the swapcache
			 * we must not set the page exclusive, otherwise we can
			 * map it writable without further checks and modify it
			 * while still under writeback.
			 *
			 * For these problematic swap backends, simply drop the
			 * exclusive marker: this is perfectly fine as we start
			 * writeback only if we fully unmapped the page and
			 * there are no unexpected references on the page after
			 * unmapping succeeded. After fully unmapped, no
			 * further GUP references (FOLL_GET and FOLL_PIN) can
			 * appear, so dropping the exclusive marker and mapping
			 * it only R/O is fine.
			 */
			exclusive = false;
		}
	}

	/*
	 * Remove the swap entry and conditionally try to free up the swapcache.
	 * We're already holding a reference on the page but haven't mapped it
	 * yet.
	 */
	swap_free(entry);
	if (should_try_to_free_swap(folio, vma, vmf->flags))
		folio_free_swap(folio);

	inc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);
	dec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);
	pte = mk_pte(page, vma->vm_page_prot);

	/*
	 * Same logic as in do_wp_page(); however, optimize for pages that are
	 * certainly not shared either because we just allocated them without
	 * exposing them to the swapcache or because the swap entry indicates
	 * exclusivity.
	 */
	if (!folio_test_ksm(folio) &&
	    (exclusive || folio_ref_count(folio) == 1)) {
		if (vmf->flags & FAULT_FLAG_WRITE) {
			pte = maybe_mkwrite(pte_mkdirty(pte), vma);
			vmf->flags &= ~FAULT_FLAG_WRITE;
			ret |= VM_FAULT_WRITE;
		}
		rmap_flags |= RMAP_EXCLUSIVE;
	}
	flush_icache_page(vma, page);
	if (pte_swp_soft_dirty(vmf->orig_pte))
		pte = pte_mksoft_dirty(pte);
	if (pte_swp_uffd_wp(vmf->orig_pte)) {
		pte = pte_mkuffd_wp(pte);
		pte = pte_wrprotect(pte);
	}
	vmf->orig_pte = pte;

	/* ksm created a completely new copy */
	if (unlikely(folio != swapcache && swapcache)) {
		page_add_new_anon_rmap(page, vma, vmf->address);
		folio_add_lru_vma(folio, vma);
	} else {
		page_add_anon_rmap(page, vma, vmf->address, rmap_flags);
	}

	VM_BUG_ON(!folio_test_anon(folio) ||
			(pte_write(pte) && !PageAnonExclusive(page)));
	set_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);
	arch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);

	folio_unlock(folio);
	if (folio != swapcache && swapcache) {
		/*
		 * Hold the lock to avoid the swap entry to be reused
		 * until we take the PT lock for the pte_same() check
		 * (to avoid false positives from pte_same). For
		 * further safety release the lock after the swap_free
		 * so that the swap count won't change under a
		 * parallel locked swapcache.
		 */
		folio_unlock(swapcache);
		folio_put(swapcache);
	}

	if (vmf->flags & FAULT_FLAG_WRITE) {
		ret |= do_wp_page(vmf);
		if (ret & VM_FAULT_ERROR)
			ret &= VM_FAULT_ERROR;
		goto out;
	}

	/* No need to invalidate - it was non-present before */
	update_mmu_cache(vma, vmf->address, vmf->pte);
unlock:
	pte_unmap_unlock(vmf->pte, vmf->ptl);
out:
	if (si)
		put_swap_device(si);
	return ret;
out_nomap:
	pte_unmap_unlock(vmf->pte, vmf->ptl);
out_page:
	folio_unlock(folio);
out_release:
	folio_put(folio);
	if (folio != swapcache && swapcache) {
		folio_unlock(swapcache);
		folio_put(swapcache);
	}
	if (si)
		put_swap_device(si);
	return ret;
}","vm_fault_t do_swap_page(struct vm_fault *VAR_0)
{
	struct vm_area_struct *VAR_1 = VAR_0->vma;
	struct folio *VAR_2, *folio = NULL;
	struct page *page;
	struct swap_info_struct *VAR_3 = NULL;
	rmap_t VAR_4 = VAR_5;
	bool VAR_6 = false;
	swp_entry_t VAR_7;
	pte_t VAR_8;
	int VAR_9;
	vm_fault_t VAR_10 = 0;
	void *VAR_11 = NULL;

	if (!pte_unmap_same(VAR_0))
		goto out;

	VAR_7 = pte_to_swp_entry(VAR_0->orig_pte);
	if (unlikely(non_swap_entry(VAR_7))) {
		if (is_migration_entry(VAR_7)) {
			migration_entry_wait(VAR_1->vm_mm, VAR_0->pmd,
					     VAR_0->address);
		} else if (is_device_exclusive_entry(VAR_7)) {
			VAR_0->page = pfn_swap_entry_to_page(VAR_7);
			VAR_10 = remove_device_exclusive_entry(VAR_0);
		} else if (is_device_private_entry(VAR_7)) {
			VAR_0->page = pfn_swap_entry_to_page(VAR_7);
			VAR_0->pte = pte_offset_map_lock(VAR_1->vm_mm, VAR_0->pmd,
					VAR_0->address, &VAR_0->ptl);
			if (unlikely(!pte_same(*VAR_0->pte, VAR_0->orig_pte))) {
				spin_unlock(VAR_0->ptl);
				goto out;
			}

			/* COMMENT_0 */
                                                          
            
      
			get_page(VAR_0->page);
			pte_unmap_unlock(VAR_0->pte, VAR_0->ptl);
			VAR_0->page->pgmap->ops->migrate_to_ram(VAR_0);
			put_page(VAR_0->page);
		} else if (is_hwpoison_entry(VAR_7)) {
			VAR_10 = VAR_12;
		} else if (is_swapin_error_entry(VAR_7)) {
			VAR_10 = VAR_13;
		} else if (is_pte_marker_entry(VAR_7)) {
			VAR_10 = handle_pte_marker(VAR_0);
		} else {
			print_bad_pte(VAR_1, VAR_0->address, VAR_0->orig_pte, NULL);
			VAR_10 = VAR_13;
		}
		goto out;
	}

	/* COMMENT_4 */
	VAR_3 = get_swap_device(VAR_7);
	if (unlikely(!VAR_3))
		goto out;

	folio = swap_cache_get_folio(VAR_7, VAR_1, VAR_0->address);
	if (folio)
		page = folio_file_page(folio, swp_offset(VAR_7));
	VAR_2 = folio;

	if (!folio) {
		if (data_race(VAR_3->flags & VAR_14) &&
		    __swap_count(VAR_7) == 1) {
			/* COMMENT_5 */
			folio = vma_alloc_folio(VAR_15, 0,
						VAR_1, VAR_0->address, false);
			page = &folio->page;
			if (folio) {
				__folio_set_locked(folio);
				__folio_set_swapbacked(folio);

				if (mem_cgroup_swapin_charge_folio(folio,
							VAR_1->vm_mm, VAR_16,
							VAR_7)) {
					VAR_10 = VAR_17;
					goto out_page;
				}
				mem_cgroup_swapin_uncharge_swap(VAR_7);

				VAR_11 = get_shadow_from_swap_cache(VAR_7);
				if (VAR_11)
					workingset_refault(folio, VAR_11);

				folio_add_lru(folio);

				/* COMMENT_6 */
				folio_set_swap_entry(folio, VAR_7);
				swap_readpage(page, true, NULL);
				folio->private = NULL;
			}
		} else {
			page = swapin_readahead(VAR_7, VAR_15,
						VAR_0);
			if (page)
				folio = page_folio(page);
			VAR_2 = folio;
		}

		if (!folio) {
			/* COMMENT_7 */
                                                   
                                     
      
			VAR_0->pte = pte_offset_map_lock(VAR_1->vm_mm, VAR_0->pmd,
					VAR_0->address, &VAR_0->ptl);
			if (likely(pte_same(*VAR_0->pte, VAR_0->orig_pte)))
				VAR_10 = VAR_17;
			goto unlock;
		}

		/* COMMENT_11 */
		VAR_10 = VAR_18;
		count_vm_event(VAR_19);
		count_memcg_event_mm(VAR_1->vm_mm, VAR_19);
	} else if (PageHWPoison(page)) {
		/* COMMENT_12 */
                                                          
                                                            
     
		VAR_10 = VAR_12;
		goto out_release;
	}

	VAR_9 = folio_lock_or_retry(folio, VAR_1->vm_mm, VAR_0->flags);

	if (!VAR_9) {
		VAR_10 |= VAR_20;
		goto out_release;
	}

	if (VAR_2) {
		/* COMMENT_16 */
                                                               
                                                              
                                                                
                                                             
             
     
		if (unlikely(!folio_test_swapcache(folio) ||
			     page_private(page) != VAR_7.val))
			goto out_page;

		/* COMMENT_23 */
                                                              
                                                                  
                                                     
     
		page = ksm_might_need_to_copy(page, VAR_1, VAR_0->address);
		if (unlikely(!page)) {
			VAR_10 = VAR_17;
			goto out_page;
		}
		folio = page_folio(page);

		/* COMMENT_28 */
                                                                  
                                                                  
                                                               
                          
     
		if ((VAR_0->flags & VAR_21) && folio == VAR_2 &&
		    !folio_test_ksm(folio) && !folio_test_lru(folio))
			lru_add_drain();
	}

	cgroup_throttle_swaprate(page, VAR_16);

	/* COMMENT_34 */
                                                          
    
	VAR_0->pte = pte_offset_map_lock(VAR_1->vm_mm, VAR_0->pmd, VAR_0->address,
			&VAR_0->ptl);
	if (unlikely(!pte_same(*VAR_0->pte, VAR_0->orig_pte)))
		goto out_nomap;

	if (unlikely(!folio_test_uptodate(folio))) {
		VAR_10 = VAR_13;
		goto out_nomap;
	}

	/* COMMENT_37 */
                                                                       
                                                                  
                                                                        
                                                                        
                                                              
                                                                
    
	BUG_ON(!folio_test_anon(folio) && folio_test_mappedtodisk(folio));
	BUG_ON(folio_test_anon(folio) && PageAnonExclusive(page));

	/* COMMENT_45 */
                                                                     
                                                               
    
	if (!folio_test_ksm(folio)) {
		/* COMMENT_49 */
                                                             
                                           
     
		VAR_6 = pte_swp_exclusive(VAR_0->orig_pte);
		if (folio != VAR_2) {
			/* COMMENT_53 */
                                                     
                                       
      
			VAR_6 = true;
		} else if (VAR_6 && folio_test_writeback(folio) &&
			  data_race(VAR_3->flags & VAR_22)) {
			/* COMMENT_57 */
                                                   
                                                          
     
                                                        
                                                          
                                                          
                                  
     
                                                          
                                                          
                                                      
                                                          
                                                   
                                                        
                                                          
                          
      
			VAR_6 = false;
		}
	}

	/* COMMENT_74 */
                                                                         
                                                                       
        
    
	swap_free(VAR_7);
	if (should_try_to_free_swap(folio, VAR_1, VAR_0->flags))
		folio_free_swap(folio);

	inc_mm_counter_fast(VAR_1->vm_mm, VAR_23);
	dec_mm_counter_fast(VAR_1->vm_mm, VAR_24);
	VAR_8 = mk_pte(page, VAR_1->vm_page_prot);

	/* COMMENT_79 */
                                                                       
                                                                      
                                                                      
                
    
	if (!folio_test_ksm(folio) &&
	    (VAR_6 || folio_ref_count(folio) == 1)) {
		if (VAR_0->flags & VAR_21) {
			VAR_8 = maybe_mkwrite(pte_mkdirty(VAR_8), VAR_1);
			VAR_0->flags &= ~VAR_21;
			VAR_10 |= VAR_25;
		}
		VAR_4 |= VAR_26;
	}
	flush_icache_page(VAR_1, page);
	if (pte_swp_soft_dirty(VAR_0->orig_pte))
		VAR_8 = pte_mksoft_dirty(VAR_8);
	if (pte_swp_uffd_wp(VAR_0->orig_pte)) {
		VAR_8 = pte_mkuffd_wp(VAR_8);
		VAR_8 = pte_wrprotect(VAR_8);
	}
	VAR_0->orig_pte = VAR_8;

	/* COMMENT_85 */
	if (unlikely(folio != VAR_2 && VAR_2)) {
		page_add_new_anon_rmap(page, VAR_1, VAR_0->address);
		folio_add_lru_vma(folio, VAR_1);
	} else {
		page_add_anon_rmap(page, VAR_1, VAR_0->address, VAR_4);
	}

	VM_BUG_ON(!folio_test_anon(folio) ||
			(pte_write(VAR_8) && !PageAnonExclusive(page)));
	set_pte_at(VAR_1->vm_mm, VAR_0->address, VAR_0->pte, VAR_8);
	arch_do_swap_page(VAR_1->vm_mm, VAR_1, VAR_0->address, VAR_8, VAR_0->orig_pte);

	folio_unlock(folio);
	if (folio != VAR_2 && VAR_2) {
		/* COMMENT_86 */
                                                       
                                                       
                                                  
                                                        
                                                
                               
     
		folio_unlock(VAR_2);
		folio_put(VAR_2);
	}

	if (VAR_0->flags & VAR_21) {
		VAR_10 |= do_wp_page(VAR_0);
		if (VAR_10 & VAR_27)
			VAR_10 &= VAR_27;
		goto out;
	}

	/* COMMENT_94 */
	update_mmu_cache(VAR_1, VAR_0->address, VAR_0->pte);
unlock:
	pte_unmap_unlock(VAR_0->pte, VAR_0->ptl);
out:
	if (VAR_3)
		put_swap_device(VAR_3);
	return VAR_10;
out_nomap:
	pte_unmap_unlock(VAR_0->pte, VAR_0->ptl);
out_page:
	folio_unlock(folio);
out_release:
	folio_put(folio);
	if (folio != VAR_2 && VAR_2) {
		folio_unlock(VAR_2);
		folio_put(VAR_2);
	}
	if (VAR_3)
		put_swap_device(VAR_3);
	return VAR_10;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/memory.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,21 @@
 			ret = remove_device_exclusive_entry(vmf);
 		} else if (is_device_private_entry(entry)) {
 			vmf->page = pfn_swap_entry_to_page(entry);
-			ret = vmf->page->pgmap->ops->migrate_to_ram(vmf);
+			vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,
+					vmf->address, &vmf->ptl);
+			if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {
+				spin_unlock(vmf->ptl);
+				goto out;
+			}
+
+			/*
+			 * Get a page reference while we know the page can't be
+			 * freed.
+			 */
+			get_page(vmf->page);
+			pte_unmap_unlock(vmf->pte, vmf->ptl);
+			vmf->page->pgmap->ops->migrate_to_ram(vmf);
+			put_page(vmf->page);
 		} else if (is_hwpoison_entry(entry)) {
 			ret = VM_FAULT_HWPOISON;
 		} else if (is_swapin_error_entry(entry)) {","{'deleted_lines': ['\t\t\tret = vmf->page->pgmap->ops->migrate_to_ram(vmf);'], 'added_lines': ['\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,', '\t\t\t\t\tvmf->address, &vmf->ptl);', '\t\t\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {', '\t\t\t\tspin_unlock(vmf->ptl);', '\t\t\t\tgoto out;', '\t\t\t}', '', '\t\t\t/*', ""\t\t\t * Get a page reference while we know the page can't be"", '\t\t\t * freed.', '\t\t\t */', '\t\t\tget_page(vmf->page);', '\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);', '\t\t\tvmf->page->pgmap->ops->migrate_to_ram(vmf);', '\t\t\tput_page(vmf->page);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/migrate_device.c,migrate_vma_check_page,"static bool migrate_vma_check_page(struct page *page)
{
int extra = 1;
if (PageCompound(page))
return false;
if (is_zone_device_page(page))
extra++;
if (page_mapping(page))
extra += 1 + page_has_private(page);
if ((page_count(page) - extra) > page_mapcount(page))
return false;
return true;
}","static bool migrate_vma_check_page(struct page *page)
{
int VAR_0 = 1;
if (PageCompound(page))
return false;
if (is_zone_device_page(page))
VAR_0++;
if (page_mapping(page))
VAR_0 += 1 + page_has_private(page);
if ((page_count(page) - VAR_0) > page_mapcount(page))
return false;
return true;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/before/0.json,"static bool migrate_vma_check_page(struct page *page, struct page *fault_page)
{
	/*
	 * One extra ref because caller holds an extra reference, either from
	 * isolate_lru_page() for a regular page, or migrate_vma_collect() for
	 * a device page.
	 */
	int extra = 1 + (page == fault_page);

	/*
	 * FIXME support THP (transparent huge page), it is bit more complex to
	 * check them than regular pages, because they can be mapped with a pmd
	 * or with a pte (split pte mapping).
	 */
	if (PageCompound(page))
		return false;

	/* Page from ZONE_DEVICE have one extra reference */
	if (is_zone_device_page(page))
		extra++;

	/* For file back page */
	if (page_mapping(page))
		extra += 1 + page_has_private(page);

	if ((page_count(page) - extra) > page_mapcount(page))
		return false;

	return true;
}","static bool migrate_vma_check_page(struct page *page, struct page *VAR_0)
{
	/* COMMENT_0 */
                                                                      
                                                                       
                  
    
	int VAR_1 = 1 + (page == VAR_0);

	/* COMMENT_5 */
                                                                        
                                                                        
                                      
    
	if (PageCompound(page))
		return false;

	/* COMMENT_10 */
	if (is_zone_device_page(page))
		VAR_1++;

	/* COMMENT_11 */
	if (page_mapping(page))
		VAR_1 += 1 + page_has_private(page);

	if ((page_count(page) - VAR_1) > page_mapcount(page))
		return false;

	return true;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
-static bool migrate_vma_check_page(struct page *page)
+static bool migrate_vma_check_page(struct page *page, struct page *fault_page)
 {
 	/*
 	 * One extra ref because caller holds an extra reference, either from
 	 * isolate_lru_page() for a regular page, or migrate_vma_collect() for
 	 * a device page.
 	 */
-	int extra = 1;
+	int extra = 1 + (page == fault_page);
 
 	/*
 	 * FIXME support THP (transparent huge page), it is bit more complex to","{'deleted_lines': ['static bool migrate_vma_check_page(struct page *page)', '\tint extra = 1;'], 'added_lines': ['static bool migrate_vma_check_page(struct page *page, struct page *fault_page)', '\tint extra = 1 + (page == fault_page);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/migrate_device.c,migrate_vma_pages,"void migrate_vma_pages(struct migrate_vma *migrate)
{
const unsigned long npages = migrate->npages;
const unsigned long start = migrate->start;
struct mmu_notifier_range range;
unsigned long addr, i;
bool notified = false;
for (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {
struct page *newpage = migrate_pfn_to_page(migrate->dst[i]);
struct page *page = migrate_pfn_to_page(migrate->src[i]);
struct address_space *mapping;
int r;
if (!newpage) {
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
continue;
}
if (!page) {
VM_BUG_ON(!migrate->vma);
if (!(migrate->src[i] & MIGRATE_PFN_MIGRATE))
continue;
if (!notified) {
notified = true;
mmu_notifier_range_init_owner(&range,
MMU_NOTIFY_MIGRATE, 0, migrate->vma,
migrate->vma->vm_mm, addr, migrate->end,
migrate->pgmap_owner);
mmu_notifier_invalidate_range_start(&range);
}
migrate_vma_insert_page(migrate, addr, newpage,
&migrate->src[i]);
continue;
}
mapping = page_mapping(page);
if (is_device_private_page(newpage) ||
is_device_coherent_page(newpage)) {
if (mapping) {
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
continue;
}
} else if (is_zone_device_page(newpage)) {
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
continue;
}
r = migrate_folio(mapping, page_folio(newpage),
page_folio(page), MIGRATE_SYNC_NO_COPY);
if (r != MIGRATEPAGE_SUCCESS)
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
}
if (notified)
mmu_notifier_invalidate_range_only_end(&range);
}","void migrate_vma_pages(struct migrate_vma *VAR_0)
{
const unsigned long VAR_1 = VAR_0->npages;
const unsigned long VAR_2 = VAR_0->start;
struct mmu_notifier_range VAR_3;
unsigned long VAR_4, VAR_5;
bool VAR_6 = false;
for (VAR_5 = 0, VAR_4 = VAR_2; VAR_5 < VAR_1; VAR_4 += VAR_7, VAR_5++) {
struct page *VAR_8 = migrate_pfn_to_page(VAR_0->dst[VAR_5]);
struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_5]);
struct address_space *VAR_9;
int VAR_10;
if (!VAR_8) {
VAR_0->src[VAR_5] &= ~VAR_11;
continue;
}
if (!page) {
VM_BUG_ON(!VAR_0->vma);
if (!(VAR_0->src[VAR_5] & VAR_11))
continue;
if (!VAR_6) {
VAR_6 = true;
mmu_notifier_range_init_owner(&VAR_3,
VAR_12, 0, VAR_0->vma,
VAR_0->vma->vm_mm, VAR_4, VAR_0->end,
VAR_0->pgmap_owner);
mmu_notifier_invalidate_range_start(&VAR_3);
}
migrate_vma_insert_page(VAR_0, VAR_4, VAR_8,
&VAR_0->src[VAR_5]);
continue;
}
VAR_9 = page_mapping(page);
if (is_device_private_page(VAR_8) ||
is_device_coherent_page(VAR_8)) {
if (VAR_9) {
VAR_0->src[VAR_5] &= ~VAR_11;
continue;
}
} else if (is_zone_device_page(VAR_8)) {
VAR_0->src[VAR_5] &= ~VAR_11;
continue;
}
VAR_10 = migrate_folio(VAR_9, page_folio(VAR_8),
page_folio(page), VAR_13);
if (VAR_10 != VAR_14)
VAR_0->src[VAR_5] &= ~VAR_11;
}
if (VAR_6)
mmu_notifier_invalidate_range_only_end(&VAR_3);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/before/1.json,"void migrate_vma_pages(struct migrate_vma *migrate)
{
	const unsigned long npages = migrate->npages;
	const unsigned long start = migrate->start;
	struct mmu_notifier_range range;
	unsigned long addr, i;
	bool notified = false;

	for (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {
		struct page *newpage = migrate_pfn_to_page(migrate->dst[i]);
		struct page *page = migrate_pfn_to_page(migrate->src[i]);
		struct address_space *mapping;
		int r;

		if (!newpage) {
			migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
			continue;
		}

		if (!page) {
			/*
			 * The only time there is no vma is when called from
			 * migrate_device_coherent_page(). However this isn't
			 * called if the page could not be unmapped.
			 */
			VM_BUG_ON(!migrate->vma);
			if (!(migrate->src[i] & MIGRATE_PFN_MIGRATE))
				continue;
			if (!notified) {
				notified = true;

				mmu_notifier_range_init_owner(&range,
					MMU_NOTIFY_MIGRATE, 0, migrate->vma,
					migrate->vma->vm_mm, addr, migrate->end,
					migrate->pgmap_owner);
				mmu_notifier_invalidate_range_start(&range);
			}
			migrate_vma_insert_page(migrate, addr, newpage,
						&migrate->src[i]);
			continue;
		}

		mapping = page_mapping(page);

		if (is_device_private_page(newpage) ||
		    is_device_coherent_page(newpage)) {
			/*
			 * For now only support anonymous memory migrating to
			 * device private or coherent memory.
			 */
			if (mapping) {
				migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
				continue;
			}
		} else if (is_zone_device_page(newpage)) {
			/*
			 * Other types of ZONE_DEVICE page are not supported.
			 */
			migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
			continue;
		}

		if (migrate->fault_page == page)
			r = migrate_folio_extra(mapping, page_folio(newpage),
						page_folio(page),
						MIGRATE_SYNC_NO_COPY, 1);
		else
			r = migrate_folio(mapping, page_folio(newpage),
					page_folio(page), MIGRATE_SYNC_NO_COPY);
		if (r != MIGRATEPAGE_SUCCESS)
			migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
	}

	/*
	 * No need to double call mmu_notifier->invalidate_range() callback as
	 * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()
	 * did already call it.
	 */
	if (notified)
		mmu_notifier_invalidate_range_only_end(&range);
}","void migrate_vma_pages(struct migrate_vma *VAR_0)
{
	const unsigned long VAR_1 = VAR_0->npages;
	const unsigned long VAR_2 = VAR_0->start;
	struct mmu_notifier_range VAR_3;
	unsigned long VAR_4, VAR_5;
	bool VAR_6 = false;

	for (VAR_5 = 0, VAR_4 = VAR_2; VAR_5 < VAR_1; VAR_4 += VAR_7, VAR_5++) {
		struct page *VAR_8 = migrate_pfn_to_page(VAR_0->dst[VAR_5]);
		struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_5]);
		struct address_space *VAR_9;
		int VAR_10;

		if (!VAR_8) {
			VAR_0->src[VAR_5] &= ~VAR_11;
			continue;
		}

		if (!page) {
			/* COMMENT_0 */
                                                       
                                                        
                                               
      
			VM_BUG_ON(!VAR_0->vma);
			if (!(VAR_0->src[VAR_5] & VAR_11))
				continue;
			if (!VAR_6) {
				VAR_6 = true;

				mmu_notifier_range_init_owner(&VAR_3,
					VAR_12, 0, VAR_0->vma,
					VAR_0->vma->vm_mm, VAR_4, VAR_0->end,
					VAR_0->pgmap_owner);
				mmu_notifier_invalidate_range_start(&VAR_3);
			}
			migrate_vma_insert_page(VAR_0, VAR_4, VAR_8,
						&VAR_0->src[VAR_5]);
			continue;
		}

		VAR_9 = page_mapping(page);

		if (is_device_private_page(VAR_8) ||
		    is_device_coherent_page(VAR_8)) {
			/* COMMENT_5 */
                                                        
                                        
      
			if (VAR_9) {
				VAR_0->src[VAR_5] &= ~VAR_11;
				continue;
			}
		} else if (is_zone_device_page(VAR_8)) {
			/* COMMENT_9 */
                                                        
      
			VAR_0->src[VAR_5] &= ~VAR_11;
			continue;
		}

		if (VAR_0->fault_page == page)
			VAR_10 = migrate_folio_extra(VAR_9, page_folio(VAR_8),
						page_folio(page),
						VAR_13, 1);
		else
			VAR_10 = migrate_folio(VAR_9, page_folio(VAR_8),
					page_folio(page), VAR_13);
		if (VAR_10 != VAR_14)
			VAR_0->src[VAR_5] &= ~VAR_11;
	}

	/* COMMENT_12 */
                                                                       
                                                                        
                        
    
	if (VAR_6)
		mmu_notifier_invalidate_range_only_end(&VAR_3);
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -60,8 +60,13 @@
 			continue;
 		}
 
-		r = migrate_folio(mapping, page_folio(newpage),
-				page_folio(page), MIGRATE_SYNC_NO_COPY);
+		if (migrate->fault_page == page)
+			r = migrate_folio_extra(mapping, page_folio(newpage),
+						page_folio(page),
+						MIGRATE_SYNC_NO_COPY, 1);
+		else
+			r = migrate_folio(mapping, page_folio(newpage),
+					page_folio(page), MIGRATE_SYNC_NO_COPY);
 		if (r != MIGRATEPAGE_SUCCESS)
 			migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
 	}","{'deleted_lines': ['\t\tr = migrate_folio(mapping, page_folio(newpage),', '\t\t\t\tpage_folio(page), MIGRATE_SYNC_NO_COPY);'], 'added_lines': ['\t\tif (migrate->fault_page == page)', '\t\t\tr = migrate_folio_extra(mapping, page_folio(newpage),', '\t\t\t\t\t\tpage_folio(page),', '\t\t\t\t\t\tMIGRATE_SYNC_NO_COPY, 1);', '\t\telse', '\t\t\tr = migrate_folio(mapping, page_folio(newpage),', '\t\t\t\t\tpage_folio(page), MIGRATE_SYNC_NO_COPY);']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/migrate_device.c,migrate_vma_setup,"int migrate_vma_setup(struct migrate_vma *args)
{
long nr_pages = (args->end - args->start) >> PAGE_SHIFT;
args->start &= PAGE_MASK;
args->end &= PAGE_MASK;
if (!args->vma || is_vm_hugetlb_page(args->vma) ||
(args->vma->vm_flags & VM_SPECIAL) || vma_is_dax(args->vma))
return -EINVAL;
if (nr_pages <= 0)
return -EINVAL;
if (args->start < args->vma->vm_start ||
args->start >= args->vma->vm_end)
return -EINVAL;
if (args->end <= args->vma->vm_start || args->end > args->vma->vm_end)
return -EINVAL;
if (!args->src || !args->dst)
return -EINVAL;
memset(args->src, 0, sizeof(*args->src) * nr_pages);
args->cpages = 0;
args->npages = 0;
migrate_vma_collect(args);
if (args->cpages)
migrate_vma_unmap(args);
return 0;
}","int migrate_vma_setup(struct migrate_vma *VAR_0)
{
long VAR_1 = (VAR_0->end - VAR_0->start) >> VAR_2;
VAR_0->start &= VAR_3;
VAR_0->end &= VAR_3;
if (!VAR_0->vma || is_vm_hugetlb_page(VAR_0->vma) ||
(VAR_0->vma->vm_flags & VAR_4) || vma_is_dax(VAR_0->vma))
return -VAR_5;
if (VAR_1 <= 0)
return -VAR_5;
if (VAR_0->start < VAR_0->vma->vm_start ||
VAR_0->start >= VAR_0->vma->vm_end)
return -VAR_5;
if (VAR_0->end <= VAR_0->vma->vm_start || VAR_0->end > VAR_0->vma->vm_end)
return -VAR_5;
if (!VAR_0->src || !VAR_0->dst)
return -VAR_5;
memset(VAR_0->src, 0, sizeof(*VAR_0->src) * VAR_1);
VAR_0->cpages = 0;
VAR_0->npages = 0;
migrate_vma_collect(VAR_0);
if (VAR_0->cpages)
migrate_vma_unmap(VAR_0);
return 0;
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/before/2.json,"int migrate_vma_setup(struct migrate_vma *args)
{
	long nr_pages = (args->end - args->start) >> PAGE_SHIFT;

	args->start &= PAGE_MASK;
	args->end &= PAGE_MASK;
	if (!args->vma || is_vm_hugetlb_page(args->vma) ||
	    (args->vma->vm_flags & VM_SPECIAL) || vma_is_dax(args->vma))
		return -EINVAL;
	if (nr_pages <= 0)
		return -EINVAL;
	if (args->start < args->vma->vm_start ||
	    args->start >= args->vma->vm_end)
		return -EINVAL;
	if (args->end <= args->vma->vm_start || args->end > args->vma->vm_end)
		return -EINVAL;
	if (!args->src || !args->dst)
		return -EINVAL;
	if (args->fault_page && !is_device_private_page(args->fault_page))
		return -EINVAL;

	memset(args->src, 0, sizeof(*args->src) * nr_pages);
	args->cpages = 0;
	args->npages = 0;

	migrate_vma_collect(args);

	if (args->cpages)
		migrate_vma_unmap(args);

	/*
	 * At this point pages are locked and unmapped, and thus they have
	 * stable content and can safely be copied to destination memory that
	 * is allocated by the drivers.
	 */
	return 0;

}","int migrate_vma_setup(struct migrate_vma *VAR_0)
{
	long VAR_1 = (VAR_0->end - VAR_0->start) >> VAR_2;

	VAR_0->start &= VAR_3;
	VAR_0->end &= VAR_3;
	if (!VAR_0->vma || is_vm_hugetlb_page(VAR_0->vma) ||
	    (VAR_0->vma->vm_flags & VAR_4) || vma_is_dax(VAR_0->vma))
		return -VAR_5;
	if (VAR_1 <= 0)
		return -VAR_5;
	if (VAR_0->start < VAR_0->vma->vm_start ||
	    VAR_0->start >= VAR_0->vma->vm_end)
		return -VAR_5;
	if (VAR_0->end <= VAR_0->vma->vm_start || VAR_0->end > VAR_0->vma->vm_end)
		return -VAR_5;
	if (!VAR_0->src || !VAR_0->dst)
		return -VAR_5;
	if (VAR_0->fault_page && !is_device_private_page(VAR_0->fault_page))
		return -VAR_5;

	memset(VAR_0->src, 0, sizeof(*VAR_0->src) * VAR_1);
	VAR_0->cpages = 0;
	VAR_0->npages = 0;

	migrate_vma_collect(VAR_0);

	if (VAR_0->cpages)
		migrate_vma_unmap(VAR_0);

	/* COMMENT_0 */
                                                                   
                                                                      
                                
    
	return 0;

}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -15,6 +15,8 @@
 	if (args->end <= args->vma->vm_start || args->end > args->vma->vm_end)
 		return -EINVAL;
 	if (!args->src || !args->dst)
+		return -EINVAL;
+	if (args->fault_page && !is_device_private_page(args->fault_page))
 		return -EINVAL;
 
 	memset(args->src, 0, sizeof(*args->src) * nr_pages);","{'deleted_lines': [], 'added_lines': ['\t\treturn -EINVAL;', '\tif (args->fault_page && !is_device_private_page(args->fault_page))']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3523,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Patch series ""Fix several device private page reference counting issues"",
v2

This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE_DEVICE pages.  These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.

During normal usage it is unlikely these will cause any problems.  However
without these fixes it is possible to crash the kernel from userspace. 
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting. 
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.

This involves some minor changes to both PowerPC and AMD GPU code. 
Unfortunately I lack hardware to test either of those so any help there
would be appreciated.  The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.


This patch (of 8):

When the CPU tries to access a device private page the migrate_to_ram()
callback associated with the pgmap for the page is called.  However no
reference is taken on the faulting page.  Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap.  This results in a race which can crash the kernel due to the
migrate_to_ram() function pointer becoming invalid.  It also means drivers
can't reliably read the zone_device_data field because the page may have
been freed with memunmap_pages().

Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed.  Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail.  To avoid
this failure pass the faulting page into the migrate_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.

[mpe@ellerman.id.au: fix build]
  Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com
Link: https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian Knig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: ""Huang, Ying"" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",16ce101db85db694a91380aa4c89b25530871d33,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16ce101db85db694a91380aa4c89b25530871d33,mm/migrate_device.c,migrate_vma_unmap,"static void migrate_vma_unmap(struct migrate_vma *migrate)
{
const unsigned long npages = migrate->npages;
unsigned long i, restore = 0;
bool allow_drain = true;
lru_add_drain();
for (i = 0; i < npages; i++) {
struct page *page = migrate_pfn_to_page(migrate->src[i]);
struct folio *folio;
if (!page)
continue;
if (!is_zone_device_page(page)) {
if (!PageLRU(page) && allow_drain) {
lru_add_drain_all();
allow_drain = false;
}
if (isolate_lru_page(page)) {
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
migrate->cpages--;
restore++;
continue;
}
put_page(page);
}
folio = page_folio(page);
if (folio_mapped(folio))
try_to_migrate(folio, 0);
if (page_mapped(page) || !migrate_vma_check_page(page)) {
if (!is_zone_device_page(page)) {
get_page(page);
putback_lru_page(page);
}
migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
migrate->cpages--;
restore++;
continue;
}
}
for (i = 0; i < npages && restore; i++) {
struct page *page = migrate_pfn_to_page(migrate->src[i]);
struct folio *folio;
if (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))
continue;
folio = page_folio(page);
remove_migration_ptes(folio, folio, false);
migrate->src[i] = 0;
folio_unlock(folio);
folio_put(folio);
restore--;
}
}","static void migrate_vma_unmap(struct migrate_vma *VAR_0)
{
const unsigned long VAR_1 = VAR_0->npages;
unsigned long VAR_2, VAR_3 = 0;
bool VAR_4 = true;
lru_add_drain();
for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++) {
struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_2]);
struct folio *folio;
if (!page)
continue;
if (!is_zone_device_page(page)) {
if (!PageLRU(page) && VAR_4) {
lru_add_drain_all();
VAR_4 = false;
}
if (isolate_lru_page(page)) {
VAR_0->src[VAR_2] &= ~VAR_5;
VAR_0->cpages--;
VAR_3++;
continue;
}
put_page(page);
}
folio = page_folio(page);
if (folio_mapped(folio))
try_to_migrate(folio, 0);
if (page_mapped(page) || !migrate_vma_check_page(page)) {
if (!is_zone_device_page(page)) {
get_page(page);
putback_lru_page(page);
}
VAR_0->src[VAR_2] &= ~VAR_5;
VAR_0->cpages--;
VAR_3++;
continue;
}
}
for (VAR_2 = 0; VAR_2 < VAR_1 && VAR_3; VAR_2++) {
struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_2]);
struct folio *folio;
if (!page || (VAR_0->src[VAR_2] & VAR_5))
continue;
folio = page_folio(page);
remove_migration_ptes(folio, folio, false);
VAR_0->src[VAR_2] = 0;
folio_unlock(folio);
folio_put(folio);
VAR_3--;
}
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/before/3.json,"static void migrate_vma_unmap(struct migrate_vma *migrate)
{
	const unsigned long npages = migrate->npages;
	unsigned long i, restore = 0;
	bool allow_drain = true;

	lru_add_drain();

	for (i = 0; i < npages; i++) {
		struct page *page = migrate_pfn_to_page(migrate->src[i]);
		struct folio *folio;

		if (!page)
			continue;

		/* ZONE_DEVICE pages are not on LRU */
		if (!is_zone_device_page(page)) {
			if (!PageLRU(page) && allow_drain) {
				/* Drain CPU's pagevec */
				lru_add_drain_all();
				allow_drain = false;
			}

			if (isolate_lru_page(page)) {
				migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
				migrate->cpages--;
				restore++;
				continue;
			}

			/* Drop the reference we took in collect */
			put_page(page);
		}

		folio = page_folio(page);
		if (folio_mapped(folio))
			try_to_migrate(folio, 0);

		if (page_mapped(page) ||
		    !migrate_vma_check_page(page, migrate->fault_page)) {
			if (!is_zone_device_page(page)) {
				get_page(page);
				putback_lru_page(page);
			}

			migrate->src[i] &= ~MIGRATE_PFN_MIGRATE;
			migrate->cpages--;
			restore++;
			continue;
		}
	}

	for (i = 0; i < npages && restore; i++) {
		struct page *page = migrate_pfn_to_page(migrate->src[i]);
		struct folio *folio;

		if (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))
			continue;

		folio = page_folio(page);
		remove_migration_ptes(folio, folio, false);

		migrate->src[i] = 0;
		folio_unlock(folio);
		folio_put(folio);
		restore--;
	}
}","static void migrate_vma_unmap(struct migrate_vma *VAR_0)
{
	const unsigned long VAR_1 = VAR_0->npages;
	unsigned long VAR_2, VAR_3 = 0;
	bool VAR_4 = true;

	lru_add_drain();

	for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++) {
		struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_2]);
		struct folio *folio;

		if (!page)
			continue;

		/* COMMENT_0 */
		if (!is_zone_device_page(page)) {
			if (!PageLRU(page) && VAR_4) {
				/* COMMENT_1 */
				lru_add_drain_all();
				VAR_4 = false;
			}

			if (isolate_lru_page(page)) {
				VAR_0->src[VAR_2] &= ~VAR_5;
				VAR_0->cpages--;
				VAR_3++;
				continue;
			}

			/* COMMENT_2 */
			put_page(page);
		}

		folio = page_folio(page);
		if (folio_mapped(folio))
			try_to_migrate(folio, 0);

		if (page_mapped(page) ||
		    !migrate_vma_check_page(page, VAR_0->fault_page)) {
			if (!is_zone_device_page(page)) {
				get_page(page);
				putback_lru_page(page);
			}

			VAR_0->src[VAR_2] &= ~VAR_5;
			VAR_0->cpages--;
			VAR_3++;
			continue;
		}
	}

	for (VAR_2 = 0; VAR_2 < VAR_1 && VAR_3; VAR_2++) {
		struct page *page = migrate_pfn_to_page(VAR_0->src[VAR_2]);
		struct folio *folio;

		if (!page || (VAR_0->src[VAR_2] & VAR_5))
			continue;

		folio = page_folio(page);
		remove_migration_ptes(folio, folio, false);

		VAR_0->src[VAR_2] = 0;
		folio_unlock(folio);
		folio_put(folio);
		VAR_3--;
	}
}",torvalds/linux/16ce101db85db694a91380aa4c89b25530871d33/migrate_device.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -36,7 +36,8 @@
 		if (folio_mapped(folio))
 			try_to_migrate(folio, 0);
 
-		if (page_mapped(page) || !migrate_vma_check_page(page)) {
+		if (page_mapped(page) ||
+		    !migrate_vma_check_page(page, migrate->fault_page)) {
 			if (!is_zone_device_page(page)) {
 				get_page(page);
 				putback_lru_page(page);","{'deleted_lines': ['\t\tif (page_mapped(page) || !migrate_vma_check_page(page)) {'], 'added_lines': ['\t\tif (page_mapped(page) ||', '\t\t    !migrate_vma_check_page(page, migrate->fault_page)) {']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,5.3,MEDIUM,1,valid,,5
CVE-2022-3524,['CWE-404'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"syzbot reported a memory leak [0] related to IPV6_ADDRFORM.

The scenario is that while one thread is converting an IPv6 socket into
IPv4 with IPV6_ADDRFORM, another thread calls do_ipv6_setsockopt() and
allocates memory to inet6_sk(sk)->XXX after conversion.

Then, the converted sk with (tcp|udp)_prot never frees the IPv6 resources,
which inet6_destroy_sock() should have cleaned up.

setsockopt(IPV6_ADDRFORM)                 setsockopt(IPV6_DSTOPTS)
+-----------------------+                 +----------------------+
- do_ipv6_setsockopt(sk, ...)
  - sockopt_lock_sock(sk)                 - do_ipv6_setsockopt(sk, ...)
    - lock_sock(sk)                         ^._ called via tcpv6_prot
  - WRITE_ONCE(sk->sk_prot, &tcp_prot)          before WRITE_ONCE()
  - xchg(&np->opt, NULL)
  - txopt_put(opt)
  - sockopt_release_sock(sk)
    - release_sock(sk)                      - sockopt_lock_sock(sk)
                                              - lock_sock(sk)
                                            - ipv6_set_opt_hdr(sk, ...)
                                              - ipv6_update_options(sk, opt)
                                                - xchg(&inet6_sk(sk)->opt, opt)
                                                  ^._ opt is never freed.

                                            - sockopt_release_sock(sk)
                                              - release_sock(sk)

Since IPV6_DSTOPTS allocates options under lock_sock(), we can avoid this
memory leak by testing whether sk_family is changed by IPV6_ADDRFORM after
acquiring the lock.

This issue exists from the initial commit between IPV6_ADDRFORM and
IPV6_PKTOPTIONS.

[0]:
BUG: memory leak
unreferenced object 0xffff888009ab9f80 (size 96):
  comm ""syz-executor583"", pid 328, jiffies 4294916198 (age 13.034s)
  hex dump (first 32 bytes):
    01 00 00 00 48 00 00 00 08 00 00 00 00 00 00 00  ....H...........
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<000000002ee98ae1>] kmalloc include/linux/slab.h:605 [inline]
    [<000000002ee98ae1>] sock_kmalloc+0xb3/0x100 net/core/sock.c:2566
    [<0000000065d7b698>] ipv6_renew_options+0x21e/0x10b0 net/ipv6/exthdrs.c:1318
    [<00000000a8c756d7>] ipv6_set_opt_hdr net/ipv6/ipv6_sockglue.c:354 [inline]
    [<00000000a8c756d7>] do_ipv6_setsockopt.constprop.0+0x28b7/0x4350 net/ipv6/ipv6_sockglue.c:668
    [<000000002854d204>] ipv6_setsockopt+0xdf/0x190 net/ipv6/ipv6_sockglue.c:1021
    [<00000000e69fdcf8>] tcp_setsockopt+0x13b/0x2620 net/ipv4/tcp.c:3789
    [<0000000090da4b9b>] __sys_setsockopt+0x239/0x620 net/socket.c:2252
    [<00000000b10d192f>] __do_sys_setsockopt net/socket.c:2263 [inline]
    [<00000000b10d192f>] __se_sys_setsockopt net/socket.c:2260 [inline]
    [<00000000b10d192f>] __x64_sys_setsockopt+0xbe/0x160 net/socket.c:2260
    [<000000000a80d7aa>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]
    [<000000000a80d7aa>] do_syscall_64+0x38/0x90 arch/x86/entry/common.c:80
    [<000000004562b5c6>] entry_SYSCALL_64_after_hwframe+0x63/0xcd

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Reported-by: syzbot <syzkaller@googlegroups.com>
Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",3c52c6bb831f6335c176a0fc7214e26f43adbd11,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3c52c6bb831f6335c176a0fc7214e26f43adbd11,net/ipv6/ipv6_sockglue.c,do_ipv6_setsockopt,"int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
sockptr_t optval, unsigned int optlen)
{
struct ipv6_pinfo *np = inet6_sk(sk);
struct net *net = sock_net(sk);
int val, valbool;
int retv = -ENOPROTOOPT;
bool needs_rtnl = setsockopt_needs_rtnl(optname);
if (sockptr_is_null(optval))
val = 0;
else {
if (optlen >= sizeof(int)) {
if (copy_from_sockptr(&val, optval, sizeof(val)))
return -EFAULT;
} else
val = 0;
}
valbool = (val != 0);
if (ip6_mroute_opt(optname))
return ip6_mroute_setsockopt(sk, optname, optval, optlen);
if (needs_rtnl)
rtnl_lock();
sockopt_lock_sock(sk);
switch (optname) {
case IPV6_ADDRFORM:
if (optlen < sizeof(int))
goto e_inval;
if (val == PF_INET) {
struct ipv6_txoptions *opt;
struct sk_buff *pktopt;
if (sk->sk_type == SOCK_RAW)
break;
if (sk->sk_protocol == IPPROTO_UDP ||
sk->sk_protocol == IPPROTO_UDPLITE) {
struct udp_sock *up = udp_sk(sk);
if (up->pending == AF_INET6) {
retv = -EBUSY;
break;
}
} else if (sk->sk_protocol == IPPROTO_TCP) {
if (sk->sk_prot != &tcpv6_prot) {
retv = -EBUSY;
break;
}
} else {
break;
}
if (sk->sk_state != TCP_ESTABLISHED) {
retv = -ENOTCONN;
break;
}
if (ipv6_only_sock(sk) ||
!ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {
retv = -EADDRNOTAVAIL;
break;
}
fl6_free_socklist(sk);
__ipv6_sock_mc_close(sk);
__ipv6_sock_ac_close(sk);
sk_refcnt_debug_dec(sk);
if (sk->sk_protocol == IPPROTO_TCP) {
struct inet_connection_sock *icsk = inet_csk(sk);
sock_prot_inuse_add(net, sk->sk_prot, -1);
sock_prot_inuse_add(net, &tcp_prot, 1);
WRITE_ONCE(sk->sk_prot, &tcp_prot);
icsk->icsk_af_ops = &ipv4_specific;
sk->sk_socket->ops = &inet_stream_ops;
sk->sk_family = PF_INET;
tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
} else {
struct proto *prot = &udp_prot;
if (sk->sk_protocol == IPPROTO_UDPLITE)
prot = &udplite_prot;
sock_prot_inuse_add(net, sk->sk_prot, -1);
sock_prot_inuse_add(net, prot, 1);
WRITE_ONCE(sk->sk_prot, prot);
sk->sk_socket->ops = &inet_dgram_ops;
sk->sk_family = PF_INET;
}
opt = xchg((__force struct ipv6_txoptions **)&np->opt,
NULL);
if (opt) {
atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
txopt_put(opt);
}
pktopt = xchg(&np->pktoptions, NULL);
kfree_skb(pktopt);
sk_refcnt_debug_inc(sk);
module_put(THIS_MODULE);
retv = 0;
break;
}
goto e_inval;
case IPV6_V6ONLY:
if (optlen < sizeof(int) ||
inet_sk(sk)->inet_num)
goto e_inval;
sk->sk_ipv6only = valbool;
retv = 0;
break;
case IPV6_RECVPKTINFO:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxinfo = valbool;
retv = 0;
break;
case IPV6_2292PKTINFO:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxoinfo = valbool;
retv = 0;
break;
case IPV6_RECVHOPLIMIT:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxhlim = valbool;
retv = 0;
break;
case IPV6_2292HOPLIMIT:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxohlim = valbool;
retv = 0;
break;
case IPV6_RECVRTHDR:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.srcrt = valbool;
retv = 0;
break;
case IPV6_2292RTHDR:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.osrcrt = valbool;
retv = 0;
break;
case IPV6_RECVHOPOPTS:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.hopopts = valbool;
retv = 0;
break;
case IPV6_2292HOPOPTS:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.ohopopts = valbool;
retv = 0;
break;
case IPV6_RECVDSTOPTS:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.dstopts = valbool;
retv = 0;
break;
case IPV6_2292DSTOPTS:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.odstopts = valbool;
retv = 0;
break;
case IPV6_TCLASS:
if (optlen < sizeof(int))
goto e_inval;
if (val < -1 || val > 0xff)
goto e_inval;
if (val == -1)
val = 0;
if (sk->sk_type == SOCK_STREAM) {
val &= ~INET_ECN_MASK;
val |= np->tclass & INET_ECN_MASK;
}
if (np->tclass != val) {
np->tclass = val;
sk_dst_reset(sk);
}
retv = 0;
break;
case IPV6_RECVTCLASS:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxtclass = valbool;
retv = 0;
break;
case IPV6_FLOWINFO:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxflow = valbool;
retv = 0;
break;
case IPV6_RECVPATHMTU:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxpmtu = valbool;
retv = 0;
break;
case IPV6_TRANSPARENT:
if (valbool && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW) &&
!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN)) {
retv = -EPERM;
break;
}
if (optlen < sizeof(int))
goto e_inval;
inet_sk(sk)->transparent = valbool;
retv = 0;
break;
case IPV6_FREEBIND:
if (optlen < sizeof(int))
goto e_inval;
inet_sk(sk)->freebind = valbool;
retv = 0;
break;
case IPV6_RECVORIGDSTADDR:
if (optlen < sizeof(int))
goto e_inval;
np->rxopt.bits.rxorigdstaddr = valbool;
retv = 0;
break;
case IPV6_HOPOPTS:
case IPV6_RTHDRDSTOPTS:
case IPV6_RTHDR:
case IPV6_DSTOPTS:
retv = ipv6_set_opt_hdr(sk, optname, optval, optlen);
break;
case IPV6_PKTINFO:
{
struct in6_pktinfo pkt;
if (optlen == 0)
goto e_inval;
else if (optlen < sizeof(struct in6_pktinfo) ||
sockptr_is_null(optval))
goto e_inval;
if (copy_from_sockptr(&pkt, optval, sizeof(pkt))) {
retv = -EFAULT;
break;
}
if (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))
goto e_inval;
np->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;
np->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;
retv = 0;
break;
}
case IPV6_2292PKTOPTIONS:
{
struct ipv6_txoptions *opt = NULL;
struct msghdr msg;
struct flowi6 fl6;
struct ipcm6_cookie ipc6;
memset(&fl6, 0, sizeof(fl6));
fl6.flowi6_oif = sk->sk_bound_dev_if;
fl6.flowi6_mark = sk->sk_mark;
if (optlen == 0)
goto update;
retv = -EINVAL;
if (optlen > 64*1024)
break;
opt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);
retv = -ENOBUFS;
if (!opt)
break;
memset(opt, 0, sizeof(*opt));
refcount_set(&opt->refcnt, 1);
opt->tot_len = sizeof(*opt) + optlen;
retv = -EFAULT;
if (copy_from_sockptr(opt + 1, optval, optlen))
goto done;
msg.msg_controllen = optlen;
msg.msg_control = (void *)(opt+1);
ipc6.opt = opt;
retv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);
if (retv)
goto done;
update:
retv = 0;
opt = ipv6_update_options(sk, opt);
done:
if (opt) {
atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
txopt_put(opt);
}
break;
}
case IPV6_UNICAST_HOPS:
if (optlen < sizeof(int))
goto e_inval;
if (val > 255 || val < -1)
goto e_inval;
np->hop_limit = val;
retv = 0;
break;
case IPV6_MULTICAST_HOPS:
if (sk->sk_type == SOCK_STREAM)
break;
if (optlen < sizeof(int))
goto e_inval;
if (val > 255 || val < -1)
goto e_inval;
np->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);
retv = 0;
break;
case IPV6_MULTICAST_LOOP:
if (optlen < sizeof(int))
goto e_inval;
if (val != valbool)
goto e_inval;
np->mc_loop = valbool;
retv = 0;
break;
case IPV6_UNICAST_IF:
{
struct net_device *dev = NULL;
int ifindex;
if (optlen != sizeof(int))
goto e_inval;
ifindex = (__force int)ntohl((__force __be32)val);
if (ifindex == 0) {
np->ucast_oif = 0;
retv = 0;
break;
}
dev = dev_get_by_index(net, ifindex);
retv = -EADDRNOTAVAIL;
if (!dev)
break;
dev_put(dev);
retv = -EINVAL;
if (sk->sk_bound_dev_if)
break;
np->ucast_oif = ifindex;
retv = 0;
break;
}
case IPV6_MULTICAST_IF:
if (sk->sk_type == SOCK_STREAM)
break;
if (optlen < sizeof(int))
goto e_inval;
if (val) {
struct net_device *dev;
int midx;
rcu_read_lock();
dev = dev_get_by_index_rcu(net, val);
if (!dev) {
rcu_read_unlock();
retv = -ENODEV;
break;
}
midx = l3mdev_master_ifindex_rcu(dev);
rcu_read_unlock();
if (sk->sk_bound_dev_if &&
sk->sk_bound_dev_if != val &&
(!midx || midx != sk->sk_bound_dev_if))
goto e_inval;
}
np->mcast_oif = val;
retv = 0;
break;
case IPV6_ADD_MEMBERSHIP:
case IPV6_DROP_MEMBERSHIP:
{
struct ipv6_mreq mreq;
if (optlen < sizeof(struct ipv6_mreq))
goto e_inval;
retv = -EPROTO;
if (inet_sk(sk)->is_icsk)
break;
retv = -EFAULT;
if (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))
break;
if (optname == IPV6_ADD_MEMBERSHIP)
retv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
else
retv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
break;
}
case IPV6_JOIN_ANYCAST:
case IPV6_LEAVE_ANYCAST:
{
struct ipv6_mreq mreq;
if (optlen < sizeof(struct ipv6_mreq))
goto e_inval;
retv = -EFAULT;
if (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))
break;
if (optname == IPV6_JOIN_ANYCAST)
retv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
else
retv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
break;
}
case IPV6_MULTICAST_ALL:
if (optlen < sizeof(int))
goto e_inval;
np->mc_all = valbool;
retv = 0;
break;
case MCAST_JOIN_GROUP:
case MCAST_LEAVE_GROUP:
if (in_compat_syscall())
retv = compat_ipv6_mcast_join_leave(sk, optname, optval,
optlen);
else
retv = ipv6_mcast_join_leave(sk, optname, optval,
optlen);
break;
case MCAST_JOIN_SOURCE_GROUP:
case MCAST_LEAVE_SOURCE_GROUP:
case MCAST_BLOCK_SOURCE:
case MCAST_UNBLOCK_SOURCE:
retv = do_ipv6_mcast_group_source(sk, optname, optval, optlen);
break;
case MCAST_MSFILTER:
if (in_compat_syscall())
retv = compat_ipv6_set_mcast_msfilter(sk, optval,
optlen);
else
retv = ipv6_set_mcast_msfilter(sk, optval, optlen);
break;
case IPV6_ROUTER_ALERT:
if (optlen < sizeof(int))
goto e_inval;
retv = ip6_ra_control(sk, val);
break;
case IPV6_ROUTER_ALERT_ISOLATE:
if (optlen < sizeof(int))
goto e_inval;
np->rtalert_isolate = valbool;
retv = 0;
break;
case IPV6_MTU_DISCOVER:
if (optlen < sizeof(int))
goto e_inval;
if (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)
goto e_inval;
np->pmtudisc = val;
retv = 0;
break;
case IPV6_MTU:
if (optlen < sizeof(int))
goto e_inval;
if (val && val < IPV6_MIN_MTU)
goto e_inval;
np->frag_size = val;
retv = 0;
break;
case IPV6_RECVERR:
if (optlen < sizeof(int))
goto e_inval;
np->recverr = valbool;
if (!val)
skb_queue_purge(&sk->sk_error_queue);
retv = 0;
break;
case IPV6_FLOWINFO_SEND:
if (optlen < sizeof(int))
goto e_inval;
np->sndflow = valbool;
retv = 0;
break;
case IPV6_FLOWLABEL_MGR:
retv = ipv6_flowlabel_opt(sk, optval, optlen);
break;
case IPV6_IPSEC_POLICY:
case IPV6_XFRM_POLICY:
retv = -EPERM;
if (!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN))
break;
retv = xfrm_user_policy(sk, optname, optval, optlen);
break;
case IPV6_ADDR_PREFERENCES:
if (optlen < sizeof(int))
goto e_inval;
retv = __ip6_sock_set_addr_preferences(sk, val);
break;
case IPV6_MINHOPCOUNT:
if (optlen < sizeof(int))
goto e_inval;
if (val < 0 || val > 255)
goto e_inval;
if (val)
static_branch_enable(&ip6_min_hopcount);
WRITE_ONCE(np->min_hopcount, val);
retv = 0;
break;
case IPV6_DONTFRAG:
np->dontfrag = valbool;
retv = 0;
break;
case IPV6_AUTOFLOWLABEL:
np->autoflowlabel = valbool;
np->autoflowlabel_set = 1;
retv = 0;
break;
case IPV6_RECVFRAGSIZE:
np->rxopt.bits.recvfragsize = valbool;
retv = 0;
break;
case IPV6_RECVERR_RFC4884:
if (optlen < sizeof(int))
goto e_inval;
if (val < 0 || val > 1)
goto e_inval;
np->recverr_rfc4884 = valbool;
retv = 0;
break;
}
sockopt_release_sock(sk);
if (needs_rtnl)
rtnl_unlock();
return retv;
e_inval:
sockopt_release_sock(sk);
if (needs_rtnl)
rtnl_unlock();
return -EINVAL;
}","int do_ipv6_setsockopt(struct sock *VAR_0, int VAR_1, int VAR_2,
sockptr_t VAR_3, unsigned int VAR_4)
{
struct ipv6_pinfo *VAR_5 = inet6_sk(VAR_0);
struct net *net = sock_net(VAR_0);
int VAR_6, VAR_7;
int VAR_8 = -VAR_9;
bool VAR_10 = setsockopt_needs_rtnl(VAR_2);
if (sockptr_is_null(VAR_3))
VAR_6 = 0;
else {
if (VAR_4 >= sizeof(int)) {
if (copy_from_sockptr(&VAR_6, VAR_3, sizeof(VAR_6)))
return -VAR_11;
} else
VAR_6 = 0;
}
VAR_7 = (VAR_6 != 0);
if (ip6_mroute_opt(VAR_2))
return ip6_mroute_setsockopt(VAR_0, VAR_2, VAR_3, VAR_4);
if (VAR_10)
rtnl_lock();
sockopt_lock_sock(VAR_0);
switch (VAR_2) {
case VAR_12:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 == VAR_13) {
struct ipv6_txoptions *VAR_14;
struct sk_buff *VAR_15;
if (VAR_0->sk_type == VAR_16)
break;
if (VAR_0->sk_protocol == VAR_17 ||
VAR_0->sk_protocol == VAR_18) {
struct udp_sock *VAR_19 = udp_sk(VAR_0);
if (VAR_19->pending == VAR_20) {
VAR_8 = -VAR_21;
break;
}
} else if (VAR_0->sk_protocol == VAR_22) {
if (VAR_0->sk_prot != &VAR_23) {
VAR_8 = -VAR_21;
break;
}
} else {
break;
}
if (VAR_0->sk_state != VAR_24) {
VAR_8 = -VAR_25;
break;
}
if (ipv6_only_sock(VAR_0) ||
!ipv6_addr_v4mapped(&VAR_0->sk_v6_daddr)) {
VAR_8 = -VAR_26;
break;
}
fl6_free_socklist(VAR_0);
__ipv6_sock_mc_close(VAR_0);
__ipv6_sock_ac_close(VAR_0);
sk_refcnt_debug_dec(VAR_0);
if (VAR_0->sk_protocol == VAR_22) {
struct inet_connection_sock *VAR_27 = inet_csk(VAR_0);
sock_prot_inuse_add(net, VAR_0->sk_prot, -1);
sock_prot_inuse_add(net, &VAR_28, 1);
WRITE_ONCE(VAR_0->sk_prot, &VAR_28);
VAR_27->icsk_af_ops = &VAR_29;
VAR_0->sk_socket->ops = &VAR_30;
VAR_0->sk_family = VAR_13;
tcp_sync_mss(VAR_0, VAR_27->icsk_pmtu_cookie);
} else {
struct proto *VAR_31 = &VAR_32;
if (VAR_0->sk_protocol == VAR_18)
VAR_31 = &VAR_33;
sock_prot_inuse_add(net, VAR_0->sk_prot, -1);
sock_prot_inuse_add(net, VAR_31, 1);
WRITE_ONCE(VAR_0->sk_prot, VAR_31);
VAR_0->sk_socket->ops = &VAR_34;
VAR_0->sk_family = VAR_13;
}
VAR_14 = xchg((VAR_35 struct ipv6_txoptions **)&VAR_5->opt,
NULL);
if (VAR_14) {
atomic_sub(VAR_14->tot_len, &VAR_0->sk_omem_alloc);
txopt_put(VAR_14);
}
VAR_15 = xchg(&VAR_5->pktoptions, NULL);
kfree_skb(VAR_15);
sk_refcnt_debug_inc(VAR_0);
module_put(VAR_36);
VAR_8 = 0;
break;
}
goto e_inval;
case VAR_37:
if (VAR_4 < sizeof(int) ||
inet_sk(VAR_0)->inet_num)
goto e_inval;
VAR_0->sk_ipv6only = VAR_7;
VAR_8 = 0;
break;
case VAR_38:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxinfo = VAR_7;
VAR_8 = 0;
break;
case VAR_39:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxoinfo = VAR_7;
VAR_8 = 0;
break;
case VAR_40:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxhlim = VAR_7;
VAR_8 = 0;
break;
case VAR_41:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxohlim = VAR_7;
VAR_8 = 0;
break;
case VAR_42:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.srcrt = VAR_7;
VAR_8 = 0;
break;
case VAR_43:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.osrcrt = VAR_7;
VAR_8 = 0;
break;
case VAR_44:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.hopopts = VAR_7;
VAR_8 = 0;
break;
case VAR_45:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.ohopopts = VAR_7;
VAR_8 = 0;
break;
case VAR_46:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.dstopts = VAR_7;
VAR_8 = 0;
break;
case VAR_47:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.odstopts = VAR_7;
VAR_8 = 0;
break;
case VAR_48:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 < -1 || VAR_6 > 0xff)
goto e_inval;
if (VAR_6 == -1)
VAR_6 = 0;
if (VAR_0->sk_type == VAR_49) {
VAR_6 &= ~VAR_50;
VAR_6 |= VAR_5->tclass & VAR_50;
}
if (VAR_5->tclass != VAR_6) {
VAR_5->tclass = VAR_6;
sk_dst_reset(VAR_0);
}
VAR_8 = 0;
break;
case VAR_51:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxtclass = VAR_7;
VAR_8 = 0;
break;
case VAR_52:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxflow = VAR_7;
VAR_8 = 0;
break;
case VAR_53:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxpmtu = VAR_7;
VAR_8 = 0;
break;
case VAR_54:
if (VAR_7 && !sockopt_ns_capable(net->user_ns, VAR_55) &&
!sockopt_ns_capable(net->user_ns, VAR_56)) {
VAR_8 = -VAR_57;
break;
}
if (VAR_4 < sizeof(int))
goto e_inval;
inet_sk(VAR_0)->transparent = VAR_7;
VAR_8 = 0;
break;
case VAR_58:
if (VAR_4 < sizeof(int))
goto e_inval;
inet_sk(VAR_0)->freebind = VAR_7;
VAR_8 = 0;
break;
case VAR_59:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rxopt.bits.rxorigdstaddr = VAR_7;
VAR_8 = 0;
break;
case VAR_60:
case VAR_61:
case VAR_62:
case VAR_63:
VAR_8 = ipv6_set_opt_hdr(VAR_0, VAR_2, VAR_3, VAR_4);
break;
case VAR_64:
{
struct in6_pktinfo VAR_65;
if (VAR_4 == 0)
goto e_inval;
else if (VAR_4 < sizeof(struct in6_pktinfo) ||
sockptr_is_null(VAR_3))
goto e_inval;
if (copy_from_sockptr(&VAR_65, VAR_3, sizeof(VAR_65))) {
VAR_8 = -VAR_11;
break;
}
if (!sk_dev_equal_l3scope(VAR_0, VAR_65.ipi6_ifindex))
goto e_inval;
VAR_5->sticky_pktinfo.ipi6_ifindex = VAR_65.ipi6_ifindex;
VAR_5->sticky_pktinfo.ipi6_addr = VAR_65.ipi6_addr;
VAR_8 = 0;
break;
}
case VAR_66:
{
struct ipv6_txoptions *VAR_14 = NULL;
struct msghdr VAR_67;
struct flowi6 VAR_68;
struct ipcm6_cookie VAR_69;
memset(&VAR_68, 0, sizeof(VAR_68));
VAR_68.flowi6_oif = VAR_0->sk_bound_dev_if;
VAR_68.flowi6_mark = VAR_0->sk_mark;
if (VAR_4 == 0)
goto update;
VAR_8 = -VAR_70;
if (VAR_4 > 64*1024)
break;
VAR_14 = sock_kmalloc(VAR_0, sizeof(*VAR_14) + VAR_4, VAR_71);
VAR_8 = -VAR_72;
if (!VAR_14)
break;
memset(VAR_14, 0, sizeof(*VAR_14));
refcount_set(&VAR_14->refcnt, 1);
VAR_14->tot_len = sizeof(*VAR_14) + VAR_4;
VAR_8 = -VAR_11;
if (copy_from_sockptr(VAR_14 + 1, VAR_3, VAR_4))
goto done;
VAR_67.msg_controllen = VAR_4;
VAR_67.msg_control = (void *)(VAR_14+1);
VAR_69.opt = VAR_14;
VAR_8 = ip6_datagram_send_ctl(net, VAR_0, &VAR_67, &VAR_68, &VAR_69);
if (VAR_8)
goto done;
update:
VAR_8 = 0;
VAR_14 = ipv6_update_options(VAR_0, VAR_14);
done:
if (VAR_14) {
atomic_sub(VAR_14->tot_len, &VAR_0->sk_omem_alloc);
txopt_put(VAR_14);
}
break;
}
case VAR_73:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 > 255 || VAR_6 < -1)
goto e_inval;
VAR_5->hop_limit = VAR_6;
VAR_8 = 0;
break;
case VAR_74:
if (VAR_0->sk_type == VAR_49)
break;
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 > 255 || VAR_6 < -1)
goto e_inval;
VAR_5->mcast_hops = (VAR_6 == -1 ? VAR_75 : VAR_6);
VAR_8 = 0;
break;
case VAR_76:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 != VAR_7)
goto e_inval;
VAR_5->mc_loop = VAR_7;
VAR_8 = 0;
break;
case VAR_77:
{
struct net_device *VAR_78 = NULL;
int VAR_79;
if (VAR_4 != sizeof(int))
goto e_inval;
VAR_79 = (__force int)ntohl((__force VAR_80)VAR_6);
if (VAR_79 == 0) {
VAR_5->ucast_oif = 0;
VAR_8 = 0;
break;
}
VAR_78 = dev_get_by_index(net, VAR_79);
VAR_8 = -VAR_26;
if (!VAR_78)
break;
dev_put(VAR_78);
VAR_8 = -VAR_70;
if (VAR_0->sk_bound_dev_if)
break;
VAR_5->ucast_oif = VAR_79;
VAR_8 = 0;
break;
}
case VAR_81:
if (VAR_0->sk_type == VAR_49)
break;
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6) {
struct net_device *VAR_78;
int VAR_82;
rcu_read_lock();
VAR_78 = dev_get_by_index_rcu(net, VAR_6);
if (!VAR_78) {
rcu_read_unlock();
VAR_8 = -VAR_83;
break;
}
VAR_82 = l3mdev_master_ifindex_rcu(VAR_78);
rcu_read_unlock();
if (VAR_0->sk_bound_dev_if &&
VAR_0->sk_bound_dev_if != VAR_6 &&
(!VAR_82 || VAR_82 != VAR_0->sk_bound_dev_if))
goto e_inval;
}
VAR_5->mcast_oif = VAR_6;
VAR_8 = 0;
break;
case VAR_84:
case VAR_85:
{
struct ipv6_mreq VAR_86;
if (VAR_4 < sizeof(struct ipv6_mreq))
goto e_inval;
VAR_8 = -VAR_87;
if (inet_sk(VAR_0)->is_icsk)
break;
VAR_8 = -VAR_11;
if (copy_from_sockptr(&VAR_86, VAR_3, sizeof(struct ipv6_mreq)))
break;
if (VAR_2 == VAR_84)
VAR_8 = ipv6_sock_mc_join(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_multiaddr);
else
VAR_8 = ipv6_sock_mc_drop(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_multiaddr);
break;
}
case VAR_88:
case VAR_89:
{
struct ipv6_mreq VAR_86;
if (VAR_4 < sizeof(struct ipv6_mreq))
goto e_inval;
VAR_8 = -VAR_11;
if (copy_from_sockptr(&VAR_86, VAR_3, sizeof(struct ipv6_mreq)))
break;
if (VAR_2 == VAR_88)
VAR_8 = ipv6_sock_ac_join(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_acaddr);
else
VAR_8 = ipv6_sock_ac_drop(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_acaddr);
break;
}
case VAR_90:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->mc_all = VAR_7;
VAR_8 = 0;
break;
case VAR_91:
case VAR_92:
if (in_compat_syscall())
VAR_8 = compat_ipv6_mcast_join_leave(VAR_0, VAR_2, VAR_3,
VAR_4);
else
VAR_8 = ipv6_mcast_join_leave(VAR_0, VAR_2, VAR_3,
VAR_4);
break;
case VAR_93:
case VAR_94:
case VAR_95:
case VAR_96:
VAR_8 = do_ipv6_mcast_group_source(VAR_0, VAR_2, VAR_3, VAR_4);
break;
case VAR_97:
if (in_compat_syscall())
VAR_8 = compat_ipv6_set_mcast_msfilter(VAR_0, VAR_3,
VAR_4);
else
VAR_8 = ipv6_set_mcast_msfilter(VAR_0, VAR_3, VAR_4);
break;
case VAR_98:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_8 = ip6_ra_control(VAR_0, VAR_6);
break;
case VAR_99:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->rtalert_isolate = VAR_7;
VAR_8 = 0;
break;
case VAR_100:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 < VAR_101 || VAR_6 > VAR_102)
goto e_inval;
VAR_5->pmtudisc = VAR_6;
VAR_8 = 0;
break;
case VAR_103:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 && VAR_6 < VAR_104)
goto e_inval;
VAR_5->frag_size = VAR_6;
VAR_8 = 0;
break;
case VAR_105:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->recverr = VAR_7;
if (!VAR_6)
skb_queue_purge(&VAR_0->sk_error_queue);
VAR_8 = 0;
break;
case VAR_106:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_5->sndflow = VAR_7;
VAR_8 = 0;
break;
case VAR_107:
VAR_8 = ipv6_flowlabel_opt(VAR_0, VAR_3, VAR_4);
break;
case VAR_108:
case VAR_109:
VAR_8 = -VAR_57;
if (!sockopt_ns_capable(net->user_ns, VAR_56))
break;
VAR_8 = xfrm_user_policy(VAR_0, VAR_2, VAR_3, VAR_4);
break;
case VAR_110:
if (VAR_4 < sizeof(int))
goto e_inval;
VAR_8 = __ip6_sock_set_addr_preferences(VAR_0, VAR_6);
break;
case VAR_111:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 < 0 || VAR_6 > 255)
goto e_inval;
if (VAR_6)
static_branch_enable(&VAR_112);
WRITE_ONCE(VAR_5->min_hopcount, VAR_6);
VAR_8 = 0;
break;
case VAR_113:
VAR_5->dontfrag = VAR_7;
VAR_8 = 0;
break;
case VAR_114:
VAR_5->autoflowlabel = VAR_7;
VAR_5->autoflowlabel_set = 1;
VAR_8 = 0;
break;
case VAR_115:
VAR_5->rxopt.bits.recvfragsize = VAR_7;
VAR_8 = 0;
break;
case VAR_116:
if (VAR_4 < sizeof(int))
goto e_inval;
if (VAR_6 < 0 || VAR_6 > 1)
goto e_inval;
VAR_5->recverr_rfc4884 = VAR_7;
VAR_8 = 0;
break;
}
sockopt_release_sock(VAR_0);
if (VAR_10)
rtnl_unlock();
return VAR_8;
e_inval:
sockopt_release_sock(VAR_0);
if (VAR_10)
rtnl_unlock();
return -VAR_70;
}",torvalds/linux/3c52c6bb831f6335c176a0fc7214e26f43adbd11/ipv6_sockglue.c/vul/before/0.json,"int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
		       sockptr_t optval, unsigned int optlen)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct net *net = sock_net(sk);
	int val, valbool;
	int retv = -ENOPROTOOPT;
	bool needs_rtnl = setsockopt_needs_rtnl(optname);

	if (sockptr_is_null(optval))
		val = 0;
	else {
		if (optlen >= sizeof(int)) {
			if (copy_from_sockptr(&val, optval, sizeof(val)))
				return -EFAULT;
		} else
			val = 0;
	}

	valbool = (val != 0);

	if (ip6_mroute_opt(optname))
		return ip6_mroute_setsockopt(sk, optname, optval, optlen);

	if (needs_rtnl)
		rtnl_lock();
	sockopt_lock_sock(sk);

	/* Another thread has converted the socket into IPv4 with
	 * IPV6_ADDRFORM concurrently.
	 */
	if (unlikely(sk->sk_family != AF_INET6))
		goto unlock;

	switch (optname) {

	case IPV6_ADDRFORM:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val == PF_INET) {
			struct ipv6_txoptions *opt;
			struct sk_buff *pktopt;

			if (sk->sk_type == SOCK_RAW)
				break;

			if (sk->sk_protocol == IPPROTO_UDP ||
			    sk->sk_protocol == IPPROTO_UDPLITE) {
				struct udp_sock *up = udp_sk(sk);
				if (up->pending == AF_INET6) {
					retv = -EBUSY;
					break;
				}
			} else if (sk->sk_protocol == IPPROTO_TCP) {
				if (sk->sk_prot != &tcpv6_prot) {
					retv = -EBUSY;
					break;
				}
			} else {
				break;
			}

			if (sk->sk_state != TCP_ESTABLISHED) {
				retv = -ENOTCONN;
				break;
			}

			if (ipv6_only_sock(sk) ||
			    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {
				retv = -EADDRNOTAVAIL;
				break;
			}

			fl6_free_socklist(sk);
			__ipv6_sock_mc_close(sk);
			__ipv6_sock_ac_close(sk);

			/*
			 * Sock is moving from IPv6 to IPv4 (sk_prot), so
			 * remove it from the refcnt debug socks count in the
			 * original family...
			 */
			sk_refcnt_debug_dec(sk);

			if (sk->sk_protocol == IPPROTO_TCP) {
				struct inet_connection_sock *icsk = inet_csk(sk);

				sock_prot_inuse_add(net, sk->sk_prot, -1);
				sock_prot_inuse_add(net, &tcp_prot, 1);

				/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */
				WRITE_ONCE(sk->sk_prot, &tcp_prot);
				icsk->icsk_af_ops = &ipv4_specific;
				sk->sk_socket->ops = &inet_stream_ops;
				sk->sk_family = PF_INET;
				tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
			} else {
				struct proto *prot = &udp_prot;

				if (sk->sk_protocol == IPPROTO_UDPLITE)
					prot = &udplite_prot;

				sock_prot_inuse_add(net, sk->sk_prot, -1);
				sock_prot_inuse_add(net, prot, 1);

				/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */
				WRITE_ONCE(sk->sk_prot, prot);
				sk->sk_socket->ops = &inet_dgram_ops;
				sk->sk_family = PF_INET;
			}
			opt = xchg((__force struct ipv6_txoptions **)&np->opt,
				   NULL);
			if (opt) {
				atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
				txopt_put(opt);
			}
			pktopt = xchg(&np->pktoptions, NULL);
			kfree_skb(pktopt);

			/*
			 * ... and add it to the refcnt debug socks count
			 * in the new family. -acme
			 */
			sk_refcnt_debug_inc(sk);
			module_put(THIS_MODULE);
			retv = 0;
			break;
		}
		goto e_inval;

	case IPV6_V6ONLY:
		if (optlen < sizeof(int) ||
		    inet_sk(sk)->inet_num)
			goto e_inval;
		sk->sk_ipv6only = valbool;
		retv = 0;
		break;

	case IPV6_RECVPKTINFO:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxinfo = valbool;
		retv = 0;
		break;

	case IPV6_2292PKTINFO:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxoinfo = valbool;
		retv = 0;
		break;

	case IPV6_RECVHOPLIMIT:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxhlim = valbool;
		retv = 0;
		break;

	case IPV6_2292HOPLIMIT:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxohlim = valbool;
		retv = 0;
		break;

	case IPV6_RECVRTHDR:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.srcrt = valbool;
		retv = 0;
		break;

	case IPV6_2292RTHDR:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.osrcrt = valbool;
		retv = 0;
		break;

	case IPV6_RECVHOPOPTS:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.hopopts = valbool;
		retv = 0;
		break;

	case IPV6_2292HOPOPTS:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.ohopopts = valbool;
		retv = 0;
		break;

	case IPV6_RECVDSTOPTS:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.dstopts = valbool;
		retv = 0;
		break;

	case IPV6_2292DSTOPTS:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.odstopts = valbool;
		retv = 0;
		break;

	case IPV6_TCLASS:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val < -1 || val > 0xff)
			goto e_inval;
		/* RFC 3542, 6.5: default traffic class of 0x0 */
		if (val == -1)
			val = 0;
		if (sk->sk_type == SOCK_STREAM) {
			val &= ~INET_ECN_MASK;
			val |= np->tclass & INET_ECN_MASK;
		}
		if (np->tclass != val) {
			np->tclass = val;
			sk_dst_reset(sk);
		}
		retv = 0;
		break;

	case IPV6_RECVTCLASS:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxtclass = valbool;
		retv = 0;
		break;

	case IPV6_FLOWINFO:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxflow = valbool;
		retv = 0;
		break;

	case IPV6_RECVPATHMTU:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxpmtu = valbool;
		retv = 0;
		break;

	case IPV6_TRANSPARENT:
		if (valbool && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW) &&
		    !sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN)) {
			retv = -EPERM;
			break;
		}
		if (optlen < sizeof(int))
			goto e_inval;
		/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */
		inet_sk(sk)->transparent = valbool;
		retv = 0;
		break;

	case IPV6_FREEBIND:
		if (optlen < sizeof(int))
			goto e_inval;
		/* we also don't have a separate freebind bit for IPV6 */
		inet_sk(sk)->freebind = valbool;
		retv = 0;
		break;

	case IPV6_RECVORIGDSTADDR:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rxopt.bits.rxorigdstaddr = valbool;
		retv = 0;
		break;

	case IPV6_HOPOPTS:
	case IPV6_RTHDRDSTOPTS:
	case IPV6_RTHDR:
	case IPV6_DSTOPTS:
		retv = ipv6_set_opt_hdr(sk, optname, optval, optlen);
		break;

	case IPV6_PKTINFO:
	{
		struct in6_pktinfo pkt;

		if (optlen == 0)
			goto e_inval;
		else if (optlen < sizeof(struct in6_pktinfo) ||
			 sockptr_is_null(optval))
			goto e_inval;

		if (copy_from_sockptr(&pkt, optval, sizeof(pkt))) {
			retv = -EFAULT;
			break;
		}
		if (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))
			goto e_inval;

		np->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;
		np->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;
		retv = 0;
		break;
	}

	case IPV6_2292PKTOPTIONS:
	{
		struct ipv6_txoptions *opt = NULL;
		struct msghdr msg;
		struct flowi6 fl6;
		struct ipcm6_cookie ipc6;

		memset(&fl6, 0, sizeof(fl6));
		fl6.flowi6_oif = sk->sk_bound_dev_if;
		fl6.flowi6_mark = sk->sk_mark;

		if (optlen == 0)
			goto update;

		/* 1K is probably excessive
		 * 1K is surely not enough, 2K per standard header is 16K.
		 */
		retv = -EINVAL;
		if (optlen > 64*1024)
			break;

		opt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);
		retv = -ENOBUFS;
		if (!opt)
			break;

		memset(opt, 0, sizeof(*opt));
		refcount_set(&opt->refcnt, 1);
		opt->tot_len = sizeof(*opt) + optlen;
		retv = -EFAULT;
		if (copy_from_sockptr(opt + 1, optval, optlen))
			goto done;

		msg.msg_controllen = optlen;
		msg.msg_control = (void *)(opt+1);
		ipc6.opt = opt;

		retv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);
		if (retv)
			goto done;
update:
		retv = 0;
		opt = ipv6_update_options(sk, opt);
done:
		if (opt) {
			atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
			txopt_put(opt);
		}
		break;
	}
	case IPV6_UNICAST_HOPS:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val > 255 || val < -1)
			goto e_inval;
		np->hop_limit = val;
		retv = 0;
		break;

	case IPV6_MULTICAST_HOPS:
		if (sk->sk_type == SOCK_STREAM)
			break;
		if (optlen < sizeof(int))
			goto e_inval;
		if (val > 255 || val < -1)
			goto e_inval;
		np->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);
		retv = 0;
		break;

	case IPV6_MULTICAST_LOOP:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val != valbool)
			goto e_inval;
		np->mc_loop = valbool;
		retv = 0;
		break;

	case IPV6_UNICAST_IF:
	{
		struct net_device *dev = NULL;
		int ifindex;

		if (optlen != sizeof(int))
			goto e_inval;

		ifindex = (__force int)ntohl((__force __be32)val);
		if (ifindex == 0) {
			np->ucast_oif = 0;
			retv = 0;
			break;
		}

		dev = dev_get_by_index(net, ifindex);
		retv = -EADDRNOTAVAIL;
		if (!dev)
			break;
		dev_put(dev);

		retv = -EINVAL;
		if (sk->sk_bound_dev_if)
			break;

		np->ucast_oif = ifindex;
		retv = 0;
		break;
	}

	case IPV6_MULTICAST_IF:
		if (sk->sk_type == SOCK_STREAM)
			break;
		if (optlen < sizeof(int))
			goto e_inval;

		if (val) {
			struct net_device *dev;
			int midx;

			rcu_read_lock();

			dev = dev_get_by_index_rcu(net, val);
			if (!dev) {
				rcu_read_unlock();
				retv = -ENODEV;
				break;
			}
			midx = l3mdev_master_ifindex_rcu(dev);

			rcu_read_unlock();

			if (sk->sk_bound_dev_if &&
			    sk->sk_bound_dev_if != val &&
			    (!midx || midx != sk->sk_bound_dev_if))
				goto e_inval;
		}
		np->mcast_oif = val;
		retv = 0;
		break;
	case IPV6_ADD_MEMBERSHIP:
	case IPV6_DROP_MEMBERSHIP:
	{
		struct ipv6_mreq mreq;

		if (optlen < sizeof(struct ipv6_mreq))
			goto e_inval;

		retv = -EPROTO;
		if (inet_sk(sk)->is_icsk)
			break;

		retv = -EFAULT;
		if (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))
			break;

		if (optname == IPV6_ADD_MEMBERSHIP)
			retv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
		else
			retv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
		break;
	}
	case IPV6_JOIN_ANYCAST:
	case IPV6_LEAVE_ANYCAST:
	{
		struct ipv6_mreq mreq;

		if (optlen < sizeof(struct ipv6_mreq))
			goto e_inval;

		retv = -EFAULT;
		if (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))
			break;

		if (optname == IPV6_JOIN_ANYCAST)
			retv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
		else
			retv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
		break;
	}
	case IPV6_MULTICAST_ALL:
		if (optlen < sizeof(int))
			goto e_inval;
		np->mc_all = valbool;
		retv = 0;
		break;

	case MCAST_JOIN_GROUP:
	case MCAST_LEAVE_GROUP:
		if (in_compat_syscall())
			retv = compat_ipv6_mcast_join_leave(sk, optname, optval,
							    optlen);
		else
			retv = ipv6_mcast_join_leave(sk, optname, optval,
						     optlen);
		break;
	case MCAST_JOIN_SOURCE_GROUP:
	case MCAST_LEAVE_SOURCE_GROUP:
	case MCAST_BLOCK_SOURCE:
	case MCAST_UNBLOCK_SOURCE:
		retv = do_ipv6_mcast_group_source(sk, optname, optval, optlen);
		break;
	case MCAST_MSFILTER:
		if (in_compat_syscall())
			retv = compat_ipv6_set_mcast_msfilter(sk, optval,
							      optlen);
		else
			retv = ipv6_set_mcast_msfilter(sk, optval, optlen);
		break;
	case IPV6_ROUTER_ALERT:
		if (optlen < sizeof(int))
			goto e_inval;
		retv = ip6_ra_control(sk, val);
		break;
	case IPV6_ROUTER_ALERT_ISOLATE:
		if (optlen < sizeof(int))
			goto e_inval;
		np->rtalert_isolate = valbool;
		retv = 0;
		break;
	case IPV6_MTU_DISCOVER:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)
			goto e_inval;
		np->pmtudisc = val;
		retv = 0;
		break;
	case IPV6_MTU:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val && val < IPV6_MIN_MTU)
			goto e_inval;
		np->frag_size = val;
		retv = 0;
		break;
	case IPV6_RECVERR:
		if (optlen < sizeof(int))
			goto e_inval;
		np->recverr = valbool;
		if (!val)
			skb_queue_purge(&sk->sk_error_queue);
		retv = 0;
		break;
	case IPV6_FLOWINFO_SEND:
		if (optlen < sizeof(int))
			goto e_inval;
		np->sndflow = valbool;
		retv = 0;
		break;
	case IPV6_FLOWLABEL_MGR:
		retv = ipv6_flowlabel_opt(sk, optval, optlen);
		break;
	case IPV6_IPSEC_POLICY:
	case IPV6_XFRM_POLICY:
		retv = -EPERM;
		if (!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN))
			break;
		retv = xfrm_user_policy(sk, optname, optval, optlen);
		break;

	case IPV6_ADDR_PREFERENCES:
		if (optlen < sizeof(int))
			goto e_inval;
		retv = __ip6_sock_set_addr_preferences(sk, val);
		break;
	case IPV6_MINHOPCOUNT:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val < 0 || val > 255)
			goto e_inval;

		if (val)
			static_branch_enable(&ip6_min_hopcount);

		/* tcp_v6_err() and tcp_v6_rcv() might read min_hopcount
		 * while we are changing it.
		 */
		WRITE_ONCE(np->min_hopcount, val);
		retv = 0;
		break;
	case IPV6_DONTFRAG:
		np->dontfrag = valbool;
		retv = 0;
		break;
	case IPV6_AUTOFLOWLABEL:
		np->autoflowlabel = valbool;
		np->autoflowlabel_set = 1;
		retv = 0;
		break;
	case IPV6_RECVFRAGSIZE:
		np->rxopt.bits.recvfragsize = valbool;
		retv = 0;
		break;
	case IPV6_RECVERR_RFC4884:
		if (optlen < sizeof(int))
			goto e_inval;
		if (val < 0 || val > 1)
			goto e_inval;
		np->recverr_rfc4884 = valbool;
		retv = 0;
		break;
	}

unlock:
	sockopt_release_sock(sk);
	if (needs_rtnl)
		rtnl_unlock();

	return retv;

e_inval:
	sockopt_release_sock(sk);
	if (needs_rtnl)
		rtnl_unlock();
	return -EINVAL;
}","int do_ipv6_setsockopt(struct sock *VAR_0, int VAR_1, int VAR_2,
		       sockptr_t VAR_3, unsigned int VAR_4)
{
	struct ipv6_pinfo *VAR_5 = inet6_sk(VAR_0);
	struct net *net = sock_net(VAR_0);
	int VAR_6, VAR_7;
	int VAR_8 = -VAR_9;
	bool VAR_10 = setsockopt_needs_rtnl(VAR_2);

	if (sockptr_is_null(VAR_3))
		VAR_6 = 0;
	else {
		if (VAR_4 >= sizeof(int)) {
			if (copy_from_sockptr(&VAR_6, VAR_3, sizeof(VAR_6)))
				return -VAR_11;
		} else
			VAR_6 = 0;
	}

	VAR_7 = (VAR_6 != 0);

	if (ip6_mroute_opt(VAR_2))
		return ip6_mroute_setsockopt(VAR_0, VAR_2, VAR_3, VAR_4);

	if (VAR_10)
		rtnl_lock();
	sockopt_lock_sock(VAR_0);

	/* COMMENT_0 */
                               
    
	if (unlikely(VAR_0->sk_family != VAR_12))
		goto unlock;

	switch (VAR_2) {

	case VAR_13:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 == VAR_14) {
			struct ipv6_txoptions *VAR_15;
			struct sk_buff *VAR_16;

			if (VAR_0->sk_type == VAR_17)
				break;

			if (VAR_0->sk_protocol == VAR_18 ||
			    VAR_0->sk_protocol == VAR_19) {
				struct udp_sock *VAR_20 = udp_sk(VAR_0);
				if (VAR_20->pending == VAR_12) {
					VAR_8 = -VAR_21;
					break;
				}
			} else if (VAR_0->sk_protocol == VAR_22) {
				if (VAR_0->sk_prot != &VAR_23) {
					VAR_8 = -VAR_21;
					break;
				}
			} else {
				break;
			}

			if (VAR_0->sk_state != VAR_24) {
				VAR_8 = -VAR_25;
				break;
			}

			if (ipv6_only_sock(VAR_0) ||
			    !ipv6_addr_v4mapped(&VAR_0->sk_v6_daddr)) {
				VAR_8 = -VAR_26;
				break;
			}

			fl6_free_socklist(VAR_0);
			__ipv6_sock_mc_close(VAR_0);
			__ipv6_sock_ac_close(VAR_0);

			/* COMMENT_3 */
                                                    
                                                        
                        
      
			sk_refcnt_debug_dec(VAR_0);

			if (VAR_0->sk_protocol == VAR_22) {
				struct inet_connection_sock *VAR_27 = inet_csk(VAR_0);

				sock_prot_inuse_add(net, VAR_0->sk_prot, -1);
				sock_prot_inuse_add(net, &VAR_28, 1);

				/* COMMENT_8 */
				WRITE_ONCE(VAR_0->sk_prot, &VAR_28);
				VAR_27->icsk_af_ops = &VAR_29;
				VAR_0->sk_socket->ops = &VAR_30;
				VAR_0->sk_family = VAR_14;
				tcp_sync_mss(VAR_0, VAR_27->icsk_pmtu_cookie);
			} else {
				struct proto *VAR_31 = &VAR_32;

				if (VAR_0->sk_protocol == VAR_19)
					VAR_31 = &VAR_33;

				sock_prot_inuse_add(net, VAR_0->sk_prot, -1);
				sock_prot_inuse_add(net, VAR_31, 1);

				/* COMMENT_8 */
				WRITE_ONCE(VAR_0->sk_prot, VAR_31);
				VAR_0->sk_socket->ops = &VAR_34;
				VAR_0->sk_family = VAR_14;
			}
			VAR_15 = xchg((VAR_35 struct ipv6_txoptions **)&VAR_5->opt,
				   NULL);
			if (VAR_15) {
				atomic_sub(VAR_15->tot_len, &VAR_0->sk_omem_alloc);
				txopt_put(VAR_15);
			}
			VAR_16 = xchg(&VAR_5->pktoptions, NULL);
			kfree_skb(VAR_16);

			/* COMMENT_9 */
                                                    
                              
      
			sk_refcnt_debug_inc(VAR_0);
			module_put(VAR_36);
			VAR_8 = 0;
			break;
		}
		goto e_inval;

	case VAR_37:
		if (VAR_4 < sizeof(int) ||
		    inet_sk(VAR_0)->inet_num)
			goto e_inval;
		VAR_0->sk_ipv6only = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_38:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxinfo = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_39:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxoinfo = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_40:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxhlim = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_41:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxohlim = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_42:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.srcrt = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_43:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.osrcrt = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_44:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.hopopts = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_45:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.ohopopts = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_46:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.dstopts = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_47:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.odstopts = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_48:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 < -1 || VAR_6 > 0xff)
			goto e_inval;
		/* COMMENT_13 */
		if (VAR_6 == -1)
			VAR_6 = 0;
		if (VAR_0->sk_type == VAR_49) {
			VAR_6 &= ~VAR_50;
			VAR_6 |= VAR_5->tclass & VAR_50;
		}
		if (VAR_5->tclass != VAR_6) {
			VAR_5->tclass = VAR_6;
			sk_dst_reset(VAR_0);
		}
		VAR_8 = 0;
		break;

	case VAR_51:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxtclass = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_52:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxflow = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_53:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxpmtu = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_54:
		if (VAR_7 && !sockopt_ns_capable(net->user_ns, VAR_55) &&
		    !sockopt_ns_capable(net->user_ns, VAR_56)) {
			VAR_8 = -VAR_57;
			break;
		}
		if (VAR_4 < sizeof(int))
			goto e_inval;
		/* COMMENT_14 */
		inet_sk(VAR_0)->transparent = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_58:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		/* COMMENT_15 */
		inet_sk(VAR_0)->freebind = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_59:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rxopt.bits.rxorigdstaddr = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_60:
	case VAR_61:
	case VAR_62:
	case VAR_63:
		VAR_8 = ipv6_set_opt_hdr(VAR_0, VAR_2, VAR_3, VAR_4);
		break;

	case VAR_64:
	{
		struct in6_pktinfo VAR_65;

		if (VAR_4 == 0)
			goto e_inval;
		else if (VAR_4 < sizeof(struct in6_pktinfo) ||
			 sockptr_is_null(VAR_3))
			goto e_inval;

		if (copy_from_sockptr(&VAR_65, VAR_3, sizeof(VAR_65))) {
			VAR_8 = -VAR_11;
			break;
		}
		if (!sk_dev_equal_l3scope(VAR_0, VAR_65.ipi6_ifindex))
			goto e_inval;

		VAR_5->sticky_pktinfo.ipi6_ifindex = VAR_65.ipi6_ifindex;
		VAR_5->sticky_pktinfo.ipi6_addr = VAR_65.ipi6_addr;
		VAR_8 = 0;
		break;
	}

	case VAR_66:
	{
		struct ipv6_txoptions *VAR_15 = NULL;
		struct msghdr VAR_67;
		struct flowi6 VAR_68;
		struct ipcm6_cookie VAR_69;

		memset(&VAR_68, 0, sizeof(VAR_68));
		VAR_68.flowi6_oif = VAR_0->sk_bound_dev_if;
		VAR_68.flowi6_mark = VAR_0->sk_mark;

		if (VAR_4 == 0)
			goto update;

		/* COMMENT_16 */
                                                            
     
		VAR_8 = -VAR_70;
		if (VAR_4 > 64*1024)
			break;

		VAR_15 = sock_kmalloc(VAR_0, sizeof(*VAR_15) + VAR_4, VAR_71);
		VAR_8 = -VAR_72;
		if (!VAR_15)
			break;

		memset(VAR_15, 0, sizeof(*VAR_15));
		refcount_set(&VAR_15->refcnt, 1);
		VAR_15->tot_len = sizeof(*VAR_15) + VAR_4;
		VAR_8 = -VAR_11;
		if (copy_from_sockptr(VAR_15 + 1, VAR_3, VAR_4))
			goto done;

		VAR_67.msg_controllen = VAR_4;
		VAR_67.msg_control = (void *)(VAR_15+1);
		VAR_69.opt = VAR_15;

		VAR_8 = ip6_datagram_send_ctl(net, VAR_0, &VAR_67, &VAR_68, &VAR_69);
		if (VAR_8)
			goto done;
update:
		VAR_8 = 0;
		VAR_15 = ipv6_update_options(VAR_0, VAR_15);
done:
		if (VAR_15) {
			atomic_sub(VAR_15->tot_len, &VAR_0->sk_omem_alloc);
			txopt_put(VAR_15);
		}
		break;
	}
	case VAR_73:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 > 255 || VAR_6 < -1)
			goto e_inval;
		VAR_5->hop_limit = VAR_6;
		VAR_8 = 0;
		break;

	case VAR_74:
		if (VAR_0->sk_type == VAR_49)
			break;
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 > 255 || VAR_6 < -1)
			goto e_inval;
		VAR_5->mcast_hops = (VAR_6 == -1 ? VAR_75 : VAR_6);
		VAR_8 = 0;
		break;

	case VAR_76:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 != VAR_7)
			goto e_inval;
		VAR_5->mc_loop = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_77:
	{
		struct net_device *VAR_78 = NULL;
		int VAR_79;

		if (VAR_4 != sizeof(int))
			goto e_inval;

		VAR_79 = (__force int)ntohl((__force VAR_80)VAR_6);
		if (VAR_79 == 0) {
			VAR_5->ucast_oif = 0;
			VAR_8 = 0;
			break;
		}

		VAR_78 = dev_get_by_index(net, VAR_79);
		VAR_8 = -VAR_26;
		if (!VAR_78)
			break;
		dev_put(VAR_78);

		VAR_8 = -VAR_70;
		if (VAR_0->sk_bound_dev_if)
			break;

		VAR_5->ucast_oif = VAR_79;
		VAR_8 = 0;
		break;
	}

	case VAR_81:
		if (VAR_0->sk_type == VAR_49)
			break;
		if (VAR_4 < sizeof(int))
			goto e_inval;

		if (VAR_6) {
			struct net_device *VAR_78;
			int VAR_82;

			rcu_read_lock();

			VAR_78 = dev_get_by_index_rcu(net, VAR_6);
			if (!VAR_78) {
				rcu_read_unlock();
				VAR_8 = -VAR_83;
				break;
			}
			VAR_82 = l3mdev_master_ifindex_rcu(VAR_78);

			rcu_read_unlock();

			if (VAR_0->sk_bound_dev_if &&
			    VAR_0->sk_bound_dev_if != VAR_6 &&
			    (!VAR_82 || VAR_82 != VAR_0->sk_bound_dev_if))
				goto e_inval;
		}
		VAR_5->mcast_oif = VAR_6;
		VAR_8 = 0;
		break;
	case VAR_84:
	case VAR_85:
	{
		struct ipv6_mreq VAR_86;

		if (VAR_4 < sizeof(struct ipv6_mreq))
			goto e_inval;

		VAR_8 = -VAR_87;
		if (inet_sk(VAR_0)->is_icsk)
			break;

		VAR_8 = -VAR_11;
		if (copy_from_sockptr(&VAR_86, VAR_3, sizeof(struct ipv6_mreq)))
			break;

		if (VAR_2 == VAR_84)
			VAR_8 = ipv6_sock_mc_join(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_multiaddr);
		else
			VAR_8 = ipv6_sock_mc_drop(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_multiaddr);
		break;
	}
	case VAR_88:
	case VAR_89:
	{
		struct ipv6_mreq VAR_86;

		if (VAR_4 < sizeof(struct ipv6_mreq))
			goto e_inval;

		VAR_8 = -VAR_11;
		if (copy_from_sockptr(&VAR_86, VAR_3, sizeof(struct ipv6_mreq)))
			break;

		if (VAR_2 == VAR_88)
			VAR_8 = ipv6_sock_ac_join(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_acaddr);
		else
			VAR_8 = ipv6_sock_ac_drop(VAR_0, VAR_86.ipv6mr_ifindex, &VAR_86.ipv6mr_acaddr);
		break;
	}
	case VAR_90:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->mc_all = VAR_7;
		VAR_8 = 0;
		break;

	case VAR_91:
	case VAR_92:
		if (in_compat_syscall())
			VAR_8 = compat_ipv6_mcast_join_leave(VAR_0, VAR_2, VAR_3,
							    VAR_4);
		else
			VAR_8 = ipv6_mcast_join_leave(VAR_0, VAR_2, VAR_3,
						     VAR_4);
		break;
	case VAR_93:
	case VAR_94:
	case VAR_95:
	case VAR_96:
		VAR_8 = do_ipv6_mcast_group_source(VAR_0, VAR_2, VAR_3, VAR_4);
		break;
	case VAR_97:
		if (in_compat_syscall())
			VAR_8 = compat_ipv6_set_mcast_msfilter(VAR_0, VAR_3,
							      VAR_4);
		else
			VAR_8 = ipv6_set_mcast_msfilter(VAR_0, VAR_3, VAR_4);
		break;
	case VAR_98:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_8 = ip6_ra_control(VAR_0, VAR_6);
		break;
	case VAR_99:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->rtalert_isolate = VAR_7;
		VAR_8 = 0;
		break;
	case VAR_100:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 < VAR_101 || VAR_6 > VAR_102)
			goto e_inval;
		VAR_5->pmtudisc = VAR_6;
		VAR_8 = 0;
		break;
	case VAR_103:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 && VAR_6 < VAR_104)
			goto e_inval;
		VAR_5->frag_size = VAR_6;
		VAR_8 = 0;
		break;
	case VAR_105:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->recverr = VAR_7;
		if (!VAR_6)
			skb_queue_purge(&VAR_0->sk_error_queue);
		VAR_8 = 0;
		break;
	case VAR_106:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_5->sndflow = VAR_7;
		VAR_8 = 0;
		break;
	case VAR_107:
		VAR_8 = ipv6_flowlabel_opt(VAR_0, VAR_3, VAR_4);
		break;
	case VAR_108:
	case VAR_109:
		VAR_8 = -VAR_57;
		if (!sockopt_ns_capable(net->user_ns, VAR_56))
			break;
		VAR_8 = xfrm_user_policy(VAR_0, VAR_2, VAR_3, VAR_4);
		break;

	case VAR_110:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		VAR_8 = __ip6_sock_set_addr_preferences(VAR_0, VAR_6);
		break;
	case VAR_111:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 < 0 || VAR_6 > 255)
			goto e_inval;

		if (VAR_6)
			static_branch_enable(&VAR_112);

		/* COMMENT_19 */
                              
     
		WRITE_ONCE(VAR_5->min_hopcount, VAR_6);
		VAR_8 = 0;
		break;
	case VAR_113:
		VAR_5->dontfrag = VAR_7;
		VAR_8 = 0;
		break;
	case VAR_114:
		VAR_5->autoflowlabel = VAR_7;
		VAR_5->autoflowlabel_set = 1;
		VAR_8 = 0;
		break;
	case VAR_115:
		VAR_5->rxopt.bits.recvfragsize = VAR_7;
		VAR_8 = 0;
		break;
	case VAR_116:
		if (VAR_4 < sizeof(int))
			goto e_inval;
		if (VAR_6 < 0 || VAR_6 > 1)
			goto e_inval;
		VAR_5->recverr_rfc4884 = VAR_7;
		VAR_8 = 0;
		break;
	}

unlock:
	sockopt_release_sock(VAR_0);
	if (VAR_10)
		rtnl_unlock();

	return VAR_8;

e_inval:
	sockopt_release_sock(VAR_0);
	if (VAR_10)
		rtnl_unlock();
	return -VAR_70;
}",torvalds/linux/3c52c6bb831f6335c176a0fc7214e26f43adbd11/ipv6_sockglue.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,6 +25,12 @@
 	if (needs_rtnl)
 		rtnl_lock();
 	sockopt_lock_sock(sk);
+
+	/* Another thread has converted the socket into IPv4 with
+	 * IPV6_ADDRFORM concurrently.
+	 */
+	if (unlikely(sk->sk_family != AF_INET6))
+		goto unlock;
 
 	switch (optname) {
 
@@ -601,6 +607,7 @@
 		break;
 	}
 
+unlock:
 	sockopt_release_sock(sk);
 	if (needs_rtnl)
 		rtnl_unlock();","{'deleted_lines': [], 'added_lines': ['', '\t/* Another thread has converted the socket into IPv4 with', '\t * IPV6_ADDRFORM concurrently.', '\t */', '\tif (unlikely(sk->sk_family != AF_INET6))', '\t\tgoto unlock;', 'unlock:']}",True,A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function ipv6_renew_options of the component IPv6 Handler. The manipulation leads to memory leak. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211021 was assigned to this vulnerability.,5.5,MEDIUM,1,valid,,5
CVE-2017-15022,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR22201, DW_AT_name with out of bounds reference

DW_AT_name ought to always have a string value.

	PR 22201
	* dwarf2.c (scan_unit_for_symbols): Ignore DW_AT_name unless it
	has string form.
	(parse_comp_unit): Likewise.
",11855d8a1f11b102a702ab76e95b22082cccf2f8,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=11855d8a1f11b102a702ab76e95b22082cccf2f8,bfd/dwarf2.c,scan_unit_for_symbols,"static bfd_boolean
scan_unit_for_symbols (struct comp_unit *unit)
{
bfd *abfd = unit->abfd;
bfd_byte *info_ptr = unit->first_child_die_ptr;
bfd_byte *info_ptr_end = unit->stash->info_ptr_end;
int nesting_level = 0;
struct nest_funcinfo {
struct funcinfo *func;
} *nested_funcs;
int nested_funcs_size;
nested_funcs_size = 32;
nested_funcs = (struct nest_funcinfo *)
bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));
if (nested_funcs == NULL)
return FALSE;
nested_funcs[nesting_level].func = 0;
while (nesting_level >= 0)
{
unsigned int abbrev_number, bytes_read, i;
struct abbrev_info *abbrev;
struct attribute attr;
struct funcinfo *func;
struct varinfo *var;
bfd_vma low_pc = 0;
bfd_vma high_pc = 0;
bfd_boolean high_pc_relative = FALSE;
if (info_ptr >= info_ptr_end)
goto fail;
abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,
FALSE, info_ptr_end);
info_ptr += bytes_read;
if (! abbrev_number)
{
nesting_level--;
continue;
}
abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);
if (! abbrev)
{
static unsigned int previous_failed_abbrev = -1U;
if (abbrev_number != previous_failed_abbrev)
{
_bfd_error_handler
(_(""Dwarf Error: Could not find abbrev number %u.""),
abbrev_number);
previous_failed_abbrev = abbrev_number;
}
bfd_set_error (bfd_error_bad_value);
goto fail;
}
var = NULL;
if (abbrev->tag == DW_TAG_subprogram
|| abbrev->tag == DW_TAG_entry_point
|| abbrev->tag == DW_TAG_inlined_subroutine)
{
bfd_size_type amt = sizeof (struct funcinfo);
func = (struct funcinfo *) bfd_zalloc (abfd, amt);
if (func == NULL)
goto fail;
func->tag = abbrev->tag;
func->prev_func = unit->function_table;
unit->function_table = func;
unit->number_of_functions++;
BFD_ASSERT (!unit->cached);
if (func->tag == DW_TAG_inlined_subroutine)
for (i = nesting_level; i-- != 0; )
if (nested_funcs[i].func)
{
func->caller_func = nested_funcs[i].func;
break;
}
nested_funcs[nesting_level].func = func;
}
else
{
func = NULL;
if (abbrev->tag == DW_TAG_variable)
{
bfd_size_type amt = sizeof (struct varinfo);
var = (struct varinfo *) bfd_zalloc (abfd, amt);
if (var == NULL)
goto fail;
var->tag = abbrev->tag;
var->stack = 1;
var->prev_var = unit->variable_table;
unit->variable_table = var;
}
nested_funcs[nesting_level].func = 0;
}
for (i = 0; i < abbrev->num_attrs; ++i)
{
info_ptr = read_attribute (&attr, &abbrev->attrs[i],
unit, info_ptr, info_ptr_end);
if (info_ptr == NULL)
goto fail;
if (func)
{
switch (attr.name)
{
case DW_AT_call_file:
func->caller_file = concat_filename (unit->line_table,
attr.u.val);
break;
case DW_AT_call_line:
func->caller_line = attr.u.val;
break;
case DW_AT_abstract_origin:
case DW_AT_specification:
if (!find_abstract_instance_name (unit, info_ptr, &attr,
&func->name,
&func->is_linkage))
goto fail;
break;
case DW_AT_name:
if (func->name == NULL && is_str_attr (attr.form))
{
func->name = attr.u.str;
if (non_mangled (unit->lang))
func->is_linkage = TRUE;
}
break;
case DW_AT_linkage_name:
case DW_AT_MIPS_linkage_name:
if (is_str_attr (attr.form))
{
func->name = attr.u.str;
func->is_linkage = TRUE;
}
break;
case DW_AT_low_pc:
low_pc = attr.u.val;
break;
case DW_AT_high_pc:
high_pc = attr.u.val;
high_pc_relative = attr.form != DW_FORM_addr;
break;
case DW_AT_ranges:
if (!read_rangelist (unit, &func->arange, attr.u.val))
goto fail;
break;
case DW_AT_decl_file:
func->file = concat_filename (unit->line_table,
attr.u.val);
break;
case DW_AT_decl_line:
func->line = attr.u.val;
break;
default:
break;
}
}
else if (var)
{
switch (attr.name)
{
case DW_AT_name:
var->name = attr.u.str;
break;
case DW_AT_decl_file:
var->file = concat_filename (unit->line_table,
attr.u.val);
break;
case DW_AT_decl_line:
var->line = attr.u.val;
break;
case DW_AT_external:
if (attr.u.val != 0)
var->stack = 0;
break;
case DW_AT_location:
switch (attr.form)
{
case DW_FORM_block:
case DW_FORM_block1:
case DW_FORM_block2:
case DW_FORM_block4:
case DW_FORM_exprloc:
if (attr.u.blk->data != NULL
&& *attr.u.blk->data == DW_OP_addr)
{
var->stack = 0;
if (attr.u.blk->size == unit->addr_size + 1U)
var->addr = bfd_get (unit->addr_size * 8,
unit->abfd,
attr.u.blk->data + 1);
}
break;
default:
break;
}
break;
default:
break;
}
}
}
if (high_pc_relative)
high_pc += low_pc;
if (func && high_pc != 0)
{
if (!arange_add (unit, &func->arange, low_pc, high_pc))
goto fail;
}
if (abbrev->has_children)
{
nesting_level++;
if (nesting_level >= nested_funcs_size)
{
struct nest_funcinfo *tmp;
nested_funcs_size *= 2;
tmp = (struct nest_funcinfo *)
bfd_realloc (nested_funcs,
nested_funcs_size * sizeof (*nested_funcs));
if (tmp == NULL)
goto fail;
nested_funcs = tmp;
}
nested_funcs[nesting_level].func = 0;
}
}
free (nested_funcs);
return TRUE;
fail:
free (nested_funcs);
return FALSE;
}","static bfd_boolean
scan_unit_for_symbols (struct comp_unit *VAR_0)
{
bfd *VAR_1 = VAR_0->abfd;
bfd_byte *VAR_2 = VAR_0->first_child_die_ptr;
bfd_byte *VAR_3 = VAR_0->stash->info_ptr_end;
int VAR_4 = 0;
struct nest_funcinfo {
struct funcinfo *func;
} *VAR_5;
int VAR_6;
VAR_6 = 32;
VAR_5 = (struct nest_funcinfo *)
bfd_malloc (VAR_6 * sizeof (*VAR_5));
if (VAR_5 == NULL)
return FALSE;
VAR_5[VAR_4].func = 0;
while (VAR_4 >= 0)
{
unsigned int VAR_7, VAR_8, VAR_9;
struct abbrev_info *VAR_10;
struct attribute VAR_11;
struct funcinfo *VAR_12;
struct varinfo *VAR_13;
bfd_vma VAR_14 = 0;
bfd_vma VAR_15 = 0;
bfd_boolean VAR_16 = FALSE;
if (VAR_2 >= VAR_3)
goto fail;
VAR_7 = _bfd_safe_read_leb128 (VAR_1, VAR_2, &VAR_8,
FALSE, VAR_3);
VAR_2 += VAR_8;
if (! VAR_7)
{
VAR_4--;
continue;
}
VAR_10 = lookup_abbrev (VAR_7, VAR_0->abbrevs);
if (! VAR_10)
{
static unsigned int VAR_17 = -1U;
if (VAR_7 != VAR_17)
{
_bfd_error_handler
(_(""Dwarf Error: Could not find abbrev number %u.""),
VAR_7);
VAR_17 = VAR_7;
}
bfd_set_error (VAR_18);
goto fail;
}
VAR_13 = NULL;
if (VAR_10->tag == VAR_19
|| VAR_10->tag == VAR_20
|| VAR_10->tag == VAR_21)
{
bfd_size_type VAR_22 = sizeof (struct funcinfo);
VAR_12 = (struct funcinfo *) bfd_zalloc (VAR_1, VAR_22);
if (VAR_12 == NULL)
goto fail;
VAR_12->tag = VAR_10->tag;
VAR_12->prev_func = VAR_0->function_table;
VAR_0->function_table = VAR_12;
VAR_0->number_of_functions++;
BFD_ASSERT (!VAR_0->cached);
if (VAR_12->tag == VAR_21)
for (VAR_9 = VAR_4; VAR_9-- != 0; )
if (VAR_5[VAR_9].func)
{
VAR_12->caller_func = VAR_5[VAR_9].func;
break;
}
VAR_5[VAR_4].func = VAR_12;
}
else
{
VAR_12 = NULL;
if (VAR_10->tag == VAR_23)
{
bfd_size_type VAR_22 = sizeof (struct varinfo);
VAR_13 = (struct varinfo *) bfd_zalloc (VAR_1, VAR_22);
if (VAR_13 == NULL)
goto fail;
VAR_13->tag = VAR_10->tag;
VAR_13->stack = 1;
VAR_13->prev_var = VAR_0->variable_table;
VAR_0->variable_table = VAR_13;
}
VAR_5[VAR_4].func = 0;
}
for (VAR_9 = 0; VAR_9 < VAR_10->num_attrs; ++VAR_9)
{
VAR_2 = read_attribute (&VAR_11, &VAR_10->attrs[VAR_9],
VAR_0, VAR_2, VAR_3);
if (VAR_2 == NULL)
goto fail;
if (VAR_12)
{
switch (VAR_11.name)
{
case VAR_24:
VAR_12->caller_file = concat_filename (VAR_0->line_table,
VAR_11.u.val);
break;
case VAR_25:
VAR_12->caller_line = VAR_11.u.val;
break;
case VAR_26:
case VAR_27:
if (!find_abstract_instance_name (VAR_0, VAR_2, &VAR_11,
&VAR_12->name,
&VAR_12->is_linkage))
goto fail;
break;
case VAR_28:
if (VAR_12->name == NULL && is_str_attr (VAR_11.form))
{
VAR_12->name = VAR_11.u.str;
if (non_mangled (VAR_0->lang))
VAR_12->is_linkage = TRUE;
}
break;
case VAR_29:
case VAR_30:
if (is_str_attr (VAR_11.form))
{
VAR_12->name = VAR_11.u.str;
VAR_12->is_linkage = TRUE;
}
break;
case VAR_31:
VAR_14 = VAR_11.u.val;
break;
case VAR_32:
VAR_15 = VAR_11.u.val;
VAR_16 = VAR_11.form != VAR_33;
break;
case VAR_34:
if (!read_rangelist (VAR_0, &VAR_12->arange, VAR_11.u.val))
goto fail;
break;
case VAR_35:
VAR_12->file = concat_filename (VAR_0->line_table,
VAR_11.u.val);
break;
case VAR_36:
VAR_12->line = VAR_11.u.val;
break;
default:
break;
}
}
else if (VAR_13)
{
switch (VAR_11.name)
{
case VAR_28:
VAR_13->name = VAR_11.u.str;
break;
case VAR_35:
VAR_13->file = concat_filename (VAR_0->line_table,
VAR_11.u.val);
break;
case VAR_36:
VAR_13->line = VAR_11.u.val;
break;
case VAR_37:
if (VAR_11.u.val != 0)
VAR_13->stack = 0;
break;
case VAR_38:
switch (VAR_11.form)
{
case VAR_39:
case VAR_40:
case VAR_41:
case VAR_42:
case VAR_43:
if (VAR_11.u.blk->data != NULL
&& *VAR_11.u.blk->data == VAR_44)
{
VAR_13->stack = 0;
if (VAR_11.u.blk->size == VAR_0->addr_size + 1U)
VAR_13->addr = bfd_get (VAR_0->addr_size * 8,
VAR_0->abfd,
VAR_11.u.blk->data + 1);
}
break;
default:
break;
}
break;
default:
break;
}
}
}
if (VAR_16)
VAR_15 += VAR_14;
if (VAR_12 && VAR_15 != 0)
{
if (!arange_add (VAR_0, &VAR_12->arange, VAR_14, VAR_15))
goto fail;
}
if (VAR_10->has_children)
{
VAR_4++;
if (VAR_4 >= VAR_6)
{
struct nest_funcinfo *VAR_45;
VAR_6 *= 2;
VAR_45 = (struct nest_funcinfo *)
bfd_realloc (VAR_5,
VAR_6 * sizeof (*VAR_5));
if (VAR_45 == NULL)
goto fail;
VAR_5 = VAR_45;
}
VAR_5[VAR_4].func = 0;
}
}
free (VAR_5);
return TRUE;
fail:
free (VAR_5);
return FALSE;
}",binutils-gdb/11855d8a1f11b102a702ab76e95b22082cccf2f8/dwarf2.c/vul/before/0.json,"static bfd_boolean
scan_unit_for_symbols (struct comp_unit *unit)
{
  bfd *abfd = unit->abfd;
  bfd_byte *info_ptr = unit->first_child_die_ptr;
  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;
  int nesting_level = 0;
  struct nest_funcinfo {
    struct funcinfo *func;
  } *nested_funcs;
  int nested_funcs_size;

  /* Maintain a stack of in-scope functions and inlined functions, which we
     can use to set the caller_func field.  */
  nested_funcs_size = 32;
  nested_funcs = (struct nest_funcinfo *)
    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));
  if (nested_funcs == NULL)
    return FALSE;
  nested_funcs[nesting_level].func = 0;

  while (nesting_level >= 0)
    {
      unsigned int abbrev_number, bytes_read, i;
      struct abbrev_info *abbrev;
      struct attribute attr;
      struct funcinfo *func;
      struct varinfo *var;
      bfd_vma low_pc = 0;
      bfd_vma high_pc = 0;
      bfd_boolean high_pc_relative = FALSE;

      /* PR 17512: file: 9f405d9d.  */
      if (info_ptr >= info_ptr_end)
	goto fail;

      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,
					     FALSE, info_ptr_end);
      info_ptr += bytes_read;

      if (! abbrev_number)
	{
	  nesting_level--;
	  continue;
	}

      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);
      if (! abbrev)
	{
	  static unsigned int previous_failed_abbrev = -1U;

	  /* Avoid multiple reports of the same missing abbrev.  */
	  if (abbrev_number != previous_failed_abbrev)
	    {
	      _bfd_error_handler
		(_(""Dwarf Error: Could not find abbrev number %u.""),
		 abbrev_number);
	      previous_failed_abbrev = abbrev_number;
	    }
	  bfd_set_error (bfd_error_bad_value);
	  goto fail;
	}

      var = NULL;
      if (abbrev->tag == DW_TAG_subprogram
	  || abbrev->tag == DW_TAG_entry_point
	  || abbrev->tag == DW_TAG_inlined_subroutine)
	{
	  bfd_size_type amt = sizeof (struct funcinfo);
	  func = (struct funcinfo *) bfd_zalloc (abfd, amt);
	  if (func == NULL)
	    goto fail;
	  func->tag = abbrev->tag;
	  func->prev_func = unit->function_table;
	  unit->function_table = func;
	  unit->number_of_functions++;
	  BFD_ASSERT (!unit->cached);

	  if (func->tag == DW_TAG_inlined_subroutine)
	    for (i = nesting_level; i-- != 0; )
	      if (nested_funcs[i].func)
		{
		  func->caller_func = nested_funcs[i].func;
		  break;
		}
	  nested_funcs[nesting_level].func = func;
	}
      else
	{
	  func = NULL;
	  if (abbrev->tag == DW_TAG_variable)
	    {
	      bfd_size_type amt = sizeof (struct varinfo);
	      var = (struct varinfo *) bfd_zalloc (abfd, amt);
	      if (var == NULL)
		goto fail;
	      var->tag = abbrev->tag;
	      var->stack = 1;
	      var->prev_var = unit->variable_table;
	      unit->variable_table = var;
	      /* PR 18205: Missing debug information can cause this
		 var to be attached to an already cached unit.  */
	    }

	  /* No inline function in scope at this nesting level.  */
	  nested_funcs[nesting_level].func = 0;
	}

      for (i = 0; i < abbrev->num_attrs; ++i)
	{
	  info_ptr = read_attribute (&attr, &abbrev->attrs[i],
				     unit, info_ptr, info_ptr_end);
	  if (info_ptr == NULL)
	    goto fail;

	  if (func)
	    {
	      switch (attr.name)
		{
		case DW_AT_call_file:
		  func->caller_file = concat_filename (unit->line_table,
						       attr.u.val);
		  break;

		case DW_AT_call_line:
		  func->caller_line = attr.u.val;
		  break;

		case DW_AT_abstract_origin:
		case DW_AT_specification:
		  if (!find_abstract_instance_name (unit, info_ptr, &attr,
						    &func->name,
						    &func->is_linkage))
		    goto fail;
		  break;

		case DW_AT_name:
		  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name
		     over DW_AT_name.  */
		  if (func->name == NULL && is_str_attr (attr.form))
		    {
		      func->name = attr.u.str;
		      if (non_mangled (unit->lang))
			func->is_linkage = TRUE;
		    }
		  break;

		case DW_AT_linkage_name:
		case DW_AT_MIPS_linkage_name:
		  /* PR 16949:  Corrupt debug info can place
		     non-string forms into these attributes.  */
		  if (is_str_attr (attr.form))
		    {
		      func->name = attr.u.str;
		      func->is_linkage = TRUE;
		    }
		  break;

		case DW_AT_low_pc:
		  low_pc = attr.u.val;
		  break;

		case DW_AT_high_pc:
		  high_pc = attr.u.val;
		  high_pc_relative = attr.form != DW_FORM_addr;
		  break;

		case DW_AT_ranges:
		  if (!read_rangelist (unit, &func->arange, attr.u.val))
		    goto fail;
		  break;

		case DW_AT_decl_file:
		  func->file = concat_filename (unit->line_table,
						attr.u.val);
		  break;

		case DW_AT_decl_line:
		  func->line = attr.u.val;
		  break;

		default:
		  break;
		}
	    }
	  else if (var)
	    {
	      switch (attr.name)
		{
		case DW_AT_name:
		  if (is_str_attr (attr.form))
		    var->name = attr.u.str;
		  break;

		case DW_AT_decl_file:
		  var->file = concat_filename (unit->line_table,
					       attr.u.val);
		  break;

		case DW_AT_decl_line:
		  var->line = attr.u.val;
		  break;

		case DW_AT_external:
		  if (attr.u.val != 0)
		    var->stack = 0;
		  break;

		case DW_AT_location:
		  switch (attr.form)
		    {
		    case DW_FORM_block:
		    case DW_FORM_block1:
		    case DW_FORM_block2:
		    case DW_FORM_block4:
		    case DW_FORM_exprloc:
		      if (attr.u.blk->data != NULL
			  && *attr.u.blk->data == DW_OP_addr)
			{
			  var->stack = 0;

			  /* Verify that DW_OP_addr is the only opcode in the
			     location, in which case the block size will be 1
			     plus the address size.  */
			  /* ??? For TLS variables, gcc can emit
			     DW_OP_addr <addr> DW_OP_GNU_push_tls_address
			     which we don't handle here yet.  */
			  if (attr.u.blk->size == unit->addr_size + 1U)
			    var->addr = bfd_get (unit->addr_size * 8,
						 unit->abfd,
						 attr.u.blk->data + 1);
			}
		      break;

		    default:
		      break;
		    }
		  break;

		default:
		  break;
		}
	    }
	}

      if (high_pc_relative)
	high_pc += low_pc;

      if (func && high_pc != 0)
	{
	  if (!arange_add (unit, &func->arange, low_pc, high_pc))
	    goto fail;
	}

      if (abbrev->has_children)
	{
	  nesting_level++;

	  if (nesting_level >= nested_funcs_size)
	    {
	      struct nest_funcinfo *tmp;

	      nested_funcs_size *= 2;
	      tmp = (struct nest_funcinfo *)
		bfd_realloc (nested_funcs,
			     nested_funcs_size * sizeof (*nested_funcs));
	      if (tmp == NULL)
		goto fail;
	      nested_funcs = tmp;
	    }
	  nested_funcs[nesting_level].func = 0;
	}
    }

  free (nested_funcs);
  return TRUE;

 fail:
  free (nested_funcs);
  return FALSE;
}","static bfd_boolean
scan_unit_for_symbols (struct comp_unit *VAR_0)
{
  bfd *VAR_1 = VAR_0->abfd;
  bfd_byte *VAR_2 = VAR_0->first_child_die_ptr;
  bfd_byte *VAR_3 = VAR_0->stash->info_ptr_end;
  int VAR_4 = 0;
  struct nest_funcinfo {
    struct funcinfo *func;
  } *VAR_5;
  int VAR_6;

  /* COMMENT_0 */
                                              
  VAR_6 = 32;
  VAR_5 = (struct nest_funcinfo *)
    bfd_malloc (VAR_6 * sizeof (*VAR_5));
  if (VAR_5 == NULL)
    return FALSE;
  VAR_5[VAR_4].func = 0;

  while (VAR_4 >= 0)
    {
      unsigned int VAR_7, VAR_8, VAR_9;
      struct abbrev_info *VAR_10;
      struct attribute VAR_11;
      struct funcinfo *VAR_12;
      struct varinfo *VAR_13;
      bfd_vma VAR_14 = 0;
      bfd_vma VAR_15 = 0;
      bfd_boolean VAR_16 = FALSE;

      /* COMMENT_2 */
      if (VAR_2 >= VAR_3)
	goto fail;

      VAR_7 = _bfd_safe_read_leb128 (VAR_1, VAR_2, &VAR_8,
					     FALSE, VAR_3);
      VAR_2 += VAR_8;

      if (! VAR_7)
	{
	  VAR_4--;
	  continue;
	}

      VAR_10 = lookup_abbrev (VAR_7, VAR_0->abbrevs);
      if (! VAR_10)
	{
	  static unsigned int VAR_17 = -1U;

	  /* COMMENT_3 */
	  if (VAR_7 != VAR_17)
	    {
	      _bfd_error_handler
		(_(""Dwarf Error: Could not find abbrev number %u.""),
		 VAR_7);
	      VAR_17 = VAR_7;
	    }
	  bfd_set_error (VAR_18);
	  goto fail;
	}

      VAR_13 = NULL;
      if (VAR_10->tag == VAR_19
	  || VAR_10->tag == VAR_20
	  || VAR_10->tag == VAR_21)
	{
	  bfd_size_type VAR_22 = sizeof (struct funcinfo);
	  VAR_12 = (struct funcinfo *) bfd_zalloc (VAR_1, VAR_22);
	  if (VAR_12 == NULL)
	    goto fail;
	  VAR_12->tag = VAR_10->tag;
	  VAR_12->prev_func = VAR_0->function_table;
	  VAR_0->function_table = VAR_12;
	  VAR_0->number_of_functions++;
	  BFD_ASSERT (!VAR_0->cached);

	  if (VAR_12->tag == VAR_21)
	    for (VAR_9 = VAR_4; VAR_9-- != 0; )
	      if (VAR_5[VAR_9].func)
		{
		  VAR_12->caller_func = VAR_5[VAR_9].func;
		  break;
		}
	  VAR_5[VAR_4].func = VAR_12;
	}
      else
	{
	  VAR_12 = NULL;
	  if (VAR_10->tag == VAR_23)
	    {
	      bfd_size_type VAR_22 = sizeof (struct varinfo);
	      VAR_13 = (struct varinfo *) bfd_zalloc (VAR_1, VAR_22);
	      if (VAR_13 == NULL)
		goto fail;
	      VAR_13->tag = VAR_10->tag;
	      VAR_13->stack = 1;
	      VAR_13->prev_var = VAR_0->variable_table;
	      VAR_0->variable_table = VAR_13;
	      /* COMMENT_4 */
                                                    
	    }

	  /* COMMENT_6 */
	  VAR_5[VAR_4].func = 0;
	}

      for (VAR_9 = 0; VAR_9 < VAR_10->num_attrs; ++VAR_9)
	{
	  VAR_2 = read_attribute (&VAR_11, &VAR_10->attrs[VAR_9],
				     VAR_0, VAR_2, VAR_3);
	  if (VAR_2 == NULL)
	    goto fail;

	  if (VAR_12)
	    {
	      switch (VAR_11.name)
		{
		case VAR_24:
		  VAR_12->caller_file = concat_filename (VAR_0->line_table,
						       VAR_11.u.val);
		  break;

		case VAR_25:
		  VAR_12->caller_line = VAR_11.u.val;
		  break;

		case VAR_26:
		case VAR_27:
		  if (!find_abstract_instance_name (VAR_0, VAR_2, &VAR_11,
						    &VAR_12->name,
						    &VAR_12->is_linkage))
		    goto fail;
		  break;

		case VAR_28:
		  /* COMMENT_7 */
                           
		  if (VAR_12->name == NULL && is_str_attr (VAR_11.form))
		    {
		      VAR_12->name = VAR_11.u.str;
		      if (non_mangled (VAR_0->lang))
			VAR_12->is_linkage = TRUE;
		    }
		  break;

		case VAR_29:
		case VAR_30:
		  /* COMMENT_9 */
                                                  
		  if (is_str_attr (VAR_11.form))
		    {
		      VAR_12->name = VAR_11.u.str;
		      VAR_12->is_linkage = TRUE;
		    }
		  break;

		case VAR_31:
		  VAR_14 = VAR_11.u.val;
		  break;

		case VAR_32:
		  VAR_15 = VAR_11.u.val;
		  VAR_16 = VAR_11.form != VAR_33;
		  break;

		case VAR_34:
		  if (!read_rangelist (VAR_0, &VAR_12->arange, VAR_11.u.val))
		    goto fail;
		  break;

		case VAR_35:
		  VAR_12->file = concat_filename (VAR_0->line_table,
						VAR_11.u.val);
		  break;

		case VAR_36:
		  VAR_12->line = VAR_11.u.val;
		  break;

		default:
		  break;
		}
	    }
	  else if (VAR_13)
	    {
	      switch (VAR_11.name)
		{
		case VAR_28:
		  if (is_str_attr (VAR_11.form))
		    VAR_13->name = VAR_11.u.str;
		  break;

		case VAR_35:
		  VAR_13->file = concat_filename (VAR_0->line_table,
					       VAR_11.u.val);
		  break;

		case VAR_36:
		  VAR_13->line = VAR_11.u.val;
		  break;

		case VAR_37:
		  if (VAR_11.u.val != 0)
		    VAR_13->stack = 0;
		  break;

		case VAR_38:
		  switch (VAR_11.form)
		    {
		    case VAR_39:
		    case VAR_40:
		    case VAR_41:
		    case VAR_42:
		    case VAR_43:
		      if (VAR_11.u.blk->data != NULL
			  && *VAR_11.u.blk->data == VAR_44)
			{
			  VAR_13->stack = 0;

			  /* COMMENT_11 */
                                                        
                                  
			  /* COMMENT_14 */
                                                    
                                           
			  if (VAR_11.u.blk->size == VAR_0->addr_size + 1U)
			    VAR_13->addr = bfd_get (VAR_0->addr_size * 8,
						 VAR_0->abfd,
						 VAR_11.u.blk->data + 1);
			}
		      break;

		    default:
		      break;
		    }
		  break;

		default:
		  break;
		}
	    }
	}

      if (VAR_16)
	VAR_15 += VAR_14;

      if (VAR_12 && VAR_15 != 0)
	{
	  if (!arange_add (VAR_0, &VAR_12->arange, VAR_14, VAR_15))
	    goto fail;
	}

      if (VAR_10->has_children)
	{
	  VAR_4++;

	  if (VAR_4 >= VAR_6)
	    {
	      struct nest_funcinfo *VAR_45;

	      VAR_6 *= 2;
	      VAR_45 = (struct nest_funcinfo *)
		bfd_realloc (VAR_5,
			     VAR_6 * sizeof (*VAR_5));
	      if (VAR_45 == NULL)
		goto fail;
	      VAR_5 = VAR_45;
	    }
	  VAR_5[VAR_4].func = 0;
	}
    }

  free (VAR_5);
  return TRUE;

 fail:
  free (VAR_5);
  return FALSE;
}",binutils-gdb/11855d8a1f11b102a702ab76e95b22082cccf2f8/dwarf2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -188,7 +188,8 @@
 	      switch (attr.name)
 		{
 		case DW_AT_name:
-		  var->name = attr.u.str;
+		  if (is_str_attr (attr.form))
+		    var->name = attr.u.str;
 		  break;
 
 		case DW_AT_decl_file:","{'deleted_lines': ['\t\t  var->name = attr.u.str;'], 'added_lines': ['\t\t  if (is_str_attr (attr.form))', '\t\t    var->name = attr.u.str;']}",True,"dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the DW_AT_name data type, which allows remote attackers to cause a denial of service (bfd_hash_hash NULL pointer dereference, or out-of-bounds access, and application crash) via a crafted ELF file, related to scan_unit_for_symbols and parse_comp_unit.",5.5,MEDIUM,1,valid,,5
CVE-2017-15022,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR22201, DW_AT_name with out of bounds reference

DW_AT_name ought to always have a string value.

	PR 22201
	* dwarf2.c (scan_unit_for_symbols): Ignore DW_AT_name unless it
	has string form.
	(parse_comp_unit): Likewise.
",11855d8a1f11b102a702ab76e95b22082cccf2f8,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=11855d8a1f11b102a702ab76e95b22082cccf2f8,bfd/dwarf2.c,parse_comp_unit,"static struct comp_unit *
parse_comp_unit (struct dwarf2_debug *stash,
bfd_vma unit_length,
bfd_byte *info_ptr_unit,
unsigned int offset_size)
{
struct comp_unit* unit;
unsigned int version;
bfd_uint64_t abbrev_offset = 0;
unsigned int addr_size = -1;
struct abbrev_info** abbrevs;
unsigned int abbrev_number, bytes_read, i;
struct abbrev_info *abbrev;
struct attribute attr;
bfd_byte *info_ptr = stash->info_ptr;
bfd_byte *end_ptr = info_ptr + unit_length;
bfd_size_type amt;
bfd_vma low_pc = 0;
bfd_vma high_pc = 0;
bfd *abfd = stash->bfd_ptr;
bfd_boolean high_pc_relative = FALSE;
enum dwarf_unit_type unit_type;
version = read_2_bytes (abfd, info_ptr, end_ptr);
info_ptr += 2;
if (version < 2 || version > 5)
{
if (version)
{
_bfd_error_handler
(_(""Dwarf Error: found dwarf version '%u', this reader""
"" only handles version 2, 3, 4 and 5 information.""), version);
bfd_set_error (bfd_error_bad_value);
}
return NULL;
}
if (version < 5)
unit_type = DW_UT_compile;
else
{
unit_type = read_1_byte (abfd, info_ptr, end_ptr);
info_ptr += 1;
addr_size = read_1_byte (abfd, info_ptr, end_ptr);
info_ptr += 1;
}
BFD_ASSERT (offset_size == 4 || offset_size == 8);
if (offset_size == 4)
abbrev_offset = read_4_bytes (abfd, info_ptr, end_ptr);
else
abbrev_offset = read_8_bytes (abfd, info_ptr, end_ptr);
info_ptr += offset_size;
if (version < 5)
{
addr_size = read_1_byte (abfd, info_ptr, end_ptr);
info_ptr += 1;
}
if (unit_type == DW_UT_type)
{
info_ptr += 8;
info_ptr += offset_size;
}
if (addr_size > sizeof (bfd_vma))
{
_bfd_error_handler
(_(""Dwarf Error: found address size '%u', this reader""
"" can not handle sizes greater than '%u'.""),
addr_size,
(unsigned int) sizeof (bfd_vma));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
if (addr_size != 2 && addr_size != 4 && addr_size != 8)
{
_bfd_error_handler
(""Dwarf Error: found address size '%u', this reader""
"" can only handle address sizes '2', '4' and '8'."", addr_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
abbrevs = read_abbrevs (abfd, abbrev_offset, stash);
if (! abbrevs)
return NULL;
abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,
FALSE, end_ptr);
info_ptr += bytes_read;
if (! abbrev_number)
{
return NULL;
}
abbrev = lookup_abbrev (abbrev_number, abbrevs);
if (! abbrev)
{
_bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""),
abbrev_number);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
amt = sizeof (struct comp_unit);
unit = (struct comp_unit *) bfd_zalloc (abfd, amt);
if (unit == NULL)
return NULL;
unit->abfd = abfd;
unit->version = version;
unit->addr_size = addr_size;
unit->offset_size = offset_size;
unit->abbrevs = abbrevs;
unit->end_ptr = end_ptr;
unit->stash = stash;
unit->info_ptr_unit = info_ptr_unit;
unit->sec_info_ptr = stash->sec_info_ptr;
for (i = 0; i < abbrev->num_attrs; ++i)
{
info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, end_ptr);
if (info_ptr == NULL)
return NULL;
switch (attr.name)
{
case DW_AT_stmt_list:
unit->stmtlist = 1;
unit->line_offset = attr.u.val;
break;
case DW_AT_name:
unit->name = attr.u.str;
break;
case DW_AT_low_pc:
low_pc = attr.u.val;
if (abbrev->tag == DW_TAG_compile_unit)
unit->base_address = low_pc;
break;
case DW_AT_high_pc:
high_pc = attr.u.val;
high_pc_relative = attr.form != DW_FORM_addr;
break;
case DW_AT_ranges:
if (!read_rangelist (unit, &unit->arange, attr.u.val))
return NULL;
break;
case DW_AT_comp_dir:
{
char *comp_dir = attr.u.str;
if (! is_str_attr (attr.form))
{
_bfd_error_handler
(_(""Dwarf Error: DW_AT_comp_dir attribute encountered with a non-string form.""));
comp_dir = NULL;
}
if (comp_dir)
{
char *cp = strchr (comp_dir, ':');
if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
comp_dir = cp + 1;
}
unit->comp_dir = comp_dir;
break;
}
case DW_AT_language:
unit->lang = attr.u.val;
break;
default:
break;
}
}
if (high_pc_relative)
high_pc += low_pc;
if (high_pc != 0)
{
if (!arange_add (unit, &unit->arange, low_pc, high_pc))
return NULL;
}
unit->first_child_die_ptr = info_ptr;
return unit;
}","static struct comp_unit *
parse_comp_unit (struct dwarf2_debug *VAR_0,
bfd_vma VAR_1,
bfd_byte *VAR_2,
unsigned int VAR_3)
{
struct comp_unit* VAR_4;
unsigned int VAR_5;
bfd_uint64_t VAR_6 = 0;
unsigned int VAR_7 = -1;
struct abbrev_info** VAR_8;
unsigned int VAR_9, VAR_10, VAR_11;
struct abbrev_info *VAR_12;
struct attribute VAR_13;
bfd_byte *VAR_14 = VAR_0->info_ptr;
bfd_byte *VAR_15 = VAR_14 + VAR_1;
bfd_size_type VAR_16;
bfd_vma VAR_17 = 0;
bfd_vma VAR_18 = 0;
bfd *VAR_19 = VAR_0->bfd_ptr;
bfd_boolean VAR_20 = FALSE;
enum dwarf_unit_type VAR_21;
VAR_5 = read_2_bytes (VAR_19, VAR_14, VAR_15);
VAR_14 += 2;
if (VAR_5 < 2 || VAR_5 > 5)
{
if (VAR_5)
{
_bfd_error_handler
(_(""Dwarf Error: found dwarf version '%u', this reader""
"" only handles version 2, 3, 4 and 5 information.""), VAR_5);
bfd_set_error (VAR_22);
}
return NULL;
}
if (VAR_5 < 5)
VAR_21 = VAR_23;
else
{
VAR_21 = read_1_byte (VAR_19, VAR_14, VAR_15);
VAR_14 += 1;
VAR_7 = read_1_byte (VAR_19, VAR_14, VAR_15);
VAR_14 += 1;
}
BFD_ASSERT (VAR_3 == 4 || VAR_3 == 8);
if (VAR_3 == 4)
VAR_6 = read_4_bytes (VAR_19, VAR_14, VAR_15);
else
VAR_6 = read_8_bytes (VAR_19, VAR_14, VAR_15);
VAR_14 += VAR_3;
if (VAR_5 < 5)
{
VAR_7 = read_1_byte (VAR_19, VAR_14, VAR_15);
VAR_14 += 1;
}
if (VAR_21 == VAR_24)
{
VAR_14 += 8;
VAR_14 += VAR_3;
}
if (VAR_7 > sizeof (bfd_vma))
{
_bfd_error_handler
(_(""Dwarf Error: found address size '%u', this reader""
"" can not handle sizes greater than '%u'.""),
VAR_7,
(unsigned int) sizeof (bfd_vma));
bfd_set_error (VAR_22);
return NULL;
}
if (VAR_7 != 2 && VAR_7 != 4 && VAR_7 != 8)
{
_bfd_error_handler
(""Dwarf Error: found address size '%u', this reader""
"" can only handle address sizes '2', '4' and '8'."", VAR_7);
bfd_set_error (VAR_22);
return NULL;
}
VAR_8 = read_abbrevs (VAR_19, VAR_6, VAR_0);
if (! VAR_8)
return NULL;
VAR_9 = _bfd_safe_read_leb128 (VAR_19, VAR_14, &VAR_10,
FALSE, VAR_15);
VAR_14 += VAR_10;
if (! VAR_9)
{
return NULL;
}
VAR_12 = lookup_abbrev (VAR_9, VAR_8);
if (! VAR_12)
{
_bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""),
VAR_9);
bfd_set_error (VAR_22);
return NULL;
}
VAR_16 = sizeof (struct comp_unit);
VAR_4 = (struct comp_unit *) bfd_zalloc (VAR_19, VAR_16);
if (VAR_4 == NULL)
return NULL;
VAR_4->abfd = VAR_19;
VAR_4->version = VAR_5;
VAR_4->addr_size = VAR_7;
VAR_4->offset_size = VAR_3;
VAR_4->abbrevs = VAR_8;
VAR_4->end_ptr = VAR_15;
VAR_4->stash = VAR_0;
VAR_4->info_ptr_unit = VAR_2;
VAR_4->sec_info_ptr = VAR_0->sec_info_ptr;
for (VAR_11 = 0; VAR_11 < VAR_12->num_attrs; ++VAR_11)
{
VAR_14 = read_attribute (&VAR_13, &VAR_12->attrs[VAR_11], VAR_4, VAR_14, VAR_15);
if (VAR_14 == NULL)
return NULL;
switch (VAR_13.name)
{
case VAR_25:
VAR_4->stmtlist = 1;
VAR_4->line_offset = VAR_13.u.val;
break;
case VAR_26:
VAR_4->name = VAR_13.u.str;
break;
case VAR_27:
VAR_17 = VAR_13.u.val;
if (VAR_12->tag == VAR_28)
VAR_4->base_address = VAR_17;
break;
case VAR_29:
VAR_18 = VAR_13.u.val;
VAR_20 = VAR_13.form != VAR_30;
break;
case VAR_31:
if (!read_rangelist (VAR_4, &VAR_4->arange, VAR_13.u.val))
return NULL;
break;
case VAR_32:
{
char *VAR_33 = VAR_13.u.str;
if (! is_str_attr (VAR_13.form))
{
_bfd_error_handler
(_(""Dwarf Error: DW_AT_comp_dir attribute encountered with a non-string form.""));
VAR_33 = NULL;
}
if (VAR_33)
{
char *VAR_34 = strchr (VAR_33, ':');
if (VAR_34 && VAR_34 != VAR_33 && VAR_34[-1] == '.' && VAR_34[1] == '/')
VAR_33 = VAR_34 + 1;
}
VAR_4->comp_dir = VAR_33;
break;
}
case VAR_35:
VAR_4->lang = VAR_13.u.val;
break;
default:
break;
}
}
if (VAR_20)
VAR_18 += VAR_17;
if (VAR_18 != 0)
{
if (!arange_add (VAR_4, &VAR_4->arange, VAR_17, VAR_18))
return NULL;
}
VAR_4->first_child_die_ptr = VAR_14;
return VAR_4;
}",binutils-gdb/11855d8a1f11b102a702ab76e95b22082cccf2f8/dwarf2.c/vul/before/1.json,"static struct comp_unit *
parse_comp_unit (struct dwarf2_debug *stash,
		 bfd_vma unit_length,
		 bfd_byte *info_ptr_unit,
		 unsigned int offset_size)
{
  struct comp_unit* unit;
  unsigned int version;
  bfd_uint64_t abbrev_offset = 0;
  /* Initialize it just to avoid a GCC false warning.  */
  unsigned int addr_size = -1;
  struct abbrev_info** abbrevs;
  unsigned int abbrev_number, bytes_read, i;
  struct abbrev_info *abbrev;
  struct attribute attr;
  bfd_byte *info_ptr = stash->info_ptr;
  bfd_byte *end_ptr = info_ptr + unit_length;
  bfd_size_type amt;
  bfd_vma low_pc = 0;
  bfd_vma high_pc = 0;
  bfd *abfd = stash->bfd_ptr;
  bfd_boolean high_pc_relative = FALSE;
  enum dwarf_unit_type unit_type;

  version = read_2_bytes (abfd, info_ptr, end_ptr);
  info_ptr += 2;
  if (version < 2 || version > 5)
    {
      /* PR 19872: A version number of 0 probably means that there is padding
	 at the end of the .debug_info section.  Gold puts it there when
	 performing an incremental link, for example.  So do not generate
	 an error, just return a NULL.  */
      if (version)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: found dwarf version '%u', this reader""
	       "" only handles version 2, 3, 4 and 5 information.""), version);
	  bfd_set_error (bfd_error_bad_value);
	}
      return NULL;
    }

  if (version < 5)
    unit_type = DW_UT_compile;
  else
    {
      unit_type = read_1_byte (abfd, info_ptr, end_ptr);
      info_ptr += 1;

      addr_size = read_1_byte (abfd, info_ptr, end_ptr);
      info_ptr += 1;
    }

  BFD_ASSERT (offset_size == 4 || offset_size == 8);
  if (offset_size == 4)
    abbrev_offset = read_4_bytes (abfd, info_ptr, end_ptr);
  else
    abbrev_offset = read_8_bytes (abfd, info_ptr, end_ptr);
  info_ptr += offset_size;

  if (version < 5)
    {
      addr_size = read_1_byte (abfd, info_ptr, end_ptr);
      info_ptr += 1;
    }

  if (unit_type == DW_UT_type)
    {
      /* Skip type signature.  */
      info_ptr += 8;

      /* Skip type offset.  */
      info_ptr += offset_size;
    }

  if (addr_size > sizeof (bfd_vma))
    {
      _bfd_error_handler
	/* xgettext: c-format */
	(_(""Dwarf Error: found address size '%u', this reader""
	   "" can not handle sizes greater than '%u'.""),
	 addr_size,
	 (unsigned int) sizeof (bfd_vma));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  if (addr_size != 2 && addr_size != 4 && addr_size != 8)
    {
      _bfd_error_handler
	(""Dwarf Error: found address size '%u', this reader""
	 "" can only handle address sizes '2', '4' and '8'."", addr_size);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  /* Read the abbrevs for this compilation unit into a table.  */
  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);
  if (! abbrevs)
    return NULL;

  abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,
					 FALSE, end_ptr);
  info_ptr += bytes_read;
  if (! abbrev_number)
    {
      /* PR 19872: An abbrev number of 0 probably means that there is padding
	 at the end of the .debug_abbrev section.  Gold puts it there when
	 performing an incremental link, for example.  So do not generate
	 an error, just return a NULL.  */
      return NULL;
    }

  abbrev = lookup_abbrev (abbrev_number, abbrevs);
  if (! abbrev)
    {
      _bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""),
			  abbrev_number);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  amt = sizeof (struct comp_unit);
  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);
  if (unit == NULL)
    return NULL;
  unit->abfd = abfd;
  unit->version = version;
  unit->addr_size = addr_size;
  unit->offset_size = offset_size;
  unit->abbrevs = abbrevs;
  unit->end_ptr = end_ptr;
  unit->stash = stash;
  unit->info_ptr_unit = info_ptr_unit;
  unit->sec_info_ptr = stash->sec_info_ptr;

  for (i = 0; i < abbrev->num_attrs; ++i)
    {
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, end_ptr);
      if (info_ptr == NULL)
	return NULL;

      /* Store the data if it is of an attribute we want to keep in a
	 partial symbol table.  */
      switch (attr.name)
	{
	case DW_AT_stmt_list:
	  unit->stmtlist = 1;
	  unit->line_offset = attr.u.val;
	  break;

	case DW_AT_name:
	  if (is_str_attr (attr.form))
	    unit->name = attr.u.str;
	  break;

	case DW_AT_low_pc:
	  low_pc = attr.u.val;
	  /* If the compilation unit DIE has a DW_AT_low_pc attribute,
	     this is the base address to use when reading location
	     lists or range lists.  */
	  if (abbrev->tag == DW_TAG_compile_unit)
	    unit->base_address = low_pc;
	  break;

	case DW_AT_high_pc:
	  high_pc = attr.u.val;
	  high_pc_relative = attr.form != DW_FORM_addr;
	  break;

	case DW_AT_ranges:
	  if (!read_rangelist (unit, &unit->arange, attr.u.val))
	    return NULL;
	  break;

	case DW_AT_comp_dir:
	  {
	    char *comp_dir = attr.u.str;

	    /* PR 17512: file: 1fe726be.  */
	    if (! is_str_attr (attr.form))
	      {
		_bfd_error_handler
		  (_(""Dwarf Error: DW_AT_comp_dir attribute encountered with a non-string form.""));
		comp_dir = NULL;
	      }

	    if (comp_dir)
	      {
		/* Irix 6.2 native cc prepends <machine>.: to the compilation
		   directory, get rid of it.  */
		char *cp = strchr (comp_dir, ':');

		if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
		  comp_dir = cp + 1;
	      }
	    unit->comp_dir = comp_dir;
	    break;
	  }

	case DW_AT_language:
	  unit->lang = attr.u.val;
	  break;

	default:
	  break;
	}
    }
  if (high_pc_relative)
    high_pc += low_pc;
  if (high_pc != 0)
    {
      if (!arange_add (unit, &unit->arange, low_pc, high_pc))
	return NULL;
    }

  unit->first_child_die_ptr = info_ptr;
  return unit;
}","static struct comp_unit *
parse_comp_unit (struct dwarf2_debug *VAR_0,
		 bfd_vma VAR_1,
		 bfd_byte *VAR_2,
		 unsigned int VAR_3)
{
  struct comp_unit* VAR_4;
  unsigned int VAR_5;
  bfd_uint64_t VAR_6 = 0;
  /* COMMENT_0 */
  unsigned int VAR_7 = -1;
  struct abbrev_info** VAR_8;
  unsigned int VAR_9, VAR_10, VAR_11;
  struct abbrev_info *VAR_12;
  struct attribute VAR_13;
  bfd_byte *VAR_14 = VAR_0->info_ptr;
  bfd_byte *VAR_15 = VAR_14 + VAR_1;
  bfd_size_type VAR_16;
  bfd_vma VAR_17 = 0;
  bfd_vma VAR_18 = 0;
  bfd *VAR_19 = VAR_0->bfd_ptr;
  bfd_boolean VAR_20 = FALSE;
  enum dwarf_unit_type VAR_21;

  VAR_5 = read_2_bytes (VAR_19, VAR_14, VAR_15);
  VAR_14 += 2;
  if (VAR_5 < 2 || VAR_5 > 5)
    {
      /* COMMENT_1 */
                                                                 
                                                                  
                                   
      if (VAR_5)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: found dwarf version '%u', this reader""
	       "" only handles version 2, 3, 4 and 5 information.""), VAR_5);
	  bfd_set_error (VAR_22);
	}
      return NULL;
    }

  if (VAR_5 < 5)
    VAR_21 = VAR_23;
  else
    {
      VAR_21 = read_1_byte (VAR_19, VAR_14, VAR_15);
      VAR_14 += 1;

      VAR_7 = read_1_byte (VAR_19, VAR_14, VAR_15);
      VAR_14 += 1;
    }

  BFD_ASSERT (VAR_3 == 4 || VAR_3 == 8);
  if (VAR_3 == 4)
    VAR_6 = read_4_bytes (VAR_19, VAR_14, VAR_15);
  else
    VAR_6 = read_8_bytes (VAR_19, VAR_14, VAR_15);
  VAR_14 += VAR_3;

  if (VAR_5 < 5)
    {
      VAR_7 = read_1_byte (VAR_19, VAR_14, VAR_15);
      VAR_14 += 1;
    }

  if (VAR_21 == VAR_24)
    {
      /* COMMENT_5 */
      VAR_14 += 8;

      /* COMMENT_6 */
      VAR_14 += VAR_3;
    }

  if (VAR_7 > sizeof (bfd_vma))
    {
      _bfd_error_handler
	/* COMMENT_7 */
	(_(""Dwarf Error: found address size '%u', this reader""
	   "" can not handle sizes greater than '%u'.""),
	 VAR_7,
	 (unsigned int) sizeof (bfd_vma));
      bfd_set_error (VAR_22);
      return NULL;
    }

  if (VAR_7 != 2 && VAR_7 != 4 && VAR_7 != 8)
    {
      _bfd_error_handler
	(""Dwarf Error: found address size '%u', this reader""
	 "" can only handle address sizes '2', '4' and '8'."", VAR_7);
      bfd_set_error (VAR_22);
      return NULL;
    }

  /* COMMENT_8 */
  VAR_8 = read_abbrevs (VAR_19, VAR_6, VAR_0);
  if (! VAR_8)
    return NULL;

  VAR_9 = _bfd_safe_read_leb128 (VAR_19, VAR_14, &VAR_10,
					 FALSE, VAR_15);
  VAR_14 += VAR_10;
  if (! VAR_9)
    {
      /* COMMENT_9 */
                                                                   
                                                                  
                                   
      return NULL;
    }

  VAR_12 = lookup_abbrev (VAR_9, VAR_8);
  if (! VAR_12)
    {
      _bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""),
			  VAR_9);
      bfd_set_error (VAR_22);
      return NULL;
    }

  VAR_16 = sizeof (struct comp_unit);
  VAR_4 = (struct comp_unit *) bfd_zalloc (VAR_19, VAR_16);
  if (VAR_4 == NULL)
    return NULL;
  VAR_4->abfd = VAR_19;
  VAR_4->version = VAR_5;
  VAR_4->addr_size = VAR_7;
  VAR_4->offset_size = VAR_3;
  VAR_4->abbrevs = VAR_8;
  VAR_4->end_ptr = VAR_15;
  VAR_4->stash = VAR_0;
  VAR_4->info_ptr_unit = VAR_2;
  VAR_4->sec_info_ptr = VAR_0->sec_info_ptr;

  for (VAR_11 = 0; VAR_11 < VAR_12->num_attrs; ++VAR_11)
    {
      VAR_14 = read_attribute (&VAR_13, &VAR_12->attrs[VAR_11], VAR_4, VAR_14, VAR_15);
      if (VAR_14 == NULL)
	return NULL;

      /* COMMENT_13 */
                           
      switch (VAR_13.name)
	{
	case VAR_25:
	  VAR_4->stmtlist = 1;
	  VAR_4->line_offset = VAR_13.u.val;
	  break;

	case VAR_26:
	  if (is_str_attr (VAR_13.form))
	    VAR_4->name = VAR_13.u.str;
	  break;

	case VAR_27:
	  VAR_17 = VAR_13.u.val;
	  /* COMMENT_15 */
                                                           
                               
	  if (VAR_12->tag == VAR_28)
	    VAR_4->base_address = VAR_17;
	  break;

	case VAR_29:
	  VAR_18 = VAR_13.u.val;
	  VAR_20 = VAR_13.form != VAR_30;
	  break;

	case VAR_31:
	  if (!read_rangelist (VAR_4, &VAR_4->arange, VAR_13.u.val))
	    return NULL;
	  break;

	case VAR_32:
	  {
	    char *VAR_33 = VAR_13.u.str;

	    /* COMMENT_18 */
	    if (! is_str_attr (VAR_13.form))
	      {
		_bfd_error_handler
		  (_(""Dwarf Error: DW_AT_comp_dir attribute encountered with a non-string form.""));
		VAR_33 = NULL;
	      }

	    if (VAR_33)
	      {
		/* COMMENT_19 */
                                  
		char *VAR_34 = strchr (VAR_33, ':');

		if (VAR_34 && VAR_34 != VAR_33 && VAR_34[-1] == '.' && VAR_34[1] == '/')
		  VAR_33 = VAR_34 + 1;
	      }
	    VAR_4->comp_dir = VAR_33;
	    break;
	  }

	case VAR_35:
	  VAR_4->lang = VAR_13.u.val;
	  break;

	default:
	  break;
	}
    }
  if (VAR_20)
    VAR_18 += VAR_17;
  if (VAR_18 != 0)
    {
      if (!arange_add (VAR_4, &VAR_4->arange, VAR_17, VAR_18))
	return NULL;
    }

  VAR_4->first_child_die_ptr = VAR_14;
  return VAR_4;
}",binutils-gdb/11855d8a1f11b102a702ab76e95b22082cccf2f8/dwarf2.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -150,7 +150,8 @@
 	  break;
 
 	case DW_AT_name:
-	  unit->name = attr.u.str;
+	  if (is_str_attr (attr.form))
+	    unit->name = attr.u.str;
 	  break;
 
 	case DW_AT_low_pc:","{'deleted_lines': ['\t  unit->name = attr.u.str;'], 'added_lines': ['\t  if (is_str_attr (attr.form))', '\t    unit->name = attr.u.str;']}",True,"dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the DW_AT_name data type, which allows remote attackers to cause a denial of service (bfd_hash_hash NULL pointer dereference, or out-of-bounds access, and application crash) via a crafted ELF file, related to scan_unit_for_symbols and parse_comp_unit.",5.5,MEDIUM,1,valid,,5
CVE-2017-15025,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR22186, divide-by-zero in decode_line_info

	PR 22186
	* dwarf2.c (decode_line_info): Fail on lh.line_range of zero
	rather than dividing by zero.
",d8010d3e75ec7194a4703774090b27486b742d48,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=d8010d3e75ec7194a4703774090b27486b742d48,bfd/dwarf2.c,decode_line_info,"static struct line_info_table*
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
{
bfd *abfd = unit->abfd;
struct line_info_table* table;
bfd_byte *line_ptr;
bfd_byte *line_end;
struct line_head lh;
unsigned int i, bytes_read, offset_size;
char *cur_file, *cur_dir;
unsigned char op_code, extended_op, adj_opcode;
unsigned int exop_len;
bfd_size_type amt;
if (! read_section (abfd, &stash->debug_sections[debug_line],
stash->syms, unit->line_offset,
&stash->dwarf_line_buffer, &stash->dwarf_line_size))
return NULL;
amt = sizeof (struct line_info_table);
table = (struct line_info_table *) bfd_alloc (abfd, amt);
if (table == NULL)
return NULL;
table->abfd = abfd;
table->comp_dir = unit->comp_dir;
table->num_files = 0;
table->files = NULL;
table->num_dirs = 0;
table->dirs = NULL;
table->num_sequences = 0;
table->sequences = NULL;
table->lcl_head = NULL;
if (stash->dwarf_line_size < 16)
{
_bfd_error_handler
(_(""Dwarf Error: Line info section is too small (%Ld)""),
stash->dwarf_line_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_ptr = stash->dwarf_line_buffer + unit->line_offset;
line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;
lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
line_ptr += 4;
offset_size = 4;
if (lh.total_length == 0xffffffff)
{
lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
line_ptr += 8;
offset_size = 8;
}
else if (lh.total_length == 0 && unit->addr_size == 8)
{
lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
line_ptr += 4;
offset_size = 8;
}
if (lh.total_length > (size_t) (line_end - line_ptr))
{
_bfd_error_handler
(_(""Dwarf Error: Line info data is bigger (%#Lx)""
"" than the space remaining in the section (%#lx)""),
lh.total_length, (unsigned long) (line_end - line_ptr));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_end = line_ptr + lh.total_length;
lh.version = read_2_bytes (abfd, line_ptr, line_end);
if (lh.version < 2 || lh.version > 5)
{
_bfd_error_handler
(_(""Dwarf Error: Unhandled .debug_line version %d.""), lh.version);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_ptr += 2;
if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
>= line_end)
{
_bfd_error_handler
(_(""Dwarf Error: Ran out of room reading prologue""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
if (lh.version >= 5)
{
unsigned int segment_selector_size;
read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (segment_selector_size != 0)
{
_bfd_error_handler
(_(""Dwarf Error: Line info unsupported segment selector size %u.""),
segment_selector_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
}
if (offset_size == 4)
lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
else
lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
line_ptr += offset_size;
lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (lh.version >= 4)
{
lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
}
else
lh.maximum_ops_per_insn = 1;
if (lh.maximum_ops_per_insn == 0)
{
_bfd_error_handler
(_(""Dwarf Error: Invalid maximum operations per instruction.""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.line_range = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (line_ptr + (lh.opcode_base - 1) >= line_end)
{
_bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
amt = lh.opcode_base * sizeof (unsigned char);
lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
lh.standard_opcode_lengths[0] = 1;
for (i = 1; i < lh.opcode_base; ++i)
{
lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
}
if (lh.version >= 5)
{
if (!read_formatted_entries (unit, &line_ptr, line_end, table,
line_info_add_include_dir_stub))
goto fail;
if (!read_formatted_entries (unit, &line_ptr, line_end, table,
line_info_add_file_name))
goto fail;
}
else
{
while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
{
line_ptr += bytes_read;
if (!line_info_add_include_dir (table, cur_dir))
goto fail;
}
line_ptr += bytes_read;
while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
{
unsigned int dir, xtime, size;
line_ptr += bytes_read;
dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
goto fail;
}
line_ptr += bytes_read;
}
while (line_ptr < line_end)
{
bfd_vma address = 0;
unsigned char op_index = 0;
char * filename = table->num_files ? concat_filename (table, 1) : NULL;
unsigned int line = 1;
unsigned int column = 0;
unsigned int discriminator = 0;
int is_stmt = lh.default_is_stmt;
int end_sequence = 0;
bfd_vma low_pc  = (bfd_vma) -1;
bfd_vma high_pc = 0;
while (! end_sequence)
{
op_code = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (op_code >= lh.opcode_base)
{
adj_opcode = op_code - lh.opcode_base;
if (lh.line_range == 0)
goto line_fail;
if (lh.maximum_ops_per_insn == 1)
address += (adj_opcode / lh.line_range
* lh.minimum_instruction_length);
else
{
address += ((op_index + adj_opcode / lh.line_range)
/ lh.maximum_ops_per_insn
* lh.minimum_instruction_length);
op_index = ((op_index + adj_opcode / lh.line_range)
% lh.maximum_ops_per_insn);
}
line += lh.line_base + (adj_opcode % lh.line_range);
if (!add_line_info (table, address, op_index, filename,
line, column, discriminator, 0))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
}
else switch (op_code)
{
case DW_LNS_extended_op:
exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
extended_op = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
switch (extended_op)
{
case DW_LNE_end_sequence:
end_sequence = 1;
if (!add_line_info (table, address, op_index, filename, line,
column, discriminator, end_sequence))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
if (!arange_add (unit, &unit->arange, low_pc, high_pc))
goto line_fail;
break;
case DW_LNE_set_address:
address = read_address (unit, line_ptr, line_end);
op_index = 0;
line_ptr += unit->addr_size;
break;
case DW_LNE_define_file:
cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
line_ptr += bytes_read;
if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
{
struct fileinfo *tmp;
amt = table->num_files + FILE_ALLOC_CHUNK;
amt *= sizeof (struct fileinfo);
tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
if (tmp == NULL)
goto line_fail;
table->files = tmp;
}
table->files[table->num_files].name = cur_file;
table->files[table->num_files].dir =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->files[table->num_files].time =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->files[table->num_files].size =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->num_files++;
break;
case DW_LNE_set_discriminator:
discriminator =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
break;
case DW_LNE_HP_source_file_correlation:
line_ptr += exop_len - 1;
break;
default:
_bfd_error_handler
(_(""Dwarf Error: mangled line number section.""));
bfd_set_error (bfd_error_bad_value);
line_fail:
if (filename != NULL)
free (filename);
goto fail;
}
break;
case DW_LNS_copy:
if (!add_line_info (table, address, op_index,
filename, line, column, discriminator, 0))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
break;
case DW_LNS_advance_pc:
if (lh.maximum_ops_per_insn == 1)
address += (lh.minimum_instruction_length
* _bfd_safe_read_leb128 (abfd, line_ptr,
&bytes_read,
FALSE, line_end));
else
{
bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
&bytes_read,
FALSE, line_end);
address = ((op_index + adjust) / lh.maximum_ops_per_insn
* lh.minimum_instruction_length);
op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
}
line_ptr += bytes_read;
break;
case DW_LNS_advance_line:
line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
TRUE, line_end);
line_ptr += bytes_read;
break;
case DW_LNS_set_file:
{
unsigned int file;
file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
if (filename)
free (filename);
filename = concat_filename (table, file);
break;
}
case DW_LNS_set_column:
column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
break;
case DW_LNS_negate_stmt:
is_stmt = (!is_stmt);
break;
case DW_LNS_set_basic_block:
break;
case DW_LNS_const_add_pc:
if (lh.maximum_ops_per_insn == 1)
address += (lh.minimum_instruction_length
* ((255 - lh.opcode_base) / lh.line_range));
else
{
bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
address += (lh.minimum_instruction_length
* ((op_index + adjust)
/ lh.maximum_ops_per_insn));
op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
}
break;
case DW_LNS_fixed_advance_pc:
address += read_2_bytes (abfd, line_ptr, line_end);
op_index = 0;
line_ptr += 2;
break;
default:
for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
{
(void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
}
break;
}
}
if (filename)
free (filename);
}
if (sort_line_sequences (table))
return table;
fail:
if (table->sequences != NULL)
free (table->sequences);
if (table->files != NULL)
free (table->files);
if (table->dirs != NULL)
free (table->dirs);
return NULL;
}","static struct line_info_table*
decode_line_info (struct comp_unit *VAR_0, struct dwarf2_debug *VAR_1)
{
bfd *VAR_2 = VAR_0->abfd;
struct line_info_table* VAR_3;
bfd_byte *VAR_4;
bfd_byte *VAR_5;
struct line_head VAR_6;
unsigned int VAR_7, VAR_8, VAR_9;
char *VAR_10, *VAR_11;
unsigned char VAR_12, VAR_13, VAR_14;
unsigned int VAR_15;
bfd_size_type VAR_16;
if (! read_section (VAR_2, &VAR_1->debug_sections[VAR_17],
VAR_1->syms, VAR_0->line_offset,
&VAR_1->dwarf_line_buffer, &VAR_1->dwarf_line_size))
return NULL;
VAR_16 = sizeof (struct line_info_table);
VAR_3 = (struct line_info_table *) bfd_alloc (VAR_2, VAR_16);
if (VAR_3 == NULL)
return NULL;
VAR_3->abfd = VAR_2;
VAR_3->comp_dir = VAR_0->comp_dir;
VAR_3->num_files = 0;
VAR_3->files = NULL;
VAR_3->num_dirs = 0;
VAR_3->dirs = NULL;
VAR_3->num_sequences = 0;
VAR_3->sequences = NULL;
VAR_3->lcl_head = NULL;
if (VAR_1->dwarf_line_size < 16)
{
_bfd_error_handler
(_(""Dwarf Error: Line info section is too small (%Ld)""),
VAR_1->dwarf_line_size);
bfd_set_error (VAR_18);
return NULL;
}
VAR_4 = VAR_1->dwarf_line_buffer + VAR_0->line_offset;
VAR_5 = VAR_1->dwarf_line_buffer + VAR_1->dwarf_line_size;
VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 4;
VAR_9 = 4;
if (VAR_6.total_length == 0xffffffff)
{
VAR_6.total_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 8;
VAR_9 = 8;
}
else if (VAR_6.total_length == 0 && VAR_0->addr_size == 8)
{
VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 4;
VAR_9 = 8;
}
if (VAR_6.total_length > (size_t) (VAR_5 - VAR_4))
{
_bfd_error_handler
(_(""Dwarf Error: Line info data is bigger (%#Lx)""
"" than the space remaining in the section (%#lx)""),
VAR_6.total_length, (unsigned long) (VAR_5 - VAR_4));
bfd_set_error (VAR_18);
return NULL;
}
VAR_5 = VAR_4 + VAR_6.total_length;
VAR_6.version = read_2_bytes (VAR_2, VAR_4, VAR_5);
if (VAR_6.version < 2 || VAR_6.version > 5)
{
_bfd_error_handler
(_(""Dwarf Error: Unhandled .debug_line version %d.""), VAR_6.version);
bfd_set_error (VAR_18);
return NULL;
}
VAR_4 += 2;
if (VAR_4 + VAR_9 + (VAR_6.version >= 5 ? 8 : (VAR_6.version >= 4 ? 6 : 5))
>= VAR_5)
{
_bfd_error_handler
(_(""Dwarf Error: Ran out of room reading prologue""));
bfd_set_error (VAR_18);
return NULL;
}
if (VAR_6.version >= 5)
{
unsigned int VAR_19;
read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_19 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_19 != 0)
{
_bfd_error_handler
(_(""Dwarf Error: Line info unsupported segment selector size %u.""),
VAR_19);
bfd_set_error (VAR_18);
return NULL;
}
}
if (VAR_9 == 4)
VAR_6.prologue_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
else
VAR_6.prologue_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += VAR_9;
VAR_6.minimum_instruction_length = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_6.version >= 4)
{
VAR_6.maximum_ops_per_insn = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
}
else
VAR_6.maximum_ops_per_insn = 1;
if (VAR_6.maximum_ops_per_insn == 0)
{
_bfd_error_handler
(_(""Dwarf Error: Invalid maximum operations per instruction.""));
bfd_set_error (VAR_18);
return NULL;
}
VAR_6.default_is_stmt = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.line_base = read_1_signed_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.line_range = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.opcode_base = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_4 + (VAR_6.opcode_base - 1) >= VAR_5)
{
_bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
bfd_set_error (VAR_18);
return NULL;
}
VAR_16 = VAR_6.opcode_base * sizeof (unsigned char);
VAR_6.standard_opcode_lengths = (unsigned char *) bfd_alloc (VAR_2, VAR_16);
VAR_6.standard_opcode_lengths[0] = 1;
for (VAR_7 = 1; VAR_7 < VAR_6.opcode_base; ++VAR_7)
{
VAR_6.standard_opcode_lengths[VAR_7] = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
}
if (VAR_6.version >= 5)
{
if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
VAR_20))
goto fail;
if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
VAR_21))
goto fail;
}
else
{
while ((VAR_11 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
{
VAR_4 += VAR_8;
if (!line_info_add_include_dir (VAR_3, VAR_11))
goto fail;
}
VAR_4 += VAR_8;
while ((VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
{
unsigned int VAR_22, VAR_23, VAR_24;
VAR_4 += VAR_8;
VAR_22 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_23 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_24 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
if (!VAR_21 (VAR_3, VAR_10, VAR_22, VAR_23, VAR_24))
goto fail;
}
VAR_4 += VAR_8;
}
while (VAR_4 < VAR_5)
{
bfd_vma VAR_25 = 0;
unsigned char VAR_26 = 0;
char * VAR_27 = VAR_3->num_files ? concat_filename (VAR_3, 1) : NULL;
unsigned int VAR_28 = 1;
unsigned int VAR_29 = 0;
unsigned int VAR_30 = 0;
int VAR_31 = VAR_6.default_is_stmt;
int VAR_32 = 0;
bfd_vma VAR_33  = (bfd_vma) -1;
bfd_vma VAR_34 = 0;
while (! VAR_32)
{
VAR_12 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_12 >= VAR_6.opcode_base)
{
VAR_14 = VAR_12 - VAR_6.opcode_base;
if (VAR_6.line_range == 0)
goto line_fail;
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_14 / VAR_6.line_range
* VAR_6.minimum_instruction_length);
else
{
VAR_25 += ((VAR_26 + VAR_14 / VAR_6.line_range)
/ VAR_6.maximum_ops_per_insn
* VAR_6.minimum_instruction_length);
VAR_26 = ((VAR_26 + VAR_14 / VAR_6.line_range)
% VAR_6.maximum_ops_per_insn);
}
VAR_28 += VAR_6.line_base + (VAR_14 % VAR_6.line_range);
if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27,
VAR_28, VAR_29, VAR_30, 0))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
}
else switch (VAR_12)
{
case VAR_35:
VAR_15 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_13 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
switch (VAR_13)
{
case VAR_36:
VAR_32 = 1;
if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27, VAR_28,
VAR_29, VAR_30, VAR_32))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
if (!arange_add (VAR_0, &VAR_0->arange, VAR_33, VAR_34))
goto line_fail;
break;
case VAR_37:
VAR_25 = read_address (VAR_0, VAR_4, VAR_5);
VAR_26 = 0;
VAR_4 += VAR_0->addr_size;
break;
case VAR_38:
VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8);
VAR_4 += VAR_8;
if ((VAR_3->num_files % VAR_39) == 0)
{
struct fileinfo *VAR_40;
VAR_16 = VAR_3->num_files + VAR_39;
VAR_16 *= sizeof (struct fileinfo);
VAR_40 = (struct fileinfo *) bfd_realloc (VAR_3->files, VAR_16);
if (VAR_40 == NULL)
goto line_fail;
VAR_3->files = VAR_40;
}
VAR_3->files[VAR_3->num_files].name = VAR_10;
VAR_3->files[VAR_3->num_files].dir =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->files[VAR_3->num_files].time =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->files[VAR_3->num_files].size =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->num_files++;
break;
case VAR_41:
VAR_30 =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_42:
VAR_4 += VAR_15 - 1;
break;
default:
_bfd_error_handler
(_(""Dwarf Error: mangled line number section.""));
bfd_set_error (VAR_18);
line_fail:
if (VAR_27 != NULL)
free (VAR_27);
goto fail;
}
break;
case VAR_43:
if (!add_line_info (VAR_3, VAR_25, VAR_26,
VAR_27, VAR_28, VAR_29, VAR_30, 0))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
break;
case VAR_44:
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_6.minimum_instruction_length
* _bfd_safe_read_leb128 (VAR_2, VAR_4,
&VAR_8,
FALSE, VAR_5));
else
{
bfd_vma VAR_45 = _bfd_safe_read_leb128 (VAR_2, VAR_4,
&VAR_8,
FALSE, VAR_5);
VAR_25 = ((VAR_26 + VAR_45) / VAR_6.maximum_ops_per_insn
* VAR_6.minimum_instruction_length);
VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
}
VAR_4 += VAR_8;
break;
case VAR_46:
VAR_28 += _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
TRUE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_47:
{
unsigned int VAR_48;
VAR_48 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
if (VAR_27)
free (VAR_27);
VAR_27 = concat_filename (VAR_3, VAR_48);
break;
}
case VAR_49:
VAR_29 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_50:
VAR_31 = (!VAR_31);
break;
case VAR_51:
break;
case VAR_52:
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_6.minimum_instruction_length
* ((255 - VAR_6.opcode_base) / VAR_6.line_range));
else
{
bfd_vma VAR_45 = ((255 - VAR_6.opcode_base) / VAR_6.line_range);
VAR_25 += (VAR_6.minimum_instruction_length
* ((VAR_26 + VAR_45)
/ VAR_6.maximum_ops_per_insn));
VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
}
break;
case VAR_53:
VAR_25 += read_2_bytes (VAR_2, VAR_4, VAR_5);
VAR_26 = 0;
VAR_4 += 2;
break;
default:
for (VAR_7 = 0; VAR_7 < VAR_6.standard_opcode_lengths[VAR_12]; VAR_7++)
{
(void) _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
}
break;
}
}
if (VAR_27)
free (VAR_27);
}
if (sort_line_sequences (VAR_3))
return VAR_3;
fail:
if (VAR_3->sequences != NULL)
free (VAR_3->sequences);
if (VAR_3->files != NULL)
free (VAR_3->files);
if (VAR_3->dirs != NULL)
free (VAR_3->dirs);
return NULL;
}",binutils-gdb/d8010d3e75ec7194a4703774090b27486b742d48/dwarf2.c/vul/before/0.json,"static struct line_info_table*
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
{
  bfd *abfd = unit->abfd;
  struct line_info_table* table;
  bfd_byte *line_ptr;
  bfd_byte *line_end;
  struct line_head lh;
  unsigned int i, bytes_read, offset_size;
  char *cur_file, *cur_dir;
  unsigned char op_code, extended_op, adj_opcode;
  unsigned int exop_len;
  bfd_size_type amt;

  if (! read_section (abfd, &stash->debug_sections[debug_line],
		      stash->syms, unit->line_offset,
		      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
    return NULL;

  amt = sizeof (struct line_info_table);
  table = (struct line_info_table *) bfd_alloc (abfd, amt);
  if (table == NULL)
    return NULL;
  table->abfd = abfd;
  table->comp_dir = unit->comp_dir;

  table->num_files = 0;
  table->files = NULL;

  table->num_dirs = 0;
  table->dirs = NULL;

  table->num_sequences = 0;
  table->sequences = NULL;

  table->lcl_head = NULL;

  if (stash->dwarf_line_size < 16)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Line info section is too small (%Ld)""),
	 stash->dwarf_line_size);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  line_ptr = stash->dwarf_line_buffer + unit->line_offset;
  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;

  /* Read in the prologue.  */
  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
  line_ptr += 4;
  offset_size = 4;
  if (lh.total_length == 0xffffffff)
    {
      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
      line_ptr += 8;
      offset_size = 8;
    }
  else if (lh.total_length == 0 && unit->addr_size == 8)
    {
      /* Handle (non-standard) 64-bit DWARF2 formats.  */
      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
      line_ptr += 4;
      offset_size = 8;
    }

  if (lh.total_length > (size_t) (line_end - line_ptr))
    {
      _bfd_error_handler
	/* xgettext: c-format */
	(_(""Dwarf Error: Line info data is bigger (%#Lx)""
	   "" than the space remaining in the section (%#lx)""),
	 lh.total_length, (unsigned long) (line_end - line_ptr));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  line_end = line_ptr + lh.total_length;

  lh.version = read_2_bytes (abfd, line_ptr, line_end);
  if (lh.version < 2 || lh.version > 5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Unhandled .debug_line version %d.""), lh.version);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  line_ptr += 2;

  if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
      >= line_end)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Ran out of room reading prologue""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  if (lh.version >= 5)
    {
      unsigned int segment_selector_size;

      /* Skip address size.  */
      read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;

      segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
      if (segment_selector_size != 0)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: Line info unsupported segment selector size %u.""),
	     segment_selector_size);
	  bfd_set_error (bfd_error_bad_value);
	  return NULL;
	}
    }

  if (offset_size == 4)
    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
  else
    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
  line_ptr += offset_size;

  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  if (lh.version >= 4)
    {
      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
    }
  else
    lh.maximum_ops_per_insn = 1;

  if (lh.maximum_ops_per_insn == 0)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Invalid maximum operations per instruction.""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.line_range = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  if (line_ptr + (lh.opcode_base - 1) >= line_end)
    {
      _bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  amt = lh.opcode_base * sizeof (unsigned char);
  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);

  lh.standard_opcode_lengths[0] = 1;

  for (i = 1; i < lh.opcode_base; ++i)
    {
      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
    }

  if (lh.version >= 5)
    {
      /* Read directory table.  */
      if (!read_formatted_entries (unit, &line_ptr, line_end, table,
				   line_info_add_include_dir_stub))
	goto fail;

      /* Read file name table.  */
      if (!read_formatted_entries (unit, &line_ptr, line_end, table,
				   line_info_add_file_name))
	goto fail;
    }
  else
    {
      /* Read directory table.  */
      while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
	{
	  line_ptr += bytes_read;

	  if (!line_info_add_include_dir (table, cur_dir))
	    goto fail;
	}

      line_ptr += bytes_read;

      /* Read file name table.  */
      while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
	{
	  unsigned int dir, xtime, size;

	  line_ptr += bytes_read;

	  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;
	  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;
	  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;

	  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
	    goto fail;
	}

      line_ptr += bytes_read;
    }

  /* Read the statement sequences until there's nothing left.  */
  while (line_ptr < line_end)
    {
      /* State machine registers.  */
      bfd_vma address = 0;
      unsigned char op_index = 0;
      char * filename = table->num_files ? concat_filename (table, 1) : NULL;
      unsigned int line = 1;
      unsigned int column = 0;
      unsigned int discriminator = 0;
      int is_stmt = lh.default_is_stmt;
      int end_sequence = 0;
      /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = (bfd_vma) -1;
      bfd_vma high_pc = 0;

      /* Decode the table.  */
      while (! end_sequence)
	{
	  op_code = read_1_byte (abfd, line_ptr, line_end);
	  line_ptr += 1;

	  if (op_code >= lh.opcode_base)
	    {
	      /* Special operand.  */
	      adj_opcode = op_code - lh.opcode_base;
	      if (lh.line_range == 0)
		goto line_fail;
	      if (lh.maximum_ops_per_insn == 1)
		address += (adj_opcode / lh.line_range
			    * lh.minimum_instruction_length);
	      else
		{
		  address += ((op_index + adj_opcode / lh.line_range)
			      / lh.maximum_ops_per_insn
			      * lh.minimum_instruction_length);
		  op_index = ((op_index + adj_opcode / lh.line_range)
			      % lh.maximum_ops_per_insn);
		}
	      line += lh.line_base + (adj_opcode % lh.line_range);
	      /* Append row to matrix using current values.  */
	      if (!add_line_info (table, address, op_index, filename,
				  line, column, discriminator, 0))
		goto line_fail;
	      discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
						FALSE, line_end);
	      line_ptr += bytes_read;
	      extended_op = read_1_byte (abfd, line_ptr, line_end);
	      line_ptr += 1;

	      switch (extended_op)
		{
		case DW_LNE_end_sequence:
		  end_sequence = 1;
		  if (!add_line_info (table, address, op_index, filename, line,
				      column, discriminator, end_sequence))
		    goto line_fail;
		  discriminator = 0;
		  if (address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
		  if (!arange_add (unit, &unit->arange, low_pc, high_pc))
		    goto line_fail;
		  break;
		case DW_LNE_set_address:
		  address = read_address (unit, line_ptr, line_end);
		  op_index = 0;
		  line_ptr += unit->addr_size;
		  break;
		case DW_LNE_define_file:
		  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
		  line_ptr += bytes_read;
		  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
		    {
		      struct fileinfo *tmp;

		      amt = table->num_files + FILE_ALLOC_CHUNK;
		      amt *= sizeof (struct fileinfo);
		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
		      if (tmp == NULL)
			goto line_fail;
		      table->files = tmp;
		    }
		  table->files[table->num_files].name = cur_file;
		  table->files[table->num_files].dir =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->files[table->num_files].time =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->files[table->num_files].size =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->num_files++;
		  break;
		case DW_LNE_set_discriminator:
		  discriminator =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  break;
		case DW_LNE_HP_source_file_correlation:
		  line_ptr += exop_len - 1;
		  break;
		default:
		  _bfd_error_handler
		    (_(""Dwarf Error: mangled line number section.""));
		  bfd_set_error (bfd_error_bad_value);
		line_fail:
		  if (filename != NULL)
		    free (filename);
		  goto fail;
		}
	      break;
	    case DW_LNS_copy:
	      if (!add_line_info (table, address, op_index,
				  filename, line, column, discriminator, 0))
		goto line_fail;
	      discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	      break;
	    case DW_LNS_advance_pc:
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * _bfd_safe_read_leb128 (abfd, line_ptr,
						     &bytes_read,
						     FALSE, line_end));
	      else
		{
		  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
							  &bytes_read,
							  FALSE, line_end);
		  address = ((op_index + adjust) / lh.maximum_ops_per_insn
			     * lh.minimum_instruction_length);
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_advance_line:
	      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					     TRUE, line_end);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_set_file:
	      {
		unsigned int file;

		/* The file and directory tables are 0
		   based, the references are 1 based.  */
		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					      FALSE, line_end);
		line_ptr += bytes_read;
		if (filename)
		  free (filename);
		filename = concat_filename (table, file);
		break;
	      }
	    case DW_LNS_set_column:
	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					      FALSE, line_end);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_negate_stmt:
	      is_stmt = (!is_stmt);
	      break;
	    case DW_LNS_set_basic_block:
	      break;
	    case DW_LNS_const_add_pc:
	      if (lh.line_range == 0)
		goto line_fail;
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * ((255 - lh.opcode_base) / lh.line_range));
	      else
		{
		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
		  address += (lh.minimum_instruction_length
			      * ((op_index + adjust)
				 / lh.maximum_ops_per_insn));
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      break;
	    case DW_LNS_fixed_advance_pc:
	      address += read_2_bytes (abfd, line_ptr, line_end);
	      op_index = 0;
	      line_ptr += 2;
	      break;
	    default:
	      /* Unknown standard opcode, ignore it.  */
	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
		{
		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
						FALSE, line_end);
		  line_ptr += bytes_read;
		}
	      break;
	    }
	}

      if (filename)
	free (filename);
    }

  if (sort_line_sequences (table))
    return table;

 fail:
  if (table->sequences != NULL)
    free (table->sequences);
  if (table->files != NULL)
    free (table->files);
  if (table->dirs != NULL)
    free (table->dirs);
  return NULL;
}","static struct line_info_table*
decode_line_info (struct comp_unit *VAR_0, struct dwarf2_debug *VAR_1)
{
  bfd *VAR_2 = VAR_0->abfd;
  struct line_info_table* VAR_3;
  bfd_byte *VAR_4;
  bfd_byte *VAR_5;
  struct line_head VAR_6;
  unsigned int VAR_7, VAR_8, VAR_9;
  char *VAR_10, *VAR_11;
  unsigned char VAR_12, VAR_13, VAR_14;
  unsigned int VAR_15;
  bfd_size_type VAR_16;

  if (! read_section (VAR_2, &VAR_1->debug_sections[VAR_17],
		      VAR_1->syms, VAR_0->line_offset,
		      &VAR_1->dwarf_line_buffer, &VAR_1->dwarf_line_size))
    return NULL;

  VAR_16 = sizeof (struct line_info_table);
  VAR_3 = (struct line_info_table *) bfd_alloc (VAR_2, VAR_16);
  if (VAR_3 == NULL)
    return NULL;
  VAR_3->abfd = VAR_2;
  VAR_3->comp_dir = VAR_0->comp_dir;

  VAR_3->num_files = 0;
  VAR_3->files = NULL;

  VAR_3->num_dirs = 0;
  VAR_3->dirs = NULL;

  VAR_3->num_sequences = 0;
  VAR_3->sequences = NULL;

  VAR_3->lcl_head = NULL;

  if (VAR_1->dwarf_line_size < 16)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Line info section is too small (%Ld)""),
	 VAR_1->dwarf_line_size);
      bfd_set_error (VAR_18);
      return NULL;
    }
  VAR_4 = VAR_1->dwarf_line_buffer + VAR_0->line_offset;
  VAR_5 = VAR_1->dwarf_line_buffer + VAR_1->dwarf_line_size;

  /* COMMENT_0 */
  VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
  VAR_4 += 4;
  VAR_9 = 4;
  if (VAR_6.total_length == 0xffffffff)
    {
      VAR_6.total_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
      VAR_4 += 8;
      VAR_9 = 8;
    }
  else if (VAR_6.total_length == 0 && VAR_0->addr_size == 8)
    {
      /* COMMENT_1 */
      VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
      VAR_4 += 4;
      VAR_9 = 8;
    }

  if (VAR_6.total_length > (size_t) (VAR_5 - VAR_4))
    {
      _bfd_error_handler
	/* COMMENT_2 */
	(_(""Dwarf Error: Line info data is bigger (%#Lx)""
	   "" than the space remaining in the section (%#lx)""),
	 VAR_6.total_length, (unsigned long) (VAR_5 - VAR_4));
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_5 = VAR_4 + VAR_6.total_length;

  VAR_6.version = read_2_bytes (VAR_2, VAR_4, VAR_5);
  if (VAR_6.version < 2 || VAR_6.version > 5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Unhandled .debug_line version %d.""), VAR_6.version);
      bfd_set_error (VAR_18);
      return NULL;
    }
  VAR_4 += 2;

  if (VAR_4 + VAR_9 + (VAR_6.version >= 5 ? 8 : (VAR_6.version >= 4 ? 6 : 5))
      >= VAR_5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Ran out of room reading prologue""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  if (VAR_6.version >= 5)
    {
      unsigned int VAR_19;

      /* COMMENT_3 */
      read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;

      VAR_19 = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
      if (VAR_19 != 0)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: Line info unsupported segment selector size %u.""),
	     VAR_19);
	  bfd_set_error (VAR_18);
	  return NULL;
	}
    }

  if (VAR_9 == 4)
    VAR_6.prologue_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
  else
    VAR_6.prologue_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
  VAR_4 += VAR_9;

  VAR_6.minimum_instruction_length = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  if (VAR_6.version >= 4)
    {
      VAR_6.maximum_ops_per_insn = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
    }
  else
    VAR_6.maximum_ops_per_insn = 1;

  if (VAR_6.maximum_ops_per_insn == 0)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Invalid maximum operations per instruction.""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_6.default_is_stmt = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.line_base = read_1_signed_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.line_range = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.opcode_base = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  if (VAR_4 + (VAR_6.opcode_base - 1) >= VAR_5)
    {
      _bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_16 = VAR_6.opcode_base * sizeof (unsigned char);
  VAR_6.standard_opcode_lengths = (unsigned char *) bfd_alloc (VAR_2, VAR_16);

  VAR_6.standard_opcode_lengths[0] = 1;

  for (VAR_7 = 1; VAR_7 < VAR_6.opcode_base; ++VAR_7)
    {
      VAR_6.standard_opcode_lengths[VAR_7] = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
    }

  if (VAR_6.version >= 5)
    {
      /* COMMENT_4 */
      if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
				   VAR_20))
	goto fail;

      /* COMMENT_5 */
      if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
				   VAR_21))
	goto fail;
    }
  else
    {
      /* COMMENT_4 */
      while ((VAR_11 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
	{
	  VAR_4 += VAR_8;

	  if (!line_info_add_include_dir (VAR_3, VAR_11))
	    goto fail;
	}

      VAR_4 += VAR_8;

      /* COMMENT_5 */
      while ((VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
	{
	  unsigned int VAR_22, VAR_23, VAR_24;

	  VAR_4 += VAR_8;

	  VAR_22 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;
	  VAR_23 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;
	  VAR_24 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;

	  if (!VAR_21 (VAR_3, VAR_10, VAR_22, VAR_23, VAR_24))
	    goto fail;
	}

      VAR_4 += VAR_8;
    }

  /* COMMENT_6 */
  while (VAR_4 < VAR_5)
    {
      /* COMMENT_7 */
      bfd_vma VAR_25 = 0;
      unsigned char VAR_26 = 0;
      char * VAR_27 = VAR_3->num_files ? concat_filename (VAR_3, 1) : NULL;
      unsigned int VAR_28 = 1;
      unsigned int VAR_29 = 0;
      unsigned int VAR_30 = 0;
      int VAR_31 = VAR_6.default_is_stmt;
      int VAR_32 = 0;
      /* COMMENT_8 */
                                                             
                                                             
                                                       
                                                         
      bfd_vma VAR_33  = (bfd_vma) -1;
      bfd_vma VAR_34 = 0;

      /* COMMENT_13 */
      while (! VAR_32)
	{
	  VAR_12 = read_1_byte (VAR_2, VAR_4, VAR_5);
	  VAR_4 += 1;

	  if (VAR_12 >= VAR_6.opcode_base)
	    {
	      /* COMMENT_14 */
	      VAR_14 = VAR_12 - VAR_6.opcode_base;
	      if (VAR_6.line_range == 0)
		goto line_fail;
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_14 / VAR_6.line_range
			    * VAR_6.minimum_instruction_length);
	      else
		{
		  VAR_25 += ((VAR_26 + VAR_14 / VAR_6.line_range)
			      / VAR_6.maximum_ops_per_insn
			      * VAR_6.minimum_instruction_length);
		  VAR_26 = ((VAR_26 + VAR_14 / VAR_6.line_range)
			      % VAR_6.maximum_ops_per_insn);
		}
	      VAR_28 += VAR_6.line_base + (VAR_14 % VAR_6.line_range);
	      /* COMMENT_15 */
	      if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27,
				  VAR_28, VAR_29, VAR_30, 0))
		goto line_fail;
	      VAR_30 = 0;
	      if (VAR_25 < VAR_33)
		VAR_33 = VAR_25;
	      if (VAR_25 > VAR_34)
		VAR_34 = VAR_25;
	    }
	  else switch (VAR_12)
	    {
	    case VAR_35:
	      VAR_15 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
						FALSE, VAR_5);
	      VAR_4 += VAR_8;
	      VAR_13 = read_1_byte (VAR_2, VAR_4, VAR_5);
	      VAR_4 += 1;

	      switch (VAR_13)
		{
		case VAR_36:
		  VAR_32 = 1;
		  if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27, VAR_28,
				      VAR_29, VAR_30, VAR_32))
		    goto line_fail;
		  VAR_30 = 0;
		  if (VAR_25 < VAR_33)
		    VAR_33 = VAR_25;
		  if (VAR_25 > VAR_34)
		    VAR_34 = VAR_25;
		  if (!arange_add (VAR_0, &VAR_0->arange, VAR_33, VAR_34))
		    goto line_fail;
		  break;
		case VAR_37:
		  VAR_25 = read_address (VAR_0, VAR_4, VAR_5);
		  VAR_26 = 0;
		  VAR_4 += VAR_0->addr_size;
		  break;
		case VAR_38:
		  VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8);
		  VAR_4 += VAR_8;
		  if ((VAR_3->num_files % VAR_39) == 0)
		    {
		      struct fileinfo *VAR_40;

		      VAR_16 = VAR_3->num_files + VAR_39;
		      VAR_16 *= sizeof (struct fileinfo);
		      VAR_40 = (struct fileinfo *) bfd_realloc (VAR_3->files, VAR_16);
		      if (VAR_40 == NULL)
			goto line_fail;
		      VAR_3->files = VAR_40;
		    }
		  VAR_3->files[VAR_3->num_files].name = VAR_10;
		  VAR_3->files[VAR_3->num_files].dir =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->files[VAR_3->num_files].time =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->files[VAR_3->num_files].size =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->num_files++;
		  break;
		case VAR_41:
		  VAR_30 =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  break;
		case VAR_42:
		  VAR_4 += VAR_15 - 1;
		  break;
		default:
		  _bfd_error_handler
		    (_(""Dwarf Error: mangled line number section.""));
		  bfd_set_error (VAR_18);
		line_fail:
		  if (VAR_27 != NULL)
		    free (VAR_27);
		  goto fail;
		}
	      break;
	    case VAR_43:
	      if (!add_line_info (VAR_3, VAR_25, VAR_26,
				  VAR_27, VAR_28, VAR_29, VAR_30, 0))
		goto line_fail;
	      VAR_30 = 0;
	      if (VAR_25 < VAR_33)
		VAR_33 = VAR_25;
	      if (VAR_25 > VAR_34)
		VAR_34 = VAR_25;
	      break;
	    case VAR_44:
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_6.minimum_instruction_length
			    * _bfd_safe_read_leb128 (VAR_2, VAR_4,
						     &VAR_8,
						     FALSE, VAR_5));
	      else
		{
		  bfd_vma VAR_45 = _bfd_safe_read_leb128 (VAR_2, VAR_4,
							  &VAR_8,
							  FALSE, VAR_5);
		  VAR_25 = ((VAR_26 + VAR_45) / VAR_6.maximum_ops_per_insn
			     * VAR_6.minimum_instruction_length);
		  VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
		}
	      VAR_4 += VAR_8;
	      break;
	    case VAR_46:
	      VAR_28 += _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					     TRUE, VAR_5);
	      VAR_4 += VAR_8;
	      break;
	    case VAR_47:
	      {
		unsigned int VAR_48;

		/* COMMENT_16 */
                                           
		VAR_48 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					      FALSE, VAR_5);
		VAR_4 += VAR_8;
		if (VAR_27)
		  free (VAR_27);
		VAR_27 = concat_filename (VAR_3, VAR_48);
		break;
	      }
	    case VAR_49:
	      VAR_29 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					      FALSE, VAR_5);
	      VAR_4 += VAR_8;
	      break;
	    case VAR_50:
	      VAR_31 = (!VAR_31);
	      break;
	    case VAR_51:
	      break;
	    case VAR_52:
	      if (VAR_6.line_range == 0)
		goto line_fail;
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_6.minimum_instruction_length
			    * ((255 - VAR_6.opcode_base) / VAR_6.line_range));
	      else
		{
		  bfd_vma VAR_45 = ((255 - VAR_6.opcode_base) / VAR_6.line_range);
		  VAR_25 += (VAR_6.minimum_instruction_length
			      * ((VAR_26 + VAR_45)
				 / VAR_6.maximum_ops_per_insn));
		  VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
		}
	      break;
	    case VAR_53:
	      VAR_25 += read_2_bytes (VAR_2, VAR_4, VAR_5);
	      VAR_26 = 0;
	      VAR_4 += 2;
	      break;
	    default:
	      /* COMMENT_18 */
	      for (VAR_7 = 0; VAR_7 < VAR_6.standard_opcode_lengths[VAR_12]; VAR_7++)
		{
		  (void) _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
						FALSE, VAR_5);
		  VAR_4 += VAR_8;
		}
	      break;
	    }
	}

      if (VAR_27)
	free (VAR_27);
    }

  if (sort_line_sequences (VAR_3))
    return VAR_3;

 fail:
  if (VAR_3->sequences != NULL)
    free (VAR_3->sequences);
  if (VAR_3->files != NULL)
    free (VAR_3->files);
  if (VAR_3->dirs != NULL)
    free (VAR_3->dirs);
  return NULL;
}",binutils-gdb/d8010d3e75ec7194a4703774090b27486b742d48/dwarf2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -405,6 +405,8 @@
 	    case DW_LNS_set_basic_block:
 	      break;
 	    case DW_LNS_const_add_pc:
+	      if (lh.line_range == 0)
+		goto line_fail;
 	      if (lh.maximum_ops_per_insn == 1)
 		address += (lh.minimum_instruction_length
 			    * ((255 - lh.opcode_base) / lh.line_range));","{'deleted_lines': [], 'added_lines': ['\t      if (lh.line_range == 0)', '\t\tgoto line_fail;']}",True,"decode_line_info in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted ELF file.",5.5,MEDIUM,1,valid,,5
CVE-2015-5327,['CWE-125'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,torvalds/linux,"This fixes CVE-2015-5327.  It affects kernels from 4.3-rc1 onwards.

Fix the X.509 time validation to use month number-1 when looking up the
number of days in that month.  Also put the month number validation before
doing the lookup so as not to risk overrunning the array.

This can be tested by doing the following:

cat <<EOF | openssl x509 -outform DER | keyctl padd asymmetric """" @s
-----BEGIN CERTIFICATE-----
MIIDbjCCAlagAwIBAgIJAN/lUld+VR4hMA0GCSqGSIb3DQEBCwUAMCkxETAPBgNV
BAoMCGxvY2FsLWNhMRQwEgYDVQQDDAtzaWduaW5nIGtleTAeFw0xNTA5MDEyMTMw
MThaFw0xNjA4MzEyMTMwMThaMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQwEgYDVQQD
DAtzaWduaW5nIGtleTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANrn
crcMfMeG67nagX4+m02Xk9rkmsMKI5XTUxbikROe7GSUVJ27sPVPZp4mgzoWlvhh
jfK8CC/qhEhwep8Pgg4EJZyWOjhZb7R97ckGvLIoUC6IO3FC2ZnR7WtmWDgo2Jcj
VlXwJdHhKU1VZwulh81O61N8IBKqz2r/kDhIWiicUCUkI/Do/RMRfKAoDBcSh86m
gOeIAGfq62vbiZhVsX5dOE8Oo2TK5weAvwUIOR7OuGBl5AqwFlPnXQolewiHzKry
THg9e44HfzG4Mi6wUvcJxVaQT1h5SrKD779Z5+8+wf1JLaooetcEUArvWyuxCU59
qxA4lsTjBwl4cmEki+cCAwEAAaOBmDCBlTAMBgNVHRMEBTADAQH/MAsGA1UdDwQE
AwIHgDAdBgNVHQ4EFgQUyND/eKUis7ep/hXMJ8iZMdUhI+IwWQYDVR0jBFIwUIAU
yND/eKUis7ep/hXMJ8iZMdUhI+KhLaQrMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQw
EgYDVQQDDAtzaWduaW5nIGtleYIJAN/lUld+VR4hMA0GCSqGSIb3DQEBCwUAA4IB
AQAMqm1N1yD5pimUELLhT5eO2lRdGUfTozljRxc7e2QT3RLk2TtGhg65JFFN6eml
XS58AEPVcAsSLDlR6WpOpOLB2giM0+fV/eYFHHmh22yqTJl4YgkdUwyzPdCHNOZL
hmSKeY9xliHb6PNrNWWtZwhYYvRaO2DX4GXOMR0Oa2O4vaYu6/qGlZOZv3U6qZLY
wwHEJSrqeBDyMuwN+eANHpoSpiBzD77S4e+7hUDJnql4j6xzJ65+nWJ89fCrQypR
4sN5R3aGeIh3QAQUIKpHilwek0CtEaYERgc5m+jGyKSc1rezJW62hWRTaitOc+d5
G5hh+9YpnYcxQHEKnZ7rFNKJ
-----END CERTIFICATE-----
EOF

If it works, it emit a key ID; if it fails, it should give a bad message
error.

Reported-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Tested-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Acked-by: David Woodhouse <David.Woodhouse@intel.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>
",cc25b994acfbc901429da682d0f73c190e960206,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=cc25b994acfbc901429da682d0f73c190e960206,crypto/asymmetric_keys/x509_cert_parser.c,x509_decode_time,"int x509_decode_time(time64_t *_t,  size_t hdrlen,
unsigned char tag,
const unsigned char *value, size_t vlen)
{
static const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,
31, 31, 30, 31, 30, 31 };
const unsigned char *p = value;
unsigned year, mon, day, hour, min, sec, mon_len;
#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })
#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })
if (tag == ASN1_UNITIM) {
if (vlen != 13)
goto unsupported_time;
year = DD2bin(p);
if (year >= 50)
year += 1900;
else
year += 2000;
} else if (tag == ASN1_GENTIM) {
if (vlen != 15)
goto unsupported_time;
year = DD2bin(p) * 100 + DD2bin(p);
if (year >= 1950 && year <= 2049)
goto invalid_time;
} else {
goto unsupported_time;
}
mon  = DD2bin(p);
day = DD2bin(p);
hour = DD2bin(p);
min  = DD2bin(p);
sec  = DD2bin(p);
if (*p != 'Z')
goto unsupported_time;
mon_len = month_lengths[mon];
if (mon == 2) {
if (year % 4 == 0) {
mon_len = 29;
if (year % 100 == 0) {
year /= 100;
if (year % 4 != 0)
mon_len = 28;
}
}
}
if (year < 1970 ||
mon < 1 || mon > 12 ||
day < 1 || day > mon_len ||
hour > 23 ||
min > 59 ||
sec > 59)
goto invalid_time;
*_t = mktime64(year, mon, day, hour, min, sec);
return 0;
unsupported_time:
pr_debug(""Got unsupported time [tag %02x]: '%*phN'\n"",
tag, (int)vlen, value);
return -EBADMSG;
invalid_time:
pr_debug(""Got invalid time [tag %02x]: '%*phN'\n"",
tag, (int)vlen, value);
return -EBADMSG;
}","int x509_decode_time(time64_t *VAR_0,  size_t VAR_1,
unsigned char VAR_2,
const unsigned char *VAR_3, size_t VAR_4)
{
static const unsigned char VAR_5[] = { 31, 29, 31, 30, 31, 30,
31, 31, 30, 31, 30, 31 };
const unsigned char *VAR_6 = VAR_3;
unsigned VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;
#define dec2bin(VAR_14) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })
#define DD2bin(VAR_15) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })
if (VAR_2 == VAR_16) {
if (VAR_4 != 13)
goto unsupported_time;
VAR_7 = DD2bin(VAR_6);
if (VAR_7 >= 50)
VAR_7 += 1900;
else
VAR_7 += 2000;
} else if (VAR_2 == VAR_17) {
if (VAR_4 != 15)
goto unsupported_time;
VAR_7 = DD2bin(VAR_6) * 100 + DD2bin(VAR_6);
if (VAR_7 >= 1950 && VAR_7 <= 2049)
goto invalid_time;
} else {
goto unsupported_time;
}
VAR_8  = DD2bin(VAR_6);
VAR_9 = DD2bin(VAR_6);
VAR_10 = DD2bin(VAR_6);
VAR_11  = DD2bin(VAR_6);
VAR_12  = DD2bin(VAR_6);
if (*VAR_6 != 'Z')
goto unsupported_time;
VAR_13 = VAR_5[VAR_8];
if (VAR_8 == 2) {
if (VAR_7 % 4 == 0) {
VAR_13 = 29;
if (VAR_7 % 100 == 0) {
VAR_7 /= 100;
if (VAR_7 % 4 != 0)
VAR_13 = 28;
}
}
}
if (VAR_7 < 1970 ||
VAR_8 < 1 || VAR_8 > 12 ||
VAR_9 < 1 || VAR_9 > VAR_13 ||
VAR_10 > 23 ||
VAR_11 > 59 ||
VAR_12 > 59)
goto invalid_time;
*VAR_0 = mktime64(VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12);
return 0;
unsupported_time:
pr_debug(""Got unsupported time [tag %02x]: '%*phN'\n"",
VAR_2, (int)VAR_4, VAR_3);
return -VAR_18;
invalid_time:
pr_debug(""Got invalid time [tag %02x]: '%*phN'\n"",
VAR_2, (int)VAR_4, VAR_3);
return -VAR_18;
}",torvalds/linux/cc25b994acfbc901429da682d0f73c190e960206/x509_cert_parser.c/vul/before/0.json,"int x509_decode_time(time64_t *_t,  size_t hdrlen,
		     unsigned char tag,
		     const unsigned char *value, size_t vlen)
{
	static const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,
						       31, 31, 30, 31, 30, 31 };
	const unsigned char *p = value;
	unsigned year, mon, day, hour, min, sec, mon_len;

#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })
#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })

	if (tag == ASN1_UNITIM) {
		/* UTCTime: YYMMDDHHMMSSZ */
		if (vlen != 13)
			goto unsupported_time;
		year = DD2bin(p);
		if (year >= 50)
			year += 1900;
		else
			year += 2000;
	} else if (tag == ASN1_GENTIM) {
		/* GenTime: YYYYMMDDHHMMSSZ */
		if (vlen != 15)
			goto unsupported_time;
		year = DD2bin(p) * 100 + DD2bin(p);
		if (year >= 1950 && year <= 2049)
			goto invalid_time;
	} else {
		goto unsupported_time;
	}

	mon  = DD2bin(p);
	day = DD2bin(p);
	hour = DD2bin(p);
	min  = DD2bin(p);
	sec  = DD2bin(p);

	if (*p != 'Z')
		goto unsupported_time;

	if (year < 1970 ||
	    mon < 1 || mon > 12)
		goto invalid_time;

	mon_len = month_lengths[mon - 1];
	if (mon == 2) {
		if (year % 4 == 0) {
			mon_len = 29;
			if (year % 100 == 0) {
				year /= 100;
				if (year % 4 != 0)
					mon_len = 28;
			}
		}
	}

	if (day < 1 || day > mon_len ||
	    hour > 23 ||
	    min > 59 ||
	    sec > 59)
		goto invalid_time;

	*_t = mktime64(year, mon, day, hour, min, sec);
	return 0;

unsupported_time:
	pr_debug(""Got unsupported time [tag %02x]: '%*phN'\n"",
		 tag, (int)vlen, value);
	return -EBADMSG;
invalid_time:
	pr_debug(""Got invalid time [tag %02x]: '%*phN'\n"",
		 tag, (int)vlen, value);
	return -EBADMSG;
}","int x509_decode_time(time64_t *VAR_0,  size_t VAR_1,
		     unsigned char VAR_2,
		     const unsigned char *VAR_3, size_t VAR_4)
{
	static const unsigned char VAR_5[] = { 31, 29, 31, 30, 31, 30,
						       31, 31, 30, 31, 30, 31 };
	const unsigned char *VAR_6 = VAR_3;
	unsigned VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;

#define dec2bin(VAR_14) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })
#define DD2bin(VAR_15) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })

	if (VAR_2 == VAR_16) {
		/* COMMENT_0 */
		if (VAR_4 != 13)
			goto unsupported_time;
		VAR_7 = DD2bin(VAR_6);
		if (VAR_7 >= 50)
			VAR_7 += 1900;
		else
			VAR_7 += 2000;
	} else if (VAR_2 == VAR_17) {
		/* COMMENT_1 */
		if (VAR_4 != 15)
			goto unsupported_time;
		VAR_7 = DD2bin(VAR_6) * 100 + DD2bin(VAR_6);
		if (VAR_7 >= 1950 && VAR_7 <= 2049)
			goto invalid_time;
	} else {
		goto unsupported_time;
	}

	VAR_8  = DD2bin(VAR_6);
	VAR_9 = DD2bin(VAR_6);
	VAR_10 = DD2bin(VAR_6);
	VAR_11  = DD2bin(VAR_6);
	VAR_12  = DD2bin(VAR_6);

	if (*VAR_6 != 'Z')
		goto unsupported_time;

	if (VAR_7 < 1970 ||
	    VAR_8 < 1 || VAR_8 > 12)
		goto invalid_time;

	VAR_13 = VAR_5[VAR_8 - 1];
	if (VAR_8 == 2) {
		if (VAR_7 % 4 == 0) {
			VAR_13 = 29;
			if (VAR_7 % 100 == 0) {
				VAR_7 /= 100;
				if (VAR_7 % 4 != 0)
					VAR_13 = 28;
			}
		}
	}

	if (VAR_9 < 1 || VAR_9 > VAR_13 ||
	    VAR_10 > 23 ||
	    VAR_11 > 59 ||
	    VAR_12 > 59)
		goto invalid_time;

	*VAR_0 = mktime64(VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12);
	return 0;

unsupported_time:
	pr_debug(""Got unsupported time [tag %02x]: '%*phN'\n"",
		 VAR_2, (int)VAR_4, VAR_3);
	return -VAR_18;
invalid_time:
	pr_debug(""Got invalid time [tag %02x]: '%*phN'\n"",
		 VAR_2, (int)VAR_4, VAR_3);
	return -VAR_18;
}",torvalds/linux/cc25b994acfbc901429da682d0f73c190e960206/x509_cert_parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,7 +39,11 @@
 	if (*p != 'Z')
 		goto unsupported_time;
 
-	mon_len = month_lengths[mon];
+	if (year < 1970 ||
+	    mon < 1 || mon > 12)
+		goto invalid_time;
+
+	mon_len = month_lengths[mon - 1];
 	if (mon == 2) {
 		if (year % 4 == 0) {
 			mon_len = 29;
@@ -51,14 +55,12 @@
 		}
 	}
 
-	if (year < 1970 ||
-	    mon < 1 || mon > 12 ||
-	    day < 1 || day > mon_len ||
+	if (day < 1 || day > mon_len ||
 	    hour > 23 ||
 	    min > 59 ||
 	    sec > 59)
 		goto invalid_time;
-	
+
 	*_t = mktime64(year, mon, day, hour, min, sec);
 	return 0;
 ","{'deleted_lines': ['\tmon_len = month_lengths[mon];', '\tif (year < 1970 ||', '\t    mon < 1 || mon > 12 ||', '\t    day < 1 || day > mon_len ||', '\t'], 'added_lines': ['\tif (year < 1970 ||', '\t    mon < 1 || mon > 12)', '\t\tgoto invalid_time;', '', '\tmon_len = month_lengths[mon - 1];', '\tif (day < 1 || day > mon_len ||', '']}",True,Out-of-bounds memory read in the x509_decode_time function in x509_cert_parser.c in Linux kernels 4.3-rc1 and after.,6.5,MEDIUM,1,valid,,5
CVE-2017-14934,"['CWE-835', 'CWE-131']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
Prevent an infinite loop in the DWARF parsing code when encountering a CU structure with a small negative size.

	PR 22219
	* dwarf.c (process_debug_info): Add a check for a negative
	cu_length field.
",19485196044b2521af979f1e5c4a89bfb90fba0b,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=19485196044b2521af979f1e5c4a89bfb90fba0b,binutils/dwarf.c,process_debug_info,"static int
process_debug_info (struct dwarf_section *section,
void *file,
enum dwarf_section_display_enum abbrev_sec,
int do_loc,
int do_types)
{
unsigned char *start = section->start;
unsigned char *end = start + section->size;
unsigned char *section_begin;
unsigned int unit;
unsigned int num_units = 0;
if ((do_loc || do_debug_loc || do_debug_ranges)
&& num_debug_info_entries == 0
&& ! do_types)
{
dwarf_vma length;
for (section_begin = start, num_units = 0; section_begin < end;
num_units ++)
{
SAFE_BYTE_GET (length, section_begin, 4, end);
if (length == 0xffffffff)
{
SAFE_BYTE_GET (length, section_begin + 4, 8, end);
section_begin += length + 12;
}
else if (length >= 0xfffffff0 && length < 0xffffffff)
{
warn (_(""Reserved length value (0x%s) found in section %s\n""),
dwarf_vmatoa (""x"", length), section->name);
return 0;
}
else
section_begin += length + 4;
if ((signed long) length <= 0 || section_begin < start)
{
warn (_(""Corrupt unit length (0x%s) found in section %s\n""),
dwarf_vmatoa (""x"", length), section->name);
return 0;
}
}
if (num_units == 0)
{
error (_(""No comp units in %s section ?\n""), section->name);
return 0;
}
debug_information = (debug_info *) cmalloc (num_units,
sizeof (* debug_information));
if (debug_information == NULL)
{
error (_(""Not enough memory for a debug info array of %u entries\n""),
num_units);
alloc_num_debug_info_entries = num_debug_info_entries = 0;
return 0;
}
memset (debug_information, 0, num_units * sizeof (*debug_information));
alloc_num_debug_info_entries = num_units;
}
if (!do_loc)
{
if (dwarf_start_die == 0)
printf (_(""Contents of the %s section:\n\n""), section->name);
load_debug_section (str, file);
load_debug_section (line_str, file);
load_debug_section (str_dwo, file);
load_debug_section (str_index, file);
load_debug_section (str_index_dwo, file);
load_debug_section (debug_addr, file);
}
load_debug_section (abbrev_sec, file);
if (debug_displays [abbrev_sec].section.start == NULL)
{
warn (_(""Unable to locate %s section!\n""),
debug_displays [abbrev_sec].section.name);
return 0;
}
for (section_begin = start, unit = 0; start < end; unit++)
{
DWARF2_Internal_CompUnit compunit;
unsigned char *hdrptr;
unsigned char *tags;
int level, last_level, saved_level;
dwarf_vma cu_offset;
unsigned int offset_size;
int initial_length_size;
dwarf_vma signature_high = 0;
dwarf_vma signature_low = 0;
dwarf_vma type_offset = 0;
struct cu_tu_set *this_set;
dwarf_vma abbrev_base;
size_t abbrev_size;
hdrptr = start;
SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);
if (compunit.cu_length == 0xffffffff)
{
SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);
offset_size = 8;
initial_length_size = 12;
}
else
{
offset_size = 4;
initial_length_size = 4;
}
SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);
cu_offset = start - section_begin;
this_set = find_cu_tu_set_v2 (cu_offset, do_types);
if (compunit.cu_version < 5)
{
compunit.cu_unit_type = DW_UT_compile;
compunit.cu_pointer_size = -1;
}
else
{
SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);
do_types = (compunit.cu_unit_type == DW_UT_type);
SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);
}
SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);
if (this_set == NULL)
{
abbrev_base = 0;
abbrev_size = debug_displays [abbrev_sec].section.size;
}
else
{
abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];
abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];
}
if (compunit.cu_version < 5)
SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);
if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)
{
warn (_(""Invalid pointer size (%d) in compunit header, using %d instead\n""),
compunit.cu_pointer_size, offset_size);
compunit.cu_pointer_size = offset_size;
}
if (do_types)
{
SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);
hdrptr += 8;
SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);
}
if ((do_loc || do_debug_loc || do_debug_ranges)
&& num_debug_info_entries == 0
&& ! do_types)
{
debug_information [unit].cu_offset = cu_offset;
debug_information [unit].pointer_size
= compunit.cu_pointer_size;
debug_information [unit].offset_size = offset_size;
debug_information [unit].dwarf_version = compunit.cu_version;
debug_information [unit].base_address = 0;
debug_information [unit].addr_base = DEBUG_INFO_UNAVAILABLE;
debug_information [unit].ranges_base = DEBUG_INFO_UNAVAILABLE;
debug_information [unit].loc_offsets = NULL;
debug_information [unit].have_frame_base = NULL;
debug_information [unit].max_loc_offsets = 0;
debug_information [unit].num_loc_offsets = 0;
debug_information [unit].range_lists = NULL;
debug_information [unit].max_range_lists= 0;
debug_information [unit].num_range_lists = 0;
}
if (!do_loc && dwarf_start_die == 0)
{
printf (_(""  Compilation Unit @ offset 0x%s:\n""),
dwarf_vmatoa (""x"", cu_offset));
printf (_(""   Length:        0x%s (%s)\n""),
dwarf_vmatoa (""x"", compunit.cu_length),
offset_size == 8 ? ""64-bit"" : ""32-bit"");
printf (_(""   Version:       %d\n""), compunit.cu_version);
printf (_(""   Abbrev Offset: 0x%s\n""),
dwarf_vmatoa (""x"", compunit.cu_abbrev_offset));
printf (_(""   Pointer Size:  %d\n""), compunit.cu_pointer_size);
if (do_types)
{
char buf[64];
printf (_(""   Signature:     0x%s\n""),
dwarf_vmatoa64 (signature_high, signature_low,
buf, sizeof (buf)));
printf (_(""   Type Offset:   0x%s\n""),
dwarf_vmatoa (""x"", type_offset));
}
if (this_set != NULL)
{
dwarf_vma *offsets = this_set->section_offsets;
size_t *sizes = this_set->section_sizes;
printf (_(""   Section contributions:\n""));
printf (_(""    .debug_abbrev.dwo:       0x%s  0x%s\n""),
dwarf_vmatoa (""x"", offsets [DW_SECT_ABBREV]),
dwarf_vmatoa (""x"", sizes [DW_SECT_ABBREV]));
printf (_(""    .debug_line.dwo:         0x%s  0x%s\n""),
dwarf_vmatoa (""x"", offsets [DW_SECT_LINE]),
dwarf_vmatoa (""x"", sizes [DW_SECT_LINE]));
printf (_(""    .debug_loc.dwo:          0x%s  0x%s\n""),
dwarf_vmatoa (""x"", offsets [DW_SECT_LOC]),
dwarf_vmatoa (""x"", sizes [DW_SECT_LOC]));
printf (_(""    .debug_str_offsets.dwo:  0x%s  0x%s\n""),
dwarf_vmatoa (""x"", offsets [DW_SECT_STR_OFFSETS]),
dwarf_vmatoa (""x"", sizes [DW_SECT_STR_OFFSETS]));
}
}
if (cu_offset + compunit.cu_length + initial_length_size
> section->size)
{
warn (_(""Debug info is corrupted, length of CU at %s""
"" extends beyond end of section (length = %s)\n""),
dwarf_vmatoa (""x"", cu_offset),
dwarf_vmatoa (""x"", compunit.cu_length));
num_units = unit;
break;
}
tags = hdrptr;
start += compunit.cu_length + initial_length_size;
if (start > end)
{
warn (_(""Debug info is corrupt.  CU at %s extends beyond end of section""),
dwarf_vmatoa (""x"", cu_offset));
start = end;
}
if (compunit.cu_version < 2 || compunit.cu_version > 5)
{
warn (_(""CU at offset %s contains corrupt or ""
""unsupported version number: %d.\n""),
dwarf_vmatoa (""x"", cu_offset), compunit.cu_version);
continue;
}
if (compunit.cu_unit_type != DW_UT_compile
&& compunit.cu_unit_type != DW_UT_type)
{
warn (_(""CU at offset %s contains corrupt or ""
""unsupported unit type: %d.\n""),
dwarf_vmatoa (""x"", cu_offset), compunit.cu_unit_type);
continue;
}
free_abbrevs ();
if (compunit.cu_abbrev_offset >= abbrev_size)
warn (_(""Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n""),
(unsigned long) compunit.cu_abbrev_offset,
(unsigned long) abbrev_size);
else if ((abbrev_base + abbrev_size)
> debug_displays [abbrev_sec].section.size)
warn (_(""Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n""),
(unsigned long) abbrev_base + abbrev_size,
(unsigned long) debug_displays [abbrev_sec].section.size);
else
process_abbrev_section
(((unsigned char *) debug_displays [abbrev_sec].section.start
+ abbrev_base + compunit.cu_abbrev_offset),
((unsigned char *) debug_displays [abbrev_sec].section.start
+ abbrev_base + abbrev_size));
level = 0;
last_level = level;
saved_level = -1;
while (tags < start)
{
unsigned int bytes_read;
unsigned long abbrev_number;
unsigned long die_offset;
abbrev_entry *entry;
abbrev_attr *attr;
int do_printing = 1;
die_offset = tags - section_begin;
abbrev_number = read_uleb128 (tags, & bytes_read, start);
tags += bytes_read;
if (abbrev_number == 0)
{
if (level == 0 && start == end)
{
unsigned char *chk;
for (chk = tags; chk < start; chk++)
if (*chk != 0)
break;
if (chk == start)
break;
}
if (!do_loc && die_offset >= dwarf_start_die
&& (dwarf_cutoff_level == -1
|| level < dwarf_cutoff_level))
printf (_("" <%d><%lx>: Abbrev Number: 0\n""),
level, die_offset);
--level;
if (level < 0)
{
static unsigned num_bogus_warns = 0;
if (num_bogus_warns < 3)
{
warn (_(""Bogus end-of-siblings marker detected at offset %lx in %s section\n""),
die_offset, section->name);
num_bogus_warns ++;
if (num_bogus_warns == 3)
warn (_(""Further warnings about bogus end-of-sibling markers suppressed\n""));
}
}
if (dwarf_start_die != 0 && level < saved_level)
return 1;
continue;
}
if (!do_loc)
{
if (dwarf_start_die != 0 && die_offset < dwarf_start_die)
do_printing = 0;
else
{
if (dwarf_start_die != 0 && die_offset == dwarf_start_die)
saved_level = level;
do_printing = (dwarf_cutoff_level == -1
|| level < dwarf_cutoff_level);
if (do_printing)
printf (_("" <%d><%lx>: Abbrev Number: %lu""),
level, die_offset, abbrev_number);
else if (dwarf_cutoff_level == -1
|| last_level < dwarf_cutoff_level)
printf (_("" <%d><%lx>: ...\n""), level, die_offset);
last_level = level;
}
}
for (entry = first_abbrev;
entry && entry->entry != abbrev_number;
entry = entry->next)
continue;
if (entry == NULL)
{
if (!do_loc && do_printing)
{
printf (""\n"");
fflush (stdout);
}
warn (_(""DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n""),
die_offset, abbrev_number);
return 0;
}
if (!do_loc && do_printing)
printf ("" (%s)\n"", get_TAG_name (entry->tag));
switch (entry->tag)
{
default:
need_base_address = 0;
break;
case DW_TAG_compile_unit:
need_base_address = 1;
break;
case DW_TAG_entry_point:
case DW_TAG_subprogram:
need_base_address = 0;
have_frame_base = 0;
break;
}
debug_info *debug_info_p =
(debug_information && unit < alloc_num_debug_info_entries)
? debug_information + unit : NULL;
assert (!debug_info_p
|| (debug_info_p->num_loc_offsets
== debug_info_p->num_loc_views));
for (attr = entry->first_attr;
attr && attr->attribute;
attr = attr->next)
{
if (! do_loc && do_printing)
printf (""    <%lx>"", (unsigned long)(tags - section_begin));
tags = read_and_display_attr (attr->attribute,
attr->form,
attr->implicit_const,
tags,
end,
cu_offset,
compunit.cu_pointer_size,
offset_size,
compunit.cu_version,
debug_info_p,
do_loc || ! do_printing,
section,
this_set);
}
if (debug_info_p)
switch (debug_info_p->num_loc_offsets - debug_info_p->num_loc_views)
{
case 1:
debug_info_p->loc_views [debug_info_p->num_loc_views] = vm1;
debug_info_p->num_loc_views++;
assert (debug_info_p->num_loc_views
== debug_info_p->num_loc_offsets);
break;
case 0:
break;
case -1:
warn(_(""DIE has locviews without loclist\n""));
debug_info_p->num_loc_views--;
break;
default:
assert (0);
}
if (entry->children)
++level;
}
}
if ((do_loc || do_debug_loc || do_debug_ranges)
&& num_debug_info_entries == 0
&& ! do_types)
{
if (num_units > alloc_num_debug_info_entries)
num_debug_info_entries = alloc_num_debug_info_entries;
else
num_debug_info_entries = num_units;
}
if (!do_loc)
printf (""\n"");
return 1;
}","static int
process_debug_info (struct dwarf_section *VAR_0,
void *VAR_1,
enum dwarf_section_display_enum VAR_2,
int VAR_3,
int VAR_4)
{
unsigned char *VAR_5 = VAR_0->start;
unsigned char *VAR_6 = VAR_5 + VAR_0->size;
unsigned char *VAR_7;
unsigned int VAR_8;
unsigned int VAR_9 = 0;
if ((VAR_3 || VAR_10 || VAR_11)
&& VAR_12 == 0
&& ! VAR_4)
{
dwarf_vma VAR_13;
for (VAR_7 = VAR_5, VAR_9 = 0; VAR_7 < VAR_6;
VAR_9 ++)
{
SAFE_BYTE_GET (VAR_13, VAR_7, 4, VAR_6);
if (VAR_13 == 0xffffffff)
{
SAFE_BYTE_GET (VAR_13, VAR_7 + 4, 8, VAR_6);
VAR_7 += VAR_13 + 12;
}
else if (VAR_13 >= 0xfffffff0 && VAR_13 < 0xffffffff)
{
warn (_(""Reserved length value (0x%s) found in section %s\n""),
dwarf_vmatoa (""x"", VAR_13), VAR_0->name);
return 0;
}
else
VAR_7 += VAR_13 + 4;
if ((signed long) VAR_13 <= 0 || VAR_7 < VAR_5)
{
warn (_(""Corrupt unit length (0x%s) found in section %s\n""),
dwarf_vmatoa (""x"", VAR_13), VAR_0->name);
return 0;
}
}
if (VAR_9 == 0)
{
error (_(""No comp units in %s section ?\n""), VAR_0->name);
return 0;
}
VAR_14 = (debug_info *) cmalloc (VAR_9,
sizeof (* VAR_14));
if (VAR_14 == NULL)
{
error (_(""Not enough memory for a debug info array of %u entries\n""),
VAR_9);
VAR_15 = VAR_12 = 0;
return 0;
}
memset (VAR_14, 0, VAR_9 * sizeof (*VAR_14));
VAR_15 = VAR_9;
}
if (!VAR_3)
{
if (VAR_16 == 0)
printf (_(""Contents of the %s section:\n\n""), VAR_0->name);
load_debug_section (VAR_17, VAR_1);
load_debug_section (VAR_18, VAR_1);
load_debug_section (VAR_19, VAR_1);
load_debug_section (VAR_20, VAR_1);
load_debug_section (VAR_21, VAR_1);
load_debug_section (VAR_22, VAR_1);
}
load_debug_section (VAR_2, VAR_1);
if (VAR_23 [VAR_2].section.start == NULL)
{
warn (_(""Unable to locate %s section!\n""),
VAR_23 [VAR_2].section.name);
return 0;
}
for (VAR_7 = VAR_5, VAR_8 = 0; VAR_5 < VAR_6; VAR_8++)
{
DWARF2_Internal_CompUnit VAR_24;
unsigned char *VAR_25;
unsigned char *VAR_26;
int VAR_27, VAR_28, VAR_29;
dwarf_vma VAR_30;
unsigned int VAR_31;
int VAR_32;
dwarf_vma VAR_33 = 0;
dwarf_vma VAR_34 = 0;
dwarf_vma VAR_35 = 0;
struct cu_tu_set *VAR_36;
dwarf_vma VAR_37;
size_t VAR_38;
VAR_25 = VAR_5;
SAFE_BYTE_GET_AND_INC (VAR_24.cu_length, VAR_25, 4, VAR_6);
if (VAR_24.cu_length == 0xffffffff)
{
SAFE_BYTE_GET_AND_INC (VAR_24.cu_length, VAR_25, 8, VAR_6);
VAR_31 = 8;
VAR_32 = 12;
}
else
{
VAR_31 = 4;
VAR_32 = 4;
}
SAFE_BYTE_GET_AND_INC (VAR_24.cu_version, VAR_25, 2, VAR_6);
VAR_30 = VAR_5 - VAR_7;
VAR_36 = find_cu_tu_set_v2 (VAR_30, VAR_4);
if (VAR_24.cu_version < 5)
{
VAR_24.cu_unit_type = VAR_39;
VAR_24.cu_pointer_size = -1;
}
else
{
SAFE_BYTE_GET_AND_INC (VAR_24.cu_unit_type, VAR_25, 1, VAR_6);
VAR_4 = (VAR_24.cu_unit_type == VAR_40);
SAFE_BYTE_GET_AND_INC (VAR_24.cu_pointer_size, VAR_25, 1, VAR_6);
}
SAFE_BYTE_GET_AND_INC (VAR_24.cu_abbrev_offset, VAR_25, VAR_31, VAR_6);
if (VAR_36 == NULL)
{
VAR_37 = 0;
VAR_38 = VAR_23 [VAR_2].section.size;
}
else
{
VAR_37 = VAR_36->section_offsets [VAR_41];
VAR_38 = VAR_36->section_sizes [VAR_41];
}
if (VAR_24.cu_version < 5)
SAFE_BYTE_GET_AND_INC (VAR_24.cu_pointer_size, VAR_25, 1, VAR_6);
if (VAR_24.cu_pointer_size < 2 || VAR_24.cu_pointer_size > 8)
{
warn (_(""Invalid pointer size (%d) in compunit header, using %d instead\n""),
VAR_24.cu_pointer_size, VAR_31);
VAR_24.cu_pointer_size = VAR_31;
}
if (VAR_4)
{
SAFE_BYTE_GET64 (VAR_25, &VAR_33, &VAR_34, VAR_6);
VAR_25 += 8;
SAFE_BYTE_GET_AND_INC (VAR_35, VAR_25, VAR_31, VAR_6);
}
if ((VAR_3 || VAR_10 || VAR_11)
&& VAR_12 == 0
&& ! VAR_4)
{
VAR_14 [VAR_8].cu_offset = VAR_30;
VAR_14 [VAR_8].pointer_size
= VAR_24.cu_pointer_size;
VAR_14 [VAR_8].offset_size = VAR_31;
VAR_14 [VAR_8].dwarf_version = VAR_24.cu_version;
VAR_14 [VAR_8].base_address = 0;
VAR_14 [VAR_8].addr_base = VAR_42;
VAR_14 [VAR_8].ranges_base = VAR_42;
VAR_14 [VAR_8].loc_offsets = NULL;
VAR_14 [VAR_8].have_frame_base = NULL;
VAR_14 [VAR_8].max_loc_offsets = 0;
VAR_14 [VAR_8].num_loc_offsets = 0;
VAR_14 [VAR_8].range_lists = NULL;
VAR_14 [VAR_8].max_range_lists= 0;
VAR_14 [VAR_8].num_range_lists = 0;
}
if (!VAR_3 && VAR_16 == 0)
{
printf (_(""  Compilation Unit @ offset 0x%s:\n""),
dwarf_vmatoa (""x"", VAR_30));
printf (_(""   Length:        0x%s (%s)\n""),
dwarf_vmatoa (""x"", VAR_24.cu_length),
VAR_31 == 8 ? ""64-bit"" : ""32-bit"");
printf (_(""   Version:       %d\n""), VAR_24.cu_version);
printf (_(""   Abbrev Offset: 0x%s\n""),
dwarf_vmatoa (""x"", VAR_24.cu_abbrev_offset));
printf (_(""   Pointer Size:  %d\n""), VAR_24.cu_pointer_size);
if (VAR_4)
{
char VAR_43[64];
printf (_(""   Signature:     0x%s\n""),
dwarf_vmatoa64 (VAR_33, VAR_34,
VAR_43, sizeof (VAR_43)));
printf (_(""   Type Offset:   0x%s\n""),
dwarf_vmatoa (""x"", VAR_35));
}
if (VAR_36 != NULL)
{
dwarf_vma *VAR_44 = VAR_36->section_offsets;
size_t *VAR_45 = VAR_36->section_sizes;
printf (_(""   Section contributions:\n""));
printf (_(""    .debug_abbrev.dwo:       0x%s  0x%s\n""),
dwarf_vmatoa (""x"", VAR_44 [VAR_41]),
dwarf_vmatoa (""x"", VAR_45 [VAR_41]));
printf (_(""    .debug_line.dwo:         0x%s  0x%s\n""),
dwarf_vmatoa (""x"", VAR_44 [VAR_46]),
dwarf_vmatoa (""x"", VAR_45 [VAR_46]));
printf (_(""    .debug_loc.dwo:          0x%s  0x%s\n""),
dwarf_vmatoa (""x"", VAR_44 [VAR_47]),
dwarf_vmatoa (""x"", VAR_45 [VAR_47]));
printf (_(""    .debug_str_offsets.dwo:  0x%s  0x%s\n""),
dwarf_vmatoa (""x"", VAR_44 [VAR_48]),
dwarf_vmatoa (""x"", VAR_45 [VAR_48]));
}
}
if (VAR_30 + VAR_24.cu_length + VAR_32
> VAR_0->size)
{
warn (_(""Debug info is corrupted, length of CU at %s""
"" extends beyond end of section (length = %s)\n""),
dwarf_vmatoa (""x"", VAR_30),
dwarf_vmatoa (""x"", VAR_24.cu_length));
VAR_9 = VAR_8;
break;
}
VAR_26 = VAR_25;
VAR_5 += VAR_24.cu_length + VAR_32;
if (VAR_5 > VAR_6)
{
warn (_(""Debug info is corrupt.  CU at %s extends beyond end of section""),
dwarf_vmatoa (""x"", VAR_30));
VAR_5 = VAR_6;
}
if (VAR_24.cu_version < 2 || VAR_24.cu_version > 5)
{
warn (_(""CU at offset %s contains corrupt or ""
""unsupported version number: %d.\n""),
dwarf_vmatoa (""x"", VAR_30), VAR_24.cu_version);
continue;
}
if (VAR_24.cu_unit_type != VAR_39
&& VAR_24.cu_unit_type != VAR_40)
{
warn (_(""CU at offset %s contains corrupt or ""
""unsupported unit type: %d.\n""),
dwarf_vmatoa (""x"", VAR_30), VAR_24.cu_unit_type);
continue;
}
free_abbrevs ();
if (VAR_24.cu_abbrev_offset >= VAR_38)
warn (_(""Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n""),
(unsigned long) VAR_24.cu_abbrev_offset,
(unsigned long) VAR_38);
else if ((VAR_37 + VAR_38)
> VAR_23 [VAR_2].section.size)
warn (_(""Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n""),
(unsigned long) VAR_37 + VAR_38,
(unsigned long) VAR_23 [VAR_2].section.size);
else
process_abbrev_section
(((unsigned char *) VAR_23 [VAR_2].section.start
+ VAR_37 + VAR_24.cu_abbrev_offset),
((unsigned char *) VAR_23 [VAR_2].section.start
+ VAR_37 + VAR_38));
VAR_27 = 0;
VAR_28 = VAR_27;
VAR_29 = -1;
while (VAR_26 < VAR_5)
{
unsigned int VAR_49;
unsigned long VAR_50;
unsigned long VAR_51;
abbrev_entry *VAR_52;
abbrev_attr *VAR_53;
int VAR_54 = 1;
VAR_51 = VAR_26 - VAR_7;
VAR_50 = read_uleb128 (VAR_26, & VAR_49, VAR_5);
VAR_26 += VAR_49;
if (VAR_50 == 0)
{
if (VAR_27 == 0 && VAR_5 == VAR_6)
{
unsigned char *VAR_55;
for (VAR_55 = VAR_26; VAR_55 < VAR_5; VAR_55++)
if (*VAR_55 != 0)
break;
if (VAR_55 == VAR_5)
break;
}
if (!VAR_3 && VAR_51 >= VAR_16
&& (VAR_56 == -1
|| VAR_27 < VAR_56))
printf (_("" <%d><%lx>: Abbrev Number: 0\n""),
VAR_27, VAR_51);
--VAR_27;
if (VAR_27 < 0)
{
static unsigned VAR_57 = 0;
if (VAR_57 < 3)
{
warn (_(""Bogus end-of-siblings marker detected at offset %lx in %s section\n""),
VAR_51, VAR_0->name);
VAR_57 ++;
if (VAR_57 == 3)
warn (_(""Further warnings about bogus end-of-sibling markers suppressed\n""));
}
}
if (VAR_16 != 0 && VAR_27 < VAR_29)
return 1;
continue;
}
if (!VAR_3)
{
if (VAR_16 != 0 && VAR_51 < VAR_16)
VAR_54 = 0;
else
{
if (VAR_16 != 0 && VAR_51 == VAR_16)
VAR_29 = VAR_27;
VAR_54 = (VAR_56 == -1
|| VAR_27 < VAR_56);
if (VAR_54)
printf (_("" <%d><%lx>: Abbrev Number: %lu""),
VAR_27, VAR_51, VAR_50);
else if (VAR_56 == -1
|| VAR_28 < VAR_56)
printf (_("" <%d><%lx>: ...\n""), VAR_27, VAR_51);
VAR_28 = VAR_27;
}
}
for (VAR_52 = VAR_58;
VAR_52 && VAR_52->entry != VAR_50;
VAR_52 = VAR_52->next)
continue;
if (VAR_52 == NULL)
{
if (!VAR_3 && VAR_54)
{
printf (""\n"");
fflush (VAR_59);
}
warn (_(""DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n""),
VAR_51, VAR_50);
return 0;
}
if (!VAR_3 && VAR_54)
printf ("" (%s)\n"", get_TAG_name (VAR_52->tag));
switch (VAR_52->tag)
{
default:
VAR_60 = 0;
break;
case VAR_61:
VAR_60 = 1;
break;
case VAR_62:
case VAR_63:
VAR_60 = 0;
VAR_64 = 0;
break;
}
debug_info *VAR_65 =
(VAR_14 && VAR_8 < VAR_15)
? VAR_14 + VAR_8 : NULL;
assert (!VAR_65
|| (VAR_65->num_loc_offsets
== VAR_65->num_loc_views));
for (VAR_53 = VAR_52->first_attr;
VAR_53 && VAR_53->attribute;
VAR_53 = VAR_53->next)
{
if (! VAR_3 && VAR_54)
printf (""    <%lx>"", (unsigned long)(VAR_26 - VAR_7));
VAR_26 = read_and_display_attr (VAR_53->attribute,
VAR_53->form,
VAR_53->implicit_const,
VAR_26,
VAR_6,
VAR_30,
VAR_24.cu_pointer_size,
VAR_31,
VAR_24.cu_version,
VAR_65,
VAR_3 || ! VAR_54,
VAR_0,
VAR_36);
}
if (VAR_65)
switch (VAR_65->num_loc_offsets - VAR_65->num_loc_views)
{
case 1:
VAR_65->loc_views [VAR_65->num_loc_views] = VAR_66;
VAR_65->num_loc_views++;
assert (VAR_65->num_loc_views
== VAR_65->num_loc_offsets);
break;
case 0:
break;
case -1:
warn(_(""DIE has locviews without loclist\n""));
VAR_65->num_loc_views--;
break;
default:
assert (0);
}
if (VAR_52->children)
++VAR_27;
}
}
if ((VAR_3 || VAR_10 || VAR_11)
&& VAR_12 == 0
&& ! VAR_4)
{
if (VAR_9 > VAR_15)
VAR_12 = VAR_15;
else
VAR_12 = VAR_9;
}
if (!VAR_3)
printf (""\n"");
return 1;
}",binutils-gdb/19485196044b2521af979f1e5c4a89bfb90fba0b/dwarf.c/vul/before/0.json,"static int
process_debug_info (struct dwarf_section *section,
		    void *file,
		    enum dwarf_section_display_enum abbrev_sec,
		    int do_loc,
		    int do_types)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_begin;
  unsigned int unit;
  unsigned int num_units = 0;

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    {
      dwarf_vma length;

      /* First scan the section to get the number of comp units.  */
      for (section_begin = start, num_units = 0; section_begin < end;
	   num_units ++)
	{
	  /* Read the first 4 bytes.  For a 32-bit DWARF section, this
	     will be the length.  For a 64-bit DWARF section, it'll be
	     the escape code 0xffffffff followed by an 8 byte length.  */
	  SAFE_BYTE_GET (length, section_begin, 4, end);

	  if (length == 0xffffffff)
	    {
	      SAFE_BYTE_GET (length, section_begin + 4, 8, end);
	      section_begin += length + 12;
	    }
	  else if (length >= 0xfffffff0 && length < 0xffffffff)
	    {
	      warn (_(""Reserved length value (0x%s) found in section %s\n""),
		    dwarf_vmatoa (""x"", length), section->name);
	      return 0;
	    }
	  else
	    section_begin += length + 4;

	  /* Negative values are illegal, they may even cause infinite
	     looping.  This can happen if we can't accurately apply
	     relocations to an object file, or if the file is corrupt.  */
	  if ((signed long) length <= 0 || section_begin < start)
	    {
	      warn (_(""Corrupt unit length (0x%s) found in section %s\n""),
		    dwarf_vmatoa (""x"", length), section->name);
	      return 0;
	    }
	}

      if (num_units == 0)
	{
	  error (_(""No comp units in %s section ?\n""), section->name);
	  return 0;
	}

      /* Then allocate an array to hold the information.  */
      debug_information = (debug_info *) cmalloc (num_units,
						  sizeof (* debug_information));
      if (debug_information == NULL)
	{
	  error (_(""Not enough memory for a debug info array of %u entries\n""),
		 num_units);
	  alloc_num_debug_info_entries = num_debug_info_entries = 0;
	  return 0;
	}
      /* PR 17531: file: 92ca3797.
	 We cannot rely upon the debug_information array being initialised
	 before it is used.  A corrupt file could easily contain references
	 to a unit for which information has not been made available.  So
	 we ensure that the array is zeroed here.  */
      memset (debug_information, 0, num_units * sizeof (*debug_information));

      alloc_num_debug_info_entries = num_units;
    }

  if (!do_loc)
    {
      if (dwarf_start_die == 0)
	printf (_(""Contents of the %s section:\n\n""), section->name);

      load_debug_section (str, file);
      load_debug_section (line_str, file);
      load_debug_section (str_dwo, file);
      load_debug_section (str_index, file);
      load_debug_section (str_index_dwo, file);
      load_debug_section (debug_addr, file);
    }

  load_debug_section (abbrev_sec, file);
  if (debug_displays [abbrev_sec].section.start == NULL)
    {
      warn (_(""Unable to locate %s section!\n""),
	    debug_displays [abbrev_sec].section.name);
      return 0;
    }

  for (section_begin = start, unit = 0; start < end; unit++)
    {
      DWARF2_Internal_CompUnit compunit;
      unsigned char *hdrptr;
      unsigned char *tags;
      int level, last_level, saved_level;
      dwarf_vma cu_offset;
      unsigned int offset_size;
      unsigned int initial_length_size;
      dwarf_vma signature_high = 0;
      dwarf_vma signature_low = 0;
      dwarf_vma type_offset = 0;
      struct cu_tu_set *this_set;
      dwarf_vma abbrev_base;
      size_t abbrev_size;

      hdrptr = start;

      SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);

      if (compunit.cu_length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);

      cu_offset = start - section_begin;

      this_set = find_cu_tu_set_v2 (cu_offset, do_types);

      if (compunit.cu_version < 5)
	{
	  compunit.cu_unit_type = DW_UT_compile;
	  /* Initialize it due to a false compiler warning.  */
	  compunit.cu_pointer_size = -1;
	}
      else
	{
	  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);
	  do_types = (compunit.cu_unit_type == DW_UT_type);

	  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);
	}

      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);

      if (this_set == NULL)
	{
	  abbrev_base = 0;
	  abbrev_size = debug_displays [abbrev_sec].section.size;
	}
      else
	{
	  abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];
	  abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];
	}

      if (compunit.cu_version < 5)
	SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);

      /* PR 17512: file: 001-108546-0.001:0.1.  */
      if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)
	{
	  warn (_(""Invalid pointer size (%d) in compunit header, using %d instead\n""),
		compunit.cu_pointer_size, offset_size);
	  compunit.cu_pointer_size = offset_size;
	}

      if (do_types)
	{
	  SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);
	  hdrptr += 8;
	  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);
	}

      if ((do_loc || do_debug_loc || do_debug_ranges)
	  && num_debug_info_entries == 0
	  && ! do_types)
	{
	  debug_information [unit].cu_offset = cu_offset;
	  debug_information [unit].pointer_size
	    = compunit.cu_pointer_size;
	  debug_information [unit].offset_size = offset_size;
	  debug_information [unit].dwarf_version = compunit.cu_version;
	  debug_information [unit].base_address = 0;
	  debug_information [unit].addr_base = DEBUG_INFO_UNAVAILABLE;
	  debug_information [unit].ranges_base = DEBUG_INFO_UNAVAILABLE;
	  debug_information [unit].loc_offsets = NULL;
	  debug_information [unit].have_frame_base = NULL;
	  debug_information [unit].max_loc_offsets = 0;
	  debug_information [unit].num_loc_offsets = 0;
	  debug_information [unit].range_lists = NULL;
	  debug_information [unit].max_range_lists= 0;
	  debug_information [unit].num_range_lists = 0;
	}

      if (!do_loc && dwarf_start_die == 0)
	{
	  printf (_(""  Compilation Unit @ offset 0x%s:\n""),
		  dwarf_vmatoa (""x"", cu_offset));
	  printf (_(""   Length:        0x%s (%s)\n""),
		  dwarf_vmatoa (""x"", compunit.cu_length),
		  offset_size == 8 ? ""64-bit"" : ""32-bit"");
	  printf (_(""   Version:       %d\n""), compunit.cu_version);
	  printf (_(""   Abbrev Offset: 0x%s\n""),
		  dwarf_vmatoa (""x"", compunit.cu_abbrev_offset));
	  printf (_(""   Pointer Size:  %d\n""), compunit.cu_pointer_size);
	  if (do_types)
	    {
	      char buf[64];

	      printf (_(""   Signature:     0x%s\n""),
		      dwarf_vmatoa64 (signature_high, signature_low,
				      buf, sizeof (buf)));
	      printf (_(""   Type Offset:   0x%s\n""),
		      dwarf_vmatoa (""x"", type_offset));
	    }
	  if (this_set != NULL)
	    {
	      dwarf_vma *offsets = this_set->section_offsets;
	      size_t *sizes = this_set->section_sizes;

	      printf (_(""   Section contributions:\n""));
	      printf (_(""    .debug_abbrev.dwo:       0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", offsets [DW_SECT_ABBREV]),
		      dwarf_vmatoa (""x"", sizes [DW_SECT_ABBREV]));
	      printf (_(""    .debug_line.dwo:         0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", offsets [DW_SECT_LINE]),
		      dwarf_vmatoa (""x"", sizes [DW_SECT_LINE]));
	      printf (_(""    .debug_loc.dwo:          0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", offsets [DW_SECT_LOC]),
		      dwarf_vmatoa (""x"", sizes [DW_SECT_LOC]));
	      printf (_(""    .debug_str_offsets.dwo:  0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", offsets [DW_SECT_STR_OFFSETS]),
		      dwarf_vmatoa (""x"", sizes [DW_SECT_STR_OFFSETS]));
	    }
	}

      if (cu_offset + compunit.cu_length + initial_length_size
	  > section->size)
	{
	  warn (_(""Debug info is corrupted, length of CU at %s""
		  "" extends beyond end of section (length = %s)\n""),
		dwarf_vmatoa (""x"", cu_offset),
		dwarf_vmatoa (""x"", compunit.cu_length));
	  num_units = unit;
	  break;
	}
      else if (compunit.cu_length + initial_length_size < initial_length_size)
	{
	  warn (_(""Debug info is corrupted, length of CU at %s is negative (%s)\n""),
		dwarf_vmatoa (""x"", cu_offset),
		dwarf_vmatoa (""x"", compunit.cu_length));
	  num_units = unit;
	  break;
	}

      tags = hdrptr;
      start += compunit.cu_length + initial_length_size;

      if (start > end)
	{
	  warn (_(""Debug info is corrupt.  CU at %s extends beyond end of section""),
		dwarf_vmatoa (""x"", cu_offset));
	  start = end;
	}

      if (compunit.cu_version < 2 || compunit.cu_version > 5)
	{
	  warn (_(""CU at offset %s contains corrupt or ""
		  ""unsupported version number: %d.\n""),
		dwarf_vmatoa (""x"", cu_offset), compunit.cu_version);
	  continue;
	}

      if (compunit.cu_unit_type != DW_UT_compile
	  && compunit.cu_unit_type != DW_UT_type)
	{
	  warn (_(""CU at offset %s contains corrupt or ""
		  ""unsupported unit type: %d.\n""),
		dwarf_vmatoa (""x"", cu_offset), compunit.cu_unit_type);
	  continue;
	}

      free_abbrevs ();

      /* Process the abbrevs used by this compilation unit.  */
      if (compunit.cu_abbrev_offset >= abbrev_size)
	warn (_(""Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n""),
	      (unsigned long) compunit.cu_abbrev_offset,
	      (unsigned long) abbrev_size);
      /* PR 17531: file:4bcd9ce9.  */
      else if ((abbrev_base + abbrev_size)
	       > debug_displays [abbrev_sec].section.size)
	warn (_(""Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n""),
	      (unsigned long) abbrev_base + abbrev_size,
	      (unsigned long) debug_displays [abbrev_sec].section.size);
      else
	process_abbrev_section
	  (((unsigned char *) debug_displays [abbrev_sec].section.start
	    + abbrev_base + compunit.cu_abbrev_offset),
	   ((unsigned char *) debug_displays [abbrev_sec].section.start
	    + abbrev_base + abbrev_size));

      level = 0;
      last_level = level;
      saved_level = -1;
      while (tags < start)
	{
	  unsigned int bytes_read;
	  unsigned long abbrev_number;
	  unsigned long die_offset;
	  abbrev_entry *entry;
	  abbrev_attr *attr;
	  int do_printing = 1;

	  die_offset = tags - section_begin;

	  abbrev_number = read_uleb128 (tags, & bytes_read, start);
	  tags += bytes_read;

	  /* A null DIE marks the end of a list of siblings or it may also be
	     a section padding.  */
	  if (abbrev_number == 0)
	    {
	      /* Check if it can be a section padding for the last CU.  */
	      if (level == 0 && start == end)
		{
		  unsigned char *chk;

		  for (chk = tags; chk < start; chk++)
		    if (*chk != 0)
		      break;
		  if (chk == start)
		    break;
		}

	      if (!do_loc && die_offset >= dwarf_start_die
		  && (dwarf_cutoff_level == -1
		      || level < dwarf_cutoff_level))
		printf (_("" <%d><%lx>: Abbrev Number: 0\n""),
			level, die_offset);

	      --level;
	      if (level < 0)
		{
		  static unsigned num_bogus_warns = 0;

		  if (num_bogus_warns < 3)
		    {
		      warn (_(""Bogus end-of-siblings marker detected at offset %lx in %s section\n""),
			    die_offset, section->name);
		      num_bogus_warns ++;
		      if (num_bogus_warns == 3)
			warn (_(""Further warnings about bogus end-of-sibling markers suppressed\n""));
		    }
		}
	      if (dwarf_start_die != 0 && level < saved_level)
		return 1;
	      continue;
	    }

	  if (!do_loc)
	    {
	      if (dwarf_start_die != 0 && die_offset < dwarf_start_die)
		do_printing = 0;
	      else
		{
		  if (dwarf_start_die != 0 && die_offset == dwarf_start_die)
		    saved_level = level;
		  do_printing = (dwarf_cutoff_level == -1
				 || level < dwarf_cutoff_level);
		  if (do_printing)
		    printf (_("" <%d><%lx>: Abbrev Number: %lu""),
			    level, die_offset, abbrev_number);
		  else if (dwarf_cutoff_level == -1
			   || last_level < dwarf_cutoff_level)
		    printf (_("" <%d><%lx>: ...\n""), level, die_offset);
		  last_level = level;
		}
	    }

	  /* Scan through the abbreviation list until we reach the
	     correct entry.  */
	  for (entry = first_abbrev;
	       entry && entry->entry != abbrev_number;
	       entry = entry->next)
	    continue;

	  if (entry == NULL)
	    {
	      if (!do_loc && do_printing)
		{
		  printf (""\n"");
		  fflush (stdout);
		}
	      warn (_(""DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n""),
		    die_offset, abbrev_number);
	      return 0;
	    }

	  if (!do_loc && do_printing)
	    printf ("" (%s)\n"", get_TAG_name (entry->tag));

	  switch (entry->tag)
	    {
	    default:
	      need_base_address = 0;
	      break;
	    case DW_TAG_compile_unit:
	      need_base_address = 1;
	      break;
	    case DW_TAG_entry_point:
	    case DW_TAG_subprogram:
	      need_base_address = 0;
	      /* Assuming that there is no DW_AT_frame_base.  */
	      have_frame_base = 0;
	      break;
	    }

	  debug_info *debug_info_p =
	    (debug_information && unit < alloc_num_debug_info_entries)
	    ? debug_information + unit : NULL;

	  assert (!debug_info_p
		  || (debug_info_p->num_loc_offsets
		      == debug_info_p->num_loc_views));

	  for (attr = entry->first_attr;
	       attr && attr->attribute;
	       attr = attr->next)
	    {
	      if (! do_loc && do_printing)
		/* Show the offset from where the tag was extracted.  */
		printf (""    <%lx>"", (unsigned long)(tags - section_begin));

	      tags = read_and_display_attr (attr->attribute,
					    attr->form,
					    attr->implicit_const,
					    tags,
					    end,
					    cu_offset,
					    compunit.cu_pointer_size,
					    offset_size,
					    compunit.cu_version,
					    debug_info_p,
					    do_loc || ! do_printing,
					    section,
					    this_set);
	    }

	  /* If a locview attribute appears before a location one,
	     make sure we don't associate it with an earlier
	     loclist. */
	  if (debug_info_p)
	    switch (debug_info_p->num_loc_offsets - debug_info_p->num_loc_views)
	      {
	      case 1:
		debug_info_p->loc_views [debug_info_p->num_loc_views] = vm1;
		debug_info_p->num_loc_views++;
		assert (debug_info_p->num_loc_views
			== debug_info_p->num_loc_offsets);
		break;

	      case 0:
		break;

	      case -1:
		warn(_(""DIE has locviews without loclist\n""));
		debug_info_p->num_loc_views--;
		break;

	      default:
		assert (0);
	    }

	  if (entry->children)
	    ++level;
	}
    }

  /* Set num_debug_info_entries here so that it can be used to check if
     we need to process .debug_loc and .debug_ranges sections.  */
  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    {
      if (num_units > alloc_num_debug_info_entries)
	num_debug_info_entries = alloc_num_debug_info_entries;
      else
	num_debug_info_entries = num_units;
    }

  if (!do_loc)
    printf (""\n"");

  return 1;
}","static int
process_debug_info (struct dwarf_section *VAR_0,
		    void *VAR_1,
		    enum dwarf_section_display_enum VAR_2,
		    int VAR_3,
		    int VAR_4)
{
  unsigned char *VAR_5 = VAR_0->start;
  unsigned char *VAR_6 = VAR_5 + VAR_0->size;
  unsigned char *VAR_7;
  unsigned int VAR_8;
  unsigned int VAR_9 = 0;

  if ((VAR_3 || VAR_10 || VAR_11)
      && VAR_12 == 0
      && ! VAR_4)
    {
      dwarf_vma VAR_13;

      /* COMMENT_0 */
      for (VAR_7 = VAR_5, VAR_9 = 0; VAR_7 < VAR_6;
	   VAR_9 ++)
	{
	  /* COMMENT_1 */
                                                               
                                                                  
	  SAFE_BYTE_GET (VAR_13, VAR_7, 4, VAR_6);

	  if (VAR_13 == 0xffffffff)
	    {
	      SAFE_BYTE_GET (VAR_13, VAR_7 + 4, 8, VAR_6);
	      VAR_7 += VAR_13 + 12;
	    }
	  else if (VAR_13 >= 0xfffffff0 && VAR_13 < 0xffffffff)
	    {
	      warn (_(""Reserved length value (0x%s) found in section %s\n""),
		    dwarf_vmatoa (""x"", VAR_13), VAR_0->name);
	      return 0;
	    }
	  else
	    VAR_7 += VAR_13 + 4;

	  /* COMMENT_4 */
                                                            
                                                                   
	  if ((signed long) VAR_13 <= 0 || VAR_7 < VAR_5)
	    {
	      warn (_(""Corrupt unit length (0x%s) found in section %s\n""),
		    dwarf_vmatoa (""x"", VAR_13), VAR_0->name);
	      return 0;
	    }
	}

      if (VAR_9 == 0)
	{
	  error (_(""No comp units in %s section ?\n""), VAR_0->name);
	  return 0;
	}

      /* COMMENT_7 */
      VAR_14 = (debug_info *) cmalloc (VAR_9,
						  sizeof (* VAR_14));
      if (VAR_14 == NULL)
	{
	  error (_(""Not enough memory for a debug info array of %u entries\n""),
		 VAR_9);
	  VAR_15 = VAR_12 = 0;
	  return 0;
	}
      /* COMMENT_8 */
                                                                   
                                                                    
                                                                  
                                              
      memset (VAR_14, 0, VAR_9 * sizeof (*VAR_14));

      VAR_15 = VAR_9;
    }

  if (!VAR_3)
    {
      if (VAR_16 == 0)
	printf (_(""Contents of the %s section:\n\n""), VAR_0->name);

      load_debug_section (VAR_17, VAR_1);
      load_debug_section (VAR_18, VAR_1);
      load_debug_section (VAR_19, VAR_1);
      load_debug_section (VAR_20, VAR_1);
      load_debug_section (VAR_21, VAR_1);
      load_debug_section (VAR_22, VAR_1);
    }

  load_debug_section (VAR_2, VAR_1);
  if (VAR_23 [VAR_2].section.start == NULL)
    {
      warn (_(""Unable to locate %s section!\n""),
	    VAR_23 [VAR_2].section.name);
      return 0;
    }

  for (VAR_7 = VAR_5, VAR_8 = 0; VAR_5 < VAR_6; VAR_8++)
    {
      DWARF2_Internal_CompUnit VAR_24;
      unsigned char *VAR_25;
      unsigned char *VAR_26;
      int VAR_27, VAR_28, VAR_29;
      dwarf_vma VAR_30;
      unsigned int VAR_31;
      unsigned int VAR_32;
      dwarf_vma VAR_33 = 0;
      dwarf_vma VAR_34 = 0;
      dwarf_vma VAR_35 = 0;
      struct cu_tu_set *VAR_36;
      dwarf_vma VAR_37;
      size_t VAR_38;

      VAR_25 = VAR_5;

      SAFE_BYTE_GET_AND_INC (VAR_24.cu_length, VAR_25, 4, VAR_6);

      if (VAR_24.cu_length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (VAR_24.cu_length, VAR_25, 8, VAR_6);
	  VAR_31 = 8;
	  VAR_32 = 12;
	}
      else
	{
	  VAR_31 = 4;
	  VAR_32 = 4;
	}

      SAFE_BYTE_GET_AND_INC (VAR_24.cu_version, VAR_25, 2, VAR_6);

      VAR_30 = VAR_5 - VAR_7;

      VAR_36 = find_cu_tu_set_v2 (VAR_30, VAR_4);

      if (VAR_24.cu_version < 5)
	{
	  VAR_24.cu_unit_type = VAR_39;
	  /* COMMENT_13 */
	  VAR_24.cu_pointer_size = -1;
	}
      else
	{
	  SAFE_BYTE_GET_AND_INC (VAR_24.cu_unit_type, VAR_25, 1, VAR_6);
	  VAR_4 = (VAR_24.cu_unit_type == VAR_40);

	  SAFE_BYTE_GET_AND_INC (VAR_24.cu_pointer_size, VAR_25, 1, VAR_6);
	}

      SAFE_BYTE_GET_AND_INC (VAR_24.cu_abbrev_offset, VAR_25, VAR_31, VAR_6);

      if (VAR_36 == NULL)
	{
	  VAR_37 = 0;
	  VAR_38 = VAR_23 [VAR_2].section.size;
	}
      else
	{
	  VAR_37 = VAR_36->section_offsets [VAR_41];
	  VAR_38 = VAR_36->section_sizes [VAR_41];
	}

      if (VAR_24.cu_version < 5)
	SAFE_BYTE_GET_AND_INC (VAR_24.cu_pointer_size, VAR_25, 1, VAR_6);

      /* COMMENT_14 */
      if (VAR_24.cu_pointer_size < 2 || VAR_24.cu_pointer_size > 8)
	{
	  warn (_(""Invalid pointer size (%d) in compunit header, using %d instead\n""),
		VAR_24.cu_pointer_size, VAR_31);
	  VAR_24.cu_pointer_size = VAR_31;
	}

      if (VAR_4)
	{
	  SAFE_BYTE_GET64 (VAR_25, &VAR_33, &VAR_34, VAR_6);
	  VAR_25 += 8;
	  SAFE_BYTE_GET_AND_INC (VAR_35, VAR_25, VAR_31, VAR_6);
	}

      if ((VAR_3 || VAR_10 || VAR_11)
	  && VAR_12 == 0
	  && ! VAR_4)
	{
	  VAR_14 [VAR_8].cu_offset = VAR_30;
	  VAR_14 [VAR_8].pointer_size
	    = VAR_24.cu_pointer_size;
	  VAR_14 [VAR_8].offset_size = VAR_31;
	  VAR_14 [VAR_8].dwarf_version = VAR_24.cu_version;
	  VAR_14 [VAR_8].base_address = 0;
	  VAR_14 [VAR_8].addr_base = VAR_42;
	  VAR_14 [VAR_8].ranges_base = VAR_42;
	  VAR_14 [VAR_8].loc_offsets = NULL;
	  VAR_14 [VAR_8].have_frame_base = NULL;
	  VAR_14 [VAR_8].max_loc_offsets = 0;
	  VAR_14 [VAR_8].num_loc_offsets = 0;
	  VAR_14 [VAR_8].range_lists = NULL;
	  VAR_14 [VAR_8].max_range_lists= 0;
	  VAR_14 [VAR_8].num_range_lists = 0;
	}

      if (!VAR_3 && VAR_16 == 0)
	{
	  printf (_(""  Compilation Unit @ offset 0x%s:\n""),
		  dwarf_vmatoa (""x"", VAR_30));
	  printf (_(""   Length:        0x%s (%s)\n""),
		  dwarf_vmatoa (""x"", VAR_24.cu_length),
		  VAR_31 == 8 ? ""64-bit"" : ""32-bit"");
	  printf (_(""   Version:       %d\n""), VAR_24.cu_version);
	  printf (_(""   Abbrev Offset: 0x%s\n""),
		  dwarf_vmatoa (""x"", VAR_24.cu_abbrev_offset));
	  printf (_(""   Pointer Size:  %d\n""), VAR_24.cu_pointer_size);
	  if (VAR_4)
	    {
	      char VAR_43[64];

	      printf (_(""   Signature:     0x%s\n""),
		      dwarf_vmatoa64 (VAR_33, VAR_34,
				      VAR_43, sizeof (VAR_43)));
	      printf (_(""   Type Offset:   0x%s\n""),
		      dwarf_vmatoa (""x"", VAR_35));
	    }
	  if (VAR_36 != NULL)
	    {
	      dwarf_vma *VAR_44 = VAR_36->section_offsets;
	      size_t *VAR_45 = VAR_36->section_sizes;

	      printf (_(""   Section contributions:\n""));
	      printf (_(""    .debug_abbrev.dwo:       0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", VAR_44 [VAR_41]),
		      dwarf_vmatoa (""x"", VAR_45 [VAR_41]));
	      printf (_(""    .debug_line.dwo:         0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", VAR_44 [VAR_46]),
		      dwarf_vmatoa (""x"", VAR_45 [VAR_46]));
	      printf (_(""    .debug_loc.dwo:          0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", VAR_44 [VAR_47]),
		      dwarf_vmatoa (""x"", VAR_45 [VAR_47]));
	      printf (_(""    .debug_str_offsets.dwo:  0x%s  0x%s\n""),
		      dwarf_vmatoa (""x"", VAR_44 [VAR_48]),
		      dwarf_vmatoa (""x"", VAR_45 [VAR_48]));
	    }
	}

      if (VAR_30 + VAR_24.cu_length + VAR_32
	  > VAR_0->size)
	{
	  warn (_(""Debug info is corrupted, length of CU at %s""
		  "" extends beyond end of section (length = %s)\n""),
		dwarf_vmatoa (""x"", VAR_30),
		dwarf_vmatoa (""x"", VAR_24.cu_length));
	  VAR_9 = VAR_8;
	  break;
	}
      else if (VAR_24.cu_length + VAR_32 < VAR_32)
	{
	  warn (_(""Debug info is corrupted, length of CU at %s is negative (%s)\n""),
		dwarf_vmatoa (""x"", VAR_30),
		dwarf_vmatoa (""x"", VAR_24.cu_length));
	  VAR_9 = VAR_8;
	  break;
	}

      VAR_26 = VAR_25;
      VAR_5 += VAR_24.cu_length + VAR_32;

      if (VAR_5 > VAR_6)
	{
	  warn (_(""Debug info is corrupt.  CU at %s extends beyond end of section""),
		dwarf_vmatoa (""x"", VAR_30));
	  VAR_5 = VAR_6;
	}

      if (VAR_24.cu_version < 2 || VAR_24.cu_version > 5)
	{
	  warn (_(""CU at offset %s contains corrupt or ""
		  ""unsupported version number: %d.\n""),
		dwarf_vmatoa (""x"", VAR_30), VAR_24.cu_version);
	  continue;
	}

      if (VAR_24.cu_unit_type != VAR_39
	  && VAR_24.cu_unit_type != VAR_40)
	{
	  warn (_(""CU at offset %s contains corrupt or ""
		  ""unsupported unit type: %d.\n""),
		dwarf_vmatoa (""x"", VAR_30), VAR_24.cu_unit_type);
	  continue;
	}

      free_abbrevs ();

      /* COMMENT_15 */
      if (VAR_24.cu_abbrev_offset >= VAR_38)
	warn (_(""Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n""),
	      (unsigned long) VAR_24.cu_abbrev_offset,
	      (unsigned long) VAR_38);
      /* COMMENT_16 */
      else if ((VAR_37 + VAR_38)
	       > VAR_23 [VAR_2].section.size)
	warn (_(""Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n""),
	      (unsigned long) VAR_37 + VAR_38,
	      (unsigned long) VAR_23 [VAR_2].section.size);
      else
	process_abbrev_section
	  (((unsigned char *) VAR_23 [VAR_2].section.start
	    + VAR_37 + VAR_24.cu_abbrev_offset),
	   ((unsigned char *) VAR_23 [VAR_2].section.start
	    + VAR_37 + VAR_38));

      VAR_27 = 0;
      VAR_28 = VAR_27;
      VAR_29 = -1;
      while (VAR_26 < VAR_5)
	{
	  unsigned int VAR_49;
	  unsigned long VAR_50;
	  unsigned long VAR_51;
	  abbrev_entry *VAR_52;
	  abbrev_attr *VAR_53;
	  int VAR_54 = 1;

	  VAR_51 = VAR_26 - VAR_7;

	  VAR_50 = read_uleb128 (VAR_26, & VAR_49, VAR_5);
	  VAR_26 += VAR_49;

	  /* COMMENT_17 */
                            
	  if (VAR_50 == 0)
	    {
	      /* COMMENT_19 */
	      if (VAR_27 == 0 && VAR_5 == VAR_6)
		{
		  unsigned char *VAR_55;

		  for (VAR_55 = VAR_26; VAR_55 < VAR_5; VAR_55++)
		    if (*VAR_55 != 0)
		      break;
		  if (VAR_55 == VAR_5)
		    break;
		}

	      if (!VAR_3 && VAR_51 >= VAR_16
		  && (VAR_56 == -1
		      || VAR_27 < VAR_56))
		printf (_("" <%d><%lx>: Abbrev Number: 0\n""),
			VAR_27, VAR_51);

	      --VAR_27;
	      if (VAR_27 < 0)
		{
		  static unsigned VAR_57 = 0;

		  if (VAR_57 < 3)
		    {
		      warn (_(""Bogus end-of-siblings marker detected at offset %lx in %s section\n""),
			    VAR_51, VAR_0->name);
		      VAR_57 ++;
		      if (VAR_57 == 3)
			warn (_(""Further warnings about bogus end-of-sibling markers suppressed\n""));
		    }
		}
	      if (VAR_16 != 0 && VAR_27 < VAR_29)
		return 1;
	      continue;
	    }

	  if (!VAR_3)
	    {
	      if (VAR_16 != 0 && VAR_51 < VAR_16)
		VAR_54 = 0;
	      else
		{
		  if (VAR_16 != 0 && VAR_51 == VAR_16)
		    VAR_29 = VAR_27;
		  VAR_54 = (VAR_56 == -1
				 || VAR_27 < VAR_56);
		  if (VAR_54)
		    printf (_("" <%d><%lx>: Abbrev Number: %lu""),
			    VAR_27, VAR_51, VAR_50);
		  else if (VAR_56 == -1
			   || VAR_28 < VAR_56)
		    printf (_("" <%d><%lx>: ...\n""), VAR_27, VAR_51);
		  VAR_28 = VAR_27;
		}
	    }

	  /* COMMENT_20 */
                        
	  for (VAR_52 = VAR_58;
	       VAR_52 && VAR_52->entry != VAR_50;
	       VAR_52 = VAR_52->next)
	    continue;

	  if (VAR_52 == NULL)
	    {
	      if (!VAR_3 && VAR_54)
		{
		  printf (""\n"");
		  fflush (VAR_59);
		}
	      warn (_(""DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n""),
		    VAR_51, VAR_50);
	      return 0;
	    }

	  if (!VAR_3 && VAR_54)
	    printf ("" (%s)\n"", get_TAG_name (VAR_52->tag));

	  switch (VAR_52->tag)
	    {
	    default:
	      VAR_60 = 0;
	      break;
	    case VAR_61:
	      VAR_60 = 1;
	      break;
	    case VAR_62:
	    case VAR_63:
	      VAR_60 = 0;
	      /* COMMENT_22 */
	      VAR_64 = 0;
	      break;
	    }

	  debug_info *VAR_65 =
	    (VAR_14 && VAR_8 < VAR_15)
	    ? VAR_14 + VAR_8 : NULL;

	  assert (!VAR_65
		  || (VAR_65->num_loc_offsets
		      == VAR_65->num_loc_views));

	  for (VAR_53 = VAR_52->first_attr;
	       VAR_53 && VAR_53->attribute;
	       VAR_53 = VAR_53->next)
	    {
	      if (! VAR_3 && VAR_54)
		/* COMMENT_23 */
		printf (""    <%lx>"", (unsigned long)(VAR_26 - VAR_7));

	      VAR_26 = read_and_display_attr (VAR_53->attribute,
					    VAR_53->form,
					    VAR_53->implicit_const,
					    VAR_26,
					    VAR_6,
					    VAR_30,
					    VAR_24.cu_pointer_size,
					    VAR_31,
					    VAR_24.cu_version,
					    VAR_65,
					    VAR_3 || ! VAR_54,
					    VAR_0,
					    VAR_36);
	    }

	  /* COMMENT_24 */
                                                     
                 
	  if (VAR_65)
	    switch (VAR_65->num_loc_offsets - VAR_65->num_loc_views)
	      {
	      case 1:
		VAR_65->loc_views [VAR_65->num_loc_views] = VAR_66;
		VAR_65->num_loc_views++;
		assert (VAR_65->num_loc_views
			== VAR_65->num_loc_offsets);
		break;

	      case 0:
		break;

	      case -1:
		warn(_(""DIE has locviews without loclist\n""));
		VAR_65->num_loc_views--;
		break;

	      default:
		assert (0);
	    }

	  if (VAR_52->children)
	    ++VAR_27;
	}
    }

  /* COMMENT_27 */
                                                                  
  if ((VAR_3 || VAR_10 || VAR_11)
      && VAR_12 == 0
      && ! VAR_4)
    {
      if (VAR_9 > VAR_15)
	VAR_12 = VAR_15;
      else
	VAR_12 = VAR_9;
    }

  if (!VAR_3)
    printf (""\n"");

  return 1;
}",binutils-gdb/19485196044b2521af979f1e5c4a89bfb90fba0b/dwarf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -106,7 +106,7 @@
       int level, last_level, saved_level;
       dwarf_vma cu_offset;
       unsigned int offset_size;
-      int initial_length_size;
+      unsigned int initial_length_size;
       dwarf_vma signature_high = 0;
       dwarf_vma signature_low = 0;
       dwarf_vma type_offset = 0;
@@ -254,6 +254,15 @@
 	  num_units = unit;
 	  break;
 	}
+      else if (compunit.cu_length + initial_length_size < initial_length_size)
+	{
+	  warn (_(""Debug info is corrupted, length of CU at %s is negative (%s)\n""),
+		dwarf_vmatoa (""x"", cu_offset),
+		dwarf_vmatoa (""x"", compunit.cu_length));
+	  num_units = unit;
+	  break;
+	}
+
       tags = hdrptr;
       start += compunit.cu_length + initial_length_size;
 ","{'deleted_lines': ['      int initial_length_size;'], 'added_lines': ['      unsigned int initial_length_size;', '      else if (compunit.cu_length + initial_length_size < initial_length_size)', '\t{', '\t  warn (_(""Debug info is corrupted, length of CU at %s is negative (%s)\\n""),', '\t\tdwarf_vmatoa (""x"", cu_offset),', '\t\tdwarf_vmatoa (""x"", compunit.cu_length));', '\t  num_units = unit;', '\t  break;', '\t}', '']}",True,"process_debug_info in dwarf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite loop) via a crafted ELF file that contains a negative size value in a CU structure.",5.5,MEDIUM,1,valid,,5
CVE-2018-20481,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,poppler,,39a251b1b3a3343400a08e2f03c5518a26624626,https://cgit.freedesktop.org/poppler/poppler/commit/?id=39a251b1b3a3343400a08e2f03c5518a26624626,poppler/XRef.cc,XRef::getEntry,"XRefEntry *XRef::getEntry(int i, bool complainIfMissing)
{
if (i >= size || entries[i].type == xrefEntryNone) {
if ((!xRefStream) && mainXRefEntriesOffset) {
if (!parseEntry(mainXRefEntriesOffset + 20*i, &entries[i])) {
error(errSyntaxError, -1, ""Failed to parse XRef entry [{0:d}]."", i);
}
} else {
readXRefUntil(i);
if (unlikely(i >= size)) {
static XRefEntry dummy;
dummy.offset = 0;
dummy.gen = -1;
dummy.type = xrefEntryNone;
dummy.flags = 0;
return &dummy;
}
if (entries[i].type == xrefEntryNone) {
if (complainIfMissing) {
error(errSyntaxError, -1, ""Invalid XRef entry {0:d}"", i);
}
entries[i].type = xrefEntryFree;
}
}
}
return &entries[i];
}","XRefEntry *XRef::getEntry(int VAR_0, bool VAR_1)
{
if (VAR_0 >= VAR_2 || VAR_3[VAR_0].type == VAR_4) {
if ((!VAR_5) && VAR_6) {
if (!parseEntry(VAR_6 + 20*VAR_0, &VAR_3[VAR_0])) {
error(VAR_7, -1, ""Failed to parse XRef entry [{0:d}]."", VAR_0);
}
} else {
readXRefUntil(VAR_0);
if (unlikely(VAR_0 >= VAR_2)) {
static XRefEntry VAR_8;
VAR_8.offset = 0;
VAR_8.gen = -1;
VAR_8.type = VAR_4;
VAR_8.flags = 0;
return &VAR_8;
}
if (VAR_3[VAR_0].type == VAR_4) {
if (VAR_1) {
error(VAR_7, -1, ""Invalid XRef entry {0:d}"", VAR_0);
}
VAR_3[VAR_0].type = VAR_9;
}
}
}
return &VAR_3[VAR_0];
}",poppler/39a251b1b3a3343400a08e2f03c5518a26624626/XRef.cc/vul/before/0.json,"XRefEntry *XRef::getEntry(int i, bool complainIfMissing)
{
  if (i >= size || entries[i].type == xrefEntryNone) {

    if ((!xRefStream) && mainXRefEntriesOffset) {
      if (unlikely(i >= capacity)) {
	error(errInternal, -1, ""Request for out-of-bounds XRef entry [{0:d}]"", i);
	return &dummyXRefEntry;
      }

      if (!parseEntry(mainXRefEntriesOffset + 20*i, &entries[i])) {
        error(errSyntaxError, -1, ""Failed to parse XRef entry [{0:d}]."", i);
      }
    } else {
      // Read XRef tables until the entry we're looking for is found
      readXRefUntil(i);
      
      // We might have reconstructed the xref
      // Check again i is in bounds
      if (unlikely(i >= size)) {
	return &dummyXRefEntry;
      }

      if (entries[i].type == xrefEntryNone) {
        if (complainIfMissing) {
          error(errSyntaxError, -1, ""Invalid XRef entry {0:d}"", i);
        }
        entries[i].type = xrefEntryFree;
      }
    }
  }

  return &entries[i];
}","XRefEntry *XRef::getEntry(int VAR_0, bool VAR_1)
{
  if (VAR_0 >= VAR_2 || VAR_3[VAR_0].type == VAR_4) {

    if ((!VAR_5) && VAR_6) {
      if (unlikely(VAR_0 >= VAR_7)) {
	error(VAR_8, -1, ""Request for out-of-bounds XRef entry [{0:d}]"", VAR_0);
	return &VAR_9;
      }

      if (!parseEntry(VAR_6 + 20*VAR_0, &VAR_3[VAR_0])) {
        error(VAR_10, -1, ""Failed to parse XRef entry [{0:d}]."", VAR_0);
      }
    } else {
      /* COMMENT_0 */
      readXRefUntil(VAR_0);
      
      /* COMMENT_1 */
      /* COMMENT_2 */
      if (unlikely(VAR_0 >= VAR_2)) {
	return &VAR_9;
      }

      if (VAR_3[VAR_0].type == VAR_4) {
        if (VAR_1) {
          error(VAR_10, -1, ""Invalid XRef entry {0:d}"", VAR_0);
        }
        VAR_3[VAR_0].type = VAR_11;
      }
    }
  }

  return &VAR_3[VAR_0];
}",poppler/39a251b1b3a3343400a08e2f03c5518a26624626/XRef.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,11 @@
   if (i >= size || entries[i].type == xrefEntryNone) {
 
     if ((!xRefStream) && mainXRefEntriesOffset) {
+      if (unlikely(i >= capacity)) {
+	error(errInternal, -1, ""Request for out-of-bounds XRef entry [{0:d}]"", i);
+	return &dummyXRefEntry;
+      }
+
       if (!parseEntry(mainXRefEntriesOffset + 20*i, &entries[i])) {
         error(errSyntaxError, -1, ""Failed to parse XRef entry [{0:d}]."", i);
       }
@@ -13,12 +18,7 @@
       // We might have reconstructed the xref
       // Check again i is in bounds
       if (unlikely(i >= size)) {
-        static XRefEntry dummy;
-        dummy.offset = 0;
-        dummy.gen = -1;
-        dummy.type = xrefEntryNone;
-        dummy.flags = 0;
-        return &dummy;
+	return &dummyXRefEntry;
       }
 
       if (entries[i].type == xrefEntryNone) {","{'deleted_lines': ['        static XRefEntry dummy;', '        dummy.offset = 0;', '        dummy.gen = -1;', '        dummy.type = xrefEntryNone;', '        dummy.flags = 0;', '        return &dummy;'], 'added_lines': ['      if (unlikely(i >= capacity)) {', '\terror(errInternal, -1, ""Request for out-of-bounds XRef entry [{0:d}]"", i);', '\treturn &dummyXRefEntry;', '      }', '', '\treturn &dummyXRefEntry;']}",True,"XRef::getEntry in XRef.cc in Poppler 0.72.0 mishandles unallocated XRef entries, which allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted PDF document, when XRefEntry::setFlag in XRef.h is called from Parser::makeStream in Parser.cc.",6.5,MEDIUM,1,valid,,5
CVE-2020-14314,['CWE-125'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"If for any reason a directory passed to do_split() does not have enough
active entries to exceed half the size of the block, we can end up
iterating over all ""count"" entries without finding a split point.

In this case, count == move, and split will be zero, and we will
attempt a negative index into map[].

Guard against this by detecting this case, and falling back to
split-to-half-of-count instead; in this case we will still have
plenty of space (> half blocksize) in each split block.

Fixes: ef2b02d3e617 (""ext34: ensure do_split leaves enough free space in both blocks"")
Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Reviewed-by: Jan Kara <jack@suse.cz>
Link: https://lore.kernel.org/r/f53e246b-647c-64bb-16ec-135383c70ad7@redhat.com
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
",5872331b3d91820e14716632ebb56b1399b34fe1,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5872331b3d91820e14716632ebb56b1399b34fe1,fs/ext4/namei.c,do_split,"static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,
struct buffer_head **bh,struct dx_frame *frame,
struct dx_hash_info *hinfo)
{
unsigned blocksize = dir->i_sb->s_blocksize;
unsigned count, continued;
struct buffer_head *bh2;
ext4_lblk_t newblock;
u32 hash2;
struct dx_map_entry *map;
char *data1 = (*bh)->b_data, *data2;
unsigned split, move, size;
struct ext4_dir_entry_2 *de = NULL, *de2;
intcsum_size = 0;
interr = 0, i;
if (ext4_has_metadata_csum(dir->i_sb))
csum_size = sizeof(struct ext4_dir_entry_tail);
bh2 = ext4_append(handle, dir, &newblock);
if (IS_ERR(bh2)) {
brelse(*bh);
*bh = NULL;
return (struct ext4_dir_entry_2 *) bh2;
}
BUFFER_TRACE(*bh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, *bh);
if (err)
goto journal_error;
BUFFER_TRACE(frame->bh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, frame->bh);
if (err)
goto journal_error;
data2 = bh2->b_data;
map = (struct dx_map_entry *) (data2 + blocksize);
count = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,
blocksize, hinfo, map);
map -= count;
dx_sort_map(map, count);
size = 0;
move = 0;
for (i = count-1; i >= 0; i--) {
if (size + map[i].size/2 > blocksize/2)
break;
size += map[i].size;
move++;
}
split = count - move;
hash2 = map[split].hash;
continued = hash2 == map[split - 1].hash;
dxtrace(printk(KERN_INFO ""Split block %lu at %x, %i/%i\n"",
(unsigned long)dx_get_block(frame->at),
hash2, split, count-split));
de2 = dx_move_dirents(data1, data2, map + split, count - split,
blocksize);
de = dx_pack_dirents(data1, blocksize);
de->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -
(char *) de,
blocksize);
de2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -
(char *) de2,
blocksize);
if (csum_size) {
ext4_initialize_dirent_tail(*bh, blocksize);
ext4_initialize_dirent_tail(bh2, blocksize);
}
dxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,
blocksize, 1));
dxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,
blocksize, 1));
if (hinfo->hash >= hash2) {
swap(*bh, bh2);
de = de2;
}
dx_insert_block(frame, hash2 + continued, newblock);
err = ext4_handle_dirty_dirblock(handle, dir, bh2);
if (err)
goto journal_error;
err = ext4_handle_dirty_dx_node(handle, dir, frame->bh);
if (err)
goto journal_error;
brelse(bh2);
dxtrace(dx_show_index(""frame"", frame->entries));
return de;
journal_error:
brelse(*bh);
brelse(bh2);
*bh = NULL;
ext4_std_error(dir->i_sb, err);
return ERR_PTR(err);
}","static struct ext4_dir_entry_2 *do_split(handle_t *VAR_0, struct inode *VAR_1,
struct buffer_head **VAR_2,struct dx_frame *VAR_3,
struct dx_hash_info *VAR_4)
{
unsigned VAR_5 = VAR_1->i_sb->s_blocksize;
unsigned VAR_6, VAR_7;
struct buffer_head *VAR_8;
ext4_lblk_t VAR_9;
u32 VAR_10;
struct dx_map_entry *VAR_11;
char *VAR_12 = (*VAR_2)->b_data, *VAR_13;
unsigned VAR_14, VAR_15, VAR_16;
struct ext4_dir_entry_2 *VAR_17 = NULL, *VAR_18;
intVAR_19 = 0;
intVAR_20 = 0, VAR_21;
if (ext4_has_metadata_csum(VAR_1->i_sb))
VAR_19 = sizeof(struct ext4_dir_entry_tail);
VAR_8 = ext4_append(VAR_0, VAR_1, &VAR_9);
if (IS_ERR(VAR_8)) {
brelse(*VAR_2);
*VAR_2 = NULL;
return (struct ext4_dir_entry_2 *) VAR_8;
}
BUFFER_TRACE(*VAR_2, ""get_write_access"");
VAR_20 = ext4_journal_get_write_access(VAR_0, *VAR_2);
if (VAR_20)
goto journal_error;
BUFFER_TRACE(VAR_3->bh, ""get_write_access"");
VAR_20 = ext4_journal_get_write_access(VAR_0, VAR_3->bh);
if (VAR_20)
goto journal_error;
VAR_13 = VAR_8->b_data;
VAR_11 = (struct dx_map_entry *) (VAR_13 + VAR_5);
VAR_6 = dx_make_map(VAR_1, (struct ext4_dir_entry_2 *) VAR_12,
VAR_5, VAR_4, VAR_11);
VAR_11 -= VAR_6;
dx_sort_map(VAR_11, VAR_6);
VAR_16 = 0;
VAR_15 = 0;
for (VAR_21 = VAR_6-1; VAR_21 >= 0; VAR_21--) {
if (VAR_16 + VAR_11[VAR_21].size/2 > VAR_5/2)
break;
VAR_16 += VAR_11[VAR_21].size;
VAR_15++;
}
VAR_14 = VAR_6 - VAR_15;
VAR_10 = VAR_11[VAR_14].hash;
VAR_7 = VAR_10 == VAR_11[VAR_14 - 1].hash;
dxtrace(printk(KERN_INFO ""Split block %lu at %x, %i/%i\n"",
(unsigned long)dx_get_block(VAR_3->at),
VAR_10, VAR_14, VAR_6-VAR_14));
VAR_18 = dx_move_dirents(VAR_12, VAR_13, VAR_11 + VAR_14, VAR_6 - VAR_14,
VAR_5);
VAR_17 = dx_pack_dirents(VAR_12, VAR_5);
VAR_17->rec_len = ext4_rec_len_to_disk(VAR_12 + (VAR_5 - VAR_19) -
(char *) VAR_17,
VAR_5);
VAR_18->rec_len = ext4_rec_len_to_disk(VAR_13 + (VAR_5 - VAR_19) -
(char *) VAR_18,
VAR_5);
if (VAR_19) {
ext4_initialize_dirent_tail(*VAR_2, VAR_5);
ext4_initialize_dirent_tail(VAR_8, VAR_5);
}
dxtrace(dx_show_leaf(VAR_1, VAR_4, (struct ext4_dir_entry_2 *) VAR_12,
VAR_5, 1));
dxtrace(dx_show_leaf(VAR_1, VAR_4, (struct ext4_dir_entry_2 *) VAR_13,
VAR_5, 1));
if (VAR_4->hash >= VAR_10) {
swap(*VAR_2, VAR_8);
VAR_17 = VAR_18;
}
dx_insert_block(VAR_3, VAR_10 + VAR_7, VAR_9);
VAR_20 = ext4_handle_dirty_dirblock(VAR_0, VAR_1, VAR_8);
if (VAR_20)
goto journal_error;
VAR_20 = ext4_handle_dirty_dx_node(VAR_0, VAR_1, VAR_3->bh);
if (VAR_20)
goto journal_error;
brelse(VAR_8);
dxtrace(dx_show_index(""frame"", VAR_3->entries));
return VAR_17;
journal_error:
brelse(*VAR_2);
brelse(VAR_8);
*VAR_2 = NULL;
ext4_std_error(VAR_1->i_sb, VAR_20);
return ERR_PTR(VAR_20);
}",torvalds/linux/5872331b3d91820e14716632ebb56b1399b34fe1/namei.c/vul/before/0.json,"static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,
			struct buffer_head **bh,struct dx_frame *frame,
			struct dx_hash_info *hinfo)
{
	unsigned blocksize = dir->i_sb->s_blocksize;
	unsigned count, continued;
	struct buffer_head *bh2;
	ext4_lblk_t newblock;
	u32 hash2;
	struct dx_map_entry *map;
	char *data1 = (*bh)->b_data, *data2;
	unsigned split, move, size;
	struct ext4_dir_entry_2 *de = NULL, *de2;
	int	csum_size = 0;
	int	err = 0, i;

	if (ext4_has_metadata_csum(dir->i_sb))
		csum_size = sizeof(struct ext4_dir_entry_tail);

	bh2 = ext4_append(handle, dir, &newblock);
	if (IS_ERR(bh2)) {
		brelse(*bh);
		*bh = NULL;
		return (struct ext4_dir_entry_2 *) bh2;
	}

	BUFFER_TRACE(*bh, ""get_write_access"");
	err = ext4_journal_get_write_access(handle, *bh);
	if (err)
		goto journal_error;

	BUFFER_TRACE(frame->bh, ""get_write_access"");
	err = ext4_journal_get_write_access(handle, frame->bh);
	if (err)
		goto journal_error;

	data2 = bh2->b_data;

	/* create map in the end of data2 block */
	map = (struct dx_map_entry *) (data2 + blocksize);
	count = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,
			     blocksize, hinfo, map);
	map -= count;
	dx_sort_map(map, count);
	/* Ensure that neither split block is over half full */
	size = 0;
	move = 0;
	for (i = count-1; i >= 0; i--) {
		/* is more than half of this entry in 2nd half of the block? */
		if (size + map[i].size/2 > blocksize/2)
			break;
		size += map[i].size;
		move++;
	}
	/*
	 * map index at which we will split
	 *
	 * If the sum of active entries didn't exceed half the block size, just
	 * split it in half by count; each resulting block will have at least
	 * half the space free.
	 */
	if (i > 0)
		split = count - move;
	else
		split = count/2;

	hash2 = map[split].hash;
	continued = hash2 == map[split - 1].hash;
	dxtrace(printk(KERN_INFO ""Split block %lu at %x, %i/%i\n"",
			(unsigned long)dx_get_block(frame->at),
					hash2, split, count-split));

	/* Fancy dance to stay within two buffers */
	de2 = dx_move_dirents(data1, data2, map + split, count - split,
			      blocksize);
	de = dx_pack_dirents(data1, blocksize);
	de->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -
					   (char *) de,
					   blocksize);
	de2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -
					    (char *) de2,
					    blocksize);
	if (csum_size) {
		ext4_initialize_dirent_tail(*bh, blocksize);
		ext4_initialize_dirent_tail(bh2, blocksize);
	}

	dxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,
			blocksize, 1));
	dxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,
			blocksize, 1));

	/* Which block gets the new entry? */
	if (hinfo->hash >= hash2) {
		swap(*bh, bh2);
		de = de2;
	}
	dx_insert_block(frame, hash2 + continued, newblock);
	err = ext4_handle_dirty_dirblock(handle, dir, bh2);
	if (err)
		goto journal_error;
	err = ext4_handle_dirty_dx_node(handle, dir, frame->bh);
	if (err)
		goto journal_error;
	brelse(bh2);
	dxtrace(dx_show_index(""frame"", frame->entries));
	return de;

journal_error:
	brelse(*bh);
	brelse(bh2);
	*bh = NULL;
	ext4_std_error(dir->i_sb, err);
	return ERR_PTR(err);
}","static struct ext4_dir_entry_2 *do_split(handle_t *VAR_0, struct inode *VAR_1,
			struct buffer_head **VAR_2,struct dx_frame *VAR_3,
			struct dx_hash_info *VAR_4)
{
	unsigned VAR_5 = VAR_1->i_sb->s_blocksize;
	unsigned VAR_6, VAR_7;
	struct buffer_head *VAR_8;
	ext4_lblk_t VAR_9;
	u32 VAR_10;
	struct dx_map_entry *VAR_11;
	char *VAR_12 = (*VAR_2)->b_data, *VAR_13;
	unsigned VAR_14, VAR_15, VAR_16;
	struct ext4_dir_entry_2 *VAR_17 = NULL, *VAR_18;
	int	VAR_19 = 0;
	int	VAR_20 = 0, VAR_21;

	if (ext4_has_metadata_csum(VAR_1->i_sb))
		VAR_19 = sizeof(struct ext4_dir_entry_tail);

	VAR_8 = ext4_append(VAR_0, VAR_1, &VAR_9);
	if (IS_ERR(VAR_8)) {
		brelse(*VAR_2);
		*VAR_2 = NULL;
		return (struct ext4_dir_entry_2 *) VAR_8;
	}

	BUFFER_TRACE(*VAR_2, ""get_write_access"");
	VAR_20 = ext4_journal_get_write_access(VAR_0, *VAR_2);
	if (VAR_20)
		goto journal_error;

	BUFFER_TRACE(VAR_3->bh, ""get_write_access"");
	VAR_20 = ext4_journal_get_write_access(VAR_0, VAR_3->bh);
	if (VAR_20)
		goto journal_error;

	VAR_13 = VAR_8->b_data;

	/* COMMENT_0 */
	VAR_11 = (struct dx_map_entry *) (VAR_13 + VAR_5);
	VAR_6 = dx_make_map(VAR_1, (struct ext4_dir_entry_2 *) VAR_12,
			     VAR_5, VAR_4, VAR_11);
	VAR_11 -= VAR_6;
	dx_sort_map(VAR_11, VAR_6);
	/* COMMENT_1 */
	VAR_16 = 0;
	VAR_15 = 0;
	for (VAR_21 = VAR_6-1; VAR_21 >= 0; VAR_21--) {
		/* COMMENT_2 */
		if (VAR_16 + VAR_11[VAR_21].size/2 > VAR_5/2)
			break;
		VAR_16 += VAR_11[VAR_21].size;
		VAR_15++;
	}
	/* COMMENT_3 */
                                    
   
                                                                        
                                                                      
                        
    
	if (VAR_21 > 0)
		VAR_14 = VAR_6 - VAR_15;
	else
		VAR_14 = VAR_6/2;

	VAR_10 = VAR_11[VAR_14].hash;
	VAR_7 = VAR_10 == VAR_11[VAR_14 - 1].hash;
	dxtrace(printk(KERN_INFO ""Split block %lu at %x, %i/%i\n"",
			(unsigned long)dx_get_block(VAR_3->at),
					VAR_10, VAR_14, VAR_6-VAR_14));

	/* COMMENT_10 */
	VAR_18 = dx_move_dirents(VAR_12, VAR_13, VAR_11 + VAR_14, VAR_6 - VAR_14,
			      VAR_5);
	VAR_17 = dx_pack_dirents(VAR_12, VAR_5);
	VAR_17->rec_len = ext4_rec_len_to_disk(VAR_12 + (VAR_5 - VAR_19) -
					   (char *) VAR_17,
					   VAR_5);
	VAR_18->rec_len = ext4_rec_len_to_disk(VAR_13 + (VAR_5 - VAR_19) -
					    (char *) VAR_18,
					    VAR_5);
	if (VAR_19) {
		ext4_initialize_dirent_tail(*VAR_2, VAR_5);
		ext4_initialize_dirent_tail(VAR_8, VAR_5);
	}

	dxtrace(dx_show_leaf(VAR_1, VAR_4, (struct ext4_dir_entry_2 *) VAR_12,
			VAR_5, 1));
	dxtrace(dx_show_leaf(VAR_1, VAR_4, (struct ext4_dir_entry_2 *) VAR_13,
			VAR_5, 1));

	/* COMMENT_11 */
	if (VAR_4->hash >= VAR_10) {
		swap(*VAR_2, VAR_8);
		VAR_17 = VAR_18;
	}
	dx_insert_block(VAR_3, VAR_10 + VAR_7, VAR_9);
	VAR_20 = ext4_handle_dirty_dirblock(VAR_0, VAR_1, VAR_8);
	if (VAR_20)
		goto journal_error;
	VAR_20 = ext4_handle_dirty_dx_node(VAR_0, VAR_1, VAR_3->bh);
	if (VAR_20)
		goto journal_error;
	brelse(VAR_8);
	dxtrace(dx_show_index(""frame"", VAR_3->entries));
	return VAR_17;

journal_error:
	brelse(*VAR_2);
	brelse(VAR_8);
	*VAR_2 = NULL;
	ext4_std_error(VAR_1->i_sb, VAR_20);
	return ERR_PTR(VAR_20);
}",torvalds/linux/5872331b3d91820e14716632ebb56b1399b34fe1/namei.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,7 +42,7 @@
 			     blocksize, hinfo, map);
 	map -= count;
 	dx_sort_map(map, count);
-	/* Split the existing block in the middle, size-wise */
+	/* Ensure that neither split block is over half full */
 	size = 0;
 	move = 0;
 	for (i = count-1; i >= 0; i--) {
@@ -52,8 +52,18 @@
 		size += map[i].size;
 		move++;
 	}
-	/* map index at which we will split */
-	split = count - move;
+	/*
+	 * map index at which we will split
+	 *
+	 * If the sum of active entries didn't exceed half the block size, just
+	 * split it in half by count; each resulting block will have at least
+	 * half the space free.
+	 */
+	if (i > 0)
+		split = count - move;
+	else
+		split = count/2;
+
 	hash2 = map[split].hash;
 	continued = hash2 == map[split - 1].hash;
 	dxtrace(printk(KERN_INFO ""Split block %lu at %x, %i/%i\n"",","{'deleted_lines': ['\t/* Split the existing block in the middle, size-wise */', '\t/* map index at which we will split */', '\tsplit = count - move;'], 'added_lines': ['\t/* Ensure that neither split block is over half full */', '\t/*', '\t * map index at which we will split', '\t *', ""\t * If the sum of active entries didn't exceed half the block size, just"", '\t * split it in half by count; each resulting block will have at least', '\t * half the space free.', '\t */', '\tif (i > 0)', '\t\tsplit = count - move;', '\telse', '\t\tsplit = count/2;', '']}",True,"A memory out-of-bounds read flaw was found in the Linux kernel before 5.9-rc2 with the ext3/ext4 file system, in the way it accesses a directory with broken indexing. This flaw allows a local user to crash the system if the directory exists. The highest threat from this vulnerability is to system availability.",5.5,MEDIUM,1,valid,,5
CVE-2023-3611,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Lion says:
-------
In the QFQ scheduler a similar issue to CVE-2023-31436
persists.

Consider the following code in net/sched/sch_qfq.c:

static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,
                struct sk_buff **to_free)
{
     unsigned int len = qdisc_pkt_len(skb), gso_segs;

    // ...

     if (unlikely(cl->agg->lmax < len)) {
         pr_debug(""qfq: increasing maxpkt from %u to %u for class %u"",
              cl->agg->lmax, len, cl->common.classid);
         err = qfq_change_agg(sch, cl, cl->agg->class_weight, len);
         if (err) {
             cl->qstats.drops++;
             return qdisc_drop(skb, sch, to_free);
         }

    // ...

     }

Similarly to CVE-2023-31436, ""lmax"" is increased without any bounds
checks according to the packet length ""len"". Usually this would not
impose a problem because packet sizes are naturally limited.

This is however not the actual packet length, rather the
""qdisc_pkt_len(skb)"" which might apply size transformations according to
""struct qdisc_size_table"" as created by ""qdisc_get_stab()"" in
net/sched/sch_api.c if the TCA_STAB option was set when modifying the qdisc.

A user may choose virtually any size using such a table.

As a result the same issue as in CVE-2023-31436 can occur, allowing heap
out-of-bounds read / writes in the kmalloc-8192 cache.
-------

We can create the issue with the following commands:

tc qdisc add dev $DEV root handle 1: stab mtu 2048 tsize 512 mpu 0 \
overhead 999999999 linklayer ethernet qfq
tc class add dev $DEV parent 1: classid 1:1 htb rate 6mbit burst 15k
tc filter add dev $DEV parent 1: matchall classid 1:1
ping -I $DEV 1.1.1.2

This is caused by incorrectly assuming that qdisc_pkt_len() returns a
length within the QFQ_MIN_LMAX < len < QFQ_MAX_LMAX.

Fixes: 462dbc9101ac (""pkt_sched: QFQ Plus: fair-queueing service at DRR cost"")
Reported-by: Lion <nnamrec@gmail.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
Signed-off-by: Pedro Tammela <pctammela@mojatatu.com>
Reviewed-by: Simon Horman <simon.horman@corigine.com>
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
",3e337087c3b5805fe0b8a46ba622a962880b5d64,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3e337087c3b5805fe0b8a46ba622a962880b5d64,net/sched/sch_qfq.c,qfq_change_agg,"static int qfq_change_agg(struct Qdisc *sch, struct qfq_class *cl, u32 weight,
u32 lmax)
{
struct qfq_sched *q = qdisc_priv(sch);
struct qfq_aggregate *new_agg = qfq_find_agg(q, lmax, weight);
if (new_agg == NULL) { 
new_agg = kzalloc(sizeof(*new_agg), GFP_ATOMIC);
if (new_agg == NULL)
return -ENOBUFS;
qfq_init_agg(q, new_agg, lmax, weight);
}
qfq_deact_rm_from_agg(q, cl);
qfq_add_to_agg(q, new_agg, cl);
return 0;
}","static int qfq_change_agg(struct Qdisc *VAR_0, struct qfq_class *VAR_1, u32 VAR_2,
u32 VAR_3)
{
struct qfq_sched *VAR_4 = qdisc_priv(VAR_0);
struct qfq_aggregate *VAR_5 = qfq_find_agg(VAR_4, VAR_3, VAR_2);
if (VAR_5 == NULL) { 
VAR_5 = kzalloc(sizeof(*VAR_5), VAR_6);
if (VAR_5 == NULL)
return -VAR_7;
qfq_init_agg(VAR_4, VAR_5, VAR_3, VAR_2);
}
qfq_deact_rm_from_agg(VAR_4, VAR_1);
qfq_add_to_agg(VAR_4, VAR_5, VAR_1);
return 0;
}",torvalds/linux/3e337087c3b5805fe0b8a46ba622a962880b5d64/sch_qfq.c/vul/before/0.json,"static int qfq_change_agg(struct Qdisc *sch, struct qfq_class *cl, u32 weight,
			   u32 lmax)
{
	struct qfq_sched *q = qdisc_priv(sch);
	struct qfq_aggregate *new_agg;

	/* 'lmax' can range from [QFQ_MIN_LMAX, pktlen + stab overhead] */
	if (lmax > QFQ_MAX_LMAX)
		return -EINVAL;

	new_agg = qfq_find_agg(q, lmax, weight);
	if (new_agg == NULL) { /* create new aggregate */
		new_agg = kzalloc(sizeof(*new_agg), GFP_ATOMIC);
		if (new_agg == NULL)
			return -ENOBUFS;
		qfq_init_agg(q, new_agg, lmax, weight);
	}
	qfq_deact_rm_from_agg(q, cl);
	qfq_add_to_agg(q, new_agg, cl);

	return 0;
}","static int qfq_change_agg(struct Qdisc *VAR_0, struct qfq_class *VAR_1, u32 VAR_2,
			   u32 VAR_3)
{
	struct qfq_sched *VAR_4 = qdisc_priv(VAR_0);
	struct qfq_aggregate *VAR_5;

	/* COMMENT_0 */
	if (VAR_3 > VAR_6)
		return -VAR_7;

	VAR_5 = qfq_find_agg(VAR_4, VAR_3, VAR_2);
	if (VAR_5 == NULL) { /* COMMENT_1 */
		VAR_5 = kzalloc(sizeof(*VAR_5), VAR_8);
		if (VAR_5 == NULL)
			return -VAR_9;
		qfq_init_agg(VAR_4, VAR_5, VAR_3, VAR_2);
	}
	qfq_deact_rm_from_agg(VAR_4, VAR_1);
	qfq_add_to_agg(VAR_4, VAR_5, VAR_1);

	return 0;
}",torvalds/linux/3e337087c3b5805fe0b8a46ba622a962880b5d64/sch_qfq.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,13 @@
 			   u32 lmax)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
-	struct qfq_aggregate *new_agg = qfq_find_agg(q, lmax, weight);
+	struct qfq_aggregate *new_agg;
 
+	/* 'lmax' can range from [QFQ_MIN_LMAX, pktlen + stab overhead] */
+	if (lmax > QFQ_MAX_LMAX)
+		return -EINVAL;
+
+	new_agg = qfq_find_agg(q, lmax, weight);
 	if (new_agg == NULL) { /* create new aggregate */
 		new_agg = kzalloc(sizeof(*new_agg), GFP_ATOMIC);
 		if (new_agg == NULL)","{'deleted_lines': ['\tstruct qfq_aggregate *new_agg = qfq_find_agg(q, lmax, weight);'], 'added_lines': ['\tstruct qfq_aggregate *new_agg;', ""\t/* 'lmax' can range from [QFQ_MIN_LMAX, pktlen + stab overhead] */"", '\tif (lmax > QFQ_MAX_LMAX)', '\t\treturn -EINVAL;', '', '\tnew_agg = qfq_find_agg(q, lmax, weight);']}",True,"An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.

The qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks.

We recommend upgrading past commit 3e337087c3b5805fe0b8a46ba622a962880b5d64.

",7.8,HIGH,2,valid,,5
CVE-2023-3776,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"In the event of a failure in tcf_change_indev(), fw_set_parms() will
immediately return an error after incrementing or decrementing
reference counter in tcf_bind_filter().  If attacker can control
reference counter to zero and make reference freed, leading to
use after free.

In order to prevent this, move the point of possible failure above the
point where the TC_FW_CLASSID is handled.

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Reported-by: M A Ramdhan <ramdhan@starlabs.sg>
Signed-off-by: M A Ramdhan <ramdhan@starlabs.sg>
Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
Reviewed-by: Pedro Tammela <pctammela@mojatatu.com>
Message-ID: <20230705161530.52003-1-ramdhan@starlabs.sg>
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",0323bce598eea038714f941ce2b22541c46d488f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=0323bce598eea038714f941ce2b22541c46d488f,net/sched/cls_fw.c,fw_set_parms,"static int fw_set_parms(struct net *net, struct tcf_proto *tp,
struct fw_filter *f, struct nlattr **tb,
struct nlattr **tca, unsigned long base, u32 flags,
struct netlink_ext_ack *extack)
{
struct fw_head *head = rtnl_dereference(tp->root);
u32 mask;
int err;
err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags,
extack);
if (err < 0)
return err;
if (tb[TCA_FW_CLASSID]) {
f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);
tcf_bind_filter(tp, &f->res, base);
}
if (tb[TCA_FW_INDEV]) {
int ret;
ret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack);
if (ret < 0)
return ret;
f->ifindex = ret;
}
err = -EINVAL;
if (tb[TCA_FW_MASK]) {
mask = nla_get_u32(tb[TCA_FW_MASK]);
if (mask != head->mask)
return err;
} else if (head->mask != 0xFFFFFFFF)
return err;
return 0;
}","static int fw_set_parms(struct net *net, struct tcf_proto *VAR_0,
struct fw_filter *VAR_1, struct nlattr **VAR_2,
struct nlattr **VAR_3, unsigned long VAR_4, u32 VAR_5,
struct netlink_ext_ack *VAR_6)
{
struct fw_head *VAR_7 = rtnl_dereference(VAR_0->root);
u32 VAR_8;
int VAR_9;
VAR_9 = tcf_exts_validate(net, VAR_0, VAR_2, VAR_3[VAR_10], &VAR_1->exts, VAR_5,
VAR_6);
if (VAR_9 < 0)
return VAR_9;
if (VAR_2[VAR_11]) {
VAR_1->res.classid = nla_get_u32(VAR_2[VAR_11]);
tcf_bind_filter(VAR_0, &VAR_1->res, VAR_4);
}
if (VAR_2[VAR_12]) {
int VAR_13;
VAR_13 = tcf_change_indev(net, VAR_2[VAR_12], VAR_6);
if (VAR_13 < 0)
return VAR_13;
VAR_1->ifindex = VAR_13;
}
VAR_9 = -VAR_14;
if (VAR_2[VAR_15]) {
VAR_8 = nla_get_u32(VAR_2[VAR_15]);
if (VAR_8 != VAR_7->mask)
return VAR_9;
} else if (VAR_7->mask != 0xFFFFFFFF)
return VAR_9;
return 0;
}",torvalds/linux/0323bce598eea038714f941ce2b22541c46d488f/cls_fw.c/vul/before/0.json,"static int fw_set_parms(struct net *net, struct tcf_proto *tp,
			struct fw_filter *f, struct nlattr **tb,
			struct nlattr **tca, unsigned long base, u32 flags,
			struct netlink_ext_ack *extack)
{
	struct fw_head *head = rtnl_dereference(tp->root);
	u32 mask;
	int err;

	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags,
				extack);
	if (err < 0)
		return err;

	if (tb[TCA_FW_INDEV]) {
		int ret;
		ret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack);
		if (ret < 0)
			return ret;
		f->ifindex = ret;
	}

	err = -EINVAL;
	if (tb[TCA_FW_MASK]) {
		mask = nla_get_u32(tb[TCA_FW_MASK]);
		if (mask != head->mask)
			return err;
	} else if (head->mask != 0xFFFFFFFF)
		return err;

	if (tb[TCA_FW_CLASSID]) {
		f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);
		tcf_bind_filter(tp, &f->res, base);
	}

	return 0;
}","static int fw_set_parms(struct net *net, struct tcf_proto *VAR_0,
			struct fw_filter *VAR_1, struct nlattr **VAR_2,
			struct nlattr **VAR_3, unsigned long VAR_4, u32 VAR_5,
			struct netlink_ext_ack *VAR_6)
{
	struct fw_head *VAR_7 = rtnl_dereference(VAR_0->root);
	u32 VAR_8;
	int VAR_9;

	VAR_9 = tcf_exts_validate(net, VAR_0, VAR_2, VAR_3[VAR_10], &VAR_1->exts, VAR_5,
				VAR_6);
	if (VAR_9 < 0)
		return VAR_9;

	if (VAR_2[VAR_11]) {
		int VAR_12;
		VAR_12 = tcf_change_indev(net, VAR_2[VAR_11], VAR_6);
		if (VAR_12 < 0)
			return VAR_12;
		VAR_1->ifindex = VAR_12;
	}

	VAR_9 = -VAR_13;
	if (VAR_2[VAR_14]) {
		VAR_8 = nla_get_u32(VAR_2[VAR_14]);
		if (VAR_8 != VAR_7->mask)
			return VAR_9;
	} else if (VAR_7->mask != 0xFFFFFFFF)
		return VAR_9;

	if (VAR_2[VAR_15]) {
		VAR_1->res.classid = nla_get_u32(VAR_2[VAR_15]);
		tcf_bind_filter(VAR_0, &VAR_1->res, VAR_4);
	}

	return 0;
}",torvalds/linux/0323bce598eea038714f941ce2b22541c46d488f/cls_fw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,11 +11,6 @@
 				extack);
 	if (err < 0)
 		return err;
-
-	if (tb[TCA_FW_CLASSID]) {
-		f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);
-		tcf_bind_filter(tp, &f->res, base);
-	}
 
 	if (tb[TCA_FW_INDEV]) {
 		int ret;
@@ -33,5 +28,10 @@
 	} else if (head->mask != 0xFFFFFFFF)
 		return err;
 
+	if (tb[TCA_FW_CLASSID]) {
+		f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);
+		tcf_bind_filter(tp, &f->res, base);
+	}
+
 	return 0;
 }","{'deleted_lines': ['', '\tif (tb[TCA_FW_CLASSID]) {', '\t\tf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);', '\t\ttcf_bind_filter(tp, &f->res, base);', '\t}'], 'added_lines': ['\tif (tb[TCA_FW_CLASSID]) {', '\t\tf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);', '\t\ttcf_bind_filter(tp, &f->res, base);', '\t}', '']}",True,"A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.

If tcf_change_indev() fails, fw_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.

We recommend upgrading past commit 0323bce598eea038714f941ce2b22541c46d488f.

",7.8,HIGH,2,valid,,5
CVE-2023-3812,"['CWE-787', 'CWE-416']",CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Recently, we got two syzkaller problems because of oversize packet
when napi frags enabled.

One of the problems is because the first seg size of the iov_iter
from user space is very big, it is 2147479538 which is bigger than
the threshold value for bail out early in __alloc_pages(). And
skb->pfmemalloc is true, __kmalloc_reserve() would use pfmemalloc
reserves without __GFP_NOWARN flag. Thus we got a warning as following:

========================================================
WARNING: CPU: 1 PID: 17965 at mm/page_alloc.c:5295 __alloc_pages+0x1308/0x16c4 mm/page_alloc.c:5295
...
Call trace:
 __alloc_pages+0x1308/0x16c4 mm/page_alloc.c:5295
 __alloc_pages_node include/linux/gfp.h:550 [inline]
 alloc_pages_node include/linux/gfp.h:564 [inline]
 kmalloc_large_node+0x94/0x350 mm/slub.c:4038
 __kmalloc_node_track_caller+0x620/0x8e4 mm/slub.c:4545
 __kmalloc_reserve.constprop.0+0x1e4/0x2b0 net/core/skbuff.c:151
 pskb_expand_head+0x130/0x8b0 net/core/skbuff.c:1654
 __skb_grow include/linux/skbuff.h:2779 [inline]
 tun_napi_alloc_frags+0x144/0x610 drivers/net/tun.c:1477
 tun_get_user+0x31c/0x2010 drivers/net/tun.c:1835
 tun_chr_write_iter+0x98/0x100 drivers/net/tun.c:2036

The other problem is because odd IPv6 packets without NEXTHDR_NONE
extension header and have big packet length, it is 2127925 which is
bigger than ETH_MAX_MTU(65535). After ipv6_gso_pull_exthdrs() in
ipv6_gro_receive(), network_header offset and transport_header offset
are all bigger than U16_MAX. That would trigger skb->network_header
and skb->transport_header overflow error, because they are all '__u16'
type. Eventually, it would affect the value for __skb_push(skb, value),
and make it be a big value. After __skb_push() in ipv6_gro_receive(),
skb->data would less than skb->head, an out of bounds memory bug occurred.
That would trigger the problem as following:

==================================================================
BUG: KASAN: use-after-free in eth_type_trans+0x100/0x260
...
Call trace:
 dump_backtrace+0xd8/0x130
 show_stack+0x1c/0x50
 dump_stack_lvl+0x64/0x7c
 print_address_description.constprop.0+0xbc/0x2e8
 print_report+0x100/0x1e4
 kasan_report+0x80/0x120
 __asan_load8+0x78/0xa0
 eth_type_trans+0x100/0x260
 napi_gro_frags+0x164/0x550
 tun_get_user+0xda4/0x1270
 tun_chr_write_iter+0x74/0x130
 do_iter_readv_writev+0x130/0x1ec
 do_iter_write+0xbc/0x1e0
 vfs_writev+0x13c/0x26c

To fix the problems, restrict the packet size less than
(ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN) which has considered reserved
skb space in napi_alloc_skb() because transport_header is an offset from
skb->head. Add len check in tun_napi_alloc_frags() simply.

Fixes: 90e33d459407 (""tun: enable napi_gro_frags() for TUN/TAP driver"")
Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20221029094101.1653855-1-william.xuanziyang@huawei.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",363a5328f4b0517e59572118ccfb7c626d81dca9,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=363a5328f4b0,drivers/net/tun.c,tun_napi_alloc_frags,"static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,
size_t len,
const struct iov_iter *it)
{
struct sk_buff *skb;
size_t linear;
int err;
int i;
if (it->nr_segs > MAX_SKB_FRAGS + 1)
return ERR_PTR(-EMSGSIZE);
local_bh_disable();
skb = napi_get_frags(&tfile->napi);
local_bh_enable();
if (!skb)
return ERR_PTR(-ENOMEM);
linear = iov_iter_single_seg_count(it);
err = __skb_grow(skb, linear);
if (err)
goto free;
skb->len = len;
skb->data_len = len - linear;
skb->truesize += skb->data_len;
for (i = 1; i < it->nr_segs; i++) {
size_t fragsz = it->iov[i].iov_len;
struct page *page;
void *frag;
if (fragsz == 0 || fragsz > PAGE_SIZE) {
err = -EINVAL;
goto free;
}
frag = netdev_alloc_frag(fragsz);
if (!frag) {
err = -ENOMEM;
goto free;
}
page = virt_to_head_page(frag);
skb_fill_page_desc(skb, i - 1, page,
frag - page_address(page), fragsz);
}
return skb;
free:
napi_free_frags(&tfile->napi);
return ERR_PTR(err);
}","static struct sk_buff *tun_napi_alloc_frags(struct tun_file *VAR_0,
size_t VAR_1,
const struct iov_iter *VAR_2)
{
struct sk_buff *VAR_3;
size_t VAR_4;
int VAR_5;
int VAR_6;
if (VAR_2->nr_segs > VAR_7 + 1)
return ERR_PTR(-VAR_8);
local_bh_disable();
VAR_3 = napi_get_frags(&VAR_0->napi);
local_bh_enable();
if (!VAR_3)
return ERR_PTR(-VAR_9);
VAR_4 = iov_iter_single_seg_count(VAR_2);
VAR_5 = __skb_grow(VAR_3, VAR_4);
if (VAR_5)
goto free;
VAR_3->len = VAR_1;
VAR_3->data_len = VAR_1 - VAR_4;
VAR_3->truesize += VAR_3->data_len;
for (VAR_6 = 1; VAR_6 < VAR_2->nr_segs; VAR_6++) {
size_t VAR_10 = VAR_2->iov[VAR_6].iov_len;
struct page *page;
void *VAR_11;
if (VAR_10 == 0 || VAR_10 > VAR_12) {
VAR_5 = -VAR_13;
goto free;
}
VAR_11 = netdev_alloc_frag(VAR_10);
if (!VAR_11) {
VAR_5 = -VAR_9;
goto free;
}
page = virt_to_head_page(VAR_11);
skb_fill_page_desc(VAR_3, VAR_6 - 1, page,
VAR_11 - page_address(page), VAR_10);
}
return VAR_3;
free:
napi_free_frags(&VAR_0->napi);
return ERR_PTR(VAR_5);
}",torvalds/linux/363a5328f4b0517e59572118ccfb7c626d81dca9/tun.c/vul/before/0.json,"static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,
					    size_t len,
					    const struct iov_iter *it)
{
	struct sk_buff *skb;
	size_t linear;
	int err;
	int i;

	if (it->nr_segs > MAX_SKB_FRAGS + 1 ||
	    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))
		return ERR_PTR(-EMSGSIZE);

	local_bh_disable();
	skb = napi_get_frags(&tfile->napi);
	local_bh_enable();
	if (!skb)
		return ERR_PTR(-ENOMEM);

	linear = iov_iter_single_seg_count(it);
	err = __skb_grow(skb, linear);
	if (err)
		goto free;

	skb->len = len;
	skb->data_len = len - linear;
	skb->truesize += skb->data_len;

	for (i = 1; i < it->nr_segs; i++) {
		size_t fragsz = it->iov[i].iov_len;
		struct page *page;
		void *frag;

		if (fragsz == 0 || fragsz > PAGE_SIZE) {
			err = -EINVAL;
			goto free;
		}
		frag = netdev_alloc_frag(fragsz);
		if (!frag) {
			err = -ENOMEM;
			goto free;
		}
		page = virt_to_head_page(frag);
		skb_fill_page_desc(skb, i - 1, page,
				   frag - page_address(page), fragsz);
	}

	return skb;
free:
	/* frees skb and all frags allocated with napi_alloc_frag() */
	napi_free_frags(&tfile->napi);
	return ERR_PTR(err);
}","static struct sk_buff *tun_napi_alloc_frags(struct tun_file *VAR_0,
					    size_t VAR_1,
					    const struct iov_iter *VAR_2)
{
	struct sk_buff *VAR_3;
	size_t VAR_4;
	int VAR_5;
	int VAR_6;

	if (VAR_2->nr_segs > VAR_7 + 1 ||
	    VAR_1 > (VAR_8 - VAR_9 - VAR_10))
		return ERR_PTR(-VAR_11);

	local_bh_disable();
	VAR_3 = napi_get_frags(&VAR_0->napi);
	local_bh_enable();
	if (!VAR_3)
		return ERR_PTR(-VAR_12);

	VAR_4 = iov_iter_single_seg_count(VAR_2);
	VAR_5 = __skb_grow(VAR_3, VAR_4);
	if (VAR_5)
		goto free;

	VAR_3->len = VAR_1;
	VAR_3->data_len = VAR_1 - VAR_4;
	VAR_3->truesize += VAR_3->data_len;

	for (VAR_6 = 1; VAR_6 < VAR_2->nr_segs; VAR_6++) {
		size_t VAR_13 = VAR_2->iov[VAR_6].iov_len;
		struct page *page;
		void *VAR_14;

		if (VAR_13 == 0 || VAR_13 > VAR_15) {
			VAR_5 = -VAR_16;
			goto free;
		}
		VAR_14 = netdev_alloc_frag(VAR_13);
		if (!VAR_14) {
			VAR_5 = -VAR_12;
			goto free;
		}
		page = virt_to_head_page(VAR_14);
		skb_fill_page_desc(VAR_3, VAR_6 - 1, page,
				   VAR_14 - page_address(page), VAR_13);
	}

	return VAR_3;
free:
	/* COMMENT_0 */
	napi_free_frags(&VAR_0->napi);
	return ERR_PTR(VAR_5);
}",torvalds/linux/363a5328f4b0517e59572118ccfb7c626d81dca9/tun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,8 @@
 	int err;
 	int i;
 
-	if (it->nr_segs > MAX_SKB_FRAGS + 1)
+	if (it->nr_segs > MAX_SKB_FRAGS + 1 ||
+	    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))
 		return ERR_PTR(-EMSGSIZE);
 
 	local_bh_disable();","{'deleted_lines': ['\tif (it->nr_segs > MAX_SKB_FRAGS + 1)'], 'added_lines': ['\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||', '\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))']}",True,An out-of-bounds memory access flaw was found in the Linux kernels TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.,7.8,HIGH,2,valid,,5
CVE-2016-1635,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix re-entrancy and lifetime issue in RenderFrameObserverNatives::OnDocumentElementCreated

BUG=585268,568130

Review URL: https://codereview.chromium.org/1684953002

Cr-Commit-Position: refs/heads/master@{#374758}
",5a15b72a270b514cd442872221a788a303bdaa88,https://chromium.googlesource.com/chromium/src/+/5a15b72a270b514cd442872221a788a303bdaa88,extensions/renderer/render_frame_observer_natives.cc,DidFailProvisionalLoad,"void DidFailProvisionalLoad(const blink::WebURLError& error) override {
CallbackAndDie(false);
}","void DidFailProvisionalLoad(const blink::WebURLError& VAR_0) override {
CallbackAndDie(false);
}",,"void DidFailProvisionalLoad(const blink::WebURLError& error) override {
    // Use PostTask to avoid running user scripts while handling this
    // DidFailProvisionalLoad notification.
    base::MessageLoop::current()->PostTask(FROM_HERE,
                                           base::Bind(callback_, false));
    delete this;
  }","void DidFailProvisionalLoad(const blink::WebURLError& VAR_0) override {
    /* COMMENT_0 */
    /* COMMENT_1 */
    base::MessageLoop::current()->PostTask(VAR_1,
                                           base::Bind(VAR_2, false));
    delete this;
  }",,"--- func_before
+++ func_after
@@ -1,3 +1,7 @@
 void DidFailProvisionalLoad(const blink::WebURLError& error) override {
-    CallbackAndDie(false);
+    // Use PostTask to avoid running user scripts while handling this
+    // DidFailProvisionalLoad notification.
+    base::MessageLoop::current()->PostTask(FROM_HERE,
+                                           base::Bind(callback_, false));
+    delete this;
   }","{'deleted_lines': ['    CallbackAndDie(false);'], 'added_lines': ['    // Use PostTask to avoid running user scripts while handling this', '    // DidFailProvisionalLoad notification.', '    base::MessageLoop::current()->PostTask(FROM_HERE,', '                                           base::Bind(callback_, false));', '    delete this;']}",True,"extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",9.8,CRITICAL,3,valid,,5
CVE-2016-1635,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix re-entrancy and lifetime issue in RenderFrameObserverNatives::OnDocumentElementCreated

BUG=585268,568130

Review URL: https://codereview.chromium.org/1684953002

Cr-Commit-Position: refs/heads/master@{#374758}
",5a15b72a270b514cd442872221a788a303bdaa88,https://chromium.googlesource.com/chromium/src/+/5a15b72a270b514cd442872221a788a303bdaa88,extensions/renderer/render_frame_observer_natives.cc,RenderFrameObserverNatives::OnDocumentElementCreated,"void RenderFrameObserverNatives::OnDocumentElementCreated(
const v8::FunctionCallbackInfo<v8::Value>& args) {
CHECK(args.Length() == 2);
CHECK(args[0]->IsInt32());
CHECK(args[1]->IsFunction());
int frame_id = args[0]->Int32Value();
content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id);
if (!frame) {
LOG(WARNING) << ""No render frame found to register LoadWatcher."";
return;
}
new LoadWatcher(context(), frame, args[1].As<v8::Function>());
args.GetReturnValue().Set(true);
}","void RenderFrameObserverNatives::OnDocumentElementCreated(
const v8::FunctionCallbackInfo<v8::Value>& VAR_0) {
CHECK(VAR_0.Length() == 2);
CHECK(VAR_0[0]->IsInt32());
CHECK(VAR_0[1]->IsFunction());
int VAR_1 = VAR_0[0]->Int32Value();
content::RenderFrame* VAR_2 = content::RenderFrame::FromRoutingID(VAR_1);
if (!VAR_2) {
LOG(VAR_3) << ""No render frame found to register LoadWatcher."";
return;
}
new LoadWatcher(context(), VAR_2, VAR_0[1].As<v8::Function>());
VAR_0.GetReturnValue().Set(true);
}",chromium/5a15b72a270b514cd442872221a788a303bdaa88/render_frame_observer_natives.cc/vul/before/1.json,"void RenderFrameObserverNatives::OnDocumentElementCreated(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsFunction());

  int frame_id = args[0]->Int32Value();

  content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id);
  if (!frame) {
    LOG(WARNING) << ""No render frame found to register LoadWatcher."";
    return;
  }

  v8::Global<v8::Function> v8_callback(context()->isolate(),
                                       args[1].As<v8::Function>());
  base::Callback<void(bool)> callback(
      base::Bind(&RenderFrameObserverNatives::InvokeCallback,
                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&v8_callback)));
  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {
    // If the document element is already created, then we can call the callback
    // immediately (though use PostTask to ensure that the callback is called
    // asynchronously).
    base::MessageLoop::current()->PostTask(FROM_HERE,
                                           base::Bind(callback, true));
  } else {
    new LoadWatcher(frame, callback);
  }

  args.GetReturnValue().Set(true);
}","void RenderFrameObserverNatives::OnDocumentElementCreated(
    const v8::FunctionCallbackInfo<v8::Value>& VAR_0) {
  CHECK(VAR_0.Length() == 2);
  CHECK(VAR_0[0]->IsInt32());
  CHECK(VAR_0[1]->IsFunction());

  int VAR_1 = VAR_0[0]->Int32Value();

  content::RenderFrame* VAR_2 = content::RenderFrame::FromRoutingID(VAR_1);
  if (!VAR_2) {
    LOG(VAR_3) << ""No render frame found to register LoadWatcher."";
    return;
  }

  v8::Global<v8::Function> VAR_4(context()->isolate(),
                                       VAR_0[1].As<v8::Function>());
  base::Callback<void(bool)> VAR_5(
      base::Bind(&RenderFrameObserverNatives::InvokeCallback,
                 VAR_6.GetWeakPtr(), base::Passed(&VAR_4)));
  if (ExtensionFrameHelper::Get(VAR_2)->did_create_current_document_element()) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    base::MessageLoop::current()->PostTask(VAR_7,
                                           base::Bind(VAR_5, true));
  } else {
    new LoadWatcher(VAR_2, VAR_5);
  }

  VAR_0.GetReturnValue().Set(true);
}",chromium/5a15b72a270b514cd442872221a788a303bdaa88/render_frame_observer_natives.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,7 +12,20 @@
     return;
   }
 
-  new LoadWatcher(context(), frame, args[1].As<v8::Function>());
+  v8::Global<v8::Function> v8_callback(context()->isolate(),
+                                       args[1].As<v8::Function>());
+  base::Callback<void(bool)> callback(
+      base::Bind(&RenderFrameObserverNatives::InvokeCallback,
+                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&v8_callback)));
+  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {
+    // If the document element is already created, then we can call the callback
+    // immediately (though use PostTask to ensure that the callback is called
+    // asynchronously).
+    base::MessageLoop::current()->PostTask(FROM_HERE,
+                                           base::Bind(callback, true));
+  } else {
+    new LoadWatcher(frame, callback);
+  }
 
   args.GetReturnValue().Set(true);
 }","{'deleted_lines': ['  new LoadWatcher(context(), frame, args[1].As<v8::Function>());'], 'added_lines': ['  v8::Global<v8::Function> v8_callback(context()->isolate(),', '                                       args[1].As<v8::Function>());', '  base::Callback<void(bool)> callback(', '      base::Bind(&RenderFrameObserverNatives::InvokeCallback,', '                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&v8_callback)));', '  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {', '    // If the document element is already created, then we can call the callback', '    // immediately (though use PostTask to ensure that the callback is called', '    // asynchronously).', '    base::MessageLoop::current()->PostTask(FROM_HERE,', '                                           base::Bind(callback, true));', '  } else {', '    new LoadWatcher(frame, callback);', '  }']}",True,"extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",9.8,CRITICAL,3,valid,,5
CVE-2016-1635,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix re-entrancy and lifetime issue in RenderFrameObserverNatives::OnDocumentElementCreated

BUG=585268,568130

Review URL: https://codereview.chromium.org/1684953002

Cr-Commit-Position: refs/heads/master@{#374758}
",5a15b72a270b514cd442872221a788a303bdaa88,https://chromium.googlesource.com/chromium/src/+/5a15b72a270b514cd442872221a788a303bdaa88,extensions/renderer/render_frame_observer_natives.cc,DidCreateDocumentElement,void DidCreateDocumentElement() override { CallbackAndDie(true); },void DidCreateDocumentElement() override { CallbackAndDie(true); },,"void DidCreateDocumentElement() override {
    // The callback must be run as soon as the root element is available.
    // Running the callback may trigger DidCreateDocumentElement or
    // DidFailProvisionalLoad, so delete this before running the callback.
    base::Callback<void(bool)> callback = callback_;
    delete this;
    callback.Run(true);
  }","void DidCreateDocumentElement() override {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    base::Callback<void(bool)> VAR_0 = VAR_1;
    delete this;
    VAR_0.Run(true);
  }",,"--- func_before
+++ func_after
@@ -1 +1,8 @@
-void DidCreateDocumentElement() override { CallbackAndDie(true); }
+void DidCreateDocumentElement() override {
+    // The callback must be run as soon as the root element is available.
+    // Running the callback may trigger DidCreateDocumentElement or
+    // DidFailProvisionalLoad, so delete this before running the callback.
+    base::Callback<void(bool)> callback = callback_;
+    delete this;
+    callback.Run(true);
+  }","{'deleted_lines': ['void DidCreateDocumentElement() override { CallbackAndDie(true); }'], 'added_lines': ['void DidCreateDocumentElement() override {', '    // The callback must be run as soon as the root element is available.', '    // Running the callback may trigger DidCreateDocumentElement or', '    // DidFailProvisionalLoad, so delete this before running the callback.', '    base::Callback<void(bool)> callback = callback_;', '    delete this;', '    callback.Run(true);', '  }']}",True,"extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",9.8,CRITICAL,3,valid,,5
CVE-2016-1635,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix re-entrancy and lifetime issue in RenderFrameObserverNatives::OnDocumentElementCreated

BUG=585268,568130

Review URL: https://codereview.chromium.org/1684953002

Cr-Commit-Position: refs/heads/master@{#374758}
",5a15b72a270b514cd442872221a788a303bdaa88,https://chromium.googlesource.com/chromium/src/+/5a15b72a270b514cd442872221a788a303bdaa88,extensions/renderer/render_frame_observer_natives.cc,LoadWatcher,"LoadWatcher(ScriptContext* context,
content::RenderFrame* frame,
v8::Local<v8::Function> cb)
: content::RenderFrameObserver(frame),
context_(context),
callback_(context->isolate(), cb) {
if (ExtensionFrameHelper::Get(frame)->
did_create_current_document_element()) {
base::MessageLoop::current()->PostTask(
FROM_HERE,
base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),
true));
}
}","LoadWatcher(ScriptContext* VAR_0,
content::RenderFrame* VAR_1,
v8::Local<v8::Function> VAR_2)
: content::RenderFrameObserver(VAR_1),
context_(VAR_0),
callback_(VAR_0->isolate(), VAR_2) {
if (ExtensionFrameHelper::Get(VAR_1)->
did_create_current_document_element()) {
base::MessageLoop::current()->PostTask(
VAR_3,
base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),
true));
}
}",,"LoadWatcher(content::RenderFrame* frame,
              const base::Callback<void(bool)>& callback)
      : content::RenderFrameObserver(frame), callback_(callback) {}","LoadWatcher(content::RenderFrame* VAR_0,
              const base::Callback<void(bool)>& VAR_1)
      : content::RenderFrameObserver(VAR_0), callback_(VAR_1) {}",,"--- func_before
+++ func_after
@@ -1,18 +1,3 @@
-LoadWatcher(ScriptContext* context,
-              content::RenderFrame* frame,
-              v8::Local<v8::Function> cb)
-      : content::RenderFrameObserver(frame),
-        context_(context),
-        callback_(context->isolate(), cb) {
-    if (ExtensionFrameHelper::Get(frame)->
-            did_create_current_document_element()) {
-      // If the document element is already created, then we can call the
-      // callback immediately (though post it to the message loop so as to not
-      // call it re-entrantly).
-      // The Unretained is safe because this class manages its own lifetime.
-      base::MessageLoop::current()->PostTask(
-          FROM_HERE,
-          base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),
-                     true));
-    }
-  }
+LoadWatcher(content::RenderFrame* frame,
+              const base::Callback<void(bool)>& callback)
+      : content::RenderFrameObserver(frame), callback_(callback) {}","{'deleted_lines': ['LoadWatcher(ScriptContext* context,', '              content::RenderFrame* frame,', '              v8::Local<v8::Function> cb)', '      : content::RenderFrameObserver(frame),', '        context_(context),', '        callback_(context->isolate(), cb) {', '    if (ExtensionFrameHelper::Get(frame)->', '            did_create_current_document_element()) {', '      // If the document element is already created, then we can call the', '      // callback immediately (though post it to the message loop so as to not', '      // call it re-entrantly).', '      // The Unretained is safe because this class manages its own lifetime.', '      base::MessageLoop::current()->PostTask(', '          FROM_HERE,', '          base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),', '                     true));', '    }', '  }'], 'added_lines': ['LoadWatcher(content::RenderFrame* frame,', '              const base::Callback<void(bool)>& callback)', '      : content::RenderFrameObserver(frame), callback_(callback) {}']}",True,"extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",9.8,CRITICAL,3,valid,,5
CVE-2016-1635,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix re-entrancy and lifetime issue in RenderFrameObserverNatives::OnDocumentElementCreated

BUG=585268,568130

Review URL: https://codereview.chromium.org/1684953002

Cr-Commit-Position: refs/heads/master@{#374758}
",5a15b72a270b514cd442872221a788a303bdaa88,https://chromium.googlesource.com/chromium/src/+/5a15b72a270b514cd442872221a788a303bdaa88,extensions/renderer/render_frame_observer_natives.cc,RenderFrameObserverNatives::RenderFrameObserverNatives,"RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
: ObjectBackedNativeHandler(context) {
RouteFunction(
""OnDocumentElementCreated"",
base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
base::Unretained(this)));
}","RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* VAR_0)
: ObjectBackedNativeHandler(VAR_0) {
RouteFunction(
""OnDocumentElementCreated"",
base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
base::Unretained(this)));
}",chromium/5a15b72a270b514cd442872221a788a303bdaa88/render_frame_observer_natives.cc/vul/before/4.json,"RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {
  RouteFunction(
      ""OnDocumentElementCreated"",
      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                 base::Unretained(this)));
}","RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* VAR_0)
    : ObjectBackedNativeHandler(VAR_0), weak_ptr_factory_(this) {
  RouteFunction(
      ""OnDocumentElementCreated"",
      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                 base::Unretained(this)));
}",chromium/5a15b72a270b514cd442872221a788a303bdaa88/render_frame_observer_natives.cc/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
-    : ObjectBackedNativeHandler(context) {
+    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,","{'deleted_lines': ['    : ObjectBackedNativeHandler(context) {'], 'added_lines': ['    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {']}",True,"extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",9.8,CRITICAL,3,valid,,5
CVE-2016-1637,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,skia,"Pin result in SkATan2_255

BUG=555544

Review URL: https://codereview.chromium.org/1506913002
",1d265ca85f51ea1ba087ca4d0f80b008c256a47d,https://skia.googlesource.com/skia/+/1d265ca85f51ea1ba087ca4d0f80b008c256a47d,src/effects/gradients/SkSweepGradient.cpp,SkATan2_255,"static unsigned SkATan2_255(float y, float x) {
static const float g255Over2PI = 40.584510488433314f;
float result = sk_float_atan2(y, x);
if (result < 0) {
result += 2 * SK_ScalarPI;
}
SkASSERT(result >= 0);
int ir = (int)(result * g255Over2PI);
SkASSERT(ir >= 0 && ir <= 255);
return ir;
}","static unsigned SkATan2_255(float VAR_0, float VAR_1) {
static const float VAR_2 = 40.584510488433314f;
float VAR_3 = sk_float_atan2(VAR_0, VAR_1);
if (VAR_3 < 0) {
VAR_3 += 2 * VAR_4;
}
SkASSERT(VAR_3 >= 0);
int VAR_5 = (int)(VAR_3 * VAR_2);
SkASSERT(VAR_5 >= 0 && VAR_5 <= 255);
return VAR_5;
}",skia/1d265ca85f51ea1ba087ca4d0f80b008c256a47d/SkSweepGradient.cpp/vul/before/0.json,"static unsigned SkATan2_255(float y, float x) {
    //    static const float g255Over2PI = 255 / (2 * SK_ScalarPI);
    static const float g255Over2PI = 40.584510488433314f;

    float result = sk_float_atan2(y, x);
    if (!SkScalarIsFinite(result)) {
        return 0;
    }
    if (result < 0) {
        result += 2 * SK_ScalarPI;
    }
    SkASSERT(result >= 0);
    // since our value is always >= 0, we can cast to int, which is faster than
    // calling floorf()
    int ir = (int)(result * g255Over2PI);
    SkASSERT(ir >= 0 && ir <= 255);
    return ir;
}","static unsigned SkATan2_255(float VAR_0, float VAR_1) {
    /* COMMENT_0 */
    static const float VAR_2 = 40.584510488433314f;

    float VAR_3 = sk_float_atan2(VAR_0, VAR_1);
    if (!SkScalarIsFinite(VAR_3)) {
        return 0;
    }
    if (VAR_3 < 0) {
        VAR_3 += 2 * VAR_4;
    }
    SkASSERT(VAR_3 >= 0);
    /* COMMENT_1 */
    /* COMMENT_2 */
    int VAR_5 = (int)(VAR_3 * VAR_2);
    SkASSERT(VAR_5 >= 0 && VAR_5 <= 255);
    return VAR_5;
}",skia/1d265ca85f51ea1ba087ca4d0f80b008c256a47d/SkSweepGradient.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
     static const float g255Over2PI = 40.584510488433314f;
 
     float result = sk_float_atan2(y, x);
+    if (!SkScalarIsFinite(result)) {
+        return 0;
+    }
     if (result < 0) {
         result += 2 * SK_ScalarPI;
     }","{'deleted_lines': [], 'added_lines': ['    if (!SkScalarIsFinite(result)) {', '        return 0;', '    }']}",True,"The SkATan2_255 function in effects/gradients/SkSweepGradient.cpp in Skia, as used in Google Chrome before 49.0.2623.75, mishandles arctangent calculations, which allows remote attackers to obtain sensitive information via a crafted web site.",6.5,MEDIUM,1,valid,,5
CVE-2016-0850,['CWE-264'],AV:A/AC:L/Au:N/C:P/I:P/A:P,0,android,"DO NOT MERGE Remove Porsche car-kit pairing workaround

Bug: 26551752
Change-Id: I14c5e3fcda0849874c8a94e48aeb7d09585617e1
",c677ee92595335233eb0e7b59809a1a94e7a678a,https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/c677ee92595335233eb0e7b59809a1a94e7a678a,stack/btm/btm_sec.c,btm_sec_pin_code_request,"void btm_sec_pin_code_request (UINT8 *p_bda)
{
tBTM_SEC_DEV_REC *p_dev_rec;
tBTM_CB          *p_cb = &btm_cb;
#ifdef PORCHE_PAIRING_CONFLICT
UINT8 default_pin_code_len = 4;
PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};
#endif
BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
btm_pair_state_descr(btm_cb.pairing_state),
(p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );
if (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)
{
if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&
(btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )
{
if(! btm_cb.pin_code_len_saved)
{
btsnd_hcic_pin_code_neg_reply (p_bda);
return;
}
else
{
btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
return;
}
}
else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)
|| memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
{
BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
btm_pair_state_descr(btm_cb.pairing_state));
#ifdef PORCHE_PAIRING_CONFLICT
BTM_TRACE_EVENT (""btm_sec_pin_code_request from remote dev. for local initiated pairing"");
if(! btm_cb.pin_code_len_saved)
{
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);
}
else
{
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
}
#else
btsnd_hcic_pin_code_neg_reply (p_bda);
#endif
return;
}
}
p_dev_rec = btm_find_or_alloc_dev (p_bda);
p_dev_rec->sm4 = BTM_SM4_KNOWN;
if (btm_cb.pairing_state == BTM_PAIR_STATE_IDLE)
{
memcpy (btm_cb.pairing_bda, p_bda, BD_ADDR_LEN);
btm_cb.pairing_flags = BTM_PAIR_FLAGS_PEER_STARTED_DD;
BTM_SEC_CLR_TRUSTED_DEVICE(p_dev_rec->trusted_mask);
}
if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED))
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request fixed pin replying"");
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
btsnd_hcic_pin_code_req_reply (p_bda, p_cb->cfg.pin_code_len, p_cb->cfg.pin_code);
return;
}
if ( (!memcmp (p_bda, p_cb->connecting_bda, BD_ADDR_LEN))
&&  (p_cb->connecting_dc[0] || p_cb->connecting_dc[1] || p_cb->connecting_dc[2]) )
memcpy (p_dev_rec->dev_class, p_cb->connecting_dc, DEV_CLASS_LEN);
if (btm_cb.pin_code_len != 0)
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);
#ifdef PORCHE_PAIRING_CONFLICT
btm_cb.pin_code_len_saved = btm_cb.pin_code_len;
#endif
btm_cb.pin_code_len = 0;
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
}
else if (p_cb->pairing_disabled
|| (p_cb->api.p_pin_callback == NULL)
|| (!p_dev_rec->is_originator
&& ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)
&&  (p_dev_rec->dev_class[2] & BTM_COD_MINOR_KEYBOARD)) )
{
BTM_TRACE_WARNING(""btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!"",
p_cb->pairing_disabled, p_cb->api.p_pin_callback, p_dev_rec);
btsnd_hcic_pin_code_neg_reply (p_bda);
}
else
{
btm_cb.pin_code_len_saved = 0;
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);
memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);
memcpy (p_cb->connecting_dc,  p_dev_rec->dev_class, DEV_CLASS_LEN);
if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN)
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request going for callback"");
btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
if (p_cb->api.p_pin_callback)
(*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
}
else
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request going for remote name"");
if (!btsnd_hcic_rmt_name_req (p_dev_rec->bd_addr,
HCI_PAGE_SCAN_REP_MODE_R1,
HCI_MANDATARY_PAGE_SCAN_MODE, 0))
{
p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
p_dev_rec->sec_bd_name[0] = 'f';
p_dev_rec->sec_bd_name[1] = '0';
BTM_TRACE_ERROR (""can not send rmt_name_req?? fake a name and call callback"");
btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
if (p_cb->api.p_pin_callback)
(*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
}
}
}
return;
}","void btm_sec_pin_code_request (UINT8 *VAR_0)
{
tBTM_SEC_DEV_REC *VAR_1;
tBTM_CB          *VAR_2 = &VAR_3;
#ifdef VAR_4
UINT8 VAR_5 = 4;
PIN_CODE VAR_6 = {0x30, 0x30, 0x30, 0x30};
#endif
BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
btm_pair_state_descr(VAR_3.pairing_state),
(VAR_0[0]<<8)+VAR_0[1], (VAR_0[2]<<24)+(VAR_0[3]<<16)+(VAR_0[4]<<8)+VAR_0[5] );
if (VAR_3.pairing_state != VAR_7)
{
if ( (memcmp (VAR_0, VAR_3.pairing_bda, VAR_8) == 0)  &&
(VAR_3.pairing_state == VAR_9) )
{
if(! VAR_3.pin_code_len_saved)
{
btsnd_hcic_pin_code_neg_reply (VAR_0);
return;
}
else
{
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_3.pin_code_len_saved, VAR_2->pin_code);
return;
}
}
else if ((VAR_3.pairing_state != VAR_10)
|| memcmp (VAR_0, VAR_3.pairing_bda, VAR_8) != 0)
{
BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
btm_pair_state_descr(VAR_3.pairing_state));
#ifdef VAR_4
BTM_TRACE_EVENT (""btm_sec_pin_code_request from remote dev. for local initiated pairing"");
if(! VAR_3.pin_code_len_saved)
{
btm_sec_change_pairing_state (VAR_9);
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_5, VAR_6);
}
else
{
btm_sec_change_pairing_state (VAR_9);
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_3.pin_code_len_saved, VAR_2->pin_code);
}
#else
btsnd_hcic_pin_code_neg_reply (VAR_0);
#endif
return;
}
}
VAR_1 = btm_find_or_alloc_dev (VAR_0);
VAR_1->sm4 = VAR_11;
if (VAR_3.pairing_state == VAR_7)
{
memcpy (VAR_3.pairing_bda, VAR_0, VAR_8);
VAR_3.pairing_flags = VAR_12;
BTM_SEC_CLR_TRUSTED_DEVICE(VAR_1->trusted_mask);
}
if (!VAR_2->pairing_disabled && (VAR_2->cfg.pin_type == VAR_13))
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request fixed pin replying"");
btm_sec_change_pairing_state (VAR_9);
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_2->cfg.pin_code_len, VAR_2->cfg.pin_code);
return;
}
if ( (!memcmp (VAR_0, VAR_2->connecting_bda, VAR_8))
&&  (VAR_2->connecting_dc[0] || VAR_2->connecting_dc[1] || VAR_2->connecting_dc[2]) )
memcpy (VAR_1->dev_class, VAR_2->connecting_dc, VAR_14);
if (VAR_3.pin_code_len != 0)
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_3.pin_code_len, VAR_2->pin_code);
#ifdef VAR_4
VAR_3.pin_code_len_saved = VAR_3.pin_code_len;
#endif
VAR_3.pin_code_len = 0;
btm_sec_change_pairing_state (VAR_9);
}
else if (VAR_2->pairing_disabled
|| (VAR_2->api.p_pin_callback == NULL)
|| (!VAR_1->is_originator
&& ((VAR_1->dev_class[1] & VAR_15) == VAR_16)
&&  (VAR_1->dev_class[2] & VAR_17)) )
{
BTM_TRACE_WARNING(""btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!"",
VAR_2->pairing_disabled, VAR_2->api.p_pin_callback, VAR_1);
btsnd_hcic_pin_code_neg_reply (VAR_0);
}
else
{
VAR_3.pin_code_len_saved = 0;
btm_sec_change_pairing_state (VAR_18);
memcpy (VAR_2->connecting_bda, VAR_0, VAR_8);
memcpy (VAR_2->connecting_dc,  VAR_1->dev_class, VAR_14);
if (VAR_1->sec_flags & VAR_19)
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request going for callback"");
VAR_3.pairing_flags |= VAR_20;
if (VAR_2->api.p_pin_callback)
(*VAR_2->api.p_pin_callback) (VAR_0, VAR_1->dev_class, VAR_1->sec_bd_name);
}
else
{
BTM_TRACE_EVENT (""btm_sec_pin_code_request going for remote name"");
if (!btsnd_hcic_rmt_name_req (VAR_1->bd_addr,
VAR_21,
VAR_22, 0))
{
VAR_1->sec_flags |= VAR_19;
VAR_1->sec_bd_name[0] = 'f';
VAR_1->sec_bd_name[1] = '0';
BTM_TRACE_ERROR (""can not send rmt_name_req?? fake a name and call callback"");
VAR_3.pairing_flags |= VAR_20;
if (VAR_2->api.p_pin_callback)
(*VAR_2->api.p_pin_callback) (VAR_0, VAR_1->dev_class, VAR_1->sec_bd_name);
}
}
}
return;
}",android/c677ee92595335233eb0e7b59809a1a94e7a678a/btm_sec.c/vul/before/0.json,"void btm_sec_pin_code_request (UINT8 *p_bda)
{
    tBTM_SEC_DEV_REC *p_dev_rec;
    tBTM_CB          *p_cb = &btm_cb;

    BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
                      btm_pair_state_descr(btm_cb.pairing_state),
                      (p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );

    if (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)
    {
        if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&
             (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )
        {
             btsnd_hcic_pin_code_neg_reply (p_bda);
             return;
        }
        else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)
                 || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
        {
            BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
                                btm_pair_state_descr(btm_cb.pairing_state));

            btsnd_hcic_pin_code_neg_reply (p_bda);
            return;
        }
    }

    p_dev_rec = btm_find_or_alloc_dev (p_bda);
    /* received PIN code request. must be non-sm4 */
    p_dev_rec->sm4 = BTM_SM4_KNOWN;

    if (btm_cb.pairing_state == BTM_PAIR_STATE_IDLE)
    {
        memcpy (btm_cb.pairing_bda, p_bda, BD_ADDR_LEN);

        btm_cb.pairing_flags = BTM_PAIR_FLAGS_PEER_STARTED_DD;
        /* Make sure we reset the trusted mask to help against attacks */
        BTM_SEC_CLR_TRUSTED_DEVICE(p_dev_rec->trusted_mask);
    }

    if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED))
    {
        BTM_TRACE_EVENT (""btm_sec_pin_code_request fixed pin replying"");
        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
        btsnd_hcic_pin_code_req_reply (p_bda, p_cb->cfg.pin_code_len, p_cb->cfg.pin_code);
        return;
    }

    /* Use the connecting device's CoD for the connection */
    if ( (!memcmp (p_bda, p_cb->connecting_bda, BD_ADDR_LEN))
         &&  (p_cb->connecting_dc[0] || p_cb->connecting_dc[1] || p_cb->connecting_dc[2]) )
        memcpy (p_dev_rec->dev_class, p_cb->connecting_dc, DEV_CLASS_LEN);

    /* We could have started connection after asking user for the PIN code */
    if (btm_cb.pin_code_len != 0)
    {
        BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
        btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);

        /* Mark that we forwarded received from the user PIN code */
        btm_cb.pin_code_len = 0;

        /* We can change mode back right away, that other connection being established */
        /* is not forced to be secure - found a FW issue, so we can not do this
        btm_restore_mode(); */

        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
    }

    /* If pairing disabled OR (no PIN callback and not bonding) */
    /* OR we could not allocate entry in the database reject pairing request */
    else if (p_cb->pairing_disabled
             || (p_cb->api.p_pin_callback == NULL)

             /* OR Microsoft keyboard can for some reason try to establish connection */
             /*  the only thing we can do here is to shut it up.  Normally we will be originator */
             /*  for keyboard bonding */
             || (!p_dev_rec->is_originator
                 && ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)
                 &&  (p_dev_rec->dev_class[2] & BTM_COD_MINOR_KEYBOARD)) )
    {
        BTM_TRACE_WARNING(""btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!"",
                           p_cb->pairing_disabled, p_cb->api.p_pin_callback, p_dev_rec);

        btsnd_hcic_pin_code_neg_reply (p_bda);
    }
    /* Notify upper layer of PIN request and start expiration timer */
    else
    {
        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);
        /* Pin code request can not come at the same time as connection request */
        memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);
        memcpy (p_cb->connecting_dc,  p_dev_rec->dev_class, DEV_CLASS_LEN);

        /* Check if the name is known */
        /* Even if name is not known we might not be able to get one */
        /* this is the case when we are already getting something from the */
        /* device, so HCI level is flow controlled */
        /* Also cannot send remote name request while paging, i.e. connection is not completed */
        if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN)
        {
            BTM_TRACE_EVENT (""btm_sec_pin_code_request going for callback"");

            btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
            if (p_cb->api.p_pin_callback)
                (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
        }
        else
        {
            BTM_TRACE_EVENT (""btm_sec_pin_code_request going for remote name"");

            /* We received PIN code request for the device with unknown name */
            /* it is not user friendly just to ask for the PIN without name */
            /* try to get name at first */
            if (!btsnd_hcic_rmt_name_req (p_dev_rec->bd_addr,
                                          HCI_PAGE_SCAN_REP_MODE_R1,
                                          HCI_MANDATARY_PAGE_SCAN_MODE, 0))
            {
                p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
                p_dev_rec->sec_bd_name[0] = 'f';
                p_dev_rec->sec_bd_name[1] = '0';
                BTM_TRACE_ERROR (""can not send rmt_name_req?? fake a name and call callback"");

                btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
                if (p_cb->api.p_pin_callback)
                    (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
            }
        }
    }

    return;
}","void btm_sec_pin_code_request (UINT8 *VAR_0)
{
    tBTM_SEC_DEV_REC *VAR_1;
    tBTM_CB          *VAR_2 = &VAR_3;

    BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
                      btm_pair_state_descr(VAR_3.pairing_state),
                      (VAR_0[0]<<8)+VAR_0[1], (VAR_0[2]<<24)+(VAR_0[3]<<16)+(VAR_0[4]<<8)+VAR_0[5] );

    if (VAR_3.pairing_state != VAR_4)
    {
        if ( (memcmp (VAR_0, VAR_3.pairing_bda, VAR_5) == 0)  &&
             (VAR_3.pairing_state == VAR_6) )
        {
             btsnd_hcic_pin_code_neg_reply (VAR_0);
             return;
        }
        else if ((VAR_3.pairing_state != VAR_7)
                 || memcmp (VAR_0, VAR_3.pairing_bda, VAR_5) != 0)
        {
            BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
                                btm_pair_state_descr(VAR_3.pairing_state));

            btsnd_hcic_pin_code_neg_reply (VAR_0);
            return;
        }
    }

    VAR_1 = btm_find_or_alloc_dev (VAR_0);
    /* COMMENT_0 */
    VAR_1->sm4 = VAR_8;

    if (VAR_3.pairing_state == VAR_4)
    {
        memcpy (VAR_3.pairing_bda, VAR_0, VAR_5);

        VAR_3.pairing_flags = VAR_9;
        /* COMMENT_1 */
        BTM_SEC_CLR_TRUSTED_DEVICE(VAR_1->trusted_mask);
    }

    if (!VAR_2->pairing_disabled && (VAR_2->cfg.pin_type == VAR_10))
    {
        BTM_TRACE_EVENT (""btm_sec_pin_code_request fixed pin replying"");
        btm_sec_change_pairing_state (VAR_6);
        btsnd_hcic_pin_code_req_reply (VAR_0, VAR_2->cfg.pin_code_len, VAR_2->cfg.pin_code);
        return;
    }

    /* COMMENT_2 */
    if ( (!memcmp (VAR_0, VAR_2->connecting_bda, VAR_5))
         &&  (VAR_2->connecting_dc[0] || VAR_2->connecting_dc[1] || VAR_2->connecting_dc[2]) )
        memcpy (VAR_1->dev_class, VAR_2->connecting_dc, VAR_11);

    /* COMMENT_3 */
    if (VAR_3.pin_code_len != 0)
    {
        BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
        btsnd_hcic_pin_code_req_reply (VAR_0, VAR_3.pin_code_len, VAR_2->pin_code);

        /* COMMENT_4 */
        VAR_3.pin_code_len = 0;

        /* COMMENT_5 */
        /* COMMENT_6 */
                              

        btm_sec_change_pairing_state (VAR_6);
    }

    /* COMMENT_8 */
    /* COMMENT_9 */
    else if (VAR_2->pairing_disabled
             || (VAR_2->api.p_pin_callback == NULL)

             /* COMMENT_10 */
             /* COMMENT_11 */
             /* COMMENT_12 */
             || (!VAR_1->is_originator
                 && ((VAR_1->dev_class[1] & VAR_12) == VAR_13)
                 &&  (VAR_1->dev_class[2] & VAR_14)) )
    {
        BTM_TRACE_WARNING(""btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!"",
                           VAR_2->pairing_disabled, VAR_2->api.p_pin_callback, VAR_1);

        btsnd_hcic_pin_code_neg_reply (VAR_0);
    }
    /* COMMENT_13 */
    else
    {
        btm_sec_change_pairing_state (VAR_15);
        /* COMMENT_14 */
        memcpy (VAR_2->connecting_bda, VAR_0, VAR_5);
        memcpy (VAR_2->connecting_dc,  VAR_1->dev_class, VAR_11);

        /* COMMENT_15 */
        /* COMMENT_16 */
        /* COMMENT_17 */
        /* COMMENT_18 */
        /* COMMENT_19 */
        if (VAR_1->sec_flags & VAR_16)
        {
            BTM_TRACE_EVENT (""btm_sec_pin_code_request going for callback"");

            VAR_3.pairing_flags |= VAR_17;
            if (VAR_2->api.p_pin_callback)
                (*VAR_2->api.p_pin_callback) (VAR_0, VAR_1->dev_class, VAR_1->sec_bd_name);
        }
        else
        {
            BTM_TRACE_EVENT (""btm_sec_pin_code_request going for remote name"");

            /* COMMENT_20 */
            /* COMMENT_21 */
            /* COMMENT_22 */
            if (!btsnd_hcic_rmt_name_req (VAR_1->bd_addr,
                                          VAR_18,
                                          VAR_19, 0))
            {
                VAR_1->sec_flags |= VAR_16;
                VAR_1->sec_bd_name[0] = 'f';
                VAR_1->sec_bd_name[1] = '0';
                BTM_TRACE_ERROR (""can not send rmt_name_req?? fake a name and call callback"");

                VAR_3.pairing_flags |= VAR_17;
                if (VAR_2->api.p_pin_callback)
                    (*VAR_2->api.p_pin_callback) (VAR_0, VAR_1->dev_class, VAR_1->sec_bd_name);
            }
        }
    }

    return;
}",android/c677ee92595335233eb0e7b59809a1a94e7a678a/btm_sec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,10 +3,6 @@
     tBTM_SEC_DEV_REC *p_dev_rec;
     tBTM_CB          *p_cb = &btm_cb;
 
-#ifdef PORCHE_PAIRING_CONFLICT
-    UINT8 default_pin_code_len = 4;
-    PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};
-#endif
     BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
                       btm_pair_state_descr(btm_cb.pairing_state),
                       (p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );
@@ -16,18 +12,8 @@
         if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&
              (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )
         {
-             /* fake this out - porshe carkit issue - */
-//            btm_cb.pairing_state = BTM_PAIR_STATE_IDLE;
-             if(! btm_cb.pin_code_len_saved)
-             {
-                 btsnd_hcic_pin_code_neg_reply (p_bda);
-                 return;
-             }
-             else
-             {
-                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
-      	         return;
-             }
+             btsnd_hcic_pin_code_neg_reply (p_bda);
+             return;
         }
         else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)
                  || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
@@ -35,22 +21,7 @@
             BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
                                 btm_pair_state_descr(btm_cb.pairing_state));
 
-#ifdef PORCHE_PAIRING_CONFLICT
-            /* reply pin code again due to counter in_rand when local initiates pairing */
-            BTM_TRACE_EVENT (""btm_sec_pin_code_request from remote dev. for local initiated pairing"");
-            if(! btm_cb.pin_code_len_saved)
-            {
-                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
-                btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);
-            }
-            else
-            {
-                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
-                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
-            }
-#else
             btsnd_hcic_pin_code_neg_reply (p_bda);
-#endif
             return;
         }
     }
@@ -87,10 +58,6 @@
         BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
         btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);
 
-#ifdef PORCHE_PAIRING_CONFLICT
-        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;
-#endif
-
         /* Mark that we forwarded received from the user PIN code */
         btm_cb.pin_code_len = 0;
 
@@ -121,7 +88,6 @@
     /* Notify upper layer of PIN request and start expiration timer */
     else
     {
-        btm_cb.pin_code_len_saved = 0;
         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);
         /* Pin code request can not come at the same time as connection request */
         memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);","{'deleted_lines': ['#ifdef PORCHE_PAIRING_CONFLICT', '    UINT8 default_pin_code_len = 4;', '    PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};', '#endif', '             /* fake this out - porshe carkit issue - */', '//            btm_cb.pairing_state = BTM_PAIR_STATE_IDLE;', '             if(! btm_cb.pin_code_len_saved)', '             {', '                 btsnd_hcic_pin_code_neg_reply (p_bda);', '                 return;', '             }', '             else', '             {', '                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);', '      \t         return;', '             }', '#ifdef PORCHE_PAIRING_CONFLICT', '            /* reply pin code again due to counter in_rand when local initiates pairing */', '            BTM_TRACE_EVENT (""btm_sec_pin_code_request from remote dev. for local initiated pairing"");', '            if(! btm_cb.pin_code_len_saved)', '            {', '                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);', '                btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);', '            }', '            else', '            {', '                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);', '                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);', '            }', '#else', '#endif', '#ifdef PORCHE_PAIRING_CONFLICT', '        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;', '#endif', '', '        btm_cb.pin_code_len_saved = 0;'], 'added_lines': ['             btsnd_hcic_pin_code_neg_reply (p_bda);', '             return;']}",True,"The PORCHE_PAIRING_CONFLICT feature in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to bypass intended pairing restrictions via a crafted device, aka internal bug 26551752.",8.8,HIGH,2,valid,,5
CVE-2016-0850,['CWE-264'],AV:A/AC:L/Au:N/C:P/I:P/A:P,0,android,"DO NOT MERGE Remove Porsche car-kit pairing workaround

Bug: 26551752
Change-Id: I14c5e3fcda0849874c8a94e48aeb7d09585617e1
",c677ee92595335233eb0e7b59809a1a94e7a678a,https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/c677ee92595335233eb0e7b59809a1a94e7a678a,stack/btm/btm_sec.c,BTM_PINCodeReply,"void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])
{
tBTM_SEC_DEV_REC *p_dev_rec;
BTM_TRACE_API (""BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d"",
btm_pair_state_descr(btm_cb.pairing_state), btm_cb.pairing_flags, pin_len, res);
if (btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply() - Wrong State: %d"", btm_cb.pairing_state);
return;
}
if (memcmp (bd_addr, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
{
BTM_TRACE_ERROR (""BTM_PINCodeReply() - Wrong BD Addr"");
return;
}
if ((p_dev_rec = btm_find_dev (bd_addr)) == NULL)
{
BTM_TRACE_ERROR (""BTM_PINCodeReply() - no dev CB"");
return;
}
if ( (pin_len > PIN_CODE_LEN) || (pin_len == 0) || (p_pin == NULL) )
res = BTM_ILLEGAL_VALUE;
if (res != BTM_SUCCESS)
{
if ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_PEER_STARTED_DD) ||
((btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
(btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) )
{
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
btm_cb.acl_disc_reason = HCI_ERR_HOST_REJECT_SECURITY;
btsnd_hcic_pin_code_neg_reply (bd_addr);
}
else
{
p_dev_rec->security_required = BTM_SEC_NONE;
btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
}
return;
}
if (trusted_mask)
BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask);
p_dev_rec->sec_flags   |= BTM_SEC_LINK_KEY_AUTHED;
if ( (btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD)
&&  (p_dev_rec->hci_handle == BTM_SEC_INVALID_HANDLE)
&&  (btm_cb.security_mode_changed == FALSE) )
{
btm_cb.pin_code_len = pin_len;
memcpy (btm_cb.pin_code, p_pin, pin_len);
btm_cb.security_mode_changed = TRUE;
#ifdef APPL_AUTH_WRITE_EXCEPTION
if(!(APPL_AUTH_WRITE_EXCEPTION)(p_dev_rec->bd_addr))
#endif
btsnd_hcic_write_auth_enable (TRUE);
btm_cb.acl_disc_reason = 0xff ;
if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_REJECTED_CONNECT)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection"");
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);
}
else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply(): link is connecting so wait pin code request from peer"");
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);
}
else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED)
{
btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;
if (btm_cb.api.p_auth_complete_callback)
(*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,  p_dev_rec->dev_class,
p_dev_rec->sec_bd_name, HCI_ERR_AUTH_FAILURE);
}
return;
}
btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
btm_cb.acl_disc_reason = HCI_SUCCESS;
#ifdef PORCHE_PAIRING_CONFLICT
BTM_TRACE_EVENT(""BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d"", pin_len, btm_cb.pin_code_len);
if (btm_cb.pin_code_len == 0)
memcpy (btm_cb.pin_code, p_pin, pin_len);
btm_cb.pin_code_len_saved = pin_len;
#endif
btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);
}","void BTM_PINCodeReply (BD_ADDR VAR_0, UINT8 VAR_1, UINT8 VAR_2, UINT8 *VAR_3, UINT32 VAR_4[])
{
tBTM_SEC_DEV_REC *VAR_5;
BTM_TRACE_API (""BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d"",
btm_pair_state_descr(VAR_6.pairing_state), VAR_6.pairing_flags, VAR_2, VAR_1);
if (VAR_6.pairing_state != VAR_7)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply() - Wrong State: %d"", VAR_6.pairing_state);
return;
}
if (memcmp (VAR_0, VAR_6.pairing_bda, VAR_8) != 0)
{
BTM_TRACE_ERROR (""BTM_PINCodeReply() - Wrong BD Addr"");
return;
}
if ((VAR_5 = btm_find_dev (VAR_0)) == NULL)
{
BTM_TRACE_ERROR (""BTM_PINCodeReply() - no dev CB"");
return;
}
if ( (VAR_2 > VAR_9) || (VAR_2 == 0) || (VAR_3 == NULL) )
VAR_1 = VAR_10;
if (VAR_1 != VAR_11)
{
if ((VAR_6.pairing_flags & VAR_12) ||
((VAR_6.pairing_flags & VAR_13) &&
(VAR_6.pairing_flags & VAR_14)) )
{
btm_sec_change_pairing_state (VAR_15);
VAR_6.acl_disc_reason = VAR_16;
btsnd_hcic_pin_code_neg_reply (VAR_0);
}
else
{
VAR_5->security_required = VAR_17;
btm_sec_change_pairing_state (VAR_18);
}
return;
}
if (VAR_4)
BTM_SEC_COPY_TRUSTED_DEVICE(VAR_4, VAR_5->trusted_mask);
VAR_5->sec_flags   |= VAR_19;
if ( (VAR_6.pairing_flags & VAR_13)
&&  (VAR_5->hci_handle == VAR_20)
&&  (VAR_6.security_mode_changed == FALSE) )
{
VAR_6.pin_code_len = VAR_2;
memcpy (VAR_6.pin_code, VAR_3, VAR_2);
VAR_6.security_mode_changed = TRUE;
#ifdef VAR_21
if(!(VAR_21)(VAR_5->bd_addr))
#endif
btsnd_hcic_write_auth_enable (TRUE);
VAR_6.acl_disc_reason = 0xff ;
if (VAR_6.pairing_flags & VAR_22)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection"");
btm_sec_change_pairing_state (VAR_23);
}
else if (VAR_5->sm4 & VAR_24)
{
BTM_TRACE_WARNING (""BTM_PINCodeReply(): link is connecting so wait pin code request from peer"");
btm_sec_change_pairing_state (VAR_23);
}
else if (btm_sec_dd_create_conn(VAR_5) != VAR_25)
{
btm_sec_change_pairing_state (VAR_18);
VAR_5->sec_flags &= ~VAR_19;
if (VAR_6.api.p_auth_complete_callback)
(*VAR_6.api.p_auth_complete_callback) (VAR_5->bd_addr,  VAR_5->dev_class,
VAR_5->sec_bd_name, VAR_26);
}
return;
}
btm_sec_change_pairing_state (VAR_15);
VAR_6.acl_disc_reason = VAR_27;
#ifdef VAR_28
BTM_TRACE_EVENT(""BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d"", VAR_2, VAR_6.pin_code_len);
if (VAR_6.pin_code_len == 0)
memcpy (VAR_6.pin_code, VAR_3, VAR_2);
VAR_6.pin_code_len_saved = VAR_2;
#endif
btsnd_hcic_pin_code_req_reply (VAR_0, VAR_2, VAR_3);
}",android/c677ee92595335233eb0e7b59809a1a94e7a678a/btm_sec.c/vul/before/1.json,"void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])
{
    tBTM_SEC_DEV_REC *p_dev_rec;

    BTM_TRACE_API (""BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d"",
                    btm_pair_state_descr(btm_cb.pairing_state), btm_cb.pairing_flags, pin_len, res);

    /* If timeout already expired or has been canceled, ignore the reply */
    if (btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN)
    {
        BTM_TRACE_WARNING (""BTM_PINCodeReply() - Wrong State: %d"", btm_cb.pairing_state);
        return;
    }

    if (memcmp (bd_addr, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
    {
        BTM_TRACE_ERROR (""BTM_PINCodeReply() - Wrong BD Addr"");
        return;
    }

    if ((p_dev_rec = btm_find_dev (bd_addr)) == NULL)
    {
        BTM_TRACE_ERROR (""BTM_PINCodeReply() - no dev CB"");
        return;
    }

    if ( (pin_len > PIN_CODE_LEN) || (pin_len == 0) || (p_pin == NULL) )
        res = BTM_ILLEGAL_VALUE;

    if (res != BTM_SUCCESS)
    {
        /* if peer started dd OR we started dd and pre-fetch pin was not used send negative reply */
        if ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_PEER_STARTED_DD) ||
            ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
            (btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) )
        {
            /* use BTM_PAIR_STATE_WAIT_AUTH_COMPLETE to report authentication failed event */
            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
            btm_cb.acl_disc_reason = HCI_ERR_HOST_REJECT_SECURITY;

            btsnd_hcic_pin_code_neg_reply (bd_addr);
        }
        else
        {
            p_dev_rec->security_required = BTM_SEC_NONE;
            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
        }
        return;
    }
    if (trusted_mask)
        BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask);
    p_dev_rec->sec_flags   |= BTM_SEC_LINK_KEY_AUTHED;

    if ( (btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD)
         &&  (p_dev_rec->hci_handle == BTM_SEC_INVALID_HANDLE)
         &&  (btm_cb.security_mode_changed == FALSE) )
    {
        /* This is start of the dedicated bonding if local device is 2.0 */
        btm_cb.pin_code_len = pin_len;
        memcpy (btm_cb.pin_code, p_pin, pin_len);

        btm_cb.security_mode_changed = TRUE;
#ifdef APPL_AUTH_WRITE_EXCEPTION
        if(!(APPL_AUTH_WRITE_EXCEPTION)(p_dev_rec->bd_addr))
#endif
        btsnd_hcic_write_auth_enable (TRUE);

        btm_cb.acl_disc_reason = 0xff ;

        /* if we rejected incoming connection request, we have to wait HCI_Connection_Complete event */
        /*  before originating  */
        if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_REJECTED_CONNECT)
        {
            BTM_TRACE_WARNING (""BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection"");
            /* we change state little bit early so btm_sec_connected() will originate connection */
            /*   when existing ACL link is down completely */
            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);
        }
        /* if we already accepted incoming connection from pairing device */
        else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND)
        {
            BTM_TRACE_WARNING (""BTM_PINCodeReply(): link is connecting so wait pin code request from peer"");
            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);
        }
        else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED)
        {
            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
            p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;

            if (btm_cb.api.p_auth_complete_callback)
                (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,  p_dev_rec->dev_class,
                                                    p_dev_rec->sec_bd_name, HCI_ERR_AUTH_FAILURE);
        }
        return;
    }

    btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
    btm_cb.acl_disc_reason = HCI_SUCCESS;

    btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);
}","void BTM_PINCodeReply (BD_ADDR VAR_0, UINT8 VAR_1, UINT8 VAR_2, UINT8 *VAR_3, UINT32 VAR_4[])
{
    tBTM_SEC_DEV_REC *VAR_5;

    BTM_TRACE_API (""BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d"",
                    btm_pair_state_descr(VAR_6.pairing_state), VAR_6.pairing_flags, VAR_2, VAR_1);

    /* COMMENT_0 */
    if (VAR_6.pairing_state != VAR_7)
    {
        BTM_TRACE_WARNING (""BTM_PINCodeReply() - Wrong State: %d"", VAR_6.pairing_state);
        return;
    }

    if (memcmp (VAR_0, VAR_6.pairing_bda, VAR_8) != 0)
    {
        BTM_TRACE_ERROR (""BTM_PINCodeReply() - Wrong BD Addr"");
        return;
    }

    if ((VAR_5 = btm_find_dev (VAR_0)) == NULL)
    {
        BTM_TRACE_ERROR (""BTM_PINCodeReply() - no dev CB"");
        return;
    }

    if ( (VAR_2 > VAR_9) || (VAR_2 == 0) || (VAR_3 == NULL) )
        VAR_1 = VAR_10;

    if (VAR_1 != VAR_11)
    {
        /* COMMENT_1 */
        if ((VAR_6.pairing_flags & VAR_12) ||
            ((VAR_6.pairing_flags & VAR_13) &&
            (VAR_6.pairing_flags & VAR_14)) )
        {
            /* COMMENT_2 */
            btm_sec_change_pairing_state (VAR_15);
            VAR_6.acl_disc_reason = VAR_16;

            btsnd_hcic_pin_code_neg_reply (VAR_0);
        }
        else
        {
            VAR_5->security_required = VAR_17;
            btm_sec_change_pairing_state (VAR_18);
        }
        return;
    }
    if (VAR_4)
        BTM_SEC_COPY_TRUSTED_DEVICE(VAR_4, VAR_5->trusted_mask);
    VAR_5->sec_flags   |= VAR_19;

    if ( (VAR_6.pairing_flags & VAR_13)
         &&  (VAR_5->hci_handle == VAR_20)
         &&  (VAR_6.security_mode_changed == FALSE) )
    {
        /* COMMENT_3 */
        VAR_6.pin_code_len = VAR_2;
        memcpy (VAR_6.pin_code, VAR_3, VAR_2);

        VAR_6.security_mode_changed = TRUE;
#ifdef VAR_21
        if(!(VAR_21)(VAR_5->bd_addr))
#endif
        btsnd_hcic_write_auth_enable (TRUE);

        VAR_6.acl_disc_reason = 0xff ;

        /* COMMENT_4 */
        /* COMMENT_5 */
        if (VAR_6.pairing_flags & VAR_22)
        {
            BTM_TRACE_WARNING (""BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection"");
            /* COMMENT_6 */
            /* COMMENT_7 */
            btm_sec_change_pairing_state (VAR_23);
        }
        /* COMMENT_8 */
        else if (VAR_5->sm4 & VAR_24)
        {
            BTM_TRACE_WARNING (""BTM_PINCodeReply(): link is connecting so wait pin code request from peer"");
            btm_sec_change_pairing_state (VAR_23);
        }
        else if (btm_sec_dd_create_conn(VAR_5) != VAR_25)
        {
            btm_sec_change_pairing_state (VAR_18);
            VAR_5->sec_flags &= ~VAR_19;

            if (VAR_6.api.p_auth_complete_callback)
                (*VAR_6.api.p_auth_complete_callback) (VAR_5->bd_addr,  VAR_5->dev_class,
                                                    VAR_5->sec_bd_name, VAR_26);
        }
        return;
    }

    btm_sec_change_pairing_state (VAR_15);
    VAR_6.acl_disc_reason = VAR_27;

    btsnd_hcic_pin_code_req_reply (VAR_0, VAR_2, VAR_3);
}",android/c677ee92595335233eb0e7b59809a1a94e7a678a/btm_sec.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -97,12 +97,5 @@
     btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
     btm_cb.acl_disc_reason = HCI_SUCCESS;
 
-#ifdef PORCHE_PAIRING_CONFLICT
-    BTM_TRACE_EVENT(""BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d"", pin_len, btm_cb.pin_code_len);
-    /* if this was not pre-fetched, save the PIN */
-    if (btm_cb.pin_code_len == 0)
-        memcpy (btm_cb.pin_code, p_pin, pin_len);
-    btm_cb.pin_code_len_saved = pin_len;
-#endif
     btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);
 }","{'deleted_lines': ['#ifdef PORCHE_PAIRING_CONFLICT', '    BTM_TRACE_EVENT(""BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d"", pin_len, btm_cb.pin_code_len);', '    /* if this was not pre-fetched, save the PIN */', '    if (btm_cb.pin_code_len == 0)', '        memcpy (btm_cb.pin_code, p_pin, pin_len);', '    btm_cb.pin_code_len_saved = pin_len;', '#endif'], 'added_lines': []}",True,"The PORCHE_PAIRING_CONFLICT feature in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to bypass intended pairing restrictions via a crafted device, aka internal bug 26551752.",8.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/readdir.c,ovl_cleanup_whiteouts,"void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)
{
struct ovl_cache_entry *p;
mutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);
list_for_each_entry(p, list, l_node) {
struct dentry *dentry;
if (!p->is_whiteout)
continue;
dentry = lookup_one_len(p->name, upper, p->len);
if (IS_ERR(dentry)) {
pr_err(""overlayfs: lookup '%s/%.*s' failed (%i)\n"",
upper->d_name.name, p->len, p->name,
(int) PTR_ERR(dentry));
continue;
}
ovl_cleanup(upper->d_inode, dentry);
dput(dentry);
}
mutex_unlock(&upper->d_inode->i_mutex);
}","void ovl_cleanup_whiteouts(struct dentry *VAR_0, struct list_head *VAR_1)
{
struct ovl_cache_entry *VAR_2;
mutex_lock_nested(&VAR_0->d_inode->i_mutex, VAR_3);
list_for_each_entry(VAR_2, VAR_1, VAR_4) {
struct dentry *dentry;
if (!VAR_2->is_whiteout)
continue;
dentry = lookup_one_len(VAR_2->name, VAR_0, VAR_2->len);
if (IS_ERR(dentry)) {
pr_err(""overlayfs: lookup '%s/%.*s' failed (%i)\n"",
VAR_0->d_name.name, VAR_2->len, VAR_2->name,
(int) PTR_ERR(dentry));
continue;
}
ovl_cleanup(VAR_0->d_inode, dentry);
dput(dentry);
}
mutex_unlock(&VAR_0->d_inode->i_mutex);
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/readdir.c/vul/before/0.json,"void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)
{
	struct ovl_cache_entry *p;

	mutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);
	list_for_each_entry(p, list, l_node) {
		struct dentry *dentry;

		if (!p->is_whiteout)
			continue;

		dentry = lookup_one_len(p->name, upper, p->len);
		if (IS_ERR(dentry)) {
			pr_err(""overlayfs: lookup '%s/%.*s' failed (%i)\n"",
			       upper->d_name.name, p->len, p->name,
			       (int) PTR_ERR(dentry));
			continue;
		}
		if (dentry->d_inode)
			ovl_cleanup(upper->d_inode, dentry);
		dput(dentry);
	}
	mutex_unlock(&upper->d_inode->i_mutex);
}","void ovl_cleanup_whiteouts(struct dentry *VAR_0, struct list_head *VAR_1)
{
	struct ovl_cache_entry *VAR_2;

	mutex_lock_nested(&VAR_0->d_inode->i_mutex, VAR_3);
	list_for_each_entry(VAR_2, VAR_1, VAR_4) {
		struct dentry *dentry;

		if (!VAR_2->is_whiteout)
			continue;

		dentry = lookup_one_len(VAR_2->name, VAR_0, VAR_2->len);
		if (IS_ERR(dentry)) {
			pr_err(""overlayfs: lookup '%s/%.*s' failed (%i)\n"",
			       VAR_0->d_name.name, VAR_2->len, VAR_2->name,
			       (int) PTR_ERR(dentry));
			continue;
		}
		if (dentry->d_inode)
			ovl_cleanup(VAR_0->d_inode, dentry);
		dput(dentry);
	}
	mutex_unlock(&VAR_0->d_inode->i_mutex);
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/readdir.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,8 @@
 			       (int) PTR_ERR(dentry));
 			continue;
 		}
-		ovl_cleanup(upper->d_inode, dentry);
+		if (dentry->d_inode)
+			ovl_cleanup(upper->d_inode, dentry);
 		dput(dentry);
 	}
 	mutex_unlock(&upper->d_inode->i_mutex);","{'deleted_lines': ['\t\tovl_cleanup(upper->d_inode, dentry);'], 'added_lines': ['\t\tif (dentry->d_inode)', '\t\t\tovl_cleanup(upper->d_inode, dentry);']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/super.c,ovl_show_options,"static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
{
struct super_block *sb = dentry->d_sb;
struct ovl_fs *ufs = sb->s_fs_info;
seq_show_option(m, ""lowerdir"", ufs->config.lowerdir);
if (ufs->config.upperdir) {
seq_show_option(m, ""upperdir"", ufs->config.upperdir);
seq_show_option(m, ""workdir"", ufs->config.workdir);
}
return 0;
}","static int ovl_show_options(struct seq_file *VAR_0, struct dentry *dentry)
{
struct super_block *VAR_1 = dentry->d_sb;
struct ovl_fs *VAR_2 = VAR_1->s_fs_info;
seq_show_option(VAR_0, ""lowerdir"", VAR_2->config.lowerdir);
if (VAR_2->config.upperdir) {
seq_show_option(VAR_0, ""upperdir"", VAR_2->config.upperdir);
seq_show_option(VAR_0, ""workdir"", VAR_2->config.workdir);
}
return 0;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/before/0.json,"static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
{
	struct super_block *sb = dentry->d_sb;
	struct ovl_fs *ufs = sb->s_fs_info;

	seq_show_option(m, ""lowerdir"", ufs->config.lowerdir);
	if (ufs->config.upperdir) {
		seq_show_option(m, ""upperdir"", ufs->config.upperdir);
		seq_show_option(m, ""workdir"", ufs->config.workdir);
	}
	if (ufs->config.default_permissions)
		seq_puts(m, "",default_permissions"");
	return 0;
}","static int ovl_show_options(struct seq_file *VAR_0, struct dentry *dentry)
{
	struct super_block *VAR_1 = dentry->d_sb;
	struct ovl_fs *VAR_2 = VAR_1->s_fs_info;

	seq_show_option(VAR_0, ""lowerdir"", VAR_2->config.lowerdir);
	if (VAR_2->config.upperdir) {
		seq_show_option(VAR_0, ""upperdir"", VAR_2->config.upperdir);
		seq_show_option(VAR_0, ""workdir"", VAR_2->config.workdir);
	}
	if (VAR_2->config.default_permissions)
		seq_puts(VAR_0, "",default_permissions"");
	return 0;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,5 +8,7 @@
 		seq_show_option(m, ""upperdir"", ufs->config.upperdir);
 		seq_show_option(m, ""workdir"", ufs->config.workdir);
 	}
+	if (ufs->config.default_permissions)
+		seq_puts(m, "",default_permissions"");
 	return 0;
 }","{'deleted_lines': [], 'added_lines': ['\tif (ufs->config.default_permissions)', '\t\tseq_puts(m, "",default_permissions"");']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/super.c,ovl_parse_opt,"static int ovl_parse_opt(char *opt, struct ovl_config *config)
{
char *p;
while ((p = ovl_next_opt(&opt)) != NULL) {
int token;
substring_t args[MAX_OPT_ARGS];
if (!*p)
continue;
token = match_token(p, ovl_tokens, args);
switch (token) {
case OPT_UPPERDIR:
kfree(config->upperdir);
config->upperdir = match_strdup(&args[0]);
if (!config->upperdir)
return -ENOMEM;
break;
case OPT_LOWERDIR:
kfree(config->lowerdir);
config->lowerdir = match_strdup(&args[0]);
if (!config->lowerdir)
return -ENOMEM;
break;
case OPT_WORKDIR:
kfree(config->workdir);
config->workdir = match_strdup(&args[0]);
if (!config->workdir)
return -ENOMEM;
break;
default:
pr_err(""overlayfs: unrecognized mount option \""%s\"" or missing value\n"", p);
return -EINVAL;
}
}
if (!config->upperdir && config->workdir) {
pr_info(""overlayfs: option \""workdir=%s\"" is useless in a non-upper mount, ignore\n"",
config->workdir);
kfree(config->workdir);
config->workdir = NULL;
}
return 0;
}","static int ovl_parse_opt(char *VAR_0, struct ovl_config *VAR_1)
{
char *VAR_2;
while ((VAR_2 = ovl_next_opt(&VAR_0)) != NULL) {
int VAR_3;
substring_t VAR_4[VAR_5];
if (!*VAR_2)
continue;
VAR_3 = match_token(VAR_2, VAR_6, VAR_4);
switch (VAR_3) {
case VAR_7:
kfree(VAR_1->upperdir);
VAR_1->upperdir = match_strdup(&VAR_4[0]);
if (!VAR_1->upperdir)
return -VAR_8;
break;
case VAR_9:
kfree(VAR_1->lowerdir);
VAR_1->lowerdir = match_strdup(&VAR_4[0]);
if (!VAR_1->lowerdir)
return -VAR_8;
break;
case VAR_10:
kfree(VAR_1->workdir);
VAR_1->workdir = match_strdup(&VAR_4[0]);
if (!VAR_1->workdir)
return -VAR_8;
break;
default:
pr_err(""overlayfs: unrecognized mount option \""%s\"" or missing value\n"", VAR_2);
return -VAR_11;
}
}
if (!VAR_1->upperdir && VAR_1->workdir) {
pr_info(""overlayfs: option \""workdir=%s\"" is useless in a non-upper mount, ignore\n"",
VAR_1->workdir);
kfree(VAR_1->workdir);
VAR_1->workdir = NULL;
}
return 0;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/before/1.json,"static int ovl_parse_opt(char *opt, struct ovl_config *config)
{
	char *p;

	while ((p = ovl_next_opt(&opt)) != NULL) {
		int token;
		substring_t args[MAX_OPT_ARGS];

		if (!*p)
			continue;

		token = match_token(p, ovl_tokens, args);
		switch (token) {
		case OPT_UPPERDIR:
			kfree(config->upperdir);
			config->upperdir = match_strdup(&args[0]);
			if (!config->upperdir)
				return -ENOMEM;
			break;

		case OPT_LOWERDIR:
			kfree(config->lowerdir);
			config->lowerdir = match_strdup(&args[0]);
			if (!config->lowerdir)
				return -ENOMEM;
			break;

		case OPT_WORKDIR:
			kfree(config->workdir);
			config->workdir = match_strdup(&args[0]);
			if (!config->workdir)
				return -ENOMEM;
			break;

		case OPT_DEFAULT_PERMISSIONS:
			config->default_permissions = true;
			break;

		default:
			pr_err(""overlayfs: unrecognized mount option \""%s\"" or missing value\n"", p);
			return -EINVAL;
		}
	}

	/* Workdir is useless in non-upper mount */
	if (!config->upperdir && config->workdir) {
		pr_info(""overlayfs: option \""workdir=%s\"" is useless in a non-upper mount, ignore\n"",
			config->workdir);
		kfree(config->workdir);
		config->workdir = NULL;
	}

	return 0;
}","static int ovl_parse_opt(char *VAR_0, struct ovl_config *VAR_1)
{
	char *VAR_2;

	while ((VAR_2 = ovl_next_opt(&VAR_0)) != NULL) {
		int VAR_3;
		substring_t VAR_4[VAR_5];

		if (!*VAR_2)
			continue;

		VAR_3 = match_token(VAR_2, VAR_6, VAR_4);
		switch (VAR_3) {
		case VAR_7:
			kfree(VAR_1->upperdir);
			VAR_1->upperdir = match_strdup(&VAR_4[0]);
			if (!VAR_1->upperdir)
				return -VAR_8;
			break;

		case VAR_9:
			kfree(VAR_1->lowerdir);
			VAR_1->lowerdir = match_strdup(&VAR_4[0]);
			if (!VAR_1->lowerdir)
				return -VAR_8;
			break;

		case VAR_10:
			kfree(VAR_1->workdir);
			VAR_1->workdir = match_strdup(&VAR_4[0]);
			if (!VAR_1->workdir)
				return -VAR_8;
			break;

		case VAR_11:
			VAR_1->default_permissions = true;
			break;

		default:
			pr_err(""overlayfs: unrecognized mount option \""%s\"" or missing value\n"", VAR_2);
			return -VAR_12;
		}
	}

	/* COMMENT_0 */
	if (!VAR_1->upperdir && VAR_1->workdir) {
		pr_info(""overlayfs: option \""workdir=%s\"" is useless in a non-upper mount, ignore\n"",
			VAR_1->workdir);
		kfree(VAR_1->workdir);
		VAR_1->workdir = NULL;
	}

	return 0;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -32,6 +32,10 @@
 				return -ENOMEM;
 			break;
 
+		case OPT_DEFAULT_PERMISSIONS:
+			config->default_permissions = true;
+			break;
+
 		default:
 			pr_err(""overlayfs: unrecognized mount option \""%s\"" or missing value\n"", p);
 			return -EINVAL;","{'deleted_lines': [], 'added_lines': ['\t\tcase OPT_DEFAULT_PERMISSIONS:', '\t\t\tconfig->default_permissions = true;', '\t\t\tbreak;', '']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/super.c,ovl_fill_super,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
struct path upperpath = { NULL, NULL };
struct path workpath = { NULL, NULL };
struct dentry *root_dentry;
struct ovl_entry *oe;
struct ovl_fs *ufs;
struct path *stack = NULL;
char *lowertmp;
char *lower;
unsigned int numlower;
unsigned int stacklen = 0;
unsigned int i;
bool remote = false;
int err;
err = -ENOMEM;
ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
if (!ufs)
goto out;
err = ovl_parse_opt((char *) data, &ufs->config);
if (err)
goto out_free_config;
err = -EINVAL;
if (!ufs->config.lowerdir) {
pr_err(""overlayfs: missing 'lowerdir'\n"");
goto out_free_config;
}
sb->s_stack_depth = 0;
if (ufs->config.upperdir) {
if (!ufs->config.workdir) {
pr_err(""overlayfs: missing 'workdir'\n"");
goto out_free_config;
}
err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
if (err)
goto out_free_config;
if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
pr_err(""overlayfs: upper fs is r/o, try multi-lower layers mount\n"");
err = -EINVAL;
goto out_put_upperpath;
}
err = ovl_mount_dir(ufs->config.workdir, &workpath);
if (err)
goto out_put_upperpath;
err = -EINVAL;
if (upperpath.mnt != workpath.mnt) {
pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
goto out_put_workpath;
}
if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
goto out_put_workpath;
}
sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
}
err = -ENOMEM;
lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
if (!lowertmp)
goto out_put_workpath;
err = -EINVAL;
stacklen = ovl_split_lowerdirs(lowertmp);
if (stacklen > OVL_MAX_STACK) {
pr_err(""overlayfs: too many lower directries, limit is %d\n"",
OVL_MAX_STACK);
goto out_free_lowertmp;
} else if (!ufs->config.upperdir && stacklen == 1) {
pr_err(""overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n"");
goto out_free_lowertmp;
}
stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
if (!stack)
goto out_free_lowertmp;
lower = lowertmp;
for (numlower = 0; numlower < stacklen; numlower++) {
err = ovl_lower_dir(lower, &stack[numlower],
&ufs->lower_namelen, &sb->s_stack_depth,
&remote);
if (err)
goto out_put_lowerpath;
lower = strchr(lower, '\0') + 1;
}
err = -EINVAL;
sb->s_stack_depth++;
if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
goto out_put_lowerpath;
}
if (ufs->config.upperdir) {
ufs->upper_mnt = clone_private_mount(&upperpath);
err = PTR_ERR(ufs->upper_mnt);
if (IS_ERR(ufs->upper_mnt)) {
pr_err(""overlayfs: failed to clone upperpath\n"");
goto out_put_lowerpath;
}
ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
err = PTR_ERR(ufs->workdir);
if (IS_ERR(ufs->workdir)) {
pr_warn(""overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n"",
ufs->config.workdir, OVL_WORKDIR_NAME, -err);
sb->s_flags |= MS_RDONLY;
ufs->workdir = NULL;
}
}
err = -ENOMEM;
ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
if (ufs->lower_mnt == NULL)
goto out_put_workdir;
for (i = 0; i < numlower; i++) {
struct vfsmount *mnt = clone_private_mount(&stack[i]);
err = PTR_ERR(mnt);
if (IS_ERR(mnt)) {
pr_err(""overlayfs: failed to clone lowerpath\n"");
goto out_put_lower_mnt;
}
mnt->mnt_flags |= MNT_READONLY;
ufs->lower_mnt[ufs->numlower] = mnt;
ufs->numlower++;
}
if (!ufs->upper_mnt)
sb->s_flags |= MS_RDONLY;
if (remote)
sb->s_d_op = &ovl_reval_dentry_operations;
else
sb->s_d_op = &ovl_dentry_operations;
err = -ENOMEM;
oe = ovl_alloc_entry(numlower);
if (!oe)
goto out_put_lower_mnt;
root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
if (!root_dentry)
goto out_free_oe;
mntput(upperpath.mnt);
for (i = 0; i < numlower; i++)
mntput(stack[i].mnt);
path_put(&workpath);
kfree(lowertmp);
oe->__upperdentry = upperpath.dentry;
for (i = 0; i < numlower; i++) {
oe->lowerstack[i].dentry = stack[i].dentry;
oe->lowerstack[i].mnt = ufs->lower_mnt[i];
}
kfree(stack);
root_dentry->d_fsdata = oe;
sb->s_magic = OVERLAYFS_SUPER_MAGIC;
sb->s_op = &ovl_super_operations;
sb->s_root = root_dentry;
sb->s_fs_info = ufs;
return 0;
out_free_oe:
kfree(oe);
out_put_lower_mnt:
for (i = 0; i < ufs->numlower; i++)
mntput(ufs->lower_mnt[i]);
kfree(ufs->lower_mnt);
out_put_workdir:
dput(ufs->workdir);
mntput(ufs->upper_mnt);
out_put_lowerpath:
for (i = 0; i < numlower; i++)
path_put(&stack[i]);
kfree(stack);
out_free_lowertmp:
kfree(lowertmp);
out_put_workpath:
path_put(&workpath);
out_put_upperpath:
path_put(&upperpath);
out_free_config:
kfree(ufs->config.lowerdir);
kfree(ufs->config.upperdir);
kfree(ufs->config.workdir);
kfree(ufs);
out:
return err;
}","static int ovl_fill_super(struct super_block *VAR_0, void *VAR_1, int VAR_2)
{
struct path VAR_3 = { NULL, NULL };
struct path VAR_4 = { NULL, NULL };
struct dentry *VAR_5;
struct ovl_entry *VAR_6;
struct ovl_fs *VAR_7;
struct path *VAR_8 = NULL;
char *VAR_9;
char *VAR_10;
unsigned int VAR_11;
unsigned int VAR_12 = 0;
unsigned int VAR_13;
bool VAR_14 = false;
int VAR_15;
VAR_15 = -VAR_16;
VAR_7 = kzalloc(sizeof(struct ovl_fs), VAR_17);
if (!VAR_7)
goto out;
VAR_15 = ovl_parse_opt((char *) VAR_1, &VAR_7->config);
if (VAR_15)
goto out_free_config;
VAR_15 = -VAR_18;
if (!VAR_7->config.lowerdir) {
pr_err(""overlayfs: missing 'lowerdir'\n"");
goto out_free_config;
}
VAR_0->s_stack_depth = 0;
if (VAR_7->config.upperdir) {
if (!VAR_7->config.workdir) {
pr_err(""overlayfs: missing 'workdir'\n"");
goto out_free_config;
}
VAR_15 = ovl_mount_dir(VAR_7->config.upperdir, &VAR_3);
if (VAR_15)
goto out_free_config;
if (VAR_3.mnt->mnt_sb->s_flags & VAR_19) {
pr_err(""overlayfs: upper fs is r/o, try multi-lower layers mount\n"");
VAR_15 = -VAR_18;
goto out_put_upperpath;
}
VAR_15 = ovl_mount_dir(VAR_7->config.workdir, &VAR_4);
if (VAR_15)
goto out_put_upperpath;
VAR_15 = -VAR_18;
if (VAR_3.mnt != VAR_4.mnt) {
pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
goto out_put_workpath;
}
if (!ovl_workdir_ok(VAR_4.dentry, VAR_3.dentry)) {
pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
goto out_put_workpath;
}
VAR_0->s_stack_depth = VAR_3.mnt->mnt_sb->s_stack_depth;
}
VAR_15 = -VAR_16;
VAR_9 = kstrdup(VAR_7->config.lowerdir, VAR_17);
if (!VAR_9)
goto out_put_workpath;
VAR_15 = -VAR_18;
VAR_12 = ovl_split_lowerdirs(VAR_9);
if (VAR_12 > VAR_20) {
pr_err(""overlayfs: too many lower directries, limit is %d\n"",
VAR_20);
goto out_free_lowertmp;
} else if (!VAR_7->config.upperdir && VAR_12 == 1) {
pr_err(""overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n"");
goto out_free_lowertmp;
}
VAR_8 = kcalloc(VAR_12, sizeof(struct path), VAR_17);
if (!VAR_8)
goto out_free_lowertmp;
VAR_10 = VAR_9;
for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++) {
VAR_15 = ovl_lower_dir(VAR_10, &VAR_8[VAR_11],
&VAR_7->lower_namelen, &VAR_0->s_stack_depth,
&VAR_14);
if (VAR_15)
goto out_put_lowerpath;
VAR_10 = strchr(VAR_10, '\0') + 1;
}
VAR_15 = -VAR_18;
VAR_0->s_stack_depth++;
if (VAR_0->s_stack_depth > VAR_21) {
pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
goto out_put_lowerpath;
}
if (VAR_7->config.upperdir) {
VAR_7->upper_mnt = clone_private_mount(&VAR_3);
VAR_15 = PTR_ERR(VAR_7->upper_mnt);
if (IS_ERR(VAR_7->upper_mnt)) {
pr_err(""overlayfs: failed to clone upperpath\n"");
goto out_put_lowerpath;
}
VAR_7->workdir = ovl_workdir_create(VAR_7->upper_mnt, VAR_4.dentry);
VAR_15 = PTR_ERR(VAR_7->workdir);
if (IS_ERR(VAR_7->workdir)) {
pr_warn(""overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n"",
VAR_7->config.workdir, VAR_22, -VAR_15);
VAR_0->s_flags |= VAR_19;
VAR_7->workdir = NULL;
}
}
VAR_15 = -VAR_16;
VAR_7->lower_mnt = kcalloc(VAR_11, sizeof(struct vfsmount *), VAR_17);
if (VAR_7->lower_mnt == NULL)
goto out_put_workdir;
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
struct vfsmount *VAR_23 = clone_private_mount(&VAR_8[VAR_13]);
VAR_15 = PTR_ERR(VAR_23);
if (IS_ERR(VAR_23)) {
pr_err(""overlayfs: failed to clone lowerpath\n"");
goto out_put_lower_mnt;
}
VAR_23->mnt_flags |= VAR_24;
VAR_7->lower_mnt[VAR_7->numlower] = VAR_23;
VAR_7->numlower++;
}
if (!VAR_7->upper_mnt)
VAR_0->s_flags |= VAR_19;
if (VAR_14)
VAR_0->s_d_op = &VAR_25;
else
VAR_0->s_d_op = &VAR_26;
VAR_15 = -VAR_16;
VAR_6 = ovl_alloc_entry(VAR_11);
if (!VAR_6)
goto out_put_lower_mnt;
VAR_5 = d_make_root(ovl_new_inode(VAR_0, VAR_27, VAR_6));
if (!VAR_5)
goto out_free_oe;
mntput(VAR_3.mnt);
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
mntput(VAR_8[VAR_13].mnt);
path_put(&VAR_4);
kfree(VAR_9);
VAR_6->__upperdentry = VAR_3.dentry;
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
VAR_6->lowerstack[VAR_13].dentry = VAR_8[VAR_13].dentry;
VAR_6->lowerstack[VAR_13].mnt = VAR_7->lower_mnt[VAR_13];
}
kfree(VAR_8);
VAR_5->d_fsdata = VAR_6;
VAR_0->s_magic = VAR_28;
VAR_0->s_op = &VAR_29;
VAR_0->s_root = VAR_5;
VAR_0->s_fs_info = VAR_7;
return 0;
out_free_oe:
kfree(VAR_6);
out_put_lower_mnt:
for (VAR_13 = 0; VAR_13 < VAR_7->numlower; VAR_13++)
mntput(VAR_7->lower_mnt[VAR_13]);
kfree(VAR_7->lower_mnt);
out_put_workdir:
dput(VAR_7->workdir);
mntput(VAR_7->upper_mnt);
out_put_lowerpath:
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
path_put(&VAR_8[VAR_13]);
kfree(VAR_8);
out_free_lowertmp:
kfree(VAR_9);
out_put_workpath:
path_put(&VAR_4);
out_put_upperpath:
path_put(&VAR_3);
out_free_config:
kfree(VAR_7->config.lowerdir);
kfree(VAR_7->config.upperdir);
kfree(VAR_7->config.workdir);
kfree(VAR_7);
out:
return VAR_15;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/before/2.json,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path upperpath = { NULL, NULL };
	struct path workpath = { NULL, NULL };
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct path *stack = NULL;
	char *lowertmp;
	char *lower;
	unsigned int numlower;
	unsigned int stacklen = 0;
	unsigned int i;
	bool remote = false;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	err = -EINVAL;
	if (!ufs->config.lowerdir) {
		pr_err(""overlayfs: missing 'lowerdir'\n"");
		goto out_free_config;
	}

	sb->s_stack_depth = 0;
	sb->s_maxbytes = MAX_LFS_FILESIZE;
	if (ufs->config.upperdir) {
		if (!ufs->config.workdir) {
			pr_err(""overlayfs: missing 'workdir'\n"");
			goto out_free_config;
		}

		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
		if (err)
			goto out_free_config;

		/* Upper fs should not be r/o */
		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
			pr_err(""overlayfs: upper fs is r/o, try multi-lower layers mount\n"");
			err = -EINVAL;
			goto out_put_upperpath;
		}

		err = ovl_mount_dir(ufs->config.workdir, &workpath);
		if (err)
			goto out_put_upperpath;

		err = -EINVAL;
		if (upperpath.mnt != workpath.mnt) {
			pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
			goto out_put_workpath;
		}
		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
			pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
			goto out_put_workpath;
		}
		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
	}
	err = -ENOMEM;
	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
	if (!lowertmp)
		goto out_put_workpath;

	err = -EINVAL;
	stacklen = ovl_split_lowerdirs(lowertmp);
	if (stacklen > OVL_MAX_STACK) {
		pr_err(""overlayfs: too many lower directries, limit is %d\n"",
		       OVL_MAX_STACK);
		goto out_free_lowertmp;
	} else if (!ufs->config.upperdir && stacklen == 1) {
		pr_err(""overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n"");
		goto out_free_lowertmp;
	}

	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
	if (!stack)
		goto out_free_lowertmp;

	lower = lowertmp;
	for (numlower = 0; numlower < stacklen; numlower++) {
		err = ovl_lower_dir(lower, &stack[numlower],
				    &ufs->lower_namelen, &sb->s_stack_depth,
				    &remote);
		if (err)
			goto out_put_lowerpath;

		lower = strchr(lower, '\0') + 1;
	}

	err = -EINVAL;
	sb->s_stack_depth++;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_lowerpath;
	}

	if (ufs->config.upperdir) {
		ufs->upper_mnt = clone_private_mount(&upperpath);
		err = PTR_ERR(ufs->upper_mnt);
		if (IS_ERR(ufs->upper_mnt)) {
			pr_err(""overlayfs: failed to clone upperpath\n"");
			goto out_put_lowerpath;
		}

		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
		err = PTR_ERR(ufs->workdir);
		if (IS_ERR(ufs->workdir)) {
			pr_warn(""overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n"",
				ufs->config.workdir, OVL_WORKDIR_NAME, -err);
			sb->s_flags |= MS_RDONLY;
			ufs->workdir = NULL;
		}
	}

	err = -ENOMEM;
	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
	if (ufs->lower_mnt == NULL)
		goto out_put_workdir;
	for (i = 0; i < numlower; i++) {
		struct vfsmount *mnt = clone_private_mount(&stack[i]);

		err = PTR_ERR(mnt);
		if (IS_ERR(mnt)) {
			pr_err(""overlayfs: failed to clone lowerpath\n"");
			goto out_put_lower_mnt;
		}
		/*
		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
		 * will fail instead of modifying lower fs.
		 */
		mnt->mnt_flags |= MNT_READONLY;

		ufs->lower_mnt[ufs->numlower] = mnt;
		ufs->numlower++;
	}

	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
	if (!ufs->upper_mnt)
		sb->s_flags |= MS_RDONLY;

	if (remote)
		sb->s_d_op = &ovl_reval_dentry_operations;
	else
		sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	oe = ovl_alloc_entry(numlower);
	if (!oe)
		goto out_put_lower_mnt;

	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
	if (!root_dentry)
		goto out_free_oe;

	mntput(upperpath.mnt);
	for (i = 0; i < numlower; i++)
		mntput(stack[i].mnt);
	path_put(&workpath);
	kfree(lowertmp);

	oe->__upperdentry = upperpath.dentry;
	for (i = 0; i < numlower; i++) {
		oe->lowerstack[i].dentry = stack[i].dentry;
		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
	}
	kfree(stack);

	root_dentry->d_fsdata = oe;

	ovl_copyattr(ovl_dentry_real(root_dentry)->d_inode,
		     root_dentry->d_inode);

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_free_oe:
	kfree(oe);
out_put_lower_mnt:
	for (i = 0; i < ufs->numlower; i++)
		mntput(ufs->lower_mnt[i]);
	kfree(ufs->lower_mnt);
out_put_workdir:
	dput(ufs->workdir);
	mntput(ufs->upper_mnt);
out_put_lowerpath:
	for (i = 0; i < numlower; i++)
		path_put(&stack[i]);
	kfree(stack);
out_free_lowertmp:
	kfree(lowertmp);
out_put_workpath:
	path_put(&workpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}","static int ovl_fill_super(struct super_block *VAR_0, void *VAR_1, int VAR_2)
{
	struct path VAR_3 = { NULL, NULL };
	struct path VAR_4 = { NULL, NULL };
	struct dentry *VAR_5;
	struct ovl_entry *VAR_6;
	struct ovl_fs *VAR_7;
	struct path *VAR_8 = NULL;
	char *VAR_9;
	char *VAR_10;
	unsigned int VAR_11;
	unsigned int VAR_12 = 0;
	unsigned int VAR_13;
	bool VAR_14 = false;
	int VAR_15;

	VAR_15 = -VAR_16;
	VAR_7 = kzalloc(sizeof(struct ovl_fs), VAR_17);
	if (!VAR_7)
		goto out;

	VAR_15 = ovl_parse_opt((char *) VAR_1, &VAR_7->config);
	if (VAR_15)
		goto out_free_config;

	VAR_15 = -VAR_18;
	if (!VAR_7->config.lowerdir) {
		pr_err(""overlayfs: missing 'lowerdir'\n"");
		goto out_free_config;
	}

	VAR_0->s_stack_depth = 0;
	VAR_0->s_maxbytes = VAR_19;
	if (VAR_7->config.upperdir) {
		if (!VAR_7->config.workdir) {
			pr_err(""overlayfs: missing 'workdir'\n"");
			goto out_free_config;
		}

		VAR_15 = ovl_mount_dir(VAR_7->config.upperdir, &VAR_3);
		if (VAR_15)
			goto out_free_config;

		/* COMMENT_0 */
		if (VAR_3.mnt->mnt_sb->s_flags & VAR_20) {
			pr_err(""overlayfs: upper fs is r/o, try multi-lower layers mount\n"");
			VAR_15 = -VAR_18;
			goto out_put_upperpath;
		}

		VAR_15 = ovl_mount_dir(VAR_7->config.workdir, &VAR_4);
		if (VAR_15)
			goto out_put_upperpath;

		VAR_15 = -VAR_18;
		if (VAR_3.mnt != VAR_4.mnt) {
			pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
			goto out_put_workpath;
		}
		if (!ovl_workdir_ok(VAR_4.dentry, VAR_3.dentry)) {
			pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
			goto out_put_workpath;
		}
		VAR_0->s_stack_depth = VAR_3.mnt->mnt_sb->s_stack_depth;
	}
	VAR_15 = -VAR_16;
	VAR_9 = kstrdup(VAR_7->config.lowerdir, VAR_17);
	if (!VAR_9)
		goto out_put_workpath;

	VAR_15 = -VAR_18;
	VAR_12 = ovl_split_lowerdirs(VAR_9);
	if (VAR_12 > VAR_21) {
		pr_err(""overlayfs: too many lower directries, limit is %d\n"",
		       VAR_21);
		goto out_free_lowertmp;
	} else if (!VAR_7->config.upperdir && VAR_12 == 1) {
		pr_err(""overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n"");
		goto out_free_lowertmp;
	}

	VAR_8 = kcalloc(VAR_12, sizeof(struct path), VAR_17);
	if (!VAR_8)
		goto out_free_lowertmp;

	VAR_10 = VAR_9;
	for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++) {
		VAR_15 = ovl_lower_dir(VAR_10, &VAR_8[VAR_11],
				    &VAR_7->lower_namelen, &VAR_0->s_stack_depth,
				    &VAR_14);
		if (VAR_15)
			goto out_put_lowerpath;

		VAR_10 = strchr(VAR_10, '\0') + 1;
	}

	VAR_15 = -VAR_18;
	VAR_0->s_stack_depth++;
	if (VAR_0->s_stack_depth > VAR_22) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_lowerpath;
	}

	if (VAR_7->config.upperdir) {
		VAR_7->upper_mnt = clone_private_mount(&VAR_3);
		VAR_15 = PTR_ERR(VAR_7->upper_mnt);
		if (IS_ERR(VAR_7->upper_mnt)) {
			pr_err(""overlayfs: failed to clone upperpath\n"");
			goto out_put_lowerpath;
		}

		VAR_7->workdir = ovl_workdir_create(VAR_7->upper_mnt, VAR_4.dentry);
		VAR_15 = PTR_ERR(VAR_7->workdir);
		if (IS_ERR(VAR_7->workdir)) {
			pr_warn(""overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n"",
				VAR_7->config.workdir, VAR_23, -VAR_15);
			VAR_0->s_flags |= VAR_20;
			VAR_7->workdir = NULL;
		}
	}

	VAR_15 = -VAR_16;
	VAR_7->lower_mnt = kcalloc(VAR_11, sizeof(struct vfsmount *), VAR_17);
	if (VAR_7->lower_mnt == NULL)
		goto out_put_workdir;
	for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
		struct vfsmount *VAR_24 = clone_private_mount(&VAR_8[VAR_13]);

		VAR_15 = PTR_ERR(VAR_24);
		if (IS_ERR(VAR_24)) {
			pr_err(""overlayfs: failed to clone lowerpath\n"");
			goto out_put_lower_mnt;
		}
		/* COMMENT_1 */
                                                              
                                             
     
		VAR_24->mnt_flags |= VAR_25;

		VAR_7->lower_mnt[VAR_7->numlower] = VAR_24;
		VAR_7->numlower++;
	}

	/* COMMENT_5 */
	if (!VAR_7->upper_mnt)
		VAR_0->s_flags |= VAR_20;

	if (VAR_14)
		VAR_0->s_d_op = &VAR_26;
	else
		VAR_0->s_d_op = &VAR_27;

	VAR_15 = -VAR_16;
	VAR_6 = ovl_alloc_entry(VAR_11);
	if (!VAR_6)
		goto out_put_lower_mnt;

	VAR_5 = d_make_root(ovl_new_inode(VAR_0, VAR_28, VAR_6));
	if (!VAR_5)
		goto out_free_oe;

	mntput(VAR_3.mnt);
	for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
		mntput(VAR_8[VAR_13].mnt);
	path_put(&VAR_4);
	kfree(VAR_9);

	VAR_6->__upperdentry = VAR_3.dentry;
	for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
		VAR_6->lowerstack[VAR_13].dentry = VAR_8[VAR_13].dentry;
		VAR_6->lowerstack[VAR_13].mnt = VAR_7->lower_mnt[VAR_13];
	}
	kfree(VAR_8);

	VAR_5->d_fsdata = VAR_6;

	ovl_copyattr(ovl_dentry_real(VAR_5)->d_inode,
		     VAR_5->d_inode);

	VAR_0->s_magic = VAR_29;
	VAR_0->s_op = &VAR_30;
	VAR_0->s_root = VAR_5;
	VAR_0->s_fs_info = VAR_7;

	return 0;

out_free_oe:
	kfree(VAR_6);
out_put_lower_mnt:
	for (VAR_13 = 0; VAR_13 < VAR_7->numlower; VAR_13++)
		mntput(VAR_7->lower_mnt[VAR_13]);
	kfree(VAR_7->lower_mnt);
out_put_workdir:
	dput(VAR_7->workdir);
	mntput(VAR_7->upper_mnt);
out_put_lowerpath:
	for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
		path_put(&VAR_8[VAR_13]);
	kfree(VAR_8);
out_free_lowertmp:
	kfree(VAR_9);
out_put_workpath:
	path_put(&VAR_4);
out_put_upperpath:
	path_put(&VAR_3);
out_free_config:
	kfree(VAR_7->config.lowerdir);
	kfree(VAR_7->config.upperdir);
	kfree(VAR_7->config.workdir);
	kfree(VAR_7);
out:
	return VAR_15;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/super.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -30,6 +30,7 @@
 	}
 
 	sb->s_stack_depth = 0;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	if (ufs->config.upperdir) {
 		if (!ufs->config.workdir) {
 			pr_err(""overlayfs: missing 'workdir'\n"");
@@ -172,6 +173,9 @@
 	kfree(stack);
 
 	root_dentry->d_fsdata = oe;
+
+	ovl_copyattr(ovl_dentry_real(root_dentry)->d_inode,
+		     root_dentry->d_inode);
 
 	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
 	sb->s_op = &ovl_super_operations;","{'deleted_lines': [], 'added_lines': ['\tsb->s_maxbytes = MAX_LFS_FILESIZE;', '', '\tovl_copyattr(ovl_dentry_real(root_dentry)->d_inode,', '\t\t     root_dentry->d_inode);']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/copy_up.c,ovl_copy_xattr,"int ovl_copy_xattr(struct dentry *old, struct dentry *new)
{
ssize_t list_size, size;
char *buf, *name, *value;
int error;
if (!old->d_inode->i_op->getxattr ||
!new->d_inode->i_op->getxattr)
return 0;
list_size = vfs_listxattr(old, NULL, 0);
if (list_size <= 0) {
if (list_size == -EOPNOTSUPP)
return 0;
return list_size;
}
buf = kzalloc(list_size, GFP_KERNEL);
if (!buf)
return -ENOMEM;
error = -ENOMEM;
value = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);
if (!value)
goto out;
list_size = vfs_listxattr(old, buf, list_size);
if (list_size <= 0) {
error = list_size;
goto out_free_value;
}
for (name = buf; name < (buf + list_size); name += strlen(name) + 1) {
size = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);
if (size <= 0) {
error = size;
goto out_free_value;
}
error = vfs_setxattr(new, name, value, size, 0);
if (error)
goto out_free_value;
}
out_free_value:
kfree(value);
out:
kfree(buf);
return error;
}","int ovl_copy_xattr(struct dentry *VAR_0, struct dentry *VAR_1)
{
ssize_t VAR_2, VAR_3;
char *VAR_4, *VAR_5, *VAR_6;
int VAR_7;
if (!VAR_0->d_inode->i_op->getxattr ||
!VAR_1->d_inode->i_op->getxattr)
return 0;
VAR_2 = vfs_listxattr(VAR_0, NULL, 0);
if (VAR_2 <= 0) {
if (VAR_2 == -VAR_8)
return 0;
return VAR_2;
}
VAR_4 = kzalloc(VAR_2, VAR_9);
if (!VAR_4)
return -VAR_10;
VAR_7 = -VAR_10;
VAR_6 = kmalloc(VAR_11, VAR_9);
if (!VAR_6)
goto out;
VAR_2 = vfs_listxattr(VAR_0, VAR_4, VAR_2);
if (VAR_2 <= 0) {
VAR_7 = VAR_2;
goto out_free_value;
}
for (VAR_5 = VAR_4; VAR_5 < (VAR_4 + VAR_2); VAR_5 += strlen(VAR_5) + 1) {
VAR_3 = vfs_getxattr(VAR_0, VAR_5, VAR_6, VAR_11);
if (VAR_3 <= 0) {
VAR_7 = VAR_3;
goto out_free_value;
}
VAR_7 = vfs_setxattr(VAR_1, VAR_5, VAR_6, VAR_3, 0);
if (VAR_7)
goto out_free_value;
}
out_free_value:
kfree(VAR_6);
out:
kfree(VAR_4);
return VAR_7;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/copy_up.c/vul/before/0.json,"int ovl_copy_xattr(struct dentry *old, struct dentry *new)
{
	ssize_t list_size, size, value_size = 0;
	char *buf, *name, *value = NULL;
	int uninitialized_var(error);

	if (!old->d_inode->i_op->getxattr ||
	    !new->d_inode->i_op->getxattr)
		return 0;

	list_size = vfs_listxattr(old, NULL, 0);
	if (list_size <= 0) {
		if (list_size == -EOPNOTSUPP)
			return 0;
		return list_size;
	}

	buf = kzalloc(list_size, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	list_size = vfs_listxattr(old, buf, list_size);
	if (list_size <= 0) {
		error = list_size;
		goto out;
	}

	for (name = buf; name < (buf + list_size); name += strlen(name) + 1) {
retry:
		size = vfs_getxattr(old, name, value, value_size);
		if (size == -ERANGE)
			size = vfs_getxattr(old, name, NULL, 0);

		if (size < 0) {
			error = size;
			break;
		}

		if (size > value_size) {
			void *new;

			new = krealloc(value, size, GFP_KERNEL);
			if (!new) {
				error = -ENOMEM;
				break;
			}
			value = new;
			value_size = size;
			goto retry;
		}

		error = vfs_setxattr(new, name, value, size, 0);
		if (error)
			break;
	}
	kfree(value);
out:
	kfree(buf);
	return error;
}","int ovl_copy_xattr(struct dentry *VAR_0, struct dentry *VAR_1)
{
	ssize_t VAR_2, VAR_3, VAR_4 = 0;
	char *VAR_5, *VAR_6, *VAR_7 = NULL;
	int uninitialized_var(error);

	if (!VAR_0->d_inode->i_op->getxattr ||
	    !VAR_1->d_inode->i_op->getxattr)
		return 0;

	VAR_2 = vfs_listxattr(VAR_0, NULL, 0);
	if (VAR_2 <= 0) {
		if (VAR_2 == -VAR_8)
			return 0;
		return VAR_2;
	}

	VAR_5 = kzalloc(VAR_2, VAR_9);
	if (!VAR_5)
		return -VAR_10;

	VAR_2 = vfs_listxattr(VAR_0, VAR_5, VAR_2);
	if (VAR_2 <= 0) {
		error = VAR_2;
		goto out;
	}

	for (VAR_6 = VAR_5; VAR_6 < (VAR_5 + VAR_2); VAR_6 += strlen(VAR_6) + 1) {
retry:
		VAR_3 = vfs_getxattr(VAR_0, VAR_6, VAR_7, VAR_4);
		if (VAR_3 == -VAR_11)
			VAR_3 = vfs_getxattr(VAR_0, VAR_6, NULL, 0);

		if (VAR_3 < 0) {
			error = VAR_3;
			break;
		}

		if (VAR_3 > VAR_4) {
			void *VAR_1;

			VAR_1 = krealloc(VAR_7, VAR_3, VAR_9);
			if (!VAR_1) {
				error = -VAR_10;
				break;
			}
			VAR_7 = VAR_1;
			VAR_4 = VAR_3;
			goto retry;
		}

		error = vfs_setxattr(VAR_1, VAR_6, VAR_7, VAR_3, 0);
		if (error)
			break;
	}
	kfree(VAR_7);
out:
	kfree(VAR_5);
	return error;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/copy_up.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 int ovl_copy_xattr(struct dentry *old, struct dentry *new)
 {
-	ssize_t list_size, size;
-	char *buf, *name, *value;
-	int error;
+	ssize_t list_size, size, value_size = 0;
+	char *buf, *name, *value = NULL;
+	int uninitialized_var(error);
 
 	if (!old->d_inode->i_op->getxattr ||
 	    !new->d_inode->i_op->getxattr)
@@ -19,29 +19,40 @@
 	if (!buf)
 		return -ENOMEM;
 
-	error = -ENOMEM;
-	value = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);
-	if (!value)
-		goto out;
-
 	list_size = vfs_listxattr(old, buf, list_size);
 	if (list_size <= 0) {
 		error = list_size;
-		goto out_free_value;
+		goto out;
 	}
 
 	for (name = buf; name < (buf + list_size); name += strlen(name) + 1) {
-		size = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);
-		if (size <= 0) {
+retry:
+		size = vfs_getxattr(old, name, value, value_size);
+		if (size == -ERANGE)
+			size = vfs_getxattr(old, name, NULL, 0);
+
+		if (size < 0) {
 			error = size;
-			goto out_free_value;
+			break;
 		}
+
+		if (size > value_size) {
+			void *new;
+
+			new = krealloc(value, size, GFP_KERNEL);
+			if (!new) {
+				error = -ENOMEM;
+				break;
+			}
+			value = new;
+			value_size = size;
+			goto retry;
+		}
+
 		error = vfs_setxattr(new, name, value, size, 0);
 		if (error)
-			goto out_free_value;
+			break;
 	}
-
-out_free_value:
 	kfree(value);
 out:
 	kfree(buf);","{'deleted_lines': ['\tssize_t list_size, size;', '\tchar *buf, *name, *value;', '\tint error;', '\terror = -ENOMEM;', '\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);', '\tif (!value)', '\t\tgoto out;', '', '\t\tgoto out_free_value;', '\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);', '\t\tif (size <= 0) {', '\t\t\tgoto out_free_value;', '\t\t\tgoto out_free_value;', '', 'out_free_value:'], 'added_lines': ['\tssize_t list_size, size, value_size = 0;', '\tchar *buf, *name, *value = NULL;', '\tint uninitialized_var(error);', '\t\tgoto out;', 'retry:', '\t\tsize = vfs_getxattr(old, name, value, value_size);', '\t\tif (size == -ERANGE)', '\t\t\tsize = vfs_getxattr(old, name, NULL, 0);', '', '\t\tif (size < 0) {', '\t\t\tbreak;', '', '\t\tif (size > value_size) {', '\t\t\tvoid *new;', '', '\t\t\tnew = krealloc(value, size, GFP_KERNEL);', '\t\t\tif (!new) {', '\t\t\t\terror = -ENOMEM;', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tvalue = new;', '\t\t\tvalue_size = size;', '\t\t\tgoto retry;', '\t\t}', '', '\t\t\tbreak;']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/inode.c,ovl_permission,"int ovl_permission(struct inode *inode, int mask)
{
struct ovl_entry *oe;
struct dentry *alias = NULL;
struct inode *realinode;
struct dentry *realdentry;
bool is_upper;
int err;
if (S_ISDIR(inode->i_mode)) {
oe = inode->i_private;
} else if (mask & MAY_NOT_BLOCK) {
return -ECHILD;
} else {
alias = d_find_any_alias(inode);
if (WARN_ON(!alias))
return -ENOENT;
oe = alias->d_fsdata;
}
realdentry = ovl_entry_real(oe, &is_upper);
realinode = ACCESS_ONCE(realdentry->d_inode);
if (!realinode) {
WARN_ON(!(mask & MAY_NOT_BLOCK));
err = -ENOENT;
goto out_dput;
}
if (mask & MAY_WRITE) {
umode_t mode = realinode->i_mode;
err = -EROFS;
if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
(S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
goto out_dput;
}
err = __inode_permission(realinode, mask);
out_dput:
dput(alias);
return err;
}","int ovl_permission(struct inode *inode, int VAR_0)
{
struct ovl_entry *VAR_1;
struct dentry *VAR_2 = NULL;
struct inode *VAR_3;
struct dentry *VAR_4;
bool VAR_5;
int VAR_6;
if (S_ISDIR(inode->i_mode)) {
VAR_1 = inode->i_private;
} else if (VAR_0 & VAR_7) {
return -VAR_8;
} else {
VAR_2 = d_find_any_alias(inode);
if (WARN_ON(!VAR_2))
return -VAR_9;
VAR_1 = VAR_2->d_fsdata;
}
VAR_4 = ovl_entry_real(VAR_1, &VAR_5);
VAR_3 = ACCESS_ONCE(VAR_4->d_inode);
if (!VAR_3) {
WARN_ON(!(VAR_0 & VAR_7));
VAR_6 = -VAR_9;
goto out_dput;
}
if (VAR_0 & VAR_10) {
umode_t VAR_11 = VAR_3->i_mode;
VAR_6 = -VAR_12;
if (VAR_5 && !IS_RDONLY(inode) && IS_RDONLY(VAR_3) &&
(S_ISREG(VAR_11) || S_ISDIR(VAR_11) || S_ISLNK(VAR_11)))
goto out_dput;
}
VAR_6 = __inode_permission(VAR_3, VAR_0);
out_dput:
dput(VAR_2);
return VAR_6;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/inode.c/vul/before/0.json,"int ovl_permission(struct inode *inode, int mask)
{
	struct ovl_entry *oe;
	struct dentry *alias = NULL;
	struct inode *realinode;
	struct dentry *realdentry;
	bool is_upper;
	int err;

	if (S_ISDIR(inode->i_mode)) {
		oe = inode->i_private;
	} else if (mask & MAY_NOT_BLOCK) {
		return -ECHILD;
	} else {
		/*
		 * For non-directories find an alias and get the info
		 * from there.
		 */
		alias = d_find_any_alias(inode);
		if (WARN_ON(!alias))
			return -ENOENT;

		oe = alias->d_fsdata;
	}

	realdentry = ovl_entry_real(oe, &is_upper);

	if (ovl_is_default_permissions(inode)) {
		struct kstat stat;
		struct path realpath = { .dentry = realdentry };

		if (mask & MAY_NOT_BLOCK)
			return -ECHILD;

		realpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);

		err = vfs_getattr(&realpath, &stat);
		if (err)
			return err;

		if ((stat.mode ^ inode->i_mode) & S_IFMT)
			return -ESTALE;

		inode->i_mode = stat.mode;
		inode->i_uid = stat.uid;
		inode->i_gid = stat.gid;

		return generic_permission(inode, mask);
	}

	/* Careful in RCU walk mode */
	realinode = ACCESS_ONCE(realdentry->d_inode);
	if (!realinode) {
		WARN_ON(!(mask & MAY_NOT_BLOCK));
		err = -ENOENT;
		goto out_dput;
	}

	if (mask & MAY_WRITE) {
		umode_t mode = realinode->i_mode;

		/*
		 * Writes will always be redirected to upper layer, so
		 * ignore lower layer being read-only.
		 *
		 * If the overlay itself is read-only then proceed
		 * with the permission check, don't return EROFS.
		 * This will only happen if this is the lower layer of
		 * another overlayfs.
		 *
		 * If upper fs becomes read-only after the overlay was
		 * constructed return EROFS to prevent modification of
		 * upper layer.
		 */
		err = -EROFS;
		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
			goto out_dput;
	}

	err = __inode_permission(realinode, mask);
out_dput:
	dput(alias);
	return err;
}","int ovl_permission(struct inode *inode, int VAR_0)
{
	struct ovl_entry *VAR_1;
	struct dentry *VAR_2 = NULL;
	struct inode *VAR_3;
	struct dentry *VAR_4;
	bool VAR_5;
	int VAR_6;

	if (S_ISDIR(inode->i_mode)) {
		VAR_1 = inode->i_private;
	} else if (VAR_0 & VAR_7) {
		return -VAR_8;
	} else {
		/* COMMENT_0 */
                                                       
                
     
		VAR_2 = d_find_any_alias(inode);
		if (WARN_ON(!VAR_2))
			return -VAR_9;

		VAR_1 = VAR_2->d_fsdata;
	}

	VAR_4 = ovl_entry_real(VAR_1, &VAR_5);

	if (ovl_is_default_permissions(inode)) {
		struct kstat VAR_10;
		struct path VAR_11 = { .dentry = VAR_4 };

		if (VAR_0 & VAR_7)
			return -VAR_8;

		VAR_11.mnt = ovl_entry_mnt_real(VAR_1, inode, VAR_5);

		VAR_6 = vfs_getattr(&VAR_11, &VAR_10);
		if (VAR_6)
			return VAR_6;

		if ((VAR_10.mode ^ inode->i_mode) & VAR_12)
			return -VAR_13;

		inode->i_mode = VAR_10.mode;
		inode->i_uid = VAR_10.uid;
		inode->i_gid = VAR_10.gid;

		return generic_permission(inode, VAR_0);
	}

	/* COMMENT_4 */
	VAR_3 = ACCESS_ONCE(VAR_4->d_inode);
	if (!VAR_3) {
		WARN_ON(!(VAR_0 & VAR_7));
		VAR_6 = -VAR_9;
		goto out_dput;
	}

	if (VAR_0 & VAR_14) {
		umode_t VAR_15 = VAR_3->i_mode;

		/* COMMENT_5 */
                                                        
                                        
    
                                                    
                                                   
                                                        
                       
    
                                                        
                                                        
                 
     
		VAR_6 = -VAR_16;
		if (VAR_5 && !IS_RDONLY(inode) && IS_RDONLY(VAR_3) &&
		    (S_ISREG(VAR_15) || S_ISDIR(VAR_15) || S_ISLNK(VAR_15)))
			goto out_dput;
	}

	VAR_6 = __inode_permission(VAR_3, VAR_0);
out_dput:
	dput(VAR_2);
	return VAR_6;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,6 +24,29 @@
 	}
 
 	realdentry = ovl_entry_real(oe, &is_upper);
+
+	if (ovl_is_default_permissions(inode)) {
+		struct kstat stat;
+		struct path realpath = { .dentry = realdentry };
+
+		if (mask & MAY_NOT_BLOCK)
+			return -ECHILD;
+
+		realpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);
+
+		err = vfs_getattr(&realpath, &stat);
+		if (err)
+			return err;
+
+		if ((stat.mode ^ inode->i_mode) & S_IFMT)
+			return -ESTALE;
+
+		inode->i_mode = stat.mode;
+		inode->i_uid = stat.uid;
+		inode->i_gid = stat.gid;
+
+		return generic_permission(inode, mask);
+	}
 
 	/* Careful in RCU walk mode */
 	realinode = ACCESS_ONCE(realdentry->d_inode);","{'deleted_lines': [], 'added_lines': ['', '\tif (ovl_is_default_permissions(inode)) {', '\t\tstruct kstat stat;', '\t\tstruct path realpath = { .dentry = realdentry };', '', '\t\tif (mask & MAY_NOT_BLOCK)', '\t\t\treturn -ECHILD;', '', '\t\trealpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);', '', '\t\terr = vfs_getattr(&realpath, &stat);', '\t\tif (err)', '\t\t\treturn err;', '', '\t\tif ((stat.mode ^ inode->i_mode) & S_IFMT)', '\t\t\treturn -ESTALE;', '', '\t\tinode->i_mode = stat.mode;', '\t\tinode->i_uid = stat.uid;', '\t\tinode->i_gid = stat.gid;', '', '\t\treturn generic_permission(inode, mask);', '\t}']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-1575,"['CWE-269', 'CWE-Other']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Pull overlayfs updates from Miklos Szeredi:
 ""This contains several bug fixes and a new mount option
  'default_permissions' that allows read-only exported NFS
  filesystems to be used as lower layer""

* 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
  ovl: check dentry positiveness in ovl_cleanup_whiteouts()
  ovl: setattr: check permissions before copy-up
  ovl: root: copy attr
  ovl: move super block magic number to magic.h
  ovl: use a minimal buffer in ovl_copy_xattr
  ovl: allow zero size xattr
  ovl: default permissions
",e9f57ebcba563e0cd532926cab83c92bb4d79360,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=e9f57ebcba563e0cd532926cab83c92bb4d79360,fs/overlayfs/inode.c,ovl_setattr,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
int err;
struct dentry *upperdentry;
err = ovl_want_write(dentry);
if (err)
goto out;
err = ovl_copy_up(dentry);
if (!err) {
upperdentry = ovl_dentry_upper(dentry);
mutex_lock(&upperdentry->d_inode->i_mutex);
err = notify_change(upperdentry, attr, NULL);
mutex_unlock(&upperdentry->d_inode->i_mutex);
}
ovl_drop_write(dentry);
out:
return err;
}","int ovl_setattr(struct dentry *dentry, struct iattr *VAR_0)
{
int VAR_1;
struct dentry *VAR_2;
VAR_1 = ovl_want_write(dentry);
if (VAR_1)
goto out;
VAR_1 = ovl_copy_up(dentry);
if (!VAR_1) {
VAR_2 = ovl_dentry_upper(dentry);
mutex_lock(&VAR_2->d_inode->i_mutex);
VAR_1 = notify_change(VAR_2, VAR_0, NULL);
mutex_unlock(&VAR_2->d_inode->i_mutex);
}
ovl_drop_write(dentry);
out:
return VAR_1;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/inode.c/vul/before/1.json,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	/*
	 * Check for permissions before trying to copy-up.  This is redundant
	 * since it will be rechecked later by ->setattr() on upper dentry.  But
	 * without this, copy-up can be triggered by just about anybody.
	 *
	 * We don't initialize inode->size, which just means that
	 * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not
	 * check for a swapfile (which this won't be anyway).
	 */
	err = inode_change_ok(dentry->d_inode, attr);
	if (err)
		return err;

	err = ovl_want_write(dentry);
	if (err)
		goto out;

	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

		mutex_lock(&upperdentry->d_inode->i_mutex);
		err = notify_change(upperdentry, attr, NULL);
		mutex_unlock(&upperdentry->d_inode->i_mutex);
	}
	ovl_drop_write(dentry);
out:
	return err;
}","int ovl_setattr(struct dentry *dentry, struct iattr *VAR_0)
{
	int VAR_1;
	struct dentry *VAR_2;

	/* COMMENT_0 */
                                                                      
                                                                         
                                                                 
   
                                                          
                                                                         
                                                      
    
	VAR_1 = inode_change_ok(dentry->d_inode, VAR_0);
	if (VAR_1)
		return VAR_1;

	VAR_1 = ovl_want_write(dentry);
	if (VAR_1)
		goto out;

	VAR_1 = ovl_copy_up(dentry);
	if (!VAR_1) {
		VAR_2 = ovl_dentry_upper(dentry);

		mutex_lock(&VAR_2->d_inode->i_mutex);
		VAR_1 = notify_change(VAR_2, VAR_0, NULL);
		mutex_unlock(&VAR_2->d_inode->i_mutex);
	}
	ovl_drop_write(dentry);
out:
	return VAR_1;
}",torvalds/linux/e9f57ebcba563e0cd532926cab83c92bb4d79360/inode.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,19 @@
 {
 	int err;
 	struct dentry *upperdentry;
+
+	/*
+	 * Check for permissions before trying to copy-up.  This is redundant
+	 * since it will be rechecked later by ->setattr() on upper dentry.  But
+	 * without this, copy-up can be triggered by just about anybody.
+	 *
+	 * We don't initialize inode->size, which just means that
+	 * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not
+	 * check for a swapfile (which this won't be anyway).
+	 */
+	err = inode_change_ok(dentry->d_inode, attr);
+	if (err)
+		return err;
 
 	err = ovl_want_write(dentry);
 	if (err)","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * Check for permissions before trying to copy-up.  This is redundant', '\t * since it will be rechecked later by ->setattr() on upper dentry.  But', '\t * without this, copy-up can be triggered by just about anybody.', '\t *', ""\t * We don't initialize inode->size, which just means that"", '\t * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not', ""\t * check for a swapfile (which this won't be anyway)."", '\t */', '\terr = inode_change_ok(dentry->d_inode, attr);', '\tif (err)', '\t\treturn err;']}",True,"The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.",7.8,HIGH,2,valid,,5
CVE-2016-2449,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Camera3Device: Validate template ID

Validate template ID before creating a default request.

Bug: 26866110
Bug: 27568958
Change-Id: Ifda457024f1d5c2b1382f189c1a8d5fda852d30d
",b04aee833c5cfb6b31b8558350feb14bb1a0f353,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353,services/camera/libcameraservice/device3/Camera3Device.cpp,Camera3Device::createDefaultRequest,"status_t Camera3Device::createDefaultRequest(int templateId,
CameraMetadata *request) {
ATRACE_CALL();
ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
Mutex::Autolock il(mInterfaceLock);
Mutex::Autolock l(mLock);
switch (mStatus) {
case STATUS_ERROR:
CLOGE(""Device has encountered a serious error"");
return INVALID_OPERATION;
case STATUS_UNINITIALIZED:
CLOGE(""Device is not initialized!"");
return INVALID_OPERATION;
case STATUS_UNCONFIGURED:
case STATUS_CONFIGURED:
case STATUS_ACTIVE:
break;
default:
SET_ERR_L(""Unexpected status: %d"", mStatus);
return INVALID_OPERATION;
}
if (!mRequestTemplateCache[templateId].isEmpty()) {
*request = mRequestTemplateCache[templateId];
return OK;
}
const camera_metadata_t *rawRequest;
ATRACE_BEGIN(""camera3->construct_default_request_settings"");
rawRequest = mHal3Device->ops->construct_default_request_settings(
mHal3Device, templateId);
ATRACE_END();
if (rawRequest == NULL) {
ALOGI(""%s: template %d is not supported on this camera device"",
__FUNCTION__, templateId);
return BAD_VALUE;
}
*request = rawRequest;
mRequestTemplateCache[templateId] = rawRequest;
return OK;
}","status_t Camera3Device::createDefaultRequest(int VAR_0,
CameraMetadata *VAR_1) {
ATRACE_CALL();
ALOGV(""%s: for template %d"", VAR_2, VAR_0);
Mutex::Autolock il(mInterfaceLock);
Mutex::Autolock l(mLock);
switch (VAR_3) {
case VAR_4:
CLOGE(""Device has encountered a serious error"");
return VAR_5;
case VAR_6:
CLOGE(""Device is not initialized!"");
return VAR_5;
case VAR_7:
case VAR_8:
case VAR_9:
break;
default:
SET_ERR_L(""Unexpected status: %d"", VAR_3);
return VAR_5;
}
if (!VAR_10[VAR_0].isEmpty()) {
*VAR_1 = VAR_10[VAR_0];
return VAR_11;
}
const camera_metadata_t *VAR_12;
ATRACE_BEGIN(""camera3->construct_default_request_settings"");
VAR_12 = VAR_13->ops->construct_default_request_settings(
VAR_13, VAR_0);
ATRACE_END();
if (VAR_12 == NULL) {
ALOGI(""%s: template %d is not supported on this camera device"",
VAR_2, VAR_0);
return VAR_14;
}
*VAR_1 = VAR_12;
VAR_10[VAR_0] = VAR_12;
return VAR_11;
}",android/b04aee833c5cfb6b31b8558350feb14bb1a0f353/Camera3Device.cpp/vul/before/0.json,"status_t Camera3Device::createDefaultRequest(int templateId,
        CameraMetadata *request) {
    ATRACE_CALL();
    ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

    Mutex::Autolock il(mInterfaceLock);
    Mutex::Autolock l(mLock);

    switch (mStatus) {
        case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
            return INVALID_OPERATION;
        case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
            return INVALID_OPERATION;
        case STATUS_UNCONFIGURED:
        case STATUS_CONFIGURED:
        case STATUS_ACTIVE:
            // OK
            break;
        default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
            return INVALID_OPERATION;
    }

    if (!mRequestTemplateCache[templateId].isEmpty()) {
        *request = mRequestTemplateCache[templateId];
        return OK;
    }

    const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
    if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
        return BAD_VALUE;
    }
    *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

    return OK;
}","status_t Camera3Device::createDefaultRequest(int VAR_0,
        CameraMetadata *VAR_1) {
    ATRACE_CALL();
    ALOGV(""%s: for template %d"", VAR_2, VAR_0);

    if (VAR_0 <= 0 || VAR_0 >= VAR_3) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return VAR_4;
    }

    Mutex::Autolock il(mInterfaceLock);
    Mutex::Autolock l(mLock);

    switch (VAR_5) {
        case VAR_6:
            CLOGE(""Device has encountered a serious error"");
            return VAR_7;
        case VAR_8:
            CLOGE(""Device is not initialized!"");
            return VAR_7;
        case VAR_9:
        case VAR_10:
        case VAR_11:
            /* COMMENT_0 */
            break;
        default:
            SET_ERR_L(""Unexpected status: %d"", VAR_5);
            return VAR_7;
    }

    if (!VAR_12[VAR_0].isEmpty()) {
        *VAR_1 = VAR_12[VAR_0];
        return VAR_13;
    }

    const camera_metadata_t *VAR_14;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    VAR_14 = VAR_15->ops->construct_default_request_settings(
        VAR_15, VAR_0);
    ATRACE_END();
    if (VAR_14 == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              VAR_2, VAR_0);
        return VAR_4;
    }
    *VAR_1 = VAR_14;
    VAR_12[VAR_0] = VAR_14;

    return VAR_13;
}",android/b04aee833c5cfb6b31b8558350feb14bb1a0f353/Camera3Device.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,13 @@
         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
+
+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
+                IPCThreadState::self()->getCallingUid(), NULL, 0);
+        return BAD_VALUE;
+    }
+
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 ","{'deleted_lines': [], 'added_lines': ['', '    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {', '        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",', '                IPCThreadState::self()->getCallingUid(), NULL, 0);', '        return BAD_VALUE;', '    }', '']}",True,"services/camera/libcameraservice/device3/Camera3Device.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate template IDs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27568958.",7.8,HIGH,2,valid,,5
CVE-2016-1664,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Fix HistoryEntry corruption when commit isn't for provisional entry (try #2).

BUG=597322, 600238
TEST=See bug for repro steps.
CQ_INCLUDE_TRYBOTS=tryserver.chromium.linux:linux_site_isolation

Review URL: https://codereview.chromium.org/1848813005

Cr-Commit-Position: refs/heads/master@{#386785}
",82500315884357312b3caafb49d347ef011c296f,https://chromium.googlesource.com/chromium/src/+/82500315884357312b3caafb49d347ef011c296f,content/renderer/history_controller.cc,HistoryController::UpdateForCommit,"void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
const WebHistoryItem& item,
WebHistoryCommitType commit_type,
bool navigation_within_page) {
switch (commit_type) {
case blink::WebBackForwardCommit:
if (!provisional_entry_)
return;
current_entry_.reset(provisional_entry_.release());
if (HistoryEntry::HistoryNode* node =
current_entry_->GetHistoryNodeForFrame(frame)) {
node->set_item(item);
}
break;
case blink::WebStandardCommit:
CreateNewBackForwardItem(frame, item, navigation_within_page);
break;
case blink::WebInitialCommitInChildFrame:
UpdateForInitialLoadInChildFrame(frame, item);
break;
case blink::WebHistoryInertCommit:
if (current_entry_) {
if (HistoryEntry::HistoryNode* node =
current_entry_->GetHistoryNodeForFrame(frame)) {
if (!navigation_within_page)
node->RemoveChildren();
node->set_item(item);
}
}
break;
default:
NOTREACHED() << ""Invalid commit type: "" << commit_type;
}
}","void HistoryController::UpdateForCommit(RenderFrameImpl* VAR_0,
const WebHistoryItem& VAR_1,
WebHistoryCommitType VAR_2,
bool VAR_3) {
switch (VAR_2) {
case blink::WebBackForwardCommit:
if (!VAR_4)
return;
VAR_5.reset(VAR_4.release());
if (HistoryEntry::HistoryNode* VAR_6 =
VAR_5->GetHistoryNodeForFrame(VAR_0)) {
VAR_6->set_item(VAR_1);
}
break;
case blink::WebStandardCommit:
CreateNewBackForwardItem(VAR_0, VAR_1, VAR_3);
break;
case blink::WebInitialCommitInChildFrame:
UpdateForInitialLoadInChildFrame(VAR_0, VAR_1);
break;
case blink::WebHistoryInertCommit:
if (VAR_5) {
if (HistoryEntry::HistoryNode* VAR_6 =
VAR_5->GetHistoryNodeForFrame(VAR_0)) {
if (!VAR_3)
VAR_6->RemoveChildren();
VAR_6->set_item(VAR_1);
}
}
break;
default:
NOTREACHED() << ""Invalid commit type: "" << VAR_2;
}
}",chromium/82500315884357312b3caafb49d347ef011c296f/history_controller.cc/vul/before/0.json,"void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
    case blink::WebBackForwardCommit:
      if (!provisional_entry_)
        return;

      // If the current entry is null, this must be a main frame commit.
      DCHECK(current_entry_ || frame->IsMainFrame());

      // Commit the provisional entry, but only if it is a plausible transition.
      // Do not commit it if the navigation is in a subframe and the provisional
      // entry's main frame item does not match the current entry's main frame,
      // which can happen if multiple forward navigations occur.  In that case,
      // committing the provisional entry would corrupt it, leading to a URL
      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug
      // does not affect main frame navigations, only navigations in subframes.)
      //
      // Note that we cannot compare the provisional entry against |item|, since
      // |item| may have redirected to a different URL and ISN.  We also cannot
      // compare against the main frame's URL, since that may have changed due
      // to a replaceState.  (Even origin can change on replaceState in certain
      // modes.)
      //
      // It would be safe to additionally check the ISNs of all parent frames
      // (and not just the root), but that is less critical because it won't
      // lead to a URL spoof.
      if (frame->IsMainFrame() ||
          current_entry_->root().itemSequenceNumber() ==
              provisional_entry_->root().itemSequenceNumber()) {
        current_entry_.reset(provisional_entry_.release());
      }

      // We're guaranteed to have a current entry now.
      DCHECK(current_entry_);

      if (HistoryEntry::HistoryNode* node =
              current_entry_->GetHistoryNodeForFrame(frame)) {
        node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      // Even for inert commits (e.g., location.replace, client redirects), make
      // sure the current entry gets updated, if there is one.
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          // Inert commits that reset the page without changing the item (e.g.,
          // reloads, location.replace) shouldn't keep the old subtree.
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}","void HistoryController::UpdateForCommit(RenderFrameImpl* VAR_0,
                                        const WebHistoryItem& VAR_1,
                                        WebHistoryCommitType VAR_2,
                                        bool VAR_3) {
  switch (VAR_2) {
    case blink::WebBackForwardCommit:
      if (!VAR_4)
        return;

      /* COMMENT_0 */
      DCHECK(VAR_5 || VAR_0->IsMainFrame());

      /* COMMENT_1 */
      /* COMMENT_2 */
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      /* COMMENT_8 */
      /* COMMENT_9 */
      /* COMMENT_10 */
      /* COMMENT_11 */
      /* COMMENT_12 */
      /* COMMENT_13 */
      /* COMMENT_8 */
      /* COMMENT_14 */
      /* COMMENT_15 */
      /* COMMENT_16 */
      if (VAR_0->IsMainFrame() ||
          VAR_5->root().itemSequenceNumber() ==
              VAR_4->root().itemSequenceNumber()) {
        VAR_5.reset(VAR_4.release());
      }

      /* COMMENT_17 */
      DCHECK(VAR_5);

      if (HistoryEntry::HistoryNode* VAR_6 =
              VAR_5->GetHistoryNodeForFrame(VAR_0)) {
        VAR_6->set_item(VAR_1);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(VAR_0, VAR_1, VAR_3);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(VAR_0, VAR_1);
      break;
    case blink::WebHistoryInertCommit:
      /* COMMENT_18 */
      /* COMMENT_19 */
      if (VAR_5) {
        if (HistoryEntry::HistoryNode* VAR_6 =
                VAR_5->GetHistoryNodeForFrame(VAR_0)) {
          /* COMMENT_20 */
          /* COMMENT_21 */
          if (!VAR_3)
            VAR_6->RemoveChildren();
          VAR_6->set_item(VAR_1);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << VAR_2;
  }
}",chromium/82500315884357312b3caafb49d347ef011c296f/history_controller.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,36 @@
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
-      current_entry_.reset(provisional_entry_.release());
+
+      // If the current entry is null, this must be a main frame commit.
+      DCHECK(current_entry_ || frame->IsMainFrame());
+
+      // Commit the provisional entry, but only if it is a plausible transition.
+      // Do not commit it if the navigation is in a subframe and the provisional
+      // entry's main frame item does not match the current entry's main frame,
+      // which can happen if multiple forward navigations occur.  In that case,
+      // committing the provisional entry would corrupt it, leading to a URL
+      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug
+      // does not affect main frame navigations, only navigations in subframes.)
+      //
+      // Note that we cannot compare the provisional entry against |item|, since
+      // |item| may have redirected to a different URL and ISN.  We also cannot
+      // compare against the main frame's URL, since that may have changed due
+      // to a replaceState.  (Even origin can change on replaceState in certain
+      // modes.)
+      //
+      // It would be safe to additionally check the ISNs of all parent frames
+      // (and not just the root), but that is less critical because it won't
+      // lead to a URL spoof.
+      if (frame->IsMainFrame() ||
+          current_entry_->root().itemSequenceNumber() ==
+              provisional_entry_->root().itemSequenceNumber()) {
+        current_entry_.reset(provisional_entry_.release());
+      }
+
+      // We're guaranteed to have a current entry now.
+      DCHECK(current_entry_);
+
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);","{'deleted_lines': ['      current_entry_.reset(provisional_entry_.release());'], 'added_lines': ['', '      // If the current entry is null, this must be a main frame commit.', '      DCHECK(current_entry_ || frame->IsMainFrame());', '', '      // Commit the provisional entry, but only if it is a plausible transition.', '      // Do not commit it if the navigation is in a subframe and the provisional', ""      // entry's main frame item does not match the current entry's main frame,"", '      // which can happen if multiple forward navigations occur.  In that case,', '      // committing the provisional entry would corrupt it, leading to a URL', '      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug', '      // does not affect main frame navigations, only navigations in subframes.)', '      //', '      // Note that we cannot compare the provisional entry against |item|, since', '      // |item| may have redirected to a different URL and ISN.  We also cannot', ""      // compare against the main frame's URL, since that may have changed due"", '      // to a replaceState.  (Even origin can change on replaceState in certain', '      // modes.)', '      //', '      // It would be safe to additionally check the ISNs of all parent frames', ""      // (and not just the root), but that is less critical because it won't"", '      // lead to a URL spoof.', '      if (frame->IsMainFrame() ||', '          current_entry_->root().itemSequenceNumber() ==', '              provisional_entry_->root().itemSequenceNumber()) {', '        current_entry_.reset(provisional_entry_.release());', '      }', '', ""      // We're guaranteed to have a current entry now."", '      DCHECK(current_entry_);', '']}",True,"The HistoryController::UpdateForCommit function in content/renderer/history_controller.cc in Google Chrome before 50.0.2661.94 mishandles the interaction between subframe forward navigations and other forward navigations, which allows remote attackers to spoof the address bar via a crafted web site.",4.3,MEDIUM,1,valid,,5
CVE-2016-1682,"['CWE-254', 'CWE-284']",AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Check CSP before registering ServiceWorkers

Service Worker registrations should be subject to the same CSP checks as
other workers. The spec doesn't say this explicitly
(https://www.w3.org/TR/CSP2/#directive-child-src-workers says ""Worker or
SharedWorker constructors""), but it seems to be in the spirit of things,
and it matches Firefox's behavior.

BUG=579801

Review URL: https://codereview.chromium.org/1861253004

Cr-Commit-Position: refs/heads/master@{#385775}
",5289a5d4c98681e9a0f2d28da0c7aa35e282db57,https://chromium.googlesource.com/chromium/src/+/5289a5d4c98681e9a0f2d28da0c7aa35e282db57,third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp,ServiceWorkerContainer::registerServiceWorkerImpl,"void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
if (!m_provider) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
return;
}
RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
String errorMessage;
if (!executionContext->isSecureContext(errorMessage)) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
return;
}
KURL pageURL = KURL(KURL(), documentOrigin->toString());
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
return;
}
KURL scriptURL = rawScriptURL;
scriptURL.removeFragmentIdentifier();
if (!documentOrigin->canRequest(scriptURL)) {
RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
return;
}
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
return;
}
KURL patternURL = scope;
patternURL.removeFragmentIdentifier();
if (!documentOrigin->canRequest(patternURL)) {
RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
return;
}
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
return;
}
WebString webErrorMessage;
if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
return;
}
m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
}","void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* VAR_0, const KURL& VAR_1, const KURL& VAR_2, PassOwnPtr<RegistrationCallbacks> VAR_3)
{
if (!VAR_4) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
return;
}
RefPtr<SecurityOrigin> VAR_5 = VAR_0->getSecurityOrigin();
String VAR_6;
if (!VAR_0->isSecureContext(VAR_6)) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, VAR_6));
return;
}
KURL VAR_7 = KURL(KURL(), VAR_5->toString());
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_7.protocol())) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + VAR_5->toString() + ""') is not supported."")));
return;
}
KURL VAR_8 = VAR_1;
VAR_8.removeFragmentIdentifier();
if (!VAR_5->canRequest(VAR_8)) {
RefPtr<SecurityOrigin> VAR_9 = SecurityOrigin::create(VAR_8);
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + VAR_9->toString() + ""') does not match the current origin ('"" + VAR_5->toString() + ""')."")));
return;
}
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_8.protocol())) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + VAR_8.getString() + ""') is not supported."")));
return;
}
KURL VAR_10 = VAR_2;
VAR_10.removeFragmentIdentifier();
if (!VAR_5->canRequest(VAR_10)) {
RefPtr<SecurityOrigin> VAR_11 = SecurityOrigin::create(VAR_10);
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + VAR_11->toString() + ""') does not match the current origin ('"" + VAR_5->toString() + ""')."")));
return;
}
if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_10.protocol())) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + VAR_10.getString() + ""') is not supported."")));
return;
}
WebString VAR_12;
if (!VAR_4->validateScopeAndScriptURL(VAR_10, VAR_8, &VAR_12)) {
VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + VAR_12.utf8())));
return;
}
VAR_4->registerServiceWorker(VAR_10, VAR_8, VAR_3.leakPtr());
}",chromium/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/ServiceWorkerContainer.cpp/vul/before/0.json,"void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
        return;
    }

    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
    if (csp) {
        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
            return;
        }
    }

    m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
}","void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* VAR_0, const KURL& VAR_1, const KURL& VAR_2, PassOwnPtr<RegistrationCallbacks> VAR_3)
{
    if (!VAR_4) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> VAR_5 = VAR_0->getSecurityOrigin();
    String VAR_6;
    /* COMMENT_0 */
    if (!VAR_0->isSecureContext(VAR_6)) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, VAR_6));
        return;
    }

    KURL VAR_7 = KURL(KURL(), VAR_5->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_7.protocol())) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + VAR_5->toString() + ""') is not supported."")));
        return;
    }

    KURL VAR_8 = VAR_1;
    VAR_8.removeFragmentIdentifier();
    if (!VAR_5->canRequest(VAR_8)) {
        RefPtr<SecurityOrigin> VAR_9 = SecurityOrigin::create(VAR_8);
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + VAR_9->toString() + ""') does not match the current origin ('"" + VAR_5->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_8.protocol())) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + VAR_8.getString() + ""') is not supported."")));
        return;
    }

    KURL VAR_10 = VAR_2;
    VAR_10.removeFragmentIdentifier();

    if (!VAR_5->canRequest(VAR_10)) {
        RefPtr<SecurityOrigin> VAR_11 = SecurityOrigin::create(VAR_10);
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + VAR_11->toString() + ""') does not match the current origin ('"" + VAR_5->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(VAR_10.protocol())) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + VAR_10.getString() + ""') is not supported."")));
        return;
    }

    WebString VAR_12;
    if (!VAR_4->validateScopeAndScriptURL(VAR_10, VAR_8, &VAR_12)) {
        VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + VAR_12.utf8())));
        return;
    }

    ContentSecurityPolicy* VAR_13 = VAR_0->contentSecurityPolicy();
    if (VAR_13) {
        if (!VAR_13->allowWorkerContextFromSource(VAR_8, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
            VAR_3->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + VAR_8.getString() + ""') violates the Content Security Policy."")));
            return;
        }
    }

    VAR_4->registerServiceWorker(VAR_10, VAR_8, VAR_3.leakPtr());
}",chromium/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/ServiceWorkerContainer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,5 +50,13 @@
         return;
     }
 
+    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
+    if (csp) {
+        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
+            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
+            return;
+        }
+    }
+
     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }","{'deleted_lines': [], 'added_lines': ['    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();', '    if (csp) {', '        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {', '            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL (\'"" + scriptURL.getString() + ""\') violates the Content Security Policy."")));', '            return;', '        }', '    }', '']}",True,"The ServiceWorkerContainer::registerServiceWorkerImpl function in WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp in Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a ServiceWorker registration.",6.1,MEDIUM,1,valid,,5
CVE-2016-1685,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pdfium,"Fix integer issues leading to out of bounds access in fx_ge_text.cpp.

- Using |-skew| to get positive index, which doesn't work when skew is
  INT_MIN
- Incorrect logic when determining when to use |-skew| as an index.

R=tsepez@chromium.org,weili@chromium.org
BUG=chromium:601362

Review URL: https://codereview.chromium.org/1875673004
",b8627c9d13884d48943d8a7a5381eaf0bb2c08d9,https://pdfium.googlesource.com/pdfium/+/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9,core/fxge/ge/fx_ge_text.cpp,CFX_FaceCache::RenderGlyph,"CFX_GlyphBitmap* CFX_FaceCache::RenderGlyph(CFX_Font* pFont,
uint32_t glyph_index,
FX_BOOL bFontStyle,
const CFX_Matrix* pMatrix,
int dest_width,
int anti_alias) {
if (!m_Face) {
return NULL;
}
FXFT_Matrix ft_matrix;
ft_matrix.xx = (signed long)(pMatrix->GetA() / 64 * 65536);
ft_matrix.xy = (signed long)(pMatrix->GetC() / 64 * 65536);
ft_matrix.yx = (signed long)(pMatrix->GetB() / 64 * 65536);
ft_matrix.yy = (signed long)(pMatrix->GetD() / 64 * 65536);
FX_BOOL bUseCJKSubFont = FALSE;
const CFX_SubstFont* pSubstFont = pFont->GetSubstFont();
if (pSubstFont) {
bUseCJKSubFont = pSubstFont->m_bSubstOfCJK && bFontStyle;
int skew = 0;
if (bUseCJKSubFont) {
skew = pSubstFont->m_bItlicCJK ? -15 : 0;
} else {
skew = pSubstFont->m_ItalicAngle;
}
if (skew) {
skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)
? -58
: -g_AngleSkew[-skew];
if (pFont->IsVertical())
ft_matrix.yx += ft_matrix.yy * skew / 100;
else
ft_matrix.xy += -ft_matrix.xx * skew / 100;
}
if (pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) {
pFont->AdjustMMParams(glyph_index, dest_width,
pFont->GetSubstFont()->m_Weight);
}
}
ScopedFontTransform scoped_transform(m_Face, &ft_matrix);
int load_flags = (m_Face->face_flags & FT_FACE_FLAG_SFNT)
? FXFT_LOAD_NO_BITMAP
: (FXFT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING);
int error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags);
if (error) {
if (load_flags & FT_LOAD_NO_HINTING || load_flags & FT_LOAD_NO_SCALE) {
return NULL;
}
load_flags |= FT_LOAD_NO_HINTING;
error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags);
if (error) {
return NULL;
}
}
int weight = 0;
if (bUseCJKSubFont) {
weight = pSubstFont->m_WeightCJK;
} else {
weight = pSubstFont ? pSubstFont->m_Weight : 0;
}
if (pSubstFont && !(pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) &&
weight > 400) {
uint32_t index = (weight - 400) / 10;
if (index >= WEIGHTPOW_ARRAY_SIZE)
return NULL;
int level = 0;
if (pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET) {
level =
g_WeightPow_SHIFTJIS[index] * 2 *
(FXSYS_abs((int)(ft_matrix.xx)) + FXSYS_abs((int)(ft_matrix.xy))) /
36655;
} else {
level = g_WeightPow_11[index] * (FXSYS_abs((int)(ft_matrix.xx)) +
FXSYS_abs((int)(ft_matrix.xy))) /
36655;
}
FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level);
}
FXFT_Library_SetLcdFilter(CFX_GEModule::Get()->GetFontMgr()->GetFTLibrary(),
FT_LCD_FILTER_DEFAULT);
error = FXFT_Render_Glyph(m_Face, anti_alias);
if (error) {
return NULL;
}
int bmwidth = FXFT_Get_Bitmap_Width(FXFT_Get_Glyph_Bitmap(m_Face));
int bmheight = FXFT_Get_Bitmap_Rows(FXFT_Get_Glyph_Bitmap(m_Face));
if (bmwidth > 2048 || bmheight > 2048) {
return NULL;
}
int dib_width = bmwidth;
CFX_GlyphBitmap* pGlyphBitmap = new CFX_GlyphBitmap;
pGlyphBitmap->m_Bitmap.Create(
dib_width, bmheight,
anti_alias == FXFT_RENDER_MODE_MONO ? FXDIB_1bppMask : FXDIB_8bppMask);
pGlyphBitmap->m_Left = FXFT_Get_Glyph_BitmapLeft(m_Face);
pGlyphBitmap->m_Top = FXFT_Get_Glyph_BitmapTop(m_Face);
int dest_pitch = pGlyphBitmap->m_Bitmap.GetPitch();
int src_pitch = FXFT_Get_Bitmap_Pitch(FXFT_Get_Glyph_Bitmap(m_Face));
uint8_t* pDestBuf = pGlyphBitmap->m_Bitmap.GetBuffer();
uint8_t* pSrcBuf =
(uint8_t*)FXFT_Get_Bitmap_Buffer(FXFT_Get_Glyph_Bitmap(m_Face));
if (anti_alias != FXFT_RENDER_MODE_MONO &&
FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) ==
FXFT_PIXEL_MODE_MONO) {
int bytes = anti_alias == FXFT_RENDER_MODE_LCD ? 3 : 1;
for (int i = 0; i < bmheight; i++)
for (int n = 0; n < bmwidth; n++) {
uint8_t data =
(pSrcBuf[i * src_pitch + n / 8] & (0x80 >> (n % 8))) ? 255 : 0;
for (int b = 0; b < bytes; b++) {
pDestBuf[i * dest_pitch + n * bytes + b] = data;
}
}
} else {
FXSYS_memset(pDestBuf, 0, dest_pitch * bmheight);
if (anti_alias == FXFT_RENDER_MODE_MONO &&
FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) ==
FXFT_PIXEL_MODE_MONO) {
int rowbytes =
FXSYS_abs(src_pitch) > dest_pitch ? dest_pitch : FXSYS_abs(src_pitch);
for (int row = 0; row < bmheight; row++) {
FXSYS_memcpy(pDestBuf + row * dest_pitch, pSrcBuf + row * src_pitch,
rowbytes);
}
} else {
_ContrastAdjust(pSrcBuf, pDestBuf, bmwidth, bmheight, src_pitch,
dest_pitch);
_GammaAdjust(pDestBuf, bmwidth, bmheight, dest_pitch,
CFX_GEModule::Get()->GetTextGammaTable());
}
}
return pGlyphBitmap;
}","CFX_GlyphBitmap* CFX_FaceCache::RenderGlyph(CFX_Font* VAR_0,
uint32_t VAR_1,
FX_BOOL VAR_2,
const CFX_Matrix* VAR_3,
int VAR_4,
int VAR_5) {
if (!VAR_6) {
return NULL;
}
FXFT_Matrix VAR_7;
VAR_7.xx = (signed long)(VAR_3->GetA() / 64 * 65536);
VAR_7.xy = (signed long)(VAR_3->GetC() / 64 * 65536);
VAR_7.yx = (signed long)(VAR_3->GetB() / 64 * 65536);
VAR_7.yy = (signed long)(VAR_3->GetD() / 64 * 65536);
FX_BOOL VAR_8 = FALSE;
const CFX_SubstFont* VAR_9 = VAR_0->GetSubstFont();
if (VAR_9) {
VAR_8 = VAR_9->m_bSubstOfCJK && VAR_2;
int VAR_10 = 0;
if (VAR_8) {
VAR_10 = VAR_9->m_bItlicCJK ? -15 : 0;
} else {
VAR_10 = VAR_9->m_ItalicAngle;
}
if (VAR_10) {
VAR_10 = -VAR_10 <= VAR_11<int>(VAR_12)
? -58
: -VAR_13[-VAR_10];
if (VAR_0->IsVertical())
VAR_7.yx += VAR_7.yy * VAR_10 / 100;
else
VAR_7.xy += -VAR_7.xx * VAR_10 / 100;
}
if (VAR_9->m_SubstFlags & VAR_14) {
VAR_0->AdjustMMParams(VAR_1, VAR_4,
VAR_0->GetSubstFont()->m_Weight);
}
}
ScopedFontTransform VAR_15(VAR_6, &VAR_7);
int VAR_16 = (VAR_6->face_flags & VAR_17)
? VAR_18
: (VAR_18 | VAR_19);
int VAR_20 = FXFT_Load_Glyph(VAR_6, VAR_1, VAR_16);
if (VAR_20) {
if (VAR_16 & VAR_19 || VAR_16 & VAR_21) {
return NULL;
}
VAR_16 |= VAR_19;
VAR_20 = FXFT_Load_Glyph(VAR_6, VAR_1, VAR_16);
if (VAR_20) {
return NULL;
}
}
int VAR_22 = 0;
if (VAR_8) {
VAR_22 = VAR_9->m_WeightCJK;
} else {
VAR_22 = VAR_9 ? VAR_9->m_Weight : 0;
}
if (VAR_9 && !(VAR_9->m_SubstFlags & VAR_14) &&
VAR_22 > 400) {
uint32_t VAR_23 = (VAR_22 - 400) / 10;
if (VAR_23 >= VAR_24)
return NULL;
int VAR_25 = 0;
if (VAR_9->m_Charset == VAR_26) {
VAR_25 =
VAR_27[VAR_23] * 2 *
(FXSYS_abs((int)(VAR_7.xx)) + FXSYS_abs((int)(VAR_7.xy))) /
36655;
} else {
VAR_25 = VAR_28[VAR_23] * (FXSYS_abs((int)(VAR_7.xx)) +
FXSYS_abs((int)(VAR_7.xy))) /
36655;
}
FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(VAR_6), VAR_25);
}
FXFT_Library_SetLcdFilter(CFX_GEModule::Get()->GetFontMgr()->GetFTLibrary(),
VAR_29);
VAR_20 = FXFT_Render_Glyph(VAR_6, VAR_5);
if (VAR_20) {
return NULL;
}
int VAR_30 = FXFT_Get_Bitmap_Width(FXFT_Get_Glyph_Bitmap(VAR_6));
int VAR_31 = FXFT_Get_Bitmap_Rows(FXFT_Get_Glyph_Bitmap(VAR_6));
if (VAR_30 > 2048 || VAR_31 > 2048) {
return NULL;
}
int VAR_32 = VAR_30;
CFX_GlyphBitmap* VAR_33 = new CFX_GlyphBitmap;
VAR_33->m_Bitmap.Create(
VAR_32, VAR_31,
VAR_5 == VAR_34 ? VAR_35 : VAR_36);
VAR_33->m_Left = FXFT_Get_Glyph_BitmapLeft(VAR_6);
VAR_33->m_Top = FXFT_Get_Glyph_BitmapTop(VAR_6);
int VAR_37 = VAR_33->m_Bitmap.GetPitch();
int VAR_38 = FXFT_Get_Bitmap_Pitch(FXFT_Get_Glyph_Bitmap(VAR_6));
uint8_t* VAR_39 = VAR_33->m_Bitmap.GetBuffer();
uint8_t* VAR_40 =
(uint8_t*)FXFT_Get_Bitmap_Buffer(FXFT_Get_Glyph_Bitmap(VAR_6));
if (VAR_5 != VAR_34 &&
FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(VAR_6)) ==
VAR_41) {
int VAR_42 = VAR_5 == VAR_43 ? 3 : 1;
for (int VAR_44 = 0; VAR_44 < VAR_31; VAR_44++)
for (int VAR_45 = 0; VAR_45 < VAR_30; VAR_45++) {
uint8_t VAR_46 =
(VAR_40[VAR_44 * VAR_38 + VAR_45 / 8] & (0x80 >> (VAR_45 % 8))) ? 255 : 0;
for (int VAR_47 = 0; VAR_47 < VAR_42; VAR_47++) {
VAR_39[VAR_44 * VAR_37 + VAR_45 * VAR_42 + VAR_47] = VAR_46;
}
}
} else {
FXSYS_memset(VAR_39, 0, VAR_37 * VAR_31);
if (VAR_5 == VAR_34 &&
FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(VAR_6)) ==
VAR_41) {
int VAR_48 =
FXSYS_abs(VAR_38) > VAR_37 ? VAR_37 : FXSYS_abs(VAR_38);
for (int VAR_49 = 0; VAR_49 < VAR_31; VAR_49++) {
FXSYS_memcpy(VAR_39 + VAR_49 * VAR_37, VAR_40 + VAR_49 * VAR_38,
VAR_48);
}
} else {
_ContrastAdjust(VAR_40, VAR_39, VAR_30, VAR_31, VAR_38,
VAR_37);
_GammaAdjust(VAR_39, VAR_30, VAR_31, VAR_37,
CFX_GEModule::Get()->GetTextGammaTable());
}
}
return VAR_33;
}",pdfium/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9/fx_ge_text.cpp/vul/before/0.json,"CFX_GlyphBitmap* CFX_FaceCache::RenderGlyph(CFX_Font* pFont,
                                            uint32_t glyph_index,
                                            FX_BOOL bFontStyle,
                                            const CFX_Matrix* pMatrix,
                                            int dest_width,
                                            int anti_alias) {
  if (!m_Face) {
    return NULL;
  }
  FXFT_Matrix ft_matrix;
  ft_matrix.xx = (signed long)(pMatrix->GetA() / 64 * 65536);
  ft_matrix.xy = (signed long)(pMatrix->GetC() / 64 * 65536);
  ft_matrix.yx = (signed long)(pMatrix->GetB() / 64 * 65536);
  ft_matrix.yy = (signed long)(pMatrix->GetD() / 64 * 65536);
  FX_BOOL bUseCJKSubFont = FALSE;
  const CFX_SubstFont* pSubstFont = pFont->GetSubstFont();
  if (pSubstFont) {
    bUseCJKSubFont = pSubstFont->m_bSubstOfCJK && bFontStyle;
    int skew = 0;
    if (bUseCJKSubFont) {
      skew = pSubstFont->m_bItlicCJK ? -15 : 0;
    } else {
      skew = pSubstFont->m_ItalicAngle;
    }
    if (skew) {
      // |skew| is nonpositive so |-skew| is used as the index. We need to make
      // sure |skew| != INT_MIN since -INT_MIN is undefined.
      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&
          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {
        skew = -g_AngleSkew[-skew];
      } else {
        skew = -58;
      }
      if (pFont->IsVertical())
        ft_matrix.yx += ft_matrix.yy * skew / 100;
      else
        ft_matrix.xy += -ft_matrix.xx * skew / 100;
    }
    if (pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) {
      pFont->AdjustMMParams(glyph_index, dest_width,
                            pFont->GetSubstFont()->m_Weight);
    }
  }
  ScopedFontTransform scoped_transform(m_Face, &ft_matrix);
  int load_flags = (m_Face->face_flags & FT_FACE_FLAG_SFNT)
                       ? FXFT_LOAD_NO_BITMAP
                       : (FXFT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING);
  int error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags);
  if (error) {
    // if an error is returned, try to reload glyphs without hinting.
    if (load_flags & FT_LOAD_NO_HINTING || load_flags & FT_LOAD_NO_SCALE) {
      return NULL;
    }

    load_flags |= FT_LOAD_NO_HINTING;
    error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags);

    if (error) {
      return NULL;
    }
  }
  int weight = 0;
  if (bUseCJKSubFont) {
    weight = pSubstFont->m_WeightCJK;
  } else {
    weight = pSubstFont ? pSubstFont->m_Weight : 0;
  }
  if (pSubstFont && !(pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) &&
      weight > 400) {
    uint32_t index = (weight - 400) / 10;
    if (index >= WEIGHTPOW_ARRAY_SIZE)
      return NULL;
    int level = 0;
    if (pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET) {
      level =
          g_WeightPow_SHIFTJIS[index] * 2 *
          (FXSYS_abs((int)(ft_matrix.xx)) + FXSYS_abs((int)(ft_matrix.xy))) /
          36655;
    } else {
      level = g_WeightPow_11[index] * (FXSYS_abs((int)(ft_matrix.xx)) +
                                       FXSYS_abs((int)(ft_matrix.xy))) /
              36655;
    }
    FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level);
  }
  FXFT_Library_SetLcdFilter(CFX_GEModule::Get()->GetFontMgr()->GetFTLibrary(),
                            FT_LCD_FILTER_DEFAULT);
  error = FXFT_Render_Glyph(m_Face, anti_alias);
  if (error) {
    return NULL;
  }
  int bmwidth = FXFT_Get_Bitmap_Width(FXFT_Get_Glyph_Bitmap(m_Face));
  int bmheight = FXFT_Get_Bitmap_Rows(FXFT_Get_Glyph_Bitmap(m_Face));
  if (bmwidth > 2048 || bmheight > 2048) {
    return NULL;
  }
  int dib_width = bmwidth;
  CFX_GlyphBitmap* pGlyphBitmap = new CFX_GlyphBitmap;
  pGlyphBitmap->m_Bitmap.Create(
      dib_width, bmheight,
      anti_alias == FXFT_RENDER_MODE_MONO ? FXDIB_1bppMask : FXDIB_8bppMask);
  pGlyphBitmap->m_Left = FXFT_Get_Glyph_BitmapLeft(m_Face);
  pGlyphBitmap->m_Top = FXFT_Get_Glyph_BitmapTop(m_Face);
  int dest_pitch = pGlyphBitmap->m_Bitmap.GetPitch();
  int src_pitch = FXFT_Get_Bitmap_Pitch(FXFT_Get_Glyph_Bitmap(m_Face));
  uint8_t* pDestBuf = pGlyphBitmap->m_Bitmap.GetBuffer();
  uint8_t* pSrcBuf =
      (uint8_t*)FXFT_Get_Bitmap_Buffer(FXFT_Get_Glyph_Bitmap(m_Face));
  if (anti_alias != FXFT_RENDER_MODE_MONO &&
      FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) ==
          FXFT_PIXEL_MODE_MONO) {
    int bytes = anti_alias == FXFT_RENDER_MODE_LCD ? 3 : 1;
    for (int i = 0; i < bmheight; i++)
      for (int n = 0; n < bmwidth; n++) {
        uint8_t data =
            (pSrcBuf[i * src_pitch + n / 8] & (0x80 >> (n % 8))) ? 255 : 0;
        for (int b = 0; b < bytes; b++) {
          pDestBuf[i * dest_pitch + n * bytes + b] = data;
        }
      }
  } else {
    FXSYS_memset(pDestBuf, 0, dest_pitch * bmheight);
    if (anti_alias == FXFT_RENDER_MODE_MONO &&
        FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) ==
            FXFT_PIXEL_MODE_MONO) {
      int rowbytes =
          FXSYS_abs(src_pitch) > dest_pitch ? dest_pitch : FXSYS_abs(src_pitch);
      for (int row = 0; row < bmheight; row++) {
        FXSYS_memcpy(pDestBuf + row * dest_pitch, pSrcBuf + row * src_pitch,
                     rowbytes);
      }
    } else {
      _ContrastAdjust(pSrcBuf, pDestBuf, bmwidth, bmheight, src_pitch,
                      dest_pitch);
      _GammaAdjust(pDestBuf, bmwidth, bmheight, dest_pitch,
                   CFX_GEModule::Get()->GetTextGammaTable());
    }
  }
  return pGlyphBitmap;
}","CFX_GlyphBitmap* CFX_FaceCache::RenderGlyph(CFX_Font* VAR_0,
                                            uint32_t VAR_1,
                                            FX_BOOL VAR_2,
                                            const CFX_Matrix* VAR_3,
                                            int VAR_4,
                                            int VAR_5) {
  if (!VAR_6) {
    return NULL;
  }
  FXFT_Matrix VAR_7;
  VAR_7.xx = (signed long)(VAR_3->GetA() / 64 * 65536);
  VAR_7.xy = (signed long)(VAR_3->GetC() / 64 * 65536);
  VAR_7.yx = (signed long)(VAR_3->GetB() / 64 * 65536);
  VAR_7.yy = (signed long)(VAR_3->GetD() / 64 * 65536);
  FX_BOOL VAR_8 = FALSE;
  const CFX_SubstFont* VAR_9 = VAR_0->GetSubstFont();
  if (VAR_9) {
    VAR_8 = VAR_9->m_bSubstOfCJK && VAR_2;
    int VAR_10 = 0;
    if (VAR_8) {
      VAR_10 = VAR_9->m_bItlicCJK ? -15 : 0;
    } else {
      VAR_10 = VAR_9->m_ItalicAngle;
    }
    if (VAR_10) {
      /* COMMENT_0 */
      /* COMMENT_1 */
      if (VAR_10 <= 0 && VAR_10 != std::numeric_limits<int>::min() &&
          VAR_11<size_t>(-VAR_10) < VAR_12) {
        VAR_10 = -VAR_13[-VAR_10];
      } else {
        VAR_10 = -58;
      }
      if (VAR_0->IsVertical())
        VAR_7.yx += VAR_7.yy * VAR_10 / 100;
      else
        VAR_7.xy += -VAR_7.xx * VAR_10 / 100;
    }
    if (VAR_9->m_SubstFlags & VAR_14) {
      VAR_0->AdjustMMParams(VAR_1, VAR_4,
                            VAR_0->GetSubstFont()->m_Weight);
    }
  }
  ScopedFontTransform VAR_15(VAR_6, &VAR_7);
  int VAR_16 = (VAR_6->face_flags & VAR_17)
                       ? VAR_18
                       : (VAR_18 | VAR_19);
  int VAR_20 = FXFT_Load_Glyph(VAR_6, VAR_1, VAR_16);
  if (VAR_20) {
    /* COMMENT_2 */
    if (VAR_16 & VAR_19 || VAR_16 & VAR_21) {
      return NULL;
    }

    VAR_16 |= VAR_19;
    VAR_20 = FXFT_Load_Glyph(VAR_6, VAR_1, VAR_16);

    if (VAR_20) {
      return NULL;
    }
  }
  int VAR_22 = 0;
  if (VAR_8) {
    VAR_22 = VAR_9->m_WeightCJK;
  } else {
    VAR_22 = VAR_9 ? VAR_9->m_Weight : 0;
  }
  if (VAR_9 && !(VAR_9->m_SubstFlags & VAR_14) &&
      VAR_22 > 400) {
    uint32_t VAR_23 = (VAR_22 - 400) / 10;
    if (VAR_23 >= VAR_24)
      return NULL;
    int VAR_25 = 0;
    if (VAR_9->m_Charset == VAR_26) {
      VAR_25 =
          VAR_27[VAR_23] * 2 *
          (FXSYS_abs((int)(VAR_7.xx)) + FXSYS_abs((int)(VAR_7.xy))) /
          36655;
    } else {
      VAR_25 = VAR_28[VAR_23] * (FXSYS_abs((int)(VAR_7.xx)) +
                                       FXSYS_abs((int)(VAR_7.xy))) /
              36655;
    }
    FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(VAR_6), VAR_25);
  }
  FXFT_Library_SetLcdFilter(CFX_GEModule::Get()->GetFontMgr()->GetFTLibrary(),
                            VAR_29);
  VAR_20 = FXFT_Render_Glyph(VAR_6, VAR_5);
  if (VAR_20) {
    return NULL;
  }
  int VAR_30 = FXFT_Get_Bitmap_Width(FXFT_Get_Glyph_Bitmap(VAR_6));
  int VAR_31 = FXFT_Get_Bitmap_Rows(FXFT_Get_Glyph_Bitmap(VAR_6));
  if (VAR_30 > 2048 || VAR_31 > 2048) {
    return NULL;
  }
  int VAR_32 = VAR_30;
  CFX_GlyphBitmap* VAR_33 = new CFX_GlyphBitmap;
  VAR_33->m_Bitmap.Create(
      VAR_32, VAR_31,
      VAR_5 == VAR_34 ? VAR_35 : VAR_36);
  VAR_33->m_Left = FXFT_Get_Glyph_BitmapLeft(VAR_6);
  VAR_33->m_Top = FXFT_Get_Glyph_BitmapTop(VAR_6);
  int VAR_37 = VAR_33->m_Bitmap.GetPitch();
  int VAR_38 = FXFT_Get_Bitmap_Pitch(FXFT_Get_Glyph_Bitmap(VAR_6));
  uint8_t* VAR_39 = VAR_33->m_Bitmap.GetBuffer();
  uint8_t* VAR_40 =
      (uint8_t*)FXFT_Get_Bitmap_Buffer(FXFT_Get_Glyph_Bitmap(VAR_6));
  if (VAR_5 != VAR_34 &&
      FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(VAR_6)) ==
          VAR_41) {
    int VAR_42 = VAR_5 == VAR_43 ? 3 : 1;
    for (int VAR_44 = 0; VAR_44 < VAR_31; VAR_44++)
      for (int VAR_45 = 0; VAR_45 < VAR_30; VAR_45++) {
        uint8_t VAR_46 =
            (VAR_40[VAR_44 * VAR_38 + VAR_45 / 8] & (0x80 >> (VAR_45 % 8))) ? 255 : 0;
        for (int VAR_47 = 0; VAR_47 < VAR_42; VAR_47++) {
          VAR_39[VAR_44 * VAR_37 + VAR_45 * VAR_42 + VAR_47] = VAR_46;
        }
      }
  } else {
    FXSYS_memset(VAR_39, 0, VAR_37 * VAR_31);
    if (VAR_5 == VAR_34 &&
        FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(VAR_6)) ==
            VAR_41) {
      int VAR_48 =
          FXSYS_abs(VAR_38) > VAR_37 ? VAR_37 : FXSYS_abs(VAR_38);
      for (int VAR_49 = 0; VAR_49 < VAR_31; VAR_49++) {
        FXSYS_memcpy(VAR_39 + VAR_49 * VAR_37, VAR_40 + VAR_49 * VAR_38,
                     VAR_48);
      }
    } else {
      _ContrastAdjust(VAR_40, VAR_39, VAR_30, VAR_31, VAR_38,
                      VAR_37);
      _GammaAdjust(VAR_39, VAR_30, VAR_31, VAR_37,
                   CFX_GEModule::Get()->GetTextGammaTable());
    }
  }
  return VAR_33;
}",pdfium/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9/fx_ge_text.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,10 +23,14 @@
       skew = pSubstFont->m_ItalicAngle;
     }
     if (skew) {
-      // skew is nonpositive so -skew is used as the index.
-      skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)
-                 ? -58
-                 : -g_AngleSkew[-skew];
+      // |skew| is nonpositive so |-skew| is used as the index. We need to make
+      // sure |skew| != INT_MIN since -INT_MIN is undefined.
+      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&
+          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {
+        skew = -g_AngleSkew[-skew];
+      } else {
+        skew = -58;
+      }
       if (pFont->IsVertical())
         ft_matrix.yx += ft_matrix.yy * skew / 100;
       else","{'deleted_lines': ['      // skew is nonpositive so -skew is used as the index.', '      skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)', '                 ? -58', '                 : -g_AngleSkew[-skew];'], 'added_lines': ['      // |skew| is nonpositive so |-skew| is used as the index. We need to make', '      // sure |skew| != INT_MIN since -INT_MIN is undefined.', '      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&', '          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {', '        skew = -g_AngleSkew[-skew];', '      } else {', '        skew = -58;', '      }']}",True,"core/fxge/ge/fx_ge_text.cpp in PDFium, as used in Google Chrome before 51.0.2704.63, miscalculates certain index values, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document.",6.5,MEDIUM,1,valid,,5
CVE-2016-1685,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pdfium,"Fix integer issues leading to out of bounds access in fx_ge_text.cpp.

- Using |-skew| to get positive index, which doesn't work when skew is
  INT_MIN
- Incorrect logic when determining when to use |-skew| as an index.

R=tsepez@chromium.org,weili@chromium.org
BUG=chromium:601362

Review URL: https://codereview.chromium.org/1875673004
",b8627c9d13884d48943d8a7a5381eaf0bb2c08d9,https://pdfium.googlesource.com/pdfium/+/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9,core/fxge/ge/fx_ge_text.cpp,CFX_Font::LoadGlyphPath,"CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t glyph_index, int dest_width) {
if (!m_Face) {
return NULL;
}
FXFT_Set_Pixel_Sizes(m_Face, 0, 64);
FXFT_Matrix ft_matrix = {65536, 0, 0, 65536};
if (m_pSubstFont) {
if (m_pSubstFont->m_ItalicAngle) {
int skew = m_pSubstFont->m_ItalicAngle;
skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)
? -58
: -g_AngleSkew[-skew];
if (m_bVertical)
ft_matrix.yx += ft_matrix.yy * skew / 100;
else
ft_matrix.xy += -ft_matrix.xx * skew / 100;
}
if (m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) {
AdjustMMParams(glyph_index, dest_width, m_pSubstFont->m_Weight);
}
}
ScopedFontTransform scoped_transform(m_Face, &ft_matrix);
int load_flags = FXFT_LOAD_NO_BITMAP;
if (!(m_Face->face_flags & FT_FACE_FLAG_SFNT) || !FT_IS_TRICKY(m_Face)) {
load_flags |= FT_LOAD_NO_HINTING;
}
if (FXFT_Load_Glyph(m_Face, glyph_index, load_flags))
return NULL;
if (m_pSubstFont && !(m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) &&
m_pSubstFont->m_Weight > 400) {
uint32_t index = (m_pSubstFont->m_Weight - 400) / 10;
if (index >= WEIGHTPOW_ARRAY_SIZE)
index = WEIGHTPOW_ARRAY_SIZE - 1;
int level = 0;
if (m_pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET)
level = g_WeightPow_SHIFTJIS[index] * 2 * 65536 / 36655;
else
level = g_WeightPow[index] * 2;
FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level);
}
FXFT_Outline_Funcs funcs;
funcs.move_to = _Outline_MoveTo;
funcs.line_to = _Outline_LineTo;
funcs.conic_to = _Outline_ConicTo;
funcs.cubic_to = _Outline_CubicTo;
funcs.shift = 0;
funcs.delta = 0;
OUTLINE_PARAMS params;
params.m_bCount = TRUE;
params.m_PointCount = 0;
FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);
if (params.m_PointCount == 0) {
return NULL;
}
CFX_PathData* pPath = new CFX_PathData;
pPath->SetPointCount(params.m_PointCount);
params.m_bCount = FALSE;
params.m_PointCount = 0;
params.m_pPoints = pPath->GetPoints();
params.m_CurX = params.m_CurY = 0;
params.m_CoordUnit = 64 * 64.0;
FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);
_Outline_CheckEmptyContour(&params);
pPath->TrimPoints(params.m_PointCount);
if (params.m_PointCount) {
pPath->GetPoints()[params.m_PointCount - 1].m_Flag |= FXPT_CLOSEFIGURE;
}
return pPath;
}","CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t VAR_0, int VAR_1) {
if (!VAR_2) {
return NULL;
}
FXFT_Set_Pixel_Sizes(VAR_2, 0, 64);
FXFT_Matrix VAR_3 = {65536, 0, 0, 65536};
if (VAR_4) {
if (VAR_4->m_ItalicAngle) {
int VAR_5 = VAR_4->m_ItalicAngle;
VAR_5 = -VAR_5 <= VAR_6<int>(VAR_7)
? -58
: -VAR_8[-VAR_5];
if (VAR_9)
VAR_3.yx += VAR_3.yy * VAR_5 / 100;
else
VAR_3.xy += -VAR_3.xx * VAR_5 / 100;
}
if (VAR_4->m_SubstFlags & VAR_10) {
AdjustMMParams(VAR_0, VAR_1, VAR_4->m_Weight);
}
}
ScopedFontTransform VAR_11(VAR_2, &VAR_3);
int VAR_12 = VAR_13;
if (!(VAR_2->face_flags & VAR_14) || !FT_IS_TRICKY(VAR_2)) {
VAR_12 |= VAR_15;
}
if (FXFT_Load_Glyph(VAR_2, VAR_0, VAR_12))
return NULL;
if (VAR_4 && !(VAR_4->m_SubstFlags & VAR_10) &&
VAR_4->m_Weight > 400) {
uint32_t VAR_16 = (VAR_4->m_Weight - 400) / 10;
if (VAR_16 >= VAR_17)
VAR_16 = VAR_17 - 1;
int VAR_18 = 0;
if (VAR_4->m_Charset == VAR_19)
VAR_18 = VAR_20[VAR_16] * 2 * 65536 / 36655;
else
VAR_18 = VAR_21[VAR_16] * 2;
FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(VAR_2), VAR_18);
}
FXFT_Outline_Funcs VAR_22;
VAR_22.move_to = VAR_23;
VAR_22.line_to = VAR_24;
VAR_22.conic_to = VAR_25;
VAR_22.cubic_to = VAR_26;
VAR_22.shift = 0;
VAR_22.delta = 0;
OUTLINE_PARAMS VAR_27;
VAR_27.m_bCount = TRUE;
VAR_27.m_PointCount = 0;
FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(VAR_2), &VAR_22, &VAR_27);
if (VAR_27.m_PointCount == 0) {
return NULL;
}
CFX_PathData* VAR_28 = new CFX_PathData;
VAR_28->SetPointCount(VAR_27.m_PointCount);
VAR_27.m_bCount = FALSE;
VAR_27.m_PointCount = 0;
VAR_27.m_pPoints = VAR_28->GetPoints();
VAR_27.m_CurX = VAR_27.m_CurY = 0;
VAR_27.m_CoordUnit = 64 * 64.0;
FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(VAR_2), &VAR_22, &VAR_27);
_Outline_CheckEmptyContour(&VAR_27);
VAR_28->TrimPoints(VAR_27.m_PointCount);
if (VAR_27.m_PointCount) {
VAR_28->GetPoints()[VAR_27.m_PointCount - 1].m_Flag |= VAR_29;
}
return VAR_28;
}",pdfium/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9/fx_ge_text.cpp/vul/before/1.json,"CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t glyph_index, int dest_width) {
  if (!m_Face) {
    return NULL;
  }
  FXFT_Set_Pixel_Sizes(m_Face, 0, 64);
  FXFT_Matrix ft_matrix = {65536, 0, 0, 65536};
  if (m_pSubstFont) {
    if (m_pSubstFont->m_ItalicAngle) {
      int skew = m_pSubstFont->m_ItalicAngle;
      // |skew| is nonpositive so |-skew| is used as the index. We need to make
      // sure |skew| != INT_MIN since -INT_MIN is undefined.
      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&
          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {
        skew = -g_AngleSkew[-skew];
      } else {
        skew = -58;
      }
      if (m_bVertical)
        ft_matrix.yx += ft_matrix.yy * skew / 100;
      else
        ft_matrix.xy += -ft_matrix.xx * skew / 100;
    }
    if (m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) {
      AdjustMMParams(glyph_index, dest_width, m_pSubstFont->m_Weight);
    }
  }
  ScopedFontTransform scoped_transform(m_Face, &ft_matrix);
  int load_flags = FXFT_LOAD_NO_BITMAP;
  if (!(m_Face->face_flags & FT_FACE_FLAG_SFNT) || !FT_IS_TRICKY(m_Face)) {
    load_flags |= FT_LOAD_NO_HINTING;
  }
  if (FXFT_Load_Glyph(m_Face, glyph_index, load_flags))
    return NULL;
  if (m_pSubstFont && !(m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) &&
      m_pSubstFont->m_Weight > 400) {
    uint32_t index = (m_pSubstFont->m_Weight - 400) / 10;
    if (index >= WEIGHTPOW_ARRAY_SIZE)
      index = WEIGHTPOW_ARRAY_SIZE - 1;
    int level = 0;
    if (m_pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET)
      level = g_WeightPow_SHIFTJIS[index] * 2 * 65536 / 36655;
    else
      level = g_WeightPow[index] * 2;
    FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level);
  }
  FXFT_Outline_Funcs funcs;
  funcs.move_to = _Outline_MoveTo;
  funcs.line_to = _Outline_LineTo;
  funcs.conic_to = _Outline_ConicTo;
  funcs.cubic_to = _Outline_CubicTo;
  funcs.shift = 0;
  funcs.delta = 0;
  OUTLINE_PARAMS params;
  params.m_bCount = TRUE;
  params.m_PointCount = 0;
  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);
  if (params.m_PointCount == 0) {
    return NULL;
  }
  CFX_PathData* pPath = new CFX_PathData;
  pPath->SetPointCount(params.m_PointCount);
  params.m_bCount = FALSE;
  params.m_PointCount = 0;
  params.m_pPoints = pPath->GetPoints();
  params.m_CurX = params.m_CurY = 0;
  params.m_CoordUnit = 64 * 64.0;
  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);
  _Outline_CheckEmptyContour(&params);
  pPath->TrimPoints(params.m_PointCount);
  if (params.m_PointCount) {
    pPath->GetPoints()[params.m_PointCount - 1].m_Flag |= FXPT_CLOSEFIGURE;
  }
  return pPath;
}","CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t VAR_0, int VAR_1) {
  if (!VAR_2) {
    return NULL;
  }
  FXFT_Set_Pixel_Sizes(VAR_2, 0, 64);
  FXFT_Matrix VAR_3 = {65536, 0, 0, 65536};
  if (VAR_4) {
    if (VAR_4->m_ItalicAngle) {
      int VAR_5 = VAR_4->m_ItalicAngle;
      /* COMMENT_0 */
      /* COMMENT_1 */
      if (VAR_5 <= 0 && VAR_5 != std::numeric_limits<int>::min() &&
          VAR_6<size_t>(-VAR_5) < VAR_7) {
        VAR_5 = -VAR_8[-VAR_5];
      } else {
        VAR_5 = -58;
      }
      if (VAR_9)
        VAR_3.yx += VAR_3.yy * VAR_5 / 100;
      else
        VAR_3.xy += -VAR_3.xx * VAR_5 / 100;
    }
    if (VAR_4->m_SubstFlags & VAR_10) {
      AdjustMMParams(VAR_0, VAR_1, VAR_4->m_Weight);
    }
  }
  ScopedFontTransform VAR_11(VAR_2, &VAR_3);
  int VAR_12 = VAR_13;
  if (!(VAR_2->face_flags & VAR_14) || !FT_IS_TRICKY(VAR_2)) {
    VAR_12 |= VAR_15;
  }
  if (FXFT_Load_Glyph(VAR_2, VAR_0, VAR_12))
    return NULL;
  if (VAR_4 && !(VAR_4->m_SubstFlags & VAR_10) &&
      VAR_4->m_Weight > 400) {
    uint32_t VAR_16 = (VAR_4->m_Weight - 400) / 10;
    if (VAR_16 >= VAR_17)
      VAR_16 = VAR_17 - 1;
    int VAR_18 = 0;
    if (VAR_4->m_Charset == VAR_19)
      VAR_18 = VAR_20[VAR_16] * 2 * 65536 / 36655;
    else
      VAR_18 = VAR_21[VAR_16] * 2;
    FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(VAR_2), VAR_18);
  }
  FXFT_Outline_Funcs VAR_22;
  VAR_22.move_to = VAR_23;
  VAR_22.line_to = VAR_24;
  VAR_22.conic_to = VAR_25;
  VAR_22.cubic_to = VAR_26;
  VAR_22.shift = 0;
  VAR_22.delta = 0;
  OUTLINE_PARAMS VAR_27;
  VAR_27.m_bCount = TRUE;
  VAR_27.m_PointCount = 0;
  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(VAR_2), &VAR_22, &VAR_27);
  if (VAR_27.m_PointCount == 0) {
    return NULL;
  }
  CFX_PathData* VAR_28 = new CFX_PathData;
  VAR_28->SetPointCount(VAR_27.m_PointCount);
  VAR_27.m_bCount = FALSE;
  VAR_27.m_PointCount = 0;
  VAR_27.m_pPoints = VAR_28->GetPoints();
  VAR_27.m_CurX = VAR_27.m_CurY = 0;
  VAR_27.m_CoordUnit = 64 * 64.0;
  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(VAR_2), &VAR_22, &VAR_27);
  _Outline_CheckEmptyContour(&VAR_27);
  VAR_28->TrimPoints(VAR_27.m_PointCount);
  if (VAR_27.m_PointCount) {
    VAR_28->GetPoints()[VAR_27.m_PointCount - 1].m_Flag |= VAR_29;
  }
  return VAR_28;
}",pdfium/b8627c9d13884d48943d8a7a5381eaf0bb2c08d9/fx_ge_text.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,10 +7,14 @@
   if (m_pSubstFont) {
     if (m_pSubstFont->m_ItalicAngle) {
       int skew = m_pSubstFont->m_ItalicAngle;
-      // skew is nonpositive so -skew is used as the index.
-      skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)
-                 ? -58
-                 : -g_AngleSkew[-skew];
+      // |skew| is nonpositive so |-skew| is used as the index. We need to make
+      // sure |skew| != INT_MIN since -INT_MIN is undefined.
+      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&
+          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {
+        skew = -g_AngleSkew[-skew];
+      } else {
+        skew = -58;
+      }
       if (m_bVertical)
         ft_matrix.yx += ft_matrix.yy * skew / 100;
       else","{'deleted_lines': ['      // skew is nonpositive so -skew is used as the index.', '      skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE)', '                 ? -58', '                 : -g_AngleSkew[-skew];'], 'added_lines': ['      // |skew| is nonpositive so |-skew| is used as the index. We need to make', '      // sure |skew| != INT_MIN since -INT_MIN is undefined.', '      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&', '          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {', '        skew = -g_AngleSkew[-skew];', '      } else {', '        skew = -58;', '      }']}",True,"core/fxge/ge/fx_ge_text.cpp in PDFium, as used in Google Chrome before 51.0.2704.63, miscalculates certain index values, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document.",6.5,MEDIUM,1,valid,,5
CVE-2019-9169,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,glibc,"
regex: fix read overrun [BZ #24114]

Problem found by AddressSanitizer, reported by Hongxu Chen in:
https://debbugs.gnu.org/34140
* posix/regexec.c (proceed_next_node):
Do not read past end of input buffer.
",583dd860d5b833037175247230a328f0050dbfe9,https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=commit;h=583dd860d5b833037175247230a328f0050dbfe9,posix/regexec.c,proceed_next_node,"static Idx
proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
Idx *pidx, Idx node, re_node_set *eps_via_nodes,
struct re_fail_stack_t *fs)
{
const re_dfa_t *const dfa = mctx->dfa;
Idx i;
bool ok;
if (IS_EPSILON_NODE (dfa->nodes[node].type))
{
re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
re_node_set *edests = &dfa->edests[node];
Idx dest_node;
ok = re_node_set_insert (eps_via_nodes, node);
if (__glibc_unlikely (! ok))
return -2;
for (dest_node = -1, i = 0; i < edests->nelem; ++i)
{
Idx candidate = edests->elems[i];
if (!re_node_set_contains (cur_nodes, candidate))
continue;
if (dest_node == -1)
dest_node = candidate;
else
{
if (re_node_set_contains (eps_via_nodes, dest_node))
return candidate;
else if (fs != NULL
&& push_fail_stack (fs, *pidx, candidate, nregs, regs,
eps_via_nodes))
return -2;
break;
}
}
return dest_node;
}
else
{
Idx naccepted = 0;
re_token_type_t type = dfa->nodes[node].type;
#ifdef RE_ENABLE_I18N
if (dfa->nodes[node].accept_mb)
naccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);
else
#endif 
if (type == OP_BACK_REF)
{
Idx subexp_idx = dfa->nodes[node].opr.idx + 1;
naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;
if (fs != NULL)
{
if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)
return -1;
else if (naccepted)
{
char *buf = (char *) re_string_get_buffer (&mctx->input);
if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
naccepted) != 0)
return -1;
}
}
if (naccepted == 0)
{
Idx dest_node;
ok = re_node_set_insert (eps_via_nodes, node);
if (__glibc_unlikely (! ok))
return -2;
dest_node = dfa->edests[node].elems[0];
if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,
dest_node))
return dest_node;
}
}
if (naccepted != 0
|| check_node_accept (mctx, dfa->nodes + node, *pidx))
{
Idx dest_node = dfa->nexts[node];
*pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;
if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL
|| !re_node_set_contains (&mctx->state_log[*pidx]->nodes,
dest_node)))
return -1;
re_node_set_empty (eps_via_nodes);
return dest_node;
}
}
return -1;
}","static Idx
proceed_next_node (const re_match_context_t *VAR_0, Idx VAR_1, regmatch_t *VAR_2,
Idx *VAR_3, Idx VAR_4, re_node_set *VAR_5,
struct re_fail_stack_t *VAR_6)
{
const re_dfa_t *const VAR_7 = VAR_0->dfa;
Idx VAR_8;
bool VAR_9;
if (IS_EPSILON_NODE (VAR_7->nodes[VAR_4].type))
{
re_node_set *VAR_10 = &VAR_0->state_log[*VAR_3]->nodes;
re_node_set *VAR_11 = &VAR_7->edests[VAR_4];
Idx VAR_12;
VAR_9 = re_node_set_insert (VAR_5, VAR_4);
if (__glibc_unlikely (! VAR_9))
return -2;
for (VAR_12 = -1, VAR_8 = 0; VAR_8 < VAR_11->nelem; ++VAR_8)
{
Idx VAR_13 = VAR_11->elems[VAR_8];
if (!re_node_set_contains (VAR_10, VAR_13))
continue;
if (VAR_12 == -1)
VAR_12 = VAR_13;
else
{
if (re_node_set_contains (VAR_5, VAR_12))
return VAR_13;
else if (VAR_6 != NULL
&& push_fail_stack (VAR_6, *VAR_3, VAR_13, VAR_1, VAR_2,
VAR_5))
return -2;
break;
}
}
return VAR_12;
}
else
{
Idx VAR_14 = 0;
re_token_type_t VAR_15 = VAR_7->nodes[VAR_4].type;
#ifdef VAR_16
if (VAR_7->nodes[VAR_4].accept_mb)
VAR_14 = check_node_accept_bytes (VAR_7, VAR_4, &VAR_0->input, *VAR_3);
else
#endif 
if (VAR_15 == VAR_17)
{
Idx VAR_18 = VAR_7->nodes[VAR_4].opr.idx + 1;
VAR_14 = VAR_2[VAR_18].rm_eo - VAR_2[VAR_18].rm_so;
if (VAR_6 != NULL)
{
if (VAR_2[VAR_18].rm_so == -1 || VAR_2[VAR_18].rm_eo == -1)
return -1;
else if (VAR_14)
{
char *VAR_19 = (char *) re_string_get_buffer (&VAR_0->input);
if (memcmp (VAR_19 + VAR_2[VAR_18].rm_so, VAR_19 + *VAR_3,
VAR_14) != 0)
return -1;
}
}
if (VAR_14 == 0)
{
Idx VAR_12;
VAR_9 = re_node_set_insert (VAR_5, VAR_4);
if (__glibc_unlikely (! VAR_9))
return -2;
VAR_12 = VAR_7->edests[VAR_4].elems[0];
if (re_node_set_contains (&VAR_0->state_log[*VAR_3]->nodes,
VAR_12))
return VAR_12;
}
}
if (VAR_14 != 0
|| check_node_accept (VAR_0, VAR_7->nodes + VAR_4, *VAR_3))
{
Idx VAR_12 = VAR_7->nexts[VAR_4];
*VAR_3 = (VAR_14 == 0) ? *VAR_3 + 1 : *VAR_3 + VAR_14;
if (VAR_6 && (*VAR_3 > VAR_0->match_last || VAR_0->state_log[*VAR_3] == NULL
|| !re_node_set_contains (&VAR_0->state_log[*VAR_3]->nodes,
VAR_12)))
return -1;
re_node_set_empty (VAR_5);
return VAR_12;
}
}
return -1;
}",glibc/583dd860d5b833037175247230a328f0050dbfe9/regexec.c/vul/before/0.json,"static Idx
proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
		   Idx *pidx, Idx node, re_node_set *eps_via_nodes,
		   struct re_fail_stack_t *fs)
{
  const re_dfa_t *const dfa = mctx->dfa;
  Idx i;
  bool ok;
  if (IS_EPSILON_NODE (dfa->nodes[node].type))
    {
      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
      re_node_set *edests = &dfa->edests[node];
      Idx dest_node;
      ok = re_node_set_insert (eps_via_nodes, node);
      if (__glibc_unlikely (! ok))
	return -2;
      /* Pick up a valid destination, or return -1 if none
	 is found.  */
      for (dest_node = -1, i = 0; i < edests->nelem; ++i)
	{
	  Idx candidate = edests->elems[i];
	  if (!re_node_set_contains (cur_nodes, candidate))
	    continue;
          if (dest_node == -1)
	    dest_node = candidate;

	  else
	    {
	      /* In order to avoid infinite loop like ""(a*)*"", return the second
		 epsilon-transition if the first was already considered.  */
	      if (re_node_set_contains (eps_via_nodes, dest_node))
		return candidate;

	      /* Otherwise, push the second epsilon-transition on the fail stack.  */
	      else if (fs != NULL
		       && push_fail_stack (fs, *pidx, candidate, nregs, regs,
					   eps_via_nodes))
		return -2;

	      /* We know we are going to exit.  */
	      break;
	    }
	}
      return dest_node;
    }
  else
    {
      Idx naccepted = 0;
      re_token_type_t type = dfa->nodes[node].type;

#ifdef RE_ENABLE_I18N
      if (dfa->nodes[node].accept_mb)
	naccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);
      else
#endif /* RE_ENABLE_I18N */
      if (type == OP_BACK_REF)
	{
	  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;
	  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;
	  if (fs != NULL)
	    {
	      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)
		return -1;
	      else if (naccepted)
		{
		  char *buf = (char *) re_string_get_buffer (&mctx->input);
		  if (mctx->input.valid_len - *pidx < naccepted
		      || (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
				  naccepted)
			  != 0))
		    return -1;
		}
	    }

	  if (naccepted == 0)
	    {
	      Idx dest_node;
	      ok = re_node_set_insert (eps_via_nodes, node);
	      if (__glibc_unlikely (! ok))
		return -2;
	      dest_node = dfa->edests[node].elems[0];
	      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,
					dest_node))
		return dest_node;
	    }
	}

      if (naccepted != 0
	  || check_node_accept (mctx, dfa->nodes + node, *pidx))
	{
	  Idx dest_node = dfa->nexts[node];
	  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;
	  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL
		     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,
					       dest_node)))
	    return -1;
	  re_node_set_empty (eps_via_nodes);
	  return dest_node;
	}
    }
  return -1;
}","static Idx
proceed_next_node (const re_match_context_t *VAR_0, Idx VAR_1, regmatch_t *VAR_2,
		   Idx *VAR_3, Idx VAR_4, re_node_set *VAR_5,
		   struct re_fail_stack_t *VAR_6)
{
  const re_dfa_t *const VAR_7 = VAR_0->dfa;
  Idx VAR_8;
  bool VAR_9;
  if (IS_EPSILON_NODE (VAR_7->nodes[VAR_4].type))
    {
      re_node_set *VAR_10 = &VAR_0->state_log[*VAR_3]->nodes;
      re_node_set *VAR_11 = &VAR_7->edests[VAR_4];
      Idx VAR_12;
      VAR_9 = re_node_set_insert (VAR_5, VAR_4);
      if (__glibc_unlikely (! VAR_9))
	return -2;
      /* COMMENT_0 */
               
      for (VAR_12 = -1, VAR_8 = 0; VAR_8 < VAR_11->nelem; ++VAR_8)
	{
	  Idx VAR_13 = VAR_11->elems[VAR_8];
	  if (!re_node_set_contains (VAR_10, VAR_13))
	    continue;
          if (VAR_12 == -1)
	    VAR_12 = VAR_13;

	  else
	    {
	      /* COMMENT_2 */
                                                              
	      if (re_node_set_contains (VAR_5, VAR_12))
		return VAR_13;

	      /* COMMENT_4 */
	      else if (VAR_6 != NULL
		       && push_fail_stack (VAR_6, *VAR_3, VAR_13, VAR_1, VAR_2,
					   VAR_5))
		return -2;

	      /* COMMENT_5 */
	      break;
	    }
	}
      return VAR_12;
    }
  else
    {
      Idx VAR_14 = 0;
      re_token_type_t VAR_15 = VAR_7->nodes[VAR_4].type;

#ifdef VAR_16
      if (VAR_7->nodes[VAR_4].accept_mb)
	VAR_14 = check_node_accept_bytes (VAR_7, VAR_4, &VAR_0->input, *VAR_3);
      else
#endif /* COMMENT_6 */
      if (VAR_15 == VAR_17)
	{
	  Idx VAR_18 = VAR_7->nodes[VAR_4].opr.idx + 1;
	  VAR_14 = VAR_2[VAR_18].rm_eo - VAR_2[VAR_18].rm_so;
	  if (VAR_6 != NULL)
	    {
	      if (VAR_2[VAR_18].rm_so == -1 || VAR_2[VAR_18].rm_eo == -1)
		return -1;
	      else if (VAR_14)
		{
		  char *VAR_19 = (char *) re_string_get_buffer (&VAR_0->input);
		  if (VAR_0->input.valid_len - *VAR_3 < VAR_14
		      || (memcmp (VAR_19 + VAR_2[VAR_18].rm_so, VAR_19 + *VAR_3,
				  VAR_14)
			  != 0))
		    return -1;
		}
	    }

	  if (VAR_14 == 0)
	    {
	      Idx VAR_12;
	      VAR_9 = re_node_set_insert (VAR_5, VAR_4);
	      if (__glibc_unlikely (! VAR_9))
		return -2;
	      VAR_12 = VAR_7->edests[VAR_4].elems[0];
	      if (re_node_set_contains (&VAR_0->state_log[*VAR_3]->nodes,
					VAR_12))
		return VAR_12;
	    }
	}

      if (VAR_14 != 0
	  || check_node_accept (VAR_0, VAR_7->nodes + VAR_4, *VAR_3))
	{
	  Idx VAR_12 = VAR_7->nexts[VAR_4];
	  *VAR_3 = (VAR_14 == 0) ? *VAR_3 + 1 : *VAR_3 + VAR_14;
	  if (VAR_6 && (*VAR_3 > VAR_0->match_last || VAR_0->state_log[*VAR_3] == NULL
		     || !re_node_set_contains (&VAR_0->state_log[*VAR_3]->nodes,
					       VAR_12)))
	    return -1;
	  re_node_set_empty (VAR_5);
	  return VAR_12;
	}
    }
  return -1;
}",glibc/583dd860d5b833037175247230a328f0050dbfe9/regexec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,8 +64,10 @@
 	      else if (naccepted)
 		{
 		  char *buf = (char *) re_string_get_buffer (&mctx->input);
-		  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
-			      naccepted) != 0)
+		  if (mctx->input.valid_len - *pidx < naccepted
+		      || (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
+				  naccepted)
+			  != 0))
 		    return -1;
 		}
 	    }","{'deleted_lines': ['\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,', '\t\t\t      naccepted) != 0)'], 'added_lines': ['\t\t  if (mctx->input.valid_len - *pidx < naccepted', '\t\t      || (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,', '\t\t\t\t  naccepted)', '\t\t\t  != 0))']}",True,"In the GNU C Library (aka glibc or libc6) through 2.29, proceed_next_node in posix/regexec.c has a heap-based buffer over-read via an attempted case-insensitive regular-expression match.",9.8,CRITICAL,3,valid,,5
CVE-2019-10872,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,poppler,"Check whether area to fill in Splash::blitTransparent()
does not run out of allocated memory for source and for destination
and shrink it if needed.

Fixes #750
",6a1580e84f492b5671d23be98192267bb73de250,https://cgit.freedesktop.org/poppler/poppler/commit/?id=6a1580e84f492b5671d23be98192267bb73de250,splash/Splash.cc,Splash::blitTransparent,"SplashError Splash::blitTransparent(SplashBitmap *src, int xSrc, int ySrc,
int xDest, int yDest, int w, int h) {
SplashColorPtr p, sp;
unsigned char *q;
int x, y, mask, srcMask;
if (src->mode != bitmap->mode) {
return splashErrModeMismatch;
}
if (unlikely(!bitmap->data)) {
return splashErrZeroImage;
}
switch (bitmap->mode) {
case splashModeMono1:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + (xDest >> 3)];
mask = 0x80 >> (xDest & 7);
sp = &src->data[(ySrc + y) * src->rowSize + (xSrc >> 3)];
srcMask = 0x80 >> (xSrc & 7);
for (x = 0; x < w; ++x) {
if (*sp & srcMask) {
*p |= mask;
} else {
*p &= ~mask;
}
if (!(mask >>= 1)) {
mask = 0x80;
++p;
}
if (!(srcMask >>= 1)) {
srcMask = 0x80;
++sp;
}
}
}
break;
case splashModeMono8:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + xDest];
sp = &src->data[(ySrc + y) * bitmap->rowSize + xSrc];
for (x = 0; x < w; ++x) {
*p++ = *sp++;
}
}
break;
case splashModeRGB8:
case splashModeBGR8:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + 3 * xDest];
sp = &src->data[(ySrc + y) * src->rowSize + 3 * xSrc];
for (x = 0; x < w; ++x) {
*p++ = *sp++;
*p++ = *sp++;
*p++ = *sp++;
}
}
break;
case splashModeXBGR8:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
for (x = 0; x < w; ++x) {
*p++ = *sp++;
*p++ = *sp++;
*p++ = *sp++;
*p++ = 255;
sp++;
}
}
break;
#ifdef SPLASH_CMYK
case splashModeCMYK8:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
for (x = 0; x < w; ++x) {
*p++ = *sp++;
*p++ = *sp++;
*p++ = *sp++;
*p++ = *sp++;
}
}
break;
case splashModeDeviceN8:
for (y = 0; y < h; ++y) {
p = &bitmap->data[(yDest + y) * bitmap->rowSize + (SPOT_NCOMPS+4) * xDest];
sp = &src->data[(ySrc + y) * src->rowSize + (SPOT_NCOMPS+4) * xSrc];
for (x = 0; x < w; ++x) {
for (int cp=0; cp < SPOT_NCOMPS+4; cp++)
*p++ = *sp++;
}
}
break;
#endif
}
if (bitmap->alpha) {
for (y = 0; y < h; ++y) {
q = &bitmap->alpha[(yDest + y) * bitmap->width + xDest];
memset(q, 0x00, w);
}
}
return splashOk;
}","SplashError Splash::blitTransparent(SplashBitmap *VAR_0, int VAR_1, int VAR_2,
int VAR_3, int VAR_4, int VAR_5, int VAR_6) {
SplashColorPtr VAR_7, VAR_8;
unsigned char *VAR_9;
int VAR_10, VAR_11, VAR_12, VAR_13;
if (VAR_0->mode != VAR_14->mode) {
return VAR_15;
}
if (unlikely(!VAR_14->data)) {
return VAR_16;
}
switch (VAR_14->mode) {
case VAR_17:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + (VAR_3 >> 3)];
VAR_12 = 0x80 >> (VAR_3 & 7);
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + (VAR_1 >> 3)];
VAR_13 = 0x80 >> (VAR_1 & 7);
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
if (*VAR_8 & VAR_13) {
*VAR_7 |= VAR_12;
} else {
*VAR_7 &= ~VAR_12;
}
if (!(VAR_12 >>= 1)) {
VAR_12 = 0x80;
++VAR_7;
}
if (!(VAR_13 >>= 1)) {
VAR_13 = 0x80;
++VAR_8;
}
}
}
break;
case VAR_18:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + VAR_3];
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_14->rowSize + VAR_1];
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
*VAR_7++ = *VAR_8++;
}
}
break;
case VAR_19:
case VAR_20:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + 3 * VAR_3];
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 3 * VAR_1];
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
}
}
break;
case VAR_21:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + 4 * VAR_3];
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 4 * VAR_1];
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
*VAR_7++ = 255;
VAR_8++;
}
}
break;
#ifdef VAR_22
case VAR_23:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + 4 * VAR_3];
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 4 * VAR_1];
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
*VAR_7++ = *VAR_8++;
}
}
break;
case VAR_24:
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_7 = &VAR_14->data[(VAR_4 + VAR_11) * VAR_14->rowSize + (VAR_25+4) * VAR_3];
VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + (VAR_25+4) * VAR_1];
for (VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
for (int VAR_26=0; VAR_26 < VAR_25+4; VAR_26++)
*VAR_7++ = *VAR_8++;
}
}
break;
#endif
}
if (VAR_14->alpha) {
for (VAR_11 = 0; VAR_11 < VAR_6; ++VAR_11) {
VAR_9 = &VAR_14->alpha[(VAR_4 + VAR_11) * VAR_14->width + VAR_3];
memset(VAR_9, 0x00, VAR_5);
}
}
return VAR_27;
}",poppler/6a1580e84f492b5671d23be98192267bb73de250/Splash.cc/vul/before/0.json,"SplashError Splash::blitTransparent(SplashBitmap *src, int xSrc, int ySrc,
				    int xDest, int yDest, int w, int h) {
  SplashColorPtr p, sp;
  unsigned char *q;
  int x, y, mask, srcMask, width = w, height = h;

  if (src->mode != bitmap->mode) {
    return splashErrModeMismatch;
  }

  if (unlikely(!bitmap->data)) {
    return splashErrZeroImage;
  }

  if (src->getWidth() - xSrc < width)
    width = src->getWidth() - xSrc;

  if (src->getHeight() - ySrc < height)
    height = src->getHeight() - ySrc;

  if (bitmap->getWidth() - xDest < width)
    width = bitmap->getWidth() - xDest;

  if (bitmap->getHeight() - yDest < height)
    height = bitmap->getHeight() - yDest;

  if (width < 0)
    width = 0;

  if (height < 0)
    height = 0;

  switch (bitmap->mode) {
  case splashModeMono1:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + (xDest >> 3)];
      mask = 0x80 >> (xDest & 7);
      sp = &src->data[(ySrc + y) * src->rowSize + (xSrc >> 3)];
      srcMask = 0x80 >> (xSrc & 7);
      for (x = 0; x < width; ++x) {
	if (*sp & srcMask) {
	  *p |= mask;
	} else {
	  *p &= ~mask;
	}
	if (!(mask >>= 1)) {
	  mask = 0x80;
	  ++p;
	}
	if (!(srcMask >>= 1)) {
	  srcMask = 0x80;
	  ++sp;
	}
      }
    }
    break;
  case splashModeMono8:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + xDest];
      sp = &src->data[(ySrc + y) * bitmap->rowSize + xSrc];
      for (x = 0; x < width; ++x) {
	*p++ = *sp++;
      }
    }
    break;
  case splashModeRGB8:
  case splashModeBGR8:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 3 * xDest];
      sp = &src->data[(ySrc + y) * src->rowSize + 3 * xSrc];
      for (x = 0; x < width; ++x) {
	*p++ = *sp++;
	*p++ = *sp++;
	*p++ = *sp++;
      }
    }
    break;
  case splashModeXBGR8:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
      sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
      for (x = 0; x < width; ++x) {
	*p++ = *sp++;
	*p++ = *sp++;
	*p++ = *sp++;
	*p++ = 255;
	sp++;
      }
    }
    break;
#ifdef SPLASH_CMYK
  case splashModeCMYK8:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
      sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
      for (x = 0; x < width; ++x) {
	*p++ = *sp++;
	*p++ = *sp++;
	*p++ = *sp++;
	*p++ = *sp++;
      }
    }
    break;
  case splashModeDeviceN8:
    for (y = 0; y < height; ++y) {
      p = &bitmap->data[(yDest + y) * bitmap->rowSize + (SPOT_NCOMPS+4) * xDest];
      sp = &src->data[(ySrc + y) * src->rowSize + (SPOT_NCOMPS+4) * xSrc];
      for (x = 0; x < width; ++x) {
        for (int cp=0; cp < SPOT_NCOMPS+4; cp++)
          *p++ = *sp++;
      }
    }
    break;
#endif
  }

  if (bitmap->alpha) {
    for (y = 0; y < height; ++y) {
      q = &bitmap->alpha[(yDest + y) * bitmap->width + xDest];
      memset(q, 0x00, width);
    }
  }

  return splashOk;
}","SplashError Splash::blitTransparent(SplashBitmap *VAR_0, int VAR_1, int VAR_2,
				    int VAR_3, int VAR_4, int VAR_5, int VAR_6) {
  SplashColorPtr VAR_7, VAR_8;
  unsigned char *VAR_9;
  int VAR_10, VAR_11, VAR_12, VAR_13, VAR_14 = VAR_5, VAR_15 = VAR_6;

  if (VAR_0->mode != VAR_16->mode) {
    return VAR_17;
  }

  if (unlikely(!VAR_16->data)) {
    return VAR_18;
  }

  if (VAR_0->getWidth() - VAR_1 < VAR_14)
    VAR_14 = VAR_0->getWidth() - VAR_1;

  if (VAR_0->getHeight() - VAR_2 < VAR_15)
    VAR_15 = VAR_0->getHeight() - VAR_2;

  if (VAR_16->getWidth() - VAR_3 < VAR_14)
    VAR_14 = VAR_16->getWidth() - VAR_3;

  if (VAR_16->getHeight() - VAR_4 < VAR_15)
    VAR_15 = VAR_16->getHeight() - VAR_4;

  if (VAR_14 < 0)
    VAR_14 = 0;

  if (VAR_15 < 0)
    VAR_15 = 0;

  switch (VAR_16->mode) {
  case VAR_19:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + (VAR_3 >> 3)];
      VAR_12 = 0x80 >> (VAR_3 & 7);
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + (VAR_1 >> 3)];
      VAR_13 = 0x80 >> (VAR_1 & 7);
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
	if (*VAR_8 & VAR_13) {
	  *VAR_7 |= VAR_12;
	} else {
	  *VAR_7 &= ~VAR_12;
	}
	if (!(VAR_12 >>= 1)) {
	  VAR_12 = 0x80;
	  ++VAR_7;
	}
	if (!(VAR_13 >>= 1)) {
	  VAR_13 = 0x80;
	  ++VAR_8;
	}
      }
    }
    break;
  case VAR_20:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + VAR_3];
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_16->rowSize + VAR_1];
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
	*VAR_7++ = *VAR_8++;
      }
    }
    break;
  case VAR_21:
  case VAR_22:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + 3 * VAR_3];
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 3 * VAR_1];
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
      }
    }
    break;
  case VAR_23:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + 4 * VAR_3];
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 4 * VAR_1];
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = 255;
	VAR_8++;
      }
    }
    break;
#ifdef VAR_24
  case VAR_25:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + 4 * VAR_3];
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + 4 * VAR_1];
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
	*VAR_7++ = *VAR_8++;
      }
    }
    break;
  case VAR_26:
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_7 = &VAR_16->data[(VAR_4 + VAR_11) * VAR_16->rowSize + (VAR_27+4) * VAR_3];
      VAR_8 = &VAR_0->data[(VAR_2 + VAR_11) * VAR_0->rowSize + (VAR_27+4) * VAR_1];
      for (VAR_10 = 0; VAR_10 < VAR_14; ++VAR_10) {
        for (int VAR_28=0; VAR_28 < VAR_27+4; VAR_28++)
          *VAR_7++ = *VAR_8++;
      }
    }
    break;
#endif
  }

  if (VAR_16->alpha) {
    for (VAR_11 = 0; VAR_11 < VAR_15; ++VAR_11) {
      VAR_9 = &VAR_16->alpha[(VAR_4 + VAR_11) * VAR_16->width + VAR_3];
      memset(VAR_9, 0x00, VAR_14);
    }
  }

  return VAR_29;
}",poppler/6a1580e84f492b5671d23be98192267bb73de250/Splash.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 				    int xDest, int yDest, int w, int h) {
   SplashColorPtr p, sp;
   unsigned char *q;
-  int x, y, mask, srcMask;
+  int x, y, mask, srcMask, width = w, height = h;
 
   if (src->mode != bitmap->mode) {
     return splashErrModeMismatch;
@@ -12,14 +12,32 @@
     return splashErrZeroImage;
   }
 
+  if (src->getWidth() - xSrc < width)
+    width = src->getWidth() - xSrc;
+
+  if (src->getHeight() - ySrc < height)
+    height = src->getHeight() - ySrc;
+
+  if (bitmap->getWidth() - xDest < width)
+    width = bitmap->getWidth() - xDest;
+
+  if (bitmap->getHeight() - yDest < height)
+    height = bitmap->getHeight() - yDest;
+
+  if (width < 0)
+    width = 0;
+
+  if (height < 0)
+    height = 0;
+
   switch (bitmap->mode) {
   case splashModeMono1:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + (xDest >> 3)];
       mask = 0x80 >> (xDest & 7);
       sp = &src->data[(ySrc + y) * src->rowSize + (xSrc >> 3)];
       srcMask = 0x80 >> (xSrc & 7);
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
 	if (*sp & srcMask) {
 	  *p |= mask;
 	} else {
@@ -37,20 +55,20 @@
     }
     break;
   case splashModeMono8:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + xDest];
       sp = &src->data[(ySrc + y) * bitmap->rowSize + xSrc];
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
 	*p++ = *sp++;
       }
     }
     break;
   case splashModeRGB8:
   case splashModeBGR8:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + 3 * xDest];
       sp = &src->data[(ySrc + y) * src->rowSize + 3 * xSrc];
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
 	*p++ = *sp++;
 	*p++ = *sp++;
 	*p++ = *sp++;
@@ -58,10 +76,10 @@
     }
     break;
   case splashModeXBGR8:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
       sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
 	*p++ = *sp++;
 	*p++ = *sp++;
 	*p++ = *sp++;
@@ -72,10 +90,10 @@
     break;
 #ifdef SPLASH_CMYK
   case splashModeCMYK8:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
       sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
 	*p++ = *sp++;
 	*p++ = *sp++;
 	*p++ = *sp++;
@@ -84,10 +102,10 @@
     }
     break;
   case splashModeDeviceN8:
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + (SPOT_NCOMPS+4) * xDest];
       sp = &src->data[(ySrc + y) * src->rowSize + (SPOT_NCOMPS+4) * xSrc];
-      for (x = 0; x < w; ++x) {
+      for (x = 0; x < width; ++x) {
         for (int cp=0; cp < SPOT_NCOMPS+4; cp++)
           *p++ = *sp++;
       }
@@ -97,9 +115,9 @@
   }
 
   if (bitmap->alpha) {
-    for (y = 0; y < h; ++y) {
+    for (y = 0; y < height; ++y) {
       q = &bitmap->alpha[(yDest + y) * bitmap->width + xDest];
-      memset(q, 0x00, w);
+      memset(q, 0x00, width);
     }
   }
 ","{'deleted_lines': ['  int x, y, mask, srcMask;', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      for (x = 0; x < w; ++x) {', '    for (y = 0; y < h; ++y) {', '      memset(q, 0x00, w);'], 'added_lines': ['  int x, y, mask, srcMask, width = w, height = h;', '  if (src->getWidth() - xSrc < width)', '    width = src->getWidth() - xSrc;', '', '  if (src->getHeight() - ySrc < height)', '    height = src->getHeight() - ySrc;', '', '  if (bitmap->getWidth() - xDest < width)', '    width = bitmap->getWidth() - xDest;', '', '  if (bitmap->getHeight() - yDest < height)', '    height = bitmap->getHeight() - yDest;', '', '  if (width < 0)', '    width = 0;', '', '  if (height < 0)', '    height = 0;', '', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      for (x = 0; x < width; ++x) {', '    for (y = 0; y < height; ++y) {', '      memset(q, 0x00, width);']}",True,An issue was discovered in Poppler 0.74.0. There is a heap-based buffer over-read in the function Splash::blitTransparent at splash/Splash.cc.,8.8,HIGH,2,valid,,5
CVE-2015-1276,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,chromium,"IndexedDB: Protect against use-after-free in ChainedBlobWriter.

This is a speculative fix for a heap user-after-free bug. Was unable
to verify using a Windows SyzyASan build. The theory is that if Abort()
was called before ChainedBlobWriterImpl::WriteNextFile() could set
waiting_for_callback_ then the ReportWriteCompletion() would never know
that it was aborted and attempt to use it's dangling raw pointer to a
deleted IndexedDBBackingStore instance.

Also in this change is the elimination of the redundant aborted_
member variable.

BUG=472614

Review URL: https://codereview.chromium.org/1060613002

Cr-Commit-Position: refs/heads/master@{#326597}
",29777a8ee0f45b8160ec004e74013d5b62b6828a,https://chromium.googlesource.com/chromium/src/+/29777a8ee0f45b8160ec004e74013d5b62b6828a,content/browser/indexed_db/indexed_db_backing_store.cc,Abort,"void Abort() override {
if (!waiting_for_callback_)
return;
self_ref_ = this;
aborted_ = true;
}","void Abort() override {
if (!VAR_0)
return;
VAR_1 = this;
VAR_2 = true;
}",,"void Abort() override {
    if (!waiting_for_callback_)
      return;
    aborted_self_ref_ = this;
  }","void Abort() override {
    if (!VAR_0)
      return;
    VAR_1 = this;
  }",,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 void Abort() override {
     if (!waiting_for_callback_)
       return;
-    self_ref_ = this;
-    aborted_ = true;
+    aborted_self_ref_ = this;
   }","{'deleted_lines': ['    self_ref_ = this;', '    aborted_ = true;'], 'added_lines': ['    aborted_self_ref_ = this;']}",True,Use-after-free vulnerability in content/browser/indexed_db/indexed_db_backing_store.cc in the IndexedDB implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,9.8,CRITICAL,3,valid,,5
CVE-2015-1276,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,chromium,"IndexedDB: Protect against use-after-free in ChainedBlobWriter.

This is a speculative fix for a heap user-after-free bug. Was unable
to verify using a Windows SyzyASan build. The theory is that if Abort()
was called before ChainedBlobWriterImpl::WriteNextFile() could set
waiting_for_callback_ then the ReportWriteCompletion() would never know
that it was aborted and attempt to use it's dangling raw pointer to a
deleted IndexedDBBackingStore instance.

Also in this change is the elimination of the redundant aborted_
member variable.

BUG=472614

Review URL: https://codereview.chromium.org/1060613002

Cr-Commit-Position: refs/heads/master@{#326597}
",29777a8ee0f45b8160ec004e74013d5b62b6828a,https://chromium.googlesource.com/chromium/src/+/29777a8ee0f45b8160ec004e74013d5b62b6828a,content/browser/indexed_db/indexed_db_backing_store.cc,ReportWriteCompletion,"void ReportWriteCompletion(bool succeeded, int64 bytes_written) override {
DCHECK(waiting_for_callback_);
DCHECK(!succeeded || bytes_written >= 0);
waiting_for_callback_ = false;
if (delegate_.get())        content::BrowserThread::DeleteSoon(
content::BrowserThread::IO, FROM_HERE, delegate_.release());
if (aborted_) {
self_ref_ = NULL;
return;
}
if (iter_->size() != -1 && iter_->size() != bytes_written)
succeeded = false;
if (succeeded) {
++iter_;
WriteNextFile();
} else {
callback_->Run(false);
}
}","void ReportWriteCompletion(bool VAR_0, int64 VAR_1) override {
DCHECK(VAR_2);
DCHECK(!VAR_0 || VAR_1 >= 0);
VAR_2 = false;
if (VAR_3.get())  
content::BrowserThread::DeleteSoon(
content::BrowserThread::IO, VAR_4, VAR_3.release());
if (VAR_5) {
VAR_6 = NULL;
return;
}
if (VAR_7->size() != -1 && VAR_7->size() != VAR_1)
VAR_0 = false;
if (VAR_0) {
++VAR_7;
WriteNextFile();
} else {
VAR_8->Run(false);
}
}",,"void ReportWriteCompletion(bool succeeded, int64 bytes_written) override {
    DCHECK(waiting_for_callback_);
    DCHECK(!succeeded || bytes_written >= 0);
    waiting_for_callback_ = false;
    if (delegate_.get())  // Only present for Blob, not File.
      content::BrowserThread::DeleteSoon(
          content::BrowserThread::IO, FROM_HERE, delegate_.release());
    if (aborted_self_ref_.get()) {
      aborted_self_ref_ = NULL;
      return;
    }
    if (iter_->size() != -1 && iter_->size() != bytes_written)
      succeeded = false;
    if (succeeded) {
      ++iter_;
      WriteNextFile();
    } else {
      callback_->Run(false);
    }
  }","void ReportWriteCompletion(bool VAR_0, int64 VAR_1) override {
    DCHECK(VAR_2);
    DCHECK(!VAR_0 || VAR_1 >= 0);
    VAR_2 = false;
    if (VAR_3.get())  /* COMMENT_0 */
      content::BrowserThread::DeleteSoon(
          content::BrowserThread::IO, VAR_4, VAR_3.release());
    if (VAR_5.get()) {
      VAR_5 = NULL;
      return;
    }
    if (VAR_6->size() != -1 && VAR_6->size() != VAR_1)
      VAR_0 = false;
    if (VAR_0) {
      ++VAR_6;
      WriteNextFile();
    } else {
      VAR_7->Run(false);
    }
  }",,"--- func_before
+++ func_after
@@ -5,8 +5,8 @@
     if (delegate_.get())  // Only present for Blob, not File.
       content::BrowserThread::DeleteSoon(
           content::BrowserThread::IO, FROM_HERE, delegate_.release());
-    if (aborted_) {
-      self_ref_ = NULL;
+    if (aborted_self_ref_.get()) {
+      aborted_self_ref_ = NULL;
       return;
     }
     if (iter_->size() != -1 && iter_->size() != bytes_written)","{'deleted_lines': ['    if (aborted_) {', '      self_ref_ = NULL;'], 'added_lines': ['    if (aborted_self_ref_.get()) {', '      aborted_self_ref_ = NULL;']}",True,Use-after-free vulnerability in content/browser/indexed_db/indexed_db_backing_store.cc in the IndexedDB implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,9.8,CRITICAL,3,valid,,5
CVE-2015-1276,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,chromium,"IndexedDB: Protect against use-after-free in ChainedBlobWriter.

This is a speculative fix for a heap user-after-free bug. Was unable
to verify using a Windows SyzyASan build. The theory is that if Abort()
was called before ChainedBlobWriterImpl::WriteNextFile() could set
waiting_for_callback_ then the ReportWriteCompletion() would never know
that it was aborted and attempt to use it's dangling raw pointer to a
deleted IndexedDBBackingStore instance.

Also in this change is the elimination of the redundant aborted_
member variable.

BUG=472614

Review URL: https://codereview.chromium.org/1060613002

Cr-Commit-Position: refs/heads/master@{#326597}
",29777a8ee0f45b8160ec004e74013d5b62b6828a,https://chromium.googlesource.com/chromium/src/+/29777a8ee0f45b8160ec004e74013d5b62b6828a,content/browser/indexed_db/indexed_db_backing_store.cc,WriteNextFile,"void WriteNextFile() {
DCHECK(!waiting_for_callback_);
DCHECK(!aborted_);
if (iter_ == blobs_.end()) {
DCHECK(!self_ref_.get());
callback_->Run(true);
return;
} else {
if (!backing_store_->WriteBlobFile(database_id_, *iter_, this)) {
callback_->Run(false);
return;
}
waiting_for_callback_ = true;
}
}","void WriteNextFile() {
DCHECK(!VAR_0);
DCHECK(!VAR_1);
if (VAR_2 == VAR_3.end()) {
DCHECK(!VAR_4.get());
VAR_5->Run(true);
return;
} else {
if (!VAR_6->WriteBlobFile(VAR_7, *VAR_2, this)) {
VAR_5->Run(false);
return;
}
VAR_0 = true;
}
}",chromium/29777a8ee0f45b8160ec004e74013d5b62b6828a/indexed_db_backing_store.cc/vul/before/2.json,"void WriteNextFile() {
    DCHECK(!waiting_for_callback_);
    DCHECK(!aborted_self_ref_.get());
    if (iter_ == blobs_.end()) {
      callback_->Run(true);
      return;
    } else {
      waiting_for_callback_ = true;
      if (!backing_store_->WriteBlobFile(database_id_, *iter_, this)) {
        waiting_for_callback_ = false;
        callback_->Run(false);
        return;
      }
    }
  }","void WriteNextFile() {
    DCHECK(!VAR_0);
    DCHECK(!VAR_1.get());
    if (VAR_2 == VAR_3.end()) {
      VAR_4->Run(true);
      return;
    } else {
      VAR_0 = true;
      if (!VAR_5->WriteBlobFile(VAR_6, *VAR_2, this)) {
        VAR_0 = false;
        VAR_4->Run(false);
        return;
      }
    }
  }",chromium/29777a8ee0f45b8160ec004e74013d5b62b6828a/indexed_db_backing_store.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,15 +1,15 @@
 void WriteNextFile() {
     DCHECK(!waiting_for_callback_);
-    DCHECK(!aborted_);
+    DCHECK(!aborted_self_ref_.get());
     if (iter_ == blobs_.end()) {
-      DCHECK(!self_ref_.get());
       callback_->Run(true);
       return;
     } else {
+      waiting_for_callback_ = true;
       if (!backing_store_->WriteBlobFile(database_id_, *iter_, this)) {
+        waiting_for_callback_ = false;
         callback_->Run(false);
         return;
       }
-      waiting_for_callback_ = true;
     }
   }","{'deleted_lines': ['    DCHECK(!aborted_);', '      DCHECK(!self_ref_.get());', '      waiting_for_callback_ = true;'], 'added_lines': ['    DCHECK(!aborted_self_ref_.get());', '      waiting_for_callback_ = true;', '        waiting_for_callback_ = false;']}",True,Use-after-free vulnerability in content/browser/indexed_db/indexed_db_backing_store.cc in the IndexedDB implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,9.8,CRITICAL,3,valid,,5
CVE-2015-1276,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,chromium,"IndexedDB: Protect against use-after-free in ChainedBlobWriter.

This is a speculative fix for a heap user-after-free bug. Was unable
to verify using a Windows SyzyASan build. The theory is that if Abort()
was called before ChainedBlobWriterImpl::WriteNextFile() could set
waiting_for_callback_ then the ReportWriteCompletion() would never know
that it was aborted and attempt to use it's dangling raw pointer to a
deleted IndexedDBBackingStore instance.

Also in this change is the elimination of the redundant aborted_
member variable.

BUG=472614

Review URL: https://codereview.chromium.org/1060613002

Cr-Commit-Position: refs/heads/master@{#326597}
",29777a8ee0f45b8160ec004e74013d5b62b6828a,https://chromium.googlesource.com/chromium/src/+/29777a8ee0f45b8160ec004e74013d5b62b6828a,content/browser/indexed_db/indexed_db_backing_store.cc,ChainedBlobWriterImpl,"ChainedBlobWriterImpl(
int64 database_id,
IndexedDBBackingStore* backing_store,
WriteDescriptorVec* blobs,
scoped_refptr<IndexedDBBackingStore::BlobWriteCallback> callback)
: waiting_for_callback_(false),
database_id_(database_id),
backing_store_(backing_store),
callback_(callback),
aborted_(false) {
blobs_.swap(*blobs);
iter_ = blobs_.begin();
backing_store->task_runner()->PostTask(
FROM_HERE, base::Bind(&ChainedBlobWriterImpl::WriteNextFile, this));
}","ChainedBlobWriterImpl(
int64 VAR_0,
IndexedDBBackingStore* VAR_1,
WriteDescriptorVec* VAR_2,
scoped_refptr<IndexedDBBackingStore::BlobWriteCallback> VAR_3)
: waiting_for_callback_(false),
database_id_(VAR_0),
backing_store_(VAR_1),
callback_(VAR_3),
aborted_(false) {
VAR_4.swap(*VAR_2);
VAR_5 = VAR_4.begin();
VAR_1->task_runner()->PostTask(
VAR_6, base::Bind(&ChainedBlobWriterImpl::WriteNextFile, this));
}",,"ChainedBlobWriterImpl(
      int64 database_id,
      IndexedDBBackingStore* backing_store,
      WriteDescriptorVec* blobs,
      scoped_refptr<IndexedDBBackingStore::BlobWriteCallback> callback)
      : waiting_for_callback_(false),
        database_id_(database_id),
        backing_store_(backing_store),
        callback_(callback) {
    blobs_.swap(*blobs);
    iter_ = blobs_.begin();
    backing_store->task_runner()->PostTask(
        FROM_HERE, base::Bind(&ChainedBlobWriterImpl::WriteNextFile, this));
  }","ChainedBlobWriterImpl(
      int64 VAR_0,
      IndexedDBBackingStore* VAR_1,
      WriteDescriptorVec* VAR_2,
      scoped_refptr<IndexedDBBackingStore::BlobWriteCallback> VAR_3)
      : waiting_for_callback_(false),
        database_id_(VAR_0),
        backing_store_(VAR_1),
        callback_(VAR_3) {
    VAR_4.swap(*VAR_2);
    VAR_5 = VAR_4.begin();
    VAR_1->task_runner()->PostTask(
        VAR_6, base::Bind(&ChainedBlobWriterImpl::WriteNextFile, this));
  }",,"--- func_before
+++ func_after
@@ -6,8 +6,7 @@
       : waiting_for_callback_(false),
         database_id_(database_id),
         backing_store_(backing_store),
-        callback_(callback),
-        aborted_(false) {
+        callback_(callback) {
     blobs_.swap(*blobs);
     iter_ = blobs_.begin();
     backing_store->task_runner()->PostTask(","{'deleted_lines': ['        callback_(callback),', '        aborted_(false) {'], 'added_lines': ['        callback_(callback) {']}",True,Use-after-free vulnerability in content/browser/indexed_db/indexed_db_backing_store.cc in the IndexedDB implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,9.8,CRITICAL,3,valid,,5
CVE-2015-1276,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,chromium,"IndexedDB: Protect against use-after-free in ChainedBlobWriter.

This is a speculative fix for a heap user-after-free bug. Was unable
to verify using a Windows SyzyASan build. The theory is that if Abort()
was called before ChainedBlobWriterImpl::WriteNextFile() could set
waiting_for_callback_ then the ReportWriteCompletion() would never know
that it was aborted and attempt to use it's dangling raw pointer to a
deleted IndexedDBBackingStore instance.

Also in this change is the elimination of the redundant aborted_
member variable.

BUG=472614

Review URL: https://codereview.chromium.org/1060613002

Cr-Commit-Position: refs/heads/master@{#326597}
",29777a8ee0f45b8160ec004e74013d5b62b6828a,https://chromium.googlesource.com/chromium/src/+/29777a8ee0f45b8160ec004e74013d5b62b6828a,content/browser/indexed_db/indexed_db_backing_store.cc,~ChainedBlobWriterImpl,~ChainedBlobWriterImpl() override {},~VAR_0() override {},,~ChainedBlobWriterImpl() override { DCHECK(!waiting_for_callback_); },~VAR_0() override { DCHECK(!VAR_1); },,"--- func_before
+++ func_after
@@ -1 +1 @@
-~ChainedBlobWriterImpl() override {}
+~ChainedBlobWriterImpl() override { DCHECK(!waiting_for_callback_); }","{'deleted_lines': ['~ChainedBlobWriterImpl() override {}'], 'added_lines': ['~ChainedBlobWriterImpl() override { DCHECK(!waiting_for_callback_); }']}",True,Use-after-free vulnerability in content/browser/indexed_db/indexed_db_backing_store.cc in the IndexedDB implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,9.8,CRITICAL,3,valid,,5
CVE-2021-38604,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,glibc,"
librt: fix NULL pointer dereference (bug 28213)

Helper thread frees copied attribute on NOTIFY_REMOVED message
received from the OS kernel.  Unfortunately, it fails to check whether
copied attribute actually exists (data.attr != NULL).  This worked
earlier because free() checks passed pointer before actually
attempting to release corresponding memory.  But
__pthread_attr_destroy assumes pointer is not NULL.

So passing NULL pointer to __pthread_attr_destroy will result in
segmentation fault.  This scenario is possible if
notification->sigev_notify_attributes == NULL (which means default
thread attributes should be used).

Signed-off-by: Nikita Popov <npv1310@gmail.com>
Reviewed-by: Siddhesh Poyarekar <siddhesh@sourceware.org>
",b805aebd42364fe696e417808a700fdb9800c9e8,https://sourceware.org/git/?p=glibc.git;a=commit;h=b805aebd42364fe696e417808a700fdb9800c9e8,sysdeps/unix/sysv/linux/mq_notify.c,helper_thread,"static void *
helper_thread (void *arg)
{
while (1)
{
union notify_data data;
ssize_t n = __recv (netlink_socket, &data, sizeof (data),
MSG_NOSIGNAL | MSG_WAITALL);
if (n < NOTIFY_COOKIE_LEN)
continue;
if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_WOKENUP)
{
pthread_t th;
if (__pthread_create (&th, data.attr, notification_function, &data)
== 0)
(void) __pthread_barrier_wait (&notify_barrier);
}
else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED)
{
__pthread_attr_destroy (data.attr);
free (data.attr);
}
}
return NULL;
}","static void *
helper_thread (void *VAR_0)
{
while (1)
{
union notify_data VAR_1;
ssize_t VAR_2 = __recv (VAR_3, &VAR_1, sizeof (VAR_1),
VAR_4 | VAR_5);
if (VAR_2 < VAR_6)
continue;
if (VAR_1.raw[VAR_6 - 1] == VAR_7)
{
pthread_t VAR_8;
if (__pthread_create (&VAR_8, VAR_1.attr, VAR_9, &VAR_1)
== 0)
(void) __pthread_barrier_wait (&VAR_10);
}
else if (VAR_1.raw[VAR_6 - 1] == VAR_11)
{
__pthread_attr_destroy (VAR_1.attr);
free (VAR_1.attr);
}
}
return NULL;
}",glibc/b805aebd42364fe696e417808a700fdb9800c9e8/mq_notify.c/vul/before/0.json,"static void *
helper_thread (void *arg)
{
  while (1)
    {
      union notify_data data;

      ssize_t n = __recv (netlink_socket, &data, sizeof (data),
			  MSG_NOSIGNAL | MSG_WAITALL);
      if (n < NOTIFY_COOKIE_LEN)
	continue;

      if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_WOKENUP)
	{
	  /* Just create the thread as instructed.  There is no way to
	     report a problem with creating a thread.  */
	  pthread_t th;
	  if (__pthread_create (&th, data.attr, notification_function, &data)
	      == 0)
	    /* Since we passed a pointer to DATA to the new thread we have
	       to wait until it is done with it.  */
	    (void) __pthread_barrier_wait (&notify_barrier);
	}
      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED && data.attr != NULL)
	{
	  /* The only state we keep is the copy of the thread attributes.  */
	  __pthread_attr_destroy (data.attr);
	  free (data.attr);
	}
    }
  return NULL;
}","static void *
helper_thread (void *VAR_0)
{
  while (1)
    {
      union notify_data VAR_1;

      ssize_t VAR_2 = __recv (VAR_3, &VAR_1, sizeof (VAR_1),
			  VAR_4 | VAR_5);
      if (VAR_2 < VAR_6)
	continue;

      if (VAR_1.raw[VAR_6 - 1] == VAR_7)
	{
	  /* COMMENT_0 */
                                                  
	  pthread_t VAR_8;
	  if (__pthread_create (&VAR_8, VAR_1.attr, VAR_9, &VAR_1)
	      == 0)
	    /* COMMENT_2 */
                                             
	    (void) __pthread_barrier_wait (&VAR_10);
	}
      else if (VAR_1.raw[VAR_6 - 1] == VAR_11 && VAR_1.attr != NULL)
	{
	  /* COMMENT_4 */
	  __pthread_attr_destroy (VAR_1.attr);
	  free (VAR_1.attr);
	}
    }
  return NULL;
}",glibc/b805aebd42364fe696e417808a700fdb9800c9e8/mq_notify.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,7 @@
 	       to wait until it is done with it.  */
 	    (void) __pthread_barrier_wait (&notify_barrier);
 	}
-      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED)
+      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED && data.attr != NULL)
 	{
 	  /* The only state we keep is the copy of the thread attributes.  */
 	  __pthread_attr_destroy (data.attr);","{'deleted_lines': ['      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED)'], 'added_lines': ['      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED && data.attr != NULL)']}",True,"In librt in the GNU C Library (aka glibc) through 2.34, sysdeps/unix/sysv/linux/mq_notify.c mishandles certain NOTIFY_REMOVED data, leading to a NULL pointer dereference. NOTE: this vulnerability was introduced as a side effect of the CVE-2021-33574 fix.",7.5,HIGH,2,valid,,5
CVE-2021-3712,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,openssl,"
Fix EC_GROUP_new_from_ecparameters to check the base length

Check that there's at least one byte in params->base before trying to
read it.

CVE-2021-3712

Reviewed-by: Viktor Dukhovni <viktor@openssl.org>
Reviewed-by: Paul Dale <pauli@openssl.org>
",94d23fcff9b2a7a8368dfe52214d5c2569882c11,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=94d23fcff9b2a7a8368dfe52214d5c2569882c11,crypto/ec/ec_asn1.c,EC_GROUP_new_from_ecparameters,"EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
{
int ok = 0, tmp;
EC_GROUP *ret = NULL, *dup = NULL;
BIGNUM *p = NULL, *a = NULL, *b = NULL;
EC_POINT *point = NULL;
long field_bits;
int curve_name = NID_undef;
BN_CTX *ctx = NULL;
if (!params->fieldID || !params->fieldID->fieldType ||
!params->fieldID->p.ptr) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
if (!params->curve || !params->curve->a ||
!params->curve->a->data || !params->curve->b ||
!params->curve->b->data) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);
if (a == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
goto err;
}
b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);
if (b == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
goto err;
}
tmp = OBJ_obj2nid(params->fieldID->fieldType);
if (tmp == NID_X9_62_characteristic_two_field)
#ifdef OPENSSL_NO_EC2M
{
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
goto err;
}
#else
{
X9_62_CHARACTERISTIC_TWO *char_two;
char_two = params->fieldID->p.char_two;
field_bits = char_two->m;
if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
goto err;
}
if ((p = BN_new()) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
goto err;
}
tmp = OBJ_obj2nid(char_two->type);
if (tmp == NID_X9_62_tpBasis) {
long tmp_long;
if (!char_two->p.tpBasis) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);
if (!(char_two->m > tmp_long && tmp_long > 0)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
EC_R_INVALID_TRINOMIAL_BASIS);
goto err;
}
if (!BN_set_bit(p, (int)char_two->m))
goto err;
if (!BN_set_bit(p, (int)tmp_long))
goto err;
if (!BN_set_bit(p, 0))
goto err;
} else if (tmp == NID_X9_62_ppBasis) {
X9_62_PENTANOMIAL *penta;
penta = char_two->p.ppBasis;
if (!penta) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
if (!
(char_two->m > penta->k3 && penta->k3 > penta->k2
&& penta->k2 > penta->k1 && penta->k1 > 0)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
EC_R_INVALID_PENTANOMIAL_BASIS);
goto err;
}
if (!BN_set_bit(p, (int)char_two->m))
goto err;
if (!BN_set_bit(p, (int)penta->k1))
goto err;
if (!BN_set_bit(p, (int)penta->k2))
goto err;
if (!BN_set_bit(p, (int)penta->k3))
goto err;
if (!BN_set_bit(p, 0))
goto err;
} else if (tmp == NID_X9_62_onBasis) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
goto err;
} else {                
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);
}
#endif
else if (tmp == NID_X9_62_prime_field) {
if (!params->fieldID->p.prime) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);
if (p == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
goto err;
}
if (BN_is_negative(p) || BN_is_zero(p)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
goto err;
}
field_bits = BN_num_bits(p);
if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
goto err;
}
ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
} else {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
goto err;
}
if (ret == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
goto err;
}
if (params->curve->seed != NULL) {
OPENSSL_free(ret->seed);
if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
goto err;
}
memcpy(ret->seed, params->curve->seed->data,
params->curve->seed->length);
ret->seed_len = params->curve->seed->length;
}
if (!params->order || !params->base || !params->base->data) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
goto err;
}
if ((point = EC_POINT_new(ret)) == NULL)
goto err;
EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)
(params->base->data[0] & ~0x01));
if (!EC_POINT_oct2point(ret, point, params->base->data,
params->base->length, NULL)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
goto err;
}
if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
goto err;
}
if (BN_is_negative(a) || BN_is_zero(a)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
goto err;
}
if (BN_num_bits(a) > (int)field_bits + 1) { 
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
goto err;
}
if (params->cofactor == NULL) {
BN_free(b);
b = NULL;
} else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
goto err;
}
if (!EC_GROUP_set_generator(ret, point, a, b)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
goto err;
}
if ((ctx = BN_CTX_new()) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
goto err;
}
if ((dup = EC_GROUP_dup(ret)) == NULL
|| EC_GROUP_set_seed(dup, NULL, 0) != 1
|| !EC_GROUP_set_generator(dup, point, a, NULL)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
goto err;
}
if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
EC_GROUP *named_group = NULL;
#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
if (curve_name == NID_wap_wsg_idm_ecid_wtls12)
curve_name = NID_secp224r1;
#endif 
if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
goto err;
}
EC_GROUP_free(ret);
ret = named_group;
EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);
if (params->curve->seed == NULL) {
if (EC_GROUP_set_seed(ret, NULL, 0) != 1)
goto err;
}
}
ok = 1;
err:
if (!ok) {
EC_GROUP_free(ret);
ret = NULL;
}
EC_GROUP_free(dup);
BN_free(p);
BN_free(a);
BN_free(b);
EC_POINT_free(point);
BN_CTX_free(ctx);
return ret;
}","EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *VAR_0)
{
int VAR_1 = 0, VAR_2;
EC_GROUP *VAR_3 = NULL, *VAR_4 = NULL;
BIGNUM *VAR_5 = NULL, *VAR_6 = NULL, *VAR_7 = NULL;
EC_POINT *VAR_8 = NULL;
long VAR_9;
int VAR_10 = VAR_11;
BN_CTX *VAR_12 = NULL;
if (!VAR_0->fieldID || !VAR_0->fieldID->fieldType ||
!VAR_0->fieldID->p.ptr) {
ECerr(VAR_13, VAR_14);
goto err;
}
if (!VAR_0->curve || !VAR_0->curve->a ||
!VAR_0->curve->a->data || !VAR_0->curve->b ||
!VAR_0->curve->b->data) {
ECerr(VAR_13, VAR_14);
goto err;
}
VAR_6 = BN_bin2bn(VAR_0->curve->a->data, VAR_0->curve->a->length, NULL);
if (VAR_6 == NULL) {
ECerr(VAR_13, VAR_15);
goto err;
}
VAR_7 = BN_bin2bn(VAR_0->curve->b->data, VAR_0->curve->b->length, NULL);
if (VAR_7 == NULL) {
ECerr(VAR_13, VAR_15);
goto err;
}
VAR_2 = OBJ_obj2nid(VAR_0->fieldID->fieldType);
if (VAR_2 == VAR_16)
#ifdef VAR_17
{
ECerr(VAR_13, VAR_18);
goto err;
}
#else
{
X9_62_CHARACTERISTIC_TWO *VAR_19;
VAR_19 = VAR_0->fieldID->p.char_two;
VAR_9 = VAR_19->m;
if (VAR_9 > VAR_20) {
ECerr(VAR_13, VAR_21);
goto err;
}
if ((VAR_5 = BN_new()) == NULL) {
ECerr(VAR_13, VAR_22);
goto err;
}
VAR_2 = OBJ_obj2nid(VAR_19->type);
if (VAR_2 == VAR_23) {
long VAR_24;
if (!VAR_19->p.tpBasis) {
ECerr(VAR_13, VAR_14);
goto err;
}
VAR_24 = ASN1_INTEGER_get(VAR_19->p.tpBasis);
if (!(VAR_19->m > VAR_24 && VAR_24 > 0)) {
ECerr(VAR_13,
VAR_25);
goto err;
}
if (!BN_set_bit(VAR_5, (int)VAR_19->m))
goto err;
if (!BN_set_bit(VAR_5, (int)VAR_24))
goto err;
if (!BN_set_bit(VAR_5, 0))
goto err;
} else if (VAR_2 == VAR_26) {
X9_62_PENTANOMIAL *VAR_27;
VAR_27 = VAR_19->p.ppBasis;
if (!VAR_27) {
ECerr(VAR_13, VAR_14);
goto err;
}
if (!
(VAR_19->m > VAR_27->k3 && VAR_27->k3 > VAR_27->k2
&& VAR_27->k2 > VAR_27->k1 && VAR_27->k1 > 0)) {
ECerr(VAR_13,
VAR_28);
goto err;
}
if (!BN_set_bit(VAR_5, (int)VAR_19->m))
goto err;
if (!BN_set_bit(VAR_5, (int)VAR_27->k1))
goto err;
if (!BN_set_bit(VAR_5, (int)VAR_27->k2))
goto err;
if (!BN_set_bit(VAR_5, (int)VAR_27->k3))
goto err;
if (!BN_set_bit(VAR_5, 0))
goto err;
} else if (VAR_2 == VAR_29) {
ECerr(VAR_13, VAR_30);
goto err;
} else {                
ECerr(VAR_13, VAR_14);
goto err;
}
VAR_3 = EC_GROUP_new_curve_GF2m(VAR_5, VAR_6, VAR_7, NULL);
}
#endif
else if (tmp == VAR_31) {
if (!VAR_0->fieldID->p.prime) {
ECerr(VAR_13, VAR_14);
goto err;
}
VAR_5 = ASN1_INTEGER_to_BN(VAR_0->fieldID->p.prime, NULL);
if (VAR_5 == NULL) {
ECerr(VAR_13, VAR_32);
goto err;
}
if (BN_is_negative(VAR_5) || BN_is_zero(VAR_5)) {
ECerr(VAR_13, VAR_33);
goto err;
}
VAR_9 = BN_num_bits(VAR_5);
if (VAR_9 > VAR_20) {
ECerr(VAR_13, VAR_21);
goto err;
}
VAR_3 = EC_GROUP_new_curve_GFp(VAR_5, VAR_6, VAR_7, NULL);
} else {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
goto err;
}
if (VAR_3 == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
goto err;
}
if (VAR_0->curve->seed != NULL) {
OPENSSL_free(VAR_3->seed);
if ((VAR_3->seed = OPENSSL_malloc(VAR_0->curve->seed->length)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_22);
goto err;
}
memcpy(VAR_3->seed, VAR_0->curve->seed->data,
VAR_0->curve->seed->length);
VAR_3->seed_len = VAR_0->curve->seed->length;
}
if (!VAR_0->order || !VAR_0->base || !VAR_0->base->data) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_14);
goto err;
}
if ((VAR_8 = EC_POINT_new(VAR_3)) == NULL)
goto err;
EC_GROUP_set_point_conversion_form(VAR_3, (VAR_35)
(VAR_0->base->data[0] & ~0x01));
if (!EC_POINT_oct2point(VAR_3, VAR_8, VAR_0->base->data,
VAR_0->base->length, NULL)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
goto err;
}
if ((VAR_6 = ASN1_INTEGER_to_BN(VAR_0->order, VAR_6)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_32);
goto err;
}
if (BN_is_negative(VAR_6) || BN_is_zero(VAR_6)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_36);
goto err;
}
if (BN_num_bits(VAR_6) > (int)VAR_9 + 1) { 
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_36);
goto err;
}
if (VAR_0->cofactor == NULL) {
BN_free(VAR_7);
VAR_7 = NULL;
} else if ((VAR_7 = ASN1_INTEGER_to_BN(VAR_0->cofactor, VAR_7)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_32);
goto err;
}
if (!EC_GROUP_set_generator(VAR_3, VAR_8, VAR_6, VAR_7)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
goto err;
}
if ((VAR_12 = BN_CTX_new()) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_15);
goto err;
}
if ((VAR_4 = EC_GROUP_dup(VAR_3)) == NULL
|| EC_GROUP_set_seed(VAR_4, NULL, 0) != 1
|| !EC_GROUP_set_generator(VAR_4, VAR_8, VAR_6, NULL)) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
goto err;
}
if ((VAR_10 = ec_curve_nid_from_params(VAR_4, VAR_12)) != VAR_11) {
EC_GROUP *VAR_37 = NULL;
#ifndef VAR_38
if (VAR_10 == VAR_39)
VAR_10 = VAR_40;
#endif 
if ((VAR_37 = EC_GROUP_new_by_curve_name(VAR_10)) == NULL) {
ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
goto err;
}
EC_GROUP_free(VAR_3);
VAR_3 = VAR_37;
EC_GROUP_set_asn1_flag(VAR_3, VAR_41);
if (VAR_0->curve->seed == NULL) {
if (EC_GROUP_set_seed(VAR_3, NULL, 0) != 1)
goto err;
}
}
VAR_1 = 1;
err:
if (!VAR_1) {
EC_GROUP_free(VAR_3);
VAR_3 = NULL;
}
EC_GROUP_free(VAR_4);
BN_free(VAR_5);
BN_free(VAR_6);
BN_free(VAR_7);
EC_POINT_free(VAR_8);
BN_CTX_free(VAR_12);
return VAR_3;
}",openssl/94d23fcff9b2a7a8368dfe52214d5c2569882c11/ec_asn1.c/vul/before/0.json,"EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
{
    int ok = 0, tmp;
    EC_GROUP *ret = NULL, *dup = NULL;
    BIGNUM *p = NULL, *a = NULL, *b = NULL;
    EC_POINT *point = NULL;
    long field_bits;
    int curve_name = NID_undef;
    BN_CTX *ctx = NULL;

    if (!params->fieldID || !params->fieldID->fieldType ||
        !params->fieldID->p.ptr) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        goto err;
    }

    /*
     * Now extract the curve parameters a and b. Note that, although SEC 1
     * specifies the length of their encodings, historical versions of OpenSSL
     * encoded them incorrectly, so we must accept any length for backwards
     * compatibility.
     */
    if (!params->curve || !params->curve->a ||
        !params->curve->a->data || !params->curve->b ||
        !params->curve->b->data) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        goto err;
    }
    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);
    if (a == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        goto err;
    }
    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);
    if (b == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        goto err;
    }

    /* get the field parameters */
    tmp = OBJ_obj2nid(params->fieldID->fieldType);
    if (tmp == NID_X9_62_characteristic_two_field)
#ifdef OPENSSL_NO_EC2M
    {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
        goto err;
    }
#else
    {
        X9_62_CHARACTERISTIC_TWO *char_two;

        char_two = params->fieldID->p.char_two;

        field_bits = char_two->m;
        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
            goto err;
        }

        if ((p = BN_new()) == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
            goto err;
        }

        /* get the base type */
        tmp = OBJ_obj2nid(char_two->type);

        if (tmp == NID_X9_62_tpBasis) {
            long tmp_long;

            if (!char_two->p.tpBasis) {
                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
                goto err;
            }

            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);

            if (!(char_two->m > tmp_long && tmp_long > 0)) {
                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
                      EC_R_INVALID_TRINOMIAL_BASIS);
                goto err;
            }

            /* create the polynomial */
            if (!BN_set_bit(p, (int)char_two->m))
                goto err;
            if (!BN_set_bit(p, (int)tmp_long))
                goto err;
            if (!BN_set_bit(p, 0))
                goto err;
        } else if (tmp == NID_X9_62_ppBasis) {
            X9_62_PENTANOMIAL *penta;

            penta = char_two->p.ppBasis;
            if (!penta) {
                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
                goto err;
            }

            if (!
                (char_two->m > penta->k3 && penta->k3 > penta->k2
                 && penta->k2 > penta->k1 && penta->k1 > 0)) {
                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
                      EC_R_INVALID_PENTANOMIAL_BASIS);
                goto err;
            }

            /* create the polynomial */
            if (!BN_set_bit(p, (int)char_two->m))
                goto err;
            if (!BN_set_bit(p, (int)penta->k1))
                goto err;
            if (!BN_set_bit(p, (int)penta->k2))
                goto err;
            if (!BN_set_bit(p, (int)penta->k3))
                goto err;
            if (!BN_set_bit(p, 0))
                goto err;
        } else if (tmp == NID_X9_62_onBasis) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
            goto err;
        } else {                /* error */

            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
            goto err;
        }

        /* create the EC_GROUP structure */
        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);
    }
#endif
    else if (tmp == NID_X9_62_prime_field) {
        /* we have a curve over a prime field */
        /* extract the prime number */
        if (!params->fieldID->p.prime) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
            goto err;
        }
        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);
        if (p == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
            goto err;
        }

        if (BN_is_negative(p) || BN_is_zero(p)) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
            goto err;
        }

        field_bits = BN_num_bits(p);
        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
            goto err;
        }

        /* create the EC_GROUP structure */
        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
    } else {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
        goto err;
    }

    if (ret == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        goto err;
    }

    /* extract seed (optional) */
    if (params->curve->seed != NULL) {
        OPENSSL_free(ret->seed);
        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
            goto err;
        }
        memcpy(ret->seed, params->curve->seed->data,
               params->curve->seed->length);
        ret->seed_len = params->curve->seed->length;
    }

    if (params->order == NULL
            || params->base == NULL
            || params->base->data == NULL
            || params->base->length == 0) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        goto err;
    }

    if ((point = EC_POINT_new(ret)) == NULL)
        goto err;

    /* set the point conversion form */
    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)
                                       (params->base->data[0] & ~0x01));

    /* extract the ec point */
    if (!EC_POINT_oct2point(ret, point, params->base->data,
                            params->base->length, NULL)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        goto err;
    }

    /* extract the order */
    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
        goto err;
    }
    if (BN_is_negative(a) || BN_is_zero(a)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
        goto err;
    }
    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
        goto err;
    }

    /* extract the cofactor (optional) */
    if (params->cofactor == NULL) {
        BN_free(b);
        b = NULL;
    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
        goto err;
    }
    /* set the generator, order and cofactor (if present) */
    if (!EC_GROUP_set_generator(ret, point, a, b)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        goto err;
    }

    /*
     * Check if the explicit parameters group just created matches one of the
     * built-in curves.
     *
     * We create a copy of the group just built, so that we can remove optional
     * fields for the lookup: we do this to avoid the possibility that one of
     * the optional parameters is used to force the library into using a less
     * performant and less secure EC_METHOD instead of the specialized one.
     * In any case, `seed` is not really used in any computation, while a
     * cofactor different from the one in the built-in table is just
     * mathematically wrong anyway and should not be used.
     */
    if ((ctx = BN_CTX_new()) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        goto err;
    }
    if ((dup = EC_GROUP_dup(ret)) == NULL
            || EC_GROUP_set_seed(dup, NULL, 0) != 1
            || !EC_GROUP_set_generator(dup, point, a, NULL)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        goto err;
    }
    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
        /*
         * The input explicit parameters successfully matched one of the
         * built-in curves: often for built-in curves we have specialized
         * methods with better performance and hardening.
         *
         * In this case we replace the `EC_GROUP` created through explicit
         * parameters with one created from a named group.
         */
        EC_GROUP *named_group = NULL;

#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
        /*
         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for
         * the same curve, we prefer the SECP nid when matching explicit
         * parameters as that is associated with a specialized EC_METHOD.
         */
        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)
            curve_name = NID_secp224r1;
#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */

        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
            goto err;
        }
        EC_GROUP_free(ret);
        ret = named_group;

        /*
         * Set the flag so that EC_GROUPs created from explicit parameters are
         * serialized using explicit parameters by default.
         */
        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);

        /*
         * If the input params do not contain the optional seed field we make
         * sure it is not added to the returned group.
         *
         * The seed field is not really used inside libcrypto anyway, and
         * adding it to parsed explicit parameter keys would alter their DER
         * encoding output (because of the extra field) which could impact
         * applications fingerprinting keys by their DER encoding.
         */
        if (params->curve->seed == NULL) {
            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)
                goto err;
        }
    }

    ok = 1;

 err:
    if (!ok) {
        EC_GROUP_free(ret);
        ret = NULL;
    }
    EC_GROUP_free(dup);

    BN_free(p);
    BN_free(a);
    BN_free(b);
    EC_POINT_free(point);

    BN_CTX_free(ctx);

    return ret;
}","EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *VAR_0)
{
    int VAR_1 = 0, VAR_2;
    EC_GROUP *VAR_3 = NULL, *VAR_4 = NULL;
    BIGNUM *VAR_5 = NULL, *VAR_6 = NULL, *VAR_7 = NULL;
    EC_POINT *VAR_8 = NULL;
    long VAR_9;
    int VAR_10 = VAR_11;
    BN_CTX *VAR_12 = NULL;

    if (!VAR_0->fieldID || !VAR_0->fieldID->fieldType ||
        !VAR_0->fieldID->p.ptr) {
        ECerr(VAR_13, VAR_14);
        goto err;
    }

    /* COMMENT_0 */
                                                                          
                                                                              
                                                                           
                     
       
    if (!VAR_0->curve || !VAR_0->curve->a ||
        !VAR_0->curve->a->data || !VAR_0->curve->b ||
        !VAR_0->curve->b->data) {
        ECerr(VAR_13, VAR_14);
        goto err;
    }
    VAR_6 = BN_bin2bn(VAR_0->curve->a->data, VAR_0->curve->a->length, NULL);
    if (VAR_6 == NULL) {
        ECerr(VAR_13, VAR_15);
        goto err;
    }
    VAR_7 = BN_bin2bn(VAR_0->curve->b->data, VAR_0->curve->b->length, NULL);
    if (VAR_7 == NULL) {
        ECerr(VAR_13, VAR_15);
        goto err;
    }

    /* COMMENT_6 */
    VAR_2 = OBJ_obj2nid(VAR_0->fieldID->fieldType);
    if (VAR_2 == VAR_16)
#ifdef VAR_17
    {
        ECerr(VAR_13, VAR_18);
        goto err;
    }
#else
    {
        X9_62_CHARACTERISTIC_TWO *VAR_19;

        VAR_19 = VAR_0->fieldID->p.char_two;

        VAR_9 = VAR_19->m;
        if (VAR_9 > VAR_20) {
            ECerr(VAR_13, VAR_21);
            goto err;
        }

        if ((VAR_5 = BN_new()) == NULL) {
            ECerr(VAR_13, VAR_22);
            goto err;
        }

        /* COMMENT_7 */
        VAR_2 = OBJ_obj2nid(VAR_19->type);

        if (VAR_2 == VAR_23) {
            long VAR_24;

            if (!VAR_19->p.tpBasis) {
                ECerr(VAR_13, VAR_14);
                goto err;
            }

            VAR_24 = ASN1_INTEGER_get(VAR_19->p.tpBasis);

            if (!(VAR_19->m > VAR_24 && VAR_24 > 0)) {
                ECerr(VAR_13,
                      VAR_25);
                goto err;
            }

            /* COMMENT_8 */
            if (!BN_set_bit(VAR_5, (int)VAR_19->m))
                goto err;
            if (!BN_set_bit(VAR_5, (int)VAR_24))
                goto err;
            if (!BN_set_bit(VAR_5, 0))
                goto err;
        } else if (VAR_2 == VAR_26) {
            X9_62_PENTANOMIAL *VAR_27;

            VAR_27 = VAR_19->p.ppBasis;
            if (!VAR_27) {
                ECerr(VAR_13, VAR_14);
                goto err;
            }

            if (!
                (VAR_19->m > VAR_27->k3 && VAR_27->k3 > VAR_27->k2
                 && VAR_27->k2 > VAR_27->k1 && VAR_27->k1 > 0)) {
                ECerr(VAR_13,
                      VAR_28);
                goto err;
            }

            /* COMMENT_8 */
            if (!BN_set_bit(VAR_5, (int)VAR_19->m))
                goto err;
            if (!BN_set_bit(VAR_5, (int)VAR_27->k1))
                goto err;
            if (!BN_set_bit(VAR_5, (int)VAR_27->k2))
                goto err;
            if (!BN_set_bit(VAR_5, (int)VAR_27->k3))
                goto err;
            if (!BN_set_bit(VAR_5, 0))
                goto err;
        } else if (VAR_2 == VAR_29) {
            ECerr(VAR_13, VAR_30);
            goto err;
        } else {                /* COMMENT_9 */

            ECerr(VAR_13, VAR_14);
            goto err;
        }

        /* COMMENT_10 */
        VAR_3 = EC_GROUP_new_curve_GF2m(VAR_5, VAR_6, VAR_7, NULL);
    }
#endif
    else if (tmp == VAR_31) {
        /* COMMENT_11 */
        /* COMMENT_12 */
        if (!VAR_0->fieldID->p.prime) {
            ECerr(VAR_13, VAR_14);
            goto err;
        }
        VAR_5 = ASN1_INTEGER_to_BN(VAR_0->fieldID->p.prime, NULL);
        if (VAR_5 == NULL) {
            ECerr(VAR_13, VAR_32);
            goto err;
        }

        if (BN_is_negative(VAR_5) || BN_is_zero(VAR_5)) {
            ECerr(VAR_13, VAR_33);
            goto err;
        }

        VAR_9 = BN_num_bits(VAR_5);
        if (VAR_9 > VAR_20) {
            ECerr(VAR_13, VAR_21);
            goto err;
        }

        /* COMMENT_10 */
        VAR_3 = EC_GROUP_new_curve_GFp(VAR_5, VAR_6, VAR_7, NULL);
    } else {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
        goto err;
    }

    if (VAR_3 == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
        goto err;
    }

    /* COMMENT_13 */
    if (VAR_0->curve->seed != NULL) {
        OPENSSL_free(VAR_3->seed);
        if ((VAR_3->seed = OPENSSL_malloc(VAR_0->curve->seed->length)) == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_22);
            goto err;
        }
        memcpy(VAR_3->seed, VAR_0->curve->seed->data,
               VAR_0->curve->seed->length);
        VAR_3->seed_len = VAR_0->curve->seed->length;
    }

    if (VAR_0->order == NULL
            || VAR_0->base == NULL
            || VAR_0->base->data == NULL
            || VAR_0->base->length == 0) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_14);
        goto err;
    }

    if ((VAR_8 = EC_POINT_new(VAR_3)) == NULL)
        goto err;

    /* COMMENT_14 */
    EC_GROUP_set_point_conversion_form(VAR_3, (VAR_35)
                                       (VAR_0->base->data[0] & ~0x01));

    /* COMMENT_15 */
    if (!EC_POINT_oct2point(VAR_3, VAR_8, VAR_0->base->data,
                            VAR_0->base->length, NULL)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
        goto err;
    }

    /* COMMENT_16 */
    if ((VAR_6 = ASN1_INTEGER_to_BN(VAR_0->order, VAR_6)) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_32);
        goto err;
    }
    if (BN_is_negative(VAR_6) || BN_is_zero(VAR_6)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_36);
        goto err;
    }
    if (BN_num_bits(VAR_6) > (int)VAR_9 + 1) { /* COMMENT_17 */
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_36);
        goto err;
    }

    /* COMMENT_18 */
    if (VAR_0->cofactor == NULL) {
        BN_free(VAR_7);
        VAR_7 = NULL;
    } else if ((VAR_7 = ASN1_INTEGER_to_BN(VAR_0->cofactor, VAR_7)) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_32);
        goto err;
    }
    /* COMMENT_19 */
    if (!EC_GROUP_set_generator(VAR_3, VAR_8, VAR_6, VAR_7)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
        goto err;
    }

    /* COMMENT_20 */
                                                                             
                       
      
                                                                               
                                                                             
                                                                             
                                                                           
                                                                         
                                                                    
                                                          
       
    if ((VAR_12 = BN_CTX_new()) == NULL) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_15);
        goto err;
    }
    if ((VAR_4 = EC_GROUP_dup(VAR_3)) == NULL
            || EC_GROUP_set_seed(VAR_4, NULL, 0) != 1
            || !EC_GROUP_set_generator(VAR_4, VAR_8, VAR_6, NULL)) {
        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
        goto err;
    }
    if ((VAR_10 = ec_curve_nid_from_params(VAR_4, VAR_12)) != VAR_11) {
        /* COMMENT_32 */
                                                                        
                                                                         
                                                         
          
                                                                          
                                                          
           
        EC_GROUP *VAR_37 = NULL;

#ifndef VAR_38
        /* COMMENT_40 */
                                                                             
                                                                        
                                                                         
           
        if (VAR_10 == VAR_39)
            VAR_10 = VAR_40;
#endif /* COMMENT_45 */

        if ((VAR_37 = EC_GROUP_new_by_curve_name(VAR_10)) == NULL) {
            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, VAR_34);
            goto err;
        }
        EC_GROUP_free(VAR_3);
        VAR_3 = VAR_37;

        /* COMMENT_46 */
                                                                              
                                                           
           
        EC_GROUP_set_asn1_flag(VAR_3, VAR_41);

        /* COMMENT_50 */
                                                                             
                                                      
          
                                                                         
                                                                            
                                                                          
                                                                  
           
        if (VAR_0->curve->seed == NULL) {
            if (EC_GROUP_set_seed(VAR_3, NULL, 0) != 1)
                goto err;
        }
    }

    VAR_1 = 1;

 err:
    if (!VAR_1) {
        EC_GROUP_free(VAR_3);
        VAR_3 = NULL;
    }
    EC_GROUP_free(VAR_4);

    BN_free(VAR_5);
    BN_free(VAR_6);
    BN_free(VAR_7);
    EC_POINT_free(VAR_8);

    BN_CTX_free(VAR_12);

    return VAR_3;
}",openssl/94d23fcff9b2a7a8368dfe52214d5c2569882c11/ec_asn1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -177,7 +177,10 @@
         ret->seed_len = params->curve->seed->length;
     }
 
-    if (!params->order || !params->base || !params->base->data) {
+    if (params->order == NULL
+            || params->base == NULL
+            || params->base->data == NULL
+            || params->base->length == 0) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
         goto err;
     }","{'deleted_lines': ['    if (!params->order || !params->base || !params->base->data) {'], 'added_lines': ['    if (params->order == NULL', '            || params->base == NULL', '            || params->base->data == NULL', '            || params->base->length == 0) {']}",True,"ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).",7.4,HIGH,2,valid,,5
CVE-2017-16830,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
Work around integer overflows when readelf is checking for corrupt ELF notes when run on a 32-bit host.

	PR 22384
	* readelf.c (print_gnu_property_note): Improve overflow checks so
	that they will work on a 32-bit host.
",6ab2c4ed51f9c4243691755e1b1d2149c6a426f4,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=6ab2c4ed51f9c4243691755e1b1d2149c6a426f4,binutils/readelf.c,print_gnu_property_note,"static void
print_gnu_property_note (Elf_Internal_Note * pnote)
{
unsigned char * ptr = (unsigned char *) pnote->descdata;
unsigned char * ptr_end = ptr + pnote->descsz;
unsigned int    size = is_32bit_elf ? 4 : 8;
printf (_(""      Properties: ""));
if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
{
printf (_(""<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n""), pnote->descsz);
return;
}
while (1)
{
unsigned int j;
unsigned int type = byte_get (ptr, 4);
unsigned int datasz = byte_get (ptr + 4, 4);
ptr += 8;
if ((ptr + datasz) > ptr_end)
{
printf (_(""<corrupt type (%#x) datasz: %#x>\n""),
type, datasz);
break;
}
if (type >= GNU_PROPERTY_LOPROC && type <= GNU_PROPERTY_HIPROC)
{
if (elf_header.e_machine == EM_X86_64
|| elf_header.e_machine == EM_IAMCU
|| elf_header.e_machine == EM_386)
{
switch (type)
{
case GNU_PROPERTY_X86_ISA_1_USED:
printf (""x86 ISA used: "");
if (datasz != 4)
printf (_(""<corrupt length: %#x> ""), datasz);
else
decode_x86_isa (byte_get (ptr, 4));
goto next;
case GNU_PROPERTY_X86_ISA_1_NEEDED:
printf (""x86 ISA needed: "");
if (datasz != 4)
printf (_(""<corrupt length: %#x> ""), datasz);
else
decode_x86_isa (byte_get (ptr, 4));
goto next;
case GNU_PROPERTY_X86_FEATURE_1_AND:
printf (""x86 feature: "");
if (datasz != 4)
printf (_(""<corrupt length: %#x> ""), datasz);
else
decode_x86_feature (type, byte_get (ptr, 4));
goto next;
default:
break;
}
}
}
else
{
switch (type)
{
case GNU_PROPERTY_STACK_SIZE:
printf (_(""stack size: ""));
if (datasz != size)
printf (_(""<corrupt length: %#x> ""), datasz);
else
printf (""%#lx"", (unsigned long) byte_get (ptr, size));
goto next;
case GNU_PROPERTY_NO_COPY_ON_PROTECTED:
printf (""no copy on protected "");
if (datasz)
printf (_(""<corrupt length: %#x> ""), datasz);
goto next;
default:
break;
}
}
if (type < GNU_PROPERTY_LOPROC)
printf (_(""<unknown type %#x data: ""), type);
else if (type < GNU_PROPERTY_LOUSER)
printf (_(""<procesor-specific type %#x data: ""), type);
else
printf (_(""<application-specific type %#x data: ""), type);
for (j = 0; j < datasz; ++j)
printf (""%02x "", ptr[j] & 0xff);
printf ("">"");
next:
ptr += ((datasz + (size - 1)) & ~ (size - 1));
if (ptr == ptr_end)
break;
else
{
if (do_wide)
printf ("", "");
else
printf (""\n\t"");
}
if (ptr > (ptr_end - 8))
{
printf (_(""<corrupt descsz: %#lx>\n""), pnote->descsz);
break;
}
}
printf (""\n"");
}","static void
print_gnu_property_note (Elf_Internal_Note * VAR_0)
{
unsigned char * VAR_1 = (unsigned char *) VAR_0->descdata;
unsigned char * VAR_2 = VAR_1 + VAR_0->descsz;
unsigned int    VAR_3 = VAR_4 ? 4 : 8;
printf (_(""      Properties: ""));
if (VAR_0->descsz < 8 || (VAR_0->descsz % VAR_3) != 0)
{
printf (_(""<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n""), VAR_0->descsz);
return;
}
while (1)
{
unsigned int VAR_5;
unsigned int VAR_6 = byte_get (VAR_1, 4);
unsigned int VAR_7 = byte_get (VAR_1 + 4, 4);
VAR_1 += 8;
if ((VAR_1 + VAR_7) > VAR_2)
{
printf (_(""<corrupt type (%#x) datasz: %#x>\n""),
VAR_6, VAR_7);
break;
}
if (VAR_6 >= VAR_8 && VAR_6 <= VAR_9)
{
if (VAR_10.e_machine == VAR_11
|| VAR_10.e_machine == VAR_12
|| VAR_10.e_machine == VAR_13)
{
switch (VAR_6)
{
case VAR_14:
printf (""x86 ISA used: "");
if (VAR_7 != 4)
printf (_(""<corrupt length: %#x> ""), VAR_7);
else
decode_x86_isa (byte_get (VAR_1, 4));
goto next;
case VAR_15:
printf (""x86 ISA needed: "");
if (VAR_7 != 4)
printf (_(""<corrupt length: %#x> ""), VAR_7);
else
decode_x86_isa (byte_get (VAR_1, 4));
goto next;
case VAR_16:
printf (""x86 feature: "");
if (VAR_7 != 4)
printf (_(""<corrupt length: %#x> ""), VAR_7);
else
decode_x86_feature (VAR_6, byte_get (VAR_1, 4));
goto next;
default:
break;
}
}
}
else
{
switch (VAR_6)
{
case VAR_17:
printf (_(""stack size: ""));
if (VAR_7 != VAR_3)
printf (_(""<corrupt length: %#x> ""), VAR_7);
else
printf (""%#lx"", (unsigned long) byte_get (VAR_1, VAR_3));
goto next;
case VAR_18:
printf (""no copy on protected "");
if (VAR_7)
printf (_(""<corrupt length: %#x> ""), VAR_7);
goto next;
default:
break;
}
}
if (VAR_6 < VAR_8)
printf (_(""<unknown type %#x data: ""), VAR_6);
else if (VAR_6 < VAR_19)
printf (_(""<procesor-specific type %#x data: ""), VAR_6);
else
printf (_(""<application-specific type %#x data: ""), VAR_6);
for (VAR_5 = 0; VAR_5 < VAR_7; ++VAR_5)
printf (""%02x "", VAR_1[VAR_5] & 0xff);
printf ("">"");
next:
VAR_1 += ((VAR_7 + (VAR_3 - 1)) & ~ (VAR_3 - 1));
if (VAR_1 == VAR_2)
break;
else
{
if (VAR_20)
printf ("", "");
else
printf (""\n\t"");
}
if (VAR_1 > (VAR_2 - 8))
{
printf (_(""<corrupt descsz: %#lx>\n""), VAR_0->descsz);
break;
}
}
printf (""\n"");
}",binutils-gdb/6ab2c4ed51f9c4243691755e1b1d2149c6a426f4/readelf.c/vul/before/0.json,"static void
print_gnu_property_note (Elf_Internal_Note * pnote)
{
  unsigned char * ptr = (unsigned char *) pnote->descdata;
  unsigned char * ptr_end = ptr + pnote->descsz;
  unsigned int    size = is_32bit_elf ? 4 : 8;

  printf (_(""      Properties: ""));

  if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
    {
      printf (_(""<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n""), pnote->descsz);
      return;
    }

  while (ptr < ptr_end)
    {
      unsigned int j;
      unsigned int type;
      unsigned int datasz;

      if ((size_t) (ptr_end - ptr) < 8)
	{
	  printf (_(""<corrupt descsz: %#lx>\n""), pnote->descsz);
	  break;
	}

      type = byte_get (ptr, 4);
      datasz = byte_get (ptr + 4, 4);

      ptr += 8;

      if (datasz > (size_t) (ptr_end - ptr))
	{
	  printf (_(""<corrupt type (%#x) datasz: %#x>\n""),
		  type, datasz);
	  break;
	}

      if (type >= GNU_PROPERTY_LOPROC && type <= GNU_PROPERTY_HIPROC)
	{
	  if (elf_header.e_machine == EM_X86_64
	      || elf_header.e_machine == EM_IAMCU
	      || elf_header.e_machine == EM_386)
	    {
	      switch (type)
		{
		case GNU_PROPERTY_X86_ISA_1_USED:
		  printf (""x86 ISA used: "");
		  if (datasz != 4)
		    printf (_(""<corrupt length: %#x> ""), datasz);
		  else
		    decode_x86_isa (byte_get (ptr, 4));
		  goto next;

		case GNU_PROPERTY_X86_ISA_1_NEEDED:
		  printf (""x86 ISA needed: "");
		  if (datasz != 4)
		    printf (_(""<corrupt length: %#x> ""), datasz);
		  else
		    decode_x86_isa (byte_get (ptr, 4));
		  goto next;

		case GNU_PROPERTY_X86_FEATURE_1_AND:
		  printf (""x86 feature: "");
		  if (datasz != 4)
		    printf (_(""<corrupt length: %#x> ""), datasz);
		  else
		    decode_x86_feature (type, byte_get (ptr, 4));
		  goto next;

		default:
		  break;
		}
	    }
	}
      else
	{
	  switch (type)
	    {
	    case GNU_PROPERTY_STACK_SIZE:
	      printf (_(""stack size: ""));
	      if (datasz != size)
		printf (_(""<corrupt length: %#x> ""), datasz);
	      else
		printf (""%#lx"", (unsigned long) byte_get (ptr, size));
	      goto next;

	    case GNU_PROPERTY_NO_COPY_ON_PROTECTED:
	      printf (""no copy on protected "");
	      if (datasz)
		printf (_(""<corrupt length: %#x> ""), datasz);
	      goto next;

	    default:
	      break;
	    }
	}

      if (type < GNU_PROPERTY_LOPROC)
	printf (_(""<unknown type %#x data: ""), type);
      else if (type < GNU_PROPERTY_LOUSER)
	printf (_(""<procesor-specific type %#x data: ""), type);
      else
	printf (_(""<application-specific type %#x data: ""), type);
      for (j = 0; j < datasz; ++j)
	printf (""%02x "", ptr[j] & 0xff);
      printf ("">"");

next:
      ptr += ((datasz + (size - 1)) & ~ (size - 1));
      if (ptr == ptr_end)
	break;

      if (do_wide)
	printf ("", "");
      else
	printf (""\n\t"");
    }

  printf (""\n"");
}","static void
print_gnu_property_note (Elf_Internal_Note * VAR_0)
{
  unsigned char * VAR_1 = (unsigned char *) VAR_0->descdata;
  unsigned char * VAR_2 = VAR_1 + VAR_0->descsz;
  unsigned int    VAR_3 = VAR_4 ? 4 : 8;

  printf (_(""      Properties: ""));

  if (VAR_0->descsz < 8 || (VAR_0->descsz % VAR_3) != 0)
    {
      printf (_(""<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n""), VAR_0->descsz);
      return;
    }

  while (VAR_1 < VAR_2)
    {
      unsigned int VAR_5;
      unsigned int VAR_6;
      unsigned int VAR_7;

      if ((size_t) (VAR_2 - VAR_1) < 8)
	{
	  printf (_(""<corrupt descsz: %#lx>\n""), VAR_0->descsz);
	  break;
	}

      VAR_6 = byte_get (VAR_1, 4);
      VAR_7 = byte_get (VAR_1 + 4, 4);

      VAR_1 += 8;

      if (VAR_7 > (size_t) (VAR_2 - VAR_1))
	{
	  printf (_(""<corrupt type (%#x) datasz: %#x>\n""),
		  VAR_6, VAR_7);
	  break;
	}

      if (VAR_6 >= VAR_8 && VAR_6 <= VAR_9)
	{
	  if (VAR_10.e_machine == VAR_11
	      || VAR_10.e_machine == VAR_12
	      || VAR_10.e_machine == VAR_13)
	    {
	      switch (VAR_6)
		{
		case VAR_14:
		  printf (""x86 ISA used: "");
		  if (VAR_7 != 4)
		    printf (_(""<corrupt length: %#x> ""), VAR_7);
		  else
		    decode_x86_isa (byte_get (VAR_1, 4));
		  goto next;

		case VAR_15:
		  printf (""x86 ISA needed: "");
		  if (VAR_7 != 4)
		    printf (_(""<corrupt length: %#x> ""), VAR_7);
		  else
		    decode_x86_isa (byte_get (VAR_1, 4));
		  goto next;

		case VAR_16:
		  printf (""x86 feature: "");
		  if (VAR_7 != 4)
		    printf (_(""<corrupt length: %#x> ""), VAR_7);
		  else
		    decode_x86_feature (VAR_6, byte_get (VAR_1, 4));
		  goto next;

		default:
		  break;
		}
	    }
	}
      else
	{
	  switch (VAR_6)
	    {
	    case VAR_17:
	      printf (_(""stack size: ""));
	      if (VAR_7 != VAR_3)
		printf (_(""<corrupt length: %#x> ""), VAR_7);
	      else
		printf (""%#lx"", (unsigned long) byte_get (VAR_1, VAR_3));
	      goto next;

	    case VAR_18:
	      printf (""no copy on protected "");
	      if (VAR_7)
		printf (_(""<corrupt length: %#x> ""), VAR_7);
	      goto next;

	    default:
	      break;
	    }
	}

      if (VAR_6 < VAR_8)
	printf (_(""<unknown type %#x data: ""), VAR_6);
      else if (VAR_6 < VAR_19)
	printf (_(""<procesor-specific type %#x data: ""), VAR_6);
      else
	printf (_(""<application-specific type %#x data: ""), VAR_6);
      for (VAR_5 = 0; VAR_5 < VAR_7; ++VAR_5)
	printf (""%02x "", VAR_1[VAR_5] & 0xff);
      printf ("">"");

next:
      VAR_1 += ((VAR_7 + (VAR_3 - 1)) & ~ (VAR_3 - 1));
      if (VAR_1 == VAR_2)
	break;

      if (VAR_20)
	printf ("", "");
      else
	printf (""\n\t"");
    }

  printf (""\n"");
}",binutils-gdb/6ab2c4ed51f9c4243691755e1b1d2149c6a426f4/readelf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,15 +13,24 @@
       return;
     }
 
-  while (1)
+  while (ptr < ptr_end)
     {
       unsigned int j;
-      unsigned int type = byte_get (ptr, 4);
-      unsigned int datasz = byte_get (ptr + 4, 4);
+      unsigned int type;
+      unsigned int datasz;
+
+      if ((size_t) (ptr_end - ptr) < 8)
+	{
+	  printf (_(""<corrupt descsz: %#lx>\n""), pnote->descsz);
+	  break;
+	}
+
+      type = byte_get (ptr, 4);
+      datasz = byte_get (ptr + 4, 4);
 
       ptr += 8;
 
-      if ((ptr + datasz) > ptr_end)
+      if (datasz > (size_t) (ptr_end - ptr))
 	{
 	  printf (_(""<corrupt type (%#x) datasz: %#x>\n""),
 		  type, datasz);
@@ -102,19 +111,11 @@
       ptr += ((datasz + (size - 1)) & ~ (size - 1));
       if (ptr == ptr_end)
 	break;
+
+      if (do_wide)
+	printf ("", "");
       else
-	{
-	  if (do_wide)
-	    printf ("", "");
-	  else
-	    printf (""\n\t"");
-	}
-
-      if (ptr > (ptr_end - 8))
-	{
-	  printf (_(""<corrupt descsz: %#lx>\n""), pnote->descsz);
-	  break;
-	}
+	printf (""\n\t"");
     }
 
   printf (""\n"");","{'deleted_lines': ['  while (1)', '      unsigned int type = byte_get (ptr, 4);', '      unsigned int datasz = byte_get (ptr + 4, 4);', '      if ((ptr + datasz) > ptr_end)', '\t{', '\t  if (do_wide)', '\t    printf ("", "");', '\t  else', '\t    printf (""\\n\\t"");', '\t}', '', '      if (ptr > (ptr_end - 8))', '\t{', '\t  printf (_(""<corrupt descsz: %#lx>\\n""), pnote->descsz);', '\t  break;', '\t}'], 'added_lines': ['  while (ptr < ptr_end)', '      unsigned int type;', '      unsigned int datasz;', '', '      if ((size_t) (ptr_end - ptr) < 8)', '\t{', '\t  printf (_(""<corrupt descsz: %#lx>\\n""), pnote->descsz);', '\t  break;', '\t}', '', '      type = byte_get (ptr, 4);', '      datasz = byte_get (ptr + 4, 4);', '      if (datasz > (size_t) (ptr_end - ptr))', '', '      if (do_wide)', '\tprintf ("", "");', '\tprintf (""\\n\\t"");']}",True,"The print_gnu_property_note function in readelf.c in GNU Binutils 2.29.1 does not have integer-overflow protection on 32-bit platforms, which allows remote attackers to cause a denial of service (segmentation violation and application crash) or possibly have unspecified other impact via a crafted ELF file.",7.8,HIGH,2,valid,,5
CVE-2017-17123,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
Check for a NULL symbol pointer when reading relocs from a COFF based file.

	PR 22509
	* coffcode.h (coff_slurp_reloc_table): Check for a NULL symbol
	pointer when processing relocs.
",4581a1c7d304ce14e714b27522ebf3d0188d6543,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=4581a1c7d304ce14e714b27522ebf3d0188d6543,bfd/coffcode.h,coff_slurp_reloc_table,"static bfd_boolean
coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
{
RELOC *native_relocs;
arelent *reloc_cache;
arelent *cache_ptr;
unsigned int idx;
bfd_size_type amt;
if (asect->relocation)
return TRUE;
if (asect->reloc_count == 0)
return TRUE;
if (asect->flags & SEC_CONSTRUCTOR)
return TRUE;
if (!coff_slurp_symbol_table (abfd))
return FALSE;
amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
reloc_cache = (arelent *) bfd_alloc (abfd, amt);
if (reloc_cache == NULL || native_relocs == NULL)
return FALSE;
for (idx = 0; idx < asect->reloc_count; idx++)
{
struct internal_reloc dst;
struct external_reloc *src;
#ifndef RELOC_PROCESSING
asymbol *ptr;
#endif
cache_ptr = reloc_cache + idx;
src = native_relocs + idx;
dst.r_offset = 0;
coff_swap_reloc_in (abfd, src, &dst);
#ifdef RELOC_PROCESSING
RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
#else
cache_ptr->address = dst.r_vaddr;
if (dst.r_symndx != -1)
{
if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
{
_bfd_error_handler
(_(""%B: warning: illegal symbol index %ld in relocs""),
abfd, dst.r_symndx);
cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
ptr = NULL;
}
else
{
cache_ptr->sym_ptr_ptr = (symbols
+ obj_convert (abfd)[dst.r_symndx]);
ptr = *(cache_ptr->sym_ptr_ptr);
}
}
else
{
cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
ptr = NULL;
}
CALC_ADDEND (abfd, ptr, dst, cache_ptr);
(void) ptr;
cache_ptr->address -= asect->vma;
RTYPE2HOWTO (cache_ptr, &dst);
#endif
if (cache_ptr->howto == NULL)
{
_bfd_error_handler
(_(""%B: illegal relocation type %d at address %#Lx""),
abfd, dst.r_type, dst.r_vaddr);
bfd_set_error (bfd_error_bad_value);
return FALSE;
}
}
asect->relocation = reloc_cache;
return TRUE;
}","static bfd_boolean
coff_slurp_reloc_table (bfd * VAR_0, sec_ptr VAR_1, asymbol ** VAR_2)
{
RELOC *VAR_3;
arelent *VAR_4;
arelent *VAR_5;
unsigned int VAR_6;
bfd_size_type VAR_7;
if (VAR_1->relocation)
return TRUE;
if (VAR_1->reloc_count == 0)
return TRUE;
if (VAR_1->flags & VAR_8)
return TRUE;
if (!coff_slurp_symbol_table (VAR_0))
return FALSE;
VAR_7 = (bfd_size_type) bfd_coff_relsz (VAR_0) * VAR_1->reloc_count;
VAR_3 = (RELOC *) buy_and_read (VAR_0, VAR_1->rel_filepos, VAR_7);
VAR_7 = (bfd_size_type) VAR_1->reloc_count * sizeof (arelent);
VAR_4 = (arelent *) bfd_alloc (VAR_0, VAR_7);
if (VAR_4 == NULL || VAR_3 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_6 < VAR_1->reloc_count; VAR_6++)
{
struct internal_reloc VAR_9;
struct external_reloc *VAR_10;
#ifndef VAR_11
asymbol *VAR_12;
#endif
VAR_5 = VAR_4 + VAR_6;
VAR_10 = VAR_3 + VAR_6;
VAR_9.r_offset = 0;
coff_swap_reloc_in (VAR_0, VAR_10, &VAR_9);
#ifdef VAR_11
VAR_11 (VAR_5, &VAR_9, VAR_2, VAR_0, VAR_1);
#else
VAR_5->address = VAR_9.r_vaddr;
if (VAR_9.r_symndx != -1)
{
if (VAR_9.r_symndx < 0 || VAR_9.r_symndx >= obj_conv_table_size (VAR_0))
{
_bfd_error_handler
(_(""%B: warning: illegal symbol index %ld in relocs""),
VAR_0, VAR_9.r_symndx);
VAR_5->sym_ptr_ptr = VAR_13->symbol_ptr_ptr;
VAR_12 = NULL;
}
else
{
VAR_5->sym_ptr_ptr = (VAR_2
+ obj_convert (VAR_0)[VAR_9.r_symndx]);
VAR_12 = *(VAR_5->sym_ptr_ptr);
}
}
else
{
VAR_5->sym_ptr_ptr = VAR_13->symbol_ptr_ptr;
VAR_12 = NULL;
}
CALC_ADDEND (VAR_0, VAR_12, VAR_9, VAR_5);
(void) VAR_12;
VAR_5->address -= VAR_1->vma;
RTYPE2HOWTO (VAR_5, &VAR_9);
#endif
if (VAR_5->howto == NULL)
{
_bfd_error_handler
(_(""%B: illegal relocation type %d at address %#Lx""),
VAR_0, VAR_9.r_type, VAR_9.r_vaddr);
bfd_set_error (VAR_14);
return FALSE;
}
}
VAR_1->relocation = VAR_4;
return TRUE;
}",binutils-gdb/4581a1c7d304ce14e714b27522ebf3d0188d6543/coffcode.h/vul/before/0.json,"static bfd_boolean
coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
{
  RELOC *native_relocs;
  arelent *reloc_cache;
  arelent *cache_ptr;
  unsigned int idx;
  bfd_size_type amt;

  if (asect->relocation)
    return TRUE;
  if (asect->reloc_count == 0)
    return TRUE;
  if (asect->flags & SEC_CONSTRUCTOR)
    return TRUE;
  if (!coff_slurp_symbol_table (abfd))
    return FALSE;

  amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
  native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
  amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
  reloc_cache = (arelent *) bfd_alloc (abfd, amt);

  if (reloc_cache == NULL || native_relocs == NULL)
    return FALSE;

  for (idx = 0; idx < asect->reloc_count; idx++)
    {
      struct internal_reloc dst;
      struct external_reloc *src;
#ifndef RELOC_PROCESSING
      asymbol *ptr;
#endif

      cache_ptr = reloc_cache + idx;
      src = native_relocs + idx;

      dst.r_offset = 0;
      coff_swap_reloc_in (abfd, src, &dst);

#ifdef RELOC_PROCESSING
      RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
#else
      cache_ptr->address = dst.r_vaddr;

      if (dst.r_symndx != -1 && symbols != NULL)
	{
	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
	    {
	      _bfd_error_handler
		/* xgettext:c-format */
		(_(""%B: warning: illegal symbol index %ld in relocs""),
		 abfd, dst.r_symndx);
	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	      ptr = NULL;
	    }
	  else
	    {
	      cache_ptr->sym_ptr_ptr = (symbols
					+ obj_convert (abfd)[dst.r_symndx]);
	      ptr = *(cache_ptr->sym_ptr_ptr);
	    }
	}
      else
	{
	  cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	  ptr = NULL;
	}

      /* The symbols definitions that we have read in have been
	 relocated as if their sections started at 0. But the offsets
	 refering to the symbols in the raw data have not been
	 modified, so we have to have a negative addend to compensate.

	 Note that symbols which used to be common must be left alone.  */

      /* Calculate any reloc addend by looking at the symbol.  */
      CALC_ADDEND (abfd, ptr, dst, cache_ptr);
      (void) ptr;

      cache_ptr->address -= asect->vma;
      /* !! cache_ptr->section = NULL;*/

      /* Fill in the cache_ptr->howto field from dst.r_type.  */
      RTYPE2HOWTO (cache_ptr, &dst);
#endif	/* RELOC_PROCESSING */

      if (cache_ptr->howto == NULL)
	{
	  _bfd_error_handler
	    /* xgettext:c-format */
	    (_(""%B: illegal relocation type %d at address %#Lx""),
	     abfd, dst.r_type, dst.r_vaddr);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  asect->relocation = reloc_cache;
  return TRUE;
}","static bfd_boolean
coff_slurp_reloc_table (bfd * VAR_0, sec_ptr VAR_1, asymbol ** VAR_2)
{
  RELOC *VAR_3;
  arelent *VAR_4;
  arelent *VAR_5;
  unsigned int VAR_6;
  bfd_size_type VAR_7;

  if (VAR_1->relocation)
    return TRUE;
  if (VAR_1->reloc_count == 0)
    return TRUE;
  if (VAR_1->flags & VAR_8)
    return TRUE;
  if (!coff_slurp_symbol_table (VAR_0))
    return FALSE;

  VAR_7 = (bfd_size_type) bfd_coff_relsz (VAR_0) * VAR_1->reloc_count;
  VAR_3 = (RELOC *) buy_and_read (VAR_0, VAR_1->rel_filepos, VAR_7);
  VAR_7 = (bfd_size_type) VAR_1->reloc_count * sizeof (arelent);
  VAR_4 = (arelent *) bfd_alloc (VAR_0, VAR_7);

  if (VAR_4 == NULL || VAR_3 == NULL)
    return FALSE;

  for (VAR_6 = 0; VAR_6 < VAR_1->reloc_count; VAR_6++)
    {
      struct internal_reloc VAR_9;
      struct external_reloc *VAR_10;
#ifndef VAR_11
      asymbol *VAR_12;
#endif

      VAR_5 = VAR_4 + VAR_6;
      VAR_10 = VAR_3 + VAR_6;

      VAR_9.r_offset = 0;
      coff_swap_reloc_in (VAR_0, VAR_10, &VAR_9);

#ifdef VAR_11
      VAR_11 (VAR_5, &VAR_9, VAR_2, VAR_0, VAR_1);
#else
      VAR_5->address = VAR_9.r_vaddr;

      if (VAR_9.r_symndx != -1 && VAR_2 != NULL)
	{
	  if (VAR_9.r_symndx < 0 || VAR_9.r_symndx >= obj_conv_table_size (VAR_0))
	    {
	      _bfd_error_handler
		/* COMMENT_0 */
		(_(""%B: warning: illegal symbol index %ld in relocs""),
		 VAR_0, VAR_9.r_symndx);
	      VAR_5->sym_ptr_ptr = VAR_13->symbol_ptr_ptr;
	      VAR_12 = NULL;
	    }
	  else
	    {
	      VAR_5->sym_ptr_ptr = (VAR_2
					+ obj_convert (VAR_0)[VAR_9.r_symndx]);
	      VAR_12 = *(VAR_5->sym_ptr_ptr);
	    }
	}
      else
	{
	  VAR_5->sym_ptr_ptr = VAR_13->symbol_ptr_ptr;
	  VAR_12 = NULL;
	}

      /* COMMENT_1 */
                                                              
                                                       
                                                               

                                                                   

      /* COMMENT_7 */
      CALC_ADDEND (VAR_0, VAR_12, VAR_9, VAR_5);
      (void) VAR_12;

      VAR_5->address -= VAR_1->vma;
      /* COMMENT_8 */

      /* COMMENT_9 */
      RTYPE2HOWTO (VAR_5, &VAR_9);
#endif	/* COMMENT_10 */

      if (VAR_5->howto == NULL)
	{
	  _bfd_error_handler
	    /* COMMENT_0 */
	    (_(""%B: illegal relocation type %d at address %#Lx""),
	     VAR_0, VAR_9.r_type, VAR_9.r_vaddr);
	  bfd_set_error (VAR_14);
	  return FALSE;
	}
    }

  VAR_1->relocation = VAR_4;
  return TRUE;
}",binutils-gdb/4581a1c7d304ce14e714b27522ebf3d0188d6543/coffcode.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,7 +43,7 @@
 #else
       cache_ptr->address = dst.r_vaddr;
 
-      if (dst.r_symndx != -1)
+      if (dst.r_symndx != -1 && symbols != NULL)
 	{
 	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
 	    {","{'deleted_lines': ['      if (dst.r_symndx != -1)'], 'added_lines': ['      if (dst.r_symndx != -1 && symbols != NULL)']}",True,"The coff_slurp_reloc_table function in coffcode.h in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29.1, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted COFF based file.",5.5,MEDIUM,1,valid,,5
CVE-2015-1208,['CWE-191'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,ffmpeg,"
mov: Fix negative size calculation in mov_read_default().

The previous code assumed if an atom was marked with a 64-bit
size extension, it actually had that data available. The new
code verfies there's enough data in the atom for this to be
done.

Failure to verify causes total_size > atom.size which will
result in negative size calculations later on.

Found-by: Paul Mehta <paul@paulmehta.com>
Signed-off-by: Dale Curtis <dalecurtis@chromium.org>
Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",3ebd76a9c57558e284e94da367dd23b435e6a6d0,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3ebd76a9c57558e284e94da367dd23b435e6a6d0,libavformat/mov.c,mov_read_default,"static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
int64_t total_size = 0;
MOVAtom a;
int i;
if (c->atom_depth > 10) {
av_log(c->fc, AV_LOG_ERROR, ""Atoms too deeply nested\n"");
return AVERROR_INVALIDDATA;
}
c->atom_depth ++;
if (atom.size < 0)
atom.size = INT64_MAX;
while (total_size + 8 <= atom.size && !avio_feof(pb)) {
int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;
a.size = atom.size;
a.type=0;
if (atom.size >= 8) {
a.size = avio_rb32(pb);
a.type = avio_rl32(pb);
if (a.type == MKTAG('f','r','e','e') &&
a.size >= 8 &&
c->moov_retry) {
uint8_t buf[8];
uint32_t *type = (uint32_t *)buf + 1;
avio_read(pb, buf, 8);
avio_seek(pb, -8, SEEK_CUR);
if (*type == MKTAG('m','v','h','d') ||
*type == MKTAG('c','m','o','v')) {
av_log(c->fc, AV_LOG_ERROR, ""Detected moov in a free atom.\n"");
a.type = MKTAG('m','o','o','v');
}
}
if (atom.type != MKTAG('r','o','o','t') &&
atom.type != MKTAG('m','o','o','v'))
{
if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))
{
av_log(c->fc, AV_LOG_ERROR, ""Broken file, trak/mdat not at top-level\n"");
avio_skip(pb, -8);
c->atom_depth --;
return 0;
}
}
total_size += 8;
if (a.size == 1) { 
a.size = avio_rb64(pb) - 8;
total_size += 8;
}
}
av_dlog(c->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""PRId64"" %""PRId64"" %""PRId64""\n"",
a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);
if (a.size == 0) {
a.size = atom.size - total_size + 8;
}
a.size -= 8;
if (a.size < 0)
break;
a.size = FFMIN(a.size, atom.size - total_size);
for (i = 0; mov_default_parse_table[i].type; i++)
if (mov_default_parse_table[i].type == a.type) {
parse = mov_default_parse_table[i].parse;
break;
}
if (!parse && (atom.type == MKTAG('u','d','t','a') ||
atom.type == MKTAG('i','l','s','t')))
parse = mov_read_udta_string;
if (!parse) { 
avio_skip(pb, a.size);
} else {
int64_t start_pos = avio_tell(pb);
int64_t left;
int err = parse(c, pb, a);
if (err < 0) {
c->atom_depth --;
return err;
}
if (c->found_moov && c->found_mdat &&
((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||
start_pos + a.size == avio_size(pb))) {
if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)
c->next_root_atom = start_pos + a.size;
c->atom_depth --;
return 0;
}
left = a.size - avio_tell(pb) + start_pos;
if (left > 0) 
avio_skip(pb, left);
else if (left < 0) {
av_log(c->fc, AV_LOG_WARNING,
""overread end of atom '%.4s' by %""PRId64"" bytes\n"",
(char*)&a.type, -left);
avio_seek(pb, left, SEEK_CUR);
}
}
total_size += a.size;
}
if (total_size < atom.size && atom.size < 0x7ffff)
avio_skip(pb, atom.size - total_size);
c->atom_depth --;
return 0;
}","static int mov_read_default(MOVContext *VAR_0, AVIOContext *VAR_1, MOVAtom VAR_2)
{
int64_t VAR_3 = 0;
MOVAtom VAR_4;
int VAR_5;
if (VAR_0->atom_depth > 10) {
av_log(VAR_0->fc, VAR_6, ""Atoms too deeply nested\n"");
return VAR_7;
}
VAR_0->atom_depth ++;
if (VAR_2.size < 0)
VAR_2.size = VAR_8;
while (VAR_3 + 8 <= VAR_2.size && !avio_feof(VAR_1)) {
int (*VAR_9)(MOVContext*, AVIOContext*, MOVAtom) = NULL;
VAR_4.size = VAR_2.size;
VAR_4.type=0;
if (VAR_2.size >= 8) {
VAR_4.size = avio_rb32(VAR_1);
VAR_4.type = avio_rl32(VAR_1);
if (VAR_4.type == MKTAG('f','r','e','e') &&
VAR_4.size >= 8 &&
VAR_0->moov_retry) {
uint8_t VAR_10[8];
uint32_t *VAR_11 = (uint32_t *)VAR_10 + 1;
avio_read(VAR_1, VAR_10, 8);
avio_seek(VAR_1, -8, VAR_12);
if (*VAR_11 == MKTAG('m','v','h','d') ||
*VAR_11 == MKTAG('c','m','o','v')) {
av_log(VAR_0->fc, VAR_6, ""Detected moov in a free atom.\n"");
VAR_4.type = MKTAG('m','o','o','v');
}
}
if (VAR_2.type != MKTAG('r','o','o','t') &&
VAR_2.type != MKTAG('m','o','o','v'))
{
if (VAR_4.type == MKTAG('t','r','a','k') || VAR_4.type == MKTAG('m','d','a','t'))
{
av_log(VAR_0->fc, VAR_6, ""Broken file, trak/mdat not at top-level\n"");
avio_skip(VAR_1, -8);
VAR_0->atom_depth --;
return 0;
}
}
VAR_3 += 8;
if (VAR_4.size == 1) { 
VAR_4.size = avio_rb64(VAR_1) - 8;
VAR_3 += 8;
}
}
av_dlog(VAR_0->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""VAR_13"" %""VAR_13"" %""VAR_13""\n"",
VAR_4.type, (char*)&VAR_4.type, (char*)&VAR_2.type, VAR_4.size, VAR_3, VAR_2.size);
if (VAR_4.size == 0) {
VAR_4.size = VAR_2.size - VAR_3 + 8;
}
VAR_4.size -= 8;
if (VAR_4.size < 0)
break;
VAR_4.size = FFMIN(VAR_4.size, VAR_2.size - VAR_3);
for (VAR_5 = 0; VAR_14[VAR_5].type; VAR_5++)
if (VAR_14[VAR_5].type == VAR_4.type) {
VAR_9 = VAR_14[VAR_5].parse;
break;
}
if (!VAR_9 && (VAR_2.type == MKTAG('u','d','t','a') ||
VAR_2.type == MKTAG('i','l','s','t')))
VAR_9 = VAR_15;
if (!VAR_9) { 
avio_skip(VAR_1, VAR_4.size);
} else {
int64_t VAR_16 = avio_tell(VAR_1);
int64_t VAR_17;
int VAR_18 = VAR_9(VAR_0, VAR_1, VAR_4);
if (VAR_18 < 0) {
VAR_0->atom_depth --;
return VAR_18;
}
if (VAR_0->found_moov && VAR_0->found_mdat &&
((!VAR_1->seekable || VAR_0->fc->flags & VAR_19) ||
VAR_16 + VAR_4.size == avio_size(VAR_1))) {
if (!VAR_1->seekable || VAR_0->fc->flags & VAR_19)
VAR_0->next_root_atom = VAR_16 + VAR_4.size;
VAR_0->atom_depth --;
return 0;
}
VAR_17 = VAR_4.size - avio_tell(VAR_1) + VAR_16;
if (VAR_17 > 0) 
avio_skip(VAR_1, VAR_17);
else if (VAR_17 < 0) {
av_log(VAR_0->fc, VAR_20,
""overread end of atom '%.4s' by %""VAR_13"" bytes\n"",
(char*)&VAR_4.type, -VAR_17);
avio_seek(VAR_1, VAR_17, VAR_12);
}
}
VAR_3 += VAR_4.size;
}
if (VAR_3 < VAR_2.size && VAR_2.size < 0x7ffff)
avio_skip(VAR_1, VAR_2.size - VAR_3);
VAR_0->atom_depth --;
return 0;
}",ffmpeg/3ebd76a9c57558e284e94da367dd23b435e6a6d0/mov.c/vul/before/0.json,"static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int64_t total_size = 0;
    MOVAtom a;
    int i;

    if (c->atom_depth > 10) {
        av_log(c->fc, AV_LOG_ERROR, ""Atoms too deeply nested\n"");
        return AVERROR_INVALIDDATA;
    }
    c->atom_depth ++;

    if (atom.size < 0)
        atom.size = INT64_MAX;
    while (total_size + 8 <= atom.size && !avio_feof(pb)) {
        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;
        a.size = atom.size;
        a.type=0;
        if (atom.size >= 8) {
            a.size = avio_rb32(pb);
            a.type = avio_rl32(pb);
            if (a.type == MKTAG('f','r','e','e') &&
                a.size >= 8 &&
                c->moov_retry) {
                uint8_t buf[8];
                uint32_t *type = (uint32_t *)buf + 1;
                avio_read(pb, buf, 8);
                avio_seek(pb, -8, SEEK_CUR);
                if (*type == MKTAG('m','v','h','d') ||
                    *type == MKTAG('c','m','o','v')) {
                    av_log(c->fc, AV_LOG_ERROR, ""Detected moov in a free atom.\n"");
                    a.type = MKTAG('m','o','o','v');
                }
            }
            if (atom.type != MKTAG('r','o','o','t') &&
                atom.type != MKTAG('m','o','o','v'))
            {
                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))
                {
                    av_log(c->fc, AV_LOG_ERROR, ""Broken file, trak/mdat not at top-level\n"");
                    avio_skip(pb, -8);
                    c->atom_depth --;
                    return 0;
                }
            }
            total_size += 8;
            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */
                a.size = avio_rb64(pb) - 8;
                total_size += 8;
            }
        }
        av_dlog(c->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""PRId64"" %""PRId64"" %""PRId64""\n"",
                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);
        if (a.size == 0) {
            a.size = atom.size - total_size + 8;
        }
        a.size -= 8;
        if (a.size < 0)
            break;
        a.size = FFMIN(a.size, atom.size - total_size);

        for (i = 0; mov_default_parse_table[i].type; i++)
            if (mov_default_parse_table[i].type == a.type) {
                parse = mov_default_parse_table[i].parse;
                break;
            }

        // container is user data
        if (!parse && (atom.type == MKTAG('u','d','t','a') ||
                       atom.type == MKTAG('i','l','s','t')))
            parse = mov_read_udta_string;

        if (!parse) { /* skip leaf atoms data */
            avio_skip(pb, a.size);
        } else {
            int64_t start_pos = avio_tell(pb);
            int64_t left;
            int err = parse(c, pb, a);
            if (err < 0) {
                c->atom_depth --;
                return err;
            }
            if (c->found_moov && c->found_mdat &&
                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||
                 start_pos + a.size == avio_size(pb))) {
                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)
                    c->next_root_atom = start_pos + a.size;
                c->atom_depth --;
                return 0;
            }
            left = a.size - avio_tell(pb) + start_pos;
            if (left > 0) /* skip garbage at atom end */
                avio_skip(pb, left);
            else if (left < 0) {
                av_log(c->fc, AV_LOG_WARNING,
                       ""overread end of atom '%.4s' by %""PRId64"" bytes\n"",
                       (char*)&a.type, -left);
                avio_seek(pb, left, SEEK_CUR);
            }
        }

        total_size += a.size;
    }

    if (total_size < atom.size && atom.size < 0x7ffff)
        avio_skip(pb, atom.size - total_size);

    c->atom_depth --;
    return 0;
}","static int mov_read_default(MOVContext *VAR_0, AVIOContext *VAR_1, MOVAtom VAR_2)
{
    int64_t VAR_3 = 0;
    MOVAtom VAR_4;
    int VAR_5;

    if (VAR_0->atom_depth > 10) {
        av_log(VAR_0->fc, VAR_6, ""Atoms too deeply nested\n"");
        return VAR_7;
    }
    VAR_0->atom_depth ++;

    if (VAR_2.size < 0)
        VAR_2.size = VAR_8;
    while (VAR_3 + 8 <= VAR_2.size && !avio_feof(VAR_1)) {
        int (*VAR_9)(MOVContext*, AVIOContext*, MOVAtom) = NULL;
        VAR_4.size = VAR_2.size;
        VAR_4.type=0;
        if (VAR_2.size >= 8) {
            VAR_4.size = avio_rb32(VAR_1);
            VAR_4.type = avio_rl32(VAR_1);
            if (VAR_4.type == MKTAG('f','r','e','e') &&
                VAR_4.size >= 8 &&
                VAR_0->moov_retry) {
                uint8_t VAR_10[8];
                uint32_t *VAR_11 = (uint32_t *)VAR_10 + 1;
                avio_read(VAR_1, VAR_10, 8);
                avio_seek(VAR_1, -8, VAR_12);
                if (*VAR_11 == MKTAG('m','v','h','d') ||
                    *VAR_11 == MKTAG('c','m','o','v')) {
                    av_log(VAR_0->fc, VAR_6, ""Detected moov in a free atom.\n"");
                    VAR_4.type = MKTAG('m','o','o','v');
                }
            }
            if (VAR_2.type != MKTAG('r','o','o','t') &&
                VAR_2.type != MKTAG('m','o','o','v'))
            {
                if (VAR_4.type == MKTAG('t','r','a','k') || VAR_4.type == MKTAG('m','d','a','t'))
                {
                    av_log(VAR_0->fc, VAR_6, ""Broken file, trak/mdat not at top-level\n"");
                    avio_skip(VAR_1, -8);
                    VAR_0->atom_depth --;
                    return 0;
                }
            }
            VAR_3 += 8;
            if (VAR_4.size == 1 && VAR_3 + 8 <= VAR_2.size) { /* COMMENT_0 */
                VAR_4.size = avio_rb64(VAR_1) - 8;
                VAR_3 += 8;
            }
        }
        av_dlog(VAR_0->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""VAR_13"" %""VAR_13"" %""VAR_13""\n"",
                VAR_4.type, (char*)&VAR_4.type, (char*)&VAR_2.type, VAR_4.size, VAR_3, VAR_2.size);
        if (VAR_4.size == 0) {
            VAR_4.size = VAR_2.size - VAR_3 + 8;
        }
        VAR_4.size -= 8;
        if (VAR_4.size < 0)
            break;
        VAR_4.size = FFMIN(VAR_4.size, VAR_2.size - VAR_3);

        for (VAR_5 = 0; VAR_14[VAR_5].type; VAR_5++)
            if (VAR_14[VAR_5].type == VAR_4.type) {
                VAR_9 = VAR_14[VAR_5].parse;
                break;
            }

        /* COMMENT_1 */
        if (!VAR_9 && (VAR_2.type == MKTAG('u','d','t','a') ||
                       VAR_2.type == MKTAG('i','l','s','t')))
            VAR_9 = VAR_15;

        if (!VAR_9) { /* COMMENT_2 */
            avio_skip(VAR_1, VAR_4.size);
        } else {
            int64_t VAR_16 = avio_tell(VAR_1);
            int64_t VAR_17;
            int VAR_18 = VAR_9(VAR_0, VAR_1, VAR_4);
            if (VAR_18 < 0) {
                VAR_0->atom_depth --;
                return VAR_18;
            }
            if (VAR_0->found_moov && VAR_0->found_mdat &&
                ((!VAR_1->seekable || VAR_0->fc->flags & VAR_19) ||
                 VAR_16 + VAR_4.size == avio_size(VAR_1))) {
                if (!VAR_1->seekable || VAR_0->fc->flags & VAR_19)
                    VAR_0->next_root_atom = VAR_16 + VAR_4.size;
                VAR_0->atom_depth --;
                return 0;
            }
            VAR_17 = VAR_4.size - avio_tell(VAR_1) + VAR_16;
            if (VAR_17 > 0) /* COMMENT_3 */
                avio_skip(VAR_1, VAR_17);
            else if (VAR_17 < 0) {
                av_log(VAR_0->fc, VAR_20,
                       ""overread end of atom '%.4s' by %""VAR_13"" bytes\n"",
                       (char*)&VAR_4.type, -VAR_17);
                avio_seek(VAR_1, VAR_17, VAR_12);
            }
        }

        VAR_3 += VAR_4.size;
    }

    if (VAR_3 < VAR_2.size && VAR_2.size < 0x7ffff)
        avio_skip(VAR_1, VAR_2.size - VAR_3);

    VAR_0->atom_depth --;
    return 0;
}",ffmpeg/3ebd76a9c57558e284e94da367dd23b435e6a6d0/mov.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -44,7 +44,7 @@
                 }
             }
             total_size += 8;
-            if (a.size == 1) { /* 64 bit extended size */
+            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */
                 a.size = avio_rb64(pb) - 8;
                 total_size += 8;
             }","{'deleted_lines': ['            if (a.size == 1) { /* 64 bit extended size */'], 'added_lines': ['            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */']}",True,Integer underflow in the mov_read_default function in libavformat/mov.c in FFmpeg before 2.4.6 allows remote attackers to obtain sensitive information from heap and/or stack memory via a crafted MP4 file.,5.5,MEDIUM,1,valid,,5
CVE-2015-1290,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chromium,"Version 4.4.63.16 (cherry-pick)

Merged 8c298c79c2eff50b1d3809a5f72ed7d3679c47a4

Move compatible receiver check from CompileHandler to UpdateCaches

BUG=chromium:505374
LOG=N
TBR=hablich@chromium.org

Review URL: https://codereview.chromium.org/1233453004 .

Cr-Commit-Position: refs/branch-heads/4.4@{#20}
Cr-Branched-From: 2e4c5505e85d94b520e853dda3f0cc3f2769e5f0-refs/heads/4.4.63@{#1}
Cr-Branched-From: 0208b8e3a1d7ce393308866386ac8d94f85faa05-refs/heads/master@{#28333}
",3bf7258ec1f9806f59465aa9e0bf5c8760e98063,https://chromium.googlesource.com/v8/v8/+/3bf7258ec1f9806f59465aa9e0bf5c8760e98063,src/ic/ic.cc,LoadIC::CompileHandler,"Handle<Code> LoadIC::CompileHandler(LookupIterator* lookup,
Handle<Object> unused,
CacheHolderFlag cache_holder) {
Handle<Object> receiver = lookup->GetReceiver();
if (receiver->IsString() &&
Name::Equals(isolate()->factory()->length_string(), lookup->name())) {
FieldIndex index = FieldIndex::ForInObjectOffset(String::kLengthOffset);
return SimpleFieldLoad(index);
}
if (receiver->IsStringWrapper() &&
Name::Equals(isolate()->factory()->length_string(), lookup->name())) {
StringLengthStub string_length_stub(isolate());
return string_length_stub.GetCode();
}
if (receiver->IsJSFunction() &&
Name::Equals(isolate()->factory()->prototype_string(), lookup->name()) &&
Handle<JSFunction>::cast(receiver)->should_have_prototype() &&
!Handle<JSFunction>::cast(receiver)
->map()
->has_non_instance_prototype()) {
Handle<Code> stub;
FunctionPrototypeStub function_prototype_stub(isolate());
return function_prototype_stub.GetCode();
}
Handle<Map> map = receiver_map();
Handle<JSObject> holder = lookup->GetHolder<JSObject>();
bool receiver_is_holder = receiver.is_identical_to(holder);
switch (lookup->state()) {
case LookupIterator::INTERCEPTOR: {
DCHECK(!holder->GetNamedInterceptor()->getter()->IsUndefined());
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
LookupIterator it = *lookup;
it.Next();
LookupForRead(&it);
return compiler.CompileLoadInterceptor(&it);
}
case LookupIterator::ACCESSOR: {
int object_offset;
if (Accessors::IsJSObjectFieldAccessor(map, lookup->name(),
&object_offset)) {
FieldIndex index = FieldIndex::ForInObjectOffset(object_offset, *map);
return SimpleFieldLoad(index);
}
if (Accessors::IsJSArrayBufferViewFieldAccessor(map, lookup->name(),
&object_offset)) {
FieldIndex index = FieldIndex::ForInObjectOffset(object_offset, *map);
ArrayBufferViewLoadFieldStub stub(isolate(), index);
return stub.GetCode();
}
Handle<Object> accessors = lookup->GetAccessors();
if (accessors->IsExecutableAccessorInfo()) {
Handle<ExecutableAccessorInfo> info =
Handle<ExecutableAccessorInfo>::cast(accessors);
if (v8::ToCData<Address>(info->getter()) == 0) break;
if (!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
map)) {
break;
}
if (!holder->HasFastProperties()) break;
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return compiler.CompileLoadCallback(lookup->name(), info);
}
if (accessors->IsAccessorPair()) {
Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
isolate());
if (!getter->IsJSFunction()) break;
if (!holder->HasFastProperties()) break;
Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
if (!receiver->IsJSObject() && !function->IsBuiltin() &&
is_sloppy(function->shared()->language_mode())) {
break;
}
CallOptimization call_optimization(function);
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
if (call_optimization.is_simple_api_call() &&
call_optimization.IsCompatibleReceiver(receiver, holder)) {
return compiler.CompileLoadCallback(lookup->name(), call_optimization,
lookup->GetAccessorIndex());
}
int expected_arguments =
function->shared()->internal_formal_parameter_count();
return compiler.CompileLoadViaGetter(
lookup->name(), lookup->GetAccessorIndex(), expected_arguments);
}
break;
}
case LookupIterator::DATA: {
if (lookup->is_dictionary_holder()) {
if (kind() != Code::LOAD_IC) break;
if (holder->IsGlobalObject()) {
NamedLoadHandlerCompiler compiler(isolate(), map, holder,
cache_holder);
Handle<PropertyCell> cell = lookup->GetPropertyCell();
Handle<Code> code = compiler.CompileLoadGlobal(
cell, lookup->name(), lookup->IsConfigurable());
CacheHolderFlag flag;
Handle<Map> stub_holder_map =
GetHandlerCacheHolder(map, receiver_is_holder, isolate(), &flag);
Map::UpdateCodeCache(stub_holder_map, lookup->name(), code);
return code;
}
if (!receiver_is_holder) break;
return isolate()->builtins()->LoadIC_Normal();
}
if (lookup->property_details().type() == DATA) {
FieldIndex field = lookup->GetFieldIndex();
if (receiver_is_holder) {
return SimpleFieldLoad(field);
}
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return compiler.CompileLoadField(lookup->name(), field);
}
DCHECK(lookup->property_details().type() == DATA_CONSTANT);
if (receiver_is_holder) {
LoadConstantStub stub(isolate(), lookup->GetConstantIndex());
return stub.GetCode();
}
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return compiler.CompileLoadConstant(lookup->name(),
lookup->GetConstantIndex());
}
case LookupIterator::INTEGER_INDEXED_EXOTIC:
return slow_stub();
case LookupIterator::ACCESS_CHECK:
case LookupIterator::JSPROXY:
case LookupIterator::NOT_FOUND:
case LookupIterator::TRANSITION:
UNREACHABLE();
}
return slow_stub();
}","Handle<Code> LoadIC::CompileHandler(LookupIterator* VAR_0,
Handle<Object> VAR_1,
CacheHolderFlag VAR_2) {
Handle<Object> VAR_3 = VAR_0->GetReceiver();
if (VAR_3->IsString() &&
Name::Equals(isolate()->factory()->length_string(), VAR_0->name())) {
FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(String::kLengthOffset);
return SimpleFieldLoad(VAR_4);
}
if (VAR_3->IsStringWrapper() &&
Name::Equals(isolate()->factory()->length_string(), VAR_0->name())) {
StringLengthStub string_length_stub(isolate());
return VAR_5.GetCode();
}
if (VAR_3->IsJSFunction() &&
Name::Equals(isolate()->factory()->prototype_string(), VAR_0->name()) &&
Handle<JSFunction>::cast(VAR_3)->should_have_prototype() &&
!Handle<JSFunction>::cast(VAR_3)
->map()
->has_non_instance_prototype()) {
Handle<Code> VAR_6;
FunctionPrototypeStub function_prototype_stub(isolate());
return VAR_7.GetCode();
}
Handle<Map> VAR_8 = receiver_map();
Handle<JSObject> VAR_9 = VAR_0->GetHolder<JSObject>();
bool VAR_10 = VAR_3.is_identical_to(VAR_9);
switch (VAR_0->state()) {
case LookupIterator::INTERCEPTOR: {
DCHECK(!VAR_9->GetNamedInterceptor()->getter()->IsUndefined());
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
LookupIterator VAR_11 = *VAR_0;
VAR_11.Next();
LookupForRead(&VAR_11);
return VAR_12.CompileLoadInterceptor(&VAR_11);
}
case LookupIterator::ACCESSOR: {
int VAR_13;
if (Accessors::IsJSObjectFieldAccessor(map, VAR_0->name(),
&VAR_13)) {
FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(VAR_13, *map);
return SimpleFieldLoad(VAR_4);
}
if (Accessors::IsJSArrayBufferViewFieldAccessor(map, VAR_0->name(),
&VAR_13)) {
FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(VAR_13, *map);
ArrayBufferViewLoadFieldStub stub(isolate(), index);
return VAR_6.GetCode();
}
Handle<Object> VAR_14 = VAR_0->GetAccessors();
if (VAR_14->IsExecutableAccessorInfo()) {
Handle<ExecutableAccessorInfo> VAR_15 =
Handle<ExecutableAccessorInfo>::cast(VAR_14);
if (v8::VAR_16<Address>(VAR_15->getter()) == 0) break;
if (!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), VAR_15,
map)) {
break;
}
if (!holder->HasFastProperties()) break;
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return VAR_12.CompileLoadCallback(VAR_0->name(), VAR_15);
}
if (VAR_14->IsAccessorPair()) {
Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
isolate());
if (!getter->IsJSFunction()) break;
if (!holder->HasFastProperties()) break;
Handle<JSFunction> VAR_17 = Handle<JSFunction>::cast(getter);
if (!VAR_3->IsJSObject() && !VAR_17->IsBuiltin() &&
is_sloppy(VAR_17->shared()->language_mode())) {
break;
}
CallOptimization call_optimization(function);
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
if (VAR_18.is_simple_api_call() &&
VAR_18.IsCompatibleReceiver(VAR_3, holder)) {
return VAR_12.CompileLoadCallback(VAR_0->name(), VAR_18,
VAR_0->GetAccessorIndex());
}
int VAR_19 =
function->shared()->internal_formal_parameter_count();
return VAR_12.CompileLoadViaGetter(
VAR_0->name(), VAR_0->GetAccessorIndex(), VAR_19);
}
break;
}
case LookupIterator::DATA: {
if (VAR_0->is_dictionary_holder()) {
if (kind() != Code::LOAD_IC) break;
if (holder->IsGlobalObject()) {
NamedLoadHandlerCompiler compiler(isolate(), map, holder,
cache_holder);
Handle<PropertyCell> VAR_20 = VAR_0->GetPropertyCell();
Handle<Code> VAR_21 = VAR_12.CompileLoadGlobal(
VAR_20, VAR_0->name(), VAR_0->IsConfigurable());
CacheHolderFlag VAR_22;
Handle<Map> VAR_23 =
GetHandlerCacheHolder(map, VAR_10, isolate(), &VAR_22);
Map::UpdateCodeCache(VAR_23, VAR_0->name(), VAR_21);
return VAR_21;
}
if (!VAR_10) break;
return isolate()->builtins()->LoadIC_Normal();
}
if (VAR_0->property_details().type() == VAR_24) {
FieldIndex VAR_25 = VAR_0->GetFieldIndex();
if (VAR_10) {
return SimpleFieldLoad(VAR_25);
}
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return VAR_12.CompileLoadField(VAR_0->name(), VAR_25);
}
DCHECK(VAR_0->property_details().type() == VAR_26);
if (VAR_10) {
LoadConstantStub VAR_6(isolate(), VAR_0->GetConstantIndex());
return VAR_6.GetCode();
}
NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
return VAR_12.CompileLoadConstant(VAR_0->name(),
VAR_0->GetConstantIndex());
}
case LookupIterator::INTEGER_INDEXED_EXOTIC:
return slow_stub();
case LookupIterator::ACCESS_CHECK:
case LookupIterator::JSPROXY:
case LookupIterator::NOT_FOUND:
case LookupIterator::TRANSITION:
UNREACHABLE();
}
return slow_stub();
}",chromium/3bf7258ec1f9806f59465aa9e0bf5c8760e98063/ic.cc/vul/before/0.json,"Handle<Code> LoadIC::CompileHandler(LookupIterator* lookup,
                                    Handle<Object> unused,
                                    CacheHolderFlag cache_holder) {
  Handle<Object> receiver = lookup->GetReceiver();
  if (receiver->IsString() &&
      Name::Equals(isolate()->factory()->length_string(), lookup->name())) {
    FieldIndex index = FieldIndex::ForInObjectOffset(String::kLengthOffset);
    return SimpleFieldLoad(index);
  }

  if (receiver->IsStringWrapper() &&
      Name::Equals(isolate()->factory()->length_string(), lookup->name())) {
    StringLengthStub string_length_stub(isolate());
    return string_length_stub.GetCode();
  }

  // Use specialized code for getting prototype of functions.
  if (receiver->IsJSFunction() &&
      Name::Equals(isolate()->factory()->prototype_string(), lookup->name()) &&
      Handle<JSFunction>::cast(receiver)->should_have_prototype() &&
      !Handle<JSFunction>::cast(receiver)
           ->map()
           ->has_non_instance_prototype()) {
    Handle<Code> stub;
    FunctionPrototypeStub function_prototype_stub(isolate());
    return function_prototype_stub.GetCode();
  }

  Handle<Map> map = receiver_map();
  Handle<JSObject> holder = lookup->GetHolder<JSObject>();
  bool receiver_is_holder = receiver.is_identical_to(holder);
  switch (lookup->state()) {
    case LookupIterator::INTERCEPTOR: {
      DCHECK(!holder->GetNamedInterceptor()->getter()->IsUndefined());
      NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
      // Perform a lookup behind the interceptor. Copy the LookupIterator since
      // the original iterator will be used to fetch the value.
      LookupIterator it = *lookup;
      it.Next();
      LookupForRead(&it);
      return compiler.CompileLoadInterceptor(&it);
    }

    case LookupIterator::ACCESSOR: {
      // Use simple field loads for some well-known callback properties.
      // The method will only return true for absolute truths based on the
      // receiver maps.
      int object_offset;
      if (Accessors::IsJSObjectFieldAccessor(map, lookup->name(),
                                             &object_offset)) {
        FieldIndex index = FieldIndex::ForInObjectOffset(object_offset, *map);
        return SimpleFieldLoad(index);
      }
      if (Accessors::IsJSArrayBufferViewFieldAccessor(map, lookup->name(),
                                                      &object_offset)) {
        FieldIndex index = FieldIndex::ForInObjectOffset(object_offset, *map);
        ArrayBufferViewLoadFieldStub stub(isolate(), index);
        return stub.GetCode();
      }

      Handle<Object> accessors = lookup->GetAccessors();
      if (accessors->IsExecutableAccessorInfo()) {
        Handle<ExecutableAccessorInfo> info =
            Handle<ExecutableAccessorInfo>::cast(accessors);
        if (v8::ToCData<Address>(info->getter()) == 0) break;
        if (!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
                                                             map)) {
          // This case should be already handled in LoadIC::UpdateCaches.
          UNREACHABLE();
          break;
        }
        if (!holder->HasFastProperties()) break;
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        return compiler.CompileLoadCallback(lookup->name(), info);
      }
      if (accessors->IsAccessorPair()) {
        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
                              isolate());
        if (!getter->IsJSFunction()) break;
        if (!holder->HasFastProperties()) break;
        Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
        if (!receiver->IsJSObject() && !function->IsBuiltin() &&
            is_sloppy(function->shared()->language_mode())) {
          // Calling sloppy non-builtins with a value as the receiver
          // requires boxing.
          break;
        }
        CallOptimization call_optimization(function);
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        if (call_optimization.is_simple_api_call()) {
          if (call_optimization.IsCompatibleReceiver(receiver, holder)) {
            return compiler.CompileLoadCallback(
                lookup->name(), call_optimization, lookup->GetAccessorIndex());
          } else {
            // This case should be already handled in LoadIC::UpdateCaches.
            UNREACHABLE();
          }
        }
        int expected_arguments =
            function->shared()->internal_formal_parameter_count();
        return compiler.CompileLoadViaGetter(
            lookup->name(), lookup->GetAccessorIndex(), expected_arguments);
      }
      break;
    }

    case LookupIterator::DATA: {
      if (lookup->is_dictionary_holder()) {
        if (kind() != Code::LOAD_IC) break;
        if (holder->IsGlobalObject()) {
          NamedLoadHandlerCompiler compiler(isolate(), map, holder,
                                            cache_holder);
          Handle<PropertyCell> cell = lookup->GetPropertyCell();
          Handle<Code> code = compiler.CompileLoadGlobal(
              cell, lookup->name(), lookup->IsConfigurable());
          // TODO(verwaest): Move caching of these NORMAL stubs outside as well.
          CacheHolderFlag flag;
          Handle<Map> stub_holder_map =
              GetHandlerCacheHolder(map, receiver_is_holder, isolate(), &flag);
          Map::UpdateCodeCache(stub_holder_map, lookup->name(), code);
          return code;
        }
        // There is only one shared stub for loading normalized
        // properties. It does not traverse the prototype chain, so the
        // property must be found in the object for the stub to be
        // applicable.
        if (!receiver_is_holder) break;
        return isolate()->builtins()->LoadIC_Normal();
      }

      // -------------- Fields --------------
      if (lookup->property_details().type() == DATA) {
        FieldIndex field = lookup->GetFieldIndex();
        if (receiver_is_holder) {
          return SimpleFieldLoad(field);
        }
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        return compiler.CompileLoadField(lookup->name(), field);
      }

      // -------------- Constant properties --------------
      DCHECK(lookup->property_details().type() == DATA_CONSTANT);
      if (receiver_is_holder) {
        LoadConstantStub stub(isolate(), lookup->GetConstantIndex());
        return stub.GetCode();
      }
      NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
      return compiler.CompileLoadConstant(lookup->name(),
                                          lookup->GetConstantIndex());
    }

    case LookupIterator::INTEGER_INDEXED_EXOTIC:
      return slow_stub();
    case LookupIterator::ACCESS_CHECK:
    case LookupIterator::JSPROXY:
    case LookupIterator::NOT_FOUND:
    case LookupIterator::TRANSITION:
      UNREACHABLE();
  }

  return slow_stub();
}","Handle<Code> LoadIC::CompileHandler(LookupIterator* VAR_0,
                                    Handle<Object> VAR_1,
                                    CacheHolderFlag VAR_2) {
  Handle<Object> VAR_3 = VAR_0->GetReceiver();
  if (VAR_3->IsString() &&
      Name::Equals(isolate()->factory()->length_string(), VAR_0->name())) {
    FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(String::kLengthOffset);
    return SimpleFieldLoad(VAR_4);
  }

  if (VAR_3->IsStringWrapper() &&
      Name::Equals(isolate()->factory()->length_string(), VAR_0->name())) {
    StringLengthStub string_length_stub(isolate());
    return VAR_5.GetCode();
  }

  /* COMMENT_0 */
  if (VAR_3->IsJSFunction() &&
      Name::Equals(isolate()->factory()->prototype_string(), VAR_0->name()) &&
      Handle<JSFunction>::cast(VAR_3)->should_have_prototype() &&
      !Handle<JSFunction>::cast(VAR_3)
           ->map()
           ->has_non_instance_prototype()) {
    Handle<Code> VAR_6;
    FunctionPrototypeStub function_prototype_stub(isolate());
    return VAR_7.GetCode();
  }

  Handle<Map> VAR_8 = receiver_map();
  Handle<JSObject> VAR_9 = VAR_0->GetHolder<JSObject>();
  bool VAR_10 = VAR_3.is_identical_to(VAR_9);
  switch (VAR_0->state()) {
    case LookupIterator::INTERCEPTOR: {
      DCHECK(!VAR_9->GetNamedInterceptor()->getter()->IsUndefined());
      NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
      /* COMMENT_1 */
      /* COMMENT_2 */
      LookupIterator VAR_11 = *VAR_0;
      VAR_11.Next();
      LookupForRead(&VAR_11);
      return VAR_12.CompileLoadInterceptor(&VAR_11);
    }

    case LookupIterator::ACCESSOR: {
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      int VAR_13;
      if (Accessors::IsJSObjectFieldAccessor(map, VAR_0->name(),
                                             &VAR_13)) {
        FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(VAR_13, *map);
        return SimpleFieldLoad(VAR_4);
      }
      if (Accessors::IsJSArrayBufferViewFieldAccessor(map, VAR_0->name(),
                                                      &VAR_13)) {
        FieldIndex VAR_4 = FieldIndex::ForInObjectOffset(VAR_13, *map);
        ArrayBufferViewLoadFieldStub stub(isolate(), index);
        return VAR_6.GetCode();
      }

      Handle<Object> VAR_14 = VAR_0->GetAccessors();
      if (VAR_14->IsExecutableAccessorInfo()) {
        Handle<ExecutableAccessorInfo> VAR_15 =
            Handle<ExecutableAccessorInfo>::cast(VAR_14);
        if (v8::VAR_16<Address>(VAR_15->getter()) == 0) break;
        if (!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), VAR_15,
                                                             map)) {
          /* COMMENT_6 */
          UNREACHABLE();
          break;
        }
        if (!holder->HasFastProperties()) break;
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        return VAR_12.CompileLoadCallback(VAR_0->name(), VAR_15);
      }
      if (VAR_14->IsAccessorPair()) {
        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
                              isolate());
        if (!getter->IsJSFunction()) break;
        if (!holder->HasFastProperties()) break;
        Handle<JSFunction> VAR_17 = Handle<JSFunction>::cast(getter);
        if (!VAR_3->IsJSObject() && !VAR_17->IsBuiltin() &&
            is_sloppy(VAR_17->shared()->language_mode())) {
          /* COMMENT_7 */
          /* COMMENT_8 */
          break;
        }
        CallOptimization call_optimization(function);
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        if (VAR_18.is_simple_api_call()) {
          if (VAR_18.IsCompatibleReceiver(VAR_3, holder)) {
            return VAR_12.CompileLoadCallback(
                VAR_0->name(), VAR_18, VAR_0->GetAccessorIndex());
          } else {
            /* COMMENT_6 */
            UNREACHABLE();
          }
        }
        int VAR_19 =
            function->shared()->internal_formal_parameter_count();
        return VAR_12.CompileLoadViaGetter(
            VAR_0->name(), VAR_0->GetAccessorIndex(), VAR_19);
      }
      break;
    }

    case LookupIterator::DATA: {
      if (VAR_0->is_dictionary_holder()) {
        if (kind() != Code::LOAD_IC) break;
        if (holder->IsGlobalObject()) {
          NamedLoadHandlerCompiler compiler(isolate(), map, holder,
                                            cache_holder);
          Handle<PropertyCell> VAR_20 = VAR_0->GetPropertyCell();
          Handle<Code> VAR_21 = VAR_12.CompileLoadGlobal(
              VAR_20, VAR_0->name(), VAR_0->IsConfigurable());
          /* COMMENT_9 */
          CacheHolderFlag VAR_22;
          Handle<Map> VAR_23 =
              GetHandlerCacheHolder(map, VAR_10, isolate(), &VAR_22);
          Map::UpdateCodeCache(VAR_23, VAR_0->name(), VAR_21);
          return VAR_21;
        }
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        if (!VAR_10) break;
        return isolate()->builtins()->LoadIC_Normal();
      }

      /* COMMENT_14 */
      if (VAR_0->property_details().type() == VAR_24) {
        FieldIndex VAR_25 = VAR_0->GetFieldIndex();
        if (VAR_10) {
          return SimpleFieldLoad(VAR_25);
        }
        NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
        return VAR_12.CompileLoadField(VAR_0->name(), VAR_25);
      }

      /* COMMENT_15 */
      DCHECK(VAR_0->property_details().type() == VAR_26);
      if (VAR_10) {
        LoadConstantStub VAR_6(isolate(), VAR_0->GetConstantIndex());
        return VAR_6.GetCode();
      }
      NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
      return VAR_12.CompileLoadConstant(VAR_0->name(),
                                          VAR_0->GetConstantIndex());
    }

    case LookupIterator::INTEGER_INDEXED_EXOTIC:
      return slow_stub();
    case LookupIterator::ACCESS_CHECK:
    case LookupIterator::JSPROXY:
    case LookupIterator::NOT_FOUND:
    case LookupIterator::TRANSITION:
      UNREACHABLE();
  }

  return slow_stub();
}",chromium/3bf7258ec1f9806f59465aa9e0bf5c8760e98063/ic.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -65,6 +65,8 @@
         if (v8::ToCData<Address>(info->getter()) == 0) break;
         if (!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
                                                              map)) {
+          // This case should be already handled in LoadIC::UpdateCaches.
+          UNREACHABLE();
           break;
         }
         if (!holder->HasFastProperties()) break;
@@ -85,10 +87,14 @@
         }
         CallOptimization call_optimization(function);
         NamedLoadHandlerCompiler compiler(isolate(), map, holder, cache_holder);
-        if (call_optimization.is_simple_api_call() &&
-            call_optimization.IsCompatibleReceiver(receiver, holder)) {
-          return compiler.CompileLoadCallback(lookup->name(), call_optimization,
-                                              lookup->GetAccessorIndex());
+        if (call_optimization.is_simple_api_call()) {
+          if (call_optimization.IsCompatibleReceiver(receiver, holder)) {
+            return compiler.CompileLoadCallback(
+                lookup->name(), call_optimization, lookup->GetAccessorIndex());
+          } else {
+            // This case should be already handled in LoadIC::UpdateCaches.
+            UNREACHABLE();
+          }
         }
         int expected_arguments =
             function->shared()->internal_formal_parameter_count();","{'deleted_lines': ['        if (call_optimization.is_simple_api_call() &&', '            call_optimization.IsCompatibleReceiver(receiver, holder)) {', '          return compiler.CompileLoadCallback(lookup->name(), call_optimization,', '                                              lookup->GetAccessorIndex());'], 'added_lines': ['          // This case should be already handled in LoadIC::UpdateCaches.', '          UNREACHABLE();', '        if (call_optimization.is_simple_api_call()) {', '          if (call_optimization.IsCompatibleReceiver(receiver, holder)) {', '            return compiler.CompileLoadCallback(', '                lookup->name(), call_optimization, lookup->GetAccessorIndex());', '          } else {', '            // This case should be already handled in LoadIC::UpdateCaches.', '            UNREACHABLE();', '          }']}",True,"The Google V8 engine, as used in Google Chrome before 44.0.2403.89 and QtWebEngineCore in Qt before 5.5.1, allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via a crafted web site.",8.8,HIGH,2,valid,,5
CVE-2015-1290,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chromium,"Version 4.4.63.16 (cherry-pick)

Merged 8c298c79c2eff50b1d3809a5f72ed7d3679c47a4

Move compatible receiver check from CompileHandler to UpdateCaches

BUG=chromium:505374
LOG=N
TBR=hablich@chromium.org

Review URL: https://codereview.chromium.org/1233453004 .

Cr-Commit-Position: refs/branch-heads/4.4@{#20}
Cr-Branched-From: 2e4c5505e85d94b520e853dda3f0cc3f2769e5f0-refs/heads/4.4.63@{#1}
Cr-Branched-From: 0208b8e3a1d7ce393308866386ac8d94f85faa05-refs/heads/master@{#28333}
",3bf7258ec1f9806f59465aa9e0bf5c8760e98063,https://chromium.googlesource.com/v8/v8/+/3bf7258ec1f9806f59465aa9e0bf5c8760e98063,src/ic/ic.cc,LoadIC::UpdateCaches,"void LoadIC::UpdateCaches(LookupIterator* lookup) {
if (state() == UNINITIALIZED) {
if (UseVector()) {
ConfigureVectorState(PREMONOMORPHIC);
} else {
set_target(*pre_monomorphic_stub());
}
TRACE_IC(""LoadIC"", lookup->name());
return;
}
Handle<Code> code;
if (lookup->state() == LookupIterator::JSPROXY ||
lookup->state() == LookupIterator::ACCESS_CHECK) {
code = slow_stub();
} else if (!lookup->IsFound()) {
if (kind() == Code::LOAD_IC) {
code = NamedLoadHandlerCompiler::ComputeLoadNonexistent(lookup->name(),
receiver_map());
if (code.is_null()) code = slow_stub();
} else {
code = slow_stub();
}
} else {
code = ComputeHandler(lookup);
}
PatchCache(lookup->name(), code);
TRACE_IC(""LoadIC"", lookup->name());
}","void LoadIC::UpdateCaches(LookupIterator* VAR_0) {
if (state() == VAR_1) {
if (UseVector()) {
ConfigureVectorState(VAR_2);
} else {
set_target(*pre_monomorphic_stub());
}
TRACE_IC(""LoadIC"", VAR_0->name());
return;
}
Handle<Code> VAR_3;
if (VAR_0->state() == LookupIterator::JSPROXY ||
VAR_0->state() == LookupIterator::ACCESS_CHECK) {
VAR_3 = slow_stub();
} else if (!VAR_0->IsFound()) {
if (kind() == Code::LOAD_IC) {
VAR_3 = NamedLoadHandlerCompiler::ComputeLoadNonexistent(VAR_0->name(),
receiver_map());
if (VAR_3.is_null()) VAR_3 = slow_stub();
} else {
VAR_3 = slow_stub();
}
} else {
VAR_3 = ComputeHandler(VAR_0);
}
PatchCache(VAR_0->name(), VAR_3);
TRACE_IC(""LoadIC"", VAR_0->name());
}",chromium/3bf7258ec1f9806f59465aa9e0bf5c8760e98063/ic.cc/vul/before/1.json,"void LoadIC::UpdateCaches(LookupIterator* lookup) {
  if (state() == UNINITIALIZED) {
    // This is the first time we execute this inline cache. Set the target to
    // the pre monomorphic stub to delay setting the monomorphic state.
    if (UseVector()) {
      ConfigureVectorState(PREMONOMORPHIC);
    } else {
      set_target(*pre_monomorphic_stub());
    }
    TRACE_IC(""LoadIC"", lookup->name());
    return;
  }

  Handle<Code> code;
  if (lookup->state() == LookupIterator::JSPROXY ||
      lookup->state() == LookupIterator::ACCESS_CHECK) {
    code = slow_stub();
  } else if (!lookup->IsFound()) {
    if (kind() == Code::LOAD_IC) {
      code = NamedLoadHandlerCompiler::ComputeLoadNonexistent(lookup->name(),
                                                              receiver_map());
      // TODO(jkummerow/verwaest): Introduce a builtin that handles this case.
      if (code.is_null()) code = slow_stub();
    } else {
      code = slow_stub();
    }
  } else {
    if (lookup->state() == LookupIterator::ACCESSOR) {
      Handle<Object> accessors = lookup->GetAccessors();
      Handle<Map> map = receiver_map();
      if (accessors->IsExecutableAccessorInfo()) {
        Handle<ExecutableAccessorInfo> info =
            Handle<ExecutableAccessorInfo>::cast(accessors);
        if ((v8::ToCData<Address>(info->getter()) != 0) &&
            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
                                                             map)) {
          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
          code = slow_stub();
        }
      } else if (accessors->IsAccessorPair()) {
        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
                              isolate());
        Handle<JSObject> holder = lookup->GetHolder<JSObject>();
        Handle<Object> receiver = lookup->GetReceiver();
        if (getter->IsJSFunction() && holder->HasFastProperties()) {
          Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
          if (receiver->IsJSObject() || function->IsBuiltin() ||
              !is_sloppy(function->shared()->language_mode())) {
            CallOptimization call_optimization(function);
            if (call_optimization.is_simple_api_call() &&
                !call_optimization.IsCompatibleReceiver(receiver, holder)) {
              TRACE_GENERIC_IC(isolate(), ""LoadIC"",
                               ""incompatible receiver type"");
              code = slow_stub();
            }
          }
        }
      }
    }
    if (code.is_null()) code = ComputeHandler(lookup);
  }

  PatchCache(lookup->name(), code);
  TRACE_IC(""LoadIC"", lookup->name());
}","void LoadIC::UpdateCaches(LookupIterator* VAR_0) {
  if (state() == VAR_1) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    if (UseVector()) {
      ConfigureVectorState(VAR_2);
    } else {
      set_target(*pre_monomorphic_stub());
    }
    TRACE_IC(""LoadIC"", VAR_0->name());
    return;
  }

  Handle<Code> VAR_3;
  if (VAR_0->state() == LookupIterator::JSPROXY ||
      VAR_0->state() == LookupIterator::ACCESS_CHECK) {
    VAR_3 = slow_stub();
  } else if (!VAR_0->IsFound()) {
    if (kind() == Code::LOAD_IC) {
      VAR_3 = NamedLoadHandlerCompiler::ComputeLoadNonexistent(VAR_0->name(),
                                                              receiver_map());
      /* COMMENT_2 */
      if (VAR_3.is_null()) VAR_3 = slow_stub();
    } else {
      VAR_3 = slow_stub();
    }
  } else {
    if (VAR_0->state() == LookupIterator::ACCESSOR) {
      Handle<Object> VAR_4 = VAR_0->GetAccessors();
      Handle<Map> VAR_5 = receiver_map();
      if (VAR_4->IsExecutableAccessorInfo()) {
        Handle<ExecutableAccessorInfo> VAR_6 =
            Handle<ExecutableAccessorInfo>::cast(VAR_4);
        if ((v8::VAR_7<Address>(VAR_6->getter()) != 0) &&
            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), VAR_6,
                                                             VAR_5)) {
          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
          VAR_3 = slow_stub();
        }
      } else if (VAR_4->IsAccessorPair()) {
        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
                              isolate());
        Handle<JSObject> VAR_8 = VAR_0->GetHolder<JSObject>();
        Handle<Object> VAR_9 = VAR_0->GetReceiver();
        if (getter->IsJSFunction() && VAR_8->HasFastProperties()) {
          Handle<JSFunction> VAR_10 = Handle<JSFunction>::cast(getter);
          if (VAR_9->IsJSObject() || VAR_10->IsBuiltin() ||
              !is_sloppy(VAR_10->shared()->language_mode())) {
            CallOptimization call_optimization(function);
            if (VAR_11.is_simple_api_call() &&
                !VAR_11.IsCompatibleReceiver(VAR_9, VAR_8)) {
              TRACE_GENERIC_IC(isolate(), ""LoadIC"",
                               ""incompatible receiver type"");
              VAR_3 = slow_stub();
            }
          }
        }
      }
    }
    if (VAR_3.is_null()) VAR_3 = ComputeHandler(VAR_0);
  }

  PatchCache(VAR_0->name(), VAR_3);
  TRACE_IC(""LoadIC"", VAR_0->name());
}",chromium/3bf7258ec1f9806f59465aa9e0bf5c8760e98063/ic.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -25,7 +25,39 @@
       code = slow_stub();
     }
   } else {
-    code = ComputeHandler(lookup);
+    if (lookup->state() == LookupIterator::ACCESSOR) {
+      Handle<Object> accessors = lookup->GetAccessors();
+      Handle<Map> map = receiver_map();
+      if (accessors->IsExecutableAccessorInfo()) {
+        Handle<ExecutableAccessorInfo> info =
+            Handle<ExecutableAccessorInfo>::cast(accessors);
+        if ((v8::ToCData<Address>(info->getter()) != 0) &&
+            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
+                                                             map)) {
+          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
+          code = slow_stub();
+        }
+      } else if (accessors->IsAccessorPair()) {
+        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
+                              isolate());
+        Handle<JSObject> holder = lookup->GetHolder<JSObject>();
+        Handle<Object> receiver = lookup->GetReceiver();
+        if (getter->IsJSFunction() && holder->HasFastProperties()) {
+          Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
+          if (receiver->IsJSObject() || function->IsBuiltin() ||
+              !is_sloppy(function->shared()->language_mode())) {
+            CallOptimization call_optimization(function);
+            if (call_optimization.is_simple_api_call() &&
+                !call_optimization.IsCompatibleReceiver(receiver, holder)) {
+              TRACE_GENERIC_IC(isolate(), ""LoadIC"",
+                               ""incompatible receiver type"");
+              code = slow_stub();
+            }
+          }
+        }
+      }
+    }
+    if (code.is_null()) code = ComputeHandler(lookup);
   }
 
   PatchCache(lookup->name(), code);","{'deleted_lines': ['    code = ComputeHandler(lookup);'], 'added_lines': ['    if (lookup->state() == LookupIterator::ACCESSOR) {', '      Handle<Object> accessors = lookup->GetAccessors();', '      Handle<Map> map = receiver_map();', '      if (accessors->IsExecutableAccessorInfo()) {', '        Handle<ExecutableAccessorInfo> info =', '            Handle<ExecutableAccessorInfo>::cast(accessors);', '        if ((v8::ToCData<Address>(info->getter()) != 0) &&', '            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,', '                                                             map)) {', '          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");', '          code = slow_stub();', '        }', '      } else if (accessors->IsAccessorPair()) {', '        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),', '                              isolate());', '        Handle<JSObject> holder = lookup->GetHolder<JSObject>();', '        Handle<Object> receiver = lookup->GetReceiver();', '        if (getter->IsJSFunction() && holder->HasFastProperties()) {', '          Handle<JSFunction> function = Handle<JSFunction>::cast(getter);', '          if (receiver->IsJSObject() || function->IsBuiltin() ||', '              !is_sloppy(function->shared()->language_mode())) {', '            CallOptimization call_optimization(function);', '            if (call_optimization.is_simple_api_call() &&', '                !call_optimization.IsCompatibleReceiver(receiver, holder)) {', '              TRACE_GENERIC_IC(isolate(), ""LoadIC"",', '                               ""incompatible receiver type"");', '              code = slow_stub();', '            }', '          }', '        }', '      }', '    }', '    if (code.is_null()) code = ComputeHandler(lookup);']}",True,"The Google V8 engine, as used in Google Chrome before 44.0.2403.89 and QtWebEngineCore in Qt before 5.5.1, allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via a crafted web site.",8.8,HIGH,2,valid,,5
CVE-2017-13200,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,android,"Fix edge case when applying id3 unsynchronization

Bug: 63100526
Test: opened poc, other files
Change-Id: I0a51a2a11d0ea84ede0c075de650a7118f0e00c5
(cherry picked from commit 3e70296461c5f260988ab21854a6f43fdafea764)
",dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5,https://android.googlesource.com/platform/frameworks/av/+/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5,media/libstagefright/id3/ID3.cpp,ID3::removeUnsynchronizationV2_4,"bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
size_t oldSize = mSize;
size_t offset = 0;
while (mSize >= 10 && offset <= mSize - 10) {
if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
break;
}
size_t dataSize;
if (iTunesHack) {
dataSize = U32_AT(&mData[offset + 4]);
} else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
return false;
}
if (dataSize > mSize - 10 - offset) {
return false;
}
uint16_t flags = U16_AT(&mData[offset + 8]);
uint16_t prevFlags = flags;
if (flags & 1) {
if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
return false;
}
memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
mSize -= 4;
dataSize -= 4;
flags &= ~1;
}
if ((flags & 2) && (dataSize >= 2)) {
size_t readOffset = offset + 11;
size_t writeOffset = offset + 11;
for (size_t i = 0; i + 1 < dataSize; ++i) {
if (mData[readOffset - 1] == 0xff
&& mData[readOffset] == 0x00) {
++readOffset;
--mSize;
--dataSize;
}
mData[writeOffset++] = mData[readOffset++];
}
if (readOffset <= oldSize) {
memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
} else {
ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
android_errorWriteLog(0x534e4554, ""34618607"");
}
}
flags &= ~2;
if (flags != prevFlags || iTunesHack) {
WriteSyncsafeInteger(&mData[offset + 4], dataSize);
mData[offset + 8] = flags >> 8;
mData[offset + 9] = flags & 0xff;
}
offset += 10 + dataSize;
}
memset(&mData[mSize], 0, oldSize - mSize);
return true;
}","bool ID3::removeUnsynchronizationV2_4(bool VAR_0) {
size_t VAR_1 = VAR_2;
size_t VAR_3 = 0;
while (VAR_2 >= 10 && VAR_3 <= VAR_2 - 10) {
if (!memcmp(&VAR_4[VAR_3], ""\0\0\0\0"", 4)) {
break;
}
size_t VAR_5;
if (VAR_0) {
VAR_5 = U32_AT(&VAR_4[VAR_3 + 4]);
} else if (!ParseSyncsafeInteger(&VAR_4[VAR_3 + 4], &VAR_5)) {
return false;
}
if (VAR_5 > VAR_2 - 10 - VAR_3) {
return false;
}
uint16_t VAR_6 = U16_AT(&VAR_4[VAR_3 + 8]);
uint16_t VAR_7 = VAR_6;
if (VAR_6 & 1) {
if (VAR_2 < 14 || VAR_2 - 14 < VAR_3 || VAR_5 < 4) {
return false;
}
memmove(&VAR_4[VAR_3 + 10], &VAR_4[VAR_3 + 14], VAR_2 - VAR_3 - 14);
VAR_2 -= 4;
VAR_5 -= 4;
VAR_6 &= ~1;
}
if ((VAR_6 & 2) && (VAR_5 >= 2)) {
size_t VAR_8 = VAR_3 + 11;
size_t VAR_9 = VAR_3 + 11;
for (size_t VAR_10 = 0; VAR_10 + 1 < VAR_5; ++VAR_10) {
if (VAR_4[VAR_8 - 1] == 0xff
&& VAR_4[VAR_8] == 0x00) {
++VAR_8;
--VAR_2;
--VAR_5;
}
VAR_4[VAR_9++] = VAR_4[VAR_8++];
}
if (VAR_8 <= VAR_1) {
memmove(&VAR_4[VAR_9], &VAR_4[VAR_8], VAR_1 - VAR_8);
} else {
ALOGE(""b/34618607 (%zu %zu %zu %zu)"", VAR_8, VAR_9, VAR_1, VAR_2);
android_errorWriteLog(0x534e4554, ""34618607"");
}
}
VAR_6 &= ~2;
if (VAR_6 != VAR_7 || VAR_0) {
WriteSyncsafeInteger(&VAR_4[VAR_3 + 4], VAR_5);
VAR_4[VAR_3 + 8] = VAR_6 >> 8;
VAR_4[VAR_3 + 9] = VAR_6 & 0xff;
}
VAR_3 += 10 + VAR_5;
}
memset(&VAR_4[VAR_2], 0, VAR_1 - VAR_2);
return true;
}",android/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5/ID3.cpp/vul/before/0.json,"bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
    size_t oldSize = mSize;

    size_t offset = 0;
    while (mSize >= 10 && offset <= mSize - 10) {
        if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
            break;
        }

        size_t dataSize;
        if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
        } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
            return false;
        }

        if (dataSize > mSize - 10 - offset) {
            return false;
        }

        uint16_t flags = U16_AT(&mData[offset + 8]);
        uint16_t prevFlags = flags;

        if (flags & 1) {
            // Strip data length indicator

            if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
                return false;
            }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
        }

        if ((flags & 2) && (dataSize >= 2)) {
            // This file has ""unsynchronization"", so we have to replace occurrences
            // of 0xff 0x00 with just 0xff in order to get the real data.

            size_t readOffset = offset + 11;
            size_t writeOffset = offset + 11;
            for (size_t i = 0; i + 1 < dataSize; ++i) {
                if (mData[readOffset - 1] == 0xff
                        && mData[readOffset] == 0x00) {
                    ++readOffset;
                    --mSize;
                    --dataSize;
                }
                if (i + 1 < dataSize) {
                    // Only move data if there's actually something to move.
                    // This handles the special case of the data being only [0xff, 0x00]
                    // which should be converted to just 0xff if unsynchronization is on.
                    mData[writeOffset++] = mData[readOffset++];
                }
            }
            // move the remaining data following this frame
            if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
            } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
            }

        }
        flags &= ~2;
        if (flags != prevFlags || iTunesHack) {
            WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
        }

        offset += 10 + dataSize;
    }

    memset(&mData[mSize], 0, oldSize - mSize);

    return true;
}","bool ID3::removeUnsynchronizationV2_4(bool VAR_0) {
    size_t VAR_1 = VAR_2;

    size_t VAR_3 = 0;
    while (VAR_2 >= 10 && VAR_3 <= VAR_2 - 10) {
        if (!memcmp(&VAR_4[VAR_3], ""\0\0\0\0"", 4)) {
            break;
        }

        size_t VAR_5;
        if (VAR_0) {
            VAR_5 = U32_AT(&VAR_4[VAR_3 + 4]);
        } else if (!ParseSyncsafeInteger(&VAR_4[VAR_3 + 4], &VAR_5)) {
            return false;
        }

        if (VAR_5 > VAR_2 - 10 - VAR_3) {
            return false;
        }

        uint16_t VAR_6 = U16_AT(&VAR_4[VAR_3 + 8]);
        uint16_t VAR_7 = VAR_6;

        if (VAR_6 & 1) {
            /* COMMENT_0 */

            if (VAR_2 < 14 || VAR_2 - 14 < VAR_3 || VAR_5 < 4) {
                return false;
            }
            memmove(&VAR_4[VAR_3 + 10], &VAR_4[VAR_3 + 14], VAR_2 - VAR_3 - 14);
            VAR_2 -= 4;
            VAR_5 -= 4;

            VAR_6 &= ~1;
        }

        if ((VAR_6 & 2) && (VAR_5 >= 2)) {
            /* COMMENT_1 */
            /* COMMENT_2 */

            size_t VAR_8 = VAR_3 + 11;
            size_t VAR_9 = VAR_3 + 11;
            for (size_t VAR_10 = 0; VAR_10 + 1 < VAR_5; ++VAR_10) {
                if (VAR_4[VAR_8 - 1] == 0xff
                        && VAR_4[VAR_8] == 0x00) {
                    ++VAR_8;
                    --VAR_2;
                    --VAR_5;
                }
                if (VAR_10 + 1 < VAR_5) {
                    /* COMMENT_3 */
                    /* COMMENT_4 */
                    /* COMMENT_5 */
                    VAR_4[VAR_9++] = VAR_4[VAR_8++];
                }
            }
            /* COMMENT_6 */
            if (VAR_8 <= VAR_1) {
                memmove(&VAR_4[VAR_9], &VAR_4[VAR_8], VAR_1 - VAR_8);
            } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", VAR_8, VAR_9, VAR_1, VAR_2);
                android_errorWriteLog(0x534e4554, ""34618607"");
            }

        }
        VAR_6 &= ~2;
        if (VAR_6 != VAR_7 || VAR_0) {
            WriteSyncsafeInteger(&VAR_4[VAR_3 + 4], VAR_5);
            VAR_4[VAR_3 + 8] = VAR_6 >> 8;
            VAR_4[VAR_3 + 9] = VAR_6 & 0xff;
        }

        VAR_3 += 10 + VAR_5;
    }

    memset(&VAR_4[VAR_2], 0, VAR_1 - VAR_2);

    return true;
}",android/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5/ID3.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,7 +47,12 @@
                     --mSize;
                     --dataSize;
                 }
-                mData[writeOffset++] = mData[readOffset++];
+                if (i + 1 < dataSize) {
+                    // Only move data if there's actually something to move.
+                    // This handles the special case of the data being only [0xff, 0x00]
+                    // which should be converted to just 0xff if unsynchronization is on.
+                    mData[writeOffset++] = mData[readOffset++];
+                }
             }
             // move the remaining data following this frame
             if (readOffset <= oldSize) {","{'deleted_lines': ['                mData[writeOffset++] = mData[readOffset++];'], 'added_lines': ['                if (i + 1 < dataSize) {', ""                    // Only move data if there's actually something to move."", '                    // This handles the special case of the data being only [0xff, 0x00]', '                    // which should be converted to just 0xff if unsynchronization is on.', '                    mData[writeOffset++] = mData[readOffset++];', '                }']}",True,"An information disclosure vulnerability in the Android media framework (av) related to id3 unsynchronization. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63100526.",7.5,HIGH,2,valid,,5
CVE-2017-12179,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"[jcristau: originally this patch fixed the same issue as commit
 211e05ac85 ""Xi: Test exact size of XIBarrierReleasePointer"", with the
 addition of these checks]

This addresses CVE-2017-12179

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",d088e3c1286b548a58e62afdc70bb40981cdb9e8,https://cgit.freedesktop.org/xorg/xserver/commit/?id=d088e3c1286b548a58e62afdc70bb40981cdb9e8,Xi/xibarriers.c,ProcXIBarrierReleasePointer,"int
ProcXIBarrierReleasePointer(ClientPtr client)
{
int i;
int err;
struct PointerBarrierClient *barrier;
struct PointerBarrier *b;
xXIBarrierReleasePointerInfo *info;
REQUEST(xXIBarrierReleasePointerReq);
REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
info = (xXIBarrierReleasePointerInfo*) &stuff[1];
for (i = 0; i < stuff->num_barriers; i++, info++) {
struct PointerBarrierDevice *pbd;
DeviceIntPtr dev;
CARD32 barrier_id, event_id;
_X_UNUSED CARD32 device_id;
barrier_id = info->barrier;
event_id = info->eventid;
err = dixLookupDevice(&dev, info->deviceid, client, DixReadAccess);
if (err != Success) {
client->errorValue = BadDevice;
return err;
}
err = dixLookupResourceByType((void **) &b, barrier_id,
PointerBarrierType, client, DixReadAccess);
if (err != Success) {
client->errorValue = barrier_id;
return err;
}
if (CLIENT_ID(barrier_id) != client->index)
return BadAccess;
barrier = container_of(b, struct PointerBarrierClient, barrier);
pbd = GetBarrierDevice(barrier, dev->id);
if (pbd->barrier_event_id == event_id)
pbd->release_event_id = event_id;
}
return Success;
}","int
ProcXIBarrierReleasePointer(ClientPtr VAR_0)
{
int VAR_1;
int VAR_2;
struct PointerBarrierClient *VAR_3;
struct PointerBarrier *VAR_4;
xXIBarrierReleasePointerInfo *VAR_5;
REQUEST(VAR_6);
REQUEST_FIXED_SIZE(VAR_6, VAR_7->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
VAR_5 = (xXIBarrierReleasePointerInfo*) &VAR_7[1];
for (VAR_1 = 0; VAR_1 < VAR_7->num_barriers; VAR_1++, VAR_5++) {
struct PointerBarrierDevice *VAR_8;
DeviceIntPtr VAR_9;
CARD32 VAR_10, VAR_11;
_X_UNUSED CARD32 VAR_12;
VAR_10 = VAR_5->barrier;
VAR_11 = VAR_5->eventid;
VAR_2 = dixLookupDevice(&VAR_9, VAR_5->deviceid, VAR_0, VAR_13);
if (VAR_2 != VAR_14) {
VAR_0->errorValue = VAR_15;
return VAR_2;
}
VAR_2 = dixLookupResourceByType((void **) &VAR_4, VAR_10,
VAR_16, VAR_0, VAR_13);
if (VAR_2 != VAR_14) {
VAR_0->errorValue = VAR_10;
return VAR_2;
}
if (CLIENT_ID(VAR_10) != VAR_0->index)
return VAR_17;
VAR_3 = container_of(VAR_4, struct PointerBarrierClient, VAR_3);
VAR_8 = GetBarrierDevice(VAR_3, VAR_9->id);
if (VAR_8->barrier_event_id == VAR_11)
VAR_8->release_event_id = VAR_11;
}
return VAR_14;
}",xorg/xserver/d088e3c1286b548a58e62afdc70bb40981cdb9e8/xibarriers.c/vul/before/0.json,"int
ProcXIBarrierReleasePointer(ClientPtr client)
{
    int i;
    int err;
    struct PointerBarrierClient *barrier;
    struct PointerBarrier *b;
    xXIBarrierReleasePointerInfo *info;

    REQUEST(xXIBarrierReleasePointerReq);
    REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
        return BadLength;
    REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));

    info = (xXIBarrierReleasePointerInfo*) &stuff[1];
    for (i = 0; i < stuff->num_barriers; i++, info++) {
        struct PointerBarrierDevice *pbd;
        DeviceIntPtr dev;
        CARD32 barrier_id, event_id;
        _X_UNUSED CARD32 device_id;

        barrier_id = info->barrier;
        event_id = info->eventid;

        err = dixLookupDevice(&dev, info->deviceid, client, DixReadAccess);
        if (err != Success) {
            client->errorValue = BadDevice;
            return err;
        }

        err = dixLookupResourceByType((void **) &b, barrier_id,
                                      PointerBarrierType, client, DixReadAccess);
        if (err != Success) {
            client->errorValue = barrier_id;
            return err;
        }

        if (CLIENT_ID(barrier_id) != client->index)
            return BadAccess;


        barrier = container_of(b, struct PointerBarrierClient, barrier);

        pbd = GetBarrierDevice(barrier, dev->id);

        if (pbd->barrier_event_id == event_id)
            pbd->release_event_id = event_id;
    }

    return Success;
}","int
ProcXIBarrierReleasePointer(ClientPtr VAR_0)
{
    int VAR_1;
    int VAR_2;
    struct PointerBarrierClient *VAR_3;
    struct PointerBarrier *VAR_4;
    xXIBarrierReleasePointerInfo *VAR_5;

    REQUEST(VAR_6);
    REQUEST_AT_LEAST_SIZE(VAR_6);
    if (VAR_7->num_barriers > VAR_8 / sizeof(xXIBarrierReleasePointerInfo))
        return VAR_9;
    REQUEST_FIXED_SIZE(VAR_6, VAR_7->num_barriers * sizeof(xXIBarrierReleasePointerInfo));

    VAR_5 = (xXIBarrierReleasePointerInfo*) &VAR_7[1];
    for (VAR_1 = 0; VAR_1 < VAR_7->num_barriers; VAR_1++, VAR_5++) {
        struct PointerBarrierDevice *VAR_10;
        DeviceIntPtr VAR_11;
        CARD32 VAR_12, VAR_13;
        _X_UNUSED CARD32 VAR_14;

        VAR_12 = VAR_5->barrier;
        VAR_13 = VAR_5->eventid;

        VAR_2 = dixLookupDevice(&VAR_11, VAR_5->deviceid, VAR_0, VAR_15);
        if (VAR_2 != VAR_16) {
            VAR_0->errorValue = VAR_17;
            return VAR_2;
        }

        VAR_2 = dixLookupResourceByType((void **) &VAR_4, VAR_12,
                                      VAR_18, VAR_0, VAR_15);
        if (VAR_2 != VAR_16) {
            VAR_0->errorValue = VAR_12;
            return VAR_2;
        }

        if (CLIENT_ID(VAR_12) != VAR_0->index)
            return VAR_19;


        VAR_3 = container_of(VAR_4, struct PointerBarrierClient, VAR_3);

        VAR_10 = GetBarrierDevice(VAR_3, VAR_11->id);

        if (VAR_10->barrier_event_id == VAR_13)
            VAR_10->release_event_id = VAR_13;
    }

    return VAR_16;
}",xorg/xserver/d088e3c1286b548a58e62afdc70bb40981cdb9e8/xibarriers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
     xXIBarrierReleasePointerInfo *info;
 
     REQUEST(xXIBarrierReleasePointerReq);
+    REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
+    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
+        return BadLength;
     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
 
     info = (xXIBarrierReleasePointerInfo*) &stuff[1];","{'deleted_lines': [], 'added_lines': ['    REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);', '    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))', '        return BadLength;']}",True,xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,valid,,5
CVE-2017-12179,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"[jcristau: originally this patch fixed the same issue as commit
 211e05ac85 ""Xi: Test exact size of XIBarrierReleasePointer"", with the
 addition of these checks]

This addresses CVE-2017-12179

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",d088e3c1286b548a58e62afdc70bb40981cdb9e8,https://cgit.freedesktop.org/xorg/xserver/commit/?id=d088e3c1286b548a58e62afdc70bb40981cdb9e8,Xi/xibarriers.c,SProcXIBarrierReleasePointer,"int _X_COLD
SProcXIBarrierReleasePointer(ClientPtr client)
{
xXIBarrierReleasePointerInfo *info;
REQUEST(xXIBarrierReleasePointerReq);
int i;
swaps(&stuff->length);
REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
swapl(&stuff->num_barriers);
REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
info = (xXIBarrierReleasePointerInfo*) &stuff[1];
for (i = 0; i < stuff->num_barriers; i++, info++) {
swaps(&info->deviceid);
swapl(&info->barrier);
swapl(&info->eventid);
}
return (ProcXIBarrierReleasePointer(client));
}","int VAR_0
SProcXIBarrierReleasePointer(ClientPtr VAR_1)
{
xXIBarrierReleasePointerInfo *VAR_2;
REQUEST(VAR_3);
int VAR_4;
swaps(&VAR_5->length);
REQUEST_AT_LEAST_SIZE(VAR_3);
swapl(&VAR_5->num_barriers);
REQUEST_FIXED_SIZE(VAR_3, VAR_5->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
VAR_2 = (xXIBarrierReleasePointerInfo*) &VAR_5[1];
for (VAR_4 = 0; VAR_4 < VAR_5->num_barriers; VAR_4++, VAR_2++) {
swaps(&VAR_2->deviceid);
swapl(&VAR_2->barrier);
swapl(&VAR_2->eventid);
}
return (ProcXIBarrierReleasePointer(VAR_1));
}",,"int _X_COLD
SProcXIBarrierReleasePointer(ClientPtr client)
{
    xXIBarrierReleasePointerInfo *info;
    REQUEST(xXIBarrierReleasePointerReq);
    int i;

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);

    swapl(&stuff->num_barriers);
    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
        return BadLength;
    REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));

    info = (xXIBarrierReleasePointerInfo*) &stuff[1];
    for (i = 0; i < stuff->num_barriers; i++, info++) {
        swaps(&info->deviceid);
        swapl(&info->barrier);
        swapl(&info->eventid);
    }

    return (ProcXIBarrierReleasePointer(client));
}","int VAR_0
SProcXIBarrierReleasePointer(ClientPtr VAR_1)
{
    xXIBarrierReleasePointerInfo *VAR_2;
    REQUEST(VAR_3);
    int VAR_4;

    swaps(&VAR_5->length);
    REQUEST_AT_LEAST_SIZE(VAR_3);

    swapl(&VAR_5->num_barriers);
    if (VAR_5->num_barriers > VAR_6 / sizeof(xXIBarrierReleasePointerInfo))
        return VAR_7;
    REQUEST_FIXED_SIZE(VAR_3, VAR_5->num_barriers * sizeof(xXIBarrierReleasePointerInfo));

    VAR_2 = (xXIBarrierReleasePointerInfo*) &VAR_5[1];
    for (VAR_4 = 0; VAR_4 < VAR_5->num_barriers; VAR_4++, VAR_2++) {
        swaps(&VAR_2->deviceid);
        swapl(&VAR_2->barrier);
        swapl(&VAR_2->eventid);
    }

    return (ProcXIBarrierReleasePointer(VAR_1));
}",,"--- func_before
+++ func_after
@@ -9,6 +9,8 @@
     REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
 
     swapl(&stuff->num_barriers);
+    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
+        return BadLength;
     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
 
     info = (xXIBarrierReleasePointerInfo*) &stuff[1];","{'deleted_lines': [], 'added_lines': ['    if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))', '        return BadLength;']}",True,xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,valid,,5
CVE-2017-16912,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"get_pipe() routine doesn't validate the input endpoint number
and uses to reference ep_in and ep_out arrays. Invalid endpoint
number can trigger BUG(). Range check the epnum and returning
error instead of calling BUG().

Change caller stub_recv_cmd_submit() to handle the get_pipe()
error return.

Reported-by: Secunia Research <vuln@secunia.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",635f545a7e8be7596b9b2b6a43cab6bbd5a88e43,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/drivers/usb/usbip?h=635f545a7e8be7596b9b2b6a43cab6bbd5a88e43,drivers/usb/usbip/stub_rx.c,get_pipe,"static int get_pipe(struct stub_device *sdev, int epnum, int dir)
{
struct usb_device *udev = sdev->udev;
struct usb_host_endpoint *ep;
struct usb_endpoint_descriptor *epd = NULL;
if (dir == USBIP_DIR_IN)
ep = udev->ep_in[epnum & 0x7f];
else
ep = udev->ep_out[epnum & 0x7f];
if (!ep) {
dev_err(&sdev->udev->dev, ""no such endpoint?, %d\n"",
epnum);
BUG();
}
epd = &ep->desc;
if (usb_endpoint_xfer_control(epd)) {
if (dir == USBIP_DIR_OUT)
return usb_sndctrlpipe(udev, epnum);
else
return usb_rcvctrlpipe(udev, epnum);
}
if (usb_endpoint_xfer_bulk(epd)) {
if (dir == USBIP_DIR_OUT)
return usb_sndbulkpipe(udev, epnum);
else
return usb_rcvbulkpipe(udev, epnum);
}
if (usb_endpoint_xfer_int(epd)) {
if (dir == USBIP_DIR_OUT)
return usb_sndintpipe(udev, epnum);
else
return usb_rcvintpipe(udev, epnum);
}
if (usb_endpoint_xfer_isoc(epd)) {
if (dir == USBIP_DIR_OUT)
return usb_sndisocpipe(udev, epnum);
else
return usb_rcvisocpipe(udev, epnum);
}
dev_err(&sdev->udev->dev, ""get pipe, epnum %d\n"", epnum);
return 0;
}","static int get_pipe(struct stub_device *VAR_0, int VAR_1, int VAR_2)
{
struct usb_device *VAR_3 = VAR_0->udev;
struct usb_host_endpoint *VAR_4;
struct usb_endpoint_descriptor *VAR_5 = NULL;
if (VAR_2 == VAR_6)
VAR_4 = VAR_3->ep_in[VAR_1 & 0x7f];
else
VAR_4 = VAR_3->ep_out[VAR_1 & 0x7f];
if (!VAR_4) {
dev_err(&VAR_0->udev->dev, ""no such endpoint?, %d\n"",
VAR_1);
BUG();
}
VAR_5 = &VAR_4->desc;
if (usb_endpoint_xfer_control(VAR_5)) {
if (VAR_2 == VAR_7)
return usb_sndctrlpipe(VAR_3, VAR_1);
else
return usb_rcvctrlpipe(VAR_3, VAR_1);
}
if (usb_endpoint_xfer_bulk(VAR_5)) {
if (VAR_2 == VAR_7)
return usb_sndbulkpipe(VAR_3, VAR_1);
else
return usb_rcvbulkpipe(VAR_3, VAR_1);
}
if (usb_endpoint_xfer_int(VAR_5)) {
if (VAR_2 == VAR_7)
return usb_sndintpipe(VAR_3, VAR_1);
else
return usb_rcvintpipe(VAR_3, VAR_1);
}
if (usb_endpoint_xfer_isoc(VAR_5)) {
if (VAR_2 == VAR_7)
return usb_sndisocpipe(VAR_3, VAR_1);
else
return usb_rcvisocpipe(VAR_3, VAR_1);
}
dev_err(&VAR_0->udev->dev, ""get pipe, epnum %d\n"", VAR_1);
return 0;
}",torvalds/linux/635f545a7e8be7596b9b2b6a43cab6bbd5a88e43/stub_rx.c/vul/before/0.json,"static int get_pipe(struct stub_device *sdev, int epnum, int dir)
{
	struct usb_device *udev = sdev->udev;
	struct usb_host_endpoint *ep;
	struct usb_endpoint_descriptor *epd = NULL;

	if (epnum < 0 || epnum > 15)
		goto err_ret;

	if (dir == USBIP_DIR_IN)
		ep = udev->ep_in[epnum & 0x7f];
	else
		ep = udev->ep_out[epnum & 0x7f];
	if (!ep)
		goto err_ret;

	epd = &ep->desc;
	if (usb_endpoint_xfer_control(epd)) {
		if (dir == USBIP_DIR_OUT)
			return usb_sndctrlpipe(udev, epnum);
		else
			return usb_rcvctrlpipe(udev, epnum);
	}

	if (usb_endpoint_xfer_bulk(epd)) {
		if (dir == USBIP_DIR_OUT)
			return usb_sndbulkpipe(udev, epnum);
		else
			return usb_rcvbulkpipe(udev, epnum);
	}

	if (usb_endpoint_xfer_int(epd)) {
		if (dir == USBIP_DIR_OUT)
			return usb_sndintpipe(udev, epnum);
		else
			return usb_rcvintpipe(udev, epnum);
	}

	if (usb_endpoint_xfer_isoc(epd)) {
		if (dir == USBIP_DIR_OUT)
			return usb_sndisocpipe(udev, epnum);
		else
			return usb_rcvisocpipe(udev, epnum);
	}

err_ret:
	/* NOT REACHED */
	dev_err(&sdev->udev->dev, ""get pipe() invalid epnum %d\n"", epnum);
	return -1;
}","static int get_pipe(struct stub_device *VAR_0, int VAR_1, int VAR_2)
{
	struct usb_device *VAR_3 = VAR_0->udev;
	struct usb_host_endpoint *VAR_4;
	struct usb_endpoint_descriptor *VAR_5 = NULL;

	if (VAR_1 < 0 || VAR_1 > 15)
		goto err_ret;

	if (VAR_2 == VAR_6)
		VAR_4 = VAR_3->ep_in[VAR_1 & 0x7f];
	else
		VAR_4 = VAR_3->ep_out[VAR_1 & 0x7f];
	if (!VAR_4)
		goto err_ret;

	VAR_5 = &VAR_4->desc;
	if (usb_endpoint_xfer_control(VAR_5)) {
		if (VAR_2 == VAR_7)
			return usb_sndctrlpipe(VAR_3, VAR_1);
		else
			return usb_rcvctrlpipe(VAR_3, VAR_1);
	}

	if (usb_endpoint_xfer_bulk(VAR_5)) {
		if (VAR_2 == VAR_7)
			return usb_sndbulkpipe(VAR_3, VAR_1);
		else
			return usb_rcvbulkpipe(VAR_3, VAR_1);
	}

	if (usb_endpoint_xfer_int(VAR_5)) {
		if (VAR_2 == VAR_7)
			return usb_sndintpipe(VAR_3, VAR_1);
		else
			return usb_rcvintpipe(VAR_3, VAR_1);
	}

	if (usb_endpoint_xfer_isoc(VAR_5)) {
		if (VAR_2 == VAR_7)
			return usb_sndisocpipe(VAR_3, VAR_1);
		else
			return usb_rcvisocpipe(VAR_3, VAR_1);
	}

err_ret:
	/* COMMENT_0 */
	dev_err(&VAR_0->udev->dev, ""get pipe() invalid epnum %d\n"", VAR_1);
	return -1;
}",torvalds/linux/635f545a7e8be7596b9b2b6a43cab6bbd5a88e43/stub_rx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,15 +4,15 @@
 	struct usb_host_endpoint *ep;
 	struct usb_endpoint_descriptor *epd = NULL;
 
+	if (epnum < 0 || epnum > 15)
+		goto err_ret;
+
 	if (dir == USBIP_DIR_IN)
 		ep = udev->ep_in[epnum & 0x7f];
 	else
 		ep = udev->ep_out[epnum & 0x7f];
-	if (!ep) {
-		dev_err(&sdev->udev->dev, ""no such endpoint?, %d\n"",
-			epnum);
-		BUG();
-	}
+	if (!ep)
+		goto err_ret;
 
 	epd = &ep->desc;
 	if (usb_endpoint_xfer_control(epd)) {
@@ -43,7 +43,8 @@
 			return usb_rcvisocpipe(udev, epnum);
 	}
 
+err_ret:
 	/* NOT REACHED */
-	dev_err(&sdev->udev->dev, ""get pipe, epnum %d\n"", epnum);
-	return 0;
+	dev_err(&sdev->udev->dev, ""get pipe() invalid epnum %d\n"", epnum);
+	return -1;
 }","{'deleted_lines': ['\tif (!ep) {', '\t\tdev_err(&sdev->udev->dev, ""no such endpoint?, %d\\n"",', '\t\t\tepnum);', '\t\tBUG();', '\t}', '\tdev_err(&sdev->udev->dev, ""get pipe, epnum %d\\n"", epnum);', '\treturn 0;'], 'added_lines': ['\tif (epnum < 0 || epnum > 15)', '\t\tgoto err_ret;', '', '\tif (!ep)', '\t\tgoto err_ret;', 'err_ret:', '\tdev_err(&sdev->udev->dev, ""get pipe() invalid epnum %d\\n"", epnum);', '\treturn -1;']}",True,"The ""get_pipe()"" function (drivers/usb/usbip/stub_rx.c) in the Linux Kernel before version 4.14.8, 4.9.71, and 4.4.114 allows attackers to cause a denial of service (out-of-bounds read) via a specially crafted USB over IP packet.",5.9,MEDIUM,1,valid,,5
CVE-2017-16912,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"get_pipe() routine doesn't validate the input endpoint number
and uses to reference ep_in and ep_out arrays. Invalid endpoint
number can trigger BUG(). Range check the epnum and returning
error instead of calling BUG().

Change caller stub_recv_cmd_submit() to handle the get_pipe()
error return.

Reported-by: Secunia Research <vuln@secunia.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",635f545a7e8be7596b9b2b6a43cab6bbd5a88e43,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/drivers/usb/usbip?h=635f545a7e8be7596b9b2b6a43cab6bbd5a88e43,drivers/usb/usbip/stub_rx.c,stub_recv_cmd_submit,"static void stub_recv_cmd_submit(struct stub_device *sdev,
struct usbip_header *pdu)
{
int ret;
struct stub_priv *priv;
struct usbip_device *ud = &sdev->ud;
struct usb_device *udev = sdev->udev;
int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);
priv = stub_priv_alloc(sdev, pdu);
if (!priv)
return;
if (usb_pipeisoc(pipe))
priv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,
GFP_KERNEL);
else
priv->urb = usb_alloc_urb(0, GFP_KERNEL);
if (!priv->urb) {
usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
return;
}
if (pdu->u.cmd_submit.transfer_buffer_length > 0) {
priv->urb->transfer_buffer =
kzalloc(pdu->u.cmd_submit.transfer_buffer_length,
GFP_KERNEL);
if (!priv->urb->transfer_buffer) {
usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
return;
}
}
priv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,
GFP_KERNEL);
if (!priv->urb->setup_packet) {
dev_err(&udev->dev, ""allocate setup_packet\n"");
usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
return;
}
priv->urb->context                = (void *) priv;
priv->urb->dev                    = udev;
priv->urb->pipe                   = pipe;
priv->urb->complete               = stub_complete;
usbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0);
if (usbip_recv_xbuff(ud, priv->urb) < 0)
return;
if (usbip_recv_iso(ud, priv->urb) < 0)
return;
tweak_special_requests(priv->urb);
masking_bogus_flags(priv->urb);
ret = usb_submit_urb(priv->urb, GFP_KERNEL);
if (ret == 0)
usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"",
pdu->base.seqnum);
else {
dev_err(&udev->dev, ""submit_urb error, %d\n"", ret);
usbip_dump_header(pdu);
usbip_dump_urb(priv->urb);
usbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);
}
usbip_dbg_stub_rx(""Leave\n"");
}","static void stub_recv_cmd_submit(struct stub_device *VAR_0,
struct usbip_header *VAR_1)
{
int VAR_2;
struct stub_priv *VAR_3;
struct usbip_device *VAR_4 = &VAR_0->ud;
struct usb_device *VAR_5 = VAR_0->udev;
int VAR_6 = get_pipe(VAR_0, VAR_1->base.ep, VAR_1->base.direction);
VAR_3 = stub_priv_alloc(VAR_0, VAR_1);
if (!VAR_3)
return;
if (usb_pipeisoc(VAR_6))
VAR_3->urb = usb_alloc_urb(VAR_1->u.cmd_submit.number_of_packets,
VAR_7);
else
VAR_3->urb = usb_alloc_urb(0, VAR_7);
if (!VAR_3->urb) {
usbip_event_add(VAR_4, VAR_8);
return;
}
if (VAR_1->u.cmd_submit.transfer_buffer_length > 0) {
VAR_3->urb->transfer_buffer =
kzalloc(VAR_1->u.cmd_submit.transfer_buffer_length,
VAR_7);
if (!VAR_3->urb->transfer_buffer) {
usbip_event_add(VAR_4, VAR_8);
return;
}
}
VAR_3->urb->setup_packet = kmemdup(&VAR_1->u.cmd_submit.setup, 8,
VAR_7);
if (!VAR_3->urb->setup_packet) {
dev_err(&VAR_5->dev, ""allocate setup_packet\n"");
usbip_event_add(VAR_4, VAR_8);
return;
}
VAR_3->urb->context                = (void *) VAR_3;
VAR_3->urb->dev                    = VAR_5;
VAR_3->urb->pipe                   = VAR_6;
VAR_3->urb->complete               = VAR_9;
usbip_pack_pdu(VAR_1, VAR_3->urb, VAR_10, 0);
if (usbip_recv_xbuff(VAR_4, VAR_3->urb) < 0)
return;
if (usbip_recv_iso(VAR_4, VAR_3->urb) < 0)
return;
tweak_special_requests(VAR_3->urb);
masking_bogus_flags(VAR_3->urb);
VAR_2 = usb_submit_urb(VAR_3->urb, VAR_7);
if (VAR_2 == 0)
usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"",
VAR_1->base.seqnum);
else {
dev_err(&VAR_5->dev, ""submit_urb error, %d\n"", VAR_2);
usbip_dump_header(VAR_1);
usbip_dump_urb(VAR_3->urb);
usbip_event_add(VAR_4, VAR_11);
}
usbip_dbg_stub_rx(""Leave\n"");
}",torvalds/linux/635f545a7e8be7596b9b2b6a43cab6bbd5a88e43/stub_rx.c/vul/before/1.json,"static void stub_recv_cmd_submit(struct stub_device *sdev,
				 struct usbip_header *pdu)
{
	int ret;
	struct stub_priv *priv;
	struct usbip_device *ud = &sdev->ud;
	struct usb_device *udev = sdev->udev;
	int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);

	if (pipe == -1)
		return;

	priv = stub_priv_alloc(sdev, pdu);
	if (!priv)
		return;

	/* setup a urb */
	if (usb_pipeisoc(pipe))
		priv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,
					  GFP_KERNEL);
	else
		priv->urb = usb_alloc_urb(0, GFP_KERNEL);

	if (!priv->urb) {
		usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
		return;
	}

	/* allocate urb transfer buffer, if needed */
	if (pdu->u.cmd_submit.transfer_buffer_length > 0) {
		priv->urb->transfer_buffer =
			kzalloc(pdu->u.cmd_submit.transfer_buffer_length,
				GFP_KERNEL);
		if (!priv->urb->transfer_buffer) {
			usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
			return;
		}
	}

	/* copy urb setup packet */
	priv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,
					  GFP_KERNEL);
	if (!priv->urb->setup_packet) {
		dev_err(&udev->dev, ""allocate setup_packet\n"");
		usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
		return;
	}

	/* set other members from the base header of pdu */
	priv->urb->context                = (void *) priv;
	priv->urb->dev                    = udev;
	priv->urb->pipe                   = pipe;
	priv->urb->complete               = stub_complete;

	usbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0);


	if (usbip_recv_xbuff(ud, priv->urb) < 0)
		return;

	if (usbip_recv_iso(ud, priv->urb) < 0)
		return;

	/* no need to submit an intercepted request, but harmless? */
	tweak_special_requests(priv->urb);

	masking_bogus_flags(priv->urb);
	/* urb is now ready to submit */
	ret = usb_submit_urb(priv->urb, GFP_KERNEL);

	if (ret == 0)
		usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"",
				  pdu->base.seqnum);
	else {
		dev_err(&udev->dev, ""submit_urb error, %d\n"", ret);
		usbip_dump_header(pdu);
		usbip_dump_urb(priv->urb);

		/*
		 * Pessimistic.
		 * This connection will be discarded.
		 */
		usbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);
	}

	usbip_dbg_stub_rx(""Leave\n"");
}","static void stub_recv_cmd_submit(struct stub_device *VAR_0,
				 struct usbip_header *VAR_1)
{
	int VAR_2;
	struct stub_priv *VAR_3;
	struct usbip_device *VAR_4 = &VAR_0->ud;
	struct usb_device *VAR_5 = VAR_0->udev;
	int VAR_6 = get_pipe(VAR_0, VAR_1->base.ep, VAR_1->base.direction);

	if (VAR_6 == -1)
		return;

	VAR_3 = stub_priv_alloc(VAR_0, VAR_1);
	if (!VAR_3)
		return;

	/* COMMENT_0 */
	if (usb_pipeisoc(VAR_6))
		VAR_3->urb = usb_alloc_urb(VAR_1->u.cmd_submit.number_of_packets,
					  VAR_7);
	else
		VAR_3->urb = usb_alloc_urb(0, VAR_7);

	if (!VAR_3->urb) {
		usbip_event_add(VAR_4, VAR_8);
		return;
	}

	/* COMMENT_1 */
	if (VAR_1->u.cmd_submit.transfer_buffer_length > 0) {
		VAR_3->urb->transfer_buffer =
			kzalloc(VAR_1->u.cmd_submit.transfer_buffer_length,
				VAR_7);
		if (!VAR_3->urb->transfer_buffer) {
			usbip_event_add(VAR_4, VAR_8);
			return;
		}
	}

	/* COMMENT_2 */
	VAR_3->urb->setup_packet = kmemdup(&VAR_1->u.cmd_submit.setup, 8,
					  VAR_7);
	if (!VAR_3->urb->setup_packet) {
		dev_err(&VAR_5->dev, ""allocate setup_packet\n"");
		usbip_event_add(VAR_4, VAR_8);
		return;
	}

	/* COMMENT_3 */
	VAR_3->urb->context                = (void *) VAR_3;
	VAR_3->urb->dev                    = VAR_5;
	VAR_3->urb->pipe                   = VAR_6;
	VAR_3->urb->complete               = VAR_9;

	usbip_pack_pdu(VAR_1, VAR_3->urb, VAR_10, 0);


	if (usbip_recv_xbuff(VAR_4, VAR_3->urb) < 0)
		return;

	if (usbip_recv_iso(VAR_4, VAR_3->urb) < 0)
		return;

	/* COMMENT_4 */
	tweak_special_requests(VAR_3->urb);

	masking_bogus_flags(VAR_3->urb);
	/* COMMENT_5 */
	VAR_2 = usb_submit_urb(VAR_3->urb, VAR_7);

	if (VAR_2 == 0)
		usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"",
				  VAR_1->base.seqnum);
	else {
		dev_err(&VAR_5->dev, ""submit_urb error, %d\n"", VAR_2);
		usbip_dump_header(VAR_1);
		usbip_dump_urb(VAR_3->urb);

		/* COMMENT_6 */
                 
                                       
     
		usbip_event_add(VAR_4, VAR_11);
	}

	usbip_dbg_stub_rx(""Leave\n"");
}",torvalds/linux/635f545a7e8be7596b9b2b6a43cab6bbd5a88e43/stub_rx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
 	struct usbip_device *ud = &sdev->ud;
 	struct usb_device *udev = sdev->udev;
 	int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);
+
+	if (pipe == -1)
+		return;
 
 	priv = stub_priv_alloc(sdev, pdu);
 	if (!priv)","{'deleted_lines': [], 'added_lines': ['', '\tif (pipe == -1)', '\t\treturn;']}",True,"The ""get_pipe()"" function (drivers/usb/usbip/stub_rx.c) in the Linux Kernel before version 4.14.8, 4.9.71, and 4.4.114 allows attackers to cause a denial of service (out-of-bounds read) via a specially crafted USB over IP packet.",5.9,MEDIUM,1,valid,,5
CVE-2023-23455,['CWE-843'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"If asked to drop a packet via TC_ACT_SHOT it is unsafe to assume
res.class contains a valid pointer
Fixes: b0188d4dbe5f (""[NET_SCHED]: sch_atm: Lindent"")

Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",a2965c7be0522eaa18808684b7b82b248515511b,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a2965c7be0522eaa18808684b7b82b248515511b,net/sched/sch_atm.c,atm_tc_enqueue,"static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
struct sk_buff **to_free)
{
struct atm_qdisc_data *p = qdisc_priv(sch);
struct atm_flow_data *flow;
struct tcf_result res;
int result;
int ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;
pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", skb, sch, p);
result = TC_ACT_OK;
flow = NULL;
if (TC_H_MAJ(skb->priority) != sch->handle ||
!(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) {
struct tcf_proto *fl;
list_for_each_entry(flow, &p->flows, list) {
fl = rcu_dereference_bh(flow->filter_list);
if (fl) {
result = tcf_classify(skb, NULL, fl, &res, true);
if (result < 0)
continue;
flow = (struct atm_flow_data *)res.class;
if (!flow)
flow = lookup_flow(sch, res.classid);
goto done;
}
}
flow = NULL;
done:
;
}
if (!flow) {
flow = &p->link;
} else {
if (flow->vcc)
ATM_SKB(skb)->atm_options = flow->vcc->atm_options;
#ifdef CONFIG_NET_CLS_ACT
switch (result) {
case TC_ACT_QUEUED:
case TC_ACT_STOLEN:
case TC_ACT_TRAP:
__qdisc_drop(skb, to_free);
return NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
case TC_ACT_SHOT:
__qdisc_drop(skb, to_free);
goto drop;
case TC_ACT_RECLASSIFY:
if (flow->excess)
flow = flow->excess;
else
ATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP;
break;
}
#endif
}
ret = qdisc_enqueue(skb, flow->q, to_free);
if (ret != NET_XMIT_SUCCESS) {
drop: __maybe_unused
if (net_xmit_drop_count(ret)) {
qdisc_qstats_drop(sch);
if (flow)
flow->qstats.drops++;
}
return ret;
}
if (flow == &p->link) {
sch->q.qlen++;
return NET_XMIT_SUCCESS;
}
tasklet_schedule(&p->task);
return NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;
}","static int atm_tc_enqueue(struct sk_buff *VAR_0, struct Qdisc *VAR_1,
struct sk_buff **VAR_2)
{
struct atm_qdisc_data *VAR_3 = qdisc_priv(VAR_1);
struct atm_flow_data *VAR_4;
struct tcf_result VAR_5;
int VAR_6;
int VAR_7 = VAR_8 | VAR_9;
pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", VAR_0, VAR_1, VAR_3);
VAR_6 = VAR_10;
VAR_4 = NULL;
if (TC_H_MAJ(VAR_0->priority) != VAR_1->handle ||
!(VAR_4 = (struct atm_flow_data *)atm_tc_find(VAR_1, VAR_0->priority))) {
struct tcf_proto *VAR_11;
list_for_each_entry(VAR_4, &VAR_3->flows, VAR_12) {
VAR_11 = rcu_dereference_bh(VAR_4->filter_list);
if (VAR_11) {
VAR_6 = tcf_classify(VAR_0, NULL, VAR_11, &VAR_5, true);
if (VAR_6 < 0)
continue;
VAR_4 = (struct atm_flow_data *)VAR_5.class;
if (!VAR_4)
VAR_4 = lookup_flow(VAR_1, VAR_5.classid);
goto done;
}
}
VAR_4 = NULL;
done:
;
}
if (!VAR_4) {
VAR_4 = &VAR_3->link;
} else {
if (VAR_4->vcc)
ATM_SKB(VAR_0)->atm_options = VAR_4->vcc->atm_options;
#ifdef VAR_13
switch (VAR_6) {
case VAR_14:
case VAR_15:
case VAR_16:
__qdisc_drop(VAR_0, VAR_2);
return VAR_8 | VAR_17;
case VAR_18:
__qdisc_drop(VAR_0, VAR_2);
goto drop;
case VAR_19:
if (VAR_4->excess)
VAR_4 = VAR_4->excess;
else
ATM_SKB(VAR_0)->atm_options |= VAR_20;
break;
}
#endif
}
VAR_7 = qdisc_enqueue(VAR_0, VAR_4->q, VAR_2);
if (VAR_7 != VAR_8) {
drop: VAR_21
if (net_xmit_drop_count(VAR_7)) {
qdisc_qstats_drop(VAR_1);
if (VAR_4)
VAR_4->qstats.drops++;
}
return VAR_7;
}
if (VAR_4 == &VAR_3->link) {
VAR_1->q.qlen++;
return VAR_8;
}
tasklet_schedule(&VAR_3->task);
return VAR_8 | VAR_9;
}",torvalds/linux/a2965c7be0522eaa18808684b7b82b248515511b/sch_atm.c/vul/before/0.json,"static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
			  struct sk_buff **to_free)
{
	struct atm_qdisc_data *p = qdisc_priv(sch);
	struct atm_flow_data *flow;
	struct tcf_result res;
	int result;
	int ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;

	pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", skb, sch, p);
	result = TC_ACT_OK;	/* be nice to gcc */
	flow = NULL;
	if (TC_H_MAJ(skb->priority) != sch->handle ||
	    !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) {
		struct tcf_proto *fl;

		list_for_each_entry(flow, &p->flows, list) {
			fl = rcu_dereference_bh(flow->filter_list);
			if (fl) {
				result = tcf_classify(skb, NULL, fl, &res, true);
				if (result < 0)
					continue;
				if (result == TC_ACT_SHOT)
					goto done;

				flow = (struct atm_flow_data *)res.class;
				if (!flow)
					flow = lookup_flow(sch, res.classid);
				goto drop;
			}
		}
		flow = NULL;
done:
		;
	}
	if (!flow) {
		flow = &p->link;
	} else {
		if (flow->vcc)
			ATM_SKB(skb)->atm_options = flow->vcc->atm_options;
		/*@@@ looks good ... but it's not supposed to work :-) */
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_QUEUED:
		case TC_ACT_STOLEN:
		case TC_ACT_TRAP:
			__qdisc_drop(skb, to_free);
			return NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			__qdisc_drop(skb, to_free);
			goto drop;
		case TC_ACT_RECLASSIFY:
			if (flow->excess)
				flow = flow->excess;
			else
				ATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP;
			break;
		}
#endif
	}

	ret = qdisc_enqueue(skb, flow->q, to_free);
	if (ret != NET_XMIT_SUCCESS) {
drop: __maybe_unused
		if (net_xmit_drop_count(ret)) {
			qdisc_qstats_drop(sch);
			if (flow)
				flow->qstats.drops++;
		}
		return ret;
	}
	/*
	 * Okay, this may seem weird. We pretend we've dropped the packet if
	 * it goes via ATM. The reason for this is that the outer qdisc
	 * expects to be able to q->dequeue the packet later on if we return
	 * success at this place. Also, sch->q.qdisc needs to reflect whether
	 * there is a packet egligible for dequeuing or not. Note that the
	 * statistics of the outer qdisc are necessarily wrong because of all
	 * this. There's currently no correct solution for this.
	 */
	if (flow == &p->link) {
		sch->q.qlen++;
		return NET_XMIT_SUCCESS;
	}
	tasklet_schedule(&p->task);
	return NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;
}","static int atm_tc_enqueue(struct sk_buff *VAR_0, struct Qdisc *VAR_1,
			  struct sk_buff **VAR_2)
{
	struct atm_qdisc_data *VAR_3 = qdisc_priv(VAR_1);
	struct atm_flow_data *VAR_4;
	struct tcf_result VAR_5;
	int VAR_6;
	int VAR_7 = VAR_8 | VAR_9;

	pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", VAR_0, VAR_1, VAR_3);
	VAR_6 = VAR_10;	/* COMMENT_0 */
	VAR_4 = NULL;
	if (TC_H_MAJ(VAR_0->priority) != VAR_1->handle ||
	    !(VAR_4 = (struct atm_flow_data *)atm_tc_find(VAR_1, VAR_0->priority))) {
		struct tcf_proto *VAR_11;

		list_for_each_entry(VAR_4, &VAR_3->flows, VAR_12) {
			VAR_11 = rcu_dereference_bh(VAR_4->filter_list);
			if (VAR_11) {
				VAR_6 = tcf_classify(VAR_0, NULL, VAR_11, &VAR_5, true);
				if (VAR_6 < 0)
					continue;
				if (VAR_6 == VAR_13)
					goto done;

				VAR_4 = (struct atm_flow_data *)VAR_5.class;
				if (!VAR_4)
					VAR_4 = lookup_flow(VAR_1, VAR_5.classid);
				goto drop;
			}
		}
		VAR_4 = NULL;
done:
		;
	}
	if (!VAR_4) {
		VAR_4 = &VAR_3->link;
	} else {
		if (VAR_4->vcc)
			ATM_SKB(VAR_0)->atm_options = VAR_4->vcc->atm_options;
		/* COMMENT_1 */
#ifdef VAR_14
		switch (VAR_6) {
		case VAR_15:
		case VAR_16:
		case VAR_17:
			__qdisc_drop(VAR_0, VAR_2);
			return VAR_8 | VAR_18;
		case VAR_13:
			__qdisc_drop(VAR_0, VAR_2);
			goto drop;
		case VAR_19:
			if (VAR_4->excess)
				VAR_4 = VAR_4->excess;
			else
				ATM_SKB(VAR_0)->atm_options |= VAR_20;
			break;
		}
#endif
	}

	VAR_7 = qdisc_enqueue(VAR_0, VAR_4->q, VAR_2);
	if (VAR_7 != VAR_8) {
drop: VAR_21
		if (net_xmit_drop_count(VAR_7)) {
			qdisc_qstats_drop(VAR_1);
			if (VAR_4)
				VAR_4->qstats.drops++;
		}
		return VAR_7;
	}
	/* COMMENT_2 */
                                                                     
                                                                
                                                                     
                                                                      
                                                                   
                                                                      
                                                         
    
	if (VAR_4 == &VAR_3->link) {
		VAR_1->q.qlen++;
		return VAR_8;
	}
	tasklet_schedule(&VAR_3->task);
	return VAR_8 | VAR_9;
}",torvalds/linux/a2965c7be0522eaa18808684b7b82b248515511b/sch_atm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,10 +20,13 @@
 				result = tcf_classify(skb, NULL, fl, &res, true);
 				if (result < 0)
 					continue;
+				if (result == TC_ACT_SHOT)
+					goto done;
+
 				flow = (struct atm_flow_data *)res.class;
 				if (!flow)
 					flow = lookup_flow(sch, res.classid);
-				goto done;
+				goto drop;
 			}
 		}
 		flow = NULL;","{'deleted_lines': ['\t\t\t\tgoto done;'], 'added_lines': ['\t\t\t\tif (result == TC_ACT_SHOT)', '\t\t\t\t\tgoto done;', '', '\t\t\t\tgoto drop;']}",True,atm_tc_enqueue in net/sched/sch_atm.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).,5.5,MEDIUM,1,valid,,5
CVE-2023-0417,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,wireshark,"NFS: Fix string decoding to use UTF-8

Use tvb_get_string_enc() to read a string.

I think NFSv3 doesn't specify an encoding so interoperabilty
is dicey. I believe NFSv4 specifies UTF-8.

Fixes #18628.
",ae0c38a07a64a7c002d64b31e13c349ee4919791,https://gitlab.com/wireshark/wireshark/-/commit/ae0c38a07a64a7c002d64b31e13c349ee4919791,epan/dissectors/packet-nfs.c,dissect_nfs4_dirlist,"static int
dissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo,
proto_tree *tree, rpc_call_info_value *civ)
{
guint32    val_follows;
guint32    name_len;
char   *name;
proto_tree *dirlist_tree;
proto_item *eitem;
proto_tree *entry_tree;
dirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, ""Directory Listing"");
while (1)
{
val_follows = tvb_get_ntohl(tvb, offset);
if (val_follows) {
int start_off = offset;
name_len = tvb_get_ntohl(tvb, offset + 12);
tvb_ensure_bytes_exist(tvb, offset, 16 + name_len);
name = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);
name[name_len] = '\0';
eitem = proto_tree_add_string_format(
dirlist_tree, hf_nfs_name, tvb, offset, -1, name, ""Entry: %s"", name);
entry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry);
proto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);
offset += 4;
if (entry_tree)
dissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset);
offset += 8;
offset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL);
offset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ);
proto_item_set_len(eitem, offset - start_off);
} else {
break;
}
}
if (dirlist_tree) {
proto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);
offset += 4;
offset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset);
} else {
offset += 8;
}
return offset;
}","static int
dissect_nfs4_dirlist(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2,
proto_tree *VAR_3, rpc_call_info_value *VAR_4)
{
guint32    VAR_5;
guint32    VAR_6;
char   *VAR_7;
proto_tree *VAR_8;
proto_item *VAR_9;
proto_tree *VAR_10;
VAR_8 = proto_tree_add_subtree(VAR_3, VAR_0, VAR_1, 0, VAR_11, NULL, ""Directory Listing"");
while (1)
{
VAR_5 = tvb_get_ntohl(VAR_0, VAR_1);
if (VAR_5) {
int VAR_12 = VAR_1;
VAR_6 = tvb_get_ntohl(VAR_0, VAR_1 + 12);
tvb_ensure_bytes_exist(VAR_0, VAR_1, 16 + VAR_6);
VAR_7 = (char *)tvb_memcpy(VAR_0, wmem_alloc(wmem_packet_scope(), VAR_6+1), VAR_1 + 16, VAR_6);
VAR_7[VAR_6] = '\0';
VAR_9 = proto_tree_add_string_format(
VAR_8, VAR_13, VAR_0, VAR_1, -1, VAR_7, ""Entry: %s"", VAR_7);
VAR_10 = proto_item_add_subtree(VAR_9, VAR_14);
proto_tree_add_boolean(VAR_10, VAR_15, VAR_0, VAR_1, 4, VAR_5);
VAR_1 += 4;
if (VAR_10)
dissect_rpc_uint64(VAR_0, VAR_10, VAR_16, VAR_1);
VAR_1 += 8;
VAR_1 = dissect_nfs_utf8string(VAR_0, VAR_1, VAR_10, VAR_17, NULL);
VAR_1 = dissect_nfs4_fattrs(VAR_0, VAR_1, VAR_2, VAR_10, VAR_18, VAR_4);
proto_item_set_len(VAR_9, VAR_1 - VAR_12);
} else {
break;
}
}
if (VAR_8) {
proto_tree_add_boolean(VAR_8, VAR_15, VAR_0, VAR_1, 4, VAR_5);
VAR_1 += 4;
VAR_1 = dissect_rpc_bool(VAR_0, VAR_8, VAR_19, VAR_1);
} else {
VAR_1 += 8;
}
return VAR_1;
}",wireshark/ae0c38a07a64a7c002d64b31e13c349ee4919791/packet-nfs.c/vul/before/0.json,"static int
dissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo,
		     proto_tree *tree, rpc_call_info_value *civ)
{
	guint32	    val_follows;
	guint32	    name_len;
	char	   *name;
	proto_tree *dirlist_tree;
	proto_item *eitem;
	proto_tree *entry_tree;

	dirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, ""Directory Listing"");

	while (1)
	{
		val_follows = tvb_get_ntohl(tvb, offset);
		if (val_follows) {
			int start_off = offset;

			/* Make sure we have 16 bytes (value follows + cookie + name length) */
			name_len = tvb_get_ntohl(tvb, offset + 12);
			tvb_ensure_bytes_exist(tvb, offset, 16 + name_len);
			/*
			* Get the entry name and create subtree of field nfs.name
			*/
			name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);

			eitem = proto_tree_add_string_format(
				dirlist_tree, hf_nfs_name, tvb, offset, -1, name, ""Entry: %s"", name);
			entry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry);

			/* Value Follows: <Yes|No> */
			proto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);
			offset += 4;

			/* Directory entry cookie */
			if (entry_tree)
				dissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset);
			offset += 8;

			/* Directory entry name (nfs.entry_name) */
			offset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL);

			/* Attrmask(s) */
			offset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ);
			proto_item_set_len(eitem, offset - start_off);
		} else {
			break;
		}
	}
	if (dirlist_tree) {
		proto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);
		offset += 4;
		/* The last entry in this packet has been reached but do more follow? */
		offset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset);
	} else {
		offset += 8;
	}
	return offset;
}","static int
dissect_nfs4_dirlist(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2,
		     proto_tree *VAR_3, rpc_call_info_value *VAR_4)
{
	guint32	    VAR_5;
	guint32	    VAR_6;
	char	   *VAR_7;
	proto_tree *VAR_8;
	proto_item *VAR_9;
	proto_tree *VAR_10;

	VAR_8 = proto_tree_add_subtree(VAR_3, VAR_0, VAR_1, 0, VAR_11, NULL, ""Directory Listing"");

	while (1)
	{
		VAR_5 = tvb_get_ntohl(VAR_0, VAR_1);
		if (VAR_5) {
			int VAR_12 = VAR_1;

			/* COMMENT_0 */
			VAR_6 = tvb_get_ntohl(VAR_0, VAR_1 + 12);
			tvb_ensure_bytes_exist(VAR_0, VAR_1, 16 + VAR_6);
			/* COMMENT_1 */
                                                            
     
			VAR_7 = tvb_get_string_enc(wmem_packet_scope(), VAR_0, VAR_1 + 16, VAR_6, VAR_13);

			VAR_9 = proto_tree_add_string_format(
				VAR_8, VAR_14, VAR_0, VAR_1, -1, VAR_7, ""Entry: %s"", VAR_7);
			VAR_10 = proto_item_add_subtree(VAR_9, VAR_15);

			/* COMMENT_4 */
			proto_tree_add_boolean(VAR_10, VAR_16, VAR_0, VAR_1, 4, VAR_5);
			VAR_1 += 4;

			/* COMMENT_5 */
			if (VAR_10)
				dissect_rpc_uint64(VAR_0, VAR_10, VAR_17, VAR_1);
			VAR_1 += 8;

			/* COMMENT_6 */
			VAR_1 = dissect_nfs_utf8string(VAR_0, VAR_1, VAR_10, VAR_18, NULL);

			/* COMMENT_7 */
			VAR_1 = dissect_nfs4_fattrs(VAR_0, VAR_1, VAR_2, VAR_10, VAR_19, VAR_4);
			proto_item_set_len(VAR_9, VAR_1 - VAR_12);
		} else {
			break;
		}
	}
	if (VAR_8) {
		proto_tree_add_boolean(VAR_8, VAR_16, VAR_0, VAR_1, 4, VAR_5);
		VAR_1 += 4;
		/* COMMENT_8 */
		VAR_1 = dissect_rpc_bool(VAR_0, VAR_8, VAR_20, VAR_1);
	} else {
		VAR_1 += 8;
	}
	return VAR_1;
}",wireshark/ae0c38a07a64a7c002d64b31e13c349ee4919791/packet-nfs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,8 +23,7 @@
 			/*
 			* Get the entry name and create subtree of field nfs.name
 			*/
-			name = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);
-			name[name_len] = '\0';
+			name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);
 
 			eitem = proto_tree_add_string_format(
 				dirlist_tree, hf_nfs_name, tvb, offset, -1, name, ""Entry: %s"", name);","{'deleted_lines': ['\t\t\tname = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);', ""\t\t\tname[name_len] = '\\0';""], 'added_lines': ['\t\t\tname = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);']}",True,Memory leak in the NFS dissector in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file,6.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,extractCompositeRegions,"static int extractCompositeRegions(struct image_data *image,
struct crop_mask *crop,
unsigned char *read_buff,
unsigned char *crop_buff)
{
int shift_width, bytes_per_sample, bytes_per_pixel;
uint32_t i, trailing_bits, prev_trailing_bits;
uint32_t row, first_row, last_row, first_col, last_col;
uint32_t src_rowsize, dst_rowsize, src_offset, dst_offset;
uint32_t crop_width, crop_length, img_width ;
uint32_t prev_length, prev_width, composite_width;
uint16_t bps, spp;
uint8_t *src, *dst;
tsample_t count, sample = 0; 
img_width = image->width;
bps = image->bps;
spp = image->spp;
count = spp;
bytes_per_sample = (bps + 7) / 8;
bytes_per_pixel = ((bps * spp) + 7) / 8;
if ((bps % 8) == 0)
shift_width = 0;
else
{
if (bytes_per_pixel < (bytes_per_sample + 1))
shift_width = bytes_per_pixel;
else
shift_width = bytes_per_sample + 1;
}
src = read_buff;
dst = crop_buff;
prev_width = prev_length = 0;
prev_trailing_bits = trailing_bits = 0;
composite_width = crop->combined_width;
crop->combined_width = 0;
crop->combined_length = 0;
switch (crop->edge_ref)
{
default:
case EDGE_TOP:
case EDGE_BOTTOM:
for (i = 1; i < crop->selections; i++)
{
uint32_t crop_width0 =
crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;
uint32_t crop_width1 =
crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;
if (crop_width0 != crop_width1)
{
TIFFError(""extractCompositeRegions"",
""Only equal width regions can be combined for -E ""
""top or bottom"");
return (1);
}
}
break;
case EDGE_LEFT:
case EDGE_RIGHT:
for (i = 1; i < crop->selections; i++)
{
uint32_t crop_length0 =
crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;
uint32_t crop_length1 =
crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;
if (crop_length0 != crop_length1)
{
TIFFError(""extractCompositeRegions"",
""Only equal length regions can be combined for ""
""-E left or right"");
return (1);
}
}
}
for (i = 0; i < crop->selections; i++)
{
first_row = crop->regionlist[i].y1;
last_row = crop->regionlist[i].y2;
first_col = crop->regionlist[i].x1;
last_col = crop->regionlist[i].x2;
crop_width = last_col - first_col + 1;
crop_length = last_row - first_row + 1;
crop->regionlist[i].width = crop_width;
crop->regionlist[i].length = crop_length;
crop->regionlist[i].buffptr = crop_buff;
src_rowsize = ((img_width * bps * spp) + 7) / 8;
dst_rowsize = (((crop_width * bps * count) + 7) / 8);
switch (crop->edge_ref)
{
default:
case EDGE_TOP:
case EDGE_BOTTOM:
if ((crop->selections > i + 1) &&
(crop_width != crop->regionlist[i + 1].width))
{
TIFFError(""extractCompositeRegions"",
""Only equal width regions can be combined for -E ""
""top or bottom"");
return (1);
}
crop->combined_width = crop_width;
crop->combined_length += crop_length;
for (row = first_row; row <= last_row; row++)
{
src_offset = row * src_rowsize;
dst_offset = (row - first_row) * dst_rowsize;
src = read_buff + src_offset;
dst = crop_buff + dst_offset + (prev_length * dst_rowsize);
switch (shift_width)
{
case 0:
if (extractContigSamplesBytes(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 1:
if (bps == 1)
{
if (extractContigSamplesShifted8bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
default:
TIFFError(""extractCompositeRegions"",
""Unsupported bit depth %"" PRIu16, bps);
return (1);
}
}
prev_length += crop_length;
break;
case EDGE_LEFT: 
case EDGE_RIGHT:
if ((crop->selections > i + 1) &&
(crop_length != crop->regionlist[i + 1].length))
{
TIFFError(""extractCompositeRegions"",
""Only equal length regions can be combined for ""
""-E left or right"");
return (1);
}
crop->combined_width += crop_width;
crop->combined_length = crop_length;
dst_rowsize = (((composite_width * bps * count) + 7) / 8);
trailing_bits = (crop_width * bps * count) % 8;
for (row = first_row; row <= last_row; row++)
{
src_offset = row * src_rowsize;
dst_offset = (row - first_row) * dst_rowsize;
src = read_buff + src_offset;
dst = crop_buff + dst_offset + prev_width;
switch (shift_width)
{
case 0:
if (extractContigSamplesBytes(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 1:
if (bps == 1)
{
if (extractContigSamplesShifted8bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
src, dst, img_width, sample, spp, bps,
count, first_col, last_col + 1,
prev_trailing_bits))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" PRIu32,
row);
return (1);
}
break;
default:
TIFFError(""extractCompositeRegions"",
""Unsupported bit depth %"" PRIu16, bps);
return (1);
}
}
prev_width += (crop_width * bps * count) / 8;
prev_trailing_bits += trailing_bits;
if (prev_trailing_bits > 7)
prev_trailing_bits -= 8;
break;
}
}
if (crop->combined_width != composite_width)
TIFFError(""combineSeparateRegions"",
""Combined width does not match composite width"");
return (0);
}","static int extractCompositeRegions(struct image_data *VAR_0,
struct crop_mask *VAR_1,
unsigned char *VAR_2,
unsigned char *VAR_3)
{
int VAR_4, VAR_5, VAR_6;
uint32_t VAR_7, VAR_8, VAR_9;
uint32_t VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
uint32_t VAR_15, VAR_16, VAR_17, VAR_18;
uint32_t VAR_19, VAR_20, VAR_21 ;
uint32_t VAR_22, VAR_23, VAR_24;
uint16_t VAR_25, VAR_26;
uint8_t *VAR_27, *VAR_28;
tsample_t VAR_29, VAR_30 = 0; 
VAR_21 = VAR_0->width;
VAR_25 = VAR_0->bps;
VAR_26 = VAR_0->spp;
VAR_29 = VAR_26;
VAR_5 = (VAR_25 + 7) / 8;
VAR_6 = ((VAR_25 * VAR_26) + 7) / 8;
if ((VAR_25 % 8) == 0)
VAR_4 = 0;
else
{
if (VAR_6 < (VAR_5 + 1))
VAR_4 = VAR_6;
else
VAR_4 = VAR_5 + 1;
}
VAR_27 = VAR_2;
VAR_28 = VAR_3;
VAR_23 = VAR_22 = 0;
VAR_9 = VAR_8 = 0;
VAR_24 = VAR_1->combined_width;
VAR_1->combined_width = 0;
VAR_1->combined_length = 0;
switch (VAR_1->edge_ref)
{
default:
case VAR_31:
case VAR_32:
for (VAR_7 = 1; VAR_7 < VAR_1->selections; VAR_7++)
{
uint32_t VAR_33 =
VAR_1->regionlist[VAR_7 - 1].x2 - VAR_1->regionlist[VAR_7 - 1].x1 + 1;
uint32_t VAR_34 =
VAR_1->regionlist[VAR_7].x2 - VAR_1->regionlist[VAR_7].x1 + 1;
if (VAR_33 != VAR_34)
{
TIFFError(""extractCompositeRegions"",
""Only equal width regions can be combined for -E ""
""top or bottom"");
return (1);
}
}
break;
case VAR_35:
case VAR_36:
for (VAR_7 = 1; VAR_7 < VAR_1->selections; VAR_7++)
{
uint32_t VAR_37 =
VAR_1->regionlist[VAR_7 - 1].y2 - VAR_1->regionlist[VAR_7 - 1].y1 + 1;
uint32_t VAR_38 =
VAR_1->regionlist[VAR_7].y2 - VAR_1->regionlist[VAR_7].y1 + 1;
if (VAR_37 != VAR_38)
{
TIFFError(""extractCompositeRegions"",
""Only equal length regions can be combined for ""
""-E left or right"");
return (1);
}
}
}
for (VAR_7 = 0; VAR_7 < VAR_1->selections; VAR_7++)
{
VAR_11 = VAR_1->regionlist[VAR_7].y1;
VAR_12 = VAR_1->regionlist[VAR_7].y2;
VAR_13 = VAR_1->regionlist[VAR_7].x1;
VAR_14 = VAR_1->regionlist[VAR_7].x2;
VAR_19 = VAR_14 - VAR_13 + 1;
VAR_20 = VAR_12 - VAR_11 + 1;
VAR_1->regionlist[VAR_7].width = VAR_19;
VAR_1->regionlist[VAR_7].length = VAR_20;
VAR_1->regionlist[VAR_7].buffptr = VAR_3;
VAR_15 = ((VAR_21 * VAR_25 * VAR_26) + 7) / 8;
VAR_16 = (((VAR_19 * VAR_25 * VAR_29) + 7) / 8);
switch (VAR_1->edge_ref)
{
default:
case VAR_31:
case VAR_32:
if ((VAR_1->selections > VAR_7 + 1) &&
(VAR_19 != VAR_1->regionlist[VAR_7 + 1].width))
{
TIFFError(""extractCompositeRegions"",
""Only equal width regions can be combined for -E ""
""top or bottom"");
return (1);
}
VAR_1->combined_width = VAR_19;
VAR_1->combined_length += VAR_20;
for (VAR_10 = VAR_11; VAR_10 <= VAR_12; VAR_10++)
{
VAR_17 = VAR_10 * VAR_15;
VAR_18 = (VAR_10 - VAR_11) * VAR_16;
VAR_27 = VAR_2 + VAR_17;
VAR_28 = VAR_3 + VAR_18 + (VAR_22 * VAR_16);
switch (VAR_4)
{
case 0:
if (extractContigSamplesBytes(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 1:
if (VAR_25 == 1)
{
if (extractContigSamplesShifted8bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
default:
TIFFError(""extractCompositeRegions"",
""Unsupported bit depth %"" VAR_40, VAR_25);
return (1);
}
}
VAR_22 += VAR_20;
break;
case VAR_35: 
case VAR_36:
if ((VAR_1->selections > VAR_7 + 1) &&
(VAR_20 != VAR_1->regionlist[VAR_7 + 1].length))
{
TIFFError(""extractCompositeRegions"",
""Only equal length regions can be combined for ""
""-E left or right"");
return (1);
}
VAR_1->combined_width += VAR_19;
VAR_1->combined_length = VAR_20;
VAR_16 = (((VAR_24 * VAR_25 * VAR_29) + 7) / 8);
VAR_8 = (VAR_19 * VAR_25 * VAR_29) % 8;
for (VAR_10 = VAR_11; VAR_10 <= VAR_12; VAR_10++)
{
VAR_17 = VAR_10 * VAR_15;
VAR_18 = (VAR_10 - VAR_11) * VAR_16;
VAR_27 = VAR_2 + VAR_17;
VAR_28 = VAR_3 + VAR_18 + VAR_23;
switch (VAR_4)
{
case 0:
if (extractContigSamplesBytes(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 1:
if (VAR_25 == 1)
{
if (extractContigSamplesShifted8bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
VAR_29, VAR_13, VAR_14 + 1,
VAR_9))
{
TIFFError(""extractCompositeRegions"",
""Unable to extract row %"" VAR_39,
VAR_10);
return (1);
}
break;
default:
TIFFError(""extractCompositeRegions"",
""Unsupported bit depth %"" VAR_40, VAR_25);
return (1);
}
}
VAR_23 += (VAR_19 * VAR_25 * VAR_29) / 8;
VAR_9 += VAR_8;
if (VAR_9 > 7)
VAR_9 -= 8;
break;
}
}
if (VAR_1->combined_width != VAR_24)
TIFFError(""combineSeparateRegions"",
""Combined width does not match composite width"");
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/0.json,"static int extractCompositeRegions(struct image_data *image,
                                   struct crop_mask *crop,
                                   unsigned char *read_buff,
                                   unsigned char *crop_buff)
{
    int shift_width, bytes_per_sample, bytes_per_pixel;
    uint32_t i, trailing_bits, prev_trailing_bits;
    uint32_t row, first_row, last_row, first_col, last_col;
    uint32_t src_rowsize, dst_rowsize, src_offset, dst_offset;
    uint32_t crop_width, crop_length, img_width /*, img_length */;
    uint32_t prev_length, prev_width, composite_width;
    uint16_t bps, spp;
    uint8_t *src, *dst;
    tsample_t count, sample = 0; /* Update to extract one or more samples */

    img_width = image->width;
    /* img_length = image->length; */
    bps = image->bps;
    spp = image->spp;
    count = spp;

    bytes_per_sample = (bps + 7) / 8;
    bytes_per_pixel = ((bps * spp) + 7) / 8;
    if ((bps % 8) == 0)
        shift_width = 0;
    else
    {
        if (bytes_per_pixel < (bytes_per_sample + 1))
            shift_width = bytes_per_pixel;
        else
            shift_width = bytes_per_sample + 1;
    }
    src = read_buff;
    dst = crop_buff;

    /* These are setup for adding additional sections */
    prev_width = prev_length = 0;
    prev_trailing_bits = trailing_bits = 0;
    composite_width = crop->combined_width;
    crop->combined_width = 0;
    crop->combined_length = 0;

    /* If there is more than one region, check beforehand whether all the width
     * and length values of the regions are the same, respectively. */
    switch (crop->edge_ref)
    {
        default:
        case EDGE_TOP:
        case EDGE_BOTTOM:
            for (i = 1; i < crop->selections; i++)
            {
                uint32_t crop_width0 =
                    crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;
                uint32_t crop_width1 =
                    crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;
                if (crop_width0 != crop_width1)
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal width regions can be combined for -E ""
                              ""top or bottom"");
                    return (1);
                }
            }
            break;
        case EDGE_LEFT:
        case EDGE_RIGHT:
            for (i = 1; i < crop->selections; i++)
            {
                uint32_t crop_length0 =
                    crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;
                uint32_t crop_length1 =
                    crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;
                if (crop_length0 != crop_length1)
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal length regions can be combined for ""
                              ""-E left or right"");
                    return (1);
                }
            }
    }

    for (i = 0; i < crop->selections; i++)
    {
        /* rows, columns, width, length are expressed in pixels */
        first_row = crop->regionlist[i].y1;
        last_row = crop->regionlist[i].y2;
        first_col = crop->regionlist[i].x1;
        last_col = crop->regionlist[i].x2;

        crop_width = last_col - first_col + 1;
        crop_length = last_row - first_row + 1;

        /* These should not be needed for composite images */
        crop->regionlist[i].width = crop_width;
        crop->regionlist[i].length = crop_length;

        src_rowsize = ((img_width * bps * spp) + 7) / 8;
        dst_rowsize = (((crop_width * bps * count) + 7) / 8);

        switch (crop->edge_ref)
        {
            default:
            case EDGE_TOP:
            case EDGE_BOTTOM:
                if ((crop->selections > i + 1) &&
                    (crop_width != crop->regionlist[i + 1].width))
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal width regions can be combined for -E ""
                              ""top or bottom"");
                    return (1);
                }

                crop->combined_width = crop_width;
                crop->combined_length += crop_length;

                for (row = first_row; row <= last_row; row++)
                {
                    src_offset = row * src_rowsize;
                    dst_offset = (row - first_row) * dst_rowsize;
                    src = read_buff + src_offset;
                    dst = crop_buff + dst_offset + (prev_length * dst_rowsize);
                    switch (shift_width)
                    {
                        case 0:
                            if (extractContigSamplesBytes(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 1:
                            if (bps == 1)
                            {
                                if (extractContigSamplesShifted8bits(
                                        src, dst, img_width, sample, spp, bps,
                                        count, first_col, last_col + 1,
                                        prev_trailing_bits))
                                {
                                    TIFFError(""extractCompositeRegions"",
                                              ""Unable to extract row %"" PRIu32,
                                              row);
                                    return (1);
                                }
                                break;
                            }
                            else if (extractContigSamplesShifted16bits(
                                         src, dst, img_width, sample, spp, bps,
                                         count, first_col, last_col + 1,
                                         prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 2:
                            if (extractContigSamplesShifted24bits(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1,
                                    prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (extractContigSamplesShifted32bits(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1,
                                    prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        default:
                            TIFFError(""extractCompositeRegions"",
                                      ""Unsupported bit depth %"" PRIu16, bps);
                            return (1);
                    }
                }
                prev_length += crop_length;
                break;
            case EDGE_LEFT: /* splice the pieces of each row together, side by
                               side */
            case EDGE_RIGHT:
                if ((crop->selections > i + 1) &&
                    (crop_length != crop->regionlist[i + 1].length))
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal length regions can be combined for ""
                              ""-E left or right"");
                    return (1);
                }
                crop->combined_width += crop_width;
                crop->combined_length = crop_length;
                dst_rowsize = (((composite_width * bps * count) + 7) / 8);
                trailing_bits = (crop_width * bps * count) % 8;
                for (row = first_row; row <= last_row; row++)
                {
                    src_offset = row * src_rowsize;
                    dst_offset = (row - first_row) * dst_rowsize;
                    src = read_buff + src_offset;
                    dst = crop_buff + dst_offset + prev_width;

                    switch (shift_width)
                    {
                        case 0:
                            if (extractContigSamplesBytes(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 1:
                            if (bps == 1)
                            {
                                if (extractContigSamplesShifted8bits(
                                        src, dst, img_width, sample, spp, bps,
                                        count, first_col, last_col + 1,
                                        prev_trailing_bits))
                                {
                                    TIFFError(""extractCompositeRegions"",
                                              ""Unable to extract row %"" PRIu32,
                                              row);
                                    return (1);
                                }
                                break;
                            }
                            else if (extractContigSamplesShifted16bits(
                                         src, dst, img_width, sample, spp, bps,
                                         count, first_col, last_col + 1,
                                         prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 2:
                            if (extractContigSamplesShifted24bits(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1,
                                    prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (extractContigSamplesShifted32bits(
                                    src, dst, img_width, sample, spp, bps,
                                    count, first_col, last_col + 1,
                                    prev_trailing_bits))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" PRIu32,
                                          row);
                                return (1);
                            }
                            break;
                        default:
                            TIFFError(""extractCompositeRegions"",
                                      ""Unsupported bit depth %"" PRIu16, bps);
                            return (1);
                    }
                }
                prev_width += (crop_width * bps * count) / 8;
                prev_trailing_bits += trailing_bits;
                if (prev_trailing_bits > 7)
                    prev_trailing_bits -= 8;
                break;
        }
    }
    if (crop->combined_width != composite_width)
        TIFFError(""combineSeparateRegions"",
                  ""Combined width does not match composite width"");

    return (0);
}","static int extractCompositeRegions(struct image_data *VAR_0,
                                   struct crop_mask *VAR_1,
                                   unsigned char *VAR_2,
                                   unsigned char *VAR_3)
{
    int VAR_4, VAR_5, VAR_6;
    uint32_t VAR_7, VAR_8, VAR_9;
    uint32_t VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
    uint32_t VAR_15, VAR_16, VAR_17, VAR_18;
    uint32_t VAR_19, VAR_20, VAR_21 /* COMMENT_0 */;
    uint32_t VAR_22, VAR_23, VAR_24;
    uint16_t VAR_25, VAR_26;
    uint8_t *VAR_27, *VAR_28;
    tsample_t VAR_29, VAR_30 = 0; /* COMMENT_1 */

    VAR_21 = VAR_0->width;
    /* COMMENT_2 */
    VAR_25 = VAR_0->bps;
    VAR_26 = VAR_0->spp;
    VAR_29 = VAR_26;

    VAR_5 = (VAR_25 + 7) / 8;
    VAR_6 = ((VAR_25 * VAR_26) + 7) / 8;
    if ((VAR_25 % 8) == 0)
        VAR_4 = 0;
    else
    {
        if (VAR_6 < (VAR_5 + 1))
            VAR_4 = VAR_6;
        else
            VAR_4 = VAR_5 + 1;
    }
    VAR_27 = VAR_2;
    VAR_28 = VAR_3;

    /* COMMENT_3 */
    VAR_23 = VAR_22 = 0;
    VAR_9 = VAR_8 = 0;
    VAR_24 = VAR_1->combined_width;
    VAR_1->combined_width = 0;
    VAR_1->combined_length = 0;

    /* COMMENT_4 */
                                                                      
    switch (VAR_1->edge_ref)
    {
        default:
        case VAR_31:
        case VAR_32:
            for (VAR_7 = 1; VAR_7 < VAR_1->selections; VAR_7++)
            {
                uint32_t VAR_33 =
                    VAR_1->regionlist[VAR_7 - 1].x2 - VAR_1->regionlist[VAR_7 - 1].x1 + 1;
                uint32_t VAR_34 =
                    VAR_1->regionlist[VAR_7].x2 - VAR_1->regionlist[VAR_7].x1 + 1;
                if (VAR_33 != VAR_34)
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal width regions can be combined for -E ""
                              ""top or bottom"");
                    return (1);
                }
            }
            break;
        case VAR_35:
        case VAR_36:
            for (VAR_7 = 1; VAR_7 < VAR_1->selections; VAR_7++)
            {
                uint32_t VAR_37 =
                    VAR_1->regionlist[VAR_7 - 1].y2 - VAR_1->regionlist[VAR_7 - 1].y1 + 1;
                uint32_t VAR_38 =
                    VAR_1->regionlist[VAR_7].y2 - VAR_1->regionlist[VAR_7].y1 + 1;
                if (VAR_37 != VAR_38)
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal length regions can be combined for ""
                              ""-E left or right"");
                    return (1);
                }
            }
    }

    for (VAR_7 = 0; VAR_7 < VAR_1->selections; VAR_7++)
    {
        /* COMMENT_6 */
        VAR_11 = VAR_1->regionlist[VAR_7].y1;
        VAR_12 = VAR_1->regionlist[VAR_7].y2;
        VAR_13 = VAR_1->regionlist[VAR_7].x1;
        VAR_14 = VAR_1->regionlist[VAR_7].x2;

        VAR_19 = VAR_14 - VAR_13 + 1;
        VAR_20 = VAR_12 - VAR_11 + 1;

        /* COMMENT_7 */
        VAR_1->regionlist[VAR_7].width = VAR_19;
        VAR_1->regionlist[VAR_7].length = VAR_20;

        VAR_15 = ((VAR_21 * VAR_25 * VAR_26) + 7) / 8;
        VAR_16 = (((VAR_19 * VAR_25 * VAR_29) + 7) / 8);

        switch (VAR_1->edge_ref)
        {
            default:
            case VAR_31:
            case VAR_32:
                if ((VAR_1->selections > VAR_7 + 1) &&
                    (VAR_19 != VAR_1->regionlist[VAR_7 + 1].width))
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal width regions can be combined for -E ""
                              ""top or bottom"");
                    return (1);
                }

                VAR_1->combined_width = VAR_19;
                VAR_1->combined_length += VAR_20;

                for (VAR_10 = VAR_11; VAR_10 <= VAR_12; VAR_10++)
                {
                    VAR_17 = VAR_10 * VAR_15;
                    VAR_18 = (VAR_10 - VAR_11) * VAR_16;
                    VAR_27 = VAR_2 + VAR_17;
                    VAR_28 = VAR_3 + VAR_18 + (VAR_22 * VAR_16);
                    switch (VAR_4)
                    {
                        case 0:
                            if (extractContigSamplesBytes(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 1:
                            if (VAR_25 == 1)
                            {
                                if (extractContigSamplesShifted8bits(
                                        VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                        VAR_29, VAR_13, VAR_14 + 1,
                                        VAR_9))
                                {
                                    TIFFError(""extractCompositeRegions"",
                                              ""Unable to extract row %"" VAR_39,
                                              VAR_10);
                                    return (1);
                                }
                                break;
                            }
                            else if (extractContigSamplesShifted16bits(
                                         VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                         VAR_29, VAR_13, VAR_14 + 1,
                                         VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 2:
                            if (extractContigSamplesShifted24bits(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1,
                                    VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (extractContigSamplesShifted32bits(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1,
                                    VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        default:
                            TIFFError(""extractCompositeRegions"",
                                      ""Unsupported bit depth %"" VAR_40, VAR_25);
                            return (1);
                    }
                }
                VAR_22 += VAR_20;
                break;
            case VAR_35: /* COMMENT_8 */
                                      
            case VAR_36:
                if ((VAR_1->selections > VAR_7 + 1) &&
                    (VAR_20 != VAR_1->regionlist[VAR_7 + 1].length))
                {
                    TIFFError(""extractCompositeRegions"",
                              ""Only equal length regions can be combined for ""
                              ""-E left or right"");
                    return (1);
                }
                VAR_1->combined_width += VAR_19;
                VAR_1->combined_length = VAR_20;
                VAR_16 = (((VAR_24 * VAR_25 * VAR_29) + 7) / 8);
                VAR_8 = (VAR_19 * VAR_25 * VAR_29) % 8;
                for (VAR_10 = VAR_11; VAR_10 <= VAR_12; VAR_10++)
                {
                    VAR_17 = VAR_10 * VAR_15;
                    VAR_18 = (VAR_10 - VAR_11) * VAR_16;
                    VAR_27 = VAR_2 + VAR_17;
                    VAR_28 = VAR_3 + VAR_18 + VAR_23;

                    switch (VAR_4)
                    {
                        case 0:
                            if (extractContigSamplesBytes(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 1:
                            if (VAR_25 == 1)
                            {
                                if (extractContigSamplesShifted8bits(
                                        VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                        VAR_29, VAR_13, VAR_14 + 1,
                                        VAR_9))
                                {
                                    TIFFError(""extractCompositeRegions"",
                                              ""Unable to extract row %"" VAR_39,
                                              VAR_10);
                                    return (1);
                                }
                                break;
                            }
                            else if (extractContigSamplesShifted16bits(
                                         VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                         VAR_29, VAR_13, VAR_14 + 1,
                                         VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 2:
                            if (extractContigSamplesShifted24bits(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1,
                                    VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (extractContigSamplesShifted32bits(
                                    VAR_27, VAR_28, VAR_21, VAR_30, VAR_26, VAR_25,
                                    VAR_29, VAR_13, VAR_14 + 1,
                                    VAR_9))
                            {
                                TIFFError(""extractCompositeRegions"",
                                          ""Unable to extract row %"" VAR_39,
                                          VAR_10);
                                return (1);
                            }
                            break;
                        default:
                            TIFFError(""extractCompositeRegions"",
                                      ""Unsupported bit depth %"" VAR_40, VAR_25);
                            return (1);
                    }
                }
                VAR_23 += (VAR_19 * VAR_25 * VAR_29) / 8;
                VAR_9 += VAR_8;
                if (VAR_9 > 7)
                    VAR_9 -= 8;
                break;
        }
    }
    if (VAR_1->combined_width != VAR_24)
        TIFFError(""combineSeparateRegions"",
                  ""Combined width does not match composite width"");

    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -94,7 +94,6 @@
         /* These should not be needed for composite images */
         crop->regionlist[i].width = crop_width;
         crop->regionlist[i].length = crop_length;
-        crop->regionlist[i].buffptr = crop_buff;
 
         src_rowsize = ((img_width * bps * spp) + 7) / 8;
         dst_rowsize = (((crop_width * bps * count) + 7) / 8);","{'deleted_lines': ['        crop->regionlist[i].buffptr = crop_buff;'], 'added_lines': []}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,correct_orientation,"static int correct_orientation(struct image_data *image,
unsigned char **work_buff_ptr)
{
uint16_t mirror, rotation;
unsigned char *work_buff;
work_buff = *work_buff_ptr;
if ((image == NULL) || (work_buff == NULL))
{
TIFFError(""correct_orientatin"", ""Invalid image or buffer pointer"");
return (-1);
}
if ((image->adjustments & MIRROR_HORIZ) ||
(image->adjustments & MIRROR_VERT))
{
mirror = (uint16_t)(image->adjustments & MIRROR_BOTH);
if (mirrorImage(image->spp, image->bps, mirror, image->width,
image->length, work_buff))
{
TIFFError(""correct_orientation"", ""Unable to mirror image"");
return (-1);
}
}
if (image->adjustments & ROTATE_ANY)
{
if (image->adjustments & ROTATECW_90)
rotation = (uint16_t)90;
else if (image->adjustments & ROTATECW_180)
rotation = (uint16_t)180;
else if (image->adjustments & ROTATECW_270)
rotation = (uint16_t)270;
else
{
TIFFError(""correct_orientation"", ""Invalid rotation value: %"" PRIu16,
(uint16_t)(image->adjustments & ROTATE_ANY));
return (-1);
}
if (rotateImage(rotation, image, &image->width, &image->length,
work_buff_ptr, NULL))
{
TIFFError(""correct_orientation"", ""Unable to rotate image"");
return (-1);
}
image->orientation = ORIENTATION_TOPLEFT;
}
return (0);
}","static int correct_orientation(struct image_data *VAR_0,
unsigned char **VAR_1)
{
uint16_t VAR_2, VAR_3;
unsigned char *VAR_4;
VAR_4 = *VAR_1;
if ((VAR_0 == NULL) || (VAR_4 == NULL))
{
TIFFError(""correct_orientatin"", ""Invalid image or buffer pointer"");
return (-1);
}
if ((VAR_0->adjustments & VAR_5) ||
(VAR_0->adjustments & VAR_6))
{
VAR_2 = (uint16_t)(VAR_0->adjustments & VAR_7);
if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_2, VAR_0->width,
VAR_0->length, VAR_4))
{
TIFFError(""correct_orientation"", ""Unable to mirror image"");
return (-1);
}
}
if (VAR_0->adjustments & VAR_8)
{
if (VAR_0->adjustments & VAR_9)
VAR_3 = (uint16_t)90;
else if (VAR_0->adjustments & VAR_10)
VAR_3 = (uint16_t)180;
else if (VAR_0->adjustments & VAR_11)
VAR_3 = (uint16_t)270;
else
{
TIFFError(""correct_orientation"", ""Invalid rotation value: %"" VAR_12,
(uint16_t)(VAR_0->adjustments & VAR_8));
return (-1);
}
if (rotateImage(VAR_3, VAR_0, &VAR_0->width, &VAR_0->length,
VAR_1, NULL))
{
TIFFError(""correct_orientation"", ""Unable to rotate image"");
return (-1);
}
VAR_0->orientation = VAR_13;
}
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/1.json,"static int correct_orientation(struct image_data *image,
                               unsigned char **work_buff_ptr)
{
    uint16_t mirror, rotation;
    unsigned char *work_buff;

    work_buff = *work_buff_ptr;
    if ((image == NULL) || (work_buff == NULL))
    {
        TIFFError(""correct_orientatin"", ""Invalid image or buffer pointer"");
        return (-1);
    }

    if ((image->adjustments & MIRROR_HORIZ) ||
        (image->adjustments & MIRROR_VERT))
    {
        mirror = (uint16_t)(image->adjustments & MIRROR_BOTH);
        if (mirrorImage(image->spp, image->bps, mirror, image->width,
                        image->length, work_buff))
        {
            TIFFError(""correct_orientation"", ""Unable to mirror image"");
            return (-1);
        }
    }

    if (image->adjustments & ROTATE_ANY)
    {
        if (image->adjustments & ROTATECW_90)
            rotation = (uint16_t)90;
        else if (image->adjustments & ROTATECW_180)
            rotation = (uint16_t)180;
        else if (image->adjustments & ROTATECW_270)
            rotation = (uint16_t)270;
        else
        {
            TIFFError(""correct_orientation"", ""Invalid rotation value: %"" PRIu16,
                      (uint16_t)(image->adjustments & ROTATE_ANY));
            return (-1);
        }
        /* Dummy variable in order not to switch two times the
         * image->width,->length within rotateImage(),
         * but switch xres, yres there. */
        uint32_t width = image->width;
        uint32_t length = image->length;
        if (rotateImage(rotation, image, &width, &length, work_buff_ptr, NULL,
                        TRUE))
        {
            TIFFError(""correct_orientation"", ""Unable to rotate image"");
            return (-1);
        }
        image->orientation = ORIENTATION_TOPLEFT;
    }

    return (0);
}","static int correct_orientation(struct image_data *VAR_0,
                               unsigned char **VAR_1)
{
    uint16_t VAR_2, VAR_3;
    unsigned char *VAR_4;

    VAR_4 = *VAR_1;
    if ((VAR_0 == NULL) || (VAR_4 == NULL))
    {
        TIFFError(""correct_orientatin"", ""Invalid image or buffer pointer"");
        return (-1);
    }

    if ((VAR_0->adjustments & VAR_5) ||
        (VAR_0->adjustments & VAR_6))
    {
        VAR_2 = (uint16_t)(VAR_0->adjustments & VAR_7);
        if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_2, VAR_0->width,
                        VAR_0->length, VAR_4))
        {
            TIFFError(""correct_orientation"", ""Unable to mirror image"");
            return (-1);
        }
    }

    if (VAR_0->adjustments & VAR_8)
    {
        if (VAR_0->adjustments & VAR_9)
            VAR_3 = (uint16_t)90;
        else if (VAR_0->adjustments & VAR_10)
            VAR_3 = (uint16_t)180;
        else if (VAR_0->adjustments & VAR_11)
            VAR_3 = (uint16_t)270;
        else
        {
            TIFFError(""correct_orientation"", ""Invalid rotation value: %"" VAR_12,
                      (uint16_t)(VAR_0->adjustments & VAR_8));
            return (-1);
        }
        /* COMMENT_0 */
                                                      
                                          
        uint32_t VAR_13 = VAR_0->width;
        uint32_t VAR_14 = VAR_0->length;
        if (rotateImage(VAR_3, VAR_0, &VAR_13, &VAR_14, VAR_1, NULL,
                        TRUE))
        {
            TIFFError(""correct_orientation"", ""Unable to rotate image"");
            return (-1);
        }
        VAR_0->orientation = VAR_15;
    }

    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -37,9 +37,13 @@
                       (uint16_t)(image->adjustments & ROTATE_ANY));
             return (-1);
         }
-
-        if (rotateImage(rotation, image, &image->width, &image->length,
-                        work_buff_ptr, NULL))
+        /* Dummy variable in order not to switch two times the
+         * image->width,->length within rotateImage(),
+         * but switch xres, yres there. */
+        uint32_t width = image->width;
+        uint32_t length = image->length;
+        if (rotateImage(rotation, image, &width, &length, work_buff_ptr, NULL,
+                        TRUE))
         {
             TIFFError(""correct_orientation"", ""Unable to rotate image"");
             return (-1);","{'deleted_lines': ['', '        if (rotateImage(rotation, image, &image->width, &image->length,', '                        work_buff_ptr, NULL))'], 'added_lines': ['        /* Dummy variable in order not to switch two times the', '         * image->width,->length within rotateImage(),', '         * but switch xres, yres there. */', '        uint32_t width = image->width;', '        uint32_t length = image->length;', '        if (rotateImage(rotation, image, &width, &length, work_buff_ptr, NULL,', '                        TRUE))']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,extractSeparateRegion,"static int extractSeparateRegion(struct image_data *image,
struct crop_mask *crop,
unsigned char *read_buff,
unsigned char *crop_buff, int region)
{
int shift_width, prev_trailing_bits = 0;
uint32_t bytes_per_sample, bytes_per_pixel;
uint32_t src_rowsize, dst_rowsize;
uint32_t row, first_row, last_row, first_col, last_col;
uint32_t src_offset, dst_offset;
uint32_t crop_width, crop_length, img_width ;
uint16_t bps, spp;
uint8_t *src, *dst;
tsample_t count, sample = 0; 
img_width = image->width;
bps = image->bps;
spp = image->spp;
count = spp;
bytes_per_sample = (bps + 7) / 8;
bytes_per_pixel = ((bps * spp) + 7) / 8;
if ((bps % 8) == 0)
shift_width = 0; 
else
{
if (bytes_per_pixel < (bytes_per_sample + 1))
shift_width = bytes_per_pixel;
else
shift_width = bytes_per_sample + 1;
}
first_row = crop->regionlist[region].y1;
last_row = crop->regionlist[region].y2;
first_col = crop->regionlist[region].x1;
last_col = crop->regionlist[region].x2;
crop_width = last_col - first_col + 1;
crop_length = last_row - first_row + 1;
crop->regionlist[region].width = crop_width;
crop->regionlist[region].length = crop_length;
crop->regionlist[region].buffptr = crop_buff;
src = read_buff;
dst = crop_buff;
src_rowsize = ((img_width * bps * spp) + 7) / 8;
dst_rowsize = (((crop_width * bps * spp) + 7) / 8);
for (row = first_row; row <= last_row; row++)
{
src_offset = row * src_rowsize;
dst_offset = (row - first_row) * dst_rowsize;
src = read_buff + src_offset;
dst = crop_buff + dst_offset;
switch (shift_width)
{
case 0:
if (extractContigSamplesBytes(src, dst, img_width, sample, spp,
bps, count, first_col,
last_col + 1))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" PRIu32, row);
return (1);
}
break;
case 1:
if (bps == 1)
{
if (extractContigSamplesShifted8bits(
src, dst, img_width, sample, spp, bps, count,
first_col, last_col + 1, prev_trailing_bits))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" PRIu32, row);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
src, dst, img_width, sample, spp, bps, count,
first_col, last_col + 1, prev_trailing_bits))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" PRIu32, row);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
src, dst, img_width, sample, spp, bps, count, first_col,
last_col + 1, prev_trailing_bits))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" PRIu32, row);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
src, dst, img_width, sample, spp, bps, count, first_col,
last_col + 1, prev_trailing_bits))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" PRIu32, row);
return (1);
}
break;
default:
TIFFError(""extractSeparateRegion"",
""Unsupported bit depth %"" PRIu16, bps);
return (1);
}
}
return (0);
}","static int extractSeparateRegion(struct image_data *VAR_0,
struct crop_mask *VAR_1,
unsigned char *VAR_2,
unsigned char *VAR_3, int VAR_4)
{
int VAR_5, VAR_6 = 0;
uint32_t VAR_7, VAR_8;
uint32_t VAR_9, VAR_10;
uint32_t VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;
uint32_t VAR_16, VAR_17;
uint32_t VAR_18, VAR_19, VAR_20 ;
uint16_t VAR_21, VAR_22;
uint8_t *VAR_23, *VAR_24;
tsample_t VAR_25, VAR_26 = 0; 
VAR_20 = VAR_0->width;
VAR_21 = VAR_0->bps;
VAR_22 = VAR_0->spp;
VAR_25 = VAR_22;
VAR_7 = (VAR_21 + 7) / 8;
VAR_8 = ((VAR_21 * VAR_22) + 7) / 8;
if ((VAR_21 % 8) == 0)
VAR_5 = 0; 
else
{
if (VAR_8 < (VAR_7 + 1))
VAR_5 = VAR_8;
else
VAR_5 = VAR_7 + 1;
}
VAR_12 = VAR_1->regionlist[VAR_4].y1;
VAR_13 = VAR_1->regionlist[VAR_4].y2;
VAR_14 = VAR_1->regionlist[VAR_4].x1;
VAR_15 = VAR_1->regionlist[VAR_4].x2;
VAR_18 = VAR_15 - VAR_14 + 1;
VAR_19 = VAR_13 - VAR_12 + 1;
VAR_1->regionlist[VAR_4].width = VAR_18;
VAR_1->regionlist[VAR_4].length = VAR_19;
VAR_1->regionlist[VAR_4].buffptr = VAR_3;
VAR_23 = VAR_2;
VAR_24 = VAR_3;
VAR_9 = ((VAR_20 * VAR_21 * VAR_22) + 7) / 8;
VAR_10 = (((VAR_18 * VAR_21 * VAR_22) + 7) / 8);
for (VAR_11 = VAR_12; VAR_11 <= VAR_13; VAR_11++)
{
VAR_16 = VAR_11 * VAR_9;
VAR_17 = (VAR_11 - VAR_12) * VAR_10;
VAR_23 = VAR_2 + VAR_16;
VAR_24 = VAR_3 + VAR_17;
switch (VAR_5)
{
case 0:
if (extractContigSamplesBytes(VAR_23, VAR_24, VAR_20, VAR_26, VAR_22,
VAR_21, VAR_25, VAR_14,
VAR_15 + 1))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" VAR_27, VAR_11);
return (1);
}
break;
case 1:
if (VAR_21 == 1)
{
if (extractContigSamplesShifted8bits(
VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25,
VAR_14, VAR_15 + 1, VAR_6))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" VAR_27, VAR_11);
return (1);
}
break;
}
else if (extractContigSamplesShifted16bits(
VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25,
VAR_14, VAR_15 + 1, VAR_6))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" VAR_27, VAR_11);
return (1);
}
break;
case 2:
if (extractContigSamplesShifted24bits(
VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25, VAR_14,
VAR_15 + 1, VAR_6))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" VAR_27, VAR_11);
return (1);
}
break;
case 3:
case 4:
case 5:
if (extractContigSamplesShifted32bits(
VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25, VAR_14,
VAR_15 + 1, VAR_6))
{
TIFFError(""extractSeparateRegion"",
""Unable to extract row %"" VAR_27, VAR_11);
return (1);
}
break;
default:
TIFFError(""extractSeparateRegion"",
""Unsupported bit depth %"" VAR_28, VAR_21);
return (1);
}
}
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/2.json,"static int extractSeparateRegion(struct image_data *image,
                                 struct crop_mask *crop,
                                 unsigned char *read_buff,
                                 unsigned char *crop_buff, int region)
{
    int shift_width, prev_trailing_bits = 0;
    uint32_t bytes_per_sample, bytes_per_pixel;
    uint32_t src_rowsize, dst_rowsize;
    uint32_t row, first_row, last_row, first_col, last_col;
    uint32_t src_offset, dst_offset;
    uint32_t crop_width, crop_length, img_width /*, img_length */;
    uint16_t bps, spp;
    uint8_t *src, *dst;
    tsample_t count, sample = 0; /* Update to extract more or more samples */

    img_width = image->width;
    /* img_length = image->length; */
    bps = image->bps;
    spp = image->spp;
    count = spp;

    bytes_per_sample = (bps + 7) / 8;
    bytes_per_pixel = ((bps * spp) + 7) / 8;
    if ((bps % 8) == 0)
        shift_width = 0; /* Byte aligned data only */
    else
    {
        if (bytes_per_pixel < (bytes_per_sample + 1))
            shift_width = bytes_per_pixel;
        else
            shift_width = bytes_per_sample + 1;
    }

    /* rows, columns, width, length are expressed in pixels */
    first_row = crop->regionlist[region].y1;
    last_row = crop->regionlist[region].y2;
    first_col = crop->regionlist[region].x1;
    last_col = crop->regionlist[region].x2;

    crop_width = last_col - first_col + 1;
    crop_length = last_row - first_row + 1;

    crop->regionlist[region].width = crop_width;
    crop->regionlist[region].length = crop_length;

    src = read_buff;
    dst = crop_buff;
    src_rowsize = ((img_width * bps * spp) + 7) / 8;
    dst_rowsize = (((crop_width * bps * spp) + 7) / 8);

    for (row = first_row; row <= last_row; row++)
    {
        src_offset = row * src_rowsize;
        dst_offset = (row - first_row) * dst_rowsize;
        src = read_buff + src_offset;
        dst = crop_buff + dst_offset;

        switch (shift_width)
        {
            case 0:
                if (extractContigSamplesBytes(src, dst, img_width, sample, spp,
                                              bps, count, first_col,
                                              last_col + 1))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" PRIu32, row);
                    return (1);
                }
                break;
            case 1:
                if (bps == 1)
                {
                    if (extractContigSamplesShifted8bits(
                            src, dst, img_width, sample, spp, bps, count,
                            first_col, last_col + 1, prev_trailing_bits))
                    {
                        TIFFError(""extractSeparateRegion"",
                                  ""Unable to extract row %"" PRIu32, row);
                        return (1);
                    }
                    break;
                }
                else if (extractContigSamplesShifted16bits(
                             src, dst, img_width, sample, spp, bps, count,
                             first_col, last_col + 1, prev_trailing_bits))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" PRIu32, row);
                    return (1);
                }
                break;
            case 2:
                if (extractContigSamplesShifted24bits(
                        src, dst, img_width, sample, spp, bps, count, first_col,
                        last_col + 1, prev_trailing_bits))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" PRIu32, row);
                    return (1);
                }
                break;
            case 3:
            case 4:
            case 5:
                if (extractContigSamplesShifted32bits(
                        src, dst, img_width, sample, spp, bps, count, first_col,
                        last_col + 1, prev_trailing_bits))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" PRIu32, row);
                    return (1);
                }
                break;
            default:
                TIFFError(""extractSeparateRegion"",
                          ""Unsupported bit depth %"" PRIu16, bps);
                return (1);
        }
    }

    return (0);
}","static int extractSeparateRegion(struct image_data *VAR_0,
                                 struct crop_mask *VAR_1,
                                 unsigned char *VAR_2,
                                 unsigned char *VAR_3, int VAR_4)
{
    int VAR_5, VAR_6 = 0;
    uint32_t VAR_7, VAR_8;
    uint32_t VAR_9, VAR_10;
    uint32_t VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;
    uint32_t VAR_16, VAR_17;
    uint32_t VAR_18, VAR_19, VAR_20 /* COMMENT_0 */;
    uint16_t VAR_21, VAR_22;
    uint8_t *VAR_23, *VAR_24;
    tsample_t VAR_25, VAR_26 = 0; /* COMMENT_1 */

    VAR_20 = VAR_0->width;
    /* COMMENT_2 */
    VAR_21 = VAR_0->bps;
    VAR_22 = VAR_0->spp;
    VAR_25 = VAR_22;

    VAR_7 = (VAR_21 + 7) / 8;
    VAR_8 = ((VAR_21 * VAR_22) + 7) / 8;
    if ((VAR_21 % 8) == 0)
        VAR_5 = 0; /* COMMENT_3 */
    else
    {
        if (VAR_8 < (VAR_7 + 1))
            VAR_5 = VAR_8;
        else
            VAR_5 = VAR_7 + 1;
    }

    /* COMMENT_4 */
    VAR_12 = VAR_1->regionlist[VAR_4].y1;
    VAR_13 = VAR_1->regionlist[VAR_4].y2;
    VAR_14 = VAR_1->regionlist[VAR_4].x1;
    VAR_15 = VAR_1->regionlist[VAR_4].x2;

    VAR_18 = VAR_15 - VAR_14 + 1;
    VAR_19 = VAR_13 - VAR_12 + 1;

    VAR_1->regionlist[VAR_4].width = VAR_18;
    VAR_1->regionlist[VAR_4].length = VAR_19;

    VAR_23 = VAR_2;
    VAR_24 = VAR_3;
    VAR_9 = ((VAR_20 * VAR_21 * VAR_22) + 7) / 8;
    VAR_10 = (((VAR_18 * VAR_21 * VAR_22) + 7) / 8);

    for (VAR_11 = VAR_12; VAR_11 <= VAR_13; VAR_11++)
    {
        VAR_16 = VAR_11 * VAR_9;
        VAR_17 = (VAR_11 - VAR_12) * VAR_10;
        VAR_23 = VAR_2 + VAR_16;
        VAR_24 = VAR_3 + VAR_17;

        switch (VAR_5)
        {
            case 0:
                if (extractContigSamplesBytes(VAR_23, VAR_24, VAR_20, VAR_26, VAR_22,
                                              VAR_21, VAR_25, VAR_14,
                                              VAR_15 + 1))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" VAR_27, VAR_11);
                    return (1);
                }
                break;
            case 1:
                if (VAR_21 == 1)
                {
                    if (extractContigSamplesShifted8bits(
                            VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25,
                            VAR_14, VAR_15 + 1, VAR_6))
                    {
                        TIFFError(""extractSeparateRegion"",
                                  ""Unable to extract row %"" VAR_27, VAR_11);
                        return (1);
                    }
                    break;
                }
                else if (extractContigSamplesShifted16bits(
                             VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25,
                             VAR_14, VAR_15 + 1, VAR_6))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" VAR_27, VAR_11);
                    return (1);
                }
                break;
            case 2:
                if (extractContigSamplesShifted24bits(
                        VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25, VAR_14,
                        VAR_15 + 1, VAR_6))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" VAR_27, VAR_11);
                    return (1);
                }
                break;
            case 3:
            case 4:
            case 5:
                if (extractContigSamplesShifted32bits(
                        VAR_23, VAR_24, VAR_20, VAR_26, VAR_22, VAR_21, VAR_25, VAR_14,
                        VAR_15 + 1, VAR_6))
                {
                    TIFFError(""extractSeparateRegion"",
                              ""Unable to extract row %"" VAR_27, VAR_11);
                    return (1);
                }
                break;
            default:
                TIFFError(""extractSeparateRegion"",
                          ""Unsupported bit depth %"" VAR_28, VAR_21);
                return (1);
        }
    }

    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -42,7 +42,6 @@
 
     crop->regionlist[region].width = crop_width;
     crop->regionlist[region].length = crop_length;
-    crop->regionlist[region].buffptr = crop_buff;
 
     src = read_buff;
     dst = crop_buff;","{'deleted_lines': ['    crop->regionlist[region].buffptr = crop_buff;'], 'added_lines': []}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,processCropSelections,"static int processCropSelections(struct image_data *image,
struct crop_mask *crop,
unsigned char **read_buff_ptr,
struct buffinfo seg_buffs[])
{
int i;
uint32_t width, length, total_width, total_length;
tsize_t cropsize;
unsigned char *crop_buff = NULL;
unsigned char *read_buff = NULL;
unsigned char *next_buff = NULL;
tsize_t prev_cropsize = 0;
read_buff = *read_buff_ptr;
if (crop->img_mode == COMPOSITE_IMAGES)
{
cropsize = crop->bufftotal;
crop_buff = seg_buffs[0].buffer;
if (!crop_buff)
crop_buff = (unsigned char *)limitMalloc(cropsize +
NUM_BUFF_OVERSIZE_BYTES);
else
{
prev_cropsize = seg_buffs[0].size;
if (prev_cropsize < cropsize)
{
next_buff =
_TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
if (!next_buff)
{
_TIFFfree(crop_buff);
crop_buff = (unsigned char *)limitMalloc(
cropsize + NUM_BUFF_OVERSIZE_BYTES);
}
else
crop_buff = next_buff;
}
}
if (!crop_buff)
{
TIFFError(""processCropSelections"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
seg_buffs[0].buffer = crop_buff;
seg_buffs[0].size = cropsize;
if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
return (1);
if (crop->crop_mode & CROP_INVERT)
{
switch (crop->photometric)
{
case PHOTOMETRIC_MINISWHITE:
case PHOTOMETRIC_MINISBLACK:
image->photometric = crop->photometric;
break;
case INVERT_DATA_ONLY:
case INVERT_DATA_AND_TAG:
if (invertImage(image->photometric, image->spp, image->bps,
crop->combined_width, crop->combined_length,
crop_buff))
{
TIFFError(""processCropSelections"",
""Failed to invert colorspace for composite ""
""regions"");
return (-1);
}
if (crop->photometric == INVERT_DATA_AND_TAG)
{
switch (image->photometric)
{
case PHOTOMETRIC_MINISWHITE:
image->photometric = PHOTOMETRIC_MINISBLACK;
break;
case PHOTOMETRIC_MINISBLACK:
image->photometric = PHOTOMETRIC_MINISWHITE;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (crop->crop_mode & CROP_MIRROR)
{
if (mirrorImage(image->spp, image->bps, crop->mirror,
crop->combined_width, crop->combined_length,
crop_buff))
{
TIFFError(""processCropSelections"",
""Failed to mirror composite regions %s"",
(crop->rotation == MIRROR_HORIZ) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (crop->crop_mode & CROP_ROTATE) 
{
size_t rot_buf_size = 0;
if (rotateImage(crop->rotation, image, &crop->combined_width,
&crop->combined_length, &crop_buff, &rot_buf_size))
{
TIFFError(""processCropSelections"",
""Failed to rotate composite regions by %"" PRIu32
"" degrees"",
crop->rotation);
return (-1);
}
seg_buffs[0].buffer = crop_buff;
seg_buffs[0].size = rot_buf_size;
}
}
else 
{
total_width = total_length = 0;
for (i = 0; i < crop->selections; i++)
{
cropsize = crop->bufftotal;
crop_buff = seg_buffs[i].buffer;
if (!crop_buff)
crop_buff = (unsigned char *)limitMalloc(
cropsize + NUM_BUFF_OVERSIZE_BYTES);
else
{
prev_cropsize = seg_buffs[i].size;
if (prev_cropsize < cropsize)
{
next_buff = _TIFFrealloc(
crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
if (!next_buff)
{
_TIFFfree(crop_buff);
crop_buff = (unsigned char *)limitMalloc(
cropsize + NUM_BUFF_OVERSIZE_BYTES);
}
else
crop_buff = next_buff;
}
}
if (!crop_buff)
{
TIFFError(""processCropSelections"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
seg_buffs[i].buffer = crop_buff;
seg_buffs[i].size = cropsize;
if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))
{
TIFFError(""processCropSelections"",
""Unable to extract cropped region %d from image"", i);
return (-1);
}
width = crop->regionlist[i].width;
length = crop->regionlist[i].length;
if (crop->crop_mode & CROP_INVERT)
{
switch (crop->photometric)
{
case PHOTOMETRIC_MINISWHITE:
case PHOTOMETRIC_MINISBLACK:
image->photometric = crop->photometric;
break;
case INVERT_DATA_ONLY:
case INVERT_DATA_AND_TAG:
if (invertImage(image->photometric, image->spp,
image->bps, width, length, crop_buff))
{
TIFFError(""processCropSelections"",
""Failed to invert colorspace for region"");
return (-1);
}
if (crop->photometric == INVERT_DATA_AND_TAG)
{
switch (image->photometric)
{
case PHOTOMETRIC_MINISWHITE:
image->photometric = PHOTOMETRIC_MINISBLACK;
break;
case PHOTOMETRIC_MINISBLACK:
image->photometric = PHOTOMETRIC_MINISWHITE;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (crop->crop_mode & CROP_MIRROR)
{
if (mirrorImage(image->spp, image->bps, crop->mirror, width,
length, crop_buff))
{
TIFFError(""processCropSelections"",
""Failed to mirror crop region %s"",
(crop->rotation == MIRROR_HORIZ) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (crop->crop_mode & CROP_ROTATE) 
{
size_t rot_buf_size = 0;
if (rotateImage(
crop->rotation, image, &crop->regionlist[i].width,
&crop->regionlist[i].length, &crop_buff, &rot_buf_size))
{
TIFFError(""processCropSelections"",
""Failed to rotate crop region by %"" PRIu16
"" degrees"",
crop->rotation);
return (-1);
}
total_width += crop->regionlist[i].width;
total_length += crop->regionlist[i].length;
crop->combined_width = total_width;
crop->combined_length = total_length;
seg_buffs[i].buffer = crop_buff;
seg_buffs[i].size = rot_buf_size;
}
} 
}     
return (0);
}","static int processCropSelections(struct image_data *VAR_0,
struct crop_mask *VAR_1,
unsigned char **VAR_2,
struct buffinfo VAR_3[])
{
int VAR_4;
uint32_t VAR_5, VAR_6, VAR_7, VAR_8;
tsize_t VAR_9;
unsigned char *VAR_10 = NULL;
unsigned char *VAR_11 = NULL;
unsigned char *VAR_12 = NULL;
tsize_t VAR_13 = 0;
VAR_11 = *VAR_2;
if (VAR_1->img_mode == VAR_14)
{
VAR_9 = VAR_1->bufftotal;
VAR_10 = VAR_3[0].buffer;
if (!VAR_10)
VAR_10 = (unsigned char *)limitMalloc(VAR_9 +
VAR_15);
else
{
VAR_13 = VAR_3[0].size;
if (VAR_13 < VAR_9)
{
VAR_12 =
_TIFFrealloc(VAR_10, VAR_9 + VAR_15);
if (!VAR_12)
{
_TIFFfree(VAR_10);
VAR_10 = (unsigned char *)limitMalloc(
VAR_9 + VAR_15);
}
else
VAR_10 = VAR_12;
}
}
if (!VAR_10)
{
TIFFError(""processCropSelections"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(VAR_10, 0, VAR_9 + VAR_15);
VAR_3[0].buffer = VAR_10;
VAR_3[0].size = VAR_9;
if (extractCompositeRegions(VAR_0, VAR_1, VAR_11, VAR_10) != 0)
return (1);
if (VAR_1->crop_mode & VAR_16)
{
switch (VAR_1->photometric)
{
case VAR_17:
case VAR_18:
VAR_0->photometric = VAR_1->photometric;
break;
case VAR_19:
case VAR_20:
if (invertImage(VAR_0->photometric, VAR_0->spp, VAR_0->bps,
VAR_1->combined_width, VAR_1->combined_length,
VAR_10))
{
TIFFError(""processCropSelections"",
""Failed to invert colorspace for composite ""
""regions"");
return (-1);
}
if (VAR_1->photometric == VAR_20)
{
switch (VAR_0->photometric)
{
case VAR_17:
VAR_0->photometric = VAR_18;
break;
case VAR_18:
VAR_0->photometric = VAR_17;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (VAR_1->crop_mode & VAR_21)
{
if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror,
VAR_1->combined_width, VAR_1->combined_length,
VAR_10))
{
TIFFError(""processCropSelections"",
""Failed to mirror composite regions %s"",
(VAR_1->rotation == VAR_22) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (VAR_1->crop_mode & VAR_23) 
{
size_t VAR_24 = 0;
if (rotateImage(VAR_1->rotation, VAR_0, &VAR_1->combined_width,
&VAR_1->combined_length, &VAR_10, &VAR_24))
{
TIFFError(""processCropSelections"",
""Failed to rotate composite regions by %"" VAR_25
"" degrees"",
VAR_1->rotation);
return (-1);
}
VAR_3[0].buffer = VAR_10;
VAR_3[0].size = VAR_24;
}
}
else 
{
VAR_7 = VAR_8 = 0;
for (VAR_4 = 0; VAR_4 < VAR_1->selections; VAR_4++)
{
VAR_9 = VAR_1->bufftotal;
VAR_10 = VAR_3[VAR_4].buffer;
if (!VAR_10)
VAR_10 = (unsigned char *)limitMalloc(
VAR_9 + VAR_15);
else
{
VAR_13 = VAR_3[VAR_4].size;
if (VAR_13 < VAR_9)
{
VAR_12 = _TIFFrealloc(
VAR_10, VAR_9 + VAR_15);
if (!VAR_12)
{
_TIFFfree(VAR_10);
VAR_10 = (unsigned char *)limitMalloc(
VAR_9 + VAR_15);
}
else
VAR_10 = VAR_12;
}
}
if (!VAR_10)
{
TIFFError(""processCropSelections"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(VAR_10, 0, VAR_9 + VAR_15);
VAR_3[VAR_4].buffer = VAR_10;
VAR_3[VAR_4].size = VAR_9;
if (extractSeparateRegion(VAR_0, VAR_1, VAR_11, VAR_10, VAR_4))
{
TIFFError(""processCropSelections"",
""Unable to extract cropped region %d from image"", VAR_4);
return (-1);
}
VAR_5 = VAR_1->regionlist[VAR_4].width;
VAR_6 = VAR_1->regionlist[VAR_4].length;
if (VAR_1->crop_mode & VAR_16)
{
switch (VAR_1->photometric)
{
case VAR_17:
case VAR_18:
VAR_0->photometric = VAR_1->photometric;
break;
case VAR_19:
case VAR_20:
if (invertImage(VAR_0->photometric, VAR_0->spp,
VAR_0->bps, VAR_5, VAR_6, VAR_10))
{
TIFFError(""processCropSelections"",
""Failed to invert colorspace for region"");
return (-1);
}
if (VAR_1->photometric == VAR_20)
{
switch (VAR_0->photometric)
{
case VAR_17:
VAR_0->photometric = VAR_18;
break;
case VAR_18:
VAR_0->photometric = VAR_17;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (VAR_1->crop_mode & VAR_21)
{
if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror, VAR_5,
VAR_6, VAR_10))
{
TIFFError(""processCropSelections"",
""Failed to mirror crop region %s"",
(VAR_1->rotation == VAR_22) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (VAR_1->crop_mode & VAR_23) 
{
size_t VAR_24 = 0;
if (rotateImage(
VAR_1->rotation, VAR_0, &VAR_1->regionlist[VAR_4].width,
&VAR_1->regionlist[VAR_4].length, &VAR_10, &VAR_24))
{
TIFFError(""processCropSelections"",
""Failed to rotate crop region by %"" VAR_26
"" degrees"",
VAR_1->rotation);
return (-1);
}
VAR_7 += VAR_1->regionlist[VAR_4].width;
VAR_8 += VAR_1->regionlist[VAR_4].length;
VAR_1->combined_width = VAR_7;
VAR_1->combined_length = VAR_8;
VAR_3[VAR_4].buffer = VAR_10;
VAR_3[VAR_4].size = VAR_24;
}
} 
}     
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/3.json,"static int processCropSelections(struct image_data *image,
                                 struct crop_mask *crop,
                                 unsigned char **read_buff_ptr,
                                 struct buffinfo seg_buffs[])
{
    int i;
    uint32_t width, length, total_width, total_length;
    tsize_t cropsize;
    unsigned char *crop_buff = NULL;
    unsigned char *read_buff = NULL;
    unsigned char *next_buff = NULL;
    tsize_t prev_cropsize = 0;

    read_buff = *read_buff_ptr;

    if (crop->img_mode == COMPOSITE_IMAGES)
    {
        cropsize = crop->bufftotal;
        crop_buff = seg_buffs[0].buffer;
        if (!crop_buff)
            crop_buff = (unsigned char *)limitMalloc(cropsize +
                                                     NUM_BUFF_OVERSIZE_BYTES);
        else
        {
            prev_cropsize = seg_buffs[0].size;
            if (prev_cropsize < cropsize)
            {
                next_buff =
                    _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
                if (!next_buff)
                {
                    _TIFFfree(crop_buff);
                    crop_buff = (unsigned char *)limitMalloc(
                        cropsize + NUM_BUFF_OVERSIZE_BYTES);
                }
                else
                    crop_buff = next_buff;
            }
        }

        if (!crop_buff)
        {
            TIFFError(""processCropSelections"",
                      ""Unable to allocate/reallocate crop buffer"");
            return (-1);
        }

        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
        seg_buffs[0].buffer = crop_buff;
        seg_buffs[0].size = cropsize;

        /* Checks for matching width or length as required */
        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
            return (1);

        if (crop->crop_mode & CROP_INVERT)
        {
            switch (crop->photometric)
            {
                /* Just change the interpretation */
                case PHOTOMETRIC_MINISWHITE:
                case PHOTOMETRIC_MINISBLACK:
                    image->photometric = crop->photometric;
                    break;
                case INVERT_DATA_ONLY:
                case INVERT_DATA_AND_TAG:
                    if (invertImage(image->photometric, image->spp, image->bps,
                                    crop->combined_width, crop->combined_length,
                                    crop_buff))
                    {
                        TIFFError(""processCropSelections"",
                                  ""Failed to invert colorspace for composite ""
                                  ""regions"");
                        return (-1);
                    }
                    if (crop->photometric == INVERT_DATA_AND_TAG)
                    {
                        switch (image->photometric)
                        {
                            case PHOTOMETRIC_MINISWHITE:
                                image->photometric = PHOTOMETRIC_MINISBLACK;
                                break;
                            case PHOTOMETRIC_MINISBLACK:
                                image->photometric = PHOTOMETRIC_MINISWHITE;
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                default:
                    break;
            }
        }

        /* Mirror and Rotate will not work with multiple regions unless they are
         * the same width */
        if (crop->crop_mode & CROP_MIRROR)
        {
            if (mirrorImage(image->spp, image->bps, crop->mirror,
                            crop->combined_width, crop->combined_length,
                            crop_buff))
            {
                TIFFError(""processCropSelections"",
                          ""Failed to mirror composite regions %s"",
                          (crop->rotation == MIRROR_HORIZ) ? ""horizontally""
                                                           : ""vertically"");
                return (-1);
            }
        }

        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can
                                              reallocate the buffer */
        {
            /* rotateImage() set up a new buffer and calculates its size
             * individually. Therefore, seg_buffs size  needs to be updated
             * accordingly. */
            size_t rot_buf_size = 0;
            if (rotateImage(crop->rotation, image, &crop->combined_width,
                            &crop->combined_length, &crop_buff, &rot_buf_size,
                            FALSE))
            {
                TIFFError(""processCropSelections"",
                          ""Failed to rotate composite regions by %"" PRIu32
                          "" degrees"",
                          crop->rotation);
                return (-1);
            }
            seg_buffs[0].buffer = crop_buff;
            seg_buffs[0].size = rot_buf_size;
        }
    }
    else /* Separated Images */
    {
        total_width = total_length = 0;
        for (i = 0; i < crop->selections; i++)
        {

            cropsize = crop->bufftotal;
            crop_buff = seg_buffs[i].buffer;
            if (!crop_buff)
                crop_buff = (unsigned char *)limitMalloc(
                    cropsize + NUM_BUFF_OVERSIZE_BYTES);
            else
            {
                prev_cropsize = seg_buffs[i].size;
                if (prev_cropsize < cropsize)
                {
                    next_buff = _TIFFrealloc(
                        crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
                    if (!next_buff)
                    {
                        _TIFFfree(crop_buff);
                        crop_buff = (unsigned char *)limitMalloc(
                            cropsize + NUM_BUFF_OVERSIZE_BYTES);
                    }
                    else
                        crop_buff = next_buff;
                }
            }

            if (!crop_buff)
            {
                TIFFError(""processCropSelections"",
                          ""Unable to allocate/reallocate crop buffer"");
                return (-1);
            }

            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
            seg_buffs[i].buffer = crop_buff;
            seg_buffs[i].size = cropsize;

            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))
            {
                TIFFError(""processCropSelections"",
                          ""Unable to extract cropped region %d from image"", i);
                return (-1);
            }

            width = crop->regionlist[i].width;
            length = crop->regionlist[i].length;

            if (crop->crop_mode & CROP_INVERT)
            {
                switch (crop->photometric)
                {
                    /* Just change the interpretation */
                    case PHOTOMETRIC_MINISWHITE:
                    case PHOTOMETRIC_MINISBLACK:
                        image->photometric = crop->photometric;
                        break;
                    case INVERT_DATA_ONLY:
                    case INVERT_DATA_AND_TAG:
                        if (invertImage(image->photometric, image->spp,
                                        image->bps, width, length, crop_buff))
                        {
                            TIFFError(""processCropSelections"",
                                      ""Failed to invert colorspace for region"");
                            return (-1);
                        }
                        if (crop->photometric == INVERT_DATA_AND_TAG)
                        {
                            switch (image->photometric)
                            {
                                case PHOTOMETRIC_MINISWHITE:
                                    image->photometric = PHOTOMETRIC_MINISBLACK;
                                    break;
                                case PHOTOMETRIC_MINISBLACK:
                                    image->photometric = PHOTOMETRIC_MINISWHITE;
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    default:
                        break;
                }
            }

            if (crop->crop_mode & CROP_MIRROR)
            {
                if (mirrorImage(image->spp, image->bps, crop->mirror, width,
                                length, crop_buff))
                {
                    TIFFError(""processCropSelections"",
                              ""Failed to mirror crop region %s"",
                              (crop->rotation == MIRROR_HORIZ) ? ""horizontally""
                                                               : ""vertically"");
                    return (-1);
                }
            }

            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it
                                                  can reallocate the buffer */
            {
                /* rotateImage() changes image->width, ->length, ->xres and
                 * ->yres, what it schouldn't do here, when more than one
                 * section is processed. ToDo: Therefore rotateImage() and its
                 * usage has to be reworked (e.g. like mirrorImage()) !!
                 * Furthermore, rotateImage() set up a new buffer and calculates
                 * its size individually. Therefore, seg_buffs size  needs to be
                 * updated accordingly. */
                size_t rot_buf_size = 0;
                if (rotateImage(crop->rotation, image,
                                &crop->regionlist[i].width,
                                &crop->regionlist[i].length, &crop_buff,
                                &rot_buf_size, FALSE))
                {
                    TIFFError(""processCropSelections"",
                              ""Failed to rotate crop region by %"" PRIu16
                              "" degrees"",
                              crop->rotation);
                    return (-1);
                }
                total_width += crop->regionlist[i].width;
                total_length += crop->regionlist[i].length;
                crop->combined_width = total_width;
                crop->combined_length = total_length;
                seg_buffs[i].buffer = crop_buff;
                seg_buffs[i].size = rot_buf_size;
            }
        } /* for crop->selections loop */
    }     /* Separated Images (else case) */
    return (0);
}","static int processCropSelections(struct image_data *VAR_0,
                                 struct crop_mask *VAR_1,
                                 unsigned char **VAR_2,
                                 struct buffinfo VAR_3[])
{
    int VAR_4;
    uint32_t VAR_5, VAR_6, VAR_7, VAR_8;
    tsize_t VAR_9;
    unsigned char *VAR_10 = NULL;
    unsigned char *VAR_11 = NULL;
    unsigned char *VAR_12 = NULL;
    tsize_t VAR_13 = 0;

    VAR_11 = *VAR_2;

    if (VAR_1->img_mode == VAR_14)
    {
        VAR_9 = VAR_1->bufftotal;
        VAR_10 = VAR_3[0].buffer;
        if (!VAR_10)
            VAR_10 = (unsigned char *)limitMalloc(VAR_9 +
                                                     VAR_15);
        else
        {
            VAR_13 = VAR_3[0].size;
            if (VAR_13 < VAR_9)
            {
                VAR_12 =
                    _TIFFrealloc(VAR_10, VAR_9 + VAR_15);
                if (!VAR_12)
                {
                    _TIFFfree(VAR_10);
                    VAR_10 = (unsigned char *)limitMalloc(
                        VAR_9 + VAR_15);
                }
                else
                    VAR_10 = VAR_12;
            }
        }

        if (!VAR_10)
        {
            TIFFError(""processCropSelections"",
                      ""Unable to allocate/reallocate crop buffer"");
            return (-1);
        }

        _TIFFmemset(VAR_10, 0, VAR_9 + VAR_15);
        VAR_3[0].buffer = VAR_10;
        VAR_3[0].size = VAR_9;

        /* COMMENT_0 */
        if (extractCompositeRegions(VAR_0, VAR_1, VAR_11, VAR_10) != 0)
            return (1);

        if (VAR_1->crop_mode & VAR_16)
        {
            switch (VAR_1->photometric)
            {
                /* COMMENT_1 */
                case VAR_17:
                case VAR_18:
                    VAR_0->photometric = VAR_1->photometric;
                    break;
                case VAR_19:
                case VAR_20:
                    if (invertImage(VAR_0->photometric, VAR_0->spp, VAR_0->bps,
                                    VAR_1->combined_width, VAR_1->combined_length,
                                    VAR_10))
                    {
                        TIFFError(""processCropSelections"",
                                  ""Failed to invert colorspace for composite ""
                                  ""regions"");
                        return (-1);
                    }
                    if (VAR_1->photometric == VAR_20)
                    {
                        switch (VAR_0->photometric)
                        {
                            case VAR_17:
                                VAR_0->photometric = VAR_18;
                                break;
                            case VAR_18:
                                VAR_0->photometric = VAR_17;
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                default:
                    break;
            }
        }

        /* COMMENT_2 */
                            
        if (VAR_1->crop_mode & VAR_21)
        {
            if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror,
                            VAR_1->combined_width, VAR_1->combined_length,
                            VAR_10))
            {
                TIFFError(""processCropSelections"",
                          ""Failed to mirror composite regions %s"",
                          (VAR_1->rotation == VAR_22) ? ""horizontally""
                                                           : ""vertically"");
                return (-1);
            }
        }

        if (VAR_1->crop_mode & VAR_23) /* COMMENT_4 */
                                                                      
        {
            /* COMMENT_6 */
                                                                           
                              
            size_t VAR_24 = 0;
            if (rotateImage(VAR_1->rotation, VAR_0, &VAR_1->combined_width,
                            &VAR_1->combined_length, &VAR_10, &VAR_24,
                            FALSE))
            {
                TIFFError(""processCropSelections"",
                          ""Failed to rotate composite regions by %"" VAR_25
                          "" degrees"",
                          VAR_1->rotation);
                return (-1);
            }
            VAR_3[0].buffer = VAR_10;
            VAR_3[0].size = VAR_24;
        }
    }
    else /* COMMENT_9 */
    {
        VAR_7 = VAR_8 = 0;
        for (VAR_4 = 0; VAR_4 < VAR_1->selections; VAR_4++)
        {

            VAR_9 = VAR_1->bufftotal;
            VAR_10 = VAR_3[VAR_4].buffer;
            if (!VAR_10)
                VAR_10 = (unsigned char *)limitMalloc(
                    VAR_9 + VAR_15);
            else
            {
                VAR_13 = VAR_3[VAR_4].size;
                if (VAR_13 < VAR_9)
                {
                    VAR_12 = _TIFFrealloc(
                        VAR_10, VAR_9 + VAR_15);
                    if (!VAR_12)
                    {
                        _TIFFfree(VAR_10);
                        VAR_10 = (unsigned char *)limitMalloc(
                            VAR_9 + VAR_15);
                    }
                    else
                        VAR_10 = VAR_12;
                }
            }

            if (!VAR_10)
            {
                TIFFError(""processCropSelections"",
                          ""Unable to allocate/reallocate crop buffer"");
                return (-1);
            }

            _TIFFmemset(VAR_10, 0, VAR_9 + VAR_15);
            VAR_3[VAR_4].buffer = VAR_10;
            VAR_3[VAR_4].size = VAR_9;

            if (extractSeparateRegion(VAR_0, VAR_1, VAR_11, VAR_10, VAR_4))
            {
                TIFFError(""processCropSelections"",
                          ""Unable to extract cropped region %d from image"", VAR_4);
                return (-1);
            }

            VAR_5 = VAR_1->regionlist[VAR_4].width;
            VAR_6 = VAR_1->regionlist[VAR_4].length;

            if (VAR_1->crop_mode & VAR_16)
            {
                switch (VAR_1->photometric)
                {
                    /* COMMENT_1 */
                    case VAR_17:
                    case VAR_18:
                        VAR_0->photometric = VAR_1->photometric;
                        break;
                    case VAR_19:
                    case VAR_20:
                        if (invertImage(VAR_0->photometric, VAR_0->spp,
                                        VAR_0->bps, VAR_5, VAR_6, VAR_10))
                        {
                            TIFFError(""processCropSelections"",
                                      ""Failed to invert colorspace for region"");
                            return (-1);
                        }
                        if (VAR_1->photometric == VAR_20)
                        {
                            switch (VAR_0->photometric)
                            {
                                case VAR_17:
                                    VAR_0->photometric = VAR_18;
                                    break;
                                case VAR_18:
                                    VAR_0->photometric = VAR_17;
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    default:
                        break;
                }
            }

            if (VAR_1->crop_mode & VAR_21)
            {
                if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror, VAR_5,
                                VAR_6, VAR_10))
                {
                    TIFFError(""processCropSelections"",
                              ""Failed to mirror crop region %s"",
                              (VAR_1->rotation == VAR_22) ? ""horizontally""
                                                               : ""vertically"");
                    return (-1);
                }
            }

            if (VAR_1->crop_mode & VAR_23) /* COMMENT_10 */
                                                                              
            {
                /* COMMENT_12 */
                                                                         
                                                                              
                                                                        
                                                                                
                                                                                
                                          
                size_t VAR_24 = 0;
                if (rotateImage(VAR_1->rotation, VAR_0,
                                &VAR_1->regionlist[VAR_4].width,
                                &VAR_1->regionlist[VAR_4].length, &VAR_10,
                                &VAR_24, FALSE))
                {
                    TIFFError(""processCropSelections"",
                              ""Failed to rotate crop region by %"" VAR_26
                              "" degrees"",
                              VAR_1->rotation);
                    return (-1);
                }
                VAR_7 += VAR_1->regionlist[VAR_4].width;
                VAR_8 += VAR_1->regionlist[VAR_4].length;
                VAR_1->combined_width = VAR_7;
                VAR_1->combined_length = VAR_8;
                VAR_3[VAR_4].buffer = VAR_10;
                VAR_3[VAR_4].size = VAR_24;
            }
        } /* COMMENT_19 */
    }     /* COMMENT_20 */
    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -117,7 +117,8 @@
              * accordingly. */
             size_t rot_buf_size = 0;
             if (rotateImage(crop->rotation, image, &crop->combined_width,
-                            &crop->combined_length, &crop_buff, &rot_buf_size))
+                            &crop->combined_length, &crop_buff, &rot_buf_size,
+                            FALSE))
             {
                 TIFFError(""processCropSelections"",
                           ""Failed to rotate composite regions by %"" PRIu32
@@ -241,9 +242,10 @@
                  * its size individually. Therefore, seg_buffs size  needs to be
                  * updated accordingly. */
                 size_t rot_buf_size = 0;
-                if (rotateImage(
-                        crop->rotation, image, &crop->regionlist[i].width,
-                        &crop->regionlist[i].length, &crop_buff, &rot_buf_size))
+                if (rotateImage(crop->rotation, image,
+                                &crop->regionlist[i].width,
+                                &crop->regionlist[i].length, &crop_buff,
+                                &rot_buf_size, FALSE))
                 {
                     TIFFError(""processCropSelections"",
                               ""Failed to rotate crop region by %"" PRIu16","{'deleted_lines': ['                            &crop->combined_length, &crop_buff, &rot_buf_size))', '                if (rotateImage(', '                        crop->rotation, image, &crop->regionlist[i].width,', '                        &crop->regionlist[i].length, &crop_buff, &rot_buf_size))'], 'added_lines': ['                            &crop->combined_length, &crop_buff, &rot_buf_size,', '                            FALSE))', '                if (rotateImage(crop->rotation, image,', '                                &crop->regionlist[i].width,', '                                &crop->regionlist[i].length, &crop_buff,', '                                &rot_buf_size, FALSE))']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,rotateImage,"static int rotateImage(uint16_t rotation, struct image_data *image,
uint32_t *img_width, uint32_t *img_length,
unsigned char **ibuff_ptr, size_t *rot_buf_size)
{
int shift_width;
uint32_t bytes_per_pixel, bytes_per_sample;
uint32_t row, rowsize, src_offset, dst_offset;
uint32_t i, col, width, length;
uint32_t colsize, col_offset, pix_offset;
tmsize_t buffsize;
unsigned char *ibuff;
unsigned char *src;
unsigned char *dst;
uint16_t spp, bps;
float res_temp;
unsigned char *rbuff = NULL;
width = *img_width;
length = *img_length;
spp = image->spp;
bps = image->bps;
if ((spp != 0 && bps != 0 &&
width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) ||
(spp != 0 && bps != 0 &&
length > (uint32_t)((UINT32_MAX - 7) / spp / bps)))
{
TIFFError(""rotateImage"", ""Integer overflow detected."");
return (-1);
}
rowsize = ((bps * spp * width) + 7) / 8;
colsize = ((bps * spp * length) + 7) / 8;
if ((colsize * width) > (rowsize * length))
{
if (((tmsize_t)colsize + 1) != 0 &&
(tmsize_t)width > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
((tmsize_t)colsize + 1)))
{
TIFFError(""rotateImage"",
""Integer overflow when calculating buffer size."");
return (-1);
}
buffsize = ((tmsize_t)colsize + 1) * width;
}
else
{
if (((tmsize_t)rowsize + 1) != 0 &&
(tmsize_t)length > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
((tmsize_t)rowsize + 1)))
{
TIFFError(""rotateImage"",
""Integer overflow when calculating buffer size."");
return (-1);
}
buffsize = (rowsize + 1) * length;
}
bytes_per_sample = (bps + 7) / 8;
bytes_per_pixel = ((bps * spp) + 7) / 8;
if (bytes_per_pixel < (bytes_per_sample + 1))
shift_width = bytes_per_pixel;
else
shift_width = bytes_per_sample + 1;
switch (rotation)
{
case 0:
case 360:
return (0);
case 90:
case 180:
case 270:
break;
default:
TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16,
rotation);
return (-1);
}
if (!(rbuff =
(unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES)))
{
TIFFError(""rotateImage"",
""Unable to allocate rotation buffer of %"" TIFF_SSIZE_FORMAT
"" bytes "",
buffsize + NUM_BUFF_OVERSIZE_BYTES);
return (-1);
}
_TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
if (rot_buf_size != NULL)
*rot_buf_size = buffsize;
ibuff = *ibuff_ptr;
switch (rotation)
{
case 180:
if ((bps % 8) == 0) 
{
src = ibuff;
pix_offset = (spp * bps) / 8;
for (row = 0; row < length; row++)
{
dst_offset = (length - row - 1) * rowsize;
for (col = 0; col < width; col++)
{
col_offset = (width - col - 1) * pix_offset;
dst = rbuff + dst_offset + col_offset;
for (i = 0; i < bytes_per_pixel; i++)
*dst++ = *src++;
}
}
}
else
{ 
for (row = 0; row < length; row++)
{
src_offset = row * rowsize;
dst_offset = (length - row - 1) * rowsize;
src = ibuff + src_offset;
dst = rbuff + dst_offset;
switch (shift_width)
{
case 1:
if (bps == 1)
{
if (reverseSamples8bits(spp, bps, width, src,
dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
}
if (reverseSamples16bits(spp, bps, width, src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 2:
if (reverseSamples24bits(spp, bps, width, src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (reverseSamples32bits(spp, bps, width, src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" PRIu16, bps);
_TIFFfree(rbuff);
return (-1);
}
}
}
_TIFFfree(ibuff);
*(ibuff_ptr) = rbuff;
break;
case 90:
if ((bps % 8) == 0) 
{
for (col = 0; col < width; col++)
{
src_offset =
((length - 1) * rowsize) + (col * bytes_per_pixel);
dst_offset = col * colsize;
src = ibuff + src_offset;
dst = rbuff + dst_offset;
for (row = length; row > 0; row--)
{
for (i = 0; i < bytes_per_pixel; i++)
*dst++ = *(src + i);
src -= rowsize;
}
}
}
else
{ 
for (col = 0; col < width; col++)
{
src_offset = (length - 1) * rowsize;
dst_offset = col * colsize;
src = ibuff + src_offset;
dst = rbuff + dst_offset;
switch (shift_width)
{
case 1:
if (bps == 1)
{
if (rotateContigSamples8bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
}
if (rotateContigSamples16bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 2:
if (rotateContigSamples24bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (rotateContigSamples32bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" PRIu16, bps);
_TIFFfree(rbuff);
return (-1);
}
}
}
_TIFFfree(ibuff);
*(ibuff_ptr) = rbuff;
*img_width = length;
*img_length = width;
image->width = length;
image->length = width;
res_temp = image->xres;
image->xres = image->yres;
image->yres = res_temp;
break;
case 270:
if ((bps % 8) == 0) 
{
for (col = 0; col < width; col++)
{
src_offset = col * bytes_per_pixel;
dst_offset = (width - col - 1) * colsize;
src = ibuff + src_offset;
dst = rbuff + dst_offset;
for (row = length; row > 0; row--)
{
for (i = 0; i < bytes_per_pixel; i++)
*dst++ = *(src + i);
src += rowsize;
}
}
}
else
{ 
for (col = 0; col < width; col++)
{
src_offset = 0;
dst_offset = (width - col - 1) * colsize;
src = ibuff + src_offset;
dst = rbuff + dst_offset;
switch (shift_width)
{
case 1:
if (bps == 1)
{
if (rotateContigSamples8bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
}
if (rotateContigSamples16bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 2:
if (rotateContigSamples24bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (rotateContigSamples32bits(rotation, spp, bps,
width, length, col,
src, dst))
{
_TIFFfree(rbuff);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" PRIu16, bps);
_TIFFfree(rbuff);
return (-1);
}
}
}
_TIFFfree(ibuff);
*(ibuff_ptr) = rbuff;
*img_width = length;
*img_length = width;
image->width = length;
image->length = width;
res_temp = image->xres;
image->xres = image->yres;
image->yres = res_temp;
break;
default:
break;
}
return (0);
}","static int rotateImage(uint16_t VAR_0, struct image_data *VAR_1,
uint32_t *VAR_2, uint32_t *VAR_3,
unsigned char **VAR_4, size_t *VAR_5)
{
int VAR_6;
uint32_t VAR_7, VAR_8;
uint32_t VAR_9, VAR_10, VAR_11, VAR_12;
uint32_t VAR_13, VAR_14, VAR_15, VAR_16;
uint32_t VAR_17, VAR_18, VAR_19;
tmsize_t VAR_20;
unsigned char *VAR_21;
unsigned char *VAR_22;
unsigned char *VAR_23;
uint16_t VAR_24, VAR_25;
float VAR_26;
unsigned char *VAR_27 = NULL;
VAR_15 = *VAR_2;
VAR_16 = *VAR_3;
VAR_24 = VAR_1->spp;
VAR_25 = VAR_1->bps;
if ((VAR_24 != 0 && VAR_25 != 0 &&
VAR_15 > (uint32_t)((VAR_28 - 7) / VAR_24 / VAR_25)) ||
(VAR_24 != 0 && VAR_25 != 0 &&
VAR_16 > (uint32_t)((VAR_28 - 7) / VAR_24 / VAR_25)))
{
TIFFError(""rotateImage"", ""Integer overflow detected."");
return (-1);
}
VAR_10 = ((VAR_25 * VAR_24 * VAR_15) + 7) / 8;
VAR_17 = ((VAR_25 * VAR_24 * VAR_16) + 7) / 8;
if ((VAR_17 * VAR_15) > (VAR_10 * VAR_16))
{
if (((tmsize_t)VAR_17 + 1) != 0 &&
(tmsize_t)VAR_15 > ((VAR_29 - VAR_30) /
((tmsize_t)VAR_17 + 1)))
{
TIFFError(""rotateImage"",
""Integer overflow when calculating buffer size."");
return (-1);
}
VAR_20 = ((tmsize_t)VAR_17 + 1) * VAR_15;
}
else
{
if (((tmsize_t)VAR_10 + 1) != 0 &&
(tmsize_t)VAR_16 > ((VAR_29 - VAR_30) /
((tmsize_t)VAR_10 + 1)))
{
TIFFError(""rotateImage"",
""Integer overflow when calculating buffer size."");
return (-1);
}
VAR_20 = (VAR_10 + 1) * VAR_16;
}
VAR_8 = (VAR_25 + 7) / 8;
VAR_7 = ((VAR_25 * VAR_24) + 7) / 8;
if (VAR_7 < (VAR_8 + 1))
VAR_6 = VAR_7;
else
VAR_6 = VAR_8 + 1;
switch (VAR_0)
{
case 0:
case 360:
return (0);
case 90:
case 180:
case 270:
break;
default:
TIFFError(""rotateImage"", ""Invalid rotation angle %"" VAR_31,
VAR_0);
return (-1);
}
if (!(VAR_27 =
(unsigned char *)limitMalloc(VAR_20 + VAR_30)))
{
TIFFError(""rotateImage"",
""Unable to allocate rotation buffer of %"" VAR_32
"" bytes "",
VAR_20 + VAR_30);
return (-1);
}
_TIFFmemset(VAR_27, '\0', VAR_20 + VAR_30);
if (VAR_5 != NULL)
*VAR_5 = VAR_20;
VAR_21 = *VAR_4;
switch (VAR_0)
{
case 180:
if ((VAR_25 % 8) == 0) 
{
VAR_22 = VAR_21;
VAR_19 = (VAR_24 * VAR_25) / 8;
for (VAR_9 = 0; VAR_9 < VAR_16; VAR_9++)
{
VAR_12 = (VAR_16 - VAR_9 - 1) * VAR_10;
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
{
VAR_18 = (VAR_15 - VAR_14 - 1) * VAR_19;
VAR_23 = VAR_27 + VAR_12 + VAR_18;
for (VAR_13 = 0; VAR_13 < VAR_7; VAR_13++)
*VAR_23++ = *VAR_22++;
}
}
}
else
{ 
for (VAR_9 = 0; VAR_9 < VAR_16; VAR_9++)
{
VAR_11 = VAR_9 * VAR_10;
VAR_12 = (VAR_16 - VAR_9 - 1) * VAR_10;
VAR_22 = VAR_21 + VAR_11;
VAR_23 = VAR_27 + VAR_12;
switch (VAR_6)
{
case 1:
if (VAR_25 == 1)
{
if (reverseSamples8bits(VAR_24, VAR_25, VAR_15, VAR_22,
VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
}
if (reverseSamples16bits(VAR_24, VAR_25, VAR_15, VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 2:
if (reverseSamples24bits(VAR_24, VAR_25, VAR_15, VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (reverseSamples32bits(VAR_24, VAR_25, VAR_15, VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" VAR_31, VAR_25);
_TIFFfree(VAR_27);
return (-1);
}
}
}
_TIFFfree(VAR_21);
*(VAR_4) = VAR_27;
break;
case 90:
if ((VAR_25 % 8) == 0) 
{
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
{
VAR_11 =
((VAR_16 - 1) * VAR_10) + (VAR_14 * VAR_7);
VAR_12 = VAR_14 * VAR_17;
VAR_22 = VAR_21 + VAR_11;
VAR_23 = VAR_27 + VAR_12;
for (VAR_9 = VAR_16; VAR_9 > 0; VAR_9--)
{
for (VAR_13 = 0; VAR_13 < VAR_7; VAR_13++)
*VAR_23++ = *(VAR_22 + VAR_13);
VAR_22 -= VAR_10;
}
}
}
else
{ 
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
{
VAR_11 = (VAR_16 - 1) * VAR_10;
VAR_12 = VAR_14 * VAR_17;
VAR_22 = VAR_21 + VAR_11;
VAR_23 = VAR_27 + VAR_12;
switch (VAR_6)
{
case 1:
if (VAR_25 == 1)
{
if (rotateContigSamples8bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
}
if (rotateContigSamples16bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 2:
if (rotateContigSamples24bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (rotateContigSamples32bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" VAR_31, VAR_25);
_TIFFfree(VAR_27);
return (-1);
}
}
}
_TIFFfree(VAR_21);
*(VAR_4) = VAR_27;
*VAR_2 = VAR_16;
*VAR_3 = VAR_15;
VAR_1->width = VAR_16;
VAR_1->length = VAR_15;
VAR_26 = VAR_1->xres;
VAR_1->xres = VAR_1->yres;
VAR_1->yres = VAR_26;
break;
case 270:
if ((VAR_25 % 8) == 0) 
{
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
{
VAR_11 = VAR_14 * VAR_7;
VAR_12 = (VAR_15 - VAR_14 - 1) * VAR_17;
VAR_22 = VAR_21 + VAR_11;
VAR_23 = VAR_27 + VAR_12;
for (VAR_9 = VAR_16; VAR_9 > 0; VAR_9--)
{
for (VAR_13 = 0; VAR_13 < VAR_7; VAR_13++)
*VAR_23++ = *(VAR_22 + VAR_13);
VAR_22 += VAR_10;
}
}
}
else
{ 
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
{
VAR_11 = 0;
VAR_12 = (VAR_15 - VAR_14 - 1) * VAR_17;
VAR_22 = VAR_21 + VAR_11;
VAR_23 = VAR_27 + VAR_12;
switch (VAR_6)
{
case 1:
if (VAR_25 == 1)
{
if (rotateContigSamples8bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
}
if (rotateContigSamples16bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 2:
if (rotateContigSamples24bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
case 3:
case 4:
case 5:
if (rotateContigSamples32bits(VAR_0, VAR_24, VAR_25,
VAR_15, VAR_16, VAR_14,
VAR_22, VAR_23))
{
_TIFFfree(VAR_27);
return (-1);
}
break;
default:
TIFFError(""rotateImage"",
""Unsupported bit depth %"" VAR_31, VAR_25);
_TIFFfree(VAR_27);
return (-1);
}
}
}
_TIFFfree(VAR_21);
*(VAR_4) = VAR_27;
*VAR_2 = VAR_16;
*VAR_3 = VAR_15;
VAR_1->width = VAR_16;
VAR_1->length = VAR_15;
VAR_26 = VAR_1->xres;
VAR_1->xres = VAR_1->yres;
VAR_1->yres = VAR_26;
break;
default:
break;
}
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/4.json,"static int rotateImage(uint16_t rotation, struct image_data *image,
                       uint32_t *img_width, uint32_t *img_length,
                       unsigned char **ibuff_ptr, size_t *rot_buf_size,
                       int rot_image_params)
{
    int shift_width;
    uint32_t bytes_per_pixel, bytes_per_sample;
    uint32_t row, rowsize, src_offset, dst_offset;
    uint32_t i, col, width, length;
    uint32_t colsize, col_offset, pix_offset;
    tmsize_t buffsize;
    unsigned char *ibuff;
    unsigned char *src;
    unsigned char *dst;
    uint16_t spp, bps;
    float res_temp;
    unsigned char *rbuff = NULL;

    width = *img_width;
    length = *img_length;
    spp = image->spp;
    bps = image->bps;

    if ((spp != 0 && bps != 0 &&
         width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) ||
        (spp != 0 && bps != 0 &&
         length > (uint32_t)((UINT32_MAX - 7) / spp / bps)))
    {
        TIFFError(""rotateImage"", ""Integer overflow detected."");
        return (-1);
    }
    rowsize = ((bps * spp * width) + 7) / 8;
    colsize = ((bps * spp * length) + 7) / 8;
    if ((colsize * width) > (rowsize * length))
    {
        if (((tmsize_t)colsize + 1) != 0 &&
            (tmsize_t)width > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
                               ((tmsize_t)colsize + 1)))
        {
            TIFFError(""rotateImage"",
                      ""Integer overflow when calculating buffer size."");
            return (-1);
        }
        buffsize = ((tmsize_t)colsize + 1) * width;
    }
    else
    {
        if (((tmsize_t)rowsize + 1) != 0 &&
            (tmsize_t)length > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
                                ((tmsize_t)rowsize + 1)))
        {
            TIFFError(""rotateImage"",
                      ""Integer overflow when calculating buffer size."");
            return (-1);
        }
        buffsize = (rowsize + 1) * length;
    }

    bytes_per_sample = (bps + 7) / 8;
    bytes_per_pixel = ((bps * spp) + 7) / 8;
    if (bytes_per_pixel < (bytes_per_sample + 1))
        shift_width = bytes_per_pixel;
    else
        shift_width = bytes_per_sample + 1;

    switch (rotation)
    {
        case 0:
        case 360:
            return (0);
        case 90:
        case 180:
        case 270:
            break;
        default:
            TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16,
                      rotation);
            return (-1);
    }

    /* Add 3 padding bytes for extractContigSamplesShifted32bits */
    if (!(rbuff =
              (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES)))
    {
        TIFFError(""rotateImage"",
                  ""Unable to allocate rotation buffer of %"" TIFF_SSIZE_FORMAT
                  "" bytes "",
                  buffsize + NUM_BUFF_OVERSIZE_BYTES);
        return (-1);
    }
    _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
    if (rot_buf_size != NULL)
        *rot_buf_size = buffsize;

    ibuff = *ibuff_ptr;
    switch (rotation)
    {
        case 180:
            if ((bps % 8) == 0) /* byte aligned data */
            {
                src = ibuff;
                pix_offset = (spp * bps) / 8;
                for (row = 0; row < length; row++)
                {
                    dst_offset = (length - row - 1) * rowsize;
                    for (col = 0; col < width; col++)
                    {
                        col_offset = (width - col - 1) * pix_offset;
                        dst = rbuff + dst_offset + col_offset;

                        for (i = 0; i < bytes_per_pixel; i++)
                            *dst++ = *src++;
                    }
                }
            }
            else
            { /* non 8 bit per sample data */
                for (row = 0; row < length; row++)
                {
                    src_offset = row * rowsize;
                    dst_offset = (length - row - 1) * rowsize;
                    src = ibuff + src_offset;
                    dst = rbuff + dst_offset;
                    switch (shift_width)
                    {
                        case 1:
                            if (bps == 1)
                            {
                                if (reverseSamples8bits(spp, bps, width, src,
                                                        dst))
                                {
                                    _TIFFfree(rbuff);
                                    return (-1);
                                }
                                break;
                            }
                            if (reverseSamples16bits(spp, bps, width, src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (reverseSamples24bits(spp, bps, width, src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (reverseSamples32bits(spp, bps, width, src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" PRIu16, bps);
                            _TIFFfree(rbuff);
                            return (-1);
                    }
                }
            }
            _TIFFfree(ibuff);
            *(ibuff_ptr) = rbuff;
            break;

        case 90:
            if ((bps % 8) == 0) /* byte aligned data */
            {
                for (col = 0; col < width; col++)
                {
                    src_offset =
                        ((length - 1) * rowsize) + (col * bytes_per_pixel);
                    dst_offset = col * colsize;
                    src = ibuff + src_offset;
                    dst = rbuff + dst_offset;
                    for (row = length; row > 0; row--)
                    {
                        for (i = 0; i < bytes_per_pixel; i++)
                            *dst++ = *(src + i);
                        src -= rowsize;
                    }
                }
            }
            else
            { /* non 8 bit per sample data */
                for (col = 0; col < width; col++)
                {
                    src_offset = (length - 1) * rowsize;
                    dst_offset = col * colsize;
                    src = ibuff + src_offset;
                    dst = rbuff + dst_offset;
                    switch (shift_width)
                    {
                        case 1:
                            if (bps == 1)
                            {
                                if (rotateContigSamples8bits(rotation, spp, bps,
                                                             width, length, col,
                                                             src, dst))
                                {
                                    _TIFFfree(rbuff);
                                    return (-1);
                                }
                                break;
                            }
                            if (rotateContigSamples16bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (rotateContigSamples24bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (rotateContigSamples32bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" PRIu16, bps);
                            _TIFFfree(rbuff);
                            return (-1);
                    }
                }
            }
            _TIFFfree(ibuff);
            *(ibuff_ptr) = rbuff;

            *img_width = length;
            *img_length = width;
            /* Only toggle image parameters if whole input image is rotated. */
            if (rot_image_params)
            {
                image->width = length;
                image->length = width;
                res_temp = image->xres;
                image->xres = image->yres;
                image->yres = res_temp;
            }
            break;

        case 270:
            if ((bps % 8) == 0) /* byte aligned data */
            {
                for (col = 0; col < width; col++)
                {
                    src_offset = col * bytes_per_pixel;
                    dst_offset = (width - col - 1) * colsize;
                    src = ibuff + src_offset;
                    dst = rbuff + dst_offset;
                    for (row = length; row > 0; row--)
                    {
                        for (i = 0; i < bytes_per_pixel; i++)
                            *dst++ = *(src + i);
                        src += rowsize;
                    }
                }
            }
            else
            { /* non 8 bit per sample data */
                for (col = 0; col < width; col++)
                {
                    src_offset = 0;
                    dst_offset = (width - col - 1) * colsize;
                    src = ibuff + src_offset;
                    dst = rbuff + dst_offset;
                    switch (shift_width)
                    {
                        case 1:
                            if (bps == 1)
                            {
                                if (rotateContigSamples8bits(rotation, spp, bps,
                                                             width, length, col,
                                                             src, dst))
                                {
                                    _TIFFfree(rbuff);
                                    return (-1);
                                }
                                break;
                            }
                            if (rotateContigSamples16bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (rotateContigSamples24bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (rotateContigSamples32bits(rotation, spp, bps,
                                                          width, length, col,
                                                          src, dst))
                            {
                                _TIFFfree(rbuff);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" PRIu16, bps);
                            _TIFFfree(rbuff);
                            return (-1);
                    }
                }
            }
            _TIFFfree(ibuff);
            *(ibuff_ptr) = rbuff;

            *img_width = length;
            *img_length = width;
            /* Only toggle image parameters if whole input image is rotated. */
            if (rot_image_params)
            {
                image->width = length;
                image->length = width;
                res_temp = image->xres;
                image->xres = image->yres;
                image->yres = res_temp;
            }
            break;
        default:
            break;
    }

    return (0);
}","static int rotateImage(uint16_t VAR_0, struct image_data *VAR_1,
                       uint32_t *VAR_2, uint32_t *VAR_3,
                       unsigned char **VAR_4, size_t *VAR_5,
                       int VAR_6)
{
    int VAR_7;
    uint32_t VAR_8, VAR_9;
    uint32_t VAR_10, VAR_11, VAR_12, VAR_13;
    uint32_t VAR_14, VAR_15, VAR_16, VAR_17;
    uint32_t VAR_18, VAR_19, VAR_20;
    tmsize_t VAR_21;
    unsigned char *VAR_22;
    unsigned char *VAR_23;
    unsigned char *VAR_24;
    uint16_t VAR_25, VAR_26;
    float VAR_27;
    unsigned char *VAR_28 = NULL;

    VAR_16 = *VAR_2;
    VAR_17 = *VAR_3;
    VAR_25 = VAR_1->spp;
    VAR_26 = VAR_1->bps;

    if ((VAR_25 != 0 && VAR_26 != 0 &&
         VAR_16 > (uint32_t)((VAR_29 - 7) / VAR_25 / VAR_26)) ||
        (VAR_25 != 0 && VAR_26 != 0 &&
         VAR_17 > (uint32_t)((VAR_29 - 7) / VAR_25 / VAR_26)))
    {
        TIFFError(""rotateImage"", ""Integer overflow detected."");
        return (-1);
    }
    VAR_11 = ((VAR_26 * VAR_25 * VAR_16) + 7) / 8;
    VAR_18 = ((VAR_26 * VAR_25 * VAR_17) + 7) / 8;
    if ((VAR_18 * VAR_16) > (VAR_11 * VAR_17))
    {
        if (((tmsize_t)VAR_18 + 1) != 0 &&
            (tmsize_t)VAR_16 > ((VAR_30 - VAR_31) /
                               ((tmsize_t)VAR_18 + 1)))
        {
            TIFFError(""rotateImage"",
                      ""Integer overflow when calculating buffer size."");
            return (-1);
        }
        VAR_21 = ((tmsize_t)VAR_18 + 1) * VAR_16;
    }
    else
    {
        if (((tmsize_t)VAR_11 + 1) != 0 &&
            (tmsize_t)VAR_17 > ((VAR_30 - VAR_31) /
                                ((tmsize_t)VAR_11 + 1)))
        {
            TIFFError(""rotateImage"",
                      ""Integer overflow when calculating buffer size."");
            return (-1);
        }
        VAR_21 = (VAR_11 + 1) * VAR_17;
    }

    VAR_9 = (VAR_26 + 7) / 8;
    VAR_8 = ((VAR_26 * VAR_25) + 7) / 8;
    if (VAR_8 < (VAR_9 + 1))
        VAR_7 = VAR_8;
    else
        VAR_7 = VAR_9 + 1;

    switch (VAR_0)
    {
        case 0:
        case 360:
            return (0);
        case 90:
        case 180:
        case 270:
            break;
        default:
            TIFFError(""rotateImage"", ""Invalid rotation angle %"" VAR_32,
                      VAR_0);
            return (-1);
    }

    /* COMMENT_0 */
    if (!(VAR_28 =
              (unsigned char *)limitMalloc(VAR_21 + VAR_31)))
    {
        TIFFError(""rotateImage"",
                  ""Unable to allocate rotation buffer of %"" VAR_33
                  "" bytes "",
                  VAR_21 + VAR_31);
        return (-1);
    }
    _TIFFmemset(VAR_28, '\0', VAR_21 + VAR_31);
    if (VAR_5 != NULL)
        *VAR_5 = VAR_21;

    VAR_22 = *VAR_4;
    switch (VAR_0)
    {
        case 180:
            if ((VAR_26 % 8) == 0) /* COMMENT_1 */
            {
                VAR_23 = VAR_22;
                VAR_20 = (VAR_25 * VAR_26) / 8;
                for (VAR_10 = 0; VAR_10 < VAR_17; VAR_10++)
                {
                    VAR_13 = (VAR_17 - VAR_10 - 1) * VAR_11;
                    for (VAR_15 = 0; VAR_15 < VAR_16; VAR_15++)
                    {
                        VAR_19 = (VAR_16 - VAR_15 - 1) * VAR_20;
                        VAR_24 = VAR_28 + VAR_13 + VAR_19;

                        for (VAR_14 = 0; VAR_14 < VAR_8; VAR_14++)
                            *VAR_24++ = *VAR_23++;
                    }
                }
            }
            else
            { /* COMMENT_2 */
                for (VAR_10 = 0; VAR_10 < VAR_17; VAR_10++)
                {
                    VAR_12 = VAR_10 * VAR_11;
                    VAR_13 = (VAR_17 - VAR_10 - 1) * VAR_11;
                    VAR_23 = VAR_22 + VAR_12;
                    VAR_24 = VAR_28 + VAR_13;
                    switch (VAR_7)
                    {
                        case 1:
                            if (VAR_26 == 1)
                            {
                                if (reverseSamples8bits(VAR_25, VAR_26, VAR_16, VAR_23,
                                                        VAR_24))
                                {
                                    _TIFFfree(VAR_28);
                                    return (-1);
                                }
                                break;
                            }
                            if (reverseSamples16bits(VAR_25, VAR_26, VAR_16, VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (reverseSamples24bits(VAR_25, VAR_26, VAR_16, VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (reverseSamples32bits(VAR_25, VAR_26, VAR_16, VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" VAR_32, VAR_26);
                            _TIFFfree(VAR_28);
                            return (-1);
                    }
                }
            }
            _TIFFfree(VAR_22);
            *(VAR_4) = VAR_28;
            break;

        case 90:
            if ((VAR_26 % 8) == 0) /* COMMENT_1 */
            {
                for (VAR_15 = 0; VAR_15 < VAR_16; VAR_15++)
                {
                    VAR_12 =
                        ((VAR_17 - 1) * VAR_11) + (VAR_15 * VAR_8);
                    VAR_13 = VAR_15 * VAR_18;
                    VAR_23 = VAR_22 + VAR_12;
                    VAR_24 = VAR_28 + VAR_13;
                    for (VAR_10 = VAR_17; VAR_10 > 0; VAR_10--)
                    {
                        for (VAR_14 = 0; VAR_14 < VAR_8; VAR_14++)
                            *VAR_24++ = *(VAR_23 + VAR_14);
                        VAR_23 -= VAR_11;
                    }
                }
            }
            else
            { /* COMMENT_2 */
                for (VAR_15 = 0; VAR_15 < VAR_16; VAR_15++)
                {
                    VAR_12 = (VAR_17 - 1) * VAR_11;
                    VAR_13 = VAR_15 * VAR_18;
                    VAR_23 = VAR_22 + VAR_12;
                    VAR_24 = VAR_28 + VAR_13;
                    switch (VAR_7)
                    {
                        case 1:
                            if (VAR_26 == 1)
                            {
                                if (rotateContigSamples8bits(VAR_0, VAR_25, VAR_26,
                                                             VAR_16, VAR_17, VAR_15,
                                                             VAR_23, VAR_24))
                                {
                                    _TIFFfree(VAR_28);
                                    return (-1);
                                }
                                break;
                            }
                            if (rotateContigSamples16bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (rotateContigSamples24bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (rotateContigSamples32bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" VAR_32, VAR_26);
                            _TIFFfree(VAR_28);
                            return (-1);
                    }
                }
            }
            _TIFFfree(VAR_22);
            *(VAR_4) = VAR_28;

            *VAR_2 = VAR_17;
            *VAR_3 = VAR_16;
            /* COMMENT_3 */
            if (VAR_6)
            {
                VAR_1->width = VAR_17;
                VAR_1->length = VAR_16;
                VAR_27 = VAR_1->xres;
                VAR_1->xres = VAR_1->yres;
                VAR_1->yres = VAR_27;
            }
            break;

        case 270:
            if ((VAR_26 % 8) == 0) /* COMMENT_1 */
            {
                for (VAR_15 = 0; VAR_15 < VAR_16; VAR_15++)
                {
                    VAR_12 = VAR_15 * VAR_8;
                    VAR_13 = (VAR_16 - VAR_15 - 1) * VAR_18;
                    VAR_23 = VAR_22 + VAR_12;
                    VAR_24 = VAR_28 + VAR_13;
                    for (VAR_10 = VAR_17; VAR_10 > 0; VAR_10--)
                    {
                        for (VAR_14 = 0; VAR_14 < VAR_8; VAR_14++)
                            *VAR_24++ = *(VAR_23 + VAR_14);
                        VAR_23 += VAR_11;
                    }
                }
            }
            else
            { /* COMMENT_2 */
                for (VAR_15 = 0; VAR_15 < VAR_16; VAR_15++)
                {
                    VAR_12 = 0;
                    VAR_13 = (VAR_16 - VAR_15 - 1) * VAR_18;
                    VAR_23 = VAR_22 + VAR_12;
                    VAR_24 = VAR_28 + VAR_13;
                    switch (VAR_7)
                    {
                        case 1:
                            if (VAR_26 == 1)
                            {
                                if (rotateContigSamples8bits(VAR_0, VAR_25, VAR_26,
                                                             VAR_16, VAR_17, VAR_15,
                                                             VAR_23, VAR_24))
                                {
                                    _TIFFfree(VAR_28);
                                    return (-1);
                                }
                                break;
                            }
                            if (rotateContigSamples16bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 2:
                            if (rotateContigSamples24bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            if (rotateContigSamples32bits(VAR_0, VAR_25, VAR_26,
                                                          VAR_16, VAR_17, VAR_15,
                                                          VAR_23, VAR_24))
                            {
                                _TIFFfree(VAR_28);
                                return (-1);
                            }
                            break;
                        default:
                            TIFFError(""rotateImage"",
                                      ""Unsupported bit depth %"" VAR_32, VAR_26);
                            _TIFFfree(VAR_28);
                            return (-1);
                    }
                }
            }
            _TIFFfree(VAR_22);
            *(VAR_4) = VAR_28;

            *VAR_2 = VAR_17;
            *VAR_3 = VAR_16;
            /* COMMENT_3 */
            if (VAR_6)
            {
                VAR_1->width = VAR_17;
                VAR_1->length = VAR_16;
                VAR_27 = VAR_1->xres;
                VAR_1->xres = VAR_1->yres;
                VAR_1->yres = VAR_27;
            }
            break;
        default:
            break;
    }

    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static int rotateImage(uint16_t rotation, struct image_data *image,
                        uint32_t *img_width, uint32_t *img_length,
-                       unsigned char **ibuff_ptr, size_t *rot_buf_size)
+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,
+                       int rot_image_params)
 {
     int shift_width;
     uint32_t bytes_per_pixel, bytes_per_sample;
@@ -248,11 +249,15 @@
 
             *img_width = length;
             *img_length = width;
-            image->width = length;
-            image->length = width;
-            res_temp = image->xres;
-            image->xres = image->yres;
-            image->yres = res_temp;
+            /* Only toggle image parameters if whole input image is rotated. */
+            if (rot_image_params)
+            {
+                image->width = length;
+                image->length = width;
+                res_temp = image->xres;
+                image->xres = image->yres;
+                image->yres = res_temp;
+            }
             break;
 
         case 270:
@@ -335,11 +340,15 @@
 
             *img_width = length;
             *img_length = width;
-            image->width = length;
-            image->length = width;
-            res_temp = image->xres;
-            image->xres = image->yres;
-            image->yres = res_temp;
+            /* Only toggle image parameters if whole input image is rotated. */
+            if (rot_image_params)
+            {
+                image->width = length;
+                image->length = width;
+                res_temp = image->xres;
+                image->xres = image->yres;
+                image->yres = res_temp;
+            }
             break;
         default:
             break;","{'deleted_lines': ['                       unsigned char **ibuff_ptr, size_t *rot_buf_size)', '            image->width = length;', '            image->length = width;', '            res_temp = image->xres;', '            image->xres = image->yres;', '            image->yres = res_temp;', '            image->width = length;', '            image->length = width;', '            res_temp = image->xres;', '            image->xres = image->yres;', '            image->yres = res_temp;'], 'added_lines': ['                       unsigned char **ibuff_ptr, size_t *rot_buf_size,', '                       int rot_image_params)', '            /* Only toggle image parameters if whole input image is rotated. */', '            if (rot_image_params)', '            {', '                image->width = length;', '                image->length = width;', '                res_temp = image->xres;', '                image->xres = image->yres;', '                image->yres = res_temp;', '            }', '            /* Only toggle image parameters if whole input image is rotated. */', '            if (rot_image_params)', '            {', '                image->width = length;', '                image->length = width;', '                res_temp = image->xres;', '                image->xres = image->yres;', '                image->yres = res_temp;', '            }']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,createCroppedImage,"static int createCroppedImage(struct image_data *image, struct crop_mask *crop,
unsigned char **read_buff_ptr,
unsigned char **crop_buff_ptr)
{
tsize_t cropsize;
unsigned char *read_buff = NULL;
unsigned char *crop_buff = NULL;
unsigned char *new_buff = NULL;
static tsize_t prev_cropsize = 0;
read_buff = *read_buff_ptr;
crop_buff = read_buff;
*crop_buff_ptr = read_buff;
crop->combined_width = image->width;
crop->combined_length = image->length;
cropsize = crop->bufftotal;
crop_buff = *crop_buff_ptr;
if (!crop_buff)
{
crop_buff =
(unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
if (!crop_buff)
{
TIFFError(""createCroppedImage"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
prev_cropsize = cropsize;
}
else
{
if (prev_cropsize < cropsize)
{
new_buff =
_TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
if (!new_buff)
{
free(crop_buff);
crop_buff = (unsigned char *)limitMalloc(
cropsize + NUM_BUFF_OVERSIZE_BYTES);
}
else
crop_buff = new_buff;
if (!crop_buff)
{
TIFFError(""createCroppedImage"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
}
}
*crop_buff_ptr = crop_buff;
if (crop->crop_mode & CROP_INVERT)
{
switch (crop->photometric)
{
case PHOTOMETRIC_MINISWHITE:
case PHOTOMETRIC_MINISBLACK:
image->photometric = crop->photometric;
break;
case INVERT_DATA_ONLY:
case INVERT_DATA_AND_TAG:
if (invertImage(image->photometric, image->spp, image->bps,
crop->combined_width, crop->combined_length,
crop_buff))
{
TIFFError(""createCroppedImage"",
""Failed to invert colorspace for image or ""
""cropped selection"");
return (-1);
}
if (crop->photometric == INVERT_DATA_AND_TAG)
{
switch (image->photometric)
{
case PHOTOMETRIC_MINISWHITE:
image->photometric = PHOTOMETRIC_MINISBLACK;
break;
case PHOTOMETRIC_MINISBLACK:
image->photometric = PHOTOMETRIC_MINISWHITE;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (crop->crop_mode & CROP_MIRROR)
{
if (mirrorImage(image->spp, image->bps, crop->mirror,
crop->combined_width, crop->combined_length, crop_buff))
{
TIFFError(""createCroppedImage"",
""Failed to mirror image or cropped selection %s"",
(crop->rotation == MIRROR_HORIZ) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (crop->crop_mode &
CROP_ROTATE) 
{
if (rotateImage(crop->rotation, image, &crop->combined_width,
&crop->combined_length, crop_buff_ptr, NULL))
{
TIFFError(""createCroppedImage"",
""Failed to rotate image or cropped selection by %"" PRIu16
"" degrees"",
crop->rotation);
return (-1);
}
}
if (crop_buff ==
read_buff)             
*read_buff_ptr = NULL; 
return (0);
}","static int createCroppedImage(struct image_data *VAR_0, struct crop_mask *VAR_1,
unsigned char **VAR_2,
unsigned char **VAR_3)
{
tsize_t VAR_4;
unsigned char *VAR_5 = NULL;
unsigned char *VAR_6 = NULL;
unsigned char *VAR_7 = NULL;
static tsize_t VAR_8 = 0;
VAR_5 = *VAR_2;
VAR_6 = VAR_5;
*VAR_3 = VAR_5;
VAR_1->combined_width = VAR_0->width;
VAR_1->combined_length = VAR_0->length;
VAR_4 = VAR_1->bufftotal;
VAR_6 = *VAR_3;
if (!VAR_6)
{
VAR_6 =
(unsigned char *)limitMalloc(VAR_4 + VAR_9);
if (!VAR_6)
{
TIFFError(""createCroppedImage"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(VAR_6, 0, VAR_4 + VAR_9);
VAR_8 = VAR_4;
}
else
{
if (VAR_8 < VAR_4)
{
VAR_7 =
_TIFFrealloc(VAR_6, VAR_4 + VAR_9);
if (!VAR_7)
{
free(VAR_6);
VAR_6 = (unsigned char *)limitMalloc(
VAR_4 + VAR_9);
}
else
VAR_6 = VAR_7;
if (!VAR_6)
{
TIFFError(""createCroppedImage"",
""Unable to allocate/reallocate crop buffer"");
return (-1);
}
_TIFFmemset(VAR_6, 0, VAR_4 + VAR_9);
}
}
*VAR_3 = VAR_6;
if (VAR_1->crop_mode & VAR_10)
{
switch (VAR_1->photometric)
{
case VAR_11:
case VAR_12:
VAR_0->photometric = VAR_1->photometric;
break;
case VAR_13:
case VAR_14:
if (invertImage(VAR_0->photometric, VAR_0->spp, VAR_0->bps,
VAR_1->combined_width, VAR_1->combined_length,
VAR_6))
{
TIFFError(""createCroppedImage"",
""Failed to invert colorspace for image or ""
""cropped selection"");
return (-1);
}
if (VAR_1->photometric == VAR_14)
{
switch (VAR_0->photometric)
{
case VAR_11:
VAR_0->photometric = VAR_12;
break;
case VAR_12:
VAR_0->photometric = VAR_11;
break;
default:
break;
}
}
break;
default:
break;
}
}
if (VAR_1->crop_mode & VAR_15)
{
if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror,
VAR_1->combined_width, VAR_1->combined_length, VAR_6))
{
TIFFError(""createCroppedImage"",
""Failed to mirror image or cropped selection %s"",
(VAR_1->rotation == VAR_16) ? ""horizontally""
: ""vertically"");
return (-1);
}
}
if (VAR_1->crop_mode &
VAR_17) 
{
if (rotateImage(VAR_1->rotation, VAR_0, &VAR_1->combined_width,
&VAR_1->combined_length, VAR_3, NULL))
{
TIFFError(""createCroppedImage"",
""Failed to rotate image or cropped selection by %"" VAR_18
"" degrees"",
VAR_1->rotation);
return (-1);
}
}
if (VAR_6 ==
VAR_5)             
*VAR_2 = NULL; 
return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/5.json,"static int createCroppedImage(struct image_data *image, struct crop_mask *crop,
                              unsigned char **read_buff_ptr,
                              unsigned char **crop_buff_ptr)
{
    tsize_t cropsize;
    unsigned char *read_buff = NULL;
    unsigned char *crop_buff = NULL;
    unsigned char *new_buff = NULL;
    static tsize_t prev_cropsize = 0;

    read_buff = *read_buff_ptr;

    /* process full image, no crop buffer needed */
    crop_buff = read_buff;
    *crop_buff_ptr = read_buff;
    crop->combined_width = image->width;
    crop->combined_length = image->length;

    cropsize = crop->bufftotal;
    crop_buff = *crop_buff_ptr;
    if (!crop_buff)
    {
        crop_buff =
            (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
        if (!crop_buff)
        {
            TIFFError(""createCroppedImage"",
                      ""Unable to allocate/reallocate crop buffer"");
            return (-1);
        }
        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
        prev_cropsize = cropsize;
    }
    else
    {
        if (prev_cropsize < cropsize)
        {
            new_buff =
                _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
            if (!new_buff)
            {
                free(crop_buff);
                crop_buff = (unsigned char *)limitMalloc(
                    cropsize + NUM_BUFF_OVERSIZE_BYTES);
            }
            else
                crop_buff = new_buff;
            if (!crop_buff)
            {
                TIFFError(""createCroppedImage"",
                          ""Unable to allocate/reallocate crop buffer"");
                return (-1);
            }
            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
        }
    }

    *crop_buff_ptr = crop_buff;

    if (crop->crop_mode & CROP_INVERT)
    {
        switch (crop->photometric)
        {
            /* Just change the interpretation */
            case PHOTOMETRIC_MINISWHITE:
            case PHOTOMETRIC_MINISBLACK:
                image->photometric = crop->photometric;
                break;
            case INVERT_DATA_ONLY:
            case INVERT_DATA_AND_TAG:
                if (invertImage(image->photometric, image->spp, image->bps,
                                crop->combined_width, crop->combined_length,
                                crop_buff))
                {
                    TIFFError(""createCroppedImage"",
                              ""Failed to invert colorspace for image or ""
                              ""cropped selection"");
                    return (-1);
                }
                if (crop->photometric == INVERT_DATA_AND_TAG)
                {
                    switch (image->photometric)
                    {
                        case PHOTOMETRIC_MINISWHITE:
                            image->photometric = PHOTOMETRIC_MINISBLACK;
                            break;
                        case PHOTOMETRIC_MINISBLACK:
                            image->photometric = PHOTOMETRIC_MINISWHITE;
                            break;
                        default:
                            break;
                    }
                }
                break;
            default:
                break;
        }
    }

    if (crop->crop_mode & CROP_MIRROR)
    {
        if (mirrorImage(image->spp, image->bps, crop->mirror,
                        crop->combined_width, crop->combined_length, crop_buff))
        {
            TIFFError(""createCroppedImage"",
                      ""Failed to mirror image or cropped selection %s"",
                      (crop->rotation == MIRROR_HORIZ) ? ""horizontally""
                                                       : ""vertically"");
            return (-1);
        }
    }

    if (crop->crop_mode &
        CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
    {
        if (rotateImage(crop->rotation, image, &crop->combined_width,
                        &crop->combined_length, crop_buff_ptr, NULL, TRUE))
        {
            TIFFError(""createCroppedImage"",
                      ""Failed to rotate image or cropped selection by %"" PRIu16
                      "" degrees"",
                      crop->rotation);
            return (-1);
        }
    }

    if (crop_buff ==
        read_buff)             /* we used the read buffer for the crop buffer */
        *read_buff_ptr = NULL; /* so we don't try to free it later */

    return (0);
}","static int createCroppedImage(struct image_data *VAR_0, struct crop_mask *VAR_1,
                              unsigned char **VAR_2,
                              unsigned char **VAR_3)
{
    tsize_t VAR_4;
    unsigned char *VAR_5 = NULL;
    unsigned char *VAR_6 = NULL;
    unsigned char *VAR_7 = NULL;
    static tsize_t VAR_8 = 0;

    VAR_5 = *VAR_2;

    /* COMMENT_0 */
    VAR_6 = VAR_5;
    *VAR_3 = VAR_5;
    VAR_1->combined_width = VAR_0->width;
    VAR_1->combined_length = VAR_0->length;

    VAR_4 = VAR_1->bufftotal;
    VAR_6 = *VAR_3;
    if (!VAR_6)
    {
        VAR_6 =
            (unsigned char *)limitMalloc(VAR_4 + VAR_9);
        if (!VAR_6)
        {
            TIFFError(""createCroppedImage"",
                      ""Unable to allocate/reallocate crop buffer"");
            return (-1);
        }
        _TIFFmemset(VAR_6, 0, VAR_4 + VAR_9);
        VAR_8 = VAR_4;
    }
    else
    {
        if (VAR_8 < VAR_4)
        {
            VAR_7 =
                _TIFFrealloc(VAR_6, VAR_4 + VAR_9);
            if (!VAR_7)
            {
                free(VAR_6);
                VAR_6 = (unsigned char *)limitMalloc(
                    VAR_4 + VAR_9);
            }
            else
                VAR_6 = VAR_7;
            if (!VAR_6)
            {
                TIFFError(""createCroppedImage"",
                          ""Unable to allocate/reallocate crop buffer"");
                return (-1);
            }
            _TIFFmemset(VAR_6, 0, VAR_4 + VAR_9);
        }
    }

    *VAR_3 = VAR_6;

    if (VAR_1->crop_mode & VAR_10)
    {
        switch (VAR_1->photometric)
        {
            /* COMMENT_1 */
            case VAR_11:
            case VAR_12:
                VAR_0->photometric = VAR_1->photometric;
                break;
            case VAR_13:
            case VAR_14:
                if (invertImage(VAR_0->photometric, VAR_0->spp, VAR_0->bps,
                                VAR_1->combined_width, VAR_1->combined_length,
                                VAR_6))
                {
                    TIFFError(""createCroppedImage"",
                              ""Failed to invert colorspace for image or ""
                              ""cropped selection"");
                    return (-1);
                }
                if (VAR_1->photometric == VAR_14)
                {
                    switch (VAR_0->photometric)
                    {
                        case VAR_11:
                            VAR_0->photometric = VAR_12;
                            break;
                        case VAR_12:
                            VAR_0->photometric = VAR_11;
                            break;
                        default:
                            break;
                    }
                }
                break;
            default:
                break;
        }
    }

    if (VAR_1->crop_mode & VAR_15)
    {
        if (mirrorImage(VAR_0->spp, VAR_0->bps, VAR_1->mirror,
                        VAR_1->combined_width, VAR_1->combined_length, VAR_6))
        {
            TIFFError(""createCroppedImage"",
                      ""Failed to mirror image or cropped selection %s"",
                      (VAR_1->rotation == VAR_16) ? ""horizontally""
                                                       : ""vertically"");
            return (-1);
        }
    }

    if (VAR_1->crop_mode &
        VAR_17) /* COMMENT_2 */
    {
        if (rotateImage(VAR_1->rotation, VAR_0, &VAR_1->combined_width,
                        &VAR_1->combined_length, VAR_3, NULL, TRUE))
        {
            TIFFError(""createCroppedImage"",
                      ""Failed to rotate image or cropped selection by %"" VAR_18
                      "" degrees"",
                      VAR_1->rotation);
            return (-1);
        }
    }

    if (VAR_6 ==
        VAR_5)             /* COMMENT_3 */
        *VAR_2 = NULL; /* COMMENT_4 */

    return (0);
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -114,7 +114,7 @@
         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
         if (rotateImage(crop->rotation, image, &crop->combined_width,
-                        &crop->combined_length, crop_buff_ptr, NULL))
+                        &crop->combined_length, crop_buff_ptr, NULL, TRUE))
         {
             TIFFError(""createCroppedImage"",
                       ""Failed to rotate image or cropped selection by %"" PRIu16","{'deleted_lines': ['                        &crop->combined_length, crop_buff_ptr, NULL))'], 'added_lines': ['                        &crop->combined_length, crop_buff_ptr, NULL, TRUE))']}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-0795,"['CWE-416', 'CWE-120', 'CWE-125']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tiffcrop: Amend rotateImage() not to toggle the input (main) image width and length parameters when only cropped image sections are rotated.
Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519
",69818e2f2d246e6631ac2a2da692c3706b849c38,https://gitlab.com/libtiff/libtiff/-/commit/69818e2f2d246e6631ac2a2da692c3706b849c38,tools/tiffcrop.c,initCropMasks,"static void initCropMasks(struct crop_mask *cps)
{
int i;
cps->crop_mode = CROP_NONE;
cps->res_unit = RESUNIT_NONE;
cps->edge_ref = EDGE_TOP;
cps->width = 0;
cps->length = 0;
for (i = 0; i < 4; i++)
cps->margins[i] = 0.0;
cps->bufftotal = (uint32_t)0;
cps->combined_width = (uint32_t)0;
cps->combined_length = (uint32_t)0;
cps->rotation = (uint16_t)0;
cps->photometric = INVERT_DATA_AND_TAG;
cps->mirror = (uint16_t)0;
cps->invert = (uint16_t)0;
cps->zones = (uint32_t)0;
cps->regions = (uint32_t)0;
for (i = 0; i < MAX_REGIONS; i++)
{
cps->corners[i].X1 = 0.0;
cps->corners[i].X2 = 0.0;
cps->corners[i].Y1 = 0.0;
cps->corners[i].Y2 = 0.0;
cps->regionlist[i].x1 = 0;
cps->regionlist[i].x2 = 0;
cps->regionlist[i].y1 = 0;
cps->regionlist[i].y2 = 0;
cps->regionlist[i].width = 0;
cps->regionlist[i].length = 0;
cps->regionlist[i].buffsize = 0;
cps->regionlist[i].buffptr = NULL;
cps->zonelist[i].position = 0;
cps->zonelist[i].total = 0;
}
cps->exp_mode = ONE_FILE_COMPOSITE;
cps->img_mode = COMPOSITE_IMAGES;
}","static void initCropMasks(struct crop_mask *VAR_0)
{
int VAR_1;
VAR_0->crop_mode = VAR_2;
VAR_0->res_unit = VAR_3;
VAR_0->edge_ref = VAR_4;
VAR_0->width = 0;
VAR_0->length = 0;
for (VAR_1 = 0; VAR_1 < 4; VAR_1++)
VAR_0->margins[VAR_1] = 0.0;
VAR_0->bufftotal = (uint32_t)0;
VAR_0->combined_width = (uint32_t)0;
VAR_0->combined_length = (uint32_t)0;
VAR_0->rotation = (uint16_t)0;
VAR_0->photometric = VAR_5;
VAR_0->mirror = (uint16_t)0;
VAR_0->invert = (uint16_t)0;
VAR_0->zones = (uint32_t)0;
VAR_0->regions = (uint32_t)0;
for (VAR_1 = 0; VAR_1 < VAR_6; VAR_1++)
{
VAR_0->corners[VAR_1].X1 = 0.0;
VAR_0->corners[VAR_1].X2 = 0.0;
VAR_0->corners[VAR_1].Y1 = 0.0;
VAR_0->corners[VAR_1].Y2 = 0.0;
VAR_0->regionlist[VAR_1].x1 = 0;
VAR_0->regionlist[VAR_1].x2 = 0;
VAR_0->regionlist[VAR_1].y1 = 0;
VAR_0->regionlist[VAR_1].y2 = 0;
VAR_0->regionlist[VAR_1].width = 0;
VAR_0->regionlist[VAR_1].length = 0;
VAR_0->regionlist[VAR_1].buffsize = 0;
VAR_0->regionlist[VAR_1].buffptr = NULL;
VAR_0->zonelist[VAR_1].position = 0;
VAR_0->zonelist[VAR_1].total = 0;
}
VAR_0->exp_mode = VAR_7;
VAR_0->img_mode = VAR_8;
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/before/6.json,"static void initCropMasks(struct crop_mask *cps)
{
    int i;

    cps->crop_mode = CROP_NONE;
    cps->res_unit = RESUNIT_NONE;
    cps->edge_ref = EDGE_TOP;
    cps->width = 0;
    cps->length = 0;
    for (i = 0; i < 4; i++)
        cps->margins[i] = 0.0;
    cps->bufftotal = (uint32_t)0;
    cps->combined_width = (uint32_t)0;
    cps->combined_length = (uint32_t)0;
    cps->rotation = (uint16_t)0;
    cps->photometric = INVERT_DATA_AND_TAG;
    cps->mirror = (uint16_t)0;
    cps->invert = (uint16_t)0;
    cps->zones = (uint32_t)0;
    cps->regions = (uint32_t)0;
    for (i = 0; i < MAX_REGIONS; i++)
    {
        cps->corners[i].X1 = 0.0;
        cps->corners[i].X2 = 0.0;
        cps->corners[i].Y1 = 0.0;
        cps->corners[i].Y2 = 0.0;
        cps->regionlist[i].x1 = 0;
        cps->regionlist[i].x2 = 0;
        cps->regionlist[i].y1 = 0;
        cps->regionlist[i].y2 = 0;
        cps->regionlist[i].width = 0;
        cps->regionlist[i].length = 0;
        cps->regionlist[i].buffsize = 0;
        cps->zonelist[i].position = 0;
        cps->zonelist[i].total = 0;
    }
    cps->exp_mode = ONE_FILE_COMPOSITE;
    cps->img_mode = COMPOSITE_IMAGES;
}","static void initCropMasks(struct crop_mask *VAR_0)
{
    int VAR_1;

    VAR_0->crop_mode = VAR_2;
    VAR_0->res_unit = VAR_3;
    VAR_0->edge_ref = VAR_4;
    VAR_0->width = 0;
    VAR_0->length = 0;
    for (VAR_1 = 0; VAR_1 < 4; VAR_1++)
        VAR_0->margins[VAR_1] = 0.0;
    VAR_0->bufftotal = (uint32_t)0;
    VAR_0->combined_width = (uint32_t)0;
    VAR_0->combined_length = (uint32_t)0;
    VAR_0->rotation = (uint16_t)0;
    VAR_0->photometric = VAR_5;
    VAR_0->mirror = (uint16_t)0;
    VAR_0->invert = (uint16_t)0;
    VAR_0->zones = (uint32_t)0;
    VAR_0->regions = (uint32_t)0;
    for (VAR_1 = 0; VAR_1 < VAR_6; VAR_1++)
    {
        VAR_0->corners[VAR_1].X1 = 0.0;
        VAR_0->corners[VAR_1].X2 = 0.0;
        VAR_0->corners[VAR_1].Y1 = 0.0;
        VAR_0->corners[VAR_1].Y2 = 0.0;
        VAR_0->regionlist[VAR_1].x1 = 0;
        VAR_0->regionlist[VAR_1].x2 = 0;
        VAR_0->regionlist[VAR_1].y1 = 0;
        VAR_0->regionlist[VAR_1].y2 = 0;
        VAR_0->regionlist[VAR_1].width = 0;
        VAR_0->regionlist[VAR_1].length = 0;
        VAR_0->regionlist[VAR_1].buffsize = 0;
        VAR_0->zonelist[VAR_1].position = 0;
        VAR_0->zonelist[VAR_1].total = 0;
    }
    VAR_0->exp_mode = VAR_7;
    VAR_0->img_mode = VAR_8;
}",libtiff/69818e2f2d246e6631ac2a2da692c3706b849c38/tiffcrop.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -31,7 +31,6 @@
         cps->regionlist[i].width = 0;
         cps->regionlist[i].length = 0;
         cps->regionlist[i].buffsize = 0;
-        cps->regionlist[i].buffptr = NULL;
         cps->zonelist[i].position = 0;
         cps->zonelist[i].total = 0;
     }","{'deleted_lines': ['        cps->regionlist[i].buffptr = NULL;'], 'added_lines': []}",True,"LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",5.5,MEDIUM,1,valid,,5
CVE-2023-26606,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Syzbot reports an out of bound access in ntfs_trim_fs.
The cause of this is using a loop termination condition that compares
window index (iw) with wnd->nbits instead of wnd->nwnd, due to which the
index used for wnd->free_bits exceeds the size of the array allocated.

Fix the loop condition.

Fixes: 3f3b442b5ad2 (""fs/ntfs3: Add bitmap"")
Link: https://syzkaller.appspot.com/bug?extid=b892240eac461e488d51
Reported-by: syzbot+b892240eac461e488d51@syzkaller.appspotmail.com
Signed-off-by: Abdun Nihaal <abdun.nihaal@gmail.com>
Signed-off-by: Konstantin Komarov <almaz.alexandrovich@paragon-software.com>
",557d19675a470bb0a98beccec38c5dc3735c20fa,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=557d19675a470bb0a98beccec38c5dc3735c20fa,fs/ntfs3/bitmap.c,ntfs_trim_fs,"int ntfs_trim_fs(struct ntfs_sb_info *sbi, struct fstrim_range *range)
{
int err = 0;
struct super_block *sb = sbi->sb;
struct wnd_bitmap *wnd = &sbi->used.bitmap;
u32 wbits = 8 * sb->s_blocksize;
CLST len = 0, lcn = 0, done = 0;
CLST minlen = bytes_to_cluster(sbi, range->minlen);
CLST lcn_from = bytes_to_cluster(sbi, range->start);
size_t iw = lcn_from >> (sb->s_blocksize_bits + 3);
u32 wbit = lcn_from & (wbits - 1);
const ulong *buf;
CLST lcn_to;
if (!minlen)
minlen = 1;
if (range->len == (u64)-1)
lcn_to = wnd->nbits;
else
lcn_to = bytes_to_cluster(sbi, range->start + range->len);
down_read_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);
for (; iw < wnd->nbits; iw++, wbit = 0) {
CLST lcn_wnd = iw * wbits;
struct buffer_head *bh;
if (lcn_wnd > lcn_to)
break;
if (!wnd->free_bits[iw])
continue;
if (iw + 1 == wnd->nwnd)
wbits = wnd->bits_last;
if (lcn_wnd + wbits > lcn_to)
wbits = lcn_to - lcn_wnd;
bh = wnd_map(wnd, iw);
if (IS_ERR(bh)) {
err = PTR_ERR(bh);
break;
}
buf = (ulong *)bh->b_data;
for (; wbit < wbits; wbit++) {
if (!test_bit(wbit, buf)) {
if (!len)
lcn = lcn_wnd + wbit;
len += 1;
continue;
}
if (len >= minlen) {
err = ntfs_discard(sbi, lcn, len);
if (err)
goto out;
done += len;
}
len = 0;
}
put_bh(bh);
}
if (len >= minlen) {
err = ntfs_discard(sbi, lcn, len);
if (err)
goto out;
done += len;
}
out:
range->len = (u64)done << sbi->cluster_bits;
up_read(&wnd->rw_lock);
return err;
}","int ntfs_trim_fs(struct ntfs_sb_info *VAR_0, struct fstrim_range *VAR_1)
{
int VAR_2 = 0;
struct super_block *VAR_3 = VAR_0->sb;
struct wnd_bitmap *VAR_4 = &VAR_0->used.bitmap;
u32 VAR_5 = 8 * VAR_3->s_blocksize;
CLST VAR_6 = 0, VAR_7 = 0, VAR_8 = 0;
CLST VAR_9 = bytes_to_cluster(VAR_0, VAR_1->minlen);
CLST VAR_10 = bytes_to_cluster(VAR_0, VAR_1->start);
size_t VAR_11 = VAR_10 >> (VAR_3->s_blocksize_bits + 3);
u32 VAR_12 = VAR_10 & (VAR_5 - 1);
const ulong *VAR_13;
CLST VAR_14;
if (!VAR_9)
VAR_9 = 1;
if (VAR_1->len == (VAR_15)-1)
VAR_14 = VAR_4->nbits;
else
VAR_14 = bytes_to_cluster(VAR_0, VAR_1->start + VAR_1->len);
down_read_nested(&VAR_4->rw_lock, VAR_16);
for (; VAR_11 < VAR_4->nbits; VAR_11++, VAR_12 = 0) {
CLST VAR_17 = VAR_11 * VAR_5;
struct buffer_head *VAR_18;
if (VAR_17 > VAR_14)
break;
if (!VAR_4->free_bits[VAR_11])
continue;
if (VAR_11 + 1 == VAR_4->nwnd)
VAR_5 = VAR_4->bits_last;
if (VAR_17 + VAR_5 > VAR_14)
VAR_5 = VAR_14 - VAR_17;
VAR_18 = wnd_map(VAR_4, VAR_11);
if (IS_ERR(VAR_18)) {
VAR_2 = PTR_ERR(VAR_18);
break;
}
VAR_13 = (ulong *)VAR_18->b_data;
for (; VAR_12 < VAR_5; VAR_12++) {
if (!test_bit(VAR_12, VAR_13)) {
if (!VAR_6)
VAR_7 = VAR_17 + VAR_12;
VAR_6 += 1;
continue;
}
if (VAR_6 >= VAR_9) {
VAR_2 = ntfs_discard(VAR_0, VAR_7, VAR_6);
if (VAR_2)
goto out;
VAR_8 += VAR_6;
}
VAR_6 = 0;
}
put_bh(VAR_18);
}
if (VAR_6 >= VAR_9) {
VAR_2 = ntfs_discard(VAR_0, VAR_7, VAR_6);
if (VAR_2)
goto out;
VAR_8 += VAR_6;
}
out:
VAR_1->len = (u64)VAR_8 << VAR_0->cluster_bits;
up_read(&VAR_4->rw_lock);
return VAR_2;
}",torvalds/linux/557d19675a470bb0a98beccec38c5dc3735c20fa/bitmap.c/vul/before/0.json,"int ntfs_trim_fs(struct ntfs_sb_info *sbi, struct fstrim_range *range)
{
	int err = 0;
	struct super_block *sb = sbi->sb;
	struct wnd_bitmap *wnd = &sbi->used.bitmap;
	u32 wbits = 8 * sb->s_blocksize;
	CLST len = 0, lcn = 0, done = 0;
	CLST minlen = bytes_to_cluster(sbi, range->minlen);
	CLST lcn_from = bytes_to_cluster(sbi, range->start);
	size_t iw = lcn_from >> (sb->s_blocksize_bits + 3);
	u32 wbit = lcn_from & (wbits - 1);
	const ulong *buf;
	CLST lcn_to;

	if (!minlen)
		minlen = 1;

	if (range->len == (u64)-1)
		lcn_to = wnd->nbits;
	else
		lcn_to = bytes_to_cluster(sbi, range->start + range->len);

	down_read_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);

	for (; iw < wnd->nwnd; iw++, wbit = 0) {
		CLST lcn_wnd = iw * wbits;
		struct buffer_head *bh;

		if (lcn_wnd > lcn_to)
			break;

		if (!wnd->free_bits[iw])
			continue;

		if (iw + 1 == wnd->nwnd)
			wbits = wnd->bits_last;

		if (lcn_wnd + wbits > lcn_to)
			wbits = lcn_to - lcn_wnd;

		bh = wnd_map(wnd, iw);
		if (IS_ERR(bh)) {
			err = PTR_ERR(bh);
			break;
		}

		buf = (ulong *)bh->b_data;

		for (; wbit < wbits; wbit++) {
			if (!test_bit(wbit, buf)) {
				if (!len)
					lcn = lcn_wnd + wbit;
				len += 1;
				continue;
			}
			if (len >= minlen) {
				err = ntfs_discard(sbi, lcn, len);
				if (err)
					goto out;
				done += len;
			}
			len = 0;
		}
		put_bh(bh);
	}

	/* Process the last fragment. */
	if (len >= minlen) {
		err = ntfs_discard(sbi, lcn, len);
		if (err)
			goto out;
		done += len;
	}

out:
	range->len = (u64)done << sbi->cluster_bits;

	up_read(&wnd->rw_lock);

	return err;
}","int ntfs_trim_fs(struct ntfs_sb_info *VAR_0, struct fstrim_range *VAR_1)
{
	int VAR_2 = 0;
	struct super_block *VAR_3 = VAR_0->sb;
	struct wnd_bitmap *VAR_4 = &VAR_0->used.bitmap;
	u32 VAR_5 = 8 * VAR_3->s_blocksize;
	CLST VAR_6 = 0, VAR_7 = 0, VAR_8 = 0;
	CLST VAR_9 = bytes_to_cluster(VAR_0, VAR_1->minlen);
	CLST VAR_10 = bytes_to_cluster(VAR_0, VAR_1->start);
	size_t VAR_11 = VAR_10 >> (VAR_3->s_blocksize_bits + 3);
	u32 VAR_12 = VAR_10 & (VAR_5 - 1);
	const ulong *VAR_13;
	CLST VAR_14;

	if (!VAR_9)
		VAR_9 = 1;

	if (VAR_1->len == (VAR_15)-1)
		VAR_14 = VAR_4->nbits;
	else
		VAR_14 = bytes_to_cluster(VAR_0, VAR_1->start + VAR_1->len);

	down_read_nested(&VAR_4->rw_lock, VAR_16);

	for (; VAR_11 < VAR_4->nwnd; VAR_11++, VAR_12 = 0) {
		CLST VAR_17 = VAR_11 * VAR_5;
		struct buffer_head *VAR_18;

		if (VAR_17 > VAR_14)
			break;

		if (!VAR_4->free_bits[VAR_11])
			continue;

		if (VAR_11 + 1 == VAR_4->nwnd)
			VAR_5 = VAR_4->bits_last;

		if (VAR_17 + VAR_5 > VAR_14)
			VAR_5 = VAR_14 - VAR_17;

		VAR_18 = wnd_map(VAR_4, VAR_11);
		if (IS_ERR(VAR_18)) {
			VAR_2 = PTR_ERR(VAR_18);
			break;
		}

		VAR_13 = (ulong *)VAR_18->b_data;

		for (; VAR_12 < VAR_5; VAR_12++) {
			if (!test_bit(VAR_12, VAR_13)) {
				if (!VAR_6)
					VAR_7 = VAR_17 + VAR_12;
				VAR_6 += 1;
				continue;
			}
			if (VAR_6 >= VAR_9) {
				VAR_2 = ntfs_discard(VAR_0, VAR_7, VAR_6);
				if (VAR_2)
					goto out;
				VAR_8 += VAR_6;
			}
			VAR_6 = 0;
		}
		put_bh(VAR_18);
	}

	/* COMMENT_0 */
	if (VAR_6 >= VAR_9) {
		VAR_2 = ntfs_discard(VAR_0, VAR_7, VAR_6);
		if (VAR_2)
			goto out;
		VAR_8 += VAR_6;
	}

out:
	VAR_1->len = (u64)VAR_8 << VAR_0->cluster_bits;

	up_read(&VAR_4->rw_lock);

	return VAR_2;
}",torvalds/linux/557d19675a470bb0a98beccec38c5dc3735c20fa/bitmap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,7 +22,7 @@
 
 	down_read_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);
 
-	for (; iw < wnd->nbits; iw++, wbit = 0) {
+	for (; iw < wnd->nwnd; iw++, wbit = 0) {
 		CLST lcn_wnd = iw * wbits;
 		struct buffer_head *bh;
 ","{'deleted_lines': ['\tfor (; iw < wnd->nbits; iw++, wbit = 0) {'], 'added_lines': ['\tfor (; iw < wnd->nwnd; iw++, wbit = 0) {']}",True,"In the Linux kernel 6.0.8, there is a use-after-free in ntfs_trim_fs in fs/ntfs3/bitmap.c.",7.8,HIGH,2,valid,,5
CVE-2021-3631,['CWE-732'],AV:L/AC:M/Au:N/C:P/I:P/A:N,0,libvirt,"security: fix SELinux label generation logic

A process can access a file if the set of MCS categories
for the file is equal-to *or* a subset-of, the set of
MCS categories for the process.

If there are two VMs:

  a) svirt_t:s0:c117
  b) svirt_t:s0:c117,c720

Then VM (b) is able to access files labelled for VM (a).

IOW, we must discard case where the categories are equal
because that is a subset of many other valid category pairs.

Fixes: https://gitlab.com/libvirt/libvirt/-/issues/153
CVE-2021-3631
Reviewed-by: Peter Krempa <pkrempa@redhat.com>
Signed-off-by: Daniel P. Berrang <berrange@redhat.com>
",15073504dbb624d3f6c911e85557019d3620fdb2,https://gitlab.com/libvirt/libvirt/-/commit/15073504dbb624d3f6c911e85557019d3620fdb2,src/security/security_selinux.c,virSecuritySELinuxMCSFind,"static char *
virSecuritySELinuxMCSFind(virSecurityManager *mgr,
const char *sens,
int catMin,
int catMax)
{
virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);
int catRange;
char *mcs = NULL;
catRange = (catMax - catMin) + 1;
if (catRange < 8) {
virReportError(VIR_ERR_INTERNAL_ERROR,
_(""Category range c%d-c%d too small""),
catMin, catMax);
return NULL;
}
VIR_DEBUG(""Using sensitivity level '%s' cat min %d max %d range %d"",
sens, catMin, catMax, catRange);
for (;;) {
int c1 = virRandomInt(catRange);
int c2 = virRandomInt(catRange);
VIR_DEBUG(""Try cat %s:c%d,c%d"", sens, c1 + catMin, c2 + catMin);
if (c1 == c2) {
mcs = g_strdup_printf(""%s:c%d"", sens, catMin + c1);
} else {
if (c1 > c2) {
int t = c1;
c1 = c2;
c2 = t;
}
mcs = g_strdup_printf(""%s:c%d,c%d"", sens, catMin + c1, catMin + c2);
}
if (virHashLookup(data->mcs, mcs) == NULL)
break;
VIR_FREE(mcs);
}
return mcs;
}","static char *
virSecuritySELinuxMCSFind(virSecurityManager *VAR_0,
const char *VAR_1,
int VAR_2,
int VAR_3)
{
virSecuritySELinuxData *VAR_4 = virSecurityManagerGetPrivateData(VAR_0);
int VAR_5;
char *VAR_6 = NULL;
VAR_5 = (VAR_3 - VAR_2) + 1;
if (VAR_5 < 8) {
virReportError(VAR_7,
_(""Category range c%d-c%d too small""),
VAR_2, VAR_3);
return NULL;
}
VIR_DEBUG(""Using sensitivity level '%s' cat min %d max %d range %d"",
VAR_1, VAR_2, VAR_3, VAR_5);
for (;;) {
int VAR_8 = virRandomInt(VAR_5);
int VAR_9 = virRandomInt(VAR_5);
VIR_DEBUG(""Try cat %s:c%d,c%d"", VAR_1, VAR_8 + VAR_2, VAR_9 + VAR_2);
if (VAR_8 == VAR_9) {
VAR_6 = g_strdup_printf(""%s:c%d"", VAR_1, VAR_2 + VAR_8);
} else {
if (VAR_8 > VAR_9) {
int VAR_10 = VAR_8;
VAR_8 = VAR_9;
VAR_9 = VAR_10;
}
VAR_6 = g_strdup_printf(""%s:c%d,c%d"", VAR_1, VAR_2 + VAR_8, VAR_2 + VAR_9);
}
if (virHashLookup(VAR_4->mcs, VAR_6) == NULL)
break;
VIR_FREE(VAR_6);
}
return VAR_6;
}",libvirt/15073504dbb624d3f6c911e85557019d3620fdb2/security_selinux.c/vul/before/0.json,"static char *
virSecuritySELinuxMCSFind(virSecurityManager *mgr,
                          const char *sens,
                          int catMin,
                          int catMax)
{
    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);
    int catRange;
    char *mcs = NULL;

    /* +1 since virRandomInt range is exclusive of the upper bound */
    catRange = (catMax - catMin) + 1;

    if (catRange < 8) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _(""Category range c%d-c%d too small""),
                       catMin, catMax);
        return NULL;
    }

    VIR_DEBUG(""Using sensitivity level '%s' cat min %d max %d range %d"",
              sens, catMin, catMax, catRange);

    for (;;) {
        int c1 = virRandomInt(catRange);
        int c2 = virRandomInt(catRange);

        VIR_DEBUG(""Try cat %s:c%d,c%d"", sens, c1 + catMin, c2 + catMin);

        if (c1 == c2) {
            /*
             * A process can access a file if the set of MCS categories
             * for the file is equal-to *or* a subset-of, the set of
             * MCS categories for the process.
             *
             * IOW, we must discard case where the categories are equal
             * because that is a subset of other category pairs.
             */
            continue;
        } else {
            if (c1 > c2) {
                int t = c1;
                c1 = c2;
                c2 = t;
            }
            mcs = g_strdup_printf(""%s:c%d,c%d"", sens, catMin + c1, catMin + c2);
        }

        if (virHashLookup(data->mcs, mcs) == NULL)
            break;

        VIR_FREE(mcs);
    }

    return mcs;
}","static char *
virSecuritySELinuxMCSFind(virSecurityManager *VAR_0,
                          const char *VAR_1,
                          int VAR_2,
                          int VAR_3)
{
    virSecuritySELinuxData *VAR_4 = virSecurityManagerGetPrivateData(VAR_0);
    int VAR_5;
    char *VAR_6 = NULL;

    /* COMMENT_0 */
    VAR_5 = (VAR_3 - VAR_2) + 1;

    if (VAR_5 < 8) {
        virReportError(VAR_7,
                       _(""Category range c%d-c%d too small""),
                       VAR_2, VAR_3);
        return NULL;
    }

    VIR_DEBUG(""Using sensitivity level '%s' cat min %d max %d range %d"",
              VAR_1, VAR_2, VAR_3, VAR_5);

    for (;;) {
        int VAR_8 = virRandomInt(VAR_5);
        int VAR_9 = virRandomInt(VAR_5);

        VIR_DEBUG(""Try cat %s:c%d,c%d"", VAR_1, VAR_8 + VAR_2, VAR_9 + VAR_2);

        if (VAR_8 == VAR_9) {
            /* COMMENT_1 */
                                                                       
                                                                    
                                              
              
                                                                       
                                                                
               
            continue;
        } else {
            if (VAR_8 > VAR_9) {
                int VAR_10 = VAR_8;
                VAR_8 = VAR_9;
                VAR_9 = VAR_10;
            }
            VAR_6 = g_strdup_printf(""%s:c%d,c%d"", VAR_1, VAR_2 + VAR_8, VAR_2 + VAR_9);
        }

        if (virHashLookup(VAR_4->mcs, VAR_6) == NULL)
            break;

        VIR_FREE(VAR_6);
    }

    return VAR_6;
}",libvirt/15073504dbb624d3f6c911e85557019d3620fdb2/security_selinux.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,7 +28,15 @@
         VIR_DEBUG(""Try cat %s:c%d,c%d"", sens, c1 + catMin, c2 + catMin);
 
         if (c1 == c2) {
-            mcs = g_strdup_printf(""%s:c%d"", sens, catMin + c1);
+            /*
+             * A process can access a file if the set of MCS categories
+             * for the file is equal-to *or* a subset-of, the set of
+             * MCS categories for the process.
+             *
+             * IOW, we must discard case where the categories are equal
+             * because that is a subset of other category pairs.
+             */
+            continue;
         } else {
             if (c1 > c2) {
                 int t = c1;","{'deleted_lines': ['            mcs = g_strdup_printf(""%s:c%d"", sens, catMin + c1);'], 'added_lines': ['            /*', '             * A process can access a file if the set of MCS categories', '             * for the file is equal-to *or* a subset-of, the set of', '             * MCS categories for the process.', '             *', '             * IOW, we must discard case where the categories are equal', '             * because that is a subset of other category pairs.', '             */', '            continue;']}",True,"A flaw was found in libvirt while it generates SELinux MCS category pairs for VMs' dynamic labels. This flaw allows one exploited guest to access files labeled for another guest, resulting in the breaking out of sVirt confinement. The highest threat from this vulnerability is to confidentiality and integrity.",6.3,MEDIUM,1,valid,,5
CVE-2017-7375,['CWE-611'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,android,"DO NOT MERGE: Add validation for eternal enities

https://bugzilla.gnome.org/show_bug.cgi?id=780691

Bug: 36556310
Change-Id: I9450743e167c3c73af5e4071f3fc85e81d061648
(cherry picked from commit bef9af3d89d241bcb518c20cba6da2a2fd9ba049)
",308396a55280f69ad4112d4f9892f4cbeff042aa,https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa,parser.c,xmlParsePEReference,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
const xmlChar *name;
xmlEntityPtr entity = NULL;
xmlParserInputPtr input;
if (RAW != '%')
return;
NEXT;
name = xmlParseName(ctxt);
if (name == NULL) {
xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
""xmlParsePEReference: no name\n"");
return;
}
if (RAW != ';') {
xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
return;
}
NEXT;
ctxt->nbentities++;
if ((ctxt->sax != NULL) &&
(ctxt->sax->getParameterEntity != NULL))
entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
if (ctxt->instate == XML_PARSER_EOF)
return;
if (entity == NULL) {
if ((ctxt->standalone == 1) ||
((ctxt->hasExternalSubset == 0) &&
(ctxt->hasPErefs == 0))) {
xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name);
} else {
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name, NULL);
ctxt->valid = 0;
}
xmlParserEntityCheck(ctxt, 0, NULL, 0);
} else {
if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
(entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""Internal: %%%s; is not a parameter entity\n"",
name, NULL);
} else if (ctxt->input->free != deallocblankswrapper) {
input = xmlNewBlanksWrapperInputStream(ctxt, entity);
if (xmlPushInput(ctxt, input) < 0)
return;
} else {
input = xmlNewEntityInputStream(ctxt, entity);
if (xmlPushInput(ctxt, input) < 0)
return;
if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(ctxt);
if (ctxt->errNo ==
XML_ERR_UNSUPPORTED_ENCODING) {
xmlHaltParser(ctxt);
return;
}
}
}
}
ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
const xmlChar *VAR_1;
xmlEntityPtr VAR_2 = NULL;
xmlParserInputPtr VAR_3;
if (VAR_4 != '%')
return;
VAR_5;
VAR_1 = xmlParseName(VAR_0);
if (VAR_1 == NULL) {
xmlFatalErrMsg(VAR_0, VAR_6,
""xmlParsePEReference: no name\n"");
return;
}
if (VAR_4 != ';') {
xmlFatalErr(VAR_0, VAR_7, NULL);
return;
}
VAR_5;
VAR_0->nbentities++;
if ((VAR_0->sax != NULL) &&
(VAR_0->sax->getParameterEntity != NULL))
VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
if (VAR_0->instate == VAR_8)
return;
if (VAR_2 == NULL) {
if ((VAR_0->standalone == 1) ||
((VAR_0->hasExternalSubset == 0) &&
(VAR_0->hasPErefs == 0))) {
xmlFatalErrMsgStr(VAR_0, VAR_9,
""PEReference: %%%s; not found\n"",
VAR_1);
} else {
xmlWarningMsg(VAR_0, VAR_10,
""PEReference: %%%s; not found\n"",
VAR_1, NULL);
VAR_0->valid = 0;
}
xmlParserEntityCheck(VAR_0, 0, NULL, 0);
} else {
if ((VAR_2->etype != VAR_11) &&
(VAR_2->etype != VAR_12)) {
xmlWarningMsg(VAR_0, VAR_10,
""Internal: %%%s; is not a parameter entity\n"",
VAR_1, NULL);
} else if (VAR_0->input->free != VAR_13) {
VAR_3 = xmlNewBlanksWrapperInputStream(VAR_0, VAR_2);
if (xmlPushInput(VAR_0, VAR_3) < 0)
return;
} else {
VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
if (xmlPushInput(VAR_0, VAR_3) < 0)
return;
if ((VAR_2->etype == VAR_12) &&
(CMP5(VAR_14, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(VAR_0);
if (VAR_0->errNo ==
VAR_15) {
xmlHaltParser(VAR_0);
return;
}
}
}
}
VAR_0->hasPErefs = 1;
}",android/308396a55280f69ad4112d4f9892f4cbeff042aa/parser.c/vul/before/0.json,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
		       ""xmlParsePEReference: no name\n"");
	return;
    }
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
			  ""PEReference: %%%s; not found\n"",
			  name, NULL);
	    ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else if (ctxt->input->free != deallocblankswrapper) {
	    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	} else {
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
	        (ctxt->replaceEntities == 0) &&
	        (ctxt->validate == 0))
	        return;
	    /*
	     * TODO !!!
	     * handle the extra spaces added before and after
	     * c.f. http://www.w3.org/TR/REC-xml#as-PE
	     */
	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
		(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
		(IS_BLANK_CH(NXT(5)))) {
		xmlParseTextDecl(ctxt);
		if (ctxt->errNo ==
		    XML_ERR_UNSUPPORTED_ENCODING) {
		    /*
		     * The XML REC instructs us to stop parsing
		     * right here
		     */
		    xmlHaltParser(ctxt);
		    return;
		}
	    }
	}
    }
    ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
    const xmlChar *VAR_1;
    xmlEntityPtr VAR_2 = NULL;
    xmlParserInputPtr VAR_3;

    if (VAR_4 != '%')
        return;
    VAR_5;
    VAR_1 = xmlParseName(VAR_0);
    if (VAR_1 == NULL) {
	xmlFatalErrMsg(VAR_0, VAR_6,
		       ""xmlParsePEReference: no name\n"");
	return;
    }
    if (VAR_4 != ';') {
	xmlFatalErr(VAR_0, VAR_7, NULL);
        return;
    }

    VAR_5;

    /* COMMENT_0 */
                                                      
       
    VAR_0->nbentities++;

    /* COMMENT_3 */
                                  
       
    if ((VAR_0->sax != NULL) &&
	(VAR_0->sax->getParameterEntity != NULL))
	VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
    if (VAR_0->instate == VAR_8)
	return;
    if (VAR_2 == NULL) {
	/* COMMENT_6 */
                            
                                                          
                                                          
                                                          
                                                          
                          
    
	if ((VAR_0->standalone == 1) ||
	    ((VAR_0->hasExternalSubset == 0) &&
	     (VAR_0->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(VAR_0, VAR_9,
			      ""PEReference: %%%s; not found\n"",
			      VAR_1);
	} else {
	    /* COMMENT_14 */
                               
                                                         
                                                      
                                                      
                                      
        
	    xmlWarningMsg(VAR_0, VAR_10,
			  ""PEReference: %%%s; not found\n"",
			  VAR_1, NULL);
	    VAR_0->valid = 0;
	}
	xmlParserEntityCheck(VAR_0, 0, NULL, 0);
    } else {
	/* COMMENT_21 */
                                                     
    
	if ((VAR_2->etype != VAR_11) &&
	    (VAR_2->etype != VAR_12)) {
	    xmlWarningMsg(VAR_0, VAR_10,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  VAR_1, NULL);
	} else if (VAR_0->input->free != VAR_13) {
	    VAR_3 = xmlNewBlanksWrapperInputStream(VAR_0, VAR_2);
	    if (xmlPushInput(VAR_0, VAR_3) < 0)
		return;
	} else {
	    if ((VAR_2->etype == VAR_12) &&
	        ((VAR_0->options & VAR_14) == 0) &&
	        ((VAR_0->options & VAR_15) == 0) &&
	        ((VAR_0->options & VAR_16) == 0) &&
	        ((VAR_0->options & VAR_17) == 0) &&
	        (VAR_0->replaceEntities == 0) &&
	        (VAR_0->validate == 0))
	        return;
	    /* COMMENT_24 */
                
                                                      
                                               
        
	    VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
	    if (xmlPushInput(VAR_0, VAR_3) < 0)
		return;
	    if ((VAR_2->etype == VAR_12) &&
		(CMP5(VAR_18, '<', '?', 'x', 'm', 'l')) &&
		(IS_BLANK_CH(NXT(5)))) {
		xmlParseTextDecl(VAR_0);
		if (VAR_0->errNo ==
		    VAR_19) {
		    /* COMMENT_29 */
                                                 
                   
         
		    xmlHaltParser(VAR_0);
		    return;
		}
	    }
	}
    }
    VAR_0->hasPErefs = 1;
}",android/308396a55280f69ad4112d4f9892f4cbeff042aa/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,14 @@
 	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 	} else {
+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+	        (ctxt->replaceEntities == 0) &&
+	        (ctxt->validate == 0))
+	        return;
 	    /*
 	     * TODO !!!
 	     * handle the extra spaces added before and after","{'deleted_lines': [], 'added_lines': ['\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&', '\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&', '\t        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&', '\t        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&', '\t        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&', '\t        (ctxt->replaceEntities == 0) &&', '\t        (ctxt->validate == 0))', '\t        return;']}",True,"A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable).",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/s3_srvr.c,ssl3_get_client_hello,"int ssl3_get_client_hello(SSL *s)
{
int i, j, ok, al = SSL_AD_INTERNAL_ERROR, ret = -1, cookie_valid = 0;
unsigned int cookie_len;
long n;
unsigned long id;
unsigned char *p, *d;
SSL_CIPHER *c;
#ifndef OPENSSL_NO_COMP
unsigned char *q;
SSL_COMP *comp = NULL;
#endif
STACK_OF(SSL_CIPHER) *ciphers = NULL;
if (s->state == SSL3_ST_SR_CLNT_HELLO_C && !s->first_packet)
goto retry_cert;
if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {
s->state = SSL3_ST_SR_CLNT_HELLO_B;
}
s->first_packet = 1;
n = s->method->ssl_get_message(s,
SSL3_ST_SR_CLNT_HELLO_B,
SSL3_ST_SR_CLNT_HELLO_C,
SSL3_MT_CLIENT_HELLO,
SSL3_RT_MAX_PLAIN_LENGTH, &ok);
if (!ok)
return ((int)n);
s->first_packet = 0;
d = p = (unsigned char *)s->init_msg;
if (n < 2 + SSL3_RANDOM_SIZE + 1) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
s->client_version = (((int)p[0]) << 8) | (int)p[1];
p += 2;
if (SSL_IS_DTLS(s) ? (s->client_version > s->version &&
s->method->version != DTLS_ANY_VERSION)
: (s->client_version < s->version)) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);
if ((s->client_version >> 8) == SSL3_VERSION_MAJOR &&
!s->enc_write_ctx && !s->write_hash) {
s->version = s->client_version;
}
al = SSL_AD_PROTOCOL_VERSION;
goto f_err;
}
if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {
unsigned int session_length, cookie_length;
session_length = *(p + SSL3_RANDOM_SIZE);
if (p + SSL3_RANDOM_SIZE + session_length + 1 >= d + n) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);
if (cookie_length == 0)
return 1;
}
memcpy(s->s3->client_random, p, SSL3_RANDOM_SIZE);
p += SSL3_RANDOM_SIZE;
j = *(p++);
if (p + j > d + n) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
if ((j < 0) || (j > SSL_MAX_SSL_SESSION_ID_LENGTH)) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
goto f_err;
}
s->hit = 0;
if ((s->new_session
&& (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {
if (!ssl_get_new_session(s, 1))
goto err;
} else {
i = ssl_get_prev_session(s, p, j, d + n);
if (i == 1 && s->version == s->session->ssl_version) { 
s->hit = 1;
} else if (i == -1)
goto err;
else {                  
if (!ssl_get_new_session(s, 1))
goto err;
}
}
p += j;
if (SSL_IS_DTLS(s)) {
if (p + 1 > d + n) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
cookie_len = *(p++);
if (p + cookie_len > d + n) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
if (cookie_len > sizeof(s->d1->rcvd_cookie)) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
goto f_err;
}
if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) && cookie_len > 0) {
memcpy(s->d1->rcvd_cookie, p, cookie_len);
if (s->ctx->app_verify_cookie_cb != NULL) {
if (s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
cookie_len) == 0) {
al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_COOKIE_MISMATCH);
goto f_err;
}
}
else if (memcmp(s->d1->rcvd_cookie, s->d1->cookie,
s->d1->cookie_len) != 0) {
al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
goto f_err;
}
cookie_valid = 1;
}
p += cookie_len;
if (s->method->version == DTLS_ANY_VERSION) {
if (s->client_version <= DTLS1_2_VERSION &&
!(s->options & SSL_OP_NO_DTLSv1_2)) {
s->version = DTLS1_2_VERSION;
s->method = DTLSv1_2_server_method();
} else if (tls1_suiteb(s)) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
s->version = s->client_version;
al = SSL_AD_PROTOCOL_VERSION;
goto f_err;
} else if (s->client_version <= DTLS1_VERSION &&
!(s->options & SSL_OP_NO_DTLSv1)) {
s->version = DTLS1_VERSION;
s->method = DTLSv1_server_method();
} else {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_WRONG_VERSION_NUMBER);
s->version = s->client_version;
al = SSL_AD_PROTOCOL_VERSION;
goto f_err;
}
s->session->ssl_version = s->version;
}
}
if (p + 2 > d + n) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
n2s(p, i);
if (i == 0) {
al = SSL_AD_ILLEGAL_PARAMETER;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);
goto f_err;
}
if ((p + i + 1) > (d + n)) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
goto f_err;
}
if (ssl_bytes_to_cipher_list(s, p, i, &(ciphers)) == NULL) {
goto err;
}
p += i;
if (s->hit) {
j = 0;
id = s->session->cipher->id;
#ifdef CIPHER_DEBUG
fprintf(stderr, ""client sent %d ciphers\n"",
sk_SSL_CIPHER_num(ciphers));
#endif
for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
c = sk_SSL_CIPHER_value(ciphers, i);
#ifdef CIPHER_DEBUG
fprintf(stderr, ""client [%2d of %2d]:%s\n"",
i, sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));
#endif
if (c->id == id) {
j = 1;
break;
}
}
#if 0
if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG)
&& (sk_SSL_CIPHER_num(ciphers) == 1)) {
c = sk_SSL_CIPHER_value(ciphers, 0);
if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0) {
s->session->cipher = c;
j = 1;
}
}
#endif
if (j == 0) {
al = SSL_AD_ILLEGAL_PARAMETER;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_REQUIRED_CIPHER_MISSING);
goto f_err;
}
}
i = *(p++);
if ((p + i) > (d + n)) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
goto f_err;
}
#ifndef OPENSSL_NO_COMP
q = p;
#endif
for (j = 0; j < i; j++) {
if (p[j] == 0)
break;
}
p += i;
if (j >= i) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_COMPRESSION_SPECIFIED);
goto f_err;
}
#ifndef OPENSSL_NO_TLSEXT
if (s->version >= SSL3_VERSION) {
if (!ssl_parse_clienthello_tlsext(s, &p, d + n)) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);
goto err;
}
}
{
unsigned char *pos;
pos = s->s3->server_random;
if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0) {
goto f_err;
}
}
if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {
SSL_CIPHER *pref_cipher = NULL;
s->session->master_key_length = sizeof(s->session->master_key);
if (s->tls_session_secret_cb(s, s->session->master_key,
&s->session->master_key_length, ciphers,
&pref_cipher,
s->tls_session_secret_cb_arg)) {
s->hit = 1;
s->session->ciphers = ciphers;
s->session->verify_result = X509_V_OK;
ciphers = NULL;
pref_cipher =
pref_cipher ? pref_cipher : ssl3_choose_cipher(s,
s->
session->ciphers,
SSL_get_ciphers
(s));
if (pref_cipher == NULL) {
al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
goto f_err;
}
s->session->cipher = pref_cipher;
if (s->cipher_list)
sk_SSL_CIPHER_free(s->cipher_list);
if (s->cipher_list_by_id)
sk_SSL_CIPHER_free(s->cipher_list_by_id);
s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
}
}
#endif
s->s3->tmp.new_compression = NULL;
#ifndef OPENSSL_NO_COMP
if (s->session->compress_meth != 0) {
int m, comp_id = s->session->compress_meth;
if (s->options & SSL_OP_NO_COMPRESSION) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_INCONSISTENT_COMPRESSION);
goto f_err;
}
for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++) {
comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
if (comp_id == comp->id) {
s->s3->tmp.new_compression = comp;
break;
}
}
if (s->s3->tmp.new_compression == NULL) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_INVALID_COMPRESSION_ALGORITHM);
goto f_err;
}
for (m = 0; m < i; m++) {
if (q[m] == comp_id)
break;
}
if (m >= i) {
al = SSL_AD_ILLEGAL_PARAMETER;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
goto f_err;
}
} else if (s->hit)
comp = NULL;
else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods) {
int m, nn, o, v, done = 0;
nn = sk_SSL_COMP_num(s->ctx->comp_methods);
for (m = 0; m < nn; m++) {
comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
v = comp->id;
for (o = 0; o < i; o++) {
if (v == q[o]) {
done = 1;
break;
}
}
if (done)
break;
}
if (done)
s->s3->tmp.new_compression = comp;
else
comp = NULL;
}
#else
if (s->session->compress_meth != 0) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
goto f_err;
}
#endif
if (!s->hit) {
#ifdef OPENSSL_NO_COMP
s->session->compress_meth = 0;
#else
s->session->compress_meth = (comp == NULL) ? 0 : comp->id;
#endif
if (s->session->ciphers != NULL)
sk_SSL_CIPHER_free(s->session->ciphers);
s->session->ciphers = ciphers;
if (ciphers == NULL) {
al = SSL_AD_INTERNAL_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
goto f_err;
}
ciphers = NULL;
if (!tls1_set_server_sigalgs(s)) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
goto err;
}
retry_cert:
if (s->cert->cert_cb) {
int rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);
if (rv == 0) {
al = SSL_AD_INTERNAL_ERROR;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CERT_CB_ERROR);
goto f_err;
}
if (rv < 0) {
s->rwstate = SSL_X509_LOOKUP;
return -1;
}
s->rwstate = SSL_NOTHING;
}
c = ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
if (c == NULL) {
al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
goto f_err;
}
s->s3->tmp.new_cipher = c;
} else {
#ifdef REUSE_CIPHER_BUG
STACK_OF(SSL_CIPHER) *sk;
SSL_CIPHER *nc = NULL;
SSL_CIPHER *ec = NULL;
if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) {
sk = s->session->ciphers;
for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
c = sk_SSL_CIPHER_value(sk, i);
if (c->algorithm_enc & SSL_eNULL)
nc = c;
if (SSL_C_IS_EXPORT(c))
ec = c;
}
if (nc != NULL)
s->s3->tmp.new_cipher = nc;
else if (ec != NULL)
s->s3->tmp.new_cipher = ec;
else
s->s3->tmp.new_cipher = s->session->cipher;
} else
#endif
s->s3->tmp.new_cipher = s->session->cipher;
}
if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {
if (!ssl3_digest_cached_records(s))
goto f_err;
}
if (s->version >= SSL3_VERSION) {
if (ssl_check_clienthello_tlsext_late(s) <= 0) {
SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
goto err;
}
}
ret = cookie_valid ? 2 : 1;
if (0) {
f_err:
ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
s->state = SSL_ST_ERR;
}
if (ciphers != NULL)
sk_SSL_CIPHER_free(ciphers);
return ret;
}","int ssl3_get_client_hello(SSL *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4 = VAR_5, VAR_6 = -1, VAR_7 = 0;
unsigned int VAR_8;
long VAR_9;
unsigned long VAR_10;
unsigned char *VAR_11, *VAR_12;
SSL_CIPHER *VAR_13;
#ifndef VAR_14
unsigned char *VAR_15;
SSL_COMP *VAR_16 = NULL;
#endif
STACK_OF(SSL_CIPHER) *VAR_17 = NULL;
if (VAR_0->state == VAR_18 && !VAR_0->first_packet)
goto retry_cert;
if (VAR_0->state == VAR_19) {
VAR_0->state = VAR_20;
}
VAR_0->first_packet = 1;
VAR_9 = VAR_0->method->ssl_get_message(VAR_0,
VAR_20,
VAR_18,
VAR_21,
VAR_22, &VAR_3);
if (!VAR_3)
return ((int)VAR_9);
VAR_0->first_packet = 0;
VAR_12 = VAR_11 = (unsigned char *)VAR_0->init_msg;
if (VAR_9 < 2 + VAR_23 + 1) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
VAR_0->client_version = (((int)VAR_11[0]) << 8) | (int)VAR_11[1];
VAR_11 += 2;
if (SSL_IS_DTLS(VAR_0) ? (VAR_0->client_version > VAR_0->version &&
VAR_0->method->version != VAR_27)
: (VAR_0->client_version < VAR_0->version)) {
SSLerr(VAR_25, VAR_28);
if ((VAR_0->client_version >> 8) == VAR_29 &&
!VAR_0->enc_write_ctx && !VAR_0->write_hash) {
VAR_0->version = VAR_0->client_version;
}
VAR_4 = VAR_30;
goto f_err;
}
if (SSL_get_options(VAR_0) & VAR_31) {
unsigned int VAR_32, VAR_33;
VAR_32 = *(VAR_11 + VAR_23);
if (VAR_11 + VAR_23 + VAR_32 + 1 >= VAR_12 + VAR_9) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
VAR_33 = *(VAR_11 + VAR_23 + VAR_32 + 1);
if (VAR_33 == 0)
return 1;
}
memcpy(VAR_0->s3->client_random, VAR_11, VAR_23);
VAR_11 += VAR_23;
VAR_2 = *(VAR_11++);
if (VAR_11 + VAR_2 > VAR_12 + VAR_9) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
if ((VAR_2 < 0) || (VAR_2 > VAR_34)) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_35);
goto f_err;
}
VAR_0->hit = 0;
if ((VAR_0->new_session
&& (VAR_0->options & VAR_36))) {
if (!ssl_get_new_session(VAR_0, 1))
goto err;
} else {
VAR_1 = ssl_get_prev_session(VAR_0, VAR_11, VAR_2, VAR_12 + VAR_9);
if (VAR_1 == 1 && VAR_0->version == VAR_0->session->ssl_version) { 
VAR_0->hit = 1;
} else if (VAR_1 == -1)
goto err;
else {                  
if (!ssl_get_new_session(VAR_0, 1))
goto err;
}
}
VAR_11 += VAR_2;
if (SSL_IS_DTLS(VAR_0)) {
if (VAR_11 + 1 > VAR_12 + VAR_9) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
VAR_8 = *(VAR_11++);
if (VAR_11 + VAR_8 > VAR_12 + VAR_9) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
if (VAR_8 > sizeof(VAR_0->d1->rcvd_cookie)) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_37);
goto f_err;
}
if ((SSL_get_options(VAR_0) & VAR_31) && VAR_8 > 0) {
memcpy(VAR_0->d1->rcvd_cookie, VAR_11, VAR_8);
if (VAR_0->ctx->app_verify_cookie_cb != NULL) {
if (VAR_0->ctx->app_verify_cookie_cb(VAR_0, VAR_0->d1->rcvd_cookie,
VAR_8) == 0) {
VAR_4 = VAR_38;
SSLerr(VAR_25,
VAR_37);
goto f_err;
}
}
else if (memcmp(VAR_0->d1->rcvd_cookie, VAR_0->d1->cookie,
VAR_0->d1->cookie_len) != 0) {
VAR_4 = VAR_38;
SSLerr(VAR_25, VAR_37);
goto f_err;
}
VAR_7 = 1;
}
VAR_11 += VAR_8;
if (VAR_0->method->version == VAR_27) {
if (VAR_0->client_version <= VAR_39 &&
!(VAR_0->options & VAR_40)) {
VAR_0->version = VAR_39;
VAR_0->method = DTLSv1_2_server_method();
} else if (tls1_suiteb(VAR_0)) {
SSLerr(VAR_25,
VAR_41);
VAR_0->version = VAR_0->client_version;
VAR_4 = VAR_30;
goto f_err;
} else if (VAR_0->client_version <= VAR_42 &&
!(VAR_0->options & VAR_43)) {
VAR_0->version = VAR_42;
VAR_0->method = DTLSv1_server_method();
} else {
SSLerr(VAR_25,
VAR_28);
VAR_0->version = VAR_0->client_version;
VAR_4 = VAR_30;
goto f_err;
}
VAR_0->session->ssl_version = VAR_0->version;
}
}
if (VAR_11 + 2 > VAR_12 + VAR_9) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_26);
goto f_err;
}
n2s(VAR_11, VAR_1);
if (VAR_1 == 0) {
VAR_4 = VAR_44;
SSLerr(VAR_25, VAR_45);
goto f_err;
}
if ((VAR_11 + VAR_1 + 1) > (VAR_12 + VAR_9)) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_35);
goto f_err;
}
if (ssl_bytes_to_cipher_list(VAR_0, VAR_11, VAR_1, &(VAR_17)) == NULL) {
goto err;
}
VAR_11 += VAR_1;
if (VAR_0->hit) {
VAR_2 = 0;
VAR_10 = VAR_0->session->cipher->id;
#ifdef VAR_46
fprintf(VAR_47, ""client sent %d ciphers\n"",
sk_SSL_CIPHER_num(VAR_17));
#endif
for (VAR_1 = 0; VAR_1 < sk_SSL_CIPHER_num(VAR_17); VAR_1++) {
VAR_13 = sk_SSL_CIPHER_value(VAR_17, VAR_1);
#ifdef VAR_46
fprintf(VAR_47, ""client [%2d of %2d]:%s\n"",
VAR_1, sk_SSL_CIPHER_num(VAR_17), SSL_CIPHER_get_name(VAR_13));
#endif
if (VAR_13->id == VAR_10) {
VAR_2 = 1;
break;
}
}
#if 0
if (VAR_2 == 0 && (VAR_0->options & VAR_48)
&& (sk_SSL_CIPHER_num(VAR_17) == 1)) {
VAR_13 = sk_SSL_CIPHER_value(VAR_17, 0);
if (sk_SSL_CIPHER_find(SSL_get_ciphers(VAR_0), VAR_13) >= 0) {
VAR_0->session->cipher = VAR_13;
VAR_2 = 1;
}
}
#endif
if (VAR_2 == 0) {
VAR_4 = VAR_44;
SSLerr(VAR_25,
VAR_49);
goto f_err;
}
}
VAR_1 = *(VAR_11++);
if ((VAR_11 + VAR_1) > (VAR_12 + VAR_9)) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_35);
goto f_err;
}
#ifndef VAR_14
VAR_15 = VAR_11;
#endif
for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++) {
if (VAR_11[VAR_2] == 0)
break;
}
VAR_11 += VAR_1;
if (VAR_2 >= VAR_1) {
VAR_4 = VAR_24;
SSLerr(VAR_25, VAR_50);
goto f_err;
}
#ifndef VAR_51
if (VAR_0->version >= VAR_52) {
if (!ssl_parse_clienthello_tlsext(VAR_0, &VAR_11, VAR_12 + VAR_9)) {
SSLerr(VAR_25, VAR_53);
goto err;
}
}
{
unsigned char *VAR_54;
VAR_54 = VAR_0->s3->server_random;
if (ssl_fill_hello_random(VAR_0, 1, VAR_54, VAR_23) <= 0) {
goto f_err;
}
}
if (!VAR_0->hit && VAR_0->version >= VAR_55 && VAR_0->tls_session_secret_cb) {
SSL_CIPHER *VAR_56 = NULL;
VAR_0->session->master_key_length = sizeof(VAR_0->session->master_key);
if (VAR_0->tls_session_secret_cb(VAR_0, VAR_0->session->master_key,
&VAR_0->session->master_key_length, VAR_17,
&VAR_56,
VAR_0->tls_session_secret_cb_arg)) {
VAR_0->hit = 1;
VAR_0->session->ciphers = VAR_17;
VAR_0->session->verify_result = VAR_57;
VAR_17 = NULL;
VAR_56 =
VAR_56 ? VAR_56 : ssl3_choose_cipher(VAR_0,
VAR_0->
session->ciphers,
SSL_get_ciphers
(VAR_0));
if (VAR_56 == NULL) {
VAR_4 = VAR_38;
SSLerr(VAR_25, VAR_58);
goto f_err;
}
VAR_0->session->cipher = VAR_56;
if (VAR_0->cipher_list)
sk_SSL_CIPHER_free(VAR_0->cipher_list);
if (VAR_0->cipher_list_by_id)
sk_SSL_CIPHER_free(VAR_0->cipher_list_by_id);
VAR_0->cipher_list = sk_SSL_CIPHER_dup(VAR_0->session->ciphers);
VAR_0->cipher_list_by_id = sk_SSL_CIPHER_dup(VAR_0->session->ciphers);
}
}
#endif
VAR_0->s3->tmp.new_compression = NULL;
#ifndef VAR_14
if (VAR_0->session->compress_meth != 0) {
int VAR_59, VAR_60 = VAR_0->session->compress_meth;
if (VAR_0->options & VAR_61) {
SSLerr(VAR_25,
VAR_62);
goto f_err;
}
for (VAR_59 = 0; VAR_59 < sk_SSL_COMP_num(VAR_0->ctx->comp_methods); VAR_59++) {
VAR_16 = sk_SSL_COMP_value(VAR_0->ctx->comp_methods, VAR_59);
if (VAR_60 == VAR_16->id) {
VAR_0->s3->tmp.new_compression = VAR_16;
break;
}
}
if (VAR_0->s3->tmp.new_compression == NULL) {
SSLerr(VAR_25,
VAR_63);
goto f_err;
}
for (VAR_59 = 0; VAR_59 < VAR_1; VAR_59++) {
if (VAR_15[VAR_59] == VAR_60)
break;
}
if (VAR_59 >= VAR_1) {
VAR_4 = VAR_44;
SSLerr(VAR_25,
VAR_64);
goto f_err;
}
} else if (VAR_0->hit)
VAR_16 = NULL;
else if (!(VAR_0->options & VAR_61) && VAR_0->ctx->comp_methods) {
int VAR_59, VAR_65, VAR_66, VAR_67, VAR_68 = 0;
VAR_65 = sk_SSL_COMP_num(VAR_0->ctx->comp_methods);
for (VAR_59 = 0; VAR_59 < VAR_65; VAR_59++) {
VAR_16 = sk_SSL_COMP_value(VAR_0->ctx->comp_methods, VAR_59);
VAR_67 = VAR_16->id;
for (VAR_66 = 0; VAR_66 < VAR_1; VAR_66++) {
if (VAR_67 == VAR_15[VAR_66]) {
VAR_68 = 1;
break;
}
}
if (VAR_68)
break;
}
if (VAR_68)
VAR_0->s3->tmp.new_compression = VAR_16;
else
VAR_16 = NULL;
}
#else
if (VAR_0->session->compress_meth != 0) {
SSLerr(VAR_25, VAR_62);
goto f_err;
}
#endif
if (!VAR_0->hit) {
#ifdef VAR_14
VAR_0->session->compress_meth = 0;
#else
VAR_0->session->compress_meth = (VAR_16 == NULL) ? 0 : VAR_16->id;
#endif
if (VAR_0->session->ciphers != NULL)
sk_SSL_CIPHER_free(VAR_0->session->ciphers);
VAR_0->session->ciphers = VAR_17;
if (VAR_17 == NULL) {
VAR_4 = VAR_5;
SSLerr(VAR_25, VAR_69);
goto f_err;
}
VAR_17 = NULL;
if (!tls1_set_server_sigalgs(VAR_0)) {
SSLerr(VAR_25, VAR_70);
goto err;
}
retry_cert:
if (VAR_0->cert->cert_cb) {
int VAR_71 = VAR_0->cert->cert_cb(VAR_0, VAR_0->cert->cert_cb_arg);
if (VAR_71 == 0) {
VAR_4 = VAR_5;
SSLerr(VAR_25, VAR_72);
goto f_err;
}
if (VAR_71 < 0) {
VAR_0->rwstate = VAR_73;
return -1;
}
VAR_0->rwstate = VAR_74;
}
VAR_13 = ssl3_choose_cipher(VAR_0, VAR_0->session->ciphers, SSL_get_ciphers(VAR_0));
if (VAR_13 == NULL) {
VAR_4 = VAR_38;
SSLerr(VAR_25, VAR_58);
goto f_err;
}
VAR_0->s3->tmp.new_cipher = VAR_13;
} else {
#ifdef VAR_75
VAR_76(SSL_CIPHER) *VAR_77;
SSL_CIPHER *VAR_78 = NULL;
SSL_CIPHER *VAR_79 = NULL;
if (VAR_0->options & VAR_80) {
VAR_77 = VAR_0->session->ciphers;
for (VAR_1 = 0; VAR_1 < sk_SSL_CIPHER_num(VAR_77); VAR_1++) {
VAR_13 = sk_SSL_CIPHER_value(VAR_77, VAR_1);
if (VAR_13->algorithm_enc & VAR_81)
VAR_78 = VAR_13;
if (SSL_C_IS_EXPORT(VAR_13))
VAR_79 = VAR_13;
}
if (VAR_78 != NULL)
VAR_0->s3->tmp.new_cipher = VAR_78;
else if (VAR_79 != NULL)
VAR_0->s3->tmp.new_cipher = VAR_79;
else
VAR_0->s3->tmp.new_cipher = VAR_0->session->cipher;
} else
#endif
VAR_0->s3->tmp.new_cipher = VAR_0->session->cipher;
}
if (!SSL_USE_SIGALGS(VAR_0) || !(VAR_0->verify_mode & VAR_82)) {
if (!ssl3_digest_cached_records(VAR_0))
goto f_err;
}
if (VAR_0->version >= VAR_52) {
if (ssl_check_clienthello_tlsext_late(VAR_0) <= 0) {
SSLerr(VAR_25, VAR_70);
goto err;
}
}
VAR_6 = VAR_7 ? 2 : 1;
if (0) {
f_err:
ssl3_send_alert(VAR_0, VAR_83, VAR_4);
err:
VAR_0->state = VAR_84;
}
if (VAR_17 != NULL)
sk_SSL_CIPHER_free(VAR_17);
return VAR_6;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/s3_srvr.c/vul/before/0.json,"int ssl3_get_client_hello(SSL *s)
{
    int i, j, ok, al = SSL_AD_INTERNAL_ERROR, ret = -1, cookie_valid = 0;
    unsigned int cookie_len;
    long n;
    unsigned long id;
    unsigned char *p, *d;
    SSL_CIPHER *c;
#ifndef OPENSSL_NO_COMP
    unsigned char *q;
    SSL_COMP *comp = NULL;
#endif
    STACK_OF(SSL_CIPHER) *ciphers = NULL;

    if (s->state == SSL3_ST_SR_CLNT_HELLO_C && !s->first_packet)
        goto retry_cert;

    /*
     * We do this so that we will respond with our native type. If we are
     * TLSv1 and we get SSLv3, we will respond with TLSv1, This down
     * switching should be handled by a different method. If we are SSLv3, we
     * will respond with SSLv3, even if prompted with TLSv1.
     */
    if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {
        s->state = SSL3_ST_SR_CLNT_HELLO_B;
    }
    s->first_packet = 1;
    n = s->method->ssl_get_message(s,
                                   SSL3_ST_SR_CLNT_HELLO_B,
                                   SSL3_ST_SR_CLNT_HELLO_C,
                                   SSL3_MT_CLIENT_HELLO,
                                   SSL3_RT_MAX_PLAIN_LENGTH, &ok);

    if (!ok)
        return ((int)n);
    s->first_packet = 0;
    d = p = (unsigned char *)s->init_msg;

    /*
     * 2 bytes for client version, SSL3_RANDOM_SIZE bytes for random, 1 byte
     * for session id length
     */
    if (n < 2 + SSL3_RANDOM_SIZE + 1) {
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
        goto f_err;
    }

    /*
     * use version from inside client hello, not from record header (may
     * differ: see RFC 2246, Appendix E, second paragraph)
     */
    s->client_version = (((int)p[0]) << 8) | (int)p[1];
    p += 2;

    if (SSL_IS_DTLS(s) ? (s->client_version > s->version &&
                          s->method->version != DTLS_ANY_VERSION)
        : (s->client_version < s->version)) {
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);
        if ((s->client_version >> 8) == SSL3_VERSION_MAJOR &&
            !s->enc_write_ctx && !s->write_hash) {
            /*
             * similar to ssl3_get_record, send alert using remote version
             * number
             */
            s->version = s->client_version;
        }
        al = SSL_AD_PROTOCOL_VERSION;
        goto f_err;
    }

    /*
     * If we require cookies and this ClientHello doesn't contain one, just
     * return since we do not want to allocate any memory yet. So check
     * cookie length...
     */
    if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {
        unsigned int session_length, cookie_length;

        session_length = *(p + SSL3_RANDOM_SIZE);

        if (SSL3_RANDOM_SIZE + session_length + 1 >= (d + n) - p) {
            al = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
        }
        cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);

        if (cookie_length == 0)
            return 1;
    }

    /* load the client random */
    memcpy(s->s3->client_random, p, SSL3_RANDOM_SIZE);
    p += SSL3_RANDOM_SIZE;

    /* get the session-id */
    j = *(p++);

    if ((d + n) - p < j) {
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
        goto f_err;
    }

    if ((j < 0) || (j > SSL_MAX_SSL_SESSION_ID_LENGTH)) {
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
        goto f_err;
    }

    s->hit = 0;
    /*
     * Versions before 0.9.7 always allow clients to resume sessions in
     * renegotiation. 0.9.7 and later allow this by default, but optionally
     * ignore resumption requests with flag
     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather
     * than a change to default behavior so that applications relying on this
     * for security won't even compile against older library versions).
     * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to
     * request renegotiation but not a new session (s->new_session remains
     * unset): for servers, this essentially just means that the
     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION setting will be ignored.
     */
    if ((s->new_session
         && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {
        if (!ssl_get_new_session(s, 1))
            goto err;
    } else {
        i = ssl_get_prev_session(s, p, j, d + n);
        /*
         * Only resume if the session's version matches the negotiated
         * version.
         * RFC 5246 does not provide much useful advice on resumption
         * with a different protocol version. It doesn't forbid it but
         * the sanity of such behaviour would be questionable.
         * In practice, clients do not accept a version mismatch and
         * will abort the handshake with an error.
         */
        if (i == 1 && s->version == s->session->ssl_version) { /* previous
                                                                * session */
            s->hit = 1;
        } else if (i == -1)
            goto err;
        else {                  /* i == 0 */

            if (!ssl_get_new_session(s, 1))
                goto err;
        }
    }

    p += j;

    if (SSL_IS_DTLS(s)) {
        /* cookie stuff */
        if ((d + n) - p < 1) {
            al = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
        }
        cookie_len = *(p++);

        if ((d + n ) - p < cookie_len) {
            al = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
        }

        /*
         * The ClientHello may contain a cookie even if the
         * HelloVerify message has not been sent--make sure that it
         * does not cause an overflow.
         */
        if (cookie_len > sizeof(s->d1->rcvd_cookie)) {
            /* too much data */
            al = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
            goto f_err;
        }

        /* verify the cookie if appropriate option is set. */
        if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) && cookie_len > 0) {
            memcpy(s->d1->rcvd_cookie, p, cookie_len);

            if (s->ctx->app_verify_cookie_cb != NULL) {
                if (s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
                                                 cookie_len) == 0) {
                    al = SSL_AD_HANDSHAKE_FAILURE;
                    SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                           SSL_R_COOKIE_MISMATCH);
                    goto f_err;
                }
                /* else cookie verification succeeded */
            }
            /* default verification */
            else if (memcmp(s->d1->rcvd_cookie, s->d1->cookie,
                            s->d1->cookie_len) != 0) {
                al = SSL_AD_HANDSHAKE_FAILURE;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
                goto f_err;
            }
            cookie_valid = 1;
        }

        p += cookie_len;
        if (s->method->version == DTLS_ANY_VERSION) {
            /* Select version to use */
            if (s->client_version <= DTLS1_2_VERSION &&
                !(s->options & SSL_OP_NO_DTLSv1_2)) {
                s->version = DTLS1_2_VERSION;
                s->method = DTLSv1_2_server_method();
            } else if (tls1_suiteb(s)) {
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                       SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                s->version = s->client_version;
                al = SSL_AD_PROTOCOL_VERSION;
                goto f_err;
            } else if (s->client_version <= DTLS1_VERSION &&
                       !(s->options & SSL_OP_NO_DTLSv1)) {
                s->version = DTLS1_VERSION;
                s->method = DTLSv1_server_method();
            } else {
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                       SSL_R_WRONG_VERSION_NUMBER);
                s->version = s->client_version;
                al = SSL_AD_PROTOCOL_VERSION;
                goto f_err;
            }
            s->session->ssl_version = s->version;
        }
    }

    if ((d + n ) - p < 2) {
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
        goto f_err;
    }
    n2s(p, i);

    if (i == 0) {
        al = SSL_AD_ILLEGAL_PARAMETER;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);
        goto f_err;
    }

    /* i bytes of cipher data + 1 byte for compression length later */
    if ((d + n) - p < i + 1) {
        /* not enough data */
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
        goto f_err;
    }
    if (ssl_bytes_to_cipher_list(s, p, i, &(ciphers)) == NULL) {
        goto err;
    }
    p += i;

    /* If it is a hit, check that the cipher is in the list */
    if (s->hit) {
        j = 0;
        id = s->session->cipher->id;

#ifdef CIPHER_DEBUG
        fprintf(stderr, ""client sent %d ciphers\n"",
                sk_SSL_CIPHER_num(ciphers));
#endif
        for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
            c = sk_SSL_CIPHER_value(ciphers, i);
#ifdef CIPHER_DEBUG
            fprintf(stderr, ""client [%2d of %2d]:%s\n"",
                    i, sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));
#endif
            if (c->id == id) {
                j = 1;
                break;
            }
        }
        /*
         * Disabled because it can be used in a ciphersuite downgrade attack:
         * CVE-2010-4180.
         */
#if 0
        if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG)
            && (sk_SSL_CIPHER_num(ciphers) == 1)) {
            /*
             * Special case as client bug workaround: the previously used
             * cipher may not be in the current list, the client instead
             * might be trying to continue using a cipher that before wasn't
             * chosen due to server preferences.  We'll have to reject the
             * connection if the cipher is not enabled, though.
             */
            c = sk_SSL_CIPHER_value(ciphers, 0);
            if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0) {
                s->session->cipher = c;
                j = 1;
            }
        }
#endif
        if (j == 0) {
            /*
             * we need to have the cipher in the cipher list if we are asked
             * to reuse it
             */
            al = SSL_AD_ILLEGAL_PARAMETER;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                   SSL_R_REQUIRED_CIPHER_MISSING);
            goto f_err;
        }
    }

    /* compression */
    i = *(p++);
    if ((d + n) - p < i) {
        /* not enough data */
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
        goto f_err;
    }
#ifndef OPENSSL_NO_COMP
    q = p;
#endif
    for (j = 0; j < i; j++) {
        if (p[j] == 0)
            break;
    }

    p += i;
    if (j >= i) {
        /* no compress */
        al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_COMPRESSION_SPECIFIED);
        goto f_err;
    }
#ifndef OPENSSL_NO_TLSEXT
    /* TLS extensions */
    if (s->version >= SSL3_VERSION) {
        if (!ssl_parse_clienthello_tlsext(s, &p, d + n)) {
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);
            goto err;
        }
    }

    /*
     * Check if we want to use external pre-shared secret for this handshake
     * for not reused session only. We need to generate server_random before
     * calling tls_session_secret_cb in order to allow SessionTicket
     * processing to use it in key derivation.
     */
    {
        unsigned char *pos;
        pos = s->s3->server_random;
        if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0) {
            goto f_err;
        }
    }

    if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {
        SSL_CIPHER *pref_cipher = NULL;

        s->session->master_key_length = sizeof(s->session->master_key);
        if (s->tls_session_secret_cb(s, s->session->master_key,
                                     &s->session->master_key_length, ciphers,
                                     &pref_cipher,
                                     s->tls_session_secret_cb_arg)) {
            s->hit = 1;
            s->session->ciphers = ciphers;
            s->session->verify_result = X509_V_OK;

            ciphers = NULL;

            /* check if some cipher was preferred by call back */
            pref_cipher =
                pref_cipher ? pref_cipher : ssl3_choose_cipher(s,
                                                               s->
                                                               session->ciphers,
                                                               SSL_get_ciphers
                                                               (s));
            if (pref_cipher == NULL) {
                al = SSL_AD_HANDSHAKE_FAILURE;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
                goto f_err;
            }

            s->session->cipher = pref_cipher;

            if (s->cipher_list)
                sk_SSL_CIPHER_free(s->cipher_list);

            if (s->cipher_list_by_id)
                sk_SSL_CIPHER_free(s->cipher_list_by_id);

            s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
            s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
        }
    }
#endif

    /*
     * Worst case, we will use the NULL compression, but if we have other
     * options, we will now look for them.  We have i-1 compression
     * algorithms from the client, starting at q.
     */
    s->s3->tmp.new_compression = NULL;
#ifndef OPENSSL_NO_COMP
    /* This only happens if we have a cache hit */
    if (s->session->compress_meth != 0) {
        int m, comp_id = s->session->compress_meth;
        /* Perform sanity checks on resumed compression algorithm */
        /* Can't disable compression */
        if (s->options & SSL_OP_NO_COMPRESSION) {
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                   SSL_R_INCONSISTENT_COMPRESSION);
            goto f_err;
        }
        /* Look for resumed compression method */
        for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
            if (comp_id == comp->id) {
                s->s3->tmp.new_compression = comp;
                break;
            }
        }
        if (s->s3->tmp.new_compression == NULL) {
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                   SSL_R_INVALID_COMPRESSION_ALGORITHM);
            goto f_err;
        }
        /* Look for resumed method in compression list */
        for (m = 0; m < i; m++) {
            if (q[m] == comp_id)
                break;
        }
        if (m >= i) {
            al = SSL_AD_ILLEGAL_PARAMETER;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
                   SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
            goto f_err;
        }
    } else if (s->hit)
        comp = NULL;
    else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods) {
        /* See if we have a match */
        int m, nn, o, v, done = 0;

        nn = sk_SSL_COMP_num(s->ctx->comp_methods);
        for (m = 0; m < nn; m++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
            v = comp->id;
            for (o = 0; o < i; o++) {
                if (v == q[o]) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        if (done)
            s->s3->tmp.new_compression = comp;
        else
            comp = NULL;
    }
#else
    /*
     * If compression is disabled we'd better not try to resume a session
     * using compression.
     */
    if (s->session->compress_meth != 0) {
        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
        goto f_err;
    }
#endif

    /*
     * Given s->session->ciphers and SSL_get_ciphers, we must pick a cipher
     */

    if (!s->hit) {
#ifdef OPENSSL_NO_COMP
        s->session->compress_meth = 0;
#else
        s->session->compress_meth = (comp == NULL) ? 0 : comp->id;
#endif
        if (s->session->ciphers != NULL)
            sk_SSL_CIPHER_free(s->session->ciphers);
        s->session->ciphers = ciphers;
        if (ciphers == NULL) {
            al = SSL_AD_INTERNAL_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
            goto f_err;
        }
        ciphers = NULL;
        if (!tls1_set_server_sigalgs(s)) {
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
        /* Let cert callback update server certificates if required */
 retry_cert:
        if (s->cert->cert_cb) {
            int rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);
            if (rv == 0) {
                al = SSL_AD_INTERNAL_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CERT_CB_ERROR);
                goto f_err;
            }
            if (rv < 0) {
                s->rwstate = SSL_X509_LOOKUP;
                return -1;
            }
            s->rwstate = SSL_NOTHING;
        }
        c = ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));

        if (c == NULL) {
            al = SSL_AD_HANDSHAKE_FAILURE;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
            goto f_err;
        }
        s->s3->tmp.new_cipher = c;
    } else {
        /* Session-id reuse */
#ifdef REUSE_CIPHER_BUG
        STACK_OF(SSL_CIPHER) *sk;
        SSL_CIPHER *nc = NULL;
        SSL_CIPHER *ec = NULL;

        if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) {
            sk = s->session->ciphers;
            for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
                c = sk_SSL_CIPHER_value(sk, i);
                if (c->algorithm_enc & SSL_eNULL)
                    nc = c;
                if (SSL_C_IS_EXPORT(c))
                    ec = c;
            }
            if (nc != NULL)
                s->s3->tmp.new_cipher = nc;
            else if (ec != NULL)
                s->s3->tmp.new_cipher = ec;
            else
                s->s3->tmp.new_cipher = s->session->cipher;
        } else
#endif
            s->s3->tmp.new_cipher = s->session->cipher;
    }

    if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {
        if (!ssl3_digest_cached_records(s))
            goto f_err;
    }

    /*-
    * we now have the following setup.
     * client_random
     * cipher_list          - our prefered list of ciphers
     * ciphers              - the clients prefered list of ciphers
     * compression          - basically ignored right now
     * ssl version is set   - sslv3
     * s->session           - The ssl session has been setup.
     * s->hit               - session reuse flag
     * s->tmp.new_cipher    - the new cipher to use.
     */

    /* Handles TLS extensions that we couldn't check earlier */
    if (s->version >= SSL3_VERSION) {
        if (ssl_check_clienthello_tlsext_late(s) <= 0) {
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
    }

    ret = cookie_valid ? 2 : 1;
    if (0) {
 f_err:
        ssl3_send_alert(s, SSL3_AL_FATAL, al);
 err:
        s->state = SSL_ST_ERR;
    }

    if (ciphers != NULL)
        sk_SSL_CIPHER_free(ciphers);
    return ret;
}","int ssl3_get_client_hello(SSL *VAR_0)
{
    int VAR_1, VAR_2, VAR_3, VAR_4 = VAR_5, VAR_6 = -1, VAR_7 = 0;
    unsigned int VAR_8;
    long VAR_9;
    unsigned long VAR_10;
    unsigned char *VAR_11, *VAR_12;
    SSL_CIPHER *VAR_13;
#ifndef VAR_14
    unsigned char *VAR_15;
    SSL_COMP *VAR_16 = NULL;
#endif
    STACK_OF(SSL_CIPHER) *VAR_17 = NULL;

    if (VAR_0->state == VAR_18 && !VAR_0->first_packet)
        goto retry_cert;

    /* COMMENT_0 */
                                                                         
                                                                    
                                                                             
                                                            
       
    if (VAR_0->state == VAR_19) {
        VAR_0->state = VAR_20;
    }
    VAR_0->first_packet = 1;
    VAR_9 = VAR_0->method->ssl_get_message(VAR_0,
                                   VAR_20,
                                   VAR_18,
                                   VAR_21,
                                   VAR_22, &VAR_3);

    if (!VAR_3)
        return ((int)VAR_9);
    VAR_0->first_packet = 0;
    VAR_12 = VAR_11 = (unsigned char *)VAR_0->init_msg;

    /* COMMENT_6 */
                                                                            
                            
       
    if (VAR_9 < 2 + VAR_23 + 1) {
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_26);
        goto f_err;
    }

    /* COMMENT_10 */
                                                                        
                                                          
       
    VAR_0->client_version = (((int)VAR_11[0]) << 8) | (int)VAR_11[1];
    VAR_11 += 2;

    if (SSL_IS_DTLS(VAR_0) ? (VAR_0->client_version > VAR_0->version &&
                          VAR_0->method->version != VAR_27)
        : (VAR_0->client_version < VAR_0->version)) {
        SSLerr(VAR_25, VAR_28);
        if ((VAR_0->client_version >> 8) == VAR_29 &&
            !VAR_0->enc_write_ctx && !VAR_0->write_hash) {
            /* COMMENT_14 */
                                                                          
                     
               
            VAR_0->version = VAR_0->client_version;
        }
        VAR_4 = VAR_30;
        goto f_err;
    }

    /* COMMENT_18 */
                                                                           
                                                                       
                       
       
    if (SSL_get_options(VAR_0) & VAR_31) {
        unsigned int VAR_32, VAR_33;

        VAR_32 = *(VAR_11 + VAR_23);

        if (VAR_23 + VAR_32 + 1 >= (VAR_12 + VAR_9) - VAR_11) {
            VAR_4 = VAR_24;
            SSLerr(VAR_25, VAR_26);
            goto f_err;
        }
        VAR_33 = *(VAR_11 + VAR_23 + VAR_32 + 1);

        if (VAR_33 == 0)
            return 1;
    }

    /* COMMENT_23 */
    memcpy(VAR_0->s3->client_random, VAR_11, VAR_23);
    VAR_11 += VAR_23;

    /* COMMENT_24 */
    VAR_2 = *(VAR_11++);

    if ((VAR_12 + VAR_9) - VAR_11 < VAR_2) {
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_26);
        goto f_err;
    }

    if ((VAR_2 < 0) || (VAR_2 > VAR_34)) {
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_35);
        goto f_err;
    }

    VAR_0->hit = 0;
    /* COMMENT_25 */
                                                                       
                                                                           
                                           
                                                                            
                                                                             
                                                                       
                                                                            
                                                                          
                                                                
                                                                             
       
    if ((VAR_0->new_session
         && (VAR_0->options & VAR_36))) {
        if (!ssl_get_new_session(VAR_0, 1))
            goto err;
    } else {
        VAR_1 = ssl_get_prev_session(VAR_0, VAR_11, VAR_2, VAR_12 + VAR_9);
        /* COMMENT_37 */
                                                                      
                   
                                                                     
                                                                      
                                                              
                                                                    
                                                  
           
        if (VAR_1 == 1 && VAR_0->version == VAR_0->session->ssl_version) { /* COMMENT_46 */
                                                                            
            VAR_0->hit = 1;
        } else if (VAR_1 == -1)
            goto err;
        else {                  /* COMMENT_48 */

            if (!ssl_get_new_session(VAR_0, 1))
                goto err;
        }
    }

    VAR_11 += VAR_2;

    if (SSL_IS_DTLS(VAR_0)) {
        /* COMMENT_49 */
        if ((VAR_12 + VAR_9) - VAR_11 < 1) {
            VAR_4 = VAR_24;
            SSLerr(VAR_25, VAR_26);
            goto f_err;
        }
        VAR_8 = *(VAR_11++);

        if ((VAR_12 + VAR_9 ) - VAR_11 < VAR_8) {
            VAR_4 = VAR_24;
            SSLerr(VAR_25, VAR_26);
            goto f_err;
        }

        /* COMMENT_50 */
                                                           
                                                                   
                                      
           
        if (VAR_8 > sizeof(VAR_0->d1->rcvd_cookie)) {
            /* COMMENT_55 */
            VAR_4 = VAR_24;
            SSLerr(VAR_25, VAR_37);
            goto f_err;
        }

        /* COMMENT_56 */
        if ((SSL_get_options(VAR_0) & VAR_31) && VAR_8 > 0) {
            memcpy(VAR_0->d1->rcvd_cookie, VAR_11, VAR_8);

            if (VAR_0->ctx->app_verify_cookie_cb != NULL) {
                if (VAR_0->ctx->app_verify_cookie_cb(VAR_0, VAR_0->d1->rcvd_cookie,
                                                 VAR_8) == 0) {
                    VAR_4 = VAR_38;
                    SSLerr(VAR_25,
                           VAR_37);
                    goto f_err;
                }
                /* COMMENT_57 */
            }
            /* COMMENT_58 */
            else if (memcmp(VAR_0->d1->rcvd_cookie, VAR_0->d1->cookie,
                            VAR_0->d1->cookie_len) != 0) {
                VAR_4 = VAR_38;
                SSLerr(VAR_25, VAR_37);
                goto f_err;
            }
            VAR_7 = 1;
        }

        VAR_11 += VAR_8;
        if (VAR_0->method->version == VAR_27) {
            /* COMMENT_59 */
            if (VAR_0->client_version <= VAR_39 &&
                !(VAR_0->options & VAR_40)) {
                VAR_0->version = VAR_39;
                VAR_0->method = DTLSv1_2_server_method();
            } else if (tls1_suiteb(VAR_0)) {
                SSLerr(VAR_25,
                       VAR_41);
                VAR_0->version = VAR_0->client_version;
                VAR_4 = VAR_30;
                goto f_err;
            } else if (VAR_0->client_version <= VAR_42 &&
                       !(VAR_0->options & VAR_43)) {
                VAR_0->version = VAR_42;
                VAR_0->method = DTLSv1_server_method();
            } else {
                SSLerr(VAR_25,
                       VAR_28);
                VAR_0->version = VAR_0->client_version;
                VAR_4 = VAR_30;
                goto f_err;
            }
            VAR_0->session->ssl_version = VAR_0->version;
        }
    }

    if ((VAR_12 + VAR_9 ) - VAR_11 < 2) {
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_26);
        goto f_err;
    }
    n2s(VAR_11, VAR_1);

    if (VAR_1 == 0) {
        VAR_4 = VAR_44;
        SSLerr(VAR_25, VAR_45);
        goto f_err;
    }

    /* COMMENT_60 */
    if ((VAR_12 + VAR_9) - VAR_11 < VAR_1 + 1) {
        /* COMMENT_61 */
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_35);
        goto f_err;
    }
    if (ssl_bytes_to_cipher_list(VAR_0, VAR_11, VAR_1, &(VAR_17)) == NULL) {
        goto err;
    }
    VAR_11 += VAR_1;

    /* COMMENT_62 */
    if (VAR_0->hit) {
        VAR_2 = 0;
        VAR_10 = VAR_0->session->cipher->id;

#ifdef VAR_46
        fprintf(VAR_47, ""client sent %d ciphers\n"",
                sk_SSL_CIPHER_num(VAR_17));
#endif
        for (VAR_1 = 0; VAR_1 < sk_SSL_CIPHER_num(VAR_17); VAR_1++) {
            VAR_13 = sk_SSL_CIPHER_value(VAR_17, VAR_1);
#ifdef VAR_46
            fprintf(VAR_47, ""client [%2d of %2d]:%s\n"",
                    VAR_1, sk_SSL_CIPHER_num(VAR_17), SSL_CIPHER_get_name(VAR_13));
#endif
            if (VAR_13->id == VAR_10) {
                VAR_2 = 1;
                break;
            }
        }
        /* COMMENT_63 */
                                                                             
                         
           
#if 0
        if (VAR_2 == 0 && (VAR_0->options & VAR_48)
            && (sk_SSL_CIPHER_num(VAR_17) == 1)) {
            /* COMMENT_67 */
                                                                         
                                                                        
                                                                            
                                                                          
                                                               
               
            VAR_13 = sk_SSL_CIPHER_value(VAR_17, 0);
            if (sk_SSL_CIPHER_find(SSL_get_ciphers(VAR_0), VAR_13) >= 0) {
                VAR_0->session->cipher = VAR_13;
                VAR_2 = 1;
            }
        }
#endif
        if (VAR_2 == 0) {
            /* COMMENT_74 */
                                                                            
                          
               
            VAR_4 = VAR_44;
            SSLerr(VAR_25,
                   VAR_49);
            goto f_err;
        }
    }

    /* COMMENT_78 */
    VAR_1 = *(VAR_11++);
    if ((VAR_12 + VAR_9) - VAR_11 < VAR_1) {
        /* COMMENT_61 */
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_35);
        goto f_err;
    }
#ifndef VAR_14
    VAR_15 = VAR_11;
#endif
    for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++) {
        if (VAR_11[VAR_2] == 0)
            break;
    }

    VAR_11 += VAR_1;
    if (VAR_2 >= VAR_1) {
        /* COMMENT_79 */
        VAR_4 = VAR_24;
        SSLerr(VAR_25, VAR_50);
        goto f_err;
    }
#ifndef VAR_51
    /* COMMENT_80 */
    if (VAR_0->version >= VAR_52) {
        if (!ssl_parse_clienthello_tlsext(VAR_0, &VAR_11, VAR_12 + VAR_9)) {
            SSLerr(VAR_25, VAR_53);
            goto err;
        }
    }

    /* COMMENT_81 */
                                                                            
                                                                            
                                                                    
                                              
       
    {
        unsigned char *VAR_54;
        VAR_54 = VAR_0->s3->server_random;
        if (ssl_fill_hello_random(VAR_0, 1, VAR_54, VAR_23) <= 0) {
            goto f_err;
        }
    }

    if (!VAR_0->hit && VAR_0->version >= VAR_55 && VAR_0->tls_session_secret_cb) {
        SSL_CIPHER *VAR_56 = NULL;

        VAR_0->session->master_key_length = sizeof(VAR_0->session->master_key);
        if (VAR_0->tls_session_secret_cb(VAR_0, VAR_0->session->master_key,
                                     &VAR_0->session->master_key_length, VAR_17,
                                     &VAR_56,
                                     VAR_0->tls_session_secret_cb_arg)) {
            VAR_0->hit = 1;
            VAR_0->session->ciphers = VAR_17;
            VAR_0->session->verify_result = VAR_57;

            VAR_17 = NULL;

            /* COMMENT_87 */
            VAR_56 =
                VAR_56 ? VAR_56 : ssl3_choose_cipher(VAR_0,
                                                               VAR_0->
                                                               session->ciphers,
                                                               SSL_get_ciphers
                                                               (VAR_0));
            if (VAR_56 == NULL) {
                VAR_4 = VAR_38;
                SSLerr(VAR_25, VAR_58);
                goto f_err;
            }

            VAR_0->session->cipher = VAR_56;

            if (VAR_0->cipher_list)
                sk_SSL_CIPHER_free(VAR_0->cipher_list);

            if (VAR_0->cipher_list_by_id)
                sk_SSL_CIPHER_free(VAR_0->cipher_list_by_id);

            VAR_0->cipher_list = sk_SSL_CIPHER_dup(VAR_0->session->ciphers);
            VAR_0->cipher_list_by_id = sk_SSL_CIPHER_dup(VAR_0->session->ciphers);
        }
    }
#endif

    /* COMMENT_88 */
                                                                         
                                                                   
                                                 
       
    VAR_0->s3->tmp.new_compression = NULL;
#ifndef VAR_14
    /* COMMENT_93 */
    if (VAR_0->session->compress_meth != 0) {
        int VAR_59, VAR_60 = VAR_0->session->compress_meth;
        /* COMMENT_94 */
        /* COMMENT_95 */
        if (VAR_0->options & VAR_61) {
            SSLerr(VAR_25,
                   VAR_62);
            goto f_err;
        }
        /* COMMENT_96 */
        for (VAR_59 = 0; VAR_59 < sk_SSL_COMP_num(VAR_0->ctx->comp_methods); VAR_59++) {
            VAR_16 = sk_SSL_COMP_value(VAR_0->ctx->comp_methods, VAR_59);
            if (VAR_60 == VAR_16->id) {
                VAR_0->s3->tmp.new_compression = VAR_16;
                break;
            }
        }
        if (VAR_0->s3->tmp.new_compression == NULL) {
            SSLerr(VAR_25,
                   VAR_63);
            goto f_err;
        }
        /* COMMENT_97 */
        for (VAR_59 = 0; VAR_59 < VAR_1; VAR_59++) {
            if (VAR_15[VAR_59] == VAR_60)
                break;
        }
        if (VAR_59 >= VAR_1) {
            VAR_4 = VAR_44;
            SSLerr(VAR_25,
                   VAR_64);
            goto f_err;
        }
    } else if (VAR_0->hit)
        VAR_16 = NULL;
    else if (!(VAR_0->options & VAR_61) && VAR_0->ctx->comp_methods) {
        /* COMMENT_98 */
        int VAR_59, VAR_65, VAR_66, VAR_67, VAR_68 = 0;

        VAR_65 = sk_SSL_COMP_num(VAR_0->ctx->comp_methods);
        for (VAR_59 = 0; VAR_59 < VAR_65; VAR_59++) {
            VAR_16 = sk_SSL_COMP_value(VAR_0->ctx->comp_methods, VAR_59);
            VAR_67 = VAR_16->id;
            for (VAR_66 = 0; VAR_66 < VAR_1; VAR_66++) {
                if (VAR_67 == VAR_15[VAR_66]) {
                    VAR_68 = 1;
                    break;
                }
            }
            if (VAR_68)
                break;
        }
        if (VAR_68)
            VAR_0->s3->tmp.new_compression = VAR_16;
        else
            VAR_16 = NULL;
    }
#else
    /* COMMENT_99 */
                                                                         
                         
       
    if (VAR_0->session->compress_meth != 0) {
        SSLerr(VAR_25, VAR_62);
        goto f_err;
    }
#endif

    /* COMMENT_103 */
                                                                           
       

    if (!VAR_0->hit) {
#ifdef VAR_14
        VAR_0->session->compress_meth = 0;
#else
        VAR_0->session->compress_meth = (VAR_16 == NULL) ? 0 : VAR_16->id;
#endif
        if (VAR_0->session->ciphers != NULL)
            sk_SSL_CIPHER_free(VAR_0->session->ciphers);
        VAR_0->session->ciphers = VAR_17;
        if (VAR_17 == NULL) {
            VAR_4 = VAR_5;
            SSLerr(VAR_25, VAR_69);
            goto f_err;
        }
        VAR_17 = NULL;
        if (!tls1_set_server_sigalgs(VAR_0)) {
            SSLerr(VAR_25, VAR_70);
            goto err;
        }
        /* COMMENT_106 */
 retry_cert:
        if (VAR_0->cert->cert_cb) {
            int VAR_71 = VAR_0->cert->cert_cb(VAR_0, VAR_0->cert->cert_cb_arg);
            if (VAR_71 == 0) {
                VAR_4 = VAR_5;
                SSLerr(VAR_25, VAR_72);
                goto f_err;
            }
            if (VAR_71 < 0) {
                VAR_0->rwstate = VAR_73;
                return -1;
            }
            VAR_0->rwstate = VAR_74;
        }
        VAR_13 = ssl3_choose_cipher(VAR_0, VAR_0->session->ciphers, SSL_get_ciphers(VAR_0));

        if (VAR_13 == NULL) {
            VAR_4 = VAR_38;
            SSLerr(VAR_25, VAR_58);
            goto f_err;
        }
        VAR_0->s3->tmp.new_cipher = VAR_13;
    } else {
        /* COMMENT_107 */
#ifdef VAR_75
        VAR_76(SSL_CIPHER) *VAR_77;
        SSL_CIPHER *VAR_78 = NULL;
        SSL_CIPHER *VAR_79 = NULL;

        if (VAR_0->options & VAR_80) {
            VAR_77 = VAR_0->session->ciphers;
            for (VAR_1 = 0; VAR_1 < sk_SSL_CIPHER_num(VAR_77); VAR_1++) {
                VAR_13 = sk_SSL_CIPHER_value(VAR_77, VAR_1);
                if (VAR_13->algorithm_enc & VAR_81)
                    VAR_78 = VAR_13;
                if (SSL_C_IS_EXPORT(VAR_13))
                    VAR_79 = VAR_13;
            }
            if (VAR_78 != NULL)
                VAR_0->s3->tmp.new_cipher = VAR_78;
            else if (VAR_79 != NULL)
                VAR_0->s3->tmp.new_cipher = VAR_79;
            else
                VAR_0->s3->tmp.new_cipher = VAR_0->session->cipher;
        } else
#endif
            VAR_0->s3->tmp.new_cipher = VAR_0->session->cipher;
    }

    if (!SSL_USE_SIGALGS(VAR_0) || !(VAR_0->verify_mode & VAR_82)) {
        if (!ssl3_digest_cached_records(VAR_0))
            goto f_err;
    }

    /* COMMENT_108 */
                                      
                    
                                                          
                                                                  
                                                         
                                   
                                                             
                                                
                                                    
       

    /* COMMENT_119 */
    if (VAR_0->version >= VAR_52) {
        if (ssl_check_clienthello_tlsext_late(VAR_0) <= 0) {
            SSLerr(VAR_25, VAR_70);
            goto err;
        }
    }

    VAR_6 = VAR_7 ? 2 : 1;
    if (0) {
 f_err:
        ssl3_send_alert(VAR_0, VAR_83, VAR_4);
 err:
        VAR_0->state = VAR_84;
    }

    if (VAR_17 != NULL)
        sk_SSL_CIPHER_free(VAR_17);
    return VAR_6;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/s3_srvr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -79,7 +79,7 @@
 
         session_length = *(p + SSL3_RANDOM_SIZE);
 
-        if (p + SSL3_RANDOM_SIZE + session_length + 1 >= d + n) {
+        if (SSL3_RANDOM_SIZE + session_length + 1 >= (d + n) - p) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
             goto f_err;
@@ -97,7 +97,7 @@
     /* get the session-id */
     j = *(p++);
 
-    if (p + j > d + n) {
+    if ((d + n) - p < j) {
         al = SSL_AD_DECODE_ERROR;
         SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
         goto f_err;
@@ -153,14 +153,14 @@
 
     if (SSL_IS_DTLS(s)) {
         /* cookie stuff */
-        if (p + 1 > d + n) {
+        if ((d + n) - p < 1) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
             goto f_err;
         }
         cookie_len = *(p++);
 
-        if (p + cookie_len > d + n) {
+        if ((d + n ) - p < cookie_len) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
             goto f_err;
@@ -230,7 +230,7 @@
         }
     }
 
-    if (p + 2 > d + n) {
+    if ((d + n ) - p < 2) {
         al = SSL_AD_DECODE_ERROR;
         SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
         goto f_err;
@@ -244,7 +244,7 @@
     }
 
     /* i bytes of cipher data + 1 byte for compression length later */
-    if ((p + i + 1) > (d + n)) {
+    if ((d + n) - p < i + 1) {
         /* not enough data */
         al = SSL_AD_DECODE_ERROR;
         SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
@@ -310,7 +310,7 @@
 
     /* compression */
     i = *(p++);
-    if ((p + i) > (d + n)) {
+    if ((d + n) - p < i) {
         /* not enough data */
         al = SSL_AD_DECODE_ERROR;
         SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);","{'deleted_lines': ['        if (p + SSL3_RANDOM_SIZE + session_length + 1 >= d + n) {', '    if (p + j > d + n) {', '        if (p + 1 > d + n) {', '        if (p + cookie_len > d + n) {', '    if (p + 2 > d + n) {', '    if ((p + i + 1) > (d + n)) {', '    if ((p + i) > (d + n)) {'], 'added_lines': ['        if (SSL3_RANDOM_SIZE + session_length + 1 >= (d + n) - p) {', '    if ((d + n) - p < j) {', '        if ((d + n) - p < 1) {', '        if ((d + n ) - p < cookie_len) {', '    if ((d + n ) - p < 2) {', '    if ((d + n) - p < i + 1) {', '    if ((d + n) - p < i) {']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/t1_lib.c,ssl_scan_clienthello_custom_tlsext,"static int ssl_scan_clienthello_custom_tlsext(SSL *s,
const unsigned char *data,
const unsigned char *limit,
int *al)
{
unsigned short type, size, len;
if (s->hit || s->cert->srv_ext.meths_count == 0)
return 1;
if (data >= limit - 2)
return 1;
n2s(data, len);
if (data > limit - len)
return 1;
while (data <= limit - 4) {
n2s(data, type);
n2s(data, size);
if (data + size > limit)
return 1;
if (custom_ext_parse(s, 1  , type, data, size, al) <= 0)
return 0;
data += size;
}
return 1;
}","static int ssl_scan_clienthello_custom_tlsext(SSL *VAR_0,
const unsigned char *VAR_1,
const unsigned char *VAR_2,
int *VAR_3)
{
unsigned short VAR_4, VAR_5, VAR_6;
if (VAR_0->hit || VAR_0->cert->srv_ext.meths_count == 0)
return 1;
if (VAR_1 >= VAR_2 - 2)
return 1;
n2s(VAR_1, VAR_6);
if (VAR_1 > VAR_2 - VAR_6)
return 1;
while (VAR_1 <= VAR_2 - 4) {
n2s(VAR_1, VAR_4);
n2s(VAR_1, VAR_5);
if (VAR_1 + VAR_5 > VAR_2)
return 1;
if (custom_ext_parse(VAR_0, 1  , VAR_4, VAR_1, VAR_5, VAR_3) <= 0)
return 0;
VAR_1 += VAR_5;
}
return 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/before/0.json,"static int ssl_scan_clienthello_custom_tlsext(SSL *s,
                                              const unsigned char *data,
                                              const unsigned char *limit,
                                              int *al)
{
    unsigned short type, size, len;
    /* If resumed session or no custom extensions nothing to do */
    if (s->hit || s->cert->srv_ext.meths_count == 0)
        return 1;

    if (limit - data <= 2)
        return 1;
    n2s(data, len);

    if (limit - data < len)
        return 1;

    while (limit - data >= 4) {
        n2s(data, type);
        n2s(data, size);

        if (limit - data < size)
            return 1;
        if (custom_ext_parse(s, 1 /* server */ , type, data, size, al) <= 0)
            return 0;

        data += size;
    }

    return 1;
}","static int ssl_scan_clienthello_custom_tlsext(SSL *VAR_0,
                                              const unsigned char *VAR_1,
                                              const unsigned char *VAR_2,
                                              int *VAR_3)
{
    unsigned short VAR_4, VAR_5, VAR_6;
    /* COMMENT_0 */
    if (VAR_0->hit || VAR_0->cert->srv_ext.meths_count == 0)
        return 1;

    if (VAR_2 - VAR_1 <= 2)
        return 1;
    n2s(VAR_1, VAR_6);

    if (VAR_2 - VAR_1 < VAR_6)
        return 1;

    while (VAR_2 - VAR_1 >= 4) {
        n2s(VAR_1, VAR_4);
        n2s(VAR_1, VAR_5);

        if (VAR_2 - VAR_1 < VAR_5)
            return 1;
        if (custom_ext_parse(VAR_0, 1 /* COMMENT_1 */ , VAR_4, VAR_1, VAR_5, VAR_3) <= 0)
            return 0;

        VAR_1 += VAR_5;
    }

    return 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,18 +8,18 @@
     if (s->hit || s->cert->srv_ext.meths_count == 0)
         return 1;
 
-    if (data >= limit - 2)
+    if (limit - data <= 2)
         return 1;
     n2s(data, len);
 
-    if (data > limit - len)
+    if (limit - data < len)
         return 1;
 
-    while (data <= limit - 4) {
+    while (limit - data >= 4) {
         n2s(data, type);
         n2s(data, size);
 
-        if (data + size > limit)
+        if (limit - data < size)
             return 1;
         if (custom_ext_parse(s, 1 /* server */ , type, data, size, al) <= 0)
             return 0;","{'deleted_lines': ['    if (data >= limit - 2)', '    if (data > limit - len)', '    while (data <= limit - 4) {', '        if (data + size > limit)'], 'added_lines': ['    if (limit - data <= 2)', '    if (limit - data < len)', '    while (limit - data >= 4) {', '        if (limit - data < size)']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/t1_lib.c,ssl_scan_serverhello_tlsext,"static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p,
unsigned char *d, int n, int *al)
{
unsigned short length;
unsigned short type;
unsigned short size;
unsigned char *data = *p;
int tlsext_servername = 0;
int renegotiate_seen = 0;
# ifndef OPENSSL_NO_NEXTPROTONEG
s->s3->next_proto_neg_seen = 0;
# endif
s->tlsext_ticket_expected = 0;
if (s->s3->alpn_selected) {
OPENSSL_free(s->s3->alpn_selected);
s->s3->alpn_selected = NULL;
}
# ifndef OPENSSL_NO_HEARTBEATS
s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
# endif
if (data >= (d + n - 2))
goto ri_check;
n2s(data, length);
if (data + length != d + n) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
while (data <= (d + n - 4)) {
n2s(data, type);
n2s(data, size);
if (data + size > (d + n))
goto ri_check;
if (s->tlsext_debug_cb)
s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
if (type == TLSEXT_TYPE_server_name) {
if (s->tlsext_hostname == NULL || size > 0) {
*al = TLS1_AD_UNRECOGNIZED_NAME;
return 0;
}
tlsext_servername = 1;
}
# ifndef OPENSSL_NO_EC
else if (type == TLSEXT_TYPE_ec_point_formats) {
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
if (ecpointformatlist_length != size - 1) {
*al = TLS1_AD_DECODE_ERROR;
return 0;
}
if (!s->hit) {
s->session->tlsext_ecpointformatlist_length = 0;
if (s->session->tlsext_ecpointformatlist != NULL)
OPENSSL_free(s->session->tlsext_ecpointformatlist);
if ((s->session->tlsext_ecpointformatlist =
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
s->session->tlsext_ecpointformatlist_length =
ecpointformatlist_length;
memcpy(s->session->tlsext_ecpointformatlist, sdata,
ecpointformatlist_length);
}
#  if 0
fprintf(stderr,
""ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "");
sdata = s->session->tlsext_ecpointformatlist;
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
fprintf(stderr, ""%i "", *(sdata++));
fprintf(stderr, ""\n"");
#  endif
}
# endif                         
else if (type == TLSEXT_TYPE_session_ticket) {
if (s->tls_session_ticket_ext_cb &&
!s->tls_session_ticket_ext_cb(s, data, size,
s->tls_session_ticket_ext_cb_arg))
{
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
if ((SSL_get_options(s) & SSL_OP_NO_TICKET)
|| (size > 0)) {
*al = TLS1_AD_UNSUPPORTED_EXTENSION;
return 0;
}
s->tlsext_ticket_expected = 1;
}
# ifdef TLSEXT_TYPE_opaque_prf_input
else if (type == TLSEXT_TYPE_opaque_prf_input) {
unsigned char *sdata = data;
if (size < 2) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
n2s(sdata, s->s3->server_opaque_prf_input_len);
if (s->s3->server_opaque_prf_input_len != size - 2) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
if (s->s3->server_opaque_prf_input != NULL) {
OPENSSL_free(s->s3->server_opaque_prf_input);
}
if (s->s3->server_opaque_prf_input_len == 0) {
s->s3->server_opaque_prf_input = OPENSSL_malloc(1);
} else {
s->s3->server_opaque_prf_input =
BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);
}
if (s->s3->server_opaque_prf_input == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
}
# endif
else if (type == TLSEXT_TYPE_status_request) {
if ((s->tlsext_status_type == -1) || (size > 0)) {
*al = TLS1_AD_UNSUPPORTED_EXTENSION;
return 0;
}
s->tlsext_status_expected = 1;
}
# ifndef OPENSSL_NO_NEXTPROTONEG
else if (type == TLSEXT_TYPE_next_proto_neg &&
s->s3->tmp.finish_md_len == 0) {
unsigned char *selected;
unsigned char selected_len;
if (s->ctx->next_proto_select_cb == NULL) {
*al = TLS1_AD_UNSUPPORTED_EXTENSION;
return 0;
}
if (!ssl_next_proto_validate(data, size)) {
*al = TLS1_AD_DECODE_ERROR;
return 0;
}
if (s->
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
size,
s->ctx->next_proto_select_cb_arg) !=
SSL_TLSEXT_ERR_OK) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
s->next_proto_negotiated = OPENSSL_malloc(selected_len);
if (!s->next_proto_negotiated) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
memcpy(s->next_proto_negotiated, selected, selected_len);
s->next_proto_negotiated_len = selected_len;
s->s3->next_proto_neg_seen = 1;
}
# endif
else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {
unsigned len;
if (!s->cert->alpn_sent) {
*al = TLS1_AD_UNSUPPORTED_EXTENSION;
return 0;
}
if (size < 4) {
*al = TLS1_AD_DECODE_ERROR;
return 0;
}
len = data[0];
len <<= 8;
len |= data[1];
if (len != (unsigned)size - 2) {
*al = TLS1_AD_DECODE_ERROR;
return 0;
}
len = data[2];
if (len != (unsigned)size - 3) {
*al = TLS1_AD_DECODE_ERROR;
return 0;
}
if (s->s3->alpn_selected)
OPENSSL_free(s->s3->alpn_selected);
s->s3->alpn_selected = OPENSSL_malloc(len);
if (!s->s3->alpn_selected) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
memcpy(s->s3->alpn_selected, data + 3, len);
s->s3->alpn_selected_len = len;
}
else if (type == TLSEXT_TYPE_renegotiate) {
if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
return 0;
renegotiate_seen = 1;
}
# ifndef OPENSSL_NO_HEARTBEATS
else if (type == TLSEXT_TYPE_heartbeat) {
switch (data[0]) {
case 0x01:         
s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
break;
case 0x02:         
s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
break;
default:
*al = SSL_AD_ILLEGAL_PARAMETER;
return 0;
}
}
# endif
# ifndef OPENSSL_NO_SRTP
else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {
if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
return 0;
}
# endif
else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)
return 0;
data += size;
}
if (data != d + n) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
if (!s->hit && tlsext_servername == 1) {
if (s->tlsext_hostname) {
if (s->session->tlsext_hostname == NULL) {
s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
if (!s->session->tlsext_hostname) {
*al = SSL_AD_UNRECOGNIZED_NAME;
return 0;
}
} else {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
}
}
*p = data;
ri_check:
if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
*al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,
SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
return 0;
}
return 1;
}","static int ssl_scan_serverhello_tlsext(SSL *VAR_0, unsigned char **VAR_1,
unsigned char *VAR_2, int VAR_3, int *VAR_4)
{
unsigned short VAR_5;
unsigned short VAR_6;
unsigned short VAR_7;
unsigned char *VAR_8 = *VAR_1;
int VAR_9 = 0;
int VAR_10 = 0;
# ifndef VAR_11
VAR_0->s3->next_proto_neg_seen = 0;
# endif
VAR_0->tlsext_ticket_expected = 0;
if (VAR_0->s3->alpn_selected) {
OPENSSL_free(VAR_0->s3->alpn_selected);
VAR_0->s3->alpn_selected = NULL;
}
# ifndef VAR_12
VAR_0->tlsext_heartbeat &= ~(VAR_13 |
VAR_14);
# endif
if (VAR_8 >= (VAR_2 + VAR_3 - 2))
goto ri_check;
n2s(VAR_8, VAR_5);
if (VAR_8 + VAR_5 != VAR_2 + VAR_3) {
*VAR_4 = VAR_15;
return 0;
}
while (VAR_8 <= (VAR_2 + VAR_3 - 4)) {
n2s(VAR_8, VAR_6);
n2s(VAR_8, VAR_7);
if (VAR_8 + VAR_7 > (VAR_2 + VAR_3))
goto ri_check;
if (VAR_0->tlsext_debug_cb)
VAR_0->tlsext_debug_cb(VAR_0, 1, VAR_6, VAR_8, VAR_7, VAR_0->tlsext_debug_arg);
if (VAR_6 == VAR_16) {
if (VAR_0->tlsext_hostname == NULL || VAR_7 > 0) {
*VAR_4 = VAR_17;
return 0;
}
VAR_9 = 1;
}
# ifndef VAR_18
else if (type == VAR_19) {
unsigned char *VAR_20 = VAR_8;
int VAR_21 = *(VAR_20++);
if (VAR_21 != VAR_7 - 1) {
*VAR_4 = VAR_22;
return 0;
}
if (!VAR_0->hit) {
VAR_0->session->tlsext_ecpointformatlist_length = 0;
if (VAR_0->session->tlsext_ecpointformatlist != NULL)
OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);
if ((VAR_0->session->tlsext_ecpointformatlist =
OPENSSL_malloc(VAR_21)) == NULL) {
*VAR_4 = VAR_23;
return 0;
}
VAR_0->session->tlsext_ecpointformatlist_length =
VAR_21;
memcpy(VAR_0->session->tlsext_ecpointformatlist, VAR_20,
VAR_21);
}
#  if 0
fprintf(VAR_24,
""ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "");
VAR_20 = VAR_0->session->tlsext_ecpointformatlist;
for (VAR_25 = 0; VAR_25 < VAR_0->session->tlsext_ecpointformatlist_length; VAR_25++)
fprintf(VAR_24, ""%i "", *(VAR_20++));
fprintf(VAR_24, ""\n"");
#  endif
}
# endif                         
else if (type == VAR_26) {
if (VAR_0->tls_session_ticket_ext_cb &&
!VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_8, VAR_7,
VAR_0->tls_session_ticket_ext_cb_arg))
{
*VAR_4 = VAR_23;
return 0;
}
if ((SSL_get_options(VAR_0) & VAR_27)
|| (VAR_7 > 0)) {
*VAR_4 = VAR_28;
return 0;
}
VAR_0->tlsext_ticket_expected = 1;
}
# ifdef VAR_29
else if (type == VAR_29) {
unsigned char *VAR_20 = VAR_8;
if (VAR_7 < 2) {
*VAR_4 = VAR_15;
return 0;
}
n2s(VAR_20, VAR_0->s3->server_opaque_prf_input_len);
if (VAR_0->s3->server_opaque_prf_input_len != VAR_7 - 2) {
*VAR_4 = VAR_15;
return 0;
}
if (VAR_0->s3->server_opaque_prf_input != NULL) {
OPENSSL_free(VAR_0->s3->server_opaque_prf_input);
}
if (VAR_0->s3->server_opaque_prf_input_len == 0) {
VAR_0->s3->server_opaque_prf_input = OPENSSL_malloc(1);
} else {
VAR_0->s3->server_opaque_prf_input =
BUF_memdup(VAR_20, VAR_0->s3->server_opaque_prf_input_len);
}
if (VAR_0->s3->server_opaque_prf_input == NULL) {
*VAR_4 = VAR_23;
return 0;
}
}
# endif
else if (type == VAR_30) {
if ((VAR_0->tlsext_status_type == -1) || (VAR_7 > 0)) {
*VAR_4 = VAR_28;
return 0;
}
VAR_0->tlsext_status_expected = 1;
}
# ifndef VAR_11
else if (type == VAR_31 &&
VAR_0->VAR_32->VAR_33.VAR_34 == 0) {
unsigned char *VAR_35;
unsigned char VAR_36;
if (VAR_0->ctx->next_proto_select_cb == NULL) {
*VAR_4 = VAR_28;
return 0;
}
if (!ssl_next_proto_validate(VAR_8, VAR_7)) {
*VAR_4 = VAR_22;
return 0;
}
if (VAR_0->
ctx->next_proto_select_cb(VAR_0, &VAR_35, &VAR_36, VAR_8,
VAR_7,
VAR_0->ctx->next_proto_select_cb_arg) !=
VAR_37) {
*VAR_4 = VAR_23;
return 0;
}
VAR_0->next_proto_negotiated = OPENSSL_malloc(VAR_36);
if (!VAR_0->next_proto_negotiated) {
*VAR_4 = VAR_23;
return 0;
}
memcpy(VAR_0->next_proto_negotiated, VAR_35, VAR_36);
VAR_0->next_proto_negotiated_len = VAR_36;
VAR_0->s3->next_proto_neg_seen = 1;
}
# endif
else if (type == VAR_38) {
unsigned VAR_39;
if (!VAR_0->cert->alpn_sent) {
*VAR_4 = VAR_28;
return 0;
}
if (VAR_7 < 4) {
*VAR_4 = VAR_22;
return 0;
}
VAR_39 = VAR_8[0];
VAR_39 <<= 8;
VAR_39 |= VAR_8[1];
if (VAR_39 != (unsigned)VAR_7 - 2) {
*VAR_4 = VAR_22;
return 0;
}
VAR_39 = VAR_8[2];
if (VAR_39 != (unsigned)VAR_7 - 3) {
*VAR_4 = VAR_22;
return 0;
}
if (VAR_0->s3->alpn_selected)
OPENSSL_free(VAR_0->s3->alpn_selected);
VAR_0->s3->alpn_selected = OPENSSL_malloc(VAR_39);
if (!VAR_0->s3->alpn_selected) {
*VAR_4 = VAR_23;
return 0;
}
memcpy(VAR_0->s3->alpn_selected, VAR_8 + 3, VAR_39);
VAR_0->s3->alpn_selected_len = VAR_39;
}
else if (type == VAR_40) {
if (!ssl_parse_serverhello_renegotiate_ext(VAR_0, VAR_8, VAR_7, VAR_4))
return 0;
VAR_10 = 1;
}
# ifndef VAR_12
else if (type == VAR_41) {
switch (VAR_8[0]) {
case 0x01:         
VAR_0->tlsext_heartbeat |= VAR_13;
break;
case 0x02:         
VAR_0->tlsext_heartbeat |= VAR_13;
VAR_0->tlsext_heartbeat |= VAR_14;
break;
default:
*VAR_4 = VAR_42;
return 0;
}
}
# endif
# ifndef VAR_43
else if (VAR_44(s) && type == VAR_45) {
if (ssl_parse_serverhello_use_srtp_ext(s, VAR_8, VAR_7, VAR_4))
return 0;
}
# endif
else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)
return 0;
data += size;
}
if (data != VAR_2 + VAR_3) {
*al = VAR_15;
return 0;
}
if (!s->hit && VAR_9 == 1) {
if (s->tlsext_hostname) {
if (s->session->tlsext_hostname == NULL) {
s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
if (!s->session->tlsext_hostname) {
*al = VAR_46;
return 0;
}
} else {
*al = VAR_15;
return 0;
}
}
}
*VAR_1 = data;
ri_check:
if (!VAR_10 && !(s->options & VAR_47)
&& !(s->options & VAR_48)) {
*al = VAR_49;
SSLerr(VAR_50,
VAR_51);
return 0;
}
return 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/before/1.json,"static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p,
                                       unsigned char *d, int n, int *al)
{
    unsigned short length;
    unsigned short type;
    unsigned short size;
    unsigned char *data = *p;
    int tlsext_servername = 0;
    int renegotiate_seen = 0;

# ifndef OPENSSL_NO_NEXTPROTONEG
    s->s3->next_proto_neg_seen = 0;
# endif
    s->tlsext_ticket_expected = 0;

    if (s->s3->alpn_selected) {
        OPENSSL_free(s->s3->alpn_selected);
        s->s3->alpn_selected = NULL;
    }
# ifndef OPENSSL_NO_HEARTBEATS
    s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
                             SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
# endif

    if ((d + n) - data <= 2)
        goto ri_check;

    n2s(data, length);
    if ((d + n) - data != length) {
        *al = SSL_AD_DECODE_ERROR;
        return 0;
    }

    while ((d + n) - data >= 4) {
        n2s(data, type);
        n2s(data, size);

        if ((d + n) - data < size)
            goto ri_check;

        if (s->tlsext_debug_cb)
            s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);

        if (type == TLSEXT_TYPE_server_name) {
            if (s->tlsext_hostname == NULL || size > 0) {
                *al = TLS1_AD_UNRECOGNIZED_NAME;
                return 0;
            }
            tlsext_servername = 1;
        }
# ifndef OPENSSL_NO_EC
        else if (type == TLSEXT_TYPE_ec_point_formats) {
            unsigned char *sdata = data;
            int ecpointformatlist_length = *(sdata++);

            if (ecpointformatlist_length != size - 1) {
                *al = TLS1_AD_DECODE_ERROR;
                return 0;
            }
            if (!s->hit) {
                s->session->tlsext_ecpointformatlist_length = 0;
                if (s->session->tlsext_ecpointformatlist != NULL)
                    OPENSSL_free(s->session->tlsext_ecpointformatlist);
                if ((s->session->tlsext_ecpointformatlist =
                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
                    *al = TLS1_AD_INTERNAL_ERROR;
                    return 0;
                }
                s->session->tlsext_ecpointformatlist_length =
                    ecpointformatlist_length;
                memcpy(s->session->tlsext_ecpointformatlist, sdata,
                       ecpointformatlist_length);
            }
#  if 0
            fprintf(stderr,
                    ""ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "");
            sdata = s->session->tlsext_ecpointformatlist;
            for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
                fprintf(stderr, ""%i "", *(sdata++));
            fprintf(stderr, ""\n"");
#  endif
        }
# endif                         /* OPENSSL_NO_EC */

        else if (type == TLSEXT_TYPE_session_ticket) {
            if (s->tls_session_ticket_ext_cb &&
                !s->tls_session_ticket_ext_cb(s, data, size,
                                              s->tls_session_ticket_ext_cb_arg))
            {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
            if ((SSL_get_options(s) & SSL_OP_NO_TICKET)
                || (size > 0)) {
                *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                return 0;
            }
            s->tlsext_ticket_expected = 1;
        }
# ifdef TLSEXT_TYPE_opaque_prf_input
        else if (type == TLSEXT_TYPE_opaque_prf_input) {
            unsigned char *sdata = data;

            if (size < 2) {
                *al = SSL_AD_DECODE_ERROR;
                return 0;
            }
            n2s(sdata, s->s3->server_opaque_prf_input_len);
            if (s->s3->server_opaque_prf_input_len != size - 2) {
                *al = SSL_AD_DECODE_ERROR;
                return 0;
            }

            if (s->s3->server_opaque_prf_input != NULL) {
                /* shouldn't really happen */
                OPENSSL_free(s->s3->server_opaque_prf_input);
            }
            if (s->s3->server_opaque_prf_input_len == 0) {
                /* dummy byte just to get non-NULL */
                s->s3->server_opaque_prf_input = OPENSSL_malloc(1);
            } else {
                s->s3->server_opaque_prf_input =
                    BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);
            }

            if (s->s3->server_opaque_prf_input == NULL) {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
        }
# endif
        else if (type == TLSEXT_TYPE_status_request) {
            /*
             * MUST be empty and only sent if we've requested a status
             * request message.
             */
            if ((s->tlsext_status_type == -1) || (size > 0)) {
                *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                return 0;
            }
            /* Set flag to expect CertificateStatus message */
            s->tlsext_status_expected = 1;
        }
# ifndef OPENSSL_NO_NEXTPROTONEG
        else if (type == TLSEXT_TYPE_next_proto_neg &&
                 s->s3->tmp.finish_md_len == 0) {
            unsigned char *selected;
            unsigned char selected_len;

            /* We must have requested it. */
            if (s->ctx->next_proto_select_cb == NULL) {
                *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                return 0;
            }
            /* The data must be valid */
            if (!ssl_next_proto_validate(data, size)) {
                *al = TLS1_AD_DECODE_ERROR;
                return 0;
            }
            if (s->
                ctx->next_proto_select_cb(s, &selected, &selected_len, data,
                                          size,
                                          s->ctx->next_proto_select_cb_arg) !=
                SSL_TLSEXT_ERR_OK) {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
            s->next_proto_negotiated = OPENSSL_malloc(selected_len);
            if (!s->next_proto_negotiated) {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
            memcpy(s->next_proto_negotiated, selected, selected_len);
            s->next_proto_negotiated_len = selected_len;
            s->s3->next_proto_neg_seen = 1;
        }
# endif

        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {
            unsigned len;

            /* We must have requested it. */
            if (!s->cert->alpn_sent) {
                *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                return 0;
            }
            if (size < 4) {
                *al = TLS1_AD_DECODE_ERROR;
                return 0;
            }
            /*-
             * The extension data consists of:
             *   uint16 list_length
             *   uint8 proto_length;
             *   uint8 proto[proto_length];
             */
            len = data[0];
            len <<= 8;
            len |= data[1];
            if (len != (unsigned)size - 2) {
                *al = TLS1_AD_DECODE_ERROR;
                return 0;
            }
            len = data[2];
            if (len != (unsigned)size - 3) {
                *al = TLS1_AD_DECODE_ERROR;
                return 0;
            }
            if (s->s3->alpn_selected)
                OPENSSL_free(s->s3->alpn_selected);
            s->s3->alpn_selected = OPENSSL_malloc(len);
            if (!s->s3->alpn_selected) {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
            memcpy(s->s3->alpn_selected, data + 3, len);
            s->s3->alpn_selected_len = len;
        }

        else if (type == TLSEXT_TYPE_renegotiate) {
            if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
                return 0;
            renegotiate_seen = 1;
        }
# ifndef OPENSSL_NO_HEARTBEATS
        else if (type == TLSEXT_TYPE_heartbeat) {
            switch (data[0]) {
            case 0x01:         /* Server allows us to send HB requests */
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
                break;
            case 0x02:         /* Server doesn't accept HB requests */
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
                break;
            default:
                *al = SSL_AD_ILLEGAL_PARAMETER;
                return 0;
            }
        }
# endif
# ifndef OPENSSL_NO_SRTP
        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {
            if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
                return 0;
        }
# endif
        /*
         * If this extension type was not otherwise handled, but matches a
         * custom_cli_ext_record, then send it to the c callback
         */
        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)
            return 0;

        data += size;
    }

    if (data != d + n) {
        *al = SSL_AD_DECODE_ERROR;
        return 0;
    }

    if (!s->hit && tlsext_servername == 1) {
        if (s->tlsext_hostname) {
            if (s->session->tlsext_hostname == NULL) {
                s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
                if (!s->session->tlsext_hostname) {
                    *al = SSL_AD_UNRECOGNIZED_NAME;
                    return 0;
                }
            } else {
                *al = SSL_AD_DECODE_ERROR;
                return 0;
            }
        }
    }

    *p = data;

 ri_check:

    /*
     * Determine if we need to see RI. Strictly speaking if we want to avoid
     * an attack we should *always* see RI even on initial server hello
     * because the client doesn't see any renegotiation during an attack.
     * However this would mean we could not connect to any server which
     * doesn't support RI so for the immediate future tolerate RI absence on
     * initial connect only.
     */
    if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
        && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
        *al = SSL_AD_HANDSHAKE_FAILURE;
        SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,
               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
        return 0;
    }

    return 1;
}","static int ssl_scan_serverhello_tlsext(SSL *VAR_0, unsigned char **VAR_1,
                                       unsigned char *VAR_2, int VAR_3, int *VAR_4)
{
    unsigned short VAR_5;
    unsigned short VAR_6;
    unsigned short VAR_7;
    unsigned char *VAR_8 = *VAR_1;
    int VAR_9 = 0;
    int VAR_10 = 0;

# ifndef VAR_11
    VAR_0->s3->next_proto_neg_seen = 0;
# endif
    VAR_0->tlsext_ticket_expected = 0;

    if (VAR_0->s3->alpn_selected) {
        OPENSSL_free(VAR_0->s3->alpn_selected);
        VAR_0->s3->alpn_selected = NULL;
    }
# ifndef VAR_12
    VAR_0->tlsext_heartbeat &= ~(VAR_13 |
                             VAR_14);
# endif

    if ((VAR_2 + VAR_3) - VAR_8 <= 2)
        goto ri_check;

    n2s(VAR_8, VAR_5);
    if ((VAR_2 + VAR_3) - VAR_8 != VAR_5) {
        *VAR_4 = VAR_15;
        return 0;
    }

    while ((VAR_2 + VAR_3) - VAR_8 >= 4) {
        n2s(VAR_8, VAR_6);
        n2s(VAR_8, VAR_7);

        if ((VAR_2 + VAR_3) - VAR_8 < VAR_7)
            goto ri_check;

        if (VAR_0->tlsext_debug_cb)
            VAR_0->tlsext_debug_cb(VAR_0, 1, VAR_6, VAR_8, VAR_7, VAR_0->tlsext_debug_arg);

        if (VAR_6 == VAR_16) {
            if (VAR_0->tlsext_hostname == NULL || VAR_7 > 0) {
                *VAR_4 = VAR_17;
                return 0;
            }
            VAR_9 = 1;
        }
# ifndef VAR_18
        else if (type == VAR_19) {
            unsigned char *VAR_20 = VAR_8;
            int VAR_21 = *(VAR_20++);

            if (VAR_21 != VAR_7 - 1) {
                *VAR_4 = VAR_22;
                return 0;
            }
            if (!VAR_0->hit) {
                VAR_0->session->tlsext_ecpointformatlist_length = 0;
                if (VAR_0->session->tlsext_ecpointformatlist != NULL)
                    OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);
                if ((VAR_0->session->tlsext_ecpointformatlist =
                     OPENSSL_malloc(VAR_21)) == NULL) {
                    *VAR_4 = VAR_23;
                    return 0;
                }
                VAR_0->session->tlsext_ecpointformatlist_length =
                    VAR_21;
                memcpy(VAR_0->session->tlsext_ecpointformatlist, VAR_20,
                       VAR_21);
            }
#  if 0
            fprintf(VAR_24,
                    ""ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "");
            VAR_20 = VAR_0->session->tlsext_ecpointformatlist;
            for (VAR_25 = 0; VAR_25 < VAR_0->session->tlsext_ecpointformatlist_length; VAR_25++)
                fprintf(VAR_24, ""%i "", *(VAR_20++));
            fprintf(VAR_24, ""\n"");
#  endif
        }
# endif                         /* COMMENT_0 */

        else if (type == VAR_26) {
            if (VAR_0->tls_session_ticket_ext_cb &&
                !VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_8, VAR_7,
                                              VAR_0->tls_session_ticket_ext_cb_arg))
            {
                *VAR_4 = VAR_23;
                return 0;
            }
            if ((SSL_get_options(VAR_0) & VAR_27)
                || (VAR_7 > 0)) {
                *VAR_4 = VAR_28;
                return 0;
            }
            VAR_0->tlsext_ticket_expected = 1;
        }
# ifdef VAR_29
        else if (type == VAR_29) {
            unsigned char *VAR_20 = VAR_8;

            if (VAR_7 < 2) {
                *VAR_4 = VAR_15;
                return 0;
            }
            n2s(VAR_20, VAR_0->s3->server_opaque_prf_input_len);
            if (VAR_0->s3->server_opaque_prf_input_len != VAR_7 - 2) {
                *VAR_4 = VAR_15;
                return 0;
            }

            if (VAR_0->s3->server_opaque_prf_input != NULL) {
                /* COMMENT_1 */
                OPENSSL_free(VAR_0->s3->server_opaque_prf_input);
            }
            if (VAR_0->s3->server_opaque_prf_input_len == 0) {
                /* COMMENT_2 */
                VAR_0->s3->server_opaque_prf_input = OPENSSL_malloc(1);
            } else {
                VAR_0->s3->server_opaque_prf_input =
                    BUF_memdup(VAR_20, VAR_0->s3->server_opaque_prf_input_len);
            }

            if (VAR_0->s3->server_opaque_prf_input == NULL) {
                *VAR_4 = VAR_23;
                return 0;
            }
        }
# endif
        else if (type == VAR_30) {
            /* COMMENT_3 */
                                                                      
                               
               
            if ((VAR_0->tlsext_status_type == -1) || (VAR_7 > 0)) {
                *VAR_4 = VAR_28;
                return 0;
            }
            /* COMMENT_7 */
            VAR_0->tlsext_status_expected = 1;
        }
# ifndef VAR_11
        else if (type == VAR_31 &&
                 VAR_0->VAR_32->VAR_33.VAR_34 == 0) {
            unsigned char *VAR_35;
            unsigned char VAR_36;

            /* COMMENT_8 */
            if (VAR_0->ctx->next_proto_select_cb == NULL) {
                *VAR_4 = VAR_28;
                return 0;
            }
            /* COMMENT_9 */
            if (!ssl_next_proto_validate(VAR_8, VAR_7)) {
                *VAR_4 = VAR_22;
                return 0;
            }
            if (VAR_0->
                ctx->next_proto_select_cb(VAR_0, &VAR_35, &VAR_36, VAR_8,
                                          VAR_7,
                                          VAR_0->ctx->next_proto_select_cb_arg) !=
                VAR_37) {
                *VAR_4 = VAR_23;
                return 0;
            }
            VAR_0->next_proto_negotiated = OPENSSL_malloc(VAR_36);
            if (!VAR_0->next_proto_negotiated) {
                *VAR_4 = VAR_23;
                return 0;
            }
            memcpy(VAR_0->next_proto_negotiated, VAR_35, VAR_36);
            VAR_0->next_proto_negotiated_len = VAR_36;
            VAR_0->s3->next_proto_neg_seen = 1;
        }
# endif

        else if (type == VAR_38) {
            unsigned VAR_39;

            /* COMMENT_8 */
            if (!VAR_0->cert->alpn_sent) {
                *VAR_4 = VAR_28;
                return 0;
            }
            if (VAR_7 < 4) {
                *VAR_4 = VAR_22;
                return 0;
            }
            /* COMMENT_10 */
                                              
                                   
                                    
                                           
               
            VAR_39 = VAR_8[0];
            VAR_39 <<= 8;
            VAR_39 |= VAR_8[1];
            if (VAR_39 != (unsigned)VAR_7 - 2) {
                *VAR_4 = VAR_22;
                return 0;
            }
            VAR_39 = VAR_8[2];
            if (VAR_39 != (unsigned)VAR_7 - 3) {
                *VAR_4 = VAR_22;
                return 0;
            }
            if (VAR_0->s3->alpn_selected)
                OPENSSL_free(VAR_0->s3->alpn_selected);
            VAR_0->s3->alpn_selected = OPENSSL_malloc(VAR_39);
            if (!VAR_0->s3->alpn_selected) {
                *VAR_4 = VAR_23;
                return 0;
            }
            memcpy(VAR_0->s3->alpn_selected, VAR_8 + 3, VAR_39);
            VAR_0->s3->alpn_selected_len = VAR_39;
        }

        else if (type == VAR_40) {
            if (!ssl_parse_serverhello_renegotiate_ext(VAR_0, VAR_8, VAR_7, VAR_4))
                return 0;
            VAR_10 = 1;
        }
# ifndef VAR_12
        else if (type == VAR_41) {
            switch (VAR_8[0]) {
            case 0x01:         /* COMMENT_16 */
                VAR_0->tlsext_heartbeat |= VAR_13;
                break;
            case 0x02:         /* COMMENT_17 */
                VAR_0->tlsext_heartbeat |= VAR_13;
                VAR_0->tlsext_heartbeat |= VAR_14;
                break;
            default:
                *VAR_4 = VAR_42;
                return 0;
            }
        }
# endif
# ifndef VAR_43
        else if (VAR_44(s) && type == VAR_45) {
            if (ssl_parse_serverhello_use_srtp_ext(s, VAR_8, VAR_7, VAR_4))
                return 0;
        }
# endif
        /* COMMENT_18 */
                                                                          
                                                                
           
        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)
            return 0;

        data += size;
    }

    if (data != VAR_2 + VAR_3) {
        *al = VAR_15;
        return 0;
    }

    if (!s->hit && VAR_9 == 1) {
        if (s->tlsext_hostname) {
            if (s->session->tlsext_hostname == NULL) {
                s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
                if (!s->session->tlsext_hostname) {
                    *al = VAR_46;
                    return 0;
                }
            } else {
                *al = VAR_15;
                return 0;
            }
        }
    }

    *VAR_1 = data;

 ri_check:

    /* COMMENT_22 */
                                                                            
                                                                       
                                                                         
                                                                       
                                                                            
                            
       
    if (!VAR_10 && !(s->options & VAR_47)
        && !(s->options & VAR_48)) {
        *al = VAR_49;
        SSLerr(VAR_50,
               VAR_51);
        return 0;
    }

    return 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,20 +22,20 @@
                              SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
 # endif
 
-    if (data >= (d + n - 2))
+    if ((d + n) - data <= 2)
         goto ri_check;
 
     n2s(data, length);
-    if (data + length != d + n) {
+    if ((d + n) - data != length) {
         *al = SSL_AD_DECODE_ERROR;
         return 0;
     }
 
-    while (data <= (d + n - 4)) {
+    while ((d + n) - data >= 4) {
         n2s(data, type);
         n2s(data, size);
 
-        if (data + size > (d + n))
+        if ((d + n) - data < size)
             goto ri_check;
 
         if (s->tlsext_debug_cb)","{'deleted_lines': ['    if (data >= (d + n - 2))', '    if (data + length != d + n) {', '    while (data <= (d + n - 4)) {', '        if (data + size > (d + n))'], 'added_lines': ['    if ((d + n) - data <= 2)', '    if ((d + n) - data != length) {', '    while ((d + n) - data >= 4) {', '        if ((d + n) - data < size)']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/t1_lib.c,ssl_scan_clienthello_tlsext,"static int ssl_scan_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *limit, int *al)
{
unsigned short type;
unsigned short size;
unsigned short len;
unsigned char *data = *p;
int renegotiate_seen = 0;
s->servername_done = 0;
s->tlsext_status_type = -1;
# ifndef OPENSSL_NO_NEXTPROTONEG
s->s3->next_proto_neg_seen = 0;
# endif
if (s->s3->alpn_selected) {
OPENSSL_free(s->s3->alpn_selected);
s->s3->alpn_selected = NULL;
}
s->s3->alpn_selected_len = 0;
if (s->cert->alpn_proposed) {
OPENSSL_free(s->cert->alpn_proposed);
s->cert->alpn_proposed = NULL;
}
s->cert->alpn_proposed_len = 0;
# ifndef OPENSSL_NO_HEARTBEATS
s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
# endif
# ifndef OPENSSL_NO_EC
if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)
ssl_check_for_safari(s, data, limit);
# endif                         
if (s->cert->peer_sigalgs) {
OPENSSL_free(s->cert->peer_sigalgs);
s->cert->peer_sigalgs = NULL;
}
# ifndef OPENSSL_NO_SRP
if (s->srp_ctx.login != NULL) {
OPENSSL_free(s->srp_ctx.login);
s->srp_ctx.login = NULL;
}
# endif
s->srtp_profile = NULL;
if (data == limit)
goto ri_check;
if (data > (limit - 2))
goto err;
n2s(data, len);
if (data + len != limit)
goto err;
while (data <= (limit - 4)) {
n2s(data, type);
n2s(data, size);
if (data + size > (limit))
goto err;
# if 0
fprintf(stderr, ""Received extension type %d size %d\n"", type, size);
# endif
if (s->tlsext_debug_cb)
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
if (type == TLSEXT_TYPE_server_name) {
unsigned char *sdata;
int servname_type;
int dsize;
if (size < 2)
goto err;
n2s(data, dsize);
size -= 2;
if (dsize > size)
goto err;
sdata = data;
while (dsize > 3) {
servname_type = *(sdata++);
n2s(sdata, len);
dsize -= 3;
if (len > dsize)
goto err;
if (s->servername_done == 0)
switch (servname_type) {
case TLSEXT_NAMETYPE_host_name:
if (!s->hit) {
if (s->session->tlsext_hostname)
goto err;
if (len > TLSEXT_MAXLEN_host_name) {
*al = TLS1_AD_UNRECOGNIZED_NAME;
return 0;
}
if ((s->session->tlsext_hostname =
OPENSSL_malloc(len + 1)) == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
memcpy(s->session->tlsext_hostname, sdata, len);
s->session->tlsext_hostname[len] = '\0';
if (strlen(s->session->tlsext_hostname) != len) {
OPENSSL_free(s->session->tlsext_hostname);
s->session->tlsext_hostname = NULL;
*al = TLS1_AD_UNRECOGNIZED_NAME;
return 0;
}
s->servername_done = 1;
} else
s->servername_done = s->session->tlsext_hostname
&& strlen(s->session->tlsext_hostname) == len
&& strncmp(s->session->tlsext_hostname,
(char *)sdata, len) == 0;
break;
default:
break;
}
dsize -= len;
}
if (dsize != 0)
goto err;
}
# ifndef OPENSSL_NO_SRP
else if (type == TLSEXT_TYPE_srp) {
if (size == 0 || ((len = data[0])) != (size - 1))
goto err;
if (s->srp_ctx.login != NULL)
goto err;
if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)
return -1;
memcpy(s->srp_ctx.login, &data[1], len);
s->srp_ctx.login[len] = '\0';
if (strlen(s->srp_ctx.login) != len)
goto err;
}
# endif
# ifndef OPENSSL_NO_EC
else if (type == TLSEXT_TYPE_ec_point_formats) {
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
if (ecpointformatlist_length != size - 1 ||
ecpointformatlist_length < 1)
goto err;
if (!s->hit) {
if (s->session->tlsext_ecpointformatlist) {
OPENSSL_free(s->session->tlsext_ecpointformatlist);
s->session->tlsext_ecpointformatlist = NULL;
}
s->session->tlsext_ecpointformatlist_length = 0;
if ((s->session->tlsext_ecpointformatlist =
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
s->session->tlsext_ecpointformatlist_length =
ecpointformatlist_length;
memcpy(s->session->tlsext_ecpointformatlist, sdata,
ecpointformatlist_length);
}
#  if 0
fprintf(stderr,
""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "",
s->session->tlsext_ecpointformatlist_length);
sdata = s->session->tlsext_ecpointformatlist;
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
fprintf(stderr, ""%i "", *(sdata++));
fprintf(stderr, ""\n"");
#  endif
} else if (type == TLSEXT_TYPE_elliptic_curves) {
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
if (ellipticcurvelist_length != size - 2 ||
ellipticcurvelist_length < 1 ||
ellipticcurvelist_length & 1)
goto err;
if (!s->hit) {
if (s->session->tlsext_ellipticcurvelist)
goto err;
s->session->tlsext_ellipticcurvelist_length = 0;
if ((s->session->tlsext_ellipticcurvelist =
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
s->session->tlsext_ellipticcurvelist_length =
ellipticcurvelist_length;
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
ellipticcurvelist_length);
}
#  if 0
fprintf(stderr,
""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "",
s->session->tlsext_ellipticcurvelist_length);
sdata = s->session->tlsext_ellipticcurvelist;
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)
fprintf(stderr, ""%i "", *(sdata++));
fprintf(stderr, ""\n"");
#  endif
}
# endif                         
# ifdef TLSEXT_TYPE_opaque_prf_input
else if (type == TLSEXT_TYPE_opaque_prf_input) {
unsigned char *sdata = data;
if (size < 2) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
n2s(sdata, s->s3->client_opaque_prf_input_len);
if (s->s3->client_opaque_prf_input_len != size - 2) {
*al = SSL_AD_DECODE_ERROR;
return 0;
}
if (s->s3->client_opaque_prf_input != NULL) {
OPENSSL_free(s->s3->client_opaque_prf_input);
}
if (s->s3->client_opaque_prf_input_len == 0)
s->s3->client_opaque_prf_input = OPENSSL_malloc(1);
else
s->s3->client_opaque_prf_input =
BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);
if (s->s3->client_opaque_prf_input == NULL) {
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
}
# endif
else if (type == TLSEXT_TYPE_session_ticket) {
if (s->tls_session_ticket_ext_cb &&
!s->tls_session_ticket_ext_cb(s, data, size,
s->tls_session_ticket_ext_cb_arg))
{
*al = TLS1_AD_INTERNAL_ERROR;
return 0;
}
} else if (type == TLSEXT_TYPE_renegotiate) {
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
return 0;
renegotiate_seen = 1;
} else if (type == TLSEXT_TYPE_signature_algorithms) {
int dsize;
if (s->cert->peer_sigalgs || size < 2)
goto err;
n2s(data, dsize);
size -= 2;
if (dsize != size || dsize & 1 || !dsize)
goto err;
if (!tls1_save_sigalgs(s, data, dsize))
goto err;
} else if (type == TLSEXT_TYPE_status_request) {
if (size < 5)
goto err;
s->tlsext_status_type = *data++;
size--;
if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {
const unsigned char *sdata;
int dsize;
n2s(data, dsize);
size -= 2;
if (dsize > size)
goto err;
while (dsize > 0) {
OCSP_RESPID *id;
int idsize;
if (dsize < 4)
goto err;
n2s(data, idsize);
dsize -= 2 + idsize;
size -= 2 + idsize;
if (dsize < 0)
goto err;
sdata = data;
data += idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
if (!id)
goto err;
if (data != sdata) {
OCSP_RESPID_free(id);
goto err;
}
if (!s->tlsext_ocsp_ids
&& !(s->tlsext_ocsp_ids =
sk_OCSP_RESPID_new_null())) {
OCSP_RESPID_free(id);
*al = SSL_AD_INTERNAL_ERROR;
return 0;
}
if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {
OCSP_RESPID_free(id);
*al = SSL_AD_INTERNAL_ERROR;
return 0;
}
}
if (size < 2)
goto err;
n2s(data, dsize);
size -= 2;
if (dsize != size)
goto err;
sdata = data;
if (dsize > 0) {
if (s->tlsext_ocsp_exts) {
sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
X509_EXTENSION_free);
}
s->tlsext_ocsp_exts =
d2i_X509_EXTENSIONS(NULL, &sdata, dsize);
if (!s->tlsext_ocsp_exts || (data + dsize != sdata))
goto err;
}
}
else
s->tlsext_status_type = -1;
}
# ifndef OPENSSL_NO_HEARTBEATS
else if (type == TLSEXT_TYPE_heartbeat) {
switch (data[0]) {
case 0x01:         
s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
break;
case 0x02:         
s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
break;
default:
*al = SSL_AD_ILLEGAL_PARAMETER;
return 0;
}
}
# endif
# ifndef OPENSSL_NO_NEXTPROTONEG
else if (type == TLSEXT_TYPE_next_proto_neg &&
s->s3->tmp.finish_md_len == 0) {
s->s3->next_proto_neg_seen = 1;
}
# endif
else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&
s->s3->tmp.finish_md_len == 0) {
if (tls1_alpn_handle_client_hello(s, data, size, al) != 0)
return 0;
}
# ifndef OPENSSL_NO_SRTP
else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)
&& type == TLSEXT_TYPE_use_srtp) {
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
return 0;
}
# endif
data += size;
}
if (data != limit)
goto err;
*p = data;
ri_check:
if (!renegotiate_seen && s->renegotiate &&
!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
*al = SSL_AD_HANDSHAKE_FAILURE;
SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,
SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
return 0;
}
return 1;
err:
*al = SSL_AD_DECODE_ERROR;
return 0;
}","static int ssl_scan_clienthello_tlsext(SSL *VAR_0, unsigned char **VAR_1,
unsigned char *VAR_2, int *VAR_3)
{
unsigned short VAR_4;
unsigned short VAR_5;
unsigned short VAR_6;
unsigned char *VAR_7 = *VAR_1;
int VAR_8 = 0;
VAR_0->servername_done = 0;
VAR_0->tlsext_status_type = -1;
# ifndef VAR_9
VAR_0->s3->next_proto_neg_seen = 0;
# endif
if (VAR_0->s3->alpn_selected) {
OPENSSL_free(VAR_0->s3->alpn_selected);
VAR_0->s3->alpn_selected = NULL;
}
VAR_0->s3->alpn_selected_len = 0;
if (VAR_0->cert->alpn_proposed) {
OPENSSL_free(VAR_0->cert->alpn_proposed);
VAR_0->cert->alpn_proposed = NULL;
}
VAR_0->cert->alpn_proposed_len = 0;
# ifndef VAR_10
VAR_0->tlsext_heartbeat &= ~(VAR_11 |
VAR_12);
# endif
# ifndef VAR_13
if (VAR_0->options & VAR_14)
ssl_check_for_safari(VAR_0, VAR_7, VAR_2);
# endif                         
if (VAR_0->cert->peer_sigalgs) {
OPENSSL_free(VAR_0->cert->peer_sigalgs);
VAR_0->cert->peer_sigalgs = NULL;
}
# ifndef VAR_15
if (VAR_0->srp_ctx.login != NULL) {
OPENSSL_free(VAR_0->srp_ctx.login);
VAR_0->srp_ctx.login = NULL;
}
# endif
VAR_0->srtp_profile = NULL;
if (VAR_7 == VAR_2)
goto ri_check;
if (VAR_7 > (VAR_2 - 2))
goto err;
n2s(VAR_7, VAR_6);
if (VAR_7 + VAR_6 != VAR_2)
goto err;
while (VAR_7 <= (VAR_2 - 4)) {
n2s(VAR_7, VAR_4);
n2s(VAR_7, VAR_5);
if (VAR_7 + VAR_5 > (VAR_2))
goto err;
# if 0
fprintf(VAR_16, ""Received extension type %d size %d\n"", VAR_4, VAR_5);
# endif
if (VAR_0->tlsext_debug_cb)
VAR_0->tlsext_debug_cb(VAR_0, 0, VAR_4, VAR_7, VAR_5, VAR_0->tlsext_debug_arg);
if (VAR_4 == VAR_17) {
unsigned char *VAR_18;
int VAR_19;
int VAR_20;
if (VAR_5 < 2)
goto err;
n2s(VAR_7, VAR_20);
VAR_5 -= 2;
if (VAR_20 > VAR_5)
goto err;
VAR_18 = VAR_7;
while (VAR_20 > 3) {
VAR_19 = *(VAR_18++);
n2s(VAR_18, VAR_6);
VAR_20 -= 3;
if (VAR_6 > VAR_20)
goto err;
if (VAR_0->servername_done == 0)
switch (VAR_19) {
case VAR_21:
if (!VAR_0->hit) {
if (VAR_0->session->tlsext_hostname)
goto err;
if (VAR_6 > VAR_22) {
*VAR_3 = VAR_23;
return 0;
}
if ((VAR_0->session->tlsext_hostname =
OPENSSL_malloc(VAR_6 + 1)) == NULL) {
*VAR_3 = VAR_24;
return 0;
}
memcpy(VAR_0->session->tlsext_hostname, VAR_18, VAR_6);
VAR_0->session->tlsext_hostname[VAR_6] = '\0';
if (strlen(VAR_0->session->tlsext_hostname) != VAR_6) {
OPENSSL_free(VAR_0->session->tlsext_hostname);
VAR_0->session->tlsext_hostname = NULL;
*VAR_3 = VAR_23;
return 0;
}
VAR_0->servername_done = 1;
} else
VAR_0->servername_done = VAR_0->session->tlsext_hostname
&& strlen(VAR_0->session->tlsext_hostname) == VAR_6
&& strncmp(VAR_0->session->tlsext_hostname,
(char *)VAR_18, VAR_6) == 0;
break;
default:
break;
}
VAR_20 -= VAR_6;
}
if (VAR_20 != 0)
goto err;
}
# ifndef VAR_15
else if (type == VAR_25) {
if (VAR_5 == 0 || ((VAR_6 = VAR_7[0])) != (VAR_5 - 1))
goto err;
if (VAR_0->srp_ctx.login != NULL)
goto err;
if ((VAR_0->srp_ctx.login = OPENSSL_malloc(VAR_6 + 1)) == NULL)
return -1;
memcpy(VAR_0->srp_ctx.login, &VAR_7[1], VAR_6);
VAR_0->srp_ctx.login[VAR_6] = '\0';
if (strlen(VAR_0->srp_ctx.login) != VAR_6)
goto err;
}
# endif
# ifndef VAR_13
else if (type == VAR_26) {
unsigned char *VAR_18 = VAR_7;
int VAR_27 = *(VAR_18++);
if (VAR_27 != VAR_5 - 1 ||
VAR_27 < 1)
goto err;
if (!VAR_0->hit) {
if (VAR_0->session->tlsext_ecpointformatlist) {
OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);
VAR_0->session->tlsext_ecpointformatlist = NULL;
}
VAR_0->session->tlsext_ecpointformatlist_length = 0;
if ((VAR_0->session->tlsext_ecpointformatlist =
OPENSSL_malloc(VAR_27)) == NULL) {
*VAR_3 = VAR_24;
return 0;
}
VAR_0->session->tlsext_ecpointformatlist_length =
VAR_27;
memcpy(VAR_0->session->tlsext_ecpointformatlist, VAR_18,
VAR_27);
}
#  if 0
fprintf(VAR_16,
""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "",
VAR_0->session->tlsext_ecpointformatlist_length);
VAR_18 = VAR_0->session->tlsext_ecpointformatlist;
for (VAR_28 = 0; VAR_28 < VAR_0->session->tlsext_ecpointformatlist_length; VAR_28++)
fprintf(VAR_16, ""%i "", *(VAR_18++));
fprintf(VAR_16, ""\n"");
#  endif
} else if (type == VAR_29) {
unsigned char *VAR_18 = VAR_7;
int VAR_30 = (*(VAR_18++) << 8);
VAR_30 += (*(VAR_18++));
if (VAR_30 != VAR_5 - 2 ||
VAR_30 < 1 ||
VAR_30 & 1)
goto err;
if (!VAR_0->hit) {
if (VAR_0->session->tlsext_ellipticcurvelist)
goto err;
VAR_0->session->tlsext_ellipticcurvelist_length = 0;
if ((VAR_0->session->tlsext_ellipticcurvelist =
OPENSSL_malloc(VAR_30)) == NULL) {
*VAR_3 = VAR_24;
return 0;
}
VAR_0->session->tlsext_ellipticcurvelist_length =
VAR_30;
memcpy(VAR_0->session->tlsext_ellipticcurvelist, VAR_18,
VAR_30);
}
#  if 0
fprintf(VAR_16,
""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "",
VAR_0->session->tlsext_ellipticcurvelist_length);
VAR_18 = VAR_0->session->tlsext_ellipticcurvelist;
for (VAR_28 = 0; VAR_28 < VAR_0->session->tlsext_ellipticcurvelist_length; VAR_28++)
fprintf(VAR_16, ""%i "", *(VAR_18++));
fprintf(VAR_16, ""\n"");
#  endif
}
# endif                         
# ifdef VAR_31
else if (type == VAR_31) {
unsigned char *VAR_18 = VAR_7;
if (VAR_5 < 2) {
*VAR_3 = VAR_32;
return 0;
}
n2s(VAR_18, VAR_0->s3->client_opaque_prf_input_len);
if (VAR_0->s3->client_opaque_prf_input_len != VAR_5 - 2) {
*VAR_3 = VAR_32;
return 0;
}
if (VAR_0->s3->client_opaque_prf_input != NULL) {
OPENSSL_free(VAR_0->s3->client_opaque_prf_input);
}
if (VAR_0->s3->client_opaque_prf_input_len == 0)
VAR_0->s3->client_opaque_prf_input = OPENSSL_malloc(1);
else
VAR_0->s3->client_opaque_prf_input =
BUF_memdup(VAR_18, VAR_0->s3->client_opaque_prf_input_len);
if (VAR_0->s3->client_opaque_prf_input == NULL) {
*VAR_3 = VAR_24;
return 0;
}
}
# endif
else if (type == VAR_33) {
if (VAR_0->tls_session_ticket_ext_cb &&
!VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_7, VAR_5,
VAR_0->tls_session_ticket_ext_cb_arg))
{
*VAR_3 = VAR_24;
return 0;
}
} else if (type == VAR_34) {
if (!ssl_parse_clienthello_renegotiate_ext(VAR_0, VAR_7, VAR_5, VAR_3))
return 0;
VAR_8 = 1;
} else if (type == VAR_35) {
int VAR_20;
if (VAR_0->cert->peer_sigalgs || VAR_5 < 2)
goto err;
n2s(VAR_7, VAR_20);
VAR_5 -= 2;
if (VAR_20 != VAR_5 || VAR_20 & 1 || !VAR_20)
goto err;
if (!tls1_save_sigalgs(VAR_0, VAR_7, VAR_20))
goto err;
} else if (type == VAR_36) {
if (VAR_5 < 5)
goto err;
VAR_0->tlsext_status_type = *VAR_7++;
VAR_5--;
if (VAR_0->tlsext_status_type == VAR_37) {
const unsigned char *VAR_18;
int VAR_20;
n2s(VAR_7, VAR_20);
VAR_5 -= 2;
if (VAR_20 > VAR_5)
goto err;
while (VAR_20 > 0) {
OCSP_RESPID *VAR_38;
int VAR_39;
if (VAR_20 < 4)
goto err;
n2s(VAR_7, VAR_39);
VAR_20 -= 2 + VAR_39;
VAR_5 -= 2 + VAR_39;
if (VAR_20 < 0)
goto err;
VAR_18 = VAR_7;
VAR_7 += VAR_39;
VAR_38 = d2i_OCSP_RESPID(NULL, &VAR_18, VAR_39);
if (!VAR_38)
goto err;
if (VAR_7 != VAR_18) {
OCSP_RESPID_free(VAR_38);
goto err;
}
if (!VAR_0->tlsext_ocsp_ids
&& !(VAR_0->tlsext_ocsp_ids =
sk_OCSP_RESPID_new_null())) {
OCSP_RESPID_free(VAR_38);
*VAR_3 = VAR_40;
return 0;
}
if (!sk_OCSP_RESPID_push(VAR_0->tlsext_ocsp_ids, VAR_38)) {
OCSP_RESPID_free(VAR_38);
*VAR_3 = VAR_40;
return 0;
}
}
if (VAR_5 < 2)
goto err;
n2s(VAR_7, VAR_20);
VAR_5 -= 2;
if (VAR_20 != VAR_5)
goto err;
VAR_18 = VAR_7;
if (VAR_20 > 0) {
if (VAR_0->tlsext_ocsp_exts) {
sk_X509_EXTENSION_pop_free(VAR_0->tlsext_ocsp_exts,
VAR_41);
}
VAR_0->tlsext_ocsp_exts =
d2i_X509_EXTENSIONS(NULL, &VAR_18, VAR_20);
if (!VAR_0->tlsext_ocsp_exts || (VAR_7 + VAR_20 != VAR_18))
goto err;
}
}
else
VAR_0->tlsext_status_type = -1;
}
# ifndef VAR_10
else if (type == VAR_42) {
switch (VAR_7[0]) {
case 0x01:         
VAR_0->tlsext_heartbeat |= VAR_11;
break;
case 0x02:         
VAR_0->tlsext_heartbeat |= VAR_11;
VAR_0->tlsext_heartbeat |= VAR_12;
break;
default:
*VAR_3 = VAR_43;
return 0;
}
}
# endif
# ifndef VAR_9
else if (type == VAR_44 &&
VAR_0->VAR_45->VAR_46.VAR_47 == 0) {
VAR_0->s3->next_proto_neg_seen = 1;
}
# endif
else if (type == VAR_48 &&
VAR_0->VAR_45->VAR_46.VAR_47 == 0) {
if (tls1_alpn_handle_client_hello(VAR_0, VAR_7, VAR_5, VAR_3) != 0)
return 0;
}
# ifndef VAR_49
else if (VAR_50(s) && SSL_get_srtp_profiles(s)
&& type == VAR_51) {
if (ssl_parse_clienthello_use_srtp_ext(s, VAR_7, VAR_5, VAR_3))
return 0;
}
# endif
VAR_7 += VAR_5;
}
if (VAR_7 != VAR_2)
goto err;
*VAR_1 = VAR_7;
ri_check:
if (!VAR_8 && s->renegotiate &&
!(s->options & VAR_52)) {
*VAR_3 = VAR_53;
SSLerr(VAR_54,
VAR_55);
return 0;
}
return 1;
err:
*VAR_3 = VAR_32;
return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/before/2.json,"static int ssl_scan_clienthello_tlsext(SSL *s, unsigned char **p,
                                       unsigned char *limit, int *al)
{
    unsigned short type;
    unsigned short size;
    unsigned short len;
    unsigned char *data = *p;
    int renegotiate_seen = 0;

    s->servername_done = 0;
    s->tlsext_status_type = -1;
# ifndef OPENSSL_NO_NEXTPROTONEG
    s->s3->next_proto_neg_seen = 0;
# endif

    if (s->s3->alpn_selected) {
        OPENSSL_free(s->s3->alpn_selected);
        s->s3->alpn_selected = NULL;
    }
    s->s3->alpn_selected_len = 0;
    if (s->cert->alpn_proposed) {
        OPENSSL_free(s->cert->alpn_proposed);
        s->cert->alpn_proposed = NULL;
    }
    s->cert->alpn_proposed_len = 0;
# ifndef OPENSSL_NO_HEARTBEATS
    s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
                             SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
# endif

# ifndef OPENSSL_NO_EC
    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)
        ssl_check_for_safari(s, data, limit);
# endif                         /* !OPENSSL_NO_EC */

    /* Clear any signature algorithms extension received */
    if (s->cert->peer_sigalgs) {
        OPENSSL_free(s->cert->peer_sigalgs);
        s->cert->peer_sigalgs = NULL;
    }
# ifndef OPENSSL_NO_SRP
    if (s->srp_ctx.login != NULL) {
        OPENSSL_free(s->srp_ctx.login);
        s->srp_ctx.login = NULL;
    }
# endif

    s->srtp_profile = NULL;

    if (data == limit)
        goto ri_check;

    if (limit - data < 2)
        goto err;

    n2s(data, len);

    if (limit - data != len)
        goto err;

    while (limit - data >= 4) {
        n2s(data, type);
        n2s(data, size);

        if (limit - data < size)
            goto err;
# if 0
        fprintf(stderr, ""Received extension type %d size %d\n"", type, size);
# endif
        if (s->tlsext_debug_cb)
            s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
/*-
 * The servername extension is treated as follows:
 *
 * - Only the hostname type is supported with a maximum length of 255.
 * - The servername is rejected if too long or if it contains zeros,
 *   in which case an fatal alert is generated.
 * - The servername field is maintained together with the session cache.
 * - When a session is resumed, the servername call back invoked in order
 *   to allow the application to position itself to the right context.
 * - The servername is acknowledged if it is new for a session or when
 *   it is identical to a previously used for the same session.
 *   Applications can control the behaviour.  They can at any time
 *   set a 'desirable' servername for a new SSL object. This can be the
 *   case for example with HTTPS when a Host: header field is received and
 *   a renegotiation is requested. In this case, a possible servername
 *   presented in the new client hello is only acknowledged if it matches
 *   the value of the Host: field.
 * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
 *   if they provide for changing an explicit servername context for the
 *   session, i.e. when the session has been established with a servername
 *   extension.
 * - On session reconnect, the servername extension may be absent.
 *
 */

        if (type == TLSEXT_TYPE_server_name) {
            unsigned char *sdata;
            int servname_type;
            int dsize;

            if (size < 2)
                goto err;
            n2s(data, dsize);
            size -= 2;
            if (dsize > size)
                goto err;

            sdata = data;
            while (dsize > 3) {
                servname_type = *(sdata++);
                n2s(sdata, len);
                dsize -= 3;

                if (len > dsize)
                    goto err;

                if (s->servername_done == 0)
                    switch (servname_type) {
                    case TLSEXT_NAMETYPE_host_name:
                        if (!s->hit) {
                            if (s->session->tlsext_hostname)
                                goto err;

                            if (len > TLSEXT_MAXLEN_host_name) {
                                *al = TLS1_AD_UNRECOGNIZED_NAME;
                                return 0;
                            }
                            if ((s->session->tlsext_hostname =
                                 OPENSSL_malloc(len + 1)) == NULL) {
                                *al = TLS1_AD_INTERNAL_ERROR;
                                return 0;
                            }
                            memcpy(s->session->tlsext_hostname, sdata, len);
                            s->session->tlsext_hostname[len] = '\0';
                            if (strlen(s->session->tlsext_hostname) != len) {
                                OPENSSL_free(s->session->tlsext_hostname);
                                s->session->tlsext_hostname = NULL;
                                *al = TLS1_AD_UNRECOGNIZED_NAME;
                                return 0;
                            }
                            s->servername_done = 1;

                        } else
                            s->servername_done = s->session->tlsext_hostname
                                && strlen(s->session->tlsext_hostname) == len
                                && strncmp(s->session->tlsext_hostname,
                                           (char *)sdata, len) == 0;

                        break;

                    default:
                        break;
                    }

                dsize -= len;
            }
            if (dsize != 0)
                goto err;

        }
# ifndef OPENSSL_NO_SRP
        else if (type == TLSEXT_TYPE_srp) {
            if (size == 0 || ((len = data[0])) != (size - 1))
                goto err;
            if (s->srp_ctx.login != NULL)
                goto err;
            if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)
                return -1;
            memcpy(s->srp_ctx.login, &data[1], len);
            s->srp_ctx.login[len] = '\0';

            if (strlen(s->srp_ctx.login) != len)
                goto err;
        }
# endif

# ifndef OPENSSL_NO_EC
        else if (type == TLSEXT_TYPE_ec_point_formats) {
            unsigned char *sdata = data;
            int ecpointformatlist_length = *(sdata++);

            if (ecpointformatlist_length != size - 1 ||
                ecpointformatlist_length < 1)
                goto err;
            if (!s->hit) {
                if (s->session->tlsext_ecpointformatlist) {
                    OPENSSL_free(s->session->tlsext_ecpointformatlist);
                    s->session->tlsext_ecpointformatlist = NULL;
                }
                s->session->tlsext_ecpointformatlist_length = 0;
                if ((s->session->tlsext_ecpointformatlist =
                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
                    *al = TLS1_AD_INTERNAL_ERROR;
                    return 0;
                }
                s->session->tlsext_ecpointformatlist_length =
                    ecpointformatlist_length;
                memcpy(s->session->tlsext_ecpointformatlist, sdata,
                       ecpointformatlist_length);
            }
#  if 0
            fprintf(stderr,
                    ""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "",
                    s->session->tlsext_ecpointformatlist_length);
            sdata = s->session->tlsext_ecpointformatlist;
            for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
                fprintf(stderr, ""%i "", *(sdata++));
            fprintf(stderr, ""\n"");
#  endif
        } else if (type == TLSEXT_TYPE_elliptic_curves) {
            unsigned char *sdata = data;
            int ellipticcurvelist_length = (*(sdata++) << 8);
            ellipticcurvelist_length += (*(sdata++));

            if (ellipticcurvelist_length != size - 2 ||
                ellipticcurvelist_length < 1 ||
                /* Each NamedCurve is 2 bytes. */
                ellipticcurvelist_length & 1)
                    goto err;

            if (!s->hit) {
                if (s->session->tlsext_ellipticcurvelist)
                    goto err;

                s->session->tlsext_ellipticcurvelist_length = 0;
                if ((s->session->tlsext_ellipticcurvelist =
                     OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
                    *al = TLS1_AD_INTERNAL_ERROR;
                    return 0;
                }
                s->session->tlsext_ellipticcurvelist_length =
                    ellipticcurvelist_length;
                memcpy(s->session->tlsext_ellipticcurvelist, sdata,
                       ellipticcurvelist_length);
            }
#  if 0
            fprintf(stderr,
                    ""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "",
                    s->session->tlsext_ellipticcurvelist_length);
            sdata = s->session->tlsext_ellipticcurvelist;
            for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)
                fprintf(stderr, ""%i "", *(sdata++));
            fprintf(stderr, ""\n"");
#  endif
        }
# endif                         /* OPENSSL_NO_EC */
# ifdef TLSEXT_TYPE_opaque_prf_input
        else if (type == TLSEXT_TYPE_opaque_prf_input) {
            unsigned char *sdata = data;

            if (size < 2) {
                *al = SSL_AD_DECODE_ERROR;
                return 0;
            }
            n2s(sdata, s->s3->client_opaque_prf_input_len);
            if (s->s3->client_opaque_prf_input_len != size - 2) {
                *al = SSL_AD_DECODE_ERROR;
                return 0;
            }

            if (s->s3->client_opaque_prf_input != NULL) {
                /* shouldn't really happen */
                OPENSSL_free(s->s3->client_opaque_prf_input);
            }

            /* dummy byte just to get non-NULL */
            if (s->s3->client_opaque_prf_input_len == 0)
                s->s3->client_opaque_prf_input = OPENSSL_malloc(1);
            else
                s->s3->client_opaque_prf_input =
                    BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);
            if (s->s3->client_opaque_prf_input == NULL) {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
        }
# endif
        else if (type == TLSEXT_TYPE_session_ticket) {
            if (s->tls_session_ticket_ext_cb &&
                !s->tls_session_ticket_ext_cb(s, data, size,
                                              s->tls_session_ticket_ext_cb_arg))
            {
                *al = TLS1_AD_INTERNAL_ERROR;
                return 0;
            }
        } else if (type == TLSEXT_TYPE_renegotiate) {
            if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
                return 0;
            renegotiate_seen = 1;
        } else if (type == TLSEXT_TYPE_signature_algorithms) {
            int dsize;
            if (s->cert->peer_sigalgs || size < 2)
                goto err;
            n2s(data, dsize);
            size -= 2;
            if (dsize != size || dsize & 1 || !dsize)
                goto err;
            if (!tls1_save_sigalgs(s, data, dsize))
                goto err;
        } else if (type == TLSEXT_TYPE_status_request) {

            if (size < 5)
                goto err;

            s->tlsext_status_type = *data++;
            size--;
            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {
                const unsigned char *sdata;
                int dsize;
                /* Read in responder_id_list */
                n2s(data, dsize);
                size -= 2;
                if (dsize > size)
                    goto err;
                while (dsize > 0) {
                    OCSP_RESPID *id;
                    int idsize;
                    if (dsize < 4)
                        goto err;
                    n2s(data, idsize);
                    dsize -= 2 + idsize;
                    size -= 2 + idsize;
                    if (dsize < 0)
                        goto err;
                    sdata = data;
                    data += idsize;
                    id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
                    if (!id)
                        goto err;
                    if (data != sdata) {
                        OCSP_RESPID_free(id);
                        goto err;
                    }
                    if (!s->tlsext_ocsp_ids
                        && !(s->tlsext_ocsp_ids =
                             sk_OCSP_RESPID_new_null())) {
                        OCSP_RESPID_free(id);
                        *al = SSL_AD_INTERNAL_ERROR;
                        return 0;
                    }
                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {
                        OCSP_RESPID_free(id);
                        *al = SSL_AD_INTERNAL_ERROR;
                        return 0;
                    }
                }

                /* Read in request_extensions */
                if (size < 2)
                    goto err;
                n2s(data, dsize);
                size -= 2;
                if (dsize != size)
                    goto err;
                sdata = data;
                if (dsize > 0) {
                    if (s->tlsext_ocsp_exts) {
                        sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
                                                   X509_EXTENSION_free);
                    }

                    s->tlsext_ocsp_exts =
                        d2i_X509_EXTENSIONS(NULL, &sdata, dsize);
                    if (!s->tlsext_ocsp_exts || (data + dsize != sdata))
                        goto err;
                }
            }
            /*
             * We don't know what to do with any other type * so ignore it.
             */
            else
                s->tlsext_status_type = -1;
        }
# ifndef OPENSSL_NO_HEARTBEATS
        else if (type == TLSEXT_TYPE_heartbeat) {
            switch (data[0]) {
            case 0x01:         /* Client allows us to send HB requests */
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
                break;
            case 0x02:         /* Client doesn't accept HB requests */
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
                s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
                break;
            default:
                *al = SSL_AD_ILLEGAL_PARAMETER;
                return 0;
            }
        }
# endif
# ifndef OPENSSL_NO_NEXTPROTONEG
        else if (type == TLSEXT_TYPE_next_proto_neg &&
                 s->s3->tmp.finish_md_len == 0) {
            /*-
             * We shouldn't accept this extension on a
             * renegotiation.
             *
             * s->new_session will be set on renegotiation, but we
             * probably shouldn't rely that it couldn't be set on
             * the initial renegotation too in certain cases (when
             * there's some other reason to disallow resuming an
             * earlier session -- the current code won't be doing
             * anything like that, but this might change).
             *
             * A valid sign that there's been a previous handshake
             * in this connection is if s->s3->tmp.finish_md_len >
             * 0.  (We are talking about a check that will happen
             * in the Hello protocol round, well before a new
             * Finished message could have been computed.)
             */
            s->s3->next_proto_neg_seen = 1;
        }
# endif

        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&
                 s->s3->tmp.finish_md_len == 0) {
            if (tls1_alpn_handle_client_hello(s, data, size, al) != 0)
                return 0;
        }

        /* session ticket processed earlier */
# ifndef OPENSSL_NO_SRTP
        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)
                 && type == TLSEXT_TYPE_use_srtp) {
            if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
                return 0;
        }
# endif

        data += size;
    }

    /* Spurious data on the end */
    if (data != limit)
        goto err;

    *p = data;

 ri_check:

    /* Need RI if renegotiating */

    if (!renegotiate_seen && s->renegotiate &&
        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
        *al = SSL_AD_HANDSHAKE_FAILURE;
        SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,
               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
        return 0;
    }

    return 1;
err:
    *al = SSL_AD_DECODE_ERROR;
    return 0;
}","static int ssl_scan_clienthello_tlsext(SSL *VAR_0, unsigned char **VAR_1,
                                       unsigned char *VAR_2, int *VAR_3)
{
    unsigned short VAR_4;
    unsigned short VAR_5;
    unsigned short VAR_6;
    unsigned char *VAR_7 = *VAR_1;
    int VAR_8 = 0;

    VAR_0->servername_done = 0;
    VAR_0->tlsext_status_type = -1;
# ifndef VAR_9
    VAR_0->s3->next_proto_neg_seen = 0;
# endif

    if (VAR_0->s3->alpn_selected) {
        OPENSSL_free(VAR_0->s3->alpn_selected);
        VAR_0->s3->alpn_selected = NULL;
    }
    VAR_0->s3->alpn_selected_len = 0;
    if (VAR_0->cert->alpn_proposed) {
        OPENSSL_free(VAR_0->cert->alpn_proposed);
        VAR_0->cert->alpn_proposed = NULL;
    }
    VAR_0->cert->alpn_proposed_len = 0;
# ifndef VAR_10
    VAR_0->tlsext_heartbeat &= ~(VAR_11 |
                             VAR_12);
# endif

# ifndef VAR_13
    if (VAR_0->options & VAR_14)
        ssl_check_for_safari(VAR_0, VAR_7, VAR_2);
# endif                         /* COMMENT_0 */

    /* COMMENT_1 */
    if (VAR_0->cert->peer_sigalgs) {
        OPENSSL_free(VAR_0->cert->peer_sigalgs);
        VAR_0->cert->peer_sigalgs = NULL;
    }
# ifndef VAR_15
    if (VAR_0->srp_ctx.login != NULL) {
        OPENSSL_free(VAR_0->srp_ctx.login);
        VAR_0->srp_ctx.login = NULL;
    }
# endif

    VAR_0->srtp_profile = NULL;

    if (VAR_7 == VAR_2)
        goto ri_check;

    if (VAR_2 - VAR_7 < 2)
        goto err;

    n2s(VAR_7, VAR_6);

    if (VAR_2 - VAR_7 != VAR_6)
        goto err;

    while (VAR_2 - VAR_7 >= 4) {
        n2s(VAR_7, VAR_4);
        n2s(VAR_7, VAR_5);

        if (VAR_2 - VAR_7 < VAR_5)
            goto err;
# if 0
        fprintf(VAR_16, ""Received extension type %d size %d\n"", VAR_4, VAR_5);
# endif
        if (VAR_0->tlsext_debug_cb)
            VAR_0->tlsext_debug_cb(VAR_0, 0, VAR_4, VAR_7, VAR_5, VAR_0->tlsext_debug_arg);
/* COMMENT_2 */
                                                  
  
                                                                      
                                                                    
                                               
                                                                        
                                                                         
                                                                      
                                                                      
                                                               
                                                                  
                                                                       
                                                                          
                                                                      
                                                                         
                                  
                                                                         
                                                                        
                                                                          
               
                                                                  
  
   

        if (VAR_4 == VAR_17) {
            unsigned char *VAR_18;
            int VAR_19;
            int VAR_20;

            if (VAR_5 < 2)
                goto err;
            n2s(VAR_7, VAR_20);
            VAR_5 -= 2;
            if (VAR_20 > VAR_5)
                goto err;

            VAR_18 = VAR_7;
            while (VAR_20 > 3) {
                VAR_19 = *(VAR_18++);
                n2s(VAR_18, VAR_6);
                VAR_20 -= 3;

                if (VAR_6 > VAR_20)
                    goto err;

                if (VAR_0->servername_done == 0)
                    switch (VAR_19) {
                    case VAR_21:
                        if (!VAR_0->hit) {
                            if (VAR_0->session->tlsext_hostname)
                                goto err;

                            if (VAR_6 > VAR_22) {
                                *VAR_3 = VAR_23;
                                return 0;
                            }
                            if ((VAR_0->session->tlsext_hostname =
                                 OPENSSL_malloc(VAR_6 + 1)) == NULL) {
                                *VAR_3 = VAR_24;
                                return 0;
                            }
                            memcpy(VAR_0->session->tlsext_hostname, VAR_18, VAR_6);
                            VAR_0->session->tlsext_hostname[VAR_6] = '\0';
                            if (strlen(VAR_0->session->tlsext_hostname) != VAR_6) {
                                OPENSSL_free(VAR_0->session->tlsext_hostname);
                                VAR_0->session->tlsext_hostname = NULL;
                                *VAR_3 = VAR_23;
                                return 0;
                            }
                            VAR_0->servername_done = 1;

                        } else
                            VAR_0->servername_done = VAR_0->session->tlsext_hostname
                                && strlen(VAR_0->session->tlsext_hostname) == VAR_6
                                && strncmp(VAR_0->session->tlsext_hostname,
                                           (char *)VAR_18, VAR_6) == 0;

                        break;

                    default:
                        break;
                    }

                VAR_20 -= VAR_6;
            }
            if (VAR_20 != 0)
                goto err;

        }
# ifndef VAR_15
        else if (type == VAR_25) {
            if (VAR_5 == 0 || ((VAR_6 = VAR_7[0])) != (VAR_5 - 1))
                goto err;
            if (VAR_0->srp_ctx.login != NULL)
                goto err;
            if ((VAR_0->srp_ctx.login = OPENSSL_malloc(VAR_6 + 1)) == NULL)
                return -1;
            memcpy(VAR_0->srp_ctx.login, &VAR_7[1], VAR_6);
            VAR_0->srp_ctx.login[VAR_6] = '\0';

            if (strlen(VAR_0->srp_ctx.login) != VAR_6)
                goto err;
        }
# endif

# ifndef VAR_13
        else if (type == VAR_26) {
            unsigned char *VAR_18 = VAR_7;
            int VAR_27 = *(VAR_18++);

            if (VAR_27 != VAR_5 - 1 ||
                VAR_27 < 1)
                goto err;
            if (!VAR_0->hit) {
                if (VAR_0->session->tlsext_ecpointformatlist) {
                    OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);
                    VAR_0->session->tlsext_ecpointformatlist = NULL;
                }
                VAR_0->session->tlsext_ecpointformatlist_length = 0;
                if ((VAR_0->session->tlsext_ecpointformatlist =
                     OPENSSL_malloc(VAR_27)) == NULL) {
                    *VAR_3 = VAR_24;
                    return 0;
                }
                VAR_0->session->tlsext_ecpointformatlist_length =
                    VAR_27;
                memcpy(VAR_0->session->tlsext_ecpointformatlist, VAR_18,
                       VAR_27);
            }
#  if 0
            fprintf(VAR_16,
                    ""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "",
                    VAR_0->session->tlsext_ecpointformatlist_length);
            VAR_18 = VAR_0->session->tlsext_ecpointformatlist;
            for (VAR_28 = 0; VAR_28 < VAR_0->session->tlsext_ecpointformatlist_length; VAR_28++)
                fprintf(VAR_16, ""%i "", *(VAR_18++));
            fprintf(VAR_16, ""\n"");
#  endif
        } else if (type == VAR_29) {
            unsigned char *VAR_18 = VAR_7;
            int VAR_30 = (*(VAR_18++) << 8);
            VAR_30 += (*(VAR_18++));

            if (VAR_30 != VAR_5 - 2 ||
                VAR_30 < 1 ||
                /* COMMENT_25 */
                VAR_30 & 1)
                    goto err;

            if (!VAR_0->hit) {
                if (VAR_0->session->tlsext_ellipticcurvelist)
                    goto err;

                VAR_0->session->tlsext_ellipticcurvelist_length = 0;
                if ((VAR_0->session->tlsext_ellipticcurvelist =
                     OPENSSL_malloc(VAR_30)) == NULL) {
                    *VAR_3 = VAR_24;
                    return 0;
                }
                VAR_0->session->tlsext_ellipticcurvelist_length =
                    VAR_30;
                memcpy(VAR_0->session->tlsext_ellipticcurvelist, VAR_18,
                       VAR_30);
            }
#  if 0
            fprintf(VAR_16,
                    ""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "",
                    VAR_0->session->tlsext_ellipticcurvelist_length);
            VAR_18 = VAR_0->session->tlsext_ellipticcurvelist;
            for (VAR_28 = 0; VAR_28 < VAR_0->session->tlsext_ellipticcurvelist_length; VAR_28++)
                fprintf(VAR_16, ""%i "", *(VAR_18++));
            fprintf(VAR_16, ""\n"");
#  endif
        }
# endif                         /* COMMENT_26 */
# ifdef VAR_31
        else if (type == VAR_31) {
            unsigned char *VAR_18 = VAR_7;

            if (VAR_5 < 2) {
                *VAR_3 = VAR_32;
                return 0;
            }
            n2s(VAR_18, VAR_0->s3->client_opaque_prf_input_len);
            if (VAR_0->s3->client_opaque_prf_input_len != VAR_5 - 2) {
                *VAR_3 = VAR_32;
                return 0;
            }

            if (VAR_0->s3->client_opaque_prf_input != NULL) {
                /* COMMENT_27 */
                OPENSSL_free(VAR_0->s3->client_opaque_prf_input);
            }

            /* COMMENT_28 */
            if (VAR_0->s3->client_opaque_prf_input_len == 0)
                VAR_0->s3->client_opaque_prf_input = OPENSSL_malloc(1);
            else
                VAR_0->s3->client_opaque_prf_input =
                    BUF_memdup(VAR_18, VAR_0->s3->client_opaque_prf_input_len);
            if (VAR_0->s3->client_opaque_prf_input == NULL) {
                *VAR_3 = VAR_24;
                return 0;
            }
        }
# endif
        else if (type == VAR_33) {
            if (VAR_0->tls_session_ticket_ext_cb &&
                !VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_7, VAR_5,
                                              VAR_0->tls_session_ticket_ext_cb_arg))
            {
                *VAR_3 = VAR_24;
                return 0;
            }
        } else if (type == VAR_34) {
            if (!ssl_parse_clienthello_renegotiate_ext(VAR_0, VAR_7, VAR_5, VAR_3))
                return 0;
            VAR_8 = 1;
        } else if (type == VAR_35) {
            int VAR_20;
            if (VAR_0->cert->peer_sigalgs || VAR_5 < 2)
                goto err;
            n2s(VAR_7, VAR_20);
            VAR_5 -= 2;
            if (VAR_20 != VAR_5 || VAR_20 & 1 || !VAR_20)
                goto err;
            if (!tls1_save_sigalgs(VAR_0, VAR_7, VAR_20))
                goto err;
        } else if (type == VAR_36) {

            if (VAR_5 < 5)
                goto err;

            VAR_0->tlsext_status_type = *VAR_7++;
            VAR_5--;
            if (VAR_0->tlsext_status_type == VAR_37) {
                const unsigned char *VAR_18;
                int VAR_20;
                /* COMMENT_29 */
                n2s(VAR_7, VAR_20);
                VAR_5 -= 2;
                if (VAR_20 > VAR_5)
                    goto err;
                while (VAR_20 > 0) {
                    OCSP_RESPID *VAR_38;
                    int VAR_39;
                    if (VAR_20 < 4)
                        goto err;
                    n2s(VAR_7, VAR_39);
                    VAR_20 -= 2 + VAR_39;
                    VAR_5 -= 2 + VAR_39;
                    if (VAR_20 < 0)
                        goto err;
                    VAR_18 = VAR_7;
                    VAR_7 += VAR_39;
                    VAR_38 = d2i_OCSP_RESPID(NULL, &VAR_18, VAR_39);
                    if (!VAR_38)
                        goto err;
                    if (VAR_7 != VAR_18) {
                        OCSP_RESPID_free(VAR_38);
                        goto err;
                    }
                    if (!VAR_0->tlsext_ocsp_ids
                        && !(VAR_0->tlsext_ocsp_ids =
                             sk_OCSP_RESPID_new_null())) {
                        OCSP_RESPID_free(VAR_38);
                        *VAR_3 = VAR_40;
                        return 0;
                    }
                    if (!sk_OCSP_RESPID_push(VAR_0->tlsext_ocsp_ids, VAR_38)) {
                        OCSP_RESPID_free(VAR_38);
                        *VAR_3 = VAR_40;
                        return 0;
                    }
                }

                /* COMMENT_30 */
                if (VAR_5 < 2)
                    goto err;
                n2s(VAR_7, VAR_20);
                VAR_5 -= 2;
                if (VAR_20 != VAR_5)
                    goto err;
                VAR_18 = VAR_7;
                if (VAR_20 > 0) {
                    if (VAR_0->tlsext_ocsp_exts) {
                        sk_X509_EXTENSION_pop_free(VAR_0->tlsext_ocsp_exts,
                                                   VAR_41);
                    }

                    VAR_0->tlsext_ocsp_exts =
                        d2i_X509_EXTENSIONS(NULL, &VAR_18, VAR_20);
                    if (!VAR_0->tlsext_ocsp_exts || (VAR_7 + VAR_20 != VAR_18))
                        goto err;
                }
            }
            /* COMMENT_31 */
                                                                           
               
            else
                VAR_0->tlsext_status_type = -1;
        }
# ifndef VAR_10
        else if (type == VAR_42) {
            switch (VAR_7[0]) {
            case 0x01:         /* COMMENT_34 */
                VAR_0->tlsext_heartbeat |= VAR_11;
                break;
            case 0x02:         /* COMMENT_35 */
                VAR_0->tlsext_heartbeat |= VAR_11;
                VAR_0->tlsext_heartbeat |= VAR_12;
                break;
            default:
                *VAR_3 = VAR_43;
                return 0;
            }
        }
# endif
# ifndef VAR_9
        else if (type == VAR_44 &&
                 VAR_0->VAR_45->VAR_46.VAR_47 == 0) {
            /* COMMENT_36 */
                                                      
                             
              
                                                                  
                                                                 
                                                                  
                                                                
                                                                 
                                                          
              
                                                                  
                                                                  
                                                                 
                                                             
                                                          
               
            VAR_0->s3->next_proto_neg_seen = 1;
        }
# endif

        else if (type == VAR_48 &&
                 VAR_0->VAR_45->VAR_46.VAR_47 == 0) {
            if (tls1_alpn_handle_client_hello(VAR_0, VAR_7, VAR_5, VAR_3) != 0)
                return 0;
        }

        /* COMMENT_52 */
# ifndef VAR_49
        else if (VAR_50(s) && SSL_get_srtp_profiles(s)
                 && type == VAR_51) {
            if (ssl_parse_clienthello_use_srtp_ext(s, VAR_7, VAR_5, VAR_3))
                return 0;
        }
# endif

        VAR_7 += VAR_5;
    }

    /* COMMENT_53 */
    if (VAR_7 != VAR_2)
        goto err;

    *VAR_1 = VAR_7;

 ri_check:

    /* COMMENT_54 */

    if (!VAR_8 && s->renegotiate &&
        !(s->options & VAR_52)) {
        *VAR_3 = VAR_53;
        SSLerr(VAR_54,
               VAR_55);
        return 0;
    }

    return 1;
err:
    *VAR_3 = VAR_32;
    return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -50,19 +50,19 @@
     if (data == limit)
         goto ri_check;
 
-    if (data > (limit - 2))
+    if (limit - data < 2)
         goto err;
 
     n2s(data, len);
 
-    if (data + len != limit)
+    if (limit - data != len)
         goto err;
 
-    while (data <= (limit - 4)) {
+    while (limit - data >= 4) {
         n2s(data, type);
         n2s(data, size);
 
-        if (data + size > (limit))
+        if (limit - data < size)
             goto err;
 # if 0
         fprintf(stderr, ""Received extension type %d size %d\n"", type, size);","{'deleted_lines': ['    if (data > (limit - 2))', '    if (data + len != limit)', '    while (data <= (limit - 4)) {', '        if (data + size > (limit))'], 'added_lines': ['    if (limit - data < 2)', '    if (limit - data != len)', '    while (limit - data >= 4) {', '        if (limit - data < size)']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/t1_lib.c,tls1_process_ticket,"int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
const unsigned char *limit, SSL_SESSION **ret)
{
const unsigned char *p = session_id + len;
unsigned short i;
*ret = NULL;
s->tlsext_ticket_expected = 0;
if (SSL_get_options(s) & SSL_OP_NO_TICKET)
return 0;
if ((s->version <= SSL3_VERSION) || !limit)
return 0;
if (p >= limit)
return -1;
if (SSL_IS_DTLS(s)) {
i = *(p++);
p += i;
if (p >= limit)
return -1;
}
n2s(p, i);
p += i;
if (p >= limit)
return -1;
i = *(p++);
p += i;
if (p > limit)
return -1;
if ((p + 2) >= limit)
return 0;
n2s(p, i);
while ((p + 4) <= limit) {
unsigned short type, size;
n2s(p, type);
n2s(p, size);
if (p + size > limit)
return 0;
if (type == TLSEXT_TYPE_session_ticket) {
int r;
if (size == 0) {
s->tlsext_ticket_expected = 1;
return 1;
}
if (s->tls_session_secret_cb) {
return 2;
}
r = tls_decrypt_ticket(s, p, size, session_id, len, ret);
switch (r) {
case 2:            
s->tlsext_ticket_expected = 1;
return 2;
case 3:            
return r;
case 4:            
s->tlsext_ticket_expected = 1;
return 3;
default:           
return -1;
}
}
p += size;
}
return 0;
}","int tls1_process_ticket(SSL *VAR_0, unsigned char *VAR_1, int VAR_2,
const unsigned char *VAR_3, SSL_SESSION **VAR_4)
{
const unsigned char *VAR_5 = VAR_1 + VAR_2;
unsigned short VAR_6;
*VAR_4 = NULL;
VAR_0->tlsext_ticket_expected = 0;
if (SSL_get_options(VAR_0) & VAR_7)
return 0;
if ((VAR_0->version <= VAR_8) || !VAR_3)
return 0;
if (VAR_5 >= VAR_3)
return -1;
if (SSL_IS_DTLS(VAR_0)) {
VAR_6 = *(VAR_5++);
VAR_5 += VAR_6;
if (VAR_5 >= VAR_3)
return -1;
}
n2s(VAR_5, VAR_6);
VAR_5 += VAR_6;
if (VAR_5 >= VAR_3)
return -1;
VAR_6 = *(VAR_5++);
VAR_5 += VAR_6;
if (VAR_5 > VAR_3)
return -1;
if ((VAR_5 + 2) >= VAR_3)
return 0;
n2s(VAR_5, VAR_6);
while ((VAR_5 + 4) <= VAR_3) {
unsigned short VAR_9, VAR_10;
n2s(VAR_5, VAR_9);
n2s(VAR_5, VAR_10);
if (VAR_5 + VAR_10 > VAR_3)
return 0;
if (VAR_9 == VAR_11) {
int VAR_12;
if (VAR_10 == 0) {
VAR_0->tlsext_ticket_expected = 1;
return 1;
}
if (VAR_0->tls_session_secret_cb) {
return 2;
}
VAR_12 = tls_decrypt_ticket(VAR_0, VAR_5, VAR_10, VAR_1, VAR_2, VAR_4);
switch (VAR_12) {
case 2:            
VAR_0->tlsext_ticket_expected = 1;
return 2;
case 3:            
return VAR_12;
case 4:            
VAR_0->tlsext_ticket_expected = 1;
return 3;
default:           
return -1;
}
}
VAR_5 += VAR_10;
}
return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/before/3.json,"int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
                        const unsigned char *limit, SSL_SESSION **ret)
{
    /* Point after session ID in client hello */
    const unsigned char *p = session_id + len;
    unsigned short i;

    *ret = NULL;
    s->tlsext_ticket_expected = 0;

    /*
     * If tickets disabled behave as if no ticket present to permit stateful
     * resumption.
     */
    if (SSL_get_options(s) & SSL_OP_NO_TICKET)
        return 0;
    if ((s->version <= SSL3_VERSION) || !limit)
        return 0;
    if (p >= limit)
        return -1;
    /* Skip past DTLS cookie */
    if (SSL_IS_DTLS(s)) {
        i = *(p++);

        if (limit - p <= i)
            return -1;

        p += i;
    }
    /* Skip past cipher list */
    n2s(p, i);
    if (limit - p <= i)
        return -1;
    p += i;

    /* Skip past compression algorithm list */
    i = *(p++);
    if (limit - p < i)
        return -1;
    p += i;

    /* Now at start of extensions */
    if (limit - p <= 2)
        return 0;
    n2s(p, i);
    while (limit - p >= 4) {
        unsigned short type, size;
        n2s(p, type);
        n2s(p, size);
        if (limit - p < size)
            return 0;
        if (type == TLSEXT_TYPE_session_ticket) {
            int r;
            if (size == 0) {
                /*
                 * The client will accept a ticket but doesn't currently have
                 * one.
                 */
                s->tlsext_ticket_expected = 1;
                return 1;
            }
            if (s->tls_session_secret_cb) {
                /*
                 * Indicate that the ticket couldn't be decrypted rather than
                 * generating the session from ticket now, trigger
                 * abbreviated handshake based on external mechanism to
                 * calculate the master secret later.
                 */
                return 2;
            }
            r = tls_decrypt_ticket(s, p, size, session_id, len, ret);
            switch (r) {
            case 2:            /* ticket couldn't be decrypted */
                s->tlsext_ticket_expected = 1;
                return 2;
            case 3:            /* ticket was decrypted */
                return r;
            case 4:            /* ticket decrypted but need to renew */
                s->tlsext_ticket_expected = 1;
                return 3;
            default:           /* fatal error */
                return -1;
            }
        }
        p += size;
    }
    return 0;
}","int tls1_process_ticket(SSL *VAR_0, unsigned char *VAR_1, int VAR_2,
                        const unsigned char *VAR_3, SSL_SESSION **VAR_4)
{
    /* COMMENT_0 */
    const unsigned char *VAR_5 = VAR_1 + VAR_2;
    unsigned short VAR_6;

    *VAR_4 = NULL;
    VAR_0->tlsext_ticket_expected = 0;

    /* COMMENT_1 */
                                                                            
                  
       
    if (SSL_get_options(VAR_0) & VAR_7)
        return 0;
    if ((VAR_0->version <= VAR_8) || !VAR_3)
        return 0;
    if (VAR_5 >= VAR_3)
        return -1;
    /* COMMENT_5 */
    if (SSL_IS_DTLS(VAR_0)) {
        VAR_6 = *(VAR_5++);

        if (VAR_3 - VAR_5 <= VAR_6)
            return -1;

        VAR_5 += VAR_6;
    }
    /* COMMENT_6 */
    n2s(VAR_5, VAR_6);
    if (VAR_3 - VAR_5 <= VAR_6)
        return -1;
    VAR_5 += VAR_6;

    /* COMMENT_7 */
    VAR_6 = *(VAR_5++);
    if (VAR_3 - VAR_5 < VAR_6)
        return -1;
    VAR_5 += VAR_6;

    /* COMMENT_8 */
    if (VAR_3 - VAR_5 <= 2)
        return 0;
    n2s(VAR_5, VAR_6);
    while (VAR_3 - VAR_5 >= 4) {
        unsigned short VAR_9, VAR_10;
        n2s(VAR_5, VAR_9);
        n2s(VAR_5, VAR_10);
        if (VAR_3 - VAR_5 < VAR_10)
            return 0;
        if (VAR_9 == VAR_11) {
            int VAR_12;
            if (VAR_10 == 0) {
                /* COMMENT_9 */
                                                                             
                       
                   
                VAR_0->tlsext_ticket_expected = 1;
                return 1;
            }
            if (VAR_0->tls_session_secret_cb) {
                /* COMMENT_13 */
                                                                             
                                                                  
                                                                       
                                                     
                   
                return 2;
            }
            VAR_12 = tls_decrypt_ticket(VAR_0, VAR_5, VAR_10, VAR_1, VAR_2, VAR_4);
            switch (VAR_12) {
            case 2:            /* COMMENT_19 */
                VAR_0->tlsext_ticket_expected = 1;
                return 2;
            case 3:            /* COMMENT_20 */
                return VAR_12;
            case 4:            /* COMMENT_21 */
                VAR_0->tlsext_ticket_expected = 1;
                return 3;
            default:           /* COMMENT_22 */
                return -1;
            }
        }
        VAR_5 += VAR_10;
    }
    return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -21,29 +21,33 @@
     /* Skip past DTLS cookie */
     if (SSL_IS_DTLS(s)) {
         i = *(p++);
+
+        if (limit - p <= i)
+            return -1;
+
         p += i;
-        if (p >= limit)
-            return -1;
     }
     /* Skip past cipher list */
     n2s(p, i);
+    if (limit - p <= i)
+        return -1;
     p += i;
-    if (p >= limit)
-        return -1;
+
     /* Skip past compression algorithm list */
     i = *(p++);
+    if (limit - p < i)
+        return -1;
     p += i;
-    if (p > limit)
-        return -1;
+
     /* Now at start of extensions */
-    if ((p + 2) >= limit)
+    if (limit - p <= 2)
         return 0;
     n2s(p, i);
-    while ((p + 4) <= limit) {
+    while (limit - p >= 4) {
         unsigned short type, size;
         n2s(p, type);
         n2s(p, size);
-        if (p + size > limit)
+        if (limit - p < size)
             return 0;
         if (type == TLSEXT_TYPE_session_ticket) {
             int r;","{'deleted_lines': ['        if (p >= limit)', '            return -1;', '    if (p >= limit)', '        return -1;', '    if (p > limit)', '        return -1;', '    if ((p + 2) >= limit)', '    while ((p + 4) <= limit) {', '        if (p + size > limit)'], 'added_lines': ['', '        if (limit - p <= i)', '            return -1;', '', '    if (limit - p <= i)', '        return -1;', '', '    if (limit - p < i)', '        return -1;', '', '    if (limit - p <= 2)', '    while (limit - p >= 4) {', '        if (limit - p < size)']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/t1_lib.c,ssl_check_for_safari,"static void ssl_check_for_safari(SSL *s, const unsigned char *data,
const unsigned char *limit)
{
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
0x00, 0x0a,             
0x00, 0x08,             
0x00, 0x06,             
0x00, 0x17,             
0x00, 0x18,             
0x00, 0x19,             
0x00, 0x0b,             
0x00, 0x02,             
0x01,                   
0x00,                   
};
static const unsigned char kSafariTLS12ExtensionsBlock[] = {
0x00, 0x0d,             
0x00, 0x0c,             
0x00, 0x0a,             
0x05, 0x01,             
0x04, 0x01,             
0x02, 0x01,             
0x04, 0x03,             
0x02, 0x03,             
};
if (data >= (limit - 2))
return;
data += 2;
if (data > (limit - 4))
return;
n2s(data, type);
n2s(data, size);
if (type != TLSEXT_TYPE_server_name)
return;
if (data + size > limit)
return;
data += size;
if (TLS1_get_client_version(s) >= TLS1_2_VERSION) {
const size_t len1 = sizeof(kSafariExtensionsBlock);
const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);
if (data + len1 + len2 != limit)
return;
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
return;
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
return;
} else {
const size_t len = sizeof(kSafariExtensionsBlock);
if (data + len != limit)
return;
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
return;
}
s->s3->is_probably_safari = 1;
}","static void ssl_check_for_safari(SSL *VAR_0, const unsigned char *VAR_1,
const unsigned char *VAR_2)
{
unsigned short VAR_3, VAR_4;
static const unsigned char VAR_5[] = {
0x00, 0x0a,             
0x00, 0x08,             
0x00, 0x06,             
0x00, 0x17,             
0x00, 0x18,             
0x00, 0x19,             
0x00, 0x0b,             
0x00, 0x02,             
0x01,                   
0x00,                   
};
static const unsigned char VAR_6[] = {
0x00, 0x0d,             
0x00, 0x0c,             
0x00, 0x0a,             
0x05, 0x01,             
0x04, 0x01,             
0x02, 0x01,             
0x04, 0x03,             
0x02, 0x03,             
};
if (VAR_1 >= (VAR_2 - 2))
return;
VAR_1 += 2;
if (VAR_1 > (VAR_2 - 4))
return;
n2s(VAR_1, VAR_3);
n2s(VAR_1, VAR_4);
if (VAR_3 != VAR_7)
return;
if (VAR_1 + VAR_4 > VAR_2)
return;
VAR_1 += VAR_4;
if (TLS1_get_client_version(VAR_0) >= VAR_8) {
const size_t VAR_9 = sizeof(VAR_5);
const size_t VAR_10 = sizeof(VAR_6);
if (VAR_1 + VAR_9 + VAR_10 != VAR_2)
return;
if (memcmp(VAR_1, VAR_5, VAR_9) != 0)
return;
if (memcmp(VAR_1 + VAR_9, VAR_6, VAR_10) != 0)
return;
} else {
const size_t VAR_11 = sizeof(VAR_5);
if (VAR_1 + VAR_11 != VAR_2)
return;
if (memcmp(VAR_1, VAR_5, VAR_11) != 0)
return;
}
VAR_0->s3->is_probably_safari = 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/before/4.json,"static void ssl_check_for_safari(SSL *s, const unsigned char *data,
                                 const unsigned char *limit)
{
    unsigned short type, size;
    static const unsigned char kSafariExtensionsBlock[] = {
        0x00, 0x0a,             /* elliptic_curves extension */
        0x00, 0x08,             /* 8 bytes */
        0x00, 0x06,             /* 6 bytes of curve ids */
        0x00, 0x17,             /* P-256 */
        0x00, 0x18,             /* P-384 */
        0x00, 0x19,             /* P-521 */

        0x00, 0x0b,             /* ec_point_formats */
        0x00, 0x02,             /* 2 bytes */
        0x01,                   /* 1 point format */
        0x00,                   /* uncompressed */
    };

    /* The following is only present in TLS 1.2 */
    static const unsigned char kSafariTLS12ExtensionsBlock[] = {
        0x00, 0x0d,             /* signature_algorithms */
        0x00, 0x0c,             /* 12 bytes */
        0x00, 0x0a,             /* 10 bytes */
        0x05, 0x01,             /* SHA-384/RSA */
        0x04, 0x01,             /* SHA-256/RSA */
        0x02, 0x01,             /* SHA-1/RSA */
        0x04, 0x03,             /* SHA-256/ECDSA */
        0x02, 0x03,             /* SHA-1/ECDSA */
    };

    if (limit - data <= 2)
        return;
    data += 2;

    if (limit - data < 4)
        return;
    n2s(data, type);
    n2s(data, size);

    if (type != TLSEXT_TYPE_server_name)
        return;

    if (limit - data < size)
        return;
    data += size;

    if (TLS1_get_client_version(s) >= TLS1_2_VERSION) {
        const size_t len1 = sizeof(kSafariExtensionsBlock);
        const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);

        if (limit - data != (int)(len1 + len2))
            return;
        if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
            return;
        if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
            return;
    } else {
        const size_t len = sizeof(kSafariExtensionsBlock);

        if (limit - data != (int)(len))
            return;
        if (memcmp(data, kSafariExtensionsBlock, len) != 0)
            return;
    }

    s->s3->is_probably_safari = 1;
}","static void ssl_check_for_safari(SSL *VAR_0, const unsigned char *VAR_1,
                                 const unsigned char *VAR_2)
{
    unsigned short VAR_3, VAR_4;
    static const unsigned char VAR_5[] = {
        0x00, 0x0a,             /* COMMENT_0 */
        0x00, 0x08,             /* COMMENT_1 */
        0x00, 0x06,             /* COMMENT_2 */
        0x00, 0x17,             /* COMMENT_3 */
        0x00, 0x18,             /* COMMENT_4 */
        0x00, 0x19,             /* COMMENT_5 */

        0x00, 0x0b,             /* COMMENT_6 */
        0x00, 0x02,             /* COMMENT_7 */
        0x01,                   /* COMMENT_8 */
        0x00,                   /* COMMENT_9 */
    };

    /* COMMENT_10 */
    static const unsigned char VAR_6[] = {
        0x00, 0x0d,             /* COMMENT_11 */
        0x00, 0x0c,             /* COMMENT_12 */
        0x00, 0x0a,             /* COMMENT_13 */
        0x05, 0x01,             /* COMMENT_14 */
        0x04, 0x01,             /* COMMENT_15 */
        0x02, 0x01,             /* COMMENT_16 */
        0x04, 0x03,             /* COMMENT_17 */
        0x02, 0x03,             /* COMMENT_18 */
    };

    if (VAR_2 - VAR_1 <= 2)
        return;
    VAR_1 += 2;

    if (VAR_2 - VAR_1 < 4)
        return;
    n2s(VAR_1, VAR_3);
    n2s(VAR_1, VAR_4);

    if (VAR_3 != VAR_7)
        return;

    if (VAR_2 - VAR_1 < VAR_4)
        return;
    VAR_1 += VAR_4;

    if (TLS1_get_client_version(VAR_0) >= VAR_8) {
        const size_t VAR_9 = sizeof(VAR_5);
        const size_t VAR_10 = sizeof(VAR_6);

        if (VAR_2 - VAR_1 != (int)(VAR_9 + VAR_10))
            return;
        if (memcmp(VAR_1, VAR_5, VAR_9) != 0)
            return;
        if (memcmp(VAR_1 + VAR_9, VAR_6, VAR_10) != 0)
            return;
    } else {
        const size_t VAR_11 = sizeof(VAR_5);

        if (VAR_2 - VAR_1 != (int)(VAR_11))
            return;
        if (memcmp(VAR_1, VAR_5, VAR_11) != 0)
            return;
    }

    VAR_0->s3->is_probably_safari = 1;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/t1_lib.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -28,11 +28,11 @@
         0x02, 0x03,             /* SHA-1/ECDSA */
     };
 
-    if (data >= (limit - 2))
+    if (limit - data <= 2)
         return;
     data += 2;
 
-    if (data > (limit - 4))
+    if (limit - data < 4)
         return;
     n2s(data, type);
     n2s(data, size);
@@ -40,7 +40,7 @@
     if (type != TLSEXT_TYPE_server_name)
         return;
 
-    if (data + size > limit)
+    if (limit - data < size)
         return;
     data += size;
 
@@ -48,7 +48,7 @@
         const size_t len1 = sizeof(kSafariExtensionsBlock);
         const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);
 
-        if (data + len1 + len2 != limit)
+        if (limit - data != (int)(len1 + len2))
             return;
         if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
             return;
@@ -57,7 +57,7 @@
     } else {
         const size_t len = sizeof(kSafariExtensionsBlock);
 
-        if (data + len != limit)
+        if (limit - data != (int)(len))
             return;
         if (memcmp(data, kSafariExtensionsBlock, len) != 0)
             return;","{'deleted_lines': ['    if (data >= (limit - 2))', '    if (data > (limit - 4))', '    if (data + size > limit)', '        if (data + len1 + len2 != limit)', '        if (data + len != limit)'], 'added_lines': ['    if (limit - data <= 2)', '    if (limit - data < 4)', '    if (limit - data < size)', '        if (limit - data != (int)(len1 + len2))', '        if (limit - data != (int)(len))']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-2177,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openssl,"
Avoid some undefined pointer arithmetic

A common idiom in the codebase is:

if (p + len > limit)
{
    return; /* Too long */
}

Where ""p"" points to some malloc'd data of SIZE bytes and
limit == p + SIZE

""len"" here could be from some externally supplied data (e.g. from a TLS
message).

The rules of C pointer arithmetic are such that ""p + len"" is only well
defined where len <= SIZE. Therefore the above idiom is actually
undefined behaviour.

For example this could cause problems if some malloc implementation
provides an address for ""p"" such that ""p + len"" actually overflows for
values of len that are too big and therefore p + len < limit!

Issue reported by Guido Vranken.

CVE-2016-2177

Reviewed-by: Rich Salz <rsalz@openssl.org>
",a004e72b95835136d3f1ea90517f706c24c03da7,https://git.openssl.org/?p=openssl.git;a=commit;h=a004e72b95835136d3f1ea90517f706c24c03da7,ssl/ssl_sess.c,ssl_get_prev_session,"int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,
const unsigned char *limit)
{
SSL_SESSION *ret = NULL;
int fatal = 0;
int try_session_cache = 1;
#ifndef OPENSSL_NO_TLSEXT
int r;
#endif
if (session_id + len > limit) {
fatal = 1;
goto err;
}
if (len == 0)
try_session_cache = 0;
#ifndef OPENSSL_NO_TLSEXT
r = tls1_process_ticket(s, session_id, len, limit, &ret);
switch (r) {
case -1:                   
fatal = 1;
goto err;
case 0:                    
case 1:                    
break;                  
case 2:                    
case 3:                    
try_session_cache = 0;
break;
default:
abort();
}
#endif
if (try_session_cache &&
ret == NULL &&
!(s->session_ctx->session_cache_mode &
SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {
SSL_SESSION data;
data.ssl_version = s->version;
data.session_id_length = len;
if (len == 0)
return 0;
memcpy(data.session_id, session_id, len);
CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);
if (ret != NULL) {
CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);
}
CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
if (ret == NULL)
s->session_ctx->stats.sess_miss++;
}
if (try_session_cache &&
ret == NULL && s->session_ctx->get_session_cb != NULL) {
int copy = 1;
if ((ret = s->session_ctx->get_session_cb(s, session_id, len, &copy))) {
s->session_ctx->stats.sess_cb_hit++;
if (copy)
CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);
if (!
(s->session_ctx->session_cache_mode &
SSL_SESS_CACHE_NO_INTERNAL_STORE))
SSL_CTX_add_session(s->session_ctx, ret);
}
}
if (ret == NULL)
goto err;
if (ret->sid_ctx_length != s->sid_ctx_length
|| memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {
goto err;               
}
if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {
SSLerr(SSL_F_SSL_GET_PREV_SESSION,
SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
fatal = 1;
goto err;
}
if (ret->cipher == NULL) {
unsigned char buf[5], *p;
unsigned long l;
p = buf;
l = ret->cipher_id;
l2n(l, p);
if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)
ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));
else
ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));
if (ret->cipher == NULL)
goto err;
}
if (ret->timeout < (long)(time(NULL) - ret->time)) { 
s->session_ctx->stats.sess_timeout++;
if (try_session_cache) {
SSL_CTX_remove_session(s->session_ctx, ret);
}
goto err;
}
s->session_ctx->stats.sess_hit++;
if (s->session != NULL)
SSL_SESSION_free(s->session);
s->session = ret;
s->verify_result = s->session->verify_result;
return 1;
err:
if (ret != NULL) {
SSL_SESSION_free(ret);
#ifndef OPENSSL_NO_TLSEXT
if (!try_session_cache) {
s->tlsext_ticket_expected = 1;
}
#endif
}
if (fatal)
return -1;
else
return 0;
}","int ssl_get_prev_session(SSL *VAR_0, unsigned char *VAR_1, int VAR_2,
const unsigned char *VAR_3)
{
SSL_SESSION *VAR_4 = NULL;
int VAR_5 = 0;
int VAR_6 = 1;
#ifndef VAR_7
int VAR_8;
#endif
if (VAR_1 + VAR_2 > VAR_3) {
VAR_5 = 1;
goto err;
}
if (VAR_2 == 0)
VAR_6 = 0;
#ifndef VAR_7
VAR_8 = tls1_process_ticket(VAR_0, VAR_1, VAR_2, VAR_3, &VAR_4);
switch (VAR_8) {
case -1:                   
VAR_5 = 1;
goto err;
case 0:                    
case 1:                    
break;                  
case 2:                    
case 3:                    
VAR_6 = 0;
break;
default:
abort();
}
#endif
if (VAR_6 &&
VAR_4 == NULL &&
!(VAR_0->session_ctx->session_cache_mode &
VAR_9)) {
SSL_SESSION VAR_10;
VAR_10.ssl_version = VAR_0->version;
VAR_10.session_id_length = VAR_2;
if (VAR_2 == 0)
return 0;
memcpy(VAR_10.session_id, VAR_1, VAR_2);
CRYPTO_r_lock(VAR_11);
VAR_4 = lh_SSL_SESSION_retrieve(VAR_0->session_ctx->sessions, &VAR_10);
if (VAR_4 != NULL) {
CRYPTO_add(&VAR_4->references, 1, VAR_12);
}
CRYPTO_r_unlock(VAR_11);
if (VAR_4 == NULL)
VAR_0->session_ctx->stats.sess_miss++;
}
if (VAR_6 &&
VAR_4 == NULL && VAR_0->session_ctx->get_session_cb != NULL) {
int VAR_13 = 1;
if ((VAR_4 = VAR_0->session_ctx->get_session_cb(VAR_0, VAR_1, VAR_2, &VAR_13))) {
VAR_0->session_ctx->stats.sess_cb_hit++;
if (VAR_13)
CRYPTO_add(&VAR_4->references, 1, VAR_12);
if (!
(VAR_0->session_ctx->session_cache_mode &
VAR_14))
SSL_CTX_add_session(VAR_0->session_ctx, VAR_4);
}
}
if (VAR_4 == NULL)
goto err;
if (VAR_4->sid_ctx_length != VAR_0->sid_ctx_length
|| memcmp(VAR_4->sid_ctx, VAR_0->sid_ctx, VAR_4->sid_ctx_length)) {
goto err;               
}
if ((VAR_0->verify_mode & VAR_15) && VAR_0->sid_ctx_length == 0) {
SSLerr(VAR_16,
VAR_17);
VAR_5 = 1;
goto err;
}
if (VAR_4->cipher == NULL) {
unsigned char VAR_18[5], *VAR_19;
unsigned long VAR_20;
VAR_19 = VAR_18;
VAR_20 = VAR_4->cipher_id;
l2n(VAR_20, VAR_19);
if ((VAR_4->ssl_version >> 8) >= VAR_21)
VAR_4->cipher = ssl_get_cipher_by_char(VAR_0, &(VAR_18[2]));
else
VAR_4->cipher = ssl_get_cipher_by_char(VAR_0, &(VAR_18[1]));
if (VAR_4->cipher == NULL)
goto err;
}
if (VAR_4->timeout < (long)(time(NULL) - VAR_4->time)) { 
VAR_0->session_ctx->stats.sess_timeout++;
if (VAR_6) {
SSL_CTX_remove_session(VAR_0->session_ctx, VAR_4);
}
goto err;
}
VAR_0->session_ctx->stats.sess_hit++;
if (VAR_0->session != NULL)
SSL_SESSION_free(VAR_0->session);
VAR_0->session = VAR_4;
VAR_0->verify_result = VAR_0->session->verify_result;
return 1;
err:
if (VAR_4 != NULL) {
SSL_SESSION_free(VAR_4);
#ifndef VAR_7
if (!VAR_6) {
VAR_0->tlsext_ticket_expected = 1;
}
#endif
}
if (VAR_5)
return -1;
else
return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/ssl_sess.c/vul/before/0.json,"int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,
                         const unsigned char *limit)
{
    /* This is used only by servers. */

    SSL_SESSION *ret = NULL;
    int fatal = 0;
    int try_session_cache = 1;
#ifndef OPENSSL_NO_TLSEXT
    int r;
#endif

    if (limit - session_id < len) {
        fatal = 1;
        goto err;
    }

    if (len == 0)
        try_session_cache = 0;

#ifndef OPENSSL_NO_TLSEXT
    /* sets s->tlsext_ticket_expected */
    r = tls1_process_ticket(s, session_id, len, limit, &ret);
    switch (r) {
    case -1:                   /* Error during processing */
        fatal = 1;
        goto err;
    case 0:                    /* No ticket found */
    case 1:                    /* Zero length ticket found */
        break;                  /* Ok to carry on processing session id. */
    case 2:                    /* Ticket found but not decrypted. */
    case 3:                    /* Ticket decrypted, *ret has been set. */
        try_session_cache = 0;
        break;
    default:
        abort();
    }
#endif

    if (try_session_cache &&
        ret == NULL &&
        !(s->session_ctx->session_cache_mode &
          SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {
        SSL_SESSION data;
        data.ssl_version = s->version;
        data.session_id_length = len;
        if (len == 0)
            return 0;
        memcpy(data.session_id, session_id, len);
        CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
        ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);
        if (ret != NULL) {
            /* don't allow other threads to steal it: */
            CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);
        }
        CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
        if (ret == NULL)
            s->session_ctx->stats.sess_miss++;
    }

    if (try_session_cache &&
        ret == NULL && s->session_ctx->get_session_cb != NULL) {
        int copy = 1;

        if ((ret = s->session_ctx->get_session_cb(s, session_id, len, &copy))) {
            s->session_ctx->stats.sess_cb_hit++;

            /*
             * Increment reference count now if the session callback asks us
             * to do so (note that if the session structures returned by the
             * callback are shared between threads, it must handle the
             * reference count itself [i.e. copy == 0], or things won't be
             * thread-safe).
             */
            if (copy)
                CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);

            /*
             * Add the externally cached session to the internal cache as
             * well if and only if we are supposed to.
             */
            if (!
                (s->session_ctx->session_cache_mode &
                 SSL_SESS_CACHE_NO_INTERNAL_STORE))
                /*
                 * The following should not return 1, otherwise, things are
                 * very strange
                 */
                SSL_CTX_add_session(s->session_ctx, ret);
        }
    }

    if (ret == NULL)
        goto err;

    /* Now ret is non-NULL and we own one of its reference counts. */

    if (ret->sid_ctx_length != s->sid_ctx_length
        || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {
        /*
         * We have the session requested by the client, but we don't want to
         * use it in this context.
         */
        goto err;               /* treat like cache miss */
    }

    if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {
        /*
         * We can't be sure if this session is being used out of context,
         * which is especially important for SSL_VERIFY_PEER. The application
         * should have used SSL[_CTX]_set_session_id_context. For this error
         * case, we generate an error instead of treating the event like a
         * cache miss (otherwise it would be easy for applications to
         * effectively disable the session cache by accident without anyone
         * noticing).
         */

        SSLerr(SSL_F_SSL_GET_PREV_SESSION,
               SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
        fatal = 1;
        goto err;
    }

    if (ret->cipher == NULL) {
        unsigned char buf[5], *p;
        unsigned long l;

        p = buf;
        l = ret->cipher_id;
        l2n(l, p);
        if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)
            ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));
        else
            ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));
        if (ret->cipher == NULL)
            goto err;
    }

    if (ret->timeout < (long)(time(NULL) - ret->time)) { /* timeout */
        s->session_ctx->stats.sess_timeout++;
        if (try_session_cache) {
            /* session was from the cache, so remove it */
            SSL_CTX_remove_session(s->session_ctx, ret);
        }
        goto err;
    }

    s->session_ctx->stats.sess_hit++;

    if (s->session != NULL)
        SSL_SESSION_free(s->session);
    s->session = ret;
    s->verify_result = s->session->verify_result;
    return 1;

 err:
    if (ret != NULL) {
        SSL_SESSION_free(ret);
#ifndef OPENSSL_NO_TLSEXT
        if (!try_session_cache) {
            /*
             * The session was from a ticket, so we should issue a ticket for
             * the new session
             */
            s->tlsext_ticket_expected = 1;
        }
#endif
    }
    if (fatal)
        return -1;
    else
        return 0;
}","int ssl_get_prev_session(SSL *VAR_0, unsigned char *VAR_1, int VAR_2,
                         const unsigned char *VAR_3)
{
    /* COMMENT_0 */

    SSL_SESSION *VAR_4 = NULL;
    int VAR_5 = 0;
    int VAR_6 = 1;
#ifndef VAR_7
    int VAR_8;
#endif

    if (VAR_3 - VAR_1 < VAR_2) {
        VAR_5 = 1;
        goto err;
    }

    if (VAR_2 == 0)
        VAR_6 = 0;

#ifndef VAR_7
    /* COMMENT_1 */
    VAR_8 = tls1_process_ticket(VAR_0, VAR_1, VAR_2, VAR_3, &VAR_4);
    switch (VAR_8) {
    case -1:                   /* COMMENT_2 */
        VAR_5 = 1;
        goto err;
    case 0:                    /* COMMENT_3 */
    case 1:                    /* COMMENT_4 */
        break;                  /* COMMENT_5 */
    case 2:                    /* COMMENT_6 */
    case 3:                    /* COMMENT_7 */
        VAR_6 = 0;
        break;
    default:
        abort();
    }
#endif

    if (VAR_6 &&
        VAR_4 == NULL &&
        !(VAR_0->session_ctx->session_cache_mode &
          VAR_9)) {
        SSL_SESSION VAR_10;
        VAR_10.ssl_version = VAR_0->version;
        VAR_10.session_id_length = VAR_2;
        if (VAR_2 == 0)
            return 0;
        memcpy(VAR_10.session_id, VAR_1, VAR_2);
        CRYPTO_r_lock(VAR_11);
        VAR_4 = lh_SSL_SESSION_retrieve(VAR_0->session_ctx->sessions, &VAR_10);
        if (VAR_4 != NULL) {
            /* COMMENT_8 */
            CRYPTO_add(&VAR_4->references, 1, VAR_12);
        }
        CRYPTO_r_unlock(VAR_11);
        if (VAR_4 == NULL)
            VAR_0->session_ctx->stats.sess_miss++;
    }

    if (VAR_6 &&
        VAR_4 == NULL && VAR_0->session_ctx->get_session_cb != NULL) {
        int VAR_13 = 1;

        if ((VAR_4 = VAR_0->session_ctx->get_session_cb(VAR_0, VAR_1, VAR_2, &VAR_13))) {
            VAR_0->session_ctx->stats.sess_cb_hit++;

            /* COMMENT_9 */
                                                                            
                                                                            
                                                                      
                                                                          
                            
               
            if (VAR_13)
                CRYPTO_add(&VAR_4->references, 1, VAR_12);

            /* COMMENT_16 */
                                                                         
                                                      
               
            if (!
                (VAR_0->session_ctx->session_cache_mode &
                 VAR_14))
                /* COMMENT_20 */
                                                                           
                               
                   
                SSL_CTX_add_session(VAR_0->session_ctx, VAR_4);
        }
    }

    if (VAR_4 == NULL)
        goto err;

    /* COMMENT_24 */

    if (VAR_4->sid_ctx_length != VAR_0->sid_ctx_length
        || memcmp(VAR_4->sid_ctx, VAR_0->sid_ctx, VAR_4->sid_ctx_length)) {
        /* COMMENT_25 */
                                                                            
                                  
           
        goto err;               /* COMMENT_29 */
    }

    if ((VAR_0->verify_mode & VAR_15) && VAR_0->sid_ctx_length == 0) {
        /* COMMENT_30 */
                                                                         
                                                                             
                                                                            
                                                                          
                                                                     
                                                                           
                     
           

        SSLerr(VAR_16,
               VAR_17);
        VAR_5 = 1;
        goto err;
    }

    if (VAR_4->cipher == NULL) {
        unsigned char VAR_18[5], *VAR_19;
        unsigned long VAR_20;

        VAR_19 = VAR_18;
        VAR_20 = VAR_4->cipher_id;
        l2n(VAR_20, VAR_19);
        if ((VAR_4->ssl_version >> 8) >= VAR_21)
            VAR_4->cipher = ssl_get_cipher_by_char(VAR_0, &(VAR_18[2]));
        else
            VAR_4->cipher = ssl_get_cipher_by_char(VAR_0, &(VAR_18[1]));
        if (VAR_4->cipher == NULL)
            goto err;
    }

    if (VAR_4->timeout < (long)(time(NULL) - VAR_4->time)) { /* COMMENT_39 */
        VAR_0->session_ctx->stats.sess_timeout++;
        if (VAR_6) {
            /* COMMENT_40 */
            SSL_CTX_remove_session(VAR_0->session_ctx, VAR_4);
        }
        goto err;
    }

    VAR_0->session_ctx->stats.sess_hit++;

    if (VAR_0->session != NULL)
        SSL_SESSION_free(VAR_0->session);
    VAR_0->session = VAR_4;
    VAR_0->verify_result = VAR_0->session->verify_result;
    return 1;

 err:
    if (VAR_4 != NULL) {
        SSL_SESSION_free(VAR_4);
#ifndef VAR_7
        if (!VAR_6) {
            /* COMMENT_41 */
                                                                             
                              
               
            VAR_0->tlsext_ticket_expected = 1;
        }
#endif
    }
    if (VAR_5)
        return -1;
    else
        return 0;
}",openssl/a004e72b95835136d3f1ea90517f706c24c03da7/ssl_sess.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
     int r;
 #endif
 
-    if (session_id + len > limit) {
+    if (limit - session_id < len) {
         fatal = 1;
         goto err;
     }","{'deleted_lines': ['    if (session_id + len > limit) {'], 'added_lines': ['    if (limit - session_id < len) {']}",True,"OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",9.8,CRITICAL,3,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/retr.c,retrieve_url,"uerr_t
retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
char **newloc, const char *refurl, int *dt, bool recursive,
struct iri *iri, bool register_status)
{
uerr_t result;
char *url;
bool location_changed;
bool iri_fallbacked = 0;
int dummy;
char *mynewloc, *proxy;
struct url *u = orig_parsed, *proxy_url;
int up_error_code;            
char *local_file = NULL;
int redirection_count = 0;
bool method_suspended = false;
char *saved_body_data = NULL;
char *saved_method = NULL;
char *saved_body_file_name = NULL;
if (!dt)
{
dt = &dummy;
dummy = 0;
}
url = xstrdup (origurl);
if (newloc)
*newloc = NULL;
if (file)
*file = NULL;
if (!refurl)
refurl = opt.referer;
redirected:
result = NOCONERROR;
mynewloc = NULL;
xfree(local_file);
proxy_url = NULL;
proxy = getproxy (u);
if (proxy)
{
struct iri *pi = iri_new ();
set_uri_encoding (pi, opt.locale, true);
pi->utf8_encode = false;
proxy_url = url_parse (proxy, &up_error_code, pi, true);
if (!proxy_url)
{
char *error = url_error (proxy, up_error_code);
logprintf (LOG_NOTQUIET, _(""Error parsing proxy URL %s: %s.\n""),
proxy, error);
xfree (url);
xfree (error);
xfree (proxy);
iri_free (pi);
RESTORE_METHOD;
result = PROXERR;
goto bail;
}
if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)
{
logprintf (LOG_NOTQUIET, _(""Error in proxy URL %s: Must be HTTP.\n""), proxy);
url_free (proxy_url);
xfree (url);
xfree (proxy);
iri_free (pi);
RESTORE_METHOD;
result = PROXERR;
goto bail;
}
iri_free(pi);
xfree (proxy);
}
if (u->scheme == SCHEME_HTTP
#ifdef HAVE_SSL
|| u->scheme == SCHEME_HTTPS
#endif
|| (proxy_url && proxy_url->scheme == SCHEME_HTTP))
{
#ifdef HAVE_HSTS
#ifdef TESTING
hsts_store_t hsts_store = NULL;
#else
extern hsts_store_t hsts_store;
#endif
if (opt.hsts && hsts_store)
{
if (hsts_match (hsts_store, u))
logprintf (LOG_VERBOSE, ""URL transformed to HTTPS due to an HSTS policy\n"");
}
#endif
result = http_loop (u, orig_parsed, &mynewloc, &local_file, refurl, dt,
proxy_url, iri);
}
else if (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
|| u->scheme == SCHEME_FTPS
#endif
)
{
bool oldrec = recursive, glob = opt.ftp_glob;
if (redirection_count)
oldrec = glob = false;
result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
recursive = oldrec;
if (redirection_count && local_file && (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
|| u->scheme == SCHEME_FTPS
#endif
))
{
if (has_html_suffix_p (local_file))
*dt |= TEXTHTML;
}
}
if (proxy_url)
{
url_free (proxy_url);
proxy_url = NULL;
}
location_changed = (result == NEWLOCATION || result == NEWLOCATION_KEEP_POST);
if (location_changed)
{
char *construced_newloc;
struct url *newloc_parsed;
assert (mynewloc != NULL);
xfree (local_file);
construced_newloc = uri_merge (url, mynewloc);
xfree (mynewloc);
mynewloc = construced_newloc;
#ifdef ENABLE_IRI
iri->utf8_encode = opt.enable_iri;
if (opt.encoding_remote)
set_uri_encoding (iri, opt.encoding_remote, true);
set_content_encoding (iri, NULL);
xfree (iri->orig_url);
#endif
newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);
if (!newloc_parsed)
{
char *error = url_error (mynewloc, up_error_code);
logprintf (LOG_NOTQUIET, ""%s: %s.\n"", escnonprint_uri (mynewloc),
error);
if (orig_parsed != u)
{
url_free (u);
}
xfree (url);
xfree (mynewloc);
xfree (error);
RESTORE_METHOD;
goto bail;
}
xfree (mynewloc);
mynewloc = xstrdup (newloc_parsed->url);
if (++redirection_count > opt.max_redirect)
{
logprintf (LOG_NOTQUIET, _(""%d redirections exceeded.\n""),
opt.max_redirect);
url_free (newloc_parsed);
if (orig_parsed != u)
{
url_free (u);
}
xfree (url);
xfree (mynewloc);
RESTORE_METHOD;
result = WRONGCODE;
goto bail;
}
xfree (url);
url = mynewloc;
if (orig_parsed != u)
{
url_free (u);
}
u = newloc_parsed;
if (result != NEWLOCATION_KEEP_POST && !method_suspended)
SUSPEND_METHOD;
goto redirected;
}
else
{
xfree(mynewloc);
}
if (!(*dt & RETROKF) && iri->utf8_encode)
{
iri->utf8_encode = false;
if (orig_parsed != u)
{
url_free (u);
}
u = url_parse (origurl, NULL, iri, true);
if (u)
{
DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
xfree (url);
url = xstrdup (u->url);
iri_fallbacked = 1;
goto redirected;
}
else
DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
}
if (local_file && u && (*dt & RETROKF || opt.content_on_error))
{
register_download (u->url, local_file);
if (!opt.spider && redirection_count && 0 != strcmp (origurl, u->url))
register_redirection (origurl, u->url);
if (*dt & TEXTHTML)
register_html (local_file);
if (*dt & TEXTCSS)
register_css (local_file);
}
if (file)
*file = local_file ? local_file : NULL;
else
xfree (local_file);
if (orig_parsed != u)
{
url_free (u);
}
if (redirection_count || iri_fallbacked)
{
if (newloc)
*newloc = url;
else
xfree (url);
}
else
{
if (newloc)
*newloc = NULL;
xfree (url);
}
RESTORE_METHOD;
bail:
if (register_status)
inform_exit_status (result);
return result;
}","uerr_t
retrieve_url (struct url * VAR_0, const char *VAR_1, char **VAR_2,
char **VAR_3, const char *VAR_4, int *VAR_5, bool VAR_6,
struct iri *iri, bool VAR_7)
{
uerr_t VAR_8;
char *url;
bool VAR_9;
bool VAR_10 = 0;
int VAR_11;
char *VAR_12, *VAR_13;
struct url *VAR_14 = VAR_0, *VAR_15;
int VAR_16;            
char *VAR_17 = NULL;
int VAR_18 = 0;
bool VAR_19 = false;
char *VAR_20 = NULL;
char *VAR_21 = NULL;
char *VAR_22 = NULL;
if (!VAR_5)
{
VAR_5 = &VAR_11;
VAR_11 = 0;
}
url = xstrdup (VAR_1);
if (VAR_3)
*VAR_3 = NULL;
if (VAR_2)
*VAR_2 = NULL;
if (!VAR_4)
VAR_4 = VAR_23.referer;
redirected:
VAR_8 = VAR_24;
VAR_12 = NULL;
xfree(VAR_17);
VAR_15 = NULL;
VAR_13 = getproxy (VAR_14);
if (VAR_13)
{
struct iri *VAR_25 = iri_new ();
set_uri_encoding (VAR_25, VAR_23.locale, true);
VAR_25->utf8_encode = false;
VAR_15 = url_parse (VAR_13, &VAR_16, VAR_25, true);
if (!VAR_15)
{
char *VAR_26 = url_error (VAR_13, VAR_16);
logprintf (VAR_27, _(""Error parsing proxy URL %s: %s.\n""),
VAR_13, VAR_26);
xfree (url);
xfree (VAR_26);
xfree (VAR_13);
iri_free (VAR_25);
VAR_28;
VAR_8 = VAR_29;
goto bail;
}
if (VAR_15->scheme != VAR_30 && VAR_15->scheme != VAR_14->scheme)
{
logprintf (VAR_27, _(""Error in proxy URL %s: Must be HTTP.\n""), VAR_13);
url_free (VAR_15);
xfree (url);
xfree (VAR_13);
iri_free (VAR_25);
VAR_28;
VAR_8 = VAR_29;
goto bail;
}
iri_free(VAR_25);
xfree (VAR_13);
}
if (VAR_14->scheme == VAR_30
#ifdef VAR_31
|| VAR_14->scheme == VAR_32
#endif
|| (VAR_15 && VAR_15->scheme == VAR_30))
{
#ifdef VAR_33
#ifdef VAR_34
hsts_store_t VAR_35 = NULL;
#else
extern hsts_store_t VAR_35;
#endif
if (VAR_23.hsts && VAR_35)
{
if (hsts_match (VAR_35, VAR_14))
logprintf (VAR_36, ""URL transformed to HTTPS due to an HSTS policy\n"");
}
#endif
VAR_8 = http_loop (VAR_14, VAR_0, &VAR_12, &VAR_17, VAR_4, VAR_5,
VAR_15, iri);
}
else if (VAR_14->scheme == VAR_37
#ifdef VAR_31
|| VAR_14->scheme == VAR_38
#endif
)
{
bool VAR_39 = VAR_6, VAR_40 = VAR_23.ftp_glob;
if (VAR_18)
VAR_39 = VAR_40 = false;
VAR_8 = ftp_loop (VAR_14, &VAR_17, VAR_5, VAR_15, VAR_6, VAR_40);
VAR_6 = VAR_39;
if (VAR_18 && VAR_17 && (VAR_14->scheme == VAR_37
#ifdef VAR_31
|| VAR_14->scheme == VAR_38
#endif
))
{
if (has_html_suffix_p (VAR_17))
*VAR_5 |= VAR_41;
}
}
if (VAR_15)
{
url_free (VAR_15);
VAR_15 = NULL;
}
VAR_9 = (VAR_8 == VAR_42 || VAR_8 == VAR_43);
if (VAR_9)
{
char *VAR_44;
struct url *VAR_45;
assert (VAR_12 != NULL);
xfree (VAR_17);
VAR_44 = uri_merge (url, VAR_12);
xfree (VAR_12);
VAR_12 = VAR_44;
#ifdef VAR_46
iri->utf8_encode = VAR_23.enable_iri;
if (VAR_23.encoding_remote)
set_uri_encoding (iri, VAR_23.encoding_remote, true);
set_content_encoding (iri, NULL);
xfree (iri->orig_url);
#endif
VAR_45 = url_parse (VAR_12, &VAR_16, iri, true);
if (!VAR_45)
{
char *VAR_26 = url_error (VAR_12, VAR_16);
logprintf (VAR_27, ""%s: %s.\n"", escnonprint_uri (VAR_12),
VAR_26);
if (VAR_0 != VAR_14)
{
url_free (VAR_14);
}
xfree (url);
xfree (VAR_12);
xfree (VAR_26);
VAR_28;
goto bail;
}
xfree (VAR_12);
VAR_12 = xstrdup (VAR_45->url);
if (++VAR_18 > VAR_23.max_redirect)
{
logprintf (VAR_27, _(""%d redirections exceeded.\n""),
VAR_23.max_redirect);
url_free (VAR_45);
if (VAR_0 != VAR_14)
{
url_free (VAR_14);
}
xfree (url);
xfree (VAR_12);
VAR_28;
VAR_8 = VAR_47;
goto bail;
}
xfree (url);
url = VAR_12;
if (VAR_0 != VAR_14)
{
url_free (VAR_14);
}
VAR_14 = VAR_45;
if (VAR_8 != VAR_43 && !VAR_19)
VAR_48;
goto redirected;
}
else
{
xfree(VAR_12);
}
if (!(*VAR_5 & VAR_49) && iri->utf8_encode)
{
iri->utf8_encode = false;
if (VAR_0 != VAR_14)
{
url_free (VAR_14);
}
VAR_14 = url_parse (VAR_1, NULL, iri, true);
if (VAR_14)
{
DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
xfree (url);
url = xstrdup (VAR_14->url);
VAR_10 = 1;
goto redirected;
}
else
DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
}
if (VAR_17 && VAR_14 && (*VAR_5 & VAR_49 || VAR_23.content_on_error))
{
register_download (VAR_14->url, VAR_17);
if (!VAR_23.spider && VAR_18 && 0 != strcmp (VAR_1, VAR_14->url))
register_redirection (VAR_1, VAR_14->url);
if (*VAR_5 & VAR_41)
register_html (VAR_17);
if (*VAR_5 & VAR_50)
register_css (VAR_17);
}
if (VAR_2)
*VAR_2 = VAR_17 ? VAR_17 : NULL;
else
xfree (VAR_17);
if (VAR_0 != VAR_14)
{
url_free (VAR_14);
}
if (VAR_18 || VAR_10)
{
if (VAR_3)
*VAR_3 = url;
else
xfree (url);
}
else
{
if (VAR_3)
*VAR_3 = NULL;
xfree (url);
}
VAR_28;
bail:
if (VAR_7)
inform_exit_status (VAR_8);
return VAR_8;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/retr.c/vul/before/0.json,"uerr_t
retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
              char **newloc, const char *refurl, int *dt, bool recursive,
              struct iri *iri, bool register_status)
{
  uerr_t result;
  char *url;
  bool location_changed;
  bool iri_fallbacked = 0;
  int dummy;
  char *mynewloc, *proxy;
  struct url *u = orig_parsed, *proxy_url;
  int up_error_code;            /* url parse error code */
  char *local_file = NULL;
  int redirection_count = 0;

  bool method_suspended = false;
  char *saved_body_data = NULL;
  char *saved_method = NULL;
  char *saved_body_file_name = NULL;

  /* If dt is NULL, use local storage.  */
  if (!dt)
    {
      dt = &dummy;
      dummy = 0;
    }
  url = xstrdup (origurl);
  if (newloc)
    *newloc = NULL;
  if (file)
    *file = NULL;

  if (!refurl)
    refurl = opt.referer;

 redirected:
  /* (also for IRI fallbacking) */

  result = NOCONERROR;
  mynewloc = NULL;
  xfree(local_file);
  proxy_url = NULL;

  proxy = getproxy (u);
  if (proxy)
    {
      struct iri *pi = iri_new ();
      set_uri_encoding (pi, opt.locale, true);
      pi->utf8_encode = false;

      /* Parse the proxy URL.  */
      proxy_url = url_parse (proxy, &up_error_code, pi, true);
      if (!proxy_url)
        {
          char *error = url_error (proxy, up_error_code);
          logprintf (LOG_NOTQUIET, _(""Error parsing proxy URL %s: %s.\n""),
                     proxy, error);
          xfree (url);
          xfree (error);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)
        {
          logprintf (LOG_NOTQUIET, _(""Error in proxy URL %s: Must be HTTP.\n""), proxy);
          url_free (proxy_url);
          xfree (url);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      iri_free(pi);
      xfree (proxy);
    }

  if (u->scheme == SCHEME_HTTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_HTTPS
#endif
      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))
    {
#ifdef HAVE_HSTS
#ifdef TESTING
      /* we don't link against main.o when we're testing */
      hsts_store_t hsts_store = NULL;
#else
      extern hsts_store_t hsts_store;
#endif

      if (opt.hsts && hsts_store)
	{
	  if (hsts_match (hsts_store, u))
	    logprintf (LOG_VERBOSE, ""URL transformed to HTTPS due to an HSTS policy\n"");
	}
#endif
      result = http_loop (u, orig_parsed, &mynewloc, &local_file, refurl, dt,
                          proxy_url, iri);
    }
  else if (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_FTPS
#endif
      )
    {
      /* If this is a redirection, temporarily turn off opt.ftp_glob
         and opt.recursive, both being undesirable when following
         redirects.  */
      bool oldrec = recursive, glob = opt.ftp_glob;
      if (redirection_count)
        oldrec = glob = false;

      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
                         recursive, glob);
      recursive = oldrec;

      /* There is a possibility of having HTTP being redirected to
         FTP.  In these cases we must decide whether the text is HTML
         according to the suffix.  The HTML suffixes are `.html',
         `.htm' and a few others, case-insensitive.  */
      if (redirection_count && local_file && (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
          || u->scheme == SCHEME_FTPS
#endif
          ))
        {
          if (has_html_suffix_p (local_file))
            *dt |= TEXTHTML;
        }
    }

  if (proxy_url)
    {
      url_free (proxy_url);
      proxy_url = NULL;
    }

  location_changed = (result == NEWLOCATION || result == NEWLOCATION_KEEP_POST);
  if (location_changed)
    {
      char *construced_newloc;
      struct url *newloc_parsed;

      assert (mynewloc != NULL);

      xfree (local_file);

      /* The HTTP specs only allow absolute URLs to appear in
         redirects, but a ton of boneheaded webservers and CGIs out
         there break the rules and use relative URLs, and popular
         browsers are lenient about this, so wget should be too. */
      construced_newloc = uri_merge (url, mynewloc);
      xfree (mynewloc);
      mynewloc = construced_newloc;

#ifdef ENABLE_IRI
      /* Reset UTF-8 encoding state, set the URI encoding and reset
         the content encoding. */
      iri->utf8_encode = opt.enable_iri;
      if (opt.encoding_remote)
       set_uri_encoding (iri, opt.encoding_remote, true);
      set_content_encoding (iri, NULL);
      xfree (iri->orig_url);
#endif

      /* Now, see if this new location makes sense. */
      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);
      if (!newloc_parsed)
        {
          char *error = url_error (mynewloc, up_error_code);
          logprintf (LOG_NOTQUIET, ""%s: %s.\n"", escnonprint_uri (mynewloc),
                     error);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          xfree (error);
          RESTORE_METHOD;
          goto bail;
        }

      /* Now mynewloc will become newloc_parsed->url, because if the
         Location contained relative paths like .././something, we
         don't want that propagating as url.  */
      xfree (mynewloc);
      mynewloc = xstrdup (newloc_parsed->url);

      /* Check for max. number of redirections.  */
      if (++redirection_count > opt.max_redirect)
        {
          logprintf (LOG_NOTQUIET, _(""%d redirections exceeded.\n""),
                     opt.max_redirect);
          url_free (newloc_parsed);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          RESTORE_METHOD;
          result = WRONGCODE;
          goto bail;
        }

      xfree (url);
      url = mynewloc;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = newloc_parsed;

      /* If we're being redirected from POST, and we received a
         redirect code different than 307, we don't want to POST
         again.  Many requests answer POST with a redirection to an
         index page; that redirection is clearly a GET.  We ""suspend""
         POST data for the duration of the redirections, and restore
         it when we're done.

         RFC2616 HTTP/1.1 introduces code 307 Temporary Redirect
         specifically to preserve the method of the request.
     */
      if (result != NEWLOCATION_KEEP_POST && !method_suspended)
        SUSPEND_METHOD;

      goto redirected;
    }
  else
    {
      xfree(mynewloc);
    }

  /* Try to not encode in UTF-8 if fetching failed */
  if (!(*dt & RETROKF) && iri->utf8_encode)
    {
      iri->utf8_encode = false;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = url_parse (origurl, NULL, iri, true);
      if (u)
        {
          DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
          xfree (url);
          url = xstrdup (u->url);
          iri_fallbacked = 1;
          goto redirected;
        }
      else
          DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
    }

  if (local_file && u && (*dt & RETROKF || opt.content_on_error))
    {
      register_download (u->url, local_file);

      if (!opt.spider && redirection_count && 0 != strcmp (origurl, u->url))
        register_redirection (origurl, u->url);

      if (*dt & TEXTHTML)
        register_html (local_file);

      if (*dt & TEXTCSS)
        register_css (local_file);
    }

  if (file)
    *file = local_file ? local_file : NULL;
  else
    xfree (local_file);

  if (orig_parsed != u)
    {
      url_free (u);
    }

  if (redirection_count || iri_fallbacked)
    {
      if (newloc)
        *newloc = url;
      else
        xfree (url);
    }
  else
    {
      if (newloc)
        *newloc = NULL;
      xfree (url);
    }

  RESTORE_METHOD;

bail:
  if (register_status)
    inform_exit_status (result);

  return result;
}","uerr_t
retrieve_url (struct url * VAR_0, const char *VAR_1, char **VAR_2,
              char **VAR_3, const char *VAR_4, int *VAR_5, bool VAR_6,
              struct iri *iri, bool VAR_7)
{
  uerr_t VAR_8;
  char *url;
  bool VAR_9;
  bool VAR_10 = 0;
  int VAR_11;
  char *VAR_12, *VAR_13;
  struct url *VAR_14 = VAR_0, *VAR_15;
  int VAR_16;            /* COMMENT_0 */
  char *VAR_17 = NULL;
  int VAR_18 = 0;

  bool VAR_19 = false;
  char *VAR_20 = NULL;
  char *VAR_21 = NULL;
  char *VAR_22 = NULL;

  /* COMMENT_1 */
  if (!VAR_5)
    {
      VAR_5 = &VAR_11;
      VAR_11 = 0;
    }
  url = xstrdup (VAR_1);
  if (VAR_3)
    *VAR_3 = NULL;
  if (VAR_2)
    *VAR_2 = NULL;

  if (!VAR_4)
    VAR_4 = VAR_23.referer;

 redirected:
  /* COMMENT_2 */

  VAR_8 = VAR_24;
  VAR_12 = NULL;
  xfree(VAR_17);
  VAR_15 = NULL;

  VAR_13 = getproxy (VAR_14);
  if (VAR_13)
    {
      struct iri *VAR_25 = iri_new ();
      set_uri_encoding (VAR_25, VAR_23.locale, true);
      VAR_25->utf8_encode = false;

      /* COMMENT_3 */
      VAR_15 = url_parse (VAR_13, &VAR_16, VAR_25, true);
      if (!VAR_15)
        {
          char *VAR_26 = url_error (VAR_13, VAR_16);
          logprintf (VAR_27, _(""Error parsing proxy URL %s: %s.\n""),
                     VAR_13, VAR_26);
          xfree (url);
          xfree (VAR_26);
          xfree (VAR_13);
          iri_free (VAR_25);
          VAR_28;
          VAR_8 = VAR_29;
          goto bail;
        }
      if (VAR_15->scheme != VAR_30 && VAR_15->scheme != VAR_14->scheme)
        {
          logprintf (VAR_27, _(""Error in proxy URL %s: Must be HTTP.\n""), VAR_13);
          url_free (VAR_15);
          xfree (url);
          xfree (VAR_13);
          iri_free (VAR_25);
          VAR_28;
          VAR_8 = VAR_29;
          goto bail;
        }
      iri_free(VAR_25);
      xfree (VAR_13);
    }

  if (VAR_14->scheme == VAR_30
#ifdef VAR_31
      || VAR_14->scheme == VAR_32
#endif
      || (VAR_15 && VAR_15->scheme == VAR_30))
    {
#ifdef VAR_33
#ifdef VAR_34
      /* COMMENT_4 */
      hsts_store_t VAR_35 = NULL;
#else
      extern hsts_store_t VAR_35;
#endif

      if (VAR_23.hsts && VAR_35)
	{
	  if (hsts_match (VAR_35, VAR_14))
	    logprintf (VAR_36, ""URL transformed to HTTPS due to an HSTS policy\n"");
	}
#endif
      VAR_8 = http_loop (VAR_14, VAR_0, &VAR_12, &VAR_17, VAR_4, VAR_5,
                          VAR_15, iri);
    }
  else if (VAR_14->scheme == VAR_37
#ifdef VAR_31
      || VAR_14->scheme == VAR_38
#endif
      )
    {
      /* COMMENT_5 */
                                                                 
                       
      bool VAR_39 = VAR_6, VAR_40 = VAR_23.ftp_glob;
      if (VAR_18)
        VAR_39 = VAR_40 = false;

      VAR_8 = ftp_loop (VAR_14, VAR_0, &VAR_17, VAR_5, VAR_15,
                         VAR_6, VAR_40);
      VAR_6 = VAR_39;

      /* COMMENT_8 */
                                                                     
                                                                 
                                                       
      if (VAR_18 && VAR_17 && (VAR_14->scheme == VAR_37
#ifdef VAR_31
          || VAR_14->scheme == VAR_38
#endif
          ))
        {
          if (has_html_suffix_p (VAR_17))
            *VAR_5 |= VAR_41;
        }
    }

  if (VAR_15)
    {
      url_free (VAR_15);
      VAR_15 = NULL;
    }

  VAR_9 = (VAR_8 == VAR_42 || VAR_8 == VAR_43);
  if (VAR_9)
    {
      char *VAR_44;
      struct url *VAR_45;

      assert (VAR_12 != NULL);

      xfree (VAR_17);

      /* COMMENT_12 */
                                                                   
                                                                 
                                                                   
      VAR_44 = uri_merge (url, VAR_12);
      xfree (VAR_12);
      VAR_12 = VAR_44;

#ifdef VAR_46
      /* COMMENT_16 */
                                 
      iri->utf8_encode = VAR_23.enable_iri;
      if (VAR_23.encoding_remote)
       set_uri_encoding (iri, VAR_23.encoding_remote, true);
      set_content_encoding (iri, NULL);
      xfree (iri->orig_url);
#endif

      /* COMMENT_18 */
      VAR_45 = url_parse (VAR_12, &VAR_16, iri, true);
      if (!VAR_45)
        {
          char *VAR_26 = url_error (VAR_12, VAR_16);
          logprintf (VAR_27, ""%s: %s.\n"", escnonprint_uri (VAR_12),
                     VAR_26);
          if (VAR_0 != VAR_14)
            {
              url_free (VAR_14);
            }
          xfree (url);
          xfree (VAR_12);
          xfree (VAR_26);
          VAR_28;
          goto bail;
        }

      /* COMMENT_19 */
                                                                  
                                                
      xfree (VAR_12);
      VAR_12 = xstrdup (VAR_45->url);

      /* COMMENT_22 */
      if (++VAR_18 > VAR_23.max_redirect)
        {
          logprintf (VAR_27, _(""%d redirections exceeded.\n""),
                     VAR_23.max_redirect);
          url_free (VAR_45);
          if (VAR_0 != VAR_14)
            {
              url_free (VAR_14);
            }
          xfree (url);
          xfree (VAR_12);
          VAR_28;
          VAR_8 = VAR_47;
          goto bail;
        }

      xfree (url);
      url = VAR_12;
      if (VAR_0 != VAR_14)
        {
          url_free (VAR_14);
        }
      VAR_14 = VAR_45;

      /* COMMENT_23 */
                                                                
                                                                   
                                                                     
                                                                    
                            

                                                                
                                                            
       
      if (VAR_8 != VAR_43 && !VAR_19)
        VAR_48;

      goto redirected;
    }
  else
    {
      xfree(VAR_12);
    }

  /* COMMENT_33 */
  if (!(*VAR_5 & VAR_49) && iri->utf8_encode)
    {
      iri->utf8_encode = false;
      if (VAR_0 != VAR_14)
        {
          url_free (VAR_14);
        }
      VAR_14 = url_parse (VAR_1, NULL, iri, true);
      if (VAR_14)
        {
          DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
          xfree (url);
          url = xstrdup (VAR_14->url);
          VAR_10 = 1;
          goto redirected;
        }
      else
          DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
    }

  if (VAR_17 && VAR_14 && (*VAR_5 & VAR_49 || VAR_23.content_on_error))
    {
      register_download (VAR_14->url, VAR_17);

      if (!VAR_23.spider && VAR_18 && 0 != strcmp (VAR_1, VAR_14->url))
        register_redirection (VAR_1, VAR_14->url);

      if (*VAR_5 & VAR_41)
        register_html (VAR_17);

      if (*VAR_5 & VAR_50)
        register_css (VAR_17);
    }

  if (VAR_2)
    *VAR_2 = VAR_17 ? VAR_17 : NULL;
  else
    xfree (VAR_17);

  if (VAR_0 != VAR_14)
    {
      url_free (VAR_14);
    }

  if (VAR_18 || VAR_10)
    {
      if (VAR_3)
        *VAR_3 = url;
      else
        xfree (url);
    }
  else
    {
      if (VAR_3)
        *VAR_3 = NULL;
      xfree (url);
    }

  VAR_28;

bail:
  if (VAR_7)
    inform_exit_status (VAR_8);

  return VAR_8;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/retr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -115,7 +115,8 @@
       if (redirection_count)
         oldrec = glob = false;
 
-      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
+      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
+                         recursive, glob);
       recursive = oldrec;
 
       /* There is a possibility of having HTTP being redirected to","{'deleted_lines': ['      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);'], 'added_lines': ['      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,', '                         recursive, glob);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_loop_internal,"static uerr_t
ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
bool force_full_retrieve)
{
int count, orig_lp;
wgint restval, len = 0, qtyread = 0;
char *tms, *locf;
const char *tmrate = NULL;
uerr_t err;
struct_stat st;
bool warc_enabled = (opt.warc_filename != NULL);
FILE *warc_tmp = NULL;
ip_address *warc_ip = NULL;
wgint last_expected_bytes = 0;
if ((f == NULL) && (con->target))
{
locf = con->target;
}
else
{
xfree (con->target);
con->target = url_file_name (u, NULL);
if (!opt.output_document)
locf = con->target;
else
locf = opt.output_document;
}
if (opt.noclobber && !opt.output_document && file_exists_p (con->target)
&& !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))
{
logprintf (LOG_VERBOSE,
_(""File %s already there; not retrieving.\n""), quote (con->target));
return RETROK;
}
remove_link (con->target);
count = 0;
if (con->st & ON_YOUR_OWN)
con->st = ON_YOUR_OWN;
orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;
do
{
++count;
sleep_between_retrievals (count);
if (con->st & ON_YOUR_OWN)
{
con->cmd = 0;
con->cmd |= (DO_RETR | LEAVE_PENDING);
if (con->csock != -1)
con->cmd &= ~ (DO_LOGIN | DO_CWD);
else
con->cmd |= (DO_LOGIN | DO_CWD);
}
else 
{
if (con->csock != -1)
con->cmd &= ~DO_LOGIN;
else
con->cmd |= DO_LOGIN;
if (con->st & DONE_CWD)
con->cmd &= ~DO_CWD;
else
con->cmd |= DO_CWD;
}
if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)
{
warc_tmp = warc_tempfile ();
if (warc_tmp == NULL)
return WARC_TMP_FOPENERR;
if (!con->proxy && con->csock != -1)
{
warc_ip = (ip_address *) alloca (sizeof (ip_address));
socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);
}
}
if (con->cmd & DO_LIST)
restval = 0;
else if (force_full_retrieve)
restval = 0;
else if (opt.start_pos >= 0)
restval = opt.start_pos;
else if (opt.always_rest
&& stat (locf, &st) == 0
&& S_ISREG (st.st_mode))
restval = st.st_size;
else if (count > 1)
restval = qtyread;          
else
restval = 0;
tms = datetime_str (time (NULL));
if (opt.verbose)
{
char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
char tmp[256];
strcpy (tmp, ""        "");
if (count > 1)
sprintf (tmp, _(""(try:%2d)""), count);
logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"",
tms, hurl, tmp, quote (locf));
#ifdef WINDOWS
ws_changetitle (hurl);
#endif
xfree (hurl);
}
if (f && f->type != FT_SYMLINK)
len = f->size;
else
len = 0;
err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
warc_tmp);
if (con->csock == -1)
con->st &= ~DONE_CWD;
else
con->st |= DONE_CWD;
switch (err)
{
case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:
case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:
case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:
#ifdef HAVE_SSL
if (err == FTPNOAUTH)
logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n"");
if (opt.ftps_implicit)
logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n"");
#endif
if (warc_tmp != NULL)
fclose (warc_tmp);
return err;
case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:
case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:
case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:
case FOPEN_EXCL_ERR:
printwhat (count, opt.ntry);
if (err == FOPEN_EXCL_ERR)
{
xfree (con->target);
con->target = url_file_name (u, NULL);
locf = con->target;
}
continue;
case FTPRETRINT:
if (!f || qtyread != f->size)
{
printwhat (count, opt.ntry);
continue;
}
break;
case RETRFINISHED:
break;
default:
abort ();
}
tms = datetime_str (time (NULL));
if (!opt.spider)
tmrate = retr_rate (qtyread - restval, con->dltime);
downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);
if (con->st & ON_YOUR_OWN)
{
fd_close (con->csock);
con->csock = -1;
}
if (!opt.spider)
{
bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));
logprintf (LOG_VERBOSE,
write_to_stdout
? _(""%s (%s) - written to stdout %s[%s]\n\n"")
: _(""%s (%s) - %s saved [%s]\n\n""),
tms, tmrate,
write_to_stdout ? """" : quote (locf),
number_to_static_string (qtyread));
}
if (!opt.verbose && !opt.quiet)
{
char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
tms, hurl, number_to_static_string (qtyread), locf, count);
xfree (hurl);
}
if (warc_enabled && (con->cmd & DO_RETR))
{
bool warc_res;
warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,
warc_ip, NULL, warc_tmp, -1);
if (! warc_res)
return WARC_ERR;
warc_tmp = NULL;
}
if (con->cmd & DO_LIST)
{
if (!opt.remove_listing)
{
total_downloaded_bytes += qtyread;
numurls++;
}
}
else if (!opt.spider)
{
total_downloaded_bytes += qtyread;
numurls++;
if (opt.delete_after && !input_file_url (opt.input_filename))
{
DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf);
if (unlink (locf))
logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
}
}
if (orig_lp)
con->cmd |= LEAVE_PENDING;
else
con->cmd &= ~LEAVE_PENDING;
if (local_file)
*local_file = xstrdup (locf);
if (warc_tmp != NULL)
fclose (warc_tmp);
return RETROK;
} while (!opt.ntry || (count < opt.ntry));
if (con->csock != -1 && (con->st & ON_YOUR_OWN))
{
fd_close (con->csock);
con->csock = -1;
}
if (warc_tmp != NULL)
fclose (warc_tmp);
return TRYLIMEXC;
}","static uerr_t
ftp_loop_internal (struct url *VAR_0, struct fileinfo *VAR_1, ccon *VAR_2, char **VAR_3,
bool VAR_4)
{
int VAR_5, VAR_6;
wgint VAR_7, VAR_8 = 0, VAR_9 = 0;
char *VAR_10, *VAR_11;
const char *VAR_12 = NULL;
uerr_t VAR_13;
struct_stat VAR_14;
bool VAR_15 = (VAR_16.warc_filename != NULL);
FILE *VAR_17 = NULL;
ip_address *VAR_18 = NULL;
wgint VAR_19 = 0;
if ((VAR_1 == NULL) && (VAR_2->target))
{
VAR_11 = VAR_2->target;
}
else
{
xfree (VAR_2->target);
VAR_2->target = url_file_name (VAR_0, NULL);
if (!VAR_16.output_document)
VAR_11 = VAR_2->target;
else
VAR_11 = VAR_16.output_document;
}
if (VAR_16.noclobber && !VAR_16.output_document && file_exists_p (VAR_2->target)
&& !((VAR_2->cmd & VAR_20) && !(VAR_2->cmd & VAR_21)))
{
logprintf (VAR_22,
_(""File %s already there; not retrieving.\n""), quote (VAR_2->target));
return VAR_23;
}
remove_link (VAR_2->target);
VAR_5 = 0;
if (VAR_2->st & VAR_24)
VAR_2->st = VAR_24;
VAR_6 = VAR_2->cmd & VAR_25 ? 1 : 0;
do
{
++VAR_5;
sleep_between_retrievals (VAR_5);
if (VAR_2->st & VAR_24)
{
VAR_2->cmd = 0;
VAR_2->cmd |= (VAR_21 | VAR_25);
if (VAR_2->csock != -1)
VAR_2->cmd &= ~ (VAR_26 | VAR_27);
else
VAR_2->cmd |= (VAR_26 | VAR_27);
}
else 
{
if (VAR_2->csock != -1)
VAR_2->cmd &= ~VAR_26;
else
VAR_2->cmd |= VAR_26;
if (VAR_2->st & VAR_28)
VAR_2->cmd &= ~VAR_27;
else
VAR_2->cmd |= VAR_27;
}
if (VAR_15 && (VAR_2->cmd & VAR_21) && VAR_17 == NULL)
{
VAR_17 = warc_tempfile ();
if (VAR_17 == NULL)
return VAR_29;
if (!VAR_2->proxy && VAR_2->csock != -1)
{
VAR_18 = (ip_address *) alloca (sizeof (ip_address));
socket_ip_address (VAR_2->csock, VAR_18, VAR_30);
}
}
if (VAR_2->cmd & VAR_20)
VAR_7 = 0;
else if (VAR_4)
VAR_7 = 0;
else if (VAR_16.start_pos >= 0)
VAR_7 = VAR_16.start_pos;
else if (VAR_16.always_rest
&& stat (VAR_11, &VAR_14) == 0
&& S_ISREG (VAR_14.st_mode))
VAR_7 = VAR_14.st_size;
else if (VAR_5 > 1)
VAR_7 = VAR_9;          
else
VAR_7 = 0;
VAR_10 = datetime_str (time (NULL));
if (VAR_16.verbose)
{
char *VAR_31 = url_string (VAR_0, VAR_32);
char VAR_33[256];
strcpy (VAR_33, ""        "");
if (VAR_5 > 1)
sprintf (VAR_33, _(""(try:%2d)""), VAR_5);
logprintf (VAR_22, ""--%s--  %s\n  %s => %s\n"",
VAR_10, VAR_31, VAR_33, quote (VAR_11));
#ifdef VAR_34
ws_changetitle (VAR_31);
#endif
xfree (VAR_31);
}
if (VAR_1 && VAR_1->type != VAR_35)
VAR_8 = VAR_1->size;
else
VAR_8 = 0;
VAR_13 = getftp (VAR_0, VAR_8, &VAR_9, VAR_7, VAR_2, VAR_5, &VAR_19,
VAR_17);
if (VAR_2->csock == -1)
VAR_2->st &= ~VAR_28;
else
VAR_2->st |= VAR_28;
switch (VAR_13)
{
case VAR_36: case VAR_37: case VAR_38: case VAR_39:
case VAR_40: case VAR_41: case VAR_42: case VAR_43: case VAR_44: case VAR_45:
case VAR_46: case VAR_47: case VAR_48: case VAR_49:
#ifdef VAR_50
if (VAR_13 == VAR_43)
logputs (VAR_51, ""Server does not support AUTH TLS.\n"");
if (VAR_16.ftps_implicit)
logputs (VAR_51, ""Server does not like implicit FTPS connections.\n"");
#endif
if (VAR_17 != NULL)
fclose (VAR_17);
return VAR_13;
case VAR_52: case VAR_53: case VAR_54: case VAR_55:
case VAR_56: case VAR_57: case VAR_58:
case VAR_59: case VAR_60: case VAR_61:
case VAR_62:
printwhat (VAR_5, VAR_16.ntry);
if (VAR_13 == VAR_62)
{
xfree (VAR_2->target);
VAR_2->target = url_file_name (VAR_0, NULL);
VAR_11 = VAR_2->target;
}
continue;
case VAR_63:
if (!VAR_1 || VAR_9 != VAR_1->size)
{
printwhat (VAR_5, VAR_16.ntry);
continue;
}
break;
case VAR_64:
break;
default:
abort ();
}
VAR_10 = datetime_str (time (NULL));
if (!VAR_16.spider)
VAR_12 = retr_rate (VAR_9 - VAR_7, VAR_2->dltime);
downloaded_file (VAR_65, VAR_11);
if (VAR_2->st & VAR_24)
{
fd_close (VAR_2->csock);
VAR_2->csock = -1;
}
if (!VAR_16.spider)
{
bool VAR_66 = (VAR_16.output_document && HYPHENP (VAR_16.output_document));
logprintf (VAR_22,
VAR_66
? _(""%s (%s) - written to stdout %s[%s]\n\n"")
: _(""%s (%s) - %s saved [%s]\n\n""),
VAR_10, VAR_12,
VAR_66 ? """" : quote (VAR_11),
number_to_static_string (VAR_9));
}
if (!VAR_16.verbose && !VAR_16.quiet)
{
char *VAR_31 = url_string (VAR_0, VAR_32);
logprintf (VAR_67, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
VAR_10, VAR_31, number_to_static_string (VAR_9), VAR_11, VAR_5);
xfree (VAR_31);
}
if (VAR_15 && (VAR_2->cmd & VAR_21))
{
bool VAR_68;
VAR_68 = warc_write_resource_record (NULL, VAR_0->url, NULL, NULL,
VAR_18, NULL, VAR_17, -1);
if (! VAR_68)
return VAR_69;
VAR_17 = NULL;
}
if (VAR_2->cmd & VAR_20)
{
if (!VAR_16.remove_listing)
{
VAR_70 += VAR_9;
VAR_71++;
}
}
else if (!VAR_16.spider)
{
VAR_70 += VAR_9;
VAR_71++;
if (VAR_16.delete_after && !input_file_url (VAR_16.input_filename))
{
DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
logprintf (VAR_22, _(""Removing %s.\n""), VAR_11);
if (unlink (VAR_11))
logprintf (VAR_51, ""unlink: %s\n"", strerror (VAR_72));
}
}
if (VAR_6)
VAR_2->cmd |= VAR_25;
else
VAR_2->cmd &= ~VAR_25;
if (VAR_3)
*VAR_3 = xstrdup (VAR_11);
if (VAR_17 != NULL)
fclose (VAR_17);
return VAR_23;
} while (!VAR_16.ntry || (VAR_5 < VAR_16.ntry));
if (VAR_2->csock != -1 && (VAR_2->st & VAR_24))
{
fd_close (VAR_2->csock);
VAR_2->csock = -1;
}
if (VAR_17 != NULL)
fclose (VAR_17);
return VAR_73;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/0.json,"static uerr_t
ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
                   ccon *con, char **local_file, bool force_full_retrieve)
{
  int count, orig_lp;
  wgint restval, len = 0, qtyread = 0;
  char *tms, *locf;
  const char *tmrate = NULL;
  uerr_t err;
  struct_stat st;

  /* Declare WARC variables. */
  bool warc_enabled = (opt.warc_filename != NULL);
  FILE *warc_tmp = NULL;
  ip_address *warc_ip = NULL;
  wgint last_expected_bytes = 0;

  /* Get the target, and set the name for the message accordingly. */
  if ((f == NULL) && (con->target))
    {
      /* Explicit file (like "".listing""). */
      locf = con->target;
    }
  else
    {
      /* URL-derived file.  Consider ""-O file"" name. */
      xfree (con->target);
      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
      if (!opt.output_document)
        locf = con->target;
      else
        locf = opt.output_document;
    }

  /* If the output_document was given, then this check was already done and
     the file didn't exist. Hence the !opt.output_document */

  /* If we receive .listing file it is necessary to determine system type of the ftp
     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in
     order to establish connection with the server and get system type. */
  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)
      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))
    {
      logprintf (LOG_VERBOSE,
                 _(""File %s already there; not retrieving.\n""), quote (con->target));
      /* If the file is there, we suppose it's retrieved OK.  */
      return RETROK;
    }

  /* Remove it if it's a link.  */
  remove_link (con->target);

  count = 0;

  if (con->st & ON_YOUR_OWN)
    con->st = ON_YOUR_OWN;

  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;

  /* THE loop.  */
  do
    {
      /* Increment the pass counter.  */
      ++count;
      sleep_between_retrievals (count);
      if (con->st & ON_YOUR_OWN)
        {
          con->cmd = 0;
          con->cmd |= (DO_RETR | LEAVE_PENDING);
          if (con->csock != -1)
            con->cmd &= ~ (DO_LOGIN | DO_CWD);
          else
            con->cmd |= (DO_LOGIN | DO_CWD);
        }
      else /* not on your own */
        {
          if (con->csock != -1)
            con->cmd &= ~DO_LOGIN;
          else
            con->cmd |= DO_LOGIN;
          if (con->st & DONE_CWD)
            con->cmd &= ~DO_CWD;
          else
            con->cmd |= DO_CWD;
        }

      /* For file RETR requests, we can write a WARC record.
         We record the file contents to a temporary file. */
      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)
        {
          warc_tmp = warc_tempfile ();
          if (warc_tmp == NULL)
            return WARC_TMP_FOPENERR;

          if (!con->proxy && con->csock != -1)
            {
              warc_ip = (ip_address *) alloca (sizeof (ip_address));
              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);
            }
        }

      /* Decide whether or not to restart.  */
      if (con->cmd & DO_LIST)
        restval = 0;
      else if (force_full_retrieve)
        restval = 0;
      else if (opt.start_pos >= 0)
        restval = opt.start_pos;
      else if (opt.always_rest
          && stat (locf, &st) == 0
          && S_ISREG (st.st_mode))
        /* When -c is used, continue from on-disk size.  (Can't use
           hstat.len even if count>1 because we don't want a failed
           first attempt to clobber existing data.)  */
        restval = st.st_size;
      else if (count > 1)
        restval = qtyread;          /* start where the previous run left off */
      else
        restval = 0;

      /* Get the current time string.  */
      tms = datetime_str (time (NULL));
      /* Print fetch message, if opt.verbose.  */
      if (opt.verbose)
        {
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          char tmp[256];
          strcpy (tmp, ""        "");
          if (count > 1)
            sprintf (tmp, _(""(try:%2d)""), count);
          logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"",
                     tms, hurl, tmp, quote (locf));
#ifdef WINDOWS
          ws_changetitle (hurl);
#endif
          xfree (hurl);
        }
      /* Send getftp the proper length, if fileinfo was provided.  */
      if (f && f->type != FT_SYMLINK)
        len = f->size;
      else
        len = 0;

      /* If we are working on a WARC record, getftp should also write
         to the warc_tmp file. */
      err = getftp (u, original_url, len, &qtyread, restval, con, count,
                    &last_expected_bytes, warc_tmp);

      if (con->csock == -1)
        con->st &= ~DONE_CWD;
      else
        con->st |= DONE_CWD;

      switch (err)
        {
        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:
        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:
        case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:
#ifdef HAVE_SSL
          if (err == FTPNOAUTH)
            logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n"");
          if (opt.ftps_implicit)
            logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n"");
#endif
          /* Fatal errors, give up.  */
          if (warc_tmp != NULL)
              fclose (warc_tmp);
          return err;
        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:
        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:
        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:
        case FOPEN_EXCL_ERR:
          printwhat (count, opt.ntry);
          /* non-fatal errors */
          if (err == FOPEN_EXCL_ERR)
            {
              /* Re-determine the file name. */
              xfree (con->target);
              con->target = url_file_name (u, NULL);
              locf = con->target;
            }
          continue;
        case FTPRETRINT:
          /* If the control connection was closed, the retrieval
             will be considered OK if f->size == len.  */
          if (!f || qtyread != f->size)
            {
              printwhat (count, opt.ntry);
              continue;
            }
          break;
        case RETRFINISHED:
          /* Great!  */
          break;
        default:
          /* Not as great.  */
          abort ();
        }
      tms = datetime_str (time (NULL));
      if (!opt.spider)
        tmrate = retr_rate (qtyread - restval, con->dltime);

      /* If we get out of the switch above without continue'ing, we've
         successfully downloaded a file.  Remember this fact. */
      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);

      if (con->st & ON_YOUR_OWN)
        {
          fd_close (con->csock);
          con->csock = -1;
        }
      if (!opt.spider)
        {
          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));

          logprintf (LOG_VERBOSE,
                     write_to_stdout
                     ? _(""%s (%s) - written to stdout %s[%s]\n\n"")
                     : _(""%s (%s) - %s saved [%s]\n\n""),
                     tms, tmrate,
                     write_to_stdout ? """" : quote (locf),
                     number_to_static_string (qtyread));
        }
      if (!opt.verbose && !opt.quiet)
        {
          /* Need to hide the password from the URL.  The `if' is here
             so that we don't do the needless allocation every
             time. */
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
                     tms, hurl, number_to_static_string (qtyread), locf, count);
          xfree (hurl);
        }

      if (warc_enabled && (con->cmd & DO_RETR))
        {
          /* Create and store a WARC resource record for the retrieved file. */
          bool warc_res;

          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,
                                                  warc_ip, NULL, warc_tmp, -1);

          if (! warc_res)
            return WARC_ERR;

          /* warc_write_resource_record has also closed warc_tmp. */
          warc_tmp = NULL;
        }

      if (con->cmd & DO_LIST)
        /* This is a directory listing file. */
        {
          if (!opt.remove_listing)
            /* --dont-remove-listing was specified, so do count this towards the
               number of bytes and files downloaded. */
            {
              total_downloaded_bytes += qtyread;
              numurls++;
            }

          /* Deletion of listing files is not controlled by --delete-after, but
             by the more specific option --dont-remove-listing, and the code
             to do this deletion is in another function. */
        }
      else if (!opt.spider)
        /* This is not a directory listing file. */
        {
          /* Unlike directory listing files, don't pretend normal files weren't
             downloaded if they're going to be deleted.  People seeding proxies,
             for instance, may want to know how many bytes and files they've
             downloaded through it. */
          total_downloaded_bytes += qtyread;
          numurls++;

          if (opt.delete_after && !input_file_url (opt.input_filename))
            {
              DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
              logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf);
              if (unlink (locf))
                logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
            }
        }

      /* Restore the original leave-pendingness.  */
      if (orig_lp)
        con->cmd |= LEAVE_PENDING;
      else
        con->cmd &= ~LEAVE_PENDING;

      if (local_file)
        *local_file = xstrdup (locf);

      if (warc_tmp != NULL)
        fclose (warc_tmp);

      return RETROK;
    } while (!opt.ntry || (count < opt.ntry));

  if (con->csock != -1 && (con->st & ON_YOUR_OWN))
    {
      fd_close (con->csock);
      con->csock = -1;
    }

  if (warc_tmp != NULL)
    fclose (warc_tmp);

  return TRYLIMEXC;
}","static uerr_t
ftp_loop_internal (struct url *VAR_0, struct url *VAR_1, struct fileinfo *VAR_2,
                   ccon *VAR_3, char **VAR_4, bool VAR_5)
{
  int VAR_6, VAR_7;
  wgint VAR_8, VAR_9 = 0, VAR_10 = 0;
  char *VAR_11, *VAR_12;
  const char *VAR_13 = NULL;
  uerr_t VAR_14;
  struct_stat VAR_15;

  /* COMMENT_0 */
  bool VAR_16 = (VAR_17.warc_filename != NULL);
  FILE *VAR_18 = NULL;
  ip_address *VAR_19 = NULL;
  wgint VAR_20 = 0;

  /* COMMENT_1 */
  if ((VAR_2 == NULL) && (VAR_3->target))
    {
      /* COMMENT_2 */
      VAR_12 = VAR_3->target;
    }
  else
    {
      /* COMMENT_3 */
      xfree (VAR_3->target);
      VAR_3->target = url_file_name (VAR_17.trustservernames || !VAR_1 ? VAR_0 : VAR_1, NULL);
      if (!VAR_17.output_document)
        VAR_12 = VAR_3->target;
      else
        VAR_12 = VAR_17.output_document;
    }

  /* COMMENT_4 */
                                                             

  /* COMMENT_6 */
                                                                                
                                                                          
  if (VAR_17.noclobber && !VAR_17.output_document && file_exists_p (VAR_3->target)
      && !((VAR_3->cmd & VAR_21) && !(VAR_3->cmd & VAR_22)))
    {
      logprintf (VAR_23,
                 _(""File %s already there; not retrieving.\n""), quote (VAR_3->target));
      /* COMMENT_9 */
      return VAR_24;
    }

  /* COMMENT_10 */
  remove_link (VAR_3->target);

  VAR_6 = 0;

  if (VAR_3->st & VAR_25)
    VAR_3->st = VAR_25;

  VAR_7 = VAR_3->cmd & VAR_26 ? 1 : 0;

  /* COMMENT_11 */
  do
    {
      /* COMMENT_12 */
      ++VAR_6;
      sleep_between_retrievals (VAR_6);
      if (VAR_3->st & VAR_25)
        {
          VAR_3->cmd = 0;
          VAR_3->cmd |= (VAR_22 | VAR_26);
          if (VAR_3->csock != -1)
            VAR_3->cmd &= ~ (VAR_27 | VAR_28);
          else
            VAR_3->cmd |= (VAR_27 | VAR_28);
        }
      else /* COMMENT_13 */
        {
          if (VAR_3->csock != -1)
            VAR_3->cmd &= ~VAR_27;
          else
            VAR_3->cmd |= VAR_27;
          if (VAR_3->st & VAR_29)
            VAR_3->cmd &= ~VAR_28;
          else
            VAR_3->cmd |= VAR_28;
        }

      /* COMMENT_14 */
                                                            
      if (VAR_16 && (VAR_3->cmd & VAR_22) && VAR_18 == NULL)
        {
          VAR_18 = warc_tempfile ();
          if (VAR_18 == NULL)
            return VAR_30;

          if (!VAR_3->proxy && VAR_3->csock != -1)
            {
              VAR_19 = (ip_address *) alloca (sizeof (ip_address));
              socket_ip_address (VAR_3->csock, VAR_19, VAR_31);
            }
        }

      /* COMMENT_16 */
      if (VAR_3->cmd & VAR_21)
        VAR_8 = 0;
      else if (VAR_5)
        VAR_8 = 0;
      else if (VAR_17.start_pos >= 0)
        VAR_8 = VAR_17.start_pos;
      else if (VAR_17.always_rest
          && stat (VAR_12, &VAR_15) == 0
          && S_ISREG (VAR_15.st_mode))
        /* COMMENT_17 */
                                                                   
                                                       
        VAR_8 = VAR_15.st_size;
      else if (VAR_6 > 1)
        VAR_8 = VAR_10;          /* COMMENT_20 */
      else
        VAR_8 = 0;

      /* COMMENT_21 */
      VAR_11 = datetime_str (time (NULL));
      /* COMMENT_22 */
      if (VAR_17.verbose)
        {
          char *VAR_32 = url_string (VAR_0, VAR_33);
          char VAR_34[256];
          strcpy (VAR_34, ""        "");
          if (VAR_6 > 1)
            sprintf (VAR_34, _(""(try:%2d)""), VAR_6);
          logprintf (VAR_23, ""--%s--  %s\n  %s => %s\n"",
                     VAR_11, VAR_32, VAR_34, quote (VAR_12));
#ifdef VAR_35
          ws_changetitle (VAR_32);
#endif
          xfree (VAR_32);
        }
      /* COMMENT_23 */
      if (VAR_2 && VAR_2->type != VAR_36)
        VAR_9 = VAR_2->size;
      else
        VAR_9 = 0;

      /* COMMENT_24 */
                                 
      VAR_14 = getftp (VAR_0, VAR_1, VAR_9, &VAR_10, VAR_8, VAR_3, VAR_6,
                    &VAR_20, VAR_18);

      if (VAR_3->csock == -1)
        VAR_3->st &= ~VAR_29;
      else
        VAR_3->st |= VAR_29;

      switch (VAR_14)
        {
        case VAR_37: case VAR_38: case VAR_39: case VAR_40:
        case VAR_41: case VAR_42: case VAR_43: case VAR_44: case VAR_45: case VAR_46:
        case VAR_47: case VAR_48: case VAR_49: case VAR_50:
#ifdef VAR_51
          if (VAR_14 == VAR_44)
            logputs (VAR_52, ""Server does not support AUTH TLS.\n"");
          if (VAR_17.ftps_implicit)
            logputs (VAR_52, ""Server does not like implicit FTPS connections.\n"");
#endif
          /* COMMENT_26 */
          if (VAR_18 != NULL)
              fclose (VAR_18);
          return VAR_14;
        case VAR_53: case VAR_54: case VAR_55: case VAR_56:
        case VAR_57: case VAR_58: case VAR_59:
        case VAR_60: case VAR_61: case VAR_62:
        case VAR_63:
          printwhat (VAR_6, VAR_17.ntry);
          /* COMMENT_27 */
          if (VAR_14 == VAR_63)
            {
              /* COMMENT_28 */
              xfree (VAR_3->target);
              VAR_3->target = url_file_name (VAR_0, NULL);
              VAR_12 = VAR_3->target;
            }
          continue;
        case VAR_64:
          /* COMMENT_29 */
                                                         
          if (!VAR_2 || VAR_10 != VAR_2->size)
            {
              printwhat (VAR_6, VAR_17.ntry);
              continue;
            }
          break;
        case VAR_65:
          /* COMMENT_31 */
          break;
        default:
          /* COMMENT_32 */
          abort ();
        }
      VAR_11 = datetime_str (time (NULL));
      if (!VAR_17.spider)
        VAR_13 = retr_rate (VAR_10 - VAR_8, VAR_3->dltime);

      /* COMMENT_33 */
                                                                
      downloaded_file (VAR_66, VAR_12);

      if (VAR_3->st & VAR_25)
        {
          fd_close (VAR_3->csock);
          VAR_3->csock = -1;
        }
      if (!VAR_17.spider)
        {
          bool VAR_67 = (VAR_17.output_document && HYPHENP (VAR_17.output_document));

          logprintf (VAR_23,
                     VAR_67
                     ? _(""%s (%s) - written to stdout %s[%s]\n\n"")
                     : _(""%s (%s) - %s saved [%s]\n\n""),
                     VAR_11, VAR_13,
                     VAR_67 ? """" : quote (VAR_12),
                     number_to_static_string (VAR_10));
        }
      if (!VAR_17.verbose && !VAR_17.quiet)
        {
          /* COMMENT_35 */
                                                              
                     
          char *VAR_32 = url_string (VAR_0, VAR_33);
          logprintf (VAR_68, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
                     VAR_11, VAR_32, number_to_static_string (VAR_10), VAR_12, VAR_6);
          xfree (VAR_32);
        }

      if (VAR_16 && (VAR_3->cmd & VAR_22))
        {
          /* COMMENT_38 */
          bool VAR_69;

          VAR_69 = warc_write_resource_record (NULL, VAR_0->url, NULL, NULL,
                                                  VAR_19, NULL, VAR_18, -1);

          if (! VAR_69)
            return VAR_70;

          /* COMMENT_39 */
          VAR_18 = NULL;
        }

      if (VAR_3->cmd & VAR_21)
        /* COMMENT_40 */
        {
          if (!VAR_17.remove_listing)
            /* COMMENT_41 */
                                                       
            {
              VAR_71 += VAR_10;
              VAR_72++;
            }

          /* COMMENT_43 */
                                                                            
                                                           
        }
      else if (!VAR_17.spider)
        /* COMMENT_46 */
        {
          /* COMMENT_47 */
                                                                                
                                                                            
                                      
          VAR_71 += VAR_10;
          VAR_72++;

          if (VAR_17.delete_after && !input_file_url (VAR_17.input_filename))
            {
              DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
              logprintf (VAR_23, _(""Removing %s.\n""), VAR_12);
              if (unlink (VAR_12))
                logprintf (VAR_52, ""unlink: %s\n"", strerror (VAR_73));
            }
        }

      /* COMMENT_51 */
      if (VAR_7)
        VAR_3->cmd |= VAR_26;
      else
        VAR_3->cmd &= ~VAR_26;

      if (VAR_4)
        *VAR_4 = xstrdup (VAR_12);

      if (VAR_18 != NULL)
        fclose (VAR_18);

      return VAR_24;
    } while (!VAR_17.ntry || (VAR_6 < VAR_17.ntry));

  if (VAR_3->csock != -1 && (VAR_3->st & VAR_25))
    {
      fd_close (VAR_3->csock);
      VAR_3->csock = -1;
    }

  if (VAR_18 != NULL)
    fclose (VAR_18);

  return VAR_74;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static uerr_t
-ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
-                   bool force_full_retrieve)
+ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
+                   ccon *con, char **local_file, bool force_full_retrieve)
 {
   int count, orig_lp;
   wgint restval, len = 0, qtyread = 0;
@@ -25,7 +25,7 @@
     {
       /* URL-derived file.  Consider ""-O file"" name. */
       xfree (con->target);
-      con->target = url_file_name (u, NULL);
+      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
       if (!opt.output_document)
         locf = con->target;
       else
@@ -143,8 +143,8 @@
 
       /* If we are working on a WARC record, getftp should also write
          to the warc_tmp file. */
-      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
-                    warc_tmp);
+      err = getftp (u, original_url, len, &qtyread, restval, con, count,
+                    &last_expected_bytes, warc_tmp);
 
       if (con->csock == -1)
         con->st &= ~DONE_CWD;","{'deleted_lines': ['ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,', '                   bool force_full_retrieve)', '      con->target = url_file_name (u, NULL);', '      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,', '                    warc_tmp);'], 'added_lines': ['ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,', '                   ccon *con, char **local_file, bool force_full_retrieve)', '      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);', '      err = getftp (u, original_url, len, &qtyread, restval, con, count,', '                    &last_expected_bytes, warc_tmp);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_retrieve_list,"static uerr_t
ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
{
static int depth = 0;
uerr_t err;
struct fileinfo *orig;
wgint local_size;
time_t tml;
bool dlthis; 
const char *actual_target = NULL;
bool force_full_retrieve = false;
++depth;
if (opt.reclevel != INFINITE_RECURSION && depth > opt.reclevel)
{
DEBUGP ((_(""Recursion depth %d exceeded max. depth %d.\n""),
depth, opt.reclevel));
--depth;
return RECLEVELEXC;
}
assert (f != NULL);
orig = f;
con->st &= ~ON_YOUR_OWN;
if (!(con->st & DONE_CWD))
con->cmd |= DO_CWD;
else
con->cmd &= ~DO_CWD;
con->cmd |= (DO_RETR | LEAVE_PENDING);
if (con->csock < 0)
con->cmd |= DO_LOGIN;
else
con->cmd &= ~DO_LOGIN;
err = RETROK;                 
while (f)
{
char *old_target, *ofile;
if (opt.quota && total_downloaded_bytes > opt.quota)
{
--depth;
return QUOTEXC;
}
old_target = con->target;
ofile = xstrdup (u->file);
url_set_file (u, f->name);
con->target = url_file_name (u, NULL);
err = RETROK;
dlthis = true;
if (opt.timestamping && f->type == FT_PLAINFILE)
{
struct_stat st;
if (!stat (con->target, &st))
{
bool eq_size;
bool cor_val;
local_size = st.st_size;
tml = st.st_mtime;
#ifdef WINDOWS
tml++;
#endif
cor_val = (con->rs == ST_UNIX || con->rs == ST_WINNT);
eq_size = cor_val ? (local_size == f->size) : true;
if (f->tstamp <= tml && eq_size)
{
logprintf (LOG_VERBOSE, _(""\
Remote file no newer than local file %s -- not retrieving.\n""), quote (con->target));
dlthis = false;
}
else if (f->tstamp > tml)
{
force_full_retrieve = true;
logprintf (LOG_VERBOSE, _(""\
Remote file is newer than local file %s -- retrieving.\n\n""),
quote (con->target));
}
else
{
logprintf (LOG_VERBOSE, _(""\
The sizes do not match (local %s) -- retrieving.\n\n""),
number_to_static_string (local_size));
}
}
}       
switch (f->type)
{
case FT_SYMLINK:
if (!opt.retr_symlinks)
{
#ifdef HAVE_SYMLINK
if (!f->linkto)
logputs (LOG_NOTQUIET,
_(""Invalid name of the symlink, skipping.\n""));
else
{
struct_stat st;
int rc = lstat (con->target, &st);
if (rc == 0)
{
size_t len = strlen (f->linkto) + 1;
if (S_ISLNK (st.st_mode))
{
char *link_target = (char *)alloca (len);
size_t n = readlink (con->target, link_target, len);
if ((n == len - 1)
&& (memcmp (link_target, f->linkto, n) == 0))
{
logprintf (LOG_VERBOSE, _(""\
Already have correct symlink %s -> %s\n\n""),
quote (con->target),
quote (f->linkto));
dlthis = false;
break;
}
}
}
logprintf (LOG_VERBOSE, _(""Creating symlink %s -> %s\n""),
quote (con->target), quote (f->linkto));
unlink (con->target);
if (symlink (f->linkto, con->target) == -1)
logprintf (LOG_NOTQUIET, ""symlink: %s\n"", strerror (errno));
logputs (LOG_VERBOSE, ""\n"");
} 
#else  
logprintf (LOG_NOTQUIET,
_(""Symlinks not supported, skipping symlink %s.\n""),
quote (con->target));
#endif 
}
else                
{
if (dlthis)
err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
} 
break;
case FT_DIRECTORY:
if (!opt.recursive)
logprintf (LOG_NOTQUIET, _(""Skipping directory %s.\n""),
quote (f->name));
break;
case FT_PLAINFILE:
if (dlthis)
err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
break;
case FT_UNKNOWN:
logprintf (LOG_NOTQUIET, _(""%s: unknown/unsupported file type.\n""),
quote (f->name));
break;
}       
set_local_file (&actual_target, con->target);
if (dlthis && (actual_target != NULL) &&
(f->type == FT_PLAINFILE) && opt.preserve_perm)
{
if (f->perms)
chmod (actual_target, f->perms);
else
DEBUGP ((""Unrecognized permissions for %s.\n"", actual_target));
}
if (actual_target != NULL)
{
if (opt.useservertimestamps
&& !(f->type == FT_SYMLINK && !opt.retr_symlinks)
&& f->tstamp != -1
&& dlthis
&& file_exists_p (con->target))
{
touch (actual_target, f->tstamp);
}
else if (f->tstamp == -1)
logprintf (LOG_NOTQUIET, _(""%s: corrupt time-stamp.\n""),
actual_target);
}
xfree (con->target);
con->target = old_target;
url_set_file (u, ofile);
xfree (ofile);
if (err == QUOTEXC || err == HOSTERR || err == FWRITEERR
|| err == WARC_ERR || err == WARC_TMP_FOPENERR
|| err == WARC_TMP_FWRITEERR)
break;
con->cmd &= ~ (DO_CWD | DO_LOGIN);
f = f->next;
}
if (opt.recursive &&
!(opt.reclevel != INFINITE_RECURSION && depth >= opt.reclevel))
err = ftp_retrieve_dirs (u, orig, con);
else if (opt.recursive)
DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
depth, opt.reclevel));
--depth;
return err;
}","static uerr_t
ftp_retrieve_list (struct url *VAR_0, struct fileinfo *VAR_1, ccon *VAR_2)
{
static int VAR_3 = 0;
uerr_t VAR_4;
struct fileinfo *VAR_5;
wgint VAR_6;
time_t VAR_7;
bool VAR_8; 
const char *VAR_9 = NULL;
bool VAR_10 = false;
++VAR_3;
if (VAR_11.reclevel != VAR_12 && VAR_3 > VAR_11.reclevel)
{
DEBUGP ((_(""Recursion depth %d exceeded max. depth %d.\n""),
VAR_3, VAR_11.reclevel));
--VAR_3;
return VAR_13;
}
assert (VAR_1 != NULL);
VAR_5 = VAR_1;
VAR_2->st &= ~VAR_14;
if (!(VAR_2->st & VAR_15))
VAR_2->cmd |= VAR_16;
else
VAR_2->cmd &= ~VAR_16;
VAR_2->cmd |= (VAR_17 | VAR_18);
if (VAR_2->csock < 0)
VAR_2->cmd |= VAR_19;
else
VAR_2->cmd &= ~VAR_19;
VAR_4 = VAR_20;                 
while (VAR_1)
{
char *VAR_21, *VAR_22;
if (VAR_11.quota && VAR_23 > VAR_11.quota)
{
--VAR_3;
return VAR_24;
}
VAR_21 = VAR_2->target;
VAR_22 = xstrdup (VAR_0->file);
url_set_file (VAR_0, VAR_1->name);
VAR_2->target = url_file_name (VAR_0, NULL);
VAR_4 = VAR_20;
VAR_8 = true;
if (VAR_11.timestamping && VAR_1->type == VAR_25)
{
struct_stat VAR_26;
if (!stat (VAR_2->target, &VAR_26))
{
bool VAR_27;
bool VAR_28;
VAR_6 = VAR_26.st_size;
VAR_7 = VAR_26.st_mtime;
#ifdef VAR_29
VAR_7++;
#endif
VAR_28 = (VAR_2->rs == VAR_30 || VAR_2->rs == VAR_31);
VAR_27 = VAR_28 ? (VAR_6 == VAR_1->size) : true;
if (VAR_1->tstamp <= VAR_7 && VAR_27)
{
logprintf (VAR_32, _(""\
Remote file no newer than local file %s -- not retrieving.\n""), quote (VAR_2->target));
VAR_8 = false;
}
else if (VAR_1->tstamp > VAR_7)
{
VAR_10 = true;
logprintf (VAR_32, _(""\
Remote file is newer than local file %s -- retrieving.\n\n""),
quote (VAR_2->target));
}
else
{
logprintf (VAR_32, _(""\
The sizes do not match (local %s) -- retrieving.\n\n""),
number_to_static_string (VAR_6));
}
}
}       
switch (VAR_1->type)
{
case VAR_33:
if (!VAR_11.retr_symlinks)
{
#ifdef VAR_34
if (!VAR_1->linkto)
logputs (VAR_35,
_(""Invalid name of the symlink, skipping.\n""));
else
{
struct_stat VAR_26;
int VAR_36 = lstat (VAR_2->target, &VAR_26);
if (VAR_36 == 0)
{
size_t VAR_37 = strlen (VAR_1->linkto) + 1;
if (S_ISLNK (VAR_26.st_mode))
{
char *VAR_38 = (char *)alloca (VAR_37);
size_t VAR_39 = readlink (VAR_2->target, VAR_38, VAR_37);
if ((VAR_39 == VAR_37 - 1)
&& (memcmp (VAR_38, VAR_1->linkto, VAR_39) == 0))
{
logprintf (VAR_32, _(""\
Already have correct symlink %s -> %s\n\n""),
quote (VAR_2->target),
quote (VAR_1->linkto));
VAR_8 = false;
break;
}
}
}
logprintf (VAR_32, _(""Creating symlink %s -> %s\n""),
quote (VAR_2->target), quote (VAR_1->linkto));
unlink (VAR_2->target);
if (symlink (VAR_1->linkto, VAR_2->target) == -1)
logprintf (VAR_35, ""symlink: %s\n"", strerror (VAR_40));
logputs (VAR_32, ""\n"");
} 
#else  
logprintf (VAR_35,
_(""Symlinks not supported, skipping symlink %s.\n""),
quote (VAR_2->target));
#endif 
}
else                
{
if (VAR_8)
VAR_4 = ftp_loop_internal (VAR_0, VAR_1, VAR_2, NULL, VAR_10);
} 
break;
case VAR_41:
if (!VAR_11.recursive)
logprintf (VAR_35, _(""Skipping directory %s.\n""),
quote (VAR_1->name));
break;
case VAR_25:
if (VAR_8)
VAR_4 = ftp_loop_internal (VAR_0, VAR_1, VAR_2, NULL, VAR_10);
break;
case VAR_42:
logprintf (VAR_35, _(""%s: unknown/unsupported file type.\n""),
quote (VAR_1->name));
break;
}       
set_local_file (&VAR_9, VAR_2->target);
if (VAR_8 && (VAR_9 != NULL) &&
(VAR_1->type == VAR_25) && VAR_11.preserve_perm)
{
if (VAR_1->perms)
chmod (VAR_9, VAR_1->perms);
else
DEBUGP ((""Unrecognized permissions for %s.\n"", VAR_9));
}
if (VAR_9 != NULL)
{
if (VAR_11.useservertimestamps
&& !(VAR_1->type == VAR_33 && !VAR_11.retr_symlinks)
&& VAR_1->tstamp != -1
&& VAR_8
&& file_exists_p (VAR_2->target))
{
touch (VAR_9, VAR_1->tstamp);
}
else if (VAR_1->tstamp == -1)
logprintf (VAR_35, _(""%s: corrupt time-stamp.\n""),
VAR_9);
}
xfree (VAR_2->target);
VAR_2->target = VAR_21;
url_set_file (VAR_0, VAR_22);
xfree (VAR_22);
if (VAR_4 == VAR_24 || VAR_4 == VAR_43 || VAR_4 == VAR_44
|| VAR_4 == VAR_45 || VAR_4 == VAR_46
|| VAR_4 == VAR_47)
break;
VAR_2->cmd &= ~ (VAR_16 | VAR_19);
VAR_1 = VAR_1->next;
}
if (VAR_11.recursive &&
!(VAR_11.reclevel != VAR_12 && VAR_3 >= VAR_11.reclevel))
VAR_4 = ftp_retrieve_dirs (VAR_0, VAR_5, VAR_2);
else if (VAR_11.recursive)
DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
VAR_3, VAR_11.reclevel));
--VAR_3;
return VAR_4;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/1.json,"static uerr_t
ftp_retrieve_list (struct url *u, struct url *original_url,
                   struct fileinfo *f, ccon *con)
{
  static int depth = 0;
  uerr_t err;
  struct fileinfo *orig;
  wgint local_size;
  time_t tml;
  bool dlthis; /* Download this (file). */
  const char *actual_target = NULL;
  bool force_full_retrieve = false;

  /* Increase the depth.  */
  ++depth;
  if (opt.reclevel != INFINITE_RECURSION && depth > opt.reclevel)
    {
      DEBUGP ((_(""Recursion depth %d exceeded max. depth %d.\n""),
               depth, opt.reclevel));
      --depth;
      return RECLEVELEXC;
    }

  assert (f != NULL);
  orig = f;

  con->st &= ~ON_YOUR_OWN;
  if (!(con->st & DONE_CWD))
    con->cmd |= DO_CWD;
  else
    con->cmd &= ~DO_CWD;
  con->cmd |= (DO_RETR | LEAVE_PENDING);

  if (con->csock < 0)
    con->cmd |= DO_LOGIN;
  else
    con->cmd &= ~DO_LOGIN;

  err = RETROK;                 /* in case it's not used */

  while (f)
    {
      char *old_target, *ofile;

      if (opt.quota && total_downloaded_bytes > opt.quota)
        {
          --depth;
          return QUOTEXC;
        }
      old_target = con->target;

      ofile = xstrdup (u->file);
      url_set_file (u, f->name);

      con->target = url_file_name (u, NULL);
      err = RETROK;

      dlthis = true;
      if (opt.timestamping && f->type == FT_PLAINFILE)
        {
          struct_stat st;
          /* If conversion of HTML files retrieved via FTP is ever implemented,
             we'll need to stat() <file>.orig here when -K has been specified.
             I'm not implementing it now since files on an FTP server are much
             more likely than files on an HTTP server to legitimately have a
             .orig suffix. */
          if (!stat (con->target, &st))
            {
              bool eq_size;
              bool cor_val;
              /* Else, get it from the file.  */
              local_size = st.st_size;
              tml = st.st_mtime;
#ifdef WINDOWS
              /* Modification time granularity is 2 seconds for Windows, so
                 increase local time by 1 second for later comparison. */
              tml++;
#endif
              /* Compare file sizes only for servers that tell us correct
                 values. Assume sizes being equal for servers that lie
                 about file size.  */
              cor_val = (con->rs == ST_UNIX || con->rs == ST_WINNT);
              eq_size = cor_val ? (local_size == f->size) : true;
              if (f->tstamp <= tml && eq_size)
                {
                  /* Remote file is older, file sizes can be compared and
                     are both equal. */
                  logprintf (LOG_VERBOSE, _(""\
Remote file no newer than local file %s -- not retrieving.\n""), quote (con->target));
                  dlthis = false;
                }
              else if (f->tstamp > tml)
                {
                  /* Remote file is newer */
                  force_full_retrieve = true;
                  logprintf (LOG_VERBOSE, _(""\
Remote file is newer than local file %s -- retrieving.\n\n""),
                             quote (con->target));
                }
              else
                {
                  /* Sizes do not match */
                  logprintf (LOG_VERBOSE, _(""\
The sizes do not match (local %s) -- retrieving.\n\n""),
                             number_to_static_string (local_size));
                }
            }
        }       /* opt.timestamping && f->type == FT_PLAINFILE */
      switch (f->type)
        {
        case FT_SYMLINK:
          /* If opt.retr_symlinks is defined, we treat symlinks as
             if they were normal files.  There is currently no way
             to distinguish whether they might be directories, and
             follow them.  */
          if (!opt.retr_symlinks)
            {
#ifdef HAVE_SYMLINK
              if (!f->linkto)
                logputs (LOG_NOTQUIET,
                         _(""Invalid name of the symlink, skipping.\n""));
              else
                {
                  struct_stat st;
                  /* Check whether we already have the correct
                     symbolic link.  */
                  int rc = lstat (con->target, &st);
                  if (rc == 0)
                    {
                      size_t len = strlen (f->linkto) + 1;
                      if (S_ISLNK (st.st_mode))
                        {
                          char *link_target = (char *)alloca (len);
                          size_t n = readlink (con->target, link_target, len);
                          if ((n == len - 1)
                              && (memcmp (link_target, f->linkto, n) == 0))
                            {
                              logprintf (LOG_VERBOSE, _(""\
Already have correct symlink %s -> %s\n\n""),
                                         quote (con->target),
                                         quote (f->linkto));
                              dlthis = false;
                              break;
                            }
                        }
                    }
                  logprintf (LOG_VERBOSE, _(""Creating symlink %s -> %s\n""),
                             quote (con->target), quote (f->linkto));
                  /* Unlink before creating symlink!  */
                  unlink (con->target);
                  if (symlink (f->linkto, con->target) == -1)
                    logprintf (LOG_NOTQUIET, ""symlink: %s\n"", strerror (errno));
                  logputs (LOG_VERBOSE, ""\n"");
                } /* have f->linkto */
#else  /* not HAVE_SYMLINK */
              logprintf (LOG_NOTQUIET,
                         _(""Symlinks not supported, skipping symlink %s.\n""),
                         quote (con->target));
#endif /* not HAVE_SYMLINK */
            }
          else                /* opt.retr_symlinks */
            {
              if (dlthis)
                {
                  err = ftp_loop_internal (u, original_url, f, con, NULL,
                                           force_full_retrieve);
                }
            } /* opt.retr_symlinks */
          break;
        case FT_DIRECTORY:
          if (!opt.recursive)
            logprintf (LOG_NOTQUIET, _(""Skipping directory %s.\n""),
                       quote (f->name));
          break;
        case FT_PLAINFILE:
          /* Call the retrieve loop.  */
          if (dlthis)
            {
              err = ftp_loop_internal (u, original_url, f, con, NULL,
                                       force_full_retrieve);
            }
          break;
        case FT_UNKNOWN:
          logprintf (LOG_NOTQUIET, _(""%s: unknown/unsupported file type.\n""),
                     quote (f->name));
          break;
        }       /* switch */


      /* 2004-12-15 SMS.
       * Set permissions _before_ setting the times, as setting the
       * permissions changes the modified-time, at least on VMS.
       * Also, use the opt.output_document name here, too, as
       * appropriate.  (Do the test once, and save the result.)
       */

      set_local_file (&actual_target, con->target);

      /* If downloading a plain file, and the user requested it, then
         set valid (non-zero) permissions. */
      if (dlthis && (actual_target != NULL) &&
       (f->type == FT_PLAINFILE) && opt.preserve_perm)
        {
          if (f->perms)
            chmod (actual_target, f->perms);
          else
            DEBUGP ((""Unrecognized permissions for %s.\n"", actual_target));
        }

      /* Set the time-stamp information to the local file.  Symlinks
         are not to be stamped because it sets the stamp on the
         original.  :( */
      if (actual_target != NULL)
        {
          if (opt.useservertimestamps
              && !(f->type == FT_SYMLINK && !opt.retr_symlinks)
              && f->tstamp != -1
              && dlthis
              && file_exists_p (con->target))
            {
              touch (actual_target, f->tstamp);
            }
          else if (f->tstamp == -1)
            logprintf (LOG_NOTQUIET, _(""%s: corrupt time-stamp.\n""),
                       actual_target);
        }

      xfree (con->target);
      con->target = old_target;

      url_set_file (u, ofile);
      xfree (ofile);

      /* Break on fatals.  */
      if (err == QUOTEXC || err == HOSTERR || err == FWRITEERR
          || err == WARC_ERR || err == WARC_TMP_FOPENERR
          || err == WARC_TMP_FWRITEERR)
        break;
      con->cmd &= ~ (DO_CWD | DO_LOGIN);
      f = f->next;
    }

  /* We do not want to call ftp_retrieve_dirs here */
  if (opt.recursive &&
      !(opt.reclevel != INFINITE_RECURSION && depth >= opt.reclevel))
    err = ftp_retrieve_dirs (u, original_url, orig, con);
  else if (opt.recursive)
    DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
             depth, opt.reclevel));
  --depth;
  return err;
}","static uerr_t
ftp_retrieve_list (struct url *VAR_0, struct url *VAR_1,
                   struct fileinfo *VAR_2, ccon *VAR_3)
{
  static int VAR_4 = 0;
  uerr_t VAR_5;
  struct fileinfo *VAR_6;
  wgint VAR_7;
  time_t VAR_8;
  bool VAR_9; /* COMMENT_0 */
  const char *VAR_10 = NULL;
  bool VAR_11 = false;

  /* COMMENT_1 */
  ++VAR_4;
  if (VAR_12.reclevel != VAR_13 && VAR_4 > VAR_12.reclevel)
    {
      DEBUGP ((_(""Recursion depth %d exceeded max. depth %d.\n""),
               VAR_4, VAR_12.reclevel));
      --VAR_4;
      return VAR_14;
    }

  assert (VAR_2 != NULL);
  VAR_6 = VAR_2;

  VAR_3->st &= ~VAR_15;
  if (!(VAR_3->st & VAR_16))
    VAR_3->cmd |= VAR_17;
  else
    VAR_3->cmd &= ~VAR_17;
  VAR_3->cmd |= (VAR_18 | VAR_19);

  if (VAR_3->csock < 0)
    VAR_3->cmd |= VAR_20;
  else
    VAR_3->cmd &= ~VAR_20;

  VAR_5 = VAR_21;                 /* COMMENT_2 */

  while (VAR_2)
    {
      char *VAR_22, *VAR_23;

      if (VAR_12.quota && VAR_24 > VAR_12.quota)
        {
          --VAR_4;
          return VAR_25;
        }
      VAR_22 = VAR_3->target;

      VAR_23 = xstrdup (VAR_0->file);
      url_set_file (VAR_0, VAR_2->name);

      VAR_3->target = url_file_name (VAR_0, NULL);
      VAR_5 = VAR_21;

      VAR_9 = true;
      if (VAR_12.timestamping && VAR_2->type == VAR_26)
        {
          struct_stat VAR_27;
          /* COMMENT_3 */
                                                                              
                                                                              
                                                                            
                             
          if (!stat (VAR_3->target, &VAR_27))
            {
              bool VAR_28;
              bool VAR_29;
              /* COMMENT_8 */
              VAR_7 = VAR_27.st_size;
              VAR_8 = VAR_27.st_mtime;
#ifdef VAR_30
              /* COMMENT_9 */
                                                                         
              VAR_8++;
#endif
              /* COMMENT_11 */
                                                                      
                                     
              VAR_29 = (VAR_3->rs == VAR_31 || VAR_3->rs == VAR_32);
              VAR_28 = VAR_29 ? (VAR_7 == VAR_2->size) : true;
              if (VAR_2->tstamp <= VAR_8 && VAR_28)
                {
                  /* COMMENT_14 */
                                       
                  logprintf (VAR_33, _(""\
Remote file no newer than local file %s -- not retrieving.\n""), quote (VAR_3->target));
                  VAR_9 = false;
                }
              else if (VAR_2->tstamp > VAR_8)
                {
                  /* COMMENT_16 */
                  VAR_11 = true;
                  logprintf (VAR_33, _(""\
Remote file is newer than local file %s -- retrieving.\n\n""),
                             quote (VAR_3->target));
                }
              else
                {
                  /* COMMENT_17 */
                  logprintf (VAR_33, _(""\
The sizes do not match (local %s) -- retrieving.\n\n""),
                             number_to_static_string (VAR_7));
                }
            }
        }       /* COMMENT_18 */
      switch (VAR_2->type)
        {
        case VAR_34:
          /* COMMENT_19 */
                                                                  
                                                                  
                             
          if (!VAR_12.retr_symlinks)
            {
#ifdef VAR_35
              if (!VAR_2->linkto)
                logputs (VAR_36,
                         _(""Invalid name of the symlink, skipping.\n""));
              else
                {
                  struct_stat VAR_27;
                  /* COMMENT_23 */
                                       
                  int VAR_37 = lstat (VAR_3->target, &VAR_27);
                  if (VAR_37 == 0)
                    {
                      size_t VAR_38 = strlen (VAR_2->linkto) + 1;
                      if (S_ISLNK (VAR_27.st_mode))
                        {
                          char *VAR_39 = (char *)alloca (VAR_38);
                          size_t VAR_40 = readlink (VAR_3->target, VAR_39, VAR_38);
                          if ((VAR_40 == VAR_38 - 1)
                              && (memcmp (VAR_39, VAR_2->linkto, VAR_40) == 0))
                            {
                              logprintf (VAR_33, _(""\
Already have correct symlink %s -> %s\n\n""),
                                         quote (VAR_3->target),
                                         quote (VAR_2->linkto));
                              VAR_9 = false;
                              break;
                            }
                        }
                    }
                  logprintf (VAR_33, _(""Creating symlink %s -> %s\n""),
                             quote (VAR_3->target), quote (VAR_2->linkto));
                  /* COMMENT_25 */
                  unlink (VAR_3->target);
                  if (symlink (VAR_2->linkto, VAR_3->target) == -1)
                    logprintf (VAR_36, ""symlink: %s\n"", strerror (VAR_41));
                  logputs (VAR_33, ""\n"");
                } /* COMMENT_26 */
#else  /* COMMENT_27 */
              logprintf (VAR_36,
                         _(""Symlinks not supported, skipping symlink %s.\n""),
                         quote (VAR_3->target));
#endif /* COMMENT_27 */
            }
          else                /* COMMENT_28 */
            {
              if (VAR_9)
                {
                  VAR_5 = ftp_loop_internal (VAR_0, VAR_1, VAR_2, VAR_3, NULL,
                                           VAR_11);
                }
            } /* COMMENT_28 */
          break;
        case VAR_42:
          if (!VAR_12.recursive)
            logprintf (VAR_36, _(""Skipping directory %s.\n""),
                       quote (VAR_2->name));
          break;
        case VAR_26:
          /* COMMENT_29 */
          if (VAR_9)
            {
              VAR_5 = ftp_loop_internal (VAR_0, VAR_1, VAR_2, VAR_3, NULL,
                                       VAR_11);
            }
          break;
        case VAR_43:
          logprintf (VAR_36, _(""%s: unknown/unsupported file type.\n""),
                     quote (VAR_2->name));
          break;
        }       /* COMMENT_30 */


      /* COMMENT_31 */
                                                                   
                                                                
                                                             
                                                               
         

      set_local_file (&VAR_10, VAR_3->target);

      /* COMMENT_37 */
                                             
      if (VAR_9 && (VAR_10 != NULL) &&
       (VAR_2->type == VAR_26) && VAR_12.preserve_perm)
        {
          if (VAR_2->perms)
            chmod (VAR_10, VAR_2->perms);
          else
            DEBUGP ((""Unrecognized permissions for %s.\n"", VAR_10));
        }

      /* COMMENT_39 */
                                                               
                         
      if (VAR_10 != NULL)
        {
          if (VAR_12.useservertimestamps
              && !(VAR_2->type == VAR_34 && !VAR_12.retr_symlinks)
              && VAR_2->tstamp != -1
              && VAR_9
              && file_exists_p (VAR_3->target))
            {
              touch (VAR_10, VAR_2->tstamp);
            }
          else if (VAR_2->tstamp == -1)
            logprintf (VAR_36, _(""%s: corrupt time-stamp.\n""),
                       VAR_10);
        }

      xfree (VAR_3->target);
      VAR_3->target = VAR_22;

      url_set_file (VAR_0, VAR_23);
      xfree (VAR_23);

      /* COMMENT_42 */
      if (VAR_5 == VAR_25 || VAR_5 == VAR_44 || VAR_5 == VAR_45
          || VAR_5 == VAR_46 || VAR_5 == VAR_47
          || VAR_5 == VAR_48)
        break;
      VAR_3->cmd &= ~ (VAR_17 | VAR_20);
      VAR_2 = VAR_2->next;
    }

  /* COMMENT_43 */
  if (VAR_12.recursive &&
      !(VAR_12.reclevel != VAR_13 && VAR_4 >= VAR_12.reclevel))
    VAR_5 = ftp_retrieve_dirs (VAR_0, VAR_1, VAR_6, VAR_3);
  else if (VAR_12.recursive)
    DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
             VAR_4, VAR_12.reclevel));
  --VAR_4;
  return VAR_5;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static uerr_t
-ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
+ftp_retrieve_list (struct url *u, struct url *original_url,
+                   struct fileinfo *f, ccon *con)
 {
   static int depth = 0;
   uerr_t err;
@@ -160,7 +161,10 @@
           else                /* opt.retr_symlinks */
             {
               if (dlthis)
-                err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
+                {
+                  err = ftp_loop_internal (u, original_url, f, con, NULL,
+                                           force_full_retrieve);
+                }
             } /* opt.retr_symlinks */
           break;
         case FT_DIRECTORY:
@@ -171,7 +175,10 @@
         case FT_PLAINFILE:
           /* Call the retrieve loop.  */
           if (dlthis)
-            err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
+            {
+              err = ftp_loop_internal (u, original_url, f, con, NULL,
+                                       force_full_retrieve);
+            }
           break;
         case FT_UNKNOWN:
           logprintf (LOG_NOTQUIET, _(""%s: unknown/unsupported file type.\n""),
@@ -236,7 +243,7 @@
   /* We do not want to call ftp_retrieve_dirs here */
   if (opt.recursive &&
       !(opt.reclevel != INFINITE_RECURSION && depth >= opt.reclevel))
-    err = ftp_retrieve_dirs (u, orig, con);
+    err = ftp_retrieve_dirs (u, original_url, orig, con);
   else if (opt.recursive)
     DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
              depth, opt.reclevel));","{'deleted_lines': ['ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)', '                err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);', '            err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);', '    err = ftp_retrieve_dirs (u, orig, con);'], 'added_lines': ['ftp_retrieve_list (struct url *u, struct url *original_url,', '                   struct fileinfo *f, ccon *con)', '                {', '                  err = ftp_loop_internal (u, original_url, f, con, NULL,', '                                           force_full_retrieve);', '                }', '            {', '              err = ftp_loop_internal (u, original_url, f, con, NULL,', '                                       force_full_retrieve);', '            }', '    err = ftp_retrieve_dirs (u, original_url, orig, con);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_retrieve_glob,"static uerr_t
ftp_retrieve_glob (struct url *u, ccon *con, int action)
{
struct fileinfo *f, *start;
uerr_t res;
con->cmd |= LEAVE_PENDING;
res = ftp_get_listing (u, con, &start);
if (res != RETROK)
return res;
if (opt.accepts || opt.rejects)
{
f = start;
while (f)
{
if (f->type != FT_DIRECTORY && !acceptable (f->name))
{
logprintf (LOG_VERBOSE, _(""Rejecting %s.\n""),
quote (f->name));
f = delelement (f, &start);
}
else
f = f->next;
}
}
f = start;
while (f)
{
if (has_insecure_name_p (f->name) || is_invalid_entry (f))
{
logprintf (LOG_VERBOSE, _(""Rejecting %s.\n""),
quote (f->name));
f = delelement (f, &start);
}
else
f = f->next;
}
if (*u->file)
{
if (action == GLOB_GLOBALL)
{
int (*matcher) (const char *, const char *, int)
= opt.ignore_case ? fnmatch_nocase : fnmatch;
int matchres = 0;
f = start;
while (f)
{
matchres = matcher (u->file, f->name, 0);
if (matchres == -1)
{
logprintf (LOG_NOTQUIET, _(""Error matching %s against %s: %s\n""),
u->file, quotearg_style (escape_quoting_style, f->name),
strerror (errno));
break;
}
if (matchres == FNM_NOMATCH)
f = delelement (f, &start); 
else
f = f->next;        
}
if (matchres == -1)
{
freefileinfo (start);
return RETRBADPATTERN;
}
}
else if (action == GLOB_GETONE)
{
#ifdef __VMS
int (*cmp) (const char *, const char *)
= opt.ignore_case ? strcasecmp : (int (*)())strcmp;
#else 
int (*cmp) (const char *, const char *)
= opt.ignore_case ? strcasecmp : strcmp;
#endif 
f = start;
while (f)
{
if (0 != cmp(u->file, f->name))
f = delelement (f, &start);
else
f = f->next;
}
}
}
if (start)
{
res = ftp_retrieve_list (u, start, con);
}
else
{
if (action == GLOB_GLOBALL)
{
logprintf (LOG_VERBOSE, _(""No matches on pattern %s.\n""),
quote (u->file));
}
else if (action == GLOB_GETONE) 
{
con->st |= ON_YOUR_OWN;
res = ftp_loop_internal (u, NULL, con, NULL, false);
return res;
}
}
freefileinfo (start);
if (opt.quota && total_downloaded_bytes > opt.quota)
return QUOTEXC;
else
return res;
}","static uerr_t
ftp_retrieve_glob (struct url *VAR_0, ccon *VAR_1, int VAR_2)
{
struct fileinfo *VAR_3, *VAR_4;
uerr_t VAR_5;
VAR_1->cmd |= VAR_6;
VAR_5 = ftp_get_listing (VAR_0, VAR_1, &VAR_4);
if (VAR_5 != VAR_7)
return VAR_5;
if (VAR_8.accepts || VAR_8.rejects)
{
VAR_3 = VAR_4;
while (VAR_3)
{
if (VAR_3->type != VAR_9 && !acceptable (VAR_3->name))
{
logprintf (VAR_10, _(""Rejecting %s.\n""),
quote (VAR_3->name));
VAR_3 = delelement (VAR_3, &VAR_4);
}
else
VAR_3 = VAR_3->next;
}
}
VAR_3 = VAR_4;
while (VAR_3)
{
if (has_insecure_name_p (VAR_3->name) || is_invalid_entry (VAR_3))
{
logprintf (VAR_10, _(""Rejecting %s.\n""),
quote (VAR_3->name));
VAR_3 = delelement (VAR_3, &VAR_4);
}
else
VAR_3 = VAR_3->next;
}
if (*VAR_0->file)
{
if (VAR_2 == VAR_11)
{
int (*VAR_12) (const char *, const char *, int)
= VAR_8.ignore_case ? VAR_13 : VAR_14;
int VAR_15 = 0;
VAR_3 = VAR_4;
while (VAR_3)
{
VAR_15 = VAR_12 (VAR_0->file, VAR_3->name, 0);
if (VAR_15 == -1)
{
logprintf (VAR_16, _(""Error matching %s against %s: %s\n""),
VAR_0->file, quotearg_style (VAR_17, VAR_3->name),
strerror (VAR_18));
break;
}
if (VAR_15 == VAR_19)
VAR_3 = delelement (VAR_3, &VAR_4); 
else
VAR_3 = VAR_3->next;        
}
if (VAR_15 == -1)
{
freefileinfo (VAR_4);
return VAR_20;
}
}
else if (VAR_2 == VAR_21)
{
#ifdef VAR_22
int (*VAR_23) (const char *, const char *)
= VAR_8.ignore_case ? VAR_24 : (int (*)())VAR_25;
#else 
int (*VAR_23) (const char *, const char *)
= VAR_8.ignore_case ? VAR_24 : VAR_25;
#endif 
VAR_3 = VAR_4;
while (VAR_3)
{
if (0 != VAR_23(VAR_0->file, VAR_3->name))
VAR_3 = delelement (VAR_3, &VAR_4);
else
VAR_3 = VAR_3->next;
}
}
}
if (VAR_4)
{
VAR_5 = ftp_retrieve_list (VAR_0, VAR_4, VAR_1);
}
else
{
if (VAR_2 == VAR_11)
{
logprintf (VAR_10, _(""No matches on pattern %s.\n""),
quote (VAR_0->file));
}
else if (VAR_2 == VAR_21) 
{
VAR_1->st |= VAR_26;
VAR_5 = ftp_loop_internal (VAR_0, NULL, VAR_1, NULL, false);
return VAR_5;
}
}
freefileinfo (VAR_4);
if (VAR_8.quota && VAR_27 > VAR_8.quota)
return VAR_28;
else
return VAR_5;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/2.json,"static uerr_t
ftp_retrieve_glob (struct url *u, struct url *original_url,
                   ccon *con, int action)
{
  struct fileinfo *f, *start;
  uerr_t res;

  con->cmd |= LEAVE_PENDING;

  res = ftp_get_listing (u, original_url, con, &start);
  if (res != RETROK)
    return res;
  /* First: weed out that do not conform the global rules given in
     opt.accepts and opt.rejects.  */
  if (opt.accepts || opt.rejects)
    {
      f = start;
      while (f)
        {
          if (f->type != FT_DIRECTORY && !acceptable (f->name))
            {
              logprintf (LOG_VERBOSE, _(""Rejecting %s.\n""),
                         quote (f->name));
              f = delelement (f, &start);
            }
          else
            f = f->next;
        }
    }
  /* Remove all files with possible harmful names or invalid entries. */
  f = start;
  while (f)
    {
      if (has_insecure_name_p (f->name) || is_invalid_entry (f))
        {
          logprintf (LOG_VERBOSE, _(""Rejecting %s.\n""),
                     quote (f->name));
          f = delelement (f, &start);
        }
      else
        f = f->next;
    }
  /* Now weed out the files that do not match our globbing pattern.
     If we are dealing with a globbing pattern, that is.  */
  if (*u->file)
    {
      if (action == GLOB_GLOBALL)
        {
          int (*matcher) (const char *, const char *, int)
            = opt.ignore_case ? fnmatch_nocase : fnmatch;
          int matchres = 0;

          f = start;
          while (f)
            {
              matchres = matcher (u->file, f->name, 0);
              if (matchres == -1)
                {
                  logprintf (LOG_NOTQUIET, _(""Error matching %s against %s: %s\n""),
                             u->file, quotearg_style (escape_quoting_style, f->name),
                             strerror (errno));
                  break;
                }
              if (matchres == FNM_NOMATCH)
                f = delelement (f, &start); /* delete the element from the list */
              else
                f = f->next;        /* leave the element in the list */
            }
          if (matchres == -1)
            {
              freefileinfo (start);
              return RETRBADPATTERN;
            }
        }
      else if (action == GLOB_GETONE)
        {
#ifdef __VMS
          /* 2009-09-09 SMS.
           * Odd-ball compiler (""HP C V7.3-009 on OpenVMS Alpha V7.3-2"")
           * bug causes spurious %CC-E-BADCONDIT complaint with this
           * ""?:"" statement.  (Different linkage attributes for strcmp()
           * and strcasecmp().)  Converting to ""if"" changes the
           * complaint to %CC-W-PTRMISMATCH on ""cmp = strcmp;"".  Adding
           * the senseless type cast clears the complaint, and looks
           * harmless.
           */
          int (*cmp) (const char *, const char *)
            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;
#else /* def __VMS */
          int (*cmp) (const char *, const char *)
            = opt.ignore_case ? strcasecmp : strcmp;
#endif /* def __VMS [else] */
          f = start;
          while (f)
            {
              if (0 != cmp(u->file, f->name))
                f = delelement (f, &start);
              else
                f = f->next;
            }
        }
    }
  if (start)
    {
      /* Just get everything.  */
      res = ftp_retrieve_list (u, original_url, start, con);
    }
  else
    {
      if (action == GLOB_GLOBALL)
        {
          /* No luck.  */
          /* #### This message SUCKS.  We should see what was the
             reason that nothing was retrieved.  */
          logprintf (LOG_VERBOSE, _(""No matches on pattern %s.\n""),
                     quote (u->file));
        }
      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */
        {
          /* Let's try retrieving it anyway.  */
          con->st |= ON_YOUR_OWN;
          res = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
          return res;
        }

      /* If action == GLOB_GETALL, and the file list is empty, there's
         no point in trying to download anything or in complaining about
         it.  (An empty directory should not cause complaints.)
      */
    }
  freefileinfo (start);
  if (opt.quota && total_downloaded_bytes > opt.quota)
    return QUOTEXC;
  else
    return res;
}","static uerr_t
ftp_retrieve_glob (struct url *VAR_0, struct url *VAR_1,
                   ccon *VAR_2, int VAR_3)
{
  struct fileinfo *VAR_4, *VAR_5;
  uerr_t VAR_6;

  VAR_2->cmd |= VAR_7;

  VAR_6 = ftp_get_listing (VAR_0, VAR_1, VAR_2, &VAR_5);
  if (VAR_6 != VAR_8)
    return VAR_6;
  /* COMMENT_0 */
                                     
  if (VAR_9.accepts || VAR_9.rejects)
    {
      VAR_4 = VAR_5;
      while (VAR_4)
        {
          if (VAR_4->type != VAR_10 && !acceptable (VAR_4->name))
            {
              logprintf (VAR_11, _(""Rejecting %s.\n""),
                         quote (VAR_4->name));
              VAR_4 = delelement (VAR_4, &VAR_5);
            }
          else
            VAR_4 = VAR_4->next;
        }
    }
  /* COMMENT_2 */
  VAR_4 = VAR_5;
  while (VAR_4)
    {
      if (has_insecure_name_p (VAR_4->name) || is_invalid_entry (VAR_4))
        {
          logprintf (VAR_11, _(""Rejecting %s.\n""),
                     quote (VAR_4->name));
          VAR_4 = delelement (VAR_4, &VAR_5);
        }
      else
        VAR_4 = VAR_4->next;
    }
  /* COMMENT_3 */
                                                            
  if (*VAR_0->file)
    {
      if (VAR_3 == VAR_12)
        {
          int (*VAR_13) (const char *, const char *, int)
            = VAR_9.ignore_case ? VAR_14 : VAR_15;
          int VAR_16 = 0;

          VAR_4 = VAR_5;
          while (VAR_4)
            {
              VAR_16 = VAR_13 (VAR_0->file, VAR_4->name, 0);
              if (VAR_16 == -1)
                {
                  logprintf (VAR_17, _(""Error matching %s against %s: %s\n""),
                             VAR_0->file, quotearg_style (VAR_18, VAR_4->name),
                             strerror (VAR_19));
                  break;
                }
              if (VAR_16 == VAR_20)
                VAR_4 = delelement (VAR_4, &VAR_5); /* COMMENT_5 */
              else
                VAR_4 = VAR_4->next;        /* COMMENT_6 */
            }
          if (VAR_16 == -1)
            {
              freefileinfo (VAR_5);
              return VAR_21;
            }
        }
      else if (VAR_3 == VAR_22)
        {
#ifdef VAR_23
          /* COMMENT_7 */
                                                                        
                                                                    
                                                                        
                                                               
                                                                       
                                                                    
                      
             
          int (*VAR_24) (const char *, const char *)
            = VAR_9.ignore_case ? VAR_25 : (int (*)())VAR_26;
#else /* COMMENT_16 */
          int (*VAR_24) (const char *, const char *)
            = VAR_9.ignore_case ? VAR_25 : VAR_26;
#endif /* COMMENT_17 */
          VAR_4 = VAR_5;
          while (VAR_4)
            {
              if (0 != VAR_24(VAR_0->file, VAR_4->name))
                VAR_4 = delelement (VAR_4, &VAR_5);
              else
                VAR_4 = VAR_4->next;
            }
        }
    }
  if (VAR_5)
    {
      /* COMMENT_18 */
      VAR_6 = ftp_retrieve_list (VAR_0, VAR_1, VAR_5, VAR_2);
    }
  else
    {
      if (VAR_3 == VAR_12)
        {
          /* COMMENT_19 */
          /* COMMENT_20 */
                                                   
          logprintf (VAR_11, _(""No matches on pattern %s.\n""),
                     quote (VAR_0->file));
        }
      else if (VAR_3 == VAR_22) /* COMMENT_22 */
        {
          /* COMMENT_23 */
          VAR_2->st |= VAR_27;
          VAR_6 = ftp_loop_internal (VAR_0, VAR_1, NULL, VAR_2, NULL, false);
          return VAR_6;
        }

      /* COMMENT_24 */
                                                                        
                                                               
        
    }
  freefileinfo (VAR_5);
  if (VAR_9.quota && VAR_28 > VAR_9.quota)
    return VAR_29;
  else
    return VAR_6;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,12 +1,13 @@
 static uerr_t
-ftp_retrieve_glob (struct url *u, ccon *con, int action)
+ftp_retrieve_glob (struct url *u, struct url *original_url,
+                   ccon *con, int action)
 {
   struct fileinfo *f, *start;
   uerr_t res;
 
   con->cmd |= LEAVE_PENDING;
 
-  res = ftp_get_listing (u, con, &start);
+  res = ftp_get_listing (u, original_url, con, &start);
   if (res != RETROK)
     return res;
   /* First: weed out that do not conform the global rules given in
@@ -102,7 +103,7 @@
   if (start)
     {
       /* Just get everything.  */
-      res = ftp_retrieve_list (u, start, con);
+      res = ftp_retrieve_list (u, original_url, start, con);
     }
   else
     {
@@ -118,7 +119,7 @@
         {
           /* Let's try retrieving it anyway.  */
           con->st |= ON_YOUR_OWN;
-          res = ftp_loop_internal (u, NULL, con, NULL, false);
+          res = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
           return res;
         }
 ","{'deleted_lines': ['ftp_retrieve_glob (struct url *u, ccon *con, int action)', '  res = ftp_get_listing (u, con, &start);', '      res = ftp_retrieve_list (u, start, con);', '          res = ftp_loop_internal (u, NULL, con, NULL, false);'], 'added_lines': ['ftp_retrieve_glob (struct url *u, struct url *original_url,', '                   ccon *con, int action)', '  res = ftp_get_listing (u, original_url, con, &start);', '      res = ftp_retrieve_list (u, original_url, start, con);', '          res = ftp_loop_internal (u, original_url, NULL, con, NULL, false);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_retrieve_dirs,"static uerr_t
ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)
{
char *container = NULL;
int container_size = 0;
for (; f; f = f->next)
{
int size;
char *odir, *newdir;
if (opt.quota && total_downloaded_bytes > opt.quota)
break;
if (f->type != FT_DIRECTORY)
continue;
size = strlen (u->dir) + 1 + strlen (f->name) + 1;
if (size > container_size)
container = (char *)alloca (size);
newdir = container;
odir = u->dir;
if (*odir == '\0'
|| (*odir == '/' && *(odir + 1) == '\0'))
sprintf (newdir, ""%s%s"", odir, f->name);
else
sprintf (newdir, ""%s/%s"", odir, f->name);
DEBUGP ((""Composing new CWD relative to the initial directory.\n""));
DEBUGP ((""  odir = '%s'\n  f->name = '%s'\n  newdir = '%s'\n\n"",
odir, f->name, newdir));
if (!accdir (newdir))
{
logprintf (LOG_VERBOSE, _(""\
Not descending to %s as it is excluded/not-included.\n""),
quote (newdir));
continue;
}
con->st &= ~DONE_CWD;
odir = xstrdup (u->dir);  
url_set_dir (u, newdir);
ftp_retrieve_glob (u, con, GLOB_GETALL);
url_set_dir (u, odir);
xfree (odir);
}
if (opt.quota && total_downloaded_bytes > opt.quota)
return QUOTEXC;
else
return RETROK;
}","static uerr_t
ftp_retrieve_dirs (struct url *VAR_0, struct fileinfo *VAR_1, ccon *VAR_2)
{
char *VAR_3 = NULL;
int VAR_4 = 0;
for (; VAR_1; VAR_1 = VAR_1->next)
{
int VAR_5;
char *VAR_6, *VAR_7;
if (VAR_8.quota && VAR_9 > VAR_8.quota)
break;
if (VAR_1->type != VAR_10)
continue;
VAR_5 = strlen (VAR_0->dir) + 1 + strlen (VAR_1->name) + 1;
if (VAR_5 > VAR_4)
VAR_3 = (char *)alloca (VAR_5);
VAR_7 = VAR_3;
VAR_6 = VAR_0->dir;
if (*VAR_6 == '\0'
|| (*VAR_6 == '/' && *(VAR_6 + 1) == '\0'))
sprintf (VAR_7, ""%s%s"", VAR_6, VAR_1->name);
else
sprintf (VAR_7, ""%s/%s"", VAR_6, VAR_1->name);
DEBUGP ((""Composing new CWD relative to the initial directory.\n""));
DEBUGP ((""  odir = '%s'\n  f->name = '%s'\n  newdir = '%s'\n\n"",
VAR_6, VAR_1->name, VAR_7));
if (!accdir (VAR_7))
{
logprintf (VAR_11, _(""\
Not descending to %s as it is excluded/not-included.\n""),
quote (VAR_7));
continue;
}
VAR_2->st &= ~VAR_12;
VAR_6 = xstrdup (VAR_0->dir);  
url_set_dir (VAR_0, VAR_7);
ftp_retrieve_glob (VAR_0, VAR_2, VAR_13);
url_set_dir (VAR_0, VAR_6);
xfree (VAR_6);
}
if (VAR_8.quota && VAR_9 > VAR_8.quota)
return VAR_14;
else
return VAR_15;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/3.json,"static uerr_t
ftp_retrieve_dirs (struct url *u, struct url *original_url,
                   struct fileinfo *f, ccon *con)
{
  char *container = NULL;
  int container_size = 0;

  for (; f; f = f->next)
    {
      int size;
      char *odir, *newdir;

      if (opt.quota && total_downloaded_bytes > opt.quota)
        break;
      if (f->type != FT_DIRECTORY)
        continue;

      /* Allocate u->dir off stack, but reallocate only if a larger
         string is needed.  It's a pity there's no ""realloca"" for an
         item on the bottom of the stack.  */
      size = strlen (u->dir) + 1 + strlen (f->name) + 1;
      if (size > container_size)
        container = (char *)alloca (size);
      newdir = container;

      odir = u->dir;
      if (*odir == '\0'
          || (*odir == '/' && *(odir + 1) == '\0'))
        /* If ODIR is empty or just ""/"", simply append f->name to
           ODIR.  (In the former case, to preserve u->dir being
           relative; in the latter case, to avoid double slash.)  */
        sprintf (newdir, ""%s%s"", odir, f->name);
      else
        /* Else, use a separator. */
        sprintf (newdir, ""%s/%s"", odir, f->name);

      DEBUGP ((""Composing new CWD relative to the initial directory.\n""));
      DEBUGP ((""  odir = '%s'\n  f->name = '%s'\n  newdir = '%s'\n\n"",
               odir, f->name, newdir));
      if (!accdir (newdir))
        {
          logprintf (LOG_VERBOSE, _(""\
Not descending to %s as it is excluded/not-included.\n""),
                     quote (newdir));
          continue;
        }

      con->st &= ~DONE_CWD;

      odir = xstrdup (u->dir);  /* because url_set_dir will free
                                   u->dir. */
      url_set_dir (u, newdir);
      ftp_retrieve_glob (u, original_url, con, GLOB_GETALL);
      url_set_dir (u, odir);
      xfree (odir);

      /* Set the time-stamp?  */
    }

  if (opt.quota && total_downloaded_bytes > opt.quota)
    return QUOTEXC;
  else
    return RETROK;
}","static uerr_t
ftp_retrieve_dirs (struct url *VAR_0, struct url *VAR_1,
                   struct fileinfo *VAR_2, ccon *VAR_3)
{
  char *VAR_4 = NULL;
  int VAR_5 = 0;

  for (; VAR_2; VAR_2 = VAR_2->next)
    {
      int VAR_6;
      char *VAR_7, *VAR_8;

      if (VAR_9.quota && VAR_10 > VAR_9.quota)
        break;
      if (VAR_2->type != VAR_11)
        continue;

      /* COMMENT_0 */
                                                                    
                                             
      VAR_6 = strlen (VAR_0->dir) + 1 + strlen (VAR_2->name) + 1;
      if (VAR_6 > VAR_5)
        VAR_4 = (char *)alloca (VAR_6);
      VAR_8 = VAR_4;

      VAR_7 = VAR_0->dir;
      if (*VAR_7 == '\0'
          || (*VAR_7 == '/' && *(VAR_7 + 1) == '\0'))
        /* COMMENT_3 */
                                                               
                                                                    
        sprintf (VAR_8, ""%s%s"", VAR_7, VAR_2->name);
      else
        /* COMMENT_6 */
        sprintf (VAR_8, ""%s/%s"", VAR_7, VAR_2->name);

      DEBUGP ((""Composing new CWD relative to the initial directory.\n""));
      DEBUGP ((""  odir = '%s'\n  f->name = '%s'\n  newdir = '%s'\n\n"",
               VAR_7, VAR_2->name, VAR_8));
      if (!accdir (VAR_8))
        {
          logprintf (VAR_12, _(""\
Not descending to %s as it is excluded/not-included.\n""),
                     quote (VAR_8));
          continue;
        }

      VAR_3->st &= ~VAR_13;

      VAR_7 = xstrdup (VAR_0->dir);  /* COMMENT_7 */
                                             
      url_set_dir (VAR_0, VAR_8);
      ftp_retrieve_glob (VAR_0, VAR_1, VAR_3, VAR_14);
      url_set_dir (VAR_0, VAR_7);
      xfree (VAR_7);

      /* COMMENT_9 */
    }

  if (VAR_9.quota && VAR_10 > VAR_9.quota)
    return VAR_15;
  else
    return VAR_16;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static uerr_t
-ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)
+ftp_retrieve_dirs (struct url *u, struct url *original_url,
+                   struct fileinfo *f, ccon *con)
 {
   char *container = NULL;
   int container_size = 0;
@@ -49,7 +50,7 @@
       odir = xstrdup (u->dir);  /* because url_set_dir will free
                                    u->dir. */
       url_set_dir (u, newdir);
-      ftp_retrieve_glob (u, con, GLOB_GETALL);
+      ftp_retrieve_glob (u, original_url, con, GLOB_GETALL);
       url_set_dir (u, odir);
       xfree (odir);
 ","{'deleted_lines': ['ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)', '      ftp_retrieve_glob (u, con, GLOB_GETALL);'], 'added_lines': ['ftp_retrieve_dirs (struct url *u, struct url *original_url,', '                   struct fileinfo *f, ccon *con)', '      ftp_retrieve_glob (u, original_url, con, GLOB_GETALL);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_loop,"uerr_t
ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,
bool recursive, bool glob)
{
ccon con;                     
uerr_t res;
*dt = 0;
xzero (con);
con.csock = -1;
con.st = ON_YOUR_OWN;
con.rs = ST_UNIX;
con.id = NULL;
con.proxy = proxy;
if (!*u->file && !recursive)
{
struct fileinfo *f;
res = ftp_get_listing (u, &con, &f);
if (res == RETROK)
{
if (opt.htmlify && !opt.spider)
{
char *filename = (opt.output_document
? xstrdup (opt.output_document)
: (con.target ? xstrdup (con.target)
: url_file_name (u, NULL)));
res = ftp_index (filename, u, f);
if (res == FTPOK && opt.verbose)
{
if (!opt.output_document)
{
struct_stat st;
wgint sz;
if (stat (filename, &st) == 0)
sz = st.st_size;
else
sz = -1;
logprintf (LOG_NOTQUIET,
_(""Wrote HTML-ized index to %s [%s].\n""),
quote (filename), number_to_static_string (sz));
}
else
logprintf (LOG_NOTQUIET,
_(""Wrote HTML-ized index to %s.\n""),
quote (filename));
}
xfree (filename);
}
freefileinfo (f);
}
}
else
{
bool ispattern = false;
if (glob)
{
char *file_part = strrchr (u->path, '/');
if (!file_part)
file_part = u->path;
ispattern = has_wildcards_p (file_part);
}
if (ispattern || recursive || opt.timestamping || opt.preserve_perm)
{
res = ftp_retrieve_glob (u, &con,
ispattern ? GLOB_GLOBALL : GLOB_GETONE);
}
else
res = ftp_loop_internal (u, NULL, &con, local_file, false);
}
if (res == FTPOK)
res = RETROK;
if (res == RETROK)
*dt |= RETROKF;
if (con.csock != -1)
fd_close (con.csock);
xfree (con.id);
xfree (con.target);
return res;
}","uerr_t
ftp_loop (struct url *VAR_0, char **VAR_1, int *VAR_2, struct url *VAR_3,
bool VAR_4, bool VAR_5)
{
ccon VAR_6;                     
uerr_t VAR_7;
*VAR_2 = 0;
xzero (VAR_6);
VAR_6.csock = -1;
VAR_6.st = VAR_8;
VAR_6.rs = VAR_9;
VAR_6.id = NULL;
VAR_6.proxy = VAR_3;
if (!*VAR_0->file && !VAR_4)
{
struct fileinfo *VAR_10;
VAR_7 = ftp_get_listing (VAR_0, &VAR_6, &VAR_10);
if (VAR_7 == VAR_11)
{
if (VAR_12.htmlify && !VAR_12.spider)
{
char *VAR_13 = (VAR_12.output_document
? xstrdup (VAR_12.output_document)
: (VAR_6.target ? xstrdup (VAR_6.target)
: url_file_name (VAR_0, NULL)));
VAR_7 = ftp_index (VAR_13, VAR_0, VAR_10);
if (VAR_7 == VAR_14 && VAR_12.verbose)
{
if (!VAR_12.output_document)
{
struct_stat VAR_15;
wgint VAR_16;
if (stat (VAR_13, &VAR_15) == 0)
VAR_16 = VAR_15.st_size;
else
VAR_16 = -1;
logprintf (VAR_17,
_(""Wrote HTML-ized index to %s [%s].\n""),
quote (VAR_13), number_to_static_string (VAR_16));
}
else
logprintf (VAR_17,
_(""Wrote HTML-ized index to %s.\n""),
quote (VAR_13));
}
xfree (VAR_13);
}
freefileinfo (VAR_10);
}
}
else
{
bool VAR_18 = false;
if (VAR_5)
{
char *VAR_19 = strrchr (VAR_0->path, '/');
if (!VAR_19)
VAR_19 = VAR_0->path;
VAR_18 = has_wildcards_p (VAR_19);
}
if (VAR_18 || VAR_4 || VAR_12.timestamping || VAR_12.preserve_perm)
{
VAR_7 = ftp_retrieve_glob (VAR_0, &VAR_6,
VAR_18 ? VAR_20 : VAR_21);
}
else
VAR_7 = ftp_loop_internal (VAR_0, NULL, &VAR_6, VAR_1, false);
}
if (VAR_7 == VAR_14)
VAR_7 = VAR_11;
if (VAR_7 == VAR_11)
*VAR_2 |= VAR_22;
if (VAR_6.csock != -1)
fd_close (VAR_6.csock);
xfree (VAR_6.id);
xfree (VAR_6.target);
return VAR_7;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/4.json,"uerr_t
ftp_loop (struct url *u, struct url *original_url, char **local_file, int *dt,
          struct url *proxy, bool recursive, bool glob)
{
  ccon con;                     /* FTP connection */
  uerr_t res;

  *dt = 0;

  xzero (con);

  con.csock = -1;
  con.st = ON_YOUR_OWN;
  con.rs = ST_UNIX;
  con.id = NULL;
  con.proxy = proxy;

  /* If the file name is empty, the user probably wants a directory
     index.  We'll provide one, properly HTML-ized.  Unless
     opt.htmlify is 0, of course.  :-) */
  if (!*u->file && !recursive)
    {
      struct fileinfo *f;
      res = ftp_get_listing (u, original_url, &con, &f);

      if (res == RETROK)
        {
          if (opt.htmlify && !opt.spider)
            {
              struct url *url_file = opt.trustservernames ? u : original_url;
              char *filename = (opt.output_document
                                ? xstrdup (opt.output_document)
                                : (con.target ? xstrdup (con.target)
                                   : url_file_name (url_file, NULL)));
              res = ftp_index (filename, u, f);
              if (res == FTPOK && opt.verbose)
                {
                  if (!opt.output_document)
                    {
                      struct_stat st;
                      wgint sz;
                      if (stat (filename, &st) == 0)
                        sz = st.st_size;
                      else
                        sz = -1;
                      logprintf (LOG_NOTQUIET,
                                 _(""Wrote HTML-ized index to %s [%s].\n""),
                                 quote (filename), number_to_static_string (sz));
                    }
                  else
                    logprintf (LOG_NOTQUIET,
                               _(""Wrote HTML-ized index to %s.\n""),
                               quote (filename));
                }
              xfree (filename);
            }
          freefileinfo (f);
        }
    }
  else
    {
      bool ispattern = false;
      if (glob)
        {
          /* Treat the URL as a pattern if the file name part of the
             URL path contains wildcards.  (Don't check for u->file
             because it is unescaped and therefore doesn't leave users
             the option to escape literal '*' as %2A.)  */
          char *file_part = strrchr (u->path, '/');
          if (!file_part)
            file_part = u->path;
          ispattern = has_wildcards_p (file_part);
        }
      if (ispattern || recursive || opt.timestamping || opt.preserve_perm)
        {
          /* ftp_retrieve_glob is a catch-all function that gets called
             if we need globbing, time-stamping, recursion or preserve
             permissions.  Its third argument is just what we really need.  */
          res = ftp_retrieve_glob (u, original_url, &con,
                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);
        }
      else
        {
          res = ftp_loop_internal (u, original_url, NULL, &con, local_file, false);
        }
    }
  if (res == FTPOK)
    res = RETROK;
  if (res == RETROK)
    *dt |= RETROKF;
  /* If a connection was left, quench it.  */
  if (con.csock != -1)
    fd_close (con.csock);
  xfree (con.id);
  xfree (con.target);
  return res;
}","uerr_t
ftp_loop (struct url *VAR_0, struct url *VAR_1, char **VAR_2, int *VAR_3,
          struct url *VAR_4, bool VAR_5, bool VAR_6)
{
  ccon VAR_7;                     /* COMMENT_0 */
  uerr_t VAR_8;

  *VAR_3 = 0;

  xzero (VAR_7);

  VAR_7.csock = -1;
  VAR_7.st = VAR_9;
  VAR_7.rs = VAR_10;
  VAR_7.id = NULL;
  VAR_7.proxy = VAR_4;

  /* COMMENT_1 */
                                                           
                                         
  if (!*VAR_0->file && !VAR_5)
    {
      struct fileinfo *VAR_11;
      VAR_8 = ftp_get_listing (VAR_0, VAR_1, &VAR_7, &VAR_11);

      if (VAR_8 == VAR_12)
        {
          if (VAR_13.htmlify && !VAR_13.spider)
            {
              struct url *VAR_14 = VAR_13.trustservernames ? VAR_0 : VAR_1;
              char *VAR_15 = (VAR_13.output_document
                                ? xstrdup (VAR_13.output_document)
                                : (VAR_7.target ? xstrdup (VAR_7.target)
                                   : url_file_name (VAR_14, NULL)));
              VAR_8 = ftp_index (VAR_15, VAR_0, VAR_11);
              if (VAR_8 == VAR_16 && VAR_13.verbose)
                {
                  if (!VAR_13.output_document)
                    {
                      struct_stat VAR_17;
                      wgint VAR_18;
                      if (stat (VAR_15, &VAR_17) == 0)
                        VAR_18 = VAR_17.st_size;
                      else
                        VAR_18 = -1;
                      logprintf (VAR_19,
                                 _(""Wrote HTML-ized index to %s [%s].\n""),
                                 quote (VAR_15), number_to_static_string (VAR_18));
                    }
                  else
                    logprintf (VAR_19,
                               _(""Wrote HTML-ized index to %s.\n""),
                               quote (VAR_15));
                }
              xfree (VAR_15);
            }
          freefileinfo (VAR_11);
        }
    }
  else
    {
      bool VAR_20 = false;
      if (VAR_6)
        {
          /* COMMENT_4 */
                                                                   
                                                                      
                                                          
          char *VAR_21 = strrchr (VAR_0->path, '/');
          if (!VAR_21)
            VAR_21 = VAR_0->path;
          VAR_20 = has_wildcards_p (VAR_21);
        }
      if (VAR_20 || VAR_5 || VAR_13.timestamping || VAR_13.preserve_perm)
        {
          /* COMMENT_8 */
                                                                      
                                                                              
          VAR_8 = ftp_retrieve_glob (VAR_0, VAR_1, &VAR_7,
                                   VAR_20 ? VAR_22 : VAR_23);
        }
      else
        {
          VAR_8 = ftp_loop_internal (VAR_0, VAR_1, NULL, &VAR_7, VAR_2, false);
        }
    }
  if (VAR_8 == VAR_16)
    VAR_8 = VAR_12;
  if (VAR_8 == VAR_12)
    *VAR_3 |= VAR_24;
  /* COMMENT_11 */
  if (VAR_7.csock != -1)
    fd_close (VAR_7.csock);
  xfree (VAR_7.id);
  xfree (VAR_7.target);
  return VAR_8;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 uerr_t
-ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,
-          bool recursive, bool glob)
+ftp_loop (struct url *u, struct url *original_url, char **local_file, int *dt,
+          struct url *proxy, bool recursive, bool glob)
 {
   ccon con;                     /* FTP connection */
   uerr_t res;
@@ -21,16 +21,17 @@
   if (!*u->file && !recursive)
     {
       struct fileinfo *f;
-      res = ftp_get_listing (u, &con, &f);
+      res = ftp_get_listing (u, original_url, &con, &f);
 
       if (res == RETROK)
         {
           if (opt.htmlify && !opt.spider)
             {
+              struct url *url_file = opt.trustservernames ? u : original_url;
               char *filename = (opt.output_document
                                 ? xstrdup (opt.output_document)
                                 : (con.target ? xstrdup (con.target)
-                                   : url_file_name (u, NULL)));
+                                   : url_file_name (url_file, NULL)));
               res = ftp_index (filename, u, f);
               if (res == FTPOK && opt.verbose)
                 {
@@ -75,11 +76,13 @@
           /* ftp_retrieve_glob is a catch-all function that gets called
              if we need globbing, time-stamping, recursion or preserve
              permissions.  Its third argument is just what we really need.  */
-          res = ftp_retrieve_glob (u, &con,
+          res = ftp_retrieve_glob (u, original_url, &con,
                                    ispattern ? GLOB_GLOBALL : GLOB_GETONE);
         }
       else
-        res = ftp_loop_internal (u, NULL, &con, local_file, false);
+        {
+          res = ftp_loop_internal (u, original_url, NULL, &con, local_file, false);
+        }
     }
   if (res == FTPOK)
     res = RETROK;","{'deleted_lines': ['ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,', '          bool recursive, bool glob)', '      res = ftp_get_listing (u, &con, &f);', '                                   : url_file_name (u, NULL)));', '          res = ftp_retrieve_glob (u, &con,', '        res = ftp_loop_internal (u, NULL, &con, local_file, false);'], 'added_lines': ['ftp_loop (struct url *u, struct url *original_url, char **local_file, int *dt,', '          struct url *proxy, bool recursive, bool glob)', '      res = ftp_get_listing (u, original_url, &con, &f);', '              struct url *url_file = opt.trustservernames ? u : original_url;', '                                   : url_file_name (url_file, NULL)));', '          res = ftp_retrieve_glob (u, original_url, &con,', '        {', '          res = ftp_loop_internal (u, original_url, NULL, &con, local_file, false);', '        }']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-4971,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,wget,"If not --trust-server-names is used, FTP will also get the destination
file name from the original url specified by the user instead of the
redirected url.  Closes CVE-2016-4971.

* src/ftp.c (ftp_get_listing): Add argument original_url.
(getftp): Likewise.
(ftp_loop_internal): Likewise.  Use original_url to generate the
file name if --trust-server-names is not provided.
(ftp_retrieve_glob): Likewise.
(ftp_loop): Likewise.

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
",e996e322ffd42aaa051602da182d03178d0f13e1,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,src/ftp.c,ftp_get_listing,"static uerr_t
ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
{
uerr_t err;
char *uf;                     
char *lf;                     
char *old_target = con->target;
con->st &= ~ON_YOUR_OWN;
con->cmd |= (DO_LIST | LEAVE_PENDING);
con->cmd &= ~DO_RETR;
uf = url_file_name (u, NULL);
lf = file_merge (uf, LIST_FILENAME);
xfree (uf);
DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (lf)));
con->target = xstrdup (lf);
xfree (lf);
err = ftp_loop_internal (u, NULL, con, NULL, false);
lf = xstrdup (con->target);
xfree (con->target);
con->target = old_target;
if (err == RETROK)
{
*f = ftp_parse_ls (lf, con->rs);
if (opt.remove_listing)
{
if (unlink (lf))
logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
else
logprintf (LOG_VERBOSE, _(""Removed %s.\n""), quote (lf));
}
}
else
*f = NULL;
xfree (lf);
con->cmd &= ~DO_LIST;
return err;
}","static uerr_t
ftp_get_listing (struct url *VAR_0, ccon *VAR_1, struct fileinfo **VAR_2)
{
uerr_t VAR_3;
char *VAR_4;                     
char *VAR_5;                     
char *VAR_6 = VAR_1->target;
VAR_1->st &= ~VAR_7;
VAR_1->cmd |= (VAR_8 | VAR_9);
VAR_1->cmd &= ~VAR_10;
VAR_4 = url_file_name (VAR_0, NULL);
VAR_5 = file_merge (VAR_4, VAR_11);
xfree (VAR_4);
DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (VAR_5)));
VAR_1->target = xstrdup (VAR_5);
xfree (VAR_5);
VAR_3 = ftp_loop_internal (VAR_0, NULL, VAR_1, NULL, false);
VAR_5 = xstrdup (VAR_1->target);
xfree (VAR_1->target);
VAR_1->target = VAR_6;
if (VAR_3 == VAR_12)
{
*VAR_2 = ftp_parse_ls (VAR_5, VAR_1->rs);
if (VAR_13.remove_listing)
{
if (unlink (VAR_5))
logprintf (VAR_14, ""unlink: %s\n"", strerror (VAR_15));
else
logprintf (VAR_16, _(""Removed %s.\n""), quote (VAR_5));
}
}
else
*VAR_2 = NULL;
xfree (VAR_5);
VAR_1->cmd &= ~VAR_8;
return VAR_3;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/before/5.json,"static uerr_t
ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
                 struct fileinfo **f)
{
  uerr_t err;
  char *uf;                     /* url file name */
  char *lf;                     /* list file name */
  char *old_target = con->target;

  con->st &= ~ON_YOUR_OWN;
  con->cmd |= (DO_LIST | LEAVE_PENDING);
  con->cmd &= ~DO_RETR;

  /* Find the listing file name.  We do it by taking the file name of
     the URL and replacing the last component with the listing file
     name.  */
  uf = url_file_name (u, NULL);
  lf = file_merge (uf, LIST_FILENAME);
  xfree (uf);
  DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (lf)));

  con->target = xstrdup (lf);
  xfree (lf);
  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
  lf = xstrdup (con->target);
  xfree (con->target);
  con->target = old_target;

  if (err == RETROK)
    {
      *f = ftp_parse_ls (lf, con->rs);
      if (opt.remove_listing)
        {
          if (unlink (lf))
            logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
          else
            logprintf (LOG_VERBOSE, _(""Removed %s.\n""), quote (lf));
        }
    }
  else
    *f = NULL;
  xfree (lf);
  con->cmd &= ~DO_LIST;
  return err;
}","static uerr_t
ftp_get_listing (struct url *VAR_0, struct url *VAR_1, ccon *VAR_2,
                 struct fileinfo **VAR_3)
{
  uerr_t VAR_4;
  char *VAR_5;                     /* COMMENT_0 */
  char *VAR_6;                     /* COMMENT_1 */
  char *VAR_7 = VAR_2->target;

  VAR_2->st &= ~VAR_8;
  VAR_2->cmd |= (VAR_9 | VAR_10);
  VAR_2->cmd &= ~VAR_11;

  /* COMMENT_2 */
                                                                   
              
  VAR_5 = url_file_name (VAR_0, NULL);
  VAR_6 = file_merge (VAR_5, VAR_12);
  xfree (VAR_5);
  DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (VAR_6)));

  VAR_2->target = xstrdup (VAR_6);
  xfree (VAR_6);
  VAR_4 = ftp_loop_internal (VAR_0, VAR_1, NULL, VAR_2, NULL, false);
  VAR_6 = xstrdup (VAR_2->target);
  xfree (VAR_2->target);
  VAR_2->target = VAR_7;

  if (VAR_4 == VAR_13)
    {
      *VAR_3 = ftp_parse_ls (VAR_6, VAR_2->rs);
      if (VAR_14.remove_listing)
        {
          if (unlink (VAR_6))
            logprintf (VAR_15, ""unlink: %s\n"", strerror (VAR_16));
          else
            logprintf (VAR_17, _(""Removed %s.\n""), quote (VAR_6));
        }
    }
  else
    *VAR_3 = NULL;
  xfree (VAR_6);
  VAR_2->cmd &= ~VAR_9;
  return VAR_4;
}",wget/e996e322ffd42aaa051602da182d03178d0f13e1/ftp.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static uerr_t
-ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
+ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
+                 struct fileinfo **f)
 {
   uerr_t err;
   char *uf;                     /* url file name */
@@ -20,7 +21,7 @@
 
   con->target = xstrdup (lf);
   xfree (lf);
-  err = ftp_loop_internal (u, NULL, con, NULL, false);
+  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
   lf = xstrdup (con->target);
   xfree (con->target);
   con->target = old_target;","{'deleted_lines': ['ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)', '  err = ftp_loop_internal (u, NULL, con, NULL, false);'], 'added_lines': ['ftp_get_listing (struct url *u, struct url *original_url, ccon *con,', '                 struct fileinfo **f)', '  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);']}",True,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,8.8,HIGH,2,valid,,5
CVE-2016-3747,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE mm-video-v4l2: venc: Avoid processing ETBs/FTBs in invalid states

(per the spec) ETB/FTB should not be handled in states other than
Executing, Paused and Idle. This avoids accessing invalid buffers.
Also add a lock to protect the private-buffers from being deleted
while accessing from another thread.

Bug: 27903498
Security Vulnerability - Heap Use-After-Free and Possible LPE in
MediaServer (libOmxVenc problem #3)

CRs-Fixed: 1010088

Change-Id: I898b42034c0add621d4f9d8e02ca0ed4403d4fd3
",4ed06d14080d8667d5be14eed200e378cba78345,https://android.googlesource.com/platform/hardware/qcom/media/+/4ed06d14080d8667d5be14eed200e378cba78345,mm-video-v4l2/vidc/venc/src/omx_video_base.cpp,omx_video::fill_this_buffer,"OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  hComp,
OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", buffer->pBuffer);
if (m_state == OMX_StateInvalid) {
DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
return OMX_ErrorInvalidState;
}
if (buffer == NULL ||(buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Invalid buffer or size"");
return OMX_ErrorBadParameter;
}
if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->OMX Version Invalid"");
return OMX_ErrorVersionMismatch;
}
if (buffer->nOutputPortIndex != (OMX_U32)PORT_INDEX_OUT) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Bad port index"");
return OMX_ErrorBadPortIndex;
}
if (!m_sOutPortDef.bEnabled) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->port is disabled"");
return OMX_ErrorIncorrectStateOperation;
}
post_event((unsigned long) hComp, (unsigned long)buffer,OMX_COMPONENT_GENERATE_FTB);
return OMX_ErrorNone;
}","OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  VAR_0,
OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", VAR_1->pBuffer);
if (VAR_2 == VAR_3) {
DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
return VAR_4;
}
if (VAR_1 == NULL ||(VAR_1->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Invalid buffer or size"");
return VAR_5;
}
if (VAR_1->nVersion.nVersion != VAR_6) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->OMX Version Invalid"");
return VAR_7;
}
if (VAR_1->nOutputPortIndex != (OMX_U32)VAR_8) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Bad port index"");
return VAR_9;
}
if (!VAR_10.bEnabled) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->port is disabled"");
return VAR_11;
}
post_event((unsigned long) VAR_0, (unsigned long)VAR_1,VAR_12);
return VAR_13;
}",,"OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  hComp,
        OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
    DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", buffer->pBuffer);
    if (m_state != OMX_StateExecuting &&
            m_state != OMX_StatePause &&
            m_state != OMX_StateIdle) {
        DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
        return OMX_ErrorInvalidState;
    }

    if (buffer == NULL ||(buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Invalid buffer or size"");
        return OMX_ErrorBadParameter;
    }

    if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->OMX Version Invalid"");
        return OMX_ErrorVersionMismatch;
    }

    if (buffer->nOutputPortIndex != (OMX_U32)PORT_INDEX_OUT) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Bad port index"");
        return OMX_ErrorBadPortIndex;
    }

    if (!m_sOutPortDef.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->port is disabled"");
        return OMX_ErrorIncorrectStateOperation;
    }

    post_event((unsigned long) hComp, (unsigned long)buffer,OMX_COMPONENT_GENERATE_FTB);
    return OMX_ErrorNone;
}","OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  VAR_0,
        OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
    DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", VAR_1->pBuffer);
    if (VAR_2 != VAR_3 &&
            VAR_2 != VAR_4 &&
            VAR_2 != VAR_5) {
        DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
        return VAR_6;
    }

    if (VAR_1 == NULL ||(VAR_1->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Invalid buffer or size"");
        return VAR_7;
    }

    if (VAR_1->nVersion.nVersion != VAR_8) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->OMX Version Invalid"");
        return VAR_9;
    }

    if (VAR_1->nOutputPortIndex != (OMX_U32)VAR_10) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Bad port index"");
        return VAR_11;
    }

    if (!VAR_12.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->port is disabled"");
        return VAR_13;
    }

    post_event((unsigned long) VAR_0, (unsigned long)VAR_1,VAR_14);
    return VAR_15;
}",,"--- func_before
+++ func_after
@@ -2,7 +2,9 @@
         OMX_IN OMX_BUFFERHEADERTYPE* buffer)
 {
     DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", buffer->pBuffer);
-    if (m_state == OMX_StateInvalid) {
+    if (m_state != OMX_StateExecuting &&
+            m_state != OMX_StatePause &&
+            m_state != OMX_StateIdle) {
         DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
         return OMX_ErrorInvalidState;
     }","{'deleted_lines': ['    if (m_state == OMX_StateInvalid) {'], 'added_lines': ['    if (m_state != OMX_StateExecuting &&', '            m_state != OMX_StatePause &&', '            m_state != OMX_StateIdle) {']}",True,"Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498.",7.8,HIGH,2,valid,,5
CVE-2016-3747,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE mm-video-v4l2: venc: Avoid processing ETBs/FTBs in invalid states

(per the spec) ETB/FTB should not be handled in states other than
Executing, Paused and Idle. This avoids accessing invalid buffers.
Also add a lock to protect the private-buffers from being deleted
while accessing from another thread.

Bug: 27903498
Security Vulnerability - Heap Use-After-Free and Possible LPE in
MediaServer (libOmxVenc problem #3)

CRs-Fixed: 1010088

Change-Id: I898b42034c0add621d4f9d8e02ca0ed4403d4fd3
",4ed06d14080d8667d5be14eed200e378cba78345,https://android.googlesource.com/platform/hardware/qcom/media/+/4ed06d14080d8667d5be14eed200e378cba78345,mm-video-v4l2/vidc/venc/src/omx_video_base.cpp,omx_video::empty_this_buffer_proxy,"OMX_ERRORTYPE  omx_video::empty_this_buffer_proxy(OMX_IN OMX_HANDLETYPE  hComp,
OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
(void)hComp;
OMX_U8 *pmem_data_buf = NULL;
int push_cnt = 0;
unsigned nBufIndex = 0;
OMX_ERRORTYPE ret = OMX_ErrorNone;
encoder_media_buffer_type *media_buffer = NULL;
#ifdef _MSM8974_
int fd = 0;
#endif
DEBUG_PRINT_LOW(""ETBProxy: buffer->pBuffer[%p]"", buffer->pBuffer);
if (buffer == NULL) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid buffer[%p]"", buffer);
return OMX_ErrorBadParameter;
}
if (meta_mode_enable && !mUsesColorConversion) {
bool met_error = false;
nBufIndex = buffer - meta_buffer_hdr;
if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid meta-bufIndex = %u"", nBufIndex);
return OMX_ErrorBadParameter;
}
media_buffer = (encoder_media_buffer_type *)meta_buffer_hdr[nBufIndex].pBuffer;
if (media_buffer) {
if (media_buffer->buffer_type != kMetadataBufferTypeCameraSource &&
media_buffer->buffer_type != kMetadataBufferTypeGrallocSource) {
met_error = true;
} else {
if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
if (media_buffer->meta_handle == NULL)
met_error = true;
else if ((media_buffer->meta_handle->numFds != 1 &&
media_buffer->meta_handle->numInts != 2))
met_error = true;
}
}
} else
met_error = true;
if (met_error) {
DEBUG_PRINT_ERROR(""ERROR: Unkown source/metahandle in ETB call"");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else {
nBufIndex = buffer - ((OMX_BUFFERHEADERTYPE *)m_inp_mem_ptr);
if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid bufIndex = %u"", nBufIndex);
return OMX_ErrorBadParameter;
}
}
pending_input_buffers++;
if (input_flush_progress == true) {
post_event ((unsigned long)buffer,0,
OMX_COMPONENT_GENERATE_EBD);
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Input flush in progress"");
return OMX_ErrorNone;
}
#ifdef _MSM8974_
if (!meta_mode_enable) {
fd = m_pInput_pmem[nBufIndex].fd;
}
#endif
#ifdef _ANDROID_ICS_
if (meta_mode_enable && !mUseProxyColorFormat) {
struct pmem Input_pmem_info;
if (!media_buffer) {
DEBUG_PRINT_ERROR(""%s: invalid media_buffer"",__FUNCTION__);
return OMX_ErrorBadParameter;
}
if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
Input_pmem_info.buffer = media_buffer;
Input_pmem_info.fd = media_buffer->meta_handle->data[0];
#ifdef _MSM8974_
fd = Input_pmem_info.fd;
#endif
Input_pmem_info.offset = media_buffer->meta_handle->data[1];
Input_pmem_info.size = media_buffer->meta_handle->data[2];
DEBUG_PRINT_LOW(""ETB (meta-Camera) fd = %d, offset = %d, size = %d"",
Input_pmem_info.fd, Input_pmem_info.offset,
Input_pmem_info.size);
} else {
private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
Input_pmem_info.buffer = media_buffer;
Input_pmem_info.fd = handle->fd;
#ifdef _MSM8974_
fd = Input_pmem_info.fd;
#endif
Input_pmem_info.offset = 0;
Input_pmem_info.size = handle->size;
DEBUG_PRINT_LOW(""ETB (meta-gralloc) fd = %d, offset = %d, size = %d"",
Input_pmem_info.fd, Input_pmem_info.offset,
Input_pmem_info.size);
}
if (dev_use_buf(&Input_pmem_info,PORT_INDEX_IN,0) != true) {
DEBUG_PRINT_ERROR(""ERROR: in dev_use_buf"");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else if (meta_mode_enable && !mUsesColorConversion) {
if (media_buffer->buffer_type == kMetadataBufferTypeGrallocSource) {
private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
fd = handle->fd;
DEBUG_PRINT_LOW(""ETB (opaque-gralloc) fd = %d, size = %d"",
fd, handle->size);
} else {
DEBUG_PRINT_ERROR(""ERROR: Invalid bufferType for buffer with Opaque""
"" color format"");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else if (input_use_buffer && !m_use_input_pmem)
#else
if (input_use_buffer && !m_use_input_pmem)
#endif
{
DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");
pmem_data_buf = (OMX_U8 *)m_pInput_pmem[nBufIndex].buffer;
memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
buffer->nFilledLen);
DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
} else if (mUseProxyColorFormat) {
fd = m_pInput_pmem[nBufIndex].fd;
DEBUG_PRINT_LOW(""ETB (color-converted) fd = %d, size = %u"",
fd, (unsigned int)buffer->nFilledLen);
} else if (m_sInPortDef.format.video.eColorFormat ==
OMX_COLOR_FormatYUV420SemiPlanar) {
if (!dev_color_align(buffer, m_sInPortDef.format.video.nFrameWidth,
m_sInPortDef.format.video.nFrameHeight)) {
DEBUG_PRINT_ERROR(""Failed to adjust buffer color"");
post_event((unsigned long)buffer, 0, OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorUndefined;
}
}
#ifdef _MSM8974_
if (dev_empty_buf(buffer, pmem_data_buf,nBufIndex,fd) != true)
#else
if (dev_empty_buf(buffer, pmem_data_buf,0,0) != true)
#endif
{
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: dev_empty_buf failed"");
#ifdef _ANDROID_ICS_
omx_release_meta_buffer(buffer);
#endif
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
pending_input_buffers--;
if (hw_overload) {
return OMX_ErrorInsufficientResources;
}
return OMX_ErrorBadParameter;
}
return ret;
}","OMX_ERRORTYPE  omx_video::empty_this_buffer_proxy(OMX_IN OMX_HANDLETYPE  VAR_0,
OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
(void)VAR_0;
OMX_U8 *VAR_2 = NULL;
int VAR_3 = 0;
unsigned VAR_4 = 0;
OMX_ERRORTYPE VAR_5 = VAR_6;
encoder_media_buffer_type *VAR_7 = NULL;
#ifdef VAR_8
int VAR_9 = 0;
#endif
DEBUG_PRINT_LOW(""ETBProxy: buffer->pBuffer[%p]"", VAR_1->pBuffer);
if (VAR_1 == NULL) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid buffer[%p]"", VAR_1);
return VAR_10;
}
if (VAR_11 && !VAR_12) {
bool VAR_13 = false;
VAR_4 = VAR_1 - VAR_14;
if (VAR_4 >= VAR_15.nBufferCountActual) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid meta-bufIndex = %u"", VAR_4);
return VAR_10;
}
VAR_7 = (encoder_media_buffer_type *)VAR_14[VAR_4].pBuffer;
if (VAR_7) {
if (VAR_7->buffer_type != VAR_16 &&
VAR_7->buffer_type != VAR_17) {
VAR_13 = true;
} else {
if (VAR_7->buffer_type == VAR_16) {
if (VAR_7->meta_handle == NULL)
VAR_13 = true;
else if ((VAR_7->meta_handle->numFds != 1 &&
VAR_7->meta_handle->numInts != 2))
VAR_13 = true;
}
}
} else
VAR_13 = true;
if (VAR_13) {
DEBUG_PRINT_ERROR(""ERROR: Unkown source/metahandle in ETB call"");
post_event ((unsigned long)VAR_1,0,VAR_18);
return VAR_10;
}
} else {
VAR_4 = VAR_1 - ((OMX_BUFFERHEADERTYPE *)VAR_19);
if (VAR_4 >= VAR_15.nBufferCountActual) {
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid bufIndex = %u"", VAR_4);
return VAR_10;
}
}
VAR_20++;
if (VAR_21 == true) {
post_event ((unsigned long)VAR_1,0,
VAR_18);
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Input flush in progress"");
return VAR_6;
}
#ifdef VAR_8
if (!VAR_11) {
VAR_9 = VAR_22[VAR_4].fd;
}
#endif
#ifdef VAR_23
if (VAR_11 && !VAR_24) {
struct pmem VAR_25;
if (!VAR_7) {
DEBUG_PRINT_ERROR(""%s: invalid media_buffer"",VAR_26);
return VAR_10;
}
if (VAR_7->buffer_type == VAR_16) {
VAR_25.buffer = VAR_7;
VAR_25.fd = VAR_7->meta_handle->data[0];
#ifdef VAR_8
VAR_9 = VAR_25.fd;
#endif
VAR_25.offset = VAR_7->meta_handle->data[1];
VAR_25.size = VAR_7->meta_handle->data[2];
DEBUG_PRINT_LOW(""ETB (meta-Camera) fd = %d, offset = %d, size = %d"",
VAR_25.fd, VAR_25.offset,
VAR_25.size);
} else {
private_handle_t *VAR_27 = (private_handle_t *)VAR_7->meta_handle;
VAR_25.buffer = VAR_7;
VAR_25.fd = VAR_27->fd;
#ifdef VAR_8
VAR_9 = VAR_25.fd;
#endif
VAR_25.offset = 0;
VAR_25.size = VAR_27->size;
DEBUG_PRINT_LOW(""ETB (meta-gralloc) fd = %d, offset = %d, size = %d"",
VAR_25.fd, VAR_25.offset,
VAR_25.size);
}
if (dev_use_buf(&VAR_25,VAR_28,0) != true) {
DEBUG_PRINT_ERROR(""ERROR: in dev_use_buf"");
post_event ((unsigned long)VAR_1,0,VAR_18);
return VAR_10;
}
} else if (VAR_11 && !VAR_12) {
if (VAR_7->buffer_type == VAR_17) {
private_handle_t *VAR_27 = (private_handle_t *)VAR_7->meta_handle;
VAR_9 = VAR_27->fd;
DEBUG_PRINT_LOW(""ETB (opaque-gralloc) fd = %d, size = %d"",
VAR_9, VAR_27->size);
} else {
DEBUG_PRINT_ERROR(""ERROR: Invalid bufferType for buffer with Opaque""
"" color format"");
post_event ((unsigned long)VAR_1,0,VAR_18);
return VAR_10;
}
} else if (VAR_29 && !VAR_30)
#else
if (VAR_29 && !VAR_30)
#endif
{
DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");
VAR_2 = (OMX_U8 *)VAR_22[VAR_4].buffer;
memcpy (VAR_2, (VAR_1->pBuffer + VAR_1->nOffset),
VAR_1->nFilledLen);
DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
} else if (VAR_24) {
VAR_9 = VAR_22[VAR_4].fd;
DEBUG_PRINT_LOW(""ETB (color-converted) fd = %d, size = %u"",
VAR_9, (unsigned int)VAR_1->nFilledLen);
} else if (VAR_15.format.video.eColorFormat ==
VAR_31) {
if (!dev_color_align(VAR_1, VAR_15.format.video.nFrameWidth,
VAR_15.format.video.nFrameHeight)) {
DEBUG_PRINT_ERROR(""Failed to adjust buffer color"");
post_event((unsigned long)VAR_1, 0, VAR_18);
return VAR_32;
}
}
#ifdef VAR_8
if (dev_empty_buf(VAR_1, VAR_2,VAR_4,VAR_9) != true)
#else
if (dev_empty_buf(VAR_1, VAR_2,0,0) != true)
#endif
{
DEBUG_PRINT_ERROR(""ERROR: ETBProxy: dev_empty_buf failed"");
#ifdef VAR_23
omx_release_meta_buffer(VAR_1);
#endif
post_event ((unsigned long)VAR_1,0,VAR_18);
VAR_20--;
if (VAR_33) {
return VAR_34;
}
return VAR_10;
}
return VAR_5;
}",,"OMX_ERRORTYPE  omx_video::empty_this_buffer_proxy(OMX_IN OMX_HANDLETYPE  hComp,
        OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
    (void)hComp;
    OMX_U8 *pmem_data_buf = NULL;
    int push_cnt = 0;
    unsigned nBufIndex = 0;
    OMX_ERRORTYPE ret = OMX_ErrorNone;
    encoder_media_buffer_type *media_buffer = NULL;

#ifdef _MSM8974_
    int fd = 0;
#endif
    DEBUG_PRINT_LOW(""ETBProxy: buffer->pBuffer[%p]"", buffer->pBuffer);
    if (buffer == NULL) {
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid buffer[%p]"", buffer);
        return OMX_ErrorBadParameter;
    }

    // Buffer sanity checks
    if (meta_mode_enable && !mUsesColorConversion) {
        //For color-conversion case, we have an internal buffer and not a meta buffer
        bool met_error = false;
        nBufIndex = buffer - meta_buffer_hdr;
        if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
            DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid meta-bufIndex = %u"", nBufIndex);
            return OMX_ErrorBadParameter;
        }
        media_buffer = (encoder_media_buffer_type *)meta_buffer_hdr[nBufIndex].pBuffer;
        if (media_buffer) {
            if (media_buffer->buffer_type != kMetadataBufferTypeCameraSource &&
                    media_buffer->buffer_type != kMetadataBufferTypeGrallocSource) {
                met_error = true;
            } else {
                if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
                    if (media_buffer->meta_handle == NULL)
                        met_error = true;
                    else if ((media_buffer->meta_handle->numFds != 1 &&
                                media_buffer->meta_handle->numInts != 2))
                        met_error = true;
                }
            }
        } else
            met_error = true;
        if (met_error) {
            DEBUG_PRINT_ERROR(""ERROR: Unkown source/metahandle in ETB call"");
            post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
            return OMX_ErrorBadParameter;
        }
    } else {
        nBufIndex = buffer - ((OMX_BUFFERHEADERTYPE *)m_inp_mem_ptr);
        if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
            DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid bufIndex = %u"", nBufIndex);
            return OMX_ErrorBadParameter;
        }
    }

    pending_input_buffers++;
    if (input_flush_progress == true) {
        post_event ((unsigned long)buffer,0,
                OMX_COMPONENT_GENERATE_EBD);
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Input flush in progress"");
        return OMX_ErrorNone;
    }
#ifdef _MSM8974_
    if (!meta_mode_enable) {
        fd = m_pInput_pmem[nBufIndex].fd;
    }
#endif
#ifdef _ANDROID_ICS_
    if (meta_mode_enable && !mUseProxyColorFormat) {
        // Camera or Gralloc-source meta-buffers queued with pre-announced color-format
        struct pmem Input_pmem_info;
        if (!media_buffer) {
            DEBUG_PRINT_ERROR(""%s: invalid media_buffer"",__FUNCTION__);
            return OMX_ErrorBadParameter;
        }
        if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
            Input_pmem_info.buffer = media_buffer;
            Input_pmem_info.fd = media_buffer->meta_handle->data[0];
#ifdef _MSM8974_
            fd = Input_pmem_info.fd;
#endif
            Input_pmem_info.offset = media_buffer->meta_handle->data[1];
            Input_pmem_info.size = media_buffer->meta_handle->data[2];
            DEBUG_PRINT_LOW(""ETB (meta-Camera) fd = %d, offset = %d, size = %d"",
                    Input_pmem_info.fd, Input_pmem_info.offset,
                    Input_pmem_info.size);
        } else {
            private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
            Input_pmem_info.buffer = media_buffer;
            Input_pmem_info.fd = handle->fd;
#ifdef _MSM8974_
            fd = Input_pmem_info.fd;
#endif
            Input_pmem_info.offset = 0;
            Input_pmem_info.size = handle->size;
            DEBUG_PRINT_LOW(""ETB (meta-gralloc) fd = %d, offset = %d, size = %d"",
                    Input_pmem_info.fd, Input_pmem_info.offset,
                    Input_pmem_info.size);
        }
        if (dev_use_buf(&Input_pmem_info,PORT_INDEX_IN,0) != true) {
            DEBUG_PRINT_ERROR(""ERROR: in dev_use_buf"");
            post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
            return OMX_ErrorBadParameter;
        }
    } else if (meta_mode_enable && !mUsesColorConversion) {
        // Graphic-source meta-buffers queued with opaque color-format
        if (media_buffer->buffer_type == kMetadataBufferTypeGrallocSource) {
            private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
            fd = handle->fd;
            DEBUG_PRINT_LOW(""ETB (opaque-gralloc) fd = %d, size = %d"",
                    fd, handle->size);
        } else {
            DEBUG_PRINT_ERROR(""ERROR: Invalid bufferType for buffer with Opaque""
                    "" color format"");
            post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
            return OMX_ErrorBadParameter;
        }
    } else if (input_use_buffer && !m_use_input_pmem)
#else
    if (input_use_buffer && !m_use_input_pmem)
#endif
    {
        DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");

        auto_lock l(m_lock);
        pmem_data_buf = (OMX_U8 *)m_pInput_pmem[nBufIndex].buffer;
        if (pmem_data_buf) {
            memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
                    buffer->nFilledLen);
        }
        DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
    } else if (mUseProxyColorFormat) {
        // Gralloc-source buffers with color-conversion
        fd = m_pInput_pmem[nBufIndex].fd;
        DEBUG_PRINT_LOW(""ETB (color-converted) fd = %d, size = %u"",
                fd, (unsigned int)buffer->nFilledLen);
    } else if (m_sInPortDef.format.video.eColorFormat ==
                    OMX_COLOR_FormatYUV420SemiPlanar) {
            //For the case where YUV420SP buffers are qeueued to component
            //by sources other than camera (Apps via MediaCodec), conversion
            //to vendor flavoured NV12 color format is required.
            if (!dev_color_align(buffer, m_sInPortDef.format.video.nFrameWidth,
                                    m_sInPortDef.format.video.nFrameHeight)) {
                    DEBUG_PRINT_ERROR(""Failed to adjust buffer color"");
                    post_event((unsigned long)buffer, 0, OMX_COMPONENT_GENERATE_EBD);
                    return OMX_ErrorUndefined;
            }
    }
#ifdef _MSM8974_
    if (dev_empty_buf(buffer, pmem_data_buf,nBufIndex,fd) != true)
#else
    if (dev_empty_buf(buffer, pmem_data_buf,0,0) != true)
#endif
    {
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: dev_empty_buf failed"");
#ifdef _ANDROID_ICS_
        omx_release_meta_buffer(buffer);
#endif
        post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
        /*Generate an async error and move to invalid state*/
        pending_input_buffers--;
        if (hw_overload) {
            return OMX_ErrorInsufficientResources;
        }
        return OMX_ErrorBadParameter;
    }
    return ret;
}","OMX_ERRORTYPE  omx_video::empty_this_buffer_proxy(OMX_IN OMX_HANDLETYPE  VAR_0,
        OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
    (void)VAR_0;
    OMX_U8 *VAR_2 = NULL;
    int VAR_3 = 0;
    unsigned VAR_4 = 0;
    OMX_ERRORTYPE VAR_5 = VAR_6;
    encoder_media_buffer_type *VAR_7 = NULL;

#ifdef VAR_8
    int VAR_9 = 0;
#endif
    DEBUG_PRINT_LOW(""ETBProxy: buffer->pBuffer[%p]"", VAR_1->pBuffer);
    if (VAR_1 == NULL) {
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid buffer[%p]"", VAR_1);
        return VAR_10;
    }

    /* COMMENT_0 */
    if (VAR_11 && !VAR_12) {
        /* COMMENT_1 */
        bool VAR_13 = false;
        VAR_4 = VAR_1 - VAR_14;
        if (VAR_4 >= VAR_15.nBufferCountActual) {
            DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid meta-bufIndex = %u"", VAR_4);
            return VAR_10;
        }
        VAR_7 = (encoder_media_buffer_type *)VAR_14[VAR_4].pBuffer;
        if (VAR_7) {
            if (VAR_7->buffer_type != VAR_16 &&
                    VAR_7->buffer_type != VAR_17) {
                VAR_13 = true;
            } else {
                if (VAR_7->buffer_type == VAR_16) {
                    if (VAR_7->meta_handle == NULL)
                        VAR_13 = true;
                    else if ((VAR_7->meta_handle->numFds != 1 &&
                                VAR_7->meta_handle->numInts != 2))
                        VAR_13 = true;
                }
            }
        } else
            VAR_13 = true;
        if (VAR_13) {
            DEBUG_PRINT_ERROR(""ERROR: Unkown source/metahandle in ETB call"");
            post_event ((unsigned long)VAR_1,0,VAR_18);
            return VAR_10;
        }
    } else {
        VAR_4 = VAR_1 - ((OMX_BUFFERHEADERTYPE *)VAR_19);
        if (VAR_4 >= VAR_15.nBufferCountActual) {
            DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Invalid bufIndex = %u"", VAR_4);
            return VAR_10;
        }
    }

    VAR_20++;
    if (VAR_21 == true) {
        post_event ((unsigned long)VAR_1,0,
                VAR_18);
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: Input flush in progress"");
        return VAR_6;
    }
#ifdef VAR_8
    if (!VAR_11) {
        VAR_9 = VAR_22[VAR_4].fd;
    }
#endif
#ifdef VAR_23
    if (VAR_11 && !VAR_24) {
        /* COMMENT_2 */
        struct pmem VAR_25;
        if (!VAR_7) {
            DEBUG_PRINT_ERROR(""%s: invalid media_buffer"",VAR_26);
            return VAR_10;
        }
        if (VAR_7->buffer_type == VAR_16) {
            VAR_25.buffer = VAR_7;
            VAR_25.fd = VAR_7->meta_handle->data[0];
#ifdef VAR_8
            VAR_9 = VAR_25.fd;
#endif
            VAR_25.offset = VAR_7->meta_handle->data[1];
            VAR_25.size = VAR_7->meta_handle->data[2];
            DEBUG_PRINT_LOW(""ETB (meta-Camera) fd = %d, offset = %d, size = %d"",
                    VAR_25.fd, VAR_25.offset,
                    VAR_25.size);
        } else {
            private_handle_t *VAR_27 = (private_handle_t *)VAR_7->meta_handle;
            VAR_25.buffer = VAR_7;
            VAR_25.fd = VAR_27->fd;
#ifdef VAR_8
            VAR_9 = VAR_25.fd;
#endif
            VAR_25.offset = 0;
            VAR_25.size = VAR_27->size;
            DEBUG_PRINT_LOW(""ETB (meta-gralloc) fd = %d, offset = %d, size = %d"",
                    VAR_25.fd, VAR_25.offset,
                    VAR_25.size);
        }
        if (dev_use_buf(&VAR_25,VAR_28,0) != true) {
            DEBUG_PRINT_ERROR(""ERROR: in dev_use_buf"");
            post_event ((unsigned long)VAR_1,0,VAR_18);
            return VAR_10;
        }
    } else if (VAR_11 && !VAR_12) {
        /* COMMENT_3 */
        if (VAR_7->buffer_type == VAR_17) {
            private_handle_t *VAR_27 = (private_handle_t *)VAR_7->meta_handle;
            VAR_9 = VAR_27->fd;
            DEBUG_PRINT_LOW(""ETB (opaque-gralloc) fd = %d, size = %d"",
                    VAR_9, VAR_27->size);
        } else {
            DEBUG_PRINT_ERROR(""ERROR: Invalid bufferType for buffer with Opaque""
                    "" color format"");
            post_event ((unsigned long)VAR_1,0,VAR_18);
            return VAR_10;
        }
    } else if (VAR_29 && !VAR_30)
#else
    if (VAR_29 && !VAR_30)
#endif
    {
        DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");

        auto_lock l(m_lock);
        VAR_2 = (OMX_U8 *)VAR_22[VAR_4].buffer;
        if (VAR_2) {
            memcpy (VAR_2, (VAR_1->pBuffer + VAR_1->nOffset),
                    VAR_1->nFilledLen);
        }
        DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
    } else if (VAR_24) {
        /* COMMENT_4 */
        VAR_9 = VAR_22[VAR_4].fd;
        DEBUG_PRINT_LOW(""ETB (color-converted) fd = %d, size = %u"",
                VAR_9, (unsigned int)VAR_1->nFilledLen);
    } else if (VAR_15.format.video.eColorFormat ==
                    VAR_31) {
            /* COMMENT_5 */
            /* COMMENT_6 */
            /* COMMENT_7 */
            if (!dev_color_align(VAR_1, VAR_15.format.video.nFrameWidth,
                                    VAR_15.format.video.nFrameHeight)) {
                    DEBUG_PRINT_ERROR(""Failed to adjust buffer color"");
                    post_event((unsigned long)VAR_1, 0, VAR_18);
                    return VAR_32;
            }
    }
#ifdef VAR_8
    if (dev_empty_buf(VAR_1, VAR_2,VAR_4,VAR_9) != true)
#else
    if (dev_empty_buf(VAR_1, VAR_2,0,0) != true)
#endif
    {
        DEBUG_PRINT_ERROR(""ERROR: ETBProxy: dev_empty_buf failed"");
#ifdef VAR_23
        omx_release_meta_buffer(VAR_1);
#endif
        post_event ((unsigned long)VAR_1,0,VAR_18);
        /* COMMENT_8 */
        VAR_20--;
        if (VAR_33) {
            return VAR_34;
        }
        return VAR_10;
    }
    return VAR_5;
}",,"--- func_before
+++ func_after
@@ -123,9 +123,13 @@
 #endif
     {
         DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");
+
+        auto_lock l(m_lock);
         pmem_data_buf = (OMX_U8 *)m_pInput_pmem[nBufIndex].buffer;
-        memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
-                buffer->nFilledLen);
+        if (pmem_data_buf) {
+            memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
+                    buffer->nFilledLen);
+        }
         DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
     } else if (mUseProxyColorFormat) {
         // Gralloc-source buffers with color-conversion","{'deleted_lines': ['        memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),', '                buffer->nFilledLen);'], 'added_lines': ['', '        auto_lock l(m_lock);', '        if (pmem_data_buf) {', '            memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),', '                    buffer->nFilledLen);', '        }']}",True,"Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498.",7.8,HIGH,2,valid,,5
CVE-2016-3747,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE mm-video-v4l2: venc: Avoid processing ETBs/FTBs in invalid states

(per the spec) ETB/FTB should not be handled in states other than
Executing, Paused and Idle. This avoids accessing invalid buffers.
Also add a lock to protect the private-buffers from being deleted
while accessing from another thread.

Bug: 27903498
Security Vulnerability - Heap Use-After-Free and Possible LPE in
MediaServer (libOmxVenc problem #3)

CRs-Fixed: 1010088

Change-Id: I898b42034c0add621d4f9d8e02ca0ed4403d4fd3
",4ed06d14080d8667d5be14eed200e378cba78345,https://android.googlesource.com/platform/hardware/qcom/media/+/4ed06d14080d8667d5be14eed200e378cba78345,mm-video-v4l2/vidc/venc/src/omx_video_base.cpp,omx_video::empty_this_buffer,"OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,
OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
OMX_ERRORTYPE ret1 = OMX_ErrorNone;
unsigned int nBufferIndex ;
DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", buffer, buffer->pBuffer);
if (m_state == OMX_StateInvalid) {
DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
return OMX_ErrorInvalidState;
}
if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> buffer is null or buffer size is invalid"");
return OMX_ErrorBadParameter;
}
if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> OMX Version Invalid"");
return OMX_ErrorVersionMismatch;
}
if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {
DEBUG_PRINT_ERROR(""ERROR: Bad port index to call empty_this_buffer"");
return OMX_ErrorBadPortIndex;
}
if (!m_sInPortDef.bEnabled) {
DEBUG_PRINT_ERROR(""ERROR: Cannot call empty_this_buffer while I/P port is disabled"");
return OMX_ErrorIncorrectStateOperation;
}
nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {
DEBUG_PRINT_ERROR(""ERROR: ETB: Invalid buffer index[%d]"", nBufferIndex);
return OMX_ErrorBadParameter;
}
m_etb_count++;
DEBUG_PRINT_LOW(""DBG: i/p nTimestamp = %u"", (unsigned)buffer->nTimeStamp);
post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);
return OMX_ErrorNone;
}","OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         VAR_0,
OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
OMX_ERRORTYPE VAR_2 = VAR_3;
unsigned int VAR_4 ;
DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", VAR_1, VAR_1->pBuffer);
if (VAR_5 == VAR_6) {
DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
return VAR_7;
}
if (VAR_1 == NULL || (VAR_1->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> buffer is null or buffer size is invalid"");
return VAR_8;
}
if (VAR_1->nVersion.nVersion != VAR_9) {
DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> OMX Version Invalid"");
return VAR_10;
}
if (VAR_1->nInputPortIndex != (OMX_U32)VAR_11) {
DEBUG_PRINT_ERROR(""ERROR: Bad port index to call empty_this_buffer"");
return VAR_12;
}
if (!VAR_13.bEnabled) {
DEBUG_PRINT_ERROR(""ERROR: Cannot call empty_this_buffer while I/P port is disabled"");
return VAR_14;
}
VAR_4 = VAR_1 - ((!VAR_15)?VAR_16:VAR_17);
if (VAR_4 > VAR_13.nBufferCountActual ) {
DEBUG_PRINT_ERROR(""ERROR: ETB: Invalid buffer index[%d]"", VAR_4);
return VAR_8;
}
VAR_18++;
DEBUG_PRINT_LOW(""DBG: i/p nTimestamp = %u"", (unsigned)VAR_1->nTimeStamp);
post_event ((unsigned long)VAR_0,(unsigned long)VAR_1,VAR_19);
return VAR_3;
}",,"OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,
        OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
    OMX_ERRORTYPE ret1 = OMX_ErrorNone;
    unsigned int nBufferIndex ;

    DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", buffer, buffer->pBuffer);
    if (m_state != OMX_StateExecuting &&
            m_state != OMX_StatePause &&
            m_state != OMX_StateIdle) {
        DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
        return OMX_ErrorInvalidState;
    }

    if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> buffer is null or buffer size is invalid"");
        return OMX_ErrorBadParameter;
    }

    if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> OMX Version Invalid"");
        return OMX_ErrorVersionMismatch;
    }

    if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {
        DEBUG_PRINT_ERROR(""ERROR: Bad port index to call empty_this_buffer"");
        return OMX_ErrorBadPortIndex;
    }
    if (!m_sInPortDef.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: Cannot call empty_this_buffer while I/P port is disabled"");
        return OMX_ErrorIncorrectStateOperation;
    }

    nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);

    if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {
        DEBUG_PRINT_ERROR(""ERROR: ETB: Invalid buffer index[%d]"", nBufferIndex);
        return OMX_ErrorBadParameter;
    }

    m_etb_count++;
    DEBUG_PRINT_LOW(""DBG: i/p nTimestamp = %u"", (unsigned)buffer->nTimeStamp);
    post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);
    return OMX_ErrorNone;
}","OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         VAR_0,
        OMX_IN OMX_BUFFERHEADERTYPE* VAR_1)
{
    OMX_ERRORTYPE VAR_2 = VAR_3;
    unsigned int VAR_4 ;

    DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", VAR_1, VAR_1->pBuffer);
    if (VAR_5 != VAR_6 &&
            VAR_5 != VAR_7 &&
            VAR_5 != VAR_8) {
        DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
        return VAR_9;
    }

    if (VAR_1 == NULL || (VAR_1->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> buffer is null or buffer size is invalid"");
        return VAR_10;
    }

    if (VAR_1->nVersion.nVersion != VAR_11) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> OMX Version Invalid"");
        return VAR_12;
    }

    if (VAR_1->nInputPortIndex != (OMX_U32)VAR_13) {
        DEBUG_PRINT_ERROR(""ERROR: Bad port index to call empty_this_buffer"");
        return VAR_14;
    }
    if (!VAR_15.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: Cannot call empty_this_buffer while I/P port is disabled"");
        return VAR_16;
    }

    VAR_4 = VAR_1 - ((!VAR_17)?VAR_18:VAR_19);

    if (VAR_4 > VAR_15.nBufferCountActual ) {
        DEBUG_PRINT_ERROR(""ERROR: ETB: Invalid buffer index[%d]"", VAR_4);
        return VAR_10;
    }

    VAR_20++;
    DEBUG_PRINT_LOW(""DBG: i/p nTimestamp = %u"", (unsigned)VAR_1->nTimeStamp);
    post_event ((unsigned long)VAR_0,(unsigned long)VAR_1,VAR_21);
    return VAR_3;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,9 @@
     unsigned int nBufferIndex ;
 
     DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", buffer, buffer->pBuffer);
-    if (m_state == OMX_StateInvalid) {
+    if (m_state != OMX_StateExecuting &&
+            m_state != OMX_StatePause &&
+            m_state != OMX_StateIdle) {
         DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
         return OMX_ErrorInvalidState;
     }","{'deleted_lines': ['    if (m_state == OMX_StateInvalid) {'], 'added_lines': ['    if (m_state != OMX_StateExecuting &&', '            m_state != OMX_StatePause &&', '            m_state != OMX_StateIdle) {']}",True,"Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498.",7.8,HIGH,2,valid,,5
CVE-2016-3747,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE mm-video-v4l2: venc: Avoid processing ETBs/FTBs in invalid states

(per the spec) ETB/FTB should not be handled in states other than
Executing, Paused and Idle. This avoids accessing invalid buffers.
Also add a lock to protect the private-buffers from being deleted
while accessing from another thread.

Bug: 27903498
Security Vulnerability - Heap Use-After-Free and Possible LPE in
MediaServer (libOmxVenc problem #3)

CRs-Fixed: 1010088

Change-Id: I898b42034c0add621d4f9d8e02ca0ed4403d4fd3
",4ed06d14080d8667d5be14eed200e378cba78345,https://android.googlesource.com/platform/hardware/qcom/media/+/4ed06d14080d8667d5be14eed200e378cba78345,mm-video-v4l2/vidc/venc/src/omx_video_base.cpp,omx_video::free_input_buffer,"OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)
{
unsigned int index = 0;
OMX_U8 *temp_buff ;
if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {
DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"",
bufferHdr, m_inp_mem_ptr);
return OMX_ErrorBadParameter;
}
index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
#ifdef _ANDROID_ICS_
if (meta_mode_enable) {
if (index < m_sInPortDef.nBufferCountActual) {
memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index]));
memset(&meta_buffers[index], 0, sizeof(meta_buffers[index]));
}
if (!mUseProxyColorFormat)
return OMX_ErrorNone;
else {
c2d_conv.close();
opaque_buffer_hdr[index] = NULL;
}
}
#endif
if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat &&
dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf"");
}
if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
if(!secure_session) {
munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
} else {
free(m_pInput_pmem[index].buffer);
}
close (m_pInput_pmem[index].fd);
#ifdef USE_ION
free_ion_memory(&m_pInput_ion[index]);
#endif
m_pInput_pmem[index].fd = -1;
} else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true &&
m_use_input_pmem == OMX_FALSE)) {
DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case"");
if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
}
if(!secure_session) {
munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
}
close (m_pInput_pmem[index].fd);
#ifdef USE_ION
free_ion_memory(&m_pInput_ion[index]);
#endif
m_pInput_pmem[index].fd = -1;
} else {
DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case"");
}
}
return OMX_ErrorNone;
}","OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *VAR_0)
{
unsigned int VAR_1 = 0;
OMX_U8 *VAR_2 ;
if (VAR_0 == NULL || VAR_3 == NULL) {
DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"",
VAR_0, VAR_3);
return VAR_4;
}
VAR_1 = VAR_0 - ((!VAR_5)?VAR_3:VAR_6);
#ifdef VAR_7
if (VAR_5) {
if (VAR_1 < VAR_8.nBufferCountActual) {
memset(&VAR_6[VAR_1], 0, sizeof(VAR_6[VAR_1]));
memset(&VAR_9[VAR_1], 0, sizeof(VAR_9[VAR_1]));
}
if (!VAR_10)
return VAR_11;
else {
VAR_12.close();
VAR_13[VAR_1] = NULL;
}
}
#endif
if (VAR_1 < VAR_8.nBufferCountActual && !VAR_10 &&
dev_free_buf(&VAR_14[VAR_1],VAR_15) != true) {
DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf"");
}
if (VAR_1 < VAR_8.nBufferCountActual && VAR_14) {
if (VAR_14[VAR_1].fd > 0 && VAR_16 == false) {
DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
if(!VAR_17) {
munmap (VAR_14[VAR_1].buffer,VAR_14[VAR_1].size);
} else {
free(VAR_14[VAR_1].buffer);
}
close (VAR_14[VAR_1].fd);
#ifdef VAR_18
free_ion_memory(&VAR_19[VAR_1]);
#endif
VAR_14[VAR_1].fd = -1;
} else if (VAR_14[VAR_1].fd > 0 && (VAR_16 == true &&
VAR_20 == VAR_21)) {
DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case"");
if (dev_free_buf(&VAR_14[VAR_1],VAR_15) != true) {
DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
}
if(!VAR_17) {
munmap (VAR_14[VAR_1].buffer,VAR_14[VAR_1].size);
}
close (VAR_14[VAR_1].fd);
#ifdef VAR_18
free_ion_memory(&VAR_19[VAR_1]);
#endif
VAR_14[VAR_1].fd = -1;
} else {
DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case"");
}
}
return VAR_11;
}",android/4ed06d14080d8667d5be14eed200e378cba78345/omx_video_base.cpp/vul/before/3.json,"OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)
{
    unsigned int index = 0;
    OMX_U8 *temp_buff ;

    if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {
        DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"",
                bufferHdr, m_inp_mem_ptr);
        return OMX_ErrorBadParameter;
    }

    index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
#ifdef _ANDROID_ICS_
    if (meta_mode_enable) {
        if (index < m_sInPortDef.nBufferCountActual) {
            memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index]));
            memset(&meta_buffers[index], 0, sizeof(meta_buffers[index]));
        }
        if (!mUseProxyColorFormat)
            return OMX_ErrorNone;
        else {
            c2d_conv.close();
            opaque_buffer_hdr[index] = NULL;
        }
    }
#endif
    if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat &&
            dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
        DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf"");
    }

    if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
        auto_lock l(m_lock);

        if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
            DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
            if(!secure_session) {
            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
            } else {
                free(m_pInput_pmem[index].buffer);
            }
            m_pInput_pmem[index].buffer = NULL;
            close (m_pInput_pmem[index].fd);
#ifdef USE_ION
            free_ion_memory(&m_pInput_ion[index]);
#endif
            m_pInput_pmem[index].fd = -1;
        } else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true &&
                    m_use_input_pmem == OMX_FALSE)) {
            DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case"");
            if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
                DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
            }
            if(!secure_session) {
                munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
                m_pInput_pmem[index].buffer = NULL;
            }
            close (m_pInput_pmem[index].fd);
#ifdef USE_ION
            free_ion_memory(&m_pInput_ion[index]);
#endif
            m_pInput_pmem[index].fd = -1;
        } else {
            DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case"");
        }
    }
    return OMX_ErrorNone;
}","OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *VAR_0)
{
    unsigned int VAR_1 = 0;
    OMX_U8 *VAR_2 ;

    if (VAR_0 == NULL || VAR_3 == NULL) {
        DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"",
                VAR_0, VAR_3);
        return VAR_4;
    }

    VAR_1 = VAR_0 - ((!VAR_5)?VAR_3:VAR_6);
#ifdef VAR_7
    if (VAR_5) {
        if (VAR_1 < VAR_8.nBufferCountActual) {
            memset(&VAR_6[VAR_1], 0, sizeof(VAR_6[VAR_1]));
            memset(&VAR_9[VAR_1], 0, sizeof(VAR_9[VAR_1]));
        }
        if (!VAR_10)
            return VAR_11;
        else {
            VAR_12.close();
            VAR_13[VAR_1] = NULL;
        }
    }
#endif
    if (VAR_1 < VAR_8.nBufferCountActual && !VAR_10 &&
            dev_free_buf(&VAR_14[VAR_1],VAR_15) != true) {
        DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf"");
    }

    if (VAR_1 < VAR_8.nBufferCountActual && VAR_14) {
        auto_lock l(m_lock);

        if (VAR_14[VAR_1].fd > 0 && VAR_16 == false) {
            DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
            if(!VAR_17) {
            munmap (VAR_14[VAR_1].buffer,VAR_14[VAR_1].size);
            } else {
                free(VAR_14[VAR_1].buffer);
            }
            VAR_14[VAR_1].buffer = NULL;
            close (VAR_14[VAR_1].fd);
#ifdef VAR_18
            free_ion_memory(&VAR_19[VAR_1]);
#endif
            VAR_14[VAR_1].fd = -1;
        } else if (VAR_14[VAR_1].fd > 0 && (VAR_16 == true &&
                    VAR_20 == VAR_21)) {
            DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case"");
            if (dev_free_buf(&VAR_14[VAR_1],VAR_15) != true) {
                DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
            }
            if(!VAR_17) {
                munmap (VAR_14[VAR_1].buffer,VAR_14[VAR_1].size);
                VAR_14[VAR_1].buffer = NULL;
            }
            close (VAR_14[VAR_1].fd);
#ifdef VAR_18
            free_ion_memory(&VAR_19[VAR_1]);
#endif
            VAR_14[VAR_1].fd = -1;
        } else {
            DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case"");
        }
    }
    return VAR_11;
}",android/4ed06d14080d8667d5be14eed200e378cba78345/omx_video_base.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -30,6 +30,8 @@
     }
 
     if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
+        auto_lock l(m_lock);
+
         if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
             DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
             if(!secure_session) {
@@ -37,6 +39,7 @@
             } else {
                 free(m_pInput_pmem[index].buffer);
             }
+            m_pInput_pmem[index].buffer = NULL;
             close (m_pInput_pmem[index].fd);
 #ifdef USE_ION
             free_ion_memory(&m_pInput_ion[index]);
@@ -49,7 +52,8 @@
                 DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
             }
             if(!secure_session) {
-            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
+                munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
+                m_pInput_pmem[index].buffer = NULL;
             }
             close (m_pInput_pmem[index].fd);
 #ifdef USE_ION","{'deleted_lines': ['            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);'], 'added_lines': ['        auto_lock l(m_lock);', '', '            m_pInput_pmem[index].buffer = NULL;', '                munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);', '                m_pInput_pmem[index].buffer = NULL;']}",True,"Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498.",7.8,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (2/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19
",37c88107679d36c419572732b4af6e18bb2f7dce,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,btif/src/btif_config.c,init,"static future_t *init(void) {
pthread_mutex_init(&lock, NULL);
config = config_new(CONFIG_FILE_PATH);
if (!config) {
LOG_WARN(""%s unable to load config file; attempting to transcode legacy file."", __func__);
config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);
if (!config) {
LOG_WARN(""%s unable to transcode legacy file, starting unconfigured."", __func__);
config = config_new_empty();
if (!config) {
LOG_ERROR(""%s unable to allocate a config object."", __func__);
goto error;
}
}
if (config_save(config, CONFIG_FILE_PATH))
unlink(LEGACY_CONFIG_FILE_PATH);
}
btif_config_remove_unpaired(config);
alarm_timer = alarm_new();
if (!alarm_timer) {
LOG_ERROR(""%s unable to create alarm."", __func__);
goto error;
}
return future_new_immediate(FUTURE_SUCCESS);
error:;
alarm_free(alarm_timer);
config_free(config);
pthread_mutex_destroy(&lock);
alarm_timer = NULL;
config = NULL;
return future_new_immediate(FUTURE_FAIL);
}","static future_t *init(void) {
pthread_mutex_init(&VAR_0, NULL);
VAR_1 = config_new(VAR_2);
if (!VAR_1) {
LOG_WARN(""%s unable to load config file; attempting to transcode legacy file."", VAR_3);
VAR_1 = btif_config_transcode(VAR_4);
if (!VAR_1) {
LOG_WARN(""%s unable to transcode legacy file, starting unconfigured."", VAR_3);
VAR_1 = config_new_empty();
if (!VAR_1) {
LOG_ERROR(""%s unable to allocate a config object."", VAR_3);
goto error;
}
}
if (config_save(VAR_1, VAR_2))
unlink(VAR_4);
}
btif_config_remove_unpaired(VAR_1);
VAR_5 = alarm_new();
if (!VAR_5) {
LOG_ERROR(""%s unable to create alarm."", VAR_3);
goto error;
}
return future_new_immediate(VAR_6);
error:;
alarm_free(VAR_5);
config_free(VAR_1);
pthread_mutex_destroy(&VAR_0);
VAR_5 = NULL;
VAR_1 = NULL;
return future_new_immediate(VAR_7);
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/btif_config.c/vul/before/0.json,"static future_t *init(void) {
  pthread_mutex_init(&lock, NULL);
  config = config_new(CONFIG_FILE_PATH);
  if (!config) {
    LOG_WARN(""%s unable to load config file; attempting to transcode legacy file."", __func__);
    config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);
    if (!config) {
      LOG_WARN(""%s unable to transcode legacy file, starting unconfigured."", __func__);
      config = config_new_empty();
      if (!config) {
        LOG_ERROR(""%s unable to allocate a config object."", __func__);
        goto error;
      }
    }

    if (config_save(config, CONFIG_FILE_PATH))
      unlink(LEGACY_CONFIG_FILE_PATH);
  }

  btif_config_remove_unpaired(config);

  // Cleanup temporary pairings if we have left guest mode
  if (!is_restricted_mode())
    btif_config_remove_restricted(config);

  // TODO(sharvil): use a non-wake alarm for this once we have
  // API support for it. There's no need to wake the system to
  // write back to disk.
  alarm_timer = alarm_new();
  if (!alarm_timer) {
    LOG_ERROR(""%s unable to create alarm."", __func__);
    goto error;
  }

  return future_new_immediate(FUTURE_SUCCESS);

error:;
  alarm_free(alarm_timer);
  config_free(config);
  pthread_mutex_destroy(&lock);
  alarm_timer = NULL;
  config = NULL;
  return future_new_immediate(FUTURE_FAIL);
}","static future_t *init(void) {
  pthread_mutex_init(&VAR_0, NULL);
  VAR_1 = config_new(VAR_2);
  if (!VAR_1) {
    LOG_WARN(""%s unable to load config file; attempting to transcode legacy file."", VAR_3);
    VAR_1 = btif_config_transcode(VAR_4);
    if (!VAR_1) {
      LOG_WARN(""%s unable to transcode legacy file, starting unconfigured."", VAR_3);
      VAR_1 = config_new_empty();
      if (!VAR_1) {
        LOG_ERROR(""%s unable to allocate a config object."", VAR_3);
        goto error;
      }
    }

    if (config_save(VAR_1, VAR_2))
      unlink(VAR_4);
  }

  btif_config_remove_unpaired(VAR_1);

  /* COMMENT_0 */
  if (!is_restricted_mode())
    btif_config_remove_restricted(VAR_1);

  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  VAR_5 = alarm_new();
  if (!VAR_5) {
    LOG_ERROR(""%s unable to create alarm."", VAR_3);
    goto error;
  }

  return future_new_immediate(VAR_6);

error:;
  alarm_free(VAR_5);
  config_free(VAR_1);
  pthread_mutex_destroy(&VAR_0);
  VAR_5 = NULL;
  VAR_1 = NULL;
  return future_new_immediate(VAR_7);
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/btif_config.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,6 +19,10 @@
 
   btif_config_remove_unpaired(config);
 
+  // Cleanup temporary pairings if we have left guest mode
+  if (!is_restricted_mode())
+    btif_config_remove_restricted(config);
+
   // TODO(sharvil): use a non-wake alarm for this once we have
   // API support for it. There's no need to wake the system to
   // write back to disk.","{'deleted_lines': [], 'added_lines': ['  // Cleanup temporary pairings if we have left guest mode', '  if (!is_restricted_mode())', '    btif_config_remove_restricted(config);', '']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (2/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19
",37c88107679d36c419572732b4af6e18bb2f7dce,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,btif/src/btif_storage.c,btif_storage_add_bonded_device,"bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
LINK_KEY link_key,
uint8_t key_type,
uint8_t pin_length)
{
bdstr_t bdstr;
bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
int ret = btif_config_set_int(bdstr, ""LinkKeyType"", (int)key_type);
ret &= btif_config_set_int(bdstr, ""PinLength"", (int)pin_length);
ret &= btif_config_set_bin(bdstr, ""LinkKey"", link_key, sizeof(LINK_KEY));
btif_config_flush();
return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}","bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *VAR_0,
LINK_KEY VAR_1,
uint8_t VAR_2,
uint8_t VAR_3)
{
bdstr_t VAR_4;
bdaddr_to_string(VAR_0, VAR_4, sizeof(VAR_4));
int VAR_5 = btif_config_set_int(VAR_4, ""LinkKeyType"", (int)VAR_2);
VAR_5 &= btif_config_set_int(VAR_4, ""PinLength"", (int)VAR_3);
VAR_5 &= btif_config_set_bin(VAR_4, ""LinkKey"", VAR_1, sizeof(LINK_KEY));
btif_config_flush();
return VAR_5 ? VAR_6 : VAR_7;
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/btif_storage.c/vul/before/0.json,"bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
                                           LINK_KEY link_key,
                                           uint8_t key_type,
                                           uint8_t pin_length)
{
    bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    int ret = btif_config_set_int(bdstr, ""LinkKeyType"", (int)key_type);
    ret &= btif_config_set_int(bdstr, ""PinLength"", (int)pin_length);
    ret &= btif_config_set_bin(bdstr, ""LinkKey"", link_key, sizeof(LINK_KEY));

    if (is_restricted_mode()) {
        BTIF_TRACE_WARNING(""%s: '%s' pairing will be removed if unrestricted"",
                         __func__, bdstr);
        btif_config_set_int(bdstr, ""Restricted"", 1);
    }

    /* write bonded info immediately */
    btif_config_flush();
    return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}","bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *VAR_0,
                                           LINK_KEY VAR_1,
                                           uint8_t VAR_2,
                                           uint8_t VAR_3)
{
    bdstr_t VAR_4;
    bdaddr_to_string(VAR_0, VAR_4, sizeof(VAR_4));
    int VAR_5 = btif_config_set_int(VAR_4, ""LinkKeyType"", (int)VAR_2);
    VAR_5 &= btif_config_set_int(VAR_4, ""PinLength"", (int)VAR_3);
    VAR_5 &= btif_config_set_bin(VAR_4, ""LinkKey"", VAR_1, sizeof(LINK_KEY));

    if (is_restricted_mode()) {
        BTIF_TRACE_WARNING(""%s: '%s' pairing will be removed if unrestricted"",
                         VAR_6, VAR_4);
        btif_config_set_int(VAR_4, ""Restricted"", 1);
    }

    /* COMMENT_0 */
    btif_config_flush();
    return VAR_5 ? VAR_7 : VAR_8;
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/btif_storage.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,13 @@
     int ret = btif_config_set_int(bdstr, ""LinkKeyType"", (int)key_type);
     ret &= btif_config_set_int(bdstr, ""PinLength"", (int)pin_length);
     ret &= btif_config_set_bin(bdstr, ""LinkKey"", link_key, sizeof(LINK_KEY));
+
+    if (is_restricted_mode()) {
+        BTIF_TRACE_WARNING(""%s: '%s' pairing will be removed if unrestricted"",
+                         __func__, bdstr);
+        btif_config_set_int(bdstr, ""Restricted"", 1);
+    }
+
     /* write bonded info immediately */
     btif_config_flush();
     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;","{'deleted_lines': [], 'added_lines': ['', '    if (is_restricted_mode()) {', '        BTIF_TRACE_WARNING(""%s: \'%s\' pairing will be removed if unrestricted"",', '                         __func__, bdstr);', '        btif_config_set_int(bdstr, ""Restricted"", 1);', '    }', '']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (2/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19
",37c88107679d36c419572732b4af6e18bb2f7dce,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,btif/src/bluetooth.c,enable,"static int enable(void) {
LOG_INFO(""%s"", __func__);
if (!interface_ready())
return BT_STATUS_NOT_READY;
stack_manager_get_interface()->start_up_stack_async();
return BT_STATUS_SUCCESS;
}","static int enable(void) {
LOG_INFO(""%s"", VAR_0);
if (!interface_ready())
return VAR_1;
stack_manager_get_interface()->start_up_stack_async();
return VAR_2;
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bluetooth.c/vul/before/0.json,"static int enable(bool start_restricted) {
  LOG_INFO(LOG_TAG, ""%s: start restricted = %d"", __func__, start_restricted);

  restricted_mode = start_restricted;

  if (!interface_ready())
    return BT_STATUS_NOT_READY;

  stack_manager_get_interface()->start_up_stack_async();
  return BT_STATUS_SUCCESS;
}","static int enable(bool VAR_0) {
  LOG_INFO(VAR_1, ""%s: start restricted = %d"", VAR_2, VAR_0);

  VAR_3 = VAR_0;

  if (!interface_ready())
    return VAR_4;

  stack_manager_get_interface()->start_up_stack_async();
  return VAR_5;
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bluetooth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,7 @@
-static int enable(void) {
-  LOG_INFO(""%s"", __func__);
+static int enable(bool start_restricted) {
+  LOG_INFO(LOG_TAG, ""%s: start restricted = %d"", __func__, start_restricted);
+
+  restricted_mode = start_restricted;
 
   if (!interface_ready())
     return BT_STATUS_NOT_READY;","{'deleted_lines': ['static int enable(void) {', '  LOG_INFO(""%s"", __func__);'], 'added_lines': ['static int enable(bool start_restricted) {', '  LOG_INFO(LOG_TAG, ""%s: start restricted = %d"", __func__, start_restricted);', '', '  restricted_mode = start_restricted;']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (2/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19
",37c88107679d36c419572732b4af6e18bb2f7dce,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,btif/src/bluetooth.c,remove_bond,"static int remove_bond(const bt_bdaddr_t *bd_addr)
{
if (interface_ready() == FALSE)
return BT_STATUS_NOT_READY;
return btif_dm_remove_bond(bd_addr);
}","static int remove_bond(const bt_bdaddr_t *VAR_0)
{
if (interface_ready() == FALSE)
return VAR_1;
return btif_dm_remove_bond(VAR_0);
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bluetooth.c/vul/before/1.json,"static int remove_bond(const bt_bdaddr_t *bd_addr)
{
    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))
        return BT_STATUS_SUCCESS;

    /* sanity check */
    if (interface_ready() == FALSE)
        return BT_STATUS_NOT_READY;

    return btif_dm_remove_bond(bd_addr);
}","static int remove_bond(const bt_bdaddr_t *VAR_0)
{
    if (is_restricted_mode() && !btif_storage_is_restricted_device(VAR_0))
        return VAR_1;

    /* COMMENT_0 */
    if (interface_ready() == FALSE)
        return VAR_2;

    return btif_dm_remove_bond(VAR_0);
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bluetooth.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 static int remove_bond(const bt_bdaddr_t *bd_addr)
 {
+    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))
+        return BT_STATUS_SUCCESS;
+
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;","{'deleted_lines': [], 'added_lines': ['    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))', '        return BT_STATUS_SUCCESS;', '']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (2/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19
",37c88107679d36c419572732b4af6e18bb2f7dce,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,tools/bdtool/bdtool.c,main,"int main(int argc, char **argv) {
if (!parse_args(argc, argv)) {
usage(argv[0]);
}
if (bond && discoverable) {
fprintf(stderr, ""Can only select either bond or discoverable, not both\n"");
usage(argv[0]);
}
if (sco_listen && sco_connect) {
fprintf(stderr, ""Can only select either sco_listen or sco_connect, not both\n"");
usage(argv[0]);
}
if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {
fprintf(stderr, ""Must specify one command\n"");
usage(argv[0]);
}
if (signal(SIGINT, sig_handler) == SIG_ERR) {
fprintf(stderr, ""Will be unable to catch signals\n"");
}
fprintf(stdout, ""Bringing up bluetooth adapter\n"");
if (!hal_open(callbacks_get_adapter_struct())) {
fprintf(stderr, ""Unable to open Bluetooth HAL.\n"");
return 1;
}
if (discover) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
fprintf(stdout, ""Starting to start discovery\n"");
CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);
fprintf(stdout, ""Started discovery for %d seconds\n"", timeout_in_sec);
sleep(timeout_in_sec);
fprintf(stdout, ""Starting to cancel discovery\n"");
CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);
fprintf(stdout, ""Cancelled discovery after %d seconds\n"", timeout_in_sec);
}
if (discoverable) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
int rc = bt_interface->set_adapter_property(property);
fprintf(stdout, ""Set rc:%d device as discoverable for %d seconds\n"", rc, timeout_in_sec);
sleep(timeout_in_sec);
property_free(property);
}
if (bond) {
if (bdaddr_is_empty(&bt_remote_bdaddr)) {
fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
exit(1);
}
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 );
fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec);
sleep(timeout_in_sec);
}
if (up) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec);
sleep(timeout_in_sec);
}
if (get_name) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
int error;
CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to get adapter property\n"");
exit(1);
}
bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);
const bt_bdname_t *name = property_as_name(property);
if (name)
printf(""Queried bluetooth device name:%s\n"", name->name);
else
printf(""No name\n"");
}
if (set_name) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
bt_property_t *property = property_new_name(bd_name);
printf(""Setting bluetooth device name to:%s\n"", bd_name);
int error;
CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to set adapter property\n"");
exit(1);
}
CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to get adapter property\n"");
exit(1);
}
property_free(property);
sleep(timeout_in_sec);
}
if (sco_listen) {
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);
property_free(property);
const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
int rfcomm_fd = INVALID_FD;
int error = sock->listen(BTSOCK_RFCOMM, ""meow"", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to listen for incoming RFCOMM socket: %d\n"", error);
exit(1);
}
int sock_fd = INVALID_FD;
error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to listen for incoming SCO sockets: %d\n"", error);
exit(1);
}
fprintf(stdout, ""Waiting for incoming SCO connections...\n"");
sleep(timeout_in_sec);
}
if (sco_connect) {
if (bdaddr_is_empty(&bt_remote_bdaddr)) {
fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
exit(1);
}
CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is up\n"");
const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
int rfcomm_fd = INVALID_FD;
int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error);
exit(1);
}
WAIT(acl_state_changed);
fprintf(stdout, ""Establishing SCO connection...\n"");
int sock_fd = INVALID_FD;
error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to connect to SCO socket: %d.\n"", error);
exit(1);
}
sleep(timeout_in_sec);
}
CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
fprintf(stdout, ""BT adapter is down\n"");
}","int main(int VAR_0, char **VAR_1) {
if (!parse_args(VAR_0, VAR_1)) {
usage(VAR_1[0]);
}
if (VAR_2 && VAR_3) {
fprintf(VAR_4, ""Can only select either bond or discoverable, not both\n"");
usage(VAR_1[0]);
}
if (VAR_5 && VAR_6) {
fprintf(VAR_4, ""Can only select either sco_listen or sco_connect, not both\n"");
usage(VAR_1[0]);
}
if (!VAR_2 && !VAR_7 && !VAR_3 && !VAR_8 && !VAR_9 && !VAR_10 && !VAR_5 && !VAR_6) {
fprintf(VAR_4, ""Must specify one command\n"");
usage(VAR_1[0]);
}
if (signal(VAR_11, VAR_12) == VAR_13) {
fprintf(VAR_4, ""Will be unable to catch signals\n"");
}
fprintf(VAR_14, ""Bringing up bluetooth adapter\n"");
if (!hal_open(callbacks_get_adapter_struct())) {
fprintf(VAR_4, ""Unable to open Bluetooth HAL.\n"");
return 1;
}
if (VAR_7) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
fprintf(VAR_14, ""Starting to start discovery\n"");
CALL_AND_WAIT(VAR_15->start_discovery(), VAR_17);
fprintf(VAR_14, ""Started discovery for %d seconds\n"", VAR_18);
sleep(VAR_18);
fprintf(VAR_14, ""Starting to cancel discovery\n"");
CALL_AND_WAIT(VAR_15->cancel_discovery(), VAR_17);
fprintf(VAR_14, ""Cancelled discovery after %d seconds\n"", VAR_18);
}
if (VAR_3) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
bt_property_t *VAR_19 = property_new_scan_mode(VAR_20);
int VAR_21 = VAR_15->set_adapter_property(VAR_19);
fprintf(VAR_14, ""Set rc:%d device as discoverable for %d seconds\n"", VAR_21, VAR_18);
sleep(VAR_18);
property_free(VAR_19);
}
if (VAR_2) {
if (bdaddr_is_empty(&VAR_22)) {
fprintf(VAR_4, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
exit(1);
}
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
int VAR_21 = VAR_15->create_bond(&VAR_22, 0 );
fprintf(VAR_14, ""Started bonding:%d for %d seconds\n"", VAR_21, VAR_18);
sleep(VAR_18);
}
if (VAR_8) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
fprintf(VAR_14, ""Waiting for %d seconds\n"", VAR_18);
sleep(VAR_18);
}
if (VAR_9) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
int VAR_23;
CALL_AND_WAIT(VAR_23 = VAR_15->get_adapter_property(VAR_24), VAR_25);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to get adapter property\n"");
exit(1);
}
bt_property_t *VAR_19 = adapter_get_property(VAR_24);
const bt_bdname_t *VAR_27 = property_as_name(VAR_19);
if (VAR_27)
printf(""Queried bluetooth device name:%s\n"", VAR_27->name);
else
printf(""No name\n"");
}
if (VAR_10) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
bt_property_t *VAR_19 = property_new_name(VAR_28);
printf(""Setting bluetooth device name to:%s\n"", VAR_28);
int VAR_23;
CALL_AND_WAIT(VAR_23 = VAR_15->set_adapter_property(VAR_19), VAR_25);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to set adapter property\n"");
exit(1);
}
CALL_AND_WAIT(VAR_23 = VAR_15->get_adapter_property(VAR_24), VAR_25);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to get adapter property\n"");
exit(1);
}
property_free(VAR_19);
sleep(VAR_18);
}
if (VAR_5) {
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
bt_property_t *VAR_19 = property_new_scan_mode(VAR_20);
CALL_AND_WAIT(VAR_15->set_adapter_property(VAR_19), VAR_25);
property_free(VAR_19);
const btsock_interface_t *VAR_29 = VAR_15->get_profile_interface(VAR_30);
int VAR_31 = VAR_32;
int VAR_23 = VAR_29->listen(VAR_33, ""meow"", (const uint8_t *)&VAR_34, 0, &VAR_31, 0);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to listen for incoming RFCOMM socket: %d\n"", VAR_23);
exit(1);
}
int VAR_35 = VAR_32;
VAR_23 = VAR_29->listen(VAR_36, NULL, NULL, 5, &VAR_35, 0);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to listen for incoming SCO sockets: %d\n"", VAR_23);
exit(1);
}
fprintf(VAR_14, ""Waiting for incoming SCO connections...\n"");
sleep(VAR_18);
}
if (VAR_6) {
if (bdaddr_is_empty(&VAR_22)) {
fprintf(VAR_4, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
exit(1);
}
CALL_AND_WAIT(VAR_15->enable(), VAR_16);
fprintf(VAR_14, ""BT adapter is up\n"");
const btsock_interface_t *VAR_29 = VAR_15->get_profile_interface(VAR_30);
int VAR_31 = VAR_32;
int VAR_23 = VAR_29->connect(&VAR_22, VAR_33, (const uint8_t *)&VAR_34, 0, &VAR_31, 0);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to connect to RFCOMM socket: %d.\n"", VAR_23);
exit(1);
}
WAIT(VAR_37);
fprintf(VAR_14, ""Establishing SCO connection...\n"");
int VAR_35 = VAR_32;
VAR_23 = VAR_29->connect(&VAR_22, VAR_36, NULL, 5, &VAR_35, 0);
if (VAR_23 != VAR_26) {
fprintf(VAR_4, ""Unable to connect to SCO socket: %d.\n"", VAR_23);
exit(1);
}
sleep(VAR_18);
}
CALL_AND_WAIT(VAR_15->disable(), VAR_16);
fprintf(VAR_14, ""BT adapter is down\n"");
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bdtool.c/vul/before/0.json,"int main(int argc, char **argv) {
  if (!parse_args(argc, argv)) {
    usage(argv[0]);
  }

  if (bond && discoverable) {
    fprintf(stderr, ""Can only select either bond or discoverable, not both\n"");
    usage(argv[0]);
  }

  if (sco_listen && sco_connect) {
    fprintf(stderr, ""Can only select either sco_listen or sco_connect, not both\n"");
    usage(argv[0]);
  }

  if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {
    fprintf(stderr, ""Must specify one command\n"");
    usage(argv[0]);
  }

  if (signal(SIGINT, sig_handler) == SIG_ERR) {
    fprintf(stderr, ""Will be unable to catch signals\n"");
  }

  fprintf(stdout, ""Bringing up bluetooth adapter\n"");
  if (!hal_open(callbacks_get_adapter_struct())) {
    fprintf(stderr, ""Unable to open Bluetooth HAL.\n"");
    return 1;
  }

  if (discover) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    fprintf(stdout, ""Starting to start discovery\n"");
    CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);
    fprintf(stdout, ""Started discovery for %d seconds\n"", timeout_in_sec);

    sleep(timeout_in_sec);

    fprintf(stdout, ""Starting to cancel discovery\n"");
    CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);
    fprintf(stdout, ""Cancelled discovery after %d seconds\n"", timeout_in_sec);
  }

  if (discoverable) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);

    int rc = bt_interface->set_adapter_property(property);
    fprintf(stdout, ""Set rc:%d device as discoverable for %d seconds\n"", rc, timeout_in_sec);

    sleep(timeout_in_sec);

    property_free(property);
  }

   if (bond) {
    if (bdaddr_is_empty(&bt_remote_bdaddr)) {
      fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
      exit(1);
    }

    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 /* UNKNOWN; Currently not documented :( */);
    fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec);

    sleep(timeout_in_sec);
  }

  if (up) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec);
    sleep(timeout_in_sec);
  }

  if (get_name) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");
    int error;
    CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to get adapter property\n"");
      exit(1);
    }
    bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);
    const bt_bdname_t *name = property_as_name(property);
    if (name)
      printf(""Queried bluetooth device name:%s\n"", name->name);
    else
      printf(""No name\n"");
  }

  if (set_name) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    bt_property_t *property = property_new_name(bd_name);
    printf(""Setting bluetooth device name to:%s\n"", bd_name);
    int error;
    CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to set adapter property\n"");
      exit(1);
    }
    CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to get adapter property\n"");
      exit(1);
    }
    property_free(property);
    sleep(timeout_in_sec);
  }

  if (sco_listen) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
    CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);
    property_free(property);

    const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

    int rfcomm_fd = INVALID_FD;
    int error = sock->listen(BTSOCK_RFCOMM, ""meow"", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to listen for incoming RFCOMM socket: %d\n"", error);
      exit(1);
    }

    int sock_fd = INVALID_FD;
    error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to listen for incoming SCO sockets: %d\n"", error);
      exit(1);
    }
    fprintf(stdout, ""Waiting for incoming SCO connections...\n"");
    sleep(timeout_in_sec);
  }

  if (sco_connect) {
    if (bdaddr_is_empty(&bt_remote_bdaddr)) {
      fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
      exit(1);
    }

    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
    fprintf(stdout, ""BT adapter is up\n"");

    const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

    int rfcomm_fd = INVALID_FD;
    int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error);
      exit(1);
    }

    WAIT(acl_state_changed);

    fprintf(stdout, ""Establishing SCO connection...\n"");

    int sock_fd = INVALID_FD;
    error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);
    if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to connect to SCO socket: %d.\n"", error);
      exit(1);
    }
    sleep(timeout_in_sec);
  }

  CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
  fprintf(stdout, ""BT adapter is down\n"");
}","int main(int VAR_0, char **VAR_1) {
  if (!parse_args(VAR_0, VAR_1)) {
    usage(VAR_1[0]);
  }

  if (VAR_2 && VAR_3) {
    fprintf(VAR_4, ""Can only select either bond or discoverable, not both\n"");
    usage(VAR_1[0]);
  }

  if (VAR_5 && VAR_6) {
    fprintf(VAR_4, ""Can only select either sco_listen or sco_connect, not both\n"");
    usage(VAR_1[0]);
  }

  if (!VAR_2 && !VAR_7 && !VAR_3 && !VAR_8 && !VAR_9 && !VAR_10 && !VAR_5 && !VAR_6) {
    fprintf(VAR_4, ""Must specify one command\n"");
    usage(VAR_1[0]);
  }

  if (signal(VAR_11, VAR_12) == VAR_13) {
    fprintf(VAR_4, ""Will be unable to catch signals\n"");
  }

  fprintf(VAR_14, ""Bringing up bluetooth adapter\n"");
  if (!hal_open(callbacks_get_adapter_struct())) {
    fprintf(VAR_4, ""Unable to open Bluetooth HAL.\n"");
    return 1;
  }

  if (VAR_7) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    fprintf(VAR_14, ""Starting to start discovery\n"");
    CALL_AND_WAIT(VAR_15->start_discovery(), VAR_17);
    fprintf(VAR_14, ""Started discovery for %d seconds\n"", VAR_18);

    sleep(VAR_18);

    fprintf(VAR_14, ""Starting to cancel discovery\n"");
    CALL_AND_WAIT(VAR_15->cancel_discovery(), VAR_17);
    fprintf(VAR_14, ""Cancelled discovery after %d seconds\n"", VAR_18);
  }

  if (VAR_3) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    bt_property_t *VAR_19 = property_new_scan_mode(VAR_20);

    int VAR_21 = VAR_15->set_adapter_property(VAR_19);
    fprintf(VAR_14, ""Set rc:%d device as discoverable for %d seconds\n"", VAR_21, VAR_18);

    sleep(VAR_18);

    property_free(VAR_19);
  }

   if (VAR_2) {
    if (bdaddr_is_empty(&VAR_22)) {
      fprintf(VAR_4, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
      exit(1);
    }

    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    int VAR_21 = VAR_15->create_bond(&VAR_22, 0 /* COMMENT_0 */);
    fprintf(VAR_14, ""Started bonding:%d for %d seconds\n"", VAR_21, VAR_18);

    sleep(VAR_18);
  }

  if (VAR_8) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    fprintf(VAR_14, ""Waiting for %d seconds\n"", VAR_18);
    sleep(VAR_18);
  }

  if (VAR_9) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");
    int VAR_23;
    CALL_AND_WAIT(VAR_23 = VAR_15->get_adapter_property(VAR_24), VAR_25);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to get adapter property\n"");
      exit(1);
    }
    bt_property_t *VAR_19 = adapter_get_property(VAR_24);
    const bt_bdname_t *VAR_27 = property_as_name(VAR_19);
    if (VAR_27)
      printf(""Queried bluetooth device name:%s\n"", VAR_27->name);
    else
      printf(""No name\n"");
  }

  if (VAR_10) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    bt_property_t *VAR_19 = property_new_name(VAR_28);
    printf(""Setting bluetooth device name to:%s\n"", VAR_28);
    int VAR_23;
    CALL_AND_WAIT(VAR_23 = VAR_15->set_adapter_property(VAR_19), VAR_25);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to set adapter property\n"");
      exit(1);
    }
    CALL_AND_WAIT(VAR_23 = VAR_15->get_adapter_property(VAR_24), VAR_25);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to get adapter property\n"");
      exit(1);
    }
    property_free(VAR_19);
    sleep(VAR_18);
  }

  if (VAR_5) {
    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    bt_property_t *VAR_19 = property_new_scan_mode(VAR_20);
    CALL_AND_WAIT(VAR_15->set_adapter_property(VAR_19), VAR_25);
    property_free(VAR_19);

    const btsock_interface_t *VAR_29 = VAR_15->get_profile_interface(VAR_30);

    int VAR_31 = VAR_32;
    int VAR_23 = VAR_29->listen(VAR_33, ""meow"", (const uint8_t *)&VAR_34, 0, &VAR_31, 0);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to listen for incoming RFCOMM socket: %d\n"", VAR_23);
      exit(1);
    }

    int VAR_35 = VAR_32;
    VAR_23 = VAR_29->listen(VAR_36, NULL, NULL, 5, &VAR_35, 0);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to listen for incoming SCO sockets: %d\n"", VAR_23);
      exit(1);
    }
    fprintf(VAR_14, ""Waiting for incoming SCO connections...\n"");
    sleep(VAR_18);
  }

  if (VAR_6) {
    if (bdaddr_is_empty(&VAR_22)) {
      fprintf(VAR_4, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
      exit(1);
    }

    CALL_AND_WAIT(VAR_15->enable(false), VAR_16);
    fprintf(VAR_14, ""BT adapter is up\n"");

    const btsock_interface_t *VAR_29 = VAR_15->get_profile_interface(VAR_30);

    int VAR_31 = VAR_32;
    int VAR_23 = VAR_29->connect(&VAR_22, VAR_33, (const uint8_t *)&VAR_34, 0, &VAR_31, 0);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to connect to RFCOMM socket: %d.\n"", VAR_23);
      exit(1);
    }

    WAIT(VAR_37);

    fprintf(VAR_14, ""Establishing SCO connection...\n"");

    int VAR_35 = VAR_32;
    VAR_23 = VAR_29->connect(&VAR_22, VAR_36, NULL, 5, &VAR_35, 0);
    if (VAR_23 != VAR_26) {
      fprintf(VAR_4, ""Unable to connect to SCO socket: %d.\n"", VAR_23);
      exit(1);
    }
    sleep(VAR_18);
  }

  CALL_AND_WAIT(VAR_15->disable(), VAR_16);
  fprintf(VAR_14, ""BT adapter is down\n"");
}",android/37c88107679d36c419572732b4af6e18bb2f7dce/bdtool.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,7 +29,7 @@
   }
 
   if (discover) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     fprintf(stdout, ""Starting to start discovery\n"");
@@ -44,7 +44,7 @@
   }
 
   if (discoverable) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
@@ -63,7 +63,7 @@
       exit(1);
     }
 
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 /* UNKNOWN; Currently not documented :( */);
@@ -73,7 +73,7 @@
   }
 
   if (up) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec);
@@ -81,7 +81,7 @@
   }
 
   if (get_name) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
     int error;
     CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
@@ -98,7 +98,7 @@
   }
 
   if (set_name) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_name(bd_name);
@@ -119,7 +119,7 @@
   }
 
   if (sco_listen) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
@@ -151,7 +151,7 @@
       exit(1);
     }
 
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);","{'deleted_lines': ['    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);'], 'added_lines': ['    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);', '    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-3760,"['CWE-362', 'CWE-20']",AV:A/AC:M/Au:N/C:P/I:P/A:P,0,android,"Add guest mode functionality (3/3)

Add a flag to enable() to start Bluetooth in restricted
mode. In restricted mode, all devices that are paired during
restricted mode are deleted upon leaving restricted mode.
Right now restricted mode is only entered while a guest
user is active.

Bug: 27410683
Change-Id: If4a8855faf362d7f6de509d7ddc7197d1ac75cee
",122feb9a0b04290f55183ff2f0384c6c53756bd8,https://android.googlesource.com/platform/packages/apps/Bluetooth/+/122feb9a0b04290f55183ff2f0384c6c53756bd8,jni/com_android_bluetooth_btservice_AdapterService.cpp,enableNative,"static jboolean enableNative(JNIEnv* env, jobject obj) {
ALOGV(""%s:"",__FUNCTION__);
jboolean result = JNI_FALSE;
if (!sBluetoothInterface) return result;
int ret = sBluetoothInterface->enable();
result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
return result;
}","static jboolean enableNative(JNIEnv* VAR_0, jobject VAR_1) {
ALOGV(""%s:"",VAR_2);
jboolean VAR_3 = VAR_4;
if (!VAR_5) return VAR_3;
int VAR_6 = VAR_5->enable();
VAR_3 = (VAR_6 == VAR_7 || VAR_6 == VAR_8) ? VAR_9 : VAR_4;
return VAR_3;
}",android/122feb9a0b04290f55183ff2f0384c6c53756bd8/com_android_bluetooth_btservice_AdapterService.cpp/vul/before/0.json,"static jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {
    ALOGV(""%s:"",__FUNCTION__);

    jboolean result = JNI_FALSE;
    if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);
    result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
    return result;
}","static jboolean enableNative(JNIEnv* VAR_0, jobject VAR_1, jboolean VAR_2) {
    ALOGV(""%s:"",VAR_3);

    jboolean VAR_4 = VAR_5;
    if (!VAR_6) return VAR_4;
    int VAR_7 = VAR_6->enable(VAR_2 == VAR_8 ? 1 : 0);
    VAR_4 = (VAR_7 == VAR_9 || VAR_7 == VAR_10) ? VAR_8 : VAR_5;
    return VAR_4;
}",android/122feb9a0b04290f55183ff2f0384c6c53756bd8/com_android_bluetooth_btservice_AdapterService.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,9 @@
-static jboolean enableNative(JNIEnv* env, jobject obj) {
+static jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {
     ALOGV(""%s:"",__FUNCTION__);
 
     jboolean result = JNI_FALSE;
     if (!sBluetoothInterface) return result;
-
-    int ret = sBluetoothInterface->enable();
+    int ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);
     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
     return result;
 }","{'deleted_lines': ['static jboolean enableNative(JNIEnv* env, jobject obj) {', '', '    int ret = sBluetoothInterface->enable();'], 'added_lines': ['static jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {', '    int ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);']}",True,"Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",7.5,HIGH,2,valid,,5
CVE-2016-1711,['CWE-285'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Always use FrameNavigationDisabler during DocumentLoader detach.

BUG=617495

Review-Url: https://codereview.chromium.org/2079473002
Cr-Commit-Position: refs/heads/master@{#400558}
",be655fd4fb9ab3291a855a939496111674037a2f,https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f,third_party/WebKit/Source/core/loader/FrameLoader.cpp,FrameLoader::detachDocumentLoader,"void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader)
{
if (!loader)
return;
loader->detachFromFrame();
loader = nullptr;
}","void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& VAR_0)
{
if (!VAR_0)
return;
VAR_0->detachFromFrame();
VAR_0 = nullptr;
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/before/0.json,"void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader)
{
    if (!loader)
        return;

    FrameNavigationDisabler navigationDisabler(*m_frame);
    loader->detachFromFrame();
    loader = nullptr;
}","void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& VAR_0)
{
    if (!VAR_0)
        return;

    FrameNavigationDisabler VAR_1(*VAR_2);
    VAR_0->detachFromFrame();
    VAR_0 = nullptr;
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
     if (!loader)
         return;
 
+    FrameNavigationDisabler navigationDisabler(*m_frame);
     loader->detachFromFrame();
     loader = nullptr;
 }","{'deleted_lines': [], 'added_lines': ['    FrameNavigationDisabler navigationDisabler(*m_frame);']}",True,"WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",8.8,HIGH,2,valid,,5
CVE-2016-1711,['CWE-285'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Always use FrameNavigationDisabler during DocumentLoader detach.

BUG=617495

Review-Url: https://codereview.chromium.org/2079473002
Cr-Commit-Position: refs/heads/master@{#400558}
",be655fd4fb9ab3291a855a939496111674037a2f,https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f,third_party/WebKit/Source/core/loader/FrameLoader.cpp,FrameLoader::prepareForCommit,"bool FrameLoader::prepareForCommit()
{
PluginScriptForbiddenScope forbidPluginDestructorScripting;
DocumentLoader* pdl = m_provisionalDocumentLoader;
if (m_frame->document()) {
unsigned nodeCount = 0;
for (Frame* frame = m_frame; frame; frame = frame->tree().traverseNext()) {
if (frame->isLocalFrame()) {
LocalFrame* localFrame = toLocalFrame(frame);
nodeCount += localFrame->document()->nodeCount();
}
}
unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter);
float ratio = static_cast<float>(nodeCount) / totalNodeCount;
ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio);
}
SubframeLoadingDisabler disabler(m_frame->document());
if (m_documentLoader) {
client()->dispatchWillClose();
dispatchUnloadEvent();
}
m_frame->detachChildren();
if (pdl != m_provisionalDocumentLoader)
return false;
if (m_documentLoader) {
FrameNavigationDisabler navigationDisabler(*m_frame);
TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
detachDocumentLoader(m_documentLoader);
}
if (!m_frame->client())
return false;
ASSERT(m_provisionalDocumentLoader == pdl);
if (m_frame->document())
m_frame->document()->detach();
m_documentLoader = m_provisionalDocumentLoader.release();
takeObjectSnapshot();
return true;
}","bool FrameLoader::prepareForCommit()
{
PluginScriptForbiddenScope VAR_0;
DocumentLoader* VAR_1 = VAR_2;
if (VAR_3->document()) {
unsigned VAR_4 = 0;
for (Frame* VAR_5 = VAR_3; VAR_5; VAR_5 = VAR_5->tree().traverseNext()) {
if (VAR_5->isLocalFrame()) {
LocalFrame* VAR_6 = toLocalFrame(VAR_5);
VAR_4 += VAR_6->document()->nodeCount();
}
}
unsigned VAR_7 = InstanceCounters::counterValue(InstanceCounters::NodeCounter);
float VAR_8 = VAR_9<float>(VAR_4) / VAR_7;
ThreadState::current()->schedulePageNavigationGCIfNeeded(VAR_8);
}
SubframeLoadingDisabler VAR_10(VAR_3->document());
if (VAR_11) {
client()->dispatchWillClose();
dispatchUnloadEvent();
}
VAR_3->detachChildren();
if (VAR_1 != VAR_2)
return false;
if (VAR_11) {
FrameNavigationDisabler VAR_12(*VAR_3);
TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
detachDocumentLoader(VAR_11);
}
if (!VAR_3->client())
return false;
ASSERT(VAR_2 == VAR_1);
if (VAR_3->document())
VAR_3->document()->detach();
VAR_11 = VAR_2.release();
takeObjectSnapshot();
return true;
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/before/1.json,"bool FrameLoader::prepareForCommit()
{
    PluginScriptForbiddenScope forbidPluginDestructorScripting;
    DocumentLoader* pdl = m_provisionalDocumentLoader;

    if (m_frame->document()) {
        unsigned nodeCount = 0;
        for (Frame* frame = m_frame; frame; frame = frame->tree().traverseNext()) {
            if (frame->isLocalFrame()) {
                LocalFrame* localFrame = toLocalFrame(frame);
                nodeCount += localFrame->document()->nodeCount();
            }
        }
        unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter);
        float ratio = static_cast<float>(nodeCount) / totalNodeCount;
        ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio);
    }

    // Don't allow any new child frames to load in this frame: attaching a new
    // child frame during or after detaching children results in an attached
    // frame on a detached DOM tree, which is bad.
    SubframeLoadingDisabler disabler(m_frame->document());
    if (m_documentLoader) {
        client()->dispatchWillClose();
        dispatchUnloadEvent();
    }
    m_frame->detachChildren();
    // The previous calls to dispatchUnloadEvent() and detachChildren() can
    // execute arbitrary script via things like unload events. If the executed
    // script intiates a new load or causes the current frame to be detached,
    // we need to abandon the current load.
    if (pdl != m_provisionalDocumentLoader)
        return false;
    // detachFromFrame() will abort XHRs that haven't completed, which can
    // trigger event listeners for 'abort'. These event listeners might call
    // window.stop(), which will in turn detach the provisional document loader.
    // At this point, the provisional document loader should not detach, because
    // then the FrameLoader would not have any attached DocumentLoaders.
    if (m_documentLoader) {
        TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
        detachDocumentLoader(m_documentLoader);
    }
    // 'abort' listeners can also detach the frame.
    if (!m_frame->client())
        return false;
    ASSERT(m_provisionalDocumentLoader == pdl);
    // No more events will be dispatched so detach the Document.
    // TODO(yoav): Should we also be nullifying domWindow's document (or domWindow) since the doc is now detached?
    if (m_frame->document())
        m_frame->document()->detach();
    m_documentLoader = m_provisionalDocumentLoader.release();
    takeObjectSnapshot();

    return true;
}","bool FrameLoader::prepareForCommit()
{
    PluginScriptForbiddenScope VAR_0;
    DocumentLoader* VAR_1 = VAR_2;

    if (VAR_3->document()) {
        unsigned VAR_4 = 0;
        for (Frame* VAR_5 = VAR_3; VAR_5; VAR_5 = VAR_5->tree().traverseNext()) {
            if (VAR_5->isLocalFrame()) {
                LocalFrame* VAR_6 = toLocalFrame(VAR_5);
                VAR_4 += VAR_6->document()->nodeCount();
            }
        }
        unsigned VAR_7 = InstanceCounters::counterValue(InstanceCounters::NodeCounter);
        float VAR_8 = VAR_9<float>(VAR_4) / VAR_7;
        ThreadState::current()->schedulePageNavigationGCIfNeeded(VAR_8);
    }

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    SubframeLoadingDisabler VAR_10(VAR_3->document());
    if (VAR_11) {
        client()->dispatchWillClose();
        dispatchUnloadEvent();
    }
    VAR_3->detachChildren();
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    if (VAR_1 != VAR_2)
        return false;
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */
    if (VAR_11) {
        TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
        detachDocumentLoader(VAR_11);
    }
    /* COMMENT_12 */
    if (!VAR_3->client())
        return false;
    ASSERT(VAR_2 == VAR_1);
    /* COMMENT_13 */
    /* COMMENT_14 */
    if (VAR_3->document())
        VAR_3->document()->detach();
    VAR_11 = VAR_2.release();
    takeObjectSnapshot();

    return true;
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -37,7 +37,6 @@
     // At this point, the provisional document loader should not detach, because
     // then the FrameLoader would not have any attached DocumentLoaders.
     if (m_documentLoader) {
-        FrameNavigationDisabler navigationDisabler(*m_frame);
         TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
         detachDocumentLoader(m_documentLoader);
     }","{'deleted_lines': ['        FrameNavigationDisabler navigationDisabler(*m_frame);'], 'added_lines': []}",True,"WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",8.8,HIGH,2,valid,,5
CVE-2016-1711,['CWE-285'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Always use FrameNavigationDisabler during DocumentLoader detach.

BUG=617495

Review-Url: https://codereview.chromium.org/2079473002
Cr-Commit-Position: refs/heads/master@{#400558}
",be655fd4fb9ab3291a855a939496111674037a2f,https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f,third_party/WebKit/Source/core/loader/FrameLoader.cpp,FrameLoader::startLoad,"void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
ASSERT(client()->hasWebView());
if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
return;
NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
ResourceRequest& request = frameLoadRequest.resourceRequest();
if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
return;
m_frame->document()->cancelParsing();
if (m_provisionalDocumentLoader) {
FrameNavigationDisabler navigationDisabler(*m_frame);
detachDocumentLoader(m_provisionalDocumentLoader);
}
if (!m_frame->host())
return;
m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
m_provisionalDocumentLoader->setNavigationType(navigationType);
m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);
InspectorInstrumentation::didStartProvisionalLoad(m_frame);
m_frame->navigationScheduler().cancel();
m_checkTimer.stop();
m_loadType = type;
if (frameLoadRequest.form())
client()->dispatchWillSubmitForm(frameLoadRequest.form());
m_progressTracker->progressStarted();
if (m_provisionalDocumentLoader->isClientRedirect())
m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
ASSERT(m_provisionalDocumentLoader);
m_provisionalDocumentLoader->startLoadingMainResource();
takeObjectSnapshot();
}","void FrameLoader::startLoad(FrameLoadRequest& VAR_0, FrameLoadType VAR_1, NavigationPolicy VAR_2)
{
ASSERT(client()->hasWebView());
if (VAR_3->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
return;
NavigationType VAR_4 = determineNavigationType(VAR_1, VAR_0.resourceRequest().httpBody() || VAR_0.form(), VAR_0.triggeringEvent());
VAR_0.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(VAR_4));
VAR_0.resourceRequest().setFrameType(VAR_3->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
ResourceRequest& VAR_5 = VAR_0.resourceRequest();
if (!shouldContinueForNavigationPolicy(VAR_5, VAR_0.substituteData(), nullptr, VAR_0.shouldCheckMainWorldContentSecurityPolicy(), VAR_4, VAR_2, VAR_1 == VAR_6, VAR_0.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
return;
VAR_3->document()->cancelParsing();
if (VAR_7) {
FrameNavigationDisabler VAR_8(*VAR_3);
detachDocumentLoader(VAR_7);
}
if (!VAR_3->host())
return;
VAR_7 = client()->createDocumentLoader(VAR_3, VAR_5, VAR_0.substituteData().isValid() ? VAR_0.substituteData() : defaultSubstituteDataForURL(VAR_5.url()));
VAR_7->setNavigationType(VAR_4);
VAR_7->setReplacesCurrentHistoryItem(VAR_1 == VAR_6);
VAR_7->setIsClientRedirect(VAR_0.clientRedirect() == ClientRedirectPolicy::ClientRedirect);
InspectorInstrumentation::didStartProvisionalLoad(VAR_3);
VAR_3->navigationScheduler().cancel();
VAR_9.stop();
VAR_10 = VAR_1;
if (VAR_0.form())
client()->dispatchWillSubmitForm(VAR_0.form());
VAR_11->progressStarted();
if (VAR_7->isClientRedirect())
VAR_7->appendRedirect(VAR_3->document()->url());
VAR_7->appendRedirect(VAR_7->request().url());
double VAR_12 = VAR_0.triggeringEvent() ? VAR_0.triggeringEvent()->platformTimeStamp() : 0;
client()->dispatchDidStartProvisionalLoad(VAR_12);
ASSERT(VAR_7);
VAR_7->startLoadingMainResource();
takeObjectSnapshot();
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/before/2.json,"void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;

    m_frame->document()->cancelParsing();
    detachDocumentLoader(m_provisionalDocumentLoader);

    // beforeunload fired above, and detaching a DocumentLoader can fire
    // events, which can detach this frame.
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}","void FrameLoader::startLoad(FrameLoadRequest& VAR_0, FrameLoadType VAR_1, NavigationPolicy VAR_2)
{
    ASSERT(client()->hasWebView());
    if (VAR_3->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType VAR_4 = determineNavigationType(VAR_1, VAR_0.resourceRequest().httpBody() || VAR_0.form(), VAR_0.triggeringEvent());
    VAR_0.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(VAR_4));
    VAR_0.resourceRequest().setFrameType(VAR_3->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& VAR_5 = VAR_0.resourceRequest();
    if (!shouldContinueForNavigationPolicy(VAR_5, VAR_0.substituteData(), nullptr, VAR_0.shouldCheckMainWorldContentSecurityPolicy(), VAR_4, VAR_2, VAR_1 == VAR_6, VAR_0.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;

    VAR_3->document()->cancelParsing();
    detachDocumentLoader(VAR_7);

    /* COMMENT_0 */
    /* COMMENT_1 */
    if (!VAR_3->host())
        return;

    VAR_7 = client()->createDocumentLoader(VAR_3, VAR_5, VAR_0.substituteData().isValid() ? VAR_0.substituteData() : defaultSubstituteDataForURL(VAR_5.url()));
    VAR_7->setNavigationType(VAR_4);
    VAR_7->setReplacesCurrentHistoryItem(VAR_1 == VAR_6);
    VAR_7->setIsClientRedirect(VAR_0.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(VAR_3);

    VAR_3->navigationScheduler().cancel();
    VAR_8.stop();

    VAR_9 = VAR_1;

    if (VAR_0.form())
        client()->dispatchWillSubmitForm(VAR_0.form());

    VAR_10->progressStarted();
    if (VAR_7->isClientRedirect())
        VAR_7->appendRedirect(VAR_3->document()->url());
    VAR_7->appendRedirect(VAR_7->request().url());
    double VAR_11 = VAR_0.triggeringEvent() ? VAR_0.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(VAR_11);
    ASSERT(VAR_7);
    VAR_7->startLoadingMainResource();

    takeObjectSnapshot();
}",chromium/be655fd4fb9ab3291a855a939496111674037a2f/FrameLoader.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -12,10 +12,7 @@
         return;
 
     m_frame->document()->cancelParsing();
-    if (m_provisionalDocumentLoader) {
-        FrameNavigationDisabler navigationDisabler(*m_frame);
-        detachDocumentLoader(m_provisionalDocumentLoader);
-    }
+    detachDocumentLoader(m_provisionalDocumentLoader);
 
     // beforeunload fired above, and detaching a DocumentLoader can fire
     // events, which can detach this frame.","{'deleted_lines': ['    if (m_provisionalDocumentLoader) {', '        FrameNavigationDisabler navigationDisabler(*m_frame);', '        detachDocumentLoader(m_provisionalDocumentLoader);', '    }'], 'added_lines': ['    detachDocumentLoader(m_provisionalDocumentLoader);']}",True,"WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",8.8,HIGH,2,valid,,5
CVE-2016-3830,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,android,"SoftAAC2: fix crash on all-zero adts buffer

Bug: 29153599
Change-Id: I1cb81c054098b86cf24f024f8479909ca7bc85a6
",8e438e153f661e9df8db0ac41d587e940352df06,https://android.googlesource.com/platform/frameworks/av/+/8e438e153f661e9df8db0ac41d587e940352df06,media/libstagefright/codecs/aacdec/SoftAAC2.cpp,SoftAAC2::onQueueFilled,"void SoftAAC2::onQueueFilled(OMX_U32 ) {
if (mSignalledError || mOutputPortSettingsChange != NONE) {
return;
}
UCHAR* inBuffer[FILEREAD_MAX_LAYERS];
UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};
UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};
List<BufferInfo *> &inQueue = getPortQueue(0);
List<BufferInfo *> &outQueue = getPortQueue(1);
while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {
if (!inQueue.empty()) {
INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];
BufferInfo *inInfo = *inQueue.begin();
OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;
if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {
ALOGE(""first buffer should have OMX_BUFFERFLAG_CODECCONFIG set"");
inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;
}
if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {
BufferInfo *inInfo = *inQueue.begin();
OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
inBufferLength[0] = inHeader->nFilledLen;
AAC_DECODER_ERROR decoderErr =
aacDecoder_ConfigRaw(mAACDecoder,
inBuffer,
inBufferLength);
if (decoderErr != AAC_DEC_OK) {
ALOGW(""aacDecoder_ConfigRaw decoderErr = 0x%4.4x"", decoderErr);
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
return;
}
mInputBufferCount++;
mOutputBufferCount++; 
inInfo->mOwnedByUs = false;
inQueue.erase(inQueue.begin());
mLastInHeader = NULL;
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
configureDownmix();
if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {
ALOGI(""Initially configuring decoder: %d Hz, %d channels"",
mStreamInfo->sampleRate,
mStreamInfo->numChannels);
notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
mOutputPortSettingsChange = AWAITING_DISABLED;
}
return;
}
if (inHeader->nFilledLen == 0) {
inInfo->mOwnedByUs = false;
inQueue.erase(inQueue.begin());
mLastInHeader = NULL;
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
continue;
}
if (mIsADTS) {
size_t adtsHeaderSize = 0;
const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;
bool signalError = false;
if (inHeader->nFilledLen < 7) {
ALOGE(""Audio data too short to contain even the ADTS header. ""
""Got %d bytes."", inHeader->nFilledLen);
hexdump(adtsHeader, inHeader->nFilledLen);
signalError = true;
} else {
bool protectionAbsent = (adtsHeader[1] & 1);
unsigned aac_frame_length =
((adtsHeader[3] & 3) << 11)
| (adtsHeader[4] << 3)
| (adtsHeader[5] >> 5);
if (inHeader->nFilledLen < aac_frame_length) {
ALOGE(""Not enough audio data for the complete frame. ""
""Got %d bytes, frame size according to the ADTS ""
""header is %u bytes."",
inHeader->nFilledLen, aac_frame_length);
hexdump(adtsHeader, inHeader->nFilledLen);
signalError = true;
} else {
adtsHeaderSize = (protectionAbsent ? 7 : 9);
inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
inBufferLength[0] = aac_frame_length - adtsHeaderSize;
inHeader->nOffset += adtsHeaderSize;
inHeader->nFilledLen -= adtsHeaderSize;
}
}
if (signalError) {
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);
return;
}
mBufferSizes.add(inBufferLength[0]);
if (mLastInHeader != inHeader) {
mBufferTimestamps.add(inHeader->nTimeStamp);
mLastInHeader = inHeader;
} else {
int64_t currentTime = mBufferTimestamps.top();
currentTime += mStreamInfo->aacSamplesPerFrame *
1000000ll / mStreamInfo->aacSampleRate;
mBufferTimestamps.add(currentTime);
}
} else {
inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
inBufferLength[0] = inHeader->nFilledLen;
mLastInHeader = inHeader;
mBufferTimestamps.add(inHeader->nTimeStamp);
mBufferSizes.add(inHeader->nFilledLen);
}
bytesValid[0] = inBufferLength[0];
INT prevSampleRate = mStreamInfo->sampleRate;
INT prevNumChannels = mStreamInfo->numChannels;
aacDecoder_Fill(mAACDecoder,
inBuffer,
inBufferLength,
bytesValid);
mDrcWrap.submitStreamData(mStreamInfo);
mDrcWrap.update();
UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];
inHeader->nFilledLen -= inBufferUsedLength;
inHeader->nOffset += inBufferUsedLength;
AAC_DECODER_ERROR decoderErr;
int numLoops = 0;
do {
if (outputDelayRingBufferSpaceLeft() <
(mStreamInfo->frameSize * mStreamInfo->numChannels)) {
ALOGV(""skipping decode: not enough space left in ringbuffer"");
break;
}
int numConsumed = mStreamInfo->numTotalBytes;
decoderErr = aacDecoder_DecodeFrame(mAACDecoder,
tmpOutBuffer,
2048 * MAX_CHANNEL_COUNT,
0 );
numConsumed = mStreamInfo->numTotalBytes - numConsumed;
numLoops++;
if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {
break;
}
mDecodedSizes.add(numConsumed);
if (decoderErr != AAC_DEC_OK) {
ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", decoderErr);
}
if (bytesValid[0] != 0) {
ALOGE(""bytesValid[0] != 0 should never happen"");
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
return;
}
size_t numOutBytes =
mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;
if (decoderErr == AAC_DEC_OK) {
if (!outputDelayRingBufferPutSamples(tmpOutBuffer,
mStreamInfo->frameSize * mStreamInfo->numChannels)) {
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
return;
}
} else {
ALOGW(""AAC decoder returned error 0x%4.4x, substituting silence"", decoderErr);
memset(tmpOutBuffer, 0, numOutBytes); 
if (!outputDelayRingBufferPutSamples(tmpOutBuffer,
mStreamInfo->frameSize * mStreamInfo->numChannels)) {
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
return;
}
if (inHeader) {
inHeader->nFilledLen = 0;
}
aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);
mBufferSizes.pop();
int n = 0;
for (int i = 0; i < numLoops; i++) {
n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);
}
mBufferSizes.add(n);
}
if (mInputBufferCount <= 2 || mOutputBufferCount > 1) {                     if (mStreamInfo->sampleRate != prevSampleRate ||
mStreamInfo->numChannels != prevNumChannels) {
ALOGI(""Reconfiguring decoder: %d->%d Hz, %d->%d channels"",
prevSampleRate, mStreamInfo->sampleRate,
prevNumChannels, mStreamInfo->numChannels);
notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
mOutputPortSettingsChange = AWAITING_DISABLED;
if (inHeader && inHeader->nFilledLen == 0) {
inInfo->mOwnedByUs = false;
mInputBufferCount++;
inQueue.erase(inQueue.begin());
mLastInHeader = NULL;
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
}
return;
}
} else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {
ALOGW(""Invalid AAC stream"");
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
return;
}
if (inHeader && inHeader->nFilledLen == 0) {
inInfo->mOwnedByUs = false;
mInputBufferCount++;
inQueue.erase(inQueue.begin());
mLastInHeader = NULL;
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
} else {
ALOGV(""inHeader->nFilledLen = %d"", inHeader ? inHeader->nFilledLen : 0);
}
} while (decoderErr == AAC_DEC_OK);
}
int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;
if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {
int32_t toCompensate = outputDelay - mOutputDelayCompensated;
int32_t discard = outputDelayRingBufferSamplesAvailable();
if (discard > toCompensate) {
discard = toCompensate;
}
int32_t discarded = outputDelayRingBufferGetSamples(0, discard);
mOutputDelayCompensated += discarded;
continue;
}
if (mEndOfInput) {
while (mOutputDelayCompensated > 0) {
INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];
mDrcWrap.submitStreamData(mStreamInfo);
mDrcWrap.update();
AAC_DECODER_ERROR decoderErr =
aacDecoder_DecodeFrame(mAACDecoder,
tmpOutBuffer,
2048 * MAX_CHANNEL_COUNT,
AACDEC_FLUSH);
if (decoderErr != AAC_DEC_OK) {
ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", decoderErr);
}
int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;
if (tmpOutBufferSamples > mOutputDelayCompensated) {
tmpOutBufferSamples = mOutputDelayCompensated;
}
outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);
mOutputDelayCompensated -= tmpOutBufferSamples;
}
}
while (!outQueue.empty()
&& outputDelayRingBufferSamplesAvailable()
>= mStreamInfo->frameSize * mStreamInfo->numChannels) {
BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
if (outHeader->nOffset != 0) {
ALOGE(""outHeader->nOffset != 0 is not handled"");
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
return;
}
INT_PCM *outBuffer =
reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);
int samplesize = mStreamInfo->numChannels * sizeof(int16_t);
if (outHeader->nOffset
+ mStreamInfo->frameSize * samplesize
> outHeader->nAllocLen) {
ALOGE(""buffer overflow"");
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
return;
}
int available = outputDelayRingBufferSamplesAvailable();
int numSamples = outHeader->nAllocLen / sizeof(int16_t);
if (numSamples > available) {
numSamples = available;
}
int64_t currentTime = 0;
if (available) {
int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);
numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);
ALOGV(""%d samples available (%d), or %d frames"",
numSamples, available, numFrames);
int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);
currentTime = *nextTimeStamp;
int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);
for (int i = 0; i < numFrames; i++) {
int32_t decodedSize = mDecodedSizes.itemAt(0);
mDecodedSizes.removeAt(0);
ALOGV(""decoded %d of %d"", decodedSize, *currentBufLeft);
if (*currentBufLeft > decodedSize) {
*currentBufLeft -= decodedSize;
*nextTimeStamp += mStreamInfo->aacSamplesPerFrame *
1000000ll / mStreamInfo->aacSampleRate;
ALOGV(""adjusted nextTimeStamp/size to %lld/%d"",
(long long) *nextTimeStamp, *currentBufLeft);
} else {
if (mBufferTimestamps.size() > 0) {
mBufferTimestamps.removeAt(0);
nextTimeStamp = &mBufferTimestamps.editItemAt(0);
mBufferSizes.removeAt(0);
currentBufLeft = &mBufferSizes.editItemAt(0);
ALOGV(""moved to next time/size: %lld/%d"",
(long long) *nextTimeStamp, *currentBufLeft);
}
numFrames = i + 1;
numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;
break;
}
}
ALOGV(""getting %d from ringbuffer"", numSamples);
int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);
if (ns != numSamples) {
ALOGE(""not a complete frame of samples available"");
mSignalledError = true;
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
return;
}
}
outHeader->nFilledLen = numSamples * sizeof(int16_t);
if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {
outHeader->nFlags = OMX_BUFFERFLAG_EOS;
mEndOfOutput = true;
} else {
outHeader->nFlags = 0;
}
outHeader->nTimeStamp = currentTime;
mOutputBufferCount++;
outInfo->mOwnedByUs = false;
outQueue.erase(outQueue.begin());
outInfo = NULL;
ALOGV(""out timestamp %lld / %d"", outHeader->nTimeStamp, outHeader->nFilledLen);
notifyFillBufferDone(outHeader);
outHeader = NULL;
}
if (mEndOfInput) {
int ringBufAvail = outputDelayRingBufferSamplesAvailable();
if (!outQueue.empty()
&& ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {
if (!mEndOfOutput) {
mEndOfOutput = true;
BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer
+ outHeader->nOffset);
int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);
if (ns < 0) {
ns = 0;
}
outHeader->nFilledLen = ns;
outHeader->nFlags = OMX_BUFFERFLAG_EOS;
outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);
mBufferTimestamps.clear();
mBufferSizes.clear();
mDecodedSizes.clear();
mOutputBufferCount++;
outInfo->mOwnedByUs = false;
outQueue.erase(outQueue.begin());
outInfo = NULL;
notifyFillBufferDone(outHeader);
outHeader = NULL;
}
break;             }
}
}
}","void SoftAAC2::onQueueFilled(OMX_U32 ) {
if (VAR_0 || VAR_1 != VAR_2) {
return;
}
UCHAR* VAR_3[VAR_4];
UINT VAR_5[VAR_4] = {0};
UINT VAR_6[VAR_4] = {0};
List<BufferInfo *> &VAR_7 = getPortQueue(0);
List<BufferInfo *> &VAR_8 = getPortQueue(1);
while ((!VAR_7.empty() || VAR_9) && !VAR_8.empty()) {
if (!VAR_7.empty()) {
INT_PCM VAR_10[2048 * VAR_11];
BufferInfo *VAR_12 = *VAR_7.begin();
OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;
VAR_9 = (VAR_13->nFlags & VAR_14) != 0;
if (VAR_15 == 0 && !(VAR_13->nFlags & VAR_16)) {
ALOGE(""first buffer should have OMX_BUFFERFLAG_CODECCONFIG set"");
VAR_13->nFlags |= VAR_16;
}
if ((VAR_13->nFlags & VAR_16) != 0) {
BufferInfo *VAR_12 = *VAR_7.begin();
OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;
VAR_3[0] = VAR_13->pBuffer + VAR_13->nOffset;
VAR_5[0] = VAR_13->nFilledLen;
AAC_DECODER_ERROR VAR_17 =
aacDecoder_ConfigRaw(VAR_18,
VAR_3,
VAR_5);
if (VAR_17 != VAR_19) {
ALOGW(""aacDecoder_ConfigRaw decoderErr = 0x%4.4x"", VAR_17);
VAR_0 = true;
notify(VAR_20, VAR_21, VAR_17, NULL);
return;
}
VAR_15++;
VAR_22++; 
VAR_12->mOwnedByUs = false;
VAR_7.erase(VAR_7.begin());
VAR_23 = NULL;
VAR_12 = NULL;
notifyEmptyBufferDone(VAR_13);
VAR_13 = NULL;
configureDownmix();
if (VAR_24->sampleRate && VAR_24->numChannels) {
ALOGI(""Initially configuring decoder: %d Hz, %d channels"",
VAR_24->sampleRate,
VAR_24->numChannels);
notify(VAR_25, 1, 0, NULL);
VAR_1 = VAR_26;
}
return;
}
if (VAR_13->nFilledLen == 0) {
VAR_12->mOwnedByUs = false;
VAR_7.erase(VAR_7.begin());
VAR_23 = NULL;
VAR_12 = NULL;
notifyEmptyBufferDone(VAR_13);
VAR_13 = NULL;
continue;
}
if (VAR_27) {
size_t VAR_28 = 0;
const uint8_t *VAR_29 = VAR_13->pBuffer + VAR_13->nOffset;
bool VAR_30 = false;
if (VAR_13->nFilledLen < 7) {
ALOGE(""Audio data too short to contain even the ADTS header. ""
""Got %d bytes."", VAR_13->nFilledLen);
hexdump(VAR_29, VAR_13->nFilledLen);
VAR_30 = true;
} else {
bool VAR_31 = (VAR_29[1] & 1);
unsigned VAR_32 =
((VAR_29[3] & 3) << 11)
| (VAR_29[4] << 3)
| (VAR_29[5] >> 5);
if (VAR_13->nFilledLen < VAR_32) {
ALOGE(""Not enough audio data for the complete frame. ""
""Got %d bytes, frame size according to the ADTS ""
""header is %u bytes."",
VAR_13->nFilledLen, VAR_32);
hexdump(VAR_29, VAR_13->nFilledLen);
VAR_30 = true;
} else {
VAR_28 = (VAR_31 ? 7 : 9);
VAR_3[0] = (UCHAR *)VAR_29 + VAR_28;
VAR_5[0] = VAR_32 - VAR_28;
VAR_13->nOffset += VAR_28;
VAR_13->nFilledLen -= VAR_28;
}
}
if (VAR_30) {
VAR_0 = true;
notify(VAR_20, VAR_33, VAR_34, NULL);
return;
}
VAR_35.add(VAR_5[0]);
if (VAR_23 != VAR_13) {
VAR_36.add(VAR_13->nTimeStamp);
VAR_23 = VAR_13;
} else {
int64_t VAR_37 = VAR_36.top();
VAR_37 += VAR_24->aacSamplesPerFrame *
1000000ll / VAR_24->aacSampleRate;
VAR_36.add(VAR_37);
}
} else {
VAR_3[0] = VAR_13->pBuffer + VAR_13->nOffset;
VAR_5[0] = VAR_13->nFilledLen;
VAR_23 = VAR_13;
VAR_36.add(VAR_13->nTimeStamp);
VAR_35.add(VAR_13->nFilledLen);
}
VAR_6[0] = VAR_5[0];
INT VAR_38 = VAR_24->sampleRate;
INT VAR_39 = VAR_24->numChannels;
aacDecoder_Fill(VAR_18,
VAR_3,
VAR_5,
VAR_6);
VAR_40.submitStreamData(VAR_24);
VAR_40.update();
UINT VAR_41 = VAR_5[0] - VAR_6[0];
VAR_13->nFilledLen -= VAR_41;
VAR_13->nOffset += VAR_41;
AAC_DECODER_ERROR VAR_17;
int VAR_42 = 0;
do {
if (outputDelayRingBufferSpaceLeft() <
(VAR_24->frameSize * VAR_24->numChannels)) {
ALOGV(""skipping decode: not enough space left in ringbuffer"");
break;
}
int VAR_43 = VAR_24->numTotalBytes;
VAR_17 = aacDecoder_DecodeFrame(VAR_18,
VAR_10,
2048 * VAR_11,
0 );
VAR_43 = VAR_24->numTotalBytes - VAR_43;
VAR_42++;
if (VAR_17 == VAR_44) {
break;
}
VAR_45.add(VAR_43);
if (VAR_17 != VAR_19) {
ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", VAR_17);
}
if (VAR_6[0] != 0) {
ALOGE(""bytesValid[0] != 0 should never happen"");
VAR_0 = true;
notify(VAR_20, VAR_21, 0, NULL);
return;
}
size_t VAR_46 =
VAR_24->frameSize * sizeof(int16_t) * VAR_24->numChannels;
if (VAR_17 == VAR_19) {
if (!outputDelayRingBufferPutSamples(VAR_10,
VAR_24->frameSize * VAR_24->numChannels)) {
VAR_0 = true;
notify(VAR_20, VAR_21, VAR_17, NULL);
return;
}
} else {
ALOGW(""AAC decoder returned error 0x%4.4x, substituting silence"", VAR_17);
memset(VAR_10, 0, VAR_46); 
if (!outputDelayRingBufferPutSamples(VAR_10,
VAR_24->frameSize * VAR_24->numChannels)) {
VAR_0 = true;
notify(VAR_20, VAR_21, VAR_17, NULL);
return;
}
if (VAR_13) {
VAR_13->nFilledLen = 0;
}
aacDecoder_SetParam(VAR_18, VAR_47, 1);
VAR_35.pop();
int VAR_48 = 0;
for (int VAR_49 = 0; VAR_49 < VAR_42; VAR_49++) {
VAR_48 += VAR_45.itemAt(VAR_45.size() - VAR_42 + VAR_49);
}
VAR_35.add(VAR_48);
}
if (VAR_15 <= 2 || VAR_22 > 1) { 
if (VAR_24->sampleRate != VAR_38 ||
VAR_24->numChannels != VAR_39) {
ALOGI(""Reconfiguring decoder: %d->%d Hz, %d->%d channels"",
VAR_38, VAR_24->sampleRate,
VAR_39, VAR_24->numChannels);
notify(VAR_25, 1, 0, NULL);
VAR_1 = VAR_26;
if (VAR_13 && VAR_13->nFilledLen == 0) {
VAR_12->mOwnedByUs = false;
VAR_15++;
VAR_7.erase(VAR_7.begin());
VAR_23 = NULL;
VAR_12 = NULL;
notifyEmptyBufferDone(VAR_13);
VAR_13 = NULL;
}
return;
}
} else if (!VAR_24->sampleRate || !VAR_24->numChannels) {
ALOGW(""Invalid AAC stream"");
VAR_0 = true;
notify(VAR_20, VAR_21, VAR_17, NULL);
return;
}
if (VAR_13 && VAR_13->nFilledLen == 0) {
VAR_12->mOwnedByUs = false;
VAR_15++;
VAR_7.erase(VAR_7.begin());
VAR_23 = NULL;
VAR_12 = NULL;
notifyEmptyBufferDone(VAR_13);
VAR_13 = NULL;
} else {
ALOGV(""inHeader->nFilledLen = %d"", VAR_13 ? VAR_13->nFilledLen : 0);
}
} while (VAR_17 == VAR_19);
}
int32_t VAR_50 = VAR_24->outputDelay * VAR_24->numChannels;
if (!VAR_9 && VAR_51 < VAR_50) {
int32_t VAR_52 = VAR_50 - VAR_51;
int32_t VAR_53 = outputDelayRingBufferSamplesAvailable();
if (VAR_53 > VAR_52) {
VAR_53 = VAR_52;
}
int32_t VAR_54 = outputDelayRingBufferGetSamples(0, VAR_53);
VAR_51 += VAR_54;
continue;
}
if (VAR_9) {
while (VAR_51 > 0) {
INT_PCM VAR_10[2048 * VAR_11];
VAR_40.submitStreamData(VAR_24);
VAR_40.update();
AAC_DECODER_ERROR VAR_17 =
aacDecoder_DecodeFrame(VAR_18,
VAR_10,
2048 * VAR_11,
VAR_55);
if (VAR_17 != VAR_19) {
ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", VAR_17);
}
int32_t VAR_56 = VAR_24->frameSize * VAR_24->numChannels;
if (VAR_56 > VAR_51) {
VAR_56 = VAR_51;
}
outputDelayRingBufferPutSamples(VAR_10, VAR_56);
VAR_51 -= VAR_56;
}
}
while (!VAR_8.empty()
&& outputDelayRingBufferSamplesAvailable()
>= VAR_24->frameSize * VAR_24->numChannels) {
BufferInfo *VAR_57 = *VAR_8.begin();
OMX_BUFFERHEADERTYPE *VAR_58 = VAR_57->mHeader;
if (VAR_58->nOffset != 0) {
ALOGE(""outHeader->nOffset != 0 is not handled"");
VAR_0 = true;
notify(VAR_20, VAR_21, 0, NULL);
return;
}
INT_PCM *VAR_59 =
VAR_60<INT_PCM *>(VAR_58->pBuffer + VAR_58->nOffset);
int VAR_61 = VAR_24->numChannels * sizeof(int16_t);
if (VAR_58->nOffset
+ VAR_24->frameSize * VAR_61
> VAR_58->nAllocLen) {
ALOGE(""buffer overflow"");
VAR_0 = true;
notify(VAR_20, VAR_21, 0, NULL);
return;
}
int VAR_62 = outputDelayRingBufferSamplesAvailable();
int VAR_63 = VAR_58->nAllocLen / sizeof(int16_t);
if (VAR_63 > VAR_62) {
VAR_63 = VAR_62;
}
int64_t VAR_37 = 0;
if (VAR_62) {
int VAR_64 = VAR_63 / (VAR_24->frameSize * VAR_24->numChannels);
VAR_63 = VAR_64 * (VAR_24->frameSize * VAR_24->numChannels);
ALOGV(""%d samples available (%d), or %d frames"",
VAR_63, VAR_62, VAR_64);
int64_t *VAR_65 = &VAR_36.editItemAt(0);
VAR_37 = *VAR_65;
int32_t *VAR_66 = &VAR_35.editItemAt(0);
for (int VAR_49 = 0; VAR_49 < VAR_64; VAR_49++) {
int32_t VAR_67 = VAR_45.itemAt(0);
VAR_45.removeAt(0);
ALOGV(""decoded %d of %d"", VAR_67, *VAR_66);
if (*VAR_66 > VAR_67) {
*VAR_66 -= VAR_67;
*VAR_65 += VAR_24->aacSamplesPerFrame *
1000000ll / VAR_24->aacSampleRate;
ALOGV(""adjusted nextTimeStamp/size to %lld/%d"",
(long long) *VAR_65, *VAR_66);
} else {
if (VAR_36.size() > 0) {
VAR_36.removeAt(0);
VAR_65 = &VAR_36.editItemAt(0);
VAR_35.removeAt(0);
VAR_66 = &VAR_35.editItemAt(0);
ALOGV(""moved to next time/size: %lld/%d"",
(long long) *VAR_65, *VAR_66);
}
VAR_64 = VAR_49 + 1;
VAR_63 = VAR_64 * VAR_24->frameSize * VAR_24->numChannels;
break;
}
}
ALOGV(""getting %d from ringbuffer"", VAR_63);
int32_t VAR_68 = outputDelayRingBufferGetSamples(VAR_59, VAR_63);
if (VAR_68 != VAR_63) {
ALOGE(""not a complete frame of samples available"");
VAR_0 = true;
notify(VAR_20, VAR_21, 0, NULL);
return;
}
}
VAR_58->nFilledLen = VAR_63 * sizeof(int16_t);
if (VAR_9 && !VAR_8.empty() && outputDelayRingBufferSamplesAvailable() == 0) {
VAR_58->nFlags = VAR_14;
VAR_69 = true;
} else {
VAR_58->nFlags = 0;
}
VAR_58->nTimeStamp = VAR_37;
VAR_22++;
VAR_57->mOwnedByUs = false;
VAR_8.erase(VAR_8.begin());
VAR_57 = NULL;
ALOGV(""out timestamp %lld / %d"", VAR_58->nTimeStamp, VAR_58->nFilledLen);
notifyFillBufferDone(VAR_58);
VAR_58 = NULL;
}
if (VAR_9) {
int VAR_70 = outputDelayRingBufferSamplesAvailable();
if (!VAR_8.empty()
&& VAR_70 < VAR_24->frameSize * VAR_24->numChannels) {
if (!VAR_69) {
VAR_69 = true;
BufferInfo *VAR_57 = *VAR_8.begin();
OMX_BUFFERHEADERTYPE *VAR_58 = VAR_57->mHeader;
INT_PCM *VAR_59 = VAR_60<INT_PCM *>(VAR_58->pBuffer
+ VAR_58->nOffset);
int32_t VAR_68 = outputDelayRingBufferGetSamples(VAR_59, VAR_70);
if (VAR_68 < 0) {
VAR_68 = 0;
}
VAR_58->nFilledLen = VAR_68;
VAR_58->nFlags = VAR_14;
VAR_58->nTimeStamp = VAR_36.itemAt(0);
VAR_36.clear();
VAR_35.clear();
VAR_45.clear();
VAR_22++;
VAR_57->mOwnedByUs = false;
VAR_8.erase(VAR_8.begin());
VAR_57 = NULL;
notifyFillBufferDone(VAR_58);
VAR_58 = NULL;
}
break; 
}
}
}
}",android/8e438e153f661e9df8db0ac41d587e940352df06/SoftAAC2.cpp/vul/before/0.json,"void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
    if (mSignalledError || mOutputPortSettingsChange != NONE) {
        return;
    }

    UCHAR* inBuffer[FILEREAD_MAX_LAYERS];
    UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};
    UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};

    List<BufferInfo *> &inQueue = getPortQueue(0);
    List<BufferInfo *> &outQueue = getPortQueue(1);

    while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {
        if (!inQueue.empty()) {
            INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];
            BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

            mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;

            if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {
                ALOGE(""first buffer should have OMX_BUFFERFLAG_CODECCONFIG set"");
                inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;
            }
            if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {
                BufferInfo *inInfo = *inQueue.begin();
                OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
                inBufferLength[0] = inHeader->nFilledLen;

                AAC_DECODER_ERROR decoderErr =
                    aacDecoder_ConfigRaw(mAACDecoder,
                                         inBuffer,
                                         inBufferLength);

                if (decoderErr != AAC_DEC_OK) {
                    ALOGW(""aacDecoder_ConfigRaw decoderErr = 0x%4.4x"", decoderErr);
                    mSignalledError = true;
                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                    return;
                }

                mInputBufferCount++;
                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned

                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                mLastInHeader = NULL;
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;

                configureDownmix();
                // Only send out port settings changed event if both sample rate
                // and numChannels are valid.
                if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {
                    ALOGI(""Initially configuring decoder: %d Hz, %d channels"",
                        mStreamInfo->sampleRate,
                        mStreamInfo->numChannels);

                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
                    mOutputPortSettingsChange = AWAITING_DISABLED;
                }
                return;
            }

            if (inHeader->nFilledLen == 0) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                mLastInHeader = NULL;
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
                continue;
            }

            if (mIsADTS) {
                size_t adtsHeaderSize = 0;
                // skip 30 bits, aac_frame_length follows.
                // ssssssss ssssiiip ppffffPc ccohCCll llllllll lll?????

                const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;

                bool signalError = false;
                if (inHeader->nFilledLen < 7) {
                    ALOGE(""Audio data too short to contain even the ADTS header. ""
                            ""Got %d bytes."", inHeader->nFilledLen);
                    hexdump(adtsHeader, inHeader->nFilledLen);
                    signalError = true;
                } else {
                    bool protectionAbsent = (adtsHeader[1] & 1);

                    unsigned aac_frame_length =
                        ((adtsHeader[3] & 3) << 11)
                        | (adtsHeader[4] << 3)
                        | (adtsHeader[5] >> 5);

                    if (inHeader->nFilledLen < aac_frame_length) {
                        ALOGE(""Not enough audio data for the complete frame. ""
                                ""Got %d bytes, frame size according to the ADTS ""
                                ""header is %u bytes."",
                                inHeader->nFilledLen, aac_frame_length);
                        hexdump(adtsHeader, inHeader->nFilledLen);
                        signalError = true;
                    } else {
                        adtsHeaderSize = (protectionAbsent ? 7 : 9);
                        if (aac_frame_length < adtsHeaderSize) {
                            signalError = true;
                        } else {
                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;

                            inHeader->nOffset += adtsHeaderSize;
                            inHeader->nFilledLen -= adtsHeaderSize;
                        }
                    }
                }

                if (signalError) {
                    mSignalledError = true;
                    notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);
                    return;
                }

                // insert buffer size and time stamp
                mBufferSizes.add(inBufferLength[0]);
                if (mLastInHeader != inHeader) {
                    mBufferTimestamps.add(inHeader->nTimeStamp);
                    mLastInHeader = inHeader;
                } else {
                    int64_t currentTime = mBufferTimestamps.top();
                    currentTime += mStreamInfo->aacSamplesPerFrame *
                            1000000ll / mStreamInfo->aacSampleRate;
                    mBufferTimestamps.add(currentTime);
                }
            } else {
                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
                inBufferLength[0] = inHeader->nFilledLen;
                mLastInHeader = inHeader;
                mBufferTimestamps.add(inHeader->nTimeStamp);
                mBufferSizes.add(inHeader->nFilledLen);
            }

            // Fill and decode
            bytesValid[0] = inBufferLength[0];

            INT prevSampleRate = mStreamInfo->sampleRate;
            INT prevNumChannels = mStreamInfo->numChannels;

            aacDecoder_Fill(mAACDecoder,
                            inBuffer,
                            inBufferLength,
                            bytesValid);

            // run DRC check
            mDrcWrap.submitStreamData(mStreamInfo);
            mDrcWrap.update();

            UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];
            inHeader->nFilledLen -= inBufferUsedLength;
            inHeader->nOffset += inBufferUsedLength;

            AAC_DECODER_ERROR decoderErr;
            int numLoops = 0;
            do {
                if (outputDelayRingBufferSpaceLeft() <
                        (mStreamInfo->frameSize * mStreamInfo->numChannels)) {
                    ALOGV(""skipping decode: not enough space left in ringbuffer"");
                    break;
                }

                int numConsumed = mStreamInfo->numTotalBytes;
                decoderErr = aacDecoder_DecodeFrame(mAACDecoder,
                                           tmpOutBuffer,
                                           2048 * MAX_CHANNEL_COUNT,
                                           0 /* flags */);

                numConsumed = mStreamInfo->numTotalBytes - numConsumed;
                numLoops++;

                if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {
                    break;
                }
                mDecodedSizes.add(numConsumed);

                if (decoderErr != AAC_DEC_OK) {
                    ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", decoderErr);
                }

                if (bytesValid[0] != 0) {
                    ALOGE(""bytesValid[0] != 0 should never happen"");
                    mSignalledError = true;
                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                    return;
                }

                size_t numOutBytes =
                    mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;

                if (decoderErr == AAC_DEC_OK) {
                    if (!outputDelayRingBufferPutSamples(tmpOutBuffer,
                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {
                        mSignalledError = true;
                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                        return;
                    }
                } else {
                    ALOGW(""AAC decoder returned error 0x%4.4x, substituting silence"", decoderErr);

                    memset(tmpOutBuffer, 0, numOutBytes); // TODO: check for overflow

                    if (!outputDelayRingBufferPutSamples(tmpOutBuffer,
                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {
                        mSignalledError = true;
                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                        return;
                    }

                    // Discard input buffer.
                    if (inHeader) {
                        inHeader->nFilledLen = 0;
                    }

                    aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);

                    // After an error, replace the last entry in mBufferSizes with the sum of the
                    // last <numLoops> entries from mDecodedSizes to resynchronize the in/out lists.
                    mBufferSizes.pop();
                    int n = 0;
                    for (int i = 0; i < numLoops; i++) {
                        n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);
                    }
                    mBufferSizes.add(n);

                    // fall through
                }

                /*
                 * AAC+/eAAC+ streams can be signalled in two ways: either explicitly
                 * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual
                 * rate system and the sampling rate in the final output is actually
                 * doubled compared with the core AAC decoder sampling rate.
                 *
                 * Explicit signalling is done by explicitly defining SBR audio object
                 * type in the bitstream. Implicit signalling is done by embedding
                 * SBR content in AAC extension payload specific to SBR, and hence
                 * requires an AAC decoder to perform pre-checks on actual audio frames.
                 *
                 * Thus, we could not say for sure whether a stream is
                 * AAC+/eAAC+ until the first data frame is decoded.
                 */
                if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1
                    if (mStreamInfo->sampleRate != prevSampleRate ||
                        mStreamInfo->numChannels != prevNumChannels) {
                        ALOGI(""Reconfiguring decoder: %d->%d Hz, %d->%d channels"",
                              prevSampleRate, mStreamInfo->sampleRate,
                              prevNumChannels, mStreamInfo->numChannels);

                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
                        mOutputPortSettingsChange = AWAITING_DISABLED;

                        if (inHeader && inHeader->nFilledLen == 0) {
                            inInfo->mOwnedByUs = false;
                            mInputBufferCount++;
                            inQueue.erase(inQueue.begin());
                            mLastInHeader = NULL;
                            inInfo = NULL;
                            notifyEmptyBufferDone(inHeader);
                            inHeader = NULL;
                        }
                        return;
                    }
                } else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {
                    ALOGW(""Invalid AAC stream"");
                    mSignalledError = true;
                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                    return;
                }
                if (inHeader && inHeader->nFilledLen == 0) {
                    inInfo->mOwnedByUs = false;
                    mInputBufferCount++;
                    inQueue.erase(inQueue.begin());
                    mLastInHeader = NULL;
                    inInfo = NULL;
                    notifyEmptyBufferDone(inHeader);
                    inHeader = NULL;
                } else {
                    ALOGV(""inHeader->nFilledLen = %d"", inHeader ? inHeader->nFilledLen : 0);
                }
            } while (decoderErr == AAC_DEC_OK);
        }

        int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;

        if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {
            // discard outputDelay at the beginning
            int32_t toCompensate = outputDelay - mOutputDelayCompensated;
            int32_t discard = outputDelayRingBufferSamplesAvailable();
            if (discard > toCompensate) {
                discard = toCompensate;
            }
            int32_t discarded = outputDelayRingBufferGetSamples(0, discard);
            mOutputDelayCompensated += discarded;
            continue;
        }

        if (mEndOfInput) {
            while (mOutputDelayCompensated > 0) {
                // a buffer big enough for MAX_CHANNEL_COUNT channels of decoded HE-AAC
                INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];
 
                 // run DRC check
                 mDrcWrap.submitStreamData(mStreamInfo);
                 mDrcWrap.update();

                AAC_DECODER_ERROR decoderErr =
                    aacDecoder_DecodeFrame(mAACDecoder,
                                           tmpOutBuffer,
                                           2048 * MAX_CHANNEL_COUNT,
                                           AACDEC_FLUSH);
                if (decoderErr != AAC_DEC_OK) {
                    ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", decoderErr);
                }

                int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;
                if (tmpOutBufferSamples > mOutputDelayCompensated) {
                    tmpOutBufferSamples = mOutputDelayCompensated;
                }
                outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);
                mOutputDelayCompensated -= tmpOutBufferSamples;
            }
        }

        while (!outQueue.empty()
                && outputDelayRingBufferSamplesAvailable()
                        >= mStreamInfo->frameSize * mStreamInfo->numChannels) {
            BufferInfo *outInfo = *outQueue.begin();
            OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

            if (outHeader->nOffset != 0) {
                ALOGE(""outHeader->nOffset != 0 is not handled"");
                mSignalledError = true;
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                return;
            }

            INT_PCM *outBuffer =
                    reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);
            int samplesize = mStreamInfo->numChannels * sizeof(int16_t);
            if (outHeader->nOffset
                    + mStreamInfo->frameSize * samplesize
                    > outHeader->nAllocLen) {
                ALOGE(""buffer overflow"");
                mSignalledError = true;
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                return;

            }

            int available = outputDelayRingBufferSamplesAvailable();
            int numSamples = outHeader->nAllocLen / sizeof(int16_t);
            if (numSamples > available) {
                numSamples = available;
            }
            int64_t currentTime = 0;
            if (available) {

                int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);
                numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);

                ALOGV(""%d samples available (%d), or %d frames"",
                        numSamples, available, numFrames);
                int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);
                currentTime = *nextTimeStamp;
                int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);
                for (int i = 0; i < numFrames; i++) {
                    int32_t decodedSize = mDecodedSizes.itemAt(0);
                    mDecodedSizes.removeAt(0);
                    ALOGV(""decoded %d of %d"", decodedSize, *currentBufLeft);
                    if (*currentBufLeft > decodedSize) {
                        // adjust/interpolate next time stamp
                        *currentBufLeft -= decodedSize;
                        *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *
                                1000000ll / mStreamInfo->aacSampleRate;
                        ALOGV(""adjusted nextTimeStamp/size to %lld/%d"",
                                (long long) *nextTimeStamp, *currentBufLeft);
                    } else {
                        // move to next timestamp in list
                        if (mBufferTimestamps.size() > 0) {
                            mBufferTimestamps.removeAt(0);
                            nextTimeStamp = &mBufferTimestamps.editItemAt(0);
                            mBufferSizes.removeAt(0);
                            currentBufLeft = &mBufferSizes.editItemAt(0);
                            ALOGV(""moved to next time/size: %lld/%d"",
                                    (long long) *nextTimeStamp, *currentBufLeft);
                        }
                        // try to limit output buffer size to match input buffers
                        // (e.g when an input buffer contained 4 ""sub"" frames, output
                        // at most 4 decoded units in the corresponding output buffer)
                        // This is optional. Remove the next three lines to fill the output
                        // buffer with as many units as available.
                        numFrames = i + 1;
                        numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;
                        break;
                    }
                }

                ALOGV(""getting %d from ringbuffer"", numSamples);
                int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);
                if (ns != numSamples) {
                    ALOGE(""not a complete frame of samples available"");
                    mSignalledError = true;
                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                    return;
                }
            }

            outHeader->nFilledLen = numSamples * sizeof(int16_t);

            if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;
                mEndOfOutput = true;
            } else {
                outHeader->nFlags = 0;
            }

            outHeader->nTimeStamp = currentTime;

            mOutputBufferCount++;
            outInfo->mOwnedByUs = false;
            outQueue.erase(outQueue.begin());
            outInfo = NULL;
            ALOGV(""out timestamp %lld / %d"", outHeader->nTimeStamp, outHeader->nFilledLen);
            notifyFillBufferDone(outHeader);
            outHeader = NULL;
        }

        if (mEndOfInput) {
            int ringBufAvail = outputDelayRingBufferSamplesAvailable();
            if (!outQueue.empty()
                    && ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {
                if (!mEndOfOutput) {
                    // send partial or empty block signaling EOS
                    mEndOfOutput = true;
                    BufferInfo *outInfo = *outQueue.begin();
                    OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

                    INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer
                            + outHeader->nOffset);
                    int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);
                    if (ns < 0) {
                        ns = 0;
                    }
                    outHeader->nFilledLen = ns;
                    outHeader->nFlags = OMX_BUFFERFLAG_EOS;

                    outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);
                    mBufferTimestamps.clear();
                    mBufferSizes.clear();
                    mDecodedSizes.clear();

                    mOutputBufferCount++;
                    outInfo->mOwnedByUs = false;
                    outQueue.erase(outQueue.begin());
                    outInfo = NULL;
                    notifyFillBufferDone(outHeader);
                    outHeader = NULL;
                }
                break; // if outQueue not empty but no more output
            }
        }
    }
}","void SoftAAC2::onQueueFilled(OMX_U32 /* COMMENT_0 */) {
    if (VAR_0 || VAR_1 != VAR_2) {
        return;
    }

    UCHAR* VAR_3[VAR_4];
    UINT VAR_5[VAR_4] = {0};
    UINT VAR_6[VAR_4] = {0};

    List<BufferInfo *> &VAR_7 = getPortQueue(0);
    List<BufferInfo *> &VAR_8 = getPortQueue(1);

    while ((!VAR_7.empty() || VAR_9) && !VAR_8.empty()) {
        if (!VAR_7.empty()) {
            INT_PCM VAR_10[2048 * VAR_11];
            BufferInfo *VAR_12 = *VAR_7.begin();
            OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;

            VAR_9 = (VAR_13->nFlags & VAR_14) != 0;

            if (VAR_15 == 0 && !(VAR_13->nFlags & VAR_16)) {
                ALOGE(""first buffer should have OMX_BUFFERFLAG_CODECCONFIG set"");
                VAR_13->nFlags |= VAR_16;
            }
            if ((VAR_13->nFlags & VAR_16) != 0) {
                BufferInfo *VAR_12 = *VAR_7.begin();
                OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;

                VAR_3[0] = VAR_13->pBuffer + VAR_13->nOffset;
                VAR_5[0] = VAR_13->nFilledLen;

                AAC_DECODER_ERROR VAR_17 =
                    aacDecoder_ConfigRaw(VAR_18,
                                         VAR_3,
                                         VAR_5);

                if (VAR_17 != VAR_19) {
                    ALOGW(""aacDecoder_ConfigRaw decoderErr = 0x%4.4x"", VAR_17);
                    VAR_0 = true;
                    notify(VAR_20, VAR_21, VAR_17, NULL);
                    return;
                }

                VAR_15++;
                VAR_22++; /* COMMENT_1 */

                VAR_12->mOwnedByUs = false;
                VAR_7.erase(VAR_7.begin());
                VAR_23 = NULL;
                VAR_12 = NULL;
                notifyEmptyBufferDone(VAR_13);
                VAR_13 = NULL;

                configureDownmix();
                /* COMMENT_2 */
                /* COMMENT_3 */
                if (VAR_24->sampleRate && VAR_24->numChannels) {
                    ALOGI(""Initially configuring decoder: %d Hz, %d channels"",
                        VAR_24->sampleRate,
                        VAR_24->numChannels);

                    notify(VAR_25, 1, 0, NULL);
                    VAR_1 = VAR_26;
                }
                return;
            }

            if (VAR_13->nFilledLen == 0) {
                VAR_12->mOwnedByUs = false;
                VAR_7.erase(VAR_7.begin());
                VAR_23 = NULL;
                VAR_12 = NULL;
                notifyEmptyBufferDone(VAR_13);
                VAR_13 = NULL;
                continue;
            }

            if (VAR_27) {
                size_t VAR_28 = 0;
                /* COMMENT_4 */
                /* COMMENT_5 */

                const uint8_t *VAR_29 = VAR_13->pBuffer + VAR_13->nOffset;

                bool VAR_30 = false;
                if (VAR_13->nFilledLen < 7) {
                    ALOGE(""Audio data too short to contain even the ADTS header. ""
                            ""Got %d bytes."", VAR_13->nFilledLen);
                    hexdump(VAR_29, VAR_13->nFilledLen);
                    VAR_30 = true;
                } else {
                    bool VAR_31 = (VAR_29[1] & 1);

                    unsigned VAR_32 =
                        ((VAR_29[3] & 3) << 11)
                        | (VAR_29[4] << 3)
                        | (VAR_29[5] >> 5);

                    if (VAR_13->nFilledLen < VAR_32) {
                        ALOGE(""Not enough audio data for the complete frame. ""
                                ""Got %d bytes, frame size according to the ADTS ""
                                ""header is %u bytes."",
                                VAR_13->nFilledLen, VAR_32);
                        hexdump(VAR_29, VAR_13->nFilledLen);
                        VAR_30 = true;
                    } else {
                        VAR_28 = (VAR_31 ? 7 : 9);
                        if (VAR_32 < VAR_28) {
                            VAR_30 = true;
                        } else {
                            VAR_3[0] = (UCHAR *)VAR_29 + VAR_28;
                            VAR_5[0] = VAR_32 - VAR_28;

                            VAR_13->nOffset += VAR_28;
                            VAR_13->nFilledLen -= VAR_28;
                        }
                    }
                }

                if (VAR_30) {
                    VAR_0 = true;
                    notify(VAR_20, VAR_33, VAR_34, NULL);
                    return;
                }

                /* COMMENT_6 */
                VAR_35.add(VAR_5[0]);
                if (VAR_23 != VAR_13) {
                    VAR_36.add(VAR_13->nTimeStamp);
                    VAR_23 = VAR_13;
                } else {
                    int64_t VAR_37 = VAR_36.top();
                    VAR_37 += VAR_24->aacSamplesPerFrame *
                            1000000ll / VAR_24->aacSampleRate;
                    VAR_36.add(VAR_37);
                }
            } else {
                VAR_3[0] = VAR_13->pBuffer + VAR_13->nOffset;
                VAR_5[0] = VAR_13->nFilledLen;
                VAR_23 = VAR_13;
                VAR_36.add(VAR_13->nTimeStamp);
                VAR_35.add(VAR_13->nFilledLen);
            }

            /* COMMENT_7 */
            VAR_6[0] = VAR_5[0];

            INT VAR_38 = VAR_24->sampleRate;
            INT VAR_39 = VAR_24->numChannels;

            aacDecoder_Fill(VAR_18,
                            VAR_3,
                            VAR_5,
                            VAR_6);

            /* COMMENT_8 */
            VAR_40.submitStreamData(VAR_24);
            VAR_40.update();

            UINT VAR_41 = VAR_5[0] - VAR_6[0];
            VAR_13->nFilledLen -= VAR_41;
            VAR_13->nOffset += VAR_41;

            AAC_DECODER_ERROR VAR_17;
            int VAR_42 = 0;
            do {
                if (outputDelayRingBufferSpaceLeft() <
                        (VAR_24->frameSize * VAR_24->numChannels)) {
                    ALOGV(""skipping decode: not enough space left in ringbuffer"");
                    break;
                }

                int VAR_43 = VAR_24->numTotalBytes;
                VAR_17 = aacDecoder_DecodeFrame(VAR_18,
                                           VAR_10,
                                           2048 * VAR_11,
                                           0 /* COMMENT_9 */);

                VAR_43 = VAR_24->numTotalBytes - VAR_43;
                VAR_42++;

                if (VAR_17 == VAR_44) {
                    break;
                }
                VAR_45.add(VAR_43);

                if (VAR_17 != VAR_19) {
                    ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", VAR_17);
                }

                if (VAR_6[0] != 0) {
                    ALOGE(""bytesValid[0] != 0 should never happen"");
                    VAR_0 = true;
                    notify(VAR_20, VAR_21, 0, NULL);
                    return;
                }

                size_t VAR_46 =
                    VAR_24->frameSize * sizeof(int16_t) * VAR_24->numChannels;

                if (VAR_17 == VAR_19) {
                    if (!outputDelayRingBufferPutSamples(VAR_10,
                            VAR_24->frameSize * VAR_24->numChannels)) {
                        VAR_0 = true;
                        notify(VAR_20, VAR_21, VAR_17, NULL);
                        return;
                    }
                } else {
                    ALOGW(""AAC decoder returned error 0x%4.4x, substituting silence"", VAR_17);

                    memset(VAR_10, 0, VAR_46); /* COMMENT_10 */

                    if (!outputDelayRingBufferPutSamples(VAR_10,
                            VAR_24->frameSize * VAR_24->numChannels)) {
                        VAR_0 = true;
                        notify(VAR_20, VAR_21, VAR_17, NULL);
                        return;
                    }

                    /* COMMENT_11 */
                    if (VAR_13) {
                        VAR_13->nFilledLen = 0;
                    }

                    aacDecoder_SetParam(VAR_18, VAR_47, 1);

                    /* COMMENT_12 */
                    /* COMMENT_13 */
                    VAR_35.pop();
                    int VAR_48 = 0;
                    for (int VAR_49 = 0; VAR_49 < VAR_42; VAR_49++) {
                        VAR_48 += VAR_45.itemAt(VAR_45.size() - VAR_42 + VAR_49);
                    }
                    VAR_35.add(VAR_48);

                    /* COMMENT_14 */
                }

                /* COMMENT_15 */
                                                                                     
                                                                               
                                                                                    
                                                                            
                  
                                                                                      
                                                                                  
                                                                                  
                                                                                        
                  
                                                                      
                                                                    
                   
                if (VAR_15 <= 2 || VAR_22 > 1) { /* COMMENT_28 */
                    if (VAR_24->sampleRate != VAR_38 ||
                        VAR_24->numChannels != VAR_39) {
                        ALOGI(""Reconfiguring decoder: %d->%d Hz, %d->%d channels"",
                              VAR_38, VAR_24->sampleRate,
                              VAR_39, VAR_24->numChannels);

                        notify(VAR_25, 1, 0, NULL);
                        VAR_1 = VAR_26;

                        if (VAR_13 && VAR_13->nFilledLen == 0) {
                            VAR_12->mOwnedByUs = false;
                            VAR_15++;
                            VAR_7.erase(VAR_7.begin());
                            VAR_23 = NULL;
                            VAR_12 = NULL;
                            notifyEmptyBufferDone(VAR_13);
                            VAR_13 = NULL;
                        }
                        return;
                    }
                } else if (!VAR_24->sampleRate || !VAR_24->numChannels) {
                    ALOGW(""Invalid AAC stream"");
                    VAR_0 = true;
                    notify(VAR_20, VAR_21, VAR_17, NULL);
                    return;
                }
                if (VAR_13 && VAR_13->nFilledLen == 0) {
                    VAR_12->mOwnedByUs = false;
                    VAR_15++;
                    VAR_7.erase(VAR_7.begin());
                    VAR_23 = NULL;
                    VAR_12 = NULL;
                    notifyEmptyBufferDone(VAR_13);
                    VAR_13 = NULL;
                } else {
                    ALOGV(""inHeader->nFilledLen = %d"", VAR_13 ? VAR_13->nFilledLen : 0);
                }
            } while (VAR_17 == VAR_19);
        }

        int32_t VAR_50 = VAR_24->outputDelay * VAR_24->numChannels;

        if (!VAR_9 && VAR_51 < VAR_50) {
            /* COMMENT_29 */
            int32_t VAR_52 = VAR_50 - VAR_51;
            int32_t VAR_53 = outputDelayRingBufferSamplesAvailable();
            if (VAR_53 > VAR_52) {
                VAR_53 = VAR_52;
            }
            int32_t VAR_54 = outputDelayRingBufferGetSamples(0, VAR_53);
            VAR_51 += VAR_54;
            continue;
        }

        if (VAR_9) {
            while (VAR_51 > 0) {
                /* COMMENT_30 */
                INT_PCM VAR_10[2048 * VAR_11];
 
                 /* COMMENT_8 */
                 VAR_40.submitStreamData(VAR_24);
                 VAR_40.update();

                AAC_DECODER_ERROR VAR_17 =
                    aacDecoder_DecodeFrame(VAR_18,
                                           VAR_10,
                                           2048 * VAR_11,
                                           VAR_55);
                if (VAR_17 != VAR_19) {
                    ALOGW(""aacDecoder_DecodeFrame decoderErr = 0x%4.4x"", VAR_17);
                }

                int32_t VAR_56 = VAR_24->frameSize * VAR_24->numChannels;
                if (VAR_56 > VAR_51) {
                    VAR_56 = VAR_51;
                }
                outputDelayRingBufferPutSamples(VAR_10, VAR_56);
                VAR_51 -= VAR_56;
            }
        }

        while (!VAR_8.empty()
                && outputDelayRingBufferSamplesAvailable()
                        >= VAR_24->frameSize * VAR_24->numChannels) {
            BufferInfo *VAR_57 = *VAR_8.begin();
            OMX_BUFFERHEADERTYPE *VAR_58 = VAR_57->mHeader;

            if (VAR_58->nOffset != 0) {
                ALOGE(""outHeader->nOffset != 0 is not handled"");
                VAR_0 = true;
                notify(VAR_20, VAR_21, 0, NULL);
                return;
            }

            INT_PCM *VAR_59 =
                    VAR_60<INT_PCM *>(VAR_58->pBuffer + VAR_58->nOffset);
            int VAR_61 = VAR_24->numChannels * sizeof(int16_t);
            if (VAR_58->nOffset
                    + VAR_24->frameSize * VAR_61
                    > VAR_58->nAllocLen) {
                ALOGE(""buffer overflow"");
                VAR_0 = true;
                notify(VAR_20, VAR_21, 0, NULL);
                return;

            }

            int VAR_62 = outputDelayRingBufferSamplesAvailable();
            int VAR_63 = VAR_58->nAllocLen / sizeof(int16_t);
            if (VAR_63 > VAR_62) {
                VAR_63 = VAR_62;
            }
            int64_t VAR_37 = 0;
            if (VAR_62) {

                int VAR_64 = VAR_63 / (VAR_24->frameSize * VAR_24->numChannels);
                VAR_63 = VAR_64 * (VAR_24->frameSize * VAR_24->numChannels);

                ALOGV(""%d samples available (%d), or %d frames"",
                        VAR_63, VAR_62, VAR_64);
                int64_t *VAR_65 = &VAR_36.editItemAt(0);
                VAR_37 = *VAR_65;
                int32_t *VAR_66 = &VAR_35.editItemAt(0);
                for (int VAR_49 = 0; VAR_49 < VAR_64; VAR_49++) {
                    int32_t VAR_67 = VAR_45.itemAt(0);
                    VAR_45.removeAt(0);
                    ALOGV(""decoded %d of %d"", VAR_67, *VAR_66);
                    if (*VAR_66 > VAR_67) {
                        /* COMMENT_31 */
                        *VAR_66 -= VAR_67;
                        *VAR_65 += VAR_24->aacSamplesPerFrame *
                                1000000ll / VAR_24->aacSampleRate;
                        ALOGV(""adjusted nextTimeStamp/size to %lld/%d"",
                                (long long) *VAR_65, *VAR_66);
                    } else {
                        /* COMMENT_32 */
                        if (VAR_36.size() > 0) {
                            VAR_36.removeAt(0);
                            VAR_65 = &VAR_36.editItemAt(0);
                            VAR_35.removeAt(0);
                            VAR_66 = &VAR_35.editItemAt(0);
                            ALOGV(""moved to next time/size: %lld/%d"",
                                    (long long) *VAR_65, *VAR_66);
                        }
                        /* COMMENT_33 */
                        /* COMMENT_34 */
                        /* COMMENT_35 */
                        /* COMMENT_36 */
                        /* COMMENT_37 */
                        VAR_64 = VAR_49 + 1;
                        VAR_63 = VAR_64 * VAR_24->frameSize * VAR_24->numChannels;
                        break;
                    }
                }

                ALOGV(""getting %d from ringbuffer"", VAR_63);
                int32_t VAR_68 = outputDelayRingBufferGetSamples(VAR_59, VAR_63);
                if (VAR_68 != VAR_63) {
                    ALOGE(""not a complete frame of samples available"");
                    VAR_0 = true;
                    notify(VAR_20, VAR_21, 0, NULL);
                    return;
                }
            }

            VAR_58->nFilledLen = VAR_63 * sizeof(int16_t);

            if (VAR_9 && !VAR_8.empty() && outputDelayRingBufferSamplesAvailable() == 0) {
                VAR_58->nFlags = VAR_14;
                VAR_69 = true;
            } else {
                VAR_58->nFlags = 0;
            }

            VAR_58->nTimeStamp = VAR_37;

            VAR_22++;
            VAR_57->mOwnedByUs = false;
            VAR_8.erase(VAR_8.begin());
            VAR_57 = NULL;
            ALOGV(""out timestamp %lld / %d"", VAR_58->nTimeStamp, VAR_58->nFilledLen);
            notifyFillBufferDone(VAR_58);
            VAR_58 = NULL;
        }

        if (VAR_9) {
            int VAR_70 = outputDelayRingBufferSamplesAvailable();
            if (!VAR_8.empty()
                    && VAR_70 < VAR_24->frameSize * VAR_24->numChannels) {
                if (!VAR_69) {
                    /* COMMENT_38 */
                    VAR_69 = true;
                    BufferInfo *VAR_57 = *VAR_8.begin();
                    OMX_BUFFERHEADERTYPE *VAR_58 = VAR_57->mHeader;

                    INT_PCM *VAR_59 = VAR_60<INT_PCM *>(VAR_58->pBuffer
                            + VAR_58->nOffset);
                    int32_t VAR_68 = outputDelayRingBufferGetSamples(VAR_59, VAR_70);
                    if (VAR_68 < 0) {
                        VAR_68 = 0;
                    }
                    VAR_58->nFilledLen = VAR_68;
                    VAR_58->nFlags = VAR_14;

                    VAR_58->nTimeStamp = VAR_36.itemAt(0);
                    VAR_36.clear();
                    VAR_35.clear();
                    VAR_45.clear();

                    VAR_22++;
                    VAR_57->mOwnedByUs = false;
                    VAR_8.erase(VAR_8.begin());
                    VAR_57 = NULL;
                    notifyFillBufferDone(VAR_58);
                    VAR_58 = NULL;
                }
                break; /* COMMENT_39 */
            }
        }
    }
}",android/8e438e153f661e9df8db0ac41d587e940352df06/SoftAAC2.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -105,12 +105,15 @@
                         signalError = true;
                     } else {
                         adtsHeaderSize = (protectionAbsent ? 7 : 9);
-
-                        inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
-                        inBufferLength[0] = aac_frame_length - adtsHeaderSize;
-
-                        inHeader->nOffset += adtsHeaderSize;
-                        inHeader->nFilledLen -= adtsHeaderSize;
+                        if (aac_frame_length < adtsHeaderSize) {
+                            signalError = true;
+                        } else {
+                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
+                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;
+
+                            inHeader->nOffset += adtsHeaderSize;
+                            inHeader->nFilledLen -= adtsHeaderSize;
+                        }
                     }
                 }
 ","{'deleted_lines': ['', '                        inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;', '                        inBufferLength[0] = aac_frame_length - adtsHeaderSize;', '', '                        inHeader->nOffset += adtsHeaderSize;', '                        inHeader->nFilledLen -= adtsHeaderSize;'], 'added_lines': ['                        if (aac_frame_length < adtsHeaderSize) {', '                            signalError = true;', '                        } else {', '                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;', '                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;', '', '                            inHeader->nOffset += adtsHeaderSize;', '                            inHeader->nFilledLen -= adtsHeaderSize;', '                        }']}",True,"codecs/aacdec/SoftAAC2.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows remote attackers to cause a denial of service (device hang or reboot) via crafted ADTS data, aka internal bug 29153599.",5.5,MEDIUM,1,valid,,5
CVE-2016-5140,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pdfium,"openjpeg: Prevent a buffer overflow in opj_j2k_read_SQcd_SQcc.

BUG=chromium:619405

R=ochang@chromium.org

Review-Url: https://codereview.chromium.org/2071773002
",338a6b75994eb148d429b7abccfffaf7ae9f9b55,https://pdfium.googlesource.com/pdfium/+/338a6b75994eb148d429b7abccfffaf7ae9f9b55,third_party/libopenjpeg20/j2k.c,opj_j2k_read_SQcd_SQcc,"static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,
OPJ_UINT32 p_comp_no,
OPJ_BYTE* p_header_data,
OPJ_UINT32 * p_header_size,
opj_event_mgr_t * p_manager
)
{
OPJ_UINT32 l_band_no;
opj_cp_t *l_cp = 00;
opj_tcp_t *l_tcp = 00;
opj_tccp_t *l_tccp = 00;
OPJ_BYTE * l_current_ptr = 00;
OPJ_UINT32 l_tmp, l_num_band;
assert(p_j2k != 00);
assert(p_manager != 00);
assert(p_header_data != 00);
l_cp = &(p_j2k->m_cp);
l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? 
&l_cp->tcps[p_j2k->m_current_tile_number] :
p_j2k->m_specific_param.m_decoder.m_default_tcp;
assert(p_comp_no <  p_j2k->m_private_image->numcomps);
l_tccp = &l_tcp->tccps[p_comp_no];
l_current_ptr = p_header_data;
if (*p_header_size < 1) {
opj_event_msg(p_manager, EVT_ERROR, ""Error reading SQcd or SQcc element\n"");
return OPJ_FALSE;
}
*p_header_size -= 1;
opj_read_bytes(l_current_ptr, &l_tmp ,1);                       
++l_current_ptr;
l_tccp->qntsty = l_tmp & 0x1f;
l_tccp->numgbits = l_tmp >> 5;
if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
l_num_band = 1;
}
else {
l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?
(*p_header_size) :
(*p_header_size) / 2;
if( l_num_band > OPJ_J2K_MAXBANDS ) {
opj_event_msg(p_manager, EVT_WARNING, ""While reading CCP_QNTSTY element inside QCD or QCC marker segment, ""
""number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to ""
""OPJ_J2K_MAXBANDS (%d) and skip the rest. \n"", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);
}
}
#ifdef USE_JPWL
if (l_cp->correct) {
if ( (l_num_band >= OPJ_J2K_MAXBANDS)) {
opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
""JPWL: bad number of subbands in Sqcx (%d)\n"",
l_num_band);
if (!JPWL_ASSUME) {
opj_event_msg(p_manager, EVT_ERROR, ""JPWL: giving up\n"");
return OPJ_FALSE;
}
l_num_band = 1;
opj_event_msg(p_manager, EVT_WARNING, ""- trying to adjust them\n""
""- setting number of bands to %d => HYPOTHESIS!!!\n"",
l_num_band);
};
};
#endif 
if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
opj_read_bytes(l_current_ptr, &l_tmp ,1);                       
++l_current_ptr;
if (l_band_no < OPJ_J2K_MAXBANDS){
l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);
l_tccp->stepsizes[l_band_no].mant = 0;
}
}
*p_header_size = *p_header_size - l_num_band;
}
else {
for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
opj_read_bytes(l_current_ptr, &l_tmp ,2);                       
l_current_ptr+=2;
if (l_band_no < OPJ_J2K_MAXBANDS){
l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);
l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;
}
}
*p_header_size = *p_header_size - 2*l_num_band;
}
if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {
l_tccp->stepsizes[l_band_no].expn =
((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?
(OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;
l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
}
}
return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *VAR_0,
OPJ_UINT32 VAR_1,
OPJ_BYTE* VAR_2,
OPJ_UINT32 * VAR_3,
opj_event_mgr_t * VAR_4
)
{
OPJ_UINT32 VAR_5;
opj_cp_t *VAR_6 = 00;
opj_tcp_t *VAR_7 = 00;
opj_tccp_t *VAR_8 = 00;
OPJ_BYTE * VAR_9 = 00;
OPJ_UINT32 VAR_10, VAR_11;
assert(VAR_0 != 00);
assert(VAR_4 != 00);
assert(VAR_2 != 00);
VAR_6 = &(VAR_0->m_cp);
VAR_7 = (VAR_0->m_specific_param.m_decoder.m_state == VAR_12) ? 
&VAR_6->tcps[VAR_0->m_current_tile_number] :
VAR_0->m_specific_param.m_decoder.m_default_tcp;
assert(VAR_1 <  VAR_0->m_private_image->numcomps);
VAR_8 = &VAR_7->tccps[VAR_1];
VAR_9 = VAR_2;
if (*VAR_3 < 1) {
opj_event_msg(VAR_4, VAR_13, ""Error reading SQcd or SQcc element\n"");
return VAR_14;
}
*VAR_3 -= 1;
opj_read_bytes(VAR_9, &VAR_10 ,1);                       
++VAR_9;
VAR_8->qntsty = VAR_10 & 0x1f;
VAR_8->numgbits = VAR_10 >> 5;
if (VAR_8->qntsty == VAR_15) {
VAR_11 = 1;
}
else {
VAR_11 = (VAR_8->qntsty == VAR_16) ?
(*VAR_3) :
(*VAR_3) / 2;
if( VAR_11 > VAR_17 ) {
opj_event_msg(VAR_4, VAR_18, ""While reading CCP_QNTSTY element inside QCD or QCC marker segment, ""
""number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to ""
""OPJ_J2K_MAXBANDS (%d) and skip the rest. \n"", VAR_11, VAR_17, VAR_17);
}
}
#ifdef VAR_19
if (VAR_6->correct) {
if ( (VAR_11 >= VAR_17)) {
opj_event_msg(VAR_4, VAR_20 ? VAR_18 : VAR_13,
""JPWL: bad number of subbands in Sqcx (%d)\n"",
VAR_11);
if (!VAR_20) {
opj_event_msg(VAR_4, VAR_13, ""JPWL: giving up\n"");
return VAR_14;
}
VAR_11 = 1;
opj_event_msg(VAR_4, VAR_18, ""- trying to adjust them\n""
""- setting number of bands to %d => HYPOTHESIS!!!\n"",
VAR_11);
};
};
#endif 
if (VAR_8->qntsty == VAR_16) {
for     (VAR_5 = 0; VAR_5 < VAR_11; VAR_5++) {
opj_read_bytes(VAR_9, &VAR_10 ,1);                       
++VAR_9;
if (VAR_5 < VAR_17){
VAR_8->stepsizes[VAR_5].expn = (VAR_21)(VAR_10 >> 3);
VAR_8->stepsizes[VAR_5].mant = 0;
}
}
*VAR_3 = *VAR_3 - VAR_11;
}
else {
for     (VAR_5 = 0; VAR_5 < VAR_11; VAR_5++) {
opj_read_bytes(VAR_9, &VAR_10 ,2);                       
VAR_9+=2;
if (VAR_5 < VAR_17){
VAR_8->stepsizes[VAR_5].expn = (VAR_21)(VAR_10 >> 11);
VAR_8->stepsizes[VAR_5].mant = VAR_10 & 0x7ff;
}
}
*VAR_3 = *VAR_3 - 2*VAR_11;
}
if (VAR_8->qntsty == VAR_15) {
for (VAR_5 = 1; VAR_5 < VAR_17; VAR_5++) {
VAR_8->stepsizes[VAR_5].expn =
((VAR_21)(VAR_8->stepsizes[0].expn) - (VAR_21)((VAR_5 - 1) / 3) > 0) ?
(VAR_21)(VAR_8->stepsizes[0].expn) - (VAR_21)((VAR_5 - 1) / 3) : 0;
VAR_8->stepsizes[VAR_5].mant = VAR_8->stepsizes[0].mant;
}
}
return VAR_22;
}",pdfium/338a6b75994eb148d429b7abccfffaf7ae9f9b55/j2k.c/vul/before/0.json,"static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,
                                                            OPJ_UINT32 p_comp_no,
                                                            OPJ_BYTE* p_header_data,
                                                            OPJ_UINT32 * p_header_size,
                                                            opj_event_mgr_t * p_manager
                                                            )
{
        /* loop*/
        OPJ_UINT32 l_band_no;
        opj_cp_t *l_cp = 00;
        opj_tcp_t *l_tcp = 00;
        opj_tccp_t *l_tccp = 00;
        OPJ_BYTE * l_current_ptr = 00;
        OPJ_UINT32 l_tmp, l_num_band;

        /* preconditions*/
        assert(p_j2k != 00);
        assert(p_manager != 00);
        assert(p_header_data != 00);

        l_cp = &(p_j2k->m_cp);
        /* come from tile part header or main header ?*/
        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /*FIXME J2K_DEC_STATE_TPH*/
                                &l_cp->tcps[p_j2k->m_current_tile_number] :
                                p_j2k->m_specific_param.m_decoder.m_default_tcp;

        /* precondition again*/
        if (p_comp_no >=  p_j2k->m_private_image->numcomps) {
            return OPJ_FALSE;
        }

        l_tccp = &l_tcp->tccps[p_comp_no];
        l_current_ptr = p_header_data;

        if (*p_header_size < 1) {
                opj_event_msg(p_manager, EVT_ERROR, ""Error reading SQcd or SQcc element\n"");
                return OPJ_FALSE;
        }
        *p_header_size -= 1;

        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* Sqcx */
        ++l_current_ptr;

        l_tccp->qntsty = l_tmp & 0x1f;
        l_tccp->numgbits = l_tmp >> 5;
        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
        l_num_band = 1;
        }
        else {
                l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?
                        (*p_header_size) :
                        (*p_header_size) / 2;

                if( l_num_band > OPJ_J2K_MAXBANDS ) {
                        opj_event_msg(p_manager, EVT_WARNING, ""While reading CCP_QNTSTY element inside QCD or QCC marker segment, ""
                                ""number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to ""
                                ""OPJ_J2K_MAXBANDS (%d) and skip the rest. \n"", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);
                        /*return OPJ_FALSE;*/
                }
        }

#ifdef USE_JPWL
        if (l_cp->correct) {

                /* if JPWL is on, we check whether there are too many subbands */
                if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {
                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
                                ""JPWL: bad number of subbands in Sqcx (%d)\n"",
                                l_num_band);
                        if (!JPWL_ASSUME) {
                                opj_event_msg(p_manager, EVT_ERROR, ""JPWL: giving up\n"");
                                return OPJ_FALSE;
                        }
                        /* we try to correct */
                        l_num_band = 1;
                        opj_event_msg(p_manager, EVT_WARNING, ""- trying to adjust them\n""
                                ""- setting number of bands to %d => HYPOTHESIS!!!\n"",
                                l_num_band);
                };

        };
#endif /* USE_JPWL */

        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
                        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* SPqcx_i */
                        ++l_current_ptr;
                        if (l_band_no < OPJ_J2K_MAXBANDS){
                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);
                                l_tccp->stepsizes[l_band_no].mant = 0;
                        }
                }
                *p_header_size = *p_header_size - l_num_band;
        }
        else {
                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
                        opj_read_bytes(l_current_ptr, &l_tmp ,2);                       /* SPqcx_i */
                        l_current_ptr+=2;
                        if (l_band_no < OPJ_J2K_MAXBANDS){
                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);
                                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;
                        }
                }
                *p_header_size = *p_header_size - 2*l_num_band;
        }

        /* Add Antonin : if scalar_derived -> compute other stepsizes */
        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
                for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {
                        l_tccp->stepsizes[l_band_no].expn =
                                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?
                                        (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;
                        l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
                }
        }

        return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *VAR_0,
                                                            OPJ_UINT32 VAR_1,
                                                            OPJ_BYTE* VAR_2,
                                                            OPJ_UINT32 * VAR_3,
                                                            opj_event_mgr_t * VAR_4
                                                            )
{
        /* COMMENT_0 */
        OPJ_UINT32 VAR_5;
        opj_cp_t *VAR_6 = 00;
        opj_tcp_t *VAR_7 = 00;
        opj_tccp_t *VAR_8 = 00;
        OPJ_BYTE * VAR_9 = 00;
        OPJ_UINT32 VAR_10, VAR_11;

        /* COMMENT_1 */
        assert(VAR_0 != 00);
        assert(VAR_4 != 00);
        assert(VAR_2 != 00);

        VAR_6 = &(VAR_0->m_cp);
        /* COMMENT_2 */
        VAR_7 = (VAR_0->m_specific_param.m_decoder.m_state == VAR_12) ? /* COMMENT_3 */
                                &VAR_6->tcps[VAR_0->m_current_tile_number] :
                                VAR_0->m_specific_param.m_decoder.m_default_tcp;

        /* COMMENT_4 */
        if (VAR_1 >=  VAR_0->m_private_image->numcomps) {
            return VAR_13;
        }

        VAR_8 = &VAR_7->tccps[VAR_1];
        VAR_9 = VAR_2;

        if (*VAR_3 < 1) {
                opj_event_msg(VAR_4, VAR_14, ""Error reading SQcd or SQcc element\n"");
                return VAR_13;
        }
        *VAR_3 -= 1;

        opj_read_bytes(VAR_9, &VAR_10 ,1);                       /* COMMENT_5 */
        ++VAR_9;

        VAR_8->qntsty = VAR_10 & 0x1f;
        VAR_8->numgbits = VAR_10 >> 5;
        if (VAR_8->qntsty == VAR_15) {
        VAR_11 = 1;
        }
        else {
                VAR_11 = (VAR_8->qntsty == VAR_16) ?
                        (*VAR_3) :
                        (*VAR_3) / 2;

                if( VAR_11 > VAR_17 ) {
                        opj_event_msg(VAR_4, VAR_18, ""While reading CCP_QNTSTY element inside QCD or QCC marker segment, ""
                                ""number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to ""
                                ""OPJ_J2K_MAXBANDS (%d) and skip the rest. \n"", VAR_11, VAR_17, VAR_17);
                        /* COMMENT_6 */
                }
        }

#ifdef VAR_19
        if (VAR_6->correct) {

                /* COMMENT_7 */
                if (/* COMMENT_8 */ (VAR_11 >= VAR_17)) {
                        opj_event_msg(VAR_4, VAR_20 ? VAR_18 : VAR_14,
                                ""JPWL: bad number of subbands in Sqcx (%d)\n"",
                                VAR_11);
                        if (!VAR_20) {
                                opj_event_msg(VAR_4, VAR_14, ""JPWL: giving up\n"");
                                return VAR_13;
                        }
                        /* COMMENT_9 */
                        VAR_11 = 1;
                        opj_event_msg(VAR_4, VAR_18, ""- trying to adjust them\n""
                                ""- setting number of bands to %d => HYPOTHESIS!!!\n"",
                                VAR_11);
                };

        };
#endif /* COMMENT_10 */

        if (VAR_8->qntsty == VAR_16) {
                for     (VAR_5 = 0; VAR_5 < VAR_11; VAR_5++) {
                        opj_read_bytes(VAR_9, &VAR_10 ,1);                       /* COMMENT_11 */
                        ++VAR_9;
                        if (VAR_5 < VAR_17){
                                VAR_8->stepsizes[VAR_5].expn = (VAR_21)(VAR_10 >> 3);
                                VAR_8->stepsizes[VAR_5].mant = 0;
                        }
                }
                *VAR_3 = *VAR_3 - VAR_11;
        }
        else {
                for     (VAR_5 = 0; VAR_5 < VAR_11; VAR_5++) {
                        opj_read_bytes(VAR_9, &VAR_10 ,2);                       /* COMMENT_11 */
                        VAR_9+=2;
                        if (VAR_5 < VAR_17){
                                VAR_8->stepsizes[VAR_5].expn = (VAR_21)(VAR_10 >> 11);
                                VAR_8->stepsizes[VAR_5].mant = VAR_10 & 0x7ff;
                        }
                }
                *VAR_3 = *VAR_3 - 2*VAR_11;
        }

        /* COMMENT_12 */
        if (VAR_8->qntsty == VAR_15) {
                for (VAR_5 = 1; VAR_5 < VAR_17; VAR_5++) {
                        VAR_8->stepsizes[VAR_5].expn =
                                ((VAR_21)(VAR_8->stepsizes[0].expn) - (VAR_21)((VAR_5 - 1) / 3) > 0) ?
                                        (VAR_21)(VAR_8->stepsizes[0].expn) - (VAR_21)((VAR_5 - 1) / 3) : 0;
                        VAR_8->stepsizes[VAR_5].mant = VAR_8->stepsizes[0].mant;
                }
        }

        return VAR_22;
}",pdfium/338a6b75994eb148d429b7abccfffaf7ae9f9b55/j2k.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,9 @@
                                 p_j2k->m_specific_param.m_decoder.m_default_tcp;
 
         /* precondition again*/
-        assert(p_comp_no <  p_j2k->m_private_image->numcomps);
+        if (p_comp_no >=  p_j2k->m_private_image->numcomps) {
+            return OPJ_FALSE;
+        }
 
         l_tccp = &l_tcp->tccps[p_comp_no];
         l_current_ptr = p_header_data;","{'deleted_lines': ['        assert(p_comp_no <  p_j2k->m_private_image->numcomps);'], 'added_lines': ['        if (p_comp_no >=  p_j2k->m_private_image->numcomps) {', '            return OPJ_FALSE;', '        }']}",True,"Heap-based buffer overflow in the opj_j2k_read_SQcd_SQcc function in j2k.c in OpenJPEG, as used in PDFium in Google Chrome before 52.0.2743.116, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JPEG 2000 data.",9.8,CRITICAL,3,valid,,5
CVE-2016-3899,['CWE-284'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,android,"OMXCodec: check IMemory::pointer() before using allocation

Bug: 29421811
Change-Id: I0a73ba12bae4122f1d89fc92e5ea4f6a96cd1ed1
",97837bb6cbac21ea679843a0037779d3834bed64,https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64,media/libstagefright/OMXCodec.cpp,OMXCodec::allocateBuffersOnPort,"status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
return allocateOutputBuffersFromNativeWindow();
}
if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
ALOGE(""protected output buffers must be stent to an ANativeWindow"");
return PERMISSION_DENIED;
}
status_t err = OK;
if ((mFlags & kStoreMetaDataInVideoBuffers)
&& portIndex == kPortIndexInput) {
err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
if (err != OK) {
ALOGE(""Storing meta data in video buffers is not supported"");
return err;
}
}
OMX_PARAM_PORTDEFINITIONTYPE def;
InitOMXParams(&def);
def.nPortIndex = portIndex;
err = mOMX->getParameter(
mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
if (err != OK) {
return err;
}
CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
def.nBufferCountActual, def.nBufferSize,
portIndex == kPortIndexInput ? ""input"" : ""output"");
if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
return BAD_VALUE;
}
size_t totalSize = def.nBufferCountActual * def.nBufferSize;
mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");
for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
CHECK(mem.get() != NULL);
BufferInfo info;
info.mData = NULL;
info.mSize = def.nBufferSize;
IOMX::buffer_id buffer;
if (portIndex == kPortIndexInput
&& ((mQuirks & kRequiresAllocateBufferOnInputPorts)
|| (mFlags & kUseSecureInputBuffers))) {
if (mOMXLivesLocally) {
mem.clear();
err = mOMX->allocateBuffer(
mNode, portIndex, def.nBufferSize, &buffer,
&info.mData);
} else {
err = mOMX->allocateBufferWithBackup(
mNode, portIndex, mem, &buffer, mem->size());
}
} else if (portIndex == kPortIndexOutput
&& (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
if (mOMXLivesLocally) {
mem.clear();
err = mOMX->allocateBuffer(
mNode, portIndex, def.nBufferSize, &buffer,
&info.mData);
} else {
err = mOMX->allocateBufferWithBackup(
mNode, portIndex, mem, &buffer, mem->size());
}
} else {
err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
}
if (err != OK) {
ALOGE(""allocate_buffer_with_backup failed"");
return err;
}
if (mem != NULL) {
info.mData = mem->pointer();
}
info.mBuffer = buffer;
info.mStatus = OWNED_BY_US;
info.mMem = mem;
info.mMediaBuffer = NULL;
if (portIndex == kPortIndexOutput) {
LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
&& (mQuirks & kRequiresAllocateBufferOnOutputPorts)
&& (mQuirks & kDefersOutputBufferAllocation)),
""allocateBuffersOnPort cannot defer buffer allocation"");
info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
info.mMediaBuffer->setObserver(this);
}
mPortBuffers[portIndex].push(info);
CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
portIndex == kPortIndexInput ? ""input"" : ""output"");
}
if (portIndex == kPortIndexOutput) {
sp<MetaData> meta = mSource->getFormat();
int32_t delay = 0;
if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
delay = 0;
}
int32_t padding = 0;
if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
padding = 0;
}
int32_t numchannels = 0;
if (delay + padding) {
if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
size_t frameSize = numchannels * sizeof(int16_t);
if (mSkipCutBuffer != NULL) {
size_t prevbuffersize = mSkipCutBuffer->size();
if (prevbuffersize != 0) {
ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
}
}
mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
}
}
}
if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
Vector<MediaBuffer *> buffers;
for (size_t i = 0; i < def.nBufferCountActual; ++i) {
const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);
MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
buffers.push(mbuf);
}
status_t err = mSource->setBuffers(buffers);
if (err != OK) {
for (size_t i = 0; i < def.nBufferCountActual; ++i) {
buffers.editItemAt(i)->release();
}
buffers.clear();
CODEC_LOGE(
""Codec requested to use secure input buffers but ""
""upstream source didn't support that."");
return err;
}
}
return OK;
}","status_t OMXCodec::allocateBuffersOnPort(OMX_U32 VAR_0) {
if (VAR_1 != NULL && VAR_0 == VAR_2) {
return allocateOutputBuffersFromNativeWindow();
}
if ((VAR_3 & VAR_4) && VAR_0 == VAR_2) {
ALOGE(""protected output buffers must be stent to an ANativeWindow"");
return VAR_5;
}
status_t VAR_6 = VAR_7;
if ((VAR_3 & VAR_8)
&& VAR_0 == VAR_9) {
VAR_6 = VAR_10->storeMetaDataInBuffers(VAR_11, VAR_9, VAR_12);
if (VAR_6 != VAR_7) {
ALOGE(""Storing meta data in video buffers is not supported"");
return VAR_6;
}
}
OMX_PARAM_PORTDEFINITIONTYPE VAR_13;
InitOMXParams(&VAR_13);
VAR_13.nPortIndex = VAR_0;
VAR_6 = VAR_10->getParameter(
VAR_11, VAR_14, &VAR_13, sizeof(VAR_13));
if (VAR_6 != VAR_7) {
return VAR_6;
}
CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
VAR_13.nBufferCountActual, VAR_13.nBufferSize,
VAR_0 == VAR_9 ? ""input"" : ""output"");
if (VAR_13.nBufferSize != 0 && VAR_13.nBufferCountActual > VAR_15 / VAR_13.nBufferSize) {
return VAR_16;
}
size_t VAR_17 = VAR_13.nBufferCountActual * VAR_13.nBufferSize;
VAR_18[VAR_0] = new MemoryDealer(VAR_17, ""OMXCodec"");
for (OMX_U32 VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
sp<IMemory> VAR_20 = VAR_18[VAR_0]->allocate(VAR_13.nBufferSize);
CHECK(VAR_20.get() != NULL);
BufferInfo VAR_21;
VAR_21.mData = NULL;
VAR_21.mSize = VAR_13.nBufferSize;
IOMX::buffer_id VAR_22;
if (VAR_0 == VAR_9
&& ((VAR_23 & VAR_24)
|| (VAR_3 & VAR_25))) {
if (VAR_26) {
VAR_20.clear();
VAR_6 = VAR_10->allocateBuffer(
VAR_11, VAR_0, VAR_13.nBufferSize, &VAR_22,
&VAR_21.mData);
} else {
VAR_6 = VAR_10->allocateBufferWithBackup(
VAR_11, VAR_0, VAR_20, &VAR_22, VAR_20->size());
}
} else if (VAR_0 == VAR_2
&& (VAR_23 & VAR_27)) {
if (VAR_26) {
VAR_20.clear();
VAR_6 = VAR_10->allocateBuffer(
VAR_11, VAR_0, VAR_13.nBufferSize, &VAR_22,
&VAR_21.mData);
} else {
VAR_6 = VAR_10->allocateBufferWithBackup(
VAR_11, VAR_0, VAR_20, &VAR_22, VAR_20->size());
}
} else {
VAR_6 = VAR_10->useBuffer(VAR_11, VAR_0, VAR_20, &VAR_22, VAR_20->size());
}
if (VAR_6 != VAR_7) {
ALOGE(""allocate_buffer_with_backup failed"");
return VAR_6;
}
if (VAR_20 != NULL) {
VAR_21.mData = VAR_20->pointer();
}
VAR_21.mBuffer = VAR_22;
VAR_21.mStatus = VAR_28;
VAR_21.mMem = VAR_20;
VAR_21.mMediaBuffer = NULL;
if (VAR_0 == VAR_2) {
LOG_ALWAYS_FATAL_IF((VAR_26
&& (VAR_23 & VAR_27)
&& (VAR_23 & VAR_29)),
""allocateBuffersOnPort cannot defer buffer allocation"");
VAR_21.mMediaBuffer = new MediaBuffer(VAR_21.mData, VAR_21.mSize);
VAR_21.mMediaBuffer->setObserver(this);
}
VAR_30[VAR_0].push(VAR_21);
CODEC_LOGV(""allocated buffer %u on %s port"", VAR_22,
VAR_0 == VAR_9 ? ""input"" : ""output"");
}
if (VAR_0 == VAR_2) {
sp<MetaData> VAR_31 = VAR_32->getFormat();
int32_t VAR_33 = 0;
if (!VAR_31->findInt32(VAR_34, &VAR_33)) {
VAR_33 = 0;
}
int32_t VAR_35 = 0;
if (!VAR_31->findInt32(VAR_36, &VAR_35)) {
VAR_35 = 0;
}
int32_t VAR_37 = 0;
if (VAR_33 + VAR_35) {
if (VAR_38->findInt32(VAR_39, &VAR_37)) {
size_t VAR_40 = VAR_37 * sizeof(int16_t);
if (VAR_41 != NULL) {
size_t VAR_42 = VAR_41->size();
if (VAR_42 != 0) {
ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", VAR_42);
}
}
VAR_41 = new SkipCutBuffer(VAR_33 * VAR_40, VAR_35 * VAR_40);
}
}
}
if (VAR_0 == VAR_9 && (VAR_3 & VAR_25)) {
Vector<MediaBuffer *> VAR_43;
for (size_t VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
const BufferInfo &VAR_21 = VAR_30[VAR_9].itemAt(VAR_19);
MediaBuffer *VAR_44 = new MediaBuffer(VAR_21.mData, VAR_21.mSize);
VAR_43.push(VAR_44);
}
status_t VAR_6 = VAR_32->setBuffers(VAR_43);
if (VAR_6 != VAR_7) {
for (size_t VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
VAR_43.editItemAt(VAR_19)->release();
}
VAR_43.clear();
CODEC_LOGE(
""Codec requested to use secure input buffers but ""
""upstream source didn't support that."");
return VAR_6;
}
}
return VAR_7;
}",android/97837bb6cbac21ea679843a0037779d3834bed64/OMXCodec.cpp/vul/before/0.json,"status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
    if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
        return allocateOutputBuffersFromNativeWindow();
    }

    if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
        return PERMISSION_DENIED;
    }

    status_t err = OK;
    if ((mFlags & kStoreMetaDataInVideoBuffers)
            && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
        if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
            return err;
        }
    }

    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

    if (err != OK) {
        return err;
    }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
        return BAD_VALUE;
    }
    size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
        sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        if (mem == NULL || mem->pointer() == NULL) {
            return NO_MEMORY;
        }

        BufferInfo info;
        info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
        if (portIndex == kPortIndexInput
                && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
                    || (mFlags & kUseSecureInputBuffers))) {
            if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
                        &info.mData);
            } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
            }
        } else if (portIndex == kPortIndexOutput
                && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
            if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
                        &info.mData);
            } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
            }
        } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
        }

        if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
            return err;
        }

        if (mem != NULL) {
            info.mData = mem->pointer();
        }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

        if (portIndex == kPortIndexOutput) {
            // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;
            // this legacy mode is no longer supported.
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
                    && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
                    && (mQuirks & kDefersOutputBufferAllocation)),
                    ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
        }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
    }

    if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
        int32_t delay = 0;
        if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
        }
        int32_t padding = 0;
        if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
        }
        int32_t numchannels = 0;
        if (delay + padding) {
            if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
                size_t frameSize = numchannels * sizeof(int16_t);
                if (mSkipCutBuffer != NULL) {
                    size_t prevbuffersize = mSkipCutBuffer->size();
                    if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
                    }
                }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
            }
        }
    }

    // dumpPortStatus(portIndex);

    if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
        Vector<MediaBuffer *> buffers;
        for (size_t i = 0; i < def.nBufferCountActual; ++i) {
            const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

            MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
        }

        status_t err = mSource->setBuffers(buffers);

        if (err != OK) {
            for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
            }
            buffers.clear();

            CODEC_LOGE(
                    ""Codec requested to use secure input buffers but ""
                    ""upstream source didn't support that."");

            return err;
        }
    }

    return OK;
}","status_t OMXCodec::allocateBuffersOnPort(OMX_U32 VAR_0) {
    if (VAR_1 != NULL && VAR_0 == VAR_2) {
        return allocateOutputBuffersFromNativeWindow();
    }

    if ((VAR_3 & VAR_4) && VAR_0 == VAR_2) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
        return VAR_5;
    }

    status_t VAR_6 = VAR_7;
    if ((VAR_3 & VAR_8)
            && VAR_0 == VAR_9) {
        VAR_6 = VAR_10->storeMetaDataInBuffers(VAR_11, VAR_9, VAR_12);
        if (VAR_6 != VAR_7) {
            ALOGE(""Storing meta data in video buffers is not supported"");
            return VAR_6;
        }
    }

    OMX_PARAM_PORTDEFINITIONTYPE VAR_13;
    InitOMXParams(&VAR_13);
    VAR_13.nPortIndex = VAR_0;

    VAR_6 = VAR_10->getParameter(
            VAR_11, VAR_14, &VAR_13, sizeof(VAR_13));

    if (VAR_6 != VAR_7) {
        return VAR_6;
    }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            VAR_13.nBufferCountActual, VAR_13.nBufferSize,
            VAR_0 == VAR_9 ? ""input"" : ""output"");

    if (VAR_13.nBufferSize != 0 && VAR_13.nBufferCountActual > VAR_15 / VAR_13.nBufferSize) {
        return VAR_16;
    }
    size_t VAR_17 = VAR_13.nBufferCountActual * VAR_13.nBufferSize;
    VAR_18[VAR_0] = new MemoryDealer(VAR_17, ""OMXCodec"");

    for (OMX_U32 VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
        sp<IMemory> VAR_20 = VAR_18[VAR_0]->allocate(VAR_13.nBufferSize);
        if (VAR_20 == NULL || VAR_20->pointer() == NULL) {
            return VAR_21;
        }

        BufferInfo VAR_22;
        VAR_22.mData = NULL;
        VAR_22.mSize = VAR_13.nBufferSize;

        IOMX::buffer_id VAR_23;
        if (VAR_0 == VAR_9
                && ((VAR_24 & VAR_25)
                    || (VAR_3 & VAR_26))) {
            if (VAR_27) {
                VAR_20.clear();

                VAR_6 = VAR_10->allocateBuffer(
                        VAR_11, VAR_0, VAR_13.nBufferSize, &VAR_23,
                        &VAR_22.mData);
            } else {
                VAR_6 = VAR_10->allocateBufferWithBackup(
                        VAR_11, VAR_0, VAR_20, &VAR_23, VAR_20->size());
            }
        } else if (VAR_0 == VAR_2
                && (VAR_24 & VAR_28)) {
            if (VAR_27) {
                VAR_20.clear();

                VAR_6 = VAR_10->allocateBuffer(
                        VAR_11, VAR_0, VAR_13.nBufferSize, &VAR_23,
                        &VAR_22.mData);
            } else {
                VAR_6 = VAR_10->allocateBufferWithBackup(
                        VAR_11, VAR_0, VAR_20, &VAR_23, VAR_20->size());
            }
        } else {
            VAR_6 = VAR_10->useBuffer(VAR_11, VAR_0, VAR_20, &VAR_23, VAR_20->size());
        }

        if (VAR_6 != VAR_7) {
            ALOGE(""allocate_buffer_with_backup failed"");
            return VAR_6;
        }

        if (VAR_20 != NULL) {
            VAR_22.mData = VAR_20->pointer();
        }

        VAR_22.mBuffer = VAR_23;
        VAR_22.mStatus = VAR_29;
        VAR_22.mMem = VAR_20;
        VAR_22.mMediaBuffer = NULL;

        if (VAR_0 == VAR_2) {
            /* COMMENT_0 */
            /* COMMENT_1 */
            LOG_ALWAYS_FATAL_IF((VAR_27
                    && (VAR_24 & VAR_28)
                    && (VAR_24 & VAR_30)),
                    ""allocateBuffersOnPort cannot defer buffer allocation"");

            VAR_22.mMediaBuffer = new MediaBuffer(VAR_22.mData, VAR_22.mSize);
            VAR_22.mMediaBuffer->setObserver(this);
        }

        VAR_31[VAR_0].push(VAR_22);

        CODEC_LOGV(""allocated buffer %u on %s port"", VAR_23,
             VAR_0 == VAR_9 ? ""input"" : ""output"");
    }

    if (VAR_0 == VAR_2) {

        sp<MetaData> VAR_32 = VAR_33->getFormat();
        int32_t VAR_34 = 0;
        if (!VAR_32->findInt32(VAR_35, &VAR_34)) {
            VAR_34 = 0;
        }
        int32_t VAR_36 = 0;
        if (!VAR_32->findInt32(VAR_37, &VAR_36)) {
            VAR_36 = 0;
        }
        int32_t VAR_38 = 0;
        if (VAR_34 + VAR_36) {
            if (VAR_39->findInt32(VAR_40, &VAR_38)) {
                size_t VAR_41 = VAR_38 * sizeof(int16_t);
                if (VAR_42 != NULL) {
                    size_t VAR_43 = VAR_42->size();
                    if (VAR_43 != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", VAR_43);
                    }
                }
                VAR_42 = new SkipCutBuffer(VAR_34 * VAR_41, VAR_36 * VAR_41);
            }
        }
    }

    /* COMMENT_2 */

    if (VAR_0 == VAR_9 && (VAR_3 & VAR_26)) {
        Vector<MediaBuffer *> VAR_44;
        for (size_t VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
            const BufferInfo &VAR_22 = VAR_31[VAR_9].itemAt(VAR_19);

            MediaBuffer *VAR_45 = new MediaBuffer(VAR_22.mData, VAR_22.mSize);
            VAR_44.push(VAR_45);
        }

        status_t VAR_6 = VAR_33->setBuffers(VAR_44);

        if (VAR_6 != VAR_7) {
            for (size_t VAR_19 = 0; VAR_19 < VAR_13.nBufferCountActual; ++VAR_19) {
                VAR_44.editItemAt(VAR_19)->release();
            }
            VAR_44.clear();

            CODEC_LOGE(
                    ""Codec requested to use secure input buffers but ""
                    ""upstream source didn't support that."");

            return VAR_6;
        }
    }

    return VAR_7;
}",android/97837bb6cbac21ea679843a0037779d3834bed64/OMXCodec.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,7 +41,9 @@
 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
-        CHECK(mem.get() != NULL);
+        if (mem == NULL || mem->pointer() == NULL) {
+            return NO_MEMORY;
+        }
 
         BufferInfo info;
         info.mData = NULL;","{'deleted_lines': ['        CHECK(mem.get() != NULL);'], 'added_lines': ['        if (mem == NULL || mem->pointer() == NULL) {', '            return NO_MEMORY;', '        }']}",True,"OMXCodec.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not validate a certain pointer, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29421811.",5.5,MEDIUM,1,valid,,5
CVE-2016-6308,['CWE-399'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,openssl,"
Excessive allocation of memory in dtls1_preprocess_fragment()

This issue is very similar to CVE-2016-6307 described in the previous
commit. The underlying defect is different but the security analysis and
impacts are the same except that it impacts DTLS.

A DTLS message includes 3 bytes for its length in the header for the
message.
This would allow for messages up to 16Mb in length. Messages of this length
are excessive and OpenSSL includes a check to ensure that a peer is sending
reasonably sized messages in order to avoid too much memory being consumed
to service a connection. A flaw in the logic of version 1.1.0 means that
memory for the message is allocated too early, prior to the excessive
message length check. Due to way memory is allocated in OpenSSL this could
mean an attacker could force up to 21Mb to be allocated to service a
connection. This could lead to a Denial of Service through memory
exhaustion. However, the excessive message length check still takes place,
and this would cause the connection to immediately fail. Assuming that the
application calls SSL_free() on the failed conneciton in a timely manner
then the 21Mb of allocated memory will then be immediately freed again.
Therefore the excessive memory allocation will be transitory in nature.
This then means that there is only a security impact if:

1) The application does not call SSL_free() in a timely manner in the
event that the connection fails
or
2) The application is working in a constrained environment where there
is very little free memory
or
3) The attacker initiates multiple connection attempts such that there
are multiple connections in a state where memory has been allocated for
the connection; SSL_free() has not yet been called; and there is
insufficient memory to service the multiple requests.

Except in the instance of (1) above any Denial Of Service is likely to
be transitory because as soon as the connection fails the memory is
subsequently freed again in the SSL_free() call. However there is an
increased risk during this period of application crashes due to the lack
of memory - which would then mean a more serious Denial of Service.

This issue does not affect TLS users.

Issue was reported by Shi Lei (Gear Team, Qihoo 360 Inc.).

CVE-2016-6308

Reviewed-by: Richard Levitte <levitte@openssl.org>
(cherry picked from commit 48c054fec3506417b2598837b8062aae7114c200)
",df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e,https://git.openssl.org/?p=openssl.git;a=commit;h=df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e,ssl/statem/statem_dtls.c,dtls1_preprocess_fragment,"static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)
{
size_t frag_off, frag_len, msg_len;
msg_len = msg_hdr->msg_len;
frag_off = msg_hdr->frag_off;
frag_len = msg_hdr->frag_len;
if ((frag_off + frag_len) > msg_len) {
SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
return SSL_AD_ILLEGAL_PARAMETER;
}
if (s->d1->r_msg_hdr.frag_off == 0) { 
if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {
SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);
return SSL_AD_INTERNAL_ERROR;
}
s->s3->tmp.message_size = msg_len;
s->d1->r_msg_hdr.msg_len = msg_len;
s->s3->tmp.message_type = msg_hdr->type;
s->d1->r_msg_hdr.type = msg_hdr->type;
s->d1->r_msg_hdr.seq = msg_hdr->seq;
} else if (msg_len != s->d1->r_msg_hdr.msg_len) {
SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
return SSL_AD_ILLEGAL_PARAMETER;
}
return 0;                   
}","static int dtls1_preprocess_fragment(SSL *VAR_0, struct hm_header_st *VAR_1)
{
size_t VAR_2, VAR_3, VAR_4;
VAR_4 = VAR_1->msg_len;
VAR_2 = VAR_1->frag_off;
VAR_3 = VAR_1->frag_len;
if ((VAR_2 + VAR_3) > VAR_4) {
SSLerr(VAR_5, VAR_6);
return VAR_7;
}
if (VAR_0->d1->r_msg_hdr.frag_off == 0) { 
if (!BUF_MEM_grow_clean(VAR_0->init_buf, VAR_4 + VAR_8)) {
SSLerr(VAR_5, VAR_9);
return VAR_10;
}
VAR_0->s3->tmp.message_size = VAR_4;
VAR_0->d1->r_msg_hdr.msg_len = VAR_4;
VAR_0->s3->tmp.message_type = VAR_1->type;
VAR_0->d1->r_msg_hdr.type = VAR_1->type;
VAR_0->d1->r_msg_hdr.seq = VAR_1->seq;
} else if (VAR_4 != VAR_0->d1->r_msg_hdr.msg_len) {
SSLerr(VAR_5, VAR_6);
return VAR_7;
}
return 0;                   
}",openssl/df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e/statem_dtls.c/vul/before/0.json,"static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)
{
    size_t frag_off, frag_len, msg_len;

    msg_len = msg_hdr->msg_len;
    frag_off = msg_hdr->frag_off;
    frag_len = msg_hdr->frag_len;

    /* sanity checking */
    if ((frag_off + frag_len) > msg_len
            || msg_len > dtls1_max_handshake_message_len(s)) {
        SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
        return SSL_AD_ILLEGAL_PARAMETER;
    }

    if (s->d1->r_msg_hdr.frag_off == 0) { /* first fragment */
        /*
         * msg_len is limited to 2^24, but is effectively checked against
         * dtls_max_handshake_message_len(s) above
         */
        if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {
            SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);
            return SSL_AD_INTERNAL_ERROR;
        }

        s->s3->tmp.message_size = msg_len;
        s->d1->r_msg_hdr.msg_len = msg_len;
        s->s3->tmp.message_type = msg_hdr->type;
        s->d1->r_msg_hdr.type = msg_hdr->type;
        s->d1->r_msg_hdr.seq = msg_hdr->seq;
    } else if (msg_len != s->d1->r_msg_hdr.msg_len) {
        /*
         * They must be playing with us! BTW, failure to enforce upper limit
         * would open possibility for buffer overrun.
         */
        SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
        return SSL_AD_ILLEGAL_PARAMETER;
    }

    return 0;                   /* no error */
}","static int dtls1_preprocess_fragment(SSL *VAR_0, struct hm_header_st *VAR_1)
{
    size_t VAR_2, VAR_3, VAR_4;

    VAR_4 = VAR_1->msg_len;
    VAR_2 = VAR_1->frag_off;
    VAR_3 = VAR_1->frag_len;

    /* COMMENT_0 */
    if ((VAR_2 + VAR_3) > VAR_4
            || VAR_4 > dtls1_max_handshake_message_len(VAR_0)) {
        SSLerr(VAR_5, VAR_6);
        return VAR_7;
    }

    if (VAR_0->d1->r_msg_hdr.frag_off == 0) { /* COMMENT_1 */
        /* COMMENT_2 */
                                                                         
                                                  
           
        if (!BUF_MEM_grow_clean(VAR_0->init_buf, VAR_4 + VAR_8)) {
            SSLerr(VAR_5, VAR_9);
            return VAR_10;
        }

        VAR_0->s3->tmp.message_size = VAR_4;
        VAR_0->d1->r_msg_hdr.msg_len = VAR_4;
        VAR_0->s3->tmp.message_type = VAR_1->type;
        VAR_0->d1->r_msg_hdr.type = VAR_1->type;
        VAR_0->d1->r_msg_hdr.seq = VAR_1->seq;
    } else if (VAR_4 != VAR_0->d1->r_msg_hdr.msg_len) {
        /* COMMENT_6 */
                                                                            
                                                     
           
        SSLerr(VAR_5, VAR_6);
        return VAR_7;
    }

    return 0;                   /* COMMENT_10 */
}",openssl/df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e/statem_dtls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,15 +7,16 @@
     frag_len = msg_hdr->frag_len;
 
     /* sanity checking */
-    if ((frag_off + frag_len) > msg_len) {
+    if ((frag_off + frag_len) > msg_len
+            || msg_len > dtls1_max_handshake_message_len(s)) {
         SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
         return SSL_AD_ILLEGAL_PARAMETER;
     }
 
     if (s->d1->r_msg_hdr.frag_off == 0) { /* first fragment */
         /*
-         * msg_len is limited to 2^24, but is effectively checked against max
-         * above
+         * msg_len is limited to 2^24, but is effectively checked against
+         * dtls_max_handshake_message_len(s) above
          */
         if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {
             SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);","{'deleted_lines': ['    if ((frag_off + frag_len) > msg_len) {', '         * msg_len is limited to 2^24, but is effectively checked against max', '         * above'], 'added_lines': ['    if ((frag_off + frag_len) > msg_len', '            || msg_len > dtls1_max_handshake_message_len(s)) {', '         * msg_len is limited to 2^24, but is effectively checked against', '         * dtls_max_handshake_message_len(s) above']}",True,"statem/statem_dtls.c in the DTLS implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted DTLS messages.",5.9,MEDIUM,1,valid,,5
CVE-2015-3418,['CWE-369'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,xorg/xserver,"The length checking code validates PutImage height and byte width by
making sure that byte-width >= INT32_MAX / height. If height is zero,
this generates a divide by zero exception. Allow zero height requests
explicitly, bypassing the INT32_MAX check.

Signed-off-by: Keith Packard <keithp@keithp.com>
Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
",dc777c346d5d452a53b13b917c45f6a1bad2f20b,https://cgit.freedesktop.org/xorg/xserver/commit/?id=dc777c346d5d452a53b13b917c45f6a1bad2f20b,dix/dispatch.c,ProcPutImage,"int
ProcPutImage(ClientPtr client)
{
GC *pGC;
DrawablePtr pDraw;
long length;                
long lengthProto;           
char *tmpImage;
REQUEST(xPutImageReq);
REQUEST_AT_LEAST_SIZE(xPutImageReq);
VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
if (stuff->format == XYBitmap) {
if ((stuff->depth != 1) ||
(stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
return BadMatch;
length = BitmapBytePad(stuff->width + stuff->leftPad);
}
else if (stuff->format == XYPixmap) {
if ((pDraw->depth != stuff->depth) ||
(stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
return BadMatch;
length = BitmapBytePad(stuff->width + stuff->leftPad);
length *= stuff->depth;
}
else if (stuff->format == ZPixmap) {
if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))
return BadMatch;
length = PixmapBytePad(stuff->width, stuff->depth);
}
else {
client->errorValue = stuff->format;
return BadValue;
}
tmpImage = (char *) &stuff[1];
lengthProto = length;
if (lengthProto >= (INT32_MAX / stuff->height))
return BadLength;
if ((bytes_to_int32(lengthProto * stuff->height) +
bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)
return BadLength;
ReformatImage(tmpImage, lengthProto * stuff->height,
stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,
ClientOrder(client));
(*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,
stuff->width, stuff->height,
stuff->leftPad, stuff->format, tmpImage);
return Success;
}","int
ProcPutImage(ClientPtr VAR_0)
{
GC *VAR_1;
DrawablePtr VAR_2;
long VAR_3;                
long VAR_4;           
char *VAR_5;
REQUEST(VAR_6);
REQUEST_AT_LEAST_SIZE(VAR_6);
VALIDATE_DRAWABLE_AND_GC(VAR_7->drawable, VAR_2, VAR_8);
if (VAR_7->format == VAR_9) {
if ((VAR_7->depth != 1) ||
(VAR_7->leftPad >= (unsigned int) VAR_10.bitmapScanlinePad))
return VAR_11;
VAR_3 = BitmapBytePad(VAR_7->width + VAR_7->leftPad);
}
else if (VAR_7->format == VAR_12) {
if ((VAR_2->depth != VAR_7->depth) ||
(VAR_7->leftPad >= (unsigned int) VAR_10.bitmapScanlinePad))
return VAR_11;
VAR_3 = BitmapBytePad(VAR_7->width + VAR_7->leftPad);
VAR_3 *= VAR_7->depth;
}
else if (VAR_7->format == VAR_13) {
if ((VAR_2->depth != VAR_7->depth) || (VAR_7->leftPad != 0))
return VAR_11;
VAR_3 = PixmapBytePad(VAR_7->width, VAR_7->depth);
}
else {
VAR_0->errorValue = VAR_7->format;
return VAR_14;
}
VAR_5 = (char *) &VAR_7[1];
VAR_4 = VAR_3;
if (VAR_4 >= (VAR_15 / VAR_7->height))
return VAR_16;
if ((bytes_to_int32(VAR_4 * VAR_7->height) +
bytes_to_int32(sizeof(VAR_6))) != VAR_0->req_len)
return VAR_16;
ReformatImage(VAR_5, VAR_4 * VAR_7->height,
VAR_7->format == VAR_13 ? BitsPerPixel(VAR_7->depth) : 1,
ClientOrder(VAR_0));
(*VAR_1->ops->PutImage) (VAR_2, VAR_1, VAR_7->depth, VAR_7->dstX, VAR_7->dstY,
VAR_7->width, VAR_7->height,
VAR_7->leftPad, VAR_7->format, VAR_5);
return VAR_17;
}",xorg/xserver/dc777c346d5d452a53b13b917c45f6a1bad2f20b/dispatch.c/vul/before/0.json,"int
ProcPutImage(ClientPtr client)
{
    GC *pGC;
    DrawablePtr pDraw;
    long length;                /* length of scanline server padded */
    long lengthProto;           /* length of scanline protocol padded */
    char *tmpImage;

    REQUEST(xPutImageReq);

    REQUEST_AT_LEAST_SIZE(xPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    if (stuff->format == XYBitmap) {
        if ((stuff->depth != 1) ||
            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
            return BadMatch;
        length = BitmapBytePad(stuff->width + stuff->leftPad);
    }
    else if (stuff->format == XYPixmap) {
        if ((pDraw->depth != stuff->depth) ||
            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
            return BadMatch;
        length = BitmapBytePad(stuff->width + stuff->leftPad);
        length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap) {
        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))
            return BadMatch;
        length = PixmapBytePad(stuff->width, stuff->depth);
    }
    else {
        client->errorValue = stuff->format;
        return BadValue;
    }

    tmpImage = (char *) &stuff[1];
    lengthProto = length;

    if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))
        return BadLength;

    if ((bytes_to_int32(lengthProto * stuff->height) +
         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)
        return BadLength;

    ReformatImage(tmpImage, lengthProto * stuff->height,
                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,
                  ClientOrder(client));

    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,
                           stuff->width, stuff->height,
                           stuff->leftPad, stuff->format, tmpImage);

    return Success;
}","int
ProcPutImage(ClientPtr VAR_0)
{
    GC *VAR_1;
    DrawablePtr VAR_2;
    long VAR_3;                /* COMMENT_0 */
    long VAR_4;           /* COMMENT_1 */
    char *VAR_5;

    REQUEST(VAR_6);

    REQUEST_AT_LEAST_SIZE(VAR_6);
    VALIDATE_DRAWABLE_AND_GC(VAR_7->drawable, VAR_2, VAR_8);
    if (VAR_7->format == VAR_9) {
        if ((VAR_7->depth != 1) ||
            (VAR_7->leftPad >= (unsigned int) VAR_10.bitmapScanlinePad))
            return VAR_11;
        VAR_3 = BitmapBytePad(VAR_7->width + VAR_7->leftPad);
    }
    else if (VAR_7->format == VAR_12) {
        if ((VAR_2->depth != VAR_7->depth) ||
            (VAR_7->leftPad >= (unsigned int) VAR_10.bitmapScanlinePad))
            return VAR_11;
        VAR_3 = BitmapBytePad(VAR_7->width + VAR_7->leftPad);
        VAR_3 *= VAR_7->depth;
    }
    else if (VAR_7->format == VAR_13) {
        if ((VAR_2->depth != VAR_7->depth) || (VAR_7->leftPad != 0))
            return VAR_11;
        VAR_3 = PixmapBytePad(VAR_7->width, VAR_7->depth);
    }
    else {
        VAR_0->errorValue = VAR_7->format;
        return VAR_14;
    }

    VAR_5 = (char *) &VAR_7[1];
    VAR_4 = VAR_3;

    if (VAR_7->height != 0 && VAR_4 >= (VAR_15 / VAR_7->height))
        return VAR_16;

    if ((bytes_to_int32(VAR_4 * VAR_7->height) +
         bytes_to_int32(sizeof(VAR_6))) != VAR_0->req_len)
        return VAR_16;

    ReformatImage(VAR_5, VAR_4 * VAR_7->height,
                  VAR_7->format == VAR_13 ? BitsPerPixel(VAR_7->depth) : 1,
                  ClientOrder(VAR_0));

    (*VAR_1->ops->PutImage) (VAR_2, VAR_1, VAR_7->depth, VAR_7->dstX, VAR_7->dstY,
                           VAR_7->width, VAR_7->height,
                           VAR_7->leftPad, VAR_7->format, VAR_5);

    return VAR_17;
}",xorg/xserver/dc777c346d5d452a53b13b917c45f6a1bad2f20b/dispatch.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,7 +37,7 @@
     tmpImage = (char *) &stuff[1];
     lengthProto = length;
 
-    if (lengthProto >= (INT32_MAX / stuff->height))
+    if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))
         return BadLength;
 
     if ((bytes_to_int32(lengthProto * stuff->height) +","{'deleted_lines': ['    if (lengthProto >= (INT32_MAX / stuff->height))'], 'added_lines': ['    if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))']}",True,The ProcPutImage function in dix/dispatch.c in X.Org Server (aka xserver and xorg-server) before 1.16.4 allows attackers to cause a denial of service (divide-by-zero and crash) via a zero-height PutImage request.,7.5,HIGH,2,valid,,5
CVE-2017-0399,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Fix security vulnerability: Equalizer command might allow negative indexes

Bug: 32247948
Bug: 32438598
Bug: 32436341

Test: use POC on bug or cts security test

Change-Id: I91bd6aadb6c7410163e03101f365db767f4cd2a3
(cherry picked from commit 0872b65cff9129633471945431b9a5a28418049c)
(cherry picked from commit e981cca9fff3608af22bdf8fc1acef5470e25663)
",c66c43ad571ed2590dcd55a762c73c90d9744bac,https://android.googlesource.com/platform/frameworks/av/+/c66c43ad571ed2590dcd55a762c73c90d9744bac,media/libeffects/lvm/wrapper/Bundle/EffectBundle.cpp,Equalizer_getParameter,"int Equalizer_getParameter(EffectContext     *pContext,
void              *pParam,
uint32_t          *pValueSize,
void              *pValue){
int status = 0;
int bMute = 0;
int32_t *pParamTemp = (int32_t *)pParam;
int32_t param = *pParamTemp++;
int32_t param2;
char *name;
switch (param) {
case EQ_PARAM_NUM_BANDS:
case EQ_PARAM_CUR_PRESET:
case EQ_PARAM_GET_NUM_OF_PRESETS:
case EQ_PARAM_BAND_LEVEL:
case EQ_PARAM_GET_BAND:
if (*pValueSize < sizeof(int16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
return -EINVAL;
}
*pValueSize = sizeof(int16_t);
break;
case EQ_PARAM_LEVEL_RANGE:
if (*pValueSize < 2 * sizeof(int16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *pValueSize);
return -EINVAL;
}
*pValueSize = 2 * sizeof(int16_t);
break;
case EQ_PARAM_BAND_FREQ_RANGE:
if (*pValueSize < 2 * sizeof(int32_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *pValueSize);
return -EINVAL;
}
*pValueSize = 2 * sizeof(int32_t);
break;
case EQ_PARAM_CENTER_FREQ:
if (*pValueSize < sizeof(int32_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *pValueSize);
return -EINVAL;
}
*pValueSize = sizeof(int32_t);
break;
case EQ_PARAM_GET_PRESET_NAME:
break;
case EQ_PARAM_PROPERTIES:
if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
return -EINVAL;
}
*pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t);
break;
default:
ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", param);
return -EINVAL;
}
switch (param) {
case EQ_PARAM_NUM_BANDS:
*(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS;
break;
case EQ_PARAM_LEVEL_RANGE:
*(int16_t *)pValue = -1500;
*((int16_t *)pValue + 1) = 1500;
break;
case EQ_PARAM_BAND_LEVEL:
param2 = *pParamTemp;
if (param2 >= FIVEBAND_NUMBANDS) {
status = -EINVAL;
break;
}
*(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
break;
case EQ_PARAM_CENTER_FREQ:
param2 = *pParamTemp;
if (param2 >= FIVEBAND_NUMBANDS) {
status = -EINVAL;
break;
}
*(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
break;
case EQ_PARAM_BAND_FREQ_RANGE:
param2 = *pParamTemp;
if (param2 >= FIVEBAND_NUMBANDS) {
status = -EINVAL;
break;
}
EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
break;
case EQ_PARAM_GET_BAND:
param2 = *pParamTemp;
*(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2);
break;
case EQ_PARAM_CUR_PRESET:
*(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext);
break;
case EQ_PARAM_GET_NUM_OF_PRESETS:
*(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets();
break;
case EQ_PARAM_GET_PRESET_NAME:
param2 = *pParamTemp;
if (param2 >= EqualizerGetNumPresets()) {
status = -EINVAL;
break;
}
name = (char *)pValue;
strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1);
name[*pValueSize - 1] = 0;
*pValueSize = strlen(name) + 1;
break;
case EQ_PARAM_PROPERTIES: {
int16_t *p = (int16_t *)pValue;
ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES"");
p[0] = (int16_t)EqualizerGetPreset(pContext);
p[1] = (int16_t)FIVEBAND_NUMBANDS;
for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i);
}
} break;
default:
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", param);
status = -EINVAL;
break;
}
return status;
}","int Equalizer_getParameter(EffectContext     *VAR_0,
void              *VAR_1,
uint32_t          *VAR_2,
void              *VAR_3){
int VAR_4 = 0;
int VAR_5 = 0;
int32_t *VAR_6 = (int32_t *)VAR_1;
int32_t VAR_7 = *VAR_6++;
int32_t VAR_8;
char *VAR_9;
switch (VAR_7) {
case VAR_10:
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
if (*VAR_2 < sizeof(int16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *VAR_2);
return -VAR_15;
}
*VAR_2 = sizeof(int16_t);
break;
case VAR_16:
if (*VAR_2 < 2 * sizeof(int16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *VAR_2);
return -VAR_15;
}
*VAR_2 = 2 * sizeof(int16_t);
break;
case VAR_17:
if (*VAR_2 < 2 * sizeof(int32_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *VAR_2);
return -VAR_15;
}
*VAR_2 = 2 * sizeof(int32_t);
break;
case VAR_18:
if (*VAR_2 < sizeof(int32_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *VAR_2);
return -VAR_15;
}
*VAR_2 = sizeof(int32_t);
break;
case VAR_19:
break;
case VAR_20:
if (*VAR_2 < (2 + VAR_21) * sizeof(uint16_t)) {
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *VAR_2);
return -VAR_15;
}
*VAR_2 = (2 + VAR_21) * sizeof(uint16_t);
break;
default:
ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", VAR_7);
return -VAR_15;
}
switch (VAR_7) {
case VAR_10:
*(uint16_t *)VAR_3 = (uint16_t)VAR_21;
break;
case VAR_16:
*(int16_t *)VAR_3 = -1500;
*((int16_t *)VAR_3 + 1) = 1500;
break;
case VAR_13:
VAR_8 = *VAR_6;
if (VAR_8 >= VAR_21) {
VAR_4 = -VAR_15;
break;
}
*(int16_t *)VAR_3 = (int16_t)EqualizerGetBandLevel(VAR_0, VAR_8);
break;
case VAR_18:
VAR_8 = *VAR_6;
if (VAR_8 >= VAR_21) {
VAR_4 = -VAR_15;
break;
}
*(int32_t *)VAR_3 = EqualizerGetCentreFrequency(VAR_0, VAR_8);
break;
case VAR_17:
VAR_8 = *VAR_6;
if (VAR_8 >= VAR_21) {
VAR_4 = -VAR_15;
break;
}
EqualizerGetBandFreqRange(VAR_0, VAR_8, (uint32_t *)VAR_3, ((uint32_t *)VAR_3 + 1));
break;
case VAR_14:
VAR_8 = *VAR_6;
*(uint16_t *)VAR_3 = (uint16_t)EqualizerGetBand(VAR_0, VAR_8);
break;
case VAR_11:
*(uint16_t *)VAR_3 = (uint16_t)EqualizerGetPreset(VAR_0);
break;
case VAR_12:
*(uint16_t *)VAR_3 = (uint16_t)EqualizerGetNumPresets();
break;
case VAR_19:
VAR_8 = *VAR_6;
if (VAR_8 >= EqualizerGetNumPresets()) {
VAR_4 = -VAR_15;
break;
}
VAR_9 = (char *)VAR_3;
strncpy(VAR_9, EqualizerGetPresetName(VAR_8), *VAR_2 - 1);
VAR_9[*VAR_2 - 1] = 0;
*VAR_2 = strlen(VAR_9) + 1;
break;
case VAR_20: {
int16_t *VAR_22 = (int16_t *)VAR_3;
ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES"");
VAR_22[0] = (int16_t)EqualizerGetPreset(VAR_0);
VAR_22[1] = (int16_t)VAR_21;
for (int VAR_23 = 0; VAR_23 < VAR_21; VAR_23++) {
VAR_22[2 + VAR_23] = (int16_t)EqualizerGetBandLevel(VAR_0, VAR_23);
}
} break;
default:
ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", VAR_7);
VAR_4 = -VAR_15;
break;
}
return VAR_4;
}",android/c66c43ad571ed2590dcd55a762c73c90d9744bac/EffectBundle.cpp/vul/before/0.json,"int Equalizer_getParameter(EffectContext     *pContext,
                           void              *pParam,
                           uint32_t          *pValueSize,
                           void              *pValue){
    int status = 0;
    int bMute = 0;
    int32_t *pParamTemp = (int32_t *)pParam;
    int32_t param = *pParamTemp++;
    int32_t param2;
    char *name;

    //ALOGV(""\tEqualizer_getParameter start"");

    switch (param) {
    case EQ_PARAM_NUM_BANDS:
    case EQ_PARAM_CUR_PRESET:
    case EQ_PARAM_GET_NUM_OF_PRESETS:
    case EQ_PARAM_BAND_LEVEL:
    case EQ_PARAM_GET_BAND:
        if (*pValueSize < sizeof(int16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
            return -EINVAL;
        }
        *pValueSize = sizeof(int16_t);
        break;

    case EQ_PARAM_LEVEL_RANGE:
        if (*pValueSize < 2 * sizeof(int16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *pValueSize);
            return -EINVAL;
        }
        *pValueSize = 2 * sizeof(int16_t);
        break;
    case EQ_PARAM_BAND_FREQ_RANGE:
        if (*pValueSize < 2 * sizeof(int32_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *pValueSize);
            return -EINVAL;
        }
        *pValueSize = 2 * sizeof(int32_t);
        break;

    case EQ_PARAM_CENTER_FREQ:
        if (*pValueSize < sizeof(int32_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *pValueSize);
            return -EINVAL;
        }
        *pValueSize = sizeof(int32_t);
        break;

    case EQ_PARAM_GET_PRESET_NAME:
        break;

    case EQ_PARAM_PROPERTIES:
        if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
            return -EINVAL;
        }
        *pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t);
        break;

    default:
        ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", param);
        return -EINVAL;
    }

    switch (param) {
    case EQ_PARAM_NUM_BANDS:
        *(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS;
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_NUM_BANDS %d"", *(int16_t *)pValue);
        break;

    case EQ_PARAM_LEVEL_RANGE:
        *(int16_t *)pValue = -1500;
        *((int16_t *)pValue + 1) = 1500;
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_LEVEL_RANGE min %d, max %d"",
        //      *(int16_t *)pValue, *((int16_t *)pValue + 1));
        break;

    case EQ_PARAM_BAND_LEVEL:
        param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
            break;
        }
        *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_BAND_LEVEL band %d, level %d"",
        //      param2, *(int32_t *)pValue);
        break;

    case EQ_PARAM_CENTER_FREQ:
        param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
            break;
        }
        *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_CENTER_FREQ band %d, frequency %d"",
        //      param2, *(int32_t *)pValue);
        break;

    case EQ_PARAM_BAND_FREQ_RANGE:
        param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
            break;
        }
        EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d, min %d, max %d"",
        //      param2, *(int32_t *)pValue, *((int32_t *)pValue + 1));
        break;

    case EQ_PARAM_GET_BAND:
        param2 = *pParamTemp;
        *(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2);
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_GET_BAND frequency %d, band %d"",
        //      param2, *(uint16_t *)pValue);
        break;

    case EQ_PARAM_CUR_PRESET:
        *(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext);
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_CUR_PRESET %d"", *(int32_t *)pValue);
        break;

    case EQ_PARAM_GET_NUM_OF_PRESETS:
        *(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets();
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_GET_NUM_OF_PRESETS %d"", *(int16_t *)pValue);
        break;

    case EQ_PARAM_GET_PRESET_NAME:
        param2 = *pParamTemp;
        if (param2 >= EqualizerGetNumPresets()) {
        //if (param2 >= 20) {     // AGO FIX
            status = -EINVAL;
            break;
        }
        name = (char *)pValue;
        strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1);
        name[*pValueSize - 1] = 0;
        *pValueSize = strlen(name) + 1;
        //ALOGV(""\tEqualizer_getParameter() EQ_PARAM_GET_PRESET_NAME preset %d, name %s len %d"",
        //      param2, gEqualizerPresets[param2].name, *pValueSize);
        break;

    case EQ_PARAM_PROPERTIES: {
        int16_t *p = (int16_t *)pValue;
        ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES"");
        p[0] = (int16_t)EqualizerGetPreset(pContext);
        p[1] = (int16_t)FIVEBAND_NUMBANDS;
        for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
            p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i);
        }
    } break;

    default:
        ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", param);
        status = -EINVAL;
        break;
    }

    //GV(""\tEqualizer_getParameter end\n"");
    return status;
}","int Equalizer_getParameter(EffectContext     *VAR_0,
                           void              *VAR_1,
                           uint32_t          *VAR_2,
                           void              *VAR_3){
    int VAR_4 = 0;
    int VAR_5 = 0;
    int32_t *VAR_6 = (int32_t *)VAR_1;
    int32_t VAR_7 = *VAR_6++;
    int32_t VAR_8;
    char *VAR_9;

    /* COMMENT_0 */

    switch (VAR_7) {
    case VAR_10:
    case VAR_11:
    case VAR_12:
    case VAR_13:
    case VAR_14:
        if (*VAR_2 < sizeof(int16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *VAR_2);
            return -VAR_15;
        }
        *VAR_2 = sizeof(int16_t);
        break;

    case VAR_16:
        if (*VAR_2 < 2 * sizeof(int16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *VAR_2);
            return -VAR_15;
        }
        *VAR_2 = 2 * sizeof(int16_t);
        break;
    case VAR_17:
        if (*VAR_2 < 2 * sizeof(int32_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *VAR_2);
            return -VAR_15;
        }
        *VAR_2 = 2 * sizeof(int32_t);
        break;

    case VAR_18:
        if (*VAR_2 < sizeof(int32_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *VAR_2);
            return -VAR_15;
        }
        *VAR_2 = sizeof(int32_t);
        break;

    case VAR_19:
        break;

    case VAR_20:
        if (*VAR_2 < (2 + VAR_21) * sizeof(uint16_t)) {
            ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *VAR_2);
            return -VAR_15;
        }
        *VAR_2 = (2 + VAR_21) * sizeof(uint16_t);
        break;

    default:
        ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", VAR_7);
        return -VAR_15;
    }

    switch (VAR_7) {
    case VAR_10:
        *(uint16_t *)VAR_3 = (uint16_t)VAR_21;
        /* COMMENT_1 */
        break;

    case VAR_16:
        *(int16_t *)VAR_3 = -1500;
        *((int16_t *)VAR_3 + 1) = 1500;
        /* COMMENT_2 */
        /* COMMENT_3 */
        break;

    case VAR_13:
        VAR_8 = *VAR_6;
        if (VAR_8 < 0 || VAR_8 >= VAR_21) {
            VAR_4 = -VAR_15;
            if (VAR_8 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", VAR_8);
            }
            break;
        }
        *(int16_t *)VAR_3 = (int16_t)EqualizerGetBandLevel(VAR_0, VAR_8);
        /* COMMENT_4 */
        /* COMMENT_5 */
        break;

    case VAR_18:
        VAR_8 = *VAR_6;
        if (VAR_8 < 0 || VAR_8 >= VAR_21) {
            VAR_4 = -VAR_15;
            if (VAR_8 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", VAR_8);
            }
            break;
        }
        *(int32_t *)VAR_3 = EqualizerGetCentreFrequency(VAR_0, VAR_8);
        /* COMMENT_6 */
        /* COMMENT_5 */
        break;

    case VAR_17:
        VAR_8 = *VAR_6;
        if (VAR_8 < 0 || VAR_8 >= VAR_21) {
            VAR_4 = -VAR_15;
            if (VAR_8 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", VAR_8);
            }
            break;
        }
        EqualizerGetBandFreqRange(VAR_0, VAR_8, (uint32_t *)VAR_3, ((uint32_t *)VAR_3 + 1));
        /* COMMENT_7 */
        /* COMMENT_8 */
        break;

    case VAR_14:
        VAR_8 = *VAR_6;
        *(uint16_t *)VAR_3 = (uint16_t)EqualizerGetBand(VAR_0, VAR_8);
        /* COMMENT_9 */
        /* COMMENT_10 */
        break;

    case VAR_11:
        *(uint16_t *)VAR_3 = (uint16_t)EqualizerGetPreset(VAR_0);
        /* COMMENT_11 */
        break;

    case VAR_12:
        *(uint16_t *)VAR_3 = (uint16_t)EqualizerGetNumPresets();
        /* COMMENT_12 */
        break;

    case VAR_19:
        VAR_8 = *VAR_6;
        if (VAR_8 >= EqualizerGetNumPresets()) {
        /* COMMENT_13 */
            VAR_4 = -VAR_15;
            break;
        }
        VAR_9 = (char *)VAR_3;
        strncpy(VAR_9, EqualizerGetPresetName(VAR_8), *VAR_2 - 1);
        VAR_9[*VAR_2 - 1] = 0;
        *VAR_2 = strlen(VAR_9) + 1;
        /* COMMENT_14 */
        /* COMMENT_15 */
        break;

    case VAR_20: {
        int16_t *VAR_22 = (int16_t *)VAR_3;
        ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES"");
        VAR_22[0] = (int16_t)EqualizerGetPreset(VAR_0);
        VAR_22[1] = (int16_t)VAR_21;
        for (int VAR_23 = 0; VAR_23 < VAR_21; VAR_23++) {
            VAR_22[2 + VAR_23] = (int16_t)EqualizerGetBandLevel(VAR_0, VAR_23);
        }
    } break;

    default:
        ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", VAR_7);
        VAR_4 = -VAR_15;
        break;
    }

    /* COMMENT_16 */
    return VAR_4;
}",android/c66c43ad571ed2590dcd55a762c73c90d9744bac/EffectBundle.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -78,8 +78,12 @@
 
     case EQ_PARAM_BAND_LEVEL:
         param2 = *pParamTemp;
-        if (param2 >= FIVEBAND_NUMBANDS) {
+        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32438598"");
+                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);
+            }
             break;
         }
         *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
@@ -89,8 +93,12 @@
 
     case EQ_PARAM_CENTER_FREQ:
         param2 = *pParamTemp;
-        if (param2 >= FIVEBAND_NUMBANDS) {
+        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32436341"");
+                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);
+            }
             break;
         }
         *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
@@ -100,8 +108,12 @@
 
     case EQ_PARAM_BAND_FREQ_RANGE:
         param2 = *pParamTemp;
-        if (param2 >= FIVEBAND_NUMBANDS) {
+        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32247948"");
+                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
+            }
             break;
         }
         EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));","{'deleted_lines': ['        if (param2 >= FIVEBAND_NUMBANDS) {', '        if (param2 >= FIVEBAND_NUMBANDS) {', '        if (param2 >= FIVEBAND_NUMBANDS) {'], 'added_lines': ['        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {', '            if (param2 < 0) {', '                android_errorWriteLog(0x534e4554, ""32438598"");', '                ALOGW(""\\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);', '            }', '        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {', '            if (param2 < 0) {', '                android_errorWriteLog(0x534e4554, ""32436341"");', '                ALOGW(""\\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);', '            }', '        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {', '            if (param2 < 0) {', '                android_errorWriteLog(0x534e4554, ""32247948"");', '                ALOGW(""\\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);', '            }']}",True,"An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in the Qualcomm audio post processor could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32588756.",5.5,MEDIUM,1,valid,,5
CVE-2016-6164,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avformat/mov: Check sample size

Fixes integer overflow
Fixes: poc.mp4

Found-by: ajax secure <ajax4sec@hotmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
",8a3221cc67a516dfc1700bdae3566ec52c7ee823,http://git.videolan.org/gitweb.cgi/ffmpeg.git/?a=commit;h=8a3221cc67a516dfc1700bdae3566ec52c7ee823,libavformat/mov.c,mov_build_index,"static void mov_build_index(MOVContext *mov, AVStream *st)
{
MOVStreamContext *sc = st->priv_data;
int64_t current_offset;
int64_t current_dts = 0;
unsigned int stts_index = 0;
unsigned int stsc_index = 0;
unsigned int stss_index = 0;
unsigned int stps_index = 0;
unsigned int i, j;
uint64_t stream_size = 0;
if (sc->elst_count) {
int i, edit_start_index = 0, unsupported = 0;
int64_t empty_duration = 0;         int64_t start_time = 0; 
for (i = 0; i < sc->elst_count; i++) {
const MOVElst *e = &sc->elst_data[i];
if (i == 0 && e->time == -1) {
empty_duration = e->duration;
edit_start_index = 1;
} else if (i == edit_start_index && e->time >= 0) {
start_time = e->time;
} else
unsupported = 1;
}
if (unsupported)
av_log(mov->fc, AV_LOG_WARNING, ""multiple edit list entries, ""
""a/v desync might occur, patch welcome\n"");
if ((empty_duration || start_time) && mov->time_scale > 0) {
if (empty_duration)
empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);
sc->time_offset = start_time - empty_duration;
current_dts = -sc->time_offset;
if (sc->ctts_count>0 && sc->stts_count>0 &&
sc->ctts_data[0].duration / FFMAX(sc->stts_data[0].duration, 1) > 16) {
sc->wrong_dts = 1;
st->codecpar->video_delay = 1;
}
}
if (!unsupported && st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)
sc->start_pad = start_time;
}
if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&
sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {
unsigned int current_sample = 0;
unsigned int stts_sample = 0;
unsigned int sample_size;
unsigned int distance = 0;
unsigned int rap_group_index = 0;
unsigned int rap_group_sample = 0;
int64_t last_dts = 0;
int64_t dts_correction = 0;
int rap_group_present = sc->rap_group_count && sc->rap_group;
int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);
current_dts -= sc->dts_shift;
last_dts     = current_dts;
if (!sc->sample_count || st->nb_index_entries)
return;
if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)
return;
if (av_reallocp_array(&st->index_entries,
st->nb_index_entries + sc->sample_count,
sizeof(*st->index_entries)) < 0) {
st->nb_index_entries = 0;
return;
}
st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);
for (i = 0; i < sc->chunk_count; i++) {
int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;
current_offset = sc->chunk_offsets[i];
while (stsc_index + 1 < sc->stsc_count &&
i + 1 == sc->stsc_data[stsc_index + 1].first)
stsc_index++;
if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&
sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {
av_log(mov->fc, AV_LOG_WARNING, ""STSZ sample size %d invalid (too large), ignoring\n"", sc->stsz_sample_size);
sc->stsz_sample_size = sc->sample_size;
}
if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {
av_log(mov->fc, AV_LOG_WARNING, ""STSZ sample size %d invalid (too small), ignoring\n"", sc->stsz_sample_size);
sc->stsz_sample_size = sc->sample_size;
}
for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {
int keyframe = 0;
if (current_sample >= sc->sample_count) {
av_log(mov->fc, AV_LOG_ERROR, ""wrong sample count\n"");
return;
}
if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {
keyframe = 1;
if (stss_index + 1 < sc->keyframe_count)
stss_index++;
} else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {
keyframe = 1;
if (stps_index + 1 < sc->stps_count)
stps_index++;
}
if (rap_group_present && rap_group_index < sc->rap_group_count) {
if (sc->rap_group[rap_group_index].index > 0)
keyframe = 1;
if (++rap_group_sample == sc->rap_group[rap_group_index].count) {
rap_group_sample = 0;
rap_group_index++;
}
}
if (sc->keyframe_absent
&& !sc->stps_count
&& !rap_group_present
&& (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))
keyframe = 1;
if (keyframe)
distance = 0;
sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];
if (sc->pseudo_stream_id == -1 ||
sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {
AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];
e->pos = current_offset;
e->timestamp = current_dts;
e->size = sample_size;
e->min_distance = distance;
e->flags = keyframe ? AVINDEX_KEYFRAME : 0;
av_log(mov->fc, AV_LOG_TRACE, ""AVIndex stream %d, sample %d, offset %""PRIx64"", dts %""PRId64"", ""
""size %d, distance %d, keyframe %d\n"", st->index, current_sample,
current_offset, current_dts, sample_size, distance, keyframe);
if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st->nb_index_entries < 100)
ff_rfps_add_frame(mov->fc, st, current_dts);
}
current_offset += sample_size;
stream_size += sample_size;
if (sc->stts_data[stts_index].duration < 0) {
av_log(mov->fc, AV_LOG_WARNING,
""Invalid SampleDelta %d in STTS, at %d st:%d\n"",
sc->stts_data[stts_index].duration, stts_index,
st->index);
dts_correction += sc->stts_data[stts_index].duration - 1;
sc->stts_data[stts_index].duration = 1;
}
current_dts += sc->stts_data[stts_index].duration;
if (!dts_correction || current_dts + dts_correction > last_dts) {
current_dts += dts_correction;
dts_correction = 0;
} else {
dts_correction += current_dts - last_dts - 1;
current_dts = last_dts + 1;
}
last_dts = current_dts;
distance++;
stts_sample++;
current_sample++;
if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {
stts_sample = 0;
stts_index++;
}
}
}
if (st->duration > 0)
st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;
} else {
unsigned chunk_samples, total = 0;
for (i = 0; i < sc->stsc_count; i++) {
unsigned count, chunk_count;
chunk_samples = sc->stsc_data[i].count;
if (i != sc->stsc_count - 1 &&
sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {
av_log(mov->fc, AV_LOG_ERROR, ""error unaligned chunk\n"");
return;
}
if (sc->samples_per_frame >= 160) {                 count = chunk_samples / sc->samples_per_frame;
} else if (sc->samples_per_frame > 1) {
unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;
count = (chunk_samples+samples-1) / samples;
} else {
count = (chunk_samples+1023) / 1024;
}
if (i < sc->stsc_count - 1)
chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;
else
chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);
total += chunk_count * count;
}
av_log(mov->fc, AV_LOG_TRACE, ""chunk count %d\n"", total);
if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)
return;
if (av_reallocp_array(&st->index_entries,
st->nb_index_entries + total,
sizeof(*st->index_entries)) < 0) {
st->nb_index_entries = 0;
return;
}
st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);
for (i = 0; i < sc->chunk_count; i++) {
current_offset = sc->chunk_offsets[i];
if (stsc_index + 1 < sc->stsc_count &&
i + 1 == sc->stsc_data[stsc_index + 1].first)
stsc_index++;
chunk_samples = sc->stsc_data[stsc_index].count;
while (chunk_samples > 0) {
AVIndexEntry *e;
unsigned size, samples;
if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {
avpriv_request_sample(mov->fc,
""Zero bytes per frame, but %d samples per frame"",
sc->samples_per_frame);
return;
}
if (sc->samples_per_frame >= 160) {                     samples = sc->samples_per_frame;
size = sc->bytes_per_frame;
} else {
if (sc->samples_per_frame > 1) {
samples = FFMIN((1024 / sc->samples_per_frame)*
sc->samples_per_frame, chunk_samples);
size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;
} else {
samples = FFMIN(1024, chunk_samples);
size = samples * sc->sample_size;
}
}
if (st->nb_index_entries >= total) {
av_log(mov->fc, AV_LOG_ERROR, ""wrong chunk count %d\n"", total);
return;
}
e = &st->index_entries[st->nb_index_entries++];
e->pos = current_offset;
e->timestamp = current_dts;
e->size = size;
e->min_distance = 0;
e->flags = AVINDEX_KEYFRAME;
av_log(mov->fc, AV_LOG_TRACE, ""AVIndex stream %d, chunk %d, offset %""PRIx64"", dts %""PRId64"", ""
""size %d, duration %d\n"", st->index, i, current_offset, current_dts,
size, samples);
current_offset += size;
current_dts += samples;
chunk_samples -= samples;
}
}
}
}","static void mov_build_index(MOVContext *VAR_0, AVStream *VAR_1)
{
MOVStreamContext *VAR_2 = VAR_1->priv_data;
int64_t VAR_3;
int64_t VAR_4 = 0;
unsigned int VAR_5 = 0;
unsigned int VAR_6 = 0;
unsigned int VAR_7 = 0;
unsigned int VAR_8 = 0;
unsigned int VAR_9, VAR_10;
uint64_t VAR_11 = 0;
if (VAR_2->elst_count) {
int VAR_9, VAR_12 = 0, VAR_13 = 0;
int64_t VAR_14 = 0; 
int64_t VAR_15 = 0; 
for (VAR_9 = 0; VAR_9 < VAR_2->elst_count; VAR_9++) {
const MOVElst *VAR_16 = &VAR_2->elst_data[VAR_9];
if (VAR_9 == 0 && VAR_16->time == -1) {
VAR_14 = VAR_16->duration;
VAR_12 = 1;
} else if (VAR_9 == VAR_12 && VAR_16->time >= 0) {
VAR_15 = VAR_16->time;
} else
VAR_13 = 1;
}
if (VAR_13)
av_log(VAR_0->fc, VAR_17, ""multiple edit list entries, ""
""a/v desync might occur, patch welcome\n"");
if ((VAR_14 || VAR_15) && VAR_0->time_scale > 0) {
if (VAR_14)
VAR_14 = av_rescale(VAR_14, VAR_2->time_scale, VAR_0->time_scale);
VAR_2->time_offset = VAR_15 - VAR_14;
VAR_4 = -VAR_2->time_offset;
if (VAR_2->ctts_count>0 && VAR_2->stts_count>0 &&
VAR_2->ctts_data[0].duration / FFMAX(VAR_2->stts_data[0].duration, 1) > 16) {
VAR_2->wrong_dts = 1;
VAR_1->codecpar->video_delay = 1;
}
}
if (!VAR_13 && VAR_1->codecpar->codec_id == VAR_18 && VAR_15 > 0)
VAR_2->start_pad = VAR_15;
}
if (!(VAR_1->codecpar->codec_type == VAR_19 &&
VAR_2->stts_count == 1 && VAR_2->stts_data[0].duration == 1)) {
unsigned int VAR_20 = 0;
unsigned int VAR_21 = 0;
unsigned int VAR_22;
unsigned int VAR_23 = 0;
unsigned int VAR_24 = 0;
unsigned int VAR_25 = 0;
int64_t VAR_26 = 0;
int64_t VAR_27 = 0;
int VAR_28 = VAR_2->rap_group_count && VAR_2->rap_group;
int VAR_29 = (VAR_2->keyframe_count && VAR_2->keyframes[0] > 0) || (VAR_2->stps_count && VAR_2->stps_data[0] > 0);
VAR_4 -= VAR_2->dts_shift;
VAR_26     = VAR_4;
if (!VAR_2->sample_count || VAR_1->nb_index_entries)
return;
if (VAR_2->sample_count >= VAR_30 / sizeof(*VAR_1->index_entries) - VAR_1->nb_index_entries)
return;
if (av_reallocp_array(&VAR_1->index_entries,
VAR_1->nb_index_entries + VAR_2->sample_count,
sizeof(*VAR_1->index_entries)) < 0) {
VAR_1->nb_index_entries = 0;
return;
}
VAR_1->index_entries_allocated_size = (VAR_1->nb_index_entries + VAR_2->sample_count) * sizeof(*VAR_1->index_entries);
for (VAR_9 = 0; VAR_9 < VAR_2->chunk_count; VAR_9++) {
int64_t VAR_31 = VAR_9+1 < VAR_2->chunk_count ? VAR_2->chunk_offsets[VAR_9+1] : VAR_32;
VAR_3 = VAR_2->chunk_offsets[VAR_9];
while (VAR_6 + 1 < VAR_2->stsc_count &&
VAR_9 + 1 == VAR_2->stsc_data[VAR_6 + 1].first)
VAR_6++;
if (VAR_31 > VAR_3 && VAR_2->sample_size>0 && VAR_2->sample_size < VAR_2->stsz_sample_size &&
VAR_2->stsc_data[VAR_6].count * (int64_t)VAR_2->stsz_sample_size > VAR_31 - VAR_3) {
av_log(VAR_0->fc, VAR_17, ""STSZ sample size %d invalid (too large), ignoring\n"", VAR_2->stsz_sample_size);
VAR_2->stsz_sample_size = VAR_2->sample_size;
}
if (VAR_2->stsz_sample_size>0 && VAR_2->stsz_sample_size < VAR_2->sample_size) {
av_log(VAR_0->fc, VAR_17, ""STSZ sample size %d invalid (too small), ignoring\n"", VAR_2->stsz_sample_size);
VAR_2->stsz_sample_size = VAR_2->sample_size;
}
for (VAR_10 = 0; VAR_10 < VAR_2->stsc_data[VAR_6].count; VAR_10++) {
int VAR_33 = 0;
if (VAR_20 >= VAR_2->sample_count) {
av_log(VAR_0->fc, VAR_34, ""wrong sample count\n"");
return;
}
if (!VAR_2->keyframe_absent && (!VAR_2->keyframe_count || VAR_20+VAR_29 == VAR_2->keyframes[VAR_7])) {
VAR_33 = 1;
if (VAR_7 + 1 < VAR_2->keyframe_count)
VAR_7++;
} else if (VAR_2->stps_count && VAR_20+VAR_29 == VAR_2->stps_data[VAR_8]) {
VAR_33 = 1;
if (VAR_8 + 1 < VAR_2->stps_count)
VAR_8++;
}
if (VAR_28 && VAR_24 < VAR_2->rap_group_count) {
if (VAR_2->rap_group[VAR_24].index > 0)
VAR_33 = 1;
if (++VAR_25 == VAR_2->rap_group[VAR_24].count) {
VAR_25 = 0;
VAR_24++;
}
}
if (VAR_2->keyframe_absent
&& !VAR_2->stps_count
&& !VAR_28
&& (VAR_1->codecpar->codec_type == VAR_19 || (VAR_9==0 && VAR_10==0)))
VAR_33 = 1;
if (VAR_33)
VAR_23 = 0;
VAR_22 = VAR_2->stsz_sample_size > 0 ? VAR_2->stsz_sample_size : VAR_2->sample_sizes[VAR_20];
if (VAR_2->pseudo_stream_id == -1 ||
VAR_2->stsc_data[VAR_6].id - 1 == VAR_2->pseudo_stream_id) {
AVIndexEntry *VAR_16 = &VAR_1->index_entries[VAR_1->nb_index_entries++];
VAR_16->pos = VAR_3;
VAR_16->timestamp = VAR_4;
VAR_16->size = VAR_22;
VAR_16->min_distance = VAR_23;
VAR_16->flags = VAR_33 ? VAR_35 : 0;
av_log(VAR_0->fc, VAR_36, ""AVIndex stream %d, sample %d, offset %""VAR_37"", dts %""VAR_38"", ""
""size %d, distance %d, keyframe %d\n"", VAR_1->index, VAR_20,
VAR_3, VAR_4, VAR_22, VAR_23, VAR_33);
if (VAR_1->codecpar->codec_type == VAR_39 && VAR_1->nb_index_entries < 100)
ff_rfps_add_frame(VAR_0->fc, VAR_1, VAR_4);
}
VAR_3 += VAR_22;
VAR_11 += VAR_22;
if (VAR_2->stts_data[VAR_5].duration < 0) {
av_log(VAR_0->fc, VAR_17,
""Invalid SampleDelta %d in STTS, at %d st:%d\n"",
VAR_2->stts_data[VAR_5].duration, VAR_5,
VAR_1->index);
VAR_27 += VAR_2->stts_data[VAR_5].duration - 1;
VAR_2->stts_data[VAR_5].duration = 1;
}
VAR_4 += VAR_2->stts_data[VAR_5].duration;
if (!VAR_27 || VAR_4 + VAR_27 > VAR_26) {
VAR_4 += VAR_27;
VAR_27 = 0;
} else {
VAR_27 += VAR_4 - VAR_26 - 1;
VAR_4 = VAR_26 + 1;
}
VAR_26 = VAR_4;
VAR_23++;
VAR_21++;
VAR_20++;
if (VAR_5 + 1 < VAR_2->stts_count && VAR_21 == VAR_2->stts_data[VAR_5].count) {
VAR_21 = 0;
VAR_5++;
}
}
}
if (VAR_1->duration > 0)
VAR_1->codecpar->bit_rate = VAR_11*8*VAR_2->time_scale/VAR_1->duration;
} else {
unsigned VAR_40, VAR_41 = 0;
for (VAR_9 = 0; VAR_9 < VAR_2->stsc_count; VAR_9++) {
unsigned VAR_42, VAR_43;
VAR_40 = VAR_2->stsc_data[VAR_9].count;
if (VAR_9 != VAR_2->stsc_count - 1 &&
VAR_2->samples_per_frame && VAR_40 % VAR_2->samples_per_frame) {
av_log(VAR_0->fc, VAR_34, ""error unaligned chunk\n"");
return;
}
if (VAR_2->samples_per_frame >= 160) { 
VAR_42 = VAR_40 / VAR_2->samples_per_frame;
} else if (VAR_2->samples_per_frame > 1) {
unsigned VAR_44 = (1024/VAR_2->samples_per_frame)*VAR_2->samples_per_frame;
VAR_42 = (VAR_40+VAR_44-1) / VAR_44;
} else {
VAR_42 = (VAR_40+1023) / 1024;
}
if (VAR_9 < VAR_2->stsc_count - 1)
VAR_43 = VAR_2->stsc_data[VAR_9+1].first - VAR_2->stsc_data[VAR_9].first;
else
VAR_43 = VAR_2->chunk_count - (VAR_2->stsc_data[VAR_9].first - 1);
VAR_41 += VAR_43 * VAR_42;
}
av_log(VAR_0->fc, VAR_36, ""chunk count %d\n"", VAR_41);
if (VAR_41 >= VAR_30 / sizeof(*VAR_1->index_entries) - VAR_1->nb_index_entries)
return;
if (av_reallocp_array(&VAR_1->index_entries,
VAR_1->nb_index_entries + VAR_41,
sizeof(*VAR_1->index_entries)) < 0) {
VAR_1->nb_index_entries = 0;
return;
}
VAR_1->index_entries_allocated_size = (VAR_1->nb_index_entries + VAR_41) * sizeof(*VAR_1->index_entries);
for (VAR_9 = 0; VAR_9 < VAR_2->chunk_count; VAR_9++) {
VAR_3 = VAR_2->chunk_offsets[VAR_9];
if (VAR_6 + 1 < VAR_2->stsc_count &&
VAR_9 + 1 == VAR_2->stsc_data[VAR_6 + 1].first)
VAR_6++;
VAR_40 = VAR_2->stsc_data[VAR_6].count;
while (VAR_40 > 0) {
AVIndexEntry *VAR_16;
unsigned VAR_45, VAR_44;
if (VAR_2->samples_per_frame > 1 && !VAR_2->bytes_per_frame) {
avpriv_request_sample(VAR_0->fc,
""Zero bytes per frame, but %d samples per frame"",
VAR_2->samples_per_frame);
return;
}
if (VAR_2->samples_per_frame >= 160) { 
VAR_44 = VAR_2->samples_per_frame;
VAR_45 = VAR_2->bytes_per_frame;
} else {
if (VAR_2->samples_per_frame > 1) {
VAR_44 = FFMIN((1024 / VAR_2->samples_per_frame)*
VAR_2->samples_per_frame, VAR_40);
VAR_45 = (VAR_44 / VAR_2->samples_per_frame) * VAR_2->bytes_per_frame;
} else {
VAR_44 = FFMIN(1024, VAR_40);
VAR_45 = VAR_44 * VAR_2->sample_size;
}
}
if (VAR_1->nb_index_entries >= VAR_41) {
av_log(VAR_0->fc, VAR_34, ""wrong chunk count %d\n"", VAR_41);
return;
}
VAR_16 = &VAR_1->index_entries[VAR_1->nb_index_entries++];
VAR_16->pos = VAR_3;
VAR_16->timestamp = VAR_4;
VAR_16->size = VAR_45;
VAR_16->min_distance = 0;
VAR_16->flags = VAR_35;
av_log(VAR_0->fc, VAR_36, ""AVIndex stream %d, chunk %d, offset %""VAR_37"", dts %""VAR_38"", ""
""size %d, duration %d\n"", VAR_1->index, VAR_9, VAR_3, VAR_4,
VAR_45, VAR_44);
VAR_3 += VAR_45;
VAR_4 += VAR_44;
VAR_40 -= VAR_44;
}
}
}
}",ffmpeg/8a3221cc67a516dfc1700bdae3566ec52c7ee823/mov.c/vul/before/0.json,"static void mov_build_index(MOVContext *mov, AVStream *st)
{
    MOVStreamContext *sc = st->priv_data;
    int64_t current_offset;
    int64_t current_dts = 0;
    unsigned int stts_index = 0;
    unsigned int stsc_index = 0;
    unsigned int stss_index = 0;
    unsigned int stps_index = 0;
    unsigned int i, j;
    uint64_t stream_size = 0;

    if (sc->elst_count) {
        int i, edit_start_index = 0, unsupported = 0;
        int64_t empty_duration = 0; // empty duration of the first edit list entry
        int64_t start_time = 0; // start time of the media

        for (i = 0; i < sc->elst_count; i++) {
            const MOVElst *e = &sc->elst_data[i];
            if (i == 0 && e->time == -1) {
                /* if empty, the first entry is the start time of the stream
                 * relative to the presentation itself */
                empty_duration = e->duration;
                edit_start_index = 1;
            } else if (i == edit_start_index && e->time >= 0) {
                start_time = e->time;
            } else
                unsupported = 1;
        }
        if (unsupported)
            av_log(mov->fc, AV_LOG_WARNING, ""multiple edit list entries, ""
                   ""a/v desync might occur, patch welcome\n"");

        /* adjust first dts according to edit list */
        if ((empty_duration || start_time) && mov->time_scale > 0) {
            if (empty_duration)
                empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);
            sc->time_offset = start_time - empty_duration;
            current_dts = -sc->time_offset;
            if (sc->ctts_count>0 && sc->stts_count>0 &&
                sc->ctts_data[0].duration / FFMAX(sc->stts_data[0].duration, 1) > 16) {
                /* more than 16 frames delay, dts are likely wrong
                   this happens with files created by iMovie */
                sc->wrong_dts = 1;
                st->codecpar->video_delay = 1;
            }
        }

        if (!unsupported && st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)
            sc->start_pad = start_time;
    }

    /* only use old uncompressed audio chunk demuxing when stts specifies it */
    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&
          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {
        unsigned int current_sample = 0;
        unsigned int stts_sample = 0;
        unsigned int sample_size;
        unsigned int distance = 0;
        unsigned int rap_group_index = 0;
        unsigned int rap_group_sample = 0;
        int64_t last_dts = 0;
        int64_t dts_correction = 0;
        int rap_group_present = sc->rap_group_count && sc->rap_group;
        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);

        current_dts -= sc->dts_shift;
        last_dts     = current_dts;

        if (!sc->sample_count || st->nb_index_entries)
            return;
        if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)
            return;
        if (av_reallocp_array(&st->index_entries,
                              st->nb_index_entries + sc->sample_count,
                              sizeof(*st->index_entries)) < 0) {
            st->nb_index_entries = 0;
            return;
        }
        st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);

        for (i = 0; i < sc->chunk_count; i++) {
            int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;
            current_offset = sc->chunk_offsets[i];
            while (stsc_index + 1 < sc->stsc_count &&
                i + 1 == sc->stsc_data[stsc_index + 1].first)
                stsc_index++;

            if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&
                sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {
                av_log(mov->fc, AV_LOG_WARNING, ""STSZ sample size %d invalid (too large), ignoring\n"", sc->stsz_sample_size);
                sc->stsz_sample_size = sc->sample_size;
            }
            if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {
                av_log(mov->fc, AV_LOG_WARNING, ""STSZ sample size %d invalid (too small), ignoring\n"", sc->stsz_sample_size);
                sc->stsz_sample_size = sc->sample_size;
            }

            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {
                int keyframe = 0;
                if (current_sample >= sc->sample_count) {
                    av_log(mov->fc, AV_LOG_ERROR, ""wrong sample count\n"");
                    return;
                }

                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {
                    keyframe = 1;
                    if (stss_index + 1 < sc->keyframe_count)
                        stss_index++;
                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {
                    keyframe = 1;
                    if (stps_index + 1 < sc->stps_count)
                        stps_index++;
                }
                if (rap_group_present && rap_group_index < sc->rap_group_count) {
                    if (sc->rap_group[rap_group_index].index > 0)
                        keyframe = 1;
                    if (++rap_group_sample == sc->rap_group[rap_group_index].count) {
                        rap_group_sample = 0;
                        rap_group_index++;
                    }
                }
                if (sc->keyframe_absent
                    && !sc->stps_count
                    && !rap_group_present
                    && (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))
                     keyframe = 1;
                if (keyframe)
                    distance = 0;
                sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];
                if (sc->pseudo_stream_id == -1 ||
                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {
                    AVIndexEntry *e;
                    if (sample_size > 0x3FFFFFFF) {
                        av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", sample_size);
                        return;
                    }
                    e = &st->index_entries[st->nb_index_entries++];
                    e->pos = current_offset;
                    e->timestamp = current_dts;
                    e->size = sample_size;
                    e->min_distance = distance;
                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;
                    av_log(mov->fc, AV_LOG_TRACE, ""AVIndex stream %d, sample %d, offset %""PRIx64"", dts %""PRId64"", ""
                            ""size %d, distance %d, keyframe %d\n"", st->index, current_sample,
                            current_offset, current_dts, sample_size, distance, keyframe);
                    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st->nb_index_entries < 100)
                        ff_rfps_add_frame(mov->fc, st, current_dts);
                }

                current_offset += sample_size;
                stream_size += sample_size;

                /* A negative sample duration is invalid based on the spec,
                 * but some samples need it to correct the DTS. */
                if (sc->stts_data[stts_index].duration < 0) {
                    av_log(mov->fc, AV_LOG_WARNING,
                           ""Invalid SampleDelta %d in STTS, at %d st:%d\n"",
                           sc->stts_data[stts_index].duration, stts_index,
                           st->index);
                    dts_correction += sc->stts_data[stts_index].duration - 1;
                    sc->stts_data[stts_index].duration = 1;
                }
                current_dts += sc->stts_data[stts_index].duration;
                if (!dts_correction || current_dts + dts_correction > last_dts) {
                    current_dts += dts_correction;
                    dts_correction = 0;
                } else {
                    /* Avoid creating non-monotonous DTS */
                    dts_correction += current_dts - last_dts - 1;
                    current_dts = last_dts + 1;
                }
                last_dts = current_dts;
                distance++;
                stts_sample++;
                current_sample++;
                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {
                    stts_sample = 0;
                    stts_index++;
                }
            }
        }
        if (st->duration > 0)
            st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;
    } else {
        unsigned chunk_samples, total = 0;

        // compute total chunk count
        for (i = 0; i < sc->stsc_count; i++) {
            unsigned count, chunk_count;

            chunk_samples = sc->stsc_data[i].count;
            if (i != sc->stsc_count - 1 &&
                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {
                av_log(mov->fc, AV_LOG_ERROR, ""error unaligned chunk\n"");
                return;
            }

            if (sc->samples_per_frame >= 160) { // gsm
                count = chunk_samples / sc->samples_per_frame;
            } else if (sc->samples_per_frame > 1) {
                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;
                count = (chunk_samples+samples-1) / samples;
            } else {
                count = (chunk_samples+1023) / 1024;
            }

            if (i < sc->stsc_count - 1)
                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;
            else
                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);
            total += chunk_count * count;
        }

        av_log(mov->fc, AV_LOG_TRACE, ""chunk count %d\n"", total);
        if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)
            return;
        if (av_reallocp_array(&st->index_entries,
                              st->nb_index_entries + total,
                              sizeof(*st->index_entries)) < 0) {
            st->nb_index_entries = 0;
            return;
        }
        st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);

        // populate index
        for (i = 0; i < sc->chunk_count; i++) {
            current_offset = sc->chunk_offsets[i];
            if (stsc_index + 1 < sc->stsc_count &&
                i + 1 == sc->stsc_data[stsc_index + 1].first)
                stsc_index++;
            chunk_samples = sc->stsc_data[stsc_index].count;

            while (chunk_samples > 0) {
                AVIndexEntry *e;
                unsigned size, samples;

                if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {
                    avpriv_request_sample(mov->fc,
                           ""Zero bytes per frame, but %d samples per frame"",
                           sc->samples_per_frame);
                    return;
                }

                if (sc->samples_per_frame >= 160) { // gsm
                    samples = sc->samples_per_frame;
                    size = sc->bytes_per_frame;
                } else {
                    if (sc->samples_per_frame > 1) {
                        samples = FFMIN((1024 / sc->samples_per_frame)*
                                        sc->samples_per_frame, chunk_samples);
                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;
                    } else {
                        samples = FFMIN(1024, chunk_samples);
                        size = samples * sc->sample_size;
                    }
                }

                if (st->nb_index_entries >= total) {
                    av_log(mov->fc, AV_LOG_ERROR, ""wrong chunk count %d\n"", total);
                    return;
                }
                if (size > 0x3FFFFFFF) {
                    av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", size);
                    return;
                }
                e = &st->index_entries[st->nb_index_entries++];
                e->pos = current_offset;
                e->timestamp = current_dts;
                e->size = size;
                e->min_distance = 0;
                e->flags = AVINDEX_KEYFRAME;
                av_log(mov->fc, AV_LOG_TRACE, ""AVIndex stream %d, chunk %d, offset %""PRIx64"", dts %""PRId64"", ""
                        ""size %d, duration %d\n"", st->index, i, current_offset, current_dts,
                        size, samples);

                current_offset += size;
                current_dts += samples;
                chunk_samples -= samples;
            }
        }
    }
}","static void mov_build_index(MOVContext *VAR_0, AVStream *VAR_1)
{
    MOVStreamContext *VAR_2 = VAR_1->priv_data;
    int64_t VAR_3;
    int64_t VAR_4 = 0;
    unsigned int VAR_5 = 0;
    unsigned int VAR_6 = 0;
    unsigned int VAR_7 = 0;
    unsigned int VAR_8 = 0;
    unsigned int VAR_9, VAR_10;
    uint64_t VAR_11 = 0;

    if (VAR_2->elst_count) {
        int VAR_9, VAR_12 = 0, VAR_13 = 0;
        int64_t VAR_14 = 0; /* COMMENT_0 */
        int64_t VAR_15 = 0; /* COMMENT_1 */

        for (VAR_9 = 0; VAR_9 < VAR_2->elst_count; VAR_9++) {
            const MOVElst *VAR_16 = &VAR_2->elst_data[VAR_9];
            if (VAR_9 == 0 && VAR_16->time == -1) {
                /* COMMENT_2 */
                                                         
                VAR_14 = VAR_16->duration;
                VAR_12 = 1;
            } else if (VAR_9 == VAR_12 && VAR_16->time >= 0) {
                VAR_15 = VAR_16->time;
            } else
                VAR_13 = 1;
        }
        if (VAR_13)
            av_log(VAR_0->fc, VAR_17, ""multiple edit list entries, ""
                   ""a/v desync might occur, patch welcome\n"");

        /* COMMENT_4 */
        if ((VAR_14 || VAR_15) && VAR_0->time_scale > 0) {
            if (VAR_14)
                VAR_14 = av_rescale(VAR_14, VAR_2->time_scale, VAR_0->time_scale);
            VAR_2->time_offset = VAR_15 - VAR_14;
            VAR_4 = -VAR_2->time_offset;
            if (VAR_2->ctts_count>0 && VAR_2->stts_count>0 &&
                VAR_2->ctts_data[0].duration / FFMAX(VAR_2->stts_data[0].duration, 1) > 16) {
                /* COMMENT_5 */
                                                               
                VAR_2->wrong_dts = 1;
                VAR_1->codecpar->video_delay = 1;
            }
        }

        if (!VAR_13 && VAR_1->codecpar->codec_id == VAR_18 && VAR_15 > 0)
            VAR_2->start_pad = VAR_15;
    }

    /* COMMENT_7 */
    if (!(VAR_1->codecpar->codec_type == VAR_19 &&
          VAR_2->stts_count == 1 && VAR_2->stts_data[0].duration == 1)) {
        unsigned int VAR_20 = 0;
        unsigned int VAR_21 = 0;
        unsigned int VAR_22;
        unsigned int VAR_23 = 0;
        unsigned int VAR_24 = 0;
        unsigned int VAR_25 = 0;
        int64_t VAR_26 = 0;
        int64_t VAR_27 = 0;
        int VAR_28 = VAR_2->rap_group_count && VAR_2->rap_group;
        int VAR_29 = (VAR_2->keyframe_count && VAR_2->keyframes[0] > 0) || (VAR_2->stps_count && VAR_2->stps_data[0] > 0);

        VAR_4 -= VAR_2->dts_shift;
        VAR_26     = VAR_4;

        if (!VAR_2->sample_count || VAR_1->nb_index_entries)
            return;
        if (VAR_2->sample_count >= VAR_30 / sizeof(*VAR_1->index_entries) - VAR_1->nb_index_entries)
            return;
        if (av_reallocp_array(&VAR_1->index_entries,
                              VAR_1->nb_index_entries + VAR_2->sample_count,
                              sizeof(*VAR_1->index_entries)) < 0) {
            VAR_1->nb_index_entries = 0;
            return;
        }
        VAR_1->index_entries_allocated_size = (VAR_1->nb_index_entries + VAR_2->sample_count) * sizeof(*VAR_1->index_entries);

        for (VAR_9 = 0; VAR_9 < VAR_2->chunk_count; VAR_9++) {
            int64_t VAR_31 = VAR_9+1 < VAR_2->chunk_count ? VAR_2->chunk_offsets[VAR_9+1] : VAR_32;
            VAR_3 = VAR_2->chunk_offsets[VAR_9];
            while (VAR_6 + 1 < VAR_2->stsc_count &&
                VAR_9 + 1 == VAR_2->stsc_data[VAR_6 + 1].first)
                VAR_6++;

            if (VAR_31 > VAR_3 && VAR_2->sample_size>0 && VAR_2->sample_size < VAR_2->stsz_sample_size &&
                VAR_2->stsc_data[VAR_6].count * (int64_t)VAR_2->stsz_sample_size > VAR_31 - VAR_3) {
                av_log(VAR_0->fc, VAR_17, ""STSZ sample size %d invalid (too large), ignoring\n"", VAR_2->stsz_sample_size);
                VAR_2->stsz_sample_size = VAR_2->sample_size;
            }
            if (VAR_2->stsz_sample_size>0 && VAR_2->stsz_sample_size < VAR_2->sample_size) {
                av_log(VAR_0->fc, VAR_17, ""STSZ sample size %d invalid (too small), ignoring\n"", VAR_2->stsz_sample_size);
                VAR_2->stsz_sample_size = VAR_2->sample_size;
            }

            for (VAR_10 = 0; VAR_10 < VAR_2->stsc_data[VAR_6].count; VAR_10++) {
                int VAR_33 = 0;
                if (VAR_20 >= VAR_2->sample_count) {
                    av_log(VAR_0->fc, VAR_34, ""wrong sample count\n"");
                    return;
                }

                if (!VAR_2->keyframe_absent && (!VAR_2->keyframe_count || VAR_20+VAR_29 == VAR_2->keyframes[VAR_7])) {
                    VAR_33 = 1;
                    if (VAR_7 + 1 < VAR_2->keyframe_count)
                        VAR_7++;
                } else if (VAR_2->stps_count && VAR_20+VAR_29 == VAR_2->stps_data[VAR_8]) {
                    VAR_33 = 1;
                    if (VAR_8 + 1 < VAR_2->stps_count)
                        VAR_8++;
                }
                if (VAR_28 && VAR_24 < VAR_2->rap_group_count) {
                    if (VAR_2->rap_group[VAR_24].index > 0)
                        VAR_33 = 1;
                    if (++VAR_25 == VAR_2->rap_group[VAR_24].count) {
                        VAR_25 = 0;
                        VAR_24++;
                    }
                }
                if (VAR_2->keyframe_absent
                    && !VAR_2->stps_count
                    && !VAR_28
                    && (VAR_1->codecpar->codec_type == VAR_19 || (VAR_9==0 && VAR_10==0)))
                     VAR_33 = 1;
                if (VAR_33)
                    VAR_23 = 0;
                VAR_22 = VAR_2->stsz_sample_size > 0 ? VAR_2->stsz_sample_size : VAR_2->sample_sizes[VAR_20];
                if (VAR_2->pseudo_stream_id == -1 ||
                   VAR_2->stsc_data[VAR_6].id - 1 == VAR_2->pseudo_stream_id) {
                    AVIndexEntry *VAR_16;
                    if (VAR_22 > 0x3FFFFFFF) {
                        av_log(VAR_0->fc, VAR_34, ""Sample size %u is too large\n"", VAR_22);
                        return;
                    }
                    VAR_16 = &VAR_1->index_entries[VAR_1->nb_index_entries++];
                    VAR_16->pos = VAR_3;
                    VAR_16->timestamp = VAR_4;
                    VAR_16->size = VAR_22;
                    VAR_16->min_distance = VAR_23;
                    VAR_16->flags = VAR_33 ? VAR_35 : 0;
                    av_log(VAR_0->fc, VAR_36, ""AVIndex stream %d, sample %d, offset %""VAR_37"", dts %""VAR_38"", ""
                            ""size %d, distance %d, keyframe %d\n"", VAR_1->index, VAR_20,
                            VAR_3, VAR_4, VAR_22, VAR_23, VAR_33);
                    if (VAR_1->codecpar->codec_type == VAR_39 && VAR_1->nb_index_entries < 100)
                        ff_rfps_add_frame(VAR_0->fc, VAR_1, VAR_4);
                }

                VAR_3 += VAR_22;
                VAR_11 += VAR_22;

                /* COMMENT_8 */
                                                                  
                if (VAR_2->stts_data[VAR_5].duration < 0) {
                    av_log(VAR_0->fc, VAR_17,
                           ""Invalid SampleDelta %d in STTS, at %d st:%d\n"",
                           VAR_2->stts_data[VAR_5].duration, VAR_5,
                           VAR_1->index);
                    VAR_27 += VAR_2->stts_data[VAR_5].duration - 1;
                    VAR_2->stts_data[VAR_5].duration = 1;
                }
                VAR_4 += VAR_2->stts_data[VAR_5].duration;
                if (!VAR_27 || VAR_4 + VAR_27 > VAR_26) {
                    VAR_4 += VAR_27;
                    VAR_27 = 0;
                } else {
                    /* COMMENT_10 */
                    VAR_27 += VAR_4 - VAR_26 - 1;
                    VAR_4 = VAR_26 + 1;
                }
                VAR_26 = VAR_4;
                VAR_23++;
                VAR_21++;
                VAR_20++;
                if (VAR_5 + 1 < VAR_2->stts_count && VAR_21 == VAR_2->stts_data[VAR_5].count) {
                    VAR_21 = 0;
                    VAR_5++;
                }
            }
        }
        if (VAR_1->duration > 0)
            VAR_1->codecpar->bit_rate = VAR_11*8*VAR_2->time_scale/VAR_1->duration;
    } else {
        unsigned VAR_40, VAR_41 = 0;

        /* COMMENT_11 */
        for (VAR_9 = 0; VAR_9 < VAR_2->stsc_count; VAR_9++) {
            unsigned VAR_42, VAR_43;

            VAR_40 = VAR_2->stsc_data[VAR_9].count;
            if (VAR_9 != VAR_2->stsc_count - 1 &&
                VAR_2->samples_per_frame && VAR_40 % VAR_2->samples_per_frame) {
                av_log(VAR_0->fc, VAR_34, ""error unaligned chunk\n"");
                return;
            }

            if (VAR_2->samples_per_frame >= 160) { /* COMMENT_12 */
                VAR_42 = VAR_40 / VAR_2->samples_per_frame;
            } else if (VAR_2->samples_per_frame > 1) {
                unsigned VAR_44 = (1024/VAR_2->samples_per_frame)*VAR_2->samples_per_frame;
                VAR_42 = (VAR_40+VAR_44-1) / VAR_44;
            } else {
                VAR_42 = (VAR_40+1023) / 1024;
            }

            if (VAR_9 < VAR_2->stsc_count - 1)
                VAR_43 = VAR_2->stsc_data[VAR_9+1].first - VAR_2->stsc_data[VAR_9].first;
            else
                VAR_43 = VAR_2->chunk_count - (VAR_2->stsc_data[VAR_9].first - 1);
            VAR_41 += VAR_43 * VAR_42;
        }

        av_log(VAR_0->fc, VAR_36, ""chunk count %d\n"", VAR_41);
        if (VAR_41 >= VAR_30 / sizeof(*VAR_1->index_entries) - VAR_1->nb_index_entries)
            return;
        if (av_reallocp_array(&VAR_1->index_entries,
                              VAR_1->nb_index_entries + VAR_41,
                              sizeof(*VAR_1->index_entries)) < 0) {
            VAR_1->nb_index_entries = 0;
            return;
        }
        VAR_1->index_entries_allocated_size = (VAR_1->nb_index_entries + VAR_41) * sizeof(*VAR_1->index_entries);

        /* COMMENT_13 */
        for (VAR_9 = 0; VAR_9 < VAR_2->chunk_count; VAR_9++) {
            VAR_3 = VAR_2->chunk_offsets[VAR_9];
            if (VAR_6 + 1 < VAR_2->stsc_count &&
                VAR_9 + 1 == VAR_2->stsc_data[VAR_6 + 1].first)
                VAR_6++;
            VAR_40 = VAR_2->stsc_data[VAR_6].count;

            while (VAR_40 > 0) {
                AVIndexEntry *VAR_16;
                unsigned VAR_45, VAR_44;

                if (VAR_2->samples_per_frame > 1 && !VAR_2->bytes_per_frame) {
                    avpriv_request_sample(VAR_0->fc,
                           ""Zero bytes per frame, but %d samples per frame"",
                           VAR_2->samples_per_frame);
                    return;
                }

                if (VAR_2->samples_per_frame >= 160) { /* COMMENT_12 */
                    VAR_44 = VAR_2->samples_per_frame;
                    VAR_45 = VAR_2->bytes_per_frame;
                } else {
                    if (VAR_2->samples_per_frame > 1) {
                        VAR_44 = FFMIN((1024 / VAR_2->samples_per_frame)*
                                        VAR_2->samples_per_frame, VAR_40);
                        VAR_45 = (VAR_44 / VAR_2->samples_per_frame) * VAR_2->bytes_per_frame;
                    } else {
                        VAR_44 = FFMIN(1024, VAR_40);
                        VAR_45 = VAR_44 * VAR_2->sample_size;
                    }
                }

                if (VAR_1->nb_index_entries >= VAR_41) {
                    av_log(VAR_0->fc, VAR_34, ""wrong chunk count %d\n"", VAR_41);
                    return;
                }
                if (VAR_45 > 0x3FFFFFFF) {
                    av_log(VAR_0->fc, VAR_34, ""Sample size %u is too large\n"", VAR_45);
                    return;
                }
                VAR_16 = &VAR_1->index_entries[VAR_1->nb_index_entries++];
                VAR_16->pos = VAR_3;
                VAR_16->timestamp = VAR_4;
                VAR_16->size = VAR_45;
                VAR_16->min_distance = 0;
                VAR_16->flags = VAR_35;
                av_log(VAR_0->fc, VAR_36, ""AVIndex stream %d, chunk %d, offset %""VAR_37"", dts %""VAR_38"", ""
                        ""size %d, duration %d\n"", VAR_1->index, VAR_9, VAR_3, VAR_4,
                        VAR_45, VAR_44);

                VAR_3 += VAR_45;
                VAR_4 += VAR_44;
                VAR_40 -= VAR_44;
            }
        }
    }
}",ffmpeg/8a3221cc67a516dfc1700bdae3566ec52c7ee823/mov.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -130,7 +130,12 @@
                 sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];
                 if (sc->pseudo_stream_id == -1 ||
                    sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {
-                    AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];
+                    AVIndexEntry *e;
+                    if (sample_size > 0x3FFFFFFF) {
+                        av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", sample_size);
+                        return;
+                    }
+                    e = &st->index_entries[st->nb_index_entries++];
                     e->pos = current_offset;
                     e->timestamp = current_dts;
                     e->size = sample_size;
@@ -255,6 +260,10 @@
                     av_log(mov->fc, AV_LOG_ERROR, ""wrong chunk count %d\n"", total);
                     return;
                 }
+                if (size > 0x3FFFFFFF) {
+                    av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", size);
+                    return;
+                }
                 e = &st->index_entries[st->nb_index_entries++];
                 e->pos = current_offset;
                 e->timestamp = current_dts;","{'deleted_lines': ['                    AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];'], 'added_lines': ['                    AVIndexEntry *e;', '                    if (sample_size > 0x3FFFFFFF) {', '                        av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\\n"", sample_size);', '                        return;', '                    }', '                    e = &st->index_entries[st->nb_index_entries++];', '                if (size > 0x3FFFFFFF) {', '                    av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\\n"", size);', '                    return;', '                }']}",True,"Integer overflow in the mov_build_index function in libavformat/mov.c in FFmpeg before 2.8.8, 3.0.x before 3.0.3 and 3.1.x before 3.1.1 allows remote attackers to have unspecified impact via vectors involving sample size.",9.8,CRITICAL,3,valid,,5
CVE-2016-9445,"['CWE-190', 'CWE-665']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gstreamer/gst-plugins-bad,"We will allocate a screen area of width*height*bpp bytes, however this
calculation can easily overflow if too high width or height are given
inside the stream. Nonetheless we would just assume that enough memory
was allocated, try to fill it and overwrite as much memory as wanted.

Also allocate the screen area filled with zeroes to ensure that we start
with full-black and not any random (or not so random) data.

https://scarybeastsecurity.blogspot.gr/2016/11/0day-poc-risky-design-decisions-in.html

Ideally we should just remove this plugin in favour of the one in
gst-libav, which generally seems to be of better code quality.

https://bugzilla.gnome.org/show_bug.cgi?id=774533
",4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,gst/vmnc/vmncdec.c,vmnc_handle_packet,"static int
vmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len,
gboolean decode)
{
int type;
int offset = 0;
if (len < 4) {
GST_LOG_OBJECT (dec, ""Packet too short"");
return ERROR_INSUFFICIENT_DATA;
}
type = data[0];
switch (type) {
case 0:
{
int numrect = RFB_GET_UINT16 (data + 2);
int i;
int read;
offset = 4;
for (i = 0; i < numrect; i++) {
struct RfbRectangle r;
rectangle_handler handler;
if (len < offset + 12) {
GST_LOG_OBJECT (dec,
""Packet too short for rectangle header: %d < %d"",
len, offset + 12);
return ERROR_INSUFFICIENT_DATA;
}
GST_LOG_OBJECT (dec, ""Reading rectangle %d"", i);
r.x = RFB_GET_UINT16 (data + offset);
r.y = RFB_GET_UINT16 (data + offset + 2);
r.width = RFB_GET_UINT16 (data + offset + 4);
r.height = RFB_GET_UINT16 (data + offset + 6);
r.type = RFB_GET_UINT32 (data + offset + 8);
if (r.type != TYPE_WMVi) {
if (!dec->have_format) {
GST_WARNING_OBJECT (dec, ""Received packet without WMVi: %d"",
r.type);
return ERROR_INVALID;
}
if (r.x + r.width > dec->format.width ||
r.y + r.height > dec->format.height) {
GST_WARNING_OBJECT (dec, ""Rectangle out of range, type %d"", r.type);
return ERROR_INVALID;
}
}
switch (r.type) {
case TYPE_WMVd:
handler = vmnc_handle_wmvd_rectangle;
break;
case TYPE_WMVe:
handler = vmnc_handle_wmve_rectangle;
break;
case TYPE_WMVf:
handler = vmnc_handle_wmvf_rectangle;
break;
case TYPE_WMVg:
handler = vmnc_handle_wmvg_rectangle;
break;
case TYPE_WMVh:
handler = vmnc_handle_wmvh_rectangle;
break;
case TYPE_WMVi:
handler = vmnc_handle_wmvi_rectangle;
break;
case TYPE_WMVj:
handler = vmnc_handle_wmvj_rectangle;
break;
case TYPE_RAW:
handler = vmnc_handle_raw_rectangle;
break;
case TYPE_COPY:
handler = vmnc_handle_copy_rectangle;
break;
case TYPE_HEXTILE:
handler = vmnc_handle_hextile_rectangle;
break;
default:
GST_WARNING_OBJECT (dec, ""Unknown rectangle type"");
return ERROR_INVALID;
}
read = handler (dec, &r, data + offset + 12, len - offset - 12, decode);
if (read < 0) {
GST_DEBUG_OBJECT (dec, ""Error calling rectangle handler\n"");
return read;
}
offset += 12 + read;
}
break;
}
default:
GST_WARNING_OBJECT (dec, ""Packet type unknown: %d"", type);
return ERROR_INVALID;
}
return offset;
}","static int
vmnc_handle_packet (GstVMncDec * VAR_0, const guint8 * VAR_1, int VAR_2,
gboolean VAR_3)
{
int VAR_4;
int VAR_5 = 0;
if (VAR_2 < 4) {
GST_LOG_OBJECT (VAR_0, ""Packet too short"");
return VAR_6;
}
VAR_4 = VAR_1[0];
switch (VAR_4) {
case 0:
{
int VAR_7 = RFB_GET_UINT16 (VAR_1 + 2);
int VAR_8;
int VAR_9;
VAR_5 = 4;
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++) {
struct RfbRectangle VAR_10;
rectangle_handler VAR_11;
if (VAR_2 < VAR_5 + 12) {
GST_LOG_OBJECT (VAR_0,
""Packet too short for rectangle header: %d < %d"",
VAR_2, VAR_5 + 12);
return VAR_6;
}
GST_LOG_OBJECT (VAR_0, ""Reading rectangle %d"", VAR_8);
VAR_10.x = RFB_GET_UINT16 (VAR_1 + VAR_5);
VAR_10.y = RFB_GET_UINT16 (VAR_1 + VAR_5 + 2);
VAR_10.width = RFB_GET_UINT16 (VAR_1 + VAR_5 + 4);
VAR_10.height = RFB_GET_UINT16 (VAR_1 + VAR_5 + 6);
VAR_10.type = RFB_GET_UINT32 (VAR_1 + VAR_5 + 8);
if (VAR_10.type != VAR_12) {
if (!VAR_0->have_format) {
GST_WARNING_OBJECT (VAR_0, ""Received packet without WMVi: %d"",
VAR_10.type);
return VAR_13;
}
if (VAR_10.x + VAR_10.width > VAR_0->format.width ||
VAR_10.y + VAR_10.height > VAR_0->format.height) {
GST_WARNING_OBJECT (VAR_0, ""Rectangle out of range, type %d"", VAR_10.type);
return VAR_13;
}
}
switch (VAR_10.type) {
case VAR_14:
VAR_11 = VAR_15;
break;
case VAR_16:
VAR_11 = VAR_17;
break;
case VAR_18:
VAR_11 = VAR_19;
break;
case VAR_20:
VAR_11 = VAR_21;
break;
case VAR_22:
VAR_11 = VAR_23;
break;
case VAR_12:
VAR_11 = VAR_24;
break;
case VAR_25:
VAR_11 = VAR_26;
break;
case VAR_27:
VAR_11 = VAR_28;
break;
case VAR_29:
VAR_11 = VAR_30;
break;
case VAR_31:
VAR_11 = VAR_32;
break;
default:
GST_WARNING_OBJECT (VAR_0, ""Unknown rectangle type"");
return VAR_13;
}
VAR_9 = VAR_11 (VAR_0, &VAR_10, VAR_1 + VAR_5 + 12, VAR_2 - VAR_5 - 12, VAR_3);
if (VAR_9 < 0) {
GST_DEBUG_OBJECT (VAR_0, ""Error calling rectangle handler\n"");
return VAR_9;
}
VAR_5 += 12 + VAR_9;
}
break;
}
default:
GST_WARNING_OBJECT (VAR_0, ""Packet type unknown: %d"", VAR_4);
return VAR_13;
}
return VAR_5;
}",gstreamer/gst-plugins-bad/4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe/vmncdec.c/vul/before/0.json,"static int
vmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len,
    gboolean decode)
{
  int type;
  int offset = 0;

  if (len < 4) {
    GST_LOG_OBJECT (dec, ""Packet too short"");
    return ERROR_INSUFFICIENT_DATA;
  }

  type = data[0];

  switch (type) {
    case 0:
    {
      int numrect = RFB_GET_UINT16 (data + 2);
      int i;
      int read;

      offset = 4;

      for (i = 0; i < numrect; i++) {
        struct RfbRectangle r;
        rectangle_handler handler;

        if (len < offset + 12) {
          GST_LOG_OBJECT (dec,
              ""Packet too short for rectangle header: %d < %d"",
              len, offset + 12);
          return ERROR_INSUFFICIENT_DATA;
        }
        GST_LOG_OBJECT (dec, ""Reading rectangle %d"", i);
        r.x = RFB_GET_UINT16 (data + offset);
        r.y = RFB_GET_UINT16 (data + offset + 2);
        r.width = RFB_GET_UINT16 (data + offset + 4);
        r.height = RFB_GET_UINT16 (data + offset + 6);
        r.type = RFB_GET_UINT32 (data + offset + 8);

        if (r.type != TYPE_WMVi) {
          /* We must have a WMVi packet to initialise things before we can 
           * continue */
          if (!dec->have_format) {
            GST_WARNING_OBJECT (dec, ""Received packet without WMVi: %d"",
                r.type);
            return ERROR_INVALID;
          }
          if (r.x + r.width > dec->format.width ||
              r.y + r.height > dec->format.height) {
            GST_WARNING_OBJECT (dec, ""Rectangle out of range, type %d"", r.type);
            return ERROR_INVALID;
          }
        } else if (r.width > 16384 || r.height > 16384) {
          GST_WARNING_OBJECT (dec, ""Width or height too high: %ux%u"", r.width,
              r.height);
          return ERROR_INVALID;
        }

        switch (r.type) {
          case TYPE_WMVd:
            handler = vmnc_handle_wmvd_rectangle;
            break;
          case TYPE_WMVe:
            handler = vmnc_handle_wmve_rectangle;
            break;
          case TYPE_WMVf:
            handler = vmnc_handle_wmvf_rectangle;
            break;
          case TYPE_WMVg:
            handler = vmnc_handle_wmvg_rectangle;
            break;
          case TYPE_WMVh:
            handler = vmnc_handle_wmvh_rectangle;
            break;
          case TYPE_WMVi:
            handler = vmnc_handle_wmvi_rectangle;
            break;
          case TYPE_WMVj:
            handler = vmnc_handle_wmvj_rectangle;
            break;
          case TYPE_RAW:
            handler = vmnc_handle_raw_rectangle;
            break;
          case TYPE_COPY:
            handler = vmnc_handle_copy_rectangle;
            break;
          case TYPE_HEXTILE:
            handler = vmnc_handle_hextile_rectangle;
            break;
          default:
            GST_WARNING_OBJECT (dec, ""Unknown rectangle type"");
            return ERROR_INVALID;
        }

        read = handler (dec, &r, data + offset + 12, len - offset - 12, decode);
        if (read < 0) {
          GST_DEBUG_OBJECT (dec, ""Error calling rectangle handler\n"");
          return read;
        }
        offset += 12 + read;
      }
      break;
    }
    default:
      GST_WARNING_OBJECT (dec, ""Packet type unknown: %d"", type);
      return ERROR_INVALID;
  }

  return offset;
}","static int
vmnc_handle_packet (GstVMncDec * VAR_0, const guint8 * VAR_1, int VAR_2,
    gboolean VAR_3)
{
  int VAR_4;
  int VAR_5 = 0;

  if (VAR_2 < 4) {
    GST_LOG_OBJECT (VAR_0, ""Packet too short"");
    return VAR_6;
  }

  VAR_4 = VAR_1[0];

  switch (VAR_4) {
    case 0:
    {
      int VAR_7 = RFB_GET_UINT16 (VAR_1 + 2);
      int VAR_8;
      int VAR_9;

      VAR_5 = 4;

      for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++) {
        struct RfbRectangle VAR_10;
        rectangle_handler VAR_11;

        if (VAR_2 < VAR_5 + 12) {
          GST_LOG_OBJECT (VAR_0,
              ""Packet too short for rectangle header: %d < %d"",
              VAR_2, VAR_5 + 12);
          return VAR_6;
        }
        GST_LOG_OBJECT (VAR_0, ""Reading rectangle %d"", VAR_8);
        VAR_10.x = RFB_GET_UINT16 (VAR_1 + VAR_5);
        VAR_10.y = RFB_GET_UINT16 (VAR_1 + VAR_5 + 2);
        VAR_10.width = RFB_GET_UINT16 (VAR_1 + VAR_5 + 4);
        VAR_10.height = RFB_GET_UINT16 (VAR_1 + VAR_5 + 6);
        VAR_10.type = RFB_GET_UINT32 (VAR_1 + VAR_5 + 8);

        if (VAR_10.type != VAR_12) {
          /* COMMENT_0 */
                        
          if (!VAR_0->have_format) {
            GST_WARNING_OBJECT (VAR_0, ""Received packet without WMVi: %d"",
                VAR_10.type);
            return VAR_13;
          }
          if (VAR_10.x + VAR_10.width > VAR_0->format.width ||
              VAR_10.y + VAR_10.height > VAR_0->format.height) {
            GST_WARNING_OBJECT (VAR_0, ""Rectangle out of range, type %d"", VAR_10.type);
            return VAR_13;
          }
        } else if (VAR_10.width > 16384 || VAR_10.height > 16384) {
          GST_WARNING_OBJECT (VAR_0, ""Width or height too high: %ux%u"", VAR_10.width,
              VAR_10.height);
          return VAR_13;
        }

        switch (VAR_10.type) {
          case VAR_14:
            VAR_11 = VAR_15;
            break;
          case VAR_16:
            VAR_11 = VAR_17;
            break;
          case VAR_18:
            VAR_11 = VAR_19;
            break;
          case VAR_20:
            VAR_11 = VAR_21;
            break;
          case VAR_22:
            VAR_11 = VAR_23;
            break;
          case VAR_12:
            VAR_11 = VAR_24;
            break;
          case VAR_25:
            VAR_11 = VAR_26;
            break;
          case VAR_27:
            VAR_11 = VAR_28;
            break;
          case VAR_29:
            VAR_11 = VAR_30;
            break;
          case VAR_31:
            VAR_11 = VAR_32;
            break;
          default:
            GST_WARNING_OBJECT (VAR_0, ""Unknown rectangle type"");
            return VAR_13;
        }

        VAR_9 = VAR_11 (VAR_0, &VAR_10, VAR_1 + VAR_5 + 12, VAR_2 - VAR_5 - 12, VAR_3);
        if (VAR_9 < 0) {
          GST_DEBUG_OBJECT (VAR_0, ""Error calling rectangle handler\n"");
          return VAR_9;
        }
        VAR_5 += 12 + VAR_9;
      }
      break;
    }
    default:
      GST_WARNING_OBJECT (VAR_0, ""Packet type unknown: %d"", VAR_4);
      return VAR_13;
  }

  return VAR_5;
}",gstreamer/gst-plugins-bad/4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe/vmncdec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -51,6 +51,10 @@
             GST_WARNING_OBJECT (dec, ""Rectangle out of range, type %d"", r.type);
             return ERROR_INVALID;
           }
+        } else if (r.width > 16384 || r.height > 16384) {
+          GST_WARNING_OBJECT (dec, ""Width or height too high: %ux%u"", r.width,
+              r.height);
+          return ERROR_INVALID;
         }
 
         switch (r.type) {","{'deleted_lines': [], 'added_lines': ['        } else if (r.width > 16384 || r.height > 16384) {', '          GST_WARNING_OBJECT (dec, ""Width or height too high: %ux%u"", r.width,', '              r.height);', '          return ERROR_INVALID;']}",True,"Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.",7.5,HIGH,2,valid,,5
CVE-2016-9445,"['CWE-190', 'CWE-665']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gstreamer/gst-plugins-bad,"We will allocate a screen area of width*height*bpp bytes, however this
calculation can easily overflow if too high width or height are given
inside the stream. Nonetheless we would just assume that enough memory
was allocated, try to fill it and overwrite as much memory as wanted.

Also allocate the screen area filled with zeroes to ensure that we start
with full-black and not any random (or not so random) data.

https://scarybeastsecurity.blogspot.gr/2016/11/0day-poc-risky-design-decisions-in.html

Ideally we should just remove this plugin in favour of the one in
gst-libav, which generally seems to be of better code quality.

https://bugzilla.gnome.org/show_bug.cgi?id=774533
",4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe,gst/vmnc/vmncdec.c,vmnc_handle_wmvi_rectangle,"static int
vmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,
const guint8 * data, int len, gboolean decode)
{
GstVideoFormat format;
gint bpp, tc;
guint32 redmask, greenmask, bluemask;
guint32 endianness, dataendianness;
GstVideoCodecState *state;
if (len < 16) {
GST_DEBUG_OBJECT (dec, ""Bad WMVi rect: too short"");
return ERROR_INSUFFICIENT_DATA;
}
if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {
return 16;
}
memcpy (dec->format.descriptor, data, 16);
if (rect->x != 0 || rect->y != 0) {
GST_WARNING_OBJECT (dec, ""Bad WMVi rect: wrong coordinates"");
return ERROR_INVALID;
}
bpp = data[0];
dec->format.depth = data[1];
dec->format.big_endian = data[2];
dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;
tc = data[3];
if (bpp != 8 && bpp != 16 && bpp != 32) {
GST_WARNING_OBJECT (dec, ""Bad bpp value: %d"", bpp);
return ERROR_INVALID;
}
if (!tc) {
GST_WARNING_OBJECT (dec, ""Paletted video not supported"");
return ERROR_INVALID;
}
dec->format.bytes_per_pixel = bpp / 8;
dec->format.width = rect->width;
dec->format.height = rect->height;
redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];
greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];
bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];
GST_DEBUG_OBJECT (dec, ""Red: mask %d, shift %d"",
RFB_GET_UINT16 (data + 4), data[10]);
GST_DEBUG_OBJECT (dec, ""Green: mask %d, shift %d"",
RFB_GET_UINT16 (data + 6), data[11]);
GST_DEBUG_OBJECT (dec, ""Blue: mask %d, shift %d"",
RFB_GET_UINT16 (data + 8), data[12]);
GST_DEBUG_OBJECT (dec, ""BPP: %d. endianness: %s"", bpp,
data[2] ? ""big"" : ""little"");
if (bpp == 8) {
endianness = G_BYTE_ORDER;  
} else if (bpp == 16) {
endianness = G_BYTE_ORDER;
} else {                      
endianness = G_BIG_ENDIAN;
if (endianness != dataendianness) {
redmask = GUINT32_SWAP_LE_BE (redmask);
greenmask = GUINT32_SWAP_LE_BE (greenmask);
bluemask = GUINT32_SWAP_LE_BE (bluemask);
}
}
format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,
redmask, greenmask, bluemask, 0);
GST_DEBUG_OBJECT (dec, ""From depth: %d bpp: %u endianess: %s redmask: %X ""
""greenmask: %X bluemask: %X got format %s"",
dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? ""BE"" : ""LE"",
GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),
GUINT32_FROM_BE (bluemask),
format == GST_VIDEO_FORMAT_UNKNOWN ? ""UNKOWN"" :
gst_video_format_to_string (format));
if (format == GST_VIDEO_FORMAT_UNKNOWN) {
GST_WARNING_OBJECT (dec, ""Video format unknown to GStreamer"");
return ERROR_INVALID;
}
dec->have_format = TRUE;
if (!decode) {
GST_LOG_OBJECT (dec, ""Parsing, not setting caps"");
return 16;
}
state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,
rect->width, rect->height, dec->input_state);
gst_video_codec_state_unref (state);
g_free (dec->imagedata);
dec->imagedata = g_malloc (dec->format.width * dec->format.height *
dec->format.bytes_per_pixel);
GST_DEBUG_OBJECT (dec, ""Allocated image data at %p"", dec->imagedata);
dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;
return 16;
}","static int
vmnc_handle_wmvi_rectangle (GstVMncDec * VAR_0, struct RfbRectangle *VAR_1,
const guint8 * VAR_2, int VAR_3, gboolean VAR_4)
{
GstVideoFormat VAR_5;
gint VAR_6, VAR_7;
guint32 VAR_8, VAR_9, VAR_10;
guint32 VAR_11, VAR_12;
GstVideoCodecState *VAR_13;
if (VAR_3 < 16) {
GST_DEBUG_OBJECT (VAR_0, ""Bad WMVi rect: too short"");
return VAR_14;
}
if (VAR_0->have_format && memcmp (VAR_2, VAR_0->format.descriptor, 13) == 0) {
return 16;
}
memcpy (VAR_0->format.descriptor, VAR_2, 16);
if (VAR_1->x != 0 || VAR_1->y != 0) {
GST_WARNING_OBJECT (VAR_0, ""Bad WMVi rect: wrong coordinates"");
return VAR_15;
}
VAR_6 = VAR_2[0];
VAR_0->format.depth = VAR_2[1];
VAR_0->format.big_endian = VAR_2[2];
VAR_12 = VAR_2[2] ? VAR_16 : VAR_17;
VAR_7 = VAR_2[3];
if (VAR_6 != 8 && VAR_6 != 16 && VAR_6 != 32) {
GST_WARNING_OBJECT (VAR_0, ""Bad bpp value: %d"", VAR_6);
return VAR_15;
}
if (!VAR_7) {
GST_WARNING_OBJECT (VAR_0, ""Paletted video not supported"");
return VAR_15;
}
VAR_0->format.bytes_per_pixel = VAR_6 / 8;
VAR_0->format.width = VAR_1->width;
VAR_0->format.height = VAR_1->height;
VAR_8 = (guint32) (RFB_GET_UINT16 (VAR_2 + 4)) << VAR_2[10];
VAR_9 = (guint32) (RFB_GET_UINT16 (VAR_2 + 6)) << VAR_2[11];
VAR_10 = (guint32) (RFB_GET_UINT16 (VAR_2 + 8)) << VAR_2[12];
GST_DEBUG_OBJECT (VAR_0, ""Red: mask %d, shift %d"",
RFB_GET_UINT16 (VAR_2 + 4), VAR_2[10]);
GST_DEBUG_OBJECT (VAR_0, ""Green: mask %d, shift %d"",
RFB_GET_UINT16 (VAR_2 + 6), VAR_2[11]);
GST_DEBUG_OBJECT (VAR_0, ""Blue: mask %d, shift %d"",
RFB_GET_UINT16 (VAR_2 + 8), VAR_2[12]);
GST_DEBUG_OBJECT (VAR_0, ""BPP: %d. endianness: %s"", VAR_6,
VAR_2[2] ? ""big"" : ""little"");
if (VAR_6 == 8) {
VAR_11 = VAR_18;  
} else if (VAR_6 == 16) {
VAR_11 = VAR_18;
} else {                      
VAR_11 = VAR_16;
if (VAR_11 != VAR_12) {
VAR_8 = GUINT32_SWAP_LE_BE (VAR_8);
VAR_9 = GUINT32_SWAP_LE_BE (VAR_9);
VAR_10 = GUINT32_SWAP_LE_BE (VAR_10);
}
}
VAR_5 = gst_video_format_from_masks (VAR_0->format.depth, VAR_6, VAR_11,
VAR_8, VAR_9, VAR_10, 0);
GST_DEBUG_OBJECT (VAR_0, ""From depth: %d bpp: %u endianess: %s redmask: %X ""
""greenmask: %X bluemask: %X got format %s"",
VAR_0->format.depth, VAR_6, VAR_11 == VAR_16 ? ""BE"" : ""LE"",
GUINT32_FROM_BE (VAR_8), GUINT32_FROM_BE (VAR_9),
GUINT32_FROM_BE (VAR_10),
VAR_5 == VAR_19 ? ""UNKOWN"" :
gst_video_format_to_string (VAR_5));
if (VAR_5 == VAR_19) {
GST_WARNING_OBJECT (VAR_0, ""Video format unknown to GStreamer"");
return VAR_15;
}
VAR_0->have_format = TRUE;
if (!VAR_4) {
GST_LOG_OBJECT (VAR_0, ""Parsing, not setting caps"");
return 16;
}
VAR_13 = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (VAR_0), VAR_5,
VAR_1->width, VAR_1->height, VAR_0->input_state);
gst_video_codec_state_unref (VAR_13);
g_free (VAR_0->imagedata);
VAR_0->imagedata = g_malloc (VAR_0->format.width * VAR_0->format.height *
VAR_0->format.bytes_per_pixel);
GST_DEBUG_OBJECT (VAR_0, ""Allocated image data at %p"", VAR_0->imagedata);
VAR_0->format.stride = VAR_0->format.width * VAR_0->format.bytes_per_pixel;
return 16;
}",gstreamer/gst-plugins-bad/4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe/vmncdec.c/vul/before/1.json,"static int
vmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,
    const guint8 * data, int len, gboolean decode)
{
  GstVideoFormat format;
  gint bpp, tc;
  guint32 redmask, greenmask, bluemask;
  guint32 endianness, dataendianness;
  GstVideoCodecState *state;

  /* A WMVi rectangle has a 16byte payload */
  if (len < 16) {
    GST_DEBUG_OBJECT (dec, ""Bad WMVi rect: too short"");
    return ERROR_INSUFFICIENT_DATA;
  }

  /* We only compare 13 bytes; ignoring the 3 padding bytes at the end */
  if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {
    /* Nothing changed, so just exit */
    return 16;
  }

  /* Store the whole block for simple comparison later */
  memcpy (dec->format.descriptor, data, 16);

  if (rect->x != 0 || rect->y != 0) {
    GST_WARNING_OBJECT (dec, ""Bad WMVi rect: wrong coordinates"");
    return ERROR_INVALID;
  }

  bpp = data[0];
  dec->format.depth = data[1];
  dec->format.big_endian = data[2];
  dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;
  tc = data[3];

  if (bpp != 8 && bpp != 16 && bpp != 32) {
    GST_WARNING_OBJECT (dec, ""Bad bpp value: %d"", bpp);
    return ERROR_INVALID;
  }

  if (!tc) {
    GST_WARNING_OBJECT (dec, ""Paletted video not supported"");
    return ERROR_INVALID;
  }

  dec->format.bytes_per_pixel = bpp / 8;
  dec->format.width = rect->width;
  dec->format.height = rect->height;

  redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];
  greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];
  bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];

  GST_DEBUG_OBJECT (dec, ""Red: mask %d, shift %d"",
      RFB_GET_UINT16 (data + 4), data[10]);
  GST_DEBUG_OBJECT (dec, ""Green: mask %d, shift %d"",
      RFB_GET_UINT16 (data + 6), data[11]);
  GST_DEBUG_OBJECT (dec, ""Blue: mask %d, shift %d"",
      RFB_GET_UINT16 (data + 8), data[12]);
  GST_DEBUG_OBJECT (dec, ""BPP: %d. endianness: %s"", bpp,
      data[2] ? ""big"" : ""little"");

  /* GStreamer's RGB caps are a bit weird. */
  if (bpp == 8) {
    endianness = G_BYTE_ORDER;  /* Doesn't matter */
  } else if (bpp == 16) {
    /* We require host-endian. */
    endianness = G_BYTE_ORDER;
  } else {                      /* bpp == 32 */
    /* We require big endian */
    endianness = G_BIG_ENDIAN;
    if (endianness != dataendianness) {
      redmask = GUINT32_SWAP_LE_BE (redmask);
      greenmask = GUINT32_SWAP_LE_BE (greenmask);
      bluemask = GUINT32_SWAP_LE_BE (bluemask);
    }
  }

  format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,
      redmask, greenmask, bluemask, 0);

  GST_DEBUG_OBJECT (dec, ""From depth: %d bpp: %u endianess: %s redmask: %X ""
      ""greenmask: %X bluemask: %X got format %s"",
      dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? ""BE"" : ""LE"",
      GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),
      GUINT32_FROM_BE (bluemask),
      format == GST_VIDEO_FORMAT_UNKNOWN ? ""UNKOWN"" :
      gst_video_format_to_string (format));

  if (format == GST_VIDEO_FORMAT_UNKNOWN) {
    GST_WARNING_OBJECT (dec, ""Video format unknown to GStreamer"");
    return ERROR_INVALID;
  }

  dec->have_format = TRUE;
  if (!decode) {
    GST_LOG_OBJECT (dec, ""Parsing, not setting caps"");
    return 16;
  }


  state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,
      rect->width, rect->height, dec->input_state);
  gst_video_codec_state_unref (state);

  g_free (dec->imagedata);
  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *
      dec->format.bytes_per_pixel);
  GST_DEBUG_OBJECT (dec, ""Allocated image data at %p"", dec->imagedata);

  dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;

  return 16;
}","static int
vmnc_handle_wmvi_rectangle (GstVMncDec * VAR_0, struct RfbRectangle *VAR_1,
    const guint8 * VAR_2, int VAR_3, gboolean VAR_4)
{
  GstVideoFormat VAR_5;
  gint VAR_6, VAR_7;
  guint32 VAR_8, VAR_9, VAR_10;
  guint32 VAR_11, VAR_12;
  GstVideoCodecState *VAR_13;

  /* COMMENT_0 */
  if (VAR_3 < 16) {
    GST_DEBUG_OBJECT (VAR_0, ""Bad WMVi rect: too short"");
    return VAR_14;
  }

  /* COMMENT_1 */
  if (VAR_0->have_format && memcmp (VAR_2, VAR_0->format.descriptor, 13) == 0) {
    /* COMMENT_2 */
    return 16;
  }

  /* COMMENT_3 */
  memcpy (VAR_0->format.descriptor, VAR_2, 16);

  if (VAR_1->x != 0 || VAR_1->y != 0) {
    GST_WARNING_OBJECT (VAR_0, ""Bad WMVi rect: wrong coordinates"");
    return VAR_15;
  }

  VAR_6 = VAR_2[0];
  VAR_0->format.depth = VAR_2[1];
  VAR_0->format.big_endian = VAR_2[2];
  VAR_12 = VAR_2[2] ? VAR_16 : VAR_17;
  VAR_7 = VAR_2[3];

  if (VAR_6 != 8 && VAR_6 != 16 && VAR_6 != 32) {
    GST_WARNING_OBJECT (VAR_0, ""Bad bpp value: %d"", VAR_6);
    return VAR_15;
  }

  if (!VAR_7) {
    GST_WARNING_OBJECT (VAR_0, ""Paletted video not supported"");
    return VAR_15;
  }

  VAR_0->format.bytes_per_pixel = VAR_6 / 8;
  VAR_0->format.width = VAR_1->width;
  VAR_0->format.height = VAR_1->height;

  VAR_8 = (guint32) (RFB_GET_UINT16 (VAR_2 + 4)) << VAR_2[10];
  VAR_9 = (guint32) (RFB_GET_UINT16 (VAR_2 + 6)) << VAR_2[11];
  VAR_10 = (guint32) (RFB_GET_UINT16 (VAR_2 + 8)) << VAR_2[12];

  GST_DEBUG_OBJECT (VAR_0, ""Red: mask %d, shift %d"",
      RFB_GET_UINT16 (VAR_2 + 4), VAR_2[10]);
  GST_DEBUG_OBJECT (VAR_0, ""Green: mask %d, shift %d"",
      RFB_GET_UINT16 (VAR_2 + 6), VAR_2[11]);
  GST_DEBUG_OBJECT (VAR_0, ""Blue: mask %d, shift %d"",
      RFB_GET_UINT16 (VAR_2 + 8), VAR_2[12]);
  GST_DEBUG_OBJECT (VAR_0, ""BPP: %d. endianness: %s"", VAR_6,
      VAR_2[2] ? ""big"" : ""little"");

  /* COMMENT_4 */
  if (VAR_6 == 8) {
    VAR_11 = VAR_18;  /* COMMENT_5 */
  } else if (VAR_6 == 16) {
    /* COMMENT_6 */
    VAR_11 = VAR_18;
  } else {                      /* COMMENT_7 */
    /* COMMENT_8 */
    VAR_11 = VAR_16;
    if (VAR_11 != VAR_12) {
      VAR_8 = GUINT32_SWAP_LE_BE (VAR_8);
      VAR_9 = GUINT32_SWAP_LE_BE (VAR_9);
      VAR_10 = GUINT32_SWAP_LE_BE (VAR_10);
    }
  }

  VAR_5 = gst_video_format_from_masks (VAR_0->format.depth, VAR_6, VAR_11,
      VAR_8, VAR_9, VAR_10, 0);

  GST_DEBUG_OBJECT (VAR_0, ""From depth: %d bpp: %u endianess: %s redmask: %X ""
      ""greenmask: %X bluemask: %X got format %s"",
      VAR_0->format.depth, VAR_6, VAR_11 == VAR_16 ? ""BE"" : ""LE"",
      GUINT32_FROM_BE (VAR_8), GUINT32_FROM_BE (VAR_9),
      GUINT32_FROM_BE (VAR_10),
      VAR_5 == VAR_19 ? ""UNKOWN"" :
      gst_video_format_to_string (VAR_5));

  if (VAR_5 == VAR_19) {
    GST_WARNING_OBJECT (VAR_0, ""Video format unknown to GStreamer"");
    return VAR_15;
  }

  VAR_0->have_format = TRUE;
  if (!VAR_4) {
    GST_LOG_OBJECT (VAR_0, ""Parsing, not setting caps"");
    return 16;
  }


  VAR_13 = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (VAR_0), VAR_5,
      VAR_1->width, VAR_1->height, VAR_0->input_state);
  gst_video_codec_state_unref (VAR_13);

  g_free (VAR_0->imagedata);
  VAR_0->imagedata = g_malloc0 (VAR_0->format.width * VAR_0->format.height *
      VAR_0->format.bytes_per_pixel);
  GST_DEBUG_OBJECT (VAR_0, ""Allocated image data at %p"", VAR_0->imagedata);

  VAR_0->format.stride = VAR_0->format.width * VAR_0->format.bytes_per_pixel;

  return 16;
}",gstreamer/gst-plugins-bad/4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe/vmncdec.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -105,7 +105,7 @@
   gst_video_codec_state_unref (state);
 
   g_free (dec->imagedata);
-  dec->imagedata = g_malloc (dec->format.width * dec->format.height *
+  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *
       dec->format.bytes_per_pixel);
   GST_DEBUG_OBJECT (dec, ""Allocated image data at %p"", dec->imagedata);
 ","{'deleted_lines': ['  dec->imagedata = g_malloc (dec->format.width * dec->format.height *'], 'added_lines': ['  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *']}",True,"Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.",7.5,HIGH,2,valid,,5
CVE-2015-6792,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix a potential crash in MidiManagerMac.

R=toyoshim@chromium.org,agoode@chromium.org
BUG=564501

Review URL: https://codereview.chromium.org/1508563003

Cr-Commit-Position: refs/heads/master@{#363714}
",54d256d1fc9c6a9e7438f6f51206d1f99b1ed6b4,https://chromium.googlesource.com/chromium/src/+/54d256d1fc9c6a9e7438f6f51206d1f99b1ed6b4,media/midi/midi_manager_mac.cc,MidiManagerMac::SendMidiData,"void MidiManagerMac::SendMidiData(MidiManagerClient* client,
uint32 port_index,
const std::vector<uint8>& data,
double timestamp) {
DCHECK(client_thread_.task_runner()->BelongsToCurrentThread());
if (static_cast<size_t>(port_index) >= destinations_.size())
return;
MIDITimeStamp coremidi_timestamp = SecondsToMIDITimeStamp(timestamp);
MIDIEndpointRef destination = destinations_[port_index];
size_t send_size;
for (size_t sent_size = 0; sent_size < data.size(); sent_size += send_size) {
MIDIPacketList* packet_list =
reinterpret_cast<MIDIPacketList*>(midi_buffer_.data());
MIDIPacket* midi_packet = MIDIPacketListInit(packet_list);
send_size = std::min(data.size() - sent_size, kEstimatedMaxPacketDataSize);
midi_packet = MIDIPacketListAdd(
packet_list,
kCoreMIDIMaxPacketListSize,
midi_packet,
coremidi_timestamp,
send_size,
&data[sent_size]);
DCHECK(midi_packet);
MIDISend(coremidi_output_, destination, packet_list);
}
client->AccumulateMidiBytesSent(data.size());
}","void MidiManagerMac::SendMidiData(MidiManagerClient* VAR_0,
uint32 VAR_1,
const std::vector<uint8>& VAR_2,
double VAR_3) {
DCHECK(VAR_4.task_runner()->BelongsToCurrentThread());
if (VAR_5<size_t>(VAR_1) >= VAR_6.size())
return;
MIDITimeStamp VAR_7 = SecondsToMIDITimeStamp(VAR_3);
MIDIEndpointRef VAR_8 = VAR_6[VAR_1];
size_t VAR_9;
for (size_t VAR_10 = 0; VAR_10 < VAR_2.size(); VAR_10 += VAR_9) {
MIDIPacketList* VAR_11 =
VAR_12<MIDIPacketList*>(VAR_13.data());
MIDIPacket* VAR_14 = MIDIPacketListInit(VAR_11);
VAR_9 = std::min(VAR_2.size() - VAR_10, VAR_15);
VAR_14 = MIDIPacketListAdd(
VAR_11,
VAR_16,
VAR_14,
VAR_7,
VAR_9,
&VAR_2[VAR_10]);
DCHECK(VAR_14);
MIDISend(VAR_17, VAR_8, VAR_11);
}
VAR_0->AccumulateMidiBytesSent(VAR_2.size());
}",chromium/54d256d1fc9c6a9e7438f6f51206d1f99b1ed6b4/midi_manager_mac.cc/vul/before/0.json,"void MidiManagerMac::SendMidiData(MidiManagerClient* client,
                                  uint32 port_index,
                                  const std::vector<uint8>& data,
                                  double timestamp) {
  DCHECK(client_thread_.task_runner()->BelongsToCurrentThread());

  // Lookup the destination based on the port index.
  if (static_cast<size_t>(port_index) >= destinations_.size())
    return;

  MIDITimeStamp coremidi_timestamp = SecondsToMIDITimeStamp(timestamp);
  MIDIEndpointRef destination = destinations_[port_index];

  size_t send_size;
  for (size_t sent_size = 0; sent_size < data.size(); sent_size += send_size) {
    MIDIPacketList* packet_list =
        reinterpret_cast<MIDIPacketList*>(midi_buffer_.data());
    MIDIPacket* midi_packet = MIDIPacketListInit(packet_list);
    // Limit the maximum payload size to kEstimatedMaxPacketDataSize that is
    // half of midi_buffer data size. MIDIPacketList and MIDIPacket consume
    // extra buffer areas for meta information, and available size is smaller
    // than buffer size. Here, we simply assume that at least half size is
    // available for data payload.
    send_size = std::min(data.size() - sent_size, kEstimatedMaxPacketDataSize);
    midi_packet = MIDIPacketListAdd(
        packet_list,
        kCoreMIDIMaxPacketListSize,
        midi_packet,
        coremidi_timestamp,
        send_size,
        &data[sent_size]);
    DCHECK(midi_packet);

    MIDISend(coremidi_output_, destination, packet_list);
  }

  AccumulateMidiBytesSent(client, data.size());
}","void MidiManagerMac::SendMidiData(MidiManagerClient* VAR_0,
                                  uint32 VAR_1,
                                  const std::vector<uint8>& VAR_2,
                                  double VAR_3) {
  DCHECK(VAR_4.task_runner()->BelongsToCurrentThread());

  /* COMMENT_0 */
  if (VAR_5<size_t>(VAR_1) >= VAR_6.size())
    return;

  MIDITimeStamp VAR_7 = SecondsToMIDITimeStamp(VAR_3);
  MIDIEndpointRef VAR_8 = VAR_6[VAR_1];

  size_t VAR_9;
  for (size_t VAR_10 = 0; VAR_10 < VAR_2.size(); VAR_10 += VAR_9) {
    MIDIPacketList* VAR_11 =
        VAR_12<MIDIPacketList*>(VAR_13.data());
    MIDIPacket* VAR_14 = MIDIPacketListInit(VAR_11);
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    VAR_9 = std::min(VAR_2.size() - VAR_10, VAR_15);
    VAR_14 = MIDIPacketListAdd(
        VAR_11,
        VAR_16,
        VAR_14,
        VAR_7,
        VAR_9,
        &VAR_2[VAR_10]);
    DCHECK(VAR_14);

    MIDISend(VAR_17, VAR_8, VAR_11);
  }

  AccumulateMidiBytesSent(VAR_0, VAR_2.size());
}",chromium/54d256d1fc9c6a9e7438f6f51206d1f99b1ed6b4/midi_manager_mac.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,5 +34,5 @@
     MIDISend(coremidi_output_, destination, packet_list);
   }
 
-  client->AccumulateMidiBytesSent(data.size());
+  AccumulateMidiBytesSent(client, data.size());
 }","{'deleted_lines': ['  client->AccumulateMidiBytesSent(data.size());'], 'added_lines': ['  AccumulateMidiBytesSent(client, data.size());']}",True,"The MIDI subsystem in Google Chrome before 47.0.2526.106 does not properly handle the sending of data, which allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via unspecified vectors, related to midi_manager.cc, midi_manager_alsa.cc, and midi_manager_mac.cc, a different vulnerability than CVE-2015-8664.",9.8,CRITICAL,3,valid,,5
CVE-2015-6792,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix crash with MIDI send for MidiManagerAlsa

BUG=564501

Review URL: https://codereview.chromium.org/1500153002

Cr-Commit-Position: refs/heads/master@{#363413}
",a3d22f60a719a6dae77a0586ef32dd12ac463952,https://chromium.googlesource.com/chromium/src/+/a3d22f60a719a6dae77a0586ef32dd12ac463952,media/midi/midi_manager.cc,MidiManager::AccumulateMidiBytesSent,"void MidiManager::AccumulateMidiBytesSent(MidiManagerClient* client, size_t n) {
{
base::AutoLock auto_lock(lock_);
if (clients_.find(client) == clients_.end())
return;
}
client->AccumulateMidiBytesSent(n);
}","void MidiManager::AccumulateMidiBytesSent(MidiManagerClient* VAR_0, size_t VAR_1) {
{
base::AutoLock auto_lock(lock_);
if (VAR_2.find(VAR_0) == VAR_2.end())
return;
}
VAR_0->AccumulateMidiBytesSent(VAR_1);
}",chromium/a3d22f60a719a6dae77a0586ef32dd12ac463952/midi_manager.cc/vul/before/0.json,"void MidiManager::AccumulateMidiBytesSent(MidiManagerClient* client, size_t n) {
  base::AutoLock auto_lock(lock_);
  if (clients_.find(client) == clients_.end())
    return;

  client->AccumulateMidiBytesSent(n);
}","void MidiManager::AccumulateMidiBytesSent(MidiManagerClient* VAR_0, size_t VAR_1) {
  base::AutoLock auto_lock(lock_);
  if (VAR_2.find(VAR_0) == VAR_2.end())
    return;

  VAR_0->AccumulateMidiBytesSent(VAR_1);
}",chromium/a3d22f60a719a6dae77a0586ef32dd12ac463952/midi_manager.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,7 @@
 void MidiManager::AccumulateMidiBytesSent(MidiManagerClient* client, size_t n) {
-  {
-    base::AutoLock auto_lock(lock_);
-    if (clients_.find(client) == clients_.end())
-      return;
-  }
+  base::AutoLock auto_lock(lock_);
+  if (clients_.find(client) == clients_.end())
+    return;
+
   client->AccumulateMidiBytesSent(n);
 }","{'deleted_lines': ['  {', '    base::AutoLock auto_lock(lock_);', '    if (clients_.find(client) == clients_.end())', '      return;', '  }'], 'added_lines': ['  base::AutoLock auto_lock(lock_);', '  if (clients_.find(client) == clients_.end())', '    return;', '']}",True,"The MIDI subsystem in Google Chrome before 47.0.2526.106 does not properly handle the sending of data, which allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via unspecified vectors, related to midi_manager.cc, midi_manager_alsa.cc, and midi_manager_mac.cc, a different vulnerability than CVE-2015-8664.",9.8,CRITICAL,3,valid,,5
CVE-2015-6792,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,chromium,"Fix crash with MIDI send for MidiManagerAlsa

BUG=564501

Review URL: https://codereview.chromium.org/1500153002

Cr-Commit-Position: refs/heads/master@{#363413}
",a3d22f60a719a6dae77a0586ef32dd12ac463952,https://chromium.googlesource.com/chromium/src/+/a3d22f60a719a6dae77a0586ef32dd12ac463952,media/midi/midi_manager_alsa.cc,MidiManagerAlsa::DispatchSendMidiData,"void MidiManagerAlsa::DispatchSendMidiData(MidiManagerClient* client,
uint32 port_index,
const std::vector<uint8>& data,
double timestamp) {
if (!send_thread_.IsRunning())
send_thread_.Start();
base::TimeDelta delay;
if (timestamp != 0.0) {
base::TimeTicks time_to_send =
base::TimeTicks() + base::TimeDelta::FromMicroseconds(
timestamp * base::Time::kMicrosecondsPerSecond);
delay = std::max(time_to_send - base::TimeTicks::Now(), base::TimeDelta());
}
send_thread_.message_loop()->PostDelayedTask(
FROM_HERE, base::Bind(&MidiManagerAlsa::SendMidiData,
base::Unretained(this), port_index, data),
delay);
send_thread_.message_loop()->PostTask(
FROM_HERE, base::Bind(&MidiManagerClient::AccumulateMidiBytesSent,
base::Unretained(client), data.size()));
}","void MidiManagerAlsa::DispatchSendMidiData(MidiManagerClient* VAR_0,
uint32 VAR_1,
const std::vector<uint8>& VAR_2,
double VAR_3) {
if (!VAR_4.IsRunning())
VAR_4.Start();
base::TimeDelta VAR_5;
if (VAR_3 != 0.0) {
base::TimeTicks VAR_6 =
base::TimeTicks() + base::TimeDelta::FromMicroseconds(
VAR_3 * base::Time::kMicrosecondsPerSecond);
VAR_5 = std::max(VAR_6 - base::TimeTicks::Now(), base::TimeDelta());
}
VAR_4.message_loop()->PostDelayedTask(
VAR_7, base::Bind(&MidiManagerAlsa::SendMidiData,
base::Unretained(this), VAR_1, VAR_2),
VAR_5);
VAR_4.message_loop()->PostTask(
VAR_7, base::Bind(&MidiManagerClient::AccumulateMidiBytesSent,
base::Unretained(VAR_0), VAR_2.size()));
}",chromium/a3d22f60a719a6dae77a0586ef32dd12ac463952/midi_manager_alsa.cc/vul/before/0.json,"void MidiManagerAlsa::DispatchSendMidiData(MidiManagerClient* client,
                                           uint32 port_index,
                                           const std::vector<uint8>& data,
                                           double timestamp) {
  if (!send_thread_.IsRunning())
    send_thread_.Start();

  base::TimeDelta delay;
  if (timestamp != 0.0) {
    base::TimeTicks time_to_send =
        base::TimeTicks() + base::TimeDelta::FromMicroseconds(
                                timestamp * base::Time::kMicrosecondsPerSecond);
    delay = std::max(time_to_send - base::TimeTicks::Now(), base::TimeDelta());
  }

  send_thread_.message_loop()->PostDelayedTask(
      FROM_HERE, base::Bind(&MidiManagerAlsa::SendMidiData,
                            base::Unretained(this), port_index, data),
      delay);

  // Acknowledge send.
  send_thread_.message_loop()->PostTask(
      FROM_HERE, base::Bind(&MidiManagerAlsa::AccumulateMidiBytesSent,
                            base::Unretained(this), client, data.size()));
}","void MidiManagerAlsa::DispatchSendMidiData(MidiManagerClient* VAR_0,
                                           uint32 VAR_1,
                                           const std::vector<uint8>& VAR_2,
                                           double VAR_3) {
  if (!VAR_4.IsRunning())
    VAR_4.Start();

  base::TimeDelta VAR_5;
  if (VAR_3 != 0.0) {
    base::TimeTicks VAR_6 =
        base::TimeTicks() + base::TimeDelta::FromMicroseconds(
                                VAR_3 * base::Time::kMicrosecondsPerSecond);
    VAR_5 = std::max(VAR_6 - base::TimeTicks::Now(), base::TimeDelta());
  }

  VAR_4.message_loop()->PostDelayedTask(
      VAR_7, base::Bind(&MidiManagerAlsa::SendMidiData,
                            base::Unretained(this), VAR_1, VAR_2),
      VAR_5);

  /* COMMENT_0 */
  VAR_4.message_loop()->PostTask(
      VAR_7, base::Bind(&MidiManagerAlsa::AccumulateMidiBytesSent,
                            base::Unretained(this), VAR_0, VAR_2.size()));
}",chromium/a3d22f60a719a6dae77a0586ef32dd12ac463952/midi_manager_alsa.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,6 +20,6 @@
 
   // Acknowledge send.
   send_thread_.message_loop()->PostTask(
-      FROM_HERE, base::Bind(&MidiManagerClient::AccumulateMidiBytesSent,
-                            base::Unretained(client), data.size()));
+      FROM_HERE, base::Bind(&MidiManagerAlsa::AccumulateMidiBytesSent,
+                            base::Unretained(this), client, data.size()));
 }","{'deleted_lines': ['      FROM_HERE, base::Bind(&MidiManagerClient::AccumulateMidiBytesSent,', '                            base::Unretained(client), data.size()));'], 'added_lines': ['      FROM_HERE, base::Bind(&MidiManagerAlsa::AccumulateMidiBytesSent,', '                            base::Unretained(this), client, data.size()));']}",True,"The MIDI subsystem in Google Chrome before 47.0.2526.106 does not properly handle the sending of data, which allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via unspecified vectors, related to midi_manager.cc, midi_manager_alsa.cc, and midi_manager_mac.cc, a different vulnerability than CVE-2015-8664.",9.8,CRITICAL,3,valid,,5
CVE-2016-0807,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,android,"Fix incorrect check of descsz value.

Bug: 25187394

(cherry picked from commit 1fa55234d6773e09e3bb934419b5b6cc0df981c9)

Change-Id: Idbc9071e8b2b25a062c4e94118808d6e19d443d9
",d917514bd6b270df431ea4e781a865764d406120,https://android.googlesource.com/platform%2Fsystem%2Fcore/+/d917514bd6b270df431ea4e781a865764d406120,debuggerd/elf_utils.cpp,get_build_id,"static bool get_build_id(
Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
HdrType hdr;
memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);
if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
return false;
}
for (size_t i = 0; i < hdr.e_phnum; i++) {
PhdrType phdr;
if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
return false;
}
if (phdr.p_type == PT_NOTE) {
size_t hdr_size = phdr.p_filesz;
uintptr_t addr = base_addr + phdr.p_offset;
while (hdr_size >= sizeof(NhdrType)) {
NhdrType nhdr;
if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
return false;
}
addr += sizeof(nhdr);
if (nhdr.n_type == NT_GNU_BUILD_ID) {
addr += NOTE_ALIGN(nhdr.n_namesz);
uint8_t build_id_data[128];
if (nhdr.n_namesz > sizeof(build_id_data)) {
ALOGE(""Possible corrupted note, name size value is too large: %u"",
nhdr.n_namesz);
return false;
}
if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
return false;
}
build_id->clear();
for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
*build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
}
return true;
} else {
hdr_size -= sizeof(nhdr);
size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
addr += skip_bytes;
if (hdr_size < skip_bytes) {
break;
}
hdr_size -= skip_bytes;
}
}
}
}
return false;
}","static bool get_build_id(
Backtrace* VAR_0, uintptr_t VAR_1, uint8_t* VAR_2, std::string* VAR_3) {
HdrType VAR_4;
memcpy(&VAR_4.e_ident[0], VAR_2, VAR_5);
if (VAR_0->Read(VAR_1 + VAR_5, VAR_6<uint8_t*>(&VAR_4) + VAR_5,
sizeof(HdrType) - VAR_5) != sizeof(HdrType) - VAR_5) {
return false;
}
for (size_t VAR_7 = 0; VAR_7 < VAR_4.e_phnum; VAR_7++) {
PhdrType VAR_8;
if (VAR_0->Read(VAR_1 + VAR_4.e_phoff + VAR_7 * VAR_4.e_phentsize,
VAR_6<uint8_t*>(&VAR_8), sizeof(VAR_8)) != sizeof(VAR_8)) {
return false;
}
if (VAR_8.p_type == VAR_9) {
size_t VAR_10 = VAR_8.p_filesz;
uintptr_t VAR_11 = VAR_1 + VAR_8.p_offset;
while (VAR_10 >= sizeof(VAR_12)) {
NhdrType VAR_13;
if (VAR_0->Read(VAR_11, VAR_6<uint8_t*>(&VAR_13), sizeof(VAR_13)) != sizeof(VAR_13)) {
return false;
}
VAR_11 += sizeof(VAR_13);
if (VAR_13.n_type == VAR_14) {
VAR_11 += NOTE_ALIGN(VAR_13.n_namesz);
uint8_t VAR_15[128];
if (VAR_13.n_namesz > sizeof(VAR_15)) {
ALOGE(""Possible corrupted note, name size value is too large: %u"",
VAR_13.n_namesz);
return false;
}
if (VAR_0->Read(VAR_11, VAR_15, VAR_13.n_descsz) != VAR_13.n_descsz) {
return false;
}
VAR_3->clear();
for (size_t VAR_16 = 0; VAR_16 < VAR_13.n_descsz; VAR_16++) {
*VAR_3 += android::base::StringPrintf(""%02x"", VAR_15[VAR_16]);
}
return true;
} else {
VAR_10 -= sizeof(VAR_13);
size_t VAR_17 = NOTE_ALIGN(VAR_13.n_namesz) + NOTE_ALIGN(VAR_13.n_descsz);
VAR_11 += VAR_17;
if (VAR_10 < VAR_17) {
break;
}
VAR_10 -= VAR_17;
}
}
}
}
return false;
}",android/d917514bd6b270df431ea4e781a865764d406120/elf_utils.cpp/vul/before/0.json,"static bool get_build_id(
    Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
  HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

  // First read the rest of the header.
  if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
                      sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
    return false;
  }

  for (size_t i = 0; i < hdr.e_phnum; i++) {
    PhdrType phdr;
    if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
                        reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
      return false;
    }
    // Looking for the .note.gnu.build-id note.
    if (phdr.p_type == PT_NOTE) {
      size_t hdr_size = phdr.p_filesz;
      uintptr_t addr = base_addr + phdr.p_offset;
      while (hdr_size >= sizeof(NhdrType)) {
        NhdrType nhdr;
        if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
          return false;
        }
        addr += sizeof(nhdr);
        if (nhdr.n_type == NT_GNU_BUILD_ID) {
          // Skip the name (which is the owner and should be ""GNU"").
          addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
            return false;
          }
          if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
            return false;
          }

          build_id->clear();
          for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
            *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
          }

          return true;
        } else {
          // Move past the extra note data.
          hdr_size -= sizeof(nhdr);
          size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
          if (hdr_size < skip_bytes) {
            break;
          }
          hdr_size -= skip_bytes;
        }
      }
    }
  }
  return false;
}","static bool get_build_id(
    Backtrace* VAR_0, uintptr_t VAR_1, uint8_t* VAR_2, std::string* VAR_3) {
  HdrType VAR_4;

  memcpy(&VAR_4.e_ident[0], VAR_2, VAR_5);

  /* COMMENT_0 */
  if (VAR_0->Read(VAR_1 + VAR_5, VAR_6<uint8_t*>(&VAR_4) + VAR_5,
                      sizeof(HdrType) - VAR_5) != sizeof(HdrType) - VAR_5) {
    return false;
  }

  for (size_t VAR_7 = 0; VAR_7 < VAR_4.e_phnum; VAR_7++) {
    PhdrType VAR_8;
    if (VAR_0->Read(VAR_1 + VAR_4.e_phoff + VAR_7 * VAR_4.e_phentsize,
                        VAR_6<uint8_t*>(&VAR_8), sizeof(VAR_8)) != sizeof(VAR_8)) {
      return false;
    }
    /* COMMENT_1 */
    if (VAR_8.p_type == VAR_9) {
      size_t VAR_10 = VAR_8.p_filesz;
      uintptr_t VAR_11 = VAR_1 + VAR_8.p_offset;
      while (VAR_10 >= sizeof(VAR_12)) {
        NhdrType VAR_13;
        if (VAR_0->Read(VAR_11, VAR_6<uint8_t*>(&VAR_13), sizeof(VAR_13)) != sizeof(VAR_13)) {
          return false;
        }
        VAR_11 += sizeof(VAR_13);
        if (VAR_13.n_type == VAR_14) {
          /* COMMENT_2 */
          VAR_11 += NOTE_ALIGN(VAR_13.n_namesz);
          uint8_t VAR_15[160];
          if (VAR_13.n_descsz > sizeof(VAR_15)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  VAR_13.n_descsz);
            return false;
          }
          if (VAR_0->Read(VAR_11, VAR_15, VAR_13.n_descsz) != VAR_13.n_descsz) {
            return false;
          }

          VAR_3->clear();
          for (size_t VAR_16 = 0; VAR_16 < VAR_13.n_descsz; VAR_16++) {
            *VAR_3 += android::base::StringPrintf(""%02x"", VAR_15[VAR_16]);
          }

          return true;
        } else {
          /* COMMENT_3 */
          VAR_10 -= sizeof(VAR_13);
          size_t VAR_17 = NOTE_ALIGN(VAR_13.n_namesz) + NOTE_ALIGN(VAR_13.n_descsz);
          VAR_11 += VAR_17;
          if (VAR_10 < VAR_17) {
            break;
          }
          VAR_10 -= VAR_17;
        }
      }
    }
  }
  return false;
}",android/d917514bd6b270df431ea4e781a865764d406120/elf_utils.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,10 +29,10 @@
         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
-          uint8_t build_id_data[128];
-          if (nhdr.n_namesz > sizeof(build_id_data)) {
-            ALOGE(""Possible corrupted note, name size value is too large: %u"",
-                  nhdr.n_namesz);
+          uint8_t build_id_data[160];
+          if (nhdr.n_descsz > sizeof(build_id_data)) {
+            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
+                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {","{'deleted_lines': ['          uint8_t build_id_data[128];', '          if (nhdr.n_namesz > sizeof(build_id_data)) {', '            ALOGE(""Possible corrupted note, name size value is too large: %u"",', '                  nhdr.n_namesz);'], 'added_lines': ['          uint8_t build_id_data[160];', '          if (nhdr.n_descsz > sizeof(build_id_data)) {', '            ALOGE(""Possible corrupted note, desc size value is too large: %u"",', '                  nhdr.n_descsz);']}",True,"The get_build_id function in elf_utils.cpp in Debuggerd in Android 6.x before 2016-02-01 allows attackers to gain privileges via a crafted application that mishandles a Desc Size element in an ELF Note, aka internal bug 25187394.",8.4,HIGH,2,valid,,5
CVE-2017-5937,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,virglrenderer,"In vrend clear dispatch function, the 'buffers' is read from
guest. A malicious guest can specify a bad 'buffers' to make
a the function call util_format_is_pure_uint() even the
'ctx->sub->surf[i]' is NULL. This can cause a NULL pointer deref.
Make a sanity check to avoid this.

[airlied: use a define]

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
",48f67f60967f963b698ec8df57ec6912a43d6282,https://cgit.freedesktop.org/virglrenderer/commit/?id=48f67f60967f963b698ec8df57ec6912a43d6282,src/vrend_renderer.c,vrend_set_framebuffer_state,"void vrend_set_framebuffer_state(struct vrend_context *ctx,
uint32_t nr_cbufs, uint32_t surf_handle[8],
uint32_t zsurf_handle)
{
struct vrend_surface *surf, *zsurf;
int i;
int old_num;
GLenum status;
GLint new_height = -1;
bool new_ibf = false;
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);
if (zsurf_handle) {
zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
if (!zsurf) {
report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
return;
}
} else
zsurf = NULL;
if (ctx->sub->zsurf != zsurf) {
vrend_surface_reference(&ctx->sub->zsurf, zsurf);
vrend_hw_set_zsurf_texture(ctx);
}
old_num = ctx->sub->nr_cbufs;
ctx->sub->nr_cbufs = nr_cbufs;
ctx->sub->old_nr_cbufs = old_num;
for (i = 0; i < nr_cbufs; i++) {
if (surf_handle[i] != 0) {
surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
if (!surf) {
report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
return;
}
} else
surf = NULL;
if (ctx->sub->surf[i] != surf) {
vrend_surface_reference(&ctx->sub->surf[i], surf);
vrend_hw_set_color_surface(ctx, i);
}
}
if (old_num > ctx->sub->nr_cbufs) {
for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
vrend_surface_reference(&ctx->sub->surf[i], NULL);
vrend_hw_set_color_surface(ctx, i);
}
}
if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
new_height = 0;
new_ibf = false;
} else if (ctx->sub->nr_cbufs == 0) {
new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
}
else {
surf = NULL;
for (i = 0; i < ctx->sub->nr_cbufs; i++) {
if (ctx->sub->surf[i]) {
surf = ctx->sub->surf[i];
break;
}
}
if (surf == NULL) {
report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
return;
}
new_height = u_minify(surf->texture->base.height0, surf->val0);
new_ibf = surf->texture->y_0_top ? true : false;
}
if (new_height != -1) {
if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
ctx->sub->fb_height = new_height;
ctx->sub->inverted_fbo_content = new_ibf;
ctx->sub->scissor_state_dirty = (1 << 0);
ctx->sub->viewport_state_dirty = (1 << 0);
}
}
vrend_hw_emit_framebuffer_state(ctx);
if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
if (status != GL_FRAMEBUFFER_COMPLETE)
fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
}
ctx->sub->shader_dirty = true;
}","void vrend_set_framebuffer_state(struct vrend_context *VAR_0,
uint32_t VAR_1, uint32_t VAR_2[8],
uint32_t VAR_3)
{
struct vrend_surface *VAR_4, *VAR_5;
int VAR_6;
int VAR_7;
GLenum VAR_8;
GLint VAR_9 = -1;
bool VAR_10 = false;
glBindFramebufferEXT(VAR_11, VAR_0->sub->fb_id);
if (VAR_3) {
VAR_5 = vrend_object_lookup(VAR_0->sub->object_hash, VAR_3, VAR_12);
if (!VAR_5) {
report_context_error(VAR_0, VAR_13, VAR_3);
return;
}
} else
VAR_5 = NULL;
if (VAR_0->sub->zsurf != VAR_5) {
vrend_surface_reference(&VAR_0->sub->zsurf, VAR_5);
vrend_hw_set_zsurf_texture(VAR_0);
}
VAR_7 = VAR_0->sub->nr_cbufs;
VAR_0->sub->nr_cbufs = VAR_1;
VAR_0->sub->old_nr_cbufs = VAR_7;
for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {
if (VAR_2[VAR_6] != 0) {
VAR_4 = vrend_object_lookup(VAR_0->sub->object_hash, VAR_2[VAR_6], VAR_12);
if (!VAR_4) {
report_context_error(VAR_0, VAR_13, VAR_2[VAR_6]);
return;
}
} else
VAR_4 = NULL;
if (VAR_0->sub->surf[VAR_6] != VAR_4) {
vrend_surface_reference(&VAR_0->sub->surf[VAR_6], VAR_4);
vrend_hw_set_color_surface(VAR_0, VAR_6);
}
}
if (VAR_7 > VAR_0->sub->nr_cbufs) {
for (VAR_6 = VAR_0->sub->nr_cbufs; VAR_6 < VAR_7; VAR_6++) {
vrend_surface_reference(&VAR_0->sub->surf[VAR_6], NULL);
vrend_hw_set_color_surface(VAR_0, VAR_6);
}
}
if (VAR_0->sub->nr_cbufs == 0 && !VAR_0->sub->zsurf) {
VAR_9 = 0;
VAR_10 = false;
} else if (VAR_0->sub->nr_cbufs == 0) {
VAR_9 = u_minify(VAR_0->sub->zsurf->texture->base.height0, VAR_0->sub->zsurf->val0);
VAR_10 = VAR_0->sub->zsurf->texture->y_0_top ? true : false;
}
else {
VAR_4 = NULL;
for (VAR_6 = 0; VAR_6 < VAR_0->sub->nr_cbufs; VAR_6++) {
if (VAR_0->sub->surf[VAR_6]) {
VAR_4 = VAR_0->sub->surf[VAR_6];
break;
}
}
if (VAR_4 == NULL) {
report_context_error(VAR_0, VAR_13, VAR_6);
return;
}
VAR_9 = u_minify(VAR_4->texture->base.height0, VAR_4->val0);
VAR_10 = VAR_4->texture->y_0_top ? true : false;
}
if (VAR_9 != -1) {
if (VAR_0->sub->fb_height != VAR_9 || VAR_0->sub->inverted_fbo_content != VAR_10) {
VAR_0->sub->fb_height = VAR_9;
VAR_0->sub->inverted_fbo_content = VAR_10;
VAR_0->sub->scissor_state_dirty = (1 << 0);
VAR_0->sub->viewport_state_dirty = (1 << 0);
}
}
vrend_hw_emit_framebuffer_state(VAR_0);
if (VAR_0->sub->nr_cbufs > 0 || VAR_0->sub->zsurf) {
VAR_8 = glCheckFramebufferStatus(VAR_14);
if (VAR_8 != VAR_15)
fprintf(VAR_16,""failed to complete framebuffer 0x%x %s\n"", VAR_8, VAR_0->debug_name);
}
VAR_0->sub->shader_dirty = true;
}",virglrenderer/48f67f60967f963b698ec8df57ec6912a43d6282/vrend_renderer.c/vul/before/0.json,"void vrend_set_framebuffer_state(struct vrend_context *ctx,
                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                 uint32_t zsurf_handle)
{
   struct vrend_surface *surf, *zsurf;
   int i;
   int old_num;
   GLenum status;
   GLint new_height = -1;
   bool new_ibf = false;

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   if (zsurf_handle) {
      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
      if (!zsurf) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
         return;
      }
   } else
      zsurf = NULL;

   if (ctx->sub->zsurf != zsurf) {
      vrend_surface_reference(&ctx->sub->zsurf, zsurf);
      vrend_hw_set_zsurf_texture(ctx);
   }

   old_num = ctx->sub->nr_cbufs;
   ctx->sub->nr_cbufs = nr_cbufs;
   ctx->sub->old_nr_cbufs = old_num;

   for (i = 0; i < nr_cbufs; i++) {
      if (surf_handle[i] != 0) {
         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
         if (!surf) {
            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
            return;
         }
      } else
         surf = NULL;

      if (ctx->sub->surf[i] != surf) {
         vrend_surface_reference(&ctx->sub->surf[i], surf);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   if (old_num > ctx->sub->nr_cbufs) {
      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
         vrend_surface_reference(&ctx->sub->surf[i], NULL);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   /* find a buffer to set fb_height from */
   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
      new_height = 0;
      new_ibf = false;
   } else if (ctx->sub->nr_cbufs == 0) {
      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
   }
   else {
      surf = NULL;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i]) {
            surf = ctx->sub->surf[i];
            break;
         }
      }
      if (surf == NULL) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
         return;
      }
      new_height = u_minify(surf->texture->base.height0, surf->val0);
      new_ibf = surf->texture->y_0_top ? true : false;
   }

   if (new_height != -1) {
      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
         ctx->sub->fb_height = new_height;
         ctx->sub->inverted_fbo_content = new_ibf;
         ctx->sub->scissor_state_dirty = (1 << 0);
         ctx->sub->viewport_state_dirty = (1 << 0);
      }
   }

   vrend_hw_emit_framebuffer_state(ctx);

   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE)
         fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
   }
   ctx->sub->shader_dirty = true;
}","void vrend_set_framebuffer_state(struct vrend_context *VAR_0,
                                 uint32_t VAR_1, uint32_t VAR_2[VAR_3],
                                 uint32_t VAR_4)
{
   struct vrend_surface *VAR_5, *VAR_6;
   int VAR_7;
   int VAR_8;
   GLenum VAR_9;
   GLint VAR_10 = -1;
   bool VAR_11 = false;

   glBindFramebufferEXT(VAR_12, VAR_0->sub->fb_id);

   if (VAR_4) {
      VAR_6 = vrend_object_lookup(VAR_0->sub->object_hash, VAR_4, VAR_13);
      if (!VAR_6) {
         report_context_error(VAR_0, VAR_14, VAR_4);
         return;
      }
   } else
      VAR_6 = NULL;

   if (VAR_0->sub->zsurf != VAR_6) {
      vrend_surface_reference(&VAR_0->sub->zsurf, VAR_6);
      vrend_hw_set_zsurf_texture(VAR_0);
   }

   VAR_8 = VAR_0->sub->nr_cbufs;
   VAR_0->sub->nr_cbufs = VAR_1;
   VAR_0->sub->old_nr_cbufs = VAR_8;

   for (VAR_7 = 0; VAR_7 < VAR_1; VAR_7++) {
      if (VAR_2[VAR_7] != 0) {
         VAR_5 = vrend_object_lookup(VAR_0->sub->object_hash, VAR_2[VAR_7], VAR_13);
         if (!VAR_5) {
            report_context_error(VAR_0, VAR_14, VAR_2[VAR_7]);
            return;
         }
      } else
         VAR_5 = NULL;

      if (VAR_0->sub->surf[VAR_7] != VAR_5) {
         vrend_surface_reference(&VAR_0->sub->surf[VAR_7], VAR_5);
         vrend_hw_set_color_surface(VAR_0, VAR_7);
      }
   }

   if (VAR_8 > VAR_0->sub->nr_cbufs) {
      for (VAR_7 = VAR_0->sub->nr_cbufs; VAR_7 < VAR_8; VAR_7++) {
         vrend_surface_reference(&VAR_0->sub->surf[VAR_7], NULL);
         vrend_hw_set_color_surface(VAR_0, VAR_7);
      }
   }

   /* COMMENT_0 */
   if (VAR_0->sub->nr_cbufs == 0 && !VAR_0->sub->zsurf) {
      VAR_10 = 0;
      VAR_11 = false;
   } else if (VAR_0->sub->nr_cbufs == 0) {
      VAR_10 = u_minify(VAR_0->sub->zsurf->texture->base.height0, VAR_0->sub->zsurf->val0);
      VAR_11 = VAR_0->sub->zsurf->texture->y_0_top ? true : false;
   }
   else {
      VAR_5 = NULL;
      for (VAR_7 = 0; VAR_7 < VAR_0->sub->nr_cbufs; VAR_7++) {
         if (VAR_0->sub->surf[VAR_7]) {
            VAR_5 = VAR_0->sub->surf[VAR_7];
            break;
         }
      }
      if (VAR_5 == NULL) {
         report_context_error(VAR_0, VAR_14, VAR_7);
         return;
      }
      VAR_10 = u_minify(VAR_5->texture->base.height0, VAR_5->val0);
      VAR_11 = VAR_5->texture->y_0_top ? true : false;
   }

   if (VAR_10 != -1) {
      if (VAR_0->sub->fb_height != VAR_10 || VAR_0->sub->inverted_fbo_content != VAR_11) {
         VAR_0->sub->fb_height = VAR_10;
         VAR_0->sub->inverted_fbo_content = VAR_11;
         VAR_0->sub->scissor_state_dirty = (1 << 0);
         VAR_0->sub->viewport_state_dirty = (1 << 0);
      }
   }

   vrend_hw_emit_framebuffer_state(VAR_0);

   if (VAR_0->sub->nr_cbufs > 0 || VAR_0->sub->zsurf) {
      VAR_9 = glCheckFramebufferStatus(VAR_15);
      if (VAR_9 != VAR_16)
         fprintf(VAR_17,""failed to complete framebuffer 0x%x %s\n"", VAR_9, VAR_0->debug_name);
   }
   VAR_0->sub->shader_dirty = true;
}",virglrenderer/48f67f60967f963b698ec8df57ec6912a43d6282/vrend_renderer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 void vrend_set_framebuffer_state(struct vrend_context *ctx,
-                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
+                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;","{'deleted_lines': ['                                 uint32_t nr_cbufs, uint32_t surf_handle[8],'], 'added_lines': ['                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],']}",True,The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,6.5,MEDIUM,1,valid,,5
CVE-2017-5937,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,virglrenderer,"In vrend clear dispatch function, the 'buffers' is read from
guest. A malicious guest can specify a bad 'buffers' to make
a the function call util_format_is_pure_uint() even the
'ctx->sub->surf[i]' is NULL. This can cause a NULL pointer deref.
Make a sanity check to avoid this.

[airlied: use a define]

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
",48f67f60967f963b698ec8df57ec6912a43d6282,https://cgit.freedesktop.org/virglrenderer/commit/?id=48f67f60967f963b698ec8df57ec6912a43d6282,src/vrend_renderer.c,vrend_clear,"void vrend_clear(struct vrend_context *ctx,
unsigned buffers,
const union pipe_color_union *color,
double depth, unsigned stencil)
{
GLbitfield bits = 0;
if (ctx->in_error)
return;
if (ctx->ctx_switch_pending)
vrend_finish_context_switch(ctx);
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);
vrend_update_frontface_state(ctx);
if (ctx->sub->stencil_state_dirty)
vrend_update_stencil_state(ctx);
if (ctx->sub->scissor_state_dirty)
vrend_update_scissor_state(ctx);
if (ctx->sub->viewport_state_dirty)
vrend_update_viewport_state(ctx);
vrend_use_program(ctx, 0);
if (buffers & PIPE_CLEAR_COLOR) {
if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
glClearColor(color->f[3], 0.0, 0.0, 0.0);
} else {
glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
}
}
if (buffers & PIPE_CLEAR_DEPTH) {
glDepthMask(GL_TRUE);
glClearDepth(depth);
}
if (buffers & PIPE_CLEAR_STENCIL)
glClearStencil(stencil);
if (buffers & PIPE_CLEAR_COLOR) {
uint32_t mask = 0;
int i;
for (i = 0; i < ctx->sub->nr_cbufs; i++) {
if (ctx->sub->surf[i])
mask |= (1 << i);
}
if (mask != (buffers >> 2)) {
mask = buffers >> 2;
while (mask) {
i = u_bit_scan(&mask);
if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
glClearBufferuiv(GL_COLOR,
i, (GLuint *)color);
else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
glClearBufferiv(GL_COLOR,
i, (GLint *)color);
else
glClearBufferfv(GL_COLOR,
i, (GLfloat *)color);
}
}
else
bits |= GL_COLOR_BUFFER_BIT;
}
if (buffers & PIPE_CLEAR_DEPTH)
bits |= GL_DEPTH_BUFFER_BIT;
if (buffers & PIPE_CLEAR_STENCIL)
bits |= GL_STENCIL_BUFFER_BIT;
if (bits)
glClear(bits);
if (buffers & PIPE_CLEAR_DEPTH)
if (!ctx->sub->dsa_state.depth.writemask)
glDepthMask(GL_FALSE);
}","void vrend_clear(struct vrend_context *VAR_0,
unsigned VAR_1,
const union pipe_color_union *VAR_2,
double VAR_3, unsigned VAR_4)
{
GLbitfield VAR_5 = 0;
if (VAR_0->in_error)
return;
if (VAR_0->ctx_switch_pending)
vrend_finish_context_switch(VAR_0);
glBindFramebufferEXT(VAR_6, VAR_0->sub->fb_id);
vrend_update_frontface_state(VAR_0);
if (VAR_0->sub->stencil_state_dirty)
vrend_update_stencil_state(VAR_0);
if (VAR_0->sub->scissor_state_dirty)
vrend_update_scissor_state(VAR_0);
if (VAR_0->sub->viewport_state_dirty)
vrend_update_viewport_state(VAR_0);
vrend_use_program(VAR_0, 0);
if (VAR_1 & VAR_7) {
if (VAR_0->sub->nr_cbufs && VAR_0->sub->surf[0] && vrend_format_is_emulated_alpha(VAR_0->sub->surf[0]->format)) {
glClearColor(VAR_2->f[3], 0.0, 0.0, 0.0);
} else {
glClearColor(VAR_2->f[0], VAR_2->f[1], VAR_2->f[2], VAR_2->f[3]);
}
}
if (VAR_1 & VAR_8) {
glDepthMask(VAR_9);
glClearDepth(VAR_3);
}
if (VAR_1 & VAR_10)
glClearStencil(VAR_4);
if (VAR_1 & VAR_7) {
uint32_t VAR_11 = 0;
int VAR_12;
for (VAR_12 = 0; VAR_12 < VAR_0->sub->nr_cbufs; VAR_12++) {
if (VAR_0->sub->surf[VAR_12])
VAR_11 |= (1 << VAR_12);
}
if (VAR_11 != (VAR_1 >> 2)) {
VAR_11 = VAR_1 >> 2;
while (VAR_11) {
VAR_12 = u_bit_scan(&VAR_11);
if (util_format_is_pure_uint(VAR_0->sub->surf[VAR_12]->format))
glClearBufferuiv(VAR_13,
VAR_12, (GLuint *)VAR_2);
else if (util_format_is_pure_sint(VAR_0->sub->surf[VAR_12]->format))
glClearBufferiv(VAR_13,
VAR_12, (GLint *)VAR_2);
else
glClearBufferfv(VAR_13,
VAR_12, (GLfloat *)VAR_2);
}
}
else
VAR_5 |= VAR_14;
}
if (VAR_1 & VAR_8)
VAR_5 |= VAR_15;
if (VAR_1 & VAR_10)
VAR_5 |= VAR_16;
if (VAR_5)
glClear(VAR_5);
if (VAR_1 & VAR_8)
if (!VAR_0->sub->dsa_state.depth.writemask)
glDepthMask(VAR_17);
}",virglrenderer/48f67f60967f963b698ec8df57ec6912a43d6282/vrend_renderer.c/vul/before/1.json,"void vrend_clear(struct vrend_context *ctx,
                 unsigned buffers,
                 const union pipe_color_union *color,
                 double depth, unsigned stencil)
{
   GLbitfield bits = 0;

   if (ctx->in_error)
      return;

   if (ctx->ctx_switch_pending)
      vrend_finish_context_switch(ctx);

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   vrend_update_frontface_state(ctx);
   if (ctx->sub->stencil_state_dirty)
      vrend_update_stencil_state(ctx);
   if (ctx->sub->scissor_state_dirty)
      vrend_update_scissor_state(ctx);
   if (ctx->sub->viewport_state_dirty)
      vrend_update_viewport_state(ctx);

   vrend_use_program(ctx, 0);

   if (buffers & PIPE_CLEAR_COLOR) {
      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
         glClearColor(color->f[3], 0.0, 0.0, 0.0);
      } else {
         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
      }
   }

   if (buffers & PIPE_CLEAR_DEPTH) {
      /* gallium clears don't respect depth mask */
      glDepthMask(GL_TRUE);
      glClearDepth(depth);
   }

   if (buffers & PIPE_CLEAR_STENCIL)
      glClearStencil(stencil);

   if (buffers & PIPE_CLEAR_COLOR) {
      uint32_t mask = 0;
      int i;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i])
            mask |= (1 << i);
      }
      if (mask != (buffers >> 2)) {
         mask = buffers >> 2;
         while (mask) {
            i = u_bit_scan(&mask);
            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
               glClearBufferuiv(GL_COLOR,
                                i, (GLuint *)color);
            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
               glClearBufferiv(GL_COLOR,
                                i, (GLint *)color);
            else
               glClearBufferfv(GL_COLOR,
                                i, (GLfloat *)color);
         }
      }
      else
         bits |= GL_COLOR_BUFFER_BIT;
   }
   if (buffers & PIPE_CLEAR_DEPTH)
      bits |= GL_DEPTH_BUFFER_BIT;
   if (buffers & PIPE_CLEAR_STENCIL)
      bits |= GL_STENCIL_BUFFER_BIT;

   if (bits)
      glClear(bits);

   if (buffers & PIPE_CLEAR_DEPTH)
      if (!ctx->sub->dsa_state.depth.writemask)
         glDepthMask(GL_FALSE);
}","void vrend_clear(struct vrend_context *VAR_0,
                 unsigned VAR_1,
                 const union pipe_color_union *VAR_2,
                 double VAR_3, unsigned VAR_4)
{
   GLbitfield VAR_5 = 0;

   if (VAR_0->in_error)
      return;

   if (VAR_0->ctx_switch_pending)
      vrend_finish_context_switch(VAR_0);

   glBindFramebufferEXT(VAR_6, VAR_0->sub->fb_id);

   vrend_update_frontface_state(VAR_0);
   if (VAR_0->sub->stencil_state_dirty)
      vrend_update_stencil_state(VAR_0);
   if (VAR_0->sub->scissor_state_dirty)
      vrend_update_scissor_state(VAR_0);
   if (VAR_0->sub->viewport_state_dirty)
      vrend_update_viewport_state(VAR_0);

   vrend_use_program(VAR_0, 0);

   if (VAR_1 & VAR_7) {
      if (VAR_0->sub->nr_cbufs && VAR_0->sub->surf[0] && vrend_format_is_emulated_alpha(VAR_0->sub->surf[0]->format)) {
         glClearColor(VAR_2->f[3], 0.0, 0.0, 0.0);
      } else {
         glClearColor(VAR_2->f[0], VAR_2->f[1], VAR_2->f[2], VAR_2->f[3]);
      }
   }

   if (VAR_1 & VAR_8) {
      /* COMMENT_0 */
      glDepthMask(VAR_9);
      glClearDepth(VAR_3);
   }

   if (VAR_1 & VAR_10)
      glClearStencil(VAR_4);

   if (VAR_1 & VAR_7) {
      uint32_t VAR_11 = 0;
      int VAR_12;
      for (VAR_12 = 0; VAR_12 < VAR_0->sub->nr_cbufs; VAR_12++) {
         if (VAR_0->sub->surf[VAR_12])
            VAR_11 |= (1 << VAR_12);
      }
      if (VAR_11 != (VAR_1 >> 2)) {
         VAR_11 = VAR_1 >> 2;
         while (VAR_11) {
            VAR_12 = u_bit_scan(&VAR_11);
            if (VAR_12 < VAR_13 && VAR_0->sub->surf[VAR_12] && util_format_is_pure_uint(VAR_0->sub->surf[VAR_12] && VAR_0->sub->surf[VAR_12]->format))
               glClearBufferuiv(VAR_14,
                                VAR_12, (GLuint *)VAR_2);
            else if (VAR_12 < VAR_13 && VAR_0->sub->surf[VAR_12] && util_format_is_pure_sint(VAR_0->sub->surf[VAR_12] && VAR_0->sub->surf[VAR_12]->format))
               glClearBufferiv(VAR_14,
                                VAR_12, (GLint *)VAR_2);
            else
               glClearBufferfv(VAR_14,
                                VAR_12, (GLfloat *)VAR_2);
         }
      }
      else
         VAR_5 |= VAR_15;
   }
   if (VAR_1 & VAR_8)
      VAR_5 |= VAR_16;
   if (VAR_1 & VAR_10)
      VAR_5 |= VAR_17;

   if (VAR_5)
      glClear(VAR_5);

   if (VAR_1 & VAR_8)
      if (!VAR_0->sub->dsa_state.depth.writemask)
         glDepthMask(VAR_18);
}",virglrenderer/48f67f60967f963b698ec8df57ec6912a43d6282/vrend_renderer.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -51,10 +51,10 @@
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
-            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
+            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
-            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
+            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else","{'deleted_lines': ['            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))', '            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))'], 'added_lines': ['            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))', '            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))']}",True,The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,6.5,MEDIUM,1,valid,,5
CVE-2017-0555,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Decoder: Fixed initialization of first_slice_in_pic

To handle some errors, first_slice_in_pic was being set to 2.
This is now cleaned up and first_slice_in_pic is set to 1 only once per pic.
This will ensure picture level initializations are done only once even in case
of error clips

Bug: 33717589
Bug: 33551775
Bug: 33716442
Bug: 33677995

Change-Id: If341436b3cbaa724017eedddd88c2e6fac36d8ba
",0b23c81c3dd9ec38f7e6806a3955fed1925541a0,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,decoder/ih264d_parse_slice.c,ih264d_start_of_pic,"WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
WORD32 i4_poc,
pocstruct_t *ps_temp_poc,
UWORD16 u2_frame_num,
dec_pic_params_t *ps_pps)
{
pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
pocstruct_t *ps_cur_poc = ps_temp_poc;
pic_buffer_t *pic_buf;
ivd_video_decode_op_t * ps_dec_output =
(ivd_video_decode_op_t *)ps_dec->pv_dec_out;
dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
dec_seq_params_t *ps_seq = ps_pps->ps_sps;
UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
high_profile_tools_t s_high_profile;
WORD32 ret;
H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
ps_prev_poc->i4_delta_pic_order_cnt_bottom =
ps_cur_poc->i4_delta_pic_order_cnt_bottom;
ps_prev_poc->i4_delta_pic_order_cnt[0] =
ps_cur_poc->i4_delta_pic_order_cnt[0];
ps_prev_poc->i4_delta_pic_order_cnt[1] =
ps_cur_poc->i4_delta_pic_order_cnt[1];
ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
ps_prev_poc->u2_frame_num = u2_frame_num;
ps_dec->i1_prev_mb_qp_delta = 0;
ps_dec->i1_next_ctxt_idx = 0;
ps_dec->u4_nmb_deblk = 0;
if(ps_dec->u4_num_cores == 1)
ps_dec->u4_nmb_deblk = 1;
if(ps_seq->u1_mb_aff_flag == 1)
{
ps_dec->u4_nmb_deblk = 0;
if(ps_dec->u4_num_cores > 2)
ps_dec->u4_num_cores = 2;
}
ps_dec->u4_use_intrapred_line_copy = 0;
if (ps_seq->u1_mb_aff_flag == 0)
{
ps_dec->u4_use_intrapred_line_copy = 1;
}
ps_dec->u4_app_disable_deblk_frm = 0;
if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
{
WORD32 degrade_pic;
ps_dec->i4_degrade_pic_cnt++;
degrade_pic = 0;
switch(ps_dec->i4_degrade_pics)
{
case 4:
{
degrade_pic = 1;
break;
}
case 3:
{
if(ps_cur_slice->u1_slice_type != I_SLICE)
degrade_pic = 1;
break;
}
case 2:
{
if((ps_cur_slice->u1_slice_type != I_SLICE)
&& (ps_dec->i4_degrade_pic_cnt
!= ps_dec->i4_nondegrade_interval))
degrade_pic = 1;
break;
}
case 1:
{
if(0 == ps_cur_slice->u1_nal_ref_idc)
{
degrade_pic = 1;
}
break;
}
}
if(degrade_pic)
{
if(ps_dec->i4_degrade_type & 0x2)
ps_dec->u4_app_disable_deblk_frm = 1;
if(0 == ps_cur_slice->u1_nal_ref_idc)
{
if(ps_dec->i4_degrade_type & 0x4)
ps_dec->i4_mv_frac_mask = 0;
if(ps_dec->i4_degrade_type & 0x8)
ps_dec->i4_mv_frac_mask = 0;
}
}
else
ps_dec->i4_degrade_pic_cnt = 0;
}
{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if(ps_dec->u1_sl_typ_5_9
&& ((ps_cur_slice->u1_slice_type == I_SLICE)
|| (ps_cur_slice->u1_slice_type
== SI_SLICE)))
ps_err->u1_cur_pic_type = PIC_TYPE_I;
else
ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
{
ps_err->u1_cur_pic_type = PIC_TYPE_I;
ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
}
if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
{
if(ps_err->u1_err_flag)
ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
}
}
if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
{
WORD32 j;
for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
{
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_IO);
}
ps_dec->u1_second_field = 0;
ps_dec->i4_cur_display_seq = 0;
ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
}
ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
if(ret != OK)
return ret;
ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
if(ps_dec->u1_separate_parse)
{
UWORD16 pic_wd = ps_dec->u4_width_at_init;
UWORD16 pic_ht = ps_dec->u4_height_at_init;
UWORD32 num_mbs;
if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
{
pic_wd = ps_dec->u2_pic_wd;
pic_ht = ps_dec->u2_pic_ht;
}
num_mbs = (pic_wd * pic_ht) >> 8;
if(ps_dec->pu1_dec_mb_map)
{
memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
}
if(ps_dec->pu1_recon_mb_map)
{
memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
}
if(ps_dec->pu2_slice_num_map)
{
memset((void *)ps_dec->pu2_slice_num_map, 0,
(num_mbs * sizeof(UWORD16)));
}
}
ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
ps_dec->u2_cur_slice_num = 0;
ps_dec->s_high_profile.u1_scaling_present = 0;
ps_dec->s_high_profile.u1_transform8x8_present = 0;
if(1 == ps_dec->u4_share_disp_buf)
{
UWORD32 i;
for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
{
if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
continue;
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
BUF_MGR_IO);
ps_dec->u4_disp_buf_to_be_freed[i] = 0;
ps_dec->u4_disp_buf_mapping[i] = 0;
}
}
if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))     {
pic_buffer_t *ps_cur_pic;
WORD32 cur_pic_buf_id, cur_mv_buf_id;
col_mv_buf_t *ps_col_mv;
while(1)
{
ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
&cur_pic_buf_id);
if(ps_cur_pic == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
return ERROR_UNAVAIL_PICBUF_T;
}
if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
{
break;
}
}
ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
&cur_mv_buf_id);
if(ps_col_mv == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
return ERROR_UNAVAIL_MVBUF_T;
}
ps_dec->ps_cur_pic = ps_cur_pic;
ps_dec->u1_pic_buf_id = cur_pic_buf_id;
ps_cur_pic->u4_ts = ps_dec->u4_ts;
ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
{
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
*(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
*(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;
}
if(!ps_dec->ps_cur_pic)
{
WORD32 j;
H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
{
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_IO);
}
ps_dec->i4_cur_display_seq = 0;
ps_dec->i4_prev_max_display_seq = 0;
ps_dec->i4_max_poc = 0;
ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
&cur_pic_buf_id);
if(ps_cur_pic == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
return ERROR_UNAVAIL_PICBUF_T;
}
ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
&cur_mv_buf_id);
if(ps_col_mv == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
return ERROR_UNAVAIL_MVBUF_T;
}
ps_dec->ps_cur_pic = ps_cur_pic;
ps_dec->u1_pic_buf_id = cur_pic_buf_id;
ps_cur_pic->u4_ts = ps_dec->u4_ts;
ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;
ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
}
ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
H264_DEC_DEBUG_PRINT(""got a buffer\n"");
}
else
{
H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
}
ps_dec->u4_pic_buf_got = 1;
ps_dec->ps_cur_pic->i4_poc = i4_poc;
ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
ps_pps->i4_bottom_field_order_cnt;
ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;
ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
if(u1_field_pic_flag && u1_bottom_field_flag)
{
WORD32 i4_temp_poc;
WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
ps_dec->s_cur_pic.ps_mv +=
((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
* ps_dec->u2_pic_wd) >> 5);
ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
i4_temp_poc = MIN(i4_top_field_order_poc,
i4_bot_field_order_poc);
ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
}
ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
&& (!u1_field_pic_flag);
ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
<< 2);
ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;     ps_dec->ps_cur_mb_row++;     ps_dec->ps_top_mb_row =
ps_dec->ps_nbr_mb_row
+ ((ps_dec->u2_frm_wd_in_mbs + 1)
<< (1
- ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
ps_dec->ps_top_mb_row++; 
ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];
ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];
ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];
ps_dec->u1_yuv_scratch_idx = 0;
ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
ps_dec->u1_mv_top_p = 0;
ps_dec->u1_mb_idx = 0;
ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
ps_dec->pu1_yleft = 0;
ps_dec->pu1_uleft = 0;
ps_dec->pu1_vleft = 0;
ps_dec->u1_not_wait_rec = 2;
ps_dec->u2_total_mbs_coded = 0;
ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
ps_dec->u4_pred_info_idx = 0;
ps_dec->u4_pred_info_pkd_idx = 0;
ps_dec->u4_dma_buf_idx = 0;
ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
ps_dec->ps_part = ps_dec->ps_parse_part_params;
ps_dec->i2_prev_slice_mbx = -1;
ps_dec->i2_prev_slice_mby = 0;
ps_dec->u2_mv_2mb[0] = 0;
ps_dec->u2_mv_2mb[1] = 0;
ps_dec->u1_last_pic_not_decoded = 0;
ps_dec->u2_cur_slice_num_dec_thread = 0;
ps_dec->u2_cur_slice_num_bs = 0;
ps_dec->u4_intra_pred_line_ofst = 0;
ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;
ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;
ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
+ (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);
ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;
ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;
{
if(ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
}
else
{
ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
}
}
{
UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;
UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;
UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
% (ps_dec->u1_recon_mb_grp >> u1_mbaff));
UWORD16 ui16_lastmbs_widthY =
(uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) << 4));
UWORD16 ui16_lastmbs_widthUV =
uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) << 3);
ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
<< u1_field_pic_flag;
ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
<< u1_field_pic_flag;
if(u1_field_pic_flag)
{
ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
}
ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
>> u1_mbaff);
ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
>> u1_mbaff);
ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
+ (PAD_LEN_Y_H << 1)
+ ps_dec->s_tran_addrecon.u2_frm_wd_y
* ((15 << u1_mbaff) + u1_mbaff));
ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
+ (PAD_LEN_UV_H << 2)
+ ps_dec->s_tran_addrecon.u2_frm_wd_uv
* ((15 << u1_mbaff) + u1_mbaff));
ih264d_assign_pic_num(ps_dec);
ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
<< 2) - 1 - (u1_mbaff << 2);
ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) - 1) << (4 + u1_mbaff);
}
if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
{
if((ps_seq->i4_seq_scaling_matrix_present_flag)
|| (ps_pps->i4_pic_scaling_matrix_present_flag))
{
ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
ps_dec->s_high_profile.u1_scaling_present = 1;
}
else
{
ih264d_form_default_scaling_matrix(ps_dec);
}
if(ps_pps->i4_transform_8x8_mode_flag)
{
ps_dec->s_high_profile.u1_transform8x8_present = 1;
}
}
else
{
ih264d_form_default_scaling_matrix(ps_dec);
}
ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
ps_seq->u1_direct_8x8_inference_flag;
ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;
ps_dec->i1_recon_in_thread3_flag = 1;
ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
if(ps_dec->u1_separate_parse)
{
memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
sizeof(tfr_ctxt_t));
if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
{
memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
sizeof(tfr_ctxt_t));
ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
}
}
ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
ps_dec->u2_frm_wd_in_mbs, 0);
ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
ps_dec->u4_cur_deblk_mb_num = 0;
ps_dec->u4_deblk_mb_x = 0;
ps_dec->u4_deblk_mb_y = 0;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
return OK;
}","WORD32 ih264d_start_of_pic(dec_struct_t *VAR_0,
WORD32 VAR_1,
pocstruct_t *VAR_2,
UWORD16 VAR_3,
dec_pic_params_t *VAR_4)
{
pocstruct_t *VAR_5 = &VAR_0->s_cur_pic_poc;
pocstruct_t *VAR_6 = VAR_2;
pic_buffer_t *VAR_7;
ivd_video_decode_op_t * VAR_8 =
(ivd_video_decode_op_t *)VAR_0->pv_dec_out;
dec_slice_params_t *VAR_9 = VAR_0->ps_cur_slice;
dec_seq_params_t *VAR_10 = VAR_4->ps_sps;
UWORD8 VAR_11 = VAR_9->u1_bottom_field_flag;
UWORD8 VAR_12 = VAR_9->u1_field_pic_flag;
high_profile_tools_t VAR_13;
WORD32 VAR_14;
H264_MUTEX_LOCK(&VAR_0->process_disp_mutex);
VAR_5->i4_pic_order_cnt_lsb = VAR_6->i4_pic_order_cnt_lsb;
VAR_5->i4_pic_order_cnt_msb = VAR_6->i4_pic_order_cnt_msb;
VAR_5->i4_delta_pic_order_cnt_bottom =
VAR_6->i4_delta_pic_order_cnt_bottom;
VAR_5->i4_delta_pic_order_cnt[0] =
VAR_6->i4_delta_pic_order_cnt[0];
VAR_5->i4_delta_pic_order_cnt[1] =
VAR_6->i4_delta_pic_order_cnt[1];
VAR_5->u1_bot_field = VAR_0->ps_cur_slice->u1_bottom_field_flag;
VAR_5->i4_prev_frame_num_ofst = VAR_6->i4_prev_frame_num_ofst;
VAR_5->u2_frame_num = VAR_3;
VAR_0->i1_prev_mb_qp_delta = 0;
VAR_0->i1_next_ctxt_idx = 0;
VAR_0->u4_nmb_deblk = 0;
if(VAR_0->u4_num_cores == 1)
VAR_0->u4_nmb_deblk = 1;
if(VAR_10->u1_mb_aff_flag == 1)
{
VAR_0->u4_nmb_deblk = 0;
if(VAR_0->u4_num_cores > 2)
VAR_0->u4_num_cores = 2;
}
VAR_0->u4_use_intrapred_line_copy = 0;
if (VAR_10->u1_mb_aff_flag == 0)
{
VAR_0->u4_use_intrapred_line_copy = 1;
}
VAR_0->u4_app_disable_deblk_frm = 0;
if(VAR_0->i4_degrade_type && VAR_0->i4_degrade_pics)
{
WORD32 VAR_15;
VAR_0->i4_degrade_pic_cnt++;
VAR_15 = 0;
switch(VAR_0->i4_degrade_pics)
{
case 4:
{
VAR_15 = 1;
break;
}
case 3:
{
if(VAR_9->u1_slice_type != VAR_16)
VAR_15 = 1;
break;
}
case 2:
{
if((VAR_9->u1_slice_type != VAR_16)
&& (VAR_0->i4_degrade_pic_cnt
!= VAR_0->i4_nondegrade_interval))
VAR_15 = 1;
break;
}
case 1:
{
if(0 == VAR_9->u1_nal_ref_idc)
{
VAR_15 = 1;
}
break;
}
}
if(VAR_15)
{
if(VAR_0->i4_degrade_type & 0x2)
VAR_0->u4_app_disable_deblk_frm = 1;
if(0 == VAR_9->u1_nal_ref_idc)
{
if(VAR_0->i4_degrade_type & 0x4)
VAR_0->i4_mv_frac_mask = 0;
if(VAR_0->i4_degrade_type & 0x8)
VAR_0->i4_mv_frac_mask = 0;
}
}
else
VAR_0->i4_degrade_pic_cnt = 0;
}
{
dec_err_status_t * VAR_17 = VAR_0->ps_dec_err_status;
if(VAR_0->u1_sl_typ_5_9
&& ((VAR_9->u1_slice_type == VAR_16)
|| (VAR_9->u1_slice_type
== VAR_18)))
VAR_17->u1_cur_pic_type = VAR_19;
else
VAR_17->u1_cur_pic_type = VAR_20;
if(VAR_17->u1_pic_aud_i == VAR_19)
{
VAR_17->u1_cur_pic_type = VAR_19;
VAR_17->u1_pic_aud_i = VAR_20;
}
if(VAR_9->u1_nal_unit_type == VAR_21)
{
if(VAR_17->u1_err_flag)
ih264d_reset_ref_bufs(VAR_0->ps_dpb_mgr);
VAR_17->u1_err_flag = VAR_22;
}
}
if(VAR_0->u1_init_dec_flag && VAR_0->s_prev_seq_params.u1_eoseq_pending)
{
WORD32 VAR_23;
for(VAR_23 = 0; VAR_23 < VAR_24; VAR_23++)
{
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
VAR_23,
VAR_25);
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_23],
VAR_25);
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
VAR_23,
VAR_26);
}
VAR_0->u1_second_field = 0;
VAR_0->i4_cur_display_seq = 0;
VAR_0->s_prev_seq_params.u1_eoseq_pending = 0;
}
VAR_14 = ih264d_init_pic(VAR_0, VAR_3, VAR_1, VAR_4);
if(VAR_14 != VAR_27)
return VAR_14;
VAR_0->pv_parse_tu_coeff_data = VAR_0->pv_pic_tu_coeff_data;
VAR_0->pv_proc_tu_coeff_data  = VAR_0->pv_pic_tu_coeff_data;
VAR_0->ps_nmb_info = VAR_0->ps_frm_mb_info;
if(VAR_0->u1_separate_parse)
{
UWORD16 VAR_28 = VAR_0->u4_width_at_init;
UWORD16 VAR_29 = VAR_0->u4_height_at_init;
UWORD32 VAR_30;
if((NULL != VAR_0->ps_cur_sps) && (1 == (VAR_0->ps_cur_sps->u1_is_valid)))
{
VAR_28 = VAR_0->u2_pic_wd;
VAR_29 = VAR_0->u2_pic_ht;
}
VAR_30 = (VAR_28 * VAR_29) >> 8;
if(VAR_0->pu1_dec_mb_map)
{
memset((void *)VAR_0->pu1_dec_mb_map, 0, VAR_30);
}
if(VAR_0->pu1_recon_mb_map)
{
memset((void *)VAR_0->pu1_recon_mb_map, 0, VAR_30);
}
if(VAR_0->pu2_slice_num_map)
{
memset((void *)VAR_0->pu2_slice_num_map, 0,
(VAR_30 * sizeof(UWORD16)));
}
}
VAR_0->ps_parse_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
VAR_0->ps_decode_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
VAR_0->ps_computebs_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
VAR_0->u2_cur_slice_num = 0;
VAR_0->s_high_profile.u1_scaling_present = 0;
VAR_0->s_high_profile.u1_transform8x8_present = 0;
if(1 == VAR_0->u4_share_disp_buf)
{
UWORD32 VAR_31;
for(VAR_31 = 0; VAR_31 < VAR_24; VAR_31++)
{
if(0 == VAR_0->u4_disp_buf_to_be_freed[VAR_31])
continue;
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr, VAR_31,
VAR_26);
VAR_0->u4_disp_buf_to_be_freed[VAR_31] = 0;
VAR_0->u4_disp_buf_mapping[VAR_31] = 0;
}
}
if(!(VAR_12 && 0 != VAR_0->u1_top_bottom_decoded)) 
{
pic_buffer_t *VAR_32;
WORD32 VAR_33, VAR_34;
col_mv_buf_t *VAR_35;
while(1)
{
VAR_32 = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
&VAR_33);
if(VAR_32 == NULL)
{
VAR_0->i4_error_code = VAR_36;
return VAR_36;
}
if(0 == VAR_0->u4_disp_buf_mapping[VAR_33])
{
break;
}
}
VAR_35 = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
&VAR_34);
if(VAR_35 == NULL)
{
VAR_0->i4_error_code = VAR_37;
return VAR_37;
}
VAR_0->ps_cur_pic = VAR_32;
VAR_0->u1_pic_buf_id = VAR_33;
VAR_32->u4_ts = VAR_0->u4_ts;
VAR_32->u1_mv_buf_id = VAR_34;
VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_33] = VAR_34;
VAR_32->pu1_col_zero_flag = (UWORD8 *)VAR_35->pv_col_zero_flag;
VAR_32->ps_mv = (mv_pred_t *)VAR_35->pv_mv;
VAR_0->au1_pic_buf_ref_flag[VAR_33] = 0;
{
VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_init_dpb[0];
*(VAR_0->ps_dpb_mgr->ps_init_dpb[0][0]) = *VAR_32;
*(VAR_0->ps_dpb_mgr->ps_init_dpb[0][VAR_38]) = *VAR_32;
}
if(!VAR_0->ps_cur_pic)
{
WORD32 VAR_23;
H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
for(VAR_23 = 0; VAR_23 < VAR_24; VAR_23++)
{
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
VAR_23,
VAR_25);
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_23],
VAR_25);
ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
VAR_23,
VAR_26);
}
VAR_0->i4_cur_display_seq = 0;
VAR_0->i4_prev_max_display_seq = 0;
VAR_0->i4_max_poc = 0;
VAR_32 = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
&VAR_33);
if(VAR_32 == NULL)
{
VAR_0->i4_error_code = VAR_36;
return VAR_36;
}
VAR_35 = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
&VAR_34);
if(VAR_35 == NULL)
{
VAR_0->i4_error_code = VAR_37;
return VAR_37;
}
VAR_0->ps_cur_pic = VAR_32;
VAR_0->u1_pic_buf_id = VAR_33;
VAR_32->u4_ts = VAR_0->u4_ts;
VAR_0->apv_buf_id_pic_buf_map[VAR_33] = (void *)VAR_32;
VAR_32->u1_mv_buf_id = VAR_34;
VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_33] = VAR_34;
VAR_32->pu1_col_zero_flag = (UWORD8 *)VAR_35->pv_col_zero_flag;
VAR_32->ps_mv = (mv_pred_t *)VAR_35->pv_mv;
VAR_0->au1_pic_buf_ref_flag[VAR_33] = 0;
}
VAR_0->ps_cur_pic->u1_picturetype = VAR_12;
VAR_0->ps_cur_pic->u4_pack_slc_typ = VAR_39;
H264_DEC_DEBUG_PRINT(""got a buffer\n"");
}
else
{
H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
}
VAR_0->u4_pic_buf_got = 1;
VAR_0->ps_cur_pic->i4_poc = VAR_1;
VAR_0->ps_cur_pic->i4_frame_num = VAR_3;
VAR_0->ps_cur_pic->i4_pic_num = VAR_3;
VAR_0->ps_cur_pic->i4_top_field_order_cnt = VAR_4->i4_top_field_order_cnt;
VAR_0->ps_cur_pic->i4_bottom_field_order_cnt =
VAR_4->i4_bottom_field_order_cnt;
VAR_0->ps_cur_pic->i4_avg_poc = VAR_4->i4_avg_poc;
VAR_0->ps_cur_pic->u4_time_stamp = VAR_0->u4_pts;
VAR_0->s_cur_pic = *(VAR_0->ps_cur_pic);
if(VAR_12 && VAR_11)
{
WORD32 VAR_40;
WORD32 VAR_41, VAR_42;
VAR_0->s_cur_pic.pu1_buf1 += VAR_0->s_cur_pic.u2_frm_wd_y;
VAR_0->s_cur_pic.pu1_buf2 += VAR_0->s_cur_pic.u2_frm_wd_uv;
VAR_0->s_cur_pic.pu1_buf3 += VAR_0->s_cur_pic.u2_frm_wd_uv;
VAR_0->s_cur_pic.ps_mv +=
((VAR_0->u2_pic_ht * VAR_0->u2_pic_wd) >> 5);
VAR_0->s_cur_pic.pu1_col_zero_flag += ((VAR_0->u2_pic_ht
* VAR_0->u2_pic_wd) >> 5);
VAR_0->ps_cur_pic->u1_picturetype |= VAR_43;
VAR_41 = VAR_0->ps_cur_pic->i4_top_field_order_cnt;
VAR_42 = VAR_0->ps_cur_pic->i4_bottom_field_order_cnt;
VAR_40 = MIN(VAR_41,
VAR_42);
VAR_0->ps_cur_pic->i4_avg_poc = VAR_40;
}
VAR_9->u1_mbaff_frame_flag = VAR_10->u1_mb_aff_flag
&& (!VAR_12);
VAR_0->ps_cur_pic->u1_picturetype |= (VAR_9->u1_mbaff_frame_flag
<< 2);
VAR_0->ps_cur_mb_row = VAR_0->ps_nbr_mb_row; 
VAR_0->ps_cur_mb_row++; 
VAR_0->ps_top_mb_row =
VAR_0->ps_nbr_mb_row
+ ((VAR_0->u2_frm_wd_in_mbs + 1)
<< (1
- VAR_0->ps_cur_sps->u1_frame_mbs_only_flag));
VAR_0->ps_top_mb_row++; 
VAR_0->pu1_y = VAR_0->pu1_y_scratch[0];
VAR_0->pu1_u = VAR_0->pu1_u_scratch[0];
VAR_0->pu1_v = VAR_0->pu1_v_scratch[0];
VAR_0->u1_yuv_scratch_idx = 0;
VAR_0->ps_mv_cur = VAR_0->s_cur_pic.ps_mv;
VAR_0->ps_mv_top = VAR_0->ps_mv_top_p[0];
VAR_0->u1_mv_top_p = 0;
VAR_0->u1_mb_idx = 0;
VAR_0->ps_mv_left = VAR_0->s_cur_pic.ps_mv;
VAR_0->pu1_yleft = 0;
VAR_0->pu1_uleft = 0;
VAR_0->pu1_vleft = 0;
VAR_0->u1_not_wait_rec = 2;
VAR_0->u2_total_mbs_coded = 0;
VAR_0->i4_submb_ofst = -(VAR_44);
VAR_0->u4_pred_info_idx = 0;
VAR_0->u4_pred_info_pkd_idx = 0;
VAR_0->u4_dma_buf_idx = 0;
VAR_0->ps_mv = VAR_0->s_cur_pic.ps_mv;
VAR_0->ps_mv_bank_cur = VAR_0->s_cur_pic.ps_mv;
VAR_0->pu1_col_zero_flag = VAR_0->s_cur_pic.pu1_col_zero_flag;
VAR_0->ps_part = VAR_0->ps_parse_part_params;
VAR_0->i2_prev_slice_mbx = -1;
VAR_0->i2_prev_slice_mby = 0;
VAR_0->u2_mv_2mb[0] = 0;
VAR_0->u2_mv_2mb[1] = 0;
VAR_0->u1_last_pic_not_decoded = 0;
VAR_0->u2_cur_slice_num_dec_thread = 0;
VAR_0->u2_cur_slice_num_bs = 0;
VAR_0->u4_intra_pred_line_ofst = 0;
VAR_0->pu1_cur_y_intra_pred_line = VAR_0->pu1_y_intra_pred_line;
VAR_0->pu1_cur_u_intra_pred_line = VAR_0->pu1_u_intra_pred_line;
VAR_0->pu1_cur_v_intra_pred_line = VAR_0->pu1_v_intra_pred_line;
VAR_0->pu1_cur_y_intra_pred_line_base = VAR_0->pu1_y_intra_pred_line;
VAR_0->pu1_cur_u_intra_pred_line_base = VAR_0->pu1_u_intra_pred_line;
VAR_0->pu1_cur_v_intra_pred_line_base = VAR_0->pu1_v_intra_pred_line;
VAR_0->pu1_prev_y_intra_pred_line = VAR_0->pu1_y_intra_pred_line
+ (VAR_0->u2_frm_wd_in_mbs * VAR_45);
VAR_0->pu1_prev_u_intra_pred_line = VAR_0->pu1_u_intra_pred_line
+ VAR_0->u2_frm_wd_in_mbs * VAR_46 * VAR_47;
VAR_0->pu1_prev_v_intra_pred_line = VAR_0->pu1_v_intra_pred_line
+ VAR_0->u2_frm_wd_in_mbs * VAR_46;
VAR_0->ps_deblk_mbn = VAR_0->ps_deblk_pic;
VAR_0->ps_deblk_mbn_curr = VAR_0->ps_deblk_mbn;
VAR_0->ps_deblk_mbn_prev = VAR_0->ps_deblk_mbn + VAR_0->u1_recon_mb_grp;
{
if(VAR_9->u1_mbaff_frame_flag)
{
VAR_0->pf_compute_bs = VAR_48;
VAR_0->pf_mvpred = VAR_49;
}
else
{
VAR_0->pf_compute_bs = VAR_50;
VAR_0->u1_cur_mb_fld_dec_flag = VAR_9->u1_field_pic_flag;
}
}
{
UWORD8 VAR_12 = VAR_0->ps_cur_slice->u1_field_pic_flag;
UWORD8 VAR_51 = VAR_9->u1_mbaff_frame_flag;
UWORD8 VAR_52 = (((VAR_0->u2_pic_wd) >> 4)
% (VAR_0->u1_recon_mb_grp >> VAR_51));
UWORD16 VAR_53 =
(VAR_52 ? (VAR_52 << 4) : ((VAR_0->u1_recon_mb_grp
>> VAR_51) << 4));
UWORD16 VAR_54 =
VAR_52 ? (VAR_52 << 3) : ((VAR_0->u1_recon_mb_grp
>> VAR_51) << 3);
VAR_0->s_tran_addrecon.pu1_dest_y = VAR_0->s_cur_pic.pu1_buf1;
VAR_0->s_tran_addrecon.pu1_dest_u = VAR_0->s_cur_pic.pu1_buf2;
VAR_0->s_tran_addrecon.pu1_dest_v = VAR_0->s_cur_pic.pu1_buf3;
VAR_0->s_tran_addrecon.u2_frm_wd_y = VAR_0->u2_frm_wd_y
<< VAR_12;
VAR_0->s_tran_addrecon.u2_frm_wd_uv = VAR_0->u2_frm_wd_uv
<< VAR_12;
if(VAR_12)
{
VAR_53 += VAR_0->u2_frm_wd_y;
VAR_54 += VAR_0->u2_frm_wd_uv;
}
VAR_0->s_tran_addrecon.u4_inc_y[0] = ((VAR_0->u1_recon_mb_grp << 4)
>> VAR_51);
VAR_0->s_tran_addrecon.u4_inc_uv[0] = ((VAR_0->u1_recon_mb_grp << 4)
>> VAR_51);
VAR_0->s_tran_addrecon.u4_inc_y[1] = (VAR_53
+ (VAR_55 << 1)
+ VAR_0->s_tran_addrecon.u2_frm_wd_y
* ((15 << VAR_51) + VAR_51));
VAR_0->s_tran_addrecon.u4_inc_uv[1] = (VAR_54
+ (VAR_56 << 2)
+ VAR_0->s_tran_addrecon.u2_frm_wd_uv
* ((15 << VAR_51) + VAR_51));
ih264d_assign_pic_num(VAR_0);
VAR_0->s_tran_addrecon.u2_mv_top_left_inc = (VAR_0->u1_recon_mb_grp
<< 2) - 1 - (VAR_51 << 2);
VAR_0->s_tran_addrecon.u2_mv_left_inc = ((VAR_0->u1_recon_mb_grp
>> VAR_51) - 1) << (4 + VAR_51);
}
if(VAR_10->u1_profile_idc == VAR_57)
{
if((VAR_10->i4_seq_scaling_matrix_present_flag)
|| (VAR_4->i4_pic_scaling_matrix_present_flag))
{
ih264d_form_scaling_matrix_picture(VAR_10, VAR_4, VAR_0);
VAR_0->s_high_profile.u1_scaling_present = 1;
}
else
{
ih264d_form_default_scaling_matrix(VAR_0);
}
if(VAR_4->i4_transform_8x8_mode_flag)
{
VAR_0->s_high_profile.u1_transform8x8_present = 1;
}
}
else
{
ih264d_form_default_scaling_matrix(VAR_0);
}
VAR_0->s_high_profile.u1_direct_8x8_inference_flag =
VAR_10->u1_direct_8x8_inference_flag;
VAR_0->s_high_profile.s_cavlc_ctxt = VAR_0->s_cavlc_ctxt;
VAR_0->i1_recon_in_thread3_flag = 1;
VAR_0->ps_frame_buf_ip_recon = &VAR_0->s_tran_addrecon;
if(VAR_0->u1_separate_parse)
{
memcpy(&VAR_0->s_tran_addrecon_parse, &VAR_0->s_tran_addrecon,
sizeof(VAR_58));
if(VAR_0->u4_num_cores >= 3 && VAR_0->i1_recon_in_thread3_flag)
{
memcpy(&VAR_0->s_tran_iprecon, &VAR_0->s_tran_addrecon,
sizeof(VAR_58));
VAR_0->ps_frame_buf_ip_recon = &VAR_0->s_tran_iprecon;
}
}
ih264d_init_deblk_tfr_ctxt(VAR_0,&(VAR_0->s_pad_mgr), &(VAR_0->s_tran_addrecon),
VAR_0->u2_frm_wd_in_mbs, 0);
VAR_0->ps_cur_deblk_mb = VAR_0->ps_deblk_pic;
VAR_0->u4_cur_deblk_mb_num = 0;
VAR_0->u4_deblk_mb_x = 0;
VAR_0->u4_deblk_mb_y = 0;
VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
H264_MUTEX_UNLOCK(&VAR_0->process_disp_mutex);
return VAR_27;
}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_slice.c/vul/before/0.json,"WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
                         WORD32 i4_poc,
                         pocstruct_t *ps_temp_poc,
                         UWORD16 u2_frame_num,
                         dec_pic_params_t *ps_pps)
{
    pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
    pocstruct_t *ps_cur_poc = ps_temp_poc;

    pic_buffer_t *pic_buf;

    ivd_video_decode_op_t * ps_dec_output =
                    (ivd_video_decode_op_t *)ps_dec->pv_dec_out;
    dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
    dec_seq_params_t *ps_seq = ps_pps->ps_sps;
    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
    /* high profile related declarations */
    high_profile_tools_t s_high_profile;
    WORD32 ret;

    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);

    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
    ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;
    ps_prev_poc->i4_delta_pic_order_cnt[0] =
                    ps_cur_poc->i4_delta_pic_order_cnt[0];
    ps_prev_poc->i4_delta_pic_order_cnt[1] =
                    ps_cur_poc->i4_delta_pic_order_cnt[1];
    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
    ps_prev_poc->u2_frame_num = u2_frame_num;
    ps_dec->i1_prev_mb_qp_delta = 0;
    ps_dec->i1_next_ctxt_idx = 0;


    ps_dec->u4_nmb_deblk = 0;
    if(ps_dec->u4_num_cores == 1)
       ps_dec->u4_nmb_deblk = 1;



    if(ps_seq->u1_mb_aff_flag == 1)
    {
        ps_dec->u4_nmb_deblk = 0;
        if(ps_dec->u4_num_cores > 2)
            ps_dec->u4_num_cores = 2;
    }

        ps_dec->u4_use_intrapred_line_copy = 0;



    if (ps_seq->u1_mb_aff_flag == 0)
    {
        ps_dec->u4_use_intrapred_line_copy = 1;
    }

    ps_dec->u4_app_disable_deblk_frm = 0;
    /* If degrade is enabled, set the degrade flags appropriately */
    if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
    {
        WORD32 degrade_pic;
        ps_dec->i4_degrade_pic_cnt++;
        degrade_pic = 0;

        /* If degrade is to be done in all frames, then do not check further */
        switch(ps_dec->i4_degrade_pics)
        {
            case 4:
            {
                degrade_pic = 1;
                break;
            }
            case 3:
            {
                if(ps_cur_slice->u1_slice_type != I_SLICE)
                    degrade_pic = 1;

                break;
            }
            case 2:
            {

                /* If pic count hits non-degrade interval or it is an islice, then do not degrade */
                if((ps_cur_slice->u1_slice_type != I_SLICE)
                                && (ps_dec->i4_degrade_pic_cnt
                                                != ps_dec->i4_nondegrade_interval))
                    degrade_pic = 1;

                break;
            }
            case 1:
            {
                /* Check if the current picture is non-ref */
                if(0 == ps_cur_slice->u1_nal_ref_idc)
                {
                    degrade_pic = 1;
                }
                break;
            }

        }
        if(degrade_pic)
        {
            if(ps_dec->i4_degrade_type & 0x2)
                ps_dec->u4_app_disable_deblk_frm = 1;

            /* MC degrading is done only for non-ref pictures */
            if(0 == ps_cur_slice->u1_nal_ref_idc)
            {
                if(ps_dec->i4_degrade_type & 0x4)
                    ps_dec->i4_mv_frac_mask = 0;

                if(ps_dec->i4_degrade_type & 0x8)
                    ps_dec->i4_mv_frac_mask = 0;
            }
        }
        else
            ps_dec->i4_degrade_pic_cnt = 0;
    }

    {
        dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
        if(ps_dec->u1_sl_typ_5_9
                        && ((ps_cur_slice->u1_slice_type == I_SLICE)
                                        || (ps_cur_slice->u1_slice_type
                                                        == SI_SLICE)))
            ps_err->u1_cur_pic_type = PIC_TYPE_I;
        else
            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;

        if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
        {
            ps_err->u1_cur_pic_type = PIC_TYPE_I;
            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
        }

        if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
        {
            if(ps_err->u1_err_flag)
                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
            ps_err->u1_err_flag = ACCEPT_ALL_PICS;
        }
    }

    if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
    {
        /* Reset the decoder picture buffers */
        WORD32 j;
        for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
        {

            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                  j,
                                  BUF_MGR_REF);
            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                  BUF_MGR_REF);
            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                  j,
                                  BUF_MGR_IO);
        }

        /* reset the decoder structure parameters related to buffer handling */
        ps_dec->u1_second_field = 0;
        ps_dec->i4_cur_display_seq = 0;

        /********************************************************************/
        /* indicate in the decoder output i4_status that some frames are being */
        /* dropped, so that it resets timestamp and wait for a new sequence */
        /********************************************************************/

        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
    }
    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
    if(ret != OK)
        return ret;

    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
    if(ps_dec->u1_separate_parse)
    {
        UWORD16 pic_wd = ps_dec->u4_width_at_init;
        UWORD16 pic_ht = ps_dec->u4_height_at_init;
        UWORD32 num_mbs;

        if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
        {
            pic_wd = ps_dec->u2_pic_wd;
            pic_ht = ps_dec->u2_pic_ht;
        }
        num_mbs = (pic_wd * pic_ht) >> 8;

        if(ps_dec->pu1_dec_mb_map)
        {
            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
        }

        if(ps_dec->pu1_recon_mb_map)
        {

            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
        }

        if(ps_dec->pu2_slice_num_map)
        {
            memset((void *)ps_dec->pu2_slice_num_map, 0,
                   (num_mbs * sizeof(UWORD16)));
        }

    }

    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
    ps_dec->u2_cur_slice_num = 0;

    /* Initialize all the HP toolsets to zero */
    ps_dec->s_high_profile.u1_scaling_present = 0;
    ps_dec->s_high_profile.u1_transform8x8_present = 0;

    /* Get Next Free Picture */
    if(1 == ps_dec->u4_share_disp_buf)
    {
        UWORD32 i;
        /* Free any buffer that is in the queue to be freed */
        for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
        {
            if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
                continue;
            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
            BUF_MGR_IO);
            ps_dec->u4_disp_buf_to_be_freed[i] = 0;
            ps_dec->u4_disp_buf_mapping[i] = 0;

        }
    }
    if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))
    {
        pic_buffer_t *ps_cur_pic;
        WORD32 cur_pic_buf_id, cur_mv_buf_id;
        col_mv_buf_t *ps_col_mv;
        while(1)
        {
            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                            &cur_pic_buf_id);
            if(ps_cur_pic == NULL)
            {
                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
                return ERROR_UNAVAIL_PICBUF_T;
            }
            if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
            {
                break;
            }

        }
        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                                               &cur_mv_buf_id);
        if(ps_col_mv == NULL)
        {
            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
            return ERROR_UNAVAIL_MVBUF_T;
        }

        ps_dec->ps_cur_pic = ps_cur_pic;
        ps_dec->u1_pic_buf_id = cur_pic_buf_id;
        ps_cur_pic->u4_ts = ps_dec->u4_ts;


        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;

        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;

        {
            /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/
            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
            *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
            /* Initialize for field reference as well */
            *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;
        }

        if(!ps_dec->ps_cur_pic)
        {
            WORD32 j;
            H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
            for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
            {

                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                      j,
                                      BUF_MGR_REF);
                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                      BUF_MGR_REF);
                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                      j,
                                      BUF_MGR_IO);
            }

            ps_dec->i4_cur_display_seq = 0;
            ps_dec->i4_prev_max_display_seq = 0;
            ps_dec->i4_max_poc = 0;

            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                            &cur_pic_buf_id);
            if(ps_cur_pic == NULL)
            {
                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
                return ERROR_UNAVAIL_PICBUF_T;
            }

            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                                                   &cur_mv_buf_id);
            if(ps_col_mv == NULL)
            {
                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
                return ERROR_UNAVAIL_MVBUF_T;
            }

            ps_dec->ps_cur_pic = ps_cur_pic;
            ps_dec->u1_pic_buf_id = cur_pic_buf_id;
            ps_cur_pic->u4_ts = ps_dec->u4_ts;
            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;

            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;

            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;

        }

        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
        H264_DEC_DEBUG_PRINT(""got a buffer\n"");
    }
    else
    {
        H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
    }

    ps_dec->u4_pic_buf_got = 1;

    ps_dec->ps_cur_pic->i4_poc = i4_poc;
    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
                    ps_pps->i4_bottom_field_order_cnt;
    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;

    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
    if(u1_field_pic_flag && u1_bottom_field_flag)
    {
        WORD32 i4_temp_poc;
        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
        /* Point to odd lines, since it's bottom field */
        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
        ps_dec->s_cur_pic.ps_mv +=
                        ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
                        * ps_dec->u2_pic_wd) >> 5);
        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
        i4_temp_poc = MIN(i4_top_field_order_poc,
                                 i4_bot_field_order_poc);
        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
    }

    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
                    && (!u1_field_pic_flag);

    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
                    << 2);

    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];
    ps_dec->ps_cur_mb_row++; //Increment by 1 ,so that left mb will always be valid
    ps_dec->ps_top_mb_row =
                    ps_dec->ps_nbr_mb_row
                                    + ((ps_dec->u2_frm_wd_in_mbs + 1)
                                                    << (1
                                                                    - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
    ps_dec->ps_top_mb_row++; //Increment by 1 ,so that left mb will always be valid

    ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];
    ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];
    ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];
    ps_dec->u1_yuv_scratch_idx = 0;
    /* CHANGED CODE */
    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
    /* CHANGED CODE */
    ps_dec->u1_mv_top_p = 0;
    ps_dec->u1_mb_idx = 0;
    /* CHANGED CODE */
    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
    ps_dec->pu1_yleft = 0;
    ps_dec->pu1_uleft = 0;
    ps_dec->pu1_vleft = 0;
    ps_dec->u1_not_wait_rec = 2;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
    ps_dec->u4_pred_info_idx = 0;
    ps_dec->u4_pred_info_pkd_idx = 0;
    ps_dec->u4_dma_buf_idx = 0;
    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
    ps_dec->ps_part = ps_dec->ps_parse_part_params;
    ps_dec->i2_prev_slice_mbx = -1;
    ps_dec->i2_prev_slice_mby = 0;
    ps_dec->u2_mv_2mb[0] = 0;
    ps_dec->u2_mv_2mb[1] = 0;
    ps_dec->u1_last_pic_not_decoded = 0;

    ps_dec->u2_cur_slice_num_dec_thread = 0;
    ps_dec->u2_cur_slice_num_bs = 0;
    ps_dec->u4_intra_pred_line_ofst = 0;
    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;

    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;





    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
                    + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);

    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
                    + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
                    + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;

    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
    ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;
    ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;
    /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */
    {
        if(ps_cur_slice->u1_mbaff_frame_flag)
        {
            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
        }
        else
        {
            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
        }
    }
    /* Set up the Parameter for DMA transfer */
    {
        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;

        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;

        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
                        % (ps_dec->u1_recon_mb_grp >> u1_mbaff));
        UWORD16 ui16_lastmbs_widthY =
                        (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
                                        >> u1_mbaff) << 4));
        UWORD16 ui16_lastmbs_widthUV =
                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
                                        >> u1_mbaff) << 3);

        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;

        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
                        << u1_field_pic_flag;
        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
                        << u1_field_pic_flag;

        if(u1_field_pic_flag)
        {
            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
        }

        /* Normal Increment of Pointer */
        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
                        >> u1_mbaff);
        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
                        >> u1_mbaff);

        /* End of Row Increment */
        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
                        + (PAD_LEN_Y_H << 1)
                        + ps_dec->s_tran_addrecon.u2_frm_wd_y
                                        * ((15 << u1_mbaff) + u1_mbaff));
        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
                        + (PAD_LEN_UV_H << 2)
                        + ps_dec->s_tran_addrecon.u2_frm_wd_uv
                                        * ((15 << u1_mbaff) + u1_mbaff));

        /* Assign picture numbers to each frame/field  */
        /* only once per picture.                      */
        ih264d_assign_pic_num(ps_dec);
        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
                        << 2) - 1 - (u1_mbaff << 2);
        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
                        >> u1_mbaff) - 1) << (4 + u1_mbaff);
    }
    /**********************************************************************/
    /* High profile related initialization at pictrue level               */
    /**********************************************************************/
    if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
    {
        if((ps_seq->i4_seq_scaling_matrix_present_flag)
                        || (ps_pps->i4_pic_scaling_matrix_present_flag))
        {
            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
            ps_dec->s_high_profile.u1_scaling_present = 1;
        }
        else
        {
            ih264d_form_default_scaling_matrix(ps_dec);
        }

        if(ps_pps->i4_transform_8x8_mode_flag)
        {
            ps_dec->s_high_profile.u1_transform8x8_present = 1;
        }
    }
    else
    {
        ih264d_form_default_scaling_matrix(ps_dec);
    }

    /* required while reading the transform_size_8x8 u4_flag */
    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
                    ps_seq->u1_direct_8x8_inference_flag;
    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;

    ps_dec->i1_recon_in_thread3_flag = 1;
    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
    if(ps_dec->u1_separate_parse)
    {
        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
               sizeof(tfr_ctxt_t));
        if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
        {
            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
                   sizeof(tfr_ctxt_t));
            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
        }
    }


    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
                               ps_dec->u2_frm_wd_in_mbs, 0);

    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
    ps_dec->u4_cur_deblk_mb_num = 0;

    ps_dec->u4_deblk_mb_x = 0;
    ps_dec->u4_deblk_mb_y = 0;
    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;

    ps_dec->u4_first_slice_in_pic = 0;
    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
    return OK;
}","WORD32 ih264d_start_of_pic(dec_struct_t *VAR_0,
                         WORD32 VAR_1,
                         pocstruct_t *VAR_2,
                         UWORD16 VAR_3,
                         dec_pic_params_t *VAR_4)
{
    pocstruct_t *VAR_5 = &VAR_0->s_cur_pic_poc;
    pocstruct_t *VAR_6 = VAR_2;

    pic_buffer_t *VAR_7;

    ivd_video_decode_op_t * VAR_8 =
                    (ivd_video_decode_op_t *)VAR_0->pv_dec_out;
    dec_slice_params_t *VAR_9 = VAR_0->ps_cur_slice;
    dec_seq_params_t *VAR_10 = VAR_4->ps_sps;
    UWORD8 VAR_11 = VAR_9->u1_bottom_field_flag;
    UWORD8 VAR_12 = VAR_9->u1_field_pic_flag;
    /* COMMENT_0 */
    high_profile_tools_t VAR_13;
    WORD32 VAR_14;

    H264_MUTEX_LOCK(&VAR_0->process_disp_mutex);

    VAR_5->i4_pic_order_cnt_lsb = VAR_6->i4_pic_order_cnt_lsb;
    VAR_5->i4_pic_order_cnt_msb = VAR_6->i4_pic_order_cnt_msb;
    VAR_5->i4_delta_pic_order_cnt_bottom =
                    VAR_6->i4_delta_pic_order_cnt_bottom;
    VAR_5->i4_delta_pic_order_cnt[0] =
                    VAR_6->i4_delta_pic_order_cnt[0];
    VAR_5->i4_delta_pic_order_cnt[1] =
                    VAR_6->i4_delta_pic_order_cnt[1];
    VAR_5->u1_bot_field = VAR_0->ps_cur_slice->u1_bottom_field_flag;
    VAR_5->i4_prev_frame_num_ofst = VAR_6->i4_prev_frame_num_ofst;
    VAR_5->u2_frame_num = VAR_3;
    VAR_0->i1_prev_mb_qp_delta = 0;
    VAR_0->i1_next_ctxt_idx = 0;


    VAR_0->u4_nmb_deblk = 0;
    if(VAR_0->u4_num_cores == 1)
       VAR_0->u4_nmb_deblk = 1;



    if(VAR_10->u1_mb_aff_flag == 1)
    {
        VAR_0->u4_nmb_deblk = 0;
        if(VAR_0->u4_num_cores > 2)
            VAR_0->u4_num_cores = 2;
    }

        VAR_0->u4_use_intrapred_line_copy = 0;



    if (VAR_10->u1_mb_aff_flag == 0)
    {
        VAR_0->u4_use_intrapred_line_copy = 1;
    }

    VAR_0->u4_app_disable_deblk_frm = 0;
    /* COMMENT_1 */
    if(VAR_0->i4_degrade_type && VAR_0->i4_degrade_pics)
    {
        WORD32 VAR_15;
        VAR_0->i4_degrade_pic_cnt++;
        VAR_15 = 0;

        /* COMMENT_2 */
        switch(VAR_0->i4_degrade_pics)
        {
            case 4:
            {
                VAR_15 = 1;
                break;
            }
            case 3:
            {
                if(VAR_9->u1_slice_type != VAR_16)
                    VAR_15 = 1;

                break;
            }
            case 2:
            {

                /* COMMENT_3 */
                if((VAR_9->u1_slice_type != VAR_16)
                                && (VAR_0->i4_degrade_pic_cnt
                                                != VAR_0->i4_nondegrade_interval))
                    VAR_15 = 1;

                break;
            }
            case 1:
            {
                /* COMMENT_4 */
                if(0 == VAR_9->u1_nal_ref_idc)
                {
                    VAR_15 = 1;
                }
                break;
            }

        }
        if(VAR_15)
        {
            if(VAR_0->i4_degrade_type & 0x2)
                VAR_0->u4_app_disable_deblk_frm = 1;

            /* COMMENT_5 */
            if(0 == VAR_9->u1_nal_ref_idc)
            {
                if(VAR_0->i4_degrade_type & 0x4)
                    VAR_0->i4_mv_frac_mask = 0;

                if(VAR_0->i4_degrade_type & 0x8)
                    VAR_0->i4_mv_frac_mask = 0;
            }
        }
        else
            VAR_0->i4_degrade_pic_cnt = 0;
    }

    {
        dec_err_status_t * VAR_17 = VAR_0->ps_dec_err_status;
        if(VAR_0->u1_sl_typ_5_9
                        && ((VAR_9->u1_slice_type == VAR_16)
                                        || (VAR_9->u1_slice_type
                                                        == VAR_18)))
            VAR_17->u1_cur_pic_type = VAR_19;
        else
            VAR_17->u1_cur_pic_type = VAR_20;

        if(VAR_17->u1_pic_aud_i == VAR_19)
        {
            VAR_17->u1_cur_pic_type = VAR_19;
            VAR_17->u1_pic_aud_i = VAR_20;
        }

        if(VAR_9->u1_nal_unit_type == VAR_21)
        {
            if(VAR_17->u1_err_flag)
                ih264d_reset_ref_bufs(VAR_0->ps_dpb_mgr);
            VAR_17->u1_err_flag = VAR_22;
        }
    }

    if(VAR_0->u1_init_dec_flag && VAR_0->s_prev_seq_params.u1_eoseq_pending)
    {
        /* COMMENT_6 */
        WORD32 VAR_23;
        for(VAR_23 = 0; VAR_23 < VAR_24; VAR_23++)
        {

            ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                                  VAR_23,
                                  VAR_25);
            ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
                                  VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_23],
                                  VAR_25);
            ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                                  VAR_23,
                                  VAR_26);
        }

        /* COMMENT_7 */
        VAR_0->u1_second_field = 0;
        VAR_0->i4_cur_display_seq = 0;

        /* COMMENT_8 */
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_8 */

        VAR_0->s_prev_seq_params.u1_eoseq_pending = 0;
    }
    VAR_14 = ih264d_init_pic(VAR_0, VAR_3, VAR_1, VAR_4);
    if(VAR_14 != VAR_27)
        return VAR_14;

    VAR_0->pv_parse_tu_coeff_data = VAR_0->pv_pic_tu_coeff_data;
    VAR_0->pv_proc_tu_coeff_data  = VAR_0->pv_pic_tu_coeff_data;
    VAR_0->ps_nmb_info = VAR_0->ps_frm_mb_info;
    if(VAR_0->u1_separate_parse)
    {
        UWORD16 VAR_28 = VAR_0->u4_width_at_init;
        UWORD16 VAR_29 = VAR_0->u4_height_at_init;
        UWORD32 VAR_30;

        if((NULL != VAR_0->ps_cur_sps) && (1 == (VAR_0->ps_cur_sps->u1_is_valid)))
        {
            VAR_28 = VAR_0->u2_pic_wd;
            VAR_29 = VAR_0->u2_pic_ht;
        }
        VAR_30 = (VAR_28 * VAR_29) >> 8;

        if(VAR_0->pu1_dec_mb_map)
        {
            memset((void *)VAR_0->pu1_dec_mb_map, 0, VAR_30);
        }

        if(VAR_0->pu1_recon_mb_map)
        {

            memset((void *)VAR_0->pu1_recon_mb_map, 0, VAR_30);
        }

        if(VAR_0->pu2_slice_num_map)
        {
            memset((void *)VAR_0->pu2_slice_num_map, 0,
                   (VAR_30 * sizeof(UWORD16)));
        }

    }

    VAR_0->ps_parse_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
    VAR_0->ps_decode_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
    VAR_0->ps_computebs_cur_slice = &(VAR_0->ps_dec_slice_buf[0]);
    VAR_0->u2_cur_slice_num = 0;

    /* COMMENT_11 */
    VAR_0->s_high_profile.u1_scaling_present = 0;
    VAR_0->s_high_profile.u1_transform8x8_present = 0;

    /* COMMENT_12 */
    if(1 == VAR_0->u4_share_disp_buf)
    {
        UWORD32 VAR_31;
        /* COMMENT_13 */
        for(VAR_31 = 0; VAR_31 < VAR_24; VAR_31++)
        {
            if(0 == VAR_0->u4_disp_buf_to_be_freed[VAR_31])
                continue;
            ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr, VAR_31,
            VAR_26);
            VAR_0->u4_disp_buf_to_be_freed[VAR_31] = 0;
            VAR_0->u4_disp_buf_mapping[VAR_31] = 0;

        }
    }
    if(!(VAR_12 && 0 != VAR_0->u1_top_bottom_decoded)) /* COMMENT_14 */
    {
        pic_buffer_t *VAR_32;
        WORD32 VAR_33, VAR_34;
        col_mv_buf_t *VAR_35;
        while(1)
        {
            VAR_32 = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                            (buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                            &VAR_33);
            if(VAR_32 == NULL)
            {
                VAR_0->i4_error_code = VAR_36;
                return VAR_36;
            }
            if(0 == VAR_0->u4_disp_buf_mapping[VAR_33])
            {
                break;
            }

        }
        VAR_35 = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
                                                               &VAR_34);
        if(VAR_35 == NULL)
        {
            VAR_0->i4_error_code = VAR_37;
            return VAR_37;
        }

        VAR_0->ps_cur_pic = VAR_32;
        VAR_0->u1_pic_buf_id = VAR_33;
        VAR_32->u4_ts = VAR_0->u4_ts;


        VAR_32->u1_mv_buf_id = VAR_34;
        VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_33] = VAR_34;

        VAR_32->pu1_col_zero_flag = (UWORD8 *)VAR_35->pv_col_zero_flag;
        VAR_32->ps_mv = (mv_pred_t *)VAR_35->pv_mv;
        VAR_0->au1_pic_buf_ref_flag[VAR_33] = 0;

        {
            /* COMMENT_15 */
            VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_init_dpb[0];
            *(VAR_0->ps_dpb_mgr->ps_init_dpb[0][0]) = *VAR_32;
            /* COMMENT_16 */
            *(VAR_0->ps_dpb_mgr->ps_init_dpb[0][VAR_38]) = *VAR_32;
        }

        if(!VAR_0->ps_cur_pic)
        {
            WORD32 VAR_23;
            H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
            for(VAR_23 = 0; VAR_23 < VAR_24; VAR_23++)
            {

                ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                                      VAR_23,
                                      VAR_25);
                ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
                                      VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_23],
                                      VAR_25);
                ih264_buf_mgr_release((buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                                      VAR_23,
                                      VAR_26);
            }

            VAR_0->i4_cur_display_seq = 0;
            VAR_0->i4_prev_max_display_seq = 0;
            VAR_0->i4_max_poc = 0;

            VAR_32 = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                            (buf_mgr_t *)VAR_0->pv_pic_buf_mgr,
                            &VAR_33);
            if(VAR_32 == NULL)
            {
                VAR_0->i4_error_code = VAR_36;
                return VAR_36;
            }

            VAR_35 = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)VAR_0->pv_mv_buf_mgr,
                                                                   &VAR_34);
            if(VAR_35 == NULL)
            {
                VAR_0->i4_error_code = VAR_37;
                return VAR_37;
            }

            VAR_0->ps_cur_pic = VAR_32;
            VAR_0->u1_pic_buf_id = VAR_33;
            VAR_32->u4_ts = VAR_0->u4_ts;
            VAR_0->apv_buf_id_pic_buf_map[VAR_33] = (void *)VAR_32;

            VAR_32->u1_mv_buf_id = VAR_34;
            VAR_0->au1_pic_buf_id_mv_buf_id_map[VAR_33] = VAR_34;

            VAR_32->pu1_col_zero_flag = (UWORD8 *)VAR_35->pv_col_zero_flag;
            VAR_32->ps_mv = (mv_pred_t *)VAR_35->pv_mv;
            VAR_0->au1_pic_buf_ref_flag[VAR_33] = 0;

        }

        VAR_0->ps_cur_pic->u1_picturetype = VAR_12;
        VAR_0->ps_cur_pic->u4_pack_slc_typ = VAR_39;
        H264_DEC_DEBUG_PRINT(""got a buffer\n"");
    }
    else
    {
        H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
    }

    VAR_0->u4_pic_buf_got = 1;

    VAR_0->ps_cur_pic->i4_poc = VAR_1;
    VAR_0->ps_cur_pic->i4_frame_num = VAR_3;
    VAR_0->ps_cur_pic->i4_pic_num = VAR_3;
    VAR_0->ps_cur_pic->i4_top_field_order_cnt = VAR_4->i4_top_field_order_cnt;
    VAR_0->ps_cur_pic->i4_bottom_field_order_cnt =
                    VAR_4->i4_bottom_field_order_cnt;
    VAR_0->ps_cur_pic->i4_avg_poc = VAR_4->i4_avg_poc;
    VAR_0->ps_cur_pic->u4_time_stamp = VAR_0->u4_pts;

    VAR_0->s_cur_pic = *(VAR_0->ps_cur_pic);
    if(VAR_12 && VAR_11)
    {
        WORD32 VAR_40;
        WORD32 VAR_41, VAR_42;
        /* COMMENT_17 */
        VAR_0->s_cur_pic.pu1_buf1 += VAR_0->s_cur_pic.u2_frm_wd_y;
        VAR_0->s_cur_pic.pu1_buf2 += VAR_0->s_cur_pic.u2_frm_wd_uv;
        VAR_0->s_cur_pic.pu1_buf3 += VAR_0->s_cur_pic.u2_frm_wd_uv;
        VAR_0->s_cur_pic.ps_mv +=
                        ((VAR_0->u2_pic_ht * VAR_0->u2_pic_wd) >> 5);
        VAR_0->s_cur_pic.pu1_col_zero_flag += ((VAR_0->u2_pic_ht
                        * VAR_0->u2_pic_wd) >> 5);
        VAR_0->ps_cur_pic->u1_picturetype |= VAR_43;
        VAR_41 = VAR_0->ps_cur_pic->i4_top_field_order_cnt;
        VAR_42 = VAR_0->ps_cur_pic->i4_bottom_field_order_cnt;
        VAR_40 = MIN(VAR_41,
                                 VAR_42);
        VAR_0->ps_cur_pic->i4_avg_poc = VAR_40;
    }

    VAR_9->u1_mbaff_frame_flag = VAR_10->u1_mb_aff_flag
                    && (!VAR_12);

    VAR_0->ps_cur_pic->u1_picturetype |= (VAR_9->u1_mbaff_frame_flag
                    << 2);

    VAR_0->ps_cur_mb_row = VAR_0->ps_nbr_mb_row; /* COMMENT_18 */
    VAR_0->ps_cur_mb_row++; /* COMMENT_19 */
    VAR_0->ps_top_mb_row =
                    VAR_0->ps_nbr_mb_row
                                    + ((VAR_0->u2_frm_wd_in_mbs + 1)
                                                    << (1
                                                                    - VAR_0->ps_cur_sps->u1_frame_mbs_only_flag));
    VAR_0->ps_top_mb_row++; /* COMMENT_19 */

    VAR_0->pu1_y = VAR_0->pu1_y_scratch[0];
    VAR_0->pu1_u = VAR_0->pu1_u_scratch[0];
    VAR_0->pu1_v = VAR_0->pu1_v_scratch[0];
    VAR_0->u1_yuv_scratch_idx = 0;
    /* COMMENT_20 */
    VAR_0->ps_mv_cur = VAR_0->s_cur_pic.ps_mv;
    VAR_0->ps_mv_top = VAR_0->ps_mv_top_p[0];
    /* COMMENT_20 */
    VAR_0->u1_mv_top_p = 0;
    VAR_0->u1_mb_idx = 0;
    /* COMMENT_20 */
    VAR_0->ps_mv_left = VAR_0->s_cur_pic.ps_mv;
    VAR_0->pu1_yleft = 0;
    VAR_0->pu1_uleft = 0;
    VAR_0->pu1_vleft = 0;
    VAR_0->u1_not_wait_rec = 2;
    VAR_0->u2_total_mbs_coded = 0;
    VAR_0->i4_submb_ofst = -(VAR_44);
    VAR_0->u4_pred_info_idx = 0;
    VAR_0->u4_pred_info_pkd_idx = 0;
    VAR_0->u4_dma_buf_idx = 0;
    VAR_0->ps_mv = VAR_0->s_cur_pic.ps_mv;
    VAR_0->ps_mv_bank_cur = VAR_0->s_cur_pic.ps_mv;
    VAR_0->pu1_col_zero_flag = VAR_0->s_cur_pic.pu1_col_zero_flag;
    VAR_0->ps_part = VAR_0->ps_parse_part_params;
    VAR_0->i2_prev_slice_mbx = -1;
    VAR_0->i2_prev_slice_mby = 0;
    VAR_0->u2_mv_2mb[0] = 0;
    VAR_0->u2_mv_2mb[1] = 0;
    VAR_0->u1_last_pic_not_decoded = 0;

    VAR_0->u2_cur_slice_num_dec_thread = 0;
    VAR_0->u2_cur_slice_num_bs = 0;
    VAR_0->u4_intra_pred_line_ofst = 0;
    VAR_0->pu1_cur_y_intra_pred_line = VAR_0->pu1_y_intra_pred_line;
    VAR_0->pu1_cur_u_intra_pred_line = VAR_0->pu1_u_intra_pred_line;
    VAR_0->pu1_cur_v_intra_pred_line = VAR_0->pu1_v_intra_pred_line;

    VAR_0->pu1_cur_y_intra_pred_line_base = VAR_0->pu1_y_intra_pred_line;
    VAR_0->pu1_cur_u_intra_pred_line_base = VAR_0->pu1_u_intra_pred_line;
    VAR_0->pu1_cur_v_intra_pred_line_base = VAR_0->pu1_v_intra_pred_line;





    VAR_0->pu1_prev_y_intra_pred_line = VAR_0->pu1_y_intra_pred_line
                    + (VAR_0->u2_frm_wd_in_mbs * VAR_45);

    VAR_0->pu1_prev_u_intra_pred_line = VAR_0->pu1_u_intra_pred_line
                    + VAR_0->u2_frm_wd_in_mbs * VAR_46 * VAR_47;
    VAR_0->pu1_prev_v_intra_pred_line = VAR_0->pu1_v_intra_pred_line
                    + VAR_0->u2_frm_wd_in_mbs * VAR_46;

    VAR_0->ps_deblk_mbn = VAR_0->ps_deblk_pic;
    VAR_0->ps_deblk_mbn_curr = VAR_0->ps_deblk_mbn;
    VAR_0->ps_deblk_mbn_prev = VAR_0->ps_deblk_mbn + VAR_0->u1_recon_mb_grp;
    /* COMMENT_21 */
    {
        if(VAR_9->u1_mbaff_frame_flag)
        {
            VAR_0->pf_compute_bs = VAR_48;
            VAR_0->pf_mvpred = VAR_49;
        }
        else
        {
            VAR_0->pf_compute_bs = VAR_50;
            VAR_0->u1_cur_mb_fld_dec_flag = VAR_9->u1_field_pic_flag;
        }
    }
    /* COMMENT_22 */
    {
        UWORD8 VAR_12 = VAR_0->ps_cur_slice->u1_field_pic_flag;

        UWORD8 VAR_51 = VAR_9->u1_mbaff_frame_flag;

        UWORD8 VAR_52 = (((VAR_0->u2_pic_wd) >> 4)
                        % (VAR_0->u1_recon_mb_grp >> VAR_51));
        UWORD16 VAR_53 =
                        (VAR_52 ? (VAR_52 << 4) : ((VAR_0->u1_recon_mb_grp
                                        >> VAR_51) << 4));
        UWORD16 VAR_54 =
                        VAR_52 ? (VAR_52 << 3) : ((VAR_0->u1_recon_mb_grp
                                        >> VAR_51) << 3);

        VAR_0->s_tran_addrecon.pu1_dest_y = VAR_0->s_cur_pic.pu1_buf1;
        VAR_0->s_tran_addrecon.pu1_dest_u = VAR_0->s_cur_pic.pu1_buf2;
        VAR_0->s_tran_addrecon.pu1_dest_v = VAR_0->s_cur_pic.pu1_buf3;

        VAR_0->s_tran_addrecon.u2_frm_wd_y = VAR_0->u2_frm_wd_y
                        << VAR_12;
        VAR_0->s_tran_addrecon.u2_frm_wd_uv = VAR_0->u2_frm_wd_uv
                        << VAR_12;

        if(VAR_12)
        {
            VAR_53 += VAR_0->u2_frm_wd_y;
            VAR_54 += VAR_0->u2_frm_wd_uv;
        }

        /* COMMENT_23 */
        VAR_0->s_tran_addrecon.u4_inc_y[0] = ((VAR_0->u1_recon_mb_grp << 4)
                        >> VAR_51);
        VAR_0->s_tran_addrecon.u4_inc_uv[0] = ((VAR_0->u1_recon_mb_grp << 4)
                        >> VAR_51);

        /* COMMENT_24 */
        VAR_0->s_tran_addrecon.u4_inc_y[1] = (VAR_53
                        + (VAR_55 << 1)
                        + VAR_0->s_tran_addrecon.u2_frm_wd_y
                                        * ((15 << VAR_51) + VAR_51));
        VAR_0->s_tran_addrecon.u4_inc_uv[1] = (VAR_54
                        + (VAR_56 << 2)
                        + VAR_0->s_tran_addrecon.u2_frm_wd_uv
                                        * ((15 << VAR_51) + VAR_51));

        /* COMMENT_25 */
        /* COMMENT_26 */
        ih264d_assign_pic_num(VAR_0);
        VAR_0->s_tran_addrecon.u2_mv_top_left_inc = (VAR_0->u1_recon_mb_grp
                        << 2) - 1 - (VAR_51 << 2);
        VAR_0->s_tran_addrecon.u2_mv_left_inc = ((VAR_0->u1_recon_mb_grp
                        >> VAR_51) - 1) << (4 + VAR_51);
    }
    /* COMMENT_27 */
    /* COMMENT_28 */
    /* COMMENT_27 */
    if(VAR_10->u1_profile_idc == VAR_57)
    {
        if((VAR_10->i4_seq_scaling_matrix_present_flag)
                        || (VAR_4->i4_pic_scaling_matrix_present_flag))
        {
            ih264d_form_scaling_matrix_picture(VAR_10, VAR_4, VAR_0);
            VAR_0->s_high_profile.u1_scaling_present = 1;
        }
        else
        {
            ih264d_form_default_scaling_matrix(VAR_0);
        }

        if(VAR_4->i4_transform_8x8_mode_flag)
        {
            VAR_0->s_high_profile.u1_transform8x8_present = 1;
        }
    }
    else
    {
        ih264d_form_default_scaling_matrix(VAR_0);
    }

    /* COMMENT_29 */
    VAR_0->s_high_profile.u1_direct_8x8_inference_flag =
                    VAR_10->u1_direct_8x8_inference_flag;
    VAR_0->s_high_profile.s_cavlc_ctxt = VAR_0->s_cavlc_ctxt;

    VAR_0->i1_recon_in_thread3_flag = 1;
    VAR_0->ps_frame_buf_ip_recon = &VAR_0->s_tran_addrecon;
    if(VAR_0->u1_separate_parse)
    {
        memcpy(&VAR_0->s_tran_addrecon_parse, &VAR_0->s_tran_addrecon,
               sizeof(VAR_58));
        if(VAR_0->u4_num_cores >= 3 && VAR_0->i1_recon_in_thread3_flag)
        {
            memcpy(&VAR_0->s_tran_iprecon, &VAR_0->s_tran_addrecon,
                   sizeof(VAR_58));
            VAR_0->ps_frame_buf_ip_recon = &VAR_0->s_tran_iprecon;
        }
    }


    ih264d_init_deblk_tfr_ctxt(VAR_0,&(VAR_0->s_pad_mgr), &(VAR_0->s_tran_addrecon),
                               VAR_0->u2_frm_wd_in_mbs, 0);

    VAR_0->ps_cur_deblk_mb = VAR_0->ps_deblk_pic;
    VAR_0->u4_cur_deblk_mb_num = 0;

    VAR_0->u4_deblk_mb_x = 0;
    VAR_0->u4_deblk_mb_y = 0;
    VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;

    VAR_0->u4_first_slice_in_pic = 0;
    H264_MUTEX_UNLOCK(&VAR_0->process_disp_mutex);
    return VAR_27;
}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_slice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -577,6 +577,7 @@
     ps_dec->u4_deblk_mb_y = 0;
     ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
 
+    ps_dec->u4_first_slice_in_pic = 0;
     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
     return OK;
 }","{'deleted_lines': [], 'added_lines': ['    ps_dec->u4_first_slice_in_pic = 0;']}",True,"An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775.",5.5,MEDIUM,1,valid,,5
CVE-2017-0555,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Decoder: Fixed initialization of first_slice_in_pic

To handle some errors, first_slice_in_pic was being set to 2.
This is now cleaned up and first_slice_in_pic is set to 1 only once per pic.
This will ensure picture level initializations are done only once even in case
of error clips

Bug: 33717589
Bug: 33551775
Bug: 33716442
Bug: 33677995

Change-Id: If341436b3cbaa724017eedddd88c2e6fac36d8ba
",0b23c81c3dd9ec38f7e6806a3955fed1925541a0,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,decoder/ih264d_parse_pslice.c,ih264d_mark_err_slice_skip,"WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
WORD32 num_mb_skip,
UWORD8 u1_is_idr_slice,
UWORD16 u2_frame_num,
pocstruct_t *ps_cur_poc,
WORD32 prev_slice_err)
{
WORD32 i2_cur_mb_addr;
UWORD32 u1_num_mbs, u1_num_mbsNby2;
UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
UWORD32 i2_mb_skip_run;
UWORD32 u1_num_mbs_next, u1_end_of_row;
const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
UWORD32 u1_slice_end;
UWORD32 u1_tfr_n_mb;
UWORD32 u1_decode_nmb;
dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
deblk_mb_t *ps_cur_deblk_mb;
dec_mb_info_t *ps_cur_mb_info;
parse_pmbarams_t *ps_parse_mb_data;
UWORD32 u1_inter_mb_type;
UWORD32 u1_deblk_mb_type;
UWORD16 u2_total_mbs_coded;
UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
parse_part_params_t *ps_part_info;
WORD32 ret;
UNUSED(u1_is_idr_slice);
if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
{
ih264d_err_pic_dispbuf_mgr(ps_dec);
return 0;
}
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))
{
num_mb_skip++;
}
ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
if(prev_slice_err == 1)
{
ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
{
WORD32 i, j, poc = 0;
ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;
ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
if(ps_dec->ps_cur_pic != NULL)
poc = ps_dec->ps_cur_pic->i4_poc + 2;
j = -1;
for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
{
if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
{
if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)
{
j = i;
break;
}
}
}
if(j == -1)
{
return ERROR_INV_SLICE_HDR_T;
}
if(ps_dec->u4_pic_buf_got == 0)
{
ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
ps_dec->ps_cur_slice->u2_frame_num,
&ps_dec->ps_pps[j]);
if(ret != OK)
{
return ret;
}
}
ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;
ps_dec->u4_output_present = 0;
{
ih264d_get_next_display_field(ps_dec,
ps_dec->ps_out_buffer,
&(ps_dec->s_disp_op));
if(0 != ps_dec->s_disp_op.u4_error_code)
{
ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
}
else
ps_dec->u4_output_present = 1;
}
if(ps_dec->u1_separate_parse == 1)
{
if(ps_dec->u4_dec_thread_created == 0)
{
ithread_create(ps_dec->pv_dec_thread_handle, NULL,
(void *)ih264d_decode_picture_thread,
(void *)ps_dec);
ps_dec->u4_dec_thread_created = 1;
}
if((ps_dec->u4_num_cores == 3) &&
((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
&& (ps_dec->u4_bs_deblk_thread_created == 0))
{
ps_dec->u4_start_recon_deblk = 0;
ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
(void *)ih264d_recon_deblk_thread,
(void *)ps_dec);
ps_dec->u4_bs_deblk_thread_created = 1;
}
}
}
ps_dec->u4_first_slice_in_pic = 0;
}
else
{
dec_slice_struct_t *ps_parse_cur_slice;
ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;
if(ps_dec->u1_slice_header_done
&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
{
if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))
{
ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;
ps_dec->u2_cur_mb_addr--;
}
u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;
if(u1_num_mbs)
{
ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
}
else
{
if(ps_dec->u1_separate_parse)
{
ps_cur_mb_info = ps_dec->ps_nmb_info;
}
else
{
ps_cur_mb_info = ps_dec->ps_nmb_info
+ ps_dec->u4_num_mbs_prev_nmb - 1;
}
}
ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
ps_dec->u1_mb_ngbr_availablity =
ps_cur_mb_info->u1_mb_ngbr_availablity;
if(u1_num_mbs)
{
ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
ps_dec->u2_cur_mb_addr--;
ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;
if (ps_dec->u1_pr_sl_type == P_SLICE
|| ps_dec->u1_pr_sl_type == B_SLICE)
{
ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
ps_dec->ps_part = ps_dec->ps_parse_part_params;
}
u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
u1_end_of_row = (!u1_num_mbs_next)
&& (!(u1_mbaff && (u1_num_mbs & 0x01)));
u1_slice_end = 1;
u1_tfr_n_mb = 1;
ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
if(ps_dec->u1_separate_parse)
{
ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
ps_dec->ps_nmb_info += u1_num_mbs;
}
else
{
ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
}
ps_dec->u2_total_mbs_coded += u1_num_mbs;
ps_dec->u1_mb_idx = 0;
ps_dec->u4_num_mbs_cur_nmb = 0;
}
if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
ps_dec->u1_pic_decode_done = 1;
return 0;
}
if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <
(UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))
{
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
ps_dec->u2_cur_slice_num++;
ps_dec->ps_parse_cur_slice++;
}
}
else
{
ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
+ ps_dec->u2_cur_slice_num;
}
}
{
WORD32 num_entries;
WORD32 size;
UWORD8 *pu1_buf;
num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);
size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);
pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
pu1_buf += size * ps_dec->u2_cur_slice_num;
ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
}
ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;
if(ps_dec->ps_cur_slice->u1_field_pic_flag)
ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;
ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;
if(ps_dec->u1_separate_parse)
{
ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
}
else
{
ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
}
u1_inter_mb_type = P_MB;
u1_deblk_mb_type = D_INTER_MB;
ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
ps_dec->ps_part = ps_dec->ps_parse_part_params;
ps_dec->u2_mbx =
(MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
ps_dec->u2_mby =
(DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
ps_dec->u2_mby <<= u1_mbaff;
ps_dec->u1_slice_header_done = 2;
ps_dec->u1_qp = ps_slice->u1_slice_qp;
ih264d_update_qp(ps_dec, 0);
u1_mb_idx = ps_dec->u1_mb_idx;
ps_parse_mb_data = ps_dec->ps_parse_mb_data;
u1_num_mbs = u1_mb_idx;
u1_slice_end = 0;
u1_tfr_n_mb = 0;
u1_decode_nmb = 0;
u1_num_mbsNby2 = 0;
i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
i2_mb_skip_run = num_mb_skip;
while(!u1_slice_end)
{
UWORD8 u1_mb_type;
if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
break;
ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
ps_cur_mb_info->u1_Mux = 0;
ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
ps_cur_mb_info->u1_end_of_slice = 0;
ps_parse_mb_data->u1_num_part = 1;
ps_parse_mb_data->u1_isI_mb = 0;
if (u1_mbaff)
ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
else
ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
if(ps_dec->u4_app_disable_deblk_frm == 0)
{
ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
ps_dec->u1_mb_ngbr_availablity,
ps_dec->u1_cur_mb_fld_dec_flag);
}
ps_dec->i1_prev_mb_qp_delta = 0;
ps_dec->u1_sub_mb_num = 0;
ps_cur_mb_info->u1_mb_type = MB_SKIP;
ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
ps_cur_mb_info->u1_cbp = 0;
ps_part_info = ps_dec->ps_part;
ps_part_info->u1_is_direct = PART_DIRECT_16x16;
ps_part_info->u1_sub_mb_num = 0;
ps_dec->ps_part++;
ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
i2_mb_skip_run--;
ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
if (u1_mbaff)
{
ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
}
i2_cur_mb_addr++;
u1_num_mbs++;
u1_num_mbsNby2++;
ps_parse_mb_data++;
u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
u1_slice_end = !i2_mb_skip_run;
u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
|| u1_slice_end;
u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
if(u1_decode_nmb)
{
ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
u1_num_mbsNby2 = 0;
ps_parse_mb_data = ps_dec->ps_parse_mb_data;
ps_dec->ps_part = ps_dec->ps_parse_part_params;
if(ps_dec->u1_separate_parse)
{
ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
ps_dec->ps_nmb_info +=  u1_num_mbs;
}
else
{
ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
u1_tfr_n_mb, u1_end_of_row);
}
ps_dec->u2_total_mbs_coded += u1_num_mbs;
if(u1_tfr_n_mb)
u1_num_mbs = 0;
u1_mb_idx = u1_num_mbs;
ps_dec->u1_mb_idx = u1_num_mbs;
}
}
ps_dec->u4_num_mbs_cur_nmb = 0;
ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;
H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);
if(ps_dec->u4_first_slice_in_pic != 0)
{
ps_dec->ps_parse_cur_slice++;
ps_dec->u2_cur_slice_num++;
}
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
ps_dec->u1_pic_decode_done = 1;
}
return 0;
}","WORD32 ih264d_mark_err_slice_skip(dec_struct_t * VAR_0,
WORD32 VAR_1,
UWORD8 VAR_2,
UWORD16 VAR_3,
pocstruct_t *VAR_4,
WORD32 VAR_5)
{
WORD32 VAR_6;
UWORD32 VAR_7, VAR_8;
UWORD32 VAR_9 = VAR_0->u1_mb_idx;
UWORD32 VAR_10;
UWORD32 VAR_11, VAR_12;
const UWORD32 VAR_13 = VAR_0->u2_frm_wd_in_mbs;
UWORD32 VAR_14;
UWORD32 VAR_15;
UWORD32 VAR_16;
dec_bit_stream_t * const VAR_17 = VAR_0->ps_bitstrm;
dec_slice_params_t * VAR_18 = VAR_0->ps_cur_slice;
UWORD32 *VAR_19 = VAR_17->pu4_buffer;
UWORD32 *VAR_20 = &VAR_17->u4_ofst;
deblk_mb_t *VAR_21;
dec_mb_info_t *VAR_22;
parse_pmbarams_t *VAR_23;
UWORD32 VAR_24;
UWORD32 VAR_25;
UWORD16 VAR_26;
UWORD32 VAR_27 = VAR_18->u1_mbaff_frame_flag;
parse_part_params_t *VAR_28;
WORD32 VAR_29;
UNUSED(VAR_2);
if(VAR_0->ps_dec_err_status->u1_err_flag & VAR_30)
{
ih264d_err_pic_dispbuf_mgr(VAR_0);
return 0;
}
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag && (VAR_1 & 1))
{
VAR_1++;
}
VAR_0->ps_dpb_cmds->u1_long_term_reference_flag = 0;
if(VAR_5 == 1)
{
VAR_0->ps_cur_slice->u2_frame_num = VAR_3;
{
WORD32 VAR_31, VAR_32, VAR_33 = 0;
VAR_0->ps_cur_slice->u2_first_mb_in_slice = 0;
VAR_0->pf_mvpred = VAR_34;
VAR_0->p_form_mb_part_info = VAR_35;
VAR_0->p_motion_compensate = VAR_36;
if(VAR_0->ps_cur_pic != NULL)
VAR_33 = VAR_0->ps_cur_pic->i4_poc + 2;
VAR_32 = -1;
for(VAR_31 = 0; VAR_31 < VAR_37; VAR_31++)
{
if(VAR_0->ps_pps[VAR_31].u1_is_valid == TRUE)
{
if(VAR_0->ps_pps[VAR_31].ps_sps->u1_is_valid == TRUE)
{
VAR_32 = VAR_31;
break;
}
}
}
if(VAR_32 == -1)
{
return VAR_38;
}
if(VAR_0->u4_pic_buf_got == 0)
{
VAR_0->ps_cur_slice->u1_slice_type = VAR_39;
VAR_0->ps_cur_slice->u1_nal_ref_idc = 1;
VAR_0->ps_cur_slice->u1_nal_unit_type = 1;
VAR_29 = ih264d_start_of_pic(VAR_0, VAR_33, VAR_4,
VAR_0->ps_cur_slice->u2_frame_num,
&VAR_0->ps_pps[VAR_32]);
if(VAR_29 != VAR_40)
{
return VAR_29;
}
}
VAR_0->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;
VAR_0->u4_output_present = 0;
{
ih264d_get_next_display_field(VAR_0,
VAR_0->ps_out_buffer,
&(VAR_0->s_disp_op));
if(0 != VAR_0->s_disp_op.u4_error_code)
{
VAR_0->u4_fmt_conv_cur_row = VAR_0->s_disp_frame_info.u4_y_ht;
}
else
VAR_0->u4_output_present = 1;
}
if(VAR_0->u1_separate_parse == 1)
{
if(VAR_0->u4_dec_thread_created == 0)
{
ithread_create(VAR_0->pv_dec_thread_handle, NULL,
(void *)VAR_41,
(void *)VAR_0);
VAR_0->u4_dec_thread_created = 1;
}
if((VAR_0->u4_num_cores == 3) &&
((VAR_0->u4_app_disable_deblk_frm == 0) || VAR_0->i1_recon_in_thread3_flag)
&& (VAR_0->u4_bs_deblk_thread_created == 0))
{
VAR_0->u4_start_recon_deblk = 0;
ithread_create(VAR_0->pv_bs_deblk_thread_handle, NULL,
(void *)VAR_42,
(void *)VAR_0);
VAR_0->u4_bs_deblk_thread_created = 1;
}
}
}
VAR_0->u4_first_slice_in_pic = 0;
}
else
{
dec_slice_struct_t *VAR_43;
VAR_43 = VAR_0->ps_dec_slice_buf + VAR_0->u2_cur_slice_num;
if(VAR_0->u1_slice_header_done
&& VAR_43 == VAR_0->ps_parse_cur_slice)
{
if((VAR_27) && (VAR_0->u4_num_mbs_cur_nmb & 1))
{
VAR_0->u4_num_mbs_cur_nmb = VAR_0->u4_num_mbs_cur_nmb - 1;
VAR_0->u2_cur_mb_addr--;
}
VAR_7 = VAR_0->u4_num_mbs_cur_nmb;
if(VAR_7)
{
VAR_22 = VAR_0->ps_nmb_info + VAR_7 - 1;
}
else
{
if(VAR_0->u1_separate_parse)
{
VAR_22 = VAR_0->ps_nmb_info;
}
else
{
VAR_22 = VAR_0->ps_nmb_info
+ VAR_0->u4_num_mbs_prev_nmb - 1;
}
}
VAR_0->u2_mby = VAR_22->u2_mby;
VAR_0->u2_mbx = VAR_22->u2_mbx;
VAR_0->u1_mb_ngbr_availablity =
VAR_22->u1_mb_ngbr_availablity;
if(VAR_7)
{
VAR_0->pv_parse_tu_coeff_data = VAR_0->pv_prev_mb_parse_tu_coeff_data;
VAR_0->u2_cur_mb_addr--;
VAR_0->i4_submb_ofst -= VAR_44;
if (VAR_0->u1_pr_sl_type == VAR_39
|| VAR_0->u1_pr_sl_type == VAR_45)
{
VAR_0->pf_mvpred_ref_tfr_nby2mb(VAR_0, VAR_9,    VAR_7);
VAR_0->ps_part = VAR_0->ps_parse_part_params;
}
VAR_11 = VAR_13 - VAR_0->u2_mbx - 1;
VAR_12 = (!VAR_11)
&& (!(VAR_27 && (VAR_7 & 0x01)));
VAR_14 = 1;
VAR_15 = 1;
VAR_22->u1_end_of_slice = VAR_14;
if(VAR_0->u1_separate_parse)
{
ih264d_parse_tfr_nmb(VAR_0, VAR_9, VAR_7,
VAR_11, VAR_15, VAR_12);
VAR_0->ps_nmb_info += VAR_7;
}
else
{
ih264d_decode_recon_tfr_nmb(VAR_0, VAR_9, VAR_7,
VAR_11, VAR_15, VAR_12);
}
VAR_0->u2_total_mbs_coded += VAR_7;
VAR_0->u1_mb_idx = 0;
VAR_0->u4_num_mbs_cur_nmb = 0;
}
if(VAR_0->u2_total_mbs_coded
>= VAR_0->u2_frm_ht_in_mbs * VAR_0->u2_frm_wd_in_mbs)
{
VAR_0->u1_pic_decode_done = 1;
return 0;
}
if(VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice <
(UWORD32)(VAR_0->u2_total_mbs_coded >> VAR_18->u1_mbaff_frame_flag))
{
VAR_0->i2_prev_slice_mbx = VAR_0->u2_mbx;
VAR_0->i2_prev_slice_mby = VAR_0->u2_mby;
VAR_0->u2_cur_slice_num++;
VAR_0->ps_parse_cur_slice++;
}
}
else
{
VAR_0->ps_parse_cur_slice = VAR_0->ps_dec_slice_buf
+ VAR_0->u2_cur_slice_num;
}
}
{
WORD32 VAR_46;
WORD32 VAR_47;
UWORD8 *VAR_48;
VAR_46 = MIN(VAR_49, VAR_0->u4_num_ref_frames_at_init);
VAR_46 = 2 * ((2 * VAR_46) + 1);
VAR_47 = VAR_46 * sizeof(void *);
VAR_47 += VAR_50 * sizeof(void *);
VAR_48 = (UWORD8 *)VAR_0->pv_map_ref_idx_to_poc_buf;
VAR_48 += VAR_47 * VAR_0->u2_cur_slice_num;
VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)VAR_48;
}
VAR_0->ps_cur_slice->u2_first_mb_in_slice = VAR_0->u2_total_mbs_coded >> VAR_27;
VAR_0->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
VAR_0->ps_cur_slice->i1_slice_beta_offset = 0;
if(VAR_0->ps_cur_slice->u1_field_pic_flag)
VAR_0->u2_prv_frame_num = VAR_0->ps_cur_slice->u2_frame_num;
VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice = VAR_0->u2_total_mbs_coded >> VAR_27;
VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =    VAR_0->ps_cur_slice->u2_log2Y_crwd;
if(VAR_0->u1_separate_parse)
{
VAR_0->ps_parse_cur_slice->pv_tu_coeff_data_start = VAR_0->pv_parse_tu_coeff_data;
}
else
{
VAR_0->pv_proc_tu_coeff_data = VAR_0->pv_parse_tu_coeff_data;
}
VAR_24 = VAR_51;
VAR_25 = VAR_52;
VAR_0->ps_cur_slice->u1_slice_type = VAR_39;
VAR_0->ps_parse_cur_slice->slice_type = VAR_39;
VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_53;
VAR_0->ps_part = VAR_0->ps_parse_part_params;
VAR_0->u2_mbx =
(MOD(VAR_0->ps_cur_slice->u2_first_mb_in_slice - 1, VAR_0->u2_frm_wd_in_mbs));
VAR_0->u2_mby =
(DIV(VAR_0->ps_cur_slice->u2_first_mb_in_slice - 1, VAR_0->u2_frm_wd_in_mbs));
VAR_0->u2_mby <<= VAR_27;
VAR_0->u1_slice_header_done = 2;
VAR_0->u1_qp = VAR_18->u1_slice_qp;
ih264d_update_qp(VAR_0, 0);
VAR_9 = VAR_0->u1_mb_idx;
VAR_23 = VAR_0->ps_parse_mb_data;
VAR_7 = VAR_9;
VAR_14 = 0;
VAR_15 = 0;
VAR_16 = 0;
VAR_8 = 0;
VAR_6 = VAR_0->u2_total_mbs_coded;
VAR_10 = VAR_1;
while(!VAR_14)
{
UWORD8 VAR_54;
if(VAR_6 > VAR_0->ps_cur_sps->u2_max_mb_addr)
break;
VAR_22 = VAR_0->ps_nmb_info + VAR_7;
VAR_0->u4_num_mbs_cur_nmb = VAR_7;
VAR_22->u1_Mux = 0;
VAR_0->u4_num_pmbair = (VAR_7 >> VAR_27);
VAR_21 = VAR_0->ps_deblk_mbn + VAR_7;
VAR_22->u1_end_of_slice = 0;
VAR_23->u1_num_part = 1;
VAR_23->u1_isI_mb = 0;
if (VAR_27)
ih264d_get_mb_info_cavlc_mbaff(VAR_0, VAR_6, VAR_22, VAR_10);
else
ih264d_get_mb_info_cavlc_nonmbaff(VAR_0, VAR_6, VAR_22, VAR_10);
if(VAR_0->u4_app_disable_deblk_frm == 0)
{
ih264d_set_deblocking_parameters(VAR_21, VAR_18,
VAR_0->u1_mb_ngbr_availablity,
VAR_0->u1_cur_mb_fld_dec_flag);
}
VAR_0->i1_prev_mb_qp_delta = 0;
VAR_0->u1_sub_mb_num = 0;
VAR_22->u1_mb_type = VAR_55;
VAR_22->u1_mb_mc_mode = VAR_56;
VAR_22->u1_cbp = 0;
VAR_28 = VAR_0->ps_part;
VAR_28->u1_is_direct = VAR_57;
VAR_28->u1_sub_mb_num = 0;
VAR_0->ps_part++;
ih264d_update_nnz_for_skipmb(VAR_0, VAR_22, VAR_58);
VAR_22->ps_curmb->u1_mb_type = VAR_24;
VAR_21->u1_mb_type |= VAR_25;
VAR_10--;
VAR_21->u1_mb_qp = VAR_0->u1_qp;
if (VAR_27)
{
ih264d_update_mbaff_left_nnz(VAR_0, VAR_22);
}
VAR_6++;
VAR_7++;
VAR_8++;
VAR_23++;
VAR_11 = VAR_13 - VAR_0->u2_mbx - 1;
VAR_12 = (!VAR_11) && (!(VAR_27 && (VAR_7 & 0x01)));
VAR_14 = !VAR_10;
VAR_15 = (VAR_7 == VAR_0->u1_recon_mb_grp) || VAR_12
|| VAR_14;
VAR_16 = VAR_15 || VAR_14;
VAR_22->u1_end_of_slice = VAR_14;
if(VAR_16)
{
VAR_0->pf_mvpred_ref_tfr_nby2mb(VAR_0, VAR_9, VAR_7);
VAR_8 = 0;
VAR_23 = VAR_0->ps_parse_mb_data;
VAR_0->ps_part = VAR_0->ps_parse_part_params;
if(VAR_0->u1_separate_parse)
{
ih264d_parse_tfr_nmb(VAR_0, VAR_9, VAR_7,
VAR_11, VAR_15, VAR_12);
VAR_0->ps_nmb_info +=  VAR_7;
}
else
{
ih264d_decode_recon_tfr_nmb(VAR_0, VAR_9, VAR_7, VAR_11,
VAR_15, VAR_12);
}
VAR_0->u2_total_mbs_coded += VAR_7;
if(VAR_15)
VAR_7 = 0;
VAR_9 = VAR_7;
VAR_0->u1_mb_idx = VAR_7;
}
}
VAR_0->u4_num_mbs_cur_nmb = 0;
VAR_0->ps_cur_slice->u4_mbs_in_slice = VAR_6
- VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice;
H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", VAR_0->ps_cur_slice->u4_mbs_in_slice);
if(VAR_0->u4_first_slice_in_pic != 0)
{
VAR_0->ps_parse_cur_slice++;
VAR_0->u2_cur_slice_num++;
}
VAR_0->i2_prev_slice_mbx = VAR_0->u2_mbx;
VAR_0->i2_prev_slice_mby = VAR_0->u2_mby;
if(VAR_0->u2_total_mbs_coded
>= VAR_0->u2_frm_ht_in_mbs * VAR_0->u2_frm_wd_in_mbs)
{
VAR_0->u1_pic_decode_done = 1;
}
return 0;
}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_pslice.c/vul/before/0.json,"WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
                                WORD32 num_mb_skip,
                                UWORD8 u1_is_idr_slice,
                                UWORD16 u2_frame_num,
                                pocstruct_t *ps_cur_poc,
                                WORD32 prev_slice_err)
{
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2;
    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
    UWORD32 i2_mb_skip_run;

    UWORD32 u1_num_mbs_next, u1_end_of_row;
    const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end;
    UWORD32 u1_tfr_n_mb;
    UWORD32 u1_decode_nmb;
    dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    deblk_mb_t *ps_cur_deblk_mb;
    dec_mb_info_t *ps_cur_mb_info;
    parse_pmbarams_t *ps_parse_mb_data;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD16 u2_total_mbs_coded;
    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
    parse_part_params_t *ps_part_info;
    WORD32 ret;
    UNUSED(u1_is_idr_slice);

    if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
    {
        ih264d_err_pic_dispbuf_mgr(ps_dec);
        return 0;
    }

    if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))
    {
        num_mb_skip++;
    }
    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
    if(prev_slice_err == 1)
    {
        /* first slice - missing/header corruption */
        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
        {
            WORD32 i, j, poc = 0;

            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;

            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;

            if(ps_dec->ps_cur_pic != NULL)
                poc = ps_dec->ps_cur_pic->i4_poc + 2;

            j = -1;
            for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
            {
                   if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
                   {
                       if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)
                       {
                           j = i;
                           break;
                       }
                   }
            }

            //if valid SPS PPS is not found return error
            if(j == -1)
            {
                return ERROR_INV_SLICE_HDR_T;
            }

            /* call ih264d_start_of_pic only if it was not called earlier*/
            if(ps_dec->u4_pic_buf_got == 0)
            {
                //initialize slice params required by ih264d_start_of_pic to valid values
                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                        ps_dec->ps_cur_slice->u2_frame_num,
                        &ps_dec->ps_pps[j]);

                if(ret != OK)
                {
                    return ret;
                }
            }

            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;

            ps_dec->u4_output_present = 0;

            {
                ih264d_get_next_display_field(ps_dec,
                                              ps_dec->ps_out_buffer,
                                              &(ps_dec->s_disp_op));
                /* If error code is non-zero then there is no buffer available for display,
                 hence avoid format conversion */

                if(0 != ps_dec->s_disp_op.u4_error_code)
                {
                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
                }
                else
                    ps_dec->u4_output_present = 1;
            }

            if(ps_dec->u1_separate_parse == 1)
            {
                if(ps_dec->u4_dec_thread_created == 0)
                {
                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,
                                   (void *)ih264d_decode_picture_thread,
                                   (void *)ps_dec);

                    ps_dec->u4_dec_thread_created = 1;
                }

                if((ps_dec->u4_num_cores == 3) &&
                                ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
                                && (ps_dec->u4_bs_deblk_thread_created == 0))
                {
                    ps_dec->u4_start_recon_deblk = 0;
                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
                                   (void *)ih264d_recon_deblk_thread,
                                   (void *)ps_dec);
                    ps_dec->u4_bs_deblk_thread_created = 1;
                }
            }
        }
    }
    else
    {
        // Middle / last slice

        dec_slice_struct_t *ps_parse_cur_slice;
        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;

        if(ps_dec->u1_slice_header_done
            && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
        {
            // Slice data corrupted
            // in the case of mbaff, conceal from the even mb.
            if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))
            {
                ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;
                ps_dec->u2_cur_mb_addr--;
            }

            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;
            if(u1_num_mbs)
            {
                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
            }
            else
            {
                if(ps_dec->u1_separate_parse)
                {
                    ps_cur_mb_info = ps_dec->ps_nmb_info;
                }
                else
                {
                    ps_cur_mb_info = ps_dec->ps_nmb_info
                            + ps_dec->u4_num_mbs_prev_nmb - 1;
                }
            }

            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;

            ps_dec->u1_mb_ngbr_availablity =
                    ps_cur_mb_info->u1_mb_ngbr_availablity;

            if(u1_num_mbs)
            {
                // Going back 1 mb
                ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
                ps_dec->u2_cur_mb_addr--;
                ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;

                // Parse/decode N-MB left unparsed
                if (ps_dec->u1_pr_sl_type == P_SLICE
                        || ps_dec->u1_pr_sl_type == B_SLICE)
                {
                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                    ps_dec->ps_part = ps_dec->ps_parse_part_params;
                }

                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                u1_end_of_row = (!u1_num_mbs_next)
                        && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                u1_slice_end = 1;
                u1_tfr_n_mb = 1;
                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

                if(ps_dec->u1_separate_parse)
                {
                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                    ps_dec->ps_nmb_info += u1_num_mbs;
                }
                else
                {
                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                }
                ps_dec->u2_total_mbs_coded += u1_num_mbs;
                ps_dec->u1_mb_idx = 0;
                ps_dec->u4_num_mbs_cur_nmb = 0;
            }

            if(ps_dec->u2_total_mbs_coded
                    >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
            {
                ps_dec->u1_pic_decode_done = 1;
                return 0;
            }

            /* Inserting new slice only if the current slice has atleast 1 MB*/
            if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <
                    (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))
            {
                ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
                ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
                ps_dec->u2_cur_slice_num++;
                ps_dec->ps_parse_cur_slice++;
            }

        }
        else
        {
            // Slice missing / header corrupted
            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
                                            + ps_dec->u2_cur_slice_num;
        }
    }

    /******************************************************/
    /* Initializations to new slice                       */
    /******************************************************/
    {
        WORD32 num_entries;
        WORD32 size;
        UWORD8 *pu1_buf;

        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
        num_entries = 2 * ((2 * num_entries) + 1);

        size = num_entries * sizeof(void *);
        size += PAD_MAP_IDX_POC * sizeof(void *);

        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
        pu1_buf += size * ps_dec->u2_cur_slice_num;
        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
    }

    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;

    if(ps_dec->ps_cur_slice->u1_field_pic_flag)
        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;

    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;


    if(ps_dec->u1_separate_parse)
    {
        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
    }
    else
    {
        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
    }

    /******************************************************/
    /* Initializations specific to P slice                */
    /******************************************************/
    u1_inter_mb_type = P_MB;
    u1_deblk_mb_type = D_INTER_MB;

    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
    ps_dec->ps_part = ps_dec->ps_parse_part_params;
    ps_dec->u2_mbx =
                    (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
    ps_dec->u2_mby =
                    (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
    ps_dec->u2_mby <<= u1_mbaff;

    /******************************************************/
    /* Parsing / decoding the slice                       */
    /******************************************************/
    ps_dec->u1_slice_header_done = 2;
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    u1_num_mbs = u1_mb_idx;

    u1_slice_end = 0;
    u1_tfr_n_mb = 0;
    u1_decode_nmb = 0;
    u1_num_mbsNby2 = 0;
    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
    i2_mb_skip_run = num_mb_skip;

    while(!u1_slice_end)
    {
        UWORD8 u1_mb_type;

        if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
            break;

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

        /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

        /**************************************************************/
        /* Get the required information for decoding of MB            */
        /**************************************************************/
        /* mb_x, mb_y, neighbor availablity, */
        if (u1_mbaff)
            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
        else
            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

        /* Set the deblocking parameters for this MB */
        if(ps_dec->u4_app_disable_deblk_frm == 0)
        {
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);
        }

        /* Set appropriate flags in ps_cur_mb_info and ps_dec */
        ps_dec->i1_prev_mb_qp_delta = 0;
        ps_dec->u1_sub_mb_num = 0;
        ps_cur_mb_info->u1_mb_type = MB_SKIP;
        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
        ps_cur_mb_info->u1_cbp = 0;

        /* Storing Skip partition info */
        ps_part_info = ps_dec->ps_part;
        ps_part_info->u1_is_direct = PART_DIRECT_16x16;
        ps_part_info->u1_sub_mb_num = 0;
        ps_dec->ps_part++;

        /* Update Nnzs */
        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

        i2_mb_skip_run--;

        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

        if (u1_mbaff)
        {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
        }

        /**************************************************************/
        /* Get next Macroblock address                                */
        /**************************************************************/
        i2_cur_mb_addr++;

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

        /****************************************************************/
        /* Check for End Of Row and other flags that determine when to  */
        /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
        /* N-Mb                                                         */
        /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = !i2_mb_skip_run;
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
                        || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

        if(u1_decode_nmb)
        {
            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

            ps_parse_mb_data = ps_dec->ps_parse_mb_data;
            ps_dec->ps_part = ps_dec->ps_parse_part_params;

            if(ps_dec->u1_separate_parse)
            {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
            }
            else
            {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                            u1_tfr_n_mb, u1_end_of_row);
            }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
            if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;
        }
    }

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
                        - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;

    H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);


    /* incremented here only if first slice is inserted */
    if(ps_dec->u4_first_slice_in_pic != 0)
    {
        ps_dec->ps_parse_cur_slice++;
        ps_dec->u2_cur_slice_num++;
    }

    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

    if(ps_dec->u2_total_mbs_coded
            >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
    {
        ps_dec->u1_pic_decode_done = 1;
    }

    return 0;

}","WORD32 ih264d_mark_err_slice_skip(dec_struct_t * VAR_0,
                                WORD32 VAR_1,
                                UWORD8 VAR_2,
                                UWORD16 VAR_3,
                                pocstruct_t *VAR_4,
                                WORD32 VAR_5)
{
    WORD32 VAR_6;
    UWORD32 VAR_7, VAR_8;
    UWORD32 VAR_9 = VAR_0->u1_mb_idx;
    UWORD32 VAR_10;

    UWORD32 VAR_11, VAR_12;
    const UWORD32 VAR_13 = VAR_0->u2_frm_wd_in_mbs;
    UWORD32 VAR_14;
    UWORD32 VAR_15;
    UWORD32 VAR_16;
    dec_bit_stream_t * const VAR_17 = VAR_0->ps_bitstrm;
    dec_slice_params_t * VAR_18 = VAR_0->ps_cur_slice;
    UWORD32 *VAR_19 = VAR_17->pu4_buffer;
    UWORD32 *VAR_20 = &VAR_17->u4_ofst;
    deblk_mb_t *VAR_21;
    dec_mb_info_t *VAR_22;
    parse_pmbarams_t *VAR_23;
    UWORD32 VAR_24;
    UWORD32 VAR_25;
    UWORD16 VAR_26;
    UWORD32 VAR_27 = VAR_18->u1_mbaff_frame_flag;
    parse_part_params_t *VAR_28;
    WORD32 VAR_29;
    UNUSED(VAR_2);

    if(VAR_0->ps_dec_err_status->u1_err_flag & VAR_30)
    {
        ih264d_err_pic_dispbuf_mgr(VAR_0);
        return 0;
    }

    if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag && (VAR_1 & 1))
    {
        VAR_1++;
    }
    VAR_0->ps_dpb_cmds->u1_long_term_reference_flag = 0;
    if(VAR_5 == 1)
    {
        /* COMMENT_0 */
        VAR_0->ps_cur_slice->u2_frame_num = VAR_3;
        {
            WORD32 VAR_31, VAR_32, VAR_33 = 0;

            VAR_0->ps_cur_slice->u2_first_mb_in_slice = 0;

            VAR_0->pf_mvpred = VAR_34;
            VAR_0->p_form_mb_part_info = VAR_35;
            VAR_0->p_motion_compensate = VAR_36;

            if(VAR_0->ps_cur_pic != NULL)
                VAR_33 = VAR_0->ps_cur_pic->i4_poc + 2;

            VAR_32 = -1;
            for(VAR_31 = 0; VAR_31 < VAR_37; VAR_31++)
            {
                   if(VAR_0->ps_pps[VAR_31].u1_is_valid == TRUE)
                   {
                       if(VAR_0->ps_pps[VAR_31].ps_sps->u1_is_valid == TRUE)
                       {
                           VAR_32 = VAR_31;
                           break;
                       }
                   }
            }

            /* COMMENT_1 */
            if(VAR_32 == -1)
            {
                return VAR_38;
            }

            /* COMMENT_2 */
            if(VAR_0->u4_pic_buf_got == 0)
            {
                /* COMMENT_3 */
                VAR_0->ps_cur_slice->u1_slice_type = VAR_39;
                VAR_0->ps_cur_slice->u1_nal_ref_idc = 1;
                VAR_0->ps_cur_slice->u1_nal_unit_type = 1;
                VAR_29 = ih264d_start_of_pic(VAR_0, VAR_33, VAR_4,
                        VAR_0->ps_cur_slice->u2_frame_num,
                        &VAR_0->ps_pps[VAR_32]);

                if(VAR_29 != VAR_40)
                {
                    return VAR_29;
                }
            }

            VAR_0->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;

            VAR_0->u4_output_present = 0;

            {
                ih264d_get_next_display_field(VAR_0,
                                              VAR_0->ps_out_buffer,
                                              &(VAR_0->s_disp_op));
                /* COMMENT_4 */
                                                 

                if(0 != VAR_0->s_disp_op.u4_error_code)
                {
                    VAR_0->u4_fmt_conv_cur_row = VAR_0->s_disp_frame_info.u4_y_ht;
                }
                else
                    VAR_0->u4_output_present = 1;
            }

            if(VAR_0->u1_separate_parse == 1)
            {
                if(VAR_0->u4_dec_thread_created == 0)
                {
                    ithread_create(VAR_0->pv_dec_thread_handle, NULL,
                                   (void *)VAR_41,
                                   (void *)VAR_0);

                    VAR_0->u4_dec_thread_created = 1;
                }

                if((VAR_0->u4_num_cores == 3) &&
                                ((VAR_0->u4_app_disable_deblk_frm == 0) || VAR_0->i1_recon_in_thread3_flag)
                                && (VAR_0->u4_bs_deblk_thread_created == 0))
                {
                    VAR_0->u4_start_recon_deblk = 0;
                    ithread_create(VAR_0->pv_bs_deblk_thread_handle, NULL,
                                   (void *)VAR_42,
                                   (void *)VAR_0);
                    VAR_0->u4_bs_deblk_thread_created = 1;
                }
            }
        }
    }
    else
    {
        /* COMMENT_6 */

        dec_slice_struct_t *VAR_43;
        VAR_43 = VAR_0->ps_dec_slice_buf + VAR_0->u2_cur_slice_num;

        if(VAR_0->u1_slice_header_done
            && VAR_43 == VAR_0->ps_parse_cur_slice)
        {
            /* COMMENT_7 */
            /* COMMENT_8 */
            if((VAR_27) && (VAR_0->u4_num_mbs_cur_nmb & 1))
            {
                VAR_0->u4_num_mbs_cur_nmb = VAR_0->u4_num_mbs_cur_nmb - 1;
                VAR_0->u2_cur_mb_addr--;
            }

            VAR_7 = VAR_0->u4_num_mbs_cur_nmb;
            if(VAR_7)
            {
                VAR_22 = VAR_0->ps_nmb_info + VAR_7 - 1;
            }
            else
            {
                if(VAR_0->u1_separate_parse)
                {
                    VAR_22 = VAR_0->ps_nmb_info;
                }
                else
                {
                    VAR_22 = VAR_0->ps_nmb_info
                            + VAR_0->u4_num_mbs_prev_nmb - 1;
                }
            }

            VAR_0->u2_mby = VAR_22->u2_mby;
            VAR_0->u2_mbx = VAR_22->u2_mbx;

            VAR_0->u1_mb_ngbr_availablity =
                    VAR_22->u1_mb_ngbr_availablity;

            if(VAR_7)
            {
                /* COMMENT_9 */
                VAR_0->pv_parse_tu_coeff_data = VAR_0->pv_prev_mb_parse_tu_coeff_data;
                VAR_0->u2_cur_mb_addr--;
                VAR_0->i4_submb_ofst -= VAR_44;

                /* COMMENT_10 */
                if (VAR_0->u1_pr_sl_type == VAR_39
                        || VAR_0->u1_pr_sl_type == VAR_45)
                {
                    VAR_0->pf_mvpred_ref_tfr_nby2mb(VAR_0, VAR_9,    VAR_7);
                    VAR_0->ps_part = VAR_0->ps_parse_part_params;
                }

                VAR_11 = VAR_13 - VAR_0->u2_mbx - 1;
                VAR_12 = (!VAR_11)
                        && (!(VAR_27 && (VAR_7 & 0x01)));
                VAR_14 = 1;
                VAR_15 = 1;
                VAR_22->u1_end_of_slice = VAR_14;

                if(VAR_0->u1_separate_parse)
                {
                    ih264d_parse_tfr_nmb(VAR_0, VAR_9, VAR_7,
                            VAR_11, VAR_15, VAR_12);
                    VAR_0->ps_nmb_info += VAR_7;
                }
                else
                {
                    ih264d_decode_recon_tfr_nmb(VAR_0, VAR_9, VAR_7,
                            VAR_11, VAR_15, VAR_12);
                }
                VAR_0->u2_total_mbs_coded += VAR_7;
                VAR_0->u1_mb_idx = 0;
                VAR_0->u4_num_mbs_cur_nmb = 0;
            }

            if(VAR_0->u2_total_mbs_coded
                    >= VAR_0->u2_frm_ht_in_mbs * VAR_0->u2_frm_wd_in_mbs)
            {
                VAR_0->u1_pic_decode_done = 1;
                return 0;
            }

            /* COMMENT_11 */
            if(VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice <
                    (UWORD32)(VAR_0->u2_total_mbs_coded >> VAR_18->u1_mbaff_frame_flag))
            {
                VAR_0->i2_prev_slice_mbx = VAR_0->u2_mbx;
                VAR_0->i2_prev_slice_mby = VAR_0->u2_mby;
                VAR_0->u2_cur_slice_num++;
                VAR_0->ps_parse_cur_slice++;
            }

        }
        else
        {
            /* COMMENT_12 */
            VAR_0->ps_parse_cur_slice = VAR_0->ps_dec_slice_buf
                                            + VAR_0->u2_cur_slice_num;
        }
    }

    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_13 */
    {
        WORD32 VAR_46;
        WORD32 VAR_47;
        UWORD8 *VAR_48;

        VAR_46 = MIN(VAR_49, VAR_0->u4_num_ref_frames_at_init);
        VAR_46 = 2 * ((2 * VAR_46) + 1);

        VAR_47 = VAR_46 * sizeof(void *);
        VAR_47 += VAR_50 * sizeof(void *);

        VAR_48 = (UWORD8 *)VAR_0->pv_map_ref_idx_to_poc_buf;
        VAR_48 += VAR_47 * VAR_0->u2_cur_slice_num;
        VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)VAR_48;
    }

    VAR_0->ps_cur_slice->u2_first_mb_in_slice = VAR_0->u2_total_mbs_coded >> VAR_27;
    VAR_0->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
    VAR_0->ps_cur_slice->i1_slice_beta_offset = 0;

    if(VAR_0->ps_cur_slice->u1_field_pic_flag)
        VAR_0->u2_prv_frame_num = VAR_0->ps_cur_slice->u2_frame_num;

    VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice = VAR_0->u2_total_mbs_coded >> VAR_27;
    VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =    VAR_0->ps_cur_slice->u2_log2Y_crwd;


    if(VAR_0->u1_separate_parse)
    {
        VAR_0->ps_parse_cur_slice->pv_tu_coeff_data_start = VAR_0->pv_parse_tu_coeff_data;
    }
    else
    {
        VAR_0->pv_proc_tu_coeff_data = VAR_0->pv_parse_tu_coeff_data;
    }

    /* COMMENT_13 */
    /* COMMENT_15 */
    /* COMMENT_13 */
    VAR_24 = VAR_51;
    VAR_25 = VAR_52;

    VAR_0->ps_cur_slice->u1_slice_type = VAR_39;
    VAR_0->ps_parse_cur_slice->slice_type = VAR_39;
    VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_53;
    VAR_0->ps_part = VAR_0->ps_parse_part_params;
    VAR_0->u2_mbx =
                    (MOD(VAR_0->ps_cur_slice->u2_first_mb_in_slice - 1, VAR_0->u2_frm_wd_in_mbs));
    VAR_0->u2_mby =
                    (DIV(VAR_0->ps_cur_slice->u2_first_mb_in_slice - 1, VAR_0->u2_frm_wd_in_mbs));
    VAR_0->u2_mby <<= VAR_27;

    /* COMMENT_13 */
    /* COMMENT_16 */
    /* COMMENT_13 */
    VAR_0->u1_slice_header_done = 2;
    VAR_0->u1_qp = VAR_18->u1_slice_qp;
    ih264d_update_qp(VAR_0, 0);
    VAR_9 = VAR_0->u1_mb_idx;
    VAR_23 = VAR_0->ps_parse_mb_data;
    VAR_7 = VAR_9;

    VAR_14 = 0;
    VAR_15 = 0;
    VAR_16 = 0;
    VAR_8 = 0;
    VAR_6 = VAR_0->u2_total_mbs_coded;
    VAR_10 = VAR_1;

    while(!VAR_14)
    {
        UWORD8 VAR_54;

        if(VAR_6 > VAR_0->ps_cur_sps->u2_max_mb_addr)
            break;

        VAR_22 = VAR_0->ps_nmb_info + VAR_7;
        VAR_0->u4_num_mbs_cur_nmb = VAR_7;

        VAR_22->u1_Mux = 0;
        VAR_0->u4_num_pmbair = (VAR_7 >> VAR_27);
        VAR_21 = VAR_0->ps_deblk_mbn + VAR_7;

        VAR_22->u1_end_of_slice = 0;

        /* COMMENT_17 */
        VAR_23->u1_num_part = 1;
        VAR_23->u1_isI_mb = 0;

        /* COMMENT_18 */
        /* COMMENT_19 */
        /* COMMENT_18 */
        /* COMMENT_20 */
        if (VAR_27)
            ih264d_get_mb_info_cavlc_mbaff(VAR_0, VAR_6, VAR_22, VAR_10);
        else
            ih264d_get_mb_info_cavlc_nonmbaff(VAR_0, VAR_6, VAR_22, VAR_10);

        /* COMMENT_21 */
        if(VAR_0->u4_app_disable_deblk_frm == 0)
        {
            ih264d_set_deblocking_parameters(VAR_21, VAR_18,
                                             VAR_0->u1_mb_ngbr_availablity,
                                             VAR_0->u1_cur_mb_fld_dec_flag);
        }

        /* COMMENT_22 */
        VAR_0->i1_prev_mb_qp_delta = 0;
        VAR_0->u1_sub_mb_num = 0;
        VAR_22->u1_mb_type = VAR_55;
        VAR_22->u1_mb_mc_mode = VAR_56;
        VAR_22->u1_cbp = 0;

        /* COMMENT_23 */
        VAR_28 = VAR_0->ps_part;
        VAR_28->u1_is_direct = VAR_57;
        VAR_28->u1_sub_mb_num = 0;
        VAR_0->ps_part++;

        /* COMMENT_24 */
        ih264d_update_nnz_for_skipmb(VAR_0, VAR_22, VAR_58);

        VAR_22->ps_curmb->u1_mb_type = VAR_24;
        VAR_21->u1_mb_type |= VAR_25;

        VAR_10--;

        VAR_21->u1_mb_qp = VAR_0->u1_qp;

        if (VAR_27)
        {
            ih264d_update_mbaff_left_nnz(VAR_0, VAR_22);
        }

        /* COMMENT_18 */
        /* COMMENT_25 */
        /* COMMENT_18 */
        VAR_6++;

        VAR_7++;
        VAR_8++;
        VAR_23++;

        /* COMMENT_26 */
        /* COMMENT_27 */
        /* COMMENT_28 */
        /* COMMENT_29 */
        /* COMMENT_26 */
        VAR_11 = VAR_13 - VAR_0->u2_mbx - 1;
        VAR_12 = (!VAR_11) && (!(VAR_27 && (VAR_7 & 0x01)));
        VAR_14 = !VAR_10;
        VAR_15 = (VAR_7 == VAR_0->u1_recon_mb_grp) || VAR_12
                        || VAR_14;
        VAR_16 = VAR_15 || VAR_14;
        VAR_22->u1_end_of_slice = VAR_14;

        if(VAR_16)
        {
            VAR_0->pf_mvpred_ref_tfr_nby2mb(VAR_0, VAR_9, VAR_7);
            VAR_8 = 0;

            VAR_23 = VAR_0->ps_parse_mb_data;
            VAR_0->ps_part = VAR_0->ps_parse_part_params;

            if(VAR_0->u1_separate_parse)
            {
                ih264d_parse_tfr_nmb(VAR_0, VAR_9, VAR_7,
                                     VAR_11, VAR_15, VAR_12);
                VAR_0->ps_nmb_info +=  VAR_7;
            }
            else
            {
                ih264d_decode_recon_tfr_nmb(VAR_0, VAR_9, VAR_7, VAR_11,
                                            VAR_15, VAR_12);
            }
            VAR_0->u2_total_mbs_coded += VAR_7;
            if(VAR_15)
                VAR_7 = 0;
            VAR_9 = VAR_7;
            VAR_0->u1_mb_idx = VAR_7;
        }
    }

    VAR_0->u4_num_mbs_cur_nmb = 0;
    VAR_0->ps_cur_slice->u4_mbs_in_slice = VAR_6
                        - VAR_0->ps_parse_cur_slice->u4_first_mb_in_slice;

    H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", VAR_0->ps_cur_slice->u4_mbs_in_slice);


    /* COMMENT_30 */
    if(VAR_0->u4_first_slice_in_pic != 0)
    {
        VAR_0->ps_parse_cur_slice++;
        VAR_0->u2_cur_slice_num++;
    }

    VAR_0->i2_prev_slice_mbx = VAR_0->u2_mbx;
    VAR_0->i2_prev_slice_mby = VAR_0->u2_mby;

    if(VAR_0->u2_total_mbs_coded
            >= VAR_0->u2_frm_ht_in_mbs * VAR_0->u2_frm_wd_in_mbs)
    {
        VAR_0->u1_pic_decode_done = 1;
    }

    return 0;

}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_pslice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -135,7 +135,6 @@
                 }
             }
         }
-        ps_dec->u4_first_slice_in_pic = 0;
     }
     else
     {","{'deleted_lines': ['        ps_dec->u4_first_slice_in_pic = 0;'], 'added_lines': []}",True,"An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775.",5.5,MEDIUM,1,valid,,5
CVE-2017-0555,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Decoder: Fixed initialization of first_slice_in_pic

To handle some errors, first_slice_in_pic was being set to 2.
This is now cleaned up and first_slice_in_pic is set to 1 only once per pic.
This will ensure picture level initializations are done only once even in case
of error clips

Bug: 33717589
Bug: 33551775
Bug: 33716442
Bug: 33677995

Change-Id: If341436b3cbaa724017eedddd88c2e6fac36d8ba
",0b23c81c3dd9ec38f7e6806a3955fed1925541a0,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,decoder/ih264d_parse_headers.c,ih264d_parse_nal_unit,"WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,
ivd_video_decode_op_t *ps_dec_op,
UWORD8 *pu1_buf,
UWORD32 u4_length)
{
dec_bit_stream_t *ps_bitstrm;
dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;
ivd_video_decode_ip_t *ps_dec_in =
(ivd_video_decode_ip_t *)ps_dec->pv_dec_in;
dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
UWORD8 u1_first_byte, u1_nal_ref_idc;
UWORD8 u1_nal_unit_type;
WORD32 i_status = OK;
ps_bitstrm = ps_dec->ps_bitstrm;
if(pu1_buf)
{
if(u4_length)
{
ps_dec_op->u4_frame_decoded_flag = 0;
ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,
u4_length);
SWITCHOFFTRACE;
u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);
if(NAL_FORBIDDEN_BIT(u1_first_byte))
{
H264_DEC_DEBUG_PRINT(""\nForbidden bit set in Nal Unit, Let's try\n"");
}
u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);
if ((ps_dec->u4_slice_start_code_found == 1)
&& (ps_dec->u1_pic_decode_done != 1)
&& (u1_nal_unit_type > IDR_SLICE_NAL))
{
return ERROR_INCOMPLETE_FRAME;
}
ps_dec->u1_nal_unit_type = u1_nal_unit_type;
u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));
switch(u1_nal_unit_type)
{
case SLICE_DATA_PARTITION_A_NAL:
case SLICE_DATA_PARTITION_B_NAL:
case SLICE_DATA_PARTITION_C_NAL:
if(!ps_dec->i4_decode_header)
ih264d_parse_slice_partition(ps_dec, ps_bitstrm);
break;
case IDR_SLICE_NAL:
case SLICE_NAL:
DEBUG_THREADS_PRINTF(""Decoding  a slice NAL\n"");
if(!ps_dec->i4_decode_header)
{
if(ps_dec->i4_header_decoded == 3)
{
ps_dec->u4_slice_start_code_found = 1;
ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
i_status = ih264d_parse_decode_slice(
(UWORD8)(u1_nal_unit_type
== IDR_SLICE_NAL),
u1_nal_ref_idc, ps_dec);
if((ps_dec->u4_first_slice_in_pic != 0)&&
((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))
{
ps_dec->u4_first_slice_in_pic = 1;
}
if(i_status != OK)
{
return i_status;
}
}
else
{
H264_DEC_DEBUG_PRINT(
""\nSlice NAL Supplied but no header has been supplied\n"");
}
}
break;
case SEI_NAL:
if(!ps_dec->i4_decode_header)
{
ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);
if(i_status != OK)
return i_status;
ih264d_parse_sei(ps_dec, ps_bitstrm);
}
break;
case SEQ_PARAM_NAL:
ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);
if(i_status == ERROR_INV_SPS_PPS_T)
return i_status;
if(!i_status)
ps_dec->i4_header_decoded |= 0x1;
break;
case PIC_PARAM_NAL:
ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);
if(i_status == ERROR_INV_SPS_PPS_T)
return i_status;
if(!i_status)
ps_dec->i4_header_decoded |= 0x2;
break;
case ACCESS_UNIT_DELIMITER_RBSP:
if(!ps_dec->i4_decode_header)
{
ih264d_access_unit_delimiter_rbsp(ps_dec);
}
break;
case END_OF_STREAM_RBSP:
if(!ps_dec->i4_decode_header)
{
ih264d_parse_end_of_stream(ps_dec);
}
break;
case FILLER_DATA_NAL:
if(!ps_dec->i4_decode_header)
{
ih264d_parse_filler_data(ps_dec, ps_bitstrm);
}
break;
default:
H264_DEC_DEBUG_PRINT(""\nUnknown NAL type %d\n"", u1_nal_unit_type);
break;
}
}
}
return i_status;
}","WORD32 ih264d_parse_nal_unit(iv_obj_t *VAR_0,
ivd_video_decode_op_t *VAR_1,
UWORD8 *VAR_2,
UWORD32 VAR_3)
{
dec_bit_stream_t *VAR_4;
dec_struct_t *VAR_5 = (dec_struct_t *)VAR_0->pv_codec_handle;
ivd_video_decode_ip_t *VAR_6 =
(ivd_video_decode_ip_t *)VAR_5->pv_dec_in;
dec_slice_params_t * VAR_7 = VAR_5->ps_cur_slice;
UWORD8 VAR_8, VAR_9;
UWORD8 VAR_10;
WORD32 VAR_11 = VAR_12;
VAR_4 = VAR_5->ps_bitstrm;
if(VAR_2)
{
if(VAR_3)
{
VAR_1->u4_frame_decoded_flag = 0;
ih264d_process_nal_unit(VAR_5->ps_bitstrm, VAR_2,
VAR_3);
VAR_13;
VAR_8 = ih264d_get_bits_h264(VAR_4, 8);
if(NAL_FORBIDDEN_BIT(VAR_8))
{
H264_DEC_DEBUG_PRINT(""\nForbidden bit set in Nal Unit, Let's try\n"");
}
VAR_10 = NAL_UNIT_TYPE(VAR_8);
if ((VAR_5->u4_slice_start_code_found == 1)
&& (VAR_5->u1_pic_decode_done != 1)
&& (VAR_10 > VAR_14))
{
return VAR_15;
}
VAR_5->u1_nal_unit_type = VAR_10;
VAR_9 = (UWORD8)(NAL_REF_IDC(VAR_8));
switch(VAR_10)
{
case VAR_16:
case VAR_17:
case VAR_18:
if(!VAR_5->i4_decode_header)
ih264d_parse_slice_partition(VAR_5, VAR_4);
break;
case VAR_14:
case VAR_19:
DEBUG_THREADS_PRINTF(""Decoding  a slice NAL\n"");
if(!VAR_5->i4_decode_header)
{
if(VAR_5->i4_header_decoded == 3)
{
VAR_5->u4_slice_start_code_found = 1;
ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
VAR_11 = ih264d_parse_decode_slice(
(UWORD8)(VAR_10
== VAR_14),
VAR_9, VAR_5);
if((VAR_5->u4_first_slice_in_pic != 0)&&
((VAR_5->ps_dec_err_status->u1_err_flag & VAR_20) == 0))
{
VAR_5->u4_first_slice_in_pic = 1;
}
if(VAR_11 != VAR_12)
{
return VAR_11;
}
}
else
{
H264_DEC_DEBUG_PRINT(
""\nSlice NAL Supplied but no header has been supplied\n"");
}
}
break;
case VAR_21:
if(!VAR_5->i4_decode_header)
{
ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
VAR_11 = ih264d_parse_sei_message(VAR_5, VAR_4);
if(VAR_11 != VAR_12)
return VAR_11;
ih264d_parse_sei(VAR_5, VAR_4);
}
break;
case VAR_22:
ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
VAR_11 = ih264d_parse_sps(VAR_5, VAR_4);
if(VAR_11 == VAR_23)
return VAR_11;
if(!VAR_11)
VAR_5->i4_header_decoded |= 0x1;
break;
case VAR_24:
ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
VAR_11 = ih264d_parse_pps(VAR_5, VAR_4);
if(VAR_11 == VAR_23)
return VAR_11;
if(!VAR_11)
VAR_5->i4_header_decoded |= 0x2;
break;
case VAR_25:
if(!VAR_5->i4_decode_header)
{
ih264d_access_unit_delimiter_rbsp(VAR_5);
}
break;
case VAR_26:
if(!VAR_5->i4_decode_header)
{
ih264d_parse_end_of_stream(VAR_5);
}
break;
case VAR_27:
if(!VAR_5->i4_decode_header)
{
ih264d_parse_filler_data(VAR_5, VAR_4);
}
break;
default:
H264_DEC_DEBUG_PRINT(""\nUnknown NAL type %d\n"", VAR_10);
break;
}
}
}
return VAR_11;
}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_headers.c/vul/before/0.json,"WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,
                          ivd_video_decode_op_t *ps_dec_op,
                          UWORD8 *pu1_buf,
                          UWORD32 u4_length)
{

    dec_bit_stream_t *ps_bitstrm;


    dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;
    ivd_video_decode_ip_t *ps_dec_in =
                    (ivd_video_decode_ip_t *)ps_dec->pv_dec_in;
    dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
    UWORD8 u1_first_byte, u1_nal_ref_idc;
    UWORD8 u1_nal_unit_type;
    WORD32 i_status = OK;
    ps_bitstrm = ps_dec->ps_bitstrm;

    if(pu1_buf)
    {
        if(u4_length)
        {
            ps_dec_op->u4_frame_decoded_flag = 0;
            ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,
                                    u4_length);

            SWITCHOFFTRACE;
            u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);

            if(NAL_FORBIDDEN_BIT(u1_first_byte))
            {
                H264_DEC_DEBUG_PRINT(""\nForbidden bit set in Nal Unit, Let's try\n"");
            }
            u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);
            // if any other nal unit other than slice nal is encountered in between a
            // frame break out of loop without consuming header
            if ((ps_dec->u4_slice_start_code_found == 1)
                    && (ps_dec->u1_pic_decode_done != 1)
                    && (u1_nal_unit_type > IDR_SLICE_NAL))
            {
                return ERROR_INCOMPLETE_FRAME;
            }
            ps_dec->u1_nal_unit_type = u1_nal_unit_type;
            u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));
            //Skip all NALUs if SPS and PPS are not decoded
            switch(u1_nal_unit_type)
            {
                case SLICE_DATA_PARTITION_A_NAL:
                case SLICE_DATA_PARTITION_B_NAL:
                case SLICE_DATA_PARTITION_C_NAL:
                    if(!ps_dec->i4_decode_header)
                        ih264d_parse_slice_partition(ps_dec, ps_bitstrm);

                    break;

                case IDR_SLICE_NAL:
                case SLICE_NAL:

                    /* ! */
                    DEBUG_THREADS_PRINTF(""Decoding  a slice NAL\n"");
                    if(!ps_dec->i4_decode_header)
                    {
                        if(ps_dec->i4_header_decoded == 3)
                        {
                            /* ! */
                            ps_dec->u4_slice_start_code_found = 1;

                            ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);

                            i_status = ih264d_parse_decode_slice(
                                            (UWORD8)(u1_nal_unit_type
                                                            == IDR_SLICE_NAL),
                                            u1_nal_ref_idc, ps_dec);

                            if(i_status != OK)
                            {
                                return i_status;
                            }
                        }
                        else
                        {
                            H264_DEC_DEBUG_PRINT(
                                            ""\nSlice NAL Supplied but no header has been supplied\n"");
                        }
                    }
                    break;

                case SEI_NAL:
                    if(!ps_dec->i4_decode_header)
                    {
                        ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                        i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);
                        if(i_status != OK)
                            return i_status;
                        ih264d_parse_sei(ps_dec, ps_bitstrm);
                    }
                    break;
                case SEQ_PARAM_NAL:
                    /* ! */
                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                    i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);
                    if(i_status == ERROR_INV_SPS_PPS_T)
                        return i_status;
                    if(!i_status)
                        ps_dec->i4_header_decoded |= 0x1;
                    break;

                case PIC_PARAM_NAL:
                    /* ! */
                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                    i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);
                    if(i_status == ERROR_INV_SPS_PPS_T)
                        return i_status;
                    if(!i_status)
                        ps_dec->i4_header_decoded |= 0x2;
                    break;
                case ACCESS_UNIT_DELIMITER_RBSP:
                    if(!ps_dec->i4_decode_header)
                    {
                        ih264d_access_unit_delimiter_rbsp(ps_dec);
                    }
                    break;
                    //Let us ignore the END_OF_SEQ_RBSP NAL and decode even after this NAL
                case END_OF_STREAM_RBSP:
                    if(!ps_dec->i4_decode_header)
                    {
                        ih264d_parse_end_of_stream(ps_dec);
                    }
                    break;
                case FILLER_DATA_NAL:
                    if(!ps_dec->i4_decode_header)
                    {
                        ih264d_parse_filler_data(ps_dec, ps_bitstrm);
                    }
                    break;
                default:
                    H264_DEC_DEBUG_PRINT(""\nUnknown NAL type %d\n"", u1_nal_unit_type);
                    break;
            }

        }

    }

    return i_status;

}","WORD32 ih264d_parse_nal_unit(iv_obj_t *VAR_0,
                          ivd_video_decode_op_t *VAR_1,
                          UWORD8 *VAR_2,
                          UWORD32 VAR_3)
{

    dec_bit_stream_t *VAR_4;


    dec_struct_t *VAR_5 = (dec_struct_t *)VAR_0->pv_codec_handle;
    ivd_video_decode_ip_t *VAR_6 =
                    (ivd_video_decode_ip_t *)VAR_5->pv_dec_in;
    dec_slice_params_t * VAR_7 = VAR_5->ps_cur_slice;
    UWORD8 VAR_8, VAR_9;
    UWORD8 VAR_10;
    WORD32 VAR_11 = VAR_12;
    VAR_4 = VAR_5->ps_bitstrm;

    if(VAR_2)
    {
        if(VAR_3)
        {
            VAR_1->u4_frame_decoded_flag = 0;
            ih264d_process_nal_unit(VAR_5->ps_bitstrm, VAR_2,
                                    VAR_3);

            VAR_13;
            VAR_8 = ih264d_get_bits_h264(VAR_4, 8);

            if(NAL_FORBIDDEN_BIT(VAR_8))
            {
                H264_DEC_DEBUG_PRINT(""\nForbidden bit set in Nal Unit, Let's try\n"");
            }
            VAR_10 = NAL_UNIT_TYPE(VAR_8);
            /* COMMENT_0 */
            /* COMMENT_1 */
            if ((VAR_5->u4_slice_start_code_found == 1)
                    && (VAR_5->u1_pic_decode_done != 1)
                    && (VAR_10 > VAR_14))
            {
                return VAR_15;
            }
            VAR_5->u1_nal_unit_type = VAR_10;
            VAR_9 = (UWORD8)(NAL_REF_IDC(VAR_8));
            /* COMMENT_2 */
            switch(VAR_10)
            {
                case VAR_16:
                case VAR_17:
                case VAR_18:
                    if(!VAR_5->i4_decode_header)
                        ih264d_parse_slice_partition(VAR_5, VAR_4);

                    break;

                case VAR_14:
                case VAR_19:

                    /* COMMENT_3 */
                    DEBUG_THREADS_PRINTF(""Decoding  a slice NAL\n"");
                    if(!VAR_5->i4_decode_header)
                    {
                        if(VAR_5->i4_header_decoded == 3)
                        {
                            /* COMMENT_3 */
                            VAR_5->u4_slice_start_code_found = 1;

                            ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);

                            VAR_11 = ih264d_parse_decode_slice(
                                            (UWORD8)(VAR_10
                                                            == VAR_14),
                                            VAR_9, VAR_5);

                            if(VAR_11 != VAR_12)
                            {
                                return VAR_11;
                            }
                        }
                        else
                        {
                            H264_DEC_DEBUG_PRINT(
                                            ""\nSlice NAL Supplied but no header has been supplied\n"");
                        }
                    }
                    break;

                case VAR_20:
                    if(!VAR_5->i4_decode_header)
                    {
                        ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
                        VAR_11 = ih264d_parse_sei_message(VAR_5, VAR_4);
                        if(VAR_11 != VAR_12)
                            return VAR_11;
                        ih264d_parse_sei(VAR_5, VAR_4);
                    }
                    break;
                case VAR_21:
                    /* COMMENT_3 */
                    ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
                    VAR_11 = ih264d_parse_sps(VAR_5, VAR_4);
                    if(VAR_11 == VAR_22)
                        return VAR_11;
                    if(!VAR_11)
                        VAR_5->i4_header_decoded |= 0x1;
                    break;

                case VAR_23:
                    /* COMMENT_3 */
                    ih264d_rbsp_to_sodb(VAR_5->ps_bitstrm);
                    VAR_11 = ih264d_parse_pps(VAR_5, VAR_4);
                    if(VAR_11 == VAR_22)
                        return VAR_11;
                    if(!VAR_11)
                        VAR_5->i4_header_decoded |= 0x2;
                    break;
                case VAR_24:
                    if(!VAR_5->i4_decode_header)
                    {
                        ih264d_access_unit_delimiter_rbsp(VAR_5);
                    }
                    break;
                    /* COMMENT_4 */
                case VAR_25:
                    if(!VAR_5->i4_decode_header)
                    {
                        ih264d_parse_end_of_stream(VAR_5);
                    }
                    break;
                case VAR_26:
                    if(!VAR_5->i4_decode_header)
                    {
                        ih264d_parse_filler_data(VAR_5, VAR_4);
                    }
                    break;
                default:
                    H264_DEC_DEBUG_PRINT(""\nUnknown NAL type %d\n"", VAR_10);
                    break;
            }

        }

    }

    return VAR_11;

}",android/0b23c81c3dd9ec38f7e6806a3955fed1925541a0/ih264d_parse_headers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,13 +72,6 @@
                                                             == IDR_SLICE_NAL),
                                             u1_nal_ref_idc, ps_dec);
 
-                            if((ps_dec->u4_first_slice_in_pic != 0)&&
-                                ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))
-                            {
-                                /*  if the first slice header was not valid set to 1 */
-                                ps_dec->u4_first_slice_in_pic = 1;
-                            }
-
                             if(i_status != OK)
                             {
                                 return i_status;","{'deleted_lines': ['                            if((ps_dec->u4_first_slice_in_pic != 0)&&', '                                ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))', '                            {', '                                /*  if the first slice header was not valid set to 1 */', '                                ps_dec->u4_first_slice_in_pic = 1;', '                            }', ''], 'added_lines': []}",True,"An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775.",5.5,MEDIUM,1,valid,,5
CVE-2016-10328,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,freetype/freetype2,"* src/cff/cffparse.c (cff_parser_run): Add one more stack size
check.
",beecf80a6deecbaf5d264d4f864451bde4fe98b8,http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=beecf80a6deecbaf5d264d4f864451bde4fe98b8,src/cff/cffparse.c,cff_parser_run,"FT_LOCAL_DEF( FT_Error )
cff_parser_run( CFF_Parser  parser,
FT_Byte*    start,
FT_Byte*    limit )
{
FT_Byte*    p       = start;
FT_Error    error   = FT_Err_Ok;
FT_Library  library = parser->library;
FT_UNUSED( library );
parser->top    = parser->stack;
parser->start  = start;
parser->limit  = limit;
parser->cursor = start;
while ( p < limit )
{
FT_UInt  v = *p;
if ( v >= 27 && v != 31 && v != 255 )
{
if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
goto Stack_Overflow;
*parser->top++ = p;
if ( v == 30 )
{
p++;
for (;;)
{
if ( p >= limit )
goto Exit;
v = p[0] >> 4;
if ( v == 15 )
break;
v = p[0] & 0xF;
if ( v == 15 )
break;
p++;
}
}
else if ( v == 28 )
p += 2;
else if ( v == 29 )
p += 4;
else if ( v > 246 )
p += 1;
}
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
else if ( v == 31 )
{
CFF_Decoder  decoder;
CFF_FontRec  cff_rec;
FT_Byte*     charstring_base;
FT_ULong     charstring_len;
FT_Fixed*  stack;
FT_Byte*   q;
charstring_base = ++p;
for (;;)
{
if ( p >= limit )
goto Exit;
if ( *p == 14 )
break;
p++;
}
charstring_len = (FT_ULong)( p - charstring_base ) + 1;
FT_ZERO( &decoder );
FT_ZERO( &cff_rec );
cff_rec.top_font.font_dict.num_designs = parser->num_designs;
cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
decoder.cff                            = &cff_rec;
error = cff_decoder_parse_charstrings( &decoder,
charstring_base,
charstring_len,
1 );
q     = charstring_base - 1;
stack = decoder.stack;
while ( stack < decoder.top )
{
FT_ULong  num;
FT_Bool   neg;
if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
goto Stack_Overflow;
*parser->top++ = q;
if ( *stack < 0 )
{
num = (FT_ULong)-*stack;
neg = 1;
}
else
{
num = (FT_ULong)*stack;
neg = 0;
}
if ( num & 0xFFFFU )
{
if ( neg )
num = (FT_ULong)-num;
*q++ = 255;
*q++ = ( num & 0xFF000000U ) >> 24;
*q++ = ( num & 0x00FF0000U ) >> 16;
*q++ = ( num & 0x0000FF00U ) >>  8;
*q++ =   num & 0x000000FFU;
}
else
{
num >>= 16;
if ( neg )
{
if ( num <= 107 )
*q++ = (FT_Byte)( 139 - num );
else if ( num <= 1131 )
{
*q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
*q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
}
else
{
num = (FT_ULong)-num;
*q++ = 28;
*q++ = (FT_Byte)( num >> 8 );
*q++ = (FT_Byte)( num & 0xFF );
}
}
else
{
if ( num <= 107 )
*q++ = (FT_Byte)( num + 139 );
else if ( num <= 1131 )
{
*q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
*q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
}
else
{
*q++ = 28;
*q++ = (FT_Byte)( num >> 8 );
*q++ = (FT_Byte)( num & 0xFF );
}
}
}
stack++;
}
}
#endif 
else
{
FT_UInt                   code;
FT_UInt                   num_args = (FT_UInt)
( parser->top - parser->stack );
const CFF_Field_Handler*  field;
*parser->top = p;
code = v;
if ( v == 12 )
{
p++;
if ( p >= limit )
goto Syntax_Error;
code = 0x100 | p[0];
}
code = code | parser->object_code;
for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
{
if ( field->code == (FT_Int)code )
{
FT_Long   val;
FT_Byte*  q = (FT_Byte*)parser->object + field->offset;
#ifdef FT_DEBUG_LEVEL_TRACE
FT_TRACE4(( ""  %s"", field->id ));
#endif
if ( field->kind != cff_kind_delta && num_args < 1 )
goto Stack_Underflow;
switch ( field->kind )
{
case cff_kind_bool:
case cff_kind_string:
case cff_kind_num:
val = cff_parse_num( parser, parser->stack );
goto Store_Number;
case cff_kind_fixed:
val = cff_parse_fixed( parser, parser->stack );
goto Store_Number;
case cff_kind_fixed_thousand:
val = cff_parse_fixed_scaled( parser, parser->stack, 3 );
Store_Number:
switch ( field->size )
{
case (8 / FT_CHAR_BIT):
*(FT_Byte*)q = (FT_Byte)val;
break;
case (16 / FT_CHAR_BIT):
*(FT_Short*)q = (FT_Short)val;
break;
case (32 / FT_CHAR_BIT):
*(FT_Int32*)q = (FT_Int)val;
break;
default:  
*(FT_Long*)q = val;
}
#ifdef FT_DEBUG_LEVEL_TRACE
switch ( field->kind )
{
case cff_kind_bool:
FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
break;
case cff_kind_string:
FT_TRACE4(( "" %ld (SID)\n"", val ));
break;
case cff_kind_num:
FT_TRACE4(( "" %ld\n"", val ));
break;
case cff_kind_fixed:
FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
break;
case cff_kind_fixed_thousand:
FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));
default:
; 
}
#endif
break;
case cff_kind_delta:
{
FT_Byte*   qcount = (FT_Byte*)parser->object +
field->count_offset;
FT_Byte**  data = parser->stack;
if ( num_args > field->array_max )
num_args = field->array_max;
FT_TRACE4(( "" ["" ));
*qcount = (FT_Byte)num_args;
val = 0;
while ( num_args > 0 )
{
val += cff_parse_num( parser, data++ );
switch ( field->size )
{
case (8 / FT_CHAR_BIT):
*(FT_Byte*)q = (FT_Byte)val;
break;
case (16 / FT_CHAR_BIT):
*(FT_Short*)q = (FT_Short)val;
break;
case (32 / FT_CHAR_BIT):
*(FT_Int32*)q = (FT_Int)val;
break;
default:  
*(FT_Long*)q = val;
}
FT_TRACE4(( "" %ld"", val ));
q += field->size;
num_args--;
}
FT_TRACE4(( ""]\n"" ));
}
break;
default:  
error = field->reader( parser );
if ( error )
goto Exit;
}
goto Found;
}
}
Found:
if ( field->kind != cff_kind_blend )
parser->top = parser->stack;
}
p++;
}
Exit:
return error;
Stack_Overflow:
error = FT_THROW( Invalid_Argument );
goto Exit;
Stack_Underflow:
error = FT_THROW( Invalid_Argument );
goto Exit;
Syntax_Error:
error = FT_THROW( Invalid_Argument );
goto Exit;
}","VAR_0( FT_Error )
cff_parser_run( CFF_Parser  VAR_1,
FT_Byte*    VAR_2,
FT_Byte*    VAR_3 )
{
FT_Byte*    VAR_4       = VAR_2;
FT_Error    VAR_5   = VAR_6;
FT_Library  VAR_7 = VAR_1->library;
FT_UNUSED( VAR_7 );
VAR_1->top    = VAR_1->stack;
VAR_1->start  = VAR_2;
VAR_1->limit  = VAR_3;
VAR_1->cursor = VAR_2;
while ( VAR_4 < VAR_3 )
{
FT_UInt  VAR_8 = *VAR_4;
if ( VAR_8 >= 27 && VAR_8 != 31 && VAR_8 != 255 )
{
if ( (FT_UInt)( VAR_1->top - VAR_1->stack ) >= VAR_1->stackSize )
goto Stack_Overflow;
*VAR_1->top++ = VAR_4;
if ( VAR_8 == 30 )
{
VAR_4++;
for (;;)
{
if ( VAR_4 >= VAR_3 )
goto Exit;
VAR_8 = VAR_4[0] >> 4;
if ( VAR_8 == 15 )
break;
VAR_8 = VAR_4[0] & 0xF;
if ( VAR_8 == 15 )
break;
VAR_4++;
}
}
else if ( VAR_8 == 28 )
VAR_4 += 2;
else if ( VAR_8 == 29 )
VAR_4 += 4;
else if ( VAR_8 > 246 )
VAR_4 += 1;
}
#ifdef VAR_9
else if ( v == 31 )
{
CFF_Decoder  VAR_10;
CFF_FontRec  VAR_11;
FT_Byte*     VAR_12;
FT_ULong     VAR_13;
FT_Fixed*  VAR_14;
FT_Byte*   VAR_15;
VAR_12 = ++VAR_4;
for (;;)
{
if ( VAR_4 >= VAR_3 )
goto Exit;
if ( *VAR_4 == 14 )
break;
VAR_4++;
}
VAR_13 = (FT_ULong)( VAR_4 - VAR_12 ) + 1;
FT_ZERO( &VAR_10 );
FT_ZERO( &VAR_11 );
VAR_11.top_font.font_dict.num_designs = VAR_1->num_designs;
VAR_11.top_font.font_dict.num_axes    = VAR_1->num_axes;
VAR_10.cff                            = &VAR_11;
VAR_5 = cff_decoder_parse_charstrings( &VAR_10,
VAR_12,
VAR_13,
1 );
VAR_15     = VAR_12 - 1;
VAR_14 = VAR_10.stack;
while ( VAR_14 < VAR_10.top )
{
FT_ULong  VAR_16;
FT_Bool   VAR_17;
if ( (FT_UInt)( VAR_1->top - VAR_1->stack ) >= VAR_1->stackSize )
goto Stack_Overflow;
*VAR_1->top++ = VAR_15;
if ( *VAR_14 < 0 )
{
VAR_16 = (FT_ULong)-*VAR_14;
VAR_17 = 1;
}
else
{
VAR_16 = (FT_ULong)*VAR_14;
VAR_17 = 0;
}
if ( VAR_16 & 0xFFFFU )
{
if ( VAR_17 )
VAR_16 = (FT_ULong)-VAR_16;
*VAR_15++ = 255;
*VAR_15++ = ( VAR_16 & 0xFF000000U ) >> 24;
*VAR_15++ = ( VAR_16 & 0x00FF0000U ) >> 16;
*VAR_15++ = ( VAR_16 & 0x0000FF00U ) >>  8;
*VAR_15++ =   VAR_16 & 0x000000FFU;
}
else
{
VAR_16 >>= 16;
if ( VAR_17 )
{
if ( VAR_16 <= 107 )
*VAR_15++ = (FT_Byte)( 139 - VAR_16 );
else if ( VAR_16 <= 1131 )
{
*VAR_15++ = (FT_Byte)( ( ( VAR_16 - 108 ) >> 8 ) + 251 );
*VAR_15++ = (FT_Byte)( ( VAR_16 - 108 ) & 0xFF );
}
else
{
VAR_16 = (FT_ULong)-VAR_16;
*VAR_15++ = 28;
*VAR_15++ = (FT_Byte)( VAR_16 >> 8 );
*VAR_15++ = (FT_Byte)( VAR_16 & 0xFF );
}
}
else
{
if ( VAR_16 <= 107 )
*VAR_15++ = (FT_Byte)( VAR_16 + 139 );
else if ( VAR_16 <= 1131 )
{
*VAR_15++ = (FT_Byte)( ( ( VAR_16 - 108 ) >> 8 ) + 247 );
*VAR_15++ = (FT_Byte)( ( VAR_16 - 108 ) & 0xFF );
}
else
{
*VAR_15++ = 28;
*VAR_15++ = (FT_Byte)( VAR_16 >> 8 );
*VAR_15++ = (FT_Byte)( VAR_16 & 0xFF );
}
}
}
VAR_14++;
}
}
#endif 
else
{
FT_UInt                   VAR_18;
FT_UInt                   VAR_19 = (FT_UInt)
( VAR_1->top - VAR_1->stack );
const CFF_Field_Handler*  VAR_20;
*VAR_1->top = VAR_4;
VAR_18 = v;
if ( v == 12 )
{
VAR_4++;
if ( VAR_4 >= VAR_3 )
goto Syntax_Error;
VAR_18 = 0x100 | VAR_4[0];
}
VAR_18 = VAR_18 | VAR_1->object_code;
for ( VAR_20 = VAR_21; VAR_20->kind; VAR_20++ )
{
if ( VAR_20->code == (FT_Int)VAR_18 )
{
FT_Long   VAR_22;
FT_Byte*  VAR_15 = (FT_Byte*)VAR_1->object + VAR_20->offset;
#ifdef VAR_23
FT_TRACE4(( ""  %s"", VAR_20->id ));
#endif
if ( VAR_20->kind != VAR_24 && VAR_19 < 1 )
goto Stack_Underflow;
switch ( VAR_20->kind )
{
case VAR_25:
case VAR_26:
case VAR_27:
VAR_22 = cff_parse_num( VAR_1, VAR_1->stack );
goto Store_Number;
case VAR_28:
VAR_22 = cff_parse_fixed( VAR_1, VAR_1->stack );
goto Store_Number;
case VAR_29:
VAR_22 = cff_parse_fixed_scaled( VAR_1, VAR_1->stack, 3 );
Store_Number:
switch ( VAR_20->size )
{
case (8 / VAR_30):
*(FT_Byte*)VAR_15 = (FT_Byte)VAR_22;
break;
case (16 / VAR_30):
*(FT_Short*)VAR_15 = (FT_Short)VAR_22;
break;
case (32 / VAR_30):
*(FT_Int32*)VAR_15 = (FT_Int)VAR_22;
break;
default:  
*(FT_Long*)VAR_15 = VAR_22;
}
#ifdef VAR_23
switch ( VAR_20->kind )
{
case VAR_25:
FT_TRACE4(( "" %s\n"", VAR_22 ? ""true"" : ""false"" ));
break;
case VAR_26:
FT_TRACE4(( "" %ld (SID)\n"", VAR_22 ));
break;
case VAR_27:
FT_TRACE4(( "" %ld\n"", VAR_22 ));
break;
case VAR_28:
FT_TRACE4(( "" %f\n"", (double)VAR_22 / 65536 ));
break;
case VAR_29:
FT_TRACE4(( "" %f\n"", (double)VAR_22 / 65536 / 1000 ));
default:
; 
}
#endif
break;
case VAR_24:
{
FT_Byte*   VAR_31 = (FT_Byte*)VAR_1->object +
VAR_20->count_offset;
FT_Byte**  VAR_32 = VAR_1->stack;
if ( VAR_19 > VAR_20->array_max )
VAR_19 = VAR_20->array_max;
FT_TRACE4(( "" ["" ));
*VAR_31 = (FT_Byte)VAR_19;
VAR_22 = 0;
while ( VAR_19 > 0 )
{
VAR_22 += cff_parse_num( VAR_1, VAR_32++ );
switch ( VAR_20->size )
{
case (8 / VAR_30):
*(FT_Byte*)VAR_15 = (FT_Byte)VAR_22;
break;
case (16 / VAR_30):
*(FT_Short*)VAR_15 = (FT_Short)VAR_22;
break;
case (32 / VAR_30):
*(FT_Int32*)VAR_15 = (FT_Int)VAR_22;
break;
default:  
*(FT_Long*)VAR_15 = VAR_22;
}
FT_TRACE4(( "" %ld"", VAR_22 ));
VAR_15 += VAR_20->size;
VAR_19--;
}
FT_TRACE4(( ""]\n"" ));
}
break;
default:  
VAR_5 = VAR_20->reader( VAR_1 );
if ( VAR_5 )
goto Exit;
}
goto Found;
}
}
Found:
if ( VAR_20->kind != VAR_33 )
VAR_1->top = VAR_1->stack;
}
VAR_4++;
}
Exit:
return VAR_5;
Stack_Overflow:
VAR_5 = FT_THROW( VAR_34 );
goto Exit;
Stack_Underflow:
VAR_5 = FT_THROW( VAR_34 );
goto Exit;
Syntax_Error:
VAR_5 = FT_THROW( VAR_34 );
goto Exit;
}",,"FT_LOCAL_DEF( FT_Error )
  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
        /* and look for it in our current list.                            */

        FT_UInt                   code;
        FT_UInt                   num_args;
        const CFF_Field_Handler*  field;


        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        num_args     = (FT_UInt)( parser->top - parser->stack );
        *parser->top = p;
        code         = v;

        if ( v == 12 )
        {
          /* two byte operator */
          p++;
          if ( p >= limit )
            goto Syntax_Error;

          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }","VAR_0( FT_Error )
  cff_parser_run( CFF_Parser  VAR_1,
                  FT_Byte*    VAR_2,
                  FT_Byte*    VAR_3 )
  {
    FT_Byte*    VAR_4       = VAR_2;
    FT_Error    VAR_5   = VAR_6;
    FT_Library  VAR_7 = VAR_1->library;
    FT_UNUSED( VAR_7 );


    VAR_1->top    = VAR_1->stack;
    VAR_1->start  = VAR_2;
    VAR_1->limit  = VAR_3;
    VAR_1->cursor = VAR_2;

    while ( VAR_4 < VAR_3 )
    {
      FT_UInt  VAR_8 = *VAR_4;

      /* COMMENT_0 */
      /* COMMENT_1 */
      /* COMMENT_2 */
      if ( VAR_8 >= 27 && VAR_8 != 31 && VAR_8 != 255 )
      {
        /* COMMENT_3 */
        if ( (FT_UInt)( VAR_1->top - VAR_1->stack ) >= VAR_1->stackSize )
          goto Stack_Overflow;

        *VAR_1->top++ = VAR_4;

        /* COMMENT_4 */
        if ( VAR_8 == 30 )
        {
          /* COMMENT_5 */
          VAR_4++;
          for (;;)
          {
            /* COMMENT_6 */
            /* COMMENT_7 */
            if ( VAR_4 >= VAR_3 )
              goto Exit;
            VAR_8 = VAR_4[0] >> 4;
            if ( VAR_8 == 15 )
              break;
            VAR_8 = VAR_4[0] & 0xF;
            if ( VAR_8 == 15 )
              break;
            VAR_4++;
          }
        }
        else if ( VAR_8 == 28 )
          VAR_4 += 2;
        else if ( VAR_8 == 29 )
          VAR_4 += 4;
        else if ( VAR_8 > 246 )
          VAR_4 += 1;
      }
#ifdef VAR_9
      else if ( v == 31 )
      {
        /* COMMENT_8 */

        CFF_Decoder  VAR_10;
        CFF_FontRec  VAR_11;
        FT_Byte*     VAR_12;
        FT_ULong     VAR_13;

        FT_Fixed*  VAR_14;
        FT_Byte*   VAR_15;


        VAR_12 = ++VAR_4;

        /* COMMENT_9 */
        for (;;)
        {
          if ( VAR_4 >= VAR_3 )
            goto Exit;
          if ( *VAR_4 == 14 )
            break;
          VAR_4++;
        }

        VAR_13 = (FT_ULong)( VAR_4 - VAR_12 ) + 1;

        /* COMMENT_10 */
        FT_ZERO( &VAR_10 );
        FT_ZERO( &VAR_11 );

        VAR_11.top_font.font_dict.num_designs = VAR_1->num_designs;
        VAR_11.top_font.font_dict.num_axes    = VAR_1->num_axes;
        VAR_10.cff                            = &VAR_11;

        VAR_5 = cff_decoder_parse_charstrings( &VAR_10,
                                               VAR_12,
                                               VAR_13,
                                               1 );

        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_15 */
        /* COMMENT_16 */
        /* COMMENT_17 */
        /* COMMENT_18 */

        VAR_15     = VAR_12 - 1;
        VAR_14 = VAR_10.stack;

        while ( VAR_14 < VAR_10.top )
        {
          FT_ULong  VAR_16;
          FT_Bool   VAR_17;


          if ( (FT_UInt)( VAR_1->top - VAR_1->stack ) >= VAR_1->stackSize )
            goto Stack_Overflow;

          *VAR_1->top++ = VAR_15;

          if ( *VAR_14 < 0 )
          {
            VAR_16 = (FT_ULong)-*VAR_14;
            VAR_17 = 1;
          }
          else
          {
            VAR_16 = (FT_ULong)*VAR_14;
            VAR_17 = 0;
          }

          if ( VAR_16 & 0xFFFFU )
          {
            if ( VAR_17 )
              VAR_16 = (FT_ULong)-VAR_16;

            *VAR_15++ = 255;
            *VAR_15++ = ( VAR_16 & 0xFF000000U ) >> 24;
            *VAR_15++ = ( VAR_16 & 0x00FF0000U ) >> 16;
            *VAR_15++ = ( VAR_16 & 0x0000FF00U ) >>  8;
            *VAR_15++ =   VAR_16 & 0x000000FFU;
          }
          else
          {
            VAR_16 >>= 16;

            if ( VAR_17 )
            {
              if ( VAR_16 <= 107 )
                *VAR_15++ = (FT_Byte)( 139 - VAR_16 );
              else if ( VAR_16 <= 1131 )
              {
                *VAR_15++ = (FT_Byte)( ( ( VAR_16 - 108 ) >> 8 ) + 251 );
                *VAR_15++ = (FT_Byte)( ( VAR_16 - 108 ) & 0xFF );
              }
              else
              {
                VAR_16 = (FT_ULong)-VAR_16;

                *VAR_15++ = 28;
                *VAR_15++ = (FT_Byte)( VAR_16 >> 8 );
                *VAR_15++ = (FT_Byte)( VAR_16 & 0xFF );
              }
            }
            else
            {
              if ( VAR_16 <= 107 )
                *VAR_15++ = (FT_Byte)( VAR_16 + 139 );
              else if ( VAR_16 <= 1131 )
              {
                *VAR_15++ = (FT_Byte)( ( ( VAR_16 - 108 ) >> 8 ) + 247 );
                *VAR_15++ = (FT_Byte)( ( VAR_16 - 108 ) & 0xFF );
              }
              else
              {
                *VAR_15++ = 28;
                *VAR_15++ = (FT_Byte)( VAR_16 >> 8 );
                *VAR_15++ = (FT_Byte)( VAR_16 & 0xFF );
              }
            }
          }

          VAR_14++;
        }
      }
#endif /* COMMENT_19 */
      else
      {
        /* COMMENT_20 */
        /* COMMENT_21 */

        FT_UInt                   VAR_18;
        FT_UInt                   VAR_19;
        const CFF_Field_Handler*  VAR_20;


        if ( (FT_UInt)( VAR_1->top - VAR_1->stack ) >= VAR_1->stackSize )
          goto Stack_Overflow;

        VAR_19     = (FT_UInt)( VAR_1->top - VAR_1->stack );
        *VAR_1->top = VAR_4;
        VAR_18         = v;

        if ( v == 12 )
        {
          /* COMMENT_22 */
          VAR_4++;
          if ( VAR_4 >= VAR_3 )
            goto Syntax_Error;

          VAR_18 = 0x100 | VAR_4[0];
        }
        VAR_18 = VAR_18 | VAR_1->object_code;

        for ( VAR_20 = VAR_21; VAR_20->kind; VAR_20++ )
        {
          if ( VAR_20->code == (FT_Int)VAR_18 )
          {
            /* COMMENT_23 */
            FT_Long   VAR_22;
            FT_Byte*  VAR_15 = (FT_Byte*)VAR_1->object + VAR_20->offset;


#ifdef VAR_23
            FT_TRACE4(( ""  %s"", VAR_20->id ));
#endif

            /* COMMENT_24 */
            /* COMMENT_25 */
            if ( VAR_20->kind != VAR_24 && VAR_19 < 1 )
              goto Stack_Underflow;

            switch ( VAR_20->kind )
            {
            case VAR_25:
            case VAR_26:
            case VAR_27:
              VAR_22 = cff_parse_num( VAR_1, VAR_1->stack );
              goto Store_Number;

            case VAR_28:
              VAR_22 = cff_parse_fixed( VAR_1, VAR_1->stack );
              goto Store_Number;

            case VAR_29:
              VAR_22 = cff_parse_fixed_scaled( VAR_1, VAR_1->stack, 3 );

            Store_Number:
              switch ( VAR_20->size )
              {
              case (8 / VAR_30):
                *(FT_Byte*)VAR_15 = (FT_Byte)VAR_22;
                break;

              case (16 / VAR_30):
                *(FT_Short*)VAR_15 = (FT_Short)VAR_22;
                break;

              case (32 / VAR_30):
                *(FT_Int32*)VAR_15 = (FT_Int)VAR_22;
                break;

              default:  /* COMMENT_26 */
                *(FT_Long*)VAR_15 = VAR_22;
              }

#ifdef VAR_23
              switch ( VAR_20->kind )
              {
              case VAR_25:
                FT_TRACE4(( "" %s\n"", VAR_22 ? ""true"" : ""false"" ));
                break;

              case VAR_26:
                FT_TRACE4(( "" %ld (SID)\n"", VAR_22 ));
                break;

              case VAR_27:
                FT_TRACE4(( "" %ld\n"", VAR_22 ));
                break;

              case VAR_28:
                FT_TRACE4(( "" %f\n"", (double)VAR_22 / 65536 ));
                break;

              case VAR_29:
                FT_TRACE4(( "" %f\n"", (double)VAR_22 / 65536 / 1000 ));

              default:
                ; /* COMMENT_27 */
              }
#endif

              break;

            case VAR_24:
              {
                FT_Byte*   VAR_31 = (FT_Byte*)VAR_1->object +
                                      VAR_20->count_offset;

                FT_Byte**  VAR_32 = VAR_1->stack;


                if ( VAR_19 > VAR_20->array_max )
                  VAR_19 = VAR_20->array_max;

                FT_TRACE4(( "" ["" ));

                /* COMMENT_28 */
                *VAR_31 = (FT_Byte)VAR_19;

                VAR_22 = 0;
                while ( VAR_19 > 0 )
                {
                  VAR_22 += cff_parse_num( VAR_1, VAR_32++ );
                  switch ( VAR_20->size )
                  {
                  case (8 / VAR_30):
                    *(FT_Byte*)VAR_15 = (FT_Byte)VAR_22;
                    break;

                  case (16 / VAR_30):
                    *(FT_Short*)VAR_15 = (FT_Short)VAR_22;
                    break;

                  case (32 / VAR_30):
                    *(FT_Int32*)VAR_15 = (FT_Int)VAR_22;
                    break;

                  default:  /* COMMENT_26 */
                    *(FT_Long*)VAR_15 = VAR_22;
                  }

                  FT_TRACE4(( "" %ld"", VAR_22 ));

                  VAR_15 += VAR_20->size;
                  VAR_19--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* COMMENT_29 */
              VAR_5 = VAR_20->reader( VAR_1 );
              if ( VAR_5 )
                goto Exit;
            }
            goto Found;
          }
        }

        /* COMMENT_30 */
        /* COMMENT_31 */

      Found:
        /* COMMENT_32 */
        /* COMMENT_33 */
        /* COMMENT_34 */
        if ( VAR_20->kind != VAR_33 )
          VAR_1->top = VAR_1->stack;
      }
      VAR_4++;
    }

  Exit:
    return VAR_5;

  Stack_Overflow:
    VAR_5 = FT_THROW( VAR_34 );
    goto Exit;

  Stack_Underflow:
    VAR_5 = FT_THROW( VAR_34 );
    goto Exit;

  Syntax_Error:
    VAR_5 = FT_THROW( VAR_34 );
    goto Exit;
  }",,"--- func_before
+++ func_after
@@ -192,13 +192,17 @@
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
-        FT_UInt                   num_args = (FT_UInt)
-                                             ( parser->top - parser->stack );
+        FT_UInt                   num_args;
         const CFF_Field_Handler*  field;
 
 
+        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
+          goto Stack_Overflow;
+
+        num_args     = (FT_UInt)( parser->top - parser->stack );
         *parser->top = p;
-        code = v;
+        code         = v;
+
         if ( v == 12 )
         {
           /* two byte operator */","{'deleted_lines': ['        FT_UInt                   num_args = (FT_UInt)', '                                             ( parser->top - parser->stack );', '        code = v;'], 'added_lines': ['        FT_UInt                   num_args;', '        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )', '          goto Stack_Overflow;', '', '        num_args     = (FT_UInt)( parser->top - parser->stack );', '        code         = v;', '']}",True,FreeType 2 before 2016-12-16 has an out-of-bounds write caused by a heap-based buffer overflow related to the cff_parser_run function in cff/cffparse.c.,9.8,CRITICAL,3,valid,,5
CVE-2017-0594,['CWE-120'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Add bounds check in SoftAACEncoder2::onQueueFilled()

Original code blindly copied some header information into the
user-supplied buffer without checking for sufficient space.
The code does check when it gets to filling the data -- it's
just the header copies that weren't checked.

Bug: 34617444
Test: ran POC before/after
Change-Id: I6e80ec90616f6cd02bb8316cd2d6e309b7e4729d
(cherry picked from commit 6231243626b8b9c57593b1f0ee417f2c4af4c0aa)
",594bf934384920618d2b6ce0bcda1f60144cb3eb,https://android.googlesource.com/platform/frameworks/av/+/594bf934384920618d2b6ce0bcda1f60144cb3eb,media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp,SoftAACEncoder2::onQueueFilled,"void SoftAACEncoder2::onQueueFilled(OMX_U32 ) {
if (mSignalledError) {
return;
}
List<BufferInfo *> &inQueue = getPortQueue(0);
List<BufferInfo *> &outQueue = getPortQueue(1);
if (!mSentCodecSpecificData) {
if (outQueue.empty()) {
return;
}
if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
mSignalledError = true;
return;
}
OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
if (mBitRate != actualBitRate) {
ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
}
AACENC_InfoStruct encInfo;
if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
ALOGE(""Failed to get AAC encoder info"");
notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
mSignalledError = true;
return;
}
BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
outHeader->nFilledLen = encInfo.confSize;
outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
memcpy(out, encInfo.confBuf, encInfo.confSize);
outQueue.erase(outQueue.begin());
outInfo->mOwnedByUs = false;
notifyFillBufferDone(outHeader);
mSentCodecSpecificData = true;
}
size_t numBytesPerInputFrame =
mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);
if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
numBytesPerInputFrame = 512;
}
for (;;) {
while (mInputSize < numBytesPerInputFrame) {
if (mSawInputEOS || inQueue.empty()) {
return;
}
BufferInfo *inInfo = *inQueue.begin();
OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
const void *inData = inHeader->pBuffer + inHeader->nOffset;
size_t copy = numBytesPerInputFrame - mInputSize;
if (copy > inHeader->nFilledLen) {
copy = inHeader->nFilledLen;
}
if (mInputFrame == NULL) {
mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
}
if (mInputSize == 0) {
mInputTimeUs = inHeader->nTimeStamp;
}
memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
mInputSize += copy;
inHeader->nOffset += copy;
inHeader->nFilledLen -= copy;
inHeader->nTimeStamp +=
(copy * 1000000ll / mSampleRate)
/ (mNumChannels * sizeof(int16_t));
if (inHeader->nFilledLen == 0) {
if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
mSawInputEOS = true;
memset((uint8_t *)mInputFrame + mInputSize,
0,
numBytesPerInputFrame - mInputSize);
mInputSize = numBytesPerInputFrame;
}
inQueue.erase(inQueue.begin());
inInfo->mOwnedByUs = false;
notifyEmptyBufferDone(inHeader);
inData = NULL;
inHeader = NULL;
inInfo = NULL;
}
}
if (outQueue.empty()) {
return;
}
BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;
AACENC_InArgs inargs;
AACENC_OutArgs outargs;
memset(&inargs, 0, sizeof(inargs));
memset(&outargs, 0, sizeof(outargs));
inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);
void* inBuffer[]        = { (unsigned char *)mInputFrame };
INT   inBufferIds[]     = { IN_AUDIO_DATA };
INT   inBufferSize[]    = { (INT)numBytesPerInputFrame };
INT   inBufferElSize[]  = { sizeof(int16_t) };
AACENC_BufDesc inBufDesc;
inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
inBufDesc.bufs              = (void**)&inBuffer;
inBufDesc.bufferIdentifiers = inBufferIds;
inBufDesc.bufSizes          = inBufferSize;
inBufDesc.bufElSizes        = inBufferElSize;
void* outBuffer[]       = { outPtr };
INT   outBufferIds[]    = { OUT_BITSTREAM_DATA };
INT   outBufferSize[]   = { 0 };
INT   outBufferElSize[] = { sizeof(UCHAR) };
AACENC_BufDesc outBufDesc;
outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
outBufDesc.bufs              = (void**)&outBuffer;
outBufDesc.bufferIdentifiers = outBufferIds;
outBufDesc.bufSizes          = outBufferSize;
outBufDesc.bufElSizes        = outBufferElSize;
AACENC_ERROR encoderErr = AACENC_OK;
size_t nOutputBytes = 0;
do {
memset(&outargs, 0, sizeof(outargs));
outBuffer[0] = outPtr;
outBufferSize[0] = outAvailable - nOutputBytes;
encoderErr = aacEncEncode(mAACEncoder,
&inBufDesc,
&outBufDesc,
&inargs,
&outargs);
if (encoderErr == AACENC_OK) {
outPtr += outargs.numOutBytes;
nOutputBytes += outargs.numOutBytes;
if (outargs.numInSamples > 0) {
int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
if (numRemainingSamples > 0) {
memmove(mInputFrame,
&mInputFrame[outargs.numInSamples],
sizeof(int16_t) * numRemainingSamples);
}
inargs.numInSamples -= outargs.numInSamples;
}
}
} while (encoderErr == AACENC_OK && inargs.numInSamples > 0);
outHeader->nFilledLen = nOutputBytes;
outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
if (mSawInputEOS) {
outHeader->nFlags = OMX_BUFFERFLAG_EOS;
}
outHeader->nTimeStamp = mInputTimeUs;
#if 0
ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
nOutputBytes, mInputTimeUs, outHeader->nFlags);
hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif
outQueue.erase(outQueue.begin());
outInfo->mOwnedByUs = false;
notifyFillBufferDone(outHeader);
outHeader = NULL;
outInfo = NULL;
mInputSize = 0;
}
}","void SoftAACEncoder2::onQueueFilled(OMX_U32 ) {
if (VAR_0) {
return;
}
List<BufferInfo *> &VAR_1 = getPortQueue(0);
List<BufferInfo *> &VAR_2 = getPortQueue(1);
if (!VAR_3) {
if (VAR_2.empty()) {
return;
}
if (VAR_4 != aacEncEncode(VAR_5, NULL, NULL, NULL, NULL)) {
ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
notify(VAR_6, VAR_7, 0, NULL);
VAR_0 = true;
return;
}
OMX_U32 VAR_8  = aacEncoder_GetParam(VAR_5, VAR_9);
if (VAR_10 != VAR_8) {
ALOGW(""Requested bitrate %u unsupported, using %u"", VAR_10, VAR_8);
}
AACENC_InfoStruct VAR_11;
if (VAR_4 != aacEncInfo(VAR_5, &VAR_11)) {
ALOGE(""Failed to get AAC encoder info"");
notify(VAR_6, VAR_7, 0, NULL);
VAR_0 = true;
return;
}
BufferInfo *VAR_12 = *VAR_2.begin();
OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;
VAR_13->nFilledLen = VAR_11.confSize;
VAR_13->nFlags = VAR_14;
uint8_t *VAR_15 = VAR_13->pBuffer + VAR_13->nOffset;
memcpy(VAR_15, VAR_11.confBuf, VAR_11.confSize);
VAR_2.erase(VAR_2.begin());
VAR_12->mOwnedByUs = false;
notifyFillBufferDone(VAR_13);
VAR_3 = true;
}
size_t VAR_16 =
VAR_17 * VAR_18 * sizeof(int16_t);
if (VAR_19 == VAR_20 && VAR_16 > 512) {
VAR_16 = 512;
}
for (;;) {
while (VAR_21 < VAR_16) {
if (VAR_22 || VAR_1.empty()) {
return;
}
BufferInfo *VAR_23 = *VAR_1.begin();
OMX_BUFFERHEADERTYPE *VAR_24 = VAR_23->mHeader;
const void *VAR_25 = VAR_24->pBuffer + VAR_24->nOffset;
size_t VAR_26 = VAR_16 - VAR_21;
if (VAR_26 > VAR_24->nFilledLen) {
VAR_26 = VAR_24->nFilledLen;
}
if (VAR_27 == NULL) {
VAR_27 = new int16_t[VAR_16 / sizeof(int16_t)];
}
if (VAR_21 == 0) {
VAR_28 = VAR_24->nTimeStamp;
}
memcpy((uint8_t *)VAR_27 + VAR_21, VAR_25, VAR_26);
VAR_21 += VAR_26;
VAR_24->nOffset += VAR_26;
VAR_24->nFilledLen -= VAR_26;
VAR_24->nTimeStamp +=
(VAR_26 * 1000000ll / VAR_29)
/ (VAR_17 * sizeof(int16_t));
if (VAR_24->nFilledLen == 0) {
if (VAR_24->nFlags & VAR_30) {
VAR_22 = true;
memset((uint8_t *)VAR_27 + VAR_21,
0,
VAR_16 - VAR_21);
VAR_21 = VAR_16;
}
VAR_1.erase(VAR_1.begin());
VAR_23->mOwnedByUs = false;
notifyEmptyBufferDone(VAR_24);
VAR_25 = NULL;
VAR_24 = NULL;
VAR_23 = NULL;
}
}
if (VAR_2.empty()) {
return;
}
BufferInfo *VAR_12 = *VAR_2.begin();
OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;
uint8_t *VAR_31 = (uint8_t *)VAR_13->pBuffer + VAR_13->nOffset;
size_t VAR_32 = VAR_13->nAllocLen - VAR_13->nOffset;
AACENC_InArgs VAR_33;
AACENC_OutArgs VAR_34;
memset(&VAR_33, 0, sizeof(VAR_33));
memset(&VAR_34, 0, sizeof(VAR_34));
VAR_33.numInSamples = VAR_16 / sizeof(int16_t);
void* VAR_35[]        = { (unsigned char *)VAR_27 };
INT   VAR_36[]     = { VAR_37 };
INT   VAR_38[]    = { (INT)VAR_16 };
INT   VAR_39[]  = { sizeof(int16_t) };
AACENC_BufDesc VAR_40;
VAR_40.numBufs           = sizeof(inBuffer) / sizeof(void*);
VAR_40.bufs              = (void**)&inBuffer;
VAR_40.bufferIdentifiers = VAR_36;
VAR_40.bufSizes          = VAR_38;
VAR_40.bufElSizes        = VAR_39;
void* VAR_41[]       = { VAR_31 };
INT   VAR_42[]    = { VAR_43 };
INT   VAR_44[]   = { 0 };
INT   VAR_45[] = { sizeof(VAR_46) };
AACENC_BufDesc VAR_47;
VAR_47.numBufs           = sizeof(outBuffer) / sizeof(void*);
VAR_47.bufs              = (void**)&outBuffer;
VAR_47.bufferIdentifiers = VAR_42;
VAR_47.bufSizes          = VAR_44;
VAR_47.bufElSizes        = VAR_45;
AACENC_ERROR VAR_48 = VAR_4;
size_t VAR_49 = 0;
do {
memset(&VAR_34, 0, sizeof(VAR_34));
outBuffer[0] = VAR_31;
VAR_44[0] = VAR_32 - VAR_49;
VAR_48 = aacEncEncode(VAR_5,
&VAR_40,
&VAR_47,
&VAR_33,
&VAR_34);
if (VAR_48 == VAR_4) {
VAR_31 += VAR_34.numOutBytes;
VAR_49 += VAR_34.numOutBytes;
if (VAR_34.numInSamples > 0) {
int VAR_50 = VAR_33.numInSamples - VAR_34.numInSamples;
if (VAR_50 > 0) {
memmove(VAR_27,
&VAR_27[VAR_34.numInSamples],
sizeof(int16_t) * VAR_50);
}
VAR_33.numInSamples -= VAR_34.numInSamples;
}
}
} while (VAR_48 == VAR_4 && VAR_33.numInSamples > 0);
VAR_13->nFilledLen = VAR_49;
VAR_13->nFlags = VAR_51;
if (VAR_22) {
VAR_13->nFlags = VAR_30;
}
VAR_13->nTimeStamp = VAR_28;
#if 0
ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
VAR_49, VAR_28, VAR_13->nFlags);
hexdump(VAR_13->pBuffer + VAR_13->nOffset, VAR_13->nFilledLen);
#endif
VAR_2.erase(VAR_2.begin());
VAR_12->mOwnedByUs = false;
notifyFillBufferDone(VAR_13);
VAR_13 = NULL;
VAR_12 = NULL;
VAR_21 = 0;
}
}",android/594bf934384920618d2b6ce0bcda1f60144cb3eb/SoftAACEncoder2.cpp/vul/before/0.json,"void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
    if (mSignalledError) {
        return;
    }

    List<BufferInfo *> &inQueue = getPortQueue(0);
    List<BufferInfo *> &outQueue = getPortQueue(1);

    if (!mSentCodecSpecificData) {
        // The very first thing we want to output is the codec specific
        // data. It does not require any input data but we will need an
        // output buffer to store it in.

        if (outQueue.empty()) {
            return;
        }

        if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
        if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
        }

        AACENC_InfoStruct encInfo;
        if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

        BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

        outHeader->nFilledLen = encInfo.confSize;
        outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;

        uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
    }

    size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

    // Limit input size so we only get one ELD frame
    if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
    }

    for (;;) {
        // We do the following until we run out of buffers.

        while (mInputSize < numBytesPerInputFrame) {
            // As long as there's still input data to be read we
            // will drain ""kNumSamplesPerFrame * mNumChannels"" samples
            // into the ""mInputFrame"" buffer and then encode those
            // as a unit into an output buffer.

            if (mSawInputEOS || inQueue.empty()) {
                return;
            }

            BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

            const void *inData = inHeader->pBuffer + inHeader->nOffset;

            size_t copy = numBytesPerInputFrame - mInputSize;
            if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
            }

            if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
            }

            if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
            }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

            // ""Time"" on the input buffer has in effect advanced by the
            // number of audio frames we just advanced nOffset by.
            inHeader->nTimeStamp +=
                (copy * 1000000ll / mSampleRate)
                    / (mNumChannels * sizeof(int16_t));

            if (inHeader->nFilledLen == 0) {
                if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

                    // Pad any remaining data with zeroes.
                    memset((uint8_t *)mInputFrame + mInputSize,
                           0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
                }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
            }
        }

        // At this  point we have all the input data necessary to encode
        // a single frame, all we need is an output buffer to store the result
        // in.

        if (outQueue.empty()) {
            return;
        }

        BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
        size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

        void* inBuffer[]        = { (unsigned char *)mInputFrame };
        INT   inBufferIds[]     = { IN_AUDIO_DATA };
        INT   inBufferSize[]    = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[]  = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

        void* outBuffer[]       = { outPtr };
        INT   outBufferIds[]    = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[]   = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

        // Encode the mInputFrame, which is treated as a modulo buffer
        AACENC_ERROR encoderErr = AACENC_OK;
        size_t nOutputBytes = 0;

        do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
                                      &inBufDesc,
                                      &outBufDesc,
                                      &inargs,
                                      &outargs);

            if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

                if (outargs.numInSamples > 0) {
                    int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
                    if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
                                &mInputFrame[outargs.numInSamples],
                                sizeof(int16_t) * numRemainingSamples);
                    }
                    inargs.numInSamples -= outargs.numInSamples;
                }
            }
        } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

        if (mSawInputEOS) {
            // We also tag this output buffer with EOS if it corresponds
            // to the final input buffer.
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
        }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
    }
}","void SoftAACEncoder2::onQueueFilled(OMX_U32 /* COMMENT_0 */) {
    if (VAR_0) {
        return;
    }

    List<BufferInfo *> &VAR_1 = getPortQueue(0);
    List<BufferInfo *> &VAR_2 = getPortQueue(1);

    if (!VAR_3) {
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */

        if (VAR_2.empty()) {
            return;
        }

        if (VAR_4 != aacEncEncode(VAR_5, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(VAR_6, VAR_7, 0, NULL);
            VAR_0 = true;
            return;
        }

        OMX_U32 VAR_8  = aacEncoder_GetParam(VAR_5, VAR_9);
        if (VAR_10 != VAR_8) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", VAR_10, VAR_8);
        }

        AACENC_InfoStruct VAR_11;
        if (VAR_4 != aacEncInfo(VAR_5, &VAR_11)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(VAR_6, VAR_7, 0, NULL);
            VAR_0 = true;
            return;
        }

        BufferInfo *VAR_12 = *VAR_2.begin();
        OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;

        if (VAR_13->nOffset + VAR_11.confSize > VAR_13->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(VAR_6, VAR_7, 0, NULL);
            VAR_0 = true;
            return;
        }

        VAR_13->nFilledLen = VAR_11.confSize;
        VAR_13->nFlags = VAR_14;

        uint8_t *VAR_15 = VAR_13->pBuffer + VAR_13->nOffset;
        memcpy(VAR_15, VAR_11.confBuf, VAR_11.confSize);

        VAR_2.erase(VAR_2.begin());
        VAR_12->mOwnedByUs = false;
        notifyFillBufferDone(VAR_13);

        VAR_3 = true;
    }

    size_t VAR_16 =
        VAR_17 * VAR_18 * sizeof(int16_t);

    /* COMMENT_4 */
    if (VAR_19 == VAR_20 && VAR_16 > 512) {
        VAR_16 = 512;
    }

    for (;;) {
        /* COMMENT_5 */

        while (VAR_21 < VAR_16) {
            /* COMMENT_6 */
            /* COMMENT_7 */
            /* COMMENT_8 */
            /* COMMENT_9 */

            if (VAR_22 || VAR_1.empty()) {
                return;
            }

            BufferInfo *VAR_23 = *VAR_1.begin();
            OMX_BUFFERHEADERTYPE *VAR_24 = VAR_23->mHeader;

            const void *VAR_25 = VAR_24->pBuffer + VAR_24->nOffset;

            size_t VAR_26 = VAR_16 - VAR_21;
            if (VAR_26 > VAR_24->nFilledLen) {
                VAR_26 = VAR_24->nFilledLen;
            }

            if (VAR_27 == NULL) {
                VAR_27 = new int16_t[VAR_16 / sizeof(int16_t)];
            }

            if (VAR_21 == 0) {
                VAR_28 = VAR_24->nTimeStamp;
            }

            memcpy((uint8_t *)VAR_27 + VAR_21, VAR_25, VAR_26);
            VAR_21 += VAR_26;

            VAR_24->nOffset += VAR_26;
            VAR_24->nFilledLen -= VAR_26;

            /* COMMENT_10 */
            /* COMMENT_11 */
            VAR_24->nTimeStamp +=
                (VAR_26 * 1000000ll / VAR_29)
                    / (VAR_17 * sizeof(int16_t));

            if (VAR_24->nFilledLen == 0) {
                if (VAR_24->nFlags & VAR_30) {
                    VAR_22 = true;

                    /* COMMENT_12 */
                    memset((uint8_t *)VAR_27 + VAR_21,
                           0,
                           VAR_16 - VAR_21);

                    VAR_21 = VAR_16;
                }

                VAR_1.erase(VAR_1.begin());
                VAR_23->mOwnedByUs = false;
                notifyEmptyBufferDone(VAR_24);

                VAR_25 = NULL;
                VAR_24 = NULL;
                VAR_23 = NULL;
            }
        }

        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_15 */

        if (VAR_2.empty()) {
            return;
        }

        BufferInfo *VAR_12 = *VAR_2.begin();
        OMX_BUFFERHEADERTYPE *VAR_13 = VAR_12->mHeader;

        uint8_t *VAR_31 = (uint8_t *)VAR_13->pBuffer + VAR_13->nOffset;
        size_t VAR_32 = VAR_13->nAllocLen - VAR_13->nOffset;

        AACENC_InArgs VAR_33;
        AACENC_OutArgs VAR_34;
        memset(&VAR_33, 0, sizeof(VAR_33));
        memset(&VAR_34, 0, sizeof(VAR_34));
        VAR_33.numInSamples = VAR_16 / sizeof(int16_t);

        void* VAR_35[]        = { (unsigned char *)VAR_27 };
        INT   VAR_36[]     = { VAR_37 };
        INT   VAR_38[]    = { (INT)VAR_16 };
        INT   VAR_39[]  = { sizeof(int16_t) };

        AACENC_BufDesc VAR_40;
        VAR_40.numBufs           = sizeof(inBuffer) / sizeof(void*);
        VAR_40.bufs              = (void**)&inBuffer;
        VAR_40.bufferIdentifiers = VAR_36;
        VAR_40.bufSizes          = VAR_38;
        VAR_40.bufElSizes        = VAR_39;

        void* VAR_41[]       = { VAR_31 };
        INT   VAR_42[]    = { VAR_43 };
        INT   VAR_44[]   = { 0 };
        INT   VAR_45[] = { sizeof(VAR_46) };

        AACENC_BufDesc VAR_47;
        VAR_47.numBufs           = sizeof(outBuffer) / sizeof(void*);
        VAR_47.bufs              = (void**)&outBuffer;
        VAR_47.bufferIdentifiers = VAR_42;
        VAR_47.bufSizes          = VAR_44;
        VAR_47.bufElSizes        = VAR_45;

        /* COMMENT_16 */
        AACENC_ERROR VAR_48 = VAR_4;
        size_t VAR_49 = 0;

        do {
            memset(&VAR_34, 0, sizeof(VAR_34));

            outBuffer[0] = VAR_31;
            VAR_44[0] = VAR_32 - VAR_49;

            VAR_48 = aacEncEncode(VAR_5,
                                      &VAR_40,
                                      &VAR_47,
                                      &VAR_33,
                                      &VAR_34);

            if (VAR_48 == VAR_4) {
                VAR_31 += VAR_34.numOutBytes;
                VAR_49 += VAR_34.numOutBytes;

                if (VAR_34.numInSamples > 0) {
                    int VAR_50 = VAR_33.numInSamples - VAR_34.numInSamples;
                    if (VAR_50 > 0) {
                        memmove(VAR_27,
                                &VAR_27[VAR_34.numInSamples],
                                sizeof(int16_t) * VAR_50);
                    }
                    VAR_33.numInSamples -= VAR_34.numInSamples;
                }
            }
        } while (VAR_48 == VAR_4 && VAR_33.numInSamples > 0);

        VAR_13->nFilledLen = VAR_49;

        VAR_13->nFlags = VAR_51;

        if (VAR_22) {
            /* COMMENT_17 */
            /* COMMENT_18 */
            VAR_13->nFlags = VAR_30;
        }

        VAR_13->nTimeStamp = VAR_28;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              VAR_49, VAR_28, VAR_13->nFlags);

        hexdump(VAR_13->pBuffer + VAR_13->nOffset, VAR_13->nFilledLen);
#endif

        VAR_2.erase(VAR_2.begin());
        VAR_12->mOwnedByUs = false;
        notifyFillBufferDone(VAR_13);

        VAR_13 = NULL;
        VAR_12 = NULL;

        VAR_21 = 0;
    }
}",android/594bf934384920618d2b6ce0bcda1f60144cb3eb/SoftAACEncoder2.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,6 +37,15 @@
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
+
+        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
+            ALOGE(""b/34617444"");
+            android_errorWriteLog(0x534e4554,""34617444"");
+            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
+            mSignalledError = true;
+            return;
+        }
+
         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 ","{'deleted_lines': [], 'added_lines': ['', '        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {', '            ALOGE(""b/34617444"");', '            android_errorWriteLog(0x534e4554,""34617444"");', '            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);', '            mSignalledError = true;', '            return;', '        }', '']}",True,"An elevation of privilege vulnerability in codecs/aacenc/SoftAACEncoder2.cpp in libstagefright in Mediaserver could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34617444.",7.8,HIGH,2,valid,,5
CVE-2017-0600,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,android,"Fix NPDs in h263 decoder

Bug: 35269635
Test: decoded PoC with and without patch
Change-Id: I636a14360c7801cc5bca63c9cb44d1d235df8fd8
(cherry picked from commit 2ad2a92318a3b9daf78ebcdc597085adbf32600d)
",961e5ac5788b52304e64b9a509781beaf5201fb0,https://android.googlesource.com/platform/frameworks/av/+/961e5ac5788b52304e64b9a509781beaf5201fb0,media/libstagefright/codecs/m4v_h263/dec/src/pvdec_api.cpp,PVDecodeVopBody,"Bool PVDecodeVopBody(VideoDecControls *decCtrl, int32 buffer_size[])
{
PV_STATUS status = PV_FAIL;
VideoDecData *video = (VideoDecData *) decCtrl->videoDecoderData;
int target_layer = video->currLayer;
Vol *currVol = video->vol[target_layer];
Vop *currVop = video->currVop;
Vop *prevVop = video->prevVop;
Vop *tempVopPtr;
int bytes_consumed = 0; 
int idx;
if (currVop->vopCoded == 0)                  
{
PV_BitstreamByteAlign(currVol->bitstream);
bytes_consumed = (getPointer(currVol->bitstream) + 7) >> 3;
if (bytes_consumed > currVol->bitstream->data_end_pos)
{
bytes_consumed = currVol->bitstream->data_end_pos;
}
if (bytes_consumed < buffer_size[target_layer])
{
buffer_size[target_layer] -= bytes_consumed;
}
else
{
buffer_size[target_layer] = 0;
}
#ifdef PV_MEMORY_POOL
if (target_layer)
{
if (video->prevEnhcVop->timeStamp > video->prevVop->timeStamp)
{
video->prevVop = video->prevEnhcVop;
}
}
oscl_memcpy(currVop->yChan, video->prevVop->yChan, (decCtrl->size*3) / 2);
video->prevVop = prevVop;
video->concealFrame = currVop->yChan;       
video->vop_coding_type = currVop->predictionType; 
decCtrl->outputFrame = currVop->yChan;
if (target_layer)
{
tempVopPtr = video->prevEnhcVop;
video->prevEnhcVop = video->currVop;
video->currVop = tempVopPtr;
}
else
{
tempVopPtr = video->prevVop;
video->prevVop = video->currVop;
video->currVop = tempVopPtr;
}
#else
if (target_layer)       
{
video->prevEnhcVop->timeStamp = currVop->timeStamp;
}
else
{
video->prevVop->timeStamp = currVop->timeStamp;
}
#endif
video->vop_coding_type = currVop->predictionType; 
if (currVop->predictionType == I_VOP)
{
video->vop_coding_type = P_VOP;
}
return PV_TRUE;
}
if (decCtrl->nLayers > 1)
{
if (currVop->predictionType == I_VOP)
{
}
else if (currVop->predictionType == P_VOP)
{
switch (currVop->refSelectCode)
{
case 0 : 
if (video->prevEnhcVop->timeStamp >= video->prevVop->timeStamp)
video->prevVop = video->prevEnhcVop;
break;
case 1 : 
if (target_layer)
{
if (video->prevEnhcVop->timeStamp > video->prevVop->timeStamp)
video->prevVop = video->prevEnhcVop;
}
break;
case 2 : 
break;
case 3 : 
break;
}
}
else 
{
mp4dec_log(""DecodeVideoFrame(): B-VOP not supported.\n"");
}
}
idx = ++video->frame_idx % BITRATE_AVERAGE_WINDOW;
status = PV_DecodeVop(video);
video->nBitsPerVop[idx] = getPointer(currVol->bitstream);
video->prevTimestamp[idx] = currVop->timeStamp;
video->prevVop = prevVop;
video->duration = video->prevTimestamp[idx];
video->duration -= video->prevTimestamp[(++idx)%BITRATE_AVERAGE_WINDOW];
if (video->duration > 0)
{ 
video->frameRate = (int)(FRAMERATE_SCALE) / video->duration;
}
bytes_consumed = (getPointer(currVol->bitstream) + 7) >> 3; 
if (bytes_consumed > currVol->bitstream->data_end_pos)
{
bytes_consumed = currVol->bitstream->data_end_pos;
}
if (bytes_consumed < buffer_size[target_layer])
{
buffer_size[target_layer] -= bytes_consumed;
}
else
{
buffer_size[target_layer] = 0;
}
switch (status)
{
case PV_FAIL :
return PV_FALSE;        
case PV_END_OF_VOP :
case PV_SUCCESS :
video->concealFrame = video->currVop->yChan;       
video->vop_coding_type = video->currVop->predictionType; 
decCtrl->outputFrame = video->currVop->yChan;
if (target_layer)
{
tempVopPtr = video->prevEnhcVop;
video->prevEnhcVop = video->currVop;
video->currVop = tempVopPtr;
}
else
{
tempVopPtr = video->prevVop;
video->prevVop = video->currVop;
video->currVop = tempVopPtr;
}
break;
default :
break;
}
return PV_TRUE;
}","Bool PVDecodeVopBody(VideoDecControls *VAR_0, int32 VAR_1[])
{
PV_STATUS VAR_2 = VAR_3;
VideoDecData *VAR_4 = (VideoDecData *) VAR_0->videoDecoderData;
int VAR_5 = VAR_4->currLayer;
Vol *VAR_6 = VAR_4->vol[VAR_5];
Vop *VAR_7 = VAR_4->currVop;
Vop *VAR_8 = VAR_4->prevVop;
Vop *VAR_9;
int VAR_10 = 0; 
int VAR_11;
if (VAR_7->vopCoded == 0)                  
{
PV_BitstreamByteAlign(VAR_6->bitstream);
VAR_10 = (getPointer(VAR_6->bitstream) + 7) >> 3;
if (VAR_10 > VAR_6->bitstream->data_end_pos)
{
VAR_10 = VAR_6->bitstream->data_end_pos;
}
if (VAR_10 < VAR_1[VAR_5])
{
VAR_1[VAR_5] -= VAR_10;
}
else
{
VAR_1[VAR_5] = 0;
}
#ifdef VAR_12
if (VAR_5)
{
if (VAR_4->prevEnhcVop->timeStamp > VAR_4->prevVop->timeStamp)
{
VAR_4->prevVop = VAR_4->prevEnhcVop;
}
}
oscl_memcpy(VAR_7->yChan, VAR_4->prevVop->yChan, (VAR_0->size*3) / 2);
VAR_4->prevVop = VAR_8;
VAR_4->concealFrame = VAR_7->yChan;       
VAR_4->vop_coding_type = VAR_7->predictionType; 
VAR_0->outputFrame = VAR_7->yChan;
if (VAR_5)
{
VAR_9 = VAR_4->prevEnhcVop;
VAR_4->prevEnhcVop = VAR_4->currVop;
VAR_4->currVop = VAR_9;
}
else
{
VAR_9 = VAR_4->prevVop;
VAR_4->prevVop = VAR_4->currVop;
VAR_4->currVop = VAR_9;
}
#else
if (VAR_5)       
{
VAR_4->prevEnhcVop->timeStamp = VAR_7->timeStamp;
}
else
{
VAR_4->prevVop->timeStamp = VAR_7->timeStamp;
}
#endif
VAR_4->vop_coding_type = VAR_7->predictionType; 
if (VAR_7->predictionType == VAR_13)
{
VAR_4->vop_coding_type = VAR_14;
}
return VAR_15;
}
if (VAR_0->nLayers > 1)
{
if (VAR_7->predictionType == VAR_13)
{
}
else if (VAR_7->predictionType == VAR_14)
{
switch (VAR_7->refSelectCode)
{
case 0 : 
if (VAR_4->prevEnhcVop->timeStamp >= VAR_4->prevVop->timeStamp)
VAR_4->prevVop = VAR_4->prevEnhcVop;
break;
case 1 : 
if (VAR_5)
{
if (VAR_4->prevEnhcVop->timeStamp > VAR_4->prevVop->timeStamp)
VAR_4->prevVop = VAR_4->prevEnhcVop;
}
break;
case 2 : 
break;
case 3 : 
break;
}
}
else 
{
mp4dec_log(""DecodeVideoFrame(): B-VOP not supported.\n"");
}
}
VAR_11 = ++VAR_4->frame_idx % VAR_16;
VAR_2 = PV_DecodeVop(VAR_4);
VAR_4->nBitsPerVop[VAR_11] = getPointer(VAR_6->bitstream);
VAR_4->prevTimestamp[VAR_11] = VAR_7->timeStamp;
VAR_4->prevVop = VAR_8;
VAR_4->duration = VAR_4->prevTimestamp[VAR_11];
VAR_4->duration -= VAR_4->prevTimestamp[(++VAR_11)%VAR_16];
if (VAR_4->duration > 0)
{ 
VAR_4->frameRate = (int)(VAR_17) / VAR_4->duration;
}
VAR_10 = (getPointer(VAR_6->bitstream) + 7) >> 3; 
if (VAR_10 > VAR_6->bitstream->data_end_pos)
{
VAR_10 = VAR_6->bitstream->data_end_pos;
}
if (VAR_10 < VAR_1[VAR_5])
{
VAR_1[VAR_5] -= VAR_10;
}
else
{
VAR_1[VAR_5] = 0;
}
switch (VAR_2)
{
case VAR_3 :
return VAR_18;        
case VAR_19 :
case VAR_20 :
VAR_4->concealFrame = VAR_4->currVop->yChan;       
VAR_4->vop_coding_type = VAR_4->currVop->predictionType; 
VAR_0->outputFrame = VAR_4->currVop->yChan;
if (VAR_5)
{
VAR_9 = VAR_4->prevEnhcVop;
VAR_4->prevEnhcVop = VAR_4->currVop;
VAR_4->currVop = VAR_9;
}
else
{
VAR_9 = VAR_4->prevVop;
VAR_4->prevVop = VAR_4->currVop;
VAR_4->currVop = VAR_9;
}
break;
default :
break;
}
return VAR_15;
}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/pvdec_api.cpp/vul/before/0.json,"Bool PVDecodeVopBody(VideoDecControls *decCtrl, int32 buffer_size[])
{
    PV_STATUS status = PV_FAIL;
    VideoDecData *video = (VideoDecData *) decCtrl->videoDecoderData;
    int target_layer = video->currLayer;
    Vol *currVol = video->vol[target_layer];
    Vop *currVop = video->currVop;
    Vop *prevVop = video->prevVop;
    Vop *tempVopPtr;
    int bytes_consumed = 0; /* Record how many bits we used in the buffer.   04/24/2001 */

    int idx;

    if (currVop->vopCoded == 0)                  /*  07/03/2001 */
    {
        PV_BitstreamByteAlign(currVol->bitstream);
        /* We should always clear up bitstream buffer.   10/10/2000 */
        bytes_consumed = (getPointer(currVol->bitstream) + 7) >> 3;

        if (bytes_consumed > currVol->bitstream->data_end_pos)
        {
            bytes_consumed = currVol->bitstream->data_end_pos;
        }

        if (bytes_consumed < buffer_size[target_layer])
        {
            /* If we only consume part of the bits in the buffer, take those */
            /*  out.     04/24/2001 */
            /*          oscl_memcpy(buffer[target_layer], buffer[target_layer]+bytes_consumed,
                            (buffer_size[target_layer]-=bytes_consumed)); */
            buffer_size[target_layer] -= bytes_consumed;
        }
        else
        {
            buffer_size[target_layer] = 0;
        }
#ifdef PV_MEMORY_POOL

        if (target_layer)
        {
            if (video->prevEnhcVop->timeStamp > video->prevVop->timeStamp)
            {
                video->prevVop = video->prevEnhcVop;
            }
        }

        if (!video->prevVop->yChan) {
            ALOGE(""b/35269635"");
            android_errorWriteLog(0x534e4554, ""35269635"");
            return PV_FALSE;
        }
        oscl_memcpy(currVop->yChan, video->prevVop->yChan, (decCtrl->size*3) / 2);

        video->prevVop = prevVop;

        video->concealFrame = currVop->yChan;       /*  07/07/2001 */

        video->vop_coding_type = currVop->predictionType; /*  07/09/01 */

        decCtrl->outputFrame = currVop->yChan;

        /* Swap VOP pointers.  No enhc. frame oscl_memcpy() anymore!   04/24/2001 */
        if (target_layer)
        {
            tempVopPtr = video->prevEnhcVop;
            video->prevEnhcVop = video->currVop;
            video->currVop = tempVopPtr;
        }
        else
        {
            tempVopPtr = video->prevVop;
            video->prevVop = video->currVop;
            video->currVop = tempVopPtr;
        }
#else
        if (target_layer)       /* this is necessary to avoid flashback problems   06/21/2002*/
        {
            video->prevEnhcVop->timeStamp = currVop->timeStamp;
        }
        else
        {
            video->prevVop->timeStamp = currVop->timeStamp;
        }
#endif
        video->vop_coding_type = currVop->predictionType; /*  07/09/01 */
        /* the following is necessary to avoid displaying an notCoded I-VOP at the beginning of a session
        or after random positioning  07/03/02*/
        if (currVop->predictionType == I_VOP)
        {
            video->vop_coding_type = P_VOP;
        }


        return PV_TRUE;
    }
    /* ======================================================= */
    /*  Decode vop body (if there is no error in the header!)  */
    /* ======================================================= */

    /* first, we need to select a reference frame */
    if (decCtrl->nLayers > 1)
    {
        if (currVop->predictionType == I_VOP)
        {
            /* do nothing here */
        }
        else if (currVop->predictionType == P_VOP)
        {
            switch (currVop->refSelectCode)
            {
                case 0 : /* most recently decoded enhancement vop */
                    /* Setup video->prevVop before we call PV_DecodeVop().   04/24/2001 */
                    if (video->prevEnhcVop->timeStamp >= video->prevVop->timeStamp)
                        video->prevVop = video->prevEnhcVop;
                    break;

                case 1 : /* most recently displayed base-layer vop */
                    if (target_layer)
                    {
                        if (video->prevEnhcVop->timeStamp > video->prevVop->timeStamp)
                            video->prevVop = video->prevEnhcVop;
                    }
                    break;

                case 2 : /* next base-layer vop in display order */
                    break;

                case 3 : /* temporally coincident base-layer vop (no MV's) */
                    break;
            }
        }
        else /* we have a B-Vop */
        {
            mp4dec_log(""DecodeVideoFrame(): B-VOP not supported.\n"");
        }
    }

    /* This is for the calculation of the frame rate and bitrate. */
    idx = ++video->frame_idx % BITRATE_AVERAGE_WINDOW;

    /* Calculate bitrate for this layer.   08/23/2000 */
    status = PV_DecodeVop(video);
    video->nBitsPerVop[idx] = getPointer(currVol->bitstream);
    video->prevTimestamp[idx] = currVop->timeStamp;

    /* restore video->prevVop after PV_DecodeVop().   04/24/2001 */
//  if (currVop->refSelectCode == 0) video->prevVop = prevVop;
    video->prevVop = prevVop;

    /* Estimate the frame rate.   08/23/2000 */
    video->duration = video->prevTimestamp[idx];
    video->duration -= video->prevTimestamp[(++idx)%BITRATE_AVERAGE_WINDOW];
    if (video->duration > 0)
    { /* Only update framerate when the timestamp is right */
        video->frameRate = (int)(FRAMERATE_SCALE) / video->duration;
    }

    /* We should always clear up bitstream buffer.   10/10/2000 */
    bytes_consumed = (getPointer(currVol->bitstream) + 7) >> 3; /*  11/4/03 */

    if (bytes_consumed > currVol->bitstream->data_end_pos)
    {
        bytes_consumed = currVol->bitstream->data_end_pos;
    }

    if (bytes_consumed < buffer_size[target_layer])
    {
        /* If we only consume part of the bits in the buffer, take those */
        /*  out.     04/24/2001 */
        /*      oscl_memcpy(buffer[target_layer], buffer[target_layer]+bytes_consumed,
                    (buffer_size[target_layer]-=bytes_consumed)); */
        buffer_size[target_layer] -= bytes_consumed;
    }
    else
    {
        buffer_size[target_layer] = 0;
    }
    switch (status)
    {
        case PV_FAIL :
            return PV_FALSE;        /* this will take care of concealment if we lose whole frame  */

        case PV_END_OF_VOP :
            /* we may want to differenciate PV_END_OF_VOP and PV_SUCCESS */
            /*    in the future.     05/10/2000                      */

        case PV_SUCCESS :
            /* Nohting is wrong :). */


            video->concealFrame = video->currVop->yChan;       /*  07/07/2001 */

            video->vop_coding_type = video->currVop->predictionType; /*  07/09/01 */

            decCtrl->outputFrame = video->currVop->yChan;

            /* Swap VOP pointers.  No enhc. frame oscl_memcpy() anymore!   04/24/2001 */
            if (target_layer)
            {
                tempVopPtr = video->prevEnhcVop;
                video->prevEnhcVop = video->currVop;
                video->currVop = tempVopPtr;
            }
            else
            {
                tempVopPtr = video->prevVop;
                video->prevVop = video->currVop;
                video->currVop = tempVopPtr;
            }
            break;

        default :
            /* This will never happen */
            break;
    }

    return PV_TRUE;
}","Bool PVDecodeVopBody(VideoDecControls *VAR_0, int32 VAR_1[])
{
    PV_STATUS VAR_2 = VAR_3;
    VideoDecData *VAR_4 = (VideoDecData *) VAR_0->videoDecoderData;
    int VAR_5 = VAR_4->currLayer;
    Vol *VAR_6 = VAR_4->vol[VAR_5];
    Vop *VAR_7 = VAR_4->currVop;
    Vop *VAR_8 = VAR_4->prevVop;
    Vop *VAR_9;
    int VAR_10 = 0; /* COMMENT_0 */

    int VAR_11;

    if (VAR_7->vopCoded == 0)                  /* COMMENT_1 */
    {
        PV_BitstreamByteAlign(VAR_6->bitstream);
        /* COMMENT_2 */
        VAR_10 = (getPointer(VAR_6->bitstream) + 7) >> 3;

        if (VAR_10 > VAR_6->bitstream->data_end_pos)
        {
            VAR_10 = VAR_6->bitstream->data_end_pos;
        }

        if (VAR_10 < VAR_1[VAR_5])
        {
            /* COMMENT_3 */
            /* COMMENT_4 */
            /* COMMENT_5 */
                                                                            
            VAR_1[VAR_5] -= VAR_10;
        }
        else
        {
            VAR_1[VAR_5] = 0;
        }
#ifdef VAR_12

        if (VAR_5)
        {
            if (VAR_4->prevEnhcVop->timeStamp > VAR_4->prevVop->timeStamp)
            {
                VAR_4->prevVop = VAR_4->prevEnhcVop;
            }
        }

        if (!VAR_4->prevVop->yChan) {
            ALOGE(""b/35269635"");
            android_errorWriteLog(0x534e4554, ""35269635"");
            return VAR_13;
        }
        oscl_memcpy(VAR_7->yChan, VAR_4->prevVop->yChan, (VAR_0->size*3) / 2);

        VAR_4->prevVop = VAR_8;

        VAR_4->concealFrame = VAR_7->yChan;       /* COMMENT_7 */

        VAR_4->vop_coding_type = VAR_7->predictionType; /* COMMENT_8 */

        VAR_0->outputFrame = VAR_7->yChan;

        /* COMMENT_9 */
        if (VAR_5)
        {
            VAR_9 = VAR_4->prevEnhcVop;
            VAR_4->prevEnhcVop = VAR_4->currVop;
            VAR_4->currVop = VAR_9;
        }
        else
        {
            VAR_9 = VAR_4->prevVop;
            VAR_4->prevVop = VAR_4->currVop;
            VAR_4->currVop = VAR_9;
        }
#else
        if (VAR_5)       /* COMMENT_10 */
        {
            VAR_4->prevEnhcVop->timeStamp = VAR_7->timeStamp;
        }
        else
        {
            VAR_4->prevVop->timeStamp = VAR_7->timeStamp;
        }
#endif
        VAR_4->vop_coding_type = VAR_7->predictionType; /* COMMENT_8 */
        /* COMMENT_11 */
                                               
        if (VAR_7->predictionType == VAR_14)
        {
            VAR_4->vop_coding_type = VAR_15;
        }


        return VAR_16;
    }
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_13 */

    /* COMMENT_15 */
    if (VAR_0->nLayers > 1)
    {
        if (VAR_7->predictionType == VAR_14)
        {
            /* COMMENT_16 */
        }
        else if (VAR_7->predictionType == VAR_15)
        {
            switch (VAR_7->refSelectCode)
            {
                case 0 : /* COMMENT_17 */
                    /* COMMENT_18 */
                    if (VAR_4->prevEnhcVop->timeStamp >= VAR_4->prevVop->timeStamp)
                        VAR_4->prevVop = VAR_4->prevEnhcVop;
                    break;

                case 1 : /* COMMENT_19 */
                    if (VAR_5)
                    {
                        if (VAR_4->prevEnhcVop->timeStamp > VAR_4->prevVop->timeStamp)
                            VAR_4->prevVop = VAR_4->prevEnhcVop;
                    }
                    break;

                case 2 : /* COMMENT_20 */
                    break;

                case 3 : /* COMMENT_21 */
                    break;
            }
        }
        else /* COMMENT_22 */
        {
            mp4dec_log(""DecodeVideoFrame(): B-VOP not supported.\n"");
        }
    }

    /* COMMENT_23 */
    VAR_11 = ++VAR_4->frame_idx % VAR_17;

    /* COMMENT_24 */
    VAR_2 = PV_DecodeVop(VAR_4);
    VAR_4->nBitsPerVop[VAR_11] = getPointer(VAR_6->bitstream);
    VAR_4->prevTimestamp[VAR_11] = VAR_7->timeStamp;

    /* COMMENT_25 */
/* COMMENT_26 */
    VAR_4->prevVop = VAR_8;

    /* COMMENT_27 */
    VAR_4->duration = VAR_4->prevTimestamp[VAR_11];
    VAR_4->duration -= VAR_4->prevTimestamp[(++VAR_11)%VAR_17];
    if (VAR_4->duration > 0)
    { /* COMMENT_28 */
        VAR_4->frameRate = (int)(VAR_18) / VAR_4->duration;
    }

    /* COMMENT_2 */
    VAR_10 = (getPointer(VAR_6->bitstream) + 7) >> 3; /* COMMENT_29 */

    if (VAR_10 > VAR_6->bitstream->data_end_pos)
    {
        VAR_10 = VAR_6->bitstream->data_end_pos;
    }

    if (VAR_10 < VAR_1[VAR_5])
    {
        /* COMMENT_3 */
        /* COMMENT_4 */
        /* COMMENT_30 */
                                                                    
        VAR_1[VAR_5] -= VAR_10;
    }
    else
    {
        VAR_1[VAR_5] = 0;
    }
    switch (VAR_2)
    {
        case VAR_3 :
            return VAR_13;        /* COMMENT_32 */

        case VAR_19 :
            /* COMMENT_33 */
            /* COMMENT_34 */

        case VAR_20 :
            /* COMMENT_35 */


            VAR_4->concealFrame = VAR_4->currVop->yChan;       /* COMMENT_7 */

            VAR_4->vop_coding_type = VAR_4->currVop->predictionType; /* COMMENT_8 */

            VAR_0->outputFrame = VAR_4->currVop->yChan;

            /* COMMENT_9 */
            if (VAR_5)
            {
                VAR_9 = VAR_4->prevEnhcVop;
                VAR_4->prevEnhcVop = VAR_4->currVop;
                VAR_4->currVop = VAR_9;
            }
            else
            {
                VAR_9 = VAR_4->prevVop;
                VAR_4->prevVop = VAR_4->currVop;
                VAR_4->currVop = VAR_9;
            }
            break;

        default :
            /* COMMENT_36 */
            break;
    }

    return VAR_16;
}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/pvdec_api.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -44,6 +44,11 @@
             }
         }
 
+        if (!video->prevVop->yChan) {
+            ALOGE(""b/35269635"");
+            android_errorWriteLog(0x534e4554, ""35269635"");
+            return PV_FALSE;
+        }
         oscl_memcpy(currVop->yChan, video->prevVop->yChan, (decCtrl->size*3) / 2);
 
         video->prevVop = prevVop;","{'deleted_lines': [], 'added_lines': ['        if (!video->prevVop->yChan) {', '            ALOGE(""b/35269635"");', '            android_errorWriteLog(0x534e4554, ""35269635"");', '            return PV_FALSE;', '        }']}",True,"A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635.",5.5,MEDIUM,1,valid,,5
CVE-2017-0600,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,android,"Fix NPDs in h263 decoder

Bug: 35269635
Test: decoded PoC with and without patch
Change-Id: I636a14360c7801cc5bca63c9cb44d1d235df8fd8
(cherry picked from commit 2ad2a92318a3b9daf78ebcdc597085adbf32600d)
",961e5ac5788b52304e64b9a509781beaf5201fb0,https://android.googlesource.com/platform/frameworks/av/+/961e5ac5788b52304e64b9a509781beaf5201fb0,media/libstagefright/codecs/m4v_h263/dec/src/mb_motion_comp.cpp,SkippedMBMotionComp,"void  SkippedMBMotionComp(
VideoDecData *video
)
{
Vop *prev = video->prevVop;
Vop *comp;
int ypos, xpos;
PIXEL *c_comp, *c_prev;
PIXEL *cu_comp, *cu_prev;
PIXEL *cv_comp, *cv_prev;
int width, width_uv;
int32 offset;
#ifdef PV_POSTPROC_ON     int imv;
int32 size = (int32) video->nTotalMB << 8;
uint8 *pp_dec_y, *pp_dec_u;
uint8 *pp_prev1;
int mvwidth = video->nMBPerRow << 1;
#endif
width = video->width;
width_uv  = width >> 1;
ypos = video->mbnum_row << 4 ;
xpos = video->mbnum_col << 4 ;
offset = (int32)ypos * width + xpos;
c_prev  = prev->yChan + offset;
cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);
comp = video->currVop;
c_comp  = comp->yChan + offset;
cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);
cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);
PutSKIPPED_MB(c_comp,  c_prev, width);
PutSKIPPED_B(cu_comp, cu_prev, width_uv);
PutSKIPPED_B(cv_comp, cv_prev, width_uv);
#ifdef PV_POSTPROC_ON     if (video->postFilterType != PV_NO_POST_PROC)
{
imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
pp_prev1 = video->pstprcTypPrv + imv;
pp_dec_y = video->pstprcTypCur + imv;
*pp_dec_y = *pp_prev1;
*(pp_dec_y + 1) = *(pp_prev1 + 1);
*(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);
*(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);
pp_prev1 = video->pstprcTypPrv + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
pp_dec_u = video->pstprcTypCur + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
*pp_dec_u = *pp_prev1;
pp_dec_u[size>>8] = pp_prev1[size>>8];
}
#endif
return;
}","void  SkippedMBMotionComp(
VideoDecData *VAR_0
)
{
Vop *VAR_1 = VAR_0->prevVop;
Vop *VAR_2;
int VAR_3, VAR_4;
PIXEL *VAR_5, *VAR_6;
PIXEL *VAR_7, *VAR_8;
PIXEL *VAR_9, *VAR_10;
int VAR_11, VAR_12;
int32 VAR_13;
#ifdef VAR_14 
int VAR_15;
int32 VAR_16 = (int32) VAR_0->nTotalMB << 8;
uint8 *VAR_17, *VAR_18;
uint8 *VAR_19;
int VAR_20 = VAR_0->nMBPerRow << 1;
#endif
VAR_11 = VAR_0->width;
VAR_12  = VAR_11 >> 1;
VAR_3 = VAR_0->mbnum_row << 4 ;
VAR_4 = VAR_0->mbnum_col << 4 ;
VAR_13 = (int32)VAR_3 * VAR_11 + VAR_4;
VAR_6  = VAR_1->yChan + VAR_13;
VAR_8 = VAR_1->uChan + (VAR_13 >> 2) + (VAR_4 >> 2);
VAR_10 = VAR_1->vChan + (VAR_13 >> 2) + (VAR_4 >> 2);
VAR_2 = VAR_0->currVop;
VAR_5  = VAR_2->yChan + VAR_13;
VAR_7 = VAR_2->uChan + (VAR_13 >> 2) + (VAR_4 >> 2);
VAR_9 = VAR_2->vChan + (VAR_13 >> 2) + (VAR_4 >> 2);
PutSKIPPED_MB(VAR_5,  VAR_6, VAR_11);
PutSKIPPED_B(VAR_7, VAR_8, VAR_12);
PutSKIPPED_B(VAR_9, VAR_10, VAR_12);
#ifdef VAR_14 
if (VAR_0->postFilterType != VAR_21)
{
VAR_15 = (VAR_13 >> 6) - (VAR_4 >> 6) + (VAR_4 >> 3);
VAR_19 = VAR_0->pstprcTypPrv + VAR_15;
VAR_17 = VAR_0->pstprcTypCur + VAR_15;
*VAR_17 = *VAR_19;
*(VAR_17 + 1) = *(VAR_19 + 1);
*(VAR_17 + VAR_20) = *(VAR_19 + VAR_20);
*(VAR_17 + VAR_20 + 1) = *(VAR_19 + VAR_20 + 1);
VAR_19 = VAR_0->pstprcTypPrv + (VAR_16 >> 6) +
((VAR_15 + (VAR_4 >> 3)) >> 2);
VAR_18 = VAR_0->pstprcTypCur + (VAR_16 >> 6) +
((VAR_15 + (VAR_4 >> 3)) >> 2);
*VAR_18 = *VAR_19;
VAR_18[VAR_16>>8] = VAR_19[VAR_16>>8];
}
#endif
return;
}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/mb_motion_comp.cpp/vul/before/0.json,"void  SkippedMBMotionComp(
    VideoDecData *video
)
{
    Vop *prev = video->prevVop;
    Vop *comp;
    int ypos, xpos;
    PIXEL *c_comp, *c_prev;
    PIXEL *cu_comp, *cu_prev;
    PIXEL *cv_comp, *cv_prev;
    int width, width_uv;
    int32 offset;
#ifdef PV_POSTPROC_ON // 2/14/2001      
    int imv;
    int32 size = (int32) video->nTotalMB << 8;
    uint8 *pp_dec_y, *pp_dec_u;
    uint8 *pp_prev1;
    int mvwidth = video->nMBPerRow << 1;
#endif

    width = video->width;
    width_uv  = width >> 1;
    ypos = video->mbnum_row << 4 ;
    xpos = video->mbnum_col << 4 ;
    offset = (int32)ypos * width + xpos;


    /* zero motion compensation for previous frame */
    /*mby*width + mbx;*/
    c_prev  = prev->yChan;
    if (!c_prev) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }
    c_prev += offset;

    /*by*width_uv + bx;*/
    cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
    /*by*width_uv + bx;*/
    cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);

    comp = video->currVop;

    c_comp  = comp->yChan + offset;
    cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);
    cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);


    /* Copy previous reconstructed frame into the current frame */
    PutSKIPPED_MB(c_comp,  c_prev, width);
    PutSKIPPED_B(cu_comp, cu_prev, width_uv);
    PutSKIPPED_B(cv_comp, cv_prev, width_uv);

    /*  10/24/2000 post_processing semaphore generation */
#ifdef PV_POSTPROC_ON // 2/14/2001
    if (video->postFilterType != PV_NO_POST_PROC)
    {
        imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
        /* Post-processing mode (copy previous MB) */
        pp_prev1 = video->pstprcTypPrv + imv;
        pp_dec_y = video->pstprcTypCur + imv;
        *pp_dec_y = *pp_prev1;
        *(pp_dec_y + 1) = *(pp_prev1 + 1);
        *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);
        *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);

        /* chrominance */
        /*4*MB_in_width*MB_in_height*/
        pp_prev1 = video->pstprcTypPrv + (size >> 6) +
                   ((imv + (xpos >> 3)) >> 2);
        pp_dec_u = video->pstprcTypCur + (size >> 6) +
                   ((imv + (xpos >> 3)) >> 2);
        *pp_dec_u = *pp_prev1;
        pp_dec_u[size>>8] = pp_prev1[size>>8];
    }
#endif
    /*----------------------------------------------------------------------------
    ; Return nothing or data or data pointer
    ----------------------------------------------------------------------------*/

    return;
}","void  SkippedMBMotionComp(
    VideoDecData *VAR_0
)
{
    Vop *VAR_1 = VAR_0->prevVop;
    Vop *VAR_2;
    int VAR_3, VAR_4;
    PIXEL *VAR_5, *VAR_6;
    PIXEL *VAR_7, *VAR_8;
    PIXEL *VAR_9, *VAR_10;
    int VAR_11, VAR_12;
    int32 VAR_13;
#ifdef VAR_14 /* COMMENT_0 */
    int VAR_15;
    int32 VAR_16 = (int32) VAR_0->nTotalMB << 8;
    uint8 *VAR_17, *VAR_18;
    uint8 *VAR_19;
    int VAR_20 = VAR_0->nMBPerRow << 1;
#endif

    VAR_11 = VAR_0->width;
    VAR_12  = VAR_11 >> 1;
    VAR_3 = VAR_0->mbnum_row << 4 ;
    VAR_4 = VAR_0->mbnum_col << 4 ;
    VAR_13 = (int32)VAR_3 * VAR_11 + VAR_4;


    /* COMMENT_1 */
    /* COMMENT_2 */
    VAR_6  = VAR_1->yChan;
    if (!VAR_6) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }
    VAR_6 += VAR_13;

    /* COMMENT_3 */
    VAR_8 = VAR_1->uChan + (VAR_13 >> 2) + (VAR_4 >> 2);
    /* COMMENT_3 */
    VAR_10 = VAR_1->vChan + (VAR_13 >> 2) + (VAR_4 >> 2);

    VAR_2 = VAR_0->currVop;

    VAR_5  = VAR_2->yChan + VAR_13;
    VAR_7 = VAR_2->uChan + (VAR_13 >> 2) + (VAR_4 >> 2);
    VAR_9 = VAR_2->vChan + (VAR_13 >> 2) + (VAR_4 >> 2);


    /* COMMENT_4 */
    PutSKIPPED_MB(VAR_5,  VAR_6, VAR_11);
    PutSKIPPED_B(VAR_7, VAR_8, VAR_12);
    PutSKIPPED_B(VAR_9, VAR_10, VAR_12);

    /* COMMENT_5 */
#ifdef VAR_14 /* COMMENT_6 */
    if (VAR_0->postFilterType != VAR_21)
    {
        VAR_15 = (VAR_13 >> 6) - (VAR_4 >> 6) + (VAR_4 >> 3);
        /* COMMENT_7 */
        VAR_19 = VAR_0->pstprcTypPrv + VAR_15;
        VAR_17 = VAR_0->pstprcTypCur + VAR_15;
        *VAR_17 = *VAR_19;
        *(VAR_17 + 1) = *(VAR_19 + 1);
        *(VAR_17 + VAR_20) = *(VAR_19 + VAR_20);
        *(VAR_17 + VAR_20 + 1) = *(VAR_19 + VAR_20 + 1);

        /* COMMENT_8 */
        /* COMMENT_9 */
        VAR_19 = VAR_0->pstprcTypPrv + (VAR_16 >> 6) +
                   ((VAR_15 + (VAR_4 >> 3)) >> 2);
        VAR_18 = VAR_0->pstprcTypCur + (VAR_16 >> 6) +
                   ((VAR_15 + (VAR_4 >> 3)) >> 2);
        *VAR_18 = *VAR_19;
        VAR_18[VAR_16>>8] = VAR_19[VAR_16>>8];
    }
#endif
    /* COMMENT_10 */
                                            
                                                                                  

    return;
}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/mb_motion_comp.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,14 @@
 
     /* zero motion compensation for previous frame */
     /*mby*width + mbx;*/
-    c_prev  = prev->yChan + offset;
+    c_prev  = prev->yChan;
+    if (!c_prev) {
+        ALOGE(""b/35269635"");
+        android_errorWriteLog(0x534e4554, ""35269635"");
+        return;
+    }
+    c_prev += offset;
+
     /*by*width_uv + bx;*/
     cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
     /*by*width_uv + bx;*/","{'deleted_lines': ['    c_prev  = prev->yChan + offset;'], 'added_lines': ['    c_prev  = prev->yChan;', '    if (!c_prev) {', '        ALOGE(""b/35269635"");', '        android_errorWriteLog(0x534e4554, ""35269635"");', '        return;', '    }', '    c_prev += offset;', '']}",True,"A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635.",5.5,MEDIUM,1,valid,,5
CVE-2017-0600,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,android,"Fix NPDs in h263 decoder

Bug: 35269635
Test: decoded PoC with and without patch
Change-Id: I636a14360c7801cc5bca63c9cb44d1d235df8fd8
(cherry picked from commit 2ad2a92318a3b9daf78ebcdc597085adbf32600d)
",961e5ac5788b52304e64b9a509781beaf5201fb0,https://android.googlesource.com/platform/frameworks/av/+/961e5ac5788b52304e64b9a509781beaf5201fb0,media/libstagefright/codecs/m4v_h263/dec/src/mb_motion_comp.cpp,MBMotionComp,"void  MBMotionComp(
VideoDecData *video,
int CBP
)
{
Vop *prev = video->prevVop;
int mbnum = video->mbnum;
int MB_in_width = video->nMBPerRow;
int ypos, xpos;
PIXEL *c_comp, *c_prev;
PIXEL *cu_comp, *cu_prev;
PIXEL *cv_comp, *cv_prev;
int height, width, pred_width;
int imv, mvwidth;
int32 offset;
uint8 mode;
uint8 *pred_block, *pred;
int dx, dy;
MOT px[4], py[4];
int xpred, ypred;
int xsum;
int round1;
#ifdef PV_POSTPROC_ON     
int32 size = (int32) video->nTotalMB << 8;
uint8 *pp_dec_y, *pp_dec_u;
int ll[4];
int tmp = 0;
uint8 msk_deblock = 0;
#endif
round1 = (int)(1 - video->currVop->roundingType);
width = video->width;
height = video->height;
mvwidth = MB_in_width << 1;
ypos = video->mbnum_row << 4 ;
xpos = video->mbnum_col << 4 ;
offset = (int32)ypos * width + xpos;
mode = video->headerInfo.Mode[mbnum];
imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
if (mode & INTER_1VMASK)
{
dx = px[0] = px[1] = px[2] = px[3] = video->motX[imv];
dy = py[0] = py[1] = py[2] = py[3] = video->motY[imv];
if ((dx & 3) == 0)
{
dx = dx >> 1;
}
else
{
dx = (dx >> 1) | 1;
}
if ((dy & 3) == 0)
{
dy = dy >> 1;
}
else
{
dy = (dy >> 1) | 1;
}
}
else
{
px[0] = video->motX[imv];
px[1] = video->motX[imv+1];
px[2] = video->motX[imv+mvwidth];
px[3] = video->motX[imv+mvwidth+1];
xsum = px[0] + px[1] + px[2] + px[3];
dx = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
(((PV_ABS(xsum)) >> 4) << 1));
py[0] = video->motY[imv];
py[1] = video->motY[imv+1];
py[2] = video->motY[imv+mvwidth];
py[3] = video->motY[imv+mvwidth+1];
xsum = py[0] + py[1] + py[2] + py[3];
dy = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
(((PV_ABS(xsum)) >> 4) << 1));
}
c_prev  = prev->yChan;
pred_block = video->mblock->pred_block;
c_comp = video->currVop->yChan + offset;
xpred = (int)((xpos << 1) + px[0]);
ypred = (int)((ypos << 1) + py[0]);
if ((CBP >> 5)&1)
{
pred = pred_block;
pred_width = 16;
}
else
{
pred = c_comp;
pred_width = width;
}
if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
{   
;
GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
}
else
{   
GetPredOutside(xpred, ypred, c_prev,
pred, width, height, round1, pred_width);
}
xpred = (int)(((xpos + B_SIZE) << 1) + px[1]);
ypred = (int)((ypos << 1) + py[1]);
if ((CBP >> 4)&1)
{
pred = pred_block + 8;
pred_width = 16;
}
else
{
pred = c_comp + 8;
pred_width = width;
}
if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
{   
GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
}
else
{   
GetPredOutside(xpred, ypred, c_prev,
pred, width, height, round1, pred_width);
}
xpred = (int)((xpos << 1) + px[2]);
ypred = (int)(((ypos + B_SIZE) << 1) + py[2]);
if ((CBP >> 3)&1)
{
pred = pred_block + 128;
pred_width = 16;
}
else
{
pred = c_comp + (width << 3);
pred_width = width;
}
if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
{   
GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
}
else
{   
GetPredOutside(xpred, ypred, c_prev,
pred, width, height, round1, pred_width);
}
xpred = (int)(((xpos + B_SIZE) << 1) + px[3]);
ypred = (int)(((ypos + B_SIZE) << 1) + py[3]);
if ((CBP >> 2)&1)
{
pred = pred_block + 136;
pred_width = 16;
}
else
{
pred = c_comp + (width << 3) + 8;
pred_width = width;
}
if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
{   
GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
}
else
{   
GetPredOutside(xpred, ypred, c_prev,
pred, width, height, round1, pred_width);
}
#ifdef PV_POSTPROC_ON
if (video->postFilterType != PV_NO_POST_PROC)
{
if (mode&INTER_1VMASK)
{
pp_dec_y = video->pstprcTypCur + imv;
ll[0] = 1;
ll[1] = mvwidth - 1;
ll[2] = 1;
ll[3] = -mvwidth - 1;
msk_deblock = pp_semaphore_luma(xpred, ypred, pp_dec_y,
video->pstprcTypPrv, ll, &tmp, px[0], py[0], mvwidth,
width, height);
pp_dec_u = video->pstprcTypCur + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
pp_semaphore_chroma_inter(xpred, ypred, pp_dec_u,
video->pstprcTypPrv, dx, dy, mvwidth, height, size,
tmp, msk_deblock);
}
else
{
pp_dec_y = video->pstprcTypCur + imv;
*pp_dec_y = 4;
*(pp_dec_y + 1) = 4;
*(pp_dec_y + mvwidth) = 4;
*(pp_dec_y + mvwidth + 1) = 4;
pp_dec_u = video->pstprcTypCur + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
*pp_dec_u = 4;
pp_dec_u[size>>8] = 4;
}
}
#endif
width >>= 1;
height >>= 1;
cu_prev = prev->uChan;
cv_prev = prev->vChan;
xpred = xpos + dx;
ypred = ypos + dy;
cu_comp = video->currVop->uChan + (offset >> 2) + (xpos >> 2);
cv_comp = video->currVop->vChan + (offset >> 2) + (xpos >> 2);
if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) && ypred >= 0 &&
ypred <= ((height << 1) - (2*B_SIZE)))
{
if ((CBP >> 1)&1)
{
pred = pred_block + 256;
pred_width = 16;
}
else
{
pred = cu_comp;
pred_width = width;
}
GetPredAdvBTable[ypred&1][xpred&1](cu_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
if (CBP&1)
{
pred = pred_block + 264;
pred_width = 16;
}
else
{
pred = cv_comp;
pred_width = width;
}
GetPredAdvBTable[ypred&1][xpred&1](cv_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
return ;
}
else
{
if ((CBP >> 1)&1)
{
pred = pred_block + 256;
pred_width = 16;
}
else
{
pred = cu_comp;
pred_width = width;
}
GetPredOutside(xpred, ypred,    cu_prev,
pred, width, height, round1, pred_width);
if (CBP&1)
{
pred = pred_block + 264;
pred_width = 16;
}
else
{
pred = cv_comp;
pred_width = width;
}
GetPredOutside(xpred, ypred,    cv_prev,
pred, width, height, round1, pred_width);
return ;
}
}","void  MBMotionComp(
VideoDecData *VAR_0,
int VAR_1
)
{
Vop *VAR_2 = VAR_0->prevVop;
int VAR_3 = VAR_0->mbnum;
int VAR_4 = VAR_0->nMBPerRow;
int VAR_5, VAR_6;
PIXEL *VAR_7, *VAR_8;
PIXEL *VAR_9, *VAR_10;
PIXEL *VAR_11, *VAR_12;
int VAR_13, VAR_14, VAR_15;
int VAR_16, VAR_17;
int32 VAR_18;
uint8 VAR_19;
uint8 *VAR_20, *VAR_21;
int VAR_22, VAR_23;
MOT VAR_24[4], VAR_25[4];
int VAR_26, VAR_27;
int VAR_28;
int VAR_29;
#ifdef VAR_30 
int32 VAR_31 = (int32) VAR_0->nTotalMB << 8;
uint8 *VAR_32, *VAR_33;
int VAR_34[4];
int VAR_35 = 0;
uint8 VAR_36 = 0;
#endif
VAR_29 = (int)(1 - VAR_0->currVop->roundingType);
VAR_14 = VAR_0->width;
VAR_13 = VAR_0->height;
VAR_17 = VAR_4 << 1;
VAR_5 = VAR_0->mbnum_row << 4 ;
VAR_6 = VAR_0->mbnum_col << 4 ;
VAR_18 = (int32)VAR_5 * VAR_14 + VAR_6;
VAR_19 = VAR_0->headerInfo.Mode[VAR_3];
VAR_16 = (VAR_18 >> 6) - (VAR_6 >> 6) + (VAR_6 >> 3);
if (VAR_19 & VAR_37)
{
VAR_22 = VAR_24[0] = VAR_24[1] = VAR_24[2] = VAR_24[3] = VAR_0->motX[VAR_16];
VAR_23 = VAR_25[0] = VAR_25[1] = VAR_25[2] = VAR_25[3] = VAR_0->motY[VAR_16];
if ((VAR_22 & 3) == 0)
{
VAR_22 = VAR_22 >> 1;
}
else
{
VAR_22 = (VAR_22 >> 1) | 1;
}
if ((VAR_23 & 3) == 0)
{
VAR_23 = VAR_23 >> 1;
}
else
{
VAR_23 = (VAR_23 >> 1) | 1;
}
}
else
{
VAR_24[0] = VAR_0->motX[VAR_16];
VAR_24[1] = VAR_0->motX[VAR_16+1];
VAR_24[2] = VAR_0->motX[VAR_16+VAR_17];
VAR_24[3] = VAR_0->motX[VAR_16+VAR_17+1];
VAR_28 = VAR_24[0] + VAR_24[1] + VAR_24[2] + VAR_24[3];
VAR_22 = PV_SIGN(VAR_28) * (VAR_38[(PV_ABS(VAR_28)) & 0xF] +
(((PV_ABS(VAR_28)) >> 4) << 1));
VAR_25[0] = VAR_0->motY[VAR_16];
VAR_25[1] = VAR_0->motY[VAR_16+1];
VAR_25[2] = VAR_0->motY[VAR_16+VAR_17];
VAR_25[3] = VAR_0->motY[VAR_16+VAR_17+1];
VAR_28 = VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
VAR_23 = PV_SIGN(VAR_28) * (VAR_38[(PV_ABS(VAR_28)) & 0xF] +
(((PV_ABS(VAR_28)) >> 4) << 1));
}
VAR_8  = VAR_2->yChan;
VAR_20 = VAR_0->mblock->pred_block;
VAR_7 = VAR_0->currVop->yChan + VAR_18;
VAR_26 = (int)((VAR_6 << 1) + VAR_24[0]);
VAR_27 = (int)((VAR_5 << 1) + VAR_25[0]);
if ((VAR_1 >> 5)&1)
{
VAR_21 = VAR_20;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_7;
VAR_15 = VAR_14;
}
if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
{   
;
VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
}
else
{   
GetPredOutside(VAR_26, VAR_27, VAR_8,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
}
VAR_26 = (int)(((VAR_6 + VAR_39) << 1) + VAR_24[1]);
VAR_27 = (int)((VAR_5 << 1) + VAR_25[1]);
if ((VAR_1 >> 4)&1)
{
VAR_21 = VAR_20 + 8;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_7 + 8;
VAR_15 = VAR_14;
}
if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
{   
VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
}
else
{   
GetPredOutside(VAR_26, VAR_27, VAR_8,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
}
VAR_26 = (int)((VAR_6 << 1) + VAR_24[2]);
VAR_27 = (int)(((VAR_5 + VAR_39) << 1) + VAR_25[2]);
if ((VAR_1 >> 3)&1)
{
VAR_21 = VAR_20 + 128;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_7 + (VAR_14 << 3);
VAR_15 = VAR_14;
}
if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
{   
VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
}
else
{   
GetPredOutside(VAR_26, VAR_27, VAR_8,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
}
VAR_26 = (int)(((VAR_6 + VAR_39) << 1) + VAR_24[3]);
VAR_27 = (int)(((VAR_5 + VAR_39) << 1) + VAR_25[3]);
if ((VAR_1 >> 2)&1)
{
VAR_21 = VAR_20 + 136;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_7 + (VAR_14 << 3) + 8;
VAR_15 = VAR_14;
}
if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
{   
VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
}
else
{   
GetPredOutside(VAR_26, VAR_27, VAR_8,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
}
#ifdef VAR_30
if (VAR_0->postFilterType != VAR_41)
{
if (VAR_19&VAR_37)
{
VAR_32 = VAR_0->pstprcTypCur + VAR_16;
VAR_34[0] = 1;
VAR_34[1] = VAR_17 - 1;
VAR_34[2] = 1;
VAR_34[3] = -VAR_17 - 1;
VAR_36 = pp_semaphore_luma(VAR_26, VAR_27, VAR_32,
VAR_0->pstprcTypPrv, VAR_34, &VAR_35, VAR_24[0], VAR_25[0], VAR_17,
VAR_14, VAR_13);
VAR_33 = VAR_0->pstprcTypCur + (VAR_31 >> 6) +
((VAR_16 + (VAR_6 >> 3)) >> 2);
pp_semaphore_chroma_inter(VAR_26, VAR_27, VAR_33,
VAR_0->pstprcTypPrv, VAR_22, VAR_23, VAR_17, VAR_13, VAR_31,
VAR_35, VAR_36);
}
else
{
VAR_32 = VAR_0->pstprcTypCur + VAR_16;
*VAR_32 = 4;
*(VAR_32 + 1) = 4;
*(VAR_32 + VAR_17) = 4;
*(VAR_32 + VAR_17 + 1) = 4;
VAR_33 = VAR_0->pstprcTypCur + (VAR_31 >> 6) +
((VAR_16 + (VAR_6 >> 3)) >> 2);
*VAR_33 = 4;
VAR_33[VAR_31>>8] = 4;
}
}
#endif
VAR_14 >>= 1;
VAR_13 >>= 1;
VAR_10 = VAR_2->uChan;
VAR_12 = VAR_2->vChan;
VAR_26 = VAR_6 + VAR_22;
VAR_27 = VAR_5 + VAR_23;
VAR_9 = VAR_0->currVop->uChan + (VAR_18 >> 2) + (VAR_6 >> 2);
VAR_11 = VAR_0->currVop->vChan + (VAR_18 >> 2) + (VAR_6 >> 2);
if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) && VAR_27 >= 0 &&
VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
{
if ((VAR_1 >> 1)&1)
{
VAR_21 = VAR_20 + 256;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_9;
VAR_15 = VAR_14;
}
VAR_40[VAR_27&1][VAR_26&1](VAR_10 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
if (VAR_1&1)
{
VAR_21 = VAR_20 + 264;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_11;
VAR_15 = VAR_14;
}
VAR_40[VAR_27&1][VAR_26&1](VAR_12 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
return ;
}
else
{
if ((VAR_1 >> 1)&1)
{
VAR_21 = VAR_20 + 256;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_9;
VAR_15 = VAR_14;
}
GetPredOutside(VAR_26, VAR_27,    VAR_10,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
if (VAR_1&1)
{
VAR_21 = VAR_20 + 264;
VAR_15 = 16;
}
else
{
VAR_21 = VAR_11;
VAR_15 = VAR_14;
}
GetPredOutside(VAR_26, VAR_27,    VAR_12,
VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
return ;
}
}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/mb_motion_comp.cpp/vul/before/1.json,"void  MBMotionComp(
    VideoDecData *video,
    int CBP
)
{

    /*----------------------------------------------------------------------------
    ; Define all local variables
    ----------------------------------------------------------------------------*/
    /* Previous Video Object Plane */
    Vop *prev = video->prevVop;

    /* Current Macroblock (MB) in the VOP */
    int mbnum = video->mbnum;

    /* Number of MB per data row */
    int MB_in_width = video->nMBPerRow;
    int ypos, xpos;
    PIXEL *c_comp, *c_prev;
    PIXEL *cu_comp, *cu_prev;
    PIXEL *cv_comp, *cv_prev;
    int height, width, pred_width;
    int imv, mvwidth;
    int32 offset;
    uint8 mode;
    uint8 *pred_block, *pred;

    /* Motion vector (dx,dy) in half-pel resolution */
    int dx, dy;

    MOT px[4], py[4];
    int xpred, ypred;
    int xsum;
    int round1;
#ifdef PV_POSTPROC_ON // 2/14/2001      
    /* Total number of pixels in the VOL */
    int32 size = (int32) video->nTotalMB << 8;
    uint8 *pp_dec_y, *pp_dec_u;
    int ll[4];
    int tmp = 0;
    uint8 msk_deblock = 0;
#endif
    /*----------------------------------------------------------------------------
    ; Function body here
    ----------------------------------------------------------------------------*/
    /* Set rounding type */
    /* change from array to single 09/29/2000 */
    round1 = (int)(1 - video->currVop->roundingType);

    /* width of luminance data in pixels (y axis) */
    width = video->width;

    /* heigth of luminance data in pixels (x axis) */
    height = video->height;

    /* number of blocks per row */
    mvwidth = MB_in_width << 1;

    /* starting y position in current MB; origin of MB */
    ypos = video->mbnum_row << 4 ;
    /* starting x position in current MB; origin of MB */
    xpos = video->mbnum_col << 4 ;

    /* offset to (x,y) position in current luminance MB */
    /* in pixel resolution                              */
    /* ypos*width -> row, +x -> column */
    offset = (int32)ypos * width + xpos;

    /* get mode for current MB */
    mode = video->headerInfo.Mode[mbnum];

    /* block index */
    /* imv = (xpos/8) + ((ypos/8) * mvwidth) */
    imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
    if (mode & INTER_1VMASK)
    {
        dx = px[0] = px[1] = px[2] = px[3] = video->motX[imv];
        dy = py[0] = py[1] = py[2] = py[3] = video->motY[imv];
        if ((dx & 3) == 0)
        {
            dx = dx >> 1;
        }
        else
        {
            /* x component of MV is or'ed for rounding (?) */
            dx = (dx >> 1) | 1;
        }

        /* y component of motion vector; divide by 2 for to */
        /* convert to full-pel resolution.                  */
        if ((dy & 3) == 0)
        {
            dy = dy >> 1;
        }
        else
        {
            /* y component of MV is or'ed for rounding (?) */
            dy = (dy >> 1) | 1;
        }
    }
    else
    {
        px[0] = video->motX[imv];
        px[1] = video->motX[imv+1];
        px[2] = video->motX[imv+mvwidth];
        px[3] = video->motX[imv+mvwidth+1];
        xsum = px[0] + px[1] + px[2] + px[3];
        dx = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
                              (((PV_ABS(xsum)) >> 4) << 1));
        py[0] = video->motY[imv];
        py[1] = video->motY[imv+1];
        py[2] = video->motY[imv+mvwidth];
        py[3] = video->motY[imv+mvwidth+1];
        xsum = py[0] + py[1] + py[2] + py[3];
        dy = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
                              (((PV_ABS(xsum)) >> 4) << 1));
    }

    /* Pointer to previous luminance frame */
    c_prev  = prev->yChan;
    if (!c_prev) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }

    pred_block = video->mblock->pred_block;

    /* some blocks have no residue or INTER4V */
    /*if (mode == MODE_INTER4V)   05/08/15 */
    /* Motion Compensation for an 8x8 block within a MB */
    /* (4 MV per MB) */



    /* Call function that performs luminance prediction */
    /*      luminance_pred_mode_inter4v(xpos, ypos, px, py, c_prev,
                    video->mblock->pred_block, width, height,
                    round1, mvwidth, &xsum, &ysum);*/
    c_comp = video->currVop->yChan + offset;


    xpred = (int)((xpos << 1) + px[0]);
    ypred = (int)((ypos << 1) + py[0]);

    if ((CBP >> 5)&1)
    {
        pred = pred_block;
        pred_width = 16;
    }
    else
    {
        pred = c_comp;
        pred_width = width;
    }

    /* check whether the MV points outside the frame */
    if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
    {   /*****************************/
        /* (x,y) is inside the frame */
        /*****************************/
        ;
        GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
    }
    else
    {   /******************************/
        /* (x,y) is outside the frame */
        /******************************/
        GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
    }


    /* Compute prediction values over current luminance MB */
    /* (blocks 1); add motion vector prior to input;       */
    /* add 8 to x_pos to advance to next block         */
    xpred = (int)(((xpos + B_SIZE) << 1) + px[1]);
    ypred = (int)((ypos << 1) + py[1]);

    if ((CBP >> 4)&1)
    {
        pred = pred_block + 8;
        pred_width = 16;
    }
    else
    {
        pred = c_comp + 8;
        pred_width = width;
    }

    /* check whether the MV points outside the frame */
    if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
    {   /*****************************/
        /* (x,y) is inside the frame */
        /*****************************/
        GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
    }
    else
    {   /******************************/
        /* (x,y) is outside the frame */
        /******************************/
        GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
    }



    /* Compute prediction values over current luminance MB */
    /* (blocks 2); add motion vector prior to input        */
    /* add 8 to y_pos to advance to block on next row      */
    xpred = (int)((xpos << 1) + px[2]);
    ypred = (int)(((ypos + B_SIZE) << 1) + py[2]);

    if ((CBP >> 3)&1)
    {
        pred = pred_block + 128;
        pred_width = 16;
    }
    else
    {
        pred = c_comp + (width << 3);
        pred_width = width;
    }

    /* check whether the MV points outside the frame */
    if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
    {   /*****************************/
        /* (x,y) is inside the frame */
        /*****************************/
        GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
    }
    else
    {   /******************************/
        /* (x,y) is outside the frame */
        /******************************/
        GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
    }



    /* Compute prediction values over current luminance MB */
    /* (blocks 3); add motion vector prior to input;       */
    /* add 8 to x_pos and y_pos to advance to next block   */
    /* on next row                         */
    xpred = (int)(((xpos + B_SIZE) << 1) + px[3]);
    ypred = (int)(((ypos + B_SIZE) << 1) + py[3]);

    if ((CBP >> 2)&1)
    {
        pred = pred_block + 136;
        pred_width = 16;
    }
    else
    {
        pred = c_comp + (width << 3) + 8;
        pred_width = width;
    }

    /* check whether the MV points outside the frame */
    if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
    {   /*****************************/
        /* (x,y) is inside the frame */
        /*****************************/
        GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
    }
    else
    {   /******************************/
        /* (x,y) is outside the frame */
        /******************************/
        GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
    }
    /* Call function to set de-blocking and de-ringing */
    /*   semaphores for luminance                      */

#ifdef PV_POSTPROC_ON
    if (video->postFilterType != PV_NO_POST_PROC)
    {
        if (mode&INTER_1VMASK)
        {
            pp_dec_y = video->pstprcTypCur + imv;
            ll[0] = 1;
            ll[1] = mvwidth - 1;
            ll[2] = 1;
            ll[3] = -mvwidth - 1;
            msk_deblock = pp_semaphore_luma(xpred, ypred, pp_dec_y,
                                            video->pstprcTypPrv, ll, &tmp, px[0], py[0], mvwidth,
                                            width, height);

            pp_dec_u = video->pstprcTypCur + (size >> 6) +
                       ((imv + (xpos >> 3)) >> 2);

            pp_semaphore_chroma_inter(xpred, ypred, pp_dec_u,
                                      video->pstprcTypPrv, dx, dy, mvwidth, height, size,
                                      tmp, msk_deblock);
        }
        else
        {
            /* Post-processing mode (MBM_INTER8) */
            /* deblocking and deringing) */
            pp_dec_y = video->pstprcTypCur + imv;
            *pp_dec_y = 4;
            *(pp_dec_y + 1) = 4;
            *(pp_dec_y + mvwidth) = 4;
            *(pp_dec_y + mvwidth + 1) = 4;
            pp_dec_u = video->pstprcTypCur + (size >> 6) +
                       ((imv + (xpos >> 3)) >> 2);
            *pp_dec_u = 4;
            pp_dec_u[size>>8] = 4;
        }
    }
#endif


    /* xpred and ypred calculation for Chrominance is */
    /* in full-pel resolution.                        */

    /* Chrominance */
    /* width of chrominance data in pixels (y axis) */
    width >>= 1;

    /* heigth of chrominance data in pixels (x axis) */
    height >>= 1;

    /* Pointer to previous chrominance b frame */
    cu_prev = prev->uChan;

    /* Pointer to previous chrominance r frame */
    cv_prev = prev->vChan;

    /* x position in prediction data offset by motion vector */
    /* xpred calculation for Chrominance is in full-pel      */
    /* resolution.                                           */
    xpred = xpos + dx;

    /* y position in prediction data offset by motion vector */
    /* ypred calculation for Chrominance is in full-pel      */
    /* resolution.                                           */
    ypred = ypos + dy;

    cu_comp = video->currVop->uChan + (offset >> 2) + (xpos >> 2);
    cv_comp = video->currVop->vChan + (offset >> 2) + (xpos >> 2);

    /* Call function that performs chrominance prediction */
    /*      chrominance_pred(xpred, ypred, cu_prev, cv_prev,
            pred_block, width_uv, height_uv,
            round1);*/
    if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) && ypred >= 0 &&
            ypred <= ((height << 1) - (2*B_SIZE)))
    {
        /*****************************/
        /* (x,y) is inside the frame */
        /*****************************/
        if ((CBP >> 1)&1)
        {
            pred = pred_block + 256;
            pred_width = 16;
        }
        else
        {
            pred = cu_comp;
            pred_width = width;
        }

        /* Compute prediction for Chrominance b (block[4]) */
        GetPredAdvBTable[ypred&1][xpred&1](cu_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);

        if (CBP&1)
        {
            pred = pred_block + 264;
            pred_width = 16;
        }
        else
        {
            pred = cv_comp;
            pred_width = width;
        }
        /* Compute prediction for Chrominance r (block[5]) */
        GetPredAdvBTable[ypred&1][xpred&1](cv_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);

        return ;
    }
    else
    {
        /******************************/
        /* (x,y) is outside the frame */
        /******************************/
        if ((CBP >> 1)&1)
        {
            pred = pred_block + 256;
            pred_width = 16;
        }
        else
        {
            pred = cu_comp;
            pred_width = width;
        }

        /* Compute prediction for Chrominance b (block[4]) */
        GetPredOutside(xpred, ypred,    cu_prev,
                       pred, width, height, round1, pred_width);

        if (CBP&1)
        {
            pred = pred_block + 264;
            pred_width = 16;
        }
        else
        {
            pred = cv_comp;
            pred_width = width;
        }

        /* Compute prediction for Chrominance r (block[5]) */
        GetPredOutside(xpred, ypred,    cv_prev,
                       pred, width, height, round1, pred_width);

        return ;
    }

}","void  MBMotionComp(
    VideoDecData *VAR_0,
    int VAR_1
)
{

    /* COMMENT_0 */
                                
                                                                                  
    /* COMMENT_3 */
    Vop *VAR_2 = VAR_0->prevVop;

    /* COMMENT_4 */
    int VAR_3 = VAR_0->mbnum;

    /* COMMENT_5 */
    int VAR_4 = VAR_0->nMBPerRow;
    int VAR_5, VAR_6;
    PIXEL *VAR_7, *VAR_8;
    PIXEL *VAR_9, *VAR_10;
    PIXEL *VAR_11, *VAR_12;
    int VAR_13, VAR_14, VAR_15;
    int VAR_16, VAR_17;
    int32 VAR_18;
    uint8 VAR_19;
    uint8 *VAR_20, *VAR_21;

    /* COMMENT_6 */
    int VAR_22, VAR_23;

    MOT VAR_24[4], VAR_25[4];
    int VAR_26, VAR_27;
    int VAR_28;
    int VAR_29;
#ifdef VAR_30 /* COMMENT_7 */
    /* COMMENT_8 */
    int32 VAR_31 = (int32) VAR_0->nTotalMB << 8;
    uint8 *VAR_32, *VAR_33;
    int VAR_34[4];
    int VAR_35 = 0;
    uint8 VAR_36 = 0;
#endif
    /* COMMENT_9 */
                        
                                                                                  
    /* COMMENT_12 */
    /* COMMENT_13 */
    VAR_29 = (int)(1 - VAR_0->currVop->roundingType);

    /* COMMENT_14 */
    VAR_14 = VAR_0->width;

    /* COMMENT_15 */
    VAR_13 = VAR_0->height;

    /* COMMENT_16 */
    VAR_17 = VAR_4 << 1;

    /* COMMENT_17 */
    VAR_5 = VAR_0->mbnum_row << 4 ;
    /* COMMENT_18 */
    VAR_6 = VAR_0->mbnum_col << 4 ;

    /* COMMENT_19 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    VAR_18 = (int32)VAR_5 * VAR_14 + VAR_6;

    /* COMMENT_22 */
    VAR_19 = VAR_0->headerInfo.Mode[VAR_3];

    /* COMMENT_23 */
    /* COMMENT_24 */
    VAR_16 = (VAR_18 >> 6) - (VAR_6 >> 6) + (VAR_6 >> 3);
    if (VAR_19 & VAR_37)
    {
        VAR_22 = VAR_24[0] = VAR_24[1] = VAR_24[2] = VAR_24[3] = VAR_0->motX[VAR_16];
        VAR_23 = VAR_25[0] = VAR_25[1] = VAR_25[2] = VAR_25[3] = VAR_0->motY[VAR_16];
        if ((VAR_22 & 3) == 0)
        {
            VAR_22 = VAR_22 >> 1;
        }
        else
        {
            /* COMMENT_25 */
            VAR_22 = (VAR_22 >> 1) | 1;
        }

        /* COMMENT_26 */
        /* COMMENT_27 */
        if ((VAR_23 & 3) == 0)
        {
            VAR_23 = VAR_23 >> 1;
        }
        else
        {
            /* COMMENT_28 */
            VAR_23 = (VAR_23 >> 1) | 1;
        }
    }
    else
    {
        VAR_24[0] = VAR_0->motX[VAR_16];
        VAR_24[1] = VAR_0->motX[VAR_16+1];
        VAR_24[2] = VAR_0->motX[VAR_16+VAR_17];
        VAR_24[3] = VAR_0->motX[VAR_16+VAR_17+1];
        VAR_28 = VAR_24[0] + VAR_24[1] + VAR_24[2] + VAR_24[3];
        VAR_22 = PV_SIGN(VAR_28) * (VAR_38[(PV_ABS(VAR_28)) & 0xF] +
                              (((PV_ABS(VAR_28)) >> 4) << 1));
        VAR_25[0] = VAR_0->motY[VAR_16];
        VAR_25[1] = VAR_0->motY[VAR_16+1];
        VAR_25[2] = VAR_0->motY[VAR_16+VAR_17];
        VAR_25[3] = VAR_0->motY[VAR_16+VAR_17+1];
        VAR_28 = VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
        VAR_23 = PV_SIGN(VAR_28) * (VAR_38[(PV_ABS(VAR_28)) & 0xF] +
                              (((PV_ABS(VAR_28)) >> 4) << 1));
    }

    /* COMMENT_29 */
    VAR_8  = VAR_2->yChan;
    if (!VAR_8) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }

    VAR_20 = VAR_0->mblock->pred_block;

    /* COMMENT_30 */
    /* COMMENT_31 */
    /* COMMENT_32 */
    /* COMMENT_33 */



    /* COMMENT_34 */
    /* COMMENT_35 */
                                                             
                                                     
    VAR_7 = VAR_0->currVop->yChan + VAR_18;


    VAR_26 = (int)((VAR_6 << 1) + VAR_24[0]);
    VAR_27 = (int)((VAR_5 << 1) + VAR_25[0]);

    if ((VAR_1 >> 5)&1)
    {
        VAR_21 = VAR_20;
        VAR_15 = 16;
    }
    else
    {
        VAR_21 = VAR_7;
        VAR_15 = VAR_14;
    }

    /* COMMENT_38 */
    if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
            VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
    {   /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_39 */
        ;
        VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
    }
    else
    {   /* COMMENT_41 */
        /* COMMENT_42 */
        /* COMMENT_41 */
        GetPredOutside(VAR_26, VAR_27, VAR_8,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
    }


    /* COMMENT_43 */
    /* COMMENT_44 */
    /* COMMENT_45 */
    VAR_26 = (int)(((VAR_6 + VAR_39) << 1) + VAR_24[1]);
    VAR_27 = (int)((VAR_5 << 1) + VAR_25[1]);

    if ((VAR_1 >> 4)&1)
    {
        VAR_21 = VAR_20 + 8;
        VAR_15 = 16;
    }
    else
    {
        VAR_21 = VAR_7 + 8;
        VAR_15 = VAR_14;
    }

    /* COMMENT_38 */
    if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
            VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
    {   /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_39 */
        VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
    }
    else
    {   /* COMMENT_41 */
        /* COMMENT_42 */
        /* COMMENT_41 */
        GetPredOutside(VAR_26, VAR_27, VAR_8,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
    }



    /* COMMENT_43 */
    /* COMMENT_46 */
    /* COMMENT_47 */
    VAR_26 = (int)((VAR_6 << 1) + VAR_24[2]);
    VAR_27 = (int)(((VAR_5 + VAR_39) << 1) + VAR_25[2]);

    if ((VAR_1 >> 3)&1)
    {
        VAR_21 = VAR_20 + 128;
        VAR_15 = 16;
    }
    else
    {
        VAR_21 = VAR_7 + (VAR_14 << 3);
        VAR_15 = VAR_14;
    }

    /* COMMENT_38 */
    if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
            VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
    {   /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_39 */
        VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
    }
    else
    {   /* COMMENT_41 */
        /* COMMENT_42 */
        /* COMMENT_41 */
        GetPredOutside(VAR_26, VAR_27, VAR_8,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
    }



    /* COMMENT_43 */
    /* COMMENT_48 */
    /* COMMENT_49 */
    /* COMMENT_50 */
    VAR_26 = (int)(((VAR_6 + VAR_39) << 1) + VAR_24[3]);
    VAR_27 = (int)(((VAR_5 + VAR_39) << 1) + VAR_25[3]);

    if ((VAR_1 >> 2)&1)
    {
        VAR_21 = VAR_20 + 136;
        VAR_15 = 16;
    }
    else
    {
        VAR_21 = VAR_7 + (VAR_14 << 3) + 8;
        VAR_15 = VAR_14;
    }

    /* COMMENT_38 */
    if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) &&
            VAR_27 >= 0 && VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
    {   /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_39 */
        VAR_40[VAR_27&1][VAR_26&1](VAR_8 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);
    }
    else
    {   /* COMMENT_41 */
        /* COMMENT_42 */
        /* COMMENT_41 */
        GetPredOutside(VAR_26, VAR_27, VAR_8,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);
    }
    /* COMMENT_51 */
    /* COMMENT_52 */

#ifdef VAR_30
    if (VAR_0->postFilterType != VAR_41)
    {
        if (VAR_19&VAR_37)
        {
            VAR_32 = VAR_0->pstprcTypCur + VAR_16;
            VAR_34[0] = 1;
            VAR_34[1] = VAR_17 - 1;
            VAR_34[2] = 1;
            VAR_34[3] = -VAR_17 - 1;
            VAR_36 = pp_semaphore_luma(VAR_26, VAR_27, VAR_32,
                                            VAR_0->pstprcTypPrv, VAR_34, &VAR_35, VAR_24[0], VAR_25[0], VAR_17,
                                            VAR_14, VAR_13);

            VAR_33 = VAR_0->pstprcTypCur + (VAR_31 >> 6) +
                       ((VAR_16 + (VAR_6 >> 3)) >> 2);

            pp_semaphore_chroma_inter(VAR_26, VAR_27, VAR_33,
                                      VAR_0->pstprcTypPrv, VAR_22, VAR_23, VAR_17, VAR_13, VAR_31,
                                      VAR_35, VAR_36);
        }
        else
        {
            /* COMMENT_53 */
            /* COMMENT_54 */
            VAR_32 = VAR_0->pstprcTypCur + VAR_16;
            *VAR_32 = 4;
            *(VAR_32 + 1) = 4;
            *(VAR_32 + VAR_17) = 4;
            *(VAR_32 + VAR_17 + 1) = 4;
            VAR_33 = VAR_0->pstprcTypCur + (VAR_31 >> 6) +
                       ((VAR_16 + (VAR_6 >> 3)) >> 2);
            *VAR_33 = 4;
            VAR_33[VAR_31>>8] = 4;
        }
    }
#endif


    /* COMMENT_55 */
    /* COMMENT_56 */

    /* COMMENT_57 */
    /* COMMENT_58 */
    VAR_14 >>= 1;

    /* COMMENT_59 */
    VAR_13 >>= 1;

    /* COMMENT_60 */
    VAR_10 = VAR_2->uChan;

    /* COMMENT_61 */
    VAR_12 = VAR_2->vChan;

    /* COMMENT_62 */
    /* COMMENT_63 */
    /* COMMENT_64 */
    VAR_26 = VAR_6 + VAR_22;

    /* COMMENT_65 */
    /* COMMENT_66 */
    /* COMMENT_64 */
    VAR_27 = VAR_5 + VAR_23;

    VAR_9 = VAR_0->currVop->uChan + (VAR_18 >> 2) + (VAR_6 >> 2);
    VAR_11 = VAR_0->currVop->vChan + (VAR_18 >> 2) + (VAR_6 >> 2);

    /* COMMENT_67 */
    /* COMMENT_68 */
                                            
                      
    if (VAR_26 >= 0 && VAR_26 <= ((VAR_14 << 1) - (2*VAR_39)) && VAR_27 >= 0 &&
            VAR_27 <= ((VAR_13 << 1) - (2*VAR_39)))
    {
        /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_39 */
        if ((VAR_1 >> 1)&1)
        {
            VAR_21 = VAR_20 + 256;
            VAR_15 = 16;
        }
        else
        {
            VAR_21 = VAR_9;
            VAR_15 = VAR_14;
        }

        /* COMMENT_71 */
        VAR_40[VAR_27&1][VAR_26&1](VAR_10 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);

        if (VAR_1&1)
        {
            VAR_21 = VAR_20 + 264;
            VAR_15 = 16;
        }
        else
        {
            VAR_21 = VAR_11;
            VAR_15 = VAR_14;
        }
        /* COMMENT_72 */
        VAR_40[VAR_27&1][VAR_26&1](VAR_12 + (VAR_26 >> 1) + ((VAR_27 >> 1)*VAR_14),
                                           VAR_21, VAR_14, (VAR_15 << 1) | VAR_29);

        return ;
    }
    else
    {
        /* COMMENT_41 */
        /* COMMENT_42 */
        /* COMMENT_41 */
        if ((VAR_1 >> 1)&1)
        {
            VAR_21 = VAR_20 + 256;
            VAR_15 = 16;
        }
        else
        {
            VAR_21 = VAR_9;
            VAR_15 = VAR_14;
        }

        /* COMMENT_71 */
        GetPredOutside(VAR_26, VAR_27,    VAR_10,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);

        if (VAR_1&1)
        {
            VAR_21 = VAR_20 + 264;
            VAR_15 = 16;
        }
        else
        {
            VAR_21 = VAR_11;
            VAR_15 = VAR_14;
        }

        /* COMMENT_72 */
        GetPredOutside(VAR_26, VAR_27,    VAR_12,
                       VAR_21, VAR_14, VAR_13, VAR_29, VAR_15);

        return ;
    }

}",android/961e5ac5788b52304e64b9a509781beaf5201fb0/mb_motion_comp.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -118,6 +118,11 @@
 
     /* Pointer to previous luminance frame */
     c_prev  = prev->yChan;
+    if (!c_prev) {
+        ALOGE(""b/35269635"");
+        android_errorWriteLog(0x534e4554, ""35269635"");
+        return;
+    }
 
     pred_block = video->mblock->pred_block;
 ","{'deleted_lines': [], 'added_lines': ['    if (!c_prev) {', '        ALOGE(""b/35269635"");', '        android_errorWriteLog(0x534e4554, ""35269635"");', '        return;', '    }']}",True,"A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635.",5.5,MEDIUM,1,valid,,5
CVE-2019-18390,['CWE-125'],AV:L/AC:L/Au:N/C:P/I:N/A:P,0,virglrenderer,"Closes #141
Closes #142

v2 : drop colon in error description (Emil)

Signed-off-by: Gert Wollny <gert.wollny@collabora.com>
Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
",24f67de7a9088a873844a39be03cee6882260ac9,https://cgit.freedesktop.org/virglrenderer/commit/?id=24f67de7a9088a873844a39be03cee6882260ac9,src/vrend_renderer.c,vrend_renderer_blit,"void vrend_renderer_blit(struct vrend_context *ctx,
uint32_t dst_handle, uint32_t src_handle,
const struct pipe_blit_info *info)
{
struct vrend_resource *src_res, *dst_res;
src_res = vrend_renderer_ctx_res_lookup(ctx, src_handle);
dst_res = vrend_renderer_ctx_res_lookup(ctx, dst_handle);
if (!src_res) {
report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, src_handle);
return;
}
if (!dst_res) {
report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, dst_handle);
return;
}
if (ctx->in_error)
return;
if (info->render_condition_enable == false)
vrend_pause_render_condition(ctx, true);
VREND_DEBUG(dbg_blit, ctx, ""BLIT: rc:%d scissor:%d filter:%d alpha:%d mask:0x%x\n""
""  From %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n""
""  To   %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n"",
info->render_condition_enable, info->scissor_enable,
info->filter, info->alpha_blend, info->mask,
util_format_name(src_res->base.format),
util_format_name(info->src.format),
src_res->base.nr_samples,
info->src.box.x, info->src.box.y, info->src.box.z,
info->src.box.width, info->src.box.height, info->src.box.depth,
info->src.level,
util_format_name(dst_res->base.format),
util_format_name(info->dst.format),
dst_res->base.nr_samples,
info->dst.box.x, info->dst.box.y, info->dst.box.z,
info->dst.box.width, info->dst.box.height, info->dst.box.depth,
info->dst.level);
if (has_feature(feat_copy_image) &&
(!info->render_condition_enable || !ctx->sub->cond_render_gl_mode) &&
format_is_copy_compatible(info->src.format,info->dst.format, false) &&
!info->scissor_enable && (info->filter == PIPE_TEX_FILTER_NEAREST) &&
!info->alpha_blend && (info->mask == PIPE_MASK_RGBA) &&
src_res->base.nr_samples == dst_res->base.nr_samples &&
info->src.box.width == info->dst.box.width &&
info->src.box.height == info->dst.box.height &&
info->src.box.depth == info->dst.box.depth) {
VREND_DEBUG(dbg_blit, ctx,  ""  Use glCopyImageSubData\n"");
vrend_copy_sub_image(src_res, dst_res, info->src.level, &info->src.box,
info->dst.level, info->dst.box.x, info->dst.box.y,
info->dst.box.z);
} else {
VREND_DEBUG(dbg_blit, ctx, ""  Use blit_int\n"");
vrend_renderer_blit_int(ctx, src_res, dst_res, info);
}
if (info->render_condition_enable == false)
vrend_pause_render_condition(ctx, false);
}","void vrend_renderer_blit(struct vrend_context *VAR_0,
uint32_t VAR_1, uint32_t VAR_2,
const struct pipe_blit_info *VAR_3)
{
struct vrend_resource *VAR_4, *VAR_5;
VAR_4 = vrend_renderer_ctx_res_lookup(VAR_0, VAR_2);
VAR_5 = vrend_renderer_ctx_res_lookup(VAR_0, VAR_1);
if (!VAR_4) {
report_context_error(VAR_0, VAR_6, VAR_2);
return;
}
if (!VAR_5) {
report_context_error(VAR_0, VAR_6, VAR_1);
return;
}
if (VAR_0->in_error)
return;
if (VAR_3->render_condition_enable == false)
vrend_pause_render_condition(VAR_0, true);
VREND_DEBUG(VAR_7, VAR_0, ""BLIT: rc:%d scissor:%d filter:%d alpha:%d mask:0x%x\n""
""  From %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n""
""  To   %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n"",
VAR_3->render_condition_enable, VAR_3->scissor_enable,
VAR_3->filter, VAR_3->alpha_blend, VAR_3->mask,
util_format_name(VAR_4->base.format),
util_format_name(VAR_3->src.format),
VAR_4->base.nr_samples,
VAR_3->src.box.x, VAR_3->src.box.y, VAR_3->src.box.z,
VAR_3->src.box.width, VAR_3->src.box.height, VAR_3->src.box.depth,
VAR_3->src.level,
util_format_name(VAR_5->base.format),
util_format_name(VAR_3->dst.format),
VAR_5->base.nr_samples,
VAR_3->dst.box.x, VAR_3->dst.box.y, VAR_3->dst.box.z,
VAR_3->dst.box.width, VAR_3->dst.box.height, VAR_3->dst.box.depth,
VAR_3->dst.level);
if (has_feature(VAR_8) &&
(!VAR_3->render_condition_enable || !VAR_0->sub->cond_render_gl_mode) &&
format_is_copy_compatible(VAR_3->src.format,VAR_3->dst.format, false) &&
!VAR_3->scissor_enable && (VAR_3->filter == VAR_9) &&
!VAR_3->alpha_blend && (VAR_3->mask == VAR_10) &&
VAR_4->base.nr_samples == VAR_5->base.nr_samples &&
VAR_3->src.box.width == VAR_3->dst.box.width &&
VAR_3->src.box.height == VAR_3->dst.box.height &&
VAR_3->src.box.depth == VAR_3->dst.box.depth) {
VREND_DEBUG(VAR_7, VAR_0,  ""  Use glCopyImageSubData\n"");
vrend_copy_sub_image(VAR_4, VAR_5, VAR_3->src.level, &VAR_3->src.box,
VAR_3->dst.level, VAR_3->dst.box.x, VAR_3->dst.box.y,
VAR_3->dst.box.z);
} else {
VREND_DEBUG(VAR_7, VAR_0, ""  Use blit_int\n"");
vrend_renderer_blit_int(VAR_0, VAR_4, VAR_5, VAR_3);
}
if (VAR_3->render_condition_enable == false)
vrend_pause_render_condition(VAR_0, false);
}",virglrenderer/24f67de7a9088a873844a39be03cee6882260ac9/vrend_renderer.c/vul/before/0.json,"void vrend_renderer_blit(struct vrend_context *ctx,
                         uint32_t dst_handle, uint32_t src_handle,
                         const struct pipe_blit_info *info)
{
   struct vrend_resource *src_res, *dst_res;
   src_res = vrend_renderer_ctx_res_lookup(ctx, src_handle);
   dst_res = vrend_renderer_ctx_res_lookup(ctx, dst_handle);

   if (!src_res) {
      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, src_handle);
      return;
   }
   if (!dst_res) {
      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, dst_handle);
      return;
   }

   if (ctx->in_error)
      return;

   if (!info->src.format || (enum virgl_formats)info->src.format >= VIRGL_FORMAT_MAX) {
      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->src.format);
      return;
   }

   if (!info->dst.format || (enum virgl_formats)info->dst.format >= VIRGL_FORMAT_MAX) {
      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->dst.format);
      return;
   }

   if (info->render_condition_enable == false)
      vrend_pause_render_condition(ctx, true);

   VREND_DEBUG(dbg_blit, ctx, ""BLIT: rc:%d scissor:%d filter:%d alpha:%d mask:0x%x\n""
                                   ""  From %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n""
                                   ""  To   %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n"",
                                   info->render_condition_enable, info->scissor_enable,
                                   info->filter, info->alpha_blend, info->mask,
                                   util_format_name(src_res->base.format),
                                   util_format_name(info->src.format),
                                   src_res->base.nr_samples,
                                   info->src.box.x, info->src.box.y, info->src.box.z,
                                   info->src.box.width, info->src.box.height, info->src.box.depth,
                                   info->src.level,
                                   util_format_name(dst_res->base.format),
                                   util_format_name(info->dst.format),
                                   dst_res->base.nr_samples,
                                   info->dst.box.x, info->dst.box.y, info->dst.box.z,
                                   info->dst.box.width, info->dst.box.height, info->dst.box.depth,
                                   info->dst.level);

   /* The Gallium blit function can be called for a general blit that may
    * scale, convert the data, and apply some rander states, or it is called via
    * glCopyImageSubData. If the src or the dst image are equal, or the two
    * images formats are the same, then Galliums such calles are redirected
    * to resource_copy_region, in this case and if no render states etx need
    * to be applied, forward the call to glCopyImageSubData, otherwise do a
    * normal blit. */
   if (has_feature(feat_copy_image) &&
       (!info->render_condition_enable || !ctx->sub->cond_render_gl_mode) &&
       format_is_copy_compatible(info->src.format,info->dst.format, false) &&
       !info->scissor_enable && (info->filter == PIPE_TEX_FILTER_NEAREST) &&
       !info->alpha_blend && (info->mask == PIPE_MASK_RGBA) &&
       src_res->base.nr_samples == dst_res->base.nr_samples &&
       info->src.box.width == info->dst.box.width &&
       info->src.box.height == info->dst.box.height &&
       info->src.box.depth == info->dst.box.depth) {
      VREND_DEBUG(dbg_blit, ctx,  ""  Use glCopyImageSubData\n"");
      vrend_copy_sub_image(src_res, dst_res, info->src.level, &info->src.box,
                           info->dst.level, info->dst.box.x, info->dst.box.y,
                           info->dst.box.z);
   } else {
      VREND_DEBUG(dbg_blit, ctx, ""  Use blit_int\n"");
      vrend_renderer_blit_int(ctx, src_res, dst_res, info);
   }

   if (info->render_condition_enable == false)
      vrend_pause_render_condition(ctx, false);
}","void vrend_renderer_blit(struct vrend_context *VAR_0,
                         uint32_t VAR_1, uint32_t VAR_2,
                         const struct pipe_blit_info *VAR_3)
{
   struct vrend_resource *VAR_4, *VAR_5;
   VAR_4 = vrend_renderer_ctx_res_lookup(VAR_0, VAR_2);
   VAR_5 = vrend_renderer_ctx_res_lookup(VAR_0, VAR_1);

   if (!VAR_4) {
      report_context_error(VAR_0, VAR_6, VAR_2);
      return;
   }
   if (!VAR_5) {
      report_context_error(VAR_0, VAR_6, VAR_1);
      return;
   }

   if (VAR_0->in_error)
      return;

   if (!VAR_3->src.format || (enum virgl_formats)VAR_3->src.format >= VAR_7) {
      report_context_error(VAR_0, VAR_8, VAR_3->src.format);
      return;
   }

   if (!VAR_3->dst.format || (enum virgl_formats)VAR_3->dst.format >= VAR_7) {
      report_context_error(VAR_0, VAR_8, VAR_3->dst.format);
      return;
   }

   if (VAR_3->render_condition_enable == false)
      vrend_pause_render_condition(VAR_0, true);

   VREND_DEBUG(VAR_9, VAR_0, ""BLIT: rc:%d scissor:%d filter:%d alpha:%d mask:0x%x\n""
                                   ""  From %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n""
                                   ""  To   %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n"",
                                   VAR_3->render_condition_enable, VAR_3->scissor_enable,
                                   VAR_3->filter, VAR_3->alpha_blend, VAR_3->mask,
                                   util_format_name(VAR_4->base.format),
                                   util_format_name(VAR_3->src.format),
                                   VAR_4->base.nr_samples,
                                   VAR_3->src.box.x, VAR_3->src.box.y, VAR_3->src.box.z,
                                   VAR_3->src.box.width, VAR_3->src.box.height, VAR_3->src.box.depth,
                                   VAR_3->src.level,
                                   util_format_name(VAR_5->base.format),
                                   util_format_name(VAR_3->dst.format),
                                   VAR_5->base.nr_samples,
                                   VAR_3->dst.box.x, VAR_3->dst.box.y, VAR_3->dst.box.z,
                                   VAR_3->dst.box.width, VAR_3->dst.box.height, VAR_3->dst.box.depth,
                                   VAR_3->dst.level);

   /* COMMENT_0 */
                                                                                
                                                                           
                                                                           
                                                                            
                                                                           
                     
   if (has_feature(VAR_10) &&
       (!VAR_3->render_condition_enable || !VAR_0->sub->cond_render_gl_mode) &&
       format_is_copy_compatible(VAR_3->src.format,VAR_3->dst.format, false) &&
       !VAR_3->scissor_enable && (VAR_3->filter == VAR_11) &&
       !VAR_3->alpha_blend && (VAR_3->mask == VAR_12) &&
       VAR_4->base.nr_samples == VAR_5->base.nr_samples &&
       VAR_3->src.box.width == VAR_3->dst.box.width &&
       VAR_3->src.box.height == VAR_3->dst.box.height &&
       VAR_3->src.box.depth == VAR_3->dst.box.depth) {
      VREND_DEBUG(VAR_9, VAR_0,  ""  Use glCopyImageSubData\n"");
      vrend_copy_sub_image(VAR_4, VAR_5, VAR_3->src.level, &VAR_3->src.box,
                           VAR_3->dst.level, VAR_3->dst.box.x, VAR_3->dst.box.y,
                           VAR_3->dst.box.z);
   } else {
      VREND_DEBUG(VAR_9, VAR_0, ""  Use blit_int\n"");
      vrend_renderer_blit_int(VAR_0, VAR_4, VAR_5, VAR_3);
   }

   if (VAR_3->render_condition_enable == false)
      vrend_pause_render_condition(VAR_0, false);
}",virglrenderer/24f67de7a9088a873844a39be03cee6882260ac9/vrend_renderer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,16 @@
 
    if (ctx->in_error)
       return;
+
+   if (!info->src.format || (enum virgl_formats)info->src.format >= VIRGL_FORMAT_MAX) {
+      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->src.format);
+      return;
+   }
+
+   if (!info->dst.format || (enum virgl_formats)info->dst.format >= VIRGL_FORMAT_MAX) {
+      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->dst.format);
+      return;
+   }
 
    if (info->render_condition_enable == false)
       vrend_pause_render_condition(ctx, true);","{'deleted_lines': [], 'added_lines': ['', '   if (!info->src.format || (enum virgl_formats)info->src.format >= VIRGL_FORMAT_MAX) {', '      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->src.format);', '      return;', '   }', '', '   if (!info->dst.format || (enum virgl_formats)info->dst.format >= VIRGL_FORMAT_MAX) {', '      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_FORMAT, info->dst.format);', '      return;', '   }']}",True,An out-of-bounds read in the vrend_blit_need_swizzle function in vrend_renderer.c in virglrenderer through 0.8.0 allows guest OS users to cause a denial of service via VIRGL_CCMD_BLIT commands.,7.1,HIGH,2,valid,,5
CVE-2019-18391,['CWE-787'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,virglrenderer,"Closes #140

Signed-off-by: Gert Wollny <gert.wollny@collabora.com>
Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
",2abeb1802e3c005b17a7123e382171b3fb665971,https://cgit.freedesktop.org/virglrenderer/commit/?id=2abeb1802e3c005b17a7123e382171b3fb665971,src/vrend_renderer.c,vrend_renderer_transfer_write_iov,"static int vrend_renderer_transfer_write_iov(struct vrend_context *ctx,
struct vrend_resource *res,
struct iovec *iov, int num_iovs,
const struct vrend_transfer_info *info)
{
void *data;
if (res->storage == VREND_RESOURCE_STORAGE_GUEST ||
(res->storage == VREND_RESOURCE_STORAGE_GUEST_ELSE_SYSTEM && res->iov)) {
return vrend_copy_iovec(iov, num_iovs, info->offset,
res->iov, res->num_iovs, info->box->x,
info->box->width, res->ptr);
}
if (res->storage == VREND_RESOURCE_STORAGE_GUEST_ELSE_SYSTEM) {
assert(!res->iov);
vrend_read_from_iovec(iov, num_iovs, info->offset,
res->ptr + info->box->x, info->box->width);
return 0;
}
if (res->storage == VREND_RESOURCE_STORAGE_BUFFER) {
GLuint map_flags = GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_WRITE_BIT;
struct virgl_sub_upload_data d;
d.box = info->box;
d.target = res->target;
if (!info->synchronized)
map_flags |= GL_MAP_UNSYNCHRONIZED_BIT;
glBindBufferARB(res->target, res->id);
data = glMapBufferRange(res->target, info->box->x, info->box->width, map_flags);
if (data == NULL) {
vrend_printf(""map failed for element buffer\n"");
vrend_read_from_iovec_cb(iov, num_iovs, info->offset, info->box->width, &iov_buffer_upload, &d);
} else {
vrend_read_from_iovec(iov, num_iovs, info->offset, data, info->box->width);
glUnmapBuffer(res->target);
}
glBindBufferARB(res->target, 0);
} else {
GLenum glformat;
GLenum gltype;
int need_temp = 0;
int elsize = util_format_get_blocksize(res->base.format);
int x = 0, y = 0;
bool compressed;
bool invert = false;
float depth_scale;
GLuint send_size = 0;
uint32_t stride = info->stride;
uint32_t layer_stride = info->layer_stride;
if (ctx)
vrend_use_program(ctx, 0);
else
glUseProgram(0);
if (!stride)
stride = util_format_get_nblocksx(res->base.format, u_minify(res->base.width0, info->level)) * elsize;
if (!layer_stride)
layer_stride = util_format_get_2d_size(res->base.format, stride,
u_minify(res->base.height0, info->level));
compressed = util_format_is_compressed(res->base.format);
if (num_iovs > 1 || compressed) {
need_temp = true;
}
if (vrend_state.use_core_profile == true && (res->y_0_top || (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM))) {
need_temp = true;
if (res->y_0_top)
invert = true;
}
if (need_temp) {
send_size = util_format_get_nblocks(res->base.format, info->box->width,
info->box->height) * elsize * info->box->depth;
data = malloc(send_size);
if (!data)
return ENOMEM;
read_transfer_data(iov, num_iovs, data, res->base.format, info->offset,
stride, layer_stride, info->box, invert);
} else {
data = (char*)iov[0].iov_base + info->offset;
}
if (!need_temp) {
assert(stride);
glPixelStorei(GL_UNPACK_ROW_LENGTH, stride / elsize);
glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, layer_stride / stride);
} else
glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
switch (elsize) {
case 1:
case 3:
glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
break;
case 2:
case 6:
glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
break;
case 4:
default:
glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
break;
case 8:
glPixelStorei(GL_UNPACK_ALIGNMENT, 8);
break;
}
glformat = tex_conv_table[res->base.format].glformat;
gltype = tex_conv_table[res->base.format].gltype;
if ((!vrend_state.use_core_profile) && (res->y_0_top)) {
GLuint buffers;
if (res->readback_fb_id == 0 || (int)res->readback_fb_level != info->level) {
GLuint fb_id;
if (res->readback_fb_id)
glDeleteFramebuffers(1, &res->readback_fb_id);
glGenFramebuffers(1, &fb_id);
glBindFramebuffer(GL_FRAMEBUFFER, fb_id);
vrend_fb_bind_texture(res, 0, info->level, 0);
res->readback_fb_id = fb_id;
res->readback_fb_level = info->level;
} else {
glBindFramebuffer(GL_FRAMEBUFFER, res->readback_fb_id);
}
buffers = GL_COLOR_ATTACHMENT0;
glDrawBuffers(1, &buffers);
glDisable(GL_BLEND);
if (ctx) {
vrend_depth_test_enable(ctx, false);
vrend_alpha_test_enable(ctx, false);
vrend_stencil_test_enable(ctx, false);
} else {
glDisable(GL_DEPTH_TEST);
glDisable(GL_ALPHA_TEST);
glDisable(GL_STENCIL_TEST);
}
glPixelZoom(1.0f, res->y_0_top ? -1.0f : 1.0f);
glWindowPos2i(info->box->x, res->y_0_top ? (int)res->base.height0 - info->box->y : info->box->y);
glDrawPixels(info->box->width, info->box->height, glformat, gltype,
data);
} else {
uint32_t comp_size;
glBindTexture(res->target, res->id);
if (compressed) {
glformat = tex_conv_table[res->base.format].internalformat;
comp_size = util_format_get_nblocks(res->base.format, info->box->width,
info->box->height) * util_format_get_blocksize(res->base.format);
}
if (glformat == 0) {
glformat = GL_BGRA;
gltype = GL_UNSIGNED_BYTE;
}
x = info->box->x;
y = invert ? (int)res->base.height0 - info->box->y - info->box->height : info->box->y;
if (info->level < VR_MAX_TEXTURE_2D_LEVELS) {
int64_t level_height = u_minify(res->base.height0, info->level);
res->mipmap_offsets[info->level] = info->offset -
((info->box->z * level_height + y) * stride + x * elsize);
}
if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {
depth_scale = 256.0;
if (!vrend_state.use_core_profile)
glPixelTransferf(GL_DEPTH_SCALE, depth_scale);
else
vrend_scale_depth(data, send_size, depth_scale);
}
if (res->target == GL_TEXTURE_CUBE_MAP) {
GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + info->box->z;
if (compressed) {
glCompressedTexSubImage2D(ctarget, info->level, x, y,
info->box->width, info->box->height,
glformat, comp_size, data);
} else {
glTexSubImage2D(ctarget, info->level, x, y, info->box->width, info->box->height,
glformat, gltype, data);
}
} else if (res->target == GL_TEXTURE_3D || res->target == GL_TEXTURE_2D_ARRAY || res->target == GL_TEXTURE_CUBE_MAP_ARRAY) {
if (compressed) {
glCompressedTexSubImage3D(res->target, info->level, x, y, info->box->z,
info->box->width, info->box->height, info->box->depth,
glformat, comp_size, data);
} else {
glTexSubImage3D(res->target, info->level, x, y, info->box->z,
info->box->width, info->box->height, info->box->depth,
glformat, gltype, data);
}
} else if (res->target == GL_TEXTURE_1D) {
if (vrend_state.use_gles) {
report_gles_missing_func(ctx, ""gl[Compressed]TexSubImage1D"");
} else if (compressed) {
glCompressedTexSubImage1D(res->target, info->level, info->box->x,
info->box->width,
glformat, comp_size, data);
} else {
glTexSubImage1D(res->target, info->level, info->box->x, info->box->width,
glformat, gltype, data);
}
} else {
if (compressed) {
glCompressedTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
info->box->width, info->box->height,
glformat, comp_size, data);
} else {
glTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
info->box->width,
res->target == GL_TEXTURE_1D_ARRAY ? info->box->depth : info->box->height,
glformat, gltype, data);
}
}
if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {
if (!vrend_state.use_core_profile)
glPixelTransferf(GL_DEPTH_SCALE, 1.0);
}
glBindTexture(res->target, 0);
}
if (stride && !need_temp) {
glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
}
glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
if (need_temp)
free(data);
}
return 0;
}","static int vrend_renderer_transfer_write_iov(struct vrend_context *VAR_0,
struct vrend_resource *VAR_1,
struct iovec *VAR_2, int VAR_3,
const struct vrend_transfer_info *VAR_4)
{
void *VAR_5;
if (VAR_1->storage == VAR_6 ||
(VAR_1->storage == VAR_7 && VAR_1->iov)) {
return vrend_copy_iovec(VAR_2, VAR_3, VAR_4->offset,
VAR_1->iov, VAR_1->num_iovs, VAR_4->box->x,
VAR_4->box->width, VAR_1->ptr);
}
if (VAR_1->storage == VAR_7) {
assert(!VAR_1->iov);
vrend_read_from_iovec(VAR_2, VAR_3, VAR_4->offset,
VAR_1->ptr + VAR_4->box->x, VAR_4->box->width);
return 0;
}
if (VAR_1->storage == VAR_8) {
GLuint VAR_9 = VAR_10 | VAR_11;
struct virgl_sub_upload_data VAR_12;
VAR_12.box = VAR_4->box;
VAR_12.target = VAR_1->target;
if (!VAR_4->synchronized)
VAR_9 |= VAR_13;
glBindBufferARB(VAR_1->target, VAR_1->id);
VAR_5 = glMapBufferRange(VAR_1->target, VAR_4->box->x, VAR_4->box->width, VAR_9);
if (VAR_5 == NULL) {
vrend_printf(""map failed for element buffer\n"");
vrend_read_from_iovec_cb(VAR_2, VAR_3, VAR_4->offset, VAR_4->box->width, &VAR_14, &VAR_12);
} else {
vrend_read_from_iovec(VAR_2, VAR_3, VAR_4->offset, VAR_5, VAR_4->box->width);
glUnmapBuffer(VAR_1->target);
}
glBindBufferARB(VAR_1->target, 0);
} else {
GLenum VAR_15;
GLenum VAR_16;
int VAR_17 = 0;
int VAR_18 = util_format_get_blocksize(VAR_1->base.format);
int VAR_19 = 0, VAR_20 = 0;
bool VAR_21;
bool VAR_22 = false;
float VAR_23;
GLuint VAR_24 = 0;
uint32_t VAR_25 = VAR_4->stride;
uint32_t VAR_26 = VAR_4->layer_stride;
if (VAR_0)
vrend_use_program(VAR_0, 0);
else
glUseProgram(0);
if (!VAR_25)
VAR_25 = util_format_get_nblocksx(VAR_1->base.format, u_minify(VAR_1->base.width0, VAR_4->level)) * VAR_18;
if (!VAR_26)
VAR_26 = util_format_get_2d_size(VAR_1->base.format, VAR_25,
u_minify(VAR_1->base.height0, VAR_4->level));
VAR_21 = util_format_is_compressed(VAR_1->base.format);
if (VAR_3 > 1 || VAR_21) {
VAR_17 = true;
}
if (VAR_27.use_core_profile == true && (VAR_1->y_0_top || (VAR_1->base.format == (enum pipe_format)VAR_28))) {
VAR_17 = true;
if (VAR_1->y_0_top)
VAR_22 = true;
}
if (VAR_17) {
VAR_24 = util_format_get_nblocks(VAR_1->base.format, VAR_4->box->width,
VAR_4->box->height) * VAR_18 * VAR_4->box->depth;
VAR_5 = malloc(VAR_24);
if (!VAR_5)
return VAR_29;
read_transfer_data(VAR_2, VAR_3, VAR_5, VAR_1->base.format, VAR_4->offset,
VAR_25, VAR_26, VAR_4->box, VAR_22);
} else {
VAR_5 = (char*)VAR_2[0].iov_base + VAR_4->offset;
}
if (!VAR_17) {
assert(VAR_25);
glPixelStorei(VAR_30, VAR_25 / VAR_18);
glPixelStorei(VAR_31, VAR_26 / VAR_25);
} else
glPixelStorei(VAR_30, 0);
switch (VAR_18) {
case 1:
case 3:
glPixelStorei(VAR_32, 1);
break;
case 2:
case 6:
glPixelStorei(VAR_32, 2);
break;
case 4:
default:
glPixelStorei(VAR_32, 4);
break;
case 8:
glPixelStorei(VAR_32, 8);
break;
}
VAR_15 = VAR_33[VAR_1->base.format].glformat;
VAR_16 = VAR_33[VAR_1->base.format].gltype;
if ((!VAR_27.use_core_profile) && (VAR_1->y_0_top)) {
GLuint VAR_34;
if (VAR_1->readback_fb_id == 0 || (int)VAR_1->readback_fb_level != VAR_4->level) {
GLuint VAR_35;
if (VAR_1->readback_fb_id)
glDeleteFramebuffers(1, &VAR_1->readback_fb_id);
glGenFramebuffers(1, &VAR_35);
glBindFramebuffer(VAR_36, VAR_35);
vrend_fb_bind_texture(VAR_1, 0, VAR_4->level, 0);
VAR_1->readback_fb_id = VAR_35;
VAR_1->readback_fb_level = VAR_4->level;
} else {
glBindFramebuffer(VAR_36, VAR_1->readback_fb_id);
}
VAR_34 = VAR_37;
glDrawBuffers(1, &VAR_34);
glDisable(VAR_38);
if (VAR_0) {
vrend_depth_test_enable(VAR_0, false);
vrend_alpha_test_enable(VAR_0, false);
vrend_stencil_test_enable(VAR_0, false);
} else {
glDisable(VAR_39);
glDisable(VAR_40);
glDisable(VAR_41);
}
glPixelZoom(1.0f, VAR_1->y_0_top ? -1.0f : 1.0f);
glWindowPos2i(VAR_4->box->x, VAR_1->y_0_top ? (int)VAR_1->base.height0 - VAR_4->box->y : VAR_4->box->y);
glDrawPixels(VAR_4->box->width, VAR_4->box->height, VAR_15, VAR_16,
VAR_5);
} else {
uint32_t VAR_42;
glBindTexture(VAR_1->target, VAR_1->id);
if (VAR_21) {
VAR_15 = VAR_33[VAR_1->base.format].internalformat;
VAR_42 = util_format_get_nblocks(VAR_1->base.format, VAR_4->box->width,
VAR_4->box->height) * util_format_get_blocksize(VAR_1->base.format);
}
if (VAR_15 == 0) {
VAR_15 = VAR_43;
VAR_16 = VAR_44;
}
VAR_19 = VAR_4->box->x;
VAR_20 = VAR_22 ? (int)VAR_1->base.height0 - VAR_4->box->y - VAR_4->box->height : VAR_4->box->y;
if (VAR_4->level < VAR_45) {
int64_t VAR_46 = u_minify(VAR_1->base.height0, VAR_4->level);
VAR_1->mipmap_offsets[VAR_4->level] = VAR_4->offset -
((VAR_4->box->z * VAR_46 + VAR_20) * VAR_25 + VAR_19 * VAR_18);
}
if (VAR_1->base.format == (enum pipe_format)VAR_28) {
VAR_23 = 256.0;
if (!VAR_27.use_core_profile)
glPixelTransferf(VAR_47, VAR_23);
else
vrend_scale_depth(VAR_5, VAR_24, VAR_23);
}
if (VAR_1->target == VAR_48) {
GLenum VAR_49 = VAR_50 + VAR_4->box->z;
if (VAR_21) {
glCompressedTexSubImage2D(VAR_49, VAR_4->level, VAR_19, VAR_20,
VAR_4->box->width, VAR_4->box->height,
VAR_15, VAR_42, VAR_5);
} else {
glTexSubImage2D(VAR_49, VAR_4->level, VAR_19, VAR_20, VAR_4->box->width, VAR_4->box->height,
VAR_15, VAR_16, VAR_5);
}
} else if (VAR_1->target == VAR_51 || VAR_1->target == VAR_52 || VAR_1->target == VAR_53) {
if (VAR_21) {
glCompressedTexSubImage3D(VAR_1->target, VAR_4->level, VAR_19, VAR_20, VAR_4->box->z,
VAR_4->box->width, VAR_4->box->height, VAR_4->box->depth,
VAR_15, VAR_42, VAR_5);
} else {
glTexSubImage3D(VAR_1->target, VAR_4->level, VAR_19, VAR_20, VAR_4->box->z,
VAR_4->box->width, VAR_4->box->height, VAR_4->box->depth,
VAR_15, VAR_16, VAR_5);
}
} else if (VAR_1->target == VAR_54) {
if (VAR_27.use_gles) {
report_gles_missing_func(VAR_0, ""gl[Compressed]TexSubImage1D"");
} else if (VAR_21) {
glCompressedTexSubImage1D(VAR_1->target, VAR_4->level, VAR_4->box->x,
VAR_4->box->width,
VAR_15, VAR_42, VAR_5);
} else {
glTexSubImage1D(VAR_1->target, VAR_4->level, VAR_4->box->x, VAR_4->box->width,
VAR_15, VAR_16, VAR_5);
}
} else {
if (VAR_21) {
glCompressedTexSubImage2D(VAR_1->target, VAR_4->level, VAR_19, VAR_1->target == VAR_55 ? VAR_4->box->z : VAR_20,
VAR_4->box->width, VAR_4->box->height,
VAR_15, VAR_42, VAR_5);
} else {
glTexSubImage2D(VAR_1->target, VAR_4->level, VAR_19, VAR_1->target == VAR_55 ? VAR_4->box->z : VAR_20,
VAR_4->box->width,
VAR_1->target == VAR_55 ? VAR_4->box->depth : VAR_4->box->height,
VAR_15, VAR_16, VAR_5);
}
}
if (VAR_1->base.format == (enum pipe_format)VAR_28) {
if (!VAR_27.use_core_profile)
glPixelTransferf(VAR_47, 1.0);
}
glBindTexture(VAR_1->target, 0);
}
if (VAR_25 && !VAR_17) {
glPixelStorei(VAR_30, 0);
glPixelStorei(VAR_31, 0);
}
glPixelStorei(VAR_32, 4);
if (VAR_17)
free(VAR_5);
}
return 0;
}",virglrenderer/2abeb1802e3c005b17a7123e382171b3fb665971/vrend_renderer.c/vul/before/0.json,"static int vrend_renderer_transfer_write_iov(struct vrend_context *ctx,
                                             struct vrend_resource *res,
                                             struct iovec *iov, int num_iovs,
                                             const struct vrend_transfer_info *info)
{
   void *data;

   if (res->storage == VREND_RESOURCE_STORAGE_GUEST ||
       (res->storage == VREND_RESOURCE_STORAGE_GUEST_ELSE_SYSTEM && res->iov)) {
      return vrend_copy_iovec(iov, num_iovs, info->offset,
                              res->iov, res->num_iovs, info->box->x,
                              info->box->width, res->ptr);
   }

   if (res->storage == VREND_RESOURCE_STORAGE_GUEST_ELSE_SYSTEM) {
      assert(!res->iov);
      vrend_read_from_iovec(iov, num_iovs, info->offset,
                            res->ptr + info->box->x, info->box->width);
      return 0;
   }

   if (res->storage == VREND_RESOURCE_STORAGE_BUFFER) {
      GLuint map_flags = GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_WRITE_BIT;
      struct virgl_sub_upload_data d;
      d.box = info->box;
      d.target = res->target;

      if (!info->synchronized)
         map_flags |= GL_MAP_UNSYNCHRONIZED_BIT;

      glBindBufferARB(res->target, res->id);
      data = glMapBufferRange(res->target, info->box->x, info->box->width, map_flags);
      if (data == NULL) {
	 vrend_printf(""map failed for element buffer\n"");
	 vrend_read_from_iovec_cb(iov, num_iovs, info->offset, info->box->width, &iov_buffer_upload, &d);
      } else {
	 vrend_read_from_iovec(iov, num_iovs, info->offset, data, info->box->width);
	 glUnmapBuffer(res->target);
      }
      glBindBufferARB(res->target, 0);
   } else {
      GLenum glformat;
      GLenum gltype;
      int need_temp = 0;
      int elsize = util_format_get_blocksize(res->base.format);
      int x = 0, y = 0;
      bool compressed;
      bool invert = false;
      float depth_scale;
      GLuint send_size = 0;
      uint32_t stride = info->stride;
      uint32_t layer_stride = info->layer_stride;

      if (ctx)
         vrend_use_program(ctx, 0);
      else
         glUseProgram(0);

      if (!stride)
         stride = util_format_get_nblocksx(res->base.format, u_minify(res->base.width0, info->level)) * elsize;

      if (!layer_stride)
         layer_stride = util_format_get_2d_size(res->base.format, stride,
                                                u_minify(res->base.height0, info->level));

      compressed = util_format_is_compressed(res->base.format);
      if (num_iovs > 1 || compressed) {
         need_temp = true;
      }

      if (vrend_state.use_core_profile == true && (res->y_0_top || (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM))) {
         need_temp = true;
         if (res->y_0_top)
            invert = true;
      }

      send_size = util_format_get_nblocks(res->base.format, info->box->width,
                                          info->box->height) * elsize;
      if (res->target == GL_TEXTURE_3D ||
          res->target == GL_TEXTURE_2D_ARRAY ||
          res->target == GL_TEXTURE_CUBE_MAP_ARRAY)
          send_size *= info->box->depth;

      if (need_temp) {
         data = malloc(send_size);
         if (!data)
            return ENOMEM;
         read_transfer_data(iov, num_iovs, data, res->base.format, info->offset,
                            stride, layer_stride, info->box, invert);
      } else {
         if (send_size > iov[0].iov_len - info->offset)
            return EINVAL;
         data = (char*)iov[0].iov_base + info->offset;
      }

      if (!need_temp) {
         assert(stride);
         glPixelStorei(GL_UNPACK_ROW_LENGTH, stride / elsize);
         glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, layer_stride / stride);
      } else
         glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

      switch (elsize) {
      case 1:
      case 3:
         glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
         break;
      case 2:
      case 6:
         glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
         break;
      case 4:
      default:
         glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
         break;
      case 8:
         glPixelStorei(GL_UNPACK_ALIGNMENT, 8);
         break;
      }

      glformat = tex_conv_table[res->base.format].glformat;
      gltype = tex_conv_table[res->base.format].gltype;

      if ((!vrend_state.use_core_profile) && (res->y_0_top)) {
         GLuint buffers;

         if (res->readback_fb_id == 0 || (int)res->readback_fb_level != info->level) {
            GLuint fb_id;
            if (res->readback_fb_id)
               glDeleteFramebuffers(1, &res->readback_fb_id);

            glGenFramebuffers(1, &fb_id);
            glBindFramebuffer(GL_FRAMEBUFFER, fb_id);
            vrend_fb_bind_texture(res, 0, info->level, 0);

            res->readback_fb_id = fb_id;
            res->readback_fb_level = info->level;
         } else {
            glBindFramebuffer(GL_FRAMEBUFFER, res->readback_fb_id);
         }

         buffers = GL_COLOR_ATTACHMENT0;
         glDrawBuffers(1, &buffers);
         glDisable(GL_BLEND);
         if (ctx) {
            vrend_depth_test_enable(ctx, false);
            vrend_alpha_test_enable(ctx, false);
            vrend_stencil_test_enable(ctx, false);
         } else {
            glDisable(GL_DEPTH_TEST);
            glDisable(GL_ALPHA_TEST);
            glDisable(GL_STENCIL_TEST);
         }
         glPixelZoom(1.0f, res->y_0_top ? -1.0f : 1.0f);
         glWindowPos2i(info->box->x, res->y_0_top ? (int)res->base.height0 - info->box->y : info->box->y);
         glDrawPixels(info->box->width, info->box->height, glformat, gltype,
                      data);
      } else {
         uint32_t comp_size;
         glBindTexture(res->target, res->id);

         if (compressed) {
            glformat = tex_conv_table[res->base.format].internalformat;
            comp_size = util_format_get_nblocks(res->base.format, info->box->width,
                                                info->box->height) * util_format_get_blocksize(res->base.format);
         }

         if (glformat == 0) {
            glformat = GL_BGRA;
            gltype = GL_UNSIGNED_BYTE;
         }

         x = info->box->x;
         y = invert ? (int)res->base.height0 - info->box->y - info->box->height : info->box->y;


         /* mipmaps are usually passed in one iov, and we need to keep the offset
          * into the data in case we want to read back the data of a surface
          * that can not be rendered. Since we can not assume that the whole texture
          * is filled, we evaluate the offset for origin (0,0,0). Since it is also
          * possible that a resource is reused and resized update the offset every time.
          */
         if (info->level < VR_MAX_TEXTURE_2D_LEVELS) {
            int64_t level_height = u_minify(res->base.height0, info->level);
            res->mipmap_offsets[info->level] = info->offset -
                                               ((info->box->z * level_height + y) * stride + x * elsize);
         }

         if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {
            /* we get values from the guest as 24-bit scaled integers
               but we give them to the host GL and it interprets them
               as 32-bit scaled integers, so we need to scale them here */
            depth_scale = 256.0;
            if (!vrend_state.use_core_profile)
               glPixelTransferf(GL_DEPTH_SCALE, depth_scale);
            else
               vrend_scale_depth(data, send_size, depth_scale);
         }
         if (res->target == GL_TEXTURE_CUBE_MAP) {
            GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + info->box->z;
            if (compressed) {
               glCompressedTexSubImage2D(ctarget, info->level, x, y,
                                         info->box->width, info->box->height,
                                         glformat, comp_size, data);
            } else {
               glTexSubImage2D(ctarget, info->level, x, y, info->box->width, info->box->height,
                               glformat, gltype, data);
            }
         } else if (res->target == GL_TEXTURE_3D || res->target == GL_TEXTURE_2D_ARRAY || res->target == GL_TEXTURE_CUBE_MAP_ARRAY) {
            if (compressed) {
               glCompressedTexSubImage3D(res->target, info->level, x, y, info->box->z,
                                         info->box->width, info->box->height, info->box->depth,
                                         glformat, comp_size, data);
            } else {
               glTexSubImage3D(res->target, info->level, x, y, info->box->z,
                               info->box->width, info->box->height, info->box->depth,
                               glformat, gltype, data);
            }
         } else if (res->target == GL_TEXTURE_1D) {
            if (vrend_state.use_gles) {
               /* Covers both compressed and none compressed. */
               report_gles_missing_func(ctx, ""gl[Compressed]TexSubImage1D"");
            } else if (compressed) {
               glCompressedTexSubImage1D(res->target, info->level, info->box->x,
                                         info->box->width,
                                         glformat, comp_size, data);
            } else {
               glTexSubImage1D(res->target, info->level, info->box->x, info->box->width,
                               glformat, gltype, data);
            }
         } else {
            if (compressed) {
               glCompressedTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
                                         info->box->width, info->box->height,
                                         glformat, comp_size, data);
            } else {
               glTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
                               info->box->width,
                               res->target == GL_TEXTURE_1D_ARRAY ? info->box->depth : info->box->height,
                               glformat, gltype, data);
            }
         }
         if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {
            if (!vrend_state.use_core_profile)
               glPixelTransferf(GL_DEPTH_SCALE, 1.0);
         }
         glBindTexture(res->target, 0);
      }

      if (stride && !need_temp) {
         glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
         glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
      }

      glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

      if (need_temp)
         free(data);
   }
   return 0;
}","static int vrend_renderer_transfer_write_iov(struct vrend_context *VAR_0,
                                             struct vrend_resource *VAR_1,
                                             struct iovec *VAR_2, int VAR_3,
                                             const struct vrend_transfer_info *VAR_4)
{
   void *VAR_5;

   if (VAR_1->storage == VAR_6 ||
       (VAR_1->storage == VAR_7 && VAR_1->iov)) {
      return vrend_copy_iovec(VAR_2, VAR_3, VAR_4->offset,
                              VAR_1->iov, VAR_1->num_iovs, VAR_4->box->x,
                              VAR_4->box->width, VAR_1->ptr);
   }

   if (VAR_1->storage == VAR_7) {
      assert(!VAR_1->iov);
      vrend_read_from_iovec(VAR_2, VAR_3, VAR_4->offset,
                            VAR_1->ptr + VAR_4->box->x, VAR_4->box->width);
      return 0;
   }

   if (VAR_1->storage == VAR_8) {
      GLuint VAR_9 = VAR_10 | VAR_11;
      struct virgl_sub_upload_data VAR_12;
      VAR_12.box = VAR_4->box;
      VAR_12.target = VAR_1->target;

      if (!VAR_4->synchronized)
         VAR_9 |= VAR_13;

      glBindBufferARB(VAR_1->target, VAR_1->id);
      VAR_5 = glMapBufferRange(VAR_1->target, VAR_4->box->x, VAR_4->box->width, VAR_9);
      if (VAR_5 == NULL) {
	 vrend_printf(""map failed for element buffer\n"");
	 vrend_read_from_iovec_cb(VAR_2, VAR_3, VAR_4->offset, VAR_4->box->width, &VAR_14, &VAR_12);
      } else {
	 vrend_read_from_iovec(VAR_2, VAR_3, VAR_4->offset, VAR_5, VAR_4->box->width);
	 glUnmapBuffer(VAR_1->target);
      }
      glBindBufferARB(VAR_1->target, 0);
   } else {
      GLenum VAR_15;
      GLenum VAR_16;
      int VAR_17 = 0;
      int VAR_18 = util_format_get_blocksize(VAR_1->base.format);
      int VAR_19 = 0, VAR_20 = 0;
      bool VAR_21;
      bool VAR_22 = false;
      float VAR_23;
      GLuint VAR_24 = 0;
      uint32_t VAR_25 = VAR_4->stride;
      uint32_t VAR_26 = VAR_4->layer_stride;

      if (VAR_0)
         vrend_use_program(VAR_0, 0);
      else
         glUseProgram(0);

      if (!VAR_25)
         VAR_25 = util_format_get_nblocksx(VAR_1->base.format, u_minify(VAR_1->base.width0, VAR_4->level)) * VAR_18;

      if (!VAR_26)
         VAR_26 = util_format_get_2d_size(VAR_1->base.format, VAR_25,
                                                u_minify(VAR_1->base.height0, VAR_4->level));

      VAR_21 = util_format_is_compressed(VAR_1->base.format);
      if (VAR_3 > 1 || VAR_21) {
         VAR_17 = true;
      }

      if (VAR_27.use_core_profile == true && (VAR_1->y_0_top || (VAR_1->base.format == (enum pipe_format)VAR_28))) {
         VAR_17 = true;
         if (VAR_1->y_0_top)
            VAR_22 = true;
      }

      VAR_24 = util_format_get_nblocks(VAR_1->base.format, VAR_4->box->width,
                                          VAR_4->box->height) * VAR_18;
      if (VAR_1->target == VAR_29 ||
          VAR_1->target == VAR_30 ||
          VAR_1->target == VAR_31)
          VAR_24 *= VAR_4->box->depth;

      if (VAR_17) {
         VAR_5 = malloc(VAR_24);
         if (!VAR_5)
            return VAR_32;
         read_transfer_data(VAR_2, VAR_3, VAR_5, VAR_1->base.format, VAR_4->offset,
                            VAR_25, VAR_26, VAR_4->box, VAR_22);
      } else {
         if (VAR_24 > VAR_2[0].iov_len - VAR_4->offset)
            return VAR_33;
         VAR_5 = (char*)VAR_2[0].iov_base + VAR_4->offset;
      }

      if (!VAR_17) {
         assert(VAR_25);
         glPixelStorei(VAR_34, VAR_25 / VAR_18);
         glPixelStorei(VAR_35, VAR_26 / VAR_25);
      } else
         glPixelStorei(VAR_34, 0);

      switch (VAR_18) {
      case 1:
      case 3:
         glPixelStorei(VAR_36, 1);
         break;
      case 2:
      case 6:
         glPixelStorei(VAR_36, 2);
         break;
      case 4:
      default:
         glPixelStorei(VAR_36, 4);
         break;
      case 8:
         glPixelStorei(VAR_36, 8);
         break;
      }

      VAR_15 = VAR_37[VAR_1->base.format].glformat;
      VAR_16 = VAR_37[VAR_1->base.format].gltype;

      if ((!VAR_27.use_core_profile) && (VAR_1->y_0_top)) {
         GLuint VAR_38;

         if (VAR_1->readback_fb_id == 0 || (int)VAR_1->readback_fb_level != VAR_4->level) {
            GLuint VAR_39;
            if (VAR_1->readback_fb_id)
               glDeleteFramebuffers(1, &VAR_1->readback_fb_id);

            glGenFramebuffers(1, &VAR_39);
            glBindFramebuffer(VAR_40, VAR_39);
            vrend_fb_bind_texture(VAR_1, 0, VAR_4->level, 0);

            VAR_1->readback_fb_id = VAR_39;
            VAR_1->readback_fb_level = VAR_4->level;
         } else {
            glBindFramebuffer(VAR_40, VAR_1->readback_fb_id);
         }

         VAR_38 = VAR_41;
         glDrawBuffers(1, &VAR_38);
         glDisable(VAR_42);
         if (VAR_0) {
            vrend_depth_test_enable(VAR_0, false);
            vrend_alpha_test_enable(VAR_0, false);
            vrend_stencil_test_enable(VAR_0, false);
         } else {
            glDisable(VAR_43);
            glDisable(VAR_44);
            glDisable(VAR_45);
         }
         glPixelZoom(1.0f, VAR_1->y_0_top ? -1.0f : 1.0f);
         glWindowPos2i(VAR_4->box->x, VAR_1->y_0_top ? (int)VAR_1->base.height0 - VAR_4->box->y : VAR_4->box->y);
         glDrawPixels(VAR_4->box->width, VAR_4->box->height, VAR_15, VAR_16,
                      VAR_5);
      } else {
         uint32_t VAR_46;
         glBindTexture(VAR_1->target, VAR_1->id);

         if (VAR_21) {
            VAR_15 = VAR_37[VAR_1->base.format].internalformat;
            VAR_46 = util_format_get_nblocks(VAR_1->base.format, VAR_4->box->width,
                                                VAR_4->box->height) * util_format_get_blocksize(VAR_1->base.format);
         }

         if (VAR_15 == 0) {
            VAR_15 = VAR_47;
            VAR_16 = VAR_48;
         }

         VAR_19 = VAR_4->box->x;
         VAR_20 = VAR_22 ? (int)VAR_1->base.height0 - VAR_4->box->y - VAR_4->box->height : VAR_4->box->y;


         /* COMMENT_0 */
                                                                            
                                                                                    
                                                                                  
                                                                                        
            
         if (VAR_4->level < VAR_49) {
            int64_t VAR_50 = u_minify(VAR_1->base.height0, VAR_4->level);
            VAR_1->mipmap_offsets[VAR_4->level] = VAR_4->offset -
                                               ((VAR_4->box->z * VAR_50 + VAR_20) * VAR_25 + VAR_19 * VAR_18);
         }

         if (VAR_1->base.format == (enum pipe_format)VAR_28) {
            /* COMMENT_6 */
                                                                     
                                                                          
            VAR_23 = 256.0;
            if (!VAR_27.use_core_profile)
               glPixelTransferf(VAR_51, VAR_23);
            else
               vrend_scale_depth(VAR_5, VAR_24, VAR_23);
         }
         if (VAR_1->target == VAR_52) {
            GLenum VAR_53 = VAR_54 + VAR_4->box->z;
            if (VAR_21) {
               glCompressedTexSubImage2D(VAR_53, VAR_4->level, VAR_19, VAR_20,
                                         VAR_4->box->width, VAR_4->box->height,
                                         VAR_15, VAR_46, VAR_5);
            } else {
               glTexSubImage2D(VAR_53, VAR_4->level, VAR_19, VAR_20, VAR_4->box->width, VAR_4->box->height,
                               VAR_15, VAR_16, VAR_5);
            }
         } else if (VAR_1->target == VAR_29 || VAR_1->target == VAR_30 || VAR_1->target == VAR_31) {
            if (VAR_21) {
               glCompressedTexSubImage3D(VAR_1->target, VAR_4->level, VAR_19, VAR_20, VAR_4->box->z,
                                         VAR_4->box->width, VAR_4->box->height, VAR_4->box->depth,
                                         VAR_15, VAR_46, VAR_5);
            } else {
               glTexSubImage3D(VAR_1->target, VAR_4->level, VAR_19, VAR_20, VAR_4->box->z,
                               VAR_4->box->width, VAR_4->box->height, VAR_4->box->depth,
                               VAR_15, VAR_16, VAR_5);
            }
         } else if (VAR_1->target == VAR_55) {
            if (VAR_27.use_gles) {
               /* COMMENT_9 */
               report_gles_missing_func(VAR_0, ""gl[Compressed]TexSubImage1D"");
            } else if (VAR_21) {
               glCompressedTexSubImage1D(VAR_1->target, VAR_4->level, VAR_4->box->x,
                                         VAR_4->box->width,
                                         VAR_15, VAR_46, VAR_5);
            } else {
               glTexSubImage1D(VAR_1->target, VAR_4->level, VAR_4->box->x, VAR_4->box->width,
                               VAR_15, VAR_16, VAR_5);
            }
         } else {
            if (VAR_21) {
               glCompressedTexSubImage2D(VAR_1->target, VAR_4->level, VAR_19, VAR_1->target == VAR_56 ? VAR_4->box->z : VAR_20,
                                         VAR_4->box->width, VAR_4->box->height,
                                         VAR_15, VAR_46, VAR_5);
            } else {
               glTexSubImage2D(VAR_1->target, VAR_4->level, VAR_19, VAR_1->target == VAR_56 ? VAR_4->box->z : VAR_20,
                               VAR_4->box->width,
                               VAR_1->target == VAR_56 ? VAR_4->box->depth : VAR_4->box->height,
                               VAR_15, VAR_16, VAR_5);
            }
         }
         if (VAR_1->base.format == (enum pipe_format)VAR_28) {
            if (!VAR_27.use_core_profile)
               glPixelTransferf(VAR_51, 1.0);
         }
         glBindTexture(VAR_1->target, 0);
      }

      if (VAR_25 && !VAR_17) {
         glPixelStorei(VAR_34, 0);
         glPixelStorei(VAR_35, 0);
      }

      glPixelStorei(VAR_36, 4);

      if (VAR_17)
         free(VAR_5);
   }
   return 0;
}",virglrenderer/2abeb1802e3c005b17a7123e382171b3fb665971/vrend_renderer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -74,15 +74,22 @@
             invert = true;
       }
 
+      send_size = util_format_get_nblocks(res->base.format, info->box->width,
+                                          info->box->height) * elsize;
+      if (res->target == GL_TEXTURE_3D ||
+          res->target == GL_TEXTURE_2D_ARRAY ||
+          res->target == GL_TEXTURE_CUBE_MAP_ARRAY)
+          send_size *= info->box->depth;
+
       if (need_temp) {
-         send_size = util_format_get_nblocks(res->base.format, info->box->width,
-                                             info->box->height) * elsize * info->box->depth;
          data = malloc(send_size);
          if (!data)
             return ENOMEM;
          read_transfer_data(iov, num_iovs, data, res->base.format, info->offset,
                             stride, layer_stride, info->box, invert);
       } else {
+         if (send_size > iov[0].iov_len - info->offset)
+            return EINVAL;
          data = (char*)iov[0].iov_base + info->offset;
       }
 ","{'deleted_lines': ['         send_size = util_format_get_nblocks(res->base.format, info->box->width,', '                                             info->box->height) * elsize * info->box->depth;'], 'added_lines': ['      send_size = util_format_get_nblocks(res->base.format, info->box->width,', '                                          info->box->height) * elsize;', '      if (res->target == GL_TEXTURE_3D ||', '          res->target == GL_TEXTURE_2D_ARRAY ||', '          res->target == GL_TEXTURE_CUBE_MAP_ARRAY)', '          send_size *= info->box->depth;', '', '         if (send_size > iov[0].iov_len - info->offset)', '            return EINVAL;']}",True,A heap-based buffer overflow in the vrend_renderer_transfer_write_iov function in vrend_renderer.c in virglrenderer through 0.8.0 allows guest OS users to cause a denial of service via VIRGL_CCMD_RESOURCE_INLINE_WRITE commands.,5.5,MEDIUM,1,valid,,5
CVE-2018-13097,"['CWE-369', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,torvalds/linux,"This patch fixs to do sanity check with user_block_count.

- Overview
Divide zero in utilization when mount() a corrupted f2fs image

- Reproduce (4.18 upstream kernel)

- Kernel message
[  564.099503] F2FS-fs (loop0): invalid crc value
[  564.101991] divide error: 0000 [#1] SMP KASAN PTI
[  564.103103] CPU: 1 PID: 1298 Comm: f2fs_discard-7: Not tainted 4.18.0-rc1+ #4
[  564.104584] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
[  564.106624] RIP: 0010:issue_discard_thread+0x248/0x5c0
[  564.107692] Code: ff ff 48 8b bd e8 fe ff ff 41 8b 9d 4c 04 00 00 e8 cd b8 ad ff 41 8b 85 50 04 00 00 31 d2 48 8d 04 80 48 8d 04 80 48 c1 e0 02 <48> f7 f3 83 f8 50 7e 16 41 c7 86 7c ff ff ff 01 00 00 00 41 c7 86
[  564.111686] RSP: 0018:ffff8801f3117dc0 EFLAGS: 00010206
[  564.112775] RAX: 0000000000000384 RBX: 0000000000000000 RCX: ffffffffb88c1e03
[  564.114250] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e3aa4850
[  564.115706] RBP: ffff8801f3117f00 R08: 1ffffffff751a1d0 R09: fffffbfff751a1d0
[  564.117177] R10: 0000000000000001 R11: fffffbfff751a1d0 R12: 00000000fffffffc
[  564.118634] R13: ffff8801e3aa4400 R14: ffff8801f3117ed8 R15: ffff8801e2050000
[  564.120094] FS:  0000000000000000(0000) GS:ffff8801f6f00000(0000) knlGS:0000000000000000
[  564.121748] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  564.122923] CR2: 000000000202b078 CR3: 00000001f11ac000 CR4: 00000000000006e0
[  564.124383] Call Trace:
[  564.124924]  ? __issue_discard_cmd+0x480/0x480
[  564.125882]  ? __sched_text_start+0x8/0x8
[  564.126756]  ? __kthread_parkme+0xcb/0x100
[  564.127620]  ? kthread_blkcg+0x70/0x70
[  564.128412]  kthread+0x180/0x1d0
[  564.129105]  ? __issue_discard_cmd+0x480/0x480
[  564.130029]  ? kthread_associate_blkcg+0x150/0x150
[  564.131033]  ret_from_fork+0x35/0x40
[  564.131794] Modules linked in: snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mac_hid i2c_piix4 soundcore ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid1 raid0 multipath linear 8139too crct10dif_pclmul crc32_pclmul qxl drm_kms_helper syscopyarea aesni_intel sysfillrect sysimgblt fb_sys_fops ttm drm aes_x86_64 crypto_simd cryptd 8139cp glue_helper mii pata_acpi floppy
[  564.141798] ---[ end trace 4ce02f25ff7d3df5 ]---
[  564.142773] RIP: 0010:issue_discard_thread+0x248/0x5c0
[  564.143885] Code: ff ff 48 8b bd e8 fe ff ff 41 8b 9d 4c 04 00 00 e8 cd b8 ad ff 41 8b 85 50 04 00 00 31 d2 48 8d 04 80 48 8d 04 80 48 c1 e0 02 <48> f7 f3 83 f8 50 7e 16 41 c7 86 7c ff ff ff 01 00 00 00 41 c7 86
[  564.147776] RSP: 0018:ffff8801f3117dc0 EFLAGS: 00010206
[  564.148856] RAX: 0000000000000384 RBX: 0000000000000000 RCX: ffffffffb88c1e03
[  564.150424] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e3aa4850
[  564.151906] RBP: ffff8801f3117f00 R08: 1ffffffff751a1d0 R09: fffffbfff751a1d0
[  564.153463] R10: 0000000000000001 R11: fffffbfff751a1d0 R12: 00000000fffffffc
[  564.154915] R13: ffff8801e3aa4400 R14: ffff8801f3117ed8 R15: ffff8801e2050000
[  564.156405] FS:  0000000000000000(0000) GS:ffff8801f6f00000(0000) knlGS:0000000000000000
[  564.158070] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  564.159279] CR2: 000000000202b078 CR3: 00000001f11ac000 CR4: 00000000000006e0
[  564.161043] ==================================================================
[  564.162587] BUG: KASAN: stack-out-of-bounds in from_kuid_munged+0x1d/0x50
[  564.163994] Read of size 4 at addr ffff8801f3117c84 by task f2fs_discard-7:/1298

[  564.165852] CPU: 1 PID: 1298 Comm: f2fs_discard-7: Tainted: G      D           4.18.0-rc1+ #4
[  564.167593] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
[  564.169522] Call Trace:
[  564.170057]  dump_stack+0x7b/0xb5
[  564.170778]  print_address_description+0x70/0x290
[  564.171765]  kasan_report+0x291/0x390
[  564.172540]  ? from_kuid_munged+0x1d/0x50
[  564.173408]  __asan_load4+0x78/0x80
[  564.174148]  from_kuid_munged+0x1d/0x50
[  564.174962]  do_notify_parent+0x1f5/0x4f0
[  564.175808]  ? send_sigqueue+0x390/0x390
[  564.176639]  ? css_set_move_task+0x152/0x340
[  564.184197]  do_exit+0x1290/0x1390
[  564.184950]  ? __issue_discard_cmd+0x480/0x480
[  564.185884]  ? mm_update_next_owner+0x380/0x380
[  564.186829]  ? __sched_text_start+0x8/0x8
[  564.187672]  ? __kthread_parkme+0xcb/0x100
[  564.188528]  ? kthread_blkcg+0x70/0x70
[  564.189333]  ? kthread+0x180/0x1d0
[  564.190052]  ? __issue_discard_cmd+0x480/0x480
[  564.190983]  rewind_stack_do_exit+0x17/0x20

[  564.192190] The buggy address belongs to the page:
[  564.193213] page:ffffea0007cc45c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0
[  564.194856] flags: 0x2ffff0000000000()
[  564.195644] raw: 02ffff0000000000 0000000000000000 dead000000000200 0000000000000000
[  564.197247] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
[  564.198826] page dumped because: kasan: bad access detected

[  564.200299] Memory state around the buggy address:
[  564.201306]  ffff8801f3117b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  564.202779]  ffff8801f3117c00: 00 00 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3
[  564.204252] >ffff8801f3117c80: f3 f3 f3 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
[  564.205742]                    ^
[  564.206424]  ffff8801f3117d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  564.207908]  ffff8801f3117d80: f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00
[  564.209389] ==================================================================
[  564.231795] F2FS-fs (loop0): Mounted with checkpoint version = 2

- Location
https://elixir.bootlin.com/linux/v4.18-rc1/source/fs/f2fs/segment.h#L586
	return div_u64((u64)valid_user_blocks(sbi) * 100,
					sbi->user_block_count);
Missing checks on sbi->user_block_count.

Reported-by: Wen Xu <wen.xu@gatech.edu>
Signed-off-by: Chao Yu <yuchao0@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
",9dc956b2c8523aed39d1e6508438be9fea28c8fc,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=9dc956b2c8523aed39d1e6508438be9fea28c8fc,fs/f2fs/super.c,f2fs_sanity_check_ckpt,"int f2fs_sanity_check_ckpt(struct f2fs_sb_info *sbi)
{
unsigned int total, fsmeta;
struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
unsigned int ovp_segments, reserved_segments;
unsigned int main_segs, blocks_per_seg;
unsigned int sit_segs, nat_segs;
unsigned int sit_bitmap_size, nat_bitmap_size;
unsigned int log_blocks_per_seg;
int i;
total = le32_to_cpu(raw_super->segment_count);
fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
sit_segs = le32_to_cpu(raw_super->segment_count_sit);
fsmeta += sit_segs;
nat_segs = le32_to_cpu(raw_super->segment_count_nat);
fsmeta += nat_segs;
fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);
fsmeta += le32_to_cpu(raw_super->segment_count_ssa);
if (unlikely(fsmeta >= total))
return 1;
ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||
ovp_segments == 0 || reserved_segments == 0)) {
f2fs_msg(sbi->sb, KERN_ERR,
""Wrong layout: check mkfs.f2fs version"");
return 1;
}
main_segs = le32_to_cpu(raw_super->segment_count_main);
blocks_per_seg = sbi->blocks_per_seg;
for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
return 1;
}
for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
return 1;
}
sit_bitmap_size = le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);
nat_bitmap_size = le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);
log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);
if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||
nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {
f2fs_msg(sbi->sb, KERN_ERR,
""Wrong bitmap size: sit: %u, nat:%u"",
sit_bitmap_size, nat_bitmap_size);
return 1;
}
if (unlikely(f2fs_cp_error(sbi))) {
f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
return 1;
}
return 0;
}","int f2fs_sanity_check_ckpt(struct f2fs_sb_info *VAR_0)
{
unsigned int VAR_1, VAR_2;
struct f2fs_super_block *VAR_3 = F2FS_RAW_SUPER(VAR_0);
struct f2fs_checkpoint *VAR_4 = F2FS_CKPT(VAR_0);
unsigned int VAR_5, VAR_6;
unsigned int VAR_7, VAR_8;
unsigned int VAR_9, VAR_10;
unsigned int VAR_11, VAR_12;
unsigned int VAR_13;
int VAR_14;
VAR_1 = le32_to_cpu(VAR_3->segment_count);
VAR_2 = le32_to_cpu(VAR_3->segment_count_ckpt);
VAR_9 = le32_to_cpu(VAR_3->segment_count_sit);
VAR_2 += VAR_9;
VAR_10 = le32_to_cpu(VAR_3->segment_count_nat);
VAR_2 += VAR_10;
VAR_2 += le32_to_cpu(VAR_4->rsvd_segment_count);
VAR_2 += le32_to_cpu(VAR_3->segment_count_ssa);
if (unlikely(VAR_2 >= VAR_1))
return 1;
VAR_5 = le32_to_cpu(VAR_4->overprov_segment_count);
VAR_6 = le32_to_cpu(VAR_4->rsvd_segment_count);
if (unlikely(VAR_2 < VAR_15 ||
VAR_5 == 0 || VAR_6 == 0)) {
f2fs_msg(VAR_0->sb, VAR_16,
""Wrong layout: check mkfs.f2fs version"");
return 1;
}
VAR_7 = le32_to_cpu(VAR_3->segment_count_main);
VAR_8 = VAR_0->blocks_per_seg;
for (VAR_14 = 0; VAR_14 < VAR_17; VAR_14++) {
if (le32_to_cpu(VAR_4->cur_node_segno[VAR_14]) >= VAR_7 ||
le16_to_cpu(VAR_4->cur_node_blkoff[VAR_14]) >= VAR_8)
return 1;
}
for (VAR_14 = 0; VAR_14 < VAR_18; VAR_14++) {
if (le32_to_cpu(VAR_4->cur_data_segno[VAR_14]) >= VAR_7 ||
le16_to_cpu(VAR_4->cur_data_blkoff[VAR_14]) >= VAR_8)
return 1;
}
VAR_11 = le32_to_cpu(VAR_4->sit_ver_bitmap_bytesize);
VAR_12 = le32_to_cpu(VAR_4->nat_ver_bitmap_bytesize);
VAR_13 = le32_to_cpu(VAR_3->log_blocks_per_seg);
if (VAR_11 != ((VAR_9 / 2) << VAR_13) / 8 ||
VAR_12 != ((VAR_10 / 2) << VAR_13) / 8) {
f2fs_msg(VAR_0->sb, VAR_16,
""Wrong bitmap size: sit: %u, nat:%u"",
VAR_11, VAR_12);
return 1;
}
if (unlikely(f2fs_cp_error(VAR_0))) {
f2fs_msg(VAR_0->sb, VAR_16, ""A bug case: need to run fsck"");
return 1;
}
return 0;
}",torvalds/linux/9dc956b2c8523aed39d1e6508438be9fea28c8fc/super.c/vul/before/0.json,"int f2fs_sanity_check_ckpt(struct f2fs_sb_info *sbi)
{
	unsigned int total, fsmeta;
	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
	unsigned int ovp_segments, reserved_segments;
	unsigned int main_segs, blocks_per_seg;
	unsigned int sit_segs, nat_segs;
	unsigned int sit_bitmap_size, nat_bitmap_size;
	unsigned int log_blocks_per_seg;
	unsigned int segment_count_main;
	block_t user_block_count;
	int i;

	total = le32_to_cpu(raw_super->segment_count);
	fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
	sit_segs = le32_to_cpu(raw_super->segment_count_sit);
	fsmeta += sit_segs;
	nat_segs = le32_to_cpu(raw_super->segment_count_nat);
	fsmeta += nat_segs;
	fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);
	fsmeta += le32_to_cpu(raw_super->segment_count_ssa);

	if (unlikely(fsmeta >= total))
		return 1;

	ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);

	if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||
			ovp_segments == 0 || reserved_segments == 0)) {
		f2fs_msg(sbi->sb, KERN_ERR,
			""Wrong layout: check mkfs.f2fs version"");
		return 1;
	}

	user_block_count = le64_to_cpu(ckpt->user_block_count);
	segment_count_main = le32_to_cpu(raw_super->segment_count_main);
	log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);
	if (!user_block_count || user_block_count >=
			segment_count_main << log_blocks_per_seg) {
		f2fs_msg(sbi->sb, KERN_ERR,
			""Wrong user_block_count: %u"", user_block_count);
		return 1;
	}

	main_segs = le32_to_cpu(raw_super->segment_count_main);
	blocks_per_seg = sbi->blocks_per_seg;

	for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
			return 1;
	}
	for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
			return 1;
	}

	sit_bitmap_size = le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);
	nat_bitmap_size = le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);

	if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||
		nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {
		f2fs_msg(sbi->sb, KERN_ERR,
			""Wrong bitmap size: sit: %u, nat:%u"",
			sit_bitmap_size, nat_bitmap_size);
		return 1;
	}

	if (unlikely(f2fs_cp_error(sbi))) {
		f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
		return 1;
	}
	return 0;
}","int f2fs_sanity_check_ckpt(struct f2fs_sb_info *VAR_0)
{
	unsigned int VAR_1, VAR_2;
	struct f2fs_super_block *VAR_3 = F2FS_RAW_SUPER(VAR_0);
	struct f2fs_checkpoint *VAR_4 = F2FS_CKPT(VAR_0);
	unsigned int VAR_5, VAR_6;
	unsigned int VAR_7, VAR_8;
	unsigned int VAR_9, VAR_10;
	unsigned int VAR_11, VAR_12;
	unsigned int VAR_13;
	unsigned int VAR_14;
	block_t VAR_15;
	int VAR_16;

	VAR_1 = le32_to_cpu(VAR_3->segment_count);
	VAR_2 = le32_to_cpu(VAR_3->segment_count_ckpt);
	VAR_9 = le32_to_cpu(VAR_3->segment_count_sit);
	VAR_2 += VAR_9;
	VAR_10 = le32_to_cpu(VAR_3->segment_count_nat);
	VAR_2 += VAR_10;
	VAR_2 += le32_to_cpu(VAR_4->rsvd_segment_count);
	VAR_2 += le32_to_cpu(VAR_3->segment_count_ssa);

	if (unlikely(VAR_2 >= VAR_1))
		return 1;

	VAR_5 = le32_to_cpu(VAR_4->overprov_segment_count);
	VAR_6 = le32_to_cpu(VAR_4->rsvd_segment_count);

	if (unlikely(VAR_2 < VAR_17 ||
			VAR_5 == 0 || VAR_6 == 0)) {
		f2fs_msg(VAR_0->sb, VAR_18,
			""Wrong layout: check mkfs.f2fs version"");
		return 1;
	}

	VAR_15 = le64_to_cpu(VAR_4->user_block_count);
	VAR_14 = le32_to_cpu(VAR_3->segment_count_main);
	VAR_13 = le32_to_cpu(VAR_3->log_blocks_per_seg);
	if (!VAR_15 || VAR_15 >=
			VAR_14 << VAR_13) {
		f2fs_msg(VAR_0->sb, VAR_18,
			""Wrong user_block_count: %u"", VAR_15);
		return 1;
	}

	VAR_7 = le32_to_cpu(VAR_3->segment_count_main);
	VAR_8 = VAR_0->blocks_per_seg;

	for (VAR_16 = 0; VAR_16 < VAR_19; VAR_16++) {
		if (le32_to_cpu(VAR_4->cur_node_segno[VAR_16]) >= VAR_7 ||
			le16_to_cpu(VAR_4->cur_node_blkoff[VAR_16]) >= VAR_8)
			return 1;
	}
	for (VAR_16 = 0; VAR_16 < VAR_20; VAR_16++) {
		if (le32_to_cpu(VAR_4->cur_data_segno[VAR_16]) >= VAR_7 ||
			le16_to_cpu(VAR_4->cur_data_blkoff[VAR_16]) >= VAR_8)
			return 1;
	}

	VAR_11 = le32_to_cpu(VAR_4->sit_ver_bitmap_bytesize);
	VAR_12 = le32_to_cpu(VAR_4->nat_ver_bitmap_bytesize);

	if (VAR_11 != ((VAR_9 / 2) << VAR_13) / 8 ||
		VAR_12 != ((VAR_10 / 2) << VAR_13) / 8) {
		f2fs_msg(VAR_0->sb, VAR_18,
			""Wrong bitmap size: sit: %u, nat:%u"",
			VAR_11, VAR_12);
		return 1;
	}

	if (unlikely(f2fs_cp_error(VAR_0))) {
		f2fs_msg(VAR_0->sb, VAR_18, ""A bug case: need to run fsck"");
		return 1;
	}
	return 0;
}",torvalds/linux/9dc956b2c8523aed39d1e6508438be9fea28c8fc/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
 	unsigned int sit_segs, nat_segs;
 	unsigned int sit_bitmap_size, nat_bitmap_size;
 	unsigned int log_blocks_per_seg;
+	unsigned int segment_count_main;
+	block_t user_block_count;
 	int i;
 
 	total = le32_to_cpu(raw_super->segment_count);
@@ -32,6 +34,16 @@
 		return 1;
 	}
 
+	user_block_count = le64_to_cpu(ckpt->user_block_count);
+	segment_count_main = le32_to_cpu(raw_super->segment_count_main);
+	log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);
+	if (!user_block_count || user_block_count >=
+			segment_count_main << log_blocks_per_seg) {
+		f2fs_msg(sbi->sb, KERN_ERR,
+			""Wrong user_block_count: %u"", user_block_count);
+		return 1;
+	}
+
 	main_segs = le32_to_cpu(raw_super->segment_count_main);
 	blocks_per_seg = sbi->blocks_per_seg;
 
@@ -48,7 +60,6 @@
 
 	sit_bitmap_size = le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);
 	nat_bitmap_size = le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);
-	log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);
 
 	if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||
 		nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {","{'deleted_lines': ['\tlog_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);'], 'added_lines': ['\tunsigned int segment_count_main;', '\tblock_t user_block_count;', '\tuser_block_count = le64_to_cpu(ckpt->user_block_count);', '\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);', '\tlog_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);', '\tif (!user_block_count || user_block_count >=', '\t\t\tsegment_count_main << log_blocks_per_seg) {', '\t\tf2fs_msg(sbi->sb, KERN_ERR,', '\t\t\t""Wrong user_block_count: %u"", user_block_count);', '\t\treturn 1;', '\t}', '']}",True,"An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3. There is an out-of-bounds read or a divide-by-zero error for an incorrect user_block_count in a corrupted f2fs image, leading to a denial of service (BUG).",5.5,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/super.c,ext4_has_uninit_itable,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
struct ext4_group_desc *gdp = NULL;
for (group = 0; group < ngroups; group++) {
gdp = ext4_get_group_desc(sb, group, NULL);
if (!gdp)
continue;
if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
break;
}
return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *VAR_0)
{
ext4_group_t VAR_1, VAR_2 = EXT4_SB(VAR_0)->s_groups_count;
struct ext4_group_desc *VAR_3 = NULL;
for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
VAR_3 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
if (!VAR_3)
continue;
if (!(VAR_3->bg_flags & cpu_to_le16(VAR_4)))
break;
}
return VAR_1;
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/super.c/vul/before/0.json,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;

		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}

	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *VAR_0)
{
	ext4_group_t VAR_1, VAR_2 = EXT4_SB(VAR_0)->s_groups_count;
	struct ext4_group_desc *VAR_3 = NULL;

	if (!ext4_has_group_desc_csum(VAR_0))
		return VAR_2;

	for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
		VAR_3 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
		if (!VAR_3)
			continue;

		if (VAR_3->bg_flags & cpu_to_le16(VAR_4))
			continue;
		if (VAR_1 != 0)
			break;
		ext4_error(VAR_0, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(VAR_0))
			return VAR_2;
	}

	return VAR_1;
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,14 +2,23 @@
 {
 	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
 	struct ext4_group_desc *gdp = NULL;
+
+	if (!ext4_has_group_desc_csum(sb))
+		return ngroups;
 
 	for (group = 0; group < ngroups; group++) {
 		gdp = ext4_get_group_desc(sb, group, NULL);
 		if (!gdp)
 			continue;
 
-		if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
+		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
+			continue;
+		if (group != 0)
 			break;
+		ext4_error(sb, ""Inode table for bg 0 marked as ""
+			   ""needing zeroing"");
+		if (sb_rdonly(sb))
+			return ngroups;
 	}
 
 	return group;","{'deleted_lines': ['\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))'], 'added_lines': ['', '\tif (!ext4_has_group_desc_csum(sb))', '\t\treturn ngroups;', '\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))', '\t\t\tcontinue;', '\t\tif (group != 0)', '\t\text4_error(sb, ""Inode table for bg 0 marked as ""', '\t\t\t   ""needing zeroing"");', '\t\tif (sb_rdonly(sb))', '\t\t\treturn ngroups;']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/balloc.c,ext4_read_block_bitmap_nowait,"struct buffer_head *
ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)
{
struct ext4_group_desc *desc;
struct ext4_sb_info *sbi = EXT4_SB(sb);
struct buffer_head *bh;
ext4_fsblk_t bitmap_blk;
int err;
desc = ext4_get_group_desc(sb, block_group, NULL);
if (!desc)
return ERR_PTR(-EFSCORRUPTED);
bitmap_blk = ext4_block_bitmap(sb, desc);
if ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
(bitmap_blk >= ext4_blocks_count(sbi->s_es))) {
ext4_error(sb, ""Invalid block bitmap block %llu in ""
""block_group %u"", bitmap_blk, block_group);
ext4_mark_group_bitmap_corrupted(sb, block_group,
EXT4_GROUP_INFO_BBITMAP_CORRUPT);
return ERR_PTR(-EFSCORRUPTED);
}
bh = sb_getblk(sb, bitmap_blk);
if (unlikely(!bh)) {
ext4_error(sb, ""Cannot get buffer for block bitmap - ""
""block_group = %u, block_bitmap = %llu"",
block_group, bitmap_blk);
return ERR_PTR(-ENOMEM);
}
if (bitmap_uptodate(bh))
goto verify;
lock_buffer(bh);
if (bitmap_uptodate(bh)) {
unlock_buffer(bh);
goto verify;
}
ext4_lock_group(sb, block_group);
if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
err = ext4_init_block_bitmap(sb, bh, block_group, desc);
set_bitmap_uptodate(bh);
set_buffer_uptodate(bh);
set_buffer_verified(bh);
ext4_unlock_group(sb, block_group);
unlock_buffer(bh);
if (err) {
ext4_error(sb, ""Failed to init block bitmap for group ""
""%u: %d"", block_group, err);
goto out;
}
goto verify;
}
ext4_unlock_group(sb, block_group);
if (buffer_uptodate(bh)) {
set_bitmap_uptodate(bh);
unlock_buffer(bh);
goto verify;
}
set_buffer_new(bh);
trace_ext4_read_block_bitmap_load(sb, block_group);
bh->b_end_io = ext4_end_bitmap_read;
get_bh(bh);
submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);
return bh;
verify:
err = ext4_validate_block_bitmap(sb, desc, block_group, bh);
if (err)
goto out;
return bh;
out:
put_bh(bh);
return ERR_PTR(err);
}","struct buffer_head *
ext4_read_block_bitmap_nowait(struct super_block *VAR_0, ext4_group_t VAR_1)
{
struct ext4_group_desc *VAR_2;
struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
struct buffer_head *VAR_4;
ext4_fsblk_t VAR_5;
int VAR_6;
VAR_2 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
if (!VAR_2)
return ERR_PTR(-VAR_7);
VAR_5 = ext4_block_bitmap(VAR_0, VAR_2);
if ((VAR_5 <= le32_to_cpu(VAR_3->s_es->s_first_data_block)) ||
(VAR_5 >= ext4_blocks_count(VAR_3->s_es))) {
ext4_error(VAR_0, ""Invalid block bitmap block %llu in ""
""block_group %u"", VAR_5, VAR_1);
ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
VAR_8);
return ERR_PTR(-VAR_7);
}
VAR_4 = sb_getblk(VAR_0, VAR_5);
if (unlikely(!VAR_4)) {
ext4_error(VAR_0, ""Cannot get buffer for block bitmap - ""
""block_group = %u, block_bitmap = %llu"",
VAR_1, VAR_5);
return ERR_PTR(-VAR_9);
}
if (bitmap_uptodate(VAR_4))
goto verify;
lock_buffer(VAR_4);
if (bitmap_uptodate(VAR_4)) {
unlock_buffer(VAR_4);
goto verify;
}
ext4_lock_group(VAR_0, VAR_1);
if (VAR_2->bg_flags & cpu_to_le16(VAR_10)) {
VAR_6 = ext4_init_block_bitmap(VAR_0, VAR_4, VAR_1, VAR_2);
set_bitmap_uptodate(VAR_4);
set_buffer_uptodate(VAR_4);
set_buffer_verified(VAR_4);
ext4_unlock_group(VAR_0, VAR_1);
unlock_buffer(VAR_4);
if (VAR_6) {
ext4_error(VAR_0, ""Failed to init block bitmap for group ""
""%u: %d"", VAR_1, VAR_6);
goto out;
}
goto verify;
}
ext4_unlock_group(VAR_0, VAR_1);
if (buffer_uptodate(VAR_4)) {
set_bitmap_uptodate(VAR_4);
unlock_buffer(VAR_4);
goto verify;
}
set_buffer_new(VAR_4);
trace_ext4_read_block_bitmap_load(VAR_0, VAR_1);
VAR_4->b_end_io = VAR_11;
get_bh(VAR_4);
submit_bh(VAR_12, VAR_13 | VAR_14, VAR_4);
return VAR_4;
verify:
VAR_6 = ext4_validate_block_bitmap(VAR_0, VAR_2, VAR_1, VAR_4);
if (VAR_6)
goto out;
return VAR_4;
out:
put_bh(VAR_4);
return ERR_PTR(VAR_6);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/balloc.c/vul/before/0.json,"struct buffer_head *
ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)
{
	struct ext4_group_desc *desc;
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct buffer_head *bh;
	ext4_fsblk_t bitmap_blk;
	int err;

	desc = ext4_get_group_desc(sb, block_group, NULL);
	if (!desc)
		return ERR_PTR(-EFSCORRUPTED);
	bitmap_blk = ext4_block_bitmap(sb, desc);
	if ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {
		ext4_error(sb, ""Invalid block bitmap block %llu in ""
			   ""block_group %u"", bitmap_blk, block_group);
		ext4_mark_group_bitmap_corrupted(sb, block_group,
					EXT4_GROUP_INFO_BBITMAP_CORRUPT);
		return ERR_PTR(-EFSCORRUPTED);
	}
	bh = sb_getblk(sb, bitmap_blk);
	if (unlikely(!bh)) {
		ext4_error(sb, ""Cannot get buffer for block bitmap - ""
			   ""block_group = %u, block_bitmap = %llu"",
			   block_group, bitmap_blk);
		return ERR_PTR(-ENOMEM);
	}

	if (bitmap_uptodate(bh))
		goto verify;

	lock_buffer(bh);
	if (bitmap_uptodate(bh)) {
		unlock_buffer(bh);
		goto verify;
	}
	ext4_lock_group(sb, block_group);
	if (ext4_has_group_desc_csum(sb) &&
	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
		if (block_group == 0) {
			ext4_unlock_group(sb, block_group);
			unlock_buffer(bh);
			ext4_error(sb, ""Block bitmap for bg 0 marked ""
				   ""uninitialized"");
			err = -EFSCORRUPTED;
			goto out;
		}
		err = ext4_init_block_bitmap(sb, bh, block_group, desc);
		set_bitmap_uptodate(bh);
		set_buffer_uptodate(bh);
		set_buffer_verified(bh);
		ext4_unlock_group(sb, block_group);
		unlock_buffer(bh);
		if (err) {
			ext4_error(sb, ""Failed to init block bitmap for group ""
				   ""%u: %d"", block_group, err);
			goto out;
		}
		goto verify;
	}
	ext4_unlock_group(sb, block_group);
	if (buffer_uptodate(bh)) {
		/*
		 * if not uninit if bh is uptodate,
		 * bitmap is also uptodate
		 */
		set_bitmap_uptodate(bh);
		unlock_buffer(bh);
		goto verify;
	}
	/*
	 * submit the buffer_head for reading
	 */
	set_buffer_new(bh);
	trace_ext4_read_block_bitmap_load(sb, block_group);
	bh->b_end_io = ext4_end_bitmap_read;
	get_bh(bh);
	submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);
	return bh;
verify:
	err = ext4_validate_block_bitmap(sb, desc, block_group, bh);
	if (err)
		goto out;
	return bh;
out:
	put_bh(bh);
	return ERR_PTR(err);
}","struct buffer_head *
ext4_read_block_bitmap_nowait(struct super_block *VAR_0, ext4_group_t VAR_1)
{
	struct ext4_group_desc *VAR_2;
	struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
	struct buffer_head *VAR_4;
	ext4_fsblk_t VAR_5;
	int VAR_6;

	VAR_2 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
	if (!VAR_2)
		return ERR_PTR(-VAR_7);
	VAR_5 = ext4_block_bitmap(VAR_0, VAR_2);
	if ((VAR_5 <= le32_to_cpu(VAR_3->s_es->s_first_data_block)) ||
	    (VAR_5 >= ext4_blocks_count(VAR_3->s_es))) {
		ext4_error(VAR_0, ""Invalid block bitmap block %llu in ""
			   ""block_group %u"", VAR_5, VAR_1);
		ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
					VAR_8);
		return ERR_PTR(-VAR_7);
	}
	VAR_4 = sb_getblk(VAR_0, VAR_5);
	if (unlikely(!VAR_4)) {
		ext4_error(VAR_0, ""Cannot get buffer for block bitmap - ""
			   ""block_group = %u, block_bitmap = %llu"",
			   VAR_1, VAR_5);
		return ERR_PTR(-VAR_9);
	}

	if (bitmap_uptodate(VAR_4))
		goto verify;

	lock_buffer(VAR_4);
	if (bitmap_uptodate(VAR_4)) {
		unlock_buffer(VAR_4);
		goto verify;
	}
	ext4_lock_group(VAR_0, VAR_1);
	if (ext4_has_group_desc_csum(VAR_0) &&
	    (VAR_2->bg_flags & cpu_to_le16(VAR_10))) {
		if (VAR_1 == 0) {
			ext4_unlock_group(VAR_0, VAR_1);
			unlock_buffer(VAR_4);
			ext4_error(VAR_0, ""Block bitmap for bg 0 marked ""
				   ""uninitialized"");
			VAR_6 = -VAR_7;
			goto out;
		}
		VAR_6 = ext4_init_block_bitmap(VAR_0, VAR_4, VAR_1, VAR_2);
		set_bitmap_uptodate(VAR_4);
		set_buffer_uptodate(VAR_4);
		set_buffer_verified(VAR_4);
		ext4_unlock_group(VAR_0, VAR_1);
		unlock_buffer(VAR_4);
		if (VAR_6) {
			ext4_error(VAR_0, ""Failed to init block bitmap for group ""
				   ""%u: %d"", VAR_1, VAR_6);
			goto out;
		}
		goto verify;
	}
	ext4_unlock_group(VAR_0, VAR_1);
	if (buffer_uptodate(VAR_4)) {
		/* COMMENT_0 */
                                     
                            
     
		set_bitmap_uptodate(VAR_4);
		unlock_buffer(VAR_4);
		goto verify;
	}
	/* COMMENT_4 */
                                      
    
	set_buffer_new(VAR_4);
	trace_ext4_read_block_bitmap_load(VAR_0, VAR_1);
	VAR_4->b_end_io = VAR_11;
	get_bh(VAR_4);
	submit_bh(VAR_12, VAR_13 | VAR_14, VAR_4);
	return VAR_4;
verify:
	VAR_6 = ext4_validate_block_bitmap(VAR_0, VAR_2, VAR_1, VAR_4);
	if (VAR_6)
		goto out;
	return VAR_4;
out:
	put_bh(VAR_4);
	return ERR_PTR(VAR_6);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/balloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,7 +36,16 @@
 		goto verify;
 	}
 	ext4_lock_group(sb, block_group);
-	if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
+		if (block_group == 0) {
+			ext4_unlock_group(sb, block_group);
+			unlock_buffer(bh);
+			ext4_error(sb, ""Block bitmap for bg 0 marked ""
+				   ""uninitialized"");
+			err = -EFSCORRUPTED;
+			goto out;
+		}
 		err = ext4_init_block_bitmap(sb, bh, block_group, desc);
 		set_bitmap_uptodate(bh);
 		set_buffer_uptodate(bh);","{'deleted_lines': ['\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {'], 'added_lines': ['\tif (ext4_has_group_desc_csum(sb) &&', '\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {', '\t\tif (block_group == 0) {', '\t\t\text4_unlock_group(sb, block_group);', '\t\t\tunlock_buffer(bh);', '\t\t\text4_error(sb, ""Block bitmap for bg 0 marked ""', '\t\t\t\t   ""uninitialized"");', '\t\t\terr = -EFSCORRUPTED;', '\t\t\tgoto out;', '\t\t}']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/ialloc.c,ext4_read_inode_bitmap,"static struct buffer_head *
ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
{
struct ext4_group_desc *desc;
struct ext4_sb_info *sbi = EXT4_SB(sb);
struct buffer_head *bh = NULL;
ext4_fsblk_t bitmap_blk;
int err;
desc = ext4_get_group_desc(sb, block_group, NULL);
if (!desc)
return ERR_PTR(-EFSCORRUPTED);
bitmap_blk = ext4_inode_bitmap(sb, desc);
if ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
(bitmap_blk >= ext4_blocks_count(sbi->s_es))) {
ext4_error(sb, ""Invalid inode bitmap blk %llu in ""
""block_group %u"", bitmap_blk, block_group);
ext4_mark_group_bitmap_corrupted(sb, block_group,
EXT4_GROUP_INFO_IBITMAP_CORRUPT);
return ERR_PTR(-EFSCORRUPTED);
}
bh = sb_getblk(sb, bitmap_blk);
if (unlikely(!bh)) {
ext4_error(sb, ""Cannot read inode bitmap - ""
""block_group = %u, inode_bitmap = %llu"",
block_group, bitmap_blk);
return ERR_PTR(-ENOMEM);
}
if (bitmap_uptodate(bh))
goto verify;
lock_buffer(bh);
if (bitmap_uptodate(bh)) {
unlock_buffer(bh);
goto verify;
}
ext4_lock_group(sb, block_group);
if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {
memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),
sb->s_blocksize * 8, bh->b_data);
set_bitmap_uptodate(bh);
set_buffer_uptodate(bh);
set_buffer_verified(bh);
ext4_unlock_group(sb, block_group);
unlock_buffer(bh);
return bh;
}
ext4_unlock_group(sb, block_group);
if (buffer_uptodate(bh)) {
set_bitmap_uptodate(bh);
unlock_buffer(bh);
goto verify;
}
trace_ext4_load_inode_bitmap(sb, block_group);
bh->b_end_io = ext4_end_bitmap_read;
get_bh(bh);
submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);
wait_on_buffer(bh);
if (!buffer_uptodate(bh)) {
put_bh(bh);
ext4_error(sb, ""Cannot read inode bitmap - ""
""block_group = %u, inode_bitmap = %llu"",
block_group, bitmap_blk);
ext4_mark_group_bitmap_corrupted(sb, block_group,
EXT4_GROUP_INFO_IBITMAP_CORRUPT);
return ERR_PTR(-EIO);
}
verify:
err = ext4_validate_inode_bitmap(sb, desc, block_group, bh);
if (err)
goto out;
return bh;
out:
put_bh(bh);
return ERR_PTR(err);
}","static struct buffer_head *
ext4_read_inode_bitmap(struct super_block *VAR_0, ext4_group_t VAR_1)
{
struct ext4_group_desc *VAR_2;
struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
struct buffer_head *VAR_4 = NULL;
ext4_fsblk_t VAR_5;
int VAR_6;
VAR_2 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
if (!VAR_2)
return ERR_PTR(-VAR_7);
VAR_5 = ext4_inode_bitmap(VAR_0, VAR_2);
if ((VAR_5 <= le32_to_cpu(VAR_3->s_es->s_first_data_block)) ||
(VAR_5 >= ext4_blocks_count(VAR_3->s_es))) {
ext4_error(VAR_0, ""Invalid inode bitmap blk %llu in ""
""block_group %u"", VAR_5, VAR_1);
ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
VAR_8);
return ERR_PTR(-VAR_7);
}
VAR_4 = sb_getblk(VAR_0, VAR_5);
if (unlikely(!VAR_4)) {
ext4_error(VAR_0, ""Cannot read inode bitmap - ""
""block_group = %u, inode_bitmap = %llu"",
VAR_1, VAR_5);
return ERR_PTR(-VAR_9);
}
if (bitmap_uptodate(VAR_4))
goto verify;
lock_buffer(VAR_4);
if (bitmap_uptodate(VAR_4)) {
unlock_buffer(VAR_4);
goto verify;
}
ext4_lock_group(VAR_0, VAR_1);
if (VAR_2->bg_flags & cpu_to_le16(VAR_10)) {
memset(VAR_4->b_data, 0, (EXT4_INODES_PER_GROUP(VAR_0) + 7) / 8);
ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(VAR_0),
VAR_0->s_blocksize * 8, VAR_4->b_data);
set_bitmap_uptodate(VAR_4);
set_buffer_uptodate(VAR_4);
set_buffer_verified(VAR_4);
ext4_unlock_group(VAR_0, VAR_1);
unlock_buffer(VAR_4);
return VAR_4;
}
ext4_unlock_group(VAR_0, VAR_1);
if (buffer_uptodate(VAR_4)) {
set_bitmap_uptodate(VAR_4);
unlock_buffer(VAR_4);
goto verify;
}
trace_ext4_load_inode_bitmap(VAR_0, VAR_1);
VAR_4->b_end_io = VAR_11;
get_bh(VAR_4);
submit_bh(VAR_12, VAR_13 | VAR_14, VAR_4);
wait_on_buffer(VAR_4);
if (!buffer_uptodate(VAR_4)) {
put_bh(VAR_4);
ext4_error(VAR_0, ""Cannot read inode bitmap - ""
""block_group = %u, inode_bitmap = %llu"",
VAR_1, VAR_5);
ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
VAR_8);
return ERR_PTR(-VAR_15);
}
verify:
VAR_6 = ext4_validate_inode_bitmap(VAR_0, VAR_2, VAR_1, VAR_4);
if (VAR_6)
goto out;
return VAR_4;
out:
put_bh(VAR_4);
return ERR_PTR(VAR_6);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/ialloc.c/vul/before/0.json,"static struct buffer_head *
ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
{
	struct ext4_group_desc *desc;
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct buffer_head *bh = NULL;
	ext4_fsblk_t bitmap_blk;
	int err;

	desc = ext4_get_group_desc(sb, block_group, NULL);
	if (!desc)
		return ERR_PTR(-EFSCORRUPTED);

	bitmap_blk = ext4_inode_bitmap(sb, desc);
	if ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {
		ext4_error(sb, ""Invalid inode bitmap blk %llu in ""
			   ""block_group %u"", bitmap_blk, block_group);
		ext4_mark_group_bitmap_corrupted(sb, block_group,
					EXT4_GROUP_INFO_IBITMAP_CORRUPT);
		return ERR_PTR(-EFSCORRUPTED);
	}
	bh = sb_getblk(sb, bitmap_blk);
	if (unlikely(!bh)) {
		ext4_error(sb, ""Cannot read inode bitmap - ""
			    ""block_group = %u, inode_bitmap = %llu"",
			    block_group, bitmap_blk);
		return ERR_PTR(-ENOMEM);
	}
	if (bitmap_uptodate(bh))
		goto verify;

	lock_buffer(bh);
	if (bitmap_uptodate(bh)) {
		unlock_buffer(bh);
		goto verify;
	}

	ext4_lock_group(sb, block_group);
	if (ext4_has_group_desc_csum(sb) &&
	    (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {
		if (block_group == 0) {
			ext4_unlock_group(sb, block_group);
			unlock_buffer(bh);
			ext4_error(sb, ""Inode bitmap for bg 0 marked ""
				   ""uninitialized"");
			err = -EFSCORRUPTED;
			goto out;
		}
		memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
		ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),
				     sb->s_blocksize * 8, bh->b_data);
		set_bitmap_uptodate(bh);
		set_buffer_uptodate(bh);
		set_buffer_verified(bh);
		ext4_unlock_group(sb, block_group);
		unlock_buffer(bh);
		return bh;
	}
	ext4_unlock_group(sb, block_group);

	if (buffer_uptodate(bh)) {
		/*
		 * if not uninit if bh is uptodate,
		 * bitmap is also uptodate
		 */
		set_bitmap_uptodate(bh);
		unlock_buffer(bh);
		goto verify;
	}
	/*
	 * submit the buffer_head for reading
	 */
	trace_ext4_load_inode_bitmap(sb, block_group);
	bh->b_end_io = ext4_end_bitmap_read;
	get_bh(bh);
	submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);
	wait_on_buffer(bh);
	if (!buffer_uptodate(bh)) {
		put_bh(bh);
		ext4_error(sb, ""Cannot read inode bitmap - ""
			   ""block_group = %u, inode_bitmap = %llu"",
			   block_group, bitmap_blk);
		ext4_mark_group_bitmap_corrupted(sb, block_group,
				EXT4_GROUP_INFO_IBITMAP_CORRUPT);
		return ERR_PTR(-EIO);
	}

verify:
	err = ext4_validate_inode_bitmap(sb, desc, block_group, bh);
	if (err)
		goto out;
	return bh;
out:
	put_bh(bh);
	return ERR_PTR(err);
}","static struct buffer_head *
ext4_read_inode_bitmap(struct super_block *VAR_0, ext4_group_t VAR_1)
{
	struct ext4_group_desc *VAR_2;
	struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
	struct buffer_head *VAR_4 = NULL;
	ext4_fsblk_t VAR_5;
	int VAR_6;

	VAR_2 = ext4_get_group_desc(VAR_0, VAR_1, NULL);
	if (!VAR_2)
		return ERR_PTR(-VAR_7);

	VAR_5 = ext4_inode_bitmap(VAR_0, VAR_2);
	if ((VAR_5 <= le32_to_cpu(VAR_3->s_es->s_first_data_block)) ||
	    (VAR_5 >= ext4_blocks_count(VAR_3->s_es))) {
		ext4_error(VAR_0, ""Invalid inode bitmap blk %llu in ""
			   ""block_group %u"", VAR_5, VAR_1);
		ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
					VAR_8);
		return ERR_PTR(-VAR_7);
	}
	VAR_4 = sb_getblk(VAR_0, VAR_5);
	if (unlikely(!VAR_4)) {
		ext4_error(VAR_0, ""Cannot read inode bitmap - ""
			    ""block_group = %u, inode_bitmap = %llu"",
			    VAR_1, VAR_5);
		return ERR_PTR(-VAR_9);
	}
	if (bitmap_uptodate(VAR_4))
		goto verify;

	lock_buffer(VAR_4);
	if (bitmap_uptodate(VAR_4)) {
		unlock_buffer(VAR_4);
		goto verify;
	}

	ext4_lock_group(VAR_0, VAR_1);
	if (ext4_has_group_desc_csum(VAR_0) &&
	    (VAR_2->bg_flags & cpu_to_le16(VAR_10))) {
		if (VAR_1 == 0) {
			ext4_unlock_group(VAR_0, VAR_1);
			unlock_buffer(VAR_4);
			ext4_error(VAR_0, ""Inode bitmap for bg 0 marked ""
				   ""uninitialized"");
			VAR_6 = -VAR_7;
			goto out;
		}
		memset(VAR_4->b_data, 0, (EXT4_INODES_PER_GROUP(VAR_0) + 7) / 8);
		ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(VAR_0),
				     VAR_0->s_blocksize * 8, VAR_4->b_data);
		set_bitmap_uptodate(VAR_4);
		set_buffer_uptodate(VAR_4);
		set_buffer_verified(VAR_4);
		ext4_unlock_group(VAR_0, VAR_1);
		unlock_buffer(VAR_4);
		return VAR_4;
	}
	ext4_unlock_group(VAR_0, VAR_1);

	if (buffer_uptodate(VAR_4)) {
		/* COMMENT_0 */
                                     
                            
     
		set_bitmap_uptodate(VAR_4);
		unlock_buffer(VAR_4);
		goto verify;
	}
	/* COMMENT_4 */
                                      
    
	trace_ext4_load_inode_bitmap(VAR_0, VAR_1);
	VAR_4->b_end_io = VAR_11;
	get_bh(VAR_4);
	submit_bh(VAR_12, VAR_13 | VAR_14, VAR_4);
	wait_on_buffer(VAR_4);
	if (!buffer_uptodate(VAR_4)) {
		put_bh(VAR_4);
		ext4_error(VAR_0, ""Cannot read inode bitmap - ""
			   ""block_group = %u, inode_bitmap = %llu"",
			   VAR_1, VAR_5);
		ext4_mark_group_bitmap_corrupted(VAR_0, VAR_1,
				VAR_8);
		return ERR_PTR(-VAR_15);
	}

verify:
	VAR_6 = ext4_validate_inode_bitmap(VAR_0, VAR_2, VAR_1, VAR_4);
	if (VAR_6)
		goto out;
	return VAR_4;
out:
	put_bh(VAR_4);
	return ERR_PTR(VAR_6);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/ialloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,7 +37,16 @@
 	}
 
 	ext4_lock_group(sb, block_group);
-	if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {
+		if (block_group == 0) {
+			ext4_unlock_group(sb, block_group);
+			unlock_buffer(bh);
+			ext4_error(sb, ""Inode bitmap for bg 0 marked ""
+				   ""uninitialized"");
+			err = -EFSCORRUPTED;
+			goto out;
+		}
 		memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
 		ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),
 				     sb->s_blocksize * 8, bh->b_data);","{'deleted_lines': ['\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {'], 'added_lines': ['\tif (ext4_has_group_desc_csum(sb) &&', '\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {', '\t\tif (block_group == 0) {', '\t\t\text4_unlock_group(sb, block_group);', '\t\t\tunlock_buffer(bh);', '\t\t\text4_error(sb, ""Inode bitmap for bg 0 marked ""', '\t\t\t\t   ""uninitialized"");', '\t\t\terr = -EFSCORRUPTED;', '\t\t\tgoto out;', '\t\t}']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/ialloc.c,__ext4_new_inode,"struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,
umode_t mode, const struct qstr *qstr,
__u32 goal, uid_t *owner, __u32 i_flags,
int handle_type, unsigned int line_no,
int nblocks)
{
struct super_block *sb;
struct buffer_head *inode_bitmap_bh = NULL;
struct buffer_head *group_desc_bh;
ext4_group_t ngroups, group = 0;
unsigned long ino = 0;
struct inode *inode;
struct ext4_group_desc *gdp = NULL;
struct ext4_inode_info *ei;
struct ext4_sb_info *sbi;
int ret2, err;
struct inode *ret;
ext4_group_t i;
ext4_group_t flex_group;
struct ext4_group_info *grp;
int encrypt = 0;
if (!dir || !dir->i_nlink)
return ERR_PTR(-EPERM);
sb = dir->i_sb;
sbi = EXT4_SB(sb);
if (unlikely(ext4_forced_shutdown(sbi)))
return ERR_PTR(-EIO);
if ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&
(S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&
!(i_flags & EXT4_EA_INODE_FL)) {
err = fscrypt_get_encryption_info(dir);
if (err)
return ERR_PTR(err);
if (!fscrypt_has_encryption_key(dir))
return ERR_PTR(-ENOKEY);
encrypt = 1;
}
if (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {
#ifdef CONFIG_EXT4_FS_POSIX_ACL
struct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);
if (IS_ERR(p))
return ERR_CAST(p);
if (p) {
int acl_size = p->a_count * sizeof(ext4_acl_entry);
nblocks += (S_ISDIR(mode) ? 2 : 1) *
__ext4_xattr_set_credits(sb, NULL ,
NULL , acl_size,
true );
posix_acl_release(p);
}
#endif
#ifdef CONFIG_SECURITY
{
int num_security_xattrs = 1;
#ifdef CONFIG_INTEGRITY
num_security_xattrs++;
#endif
nblocks += num_security_xattrs *
__ext4_xattr_set_credits(sb, NULL ,
NULL , 1024,
true );
}
#endif
if (encrypt)
nblocks += __ext4_xattr_set_credits(sb,
NULL , NULL ,
FSCRYPT_SET_CONTEXT_MAX_SIZE,
true );
}
ngroups = ext4_get_groups_count(sb);
trace_ext4_request_inode(dir, mode);
inode = new_inode(sb);
if (!inode)
return ERR_PTR(-ENOMEM);
ei = EXT4_I(inode);
if (owner) {
inode->i_mode = mode;
i_uid_write(inode, owner[0]);
i_gid_write(inode, owner[1]);
} else if (test_opt(sb, GRPID)) {
inode->i_mode = mode;
inode->i_uid = current_fsuid();
inode->i_gid = dir->i_gid;
} else
inode_init_owner(inode, dir, mode);
if (ext4_has_feature_project(sb) &&
ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))
ei->i_projid = EXT4_I(dir)->i_projid;
else
ei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);
err = dquot_initialize(inode);
if (err)
goto out;
if (!goal)
goal = sbi->s_inode_goal;
if (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {
group = (goal - 1) / EXT4_INODES_PER_GROUP(sb);
ino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);
ret2 = 0;
goto got_group;
}
if (S_ISDIR(mode))
ret2 = find_group_orlov(sb, dir, &group, mode, qstr);
else
ret2 = find_group_other(sb, dir, &group, mode);
got_group:
EXT4_I(dir)->i_last_alloc_group = group;
err = -ENOSPC;
if (ret2 == -1)
goto out;
for (i = 0; i < ngroups; i++, ino = 0) {
err = -EIO;
gdp = ext4_get_group_desc(sb, group, &group_desc_bh);
if (!gdp)
goto out;
if (ext4_free_inodes_count(sb, gdp) == 0)
goto next_group;
grp = ext4_get_group_info(sb, group);
if (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))
goto next_group;
brelse(inode_bitmap_bh);
inode_bitmap_bh = ext4_read_inode_bitmap(sb, group);
if (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||
IS_ERR(inode_bitmap_bh)) {
inode_bitmap_bh = NULL;
goto next_group;
}
repeat_in_this_group:
ret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);
if (!ret2)
goto next_group;
if (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {
ext4_error(sb, ""reserved inode found cleared - ""
""inode=%lu"", ino + 1);
ext4_mark_group_bitmap_corrupted(sb, group,
EXT4_GROUP_INFO_IBITMAP_CORRUPT);
goto next_group;
}
if (!handle) {
BUG_ON(nblocks <= 0);
handle = __ext4_journal_start_sb(dir->i_sb, line_no,
handle_type, nblocks,
0);
if (IS_ERR(handle)) {
err = PTR_ERR(handle);
ext4_std_error(sb, err);
goto out;
}
}
BUFFER_TRACE(inode_bitmap_bh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, inode_bitmap_bh);
if (err) {
ext4_std_error(sb, err);
goto out;
}
ext4_lock_group(sb, group);
ret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);
if (ret2) {
ret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);
if (ret2) {
ext4_set_bit(ino, inode_bitmap_bh->b_data);
ret2 = 0;
} else {
ret2 = 1; 
}
}
ext4_unlock_group(sb, group);
ino++;
if (!ret2)
goto got; 
if (ino < EXT4_INODES_PER_GROUP(sb))
goto repeat_in_this_group;
next_group:
if (++group == ngroups)
group = 0;
}
err = -ENOSPC;
goto out;
got:
BUFFER_TRACE(inode_bitmap_bh, ""call ext4_handle_dirty_metadata"");
err = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);
if (err) {
ext4_std_error(sb, err);
goto out;
}
BUFFER_TRACE(group_desc_bh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, group_desc_bh);
if (err) {
ext4_std_error(sb, err);
goto out;
}
if (ext4_has_group_desc_csum(sb) &&
gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
struct buffer_head *block_bitmap_bh;
block_bitmap_bh = ext4_read_block_bitmap(sb, group);
if (IS_ERR(block_bitmap_bh)) {
err = PTR_ERR(block_bitmap_bh);
goto out;
}
BUFFER_TRACE(block_bitmap_bh, ""get block bitmap access"");
err = ext4_journal_get_write_access(handle, block_bitmap_bh);
if (err) {
brelse(block_bitmap_bh);
ext4_std_error(sb, err);
goto out;
}
BUFFER_TRACE(block_bitmap_bh, ""dirty block bitmap"");
err = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);
ext4_lock_group(sb, group);
if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
ext4_free_group_clusters_set(sb, gdp,
ext4_free_clusters_after_init(sb, group, gdp));
ext4_block_bitmap_csum_set(sb, group, gdp,
block_bitmap_bh);
ext4_group_desc_csum_set(sb, group, gdp);
}
ext4_unlock_group(sb, group);
brelse(block_bitmap_bh);
if (err) {
ext4_std_error(sb, err);
goto out;
}
}
if (ext4_has_group_desc_csum(sb)) {
int free;
struct ext4_group_info *grp = ext4_get_group_info(sb, group);
down_read(&grp->alloc_sem); 
ext4_lock_group(sb, group); 
free = EXT4_INODES_PER_GROUP(sb) -
ext4_itable_unused_count(sb, gdp);
if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {
gdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);
free = 0;
}
if (ino > free)
ext4_itable_unused_set(sb, gdp,
(EXT4_INODES_PER_GROUP(sb) - ino));
up_read(&grp->alloc_sem);
} else {
ext4_lock_group(sb, group);
}
ext4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);
if (S_ISDIR(mode)) {
ext4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);
if (sbi->s_log_groups_per_flex) {
ext4_group_t f = ext4_flex_group(sbi, group);
atomic_inc(&sbi->s_flex_groups[f].used_dirs);
}
}
if (ext4_has_group_desc_csum(sb)) {
ext4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,
EXT4_INODES_PER_GROUP(sb) / 8);
ext4_group_desc_csum_set(sb, group, gdp);
}
ext4_unlock_group(sb, group);
BUFFER_TRACE(group_desc_bh, ""call ext4_handle_dirty_metadata"");
err = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);
if (err) {
ext4_std_error(sb, err);
goto out;
}
percpu_counter_dec(&sbi->s_freeinodes_counter);
if (S_ISDIR(mode))
percpu_counter_inc(&sbi->s_dirs_counter);
if (sbi->s_log_groups_per_flex) {
flex_group = ext4_flex_group(sbi, group);
atomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);
}
inode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);
inode->i_blocks = 0;
inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
current_time(inode);
memset(ei->i_data, 0, sizeof(ei->i_data));
ei->i_dir_start_lookup = 0;
ei->i_disksize = 0;
ei->i_flags =
ext4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);
ei->i_flags |= i_flags;
ei->i_file_acl = 0;
ei->i_dtime = 0;
ei->i_block_group = group;
ei->i_last_alloc_group = ~0;
ext4_set_inode_flags(inode);
if (IS_DIRSYNC(inode))
ext4_handle_sync(handle);
if (insert_inode_locked(inode) < 0) {
err = -EIO;
ext4_error(sb, ""failed to insert inode %lu: doubly allocated?"",
inode->i_ino);
ext4_mark_group_bitmap_corrupted(sb, group,
EXT4_GROUP_INFO_IBITMAP_CORRUPT);
goto out;
}
inode->i_generation = prandom_u32();
if (ext4_has_metadata_csum(sb)) {
__u32 csum;
__le32 inum = cpu_to_le32(inode->i_ino);
__le32 gen = cpu_to_le32(inode->i_generation);
csum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,
sizeof(inum));
ei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,
sizeof(gen));
}
ext4_clear_state_flags(ei); 
ext4_set_inode_state(inode, EXT4_STATE_NEW);
ei->i_extra_isize = sbi->s_want_extra_isize;
ei->i_inline_off = 0;
if (ext4_has_feature_inline_data(sb))
ext4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);
ret = inode;
err = dquot_alloc_inode(inode);
if (err)
goto fail_drop;
if (encrypt) {
err = fscrypt_inherit_context(dir, inode, handle, true);
if (err)
goto fail_free_drop;
}
if (!(ei->i_flags & EXT4_EA_INODE_FL)) {
err = ext4_init_acl(handle, inode, dir);
if (err)
goto fail_free_drop;
err = ext4_init_security(handle, inode, dir, qstr);
if (err)
goto fail_free_drop;
}
if (ext4_has_feature_extents(sb)) {
if (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {
ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);
ext4_ext_tree_init(handle, inode);
}
}
if (ext4_handle_valid(handle)) {
ei->i_sync_tid = handle->h_transaction->t_tid;
ei->i_datasync_tid = handle->h_transaction->t_tid;
}
err = ext4_mark_inode_dirty(handle, inode);
if (err) {
ext4_std_error(sb, err);
goto fail_free_drop;
}
ext4_debug(""allocating inode %lu\n"", inode->i_ino);
trace_ext4_allocate_inode(inode, dir, mode);
brelse(inode_bitmap_bh);
return ret;
fail_free_drop:
dquot_free_inode(inode);
fail_drop:
clear_nlink(inode);
unlock_new_inode(inode);
out:
dquot_drop(inode);
inode->i_flags |= S_NOQUOTA;
iput(inode);
brelse(inode_bitmap_bh);
return ERR_PTR(err);
}","struct inode *__ext4_new_inode(handle_t *VAR_0, struct inode *VAR_1,
umode_t VAR_2, const struct qstr *qstr,
__u32 VAR_3, uid_t *VAR_4, __u32 VAR_5,
int VAR_6, unsigned int VAR_7,
int VAR_8)
{
struct super_block *VAR_9;
struct buffer_head *VAR_10 = NULL;
struct buffer_head *VAR_11;
ext4_group_t VAR_12, VAR_13 = 0;
unsigned long VAR_14 = 0;
struct inode *inode;
struct ext4_group_desc *VAR_15 = NULL;
struct ext4_inode_info *VAR_16;
struct ext4_sb_info *VAR_17;
int VAR_18, VAR_19;
struct inode *VAR_20;
ext4_group_t VAR_21;
ext4_group_t VAR_22;
struct ext4_group_info *VAR_23;
int VAR_24 = 0;
if (!VAR_1 || !VAR_1->i_nlink)
return ERR_PTR(-VAR_25);
VAR_9 = VAR_1->i_sb;
VAR_17 = EXT4_SB(VAR_9);
if (unlikely(ext4_forced_shutdown(VAR_17)))
return ERR_PTR(-VAR_26);
if ((ext4_encrypted_inode(VAR_1) || DUMMY_ENCRYPTION_ENABLED(VAR_17)) &&
(S_ISREG(VAR_2) || S_ISDIR(VAR_2) || S_ISLNK(VAR_2)) &&
!(VAR_5 & VAR_27)) {
VAR_19 = fscrypt_get_encryption_info(VAR_1);
if (VAR_19)
return ERR_PTR(VAR_19);
if (!fscrypt_has_encryption_key(VAR_1))
return ERR_PTR(-VAR_28);
VAR_24 = 1;
}
if (!VAR_0 && VAR_17->s_journal && !(VAR_5 & VAR_27)) {
#ifdef VAR_29
struct posix_acl *VAR_30 = get_acl(VAR_1, VAR_31);
if (IS_ERR(VAR_30))
return ERR_CAST(VAR_30);
if (VAR_30) {
int VAR_32 = VAR_30->a_count * sizeof(VAR_33);
VAR_8 += (S_ISDIR(VAR_2) ? 2 : 1) *
__ext4_xattr_set_credits(VAR_9, NULL ,
NULL , VAR_32,
true );
posix_acl_release(VAR_30);
}
#endif
#ifdef VAR_34
{
int VAR_35 = 1;
#ifdef VAR_36
VAR_35++;
#endif
VAR_8 += VAR_35 *
__ext4_xattr_set_credits(VAR_9, NULL ,
NULL , 1024,
true );
}
#endif
if (VAR_24)
VAR_8 += __ext4_xattr_set_credits(VAR_9,
NULL , NULL ,
VAR_37,
true );
}
VAR_12 = ext4_get_groups_count(VAR_9);
trace_ext4_request_inode(VAR_1, VAR_2);
inode = new_inode(VAR_9);
if (!inode)
return ERR_PTR(-VAR_38);
VAR_16 = EXT4_I(inode);
if (VAR_4) {
inode->i_mode = VAR_2;
i_uid_write(inode, VAR_4[0]);
i_gid_write(inode, VAR_4[1]);
} else if (test_opt(VAR_9, VAR_39)) {
inode->i_mode = VAR_2;
inode->i_uid = current_fsuid();
inode->i_gid = VAR_1->i_gid;
} else
inode_init_owner(inode, VAR_1, VAR_2);
if (ext4_has_feature_project(VAR_9) &&
ext4_test_inode_flag(VAR_1, VAR_40))
VAR_16->i_projid = EXT4_I(VAR_1)->i_projid;
else
VAR_16->i_projid = make_kprojid(&VAR_41, VAR_42);
VAR_19 = dquot_initialize(inode);
if (VAR_19)
goto out;
if (!VAR_3)
VAR_3 = VAR_17->s_inode_goal;
if (VAR_3 && VAR_3 <= le32_to_cpu(VAR_17->s_es->s_inodes_count)) {
VAR_13 = (VAR_3 - 1) / EXT4_INODES_PER_GROUP(VAR_9);
VAR_14 = (VAR_3 - 1) % EXT4_INODES_PER_GROUP(VAR_9);
VAR_18 = 0;
goto got_group;
}
if (S_ISDIR(VAR_2))
VAR_18 = find_group_orlov(VAR_9, VAR_1, &VAR_13, VAR_2, qstr);
else
VAR_18 = find_group_other(VAR_9, VAR_1, &VAR_13, VAR_2);
got_group:
EXT4_I(VAR_1)->i_last_alloc_group = VAR_13;
VAR_19 = -VAR_43;
if (VAR_18 == -1)
goto out;
for (VAR_21 = 0; VAR_21 < VAR_12; VAR_21++, VAR_14 = 0) {
VAR_19 = -VAR_26;
VAR_15 = ext4_get_group_desc(VAR_9, VAR_13, &VAR_11);
if (!VAR_15)
goto out;
if (ext4_free_inodes_count(VAR_9, VAR_15) == 0)
goto next_group;
VAR_23 = ext4_get_group_info(VAR_9, VAR_13);
if (EXT4_MB_GRP_IBITMAP_CORRUPT(VAR_23))
goto next_group;
brelse(VAR_10);
VAR_10 = ext4_read_inode_bitmap(VAR_9, VAR_13);
if (EXT4_MB_GRP_IBITMAP_CORRUPT(VAR_23) ||
IS_ERR(VAR_10)) {
VAR_10 = NULL;
goto next_group;
}
repeat_in_this_group:
VAR_18 = find_inode_bit(VAR_9, VAR_13, VAR_10, &VAR_14);
if (!VAR_18)
goto next_group;
if (VAR_13 == 0 && (VAR_14 + 1) < EXT4_FIRST_INO(VAR_9)) {
ext4_error(VAR_9, ""reserved inode found cleared - ""
""inode=%lu"", VAR_14 + 1);
ext4_mark_group_bitmap_corrupted(VAR_9, VAR_13,
VAR_44);
goto next_group;
}
if (!VAR_0) {
BUG_ON(VAR_8 <= 0);
VAR_0 = __ext4_journal_start_sb(VAR_1->i_sb, VAR_7,
VAR_6, VAR_8,
0);
if (IS_ERR(VAR_0)) {
VAR_19 = PTR_ERR(VAR_0);
ext4_std_error(VAR_9, VAR_19);
goto out;
}
}
BUFFER_TRACE(VAR_10, ""get_write_access"");
VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_10);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto out;
}
ext4_lock_group(VAR_9, VAR_13);
VAR_18 = ext4_test_and_set_bit(VAR_14, VAR_10->b_data);
if (VAR_18) {
VAR_18 = find_inode_bit(VAR_9, VAR_13, VAR_10, &VAR_14);
if (VAR_18) {
ext4_set_bit(VAR_14, VAR_10->b_data);
VAR_18 = 0;
} else {
VAR_18 = 1; 
}
}
ext4_unlock_group(VAR_9, VAR_13);
VAR_14++;
if (!VAR_18)
goto got; 
if (VAR_14 < EXT4_INODES_PER_GROUP(VAR_9))
goto repeat_in_this_group;
next_group:
if (++VAR_13 == VAR_12)
VAR_13 = 0;
}
VAR_19 = -VAR_43;
goto out;
got:
BUFFER_TRACE(VAR_10, ""call ext4_handle_dirty_metadata"");
VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_10);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto out;
}
BUFFER_TRACE(VAR_11, ""get_write_access"");
VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_11);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto out;
}
if (ext4_has_group_desc_csum(VAR_9) &&
VAR_15->bg_flags & cpu_to_le16(VAR_45)) {
struct buffer_head *VAR_46;
VAR_46 = ext4_read_block_bitmap(VAR_9, VAR_13);
if (IS_ERR(VAR_46)) {
VAR_19 = PTR_ERR(VAR_46);
goto out;
}
BUFFER_TRACE(VAR_46, ""get block bitmap access"");
VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_46);
if (VAR_19) {
brelse(VAR_46);
ext4_std_error(VAR_9, VAR_19);
goto out;
}
BUFFER_TRACE(VAR_46, ""dirty block bitmap"");
VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_46);
ext4_lock_group(VAR_9, VAR_13);
if (VAR_15->bg_flags & cpu_to_le16(VAR_45)) {
VAR_15->bg_flags &= cpu_to_le16(~VAR_45);
ext4_free_group_clusters_set(VAR_9, VAR_15,
ext4_free_clusters_after_init(VAR_9, VAR_13, VAR_15));
ext4_block_bitmap_csum_set(VAR_9, VAR_13, VAR_15,
VAR_46);
ext4_group_desc_csum_set(VAR_9, VAR_13, VAR_15);
}
ext4_unlock_group(VAR_9, VAR_13);
brelse(VAR_46);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto out;
}
}
if (ext4_has_group_desc_csum(VAR_9)) {
int VAR_47;
struct ext4_group_info *VAR_23 = ext4_get_group_info(VAR_9, VAR_13);
down_read(&VAR_23->alloc_sem); 
ext4_lock_group(VAR_9, VAR_13); 
VAR_47 = EXT4_INODES_PER_GROUP(VAR_9) -
ext4_itable_unused_count(VAR_9, VAR_15);
if (VAR_15->bg_flags & cpu_to_le16(VAR_48)) {
VAR_15->bg_flags &= cpu_to_le16(~VAR_48);
VAR_47 = 0;
}
if (VAR_14 > VAR_47)
ext4_itable_unused_set(VAR_9, VAR_15,
(EXT4_INODES_PER_GROUP(VAR_9) - VAR_14));
up_read(&VAR_23->alloc_sem);
} else {
ext4_lock_group(VAR_9, VAR_13);
}
ext4_free_inodes_set(VAR_9, VAR_15, ext4_free_inodes_count(VAR_9, VAR_15) - 1);
if (S_ISDIR(VAR_2)) {
ext4_used_dirs_set(VAR_9, VAR_15, ext4_used_dirs_count(VAR_9, VAR_15) + 1);
if (VAR_17->s_log_groups_per_flex) {
ext4_group_t VAR_49 = ext4_flex_group(VAR_17, VAR_13);
atomic_inc(&VAR_17->s_flex_groups[VAR_49].used_dirs);
}
}
if (ext4_has_group_desc_csum(VAR_9)) {
ext4_inode_bitmap_csum_set(VAR_9, VAR_13, VAR_15, VAR_10,
EXT4_INODES_PER_GROUP(VAR_9) / 8);
ext4_group_desc_csum_set(VAR_9, VAR_13, VAR_15);
}
ext4_unlock_group(VAR_9, VAR_13);
BUFFER_TRACE(VAR_11, ""call ext4_handle_dirty_metadata"");
VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_11);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto out;
}
percpu_counter_dec(&VAR_17->s_freeinodes_counter);
if (S_ISDIR(VAR_2))
percpu_counter_inc(&VAR_17->s_dirs_counter);
if (VAR_17->s_log_groups_per_flex) {
VAR_22 = ext4_flex_group(VAR_17, VAR_13);
atomic_dec(&VAR_17->s_flex_groups[VAR_22].free_inodes);
}
inode->i_ino = VAR_14 + VAR_13 * EXT4_INODES_PER_GROUP(VAR_9);
inode->i_blocks = 0;
inode->i_mtime = inode->i_atime = inode->i_ctime = VAR_16->i_crtime =
current_time(inode);
memset(VAR_16->i_data, 0, sizeof(VAR_16->i_data));
VAR_16->i_dir_start_lookup = 0;
VAR_16->i_disksize = 0;
VAR_16->i_flags =
ext4_mask_flags(VAR_2, EXT4_I(VAR_1)->i_flags & VAR_50);
VAR_16->i_flags |= VAR_5;
VAR_16->i_file_acl = 0;
VAR_16->i_dtime = 0;
VAR_16->i_block_group = VAR_13;
VAR_16->i_last_alloc_group = ~0;
ext4_set_inode_flags(inode);
if (IS_DIRSYNC(inode))
ext4_handle_sync(VAR_0);
if (insert_inode_locked(inode) < 0) {
VAR_19 = -VAR_26;
ext4_error(VAR_9, ""failed to insert inode %lu: doubly allocated?"",
inode->i_ino);
ext4_mark_group_bitmap_corrupted(VAR_9, VAR_13,
VAR_44);
goto out;
}
inode->i_generation = prandom_u32();
if (ext4_has_metadata_csum(VAR_9)) {
__u32 VAR_51;
__le32 VAR_52 = cpu_to_le32(inode->i_ino);
__le32 VAR_53 = cpu_to_le32(inode->i_generation);
VAR_51 = ext4_chksum(VAR_17, VAR_17->s_csum_seed, (__u8 *)&VAR_52,
sizeof(VAR_52));
VAR_16->i_csum_seed = ext4_chksum(VAR_17, VAR_51, (__u8 *)&VAR_53,
sizeof(VAR_53));
}
ext4_clear_state_flags(VAR_16); 
ext4_set_inode_state(inode, VAR_54);
VAR_16->i_extra_isize = VAR_17->s_want_extra_isize;
VAR_16->i_inline_off = 0;
if (ext4_has_feature_inline_data(VAR_9))
ext4_set_inode_state(inode, VAR_55);
VAR_20 = inode;
VAR_19 = dquot_alloc_inode(inode);
if (VAR_19)
goto fail_drop;
if (VAR_24) {
VAR_19 = fscrypt_inherit_context(VAR_1, inode, VAR_0, true);
if (VAR_19)
goto fail_free_drop;
}
if (!(VAR_16->i_flags & VAR_27)) {
VAR_19 = ext4_init_acl(VAR_0, inode, VAR_1);
if (VAR_19)
goto fail_free_drop;
VAR_19 = ext4_init_security(VAR_0, inode, VAR_1, qstr);
if (VAR_19)
goto fail_free_drop;
}
if (ext4_has_feature_extents(VAR_9)) {
if (S_ISDIR(VAR_2) || S_ISREG(VAR_2) || S_ISLNK(VAR_2)) {
ext4_set_inode_flag(inode, VAR_56);
ext4_ext_tree_init(VAR_0, inode);
}
}
if (ext4_handle_valid(VAR_0)) {
VAR_16->i_sync_tid = VAR_0->h_transaction->t_tid;
VAR_16->i_datasync_tid = VAR_0->h_transaction->t_tid;
}
VAR_19 = ext4_mark_inode_dirty(VAR_0, inode);
if (VAR_19) {
ext4_std_error(VAR_9, VAR_19);
goto fail_free_drop;
}
ext4_debug(""allocating inode %lu\n"", inode->i_ino);
trace_ext4_allocate_inode(inode, VAR_1, VAR_2);
brelse(VAR_10);
return VAR_20;
fail_free_drop:
dquot_free_inode(inode);
fail_drop:
clear_nlink(inode);
unlock_new_inode(inode);
out:
dquot_drop(inode);
inode->i_flags |= VAR_57;
iput(inode);
brelse(VAR_10);
return ERR_PTR(VAR_19);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/ialloc.c/vul/before/1.json,"struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,
			       umode_t mode, const struct qstr *qstr,
			       __u32 goal, uid_t *owner, __u32 i_flags,
			       int handle_type, unsigned int line_no,
			       int nblocks)
{
	struct super_block *sb;
	struct buffer_head *inode_bitmap_bh = NULL;
	struct buffer_head *group_desc_bh;
	ext4_group_t ngroups, group = 0;
	unsigned long ino = 0;
	struct inode *inode;
	struct ext4_group_desc *gdp = NULL;
	struct ext4_inode_info *ei;
	struct ext4_sb_info *sbi;
	int ret2, err;
	struct inode *ret;
	ext4_group_t i;
	ext4_group_t flex_group;
	struct ext4_group_info *grp;
	int encrypt = 0;

	/* Cannot create files in a deleted directory */
	if (!dir || !dir->i_nlink)
		return ERR_PTR(-EPERM);

	sb = dir->i_sb;
	sbi = EXT4_SB(sb);

	if (unlikely(ext4_forced_shutdown(sbi)))
		return ERR_PTR(-EIO);

	if ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&
	    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&
	    !(i_flags & EXT4_EA_INODE_FL)) {
		err = fscrypt_get_encryption_info(dir);
		if (err)
			return ERR_PTR(err);
		if (!fscrypt_has_encryption_key(dir))
			return ERR_PTR(-ENOKEY);
		encrypt = 1;
	}

	if (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {
#ifdef CONFIG_EXT4_FS_POSIX_ACL
		struct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);

		if (IS_ERR(p))
			return ERR_CAST(p);
		if (p) {
			int acl_size = p->a_count * sizeof(ext4_acl_entry);

			nblocks += (S_ISDIR(mode) ? 2 : 1) *
				__ext4_xattr_set_credits(sb, NULL /* inode */,
					NULL /* block_bh */, acl_size,
					true /* is_create */);
			posix_acl_release(p);
		}
#endif

#ifdef CONFIG_SECURITY
		{
			int num_security_xattrs = 1;

#ifdef CONFIG_INTEGRITY
			num_security_xattrs++;
#endif
			/*
			 * We assume that security xattrs are never
			 * more than 1k.  In practice they are under
			 * 128 bytes.
			 */
			nblocks += num_security_xattrs *
				__ext4_xattr_set_credits(sb, NULL /* inode */,
					NULL /* block_bh */, 1024,
					true /* is_create */);
		}
#endif
		if (encrypt)
			nblocks += __ext4_xattr_set_credits(sb,
					NULL /* inode */, NULL /* block_bh */,
					FSCRYPT_SET_CONTEXT_MAX_SIZE,
					true /* is_create */);
	}

	ngroups = ext4_get_groups_count(sb);
	trace_ext4_request_inode(dir, mode);
	inode = new_inode(sb);
	if (!inode)
		return ERR_PTR(-ENOMEM);
	ei = EXT4_I(inode);

	/*
	 * Initialize owners and quota early so that we don't have to account
	 * for quota initialization worst case in standard inode creating
	 * transaction
	 */
	if (owner) {
		inode->i_mode = mode;
		i_uid_write(inode, owner[0]);
		i_gid_write(inode, owner[1]);
	} else if (test_opt(sb, GRPID)) {
		inode->i_mode = mode;
		inode->i_uid = current_fsuid();
		inode->i_gid = dir->i_gid;
	} else
		inode_init_owner(inode, dir, mode);

	if (ext4_has_feature_project(sb) &&
	    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))
		ei->i_projid = EXT4_I(dir)->i_projid;
	else
		ei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);

	err = dquot_initialize(inode);
	if (err)
		goto out;

	if (!goal)
		goal = sbi->s_inode_goal;

	if (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {
		group = (goal - 1) / EXT4_INODES_PER_GROUP(sb);
		ino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);
		ret2 = 0;
		goto got_group;
	}

	if (S_ISDIR(mode))
		ret2 = find_group_orlov(sb, dir, &group, mode, qstr);
	else
		ret2 = find_group_other(sb, dir, &group, mode);

got_group:
	EXT4_I(dir)->i_last_alloc_group = group;
	err = -ENOSPC;
	if (ret2 == -1)
		goto out;

	/*
	 * Normally we will only go through one pass of this loop,
	 * unless we get unlucky and it turns out the group we selected
	 * had its last inode grabbed by someone else.
	 */
	for (i = 0; i < ngroups; i++, ino = 0) {
		err = -EIO;

		gdp = ext4_get_group_desc(sb, group, &group_desc_bh);
		if (!gdp)
			goto out;

		/*
		 * Check free inodes count before loading bitmap.
		 */
		if (ext4_free_inodes_count(sb, gdp) == 0)
			goto next_group;

		grp = ext4_get_group_info(sb, group);
		/* Skip groups with already-known suspicious inode tables */
		if (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))
			goto next_group;

		brelse(inode_bitmap_bh);
		inode_bitmap_bh = ext4_read_inode_bitmap(sb, group);
		/* Skip groups with suspicious inode tables */
		if (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||
		    IS_ERR(inode_bitmap_bh)) {
			inode_bitmap_bh = NULL;
			goto next_group;
		}

repeat_in_this_group:
		ret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);
		if (!ret2)
			goto next_group;

		if (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {
			ext4_error(sb, ""reserved inode found cleared - ""
				   ""inode=%lu"", ino + 1);
			ext4_mark_group_bitmap_corrupted(sb, group,
					EXT4_GROUP_INFO_IBITMAP_CORRUPT);
			goto next_group;
		}

		if (!handle) {
			BUG_ON(nblocks <= 0);
			handle = __ext4_journal_start_sb(dir->i_sb, line_no,
							 handle_type, nblocks,
							 0);
			if (IS_ERR(handle)) {
				err = PTR_ERR(handle);
				ext4_std_error(sb, err);
				goto out;
			}
		}
		BUFFER_TRACE(inode_bitmap_bh, ""get_write_access"");
		err = ext4_journal_get_write_access(handle, inode_bitmap_bh);
		if (err) {
			ext4_std_error(sb, err);
			goto out;
		}
		ext4_lock_group(sb, group);
		ret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);
		if (ret2) {
			/* Someone already took the bit. Repeat the search
			 * with lock held.
			 */
			ret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);
			if (ret2) {
				ext4_set_bit(ino, inode_bitmap_bh->b_data);
				ret2 = 0;
			} else {
				ret2 = 1; /* we didn't grab the inode */
			}
		}
		ext4_unlock_group(sb, group);
		ino++;		/* the inode bitmap is zero-based */
		if (!ret2)
			goto got; /* we grabbed the inode! */

		if (ino < EXT4_INODES_PER_GROUP(sb))
			goto repeat_in_this_group;
next_group:
		if (++group == ngroups)
			group = 0;
	}
	err = -ENOSPC;
	goto out;

got:
	BUFFER_TRACE(inode_bitmap_bh, ""call ext4_handle_dirty_metadata"");
	err = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);
	if (err) {
		ext4_std_error(sb, err);
		goto out;
	}

	BUFFER_TRACE(group_desc_bh, ""get_write_access"");
	err = ext4_journal_get_write_access(handle, group_desc_bh);
	if (err) {
		ext4_std_error(sb, err);
		goto out;
	}

	/* We may have to initialize the block bitmap if it isn't already */
	if (ext4_has_group_desc_csum(sb) &&
	    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
		struct buffer_head *block_bitmap_bh;

		block_bitmap_bh = ext4_read_block_bitmap(sb, group);
		if (IS_ERR(block_bitmap_bh)) {
			err = PTR_ERR(block_bitmap_bh);
			goto out;
		}
		BUFFER_TRACE(block_bitmap_bh, ""get block bitmap access"");
		err = ext4_journal_get_write_access(handle, block_bitmap_bh);
		if (err) {
			brelse(block_bitmap_bh);
			ext4_std_error(sb, err);
			goto out;
		}

		BUFFER_TRACE(block_bitmap_bh, ""dirty block bitmap"");
		err = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);

		/* recheck and clear flag under lock if we still need to */
		ext4_lock_group(sb, group);
		if (ext4_has_group_desc_csum(sb) &&
		    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
			gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
			ext4_free_group_clusters_set(sb, gdp,
				ext4_free_clusters_after_init(sb, group, gdp));
			ext4_block_bitmap_csum_set(sb, group, gdp,
						   block_bitmap_bh);
			ext4_group_desc_csum_set(sb, group, gdp);
		}
		ext4_unlock_group(sb, group);
		brelse(block_bitmap_bh);

		if (err) {
			ext4_std_error(sb, err);
			goto out;
		}
	}

	/* Update the relevant bg descriptor fields */
	if (ext4_has_group_desc_csum(sb)) {
		int free;
		struct ext4_group_info *grp = ext4_get_group_info(sb, group);

		down_read(&grp->alloc_sem); /* protect vs itable lazyinit */
		ext4_lock_group(sb, group); /* while we modify the bg desc */
		free = EXT4_INODES_PER_GROUP(sb) -
			ext4_itable_unused_count(sb, gdp);
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {
			gdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);
			free = 0;
		}
		/*
		 * Check the relative inode number against the last used
		 * relative inode number in this group. if it is greater
		 * we need to update the bg_itable_unused count
		 */
		if (ino > free)
			ext4_itable_unused_set(sb, gdp,
					(EXT4_INODES_PER_GROUP(sb) - ino));
		up_read(&grp->alloc_sem);
	} else {
		ext4_lock_group(sb, group);
	}

	ext4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);
	if (S_ISDIR(mode)) {
		ext4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);
		if (sbi->s_log_groups_per_flex) {
			ext4_group_t f = ext4_flex_group(sbi, group);

			atomic_inc(&sbi->s_flex_groups[f].used_dirs);
		}
	}
	if (ext4_has_group_desc_csum(sb)) {
		ext4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,
					   EXT4_INODES_PER_GROUP(sb) / 8);
		ext4_group_desc_csum_set(sb, group, gdp);
	}
	ext4_unlock_group(sb, group);

	BUFFER_TRACE(group_desc_bh, ""call ext4_handle_dirty_metadata"");
	err = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);
	if (err) {
		ext4_std_error(sb, err);
		goto out;
	}

	percpu_counter_dec(&sbi->s_freeinodes_counter);
	if (S_ISDIR(mode))
		percpu_counter_inc(&sbi->s_dirs_counter);

	if (sbi->s_log_groups_per_flex) {
		flex_group = ext4_flex_group(sbi, group);
		atomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);
	}

	inode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);
	/* This is the optimal IO size (for stat), not the fs block size */
	inode->i_blocks = 0;
	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
						       current_time(inode);

	memset(ei->i_data, 0, sizeof(ei->i_data));
	ei->i_dir_start_lookup = 0;
	ei->i_disksize = 0;

	/* Don't inherit extent flag from directory, amongst others. */
	ei->i_flags =
		ext4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);
	ei->i_flags |= i_flags;
	ei->i_file_acl = 0;
	ei->i_dtime = 0;
	ei->i_block_group = group;
	ei->i_last_alloc_group = ~0;

	ext4_set_inode_flags(inode);
	if (IS_DIRSYNC(inode))
		ext4_handle_sync(handle);
	if (insert_inode_locked(inode) < 0) {
		/*
		 * Likely a bitmap corruption causing inode to be allocated
		 * twice.
		 */
		err = -EIO;
		ext4_error(sb, ""failed to insert inode %lu: doubly allocated?"",
			   inode->i_ino);
		ext4_mark_group_bitmap_corrupted(sb, group,
					EXT4_GROUP_INFO_IBITMAP_CORRUPT);
		goto out;
	}
	inode->i_generation = prandom_u32();

	/* Precompute checksum seed for inode metadata */
	if (ext4_has_metadata_csum(sb)) {
		__u32 csum;
		__le32 inum = cpu_to_le32(inode->i_ino);
		__le32 gen = cpu_to_le32(inode->i_generation);
		csum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,
				   sizeof(inum));
		ei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,
					      sizeof(gen));
	}

	ext4_clear_state_flags(ei); /* Only relevant on 32-bit archs */
	ext4_set_inode_state(inode, EXT4_STATE_NEW);

	ei->i_extra_isize = sbi->s_want_extra_isize;
	ei->i_inline_off = 0;
	if (ext4_has_feature_inline_data(sb))
		ext4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);
	ret = inode;
	err = dquot_alloc_inode(inode);
	if (err)
		goto fail_drop;

	/*
	 * Since the encryption xattr will always be unique, create it first so
	 * that it's less likely to end up in an external xattr block and
	 * prevent its deduplication.
	 */
	if (encrypt) {
		err = fscrypt_inherit_context(dir, inode, handle, true);
		if (err)
			goto fail_free_drop;
	}

	if (!(ei->i_flags & EXT4_EA_INODE_FL)) {
		err = ext4_init_acl(handle, inode, dir);
		if (err)
			goto fail_free_drop;

		err = ext4_init_security(handle, inode, dir, qstr);
		if (err)
			goto fail_free_drop;
	}

	if (ext4_has_feature_extents(sb)) {
		/* set extent flag only for directory, file and normal symlink*/
		if (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {
			ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);
			ext4_ext_tree_init(handle, inode);
		}
	}

	if (ext4_handle_valid(handle)) {
		ei->i_sync_tid = handle->h_transaction->t_tid;
		ei->i_datasync_tid = handle->h_transaction->t_tid;
	}

	err = ext4_mark_inode_dirty(handle, inode);
	if (err) {
		ext4_std_error(sb, err);
		goto fail_free_drop;
	}

	ext4_debug(""allocating inode %lu\n"", inode->i_ino);
	trace_ext4_allocate_inode(inode, dir, mode);
	brelse(inode_bitmap_bh);
	return ret;

fail_free_drop:
	dquot_free_inode(inode);
fail_drop:
	clear_nlink(inode);
	unlock_new_inode(inode);
out:
	dquot_drop(inode);
	inode->i_flags |= S_NOQUOTA;
	iput(inode);
	brelse(inode_bitmap_bh);
	return ERR_PTR(err);
}","struct inode *__ext4_new_inode(handle_t *VAR_0, struct inode *VAR_1,
			       umode_t VAR_2, const struct qstr *qstr,
			       __u32 VAR_3, uid_t *VAR_4, __u32 VAR_5,
			       int VAR_6, unsigned int VAR_7,
			       int VAR_8)
{
	struct super_block *VAR_9;
	struct buffer_head *VAR_10 = NULL;
	struct buffer_head *VAR_11;
	ext4_group_t VAR_12, VAR_13 = 0;
	unsigned long VAR_14 = 0;
	struct inode *inode;
	struct ext4_group_desc *VAR_15 = NULL;
	struct ext4_inode_info *VAR_16;
	struct ext4_sb_info *VAR_17;
	int VAR_18, VAR_19;
	struct inode *VAR_20;
	ext4_group_t VAR_21;
	ext4_group_t VAR_22;
	struct ext4_group_info *VAR_23;
	int VAR_24 = 0;

	/* COMMENT_0 */
	if (!VAR_1 || !VAR_1->i_nlink)
		return ERR_PTR(-VAR_25);

	VAR_9 = VAR_1->i_sb;
	VAR_17 = EXT4_SB(VAR_9);

	if (unlikely(ext4_forced_shutdown(VAR_17)))
		return ERR_PTR(-VAR_26);

	if ((ext4_encrypted_inode(VAR_1) || DUMMY_ENCRYPTION_ENABLED(VAR_17)) &&
	    (S_ISREG(VAR_2) || S_ISDIR(VAR_2) || S_ISLNK(VAR_2)) &&
	    !(VAR_5 & VAR_27)) {
		VAR_19 = fscrypt_get_encryption_info(VAR_1);
		if (VAR_19)
			return ERR_PTR(VAR_19);
		if (!fscrypt_has_encryption_key(VAR_1))
			return ERR_PTR(-VAR_28);
		VAR_24 = 1;
	}

	if (!VAR_0 && VAR_17->s_journal && !(VAR_5 & VAR_27)) {
#ifdef VAR_29
		struct posix_acl *VAR_30 = get_acl(VAR_1, VAR_31);

		if (IS_ERR(VAR_30))
			return ERR_CAST(VAR_30);
		if (VAR_30) {
			int VAR_32 = VAR_30->a_count * sizeof(VAR_33);

			VAR_8 += (S_ISDIR(VAR_2) ? 2 : 1) *
				__ext4_xattr_set_credits(VAR_9, NULL /* COMMENT_1 */,
					NULL /* COMMENT_2 */, VAR_32,
					true /* COMMENT_3 */);
			posix_acl_release(VAR_30);
		}
#endif

#ifdef VAR_34
		{
			int VAR_35 = 1;

#ifdef VAR_36
			VAR_35++;
#endif
			/* COMMENT_4 */
                                              
                                               
                
      
			VAR_8 += VAR_35 *
				__ext4_xattr_set_credits(VAR_9, NULL /* COMMENT_1 */,
					NULL /* COMMENT_2 */, 1024,
					true /* COMMENT_3 */);
		}
#endif
		if (VAR_24)
			VAR_8 += __ext4_xattr_set_credits(VAR_9,
					NULL /* COMMENT_1 */, NULL /* COMMENT_2 */,
					VAR_37,
					true /* COMMENT_3 */);
	}

	VAR_12 = ext4_get_groups_count(VAR_9);
	trace_ext4_request_inode(VAR_1, VAR_2);
	inode = new_inode(VAR_9);
	if (!inode)
		return ERR_PTR(-VAR_38);
	VAR_16 = EXT4_I(inode);

	/* COMMENT_9 */
                                                                      
                                                                  
               
    
	if (VAR_4) {
		inode->i_mode = VAR_2;
		i_uid_write(inode, VAR_4[0]);
		i_gid_write(inode, VAR_4[1]);
	} else if (test_opt(VAR_9, VAR_39)) {
		inode->i_mode = VAR_2;
		inode->i_uid = current_fsuid();
		inode->i_gid = VAR_1->i_gid;
	} else
		inode_init_owner(inode, VAR_1, VAR_2);

	if (ext4_has_feature_project(VAR_9) &&
	    ext4_test_inode_flag(VAR_1, VAR_40))
		VAR_16->i_projid = EXT4_I(VAR_1)->i_projid;
	else
		VAR_16->i_projid = make_kprojid(&VAR_41, VAR_42);

	VAR_19 = dquot_initialize(inode);
	if (VAR_19)
		goto out;

	if (!VAR_3)
		VAR_3 = VAR_17->s_inode_goal;

	if (VAR_3 && VAR_3 <= le32_to_cpu(VAR_17->s_es->s_inodes_count)) {
		VAR_13 = (VAR_3 - 1) / EXT4_INODES_PER_GROUP(VAR_9);
		VAR_14 = (VAR_3 - 1) % EXT4_INODES_PER_GROUP(VAR_9);
		VAR_18 = 0;
		goto got_group;
	}

	if (S_ISDIR(VAR_2))
		VAR_18 = find_group_orlov(VAR_9, VAR_1, &VAR_13, VAR_2, qstr);
	else
		VAR_18 = find_group_other(VAR_9, VAR_1, &VAR_13, VAR_2);

got_group:
	EXT4_I(VAR_1)->i_last_alloc_group = VAR_13;
	VAR_19 = -VAR_43;
	if (VAR_18 == -1)
		goto out;

	/* COMMENT_14 */
                                                           
                                                                
                                               
    
	for (VAR_21 = 0; VAR_21 < VAR_12; VAR_21++, VAR_14 = 0) {
		VAR_19 = -VAR_26;

		VAR_15 = ext4_get_group_desc(VAR_9, VAR_13, &VAR_11);
		if (!VAR_15)
			goto out;

		/* COMMENT_19 */
                                                   
     
		if (ext4_free_inodes_count(VAR_9, VAR_15) == 0)
			goto next_group;

		VAR_23 = ext4_get_group_info(VAR_9, VAR_13);
		/* COMMENT_22 */
		if (EXT4_MB_GRP_IBITMAP_CORRUPT(VAR_23))
			goto next_group;

		brelse(VAR_10);
		VAR_10 = ext4_read_inode_bitmap(VAR_9, VAR_13);
		/* COMMENT_23 */
		if (EXT4_MB_GRP_IBITMAP_CORRUPT(VAR_23) ||
		    IS_ERR(VAR_10)) {
			VAR_10 = NULL;
			goto next_group;
		}

repeat_in_this_group:
		VAR_18 = find_inode_bit(VAR_9, VAR_13, VAR_10, &VAR_14);
		if (!VAR_18)
			goto next_group;

		if (VAR_13 == 0 && (VAR_14 + 1) < EXT4_FIRST_INO(VAR_9)) {
			ext4_error(VAR_9, ""reserved inode found cleared - ""
				   ""inode=%lu"", VAR_14 + 1);
			ext4_mark_group_bitmap_corrupted(VAR_9, VAR_13,
					VAR_44);
			goto next_group;
		}

		if (!VAR_0) {
			BUG_ON(VAR_8 <= 0);
			VAR_0 = __ext4_journal_start_sb(VAR_1->i_sb, VAR_7,
							 VAR_6, VAR_8,
							 0);
			if (IS_ERR(VAR_0)) {
				VAR_19 = PTR_ERR(VAR_0);
				ext4_std_error(VAR_9, VAR_19);
				goto out;
			}
		}
		BUFFER_TRACE(VAR_10, ""get_write_access"");
		VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_10);
		if (VAR_19) {
			ext4_std_error(VAR_9, VAR_19);
			goto out;
		}
		ext4_lock_group(VAR_9, VAR_13);
		VAR_18 = ext4_test_and_set_bit(VAR_14, VAR_10->b_data);
		if (VAR_18) {
			/* COMMENT_24 */
                     
      
			VAR_18 = find_inode_bit(VAR_9, VAR_13, VAR_10, &VAR_14);
			if (VAR_18) {
				ext4_set_bit(VAR_14, VAR_10->b_data);
				VAR_18 = 0;
			} else {
				VAR_18 = 1; /* COMMENT_27 */
			}
		}
		ext4_unlock_group(VAR_9, VAR_13);
		VAR_14++;		/* COMMENT_28 */
		if (!VAR_18)
			goto got; /* COMMENT_29 */

		if (VAR_14 < EXT4_INODES_PER_GROUP(VAR_9))
			goto repeat_in_this_group;
next_group:
		if (++VAR_13 == VAR_12)
			VAR_13 = 0;
	}
	VAR_19 = -VAR_43;
	goto out;

got:
	BUFFER_TRACE(VAR_10, ""call ext4_handle_dirty_metadata"");
	VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_10);
	if (VAR_19) {
		ext4_std_error(VAR_9, VAR_19);
		goto out;
	}

	BUFFER_TRACE(VAR_11, ""get_write_access"");
	VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_11);
	if (VAR_19) {
		ext4_std_error(VAR_9, VAR_19);
		goto out;
	}

	/* COMMENT_30 */
	if (ext4_has_group_desc_csum(VAR_9) &&
	    VAR_15->bg_flags & cpu_to_le16(VAR_45)) {
		struct buffer_head *VAR_46;

		VAR_46 = ext4_read_block_bitmap(VAR_9, VAR_13);
		if (IS_ERR(VAR_46)) {
			VAR_19 = PTR_ERR(VAR_46);
			goto out;
		}
		BUFFER_TRACE(VAR_46, ""get block bitmap access"");
		VAR_19 = ext4_journal_get_write_access(VAR_0, VAR_46);
		if (VAR_19) {
			brelse(VAR_46);
			ext4_std_error(VAR_9, VAR_19);
			goto out;
		}

		BUFFER_TRACE(VAR_46, ""dirty block bitmap"");
		VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_46);

		/* COMMENT_31 */
		ext4_lock_group(VAR_9, VAR_13);
		if (ext4_has_group_desc_csum(VAR_9) &&
		    (VAR_15->bg_flags & cpu_to_le16(VAR_45))) {
			VAR_15->bg_flags &= cpu_to_le16(~VAR_45);
			ext4_free_group_clusters_set(VAR_9, VAR_15,
				ext4_free_clusters_after_init(VAR_9, VAR_13, VAR_15));
			ext4_block_bitmap_csum_set(VAR_9, VAR_13, VAR_15,
						   VAR_46);
			ext4_group_desc_csum_set(VAR_9, VAR_13, VAR_15);
		}
		ext4_unlock_group(VAR_9, VAR_13);
		brelse(VAR_46);

		if (VAR_19) {
			ext4_std_error(VAR_9, VAR_19);
			goto out;
		}
	}

	/* COMMENT_32 */
	if (ext4_has_group_desc_csum(VAR_9)) {
		int VAR_47;
		struct ext4_group_info *VAR_23 = ext4_get_group_info(VAR_9, VAR_13);

		down_read(&VAR_23->alloc_sem); /* COMMENT_33 */
		ext4_lock_group(VAR_9, VAR_13); /* COMMENT_34 */
		VAR_47 = EXT4_INODES_PER_GROUP(VAR_9) -
			ext4_itable_unused_count(VAR_9, VAR_15);
		if (VAR_15->bg_flags & cpu_to_le16(VAR_48)) {
			VAR_15->bg_flags &= cpu_to_le16(~VAR_48);
			VAR_47 = 0;
		}
		/* COMMENT_35 */
                                                          
                                                          
                                                 
     
		if (VAR_14 > VAR_47)
			ext4_itable_unused_set(VAR_9, VAR_15,
					(EXT4_INODES_PER_GROUP(VAR_9) - VAR_14));
		up_read(&VAR_23->alloc_sem);
	} else {
		ext4_lock_group(VAR_9, VAR_13);
	}

	ext4_free_inodes_set(VAR_9, VAR_15, ext4_free_inodes_count(VAR_9, VAR_15) - 1);
	if (S_ISDIR(VAR_2)) {
		ext4_used_dirs_set(VAR_9, VAR_15, ext4_used_dirs_count(VAR_9, VAR_15) + 1);
		if (VAR_17->s_log_groups_per_flex) {
			ext4_group_t VAR_49 = ext4_flex_group(VAR_17, VAR_13);

			atomic_inc(&VAR_17->s_flex_groups[VAR_49].used_dirs);
		}
	}
	if (ext4_has_group_desc_csum(VAR_9)) {
		ext4_inode_bitmap_csum_set(VAR_9, VAR_13, VAR_15, VAR_10,
					   EXT4_INODES_PER_GROUP(VAR_9) / 8);
		ext4_group_desc_csum_set(VAR_9, VAR_13, VAR_15);
	}
	ext4_unlock_group(VAR_9, VAR_13);

	BUFFER_TRACE(VAR_11, ""call ext4_handle_dirty_metadata"");
	VAR_19 = ext4_handle_dirty_metadata(VAR_0, NULL, VAR_11);
	if (VAR_19) {
		ext4_std_error(VAR_9, VAR_19);
		goto out;
	}

	percpu_counter_dec(&VAR_17->s_freeinodes_counter);
	if (S_ISDIR(VAR_2))
		percpu_counter_inc(&VAR_17->s_dirs_counter);

	if (VAR_17->s_log_groups_per_flex) {
		VAR_22 = ext4_flex_group(VAR_17, VAR_13);
		atomic_dec(&VAR_17->s_flex_groups[VAR_22].free_inodes);
	}

	inode->i_ino = VAR_14 + VAR_13 * EXT4_INODES_PER_GROUP(VAR_9);
	/* COMMENT_40 */
	inode->i_blocks = 0;
	inode->i_mtime = inode->i_atime = inode->i_ctime = VAR_16->i_crtime =
						       current_time(inode);

	memset(VAR_16->i_data, 0, sizeof(VAR_16->i_data));
	VAR_16->i_dir_start_lookup = 0;
	VAR_16->i_disksize = 0;

	/* COMMENT_41 */
	VAR_16->i_flags =
		ext4_mask_flags(VAR_2, EXT4_I(VAR_1)->i_flags & VAR_50);
	VAR_16->i_flags |= VAR_5;
	VAR_16->i_file_acl = 0;
	VAR_16->i_dtime = 0;
	VAR_16->i_block_group = VAR_13;
	VAR_16->i_last_alloc_group = ~0;

	ext4_set_inode_flags(inode);
	if (IS_DIRSYNC(inode))
		ext4_handle_sync(VAR_0);
	if (insert_inode_locked(inode) < 0) {
		/* COMMENT_42 */
                                                             
           
     
		VAR_19 = -VAR_26;
		ext4_error(VAR_9, ""failed to insert inode %lu: doubly allocated?"",
			   inode->i_ino);
		ext4_mark_group_bitmap_corrupted(VAR_9, VAR_13,
					VAR_44);
		goto out;
	}
	inode->i_generation = prandom_u32();

	/* COMMENT_46 */
	if (ext4_has_metadata_csum(VAR_9)) {
		__u32 VAR_51;
		__le32 VAR_52 = cpu_to_le32(inode->i_ino);
		__le32 VAR_53 = cpu_to_le32(inode->i_generation);
		VAR_51 = ext4_chksum(VAR_17, VAR_17->s_csum_seed, (__u8 *)&VAR_52,
				   sizeof(VAR_52));
		VAR_16->i_csum_seed = ext4_chksum(VAR_17, VAR_51, (__u8 *)&VAR_53,
					      sizeof(VAR_53));
	}

	ext4_clear_state_flags(VAR_16); /* COMMENT_47 */
	ext4_set_inode_state(inode, VAR_54);

	VAR_16->i_extra_isize = VAR_17->s_want_extra_isize;
	VAR_16->i_inline_off = 0;
	if (ext4_has_feature_inline_data(VAR_9))
		ext4_set_inode_state(inode, VAR_55);
	VAR_20 = inode;
	VAR_19 = dquot_alloc_inode(inode);
	if (VAR_19)
		goto fail_drop;

	/* COMMENT_48 */
                                                                        
                                                                  
                              
    
	if (VAR_24) {
		VAR_19 = fscrypt_inherit_context(VAR_1, inode, VAR_0, true);
		if (VAR_19)
			goto fail_free_drop;
	}

	if (!(VAR_16->i_flags & VAR_27)) {
		VAR_19 = ext4_init_acl(VAR_0, inode, VAR_1);
		if (VAR_19)
			goto fail_free_drop;

		VAR_19 = ext4_init_security(VAR_0, inode, VAR_1, qstr);
		if (VAR_19)
			goto fail_free_drop;
	}

	if (ext4_has_feature_extents(VAR_9)) {
		/* COMMENT_53 */
		if (S_ISDIR(VAR_2) || S_ISREG(VAR_2) || S_ISLNK(VAR_2)) {
			ext4_set_inode_flag(inode, VAR_56);
			ext4_ext_tree_init(VAR_0, inode);
		}
	}

	if (ext4_handle_valid(VAR_0)) {
		VAR_16->i_sync_tid = VAR_0->h_transaction->t_tid;
		VAR_16->i_datasync_tid = VAR_0->h_transaction->t_tid;
	}

	VAR_19 = ext4_mark_inode_dirty(VAR_0, inode);
	if (VAR_19) {
		ext4_std_error(VAR_9, VAR_19);
		goto fail_free_drop;
	}

	ext4_debug(""allocating inode %lu\n"", inode->i_ino);
	trace_ext4_allocate_inode(inode, VAR_1, VAR_2);
	brelse(VAR_10);
	return VAR_20;

fail_free_drop:
	dquot_free_inode(inode);
fail_drop:
	clear_nlink(inode);
	unlock_new_inode(inode);
out:
	dquot_drop(inode);
	inode->i_flags |= VAR_57;
	iput(inode);
	brelse(VAR_10);
	return ERR_PTR(VAR_19);
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/ialloc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -265,7 +265,8 @@
 
 		/* recheck and clear flag under lock if we still need to */
 		ext4_lock_group(sb, group);
-		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+		if (ext4_has_group_desc_csum(sb) &&
+		    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
 			gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
 			ext4_free_group_clusters_set(sb, gdp,
 				ext4_free_clusters_after_init(sb, group, gdp));","{'deleted_lines': ['\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {'], 'added_lines': ['\t\tif (ext4_has_group_desc_csum(sb) &&', '\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/mballoc.c,ext4_mb_mark_diskspace_used,"static noinline_for_stack int
ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
handle_t *handle, unsigned int reserv_clstrs)
{
struct buffer_head *bitmap_bh = NULL;
struct ext4_group_desc *gdp;
struct buffer_head *gdp_bh;
struct ext4_sb_info *sbi;
struct super_block *sb;
ext4_fsblk_t block;
int err, len;
BUG_ON(ac->ac_status != AC_STATUS_FOUND);
BUG_ON(ac->ac_b_ex.fe_len <= 0);
sb = ac->ac_sb;
sbi = EXT4_SB(sb);
bitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);
if (IS_ERR(bitmap_bh)) {
err = PTR_ERR(bitmap_bh);
bitmap_bh = NULL;
goto out_err;
}
BUFFER_TRACE(bitmap_bh, ""getting write access"");
err = ext4_journal_get_write_access(handle, bitmap_bh);
if (err)
goto out_err;
err = -EIO;
gdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);
if (!gdp)
goto out_err;
ext4_debug(""using block group %u(%d)\n"", ac->ac_b_ex.fe_group,
ext4_free_group_clusters(sb, gdp));
BUFFER_TRACE(gdp_bh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, gdp_bh);
if (err)
goto out_err;
block = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);
len = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);
if (!ext4_data_block_valid(sbi, block, len)) {
ext4_error(sb, ""Allocating blocks %llu-%llu which overlap ""
""fs metadata"", block, block+len);
ext4_lock_group(sb, ac->ac_b_ex.fe_group);
ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
ac->ac_b_ex.fe_len);
ext4_unlock_group(sb, ac->ac_b_ex.fe_group);
err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
if (!err)
err = -EFSCORRUPTED;
goto out_err;
}
ext4_lock_group(sb, ac->ac_b_ex.fe_group);
#ifdef AGGRESSIVE_CHECK
{
int i;
for (i = 0; i < ac->ac_b_ex.fe_len; i++) {
BUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,
bitmap_bh->b_data));
}
}
#endif
ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
ac->ac_b_ex.fe_len);
if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
ext4_free_group_clusters_set(sb, gdp,
ext4_free_clusters_after_init(sb,
ac->ac_b_ex.fe_group, gdp));
}
len = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;
ext4_free_group_clusters_set(sb, gdp, len);
ext4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);
ext4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);
ext4_unlock_group(sb, ac->ac_b_ex.fe_group);
percpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);
if (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))
percpu_counter_sub(&sbi->s_dirtyclusters_counter,
reserv_clstrs);
if (sbi->s_log_groups_per_flex) {
ext4_group_t flex_group = ext4_flex_group(sbi,
ac->ac_b_ex.fe_group);
atomic64_sub(ac->ac_b_ex.fe_len,
&sbi->s_flex_groups[flex_group].free_clusters);
}
err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
if (err)
goto out_err;
err = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);
out_err:
brelse(bitmap_bh);
return err;
}","static noinline_for_stack VAR_0
ext4_mb_mark_diskspace_used(struct ext4_allocation_context *VAR_1,
handle_t *VAR_2, unsigned int VAR_3)
{
struct buffer_head *VAR_4 = NULL;
struct ext4_group_desc *VAR_5;
struct buffer_head *VAR_6;
struct ext4_sb_info *VAR_7;
struct super_block *VAR_8;
ext4_fsblk_t VAR_9;
int VAR_10, VAR_11;
BUG_ON(VAR_1->ac_status != VAR_12);
BUG_ON(VAR_1->ac_b_ex.fe_len <= 0);
VAR_8 = VAR_1->ac_sb;
VAR_7 = EXT4_SB(VAR_8);
VAR_4 = ext4_read_block_bitmap(VAR_8, VAR_1->ac_b_ex.fe_group);
if (IS_ERR(VAR_4)) {
VAR_10 = PTR_ERR(VAR_4);
VAR_4 = NULL;
goto out_err;
}
BUFFER_TRACE(VAR_4, ""getting write access"");
VAR_10 = ext4_journal_get_write_access(VAR_2, VAR_4);
if (VAR_10)
goto out_err;
VAR_10 = -VAR_13;
VAR_5 = ext4_get_group_desc(VAR_8, VAR_1->ac_b_ex.fe_group, &VAR_6);
if (!VAR_5)
goto out_err;
ext4_debug(""using block group %u(%d)\n"", VAR_1->ac_b_ex.fe_group,
ext4_free_group_clusters(VAR_8, VAR_5));
BUFFER_TRACE(VAR_6, ""get_write_access"");
VAR_10 = ext4_journal_get_write_access(VAR_2, VAR_6);
if (VAR_10)
goto out_err;
VAR_9 = ext4_grp_offs_to_block(VAR_8, &VAR_1->ac_b_ex);
VAR_11 = EXT4_C2B(VAR_7, VAR_1->ac_b_ex.fe_len);
if (!ext4_data_block_valid(VAR_7, VAR_9, VAR_11)) {
ext4_error(VAR_8, ""Allocating blocks %llu-%llu which overlap ""
""fs metadata"", VAR_9, VAR_9+VAR_11);
ext4_lock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
ext4_set_bits(VAR_4->b_data, VAR_1->ac_b_ex.fe_start,
VAR_1->ac_b_ex.fe_len);
ext4_unlock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_4);
if (!VAR_10)
VAR_10 = -VAR_14;
goto out_err;
}
ext4_lock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
#ifdef VAR_15
{
int VAR_16;
for (VAR_16 = 0; VAR_16 < VAR_1->ac_b_ex.fe_len; VAR_16++) {
BUG_ON(mb_test_bit(VAR_1->ac_b_ex.fe_start + VAR_16,
VAR_4->b_data));
}
}
#endif
ext4_set_bits(VAR_4->b_data, VAR_1->ac_b_ex.fe_start,
VAR_1->ac_b_ex.fe_len);
if (VAR_5->bg_flags & cpu_to_le16(VAR_17)) {
VAR_5->bg_flags &= cpu_to_le16(~VAR_17);
ext4_free_group_clusters_set(VAR_8, VAR_5,
ext4_free_clusters_after_init(VAR_8,
VAR_1->ac_b_ex.fe_group, VAR_5));
}
VAR_11 = ext4_free_group_clusters(VAR_8, VAR_5) - VAR_1->ac_b_ex.fe_len;
ext4_free_group_clusters_set(VAR_8, VAR_5, VAR_11);
ext4_block_bitmap_csum_set(VAR_8, VAR_1->ac_b_ex.fe_group, VAR_5, VAR_4);
ext4_group_desc_csum_set(VAR_8, VAR_1->ac_b_ex.fe_group, VAR_5);
ext4_unlock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
percpu_counter_sub(&VAR_7->s_freeclusters_counter, VAR_1->ac_b_ex.fe_len);
if (!(VAR_1->ac_flags & VAR_18))
percpu_counter_sub(&VAR_7->s_dirtyclusters_counter,
VAR_3);
if (VAR_7->s_log_groups_per_flex) {
ext4_group_t VAR_19 = ext4_flex_group(VAR_7,
VAR_1->ac_b_ex.fe_group);
atomic64_sub(VAR_1->ac_b_ex.fe_len,
&VAR_7->s_flex_groups[VAR_19].free_clusters);
}
VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_4);
if (VAR_10)
goto out_err;
VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_6);
out_err:
brelse(VAR_4);
return VAR_10;
}",,"static noinline_for_stack int
ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
				handle_t *handle, unsigned int reserv_clstrs)
{
	struct buffer_head *bitmap_bh = NULL;
	struct ext4_group_desc *gdp;
	struct buffer_head *gdp_bh;
	struct ext4_sb_info *sbi;
	struct super_block *sb;
	ext4_fsblk_t block;
	int err, len;

	BUG_ON(ac->ac_status != AC_STATUS_FOUND);
	BUG_ON(ac->ac_b_ex.fe_len <= 0);

	sb = ac->ac_sb;
	sbi = EXT4_SB(sb);

	bitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);
	if (IS_ERR(bitmap_bh)) {
		err = PTR_ERR(bitmap_bh);
		bitmap_bh = NULL;
		goto out_err;
	}

	BUFFER_TRACE(bitmap_bh, ""getting write access"");
	err = ext4_journal_get_write_access(handle, bitmap_bh);
	if (err)
		goto out_err;

	err = -EIO;
	gdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);
	if (!gdp)
		goto out_err;

	ext4_debug(""using block group %u(%d)\n"", ac->ac_b_ex.fe_group,
			ext4_free_group_clusters(sb, gdp));

	BUFFER_TRACE(gdp_bh, ""get_write_access"");
	err = ext4_journal_get_write_access(handle, gdp_bh);
	if (err)
		goto out_err;

	block = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);

	len = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);
	if (!ext4_data_block_valid(sbi, block, len)) {
		ext4_error(sb, ""Allocating blocks %llu-%llu which overlap ""
			   ""fs metadata"", block, block+len);
		/* File system mounted not to panic on error
		 * Fix the bitmap and return EFSCORRUPTED
		 * We leak some of the blocks here.
		 */
		ext4_lock_group(sb, ac->ac_b_ex.fe_group);
		ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
			      ac->ac_b_ex.fe_len);
		ext4_unlock_group(sb, ac->ac_b_ex.fe_group);
		err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
		if (!err)
			err = -EFSCORRUPTED;
		goto out_err;
	}

	ext4_lock_group(sb, ac->ac_b_ex.fe_group);
#ifdef AGGRESSIVE_CHECK
	{
		int i;
		for (i = 0; i < ac->ac_b_ex.fe_len; i++) {
			BUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,
						bitmap_bh->b_data));
		}
	}
#endif
	ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
		      ac->ac_b_ex.fe_len);
	if (ext4_has_group_desc_csum(sb) &&
	    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
		gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
		ext4_free_group_clusters_set(sb, gdp,
					     ext4_free_clusters_after_init(sb,
						ac->ac_b_ex.fe_group, gdp));
	}
	len = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;
	ext4_free_group_clusters_set(sb, gdp, len);
	ext4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);
	ext4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);

	ext4_unlock_group(sb, ac->ac_b_ex.fe_group);
	percpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);
	/*
	 * Now reduce the dirty block count also. Should not go negative
	 */
	if (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))
		/* release all the reserved blocks if non delalloc */
		percpu_counter_sub(&sbi->s_dirtyclusters_counter,
				   reserv_clstrs);

	if (sbi->s_log_groups_per_flex) {
		ext4_group_t flex_group = ext4_flex_group(sbi,
							  ac->ac_b_ex.fe_group);
		atomic64_sub(ac->ac_b_ex.fe_len,
			     &sbi->s_flex_groups[flex_group].free_clusters);
	}

	err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
	if (err)
		goto out_err;
	err = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);

out_err:
	brelse(bitmap_bh);
	return err;
}","static noinline_for_stack VAR_0
ext4_mb_mark_diskspace_used(struct ext4_allocation_context *VAR_1,
				handle_t *VAR_2, unsigned int VAR_3)
{
	struct buffer_head *VAR_4 = NULL;
	struct ext4_group_desc *VAR_5;
	struct buffer_head *VAR_6;
	struct ext4_sb_info *VAR_7;
	struct super_block *VAR_8;
	ext4_fsblk_t VAR_9;
	int VAR_10, VAR_11;

	BUG_ON(VAR_1->ac_status != VAR_12);
	BUG_ON(VAR_1->ac_b_ex.fe_len <= 0);

	VAR_8 = VAR_1->ac_sb;
	VAR_7 = EXT4_SB(VAR_8);

	VAR_4 = ext4_read_block_bitmap(VAR_8, VAR_1->ac_b_ex.fe_group);
	if (IS_ERR(VAR_4)) {
		VAR_10 = PTR_ERR(VAR_4);
		VAR_4 = NULL;
		goto out_err;
	}

	BUFFER_TRACE(VAR_4, ""getting write access"");
	VAR_10 = ext4_journal_get_write_access(VAR_2, VAR_4);
	if (VAR_10)
		goto out_err;

	VAR_10 = -VAR_13;
	VAR_5 = ext4_get_group_desc(VAR_8, VAR_1->ac_b_ex.fe_group, &VAR_6);
	if (!VAR_5)
		goto out_err;

	ext4_debug(""using block group %u(%d)\n"", VAR_1->ac_b_ex.fe_group,
			ext4_free_group_clusters(VAR_8, VAR_5));

	BUFFER_TRACE(VAR_6, ""get_write_access"");
	VAR_10 = ext4_journal_get_write_access(VAR_2, VAR_6);
	if (VAR_10)
		goto out_err;

	VAR_9 = ext4_grp_offs_to_block(VAR_8, &VAR_1->ac_b_ex);

	VAR_11 = EXT4_C2B(VAR_7, VAR_1->ac_b_ex.fe_len);
	if (!ext4_data_block_valid(VAR_7, VAR_9, VAR_11)) {
		ext4_error(VAR_8, ""Allocating blocks %llu-%llu which overlap ""
			   ""fs metadata"", VAR_9, VAR_9+VAR_11);
		/* COMMENT_0 */
                                           
                                     
     
		ext4_lock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
		ext4_set_bits(VAR_4->b_data, VAR_1->ac_b_ex.fe_start,
			      VAR_1->ac_b_ex.fe_len);
		ext4_unlock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
		VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_4);
		if (!VAR_10)
			VAR_10 = -VAR_14;
		goto out_err;
	}

	ext4_lock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
#ifdef VAR_15
	{
		int VAR_16;
		for (VAR_16 = 0; VAR_16 < VAR_1->ac_b_ex.fe_len; VAR_16++) {
			BUG_ON(mb_test_bit(VAR_1->ac_b_ex.fe_start + VAR_16,
						VAR_4->b_data));
		}
	}
#endif
	ext4_set_bits(VAR_4->b_data, VAR_1->ac_b_ex.fe_start,
		      VAR_1->ac_b_ex.fe_len);
	if (ext4_has_group_desc_csum(VAR_8) &&
	    (VAR_5->bg_flags & cpu_to_le16(VAR_17))) {
		VAR_5->bg_flags &= cpu_to_le16(~VAR_17);
		ext4_free_group_clusters_set(VAR_8, VAR_5,
					     ext4_free_clusters_after_init(VAR_8,
						VAR_1->ac_b_ex.fe_group, VAR_5));
	}
	VAR_11 = ext4_free_group_clusters(VAR_8, VAR_5) - VAR_1->ac_b_ex.fe_len;
	ext4_free_group_clusters_set(VAR_8, VAR_5, VAR_11);
	ext4_block_bitmap_csum_set(VAR_8, VAR_1->ac_b_ex.fe_group, VAR_5, VAR_4);
	ext4_group_desc_csum_set(VAR_8, VAR_1->ac_b_ex.fe_group, VAR_5);

	ext4_unlock_group(VAR_8, VAR_1->ac_b_ex.fe_group);
	percpu_counter_sub(&VAR_7->s_freeclusters_counter, VAR_1->ac_b_ex.fe_len);
	/* COMMENT_4 */
                                                                 
    
	if (!(VAR_1->ac_flags & VAR_18))
		/* COMMENT_7 */
		percpu_counter_sub(&VAR_7->s_dirtyclusters_counter,
				   VAR_3);

	if (VAR_7->s_log_groups_per_flex) {
		ext4_group_t VAR_19 = ext4_flex_group(VAR_7,
							  VAR_1->ac_b_ex.fe_group);
		atomic64_sub(VAR_1->ac_b_ex.fe_len,
			     &VAR_7->s_flex_groups[VAR_19].free_clusters);
	}

	VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_4);
	if (VAR_10)
		goto out_err;
	VAR_10 = ext4_handle_dirty_metadata(VAR_2, NULL, VAR_6);

out_err:
	brelse(VAR_4);
	return VAR_10;
}",,"--- func_before
+++ func_after
@@ -73,7 +73,8 @@
 #endif
 	ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
 		      ac->ac_b_ex.fe_len);
-	if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
 		gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
 		ext4_free_group_clusters_set(sb, gdp,
 					     ext4_free_clusters_after_init(sb,","{'deleted_lines': ['\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {'], 'added_lines': ['\tif (ext4_has_group_desc_csum(sb) &&', '\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10876,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8844618d8aa7a9973e7b527d038a2a589665002c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8844618d8aa7a9973e7b527d038a2a589665002c,fs/ext4/mballoc.c,ext4_mb_add_groupinfo,"int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
struct ext4_group_desc *desc)
{
int i;
int metalen = 0;
struct ext4_sb_info *sbi = EXT4_SB(sb);
struct ext4_group_info **meta_group_info;
struct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);
if (group % EXT4_DESC_PER_BLOCK(sb) == 0) {
metalen = sizeof(*meta_group_info) <<
EXT4_DESC_PER_BLOCK_BITS(sb);
meta_group_info = kmalloc(metalen, GFP_NOFS);
if (meta_group_info == NULL) {
ext4_msg(sb, KERN_ERR, ""can't allocate mem ""
""for a buddy group"");
goto exit_meta_group_info;
}
sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =
meta_group_info;
}
meta_group_info =
sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];
i = group & (EXT4_DESC_PER_BLOCK(sb) - 1);
meta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);
if (meta_group_info[i] == NULL) {
ext4_msg(sb, KERN_ERR, ""can't allocate buddy mem"");
goto exit_group_info;
}
set_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,
&(meta_group_info[i]->bb_state));
if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
meta_group_info[i]->bb_free =
ext4_free_clusters_after_init(sb, group, desc);
} else {
meta_group_info[i]->bb_free =
ext4_free_group_clusters(sb, desc);
}
INIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);
init_rwsem(&meta_group_info[i]->alloc_sem);
meta_group_info[i]->bb_free_root = RB_ROOT;
meta_group_info[i]->bb_largest_free_order = -1;  
#ifdef DOUBLE_CHECK
{
struct buffer_head *bh;
meta_group_info[i]->bb_bitmap =
kmalloc(sb->s_blocksize, GFP_NOFS);
BUG_ON(meta_group_info[i]->bb_bitmap == NULL);
bh = ext4_read_block_bitmap(sb, group);
BUG_ON(IS_ERR_OR_NULL(bh));
memcpy(meta_group_info[i]->bb_bitmap, bh->b_data,
sb->s_blocksize);
put_bh(bh);
}
#endif
return 0;
exit_group_info:
if (group % EXT4_DESC_PER_BLOCK(sb) == 0) {
kfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);
sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;
}
exit_meta_group_info:
return -ENOMEM;
}","int ext4_mb_add_groupinfo(struct super_block *VAR_0, ext4_group_t VAR_1,
struct ext4_group_desc *VAR_2)
{
int VAR_3;
int VAR_4 = 0;
struct ext4_sb_info *VAR_5 = EXT4_SB(VAR_0);
struct ext4_group_info **VAR_6;
struct kmem_cache *VAR_7 = get_groupinfo_cache(VAR_0->s_blocksize_bits);
if (VAR_1 % EXT4_DESC_PER_BLOCK(VAR_0) == 0) {
VAR_4 = sizeof(*VAR_6) <<
EXT4_DESC_PER_BLOCK_BITS(VAR_0);
VAR_6 = kmalloc(VAR_4, VAR_8);
if (VAR_6 == NULL) {
ext4_msg(VAR_0, VAR_9, ""can't allocate mem ""
""for a buddy group"");
goto exit_meta_group_info;
}
VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)] =
VAR_6;
}
VAR_6 =
VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)];
VAR_3 = VAR_1 & (EXT4_DESC_PER_BLOCK(VAR_0) - 1);
VAR_6[VAR_3] = kmem_cache_zalloc(VAR_7, VAR_8);
if (VAR_6[VAR_3] == NULL) {
ext4_msg(VAR_0, VAR_9, ""can't allocate buddy mem"");
goto exit_group_info;
}
set_bit(VAR_10,
&(VAR_6[VAR_3]->bb_state));
if (VAR_2->bg_flags & cpu_to_le16(VAR_11)) {
VAR_6[VAR_3]->bb_free =
ext4_free_clusters_after_init(VAR_0, VAR_1, VAR_2);
} else {
VAR_6[VAR_3]->bb_free =
ext4_free_group_clusters(VAR_0, VAR_2);
}
INIT_LIST_HEAD(&VAR_6[VAR_3]->bb_prealloc_list);
init_rwsem(&VAR_6[VAR_3]->alloc_sem);
VAR_6[VAR_3]->bb_free_root = VAR_12;
VAR_6[VAR_3]->bb_largest_free_order = -1;  
#ifdef VAR_13
{
struct buffer_head *VAR_14;
VAR_6[VAR_3]->bb_bitmap =
kmalloc(VAR_0->s_blocksize, VAR_8);
BUG_ON(VAR_6[VAR_3]->bb_bitmap == NULL);
VAR_14 = ext4_read_block_bitmap(VAR_0, VAR_1);
BUG_ON(IS_ERR_OR_NULL(VAR_14));
memcpy(VAR_6[VAR_3]->bb_bitmap, VAR_14->b_data,
VAR_0->s_blocksize);
put_bh(VAR_14);
}
#endif
return 0;
exit_group_info:
if (VAR_1 % EXT4_DESC_PER_BLOCK(VAR_0) == 0) {
kfree(VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)]);
VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)] = NULL;
}
exit_meta_group_info:
return -VAR_15;
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/mballoc.c/vul/before/1.json,"int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
			  struct ext4_group_desc *desc)
{
	int i;
	int metalen = 0;
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct ext4_group_info **meta_group_info;
	struct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);

	/*
	 * First check if this group is the first of a reserved block.
	 * If it's true, we have to allocate a new table of pointers
	 * to ext4_group_info structures
	 */
	if (group % EXT4_DESC_PER_BLOCK(sb) == 0) {
		metalen = sizeof(*meta_group_info) <<
			EXT4_DESC_PER_BLOCK_BITS(sb);
		meta_group_info = kmalloc(metalen, GFP_NOFS);
		if (meta_group_info == NULL) {
			ext4_msg(sb, KERN_ERR, ""can't allocate mem ""
				 ""for a buddy group"");
			goto exit_meta_group_info;
		}
		sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =
			meta_group_info;
	}

	meta_group_info =
		sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];
	i = group & (EXT4_DESC_PER_BLOCK(sb) - 1);

	meta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);
	if (meta_group_info[i] == NULL) {
		ext4_msg(sb, KERN_ERR, ""can't allocate buddy mem"");
		goto exit_group_info;
	}
	set_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,
		&(meta_group_info[i]->bb_state));

	/*
	 * initialize bb_free to be able to skip
	 * empty groups without initialization
	 */
	if (ext4_has_group_desc_csum(sb) &&
	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
		meta_group_info[i]->bb_free =
			ext4_free_clusters_after_init(sb, group, desc);
	} else {
		meta_group_info[i]->bb_free =
			ext4_free_group_clusters(sb, desc);
	}

	INIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);
	init_rwsem(&meta_group_info[i]->alloc_sem);
	meta_group_info[i]->bb_free_root = RB_ROOT;
	meta_group_info[i]->bb_largest_free_order = -1;  /* uninit */

#ifdef DOUBLE_CHECK
	{
		struct buffer_head *bh;
		meta_group_info[i]->bb_bitmap =
			kmalloc(sb->s_blocksize, GFP_NOFS);
		BUG_ON(meta_group_info[i]->bb_bitmap == NULL);
		bh = ext4_read_block_bitmap(sb, group);
		BUG_ON(IS_ERR_OR_NULL(bh));
		memcpy(meta_group_info[i]->bb_bitmap, bh->b_data,
			sb->s_blocksize);
		put_bh(bh);
	}
#endif

	return 0;

exit_group_info:
	/* If a meta_group_info table has been allocated, release it now */
	if (group % EXT4_DESC_PER_BLOCK(sb) == 0) {
		kfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);
		sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;
	}
exit_meta_group_info:
	return -ENOMEM;
}","int ext4_mb_add_groupinfo(struct super_block *VAR_0, ext4_group_t VAR_1,
			  struct ext4_group_desc *VAR_2)
{
	int VAR_3;
	int VAR_4 = 0;
	struct ext4_sb_info *VAR_5 = EXT4_SB(VAR_0);
	struct ext4_group_info **VAR_6;
	struct kmem_cache *VAR_7 = get_groupinfo_cache(VAR_0->s_blocksize_bits);

	/* COMMENT_0 */
                                                               
                                                             
                                 
    
	if (VAR_1 % EXT4_DESC_PER_BLOCK(VAR_0) == 0) {
		VAR_4 = sizeof(*VAR_6) <<
			EXT4_DESC_PER_BLOCK_BITS(VAR_0);
		VAR_6 = kmalloc(VAR_4, VAR_8);
		if (VAR_6 == NULL) {
			ext4_msg(VAR_0, VAR_9, ""can't allocate mem ""
				 ""for a buddy group"");
			goto exit_meta_group_info;
		}
		VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)] =
			VAR_6;
	}

	VAR_6 =
		VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)];
	VAR_3 = VAR_1 & (EXT4_DESC_PER_BLOCK(VAR_0) - 1);

	VAR_6[VAR_3] = kmem_cache_zalloc(VAR_7, VAR_8);
	if (VAR_6[VAR_3] == NULL) {
		ext4_msg(VAR_0, VAR_9, ""can't allocate buddy mem"");
		goto exit_group_info;
	}
	set_bit(VAR_10,
		&(VAR_6[VAR_3]->bb_state));

	/* COMMENT_5 */
                                         
                                       
    
	if (ext4_has_group_desc_csum(VAR_0) &&
	    (VAR_2->bg_flags & cpu_to_le16(VAR_11))) {
		VAR_6[VAR_3]->bb_free =
			ext4_free_clusters_after_init(VAR_0, VAR_1, VAR_2);
	} else {
		VAR_6[VAR_3]->bb_free =
			ext4_free_group_clusters(VAR_0, VAR_2);
	}

	INIT_LIST_HEAD(&VAR_6[VAR_3]->bb_prealloc_list);
	init_rwsem(&VAR_6[VAR_3]->alloc_sem);
	VAR_6[VAR_3]->bb_free_root = VAR_12;
	VAR_6[VAR_3]->bb_largest_free_order = -1;  /* COMMENT_9 */

#ifdef VAR_13
	{
		struct buffer_head *VAR_14;
		VAR_6[VAR_3]->bb_bitmap =
			kmalloc(VAR_0->s_blocksize, VAR_8);
		BUG_ON(VAR_6[VAR_3]->bb_bitmap == NULL);
		VAR_14 = ext4_read_block_bitmap(VAR_0, VAR_1);
		BUG_ON(IS_ERR_OR_NULL(VAR_14));
		memcpy(VAR_6[VAR_3]->bb_bitmap, VAR_14->b_data,
			VAR_0->s_blocksize);
		put_bh(VAR_14);
	}
#endif

	return 0;

exit_group_info:
	/* COMMENT_10 */
	if (VAR_1 % EXT4_DESC_PER_BLOCK(VAR_0) == 0) {
		kfree(VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)]);
		VAR_5->s_group_info[VAR_1 >> EXT4_DESC_PER_BLOCK_BITS(VAR_0)] = NULL;
	}
exit_meta_group_info:
	return -VAR_15;
}",torvalds/linux/8844618d8aa7a9973e7b527d038a2a589665002c/mballoc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -41,7 +41,8 @@
 	 * initialize bb_free to be able to skip
 	 * empty groups without initialization
 	 */
-	if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
 		meta_group_info[i]->bb_free =
 			ext4_free_clusters_after_init(sb, group, desc);
 	} else {","{'deleted_lines': ['\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {'], 'added_lines': ['\tif (ext4_has_group_desc_csum(sb) &&', '\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {']}",True,A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.,5.0,MEDIUM,1,valid,,5
CVE-2018-10881,['CWE-787'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"When converting from an inode from storing the data in-line to a data
block, ext4_destroy_inline_data_nolock() was only clearing the on-disk
copy of the i_blocks[] array.  It was not clearing copy of the
i_blocks[] in ext4_inode_info, in i_data[], which is the copy actually
used by ext4_map_blocks().

This didn't matter much if we are using extents, since the extents
header would be invalid and thus the extents could would re-initialize
the extents tree.  But if we are using indirect blocks, the previous
contents of the i_blocks array will be treated as block numbers, with
potentially catastrophic results to the file system integrity and/or
user data.

This gets worse if the file system is using a 1k block size and
s_first_data is zero, but even without this, the file system can get
quite badly corrupted.

This addresses CVE-2018-10881.

https://bugzilla.kernel.org/show_bug.cgi?id=200015

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",6e8ab72a812396996035a37e5ca4b3b99b5d214b,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6e8ab72a812396996035a37e5ca4b3b99b5d214b,fs/ext4/inline.c,ext4_destroy_inline_data_nolock,"static int ext4_destroy_inline_data_nolock(handle_t *handle,
struct inode *inode)
{
struct ext4_inode_info *ei = EXT4_I(inode);
struct ext4_xattr_ibody_find is = {
.s = { .not_found = 0, },
};
struct ext4_xattr_info i = {
.name_index = EXT4_XATTR_INDEX_SYSTEM,
.name = EXT4_XATTR_SYSTEM_DATA,
.value = NULL,
.value_len = 0,
};
int error;
if (!ei->i_inline_off)
return 0;
error = ext4_get_inode_loc(inode, &is.iloc);
if (error)
return error;
error = ext4_xattr_ibody_find(inode, &i, &is);
if (error)
goto out;
BUFFER_TRACE(is.iloc.bh, ""get_write_access"");
error = ext4_journal_get_write_access(handle, is.iloc.bh);
if (error)
goto out;
error = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);
if (error)
goto out;
memset((void *)ext4_raw_inode(&is.iloc)->i_block,
0, EXT4_MIN_INLINE_DATA_SIZE);
if (ext4_has_feature_extents(inode->i_sb)) {
if (S_ISDIR(inode->i_mode) ||
S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {
ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);
ext4_ext_tree_init(handle, inode);
}
}
ext4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);
get_bh(is.iloc.bh);
error = ext4_mark_iloc_dirty(handle, inode, &is.iloc);
EXT4_I(inode)->i_inline_off = 0;
EXT4_I(inode)->i_inline_size = 0;
ext4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);
out:
brelse(is.iloc.bh);
if (error == -ENODATA)
error = 0;
return error;
}","static int ext4_destroy_inline_data_nolock(handle_t *VAR_0,
struct inode *inode)
{
struct ext4_inode_info *VAR_1 = EXT4_I(inode);
struct ext4_xattr_ibody_find VAR_2 = {
.s = { .not_found = 0, },
};
struct ext4_xattr_info VAR_3 = {
.name_index = VAR_4,
.name = VAR_5,
.value = NULL,
.value_len = 0,
};
int VAR_6;
if (!VAR_1->i_inline_off)
return 0;
VAR_6 = ext4_get_inode_loc(inode, &VAR_2.iloc);
if (VAR_6)
return VAR_6;
VAR_6 = ext4_xattr_ibody_find(inode, &VAR_3, &VAR_2);
if (VAR_6)
goto out;
BUFFER_TRACE(VAR_2.iloc.bh, ""get_write_access"");
VAR_6 = ext4_journal_get_write_access(VAR_0, VAR_2.iloc.bh);
if (VAR_6)
goto out;
VAR_6 = ext4_xattr_ibody_inline_set(VAR_0, inode, &VAR_3, &VAR_2);
if (VAR_6)
goto out;
memset((void *)ext4_raw_inode(&VAR_2.iloc)->i_block,
0, VAR_7);
if (ext4_has_feature_extents(inode->i_sb)) {
if (S_ISDIR(inode->i_mode) ||
S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {
ext4_set_inode_flag(inode, VAR_8);
ext4_ext_tree_init(VAR_0, inode);
}
}
ext4_clear_inode_flag(inode, VAR_9);
get_bh(VAR_2.iloc.bh);
VAR_6 = ext4_mark_iloc_dirty(VAR_0, inode, &VAR_2.iloc);
EXT4_I(inode)->i_inline_off = 0;
EXT4_I(inode)->i_inline_size = 0;
ext4_clear_inode_state(inode, VAR_10);
out:
brelse(VAR_2.iloc.bh);
if (VAR_6 == -VAR_11)
VAR_6 = 0;
return VAR_6;
}",torvalds/linux/6e8ab72a812396996035a37e5ca4b3b99b5d214b/inline.c/vul/before/0.json,"static int ext4_destroy_inline_data_nolock(handle_t *handle,
					   struct inode *inode)
{
	struct ext4_inode_info *ei = EXT4_I(inode);
	struct ext4_xattr_ibody_find is = {
		.s = { .not_found = 0, },
	};
	struct ext4_xattr_info i = {
		.name_index = EXT4_XATTR_INDEX_SYSTEM,
		.name = EXT4_XATTR_SYSTEM_DATA,
		.value = NULL,
		.value_len = 0,
	};
	int error;

	if (!ei->i_inline_off)
		return 0;

	error = ext4_get_inode_loc(inode, &is.iloc);
	if (error)
		return error;

	error = ext4_xattr_ibody_find(inode, &i, &is);
	if (error)
		goto out;

	BUFFER_TRACE(is.iloc.bh, ""get_write_access"");
	error = ext4_journal_get_write_access(handle, is.iloc.bh);
	if (error)
		goto out;

	error = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);
	if (error)
		goto out;

	memset((void *)ext4_raw_inode(&is.iloc)->i_block,
		0, EXT4_MIN_INLINE_DATA_SIZE);
	memset(ei->i_data, 0, EXT4_MIN_INLINE_DATA_SIZE);

	if (ext4_has_feature_extents(inode->i_sb)) {
		if (S_ISDIR(inode->i_mode) ||
		    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {
			ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);
			ext4_ext_tree_init(handle, inode);
		}
	}
	ext4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);

	get_bh(is.iloc.bh);
	error = ext4_mark_iloc_dirty(handle, inode, &is.iloc);

	EXT4_I(inode)->i_inline_off = 0;
	EXT4_I(inode)->i_inline_size = 0;
	ext4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);
out:
	brelse(is.iloc.bh);
	if (error == -ENODATA)
		error = 0;
	return error;
}","static int ext4_destroy_inline_data_nolock(handle_t *VAR_0,
					   struct inode *inode)
{
	struct ext4_inode_info *VAR_1 = EXT4_I(inode);
	struct ext4_xattr_ibody_find VAR_2 = {
		.s = { .not_found = 0, },
	};
	struct ext4_xattr_info VAR_3 = {
		.name_index = VAR_4,
		.name = VAR_5,
		.value = NULL,
		.value_len = 0,
	};
	int VAR_6;

	if (!VAR_1->i_inline_off)
		return 0;

	VAR_6 = ext4_get_inode_loc(inode, &VAR_2.iloc);
	if (VAR_6)
		return VAR_6;

	VAR_6 = ext4_xattr_ibody_find(inode, &VAR_3, &VAR_2);
	if (VAR_6)
		goto out;

	BUFFER_TRACE(VAR_2.iloc.bh, ""get_write_access"");
	VAR_6 = ext4_journal_get_write_access(VAR_0, VAR_2.iloc.bh);
	if (VAR_6)
		goto out;

	VAR_6 = ext4_xattr_ibody_inline_set(VAR_0, inode, &VAR_3, &VAR_2);
	if (VAR_6)
		goto out;

	memset((void *)ext4_raw_inode(&VAR_2.iloc)->i_block,
		0, VAR_7);
	memset(VAR_1->i_data, 0, VAR_7);

	if (ext4_has_feature_extents(inode->i_sb)) {
		if (S_ISDIR(inode->i_mode) ||
		    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {
			ext4_set_inode_flag(inode, VAR_8);
			ext4_ext_tree_init(VAR_0, inode);
		}
	}
	ext4_clear_inode_flag(inode, VAR_9);

	get_bh(VAR_2.iloc.bh);
	VAR_6 = ext4_mark_iloc_dirty(VAR_0, inode, &VAR_2.iloc);

	EXT4_I(inode)->i_inline_off = 0;
	EXT4_I(inode)->i_inline_size = 0;
	ext4_clear_inode_state(inode, VAR_10);
out:
	brelse(VAR_2.iloc.bh);
	if (VAR_6 == -VAR_11)
		VAR_6 = 0;
	return VAR_6;
}",torvalds/linux/6e8ab72a812396996035a37e5ca4b3b99b5d214b/inline.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,7 @@
 
 	memset((void *)ext4_raw_inode(&is.iloc)->i_block,
 		0, EXT4_MIN_INLINE_DATA_SIZE);
+	memset(ei->i_data, 0, EXT4_MIN_INLINE_DATA_SIZE);
 
 	if (ext4_has_feature_extents(inode->i_sb)) {
 		if (S_ISDIR(inode->i_mode) ||","{'deleted_lines': [], 'added_lines': ['\tmemset(ei->i_data, 0, EXT4_MIN_INLINE_DATA_SIZE);']}",True,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound access in ext4_get_group_info function, a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",4.2,MEDIUM,1,valid,,5
CVE-2018-10902,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"The SNDRV_RAWMIDI_IOCTL_PARAMS ioctl may resize the buffers and the
current code is racy.  For example, the sequencer client may write to
buffer while it being resized.

As a simple workaround, let's switch to the resized buffer inside the
stream runtime lock.

Reported-by: syzbot+52f83f0ea8df16932f7f@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",39675f7a7c7e7702f7d5341f1e0d01db746543a0,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=39675f7a7c7e7702f7d5341f1e0d01db746543a0,sound/core/rawmidi.c,snd_rawmidi_output_params,"int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
struct snd_rawmidi_params * params)
{
char *newbuf;
struct snd_rawmidi_runtime *runtime = substream->runtime;
if (substream->append && substream->use_count > 1)
return -EBUSY;
snd_rawmidi_drain_output(substream);
if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {
return -EINVAL;
}
if (params->avail_min < 1 || params->avail_min > params->buffer_size) {
return -EINVAL;
}
if (params->buffer_size != runtime->buffer_size) {
newbuf = krealloc(runtime->buffer, params->buffer_size,
GFP_KERNEL);
if (!newbuf)
return -ENOMEM;
runtime->buffer = newbuf;
runtime->buffer_size = params->buffer_size;
runtime->avail = runtime->buffer_size;
}
runtime->avail_min = params->avail_min;
substream->active_sensing = !params->no_active_sensing;
return 0;
}","int snd_rawmidi_output_params(struct snd_rawmidi_substream *VAR_0,
struct snd_rawmidi_params * VAR_1)
{
char *VAR_2;
struct snd_rawmidi_runtime *VAR_3 = VAR_0->runtime;
if (VAR_0->append && VAR_0->use_count > 1)
return -VAR_4;
snd_rawmidi_drain_output(VAR_0);
if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L) {
return -VAR_5;
}
if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size) {
return -VAR_5;
}
if (VAR_1->buffer_size != VAR_3->buffer_size) {
VAR_2 = krealloc(VAR_3->buffer, VAR_1->buffer_size,
VAR_6);
if (!VAR_2)
return -VAR_7;
VAR_3->buffer = VAR_2;
VAR_3->buffer_size = VAR_1->buffer_size;
VAR_3->avail = VAR_3->buffer_size;
}
VAR_3->avail_min = VAR_1->avail_min;
VAR_0->active_sensing = !VAR_1->no_active_sensing;
return 0;
}",torvalds/linux/39675f7a7c7e7702f7d5341f1e0d01db746543a0/rawmidi.c/vul/before/0.json,"int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
			      struct snd_rawmidi_params * params)
{
	char *newbuf, *oldbuf;
	struct snd_rawmidi_runtime *runtime = substream->runtime;
	
	if (substream->append && substream->use_count > 1)
		return -EBUSY;
	snd_rawmidi_drain_output(substream);
	if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {
		return -EINVAL;
	}
	if (params->avail_min < 1 || params->avail_min > params->buffer_size) {
		return -EINVAL;
	}
	if (params->buffer_size != runtime->buffer_size) {
		newbuf = kmalloc(params->buffer_size, GFP_KERNEL);
		if (!newbuf)
			return -ENOMEM;
		spin_lock_irq(&runtime->lock);
		oldbuf = runtime->buffer;
		runtime->buffer = newbuf;
		runtime->buffer_size = params->buffer_size;
		runtime->avail = runtime->buffer_size;
		runtime->appl_ptr = runtime->hw_ptr = 0;
		spin_unlock_irq(&runtime->lock);
		kfree(oldbuf);
	}
	runtime->avail_min = params->avail_min;
	substream->active_sensing = !params->no_active_sensing;
	return 0;
}","int snd_rawmidi_output_params(struct snd_rawmidi_substream *VAR_0,
			      struct snd_rawmidi_params * VAR_1)
{
	char *VAR_2, *VAR_3;
	struct snd_rawmidi_runtime *VAR_4 = VAR_0->runtime;
	
	if (VAR_0->append && VAR_0->use_count > 1)
		return -VAR_5;
	snd_rawmidi_drain_output(VAR_0);
	if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L) {
		return -VAR_6;
	}
	if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size) {
		return -VAR_6;
	}
	if (VAR_1->buffer_size != VAR_4->buffer_size) {
		VAR_2 = kmalloc(VAR_1->buffer_size, VAR_7);
		if (!VAR_2)
			return -VAR_8;
		spin_lock_irq(&VAR_4->lock);
		VAR_3 = VAR_4->buffer;
		VAR_4->buffer = VAR_2;
		VAR_4->buffer_size = VAR_1->buffer_size;
		VAR_4->avail = VAR_4->buffer_size;
		VAR_4->appl_ptr = VAR_4->hw_ptr = 0;
		spin_unlock_irq(&VAR_4->lock);
		kfree(VAR_3);
	}
	VAR_4->avail_min = VAR_1->avail_min;
	VAR_0->active_sensing = !VAR_1->no_active_sensing;
	return 0;
}",torvalds/linux/39675f7a7c7e7702f7d5341f1e0d01db746543a0/rawmidi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
 			      struct snd_rawmidi_params * params)
 {
-	char *newbuf;
+	char *newbuf, *oldbuf;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 	
 	if (substream->append && substream->use_count > 1)
@@ -14,13 +14,17 @@
 		return -EINVAL;
 	}
 	if (params->buffer_size != runtime->buffer_size) {
-		newbuf = krealloc(runtime->buffer, params->buffer_size,
-				  GFP_KERNEL);
+		newbuf = kmalloc(params->buffer_size, GFP_KERNEL);
 		if (!newbuf)
 			return -ENOMEM;
+		spin_lock_irq(&runtime->lock);
+		oldbuf = runtime->buffer;
 		runtime->buffer = newbuf;
 		runtime->buffer_size = params->buffer_size;
 		runtime->avail = runtime->buffer_size;
+		runtime->appl_ptr = runtime->hw_ptr = 0;
+		spin_unlock_irq(&runtime->lock);
+		kfree(oldbuf);
 	}
 	runtime->avail_min = params->avail_min;
 	substream->active_sensing = !params->no_active_sensing;","{'deleted_lines': ['\tchar *newbuf;', '\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,', '\t\t\t\t  GFP_KERNEL);'], 'added_lines': ['\tchar *newbuf, *oldbuf;', '\t\tnewbuf = kmalloc(params->buffer_size, GFP_KERNEL);', '\t\tspin_lock_irq(&runtime->lock);', '\t\toldbuf = runtime->buffer;', '\t\truntime->appl_ptr = runtime->hw_ptr = 0;', '\t\tspin_unlock_irq(&runtime->lock);', '\t\tkfree(oldbuf);']}",True,It was found that the raw midi kernel driver does not protect against concurrent access which leads to a double realloc (double free) in snd_rawmidi_input_params() and snd_rawmidi_output_status() which are part of snd_rawmidi_ioctl() handler in rawmidi.c file. A malicious local attacker could possibly use this for privilege escalation.,7.8,HIGH,2,valid,,5
CVE-2018-10902,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"The SNDRV_RAWMIDI_IOCTL_PARAMS ioctl may resize the buffers and the
current code is racy.  For example, the sequencer client may write to
buffer while it being resized.

As a simple workaround, let's switch to the resized buffer inside the
stream runtime lock.

Reported-by: syzbot+52f83f0ea8df16932f7f@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",39675f7a7c7e7702f7d5341f1e0d01db746543a0,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=39675f7a7c7e7702f7d5341f1e0d01db746543a0,sound/core/rawmidi.c,snd_rawmidi_input_params,"int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
struct snd_rawmidi_params * params)
{
char *newbuf;
struct snd_rawmidi_runtime *runtime = substream->runtime;
snd_rawmidi_drain_input(substream);
if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {
return -EINVAL;
}
if (params->avail_min < 1 || params->avail_min > params->buffer_size) {
return -EINVAL;
}
if (params->buffer_size != runtime->buffer_size) {
newbuf = krealloc(runtime->buffer, params->buffer_size,
GFP_KERNEL);
if (!newbuf)
return -ENOMEM;
runtime->buffer = newbuf;
runtime->buffer_size = params->buffer_size;
}
runtime->avail_min = params->avail_min;
return 0;
}","int snd_rawmidi_input_params(struct snd_rawmidi_substream *VAR_0,
struct snd_rawmidi_params * VAR_1)
{
char *VAR_2;
struct snd_rawmidi_runtime *VAR_3 = VAR_0->runtime;
snd_rawmidi_drain_input(VAR_0);
if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L) {
return -VAR_4;
}
if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size) {
return -VAR_4;
}
if (VAR_1->buffer_size != VAR_3->buffer_size) {
VAR_2 = krealloc(VAR_3->buffer, VAR_1->buffer_size,
VAR_5);
if (!VAR_2)
return -VAR_6;
VAR_3->buffer = VAR_2;
VAR_3->buffer_size = VAR_1->buffer_size;
}
VAR_3->avail_min = VAR_1->avail_min;
return 0;
}",torvalds/linux/39675f7a7c7e7702f7d5341f1e0d01db746543a0/rawmidi.c/vul/before/1.json,"int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
			     struct snd_rawmidi_params * params)
{
	char *newbuf, *oldbuf;
	struct snd_rawmidi_runtime *runtime = substream->runtime;

	snd_rawmidi_drain_input(substream);
	if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {
		return -EINVAL;
	}
	if (params->avail_min < 1 || params->avail_min > params->buffer_size) {
		return -EINVAL;
	}
	if (params->buffer_size != runtime->buffer_size) {
		newbuf = kmalloc(params->buffer_size, GFP_KERNEL);
		if (!newbuf)
			return -ENOMEM;
		spin_lock_irq(&runtime->lock);
		oldbuf = runtime->buffer;
		runtime->buffer = newbuf;
		runtime->buffer_size = params->buffer_size;
		runtime->appl_ptr = runtime->hw_ptr = 0;
		spin_unlock_irq(&runtime->lock);
		kfree(oldbuf);
	}
	runtime->avail_min = params->avail_min;
	return 0;
}","int snd_rawmidi_input_params(struct snd_rawmidi_substream *VAR_0,
			     struct snd_rawmidi_params * VAR_1)
{
	char *VAR_2, *VAR_3;
	struct snd_rawmidi_runtime *VAR_4 = VAR_0->runtime;

	snd_rawmidi_drain_input(VAR_0);
	if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L) {
		return -VAR_5;
	}
	if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size) {
		return -VAR_5;
	}
	if (VAR_1->buffer_size != VAR_4->buffer_size) {
		VAR_2 = kmalloc(VAR_1->buffer_size, VAR_6);
		if (!VAR_2)
			return -VAR_7;
		spin_lock_irq(&VAR_4->lock);
		VAR_3 = VAR_4->buffer;
		VAR_4->buffer = VAR_2;
		VAR_4->buffer_size = VAR_1->buffer_size;
		VAR_4->appl_ptr = VAR_4->hw_ptr = 0;
		spin_unlock_irq(&VAR_4->lock);
		kfree(VAR_3);
	}
	VAR_4->avail_min = VAR_1->avail_min;
	return 0;
}",torvalds/linux/39675f7a7c7e7702f7d5341f1e0d01db746543a0/rawmidi.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
 			     struct snd_rawmidi_params * params)
 {
-	char *newbuf;
+	char *newbuf, *oldbuf;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
 	snd_rawmidi_drain_input(substream);
@@ -12,12 +12,16 @@
 		return -EINVAL;
 	}
 	if (params->buffer_size != runtime->buffer_size) {
-		newbuf = krealloc(runtime->buffer, params->buffer_size,
-				  GFP_KERNEL);
+		newbuf = kmalloc(params->buffer_size, GFP_KERNEL);
 		if (!newbuf)
 			return -ENOMEM;
+		spin_lock_irq(&runtime->lock);
+		oldbuf = runtime->buffer;
 		runtime->buffer = newbuf;
 		runtime->buffer_size = params->buffer_size;
+		runtime->appl_ptr = runtime->hw_ptr = 0;
+		spin_unlock_irq(&runtime->lock);
+		kfree(oldbuf);
 	}
 	runtime->avail_min = params->avail_min;
 	return 0;","{'deleted_lines': ['\tchar *newbuf;', '\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,', '\t\t\t\t  GFP_KERNEL);'], 'added_lines': ['\tchar *newbuf, *oldbuf;', '\t\tnewbuf = kmalloc(params->buffer_size, GFP_KERNEL);', '\t\tspin_lock_irq(&runtime->lock);', '\t\toldbuf = runtime->buffer;', '\t\truntime->appl_ptr = runtime->hw_ptr = 0;', '\t\tspin_unlock_irq(&runtime->lock);', '\t\tkfree(oldbuf);']}",True,It was found that the raw midi kernel driver does not protect against concurrent access which leads to a double realloc (double free) in snd_rawmidi_input_params() and snd_rawmidi_output_status() which are part of snd_rawmidi_ioctl() handler in rawmidi.c file. A malicious local attacker could possibly use this for privilege escalation.,7.8,HIGH,2,valid,,5
CVE-2018-14600,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/lib/libX11,"The length value is interpreted as signed char on many systems
(depending on default signedness of char), which can lead to an out of
boundary write up to 128 bytes in front of the allocated storage, but
limited to NUL byte(s).

Casting the length value to unsigned char fixes the problem and allows
string values with up to 255 characters.

Signed-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>
",dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,src/GetFPath.c,XGetFontPath,"char **XGetFontPath(
register Display *dpy,
int *npaths)
{
xGetFontPathReply rep;
unsigned long nbytes = 0;
char **flist = NULL;
char *ch = NULL;
char *chend;
int count = 0;
register unsigned i;
register int length;
_X_UNUSED register xReq *req;
LockDisplay(dpy);
GetEmptyReq (GetFontPath, req);
(void) _XReply (dpy, (xReply *) &rep, 0, xFalse);
if (rep.nPaths) {
flist = Xmalloc(rep.nPaths * sizeof (char *));
if (rep.length < (INT_MAX >> 2)) {
nbytes = (unsigned long) rep.length << 2;
ch = Xmalloc (nbytes + 1);
}
if ((! flist) || (! ch)) {
Xfree(flist);
Xfree(ch);
_XEatDataWords(dpy, rep.length);
UnlockDisplay(dpy);
SyncHandle();
return (char **) NULL;
}
_XReadPad (dpy, ch, nbytes);
chend = ch + nbytes;
length = *ch;
for (i = 0; i < rep.nPaths; i++) {
if (ch + length < chend) {
flist[i] = ch+1;  
ch += length + 1; 
length = *ch;
*ch = '\0'; 
count++;
} else
flist[i] = NULL;
}
}
*npaths = count;
UnlockDisplay(dpy);
SyncHandle();
return (flist);
}","char **XGetFontPath(
register Display *VAR_0,
int *VAR_1)
{
xGetFontPathReply VAR_2;
unsigned long VAR_3 = 0;
char **VAR_4 = NULL;
char *VAR_5 = NULL;
char *VAR_6;
int VAR_7 = 0;
register unsigned VAR_8;
register int VAR_9;
_X_UNUSED register VAR_10 *VAR_11;
LockDisplay(VAR_0);
GetEmptyReq (VAR_12, VAR_11);
(void) _XReply (VAR_0, (xReply *) &VAR_2, 0, VAR_13);
if (VAR_2.nPaths) {
VAR_4 = Xmalloc(VAR_2.nPaths * sizeof (char *));
if (VAR_2.length < (VAR_14 >> 2)) {
VAR_3 = (unsigned long) VAR_2.length << 2;
VAR_5 = Xmalloc (VAR_3 + 1);
}
if ((! VAR_4) || (! VAR_5)) {
Xfree(VAR_4);
Xfree(VAR_5);
_XEatDataWords(VAR_0, VAR_2.length);
UnlockDisplay(VAR_0);
SyncHandle();
return (char **) NULL;
}
_XReadPad (VAR_0, VAR_5, VAR_3);
VAR_6 = VAR_5 + VAR_3;
VAR_9 = *VAR_5;
for (VAR_8 = 0; VAR_8 < VAR_2.nPaths; VAR_8++) {
if (VAR_5 + VAR_9 < VAR_6) {
VAR_4[VAR_8] = VAR_5+1;  
VAR_5 += VAR_9 + 1; 
VAR_9 = *VAR_5;
*VAR_5 = '\0'; 
VAR_7++;
} else
VAR_4[VAR_8] = NULL;
}
}
*VAR_1 = VAR_7;
UnlockDisplay(VAR_0);
SyncHandle();
return (VAR_4);
}",xorg/lib/libX11/dbf72805fd9d7b1846fe9a11b46f3994bfc27fea/GetFPath.c/vul/before/0.json,"char **XGetFontPath(
    register Display *dpy,
    int *npaths)	/* RETURN */
{
	xGetFontPathReply rep;
	unsigned long nbytes = 0;
	char **flist = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;

	LockDisplay(dpy);
	GetEmptyReq (GetFontPath, req);
	(void) _XReply (dpy, (xReply *) &rep, 0, xFalse);

	if (rep.nPaths) {
	    flist = Xmalloc(rep.nPaths * sizeof (char *));
	    if (rep.length < (INT_MAX >> 2)) {
		nbytes = (unsigned long) rep.length << 2;
		ch = Xmalloc (nbytes + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((! flist) || (! ch)) {
		Xfree(flist);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, nbytes);
	    /*
	     * unpack into null terminated strings.
	     */
	    chend = ch + nbytes;
	    length = *(unsigned char *)ch;
	    for (i = 0; i < rep.nPaths; i++) {
		if (ch + length < chend) {
		    flist[i] = ch+1;  /* skip over length */
		    ch += length + 1; /* find next length ... */
		    length = *(unsigned char *)ch;
		    *ch = '\0'; /* and replace with null-termination */
		    count++;
		} else
		    flist[i] = NULL;
	    }
	}
	*npaths = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (flist);
}","char **XGetFontPath(
    register Display *VAR_0,
    int *VAR_1)	/* COMMENT_0 */
{
	xGetFontPathReply VAR_2;
	unsigned long VAR_3 = 0;
	char **VAR_4 = NULL;
	char *VAR_5 = NULL;
	char *VAR_6;
	int VAR_7 = 0;
	register unsigned VAR_8;
	register int VAR_9;
	_X_UNUSED register VAR_10 *VAR_11;

	LockDisplay(VAR_0);
	GetEmptyReq (VAR_12, VAR_11);
	(void) _XReply (VAR_0, (xReply *) &VAR_2, 0, VAR_13);

	if (VAR_2.nPaths) {
	    VAR_4 = Xmalloc(VAR_2.nPaths * sizeof (char *));
	    if (VAR_2.length < (VAR_14 >> 2)) {
		VAR_3 = (unsigned long) VAR_2.length << 2;
		VAR_5 = Xmalloc (VAR_3 + 1);
                /* COMMENT_1 */
	    }

	    if ((! VAR_4) || (! VAR_5)) {
		Xfree(VAR_4);
		Xfree(VAR_5);
		_XEatDataWords(VAR_0, VAR_2.length);
		UnlockDisplay(VAR_0);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (VAR_0, VAR_5, VAR_3);
	    /* COMMENT_2 */
                                            
        
	    VAR_6 = VAR_5 + VAR_3;
	    VAR_9 = *(unsigned char *)VAR_5;
	    for (VAR_8 = 0; VAR_8 < VAR_2.nPaths; VAR_8++) {
		if (VAR_5 + VAR_9 < VAR_6) {
		    VAR_4[VAR_8] = VAR_5+1;  /* COMMENT_5 */
		    VAR_5 += VAR_9 + 1; /* COMMENT_6 */
		    VAR_9 = *(unsigned char *)VAR_5;
		    *VAR_5 = '\0'; /* COMMENT_7 */
		    VAR_7++;
		} else
		    VAR_4[VAR_8] = NULL;
	    }
	}
	*VAR_1 = VAR_7;
	UnlockDisplay(VAR_0);
	SyncHandle();
	return (VAR_4);
}",xorg/lib/libX11/dbf72805fd9d7b1846fe9a11b46f3994bfc27fea/GetFPath.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,12 +38,12 @@
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + nbytes;
-	    length = *ch;
+	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nPaths; i++) {
 		if (ch + length < chend) {
 		    flist[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
-		    length = *ch;
+		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else","{'deleted_lines': ['\t    length = *ch;', '\t\t    length = *ch;'], 'added_lines': ['\t    length = *(unsigned char *)ch;', '\t\t    length = *(unsigned char *)ch;']}",True,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c interprets a variable as signed instead of unsigned, resulting in an out-of-bounds write (of up to 128 bytes), leading to DoS or remote code execution.",9.8,CRITICAL,3,valid,,5
CVE-2018-14600,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/lib/libX11,"The length value is interpreted as signed char on many systems
(depending on default signedness of char), which can lead to an out of
boundary write up to 128 bytes in front of the allocated storage, but
limited to NUL byte(s).

Casting the length value to unsigned char fixes the problem and allows
string values with up to 255 characters.

Signed-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>
",dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,src/ListExt.c,XListExtensions,"char **XListExtensions(
register Display *dpy,
int *nextensions)
{
xListExtensionsReply rep;
char **list = NULL;
char *ch = NULL;
char *chend;
int count = 0;
register unsigned i;
register int length;
_X_UNUSED register xReq *req;
unsigned long rlen = 0;
LockDisplay(dpy);
GetEmptyReq (ListExtensions, req);
if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
UnlockDisplay(dpy);
SyncHandle();
return (char **) NULL;
}
if (rep.nExtensions) {
list = Xmalloc (rep.nExtensions * sizeof (char *));
if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
rlen = rep.length << 2;
ch = Xmalloc (rlen + 1);
}
if ((!list) || (!ch)) {
Xfree(list);
Xfree(ch);
_XEatDataWords(dpy, rep.length);
UnlockDisplay(dpy);
SyncHandle();
return (char **) NULL;
}
_XReadPad (dpy, ch, rlen);
chend = ch + rlen;
length = *ch;
for (i = 0; i < rep.nExtensions; i++) {
if (ch + length < chend) {
list[i] = ch+1;  
ch += length + 1; 
length = *ch;
*ch = '\0'; 
count++;
} else
list[i] = NULL;
}
}
*nextensions = count;
UnlockDisplay(dpy);
SyncHandle();
return (list);
}","char **XListExtensions(
register Display *VAR_0,
int *VAR_1)
{
xListExtensionsReply VAR_2;
char **VAR_3 = NULL;
char *VAR_4 = NULL;
char *VAR_5;
int VAR_6 = 0;
register unsigned VAR_7;
register int VAR_8;
_X_UNUSED register VAR_9 *VAR_10;
unsigned long VAR_11 = 0;
LockDisplay(VAR_0);
GetEmptyReq (VAR_12, VAR_10);
if (! _XReply (VAR_0, (xReply *) &VAR_2, 0, VAR_13)) {
UnlockDisplay(VAR_0);
SyncHandle();
return (char **) NULL;
}
if (VAR_2.nExtensions) {
VAR_3 = Xmalloc (VAR_2.nExtensions * sizeof (char *));
if (VAR_2.length > 0 && VAR_2.length < (VAR_14 >> 2)) {
VAR_11 = VAR_2.length << 2;
VAR_4 = Xmalloc (VAR_11 + 1);
}
if ((!VAR_3) || (!VAR_4)) {
Xfree(VAR_3);
Xfree(VAR_4);
_XEatDataWords(VAR_0, VAR_2.length);
UnlockDisplay(VAR_0);
SyncHandle();
return (char **) NULL;
}
_XReadPad (VAR_0, VAR_4, VAR_11);
VAR_5 = VAR_4 + VAR_11;
VAR_8 = *VAR_4;
for (VAR_7 = 0; VAR_7 < VAR_2.nExtensions; VAR_7++) {
if (VAR_4 + VAR_8 < VAR_5) {
VAR_3[VAR_7] = VAR_4+1;  
VAR_4 += VAR_8 + 1; 
VAR_8 = *VAR_4;
*VAR_4 = '\0'; 
VAR_6++;
} else
VAR_3[VAR_7] = NULL;
}
}
*VAR_1 = VAR_6;
UnlockDisplay(VAR_0);
SyncHandle();
return (VAR_3);
}",xorg/lib/libX11/dbf72805fd9d7b1846fe9a11b46f3994bfc27fea/ListExt.c/vul/before/0.json,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
	     * unpack into null terminated strings.
	     */
	    chend = ch + rlen;
	    length = *(unsigned char *)ch;
	    for (i = 0; i < rep.nExtensions; i++) {
		if (ch + length < chend) {
		    list[i] = ch+1;  /* skip over length */
		    ch += length + 1; /* find next length ... */
		    length = *(unsigned char *)ch;
		    *ch = '\0'; /* and replace with null-termination */
		    count++;
		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}","char **XListExtensions(
    register Display *VAR_0,
    int *VAR_1)	/* COMMENT_0 */
{
	xListExtensionsReply VAR_2;
	char **VAR_3 = NULL;
	char *VAR_4 = NULL;
	char *VAR_5;
	int VAR_6 = 0;
	register unsigned VAR_7;
	register int VAR_8;
	_X_UNUSED register VAR_9 *VAR_10;
	unsigned long VAR_11 = 0;

	LockDisplay(VAR_0);
	GetEmptyReq (VAR_12, VAR_10);

	if (! _XReply (VAR_0, (xReply *) &VAR_2, 0, VAR_13)) {
	    UnlockDisplay(VAR_0);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (VAR_2.nExtensions) {
	    VAR_3 = Xmalloc (VAR_2.nExtensions * sizeof (char *));
	    if (VAR_2.length > 0 && VAR_2.length < (VAR_14 >> 2)) {
		VAR_11 = VAR_2.length << 2;
		VAR_4 = Xmalloc (VAR_11 + 1);
                /* COMMENT_1 */
	    }

	    if ((!VAR_3) || (!VAR_4)) {
		Xfree(VAR_3);
		Xfree(VAR_4);
		_XEatDataWords(VAR_0, VAR_2.length);
		UnlockDisplay(VAR_0);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (VAR_0, VAR_4, VAR_11);
	    /* COMMENT_2 */
                                            
        
	    VAR_5 = VAR_4 + VAR_11;
	    VAR_8 = *(unsigned char *)VAR_4;
	    for (VAR_7 = 0; VAR_7 < VAR_2.nExtensions; VAR_7++) {
		if (VAR_4 + VAR_8 < VAR_5) {
		    VAR_3[VAR_7] = VAR_4+1;  /* COMMENT_5 */
		    VAR_4 += VAR_8 + 1; /* COMMENT_6 */
		    VAR_8 = *(unsigned char *)VAR_4;
		    *VAR_4 = '\0'; /* COMMENT_7 */
		    VAR_6++;
		} else
		    VAR_3[VAR_7] = NULL;
	    }
	}

	*VAR_1 = VAR_6;
	UnlockDisplay(VAR_0);
	SyncHandle();
	return (VAR_3);
}",xorg/lib/libX11/dbf72805fd9d7b1846fe9a11b46f3994bfc27fea/ListExt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,12 +43,12 @@
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
-	    length = *ch;
+	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
-		    length = *ch;
+		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else","{'deleted_lines': ['\t    length = *ch;', '\t\t    length = *ch;'], 'added_lines': ['\t    length = *(unsigned char *)ch;', '\t\t    length = *(unsigned char *)ch;']}",True,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c interprets a variable as signed instead of unsigned, resulting in an out-of-bounds write (of up to 128 bytes), leading to DoS or remote code execution.",9.8,CRITICAL,3,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ec/ec_lib.c,EC_GROUP_copy,"int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
{
EC_EXTRA_DATA *d;
if (dest->meth->group_copy == 0)
{
ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
return 0;
}
if (dest->meth != src->meth)
{
ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);
return 0;
}
if (dest == src)
return 1;
EC_EX_DATA_free_all_data(&dest->extra_data);
for (d = src->extra_data; d != NULL; d = d->next)
{
void *t = d->dup_func(d->data);
if (t == NULL)
return 0;
if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))
return 0;
}
if (src->generator != NULL)
{
if (dest->generator == NULL)
{
dest->generator = EC_POINT_new(dest);
if (dest->generator == NULL) return 0;
}
if (!EC_POINT_copy(dest->generator, src->generator)) return 0;
}
else
{
if (dest->generator != NULL)
{
EC_POINT_clear_free(dest->generator);
dest->generator = NULL;
}
}
if (!BN_copy(&dest->order, &src->order)) return 0;
if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;
dest->curve_name = src->curve_name;
dest->asn1_flag  = src->asn1_flag;
dest->asn1_form  = src->asn1_form;
if (src->seed)
{
if (dest->seed)
OPENSSL_free(dest->seed);
dest->seed = OPENSSL_malloc(src->seed_len);
if (dest->seed == NULL)
return 0;
if (!memcpy(dest->seed, src->seed, src->seed_len))
return 0;
dest->seed_len = src->seed_len;
}
else
{
if (dest->seed)
OPENSSL_free(dest->seed);
dest->seed = NULL;
dest->seed_len = 0;
}
return dest->meth->group_copy(dest, src);
}","int EC_GROUP_copy(EC_GROUP *VAR_0, const EC_GROUP *VAR_1)
{
EC_EXTRA_DATA *VAR_2;
if (VAR_0->meth->group_copy == 0)
{
ECerr(VAR_3, VAR_4);
return 0;
}
if (VAR_0->meth != VAR_1->meth)
{
ECerr(VAR_3, VAR_5);
return 0;
}
if (VAR_0 == VAR_1)
return 1;
EC_EX_DATA_free_all_data(&VAR_0->extra_data);
for (VAR_2 = VAR_1->extra_data; VAR_2 != NULL; VAR_2 = VAR_2->next)
{
void *VAR_6 = VAR_2->dup_func(VAR_2->data);
if (VAR_6 == NULL)
return 0;
if (!EC_EX_DATA_set_data(&VAR_0->extra_data, VAR_6, VAR_2->dup_func, VAR_2->free_func, VAR_2->clear_free_func))
return 0;
}
if (VAR_1->generator != NULL)
{
if (VAR_0->generator == NULL)
{
VAR_0->generator = EC_POINT_new(VAR_0);
if (VAR_0->generator == NULL) return 0;
}
if (!EC_POINT_copy(VAR_0->generator, VAR_1->generator)) return 0;
}
else
{
if (VAR_0->generator != NULL)
{
EC_POINT_clear_free(VAR_0->generator);
VAR_0->generator = NULL;
}
}
if (!BN_copy(&VAR_0->order, &VAR_1->order)) return 0;
if (!BN_copy(&VAR_0->cofactor, &VAR_1->cofactor)) return 0;
VAR_0->curve_name = VAR_1->curve_name;
VAR_0->asn1_flag  = VAR_1->asn1_flag;
VAR_0->asn1_form  = VAR_1->asn1_form;
if (VAR_1->seed)
{
if (VAR_0->seed)
OPENSSL_free(VAR_0->seed);
VAR_0->seed = OPENSSL_malloc(VAR_1->seed_len);
if (VAR_0->seed == NULL)
return 0;
if (!memcpy(VAR_0->seed, VAR_1->seed, VAR_1->seed_len))
return 0;
VAR_0->seed_len = VAR_1->seed_len;
}
else
{
if (VAR_0->seed)
OPENSSL_free(VAR_0->seed);
VAR_0->seed = NULL;
VAR_0->seed_len = 0;
}
return VAR_0->meth->group_copy(VAR_0, VAR_1);
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/before/0.json,"int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
	{
	EC_EXTRA_DATA *d;

	if (dest->meth->group_copy == 0)
		{
		ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (dest->meth != src->meth)
		{
		ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	if (dest == src)
		return 1;
	
	EC_EX_DATA_free_all_data(&dest->extra_data);

	for (d = src->extra_data; d != NULL; d = d->next)
		{
		void *t = d->dup_func(d->data);
		
		if (t == NULL)
			return 0;
		if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))
			return 0;
		}

	if (src->mont_data != NULL)
		{
		if (dest->mont_data == NULL)
			{
			dest->mont_data = BN_MONT_CTX_new();
			if (dest->mont_data == NULL) return 0;
			}
		if (!BN_MONT_CTX_copy(dest->mont_data, src->mont_data)) return 0;
		}
	else
		{
		/* src->generator == NULL */
		if (dest->mont_data != NULL)
			{
			BN_MONT_CTX_free(dest->mont_data);
			dest->mont_data = NULL;
			}
		}

	if (src->generator != NULL)
		{
		if (dest->generator == NULL)
			{
			dest->generator = EC_POINT_new(dest);
			if (dest->generator == NULL) return 0;
			}
		if (!EC_POINT_copy(dest->generator, src->generator)) return 0;
		}
	else
		{
		/* src->generator == NULL */
		if (dest->generator != NULL)
			{
			EC_POINT_clear_free(dest->generator);
			dest->generator = NULL;
			}
		}

	if (!BN_copy(&dest->order, &src->order)) return 0;
	if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;

	dest->curve_name = src->curve_name;
	dest->asn1_flag  = src->asn1_flag;
	dest->asn1_form  = src->asn1_form;

	if (src->seed)
		{
		if (dest->seed)
			OPENSSL_free(dest->seed);
		dest->seed = OPENSSL_malloc(src->seed_len);
		if (dest->seed == NULL)
			return 0;
		if (!memcpy(dest->seed, src->seed, src->seed_len))
			return 0;
		dest->seed_len = src->seed_len;
		}
	else
		{
		if (dest->seed)
			OPENSSL_free(dest->seed);
		dest->seed = NULL;
		dest->seed_len = 0;
		}
	

	return dest->meth->group_copy(dest, src);
	}","int EC_GROUP_copy(EC_GROUP *VAR_0, const EC_GROUP *VAR_1)
	{
	EC_EXTRA_DATA *VAR_2;

	if (VAR_0->meth->group_copy == 0)
		{
		ECerr(VAR_3, VAR_4);
		return 0;
		}
	if (VAR_0->meth != VAR_1->meth)
		{
		ECerr(VAR_3, VAR_5);
		return 0;
		}
	if (VAR_0 == VAR_1)
		return 1;
	
	EC_EX_DATA_free_all_data(&VAR_0->extra_data);

	for (VAR_2 = VAR_1->extra_data; VAR_2 != NULL; VAR_2 = VAR_2->next)
		{
		void *VAR_6 = VAR_2->dup_func(VAR_2->data);
		
		if (VAR_6 == NULL)
			return 0;
		if (!EC_EX_DATA_set_data(&VAR_0->extra_data, VAR_6, VAR_2->dup_func, VAR_2->free_func, VAR_2->clear_free_func))
			return 0;
		}

	if (VAR_1->mont_data != NULL)
		{
		if (VAR_0->mont_data == NULL)
			{
			VAR_0->mont_data = BN_MONT_CTX_new();
			if (VAR_0->mont_data == NULL) return 0;
			}
		if (!BN_MONT_CTX_copy(VAR_0->mont_data, VAR_1->mont_data)) return 0;
		}
	else
		{
		/* COMMENT_0 */
		if (VAR_0->mont_data != NULL)
			{
			BN_MONT_CTX_free(VAR_0->mont_data);
			VAR_0->mont_data = NULL;
			}
		}

	if (VAR_1->generator != NULL)
		{
		if (VAR_0->generator == NULL)
			{
			VAR_0->generator = EC_POINT_new(VAR_0);
			if (VAR_0->generator == NULL) return 0;
			}
		if (!EC_POINT_copy(VAR_0->generator, VAR_1->generator)) return 0;
		}
	else
		{
		/* COMMENT_0 */
		if (VAR_0->generator != NULL)
			{
			EC_POINT_clear_free(VAR_0->generator);
			VAR_0->generator = NULL;
			}
		}

	if (!BN_copy(&VAR_0->order, &VAR_1->order)) return 0;
	if (!BN_copy(&VAR_0->cofactor, &VAR_1->cofactor)) return 0;

	VAR_0->curve_name = VAR_1->curve_name;
	VAR_0->asn1_flag  = VAR_1->asn1_flag;
	VAR_0->asn1_form  = VAR_1->asn1_form;

	if (VAR_1->seed)
		{
		if (VAR_0->seed)
			OPENSSL_free(VAR_0->seed);
		VAR_0->seed = OPENSSL_malloc(VAR_1->seed_len);
		if (VAR_0->seed == NULL)
			return 0;
		if (!memcpy(VAR_0->seed, VAR_1->seed, VAR_1->seed_len))
			return 0;
		VAR_0->seed_len = VAR_1->seed_len;
		}
	else
		{
		if (VAR_0->seed)
			OPENSSL_free(VAR_0->seed);
		VAR_0->seed = NULL;
		VAR_0->seed_len = 0;
		}
	

	return VAR_0->meth->group_copy(VAR_0, VAR_1);
	}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,6 +25,25 @@
 			return 0;
 		if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))
 			return 0;
+		}
+
+	if (src->mont_data != NULL)
+		{
+		if (dest->mont_data == NULL)
+			{
+			dest->mont_data = BN_MONT_CTX_new();
+			if (dest->mont_data == NULL) return 0;
+			}
+		if (!BN_MONT_CTX_copy(dest->mont_data, src->mont_data)) return 0;
+		}
+	else
+		{
+		/* src->generator == NULL */
+		if (dest->mont_data != NULL)
+			{
+			BN_MONT_CTX_free(dest->mont_data);
+			dest->mont_data = NULL;
+			}
 		}
 
 	if (src->generator != NULL)","{'deleted_lines': [], 'added_lines': ['\t\t}', '', '\tif (src->mont_data != NULL)', '\t\t{', '\t\tif (dest->mont_data == NULL)', '\t\t\t{', '\t\t\tdest->mont_data = BN_MONT_CTX_new();', '\t\t\tif (dest->mont_data == NULL) return 0;', '\t\t\t}', '\t\tif (!BN_MONT_CTX_copy(dest->mont_data, src->mont_data)) return 0;', '\t\t}', '\telse', '\t\t{', '\t\t/* src->generator == NULL */', '\t\tif (dest->mont_data != NULL)', '\t\t\t{', '\t\t\tBN_MONT_CTX_free(dest->mont_data);', '\t\t\tdest->mont_data = NULL;', '\t\t\t}']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ec/ec_lib.c,EC_GROUP_free,"void EC_GROUP_free(EC_GROUP *group)
{
if (!group) return;
if (group->meth->group_finish != 0)
group->meth->group_finish(group);
EC_EX_DATA_free_all_data(&group->extra_data);
if (group->generator != NULL)
EC_POINT_free(group->generator);
BN_free(&group->order);
BN_free(&group->cofactor);
if (group->seed)
OPENSSL_free(group->seed);
OPENSSL_free(group);
}","void EC_GROUP_free(EC_GROUP *VAR_0)
{
if (!VAR_0) return;
if (VAR_0->meth->group_finish != 0)
VAR_0->meth->group_finish(VAR_0);
EC_EX_DATA_free_all_data(&VAR_0->extra_data);
if (VAR_0->generator != NULL)
EC_POINT_free(VAR_0->generator);
BN_free(&VAR_0->order);
BN_free(&VAR_0->cofactor);
if (VAR_0->seed)
OPENSSL_free(VAR_0->seed);
OPENSSL_free(VAR_0);
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/before/1.json,"void EC_GROUP_free(EC_GROUP *group)
	{
	if (!group) return;

	if (group->meth->group_finish != 0)
		group->meth->group_finish(group);

	EC_EX_DATA_free_all_data(&group->extra_data);

	if (group->mont_data)
		BN_MONT_CTX_free(group->mont_data);

	if (group->generator != NULL)
		EC_POINT_free(group->generator);
	BN_free(&group->order);
	BN_free(&group->cofactor);

	if (group->seed)
		OPENSSL_free(group->seed);

	OPENSSL_free(group);
	}","void EC_GROUP_free(EC_GROUP *VAR_0)
	{
	if (!VAR_0) return;

	if (VAR_0->meth->group_finish != 0)
		VAR_0->meth->group_finish(VAR_0);

	EC_EX_DATA_free_all_data(&VAR_0->extra_data);

	if (VAR_0->mont_data)
		BN_MONT_CTX_free(VAR_0->mont_data);

	if (VAR_0->generator != NULL)
		EC_POINT_free(VAR_0->generator);
	BN_free(&VAR_0->order);
	BN_free(&VAR_0->cofactor);

	if (VAR_0->seed)
		OPENSSL_free(VAR_0->seed);

	OPENSSL_free(VAR_0);
	}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
 		group->meth->group_finish(group);
 
 	EC_EX_DATA_free_all_data(&group->extra_data);
+
+	if (group->mont_data)
+		BN_MONT_CTX_free(group->mont_data);
 
 	if (group->generator != NULL)
 		EC_POINT_free(group->generator);","{'deleted_lines': [], 'added_lines': ['', '\tif (group->mont_data)', '\t\tBN_MONT_CTX_free(group->mont_data);']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ec/ec_lib.c,EC_GROUP_set_generator,"int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
{
if (generator == NULL)
{
ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
return 0   ;
}
if (group->generator == NULL)
{
group->generator = EC_POINT_new(group);
if (group->generator == NULL) return 0;
}
if (!EC_POINT_copy(group->generator, generator)) return 0;
if (order != NULL)
{ if (!BN_copy(&group->order, order)) return 0; }
else
BN_zero(&group->order);
if (cofactor != NULL)
{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }
else
BN_zero(&group->cofactor);
return 1;
}","int EC_GROUP_set_generator(EC_GROUP *VAR_0, const EC_POINT *VAR_1, const BIGNUM *VAR_2, const BIGNUM *VAR_3)
{
if (VAR_1 == NULL)
{
ECerr(VAR_4, VAR_5);
return 0   ;
}
if (VAR_0->generator == NULL)
{
VAR_0->generator = EC_POINT_new(VAR_0);
if (VAR_0->generator == NULL) return 0;
}
if (!EC_POINT_copy(VAR_0->generator, VAR_1)) return 0;
if (VAR_2 != NULL)
{ if (!BN_copy(&VAR_0->order, VAR_2)) return 0; }
else
BN_zero(&VAR_0->order);
if (VAR_3 != NULL)
{ if (!BN_copy(&VAR_0->cofactor, VAR_3)) return 0; }
else
BN_zero(&VAR_0->cofactor);
return 1;
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/before/2.json,"int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
	{
	if (generator == NULL)
		{
		ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
		return 0   ;
		}

	if (group->generator == NULL)
		{
		group->generator = EC_POINT_new(group);
		if (group->generator == NULL) return 0;
		}
	if (!EC_POINT_copy(group->generator, generator)) return 0;

	if (order != NULL)
		{ if (!BN_copy(&group->order, order)) return 0; }	
	else
		BN_zero(&group->order);

	if (cofactor != NULL)
		{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }	
	else
		BN_zero(&group->cofactor);

	/* We ignore the return value because some groups have an order with
	 * factors of two, which makes the Montgomery setup fail.
	 * |group->mont_data| will be NULL in this case. */
	ec_precompute_mont_data(group);

	return 1;
	}","int EC_GROUP_set_generator(EC_GROUP *VAR_0, const EC_POINT *VAR_1, const BIGNUM *VAR_2, const BIGNUM *VAR_3)
	{
	if (VAR_1 == NULL)
		{
		ECerr(VAR_4, VAR_5);
		return 0   ;
		}

	if (VAR_0->generator == NULL)
		{
		VAR_0->generator = EC_POINT_new(VAR_0);
		if (VAR_0->generator == NULL) return 0;
		}
	if (!EC_POINT_copy(VAR_0->generator, VAR_1)) return 0;

	if (VAR_2 != NULL)
		{ if (!BN_copy(&VAR_0->order, VAR_2)) return 0; }	
	else
		BN_zero(&VAR_0->order);

	if (VAR_3 != NULL)
		{ if (!BN_copy(&VAR_0->cofactor, VAR_3)) return 0; }	
	else
		BN_zero(&VAR_0->cofactor);

	/* COMMENT_0 */
                                                          
                                                    
	ec_precompute_mont_data(VAR_0);

	return 1;
	}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -23,5 +23,10 @@
 	else
 		BN_zero(&group->cofactor);
 
+	/* We ignore the return value because some groups have an order with
+	 * factors of two, which makes the Montgomery setup fail.
+	 * |group->mont_data| will be NULL in this case. */
+	ec_precompute_mont_data(group);
+
 	return 1;
 	}","{'deleted_lines': [], 'added_lines': ['\t/* We ignore the return value because some groups have an order with', '\t * factors of two, which makes the Montgomery setup fail.', '\t * |group->mont_data| will be NULL in this case. */', '\tec_precompute_mont_data(group);', '']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ec/ec_lib.c,EC_GROUP_new,"EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)
{
EC_GROUP *ret;
if (meth == NULL)
{
ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);
return NULL;
}
if (meth->group_init == 0)
{
ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
return NULL;
}
ret = OPENSSL_malloc(sizeof *ret);
if (ret == NULL)
{
ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);
return NULL;
}
ret->meth = meth;
ret->extra_data = NULL;
ret->generator = NULL;
BN_init(&ret->order);
BN_init(&ret->cofactor);
ret->curve_name = 0;
ret->asn1_flag  = 0;
ret->asn1_form  = POINT_CONVERSION_UNCOMPRESSED;
ret->seed = NULL;
ret->seed_len = 0;
if (!meth->group_init(ret))
{
OPENSSL_free(ret);
return NULL;
}
return ret;
}","EC_GROUP *EC_GROUP_new(const EC_METHOD *VAR_0)
{
EC_GROUP *VAR_1;
if (VAR_0 == NULL)
{
ECerr(VAR_2, VAR_3);
return NULL;
}
if (VAR_0->group_init == 0)
{
ECerr(VAR_2, VAR_4);
return NULL;
}
VAR_1 = OPENSSL_malloc(sizeof *VAR_1);
if (VAR_1 == NULL)
{
ECerr(VAR_2, VAR_5);
return NULL;
}
VAR_1->meth = VAR_0;
VAR_1->extra_data = NULL;
VAR_1->generator = NULL;
BN_init(&VAR_1->order);
BN_init(&VAR_1->cofactor);
VAR_1->curve_name = 0;
VAR_1->asn1_flag  = 0;
VAR_1->asn1_form  = VAR_6;
VAR_1->seed = NULL;
VAR_1->seed_len = 0;
if (!VAR_0->group_init(VAR_1))
{
OPENSSL_free(VAR_1);
return NULL;
}
return VAR_1;
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/before/3.json,"EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)
	{
	EC_GROUP *ret;

	if (meth == NULL)
		{
		ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);
		return NULL;
		}
	if (meth->group_init == 0)
		{
		ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return NULL;
		}

	ret = OPENSSL_malloc(sizeof *ret);
	if (ret == NULL)
		{
		ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);
		return NULL;
		}

	ret->meth = meth;

	ret->extra_data = NULL;
	ret->mont_data = NULL;

	ret->generator = NULL;
	BN_init(&ret->order);
	BN_init(&ret->cofactor);

	ret->curve_name = 0;	
	ret->asn1_flag  = 0;
	ret->asn1_form  = POINT_CONVERSION_UNCOMPRESSED;

	ret->seed = NULL;
	ret->seed_len = 0;

	if (!meth->group_init(ret))
		{
		OPENSSL_free(ret);
		return NULL;
		}
	
	return ret;
	}","EC_GROUP *EC_GROUP_new(const EC_METHOD *VAR_0)
	{
	EC_GROUP *VAR_1;

	if (VAR_0 == NULL)
		{
		ECerr(VAR_2, VAR_3);
		return NULL;
		}
	if (VAR_0->group_init == 0)
		{
		ECerr(VAR_2, VAR_4);
		return NULL;
		}

	VAR_1 = OPENSSL_malloc(sizeof *VAR_1);
	if (VAR_1 == NULL)
		{
		ECerr(VAR_2, VAR_5);
		return NULL;
		}

	VAR_1->meth = VAR_0;

	VAR_1->extra_data = NULL;
	VAR_1->mont_data = NULL;

	VAR_1->generator = NULL;
	BN_init(&VAR_1->order);
	BN_init(&VAR_1->cofactor);

	VAR_1->curve_name = 0;	
	VAR_1->asn1_flag  = 0;
	VAR_1->asn1_form  = VAR_6;

	VAR_1->seed = NULL;
	VAR_1->seed_len = 0;

	if (!VAR_0->group_init(VAR_1))
		{
		OPENSSL_free(VAR_1);
		return NULL;
		}
	
	return VAR_1;
	}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -23,6 +23,7 @@
 	ret->meth = meth;
 
 	ret->extra_data = NULL;
+	ret->mont_data = NULL;
 
 	ret->generator = NULL;
 	BN_init(&ret->order);","{'deleted_lines': [], 'added_lines': ['\tret->mont_data = NULL;']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ec/ec_lib.c,EC_GROUP_clear_free,"void EC_GROUP_clear_free(EC_GROUP *group)
{
if (!group) return;
if (group->meth->group_clear_finish != 0)
group->meth->group_clear_finish(group);
else if (group->meth->group_finish != 0)
group->meth->group_finish(group);
EC_EX_DATA_clear_free_all_data(&group->extra_data);
if (group->generator != NULL)
EC_POINT_clear_free(group->generator);
BN_clear_free(&group->order);
BN_clear_free(&group->cofactor);
if (group->seed)
{
OPENSSL_cleanse(group->seed, group->seed_len);
OPENSSL_free(group->seed);
}
OPENSSL_cleanse(group, sizeof *group);
OPENSSL_free(group);
}","void EC_GROUP_clear_free(EC_GROUP *VAR_0)
{
if (!VAR_0) return;
if (VAR_0->meth->group_clear_finish != 0)
VAR_0->meth->group_clear_finish(VAR_0);
else if (VAR_0->meth->group_finish != 0)
VAR_0->meth->group_finish(VAR_0);
EC_EX_DATA_clear_free_all_data(&VAR_0->extra_data);
if (VAR_0->generator != NULL)
EC_POINT_clear_free(VAR_0->generator);
BN_clear_free(&VAR_0->order);
BN_clear_free(&VAR_0->cofactor);
if (VAR_0->seed)
{
OPENSSL_cleanse(VAR_0->seed, VAR_0->seed_len);
OPENSSL_free(VAR_0->seed);
}
OPENSSL_cleanse(VAR_0, sizeof *VAR_0);
OPENSSL_free(VAR_0);
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/before/4.json,"void EC_GROUP_clear_free(EC_GROUP *group)
	{
	if (!group) return;

	if (group->meth->group_clear_finish != 0)
		group->meth->group_clear_finish(group);
	else if (group->meth->group_finish != 0)
		group->meth->group_finish(group);

	EC_EX_DATA_clear_free_all_data(&group->extra_data);

	if (group->mont_data)
		BN_MONT_CTX_free(group->mont_data);

	if (group->generator != NULL)
		EC_POINT_clear_free(group->generator);
	BN_clear_free(&group->order);
	BN_clear_free(&group->cofactor);

	if (group->seed)
		{
		OPENSSL_cleanse(group->seed, group->seed_len);
		OPENSSL_free(group->seed);
		}

	OPENSSL_cleanse(group, sizeof *group);
	OPENSSL_free(group);
	}","void EC_GROUP_clear_free(EC_GROUP *VAR_0)
	{
	if (!VAR_0) return;

	if (VAR_0->meth->group_clear_finish != 0)
		VAR_0->meth->group_clear_finish(VAR_0);
	else if (VAR_0->meth->group_finish != 0)
		VAR_0->meth->group_finish(VAR_0);

	EC_EX_DATA_clear_free_all_data(&VAR_0->extra_data);

	if (VAR_0->mont_data)
		BN_MONT_CTX_free(VAR_0->mont_data);

	if (VAR_0->generator != NULL)
		EC_POINT_clear_free(VAR_0->generator);
	BN_clear_free(&VAR_0->order);
	BN_clear_free(&VAR_0->cofactor);

	if (VAR_0->seed)
		{
		OPENSSL_cleanse(VAR_0->seed, VAR_0->seed_len);
		OPENSSL_free(VAR_0->seed);
		}

	OPENSSL_cleanse(VAR_0, sizeof *VAR_0);
	OPENSSL_free(VAR_0);
	}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ec_lib.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 		group->meth->group_finish(group);
 
 	EC_EX_DATA_clear_free_all_data(&group->extra_data);
+
+	if (group->mont_data)
+		BN_MONT_CTX_free(group->mont_data);
 
 	if (group->generator != NULL)
 		EC_POINT_clear_free(group->generator);","{'deleted_lines': [], 'added_lines': ['', '\tif (group->mont_data)', '\t\tBN_MONT_CTX_free(group->mont_data);']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2016-7056,['CWE-385'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openssl,"
Reserve option to use BN_mod_exp_mont_consttime in ECDSA.

Submitted by Shay Gueron, Intel Corp.
RT: 3149

Reviewed-by: Rich Salz <rsalz@openssl.org>
",f54be179aa4cbbd944728771d7d59ed588158a12,https://git.openssl.org/?p=openssl.git;a=commit;h=f54be179aa4cbbd944728771d7d59ed588158a12,crypto/ecdsa/ecs_ossl.c,ecdsa_sign_setup,"static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
BIGNUM **kinvp, BIGNUM **rp,
const unsigned char *dgst, int dlen)
{
BN_CTX   *ctx = NULL;
BIGNUM *k = NULL, *r = NULL, *order = NULL, *X = NULL;
EC_POINT *tmp_point=NULL;
const EC_GROUP *group;
int  ret = 0;
if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);
return 0;
}
if (ctx_in == NULL) 
{
if ((ctx = BN_CTX_new()) == NULL)
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);
return 0;
}
}
else
ctx = ctx_in;
k     = BN_new();
r     = BN_new();
order = BN_new();
X     = BN_new();
if (!k || !r || !order || !X)
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
goto err;
}
if ((tmp_point = EC_POINT_new(group)) == NULL)
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
goto err;
}
if (!EC_GROUP_get_order(group, order, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
goto err;
}
#ifdef OPENSSL_FIPS
if (!fips_check_ec_prng(eckey))
goto err;
#endif
do
{
do
#ifndef OPENSSL_NO_SHA512
if (dgst != NULL)
{
if (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),
dgst, dlen, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,
ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);
goto err;
}
}
else
#endif
{
if (!BN_rand_range(k, order))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,
ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);
goto err;
}
}
while (BN_is_zero(k));
if (!BN_add(k, k, order)) goto err;
if (BN_num_bits(k) <= BN_num_bits(order))
if (!BN_add(k, k, order)) goto err;
if (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
goto err;
}
if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)
{
if (!EC_POINT_get_affine_coordinates_GFp(group,
tmp_point, X, NULL, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);
goto err;
}
}
#ifndef OPENSSL_NO_EC2M
else 
{
if (!EC_POINT_get_affine_coordinates_GF2m(group,
tmp_point, X, NULL, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);
goto err;
}
}
#endif
if (!BN_nnmod(r, X, order, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
goto err;
}
}
while (BN_is_zero(r));
if (!BN_mod_inverse(k, k, order, ctx))
{
ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
goto err;
}
if (*rp != NULL)
BN_clear_free(*rp);
if (*kinvp != NULL) 
BN_clear_free(*kinvp);
*rp    = r;
*kinvp = k;
ret = 1;
err:
if (!ret)
{
if (k != NULL) BN_clear_free(k);
if (r != NULL) BN_clear_free(r);
}
if (ctx_in == NULL) 
BN_CTX_free(ctx);
if (order != NULL)
BN_free(order);
if (tmp_point != NULL) 
EC_POINT_free(tmp_point);
if (X)
BN_clear_free(X);
return(ret);
}","static int ecdsa_sign_setup(EC_KEY *VAR_0, BN_CTX *VAR_1,
BIGNUM **VAR_2, BIGNUM **VAR_3,
const unsigned char *VAR_4, int VAR_5)
{
BN_CTX   *VAR_6 = NULL;
BIGNUM *VAR_7 = NULL, *VAR_8 = NULL, *VAR_9 = NULL, *VAR_10 = NULL;
EC_POINT *VAR_11=NULL;
const EC_GROUP *VAR_12;
int  VAR_13 = 0;
if (VAR_0 == NULL || (VAR_12 = EC_KEY_get0_group(VAR_0)) == NULL)
{
ECDSAerr(VAR_14, VAR_15);
return 0;
}
if (VAR_1 == NULL) 
{
if ((VAR_6 = BN_CTX_new()) == NULL)
{
ECDSAerr(VAR_14,VAR_16);
return 0;
}
}
else
VAR_6 = VAR_1;
VAR_7     = BN_new();
VAR_8     = BN_new();
VAR_9 = BN_new();
VAR_10     = BN_new();
if (!VAR_7 || !VAR_8 || !VAR_9 || !VAR_10)
{
ECDSAerr(VAR_14, VAR_16);
goto err;
}
if ((VAR_11 = EC_POINT_new(VAR_12)) == NULL)
{
ECDSAerr(VAR_14, VAR_17);
goto err;
}
if (!EC_GROUP_get_order(VAR_12, VAR_9, VAR_6))
{
ECDSAerr(VAR_14, VAR_17);
goto err;
}
#ifdef VAR_18
if (!fips_check_ec_prng(VAR_0))
goto err;
#endif
do
{
do
#ifndef VAR_19
if (VAR_4 != NULL)
{
if (!BN_generate_dsa_nonce(VAR_7, VAR_9, EC_KEY_get0_private_key(VAR_0),
VAR_4, VAR_5, VAR_6))
{
ECDSAerr(VAR_14,
VAR_20);
goto err;
}
}
else
#endif
{
if (!BN_rand_range(VAR_7, VAR_9))
{
ECDSAerr(VAR_14,
VAR_20);
goto err;
}
}
while (BN_is_zero(VAR_7));
if (!BN_add(VAR_7, VAR_7, VAR_9)) goto err;
if (BN_num_bits(VAR_7) <= BN_num_bits(VAR_9))
if (!BN_add(VAR_7, VAR_7, VAR_9)) goto err;
if (!EC_POINT_mul(VAR_12, VAR_11, VAR_7, NULL, NULL, VAR_6))
{
ECDSAerr(VAR_14, VAR_17);
goto err;
}
if (EC_METHOD_get_field_type(EC_GROUP_method_of(VAR_12)) == VAR_21)
{
if (!EC_POINT_get_affine_coordinates_GFp(VAR_12,
VAR_11, VAR_10, NULL, VAR_6))
{
ECDSAerr(VAR_14,VAR_17);
goto err;
}
}
#ifndef VAR_22
else 
{
if (!EC_POINT_get_affine_coordinates_GF2m(VAR_12,
VAR_11, VAR_10, NULL, VAR_6))
{
ECDSAerr(VAR_14,VAR_17);
goto err;
}
}
#endif
if (!BN_nnmod(VAR_8, VAR_10, VAR_9, VAR_6))
{
ECDSAerr(VAR_14, VAR_23);
goto err;
}
}
while (BN_is_zero(VAR_8));
if (!BN_mod_inverse(VAR_7, VAR_7, VAR_9, VAR_6))
{
ECDSAerr(VAR_14, VAR_23);
goto err;
}
if (*VAR_3 != NULL)
BN_clear_free(*VAR_3);
if (*VAR_2 != NULL) 
BN_clear_free(*VAR_2);
*VAR_3    = VAR_8;
*VAR_2 = VAR_7;
VAR_13 = 1;
err:
if (!VAR_13)
{
if (VAR_7 != NULL) BN_clear_free(VAR_7);
if (VAR_8 != NULL) BN_clear_free(VAR_8);
}
if (VAR_1 == NULL) 
BN_CTX_free(VAR_6);
if (VAR_9 != NULL)
BN_free(VAR_9);
if (VAR_11 != NULL) 
EC_POINT_free(VAR_11);
if (VAR_10)
BN_clear_free(VAR_10);
return(VAR_13);
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ecs_ossl.c/vul/before/0.json,"static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
					BIGNUM **kinvp, BIGNUM **rp,
					const unsigned char *dgst, int dlen)
{
	BN_CTX   *ctx = NULL;
	BIGNUM	 *k = NULL, *r = NULL, *order = NULL, *X = NULL;
	EC_POINT *tmp_point=NULL;
	const EC_GROUP *group;
	int 	 ret = 0;

	if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)
	{
		ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}

	if (ctx_in == NULL) 
	{
		if ((ctx = BN_CTX_new()) == NULL)
		{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);
			return 0;
		}
	}
	else
		ctx = ctx_in;

	k     = BN_new();	/* this value is later returned in *kinvp */
	r     = BN_new();	/* this value is later returned in *rp    */
	order = BN_new();
	X     = BN_new();
	if (!k || !r || !order || !X)
	{
		ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if ((tmp_point = EC_POINT_new(group)) == NULL)
	{
		ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
		goto err;
	}
	if (!EC_GROUP_get_order(group, order, ctx))
	{
		ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
		goto err;
	}

#ifdef OPENSSL_FIPS
	if (!fips_check_ec_prng(eckey))
		goto err;
#endif
	
	do
	{
		/* get random k */	
		do
#ifndef OPENSSL_NO_SHA512
			if (dgst != NULL)
			{
				if (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),
							   dgst, dlen, ctx))
					{
					ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,
						 ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);
					goto err;
					}
			}
			else
#endif
			{
				if (!BN_rand_range(k, order))
				{
					ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,
						 ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);
					goto err;
				}
			}
		while (BN_is_zero(k));

		/* We do not want timing information to leak the length of k,
		 * so we compute G*k using an equivalent scalar of fixed
		 * bit-length. */

		if (!BN_add(k, k, order)) goto err;
		if (BN_num_bits(k) <= BN_num_bits(order))
			if (!BN_add(k, k, order)) goto err;

		/* compute r the x-coordinate of generator * k */
		if (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))
		{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
			goto err;
		}
		if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)
		{
			if (!EC_POINT_get_affine_coordinates_GFp(group,
				tmp_point, X, NULL, ctx))
			{
				ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);
				goto err;
			}
		}
#ifndef OPENSSL_NO_EC2M
		else /* NID_X9_62_characteristic_two_field */
		{
			if (!EC_POINT_get_affine_coordinates_GF2m(group,
				tmp_point, X, NULL, ctx))
			{
				ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);
				goto err;
			}
		}
#endif
		if (!BN_nnmod(r, X, order, ctx))
		{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
			goto err;
		}
	}
	while (BN_is_zero(r));

	/* compute the inverse of k */
	if (EC_GROUP_get_mont_data(group) != NULL)
		{
		/* We want inverse in constant time, therefore we utilize the
		 * fact order must be prime and use Fermats Little Theorem
		 * instead. */
		if (!BN_set_word(X, 2) )
			{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
			goto err;
			}
		if (!BN_mod_sub(X, order, X, order, ctx))
			{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
			goto err;
			}
		BN_set_flags(X, BN_FLG_CONSTTIME);
		if (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))
			{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
			goto err;
			}
		}
	else
		{
		if (!BN_mod_inverse(k, k, order, ctx))
			{
			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
			goto err;	
			}
		}

	/* clear old values if necessary */
	if (*rp != NULL)
		BN_clear_free(*rp);
	if (*kinvp != NULL) 
		BN_clear_free(*kinvp);
	/* save the pre-computed values  */
	*rp    = r;
	*kinvp = k;
	ret = 1;
err:
	if (!ret)
	{
		if (k != NULL) BN_clear_free(k);
		if (r != NULL) BN_clear_free(r);
	}
	if (ctx_in == NULL) 
		BN_CTX_free(ctx);
	if (order != NULL)
		BN_free(order);
	if (tmp_point != NULL) 
		EC_POINT_free(tmp_point);
	if (X)
		BN_clear_free(X);
	return(ret);
}","static int ecdsa_sign_setup(EC_KEY *VAR_0, BN_CTX *VAR_1,
					BIGNUM **VAR_2, BIGNUM **VAR_3,
					const unsigned char *VAR_4, int VAR_5)
{
	BN_CTX   *VAR_6 = NULL;
	BIGNUM	 *VAR_7 = NULL, *VAR_8 = NULL, *VAR_9 = NULL, *VAR_10 = NULL;
	EC_POINT *VAR_11=NULL;
	const EC_GROUP *VAR_12;
	int 	 VAR_13 = 0;

	if (VAR_0 == NULL || (VAR_12 = EC_KEY_get0_group(VAR_0)) == NULL)
	{
		ECDSAerr(VAR_14, VAR_15);
		return 0;
	}

	if (VAR_1 == NULL) 
	{
		if ((VAR_6 = BN_CTX_new()) == NULL)
		{
			ECDSAerr(VAR_14,VAR_16);
			return 0;
		}
	}
	else
		VAR_6 = VAR_1;

	VAR_7     = BN_new();	/* COMMENT_0 */
	VAR_8     = BN_new();	/* COMMENT_1 */
	VAR_9 = BN_new();
	VAR_10     = BN_new();
	if (!VAR_7 || !VAR_8 || !VAR_9 || !VAR_10)
	{
		ECDSAerr(VAR_14, VAR_16);
		goto err;
	}
	if ((VAR_11 = EC_POINT_new(VAR_12)) == NULL)
	{
		ECDSAerr(VAR_14, VAR_17);
		goto err;
	}
	if (!EC_GROUP_get_order(VAR_12, VAR_9, VAR_6))
	{
		ECDSAerr(VAR_14, VAR_17);
		goto err;
	}

#ifdef VAR_18
	if (!fips_check_ec_prng(VAR_0))
		goto err;
#endif
	
	do
	{
		/* COMMENT_2 */	
		do
#ifndef VAR_19
			if (VAR_4 != NULL)
			{
				if (!BN_generate_dsa_nonce(VAR_7, VAR_9, EC_KEY_get0_private_key(VAR_0),
							   VAR_4, VAR_5, VAR_6))
					{
					ECDSAerr(VAR_14,
						 VAR_20);
					goto err;
					}
			}
			else
#endif
			{
				if (!BN_rand_range(VAR_7, VAR_9))
				{
					ECDSAerr(VAR_14,
						 VAR_20);
					goto err;
				}
			}
		while (BN_is_zero(VAR_7));

		/* COMMENT_3 */
                                                          
                   

		if (!BN_add(VAR_7, VAR_7, VAR_9)) goto err;
		if (BN_num_bits(VAR_7) <= BN_num_bits(VAR_9))
			if (!BN_add(VAR_7, VAR_7, VAR_9)) goto err;

		/* COMMENT_6 */
		if (!EC_POINT_mul(VAR_12, VAR_11, VAR_7, NULL, NULL, VAR_6))
		{
			ECDSAerr(VAR_14, VAR_17);
			goto err;
		}
		if (EC_METHOD_get_field_type(EC_GROUP_method_of(VAR_12)) == VAR_21)
		{
			if (!EC_POINT_get_affine_coordinates_GFp(VAR_12,
				VAR_11, VAR_10, NULL, VAR_6))
			{
				ECDSAerr(VAR_14,VAR_17);
				goto err;
			}
		}
#ifndef VAR_22
		else /* COMMENT_7 */
		{
			if (!EC_POINT_get_affine_coordinates_GF2m(VAR_12,
				VAR_11, VAR_10, NULL, VAR_6))
			{
				ECDSAerr(VAR_14,VAR_17);
				goto err;
			}
		}
#endif
		if (!BN_nnmod(VAR_8, VAR_10, VAR_9, VAR_6))
		{
			ECDSAerr(VAR_14, VAR_23);
			goto err;
		}
	}
	while (BN_is_zero(VAR_8));

	/* COMMENT_8 */
	if (EC_GROUP_get_mont_data(VAR_12) != NULL)
		{
		/* COMMENT_9 */
                                                            
                
		if (!BN_set_word(VAR_10, 2) )
			{
			ECDSAerr(VAR_14, VAR_23);
			goto err;
			}
		if (!BN_mod_sub(VAR_10, VAR_9, VAR_10, VAR_9, VAR_6))
			{
			ECDSAerr(VAR_14, VAR_23);
			goto err;
			}
		BN_set_flags(VAR_10, VAR_24);
		if (!BN_mod_exp_mont_consttime(VAR_7, VAR_7, VAR_10, VAR_9, VAR_6, EC_GROUP_get_mont_data(VAR_12)))
			{
			ECDSAerr(VAR_14, VAR_23);
			goto err;
			}
		}
	else
		{
		if (!BN_mod_inverse(VAR_7, VAR_7, VAR_9, VAR_6))
			{
			ECDSAerr(VAR_14, VAR_23);
			goto err;	
			}
		}

	/* COMMENT_12 */
	if (*VAR_3 != NULL)
		BN_clear_free(*VAR_3);
	if (*VAR_2 != NULL) 
		BN_clear_free(*VAR_2);
	/* COMMENT_13 */
	*VAR_3    = VAR_8;
	*VAR_2 = VAR_7;
	VAR_13 = 1;
err:
	if (!VAR_13)
	{
		if (VAR_7 != NULL) BN_clear_free(VAR_7);
		if (VAR_8 != NULL) BN_clear_free(VAR_8);
	}
	if (VAR_1 == NULL) 
		BN_CTX_free(VAR_6);
	if (VAR_9 != NULL)
		BN_free(VAR_9);
	if (VAR_11 != NULL) 
		EC_POINT_free(VAR_11);
	if (VAR_10)
		BN_clear_free(VAR_10);
	return(VAR_13);
}",openssl/f54be179aa4cbbd944728771d7d59ed588158a12/ecs_ossl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,11 +120,37 @@
 	while (BN_is_zero(r));
 
 	/* compute the inverse of k */
-	if (!BN_mod_inverse(k, k, order, ctx))
-	{
-		ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
-		goto err;	
-	}
+	if (EC_GROUP_get_mont_data(group) != NULL)
+		{
+		/* We want inverse in constant time, therefore we utilize the
+		 * fact order must be prime and use Fermats Little Theorem
+		 * instead. */
+		if (!BN_set_word(X, 2) )
+			{
+			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+			goto err;
+			}
+		if (!BN_mod_sub(X, order, X, order, ctx))
+			{
+			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+			goto err;
+			}
+		BN_set_flags(X, BN_FLG_CONSTTIME);
+		if (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))
+			{
+			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+			goto err;
+			}
+		}
+	else
+		{
+		if (!BN_mod_inverse(k, k, order, ctx))
+			{
+			ECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+			goto err;	
+			}
+		}
+
 	/* clear old values if necessary */
 	if (*rp != NULL)
 		BN_clear_free(*rp);","{'deleted_lines': ['\tif (!BN_mod_inverse(k, k, order, ctx))', '\t{', '\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);', '\t\tgoto err;\t', '\t}'], 'added_lines': ['\tif (EC_GROUP_get_mont_data(group) != NULL)', '\t\t{', '\t\t/* We want inverse in constant time, therefore we utilize the', '\t\t * fact order must be prime and use Fermats Little Theorem', '\t\t * instead. */', '\t\tif (!BN_set_word(X, 2) )', '\t\t\t{', '\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);', '\t\t\tgoto err;', '\t\t\t}', '\t\tif (!BN_mod_sub(X, order, X, order, ctx))', '\t\t\t{', '\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);', '\t\t\tgoto err;', '\t\t\t}', '\t\tBN_set_flags(X, BN_FLG_CONSTTIME);', '\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))', '\t\t\t{', '\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);', '\t\t\tgoto err;', '\t\t\t}', '\t\t}', '\telse', '\t\t{', '\t\tif (!BN_mod_inverse(k, k, order, ctx))', '\t\t\t{', '\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);', '\t\t\tgoto err;\t', '\t\t\t}', '\t\t}', '']}",True,A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.,5.5,MEDIUM,1,valid,,5
CVE-2018-9476,['CWE-416'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE AVRC: Copy browse.p_browse_data in btif_av_event_deep_copy

p_msg_src->browse.p_browse_data is not copied, but used after the
original pointer is freed

Bug: 109699112
Test: manual
Change-Id: I1d014eb9a8911da6913173a9b11218bf1c89e16e
(cherry picked from commit 1d9a58768e6573899c7e80c2b3f52e22f2d8f58b)
",dd28d8ddf2985d654781770c691c60b45d7f32b4,https://android.googlesource.com/platform/system/bt/+/dd28d8ddf2985d654781770c691c60b45d7f32b4,btif/src/btif_av.cc,btif_av_event_free_data,"static void btif_av_event_free_data(btif_sm_event_t event, void* p_data) {
switch (event) {
case BTA_AV_META_MSG_EVT: {
tBTA_AV* av = (tBTA_AV*)p_data;
osi_free_and_reset((void**)&av->meta_msg.p_data);
if (av->meta_msg.p_msg) {
if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) {
osi_free(av->meta_msg.p_msg->vendor.p_vendor_data);
}
osi_free_and_reset((void**)&av->meta_msg.p_msg);
}
} break;
default:
break;
}
}","static void btif_av_event_free_data(btif_sm_event_t VAR_0, void* VAR_1) {
switch (VAR_0) {
case VAR_2: {
tBTA_AV* VAR_3 = (tBTA_AV*)VAR_1;
osi_free_and_reset((void**)&VAR_3->meta_msg.p_data);
if (VAR_3->meta_msg.p_msg) {
if (VAR_3->meta_msg.p_msg->hdr.opcode == VAR_4) {
osi_free(VAR_3->meta_msg.p_msg->vendor.p_vendor_data);
}
osi_free_and_reset((void**)&VAR_3->meta_msg.p_msg);
}
} break;
default:
break;
}
}",android/dd28d8ddf2985d654781770c691c60b45d7f32b4/btif_av.cc/vul/before/0.json,"static void btif_av_event_free_data(btif_sm_event_t event, void* p_data) {
  switch (event) {
    case BTA_AV_META_MSG_EVT: {
      tBTA_AV* av = (tBTA_AV*)p_data;
      osi_free_and_reset((void**)&av->meta_msg.p_data);

      if (av->meta_msg.p_msg) {
        if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) {
          osi_free(av->meta_msg.p_msg->vendor.p_vendor_data);
        }
        if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_BROWSE) {
          osi_free(av->meta_msg.p_msg->browse.p_browse_data);
        }
        osi_free_and_reset((void**)&av->meta_msg.p_msg);
      }
    } break;

    default:
      break;
  }
}","static void btif_av_event_free_data(btif_sm_event_t VAR_0, void* VAR_1) {
  switch (VAR_0) {
    case VAR_2: {
      tBTA_AV* VAR_3 = (tBTA_AV*)VAR_1;
      osi_free_and_reset((void**)&VAR_3->meta_msg.p_data);

      if (VAR_3->meta_msg.p_msg) {
        if (VAR_3->meta_msg.p_msg->hdr.opcode == VAR_4) {
          osi_free(VAR_3->meta_msg.p_msg->vendor.p_vendor_data);
        }
        if (VAR_3->meta_msg.p_msg->hdr.opcode == VAR_5) {
          osi_free(VAR_3->meta_msg.p_msg->browse.p_browse_data);
        }
        osi_free_and_reset((void**)&VAR_3->meta_msg.p_msg);
      }
    } break;

    default:
      break;
  }
}",android/dd28d8ddf2985d654781770c691c60b45d7f32b4/btif_av.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
         if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) {
           osi_free(av->meta_msg.p_msg->vendor.p_vendor_data);
         }
+        if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_BROWSE) {
+          osi_free(av->meta_msg.p_msg->browse.p_browse_data);
+        }
         osi_free_and_reset((void**)&av->meta_msg.p_msg);
       }
     } break;","{'deleted_lines': [], 'added_lines': ['        if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_BROWSE) {', '          osi_free(av->meta_msg.p_msg->browse.p_browse_data);', '        }']}",True,"In avrc_pars_browsing_cmd of avrc_pars_tg.cc, there is a possible use-after-free due to improper locking. This could lead to remote escalation of privilege in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-8.0 Android-8.1 Android ID: A-109699112",9.8,CRITICAL,3,valid,,5
CVE-2018-9476,['CWE-416'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"DO NOT MERGE AVRC: Copy browse.p_browse_data in btif_av_event_deep_copy

p_msg_src->browse.p_browse_data is not copied, but used after the
original pointer is freed

Bug: 109699112
Test: manual
Change-Id: I1d014eb9a8911da6913173a9b11218bf1c89e16e
(cherry picked from commit 1d9a58768e6573899c7e80c2b3f52e22f2d8f58b)
",dd28d8ddf2985d654781770c691c60b45d7f32b4,https://android.googlesource.com/platform/system/bt/+/dd28d8ddf2985d654781770c691c60b45d7f32b4,btif/src/btif_av.cc,btif_av_event_deep_copy,"void btif_av_event_deep_copy(uint16_t event, char* p_dest, char* p_src) {
BTIF_TRACE_DEBUG(""%s"", __func__);
tBTA_AV* av_src = (tBTA_AV*)p_src;
tBTA_AV* av_dest = (tBTA_AV*)p_dest;
maybe_non_aligned_memcpy(av_dest, av_src, sizeof(*av_src));
switch (event) {
case BTA_AV_META_MSG_EVT:
if (av_src->meta_msg.p_data && av_src->meta_msg.len) {
av_dest->meta_msg.p_data = (uint8_t*)osi_calloc(av_src->meta_msg.len);
memcpy(av_dest->meta_msg.p_data, av_src->meta_msg.p_data,
av_src->meta_msg.len);
}
if (av_src->meta_msg.p_msg) {
av_dest->meta_msg.p_msg = (tAVRC_MSG*)osi_calloc(sizeof(tAVRC_MSG));
memcpy(av_dest->meta_msg.p_msg, av_src->meta_msg.p_msg,
sizeof(tAVRC_MSG));
tAVRC_MSG* p_msg_src = av_src->meta_msg.p_msg;
tAVRC_MSG* p_msg_dest = av_dest->meta_msg.p_msg;
if ((p_msg_src->hdr.opcode == AVRC_OP_VENDOR) &&
(p_msg_src->vendor.p_vendor_data && p_msg_src->vendor.vendor_len)) {
p_msg_dest->vendor.p_vendor_data =
(uint8_t*)osi_calloc(p_msg_src->vendor.vendor_len);
memcpy(p_msg_dest->vendor.p_vendor_data,
p_msg_src->vendor.p_vendor_data, p_msg_src->vendor.vendor_len);
}
}
break;
default:
break;
}
}","void btif_av_event_deep_copy(uint16_t VAR_0, char* VAR_1, char* VAR_2) {
BTIF_TRACE_DEBUG(""%s"", VAR_3);
tBTA_AV* VAR_4 = (tBTA_AV*)VAR_2;
tBTA_AV* VAR_5 = (tBTA_AV*)VAR_1;
maybe_non_aligned_memcpy(VAR_5, VAR_4, sizeof(*VAR_4));
switch (VAR_0) {
case VAR_6:
if (VAR_4->meta_msg.p_data && VAR_4->meta_msg.len) {
VAR_5->meta_msg.p_data = (uint8_t*)osi_calloc(VAR_4->meta_msg.len);
memcpy(VAR_5->meta_msg.p_data, VAR_4->meta_msg.p_data,
VAR_4->meta_msg.len);
}
if (VAR_4->meta_msg.p_msg) {
VAR_5->meta_msg.p_msg = (tAVRC_MSG*)osi_calloc(sizeof(tAVRC_MSG));
memcpy(VAR_5->meta_msg.p_msg, VAR_4->meta_msg.p_msg,
sizeof(tAVRC_MSG));
tAVRC_MSG* VAR_7 = VAR_4->meta_msg.p_msg;
tAVRC_MSG* VAR_8 = VAR_5->meta_msg.p_msg;
if ((VAR_7->hdr.opcode == VAR_9) &&
(VAR_7->vendor.p_vendor_data && VAR_7->vendor.vendor_len)) {
VAR_8->vendor.p_vendor_data =
(uint8_t*)osi_calloc(VAR_7->vendor.vendor_len);
memcpy(VAR_8->vendor.p_vendor_data,
VAR_7->vendor.p_vendor_data, VAR_7->vendor.vendor_len);
}
}
break;
default:
break;
}
}",android/dd28d8ddf2985d654781770c691c60b45d7f32b4/btif_av.cc/vul/before/1.json,"void btif_av_event_deep_copy(uint16_t event, char* p_dest, char* p_src) {
  BTIF_TRACE_DEBUG(""%s"", __func__);
  tBTA_AV* av_src = (tBTA_AV*)p_src;
  tBTA_AV* av_dest = (tBTA_AV*)p_dest;

  // First copy the structure
  maybe_non_aligned_memcpy(av_dest, av_src, sizeof(*av_src));
  switch (event) {
    case BTA_AV_META_MSG_EVT:
      if (av_src->meta_msg.p_data && av_src->meta_msg.len) {
        av_dest->meta_msg.p_data = (uint8_t*)osi_calloc(av_src->meta_msg.len);
        memcpy(av_dest->meta_msg.p_data, av_src->meta_msg.p_data,
               av_src->meta_msg.len);
      }

      if (av_src->meta_msg.p_msg) {
        av_dest->meta_msg.p_msg = (tAVRC_MSG*)osi_calloc(sizeof(tAVRC_MSG));
        memcpy(av_dest->meta_msg.p_msg, av_src->meta_msg.p_msg,
               sizeof(tAVRC_MSG));

        tAVRC_MSG* p_msg_src = av_src->meta_msg.p_msg;
        tAVRC_MSG* p_msg_dest = av_dest->meta_msg.p_msg;

        if ((p_msg_src->hdr.opcode == AVRC_OP_VENDOR) &&
            (p_msg_src->vendor.p_vendor_data && p_msg_src->vendor.vendor_len)) {
          p_msg_dest->vendor.p_vendor_data =
              (uint8_t*)osi_calloc(p_msg_src->vendor.vendor_len);
          memcpy(p_msg_dest->vendor.p_vendor_data,
                 p_msg_src->vendor.p_vendor_data, p_msg_src->vendor.vendor_len);
        }
        if ((p_msg_src->hdr.opcode == AVRC_OP_BROWSE) &&
            p_msg_src->browse.p_browse_data && p_msg_src->browse.browse_len) {
          p_msg_dest->browse.p_browse_data =
              (uint8_t*)osi_calloc(p_msg_src->browse.browse_len);
          memcpy(p_msg_dest->browse.p_browse_data,
                 p_msg_src->browse.p_browse_data, p_msg_src->browse.browse_len);
          android_errorWriteLog(0x534e4554, ""109699112"");
        }
      }
      break;

    default:
      break;
  }
}","void btif_av_event_deep_copy(uint16_t VAR_0, char* VAR_1, char* VAR_2) {
  BTIF_TRACE_DEBUG(""%s"", VAR_3);
  tBTA_AV* VAR_4 = (tBTA_AV*)VAR_2;
  tBTA_AV* VAR_5 = (tBTA_AV*)VAR_1;

  /* COMMENT_0 */
  maybe_non_aligned_memcpy(VAR_5, VAR_4, sizeof(*VAR_4));
  switch (VAR_0) {
    case VAR_6:
      if (VAR_4->meta_msg.p_data && VAR_4->meta_msg.len) {
        VAR_5->meta_msg.p_data = (uint8_t*)osi_calloc(VAR_4->meta_msg.len);
        memcpy(VAR_5->meta_msg.p_data, VAR_4->meta_msg.p_data,
               VAR_4->meta_msg.len);
      }

      if (VAR_4->meta_msg.p_msg) {
        VAR_5->meta_msg.p_msg = (tAVRC_MSG*)osi_calloc(sizeof(tAVRC_MSG));
        memcpy(VAR_5->meta_msg.p_msg, VAR_4->meta_msg.p_msg,
               sizeof(tAVRC_MSG));

        tAVRC_MSG* VAR_7 = VAR_4->meta_msg.p_msg;
        tAVRC_MSG* VAR_8 = VAR_5->meta_msg.p_msg;

        if ((VAR_7->hdr.opcode == VAR_9) &&
            (VAR_7->vendor.p_vendor_data && VAR_7->vendor.vendor_len)) {
          VAR_8->vendor.p_vendor_data =
              (uint8_t*)osi_calloc(VAR_7->vendor.vendor_len);
          memcpy(VAR_8->vendor.p_vendor_data,
                 VAR_7->vendor.p_vendor_data, VAR_7->vendor.vendor_len);
        }
        if ((VAR_7->hdr.opcode == VAR_10) &&
            VAR_7->browse.p_browse_data && VAR_7->browse.browse_len) {
          VAR_8->browse.p_browse_data =
              (uint8_t*)osi_calloc(VAR_7->browse.browse_len);
          memcpy(VAR_8->browse.p_browse_data,
                 VAR_7->browse.p_browse_data, VAR_7->browse.browse_len);
          android_errorWriteLog(0x534e4554, ""109699112"");
        }
      }
      break;

    default:
      break;
  }
}",android/dd28d8ddf2985d654781770c691c60b45d7f32b4/btif_av.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,6 +28,14 @@
           memcpy(p_msg_dest->vendor.p_vendor_data,
                  p_msg_src->vendor.p_vendor_data, p_msg_src->vendor.vendor_len);
         }
+        if ((p_msg_src->hdr.opcode == AVRC_OP_BROWSE) &&
+            p_msg_src->browse.p_browse_data && p_msg_src->browse.browse_len) {
+          p_msg_dest->browse.p_browse_data =
+              (uint8_t*)osi_calloc(p_msg_src->browse.browse_len);
+          memcpy(p_msg_dest->browse.p_browse_data,
+                 p_msg_src->browse.p_browse_data, p_msg_src->browse.browse_len);
+          android_errorWriteLog(0x534e4554, ""109699112"");
+        }
       }
       break;
 ","{'deleted_lines': [], 'added_lines': ['        if ((p_msg_src->hdr.opcode == AVRC_OP_BROWSE) &&', '            p_msg_src->browse.p_browse_data && p_msg_src->browse.browse_len) {', '          p_msg_dest->browse.p_browse_data =', '              (uint8_t*)osi_calloc(p_msg_src->browse.browse_len);', '          memcpy(p_msg_dest->browse.p_browse_data,', '                 p_msg_src->browse.p_browse_data, p_msg_src->browse.browse_len);', '          android_errorWriteLog(0x534e4554, ""109699112"");', '        }']}",True,"In avrc_pars_browsing_cmd of avrc_pars_tg.cc, there is a possible use-after-free due to improper locking. This could lead to remote escalation of privilege in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-8.0 Android-8.1 Android ID: A-109699112",9.8,CRITICAL,3,valid,,5
CVE-2018-18897,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,poppler,,e07c8b4784234383cb5ddcf1133ea91a772506e2,https://cgit.freedesktop.org/poppler/poppler/commit/?id=e07c8b4784234383cb5ddcf1133ea91a772506e2,poppler/GfxState.cc,GfxColorSpace::setDisplayProfile,"void GfxColorSpace::setDisplayProfile(void *displayProfileA) {
displayProfile = displayProfileA;
if (displayProfile != nullptr) {
cmsHTRANSFORM transform;
unsigned int nChannels;
displayPixelType = getCMSColorSpaceType(cmsGetColorSpace(displayProfile));
nChannels = getCMSNChannels(cmsGetColorSpace(displayProfile));
cmsHPROFILE XYZProfile = cmsCreateXYZProfile();
if ((transform = cmsCreateTransform(XYZProfile, TYPE_XYZ_DBL,
displayProfile,
COLORSPACE_SH(displayPixelType) |
CHANNELS_SH(nChannels) | BYTES_SH(1),
INTENT_RELATIVE_COLORIMETRIC,LCMS_FLAGS)) == nullptr) {
error(errSyntaxWarning, -1, ""Can't create Lab transform"");
} else {
XYZ2DisplayTransform = new GfxColorTransform(transform, INTENT_RELATIVE_COLORIMETRIC, PT_XYZ, displayPixelType);
}
cmsCloseProfile(XYZProfile);
}
}","void GfxColorSpace::setDisplayProfile(void *VAR_0) {
VAR_1 = VAR_0;
if (VAR_1 != nullptr) {
cmsHTRANSFORM VAR_2;
unsigned int VAR_3;
VAR_4 = getCMSColorSpaceType(cmsGetColorSpace(VAR_1));
VAR_3 = getCMSNChannels(cmsGetColorSpace(VAR_1));
cmsHPROFILE VAR_5 = cmsCreateXYZProfile();
if ((VAR_2 = cmsCreateTransform(VAR_5, VAR_6,
VAR_1,
COLORSPACE_SH(VAR_4) |
CHANNELS_SH(VAR_3) | BYTES_SH(1),
VAR_7,VAR_8)) == nullptr) {
error(VAR_9, -1, ""Can't create Lab transform"");
} else {
VAR_10 = new GfxColorTransform(VAR_2, VAR_7, VAR_11, VAR_4);
}
cmsCloseProfile(VAR_5);
}
}",poppler/e07c8b4784234383cb5ddcf1133ea91a772506e2/GfxState.cc/vul/before/0.json,"void GfxColorSpace::setDisplayProfile(void *displayProfileA) {
  if (displayProfile != nullptr) {
    error(errInternal, -1, ""The display color profile can only be set once before any rendering is done."");
    return;
  }
  displayProfile = displayProfileA;
  if (displayProfile != nullptr) {
    cmsHTRANSFORM transform;
    unsigned int nChannels;

    displayPixelType = getCMSColorSpaceType(cmsGetColorSpace(displayProfile));
    nChannels = getCMSNChannels(cmsGetColorSpace(displayProfile));
    // create transform from XYZ
    cmsHPROFILE XYZProfile = cmsCreateXYZProfile();
    if ((transform = cmsCreateTransform(XYZProfile, TYPE_XYZ_DBL,
	   displayProfile,
	   COLORSPACE_SH(displayPixelType) |
	     CHANNELS_SH(nChannels) | BYTES_SH(1),
	  INTENT_RELATIVE_COLORIMETRIC,LCMS_FLAGS)) == nullptr) {
      error(errSyntaxWarning, -1, ""Can't create Lab transform"");
    } else {
      XYZ2DisplayTransform = new GfxColorTransform(transform, INTENT_RELATIVE_COLORIMETRIC, PT_XYZ, displayPixelType);
    }
    cmsCloseProfile(XYZProfile);
  }
}","void GfxColorSpace::setDisplayProfile(void *VAR_0) {
  if (VAR_1 != nullptr) {
    error(VAR_2, -1, ""The display color profile can only be set once before any rendering is done."");
    return;
  }
  VAR_1 = VAR_0;
  if (VAR_1 != nullptr) {
    cmsHTRANSFORM VAR_3;
    unsigned int VAR_4;

    VAR_5 = getCMSColorSpaceType(cmsGetColorSpace(VAR_1));
    VAR_4 = getCMSNChannels(cmsGetColorSpace(VAR_1));
    /* COMMENT_0 */
    cmsHPROFILE VAR_6 = cmsCreateXYZProfile();
    if ((VAR_3 = cmsCreateTransform(VAR_6, VAR_7,
	   VAR_1,
	   COLORSPACE_SH(VAR_5) |
	     CHANNELS_SH(VAR_4) | BYTES_SH(1),
	  VAR_8,VAR_9)) == nullptr) {
      error(VAR_10, -1, ""Can't create Lab transform"");
    } else {
      VAR_11 = new GfxColorTransform(VAR_3, VAR_8, VAR_12, VAR_5);
    }
    cmsCloseProfile(VAR_6);
  }
}",poppler/e07c8b4784234383cb5ddcf1133ea91a772506e2/GfxState.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,8 @@
 void GfxColorSpace::setDisplayProfile(void *displayProfileA) {
+  if (displayProfile != nullptr) {
+    error(errInternal, -1, ""The display color profile can only be set once before any rendering is done."");
+    return;
+  }
   displayProfile = displayProfileA;
   if (displayProfile != nullptr) {
     cmsHTRANSFORM transform;","{'deleted_lines': [], 'added_lines': ['  if (displayProfile != nullptr) {', '    error(errInternal, -1, ""The display color profile can only be set once before any rendering is done."");', '    return;', '  }']}",True,"An issue was discovered in Poppler 0.71.0. There is a memory leak in GfxColorSpace::setDisplayProfile in GfxState.cc, as demonstrated by pdftocairo.",6.5,MEDIUM,1,valid,,5
CVE-2018-18897,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,poppler,,e07c8b4784234383cb5ddcf1133ea91a772506e2,https://cgit.freedesktop.org/poppler/poppler/commit/?id=e07c8b4784234383cb5ddcf1133ea91a772506e2,poppler/GfxState.cc,GfxColorSpace::setDisplayProfileName,"void GfxColorSpace::setDisplayProfileName(GooString *name) {
displayProfileName = name->copy();
}","void GfxColorSpace::setDisplayProfileName(GooString *VAR_0) {
VAR_1 = VAR_0->copy();
}",poppler/e07c8b4784234383cb5ddcf1133ea91a772506e2/GfxState.cc/vul/before/1.json,"void GfxColorSpace::setDisplayProfileName(GooString *name) {
  if (displayProfile != nullptr) {
    error(errInternal, -1, ""The display color profile can only be set before any rendering is done."");
    return;
  }
  delete displayProfileName;
  displayProfileName = name->copy();
}","void GfxColorSpace::setDisplayProfileName(GooString *VAR_0) {
  if (VAR_1 != nullptr) {
    error(VAR_2, -1, ""The display color profile can only be set before any rendering is done."");
    return;
  }
  delete VAR_3;
  VAR_3 = VAR_0->copy();
}",poppler/e07c8b4784234383cb5ddcf1133ea91a772506e2/GfxState.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,3 +1,8 @@
 void GfxColorSpace::setDisplayProfileName(GooString *name) {
+  if (displayProfile != nullptr) {
+    error(errInternal, -1, ""The display color profile can only be set before any rendering is done."");
+    return;
+  }
+  delete displayProfileName;
   displayProfileName = name->copy();
 }","{'deleted_lines': [], 'added_lines': ['  if (displayProfile != nullptr) {', '    error(errInternal, -1, ""The display color profile can only be set before any rendering is done."");', '    return;', '  }', '  delete displayProfileName;']}",True,"An issue was discovered in Poppler 0.71.0. There is a memory leak in GfxColorSpace::setDisplayProfile in GfxState.cc, as demonstrated by pdftocairo.",6.5,MEDIUM,1,valid,,5
CVE-2018-20002,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR23952, memory leak in _bfd_generic_read_minisymbols

bfd/
	PR 23952
	* syms.c (_bfd_generic_read_minisymbols): Free syms before
	returning with zero symcount.
binutils/
	* nm.c (display_rel_file): Use xrealloc to increase minisyms
	for synthetic symbols.
",c2f5dc30afa34696f2da0081c4ac50b958ecb0e9,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=c2f5dc30afa34696f2da0081c4ac50b958ecb0e9,bfd/syms.c,_bfd_generic_read_minisymbols,"long
_bfd_generic_read_minisymbols (bfd *abfd,
bfd_boolean dynamic,
void **minisymsp,
unsigned int *sizep)
{
long storage;
asymbol **syms = NULL;
long symcount;
if (dynamic)
storage = bfd_get_dynamic_symtab_upper_bound (abfd);
else
storage = bfd_get_symtab_upper_bound (abfd);
if (storage < 0)
goto error_return;
if (storage == 0)
return 0;
syms = (asymbol **) bfd_malloc (storage);
if (syms == NULL)
goto error_return;
if (dynamic)
symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);
else
symcount = bfd_canonicalize_symtab (abfd, syms);
if (symcount < 0)
goto error_return;
*minisymsp = syms;
*sizep = sizeof (asymbol *);
return symcount;
error_return:
bfd_set_error (bfd_error_no_symbols);
if (syms != NULL)
free (syms);
return -1;
}","long
_bfd_generic_read_minisymbols (bfd *VAR_0,
bfd_boolean VAR_1,
void **VAR_2,
unsigned int *VAR_3)
{
long VAR_4;
asymbol **VAR_5 = NULL;
long VAR_6;
if (VAR_1)
VAR_4 = bfd_get_dynamic_symtab_upper_bound (VAR_0);
else
VAR_4 = bfd_get_symtab_upper_bound (VAR_0);
if (VAR_4 < 0)
goto error_return;
if (VAR_4 == 0)
return 0;
VAR_5 = (asymbol **) bfd_malloc (VAR_4);
if (VAR_5 == NULL)
goto error_return;
if (VAR_1)
VAR_6 = bfd_canonicalize_dynamic_symtab (VAR_0, VAR_5);
else
VAR_6 = bfd_canonicalize_symtab (VAR_0, VAR_5);
if (VAR_6 < 0)
goto error_return;
*VAR_2 = VAR_5;
*VAR_3 = sizeof (asymbol *);
return VAR_6;
error_return:
bfd_set_error (VAR_7);
if (VAR_5 != NULL)
free (VAR_5);
return -1;
}",binutils-gdb/c2f5dc30afa34696f2da0081c4ac50b958ecb0e9/syms.c/vul/before/0.json,"long
_bfd_generic_read_minisymbols (bfd *abfd,
			       bfd_boolean dynamic,
			       void **minisymsp,
			       unsigned int *sizep)
{
  long storage;
  asymbol **syms = NULL;
  long symcount;

  if (dynamic)
    storage = bfd_get_dynamic_symtab_upper_bound (abfd);
  else
    storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    goto error_return;
  if (storage == 0)
    return 0;

  syms = (asymbol **) bfd_malloc (storage);
  if (syms == NULL)
    goto error_return;

  if (dynamic)
    symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);
  else
    symcount = bfd_canonicalize_symtab (abfd, syms);
  if (symcount < 0)
    goto error_return;

  if (symcount == 0)
    /* We return 0 above when storage is 0.  Exit in the same state
       here, so as to not complicate callers with having to deal with
       freeing memory for zero symcount.  */
    free (syms);
  else
    {
      *minisymsp = syms;
      *sizep = sizeof (asymbol *);
    }
  return symcount;

 error_return:
  bfd_set_error (bfd_error_no_symbols);
  if (syms != NULL)
    free (syms);
  return -1;
}","long
_bfd_generic_read_minisymbols (bfd *VAR_0,
			       bfd_boolean VAR_1,
			       void **VAR_2,
			       unsigned int *VAR_3)
{
  long VAR_4;
  asymbol **VAR_5 = NULL;
  long VAR_6;

  if (VAR_1)
    VAR_4 = bfd_get_dynamic_symtab_upper_bound (VAR_0);
  else
    VAR_4 = bfd_get_symtab_upper_bound (VAR_0);
  if (VAR_4 < 0)
    goto error_return;
  if (VAR_4 == 0)
    return 0;

  VAR_5 = (asymbol **) bfd_malloc (VAR_4);
  if (VAR_5 == NULL)
    goto error_return;

  if (VAR_1)
    VAR_6 = bfd_canonicalize_dynamic_symtab (VAR_0, VAR_5);
  else
    VAR_6 = bfd_canonicalize_symtab (VAR_0, VAR_5);
  if (VAR_6 < 0)
    goto error_return;

  if (VAR_6 == 0)
    /* COMMENT_0 */
                                                                     
                                            
    free (VAR_5);
  else
    {
      *VAR_2 = VAR_5;
      *VAR_3 = sizeof (asymbol *);
    }
  return VAR_6;

 error_return:
  bfd_set_error (VAR_7);
  if (VAR_5 != NULL)
    free (VAR_5);
  return -1;
}",binutils-gdb/c2f5dc30afa34696f2da0081c4ac50b958ecb0e9/syms.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,9 +28,16 @@
   if (symcount < 0)
     goto error_return;
 
-  *minisymsp = syms;
-  *sizep = sizeof (asymbol *);
-
+  if (symcount == 0)
+    /* We return 0 above when storage is 0.  Exit in the same state
+       here, so as to not complicate callers with having to deal with
+       freeing memory for zero symcount.  */
+    free (syms);
+  else
+    {
+      *minisymsp = syms;
+      *sizep = sizeof (asymbol *);
+    }
   return symcount;
 
  error_return:","{'deleted_lines': ['  *minisymsp = syms;', '  *sizep = sizeof (asymbol *);', ''], 'added_lines': ['  if (symcount == 0)', '    /* We return 0 above when storage is 0.  Exit in the same state', '       here, so as to not complicate callers with having to deal with', '       freeing memory for zero symcount.  */', '    free (syms);', '  else', '    {', '      *minisymsp = syms;', '      *sizep = sizeof (asymbol *);', '    }']}",True,"The _bfd_generic_read_minisymbols function in syms.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.31, has a memory leak via a crafted ELF file, leading to a denial of service (memory consumption), as demonstrated by nm.",5.5,MEDIUM,1,valid,,5
CVE-2018-20002,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR23952, memory leak in _bfd_generic_read_minisymbols

bfd/
	PR 23952
	* syms.c (_bfd_generic_read_minisymbols): Free syms before
	returning with zero symcount.
binutils/
	* nm.c (display_rel_file): Use xrealloc to increase minisyms
	for synthetic symbols.
",c2f5dc30afa34696f2da0081c4ac50b958ecb0e9,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=c2f5dc30afa34696f2da0081c4ac50b958ecb0e9,binutils/nm.c,display_rel_file,"static void
display_rel_file (bfd *abfd, bfd *archive_bfd)
{
long symcount;
void *minisyms;
unsigned int size;
struct size_sym *symsizes;
asymbol *synthsyms = NULL;
if (! dynamic)
{
if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
return;
}
}
symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
if (symcount < 0)
{
if (dynamic && bfd_get_error () == bfd_error_no_symbols)
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
return;
}
bfd_fatal (bfd_get_filename (abfd));
}
if (symcount == 0)
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
return;
}
if (show_synthetic && size == sizeof (asymbol *))
{
asymbol **static_syms = NULL;
asymbol **dyn_syms = NULL;
long static_count = 0;
long dyn_count = 0;
long synth_count;
if (dynamic)
{
dyn_count = symcount;
dyn_syms = (asymbol **) minisyms;
}
else
{
long storage = bfd_get_dynamic_symtab_upper_bound (abfd);
static_count = symcount;
static_syms = (asymbol **) minisyms;
if (storage > 0)
{
dyn_syms = (asymbol **) xmalloc (storage);
dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);
if (dyn_count < 0)
bfd_fatal (bfd_get_filename (abfd));
}
}
synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,
dyn_count, dyn_syms, &synthsyms);
if (synth_count > 0)
{
asymbol **symp;
void *new_mini;
long i;
new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));
symp = (asymbol **) new_mini;
memcpy (symp, minisyms, symcount * sizeof (*symp));
symp += symcount;
for (i = 0; i < synth_count; i++)
*symp++ = synthsyms + i;
*symp = 0;
minisyms = new_mini;
symcount += synth_count;
}
}
symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);
symsizes = NULL;
if (! no_sort)
{
sort_bfd = abfd;
sort_dynamic = dynamic;
sort_x = bfd_make_empty_symbol (abfd);
sort_y = bfd_make_empty_symbol (abfd);
if (sort_x == NULL || sort_y == NULL)
bfd_fatal (bfd_get_filename (abfd));
if (! sort_by_size)
qsort (minisyms, symcount, size,
sorters[sort_numerically][reverse_sort]);
else
symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
size, &symsizes);
}
if (! sort_by_size)
print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
else
print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);
if (synthsyms)
free (synthsyms);
free (minisyms);
free (symsizes);
}","static void
display_rel_file (bfd *VAR_0, bfd *VAR_1)
{
long VAR_2;
void *VAR_3;
unsigned int VAR_4;
struct size_sym *VAR_5;
asymbol *VAR_6 = NULL;
if (! VAR_7)
{
if (!(bfd_get_file_flags (VAR_0) & VAR_8))
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
return;
}
}
VAR_2 = bfd_read_minisymbols (VAR_0, VAR_7, &VAR_3, &VAR_4);
if (VAR_2 < 0)
{
if (VAR_7 && bfd_get_error () == VAR_9)
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
return;
}
bfd_fatal (bfd_get_filename (VAR_0));
}
if (VAR_2 == 0)
{
non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
return;
}
if (VAR_10 && VAR_4 == sizeof (asymbol *))
{
asymbol **VAR_11 = NULL;
asymbol **VAR_12 = NULL;
long VAR_13 = 0;
long VAR_14 = 0;
long VAR_15;
if (VAR_7)
{
VAR_14 = VAR_2;
VAR_12 = (asymbol **) VAR_3;
}
else
{
long VAR_16 = bfd_get_dynamic_symtab_upper_bound (VAR_0);
VAR_13 = VAR_2;
VAR_11 = (asymbol **) VAR_3;
if (VAR_16 > 0)
{
VAR_12 = (asymbol **) xmalloc (VAR_16);
VAR_14 = bfd_canonicalize_dynamic_symtab (VAR_0, VAR_12);
if (VAR_14 < 0)
bfd_fatal (bfd_get_filename (VAR_0));
}
}
VAR_15 = bfd_get_synthetic_symtab (VAR_0, VAR_13, VAR_11,
VAR_14, VAR_12, &VAR_6);
if (VAR_15 > 0)
{
asymbol **VAR_17;
void *VAR_18;
long VAR_19;
VAR_18 = xmalloc ((VAR_2 + VAR_15 + 1) * sizeof (*VAR_17));
VAR_17 = (asymbol **) VAR_18;
memcpy (VAR_17, VAR_3, VAR_2 * sizeof (*VAR_17));
VAR_17 += VAR_2;
for (VAR_19 = 0; VAR_19 < VAR_15; VAR_19++)
*VAR_17++ = VAR_6 + VAR_19;
*VAR_17 = 0;
VAR_3 = VAR_18;
VAR_2 += VAR_15;
}
}
VAR_2 = filter_symbols (VAR_0, VAR_7, VAR_3, VAR_2, VAR_4);
VAR_5 = NULL;
if (! VAR_20)
{
VAR_21 = VAR_0;
VAR_22 = VAR_7;
VAR_23 = bfd_make_empty_symbol (VAR_0);
VAR_24 = bfd_make_empty_symbol (VAR_0);
if (VAR_23 == NULL || VAR_24 == NULL)
bfd_fatal (bfd_get_filename (VAR_0));
if (! VAR_25)
qsort (VAR_3, VAR_2, VAR_4,
VAR_26[VAR_27][VAR_28]);
else
VAR_2 = sort_symbols_by_size (VAR_0, VAR_7, VAR_3, VAR_2,
VAR_4, &VAR_5);
}
if (! VAR_25)
print_symbols (VAR_0, VAR_7, VAR_3, VAR_2, VAR_4, VAR_1);
else
print_size_symbols (VAR_0, VAR_7, VAR_5, VAR_2, VAR_1);
if (VAR_6)
free (VAR_6);
free (VAR_3);
free (VAR_5);
}",binutils-gdb/c2f5dc30afa34696f2da0081c4ac50b958ecb0e9/nm.c/vul/before/0.json,"static void
display_rel_file (bfd *abfd, bfd *archive_bfd)
{
  long symcount;
  void *minisyms;
  unsigned int size;
  struct size_sym *symsizes;
  asymbol *synthsyms = NULL;

  if (! dynamic)
    {
      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
	{
	  non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
	  return;
	}
    }

  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
  if (symcount < 0)
    {
      if (dynamic && bfd_get_error () == bfd_error_no_symbols)
	{
	  non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
	  return;
	}

      bfd_fatal (bfd_get_filename (abfd));
    }

  if (symcount == 0)
    {
      non_fatal (_(""%s: no symbols""), bfd_get_filename (abfd));
      return;
    }

  if (show_synthetic && size == sizeof (asymbol *))
    {
      asymbol **static_syms = NULL;
      asymbol **dyn_syms = NULL;
      long static_count = 0;
      long dyn_count = 0;
      long synth_count;

      if (dynamic)
	{
	  dyn_count = symcount;
	  dyn_syms = (asymbol **) minisyms;
	}
      else
	{
	  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);

	  static_count = symcount;
	  static_syms = (asymbol **) minisyms;

	  if (storage > 0)
	    {
	      dyn_syms = (asymbol **) xmalloc (storage);
	      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);
	      if (dyn_count < 0)
		bfd_fatal (bfd_get_filename (abfd));
	    }
	}

      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,
					      dyn_count, dyn_syms, &synthsyms);
      if (synth_count > 0)
	{
	  asymbol **symp;
	  long i;

	  minisyms = xrealloc (minisyms,
			       (symcount + synth_count + 1) * sizeof (*symp));
	  symp = (asymbol **) minisyms + symcount;
	  for (i = 0; i < synth_count; i++)
	    *symp++ = synthsyms + i;
	  *symp = 0;
	  symcount += synth_count;
	}
    }

  /* Discard the symbols we don't want to print.
     It's OK to do this in place; we'll free the storage anyway
     (after printing).  */

  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);

  symsizes = NULL;
  if (! no_sort)
    {
      sort_bfd = abfd;
      sort_dynamic = dynamic;
      sort_x = bfd_make_empty_symbol (abfd);
      sort_y = bfd_make_empty_symbol (abfd);
      if (sort_x == NULL || sort_y == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      if (! sort_by_size)
	qsort (minisyms, symcount, size,
	       sorters[sort_numerically][reverse_sort]);
      else
	symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
					 size, &symsizes);
    }

  if (! sort_by_size)
    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
  else
    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);

  if (synthsyms)
    free (synthsyms);
  free (minisyms);
  free (symsizes);
}","static void
display_rel_file (bfd *VAR_0, bfd *VAR_1)
{
  long VAR_2;
  void *VAR_3;
  unsigned int VAR_4;
  struct size_sym *VAR_5;
  asymbol *VAR_6 = NULL;

  if (! VAR_7)
    {
      if (!(bfd_get_file_flags (VAR_0) & VAR_8))
	{
	  non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
	  return;
	}
    }

  VAR_2 = bfd_read_minisymbols (VAR_0, VAR_7, &VAR_3, &VAR_4);
  if (VAR_2 < 0)
    {
      if (VAR_7 && bfd_get_error () == VAR_9)
	{
	  non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
	  return;
	}

      bfd_fatal (bfd_get_filename (VAR_0));
    }

  if (VAR_2 == 0)
    {
      non_fatal (_(""%s: no symbols""), bfd_get_filename (VAR_0));
      return;
    }

  if (VAR_10 && VAR_4 == sizeof (asymbol *))
    {
      asymbol **VAR_11 = NULL;
      asymbol **VAR_12 = NULL;
      long VAR_13 = 0;
      long VAR_14 = 0;
      long VAR_15;

      if (VAR_7)
	{
	  VAR_14 = VAR_2;
	  VAR_12 = (asymbol **) VAR_3;
	}
      else
	{
	  long VAR_16 = bfd_get_dynamic_symtab_upper_bound (VAR_0);

	  VAR_13 = VAR_2;
	  VAR_11 = (asymbol **) VAR_3;

	  if (VAR_16 > 0)
	    {
	      VAR_12 = (asymbol **) xmalloc (VAR_16);
	      VAR_14 = bfd_canonicalize_dynamic_symtab (VAR_0, VAR_12);
	      if (VAR_14 < 0)
		bfd_fatal (bfd_get_filename (VAR_0));
	    }
	}

      VAR_15 = bfd_get_synthetic_symtab (VAR_0, VAR_13, VAR_11,
					      VAR_14, VAR_12, &VAR_6);
      if (VAR_15 > 0)
	{
	  asymbol **VAR_17;
	  long VAR_18;

	  VAR_3 = xrealloc (VAR_3,
			       (VAR_2 + VAR_15 + 1) * sizeof (*VAR_17));
	  VAR_17 = (asymbol **) VAR_3 + VAR_2;
	  for (VAR_18 = 0; VAR_18 < VAR_15; VAR_18++)
	    *VAR_17++ = VAR_6 + VAR_18;
	  *VAR_17 = 0;
	  VAR_2 += VAR_15;
	}
    }

  /* COMMENT_0 */
                                                               
                          

  VAR_2 = filter_symbols (VAR_0, VAR_7, VAR_3, VAR_2, VAR_4);

  VAR_5 = NULL;
  if (! VAR_19)
    {
      VAR_20 = VAR_0;
      VAR_21 = VAR_7;
      VAR_22 = bfd_make_empty_symbol (VAR_0);
      VAR_23 = bfd_make_empty_symbol (VAR_0);
      if (VAR_22 == NULL || VAR_23 == NULL)
	bfd_fatal (bfd_get_filename (VAR_0));

      if (! VAR_24)
	qsort (VAR_3, VAR_2, VAR_4,
	       VAR_25[VAR_26][VAR_27]);
      else
	VAR_2 = sort_symbols_by_size (VAR_0, VAR_7, VAR_3, VAR_2,
					 VAR_4, &VAR_5);
    }

  if (! VAR_24)
    print_symbols (VAR_0, VAR_7, VAR_3, VAR_2, VAR_4, VAR_1);
  else
    print_size_symbols (VAR_0, VAR_7, VAR_5, VAR_2, VAR_1);

  if (VAR_6)
    free (VAR_6);
  free (VAR_3);
  free (VAR_5);
}",binutils-gdb/c2f5dc30afa34696f2da0081c4ac50b958ecb0e9/nm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -68,17 +68,14 @@
       if (synth_count > 0)
 	{
 	  asymbol **symp;
-	  void *new_mini;
 	  long i;
 
-	  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));
-	  symp = (asymbol **) new_mini;
-	  memcpy (symp, minisyms, symcount * sizeof (*symp));
-	  symp += symcount;
+	  minisyms = xrealloc (minisyms,
+			       (symcount + synth_count + 1) * sizeof (*symp));
+	  symp = (asymbol **) minisyms + symcount;
 	  for (i = 0; i < synth_count; i++)
 	    *symp++ = synthsyms + i;
 	  *symp = 0;
-	  minisyms = new_mini;
 	  symcount += synth_count;
 	}
     }","{'deleted_lines': ['\t  void *new_mini;', '\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));', '\t  symp = (asymbol **) new_mini;', '\t  memcpy (symp, minisyms, symcount * sizeof (*symp));', '\t  symp += symcount;', '\t  minisyms = new_mini;'], 'added_lines': ['\t  minisyms = xrealloc (minisyms,', '\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));', '\t  symp = (asymbol **) minisyms + symcount;']}",True,"The _bfd_generic_read_minisymbols function in syms.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.31, has a memory leak via a crafted ELF file, leading to a denial of service (memory consumption), as demonstrated by nm.",5.5,MEDIUM,1,valid,,5
CVE-2023-3777,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Skip bound chain when flushing table rules, the rule that owns this
chain releases these objects.

Otherwise, the following warning is triggered:

  WARNING: CPU: 2 PID: 1217 at net/netfilter/nf_tables_api.c:2013 nf_tables_chain_destroy+0x1f7/0x210 [nf_tables]
  CPU: 2 PID: 1217 Comm: chain-flush Not tainted 6.1.39 #1
  RIP: 0010:nf_tables_chain_destroy+0x1f7/0x210 [nf_tables]

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Florian Westphal <fw@strlen.de>
",6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8,net/netfilter/nf_tables_api.c,nf_tables_delrule,"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,
const struct nlattr * const nla[])
{
struct netlink_ext_ack *extack = info->extack;
u8 genmask = nft_genmask_next(info->net);
u8 family = info->nfmsg->nfgen_family;
struct nft_chain *chain = NULL;
struct net *net = info->net;
struct nft_table *table;
struct nft_rule *rule;
struct nft_ctx ctx;
int err = 0;
table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
NETLINK_CB(skb).portid);
if (IS_ERR(table)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
return PTR_ERR(table);
}
if (nla[NFTA_RULE_CHAIN]) {
chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
genmask);
if (IS_ERR(chain)) {
if (PTR_ERR(chain) == -ENOENT &&
NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
return 0;
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
return PTR_ERR(chain);
}
if (nft_chain_is_bound(chain))
return -EOPNOTSUPP;
}
nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);
if (chain) {
if (nla[NFTA_RULE_HANDLE]) {
rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);
if (IS_ERR(rule)) {
if (PTR_ERR(rule) == -ENOENT &&
NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
return 0;
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
return PTR_ERR(rule);
}
err = nft_delrule(&ctx, rule);
} else if (nla[NFTA_RULE_ID]) {
rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);
if (IS_ERR(rule)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);
return PTR_ERR(rule);
}
err = nft_delrule(&ctx, rule);
} else {
err = nft_delrule_by_chain(&ctx);
}
} else {
list_for_each_entry(chain, &table->chains, list) {
if (!nft_is_active_next(net, chain))
continue;
ctx.chain = chain;
err = nft_delrule_by_chain(&ctx);
if (err < 0)
break;
}
}
return err;
}","static int nf_tables_delrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
const struct nlattr * const VAR_2[])
{
struct netlink_ext_ack *VAR_3 = VAR_1->extack;
u8 VAR_4 = nft_genmask_next(VAR_1->net);
u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
struct nft_chain *VAR_6 = NULL;
struct net *net = VAR_1->net;
struct nft_table *VAR_7;
struct nft_rule *VAR_8;
struct nft_ctx VAR_9;
int VAR_10 = 0;
VAR_7 = nft_table_lookup(net, VAR_2[VAR_11], VAR_5, VAR_4,
NETLINK_CB(VAR_0).portid);
if (IS_ERR(VAR_7)) {
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_11]);
return PTR_ERR(VAR_7);
}
if (VAR_2[VAR_12]) {
VAR_6 = nft_chain_lookup(net, VAR_7, VAR_2[VAR_12],
VAR_4);
if (IS_ERR(VAR_6)) {
if (PTR_ERR(VAR_6) == -VAR_13 &&
NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
return 0;
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_12]);
return PTR_ERR(VAR_6);
}
if (nft_chain_is_bound(VAR_6))
return -VAR_15;
}
nft_ctx_init(&VAR_9, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_6, VAR_2);
if (VAR_6) {
if (VAR_2[VAR_16]) {
VAR_8 = nft_rule_lookup(VAR_6, VAR_2[VAR_16]);
if (IS_ERR(VAR_8)) {
if (PTR_ERR(VAR_8) == -VAR_13 &&
NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
return 0;
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_16]);
return PTR_ERR(VAR_8);
}
VAR_10 = nft_delrule(&VAR_9, VAR_8);
} else if (VAR_2[VAR_17]) {
VAR_8 = nft_rule_lookup_byid(net, VAR_6, VAR_2[VAR_17]);
if (IS_ERR(VAR_8)) {
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_17]);
return PTR_ERR(VAR_8);
}
VAR_10 = nft_delrule(&VAR_9, VAR_8);
} else {
VAR_10 = nft_delrule_by_chain(&VAR_9);
}
} else {
list_for_each_entry(VAR_6, &VAR_7->chains, VAR_18) {
if (!nft_is_active_next(net, VAR_6))
continue;
VAR_9.chain = VAR_6;
VAR_10 = nft_delrule_by_chain(&VAR_9);
if (VAR_10 < 0)
break;
}
}
return VAR_10;
}",torvalds/linux/6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8/nf_tables_api.c/vul/before/0.json,"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,
			     const struct nlattr * const nla[])
{
	struct netlink_ext_ack *extack = info->extack;
	u8 genmask = nft_genmask_next(info->net);
	u8 family = info->nfmsg->nfgen_family;
	struct nft_chain *chain = NULL;
	struct net *net = info->net;
	struct nft_table *table;
	struct nft_rule *rule;
	struct nft_ctx ctx;
	int err = 0;

	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
				 NETLINK_CB(skb).portid);
	if (IS_ERR(table)) {
		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
		return PTR_ERR(table);
	}

	if (nla[NFTA_RULE_CHAIN]) {
		chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
					 genmask);
		if (IS_ERR(chain)) {
			if (PTR_ERR(chain) == -ENOENT &&
			    NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
				return 0;

			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
			return PTR_ERR(chain);
		}
		if (nft_chain_is_bound(chain))
			return -EOPNOTSUPP;
	}

	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);

	if (chain) {
		if (nla[NFTA_RULE_HANDLE]) {
			rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);
			if (IS_ERR(rule)) {
				if (PTR_ERR(rule) == -ENOENT &&
				    NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
					return 0;

				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
				return PTR_ERR(rule);
			}

			err = nft_delrule(&ctx, rule);
		} else if (nla[NFTA_RULE_ID]) {
			rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);
			if (IS_ERR(rule)) {
				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);
				return PTR_ERR(rule);
			}

			err = nft_delrule(&ctx, rule);
		} else {
			err = nft_delrule_by_chain(&ctx);
		}
	} else {
		list_for_each_entry(chain, &table->chains, list) {
			if (!nft_is_active_next(net, chain))
				continue;
			if (nft_chain_is_bound(chain))
				continue;

			ctx.chain = chain;
			err = nft_delrule_by_chain(&ctx);
			if (err < 0)
				break;
		}
	}

	return err;
}","static int nf_tables_delrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
			     const struct nlattr * const VAR_2[])
{
	struct netlink_ext_ack *VAR_3 = VAR_1->extack;
	u8 VAR_4 = nft_genmask_next(VAR_1->net);
	u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
	struct nft_chain *VAR_6 = NULL;
	struct net *net = VAR_1->net;
	struct nft_table *VAR_7;
	struct nft_rule *VAR_8;
	struct nft_ctx VAR_9;
	int VAR_10 = 0;

	VAR_7 = nft_table_lookup(net, VAR_2[VAR_11], VAR_5, VAR_4,
				 NETLINK_CB(VAR_0).portid);
	if (IS_ERR(VAR_7)) {
		NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_11]);
		return PTR_ERR(VAR_7);
	}

	if (VAR_2[VAR_12]) {
		VAR_6 = nft_chain_lookup(net, VAR_7, VAR_2[VAR_12],
					 VAR_4);
		if (IS_ERR(VAR_6)) {
			if (PTR_ERR(VAR_6) == -VAR_13 &&
			    NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
				return 0;

			NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_12]);
			return PTR_ERR(VAR_6);
		}
		if (nft_chain_is_bound(VAR_6))
			return -VAR_15;
	}

	nft_ctx_init(&VAR_9, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_6, VAR_2);

	if (VAR_6) {
		if (VAR_2[VAR_16]) {
			VAR_8 = nft_rule_lookup(VAR_6, VAR_2[VAR_16]);
			if (IS_ERR(VAR_8)) {
				if (PTR_ERR(VAR_8) == -VAR_13 &&
				    NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
					return 0;

				NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_16]);
				return PTR_ERR(VAR_8);
			}

			VAR_10 = nft_delrule(&VAR_9, VAR_8);
		} else if (VAR_2[VAR_17]) {
			VAR_8 = nft_rule_lookup_byid(net, VAR_6, VAR_2[VAR_17]);
			if (IS_ERR(VAR_8)) {
				NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_17]);
				return PTR_ERR(VAR_8);
			}

			VAR_10 = nft_delrule(&VAR_9, VAR_8);
		} else {
			VAR_10 = nft_delrule_by_chain(&VAR_9);
		}
	} else {
		list_for_each_entry(VAR_6, &VAR_7->chains, VAR_18) {
			if (!nft_is_active_next(net, VAR_6))
				continue;
			if (nft_chain_is_bound(VAR_6))
				continue;

			VAR_9.chain = VAR_6;
			VAR_10 = nft_delrule_by_chain(&VAR_9);
			if (VAR_10 < 0)
				break;
		}
	}

	return VAR_10;
}",torvalds/linux/6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8/nf_tables_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -63,6 +63,8 @@
 		list_for_each_entry(chain, &table->chains, list) {
 			if (!nft_is_active_next(net, chain))
 				continue;
+			if (nft_chain_is_bound(chain))
+				continue;
 
 			ctx.chain = chain;
 			err = nft_delrule_by_chain(&ctx);","{'deleted_lines': [], 'added_lines': ['\t\t\tif (nft_chain_is_bound(chain))', '\t\t\t\tcontinue;']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

When nf_tables_delrule() is flushing table rules, it is not checked whether the chain is bound and the chain's owner rule can also release the objects in certain circumstances.

We recommend upgrading past commit 6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8.

",7.8,HIGH,2,valid,,5
CVE-2023-5197,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H,1,torvalds/linux,"Chain binding only requires the rule addition/insertion command within
the same transaction. Removal of rules from chain bindings within the
same transaction makes no sense, userspace does not utilize this
feature. Replace nft_chain_is_bound() check to nft_chain_binding() in
rule deletion commands. Replace command implies a rule deletion, reject
this command too.

Rule flush command can also safely rely on this nft_chain_binding()
check because unbound chains are not allowed since 62e1e94b246e
(""netfilter: nf_tables: reject unbound chain set before commit phase"").

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
",f15f29fd4779be8a418b66e9d52979bb6d6c2325,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f15f29fd4779be8a418b66e9d52979bb6d6c2325,net/netfilter/nf_tables_api.c,nf_tables_newrule,"static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
const struct nlattr * const nla[])
{
struct nftables_pernet *nft_net = nft_pernet(info->net);
struct netlink_ext_ack *extack = info->extack;
unsigned int size, i, n, ulen = 0, usize = 0;
u8 genmask = nft_genmask_next(info->net);
struct nft_rule *rule, *old_rule = NULL;
struct nft_expr_info *expr_info = NULL;
u8 family = info->nfmsg->nfgen_family;
struct nft_flow_rule *flow = NULL;
struct net *net = info->net;
struct nft_userdata *udata;
struct nft_table *table;
struct nft_chain *chain;
struct nft_trans *trans;
u64 handle, pos_handle;
struct nft_expr *expr;
struct nft_ctx ctx;
struct nlattr *tmp;
int err, rem;
lockdep_assert_held(&nft_net->commit_mutex);
table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
NETLINK_CB(skb).portid);
if (IS_ERR(table)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
return PTR_ERR(table);
}
if (nla[NFTA_RULE_CHAIN]) {
chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
genmask);
if (IS_ERR(chain)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
return PTR_ERR(chain);
}
} else if (nla[NFTA_RULE_CHAIN_ID]) {
chain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID],
genmask);
if (IS_ERR(chain)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);
return PTR_ERR(chain);
}
} else {
return -EINVAL;
}
if (nft_chain_is_bound(chain))
return -EOPNOTSUPP;
if (nla[NFTA_RULE_HANDLE]) {
handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));
rule = __nft_rule_lookup(chain, handle);
if (IS_ERR(rule)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
return PTR_ERR(rule);
}
if (info->nlh->nlmsg_flags & NLM_F_EXCL) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
return -EEXIST;
}
if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
old_rule = rule;
else
return -EOPNOTSUPP;
} else {
if (!(info->nlh->nlmsg_flags & NLM_F_CREATE) ||
info->nlh->nlmsg_flags & NLM_F_REPLACE)
return -EINVAL;
handle = nf_tables_alloc_handle(table);
if (nla[NFTA_RULE_POSITION]) {
pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));
old_rule = __nft_rule_lookup(chain, pos_handle);
if (IS_ERR(old_rule)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);
return PTR_ERR(old_rule);
}
} else if (nla[NFTA_RULE_POSITION_ID]) {
old_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);
if (IS_ERR(old_rule)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);
return PTR_ERR(old_rule);
}
}
}
nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);
n = 0;
size = 0;
if (nla[NFTA_RULE_EXPRESSIONS]) {
expr_info = kvmalloc_array(NFT_RULE_MAXEXPRS,
sizeof(struct nft_expr_info),
GFP_KERNEL);
if (!expr_info)
return -ENOMEM;
nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {
err = -EINVAL;
if (nla_type(tmp) != NFTA_LIST_ELEM)
goto err_release_expr;
if (n == NFT_RULE_MAXEXPRS)
goto err_release_expr;
err = nf_tables_expr_parse(&ctx, tmp, &expr_info[n]);
if (err < 0) {
NL_SET_BAD_ATTR(extack, tmp);
goto err_release_expr;
}
size += expr_info[n].ops->size;
n++;
}
}
err = -EFBIG;
if (size >= 1 << 12)
goto err_release_expr;
if (nla[NFTA_RULE_USERDATA]) {
ulen = nla_len(nla[NFTA_RULE_USERDATA]);
if (ulen > 0)
usize = sizeof(struct nft_userdata) + ulen;
}
err = -ENOMEM;
rule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL_ACCOUNT);
if (rule == NULL)
goto err_release_expr;
nft_activate_next(net, rule);
rule->handle = handle;
rule->dlen   = size;
rule->udata  = ulen ? 1 : 0;
if (ulen) {
udata = nft_userdata(rule);
udata->len = ulen - 1;
nla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);
}
expr = nft_expr_first(rule);
for (i = 0; i < n; i++) {
err = nf_tables_newexpr(&ctx, &expr_info[i], expr);
if (err < 0) {
NL_SET_BAD_ATTR(extack, expr_info[i].attr);
goto err_release_rule;
}
if (expr_info[i].ops->validate)
nft_validate_state_update(table, NFT_VALIDATE_NEED);
expr_info[i].ops = NULL;
expr = nft_expr_next(expr);
}
if (chain->flags & NFT_CHAIN_HW_OFFLOAD) {
flow = nft_flow_rule_create(net, rule);
if (IS_ERR(flow)) {
err = PTR_ERR(flow);
goto err_release_rule;
}
}
if (!nft_use_inc(&chain->use)) {
err = -EMFILE;
goto err_release_rule;
}
if (info->nlh->nlmsg_flags & NLM_F_REPLACE) {
err = nft_delrule(&ctx, old_rule);
if (err < 0)
goto err_destroy_flow_rule;
trans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);
if (trans == NULL) {
err = -ENOMEM;
goto err_destroy_flow_rule;
}
list_add_tail_rcu(&rule->list, &old_rule->list);
} else {
trans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);
if (!trans) {
err = -ENOMEM;
goto err_destroy_flow_rule;
}
if (info->nlh->nlmsg_flags & NLM_F_APPEND) {
if (old_rule)
list_add_rcu(&rule->list, &old_rule->list);
else
list_add_tail_rcu(&rule->list, &chain->rules);
} else {
if (old_rule)
list_add_tail_rcu(&rule->list, &old_rule->list);
else
list_add_rcu(&rule->list, &chain->rules);
}
}
kvfree(expr_info);
if (flow)
nft_trans_flow_rule(trans) = flow;
if (table->validate_state == NFT_VALIDATE_DO)
return nft_table_validate(net, table);
return 0;
err_destroy_flow_rule:
nft_use_dec_restore(&chain->use);
if (flow)
nft_flow_rule_destroy(flow);
err_release_rule:
nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
nf_tables_rule_destroy(&ctx, rule);
err_release_expr:
for (i = 0; i < n; i++) {
if (expr_info[i].ops) {
module_put(expr_info[i].ops->type->owner);
if (expr_info[i].ops->type->release_ops)
expr_info[i].ops->type->release_ops(expr_info[i].ops);
}
}
kvfree(expr_info);
return err;
}","static int nf_tables_newrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
const struct nlattr * const VAR_2[])
{
struct nftables_pernet *VAR_3 = nft_pernet(VAR_1->net);
struct netlink_ext_ack *VAR_4 = VAR_1->extack;
unsigned int VAR_5, VAR_6, VAR_7, VAR_8 = 0, VAR_9 = 0;
u8 VAR_10 = nft_genmask_next(VAR_1->net);
struct nft_rule *VAR_11, *VAR_12 = NULL;
struct nft_expr_info *VAR_13 = NULL;
u8 VAR_14 = VAR_1->nfmsg->nfgen_family;
struct nft_flow_rule *VAR_15 = NULL;
struct net *net = VAR_1->net;
struct nft_userdata *VAR_16;
struct nft_table *VAR_17;
struct nft_chain *VAR_18;
struct nft_trans *VAR_19;
u64 VAR_20, VAR_21;
struct nft_expr *VAR_22;
struct nft_ctx VAR_23;
struct nlattr *VAR_24;
int VAR_25, VAR_26;
lockdep_assert_held(&VAR_3->commit_mutex);
VAR_17 = nft_table_lookup(net, VAR_2[VAR_27], VAR_14, VAR_10,
NETLINK_CB(VAR_0).portid);
if (IS_ERR(VAR_17)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_27]);
return PTR_ERR(VAR_17);
}
if (VAR_2[VAR_28]) {
VAR_18 = nft_chain_lookup(net, VAR_17, VAR_2[VAR_28],
VAR_10);
if (IS_ERR(VAR_18)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_28]);
return PTR_ERR(VAR_18);
}
} else if (VAR_2[VAR_29]) {
VAR_18 = nft_chain_lookup_byid(net, VAR_17, VAR_2[VAR_29],
VAR_10);
if (IS_ERR(VAR_18)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_29]);
return PTR_ERR(VAR_18);
}
} else {
return -VAR_30;
}
if (nft_chain_is_bound(VAR_18))
return -VAR_31;
if (VAR_2[VAR_32]) {
VAR_20 = be64_to_cpu(nla_get_be64(VAR_2[VAR_32]));
VAR_11 = __nft_rule_lookup(VAR_18, VAR_20);
if (IS_ERR(VAR_11)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_32]);
return PTR_ERR(VAR_11);
}
if (VAR_1->nlh->nlmsg_flags & VAR_33) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_32]);
return -VAR_34;
}
if (VAR_1->nlh->nlmsg_flags & VAR_35)
VAR_12 = VAR_11;
else
return -VAR_31;
} else {
if (!(VAR_1->nlh->nlmsg_flags & VAR_36) ||
VAR_1->nlh->nlmsg_flags & VAR_35)
return -VAR_30;
VAR_20 = nf_tables_alloc_handle(VAR_17);
if (VAR_2[VAR_37]) {
VAR_21 = be64_to_cpu(nla_get_be64(VAR_2[VAR_37]));
VAR_12 = __nft_rule_lookup(VAR_18, VAR_21);
if (IS_ERR(VAR_12)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_37]);
return PTR_ERR(VAR_12);
}
} else if (VAR_2[VAR_38]) {
VAR_12 = nft_rule_lookup_byid(net, VAR_18, VAR_2[VAR_38]);
if (IS_ERR(VAR_12)) {
NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_38]);
return PTR_ERR(VAR_12);
}
}
}
nft_ctx_init(&VAR_23, net, VAR_0, VAR_1->nlh, VAR_14, VAR_17, VAR_18, VAR_2);
VAR_7 = 0;
VAR_5 = 0;
if (VAR_2[VAR_39]) {
VAR_13 = kvmalloc_array(VAR_40,
sizeof(struct nft_expr_info),
VAR_41);
if (!VAR_13)
return -VAR_42;
nla_for_each_nested(VAR_24, VAR_2[VAR_39], VAR_26) {
VAR_25 = -VAR_30;
if (nla_type(VAR_24) != VAR_43)
goto err_release_expr;
if (VAR_7 == VAR_40)
goto err_release_expr;
VAR_25 = nf_tables_expr_parse(&VAR_23, VAR_24, &VAR_13[VAR_7]);
if (VAR_25 < 0) {
NL_SET_BAD_ATTR(VAR_4, VAR_24);
goto err_release_expr;
}
VAR_5 += VAR_13[VAR_7].ops->size;
VAR_7++;
}
}
VAR_25 = -VAR_44;
if (VAR_5 >= 1 << 12)
goto err_release_expr;
if (VAR_2[VAR_45]) {
VAR_8 = nla_len(VAR_2[VAR_45]);
if (VAR_8 > 0)
VAR_9 = sizeof(struct nft_userdata) + VAR_8;
}
VAR_25 = -VAR_42;
VAR_11 = kzalloc(sizeof(*VAR_11) + VAR_5 + VAR_9, VAR_46);
if (VAR_11 == NULL)
goto err_release_expr;
nft_activate_next(net, VAR_11);
VAR_11->handle = VAR_20;
VAR_11->dlen   = VAR_5;
VAR_11->udata  = VAR_8 ? 1 : 0;
if (VAR_8) {
VAR_16 = nft_userdata(VAR_11);
VAR_16->len = VAR_8 - 1;
nla_memcpy(VAR_16->data, VAR_2[VAR_45], VAR_8);
}
VAR_22 = nft_expr_first(VAR_11);
for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
VAR_25 = nf_tables_newexpr(&VAR_23, &VAR_13[VAR_6], VAR_22);
if (VAR_25 < 0) {
NL_SET_BAD_ATTR(VAR_4, VAR_13[VAR_6].attr);
goto err_release_rule;
}
if (VAR_13[VAR_6].ops->validate)
nft_validate_state_update(VAR_17, VAR_47);
VAR_13[VAR_6].ops = NULL;
VAR_22 = nft_expr_next(VAR_22);
}
if (VAR_18->flags & VAR_48) {
VAR_15 = nft_flow_rule_create(net, VAR_11);
if (IS_ERR(VAR_15)) {
VAR_25 = PTR_ERR(VAR_15);
goto err_release_rule;
}
}
if (!nft_use_inc(&VAR_18->use)) {
VAR_25 = -VAR_49;
goto err_release_rule;
}
if (VAR_1->nlh->nlmsg_flags & VAR_35) {
VAR_25 = nft_delrule(&VAR_23, VAR_12);
if (VAR_25 < 0)
goto err_destroy_flow_rule;
VAR_19 = nft_trans_rule_add(&VAR_23, VAR_50, VAR_11);
if (VAR_19 == NULL) {
VAR_25 = -VAR_42;
goto err_destroy_flow_rule;
}
list_add_tail_rcu(&VAR_11->list, &VAR_12->list);
} else {
VAR_19 = nft_trans_rule_add(&VAR_23, VAR_50, VAR_11);
if (!VAR_19) {
VAR_25 = -VAR_42;
goto err_destroy_flow_rule;
}
if (VAR_1->nlh->nlmsg_flags & VAR_51) {
if (VAR_12)
list_add_rcu(&VAR_11->list, &VAR_12->list);
else
list_add_tail_rcu(&VAR_11->list, &VAR_18->rules);
} else {
if (VAR_12)
list_add_tail_rcu(&VAR_11->list, &VAR_12->list);
else
list_add_rcu(&VAR_11->list, &VAR_18->rules);
}
}
kvfree(VAR_13);
if (VAR_15)
nft_trans_flow_rule(VAR_19) = VAR_15;
if (VAR_17->validate_state == VAR_52)
return nft_table_validate(net, VAR_17);
return 0;
err_destroy_flow_rule:
nft_use_dec_restore(&VAR_18->use);
if (VAR_15)
nft_flow_rule_destroy(VAR_15);
err_release_rule:
nft_rule_expr_deactivate(&VAR_23, VAR_11, VAR_53);
nf_tables_rule_destroy(&VAR_23, VAR_11);
err_release_expr:
for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
if (VAR_13[VAR_6].ops) {
module_put(VAR_13[VAR_6].ops->type->owner);
if (VAR_13[VAR_6].ops->type->release_ops)
VAR_13[VAR_6].ops->type->release_ops(VAR_13[VAR_6].ops);
}
}
kvfree(VAR_13);
return VAR_25;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/before/0.json,"static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
			     const struct nlattr * const nla[])
{
	struct nftables_pernet *nft_net = nft_pernet(info->net);
	struct netlink_ext_ack *extack = info->extack;
	unsigned int size, i, n, ulen = 0, usize = 0;
	u8 genmask = nft_genmask_next(info->net);
	struct nft_rule *rule, *old_rule = NULL;
	struct nft_expr_info *expr_info = NULL;
	u8 family = info->nfmsg->nfgen_family;
	struct nft_flow_rule *flow = NULL;
	struct net *net = info->net;
	struct nft_userdata *udata;
	struct nft_table *table;
	struct nft_chain *chain;
	struct nft_trans *trans;
	u64 handle, pos_handle;
	struct nft_expr *expr;
	struct nft_ctx ctx;
	struct nlattr *tmp;
	int err, rem;

	lockdep_assert_held(&nft_net->commit_mutex);

	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
				 NETLINK_CB(skb).portid);
	if (IS_ERR(table)) {
		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
		return PTR_ERR(table);
	}

	if (nla[NFTA_RULE_CHAIN]) {
		chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
					 genmask);
		if (IS_ERR(chain)) {
			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
			return PTR_ERR(chain);
		}

	} else if (nla[NFTA_RULE_CHAIN_ID]) {
		chain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID],
					      genmask);
		if (IS_ERR(chain)) {
			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);
			return PTR_ERR(chain);
		}
	} else {
		return -EINVAL;
	}

	if (nft_chain_is_bound(chain))
		return -EOPNOTSUPP;

	if (nla[NFTA_RULE_HANDLE]) {
		handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));
		rule = __nft_rule_lookup(chain, handle);
		if (IS_ERR(rule)) {
			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
			return PTR_ERR(rule);
		}

		if (info->nlh->nlmsg_flags & NLM_F_EXCL) {
			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
			return -EEXIST;
		}
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			old_rule = rule;
		else
			return -EOPNOTSUPP;
	} else {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE) ||
		    info->nlh->nlmsg_flags & NLM_F_REPLACE)
			return -EINVAL;
		handle = nf_tables_alloc_handle(table);

		if (nla[NFTA_RULE_POSITION]) {
			pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));
			old_rule = __nft_rule_lookup(chain, pos_handle);
			if (IS_ERR(old_rule)) {
				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);
				return PTR_ERR(old_rule);
			}
		} else if (nla[NFTA_RULE_POSITION_ID]) {
			old_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);
			if (IS_ERR(old_rule)) {
				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);
				return PTR_ERR(old_rule);
			}
		}
	}

	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);

	n = 0;
	size = 0;
	if (nla[NFTA_RULE_EXPRESSIONS]) {
		expr_info = kvmalloc_array(NFT_RULE_MAXEXPRS,
					   sizeof(struct nft_expr_info),
					   GFP_KERNEL);
		if (!expr_info)
			return -ENOMEM;

		nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {
			err = -EINVAL;
			if (nla_type(tmp) != NFTA_LIST_ELEM)
				goto err_release_expr;
			if (n == NFT_RULE_MAXEXPRS)
				goto err_release_expr;
			err = nf_tables_expr_parse(&ctx, tmp, &expr_info[n]);
			if (err < 0) {
				NL_SET_BAD_ATTR(extack, tmp);
				goto err_release_expr;
			}
			size += expr_info[n].ops->size;
			n++;
		}
	}
	/* Check for overflow of dlen field */
	err = -EFBIG;
	if (size >= 1 << 12)
		goto err_release_expr;

	if (nla[NFTA_RULE_USERDATA]) {
		ulen = nla_len(nla[NFTA_RULE_USERDATA]);
		if (ulen > 0)
			usize = sizeof(struct nft_userdata) + ulen;
	}

	err = -ENOMEM;
	rule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL_ACCOUNT);
	if (rule == NULL)
		goto err_release_expr;

	nft_activate_next(net, rule);

	rule->handle = handle;
	rule->dlen   = size;
	rule->udata  = ulen ? 1 : 0;

	if (ulen) {
		udata = nft_userdata(rule);
		udata->len = ulen - 1;
		nla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);
	}

	expr = nft_expr_first(rule);
	for (i = 0; i < n; i++) {
		err = nf_tables_newexpr(&ctx, &expr_info[i], expr);
		if (err < 0) {
			NL_SET_BAD_ATTR(extack, expr_info[i].attr);
			goto err_release_rule;
		}

		if (expr_info[i].ops->validate)
			nft_validate_state_update(table, NFT_VALIDATE_NEED);

		expr_info[i].ops = NULL;
		expr = nft_expr_next(expr);
	}

	if (chain->flags & NFT_CHAIN_HW_OFFLOAD) {
		flow = nft_flow_rule_create(net, rule);
		if (IS_ERR(flow)) {
			err = PTR_ERR(flow);
			goto err_release_rule;
		}
	}

	if (!nft_use_inc(&chain->use)) {
		err = -EMFILE;
		goto err_release_rule;
	}

	if (info->nlh->nlmsg_flags & NLM_F_REPLACE) {
		if (nft_chain_binding(chain)) {
			err = -EOPNOTSUPP;
			goto err_destroy_flow_rule;
		}

		err = nft_delrule(&ctx, old_rule);
		if (err < 0)
			goto err_destroy_flow_rule;

		trans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);
		if (trans == NULL) {
			err = -ENOMEM;
			goto err_destroy_flow_rule;
		}
		list_add_tail_rcu(&rule->list, &old_rule->list);
	} else {
		trans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);
		if (!trans) {
			err = -ENOMEM;
			goto err_destroy_flow_rule;
		}

		if (info->nlh->nlmsg_flags & NLM_F_APPEND) {
			if (old_rule)
				list_add_rcu(&rule->list, &old_rule->list);
			else
				list_add_tail_rcu(&rule->list, &chain->rules);
		 } else {
			if (old_rule)
				list_add_tail_rcu(&rule->list, &old_rule->list);
			else
				list_add_rcu(&rule->list, &chain->rules);
		}
	}
	kvfree(expr_info);

	if (flow)
		nft_trans_flow_rule(trans) = flow;

	if (table->validate_state == NFT_VALIDATE_DO)
		return nft_table_validate(net, table);

	return 0;

err_destroy_flow_rule:
	nft_use_dec_restore(&chain->use);
	if (flow)
		nft_flow_rule_destroy(flow);
err_release_rule:
	nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
	nf_tables_rule_destroy(&ctx, rule);
err_release_expr:
	for (i = 0; i < n; i++) {
		if (expr_info[i].ops) {
			module_put(expr_info[i].ops->type->owner);
			if (expr_info[i].ops->type->release_ops)
				expr_info[i].ops->type->release_ops(expr_info[i].ops);
		}
	}
	kvfree(expr_info);

	return err;
}","static int nf_tables_newrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
			     const struct nlattr * const VAR_2[])
{
	struct nftables_pernet *VAR_3 = nft_pernet(VAR_1->net);
	struct netlink_ext_ack *VAR_4 = VAR_1->extack;
	unsigned int VAR_5, VAR_6, VAR_7, VAR_8 = 0, VAR_9 = 0;
	u8 VAR_10 = nft_genmask_next(VAR_1->net);
	struct nft_rule *VAR_11, *VAR_12 = NULL;
	struct nft_expr_info *VAR_13 = NULL;
	u8 VAR_14 = VAR_1->nfmsg->nfgen_family;
	struct nft_flow_rule *VAR_15 = NULL;
	struct net *net = VAR_1->net;
	struct nft_userdata *VAR_16;
	struct nft_table *VAR_17;
	struct nft_chain *VAR_18;
	struct nft_trans *VAR_19;
	u64 VAR_20, VAR_21;
	struct nft_expr *VAR_22;
	struct nft_ctx VAR_23;
	struct nlattr *VAR_24;
	int VAR_25, VAR_26;

	lockdep_assert_held(&VAR_3->commit_mutex);

	VAR_17 = nft_table_lookup(net, VAR_2[VAR_27], VAR_14, VAR_10,
				 NETLINK_CB(VAR_0).portid);
	if (IS_ERR(VAR_17)) {
		NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_27]);
		return PTR_ERR(VAR_17);
	}

	if (VAR_2[VAR_28]) {
		VAR_18 = nft_chain_lookup(net, VAR_17, VAR_2[VAR_28],
					 VAR_10);
		if (IS_ERR(VAR_18)) {
			NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_28]);
			return PTR_ERR(VAR_18);
		}

	} else if (VAR_2[VAR_29]) {
		VAR_18 = nft_chain_lookup_byid(net, VAR_17, VAR_2[VAR_29],
					      VAR_10);
		if (IS_ERR(VAR_18)) {
			NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_29]);
			return PTR_ERR(VAR_18);
		}
	} else {
		return -VAR_30;
	}

	if (nft_chain_is_bound(VAR_18))
		return -VAR_31;

	if (VAR_2[VAR_32]) {
		VAR_20 = be64_to_cpu(nla_get_be64(VAR_2[VAR_32]));
		VAR_11 = __nft_rule_lookup(VAR_18, VAR_20);
		if (IS_ERR(VAR_11)) {
			NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_32]);
			return PTR_ERR(VAR_11);
		}

		if (VAR_1->nlh->nlmsg_flags & VAR_33) {
			NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_32]);
			return -VAR_34;
		}
		if (VAR_1->nlh->nlmsg_flags & VAR_35)
			VAR_12 = VAR_11;
		else
			return -VAR_31;
	} else {
		if (!(VAR_1->nlh->nlmsg_flags & VAR_36) ||
		    VAR_1->nlh->nlmsg_flags & VAR_35)
			return -VAR_30;
		VAR_20 = nf_tables_alloc_handle(VAR_17);

		if (VAR_2[VAR_37]) {
			VAR_21 = be64_to_cpu(nla_get_be64(VAR_2[VAR_37]));
			VAR_12 = __nft_rule_lookup(VAR_18, VAR_21);
			if (IS_ERR(VAR_12)) {
				NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_37]);
				return PTR_ERR(VAR_12);
			}
		} else if (VAR_2[VAR_38]) {
			VAR_12 = nft_rule_lookup_byid(net, VAR_18, VAR_2[VAR_38]);
			if (IS_ERR(VAR_12)) {
				NL_SET_BAD_ATTR(VAR_4, VAR_2[VAR_38]);
				return PTR_ERR(VAR_12);
			}
		}
	}

	nft_ctx_init(&VAR_23, net, VAR_0, VAR_1->nlh, VAR_14, VAR_17, VAR_18, VAR_2);

	VAR_7 = 0;
	VAR_5 = 0;
	if (VAR_2[VAR_39]) {
		VAR_13 = kvmalloc_array(VAR_40,
					   sizeof(struct nft_expr_info),
					   VAR_41);
		if (!VAR_13)
			return -VAR_42;

		nla_for_each_nested(VAR_24, VAR_2[VAR_39], VAR_26) {
			VAR_25 = -VAR_30;
			if (nla_type(VAR_24) != VAR_43)
				goto err_release_expr;
			if (VAR_7 == VAR_40)
				goto err_release_expr;
			VAR_25 = nf_tables_expr_parse(&VAR_23, VAR_24, &VAR_13[VAR_7]);
			if (VAR_25 < 0) {
				NL_SET_BAD_ATTR(VAR_4, VAR_24);
				goto err_release_expr;
			}
			VAR_5 += VAR_13[VAR_7].ops->size;
			VAR_7++;
		}
	}
	/* COMMENT_0 */
	VAR_25 = -VAR_44;
	if (VAR_5 >= 1 << 12)
		goto err_release_expr;

	if (VAR_2[VAR_45]) {
		VAR_8 = nla_len(VAR_2[VAR_45]);
		if (VAR_8 > 0)
			VAR_9 = sizeof(struct nft_userdata) + VAR_8;
	}

	VAR_25 = -VAR_42;
	VAR_11 = kzalloc(sizeof(*VAR_11) + VAR_5 + VAR_9, VAR_46);
	if (VAR_11 == NULL)
		goto err_release_expr;

	nft_activate_next(net, VAR_11);

	VAR_11->handle = VAR_20;
	VAR_11->dlen   = VAR_5;
	VAR_11->udata  = VAR_8 ? 1 : 0;

	if (VAR_8) {
		VAR_16 = nft_userdata(VAR_11);
		VAR_16->len = VAR_8 - 1;
		nla_memcpy(VAR_16->data, VAR_2[VAR_45], VAR_8);
	}

	VAR_22 = nft_expr_first(VAR_11);
	for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
		VAR_25 = nf_tables_newexpr(&VAR_23, &VAR_13[VAR_6], VAR_22);
		if (VAR_25 < 0) {
			NL_SET_BAD_ATTR(VAR_4, VAR_13[VAR_6].attr);
			goto err_release_rule;
		}

		if (VAR_13[VAR_6].ops->validate)
			nft_validate_state_update(VAR_17, VAR_47);

		VAR_13[VAR_6].ops = NULL;
		VAR_22 = nft_expr_next(VAR_22);
	}

	if (VAR_18->flags & VAR_48) {
		VAR_15 = nft_flow_rule_create(net, VAR_11);
		if (IS_ERR(VAR_15)) {
			VAR_25 = PTR_ERR(VAR_15);
			goto err_release_rule;
		}
	}

	if (!nft_use_inc(&VAR_18->use)) {
		VAR_25 = -VAR_49;
		goto err_release_rule;
	}

	if (VAR_1->nlh->nlmsg_flags & VAR_35) {
		if (nft_chain_binding(VAR_18)) {
			VAR_25 = -VAR_31;
			goto err_destroy_flow_rule;
		}

		VAR_25 = nft_delrule(&VAR_23, VAR_12);
		if (VAR_25 < 0)
			goto err_destroy_flow_rule;

		VAR_19 = nft_trans_rule_add(&VAR_23, VAR_50, VAR_11);
		if (VAR_19 == NULL) {
			VAR_25 = -VAR_42;
			goto err_destroy_flow_rule;
		}
		list_add_tail_rcu(&VAR_11->list, &VAR_12->list);
	} else {
		VAR_19 = nft_trans_rule_add(&VAR_23, VAR_50, VAR_11);
		if (!VAR_19) {
			VAR_25 = -VAR_42;
			goto err_destroy_flow_rule;
		}

		if (VAR_1->nlh->nlmsg_flags & VAR_51) {
			if (VAR_12)
				list_add_rcu(&VAR_11->list, &VAR_12->list);
			else
				list_add_tail_rcu(&VAR_11->list, &VAR_18->rules);
		 } else {
			if (VAR_12)
				list_add_tail_rcu(&VAR_11->list, &VAR_12->list);
			else
				list_add_rcu(&VAR_11->list, &VAR_18->rules);
		}
	}
	kvfree(VAR_13);

	if (VAR_15)
		nft_trans_flow_rule(VAR_19) = VAR_15;

	if (VAR_17->validate_state == VAR_52)
		return nft_table_validate(net, VAR_17);

	return 0;

err_destroy_flow_rule:
	nft_use_dec_restore(&VAR_18->use);
	if (VAR_15)
		nft_flow_rule_destroy(VAR_15);
err_release_rule:
	nft_rule_expr_deactivate(&VAR_23, VAR_11, VAR_53);
	nf_tables_rule_destroy(&VAR_23, VAR_11);
err_release_expr:
	for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {
		if (VAR_13[VAR_6].ops) {
			module_put(VAR_13[VAR_6].ops->type->owner);
			if (VAR_13[VAR_6].ops->type->release_ops)
				VAR_13[VAR_6].ops->type->release_ops(VAR_13[VAR_6].ops);
		}
	}
	kvfree(VAR_13);

	return VAR_25;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -172,6 +172,11 @@
 	}
 
 	if (info->nlh->nlmsg_flags & NLM_F_REPLACE) {
+		if (nft_chain_binding(chain)) {
+			err = -EOPNOTSUPP;
+			goto err_destroy_flow_rule;
+		}
+
 		err = nft_delrule(&ctx, old_rule);
 		if (err < 0)
 			goto err_destroy_flow_rule;","{'deleted_lines': [], 'added_lines': ['\t\tif (nft_chain_binding(chain)) {', '\t\t\terr = -EOPNOTSUPP;', '\t\t\tgoto err_destroy_flow_rule;', '\t\t}', '']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.

We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.

",6.6,MEDIUM,1,valid,,5
CVE-2023-5197,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H,1,torvalds/linux,"Chain binding only requires the rule addition/insertion command within
the same transaction. Removal of rules from chain bindings within the
same transaction makes no sense, userspace does not utilize this
feature. Replace nft_chain_is_bound() check to nft_chain_binding() in
rule deletion commands. Replace command implies a rule deletion, reject
this command too.

Rule flush command can also safely rely on this nft_chain_binding()
check because unbound chains are not allowed since 62e1e94b246e
(""netfilter: nf_tables: reject unbound chain set before commit phase"").

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
",f15f29fd4779be8a418b66e9d52979bb6d6c2325,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f15f29fd4779be8a418b66e9d52979bb6d6c2325,net/netfilter/nf_tables_api.c,nf_tables_delrule,"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,
const struct nlattr * const nla[])
{
struct netlink_ext_ack *extack = info->extack;
u8 genmask = nft_genmask_next(info->net);
u8 family = info->nfmsg->nfgen_family;
struct nft_chain *chain = NULL;
struct net *net = info->net;
struct nft_table *table;
struct nft_rule *rule;
struct nft_ctx ctx;
int err = 0;
table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
NETLINK_CB(skb).portid);
if (IS_ERR(table)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
return PTR_ERR(table);
}
if (nla[NFTA_RULE_CHAIN]) {
chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
genmask);
if (IS_ERR(chain)) {
if (PTR_ERR(chain) == -ENOENT &&
NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
return 0;
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
return PTR_ERR(chain);
}
if (nft_chain_is_bound(chain))
return -EOPNOTSUPP;
}
nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);
if (chain) {
if (nla[NFTA_RULE_HANDLE]) {
rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);
if (IS_ERR(rule)) {
if (PTR_ERR(rule) == -ENOENT &&
NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
return 0;
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
return PTR_ERR(rule);
}
err = nft_delrule(&ctx, rule);
} else if (nla[NFTA_RULE_ID]) {
rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);
if (IS_ERR(rule)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);
return PTR_ERR(rule);
}
err = nft_delrule(&ctx, rule);
} else {
err = nft_delrule_by_chain(&ctx);
}
} else {
list_for_each_entry(chain, &table->chains, list) {
if (!nft_is_active_next(net, chain))
continue;
if (nft_chain_is_bound(chain))
continue;
ctx.chain = chain;
err = nft_delrule_by_chain(&ctx);
if (err < 0)
break;
}
}
return err;
}","static int nf_tables_delrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
const struct nlattr * const VAR_2[])
{
struct netlink_ext_ack *VAR_3 = VAR_1->extack;
u8 VAR_4 = nft_genmask_next(VAR_1->net);
u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
struct nft_chain *VAR_6 = NULL;
struct net *net = VAR_1->net;
struct nft_table *VAR_7;
struct nft_rule *VAR_8;
struct nft_ctx VAR_9;
int VAR_10 = 0;
VAR_7 = nft_table_lookup(net, VAR_2[VAR_11], VAR_5, VAR_4,
NETLINK_CB(VAR_0).portid);
if (IS_ERR(VAR_7)) {
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_11]);
return PTR_ERR(VAR_7);
}
if (VAR_2[VAR_12]) {
VAR_6 = nft_chain_lookup(net, VAR_7, VAR_2[VAR_12],
VAR_4);
if (IS_ERR(VAR_6)) {
if (PTR_ERR(VAR_6) == -VAR_13 &&
NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
return 0;
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_12]);
return PTR_ERR(VAR_6);
}
if (nft_chain_is_bound(VAR_6))
return -VAR_15;
}
nft_ctx_init(&VAR_9, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_6, VAR_2);
if (VAR_6) {
if (VAR_2[VAR_16]) {
VAR_8 = nft_rule_lookup(VAR_6, VAR_2[VAR_16]);
if (IS_ERR(VAR_8)) {
if (PTR_ERR(VAR_8) == -VAR_13 &&
NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
return 0;
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_16]);
return PTR_ERR(VAR_8);
}
VAR_10 = nft_delrule(&VAR_9, VAR_8);
} else if (VAR_2[VAR_17]) {
VAR_8 = nft_rule_lookup_byid(net, VAR_6, VAR_2[VAR_17]);
if (IS_ERR(VAR_8)) {
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_17]);
return PTR_ERR(VAR_8);
}
VAR_10 = nft_delrule(&VAR_9, VAR_8);
} else {
VAR_10 = nft_delrule_by_chain(&VAR_9);
}
} else {
list_for_each_entry(VAR_6, &VAR_7->chains, VAR_18) {
if (!nft_is_active_next(net, VAR_6))
continue;
if (nft_chain_is_bound(VAR_6))
continue;
VAR_9.chain = VAR_6;
VAR_10 = nft_delrule_by_chain(&VAR_9);
if (VAR_10 < 0)
break;
}
}
return VAR_10;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/before/1.json,"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,
			     const struct nlattr * const nla[])
{
	struct netlink_ext_ack *extack = info->extack;
	u8 genmask = nft_genmask_next(info->net);
	u8 family = info->nfmsg->nfgen_family;
	struct nft_chain *chain = NULL;
	struct net *net = info->net;
	struct nft_table *table;
	struct nft_rule *rule;
	struct nft_ctx ctx;
	int err = 0;

	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,
				 NETLINK_CB(skb).portid);
	if (IS_ERR(table)) {
		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);
		return PTR_ERR(table);
	}

	if (nla[NFTA_RULE_CHAIN]) {
		chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],
					 genmask);
		if (IS_ERR(chain)) {
			if (PTR_ERR(chain) == -ENOENT &&
			    NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
				return 0;

			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
			return PTR_ERR(chain);
		}
		if (nft_chain_binding(chain))
			return -EOPNOTSUPP;
	}

	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);

	if (chain) {
		if (nla[NFTA_RULE_HANDLE]) {
			rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);
			if (IS_ERR(rule)) {
				if (PTR_ERR(rule) == -ENOENT &&
				    NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE)
					return 0;

				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);
				return PTR_ERR(rule);
			}

			err = nft_delrule(&ctx, rule);
		} else if (nla[NFTA_RULE_ID]) {
			rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);
			if (IS_ERR(rule)) {
				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);
				return PTR_ERR(rule);
			}

			err = nft_delrule(&ctx, rule);
		} else {
			err = nft_delrule_by_chain(&ctx);
		}
	} else {
		list_for_each_entry(chain, &table->chains, list) {
			if (!nft_is_active_next(net, chain))
				continue;
			if (nft_chain_binding(chain))
				continue;

			ctx.chain = chain;
			err = nft_delrule_by_chain(&ctx);
			if (err < 0)
				break;
		}
	}

	return err;
}","static int nf_tables_delrule(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
			     const struct nlattr * const VAR_2[])
{
	struct netlink_ext_ack *VAR_3 = VAR_1->extack;
	u8 VAR_4 = nft_genmask_next(VAR_1->net);
	u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
	struct nft_chain *VAR_6 = NULL;
	struct net *net = VAR_1->net;
	struct nft_table *VAR_7;
	struct nft_rule *VAR_8;
	struct nft_ctx VAR_9;
	int VAR_10 = 0;

	VAR_7 = nft_table_lookup(net, VAR_2[VAR_11], VAR_5, VAR_4,
				 NETLINK_CB(VAR_0).portid);
	if (IS_ERR(VAR_7)) {
		NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_11]);
		return PTR_ERR(VAR_7);
	}

	if (VAR_2[VAR_12]) {
		VAR_6 = nft_chain_lookup(net, VAR_7, VAR_2[VAR_12],
					 VAR_4);
		if (IS_ERR(VAR_6)) {
			if (PTR_ERR(VAR_6) == -VAR_13 &&
			    NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
				return 0;

			NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_12]);
			return PTR_ERR(VAR_6);
		}
		if (nft_chain_binding(VAR_6))
			return -VAR_15;
	}

	nft_ctx_init(&VAR_9, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_6, VAR_2);

	if (VAR_6) {
		if (VAR_2[VAR_16]) {
			VAR_8 = nft_rule_lookup(VAR_6, VAR_2[VAR_16]);
			if (IS_ERR(VAR_8)) {
				if (PTR_ERR(VAR_8) == -VAR_13 &&
				    NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_14)
					return 0;

				NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_16]);
				return PTR_ERR(VAR_8);
			}

			VAR_10 = nft_delrule(&VAR_9, VAR_8);
		} else if (VAR_2[VAR_17]) {
			VAR_8 = nft_rule_lookup_byid(net, VAR_6, VAR_2[VAR_17]);
			if (IS_ERR(VAR_8)) {
				NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_17]);
				return PTR_ERR(VAR_8);
			}

			VAR_10 = nft_delrule(&VAR_9, VAR_8);
		} else {
			VAR_10 = nft_delrule_by_chain(&VAR_9);
		}
	} else {
		list_for_each_entry(VAR_6, &VAR_7->chains, VAR_18) {
			if (!nft_is_active_next(net, VAR_6))
				continue;
			if (nft_chain_binding(VAR_6))
				continue;

			VAR_9.chain = VAR_6;
			VAR_10 = nft_delrule_by_chain(&VAR_9);
			if (VAR_10 < 0)
				break;
		}
	}

	return VAR_10;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -29,7 +29,7 @@
 			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);
 			return PTR_ERR(chain);
 		}
-		if (nft_chain_is_bound(chain))
+		if (nft_chain_binding(chain))
 			return -EOPNOTSUPP;
 	}
 
@@ -63,7 +63,7 @@
 		list_for_each_entry(chain, &table->chains, list) {
 			if (!nft_is_active_next(net, chain))
 				continue;
-			if (nft_chain_is_bound(chain))
+			if (nft_chain_binding(chain))
 				continue;
 
 			ctx.chain = chain;","{'deleted_lines': ['\t\tif (nft_chain_is_bound(chain))', '\t\t\tif (nft_chain_is_bound(chain))'], 'added_lines': ['\t\tif (nft_chain_binding(chain))', '\t\t\tif (nft_chain_binding(chain))']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.

We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.

",6.6,MEDIUM,1,valid,,5
CVE-2023-5197,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H,1,torvalds/linux,"Chain binding only requires the rule addition/insertion command within
the same transaction. Removal of rules from chain bindings within the
same transaction makes no sense, userspace does not utilize this
feature. Replace nft_chain_is_bound() check to nft_chain_binding() in
rule deletion commands. Replace command implies a rule deletion, reject
this command too.

Rule flush command can also safely rely on this nft_chain_binding()
check because unbound chains are not allowed since 62e1e94b246e
(""netfilter: nf_tables: reject unbound chain set before commit phase"").

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
",f15f29fd4779be8a418b66e9d52979bb6d6c2325,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f15f29fd4779be8a418b66e9d52979bb6d6c2325,net/netfilter/nf_tables_api.c,nft_flush_table,"static int nft_flush_table(struct nft_ctx *ctx)
{
struct nft_flowtable *flowtable, *nft;
struct nft_chain *chain, *nc;
struct nft_object *obj, *ne;
struct nft_set *set, *ns;
int err;
list_for_each_entry(chain, &ctx->table->chains, list) {
if (!nft_is_active_next(ctx->net, chain))
continue;
if (nft_chain_is_bound(chain))
continue;
ctx->chain = chain;
err = nft_delrule_by_chain(ctx);
if (err < 0)
goto out;
}
list_for_each_entry_safe(set, ns, &ctx->table->sets, list) {
if (!nft_is_active_next(ctx->net, set))
continue;
if (nft_set_is_anonymous(set) &&
!list_empty(&set->bindings))
continue;
err = nft_delset(ctx, set);
if (err < 0)
goto out;
}
list_for_each_entry_safe(flowtable, nft, &ctx->table->flowtables, list) {
if (!nft_is_active_next(ctx->net, flowtable))
continue;
err = nft_delflowtable(ctx, flowtable);
if (err < 0)
goto out;
}
list_for_each_entry_safe(obj, ne, &ctx->table->objects, list) {
if (!nft_is_active_next(ctx->net, obj))
continue;
err = nft_delobj(ctx, obj);
if (err < 0)
goto out;
}
list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {
if (!nft_is_active_next(ctx->net, chain))
continue;
if (nft_chain_is_bound(chain))
continue;
ctx->chain = chain;
err = nft_delchain(ctx);
if (err < 0)
goto out;
}
err = nft_deltable(ctx);
out:
return err;
}","static int nft_flush_table(struct nft_ctx *VAR_0)
{
struct nft_flowtable *VAR_1, *VAR_2;
struct nft_chain *VAR_3, *VAR_4;
struct nft_object *VAR_5, *VAR_6;
struct nft_set *VAR_7, *VAR_8;
int VAR_9;
list_for_each_entry(VAR_3, &VAR_0->table->chains, VAR_10) {
if (!nft_is_active_next(VAR_0->net, VAR_3))
continue;
if (nft_chain_is_bound(VAR_3))
continue;
VAR_0->chain = VAR_3;
VAR_9 = nft_delrule_by_chain(VAR_0);
if (VAR_9 < 0)
goto out;
}
list_for_each_entry_safe(VAR_7, VAR_8, &VAR_0->table->sets, VAR_10) {
if (!nft_is_active_next(VAR_0->net, VAR_7))
continue;
if (nft_set_is_anonymous(VAR_7) &&
!list_empty(&VAR_7->bindings))
continue;
VAR_9 = nft_delset(VAR_0, VAR_7);
if (VAR_9 < 0)
goto out;
}
list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->table->flowtables, VAR_10) {
if (!nft_is_active_next(VAR_0->net, VAR_1))
continue;
VAR_9 = nft_delflowtable(VAR_0, VAR_1);
if (VAR_9 < 0)
goto out;
}
list_for_each_entry_safe(VAR_5, VAR_6, &VAR_0->table->objects, VAR_10) {
if (!nft_is_active_next(VAR_0->net, VAR_5))
continue;
VAR_9 = nft_delobj(VAR_0, VAR_5);
if (VAR_9 < 0)
goto out;
}
list_for_each_entry_safe(VAR_3, VAR_4, &VAR_0->table->chains, VAR_10) {
if (!nft_is_active_next(VAR_0->net, VAR_3))
continue;
if (nft_chain_is_bound(VAR_3))
continue;
VAR_0->chain = VAR_3;
VAR_9 = nft_delchain(VAR_0);
if (VAR_9 < 0)
goto out;
}
VAR_9 = nft_deltable(VAR_0);
out:
return VAR_9;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/before/2.json,"static int nft_flush_table(struct nft_ctx *ctx)
{
	struct nft_flowtable *flowtable, *nft;
	struct nft_chain *chain, *nc;
	struct nft_object *obj, *ne;
	struct nft_set *set, *ns;
	int err;

	list_for_each_entry(chain, &ctx->table->chains, list) {
		if (!nft_is_active_next(ctx->net, chain))
			continue;

		if (nft_chain_binding(chain))
			continue;

		ctx->chain = chain;

		err = nft_delrule_by_chain(ctx);
		if (err < 0)
			goto out;
	}

	list_for_each_entry_safe(set, ns, &ctx->table->sets, list) {
		if (!nft_is_active_next(ctx->net, set))
			continue;

		if (nft_set_is_anonymous(set) &&
		    !list_empty(&set->bindings))
			continue;

		err = nft_delset(ctx, set);
		if (err < 0)
			goto out;
	}

	list_for_each_entry_safe(flowtable, nft, &ctx->table->flowtables, list) {
		if (!nft_is_active_next(ctx->net, flowtable))
			continue;

		err = nft_delflowtable(ctx, flowtable);
		if (err < 0)
			goto out;
	}

	list_for_each_entry_safe(obj, ne, &ctx->table->objects, list) {
		if (!nft_is_active_next(ctx->net, obj))
			continue;

		err = nft_delobj(ctx, obj);
		if (err < 0)
			goto out;
	}

	list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {
		if (!nft_is_active_next(ctx->net, chain))
			continue;

		if (nft_chain_binding(chain))
			continue;

		ctx->chain = chain;

		err = nft_delchain(ctx);
		if (err < 0)
			goto out;
	}

	err = nft_deltable(ctx);
out:
	return err;
}","static int nft_flush_table(struct nft_ctx *VAR_0)
{
	struct nft_flowtable *VAR_1, *VAR_2;
	struct nft_chain *VAR_3, *VAR_4;
	struct nft_object *VAR_5, *VAR_6;
	struct nft_set *VAR_7, *VAR_8;
	int VAR_9;

	list_for_each_entry(VAR_3, &VAR_0->table->chains, VAR_10) {
		if (!nft_is_active_next(VAR_0->net, VAR_3))
			continue;

		if (nft_chain_binding(VAR_3))
			continue;

		VAR_0->chain = VAR_3;

		VAR_9 = nft_delrule_by_chain(VAR_0);
		if (VAR_9 < 0)
			goto out;
	}

	list_for_each_entry_safe(VAR_7, VAR_8, &VAR_0->table->sets, VAR_10) {
		if (!nft_is_active_next(VAR_0->net, VAR_7))
			continue;

		if (nft_set_is_anonymous(VAR_7) &&
		    !list_empty(&VAR_7->bindings))
			continue;

		VAR_9 = nft_delset(VAR_0, VAR_7);
		if (VAR_9 < 0)
			goto out;
	}

	list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->table->flowtables, VAR_10) {
		if (!nft_is_active_next(VAR_0->net, VAR_1))
			continue;

		VAR_9 = nft_delflowtable(VAR_0, VAR_1);
		if (VAR_9 < 0)
			goto out;
	}

	list_for_each_entry_safe(VAR_5, VAR_6, &VAR_0->table->objects, VAR_10) {
		if (!nft_is_active_next(VAR_0->net, VAR_5))
			continue;

		VAR_9 = nft_delobj(VAR_0, VAR_5);
		if (VAR_9 < 0)
			goto out;
	}

	list_for_each_entry_safe(VAR_3, VAR_4, &VAR_0->table->chains, VAR_10) {
		if (!nft_is_active_next(VAR_0->net, VAR_3))
			continue;

		if (nft_chain_binding(VAR_3))
			continue;

		VAR_0->chain = VAR_3;

		VAR_9 = nft_delchain(VAR_0);
		if (VAR_9 < 0)
			goto out;
	}

	VAR_9 = nft_deltable(VAR_0);
out:
	return VAR_9;
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 		if (!nft_is_active_next(ctx->net, chain))
 			continue;
 
-		if (nft_chain_is_bound(chain))
+		if (nft_chain_binding(chain))
 			continue;
 
 		ctx->chain = chain;
@@ -55,7 +55,7 @@
 		if (!nft_is_active_next(ctx->net, chain))
 			continue;
 
-		if (nft_chain_is_bound(chain))
+		if (nft_chain_binding(chain))
 			continue;
 
 		ctx->chain = chain;","{'deleted_lines': ['\t\tif (nft_chain_is_bound(chain))', '\t\tif (nft_chain_is_bound(chain))'], 'added_lines': ['\t\tif (nft_chain_binding(chain))', '\t\tif (nft_chain_binding(chain))']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.

We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.

",6.6,MEDIUM,1,valid,,5
CVE-2023-5197,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H,1,torvalds/linux,"Chain binding only requires the rule addition/insertion command within
the same transaction. Removal of rules from chain bindings within the
same transaction makes no sense, userspace does not utilize this
feature. Replace nft_chain_is_bound() check to nft_chain_binding() in
rule deletion commands. Replace command implies a rule deletion, reject
this command too.

Rule flush command can also safely rely on this nft_chain_binding()
check because unbound chains are not allowed since 62e1e94b246e
(""netfilter: nf_tables: reject unbound chain set before commit phase"").

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
",f15f29fd4779be8a418b66e9d52979bb6d6c2325,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f15f29fd4779be8a418b66e9d52979bb6d6c2325,net/netfilter/nf_tables_api.c,__nft_release_table,"static void __nft_release_table(struct net *net, struct nft_table *table)
{
struct nft_flowtable *flowtable, *nf;
struct nft_chain *chain, *nc;
struct nft_object *obj, *ne;
struct nft_rule *rule, *nr;
struct nft_set *set, *ns;
struct nft_ctx ctx = {
.net= net,
.family= NFPROTO_NETDEV,
};
ctx.family = table->family;
ctx.table = table;
list_for_each_entry(chain, &table->chains, list) {
if (nft_chain_is_bound(chain))
continue;
ctx.chain = chain;
list_for_each_entry_safe(rule, nr, &chain->rules, list) {
list_del(&rule->list);
nft_use_dec(&chain->use);
nf_tables_rule_release(&ctx, rule);
}
}
list_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {
list_del(&flowtable->list);
nft_use_dec(&table->use);
nf_tables_flowtable_destroy(flowtable);
}
list_for_each_entry_safe(set, ns, &table->sets, list) {
list_del(&set->list);
nft_use_dec(&table->use);
if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
nft_map_deactivate(&ctx, set);
nft_set_destroy(&ctx, set);
}
list_for_each_entry_safe(obj, ne, &table->objects, list) {
nft_obj_del(obj);
nft_use_dec(&table->use);
nft_obj_destroy(&ctx, obj);
}
list_for_each_entry_safe(chain, nc, &table->chains, list) {
ctx.chain = chain;
nft_chain_del(chain);
nft_use_dec(&table->use);
nf_tables_chain_destroy(&ctx);
}
nf_tables_table_destroy(&ctx);
}","static void __nft_release_table(struct net *net, struct nft_table *VAR_0)
{
struct nft_flowtable *VAR_1, *VAR_2;
struct nft_chain *VAR_3, *VAR_4;
struct nft_object *VAR_5, *VAR_6;
struct nft_rule *VAR_7, *VAR_8;
struct nft_set *VAR_9, *VAR_10;
struct nft_ctx VAR_11 = {
.net= net,
.family= VAR_12,
};
VAR_11.family = VAR_0->family;
VAR_11.table = VAR_0;
list_for_each_entry(VAR_3, &VAR_0->chains, VAR_13) {
if (nft_chain_is_bound(VAR_3))
continue;
VAR_11.chain = VAR_3;
list_for_each_entry_safe(VAR_7, VAR_8, &VAR_3->rules, VAR_13) {
list_del(&VAR_7->list);
nft_use_dec(&VAR_3->use);
nf_tables_rule_release(&VAR_11, VAR_7);
}
}
list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->flowtables, VAR_13) {
list_del(&VAR_1->list);
nft_use_dec(&VAR_0->use);
nf_tables_flowtable_destroy(VAR_1);
}
list_for_each_entry_safe(VAR_9, VAR_10, &VAR_0->sets, VAR_13) {
list_del(&VAR_9->list);
nft_use_dec(&VAR_0->use);
if (VAR_9->flags & (VAR_14 | VAR_15))
nft_map_deactivate(&VAR_11, VAR_9);
nft_set_destroy(&VAR_11, VAR_9);
}
list_for_each_entry_safe(VAR_5, VAR_6, &VAR_0->objects, VAR_13) {
nft_obj_del(VAR_5);
nft_use_dec(&VAR_0->use);
nft_obj_destroy(&VAR_11, VAR_5);
}
list_for_each_entry_safe(VAR_3, VAR_4, &VAR_0->chains, VAR_13) {
VAR_11.chain = VAR_3;
nft_chain_del(VAR_3);
nft_use_dec(&VAR_0->use);
nf_tables_chain_destroy(&VAR_11);
}
nf_tables_table_destroy(&VAR_11);
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/before/3.json,"static void __nft_release_table(struct net *net, struct nft_table *table)
{
	struct nft_flowtable *flowtable, *nf;
	struct nft_chain *chain, *nc;
	struct nft_object *obj, *ne;
	struct nft_rule *rule, *nr;
	struct nft_set *set, *ns;
	struct nft_ctx ctx = {
		.net	= net,
		.family	= NFPROTO_NETDEV,
	};

	ctx.family = table->family;
	ctx.table = table;
	list_for_each_entry(chain, &table->chains, list) {
		if (nft_chain_binding(chain))
			continue;

		ctx.chain = chain;
		list_for_each_entry_safe(rule, nr, &chain->rules, list) {
			list_del(&rule->list);
			nft_use_dec(&chain->use);
			nf_tables_rule_release(&ctx, rule);
		}
	}
	list_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {
		list_del(&flowtable->list);
		nft_use_dec(&table->use);
		nf_tables_flowtable_destroy(flowtable);
	}
	list_for_each_entry_safe(set, ns, &table->sets, list) {
		list_del(&set->list);
		nft_use_dec(&table->use);
		if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
			nft_map_deactivate(&ctx, set);

		nft_set_destroy(&ctx, set);
	}
	list_for_each_entry_safe(obj, ne, &table->objects, list) {
		nft_obj_del(obj);
		nft_use_dec(&table->use);
		nft_obj_destroy(&ctx, obj);
	}
	list_for_each_entry_safe(chain, nc, &table->chains, list) {
		ctx.chain = chain;
		nft_chain_del(chain);
		nft_use_dec(&table->use);
		nf_tables_chain_destroy(&ctx);
	}
	nf_tables_table_destroy(&ctx);
}","static void __nft_release_table(struct net *net, struct nft_table *VAR_0)
{
	struct nft_flowtable *VAR_1, *VAR_2;
	struct nft_chain *VAR_3, *VAR_4;
	struct nft_object *VAR_5, *VAR_6;
	struct nft_rule *VAR_7, *VAR_8;
	struct nft_set *VAR_9, *VAR_10;
	struct nft_ctx VAR_11 = {
		.net	= net,
		.family	= VAR_12,
	};

	VAR_11.family = VAR_0->family;
	VAR_11.table = VAR_0;
	list_for_each_entry(VAR_3, &VAR_0->chains, VAR_13) {
		if (nft_chain_binding(VAR_3))
			continue;

		VAR_11.chain = VAR_3;
		list_for_each_entry_safe(VAR_7, VAR_8, &VAR_3->rules, VAR_13) {
			list_del(&VAR_7->list);
			nft_use_dec(&VAR_3->use);
			nf_tables_rule_release(&VAR_11, VAR_7);
		}
	}
	list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->flowtables, VAR_13) {
		list_del(&VAR_1->list);
		nft_use_dec(&VAR_0->use);
		nf_tables_flowtable_destroy(VAR_1);
	}
	list_for_each_entry_safe(VAR_9, VAR_10, &VAR_0->sets, VAR_13) {
		list_del(&VAR_9->list);
		nft_use_dec(&VAR_0->use);
		if (VAR_9->flags & (VAR_14 | VAR_15))
			nft_map_deactivate(&VAR_11, VAR_9);

		nft_set_destroy(&VAR_11, VAR_9);
	}
	list_for_each_entry_safe(VAR_5, VAR_6, &VAR_0->objects, VAR_13) {
		nft_obj_del(VAR_5);
		nft_use_dec(&VAR_0->use);
		nft_obj_destroy(&VAR_11, VAR_5);
	}
	list_for_each_entry_safe(VAR_3, VAR_4, &VAR_0->chains, VAR_13) {
		VAR_11.chain = VAR_3;
		nft_chain_del(VAR_3);
		nft_use_dec(&VAR_0->use);
		nf_tables_chain_destroy(&VAR_11);
	}
	nf_tables_table_destroy(&VAR_11);
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
 	ctx.family = table->family;
 	ctx.table = table;
 	list_for_each_entry(chain, &table->chains, list) {
-		if (nft_chain_is_bound(chain))
+		if (nft_chain_binding(chain))
 			continue;
 
 		ctx.chain = chain;","{'deleted_lines': ['\t\tif (nft_chain_is_bound(chain))'], 'added_lines': ['\t\tif (nft_chain_binding(chain))']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.

We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.

",6.6,MEDIUM,1,valid,,5
CVE-2023-5197,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H,1,torvalds/linux,"Chain binding only requires the rule addition/insertion command within
the same transaction. Removal of rules from chain bindings within the
same transaction makes no sense, userspace does not utilize this
feature. Replace nft_chain_is_bound() check to nft_chain_binding() in
rule deletion commands. Replace command implies a rule deletion, reject
this command too.

Rule flush command can also safely rely on this nft_chain_binding()
check because unbound chains are not allowed since 62e1e94b246e
(""netfilter: nf_tables: reject unbound chain set before commit phase"").

Fixes: d0e2c7de92c7 (""netfilter: nf_tables: add NFT_CHAIN_BINDING"")
Reported-by: Kevin Rich <kevinrich1337@gmail.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
",f15f29fd4779be8a418b66e9d52979bb6d6c2325,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f15f29fd4779be8a418b66e9d52979bb6d6c2325,net/netfilter/nf_tables_api.c,nf_tables_delchain,"static int nf_tables_delchain(struct sk_buff *skb, const struct nfnl_info *info,
const struct nlattr * const nla[])
{
struct netlink_ext_ack *extack = info->extack;
u8 genmask = nft_genmask_next(info->net);
u8 family = info->nfmsg->nfgen_family;
struct net *net = info->net;
const struct nlattr *attr;
struct nft_table *table;
struct nft_chain *chain;
struct nft_rule *rule;
struct nft_ctx ctx;
u64 handle;
u32 use;
int err;
table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,
NETLINK_CB(skb).portid);
if (IS_ERR(table)) {
NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);
return PTR_ERR(table);
}
if (nla[NFTA_CHAIN_HANDLE]) {
attr = nla[NFTA_CHAIN_HANDLE];
handle = be64_to_cpu(nla_get_be64(attr));
chain = nft_chain_lookup_byhandle(table, handle, genmask);
} else {
attr = nla[NFTA_CHAIN_NAME];
chain = nft_chain_lookup(net, table, attr, genmask);
}
if (IS_ERR(chain)) {
if (PTR_ERR(chain) == -ENOENT &&
NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYCHAIN)
return 0;
NL_SET_BAD_ATTR(extack, attr);
return PTR_ERR(chain);
}
nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);
if (nla[NFTA_CHAIN_HOOK]) {
if (chain->flags & NFT_CHAIN_HW_OFFLOAD)
return -EOPNOTSUPP;
if (nft_is_base_chain(chain)) {
struct nft_base_chain *basechain = nft_base_chain(chain);
if (nft_base_chain_netdev(table->family, basechain->ops.hooknum))
return nft_delchain_hook(&ctx, basechain, extack);
}
}
if (info->nlh->nlmsg_flags & NLM_F_NONREC &&
chain->use > 0)
return -EBUSY;
use = chain->use;
list_for_each_entry(rule, &chain->rules, list) {
if (!nft_is_active_next(net, rule))
continue;
use--;
err = nft_delrule(&ctx, rule);
if (err < 0)
return err;
}
if (use > 0) {
NL_SET_BAD_ATTR(extack, attr);
return -EBUSY;
}
return nft_delchain(&ctx);
}","static int nf_tables_delchain(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
const struct nlattr * const VAR_2[])
{
struct netlink_ext_ack *VAR_3 = VAR_1->extack;
u8 VAR_4 = nft_genmask_next(VAR_1->net);
u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
struct net *net = VAR_1->net;
const struct nlattr *VAR_6;
struct nft_table *VAR_7;
struct nft_chain *VAR_8;
struct nft_rule *VAR_9;
struct nft_ctx VAR_10;
u64 VAR_11;
u32 VAR_12;
int VAR_13;
VAR_7 = nft_table_lookup(net, VAR_2[VAR_14], VAR_5, VAR_4,
NETLINK_CB(VAR_0).portid);
if (IS_ERR(VAR_7)) {
NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_14]);
return PTR_ERR(VAR_7);
}
if (VAR_2[VAR_15]) {
VAR_6 = VAR_2[VAR_15];
VAR_11 = be64_to_cpu(nla_get_be64(VAR_6));
VAR_8 = nft_chain_lookup_byhandle(VAR_7, VAR_11, VAR_4);
} else {
VAR_6 = VAR_2[VAR_16];
VAR_8 = nft_chain_lookup(net, VAR_7, VAR_6, VAR_4);
}
if (IS_ERR(VAR_8)) {
if (PTR_ERR(VAR_8) == -VAR_17 &&
NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_18)
return 0;
NL_SET_BAD_ATTR(VAR_3, VAR_6);
return PTR_ERR(VAR_8);
}
nft_ctx_init(&VAR_10, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_8, VAR_2);
if (VAR_2[VAR_19]) {
if (VAR_8->flags & VAR_20)
return -VAR_21;
if (nft_is_base_chain(VAR_8)) {
struct nft_base_chain *VAR_22 = nft_base_chain(VAR_8);
if (nft_base_chain_netdev(VAR_7->family, VAR_22->ops.hooknum))
return nft_delchain_hook(&VAR_10, VAR_22, VAR_3);
}
}
if (VAR_1->nlh->nlmsg_flags & VAR_23 &&
VAR_8->use > 0)
return -VAR_24;
VAR_12 = VAR_8->use;
list_for_each_entry(VAR_9, &VAR_8->rules, VAR_25) {
if (!nft_is_active_next(net, VAR_9))
continue;
VAR_12--;
VAR_13 = nft_delrule(&VAR_10, VAR_9);
if (VAR_13 < 0)
return VAR_13;
}
if (VAR_12 > 0) {
NL_SET_BAD_ATTR(VAR_3, VAR_6);
return -VAR_24;
}
return nft_delchain(&VAR_10);
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/before/4.json,"static int nf_tables_delchain(struct sk_buff *skb, const struct nfnl_info *info,
			      const struct nlattr * const nla[])
{
	struct netlink_ext_ack *extack = info->extack;
	u8 genmask = nft_genmask_next(info->net);
	u8 family = info->nfmsg->nfgen_family;
	struct net *net = info->net;
	const struct nlattr *attr;
	struct nft_table *table;
	struct nft_chain *chain;
	struct nft_rule *rule;
	struct nft_ctx ctx;
	u64 handle;
	u32 use;
	int err;

	table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,
				 NETLINK_CB(skb).portid);
	if (IS_ERR(table)) {
		NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);
		return PTR_ERR(table);
	}

	if (nla[NFTA_CHAIN_HANDLE]) {
		attr = nla[NFTA_CHAIN_HANDLE];
		handle = be64_to_cpu(nla_get_be64(attr));
		chain = nft_chain_lookup_byhandle(table, handle, genmask);
	} else {
		attr = nla[NFTA_CHAIN_NAME];
		chain = nft_chain_lookup(net, table, attr, genmask);
	}
	if (IS_ERR(chain)) {
		if (PTR_ERR(chain) == -ENOENT &&
		    NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYCHAIN)
			return 0;

		NL_SET_BAD_ATTR(extack, attr);
		return PTR_ERR(chain);
	}

	if (nft_chain_binding(chain))
		return -EOPNOTSUPP;

	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);

	if (nla[NFTA_CHAIN_HOOK]) {
		if (chain->flags & NFT_CHAIN_HW_OFFLOAD)
			return -EOPNOTSUPP;

		if (nft_is_base_chain(chain)) {
			struct nft_base_chain *basechain = nft_base_chain(chain);

			if (nft_base_chain_netdev(table->family, basechain->ops.hooknum))
				return nft_delchain_hook(&ctx, basechain, extack);
		}
	}

	if (info->nlh->nlmsg_flags & NLM_F_NONREC &&
	    chain->use > 0)
		return -EBUSY;

	use = chain->use;
	list_for_each_entry(rule, &chain->rules, list) {
		if (!nft_is_active_next(net, rule))
			continue;
		use--;

		err = nft_delrule(&ctx, rule);
		if (err < 0)
			return err;
	}

	/* There are rules and elements that are still holding references to us,
	 * we cannot do a recursive removal in this case.
	 */
	if (use > 0) {
		NL_SET_BAD_ATTR(extack, attr);
		return -EBUSY;
	}

	return nft_delchain(&ctx);
}","static int nf_tables_delchain(struct sk_buff *VAR_0, const struct nfnl_info *VAR_1,
			      const struct nlattr * const VAR_2[])
{
	struct netlink_ext_ack *VAR_3 = VAR_1->extack;
	u8 VAR_4 = nft_genmask_next(VAR_1->net);
	u8 VAR_5 = VAR_1->nfmsg->nfgen_family;
	struct net *net = VAR_1->net;
	const struct nlattr *VAR_6;
	struct nft_table *VAR_7;
	struct nft_chain *VAR_8;
	struct nft_rule *VAR_9;
	struct nft_ctx VAR_10;
	u64 VAR_11;
	u32 VAR_12;
	int VAR_13;

	VAR_7 = nft_table_lookup(net, VAR_2[VAR_14], VAR_5, VAR_4,
				 NETLINK_CB(VAR_0).portid);
	if (IS_ERR(VAR_7)) {
		NL_SET_BAD_ATTR(VAR_3, VAR_2[VAR_14]);
		return PTR_ERR(VAR_7);
	}

	if (VAR_2[VAR_15]) {
		VAR_6 = VAR_2[VAR_15];
		VAR_11 = be64_to_cpu(nla_get_be64(VAR_6));
		VAR_8 = nft_chain_lookup_byhandle(VAR_7, VAR_11, VAR_4);
	} else {
		VAR_6 = VAR_2[VAR_16];
		VAR_8 = nft_chain_lookup(net, VAR_7, VAR_6, VAR_4);
	}
	if (IS_ERR(VAR_8)) {
		if (PTR_ERR(VAR_8) == -VAR_17 &&
		    NFNL_MSG_TYPE(VAR_1->nlh->nlmsg_type) == VAR_18)
			return 0;

		NL_SET_BAD_ATTR(VAR_3, VAR_6);
		return PTR_ERR(VAR_8);
	}

	if (nft_chain_binding(VAR_8))
		return -VAR_19;

	nft_ctx_init(&VAR_10, net, VAR_0, VAR_1->nlh, VAR_5, VAR_7, VAR_8, VAR_2);

	if (VAR_2[VAR_20]) {
		if (VAR_8->flags & VAR_21)
			return -VAR_19;

		if (nft_is_base_chain(VAR_8)) {
			struct nft_base_chain *VAR_22 = nft_base_chain(VAR_8);

			if (nft_base_chain_netdev(VAR_7->family, VAR_22->ops.hooknum))
				return nft_delchain_hook(&VAR_10, VAR_22, VAR_3);
		}
	}

	if (VAR_1->nlh->nlmsg_flags & VAR_23 &&
	    VAR_8->use > 0)
		return -VAR_24;

	VAR_12 = VAR_8->use;
	list_for_each_entry(VAR_9, &VAR_8->rules, VAR_25) {
		if (!nft_is_active_next(net, VAR_9))
			continue;
		VAR_12--;

		VAR_13 = nft_delrule(&VAR_10, VAR_9);
		if (VAR_13 < 0)
			return VAR_13;
	}

	/* COMMENT_0 */
                                                  
    
	if (VAR_12 > 0) {
		NL_SET_BAD_ATTR(VAR_3, VAR_6);
		return -VAR_24;
	}

	return nft_delchain(&VAR_10);
}",torvalds/linux/f15f29fd4779be8a418b66e9d52979bb6d6c2325/nf_tables_api.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -38,6 +38,9 @@
 		return PTR_ERR(chain);
 	}
 
+	if (nft_chain_binding(chain))
+		return -EOPNOTSUPP;
+
 	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);
 
 	if (nla[NFTA_CHAIN_HOOK]) {","{'deleted_lines': [], 'added_lines': ['\tif (nft_chain_binding(chain))', '\t\treturn -EOPNOTSUPP;', '']}",True,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.

We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.

",6.6,MEDIUM,1,valid,,5
CVE-2023-5371,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,wireshark,"RTPS: Check for signed overflow

The offset is a signed integer, and we use negative offsets
to mean ""offset counting from the end of the tvb."" That means
that we can still have an excessive loop without unsigned overflow
or running off the end of the tvb, if the result of adding a large
unsigned integer to the offset results in a small negative number.

Just check if the result of the addition makes the offset move
backwards.

Fix #19322
",0de07f8fe4f8e06da9084485e64a24c8f85a20f4,https://gitlab.com/wireshark/wireshark/-/commit/0de07f8fe4f8e06da9084485e64a24c8f85a20f4,epan/dissectors/packet-rtps.c,check_offset_addition,"static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
{
if (offset > G_MAXUINT32 - value) {
proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, ""Offset value too large: %u"", value);
THROW(ReportedBoundsError);
}
return offset + value;
}","static guint32 check_offset_addition(guint32 VAR_0, guint32 VAR_1, proto_tree *VAR_2, packet_info *VAR_3, tvbuff_t *VAR_4)
{
if (VAR_0 > VAR_5 - VAR_1) {
proto_tree_add_expert_format(VAR_2, VAR_3, &VAR_6, VAR_4, 0, 0, ""Offset value too large: %u"", VAR_1);
THROW(VAR_7);
}
return VAR_0 + VAR_1;
}",wireshark/0de07f8fe4f8e06da9084485e64a24c8f85a20f4/packet-rtps.c/vul/before/0.json,"static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
{
    gint new_offset = offset + (gint)value;
    if (new_offset < offset) {
        proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, ""Offset value too large: %u"", value);
        THROW(ReportedBoundsError);
    }
    return new_offset;
}","static gint check_offset_addition(gint VAR_0, guint32 VAR_1, proto_tree *VAR_2, packet_info *VAR_3, tvbuff_t *VAR_4)
{
    gint VAR_5 = VAR_0 + (gint)VAR_1;
    if (VAR_5 < VAR_0) {
        proto_tree_add_expert_format(VAR_2, VAR_3, &VAR_6, VAR_4, 0, 0, ""Offset value too large: %u"", VAR_1);
        THROW(VAR_7);
    }
    return VAR_5;
}",wireshark/0de07f8fe4f8e06da9084485e64a24c8f85a20f4/packet-rtps.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,9 @@
-static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
+static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
 {
-    if (offset > G_MAXUINT32 - value) {
+    gint new_offset = offset + (gint)value;
+    if (new_offset < offset) {
         proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, ""Offset value too large: %u"", value);
         THROW(ReportedBoundsError);
     }
-    return offset + value;
+    return new_offset;
 }","{'deleted_lines': ['static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)', '    if (offset > G_MAXUINT32 - value) {', '    return offset + value;'], 'added_lines': ['static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)', '    gint new_offset = offset + (gint)value;', '    if (new_offset < offset) {', '    return new_offset;']}",True,RTPS dissector memory leak in Wireshark 4.0.0 to 4.0.8 and 3.6.0 to 3.6.16 allows denial of service via packet injection or crafted capture file,6.5,MEDIUM,1,valid,,5
CVE-2023-40128,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"malloc-fail: Fix OOB read after xmlRegGetCounter

Found with libFuzzer, see #344.

(cherry picked from commit 1743c4c3fc58cf38ecce68db9de51d0f3651e033)

I also copied the error label from
e64653c0e7975594e27d7de2ed4be062c1e4ad03 to fix the build failure.

Bug: http://b/274231102
Test: TreeHugger
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e6ed17dfe8e36e5618a592a600720bd61e015cc)
Merged-In: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
Change-Id: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
",1ccf89b87a3969edd56956e2d447f896037c8be7,https://android.googlesource.com/platform/external/libxml2/+/1ccf89b87a3969edd56956e2d447f896037c8be7,xmlregexp.c,xmlAutomataNewCountTrans2,"xmlAutomataStatePtr
xmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
xmlAutomataStatePtr to, const xmlChar *token,
const xmlChar *token2,
int min, int max, void *data) {
xmlRegAtomPtr atom;
int counter;
if ((am == NULL) || (from == NULL) || (token == NULL))
return(NULL);
if (min < 0)
return(NULL);
if ((max < min) || (max < 1))
return(NULL);
atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
if (atom == NULL)
return(NULL);
if ((token2 == NULL) || (*token2 == 0)) {
atom->valuep = xmlStrdup(token);
} else {
int lenn, lenp;
xmlChar *str;
lenn = strlen((char *) token2);
lenp = strlen((char *) token);
str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
if (str == NULL) {
xmlRegFreeAtom(atom);
return(NULL);
}
memcpy(&str[0], token, lenp);
str[lenp] = '|';
memcpy(&str[lenp + 1], token2, lenn);
str[lenn + lenp + 1] = 0;
atom->valuep = str;
}
atom->data = data;
if (min == 0)
atom->min = 1;
else
atom->min = min;
atom->max = max;
counter = xmlRegGetCounter(am);
am->counters[counter].min = min;
am->counters[counter].max = max;
if (to == NULL) {
to = xmlRegNewState(am);
xmlRegStatePush(am, to);
}
xmlRegStateAddTrans(am, from, atom, to, counter, -1);
xmlRegAtomPush(am, atom);
am->state = to;
if (to == NULL)
to = am->state;
if (to == NULL)
return(NULL);
if (min == 0)
xmlFAGenerateEpsilonTransition(am, from, to);
return(to);
}","xmlAutomataStatePtr
xmlAutomataNewCountTrans2(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
const xmlChar *VAR_4,
int VAR_5, int VAR_6, void *VAR_7) {
xmlRegAtomPtr VAR_8;
int VAR_9;
if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
return(NULL);
if (VAR_5 < 0)
return(NULL);
if ((VAR_6 < VAR_5) || (VAR_6 < 1))
return(NULL);
VAR_8 = xmlRegNewAtom(VAR_0, VAR_10);
if (VAR_8 == NULL)
return(NULL);
if ((VAR_4 == NULL) || (*VAR_4 == 0)) {
VAR_8->valuep = xmlStrdup(VAR_3);
} else {
int VAR_11, VAR_12;
xmlChar *VAR_13;
VAR_11 = strlen((char *) VAR_4);
VAR_12 = strlen((char *) VAR_3);
VAR_13 = (xmlChar *) xmlMallocAtomic(VAR_11 + VAR_12 + 2);
if (VAR_13 == NULL) {
xmlRegFreeAtom(VAR_8);
return(NULL);
}
memcpy(&VAR_13[0], VAR_3, VAR_12);
VAR_13[VAR_12] = '|';
memcpy(&VAR_13[VAR_12 + 1], VAR_4, VAR_11);
VAR_13[VAR_11 + VAR_12 + 1] = 0;
VAR_8->valuep = VAR_13;
}
VAR_8->data = VAR_7;
if (VAR_5 == 0)
VAR_8->min = 1;
else
VAR_8->min = VAR_5;
VAR_8->max = VAR_6;
VAR_9 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_9].min = VAR_5;
VAR_0->counters[VAR_9].max = VAR_6;
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_2);
}
xmlRegStateAddTrans(VAR_0, VAR_1, VAR_8, VAR_2, VAR_9, -1);
xmlRegAtomPush(VAR_0, VAR_8);
VAR_0->state = VAR_2;
if (VAR_2 == NULL)
VAR_2 = VAR_0->state;
if (VAR_2 == NULL)
return(NULL);
if (VAR_5 == 0)
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
return(VAR_2);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/before/0.json,"xmlAutomataStatePtr
xmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
			 xmlAutomataStatePtr to, const xmlChar *token,
			 const xmlChar *token2,
			 int min, int max, void *data) {
    xmlRegAtomPtr atom;
    int counter;

    if ((am == NULL) || (from == NULL) || (token == NULL))
	return(NULL);
    if (min < 0)
	return(NULL);
    if ((max < min) || (max < 1))
	return(NULL);
    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
    if (atom == NULL)
	return(NULL);
    if ((token2 == NULL) || (*token2 == 0)) {
	atom->valuep = xmlStrdup(token);
    } else {
	int lenn, lenp;
	xmlChar *str;

	lenn = strlen((char *) token2);
	lenp = strlen((char *) token);

	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
	if (str == NULL) {
	    xmlRegFreeAtom(atom);
	    return(NULL);
	}
	memcpy(&str[0], token, lenp);
	str[lenp] = '|';
	memcpy(&str[lenp + 1], token2, lenn);
	str[lenn + lenp + 1] = 0;

	atom->valuep = str;
    }
    atom->data = data;
    if (min == 0)
	atom->min = 1;
    else
	atom->min = min;
    atom->max = max;

    /*
     * associate a counter to the transition.
     */
    counter = xmlRegGetCounter(am);
    if (counter < 0)
        goto error;
    am->counters[counter].min = min;
    am->counters[counter].max = max;

    /* xmlFAGenerateTransitions(am, from, to, atom); */
    if (to == NULL) {
        to = xmlRegNewState(am);
	xmlRegStatePush(am, to);
    }
    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
    xmlRegAtomPush(am, atom);
    am->state = to;

    if (to == NULL)
	to = am->state;
    if (to == NULL)
	return(NULL);
    if (min == 0)
	xmlFAGenerateEpsilonTransition(am, from, to);
    return(to);

error:
    xmlRegFreeAtom(atom);
    return(NULL);
}","xmlAutomataStatePtr
xmlAutomataNewCountTrans2(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
			 xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
			 const xmlChar *VAR_4,
			 int VAR_5, int VAR_6, void *VAR_7) {
    xmlRegAtomPtr VAR_8;
    int VAR_9;

    if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
	return(NULL);
    if (VAR_5 < 0)
	return(NULL);
    if ((VAR_6 < VAR_5) || (VAR_6 < 1))
	return(NULL);
    VAR_8 = xmlRegNewAtom(VAR_0, VAR_10);
    if (VAR_8 == NULL)
	return(NULL);
    if ((VAR_4 == NULL) || (*VAR_4 == 0)) {
	VAR_8->valuep = xmlStrdup(VAR_3);
    } else {
	int VAR_11, VAR_12;
	xmlChar *VAR_13;

	VAR_11 = strlen((char *) VAR_4);
	VAR_12 = strlen((char *) VAR_3);

	VAR_13 = (xmlChar *) xmlMallocAtomic(VAR_11 + VAR_12 + 2);
	if (VAR_13 == NULL) {
	    xmlRegFreeAtom(VAR_8);
	    return(NULL);
	}
	memcpy(&VAR_13[0], VAR_3, VAR_12);
	VAR_13[VAR_12] = '|';
	memcpy(&VAR_13[VAR_12 + 1], VAR_4, VAR_11);
	VAR_13[VAR_11 + VAR_12 + 1] = 0;

	VAR_8->valuep = VAR_13;
    }
    VAR_8->data = VAR_7;
    if (VAR_5 == 0)
	VAR_8->min = 1;
    else
	VAR_8->min = VAR_5;
    VAR_8->max = VAR_6;

    /* COMMENT_0 */
                                             
       
    VAR_9 = xmlRegGetCounter(VAR_0);
    if (VAR_9 < 0)
        goto error;
    VAR_0->counters[VAR_9].min = VAR_5;
    VAR_0->counters[VAR_9].max = VAR_6;

    /* COMMENT_3 */
    if (VAR_2 == NULL) {
        VAR_2 = xmlRegNewState(VAR_0);
	xmlRegStatePush(VAR_0, VAR_2);
    }
    xmlRegStateAddTrans(VAR_0, VAR_1, VAR_8, VAR_2, VAR_9, -1);
    xmlRegAtomPush(VAR_0, VAR_8);
    VAR_0->state = VAR_2;

    if (VAR_2 == NULL)
	VAR_2 = VAR_0->state;
    if (VAR_2 == NULL)
	return(NULL);
    if (VAR_5 == 0)
	xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
    return(VAR_2);

error:
    xmlRegFreeAtom(VAR_8);
    return(NULL);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,6 +47,8 @@
      * associate a counter to the transition.
      */
     counter = xmlRegGetCounter(am);
+    if (counter < 0)
+        goto error;
     am->counters[counter].min = min;
     am->counters[counter].max = max;
 
@@ -66,4 +68,8 @@
     if (min == 0)
 	xmlFAGenerateEpsilonTransition(am, from, to);
     return(to);
+
+error:
+    xmlRegFreeAtom(atom);
+    return(NULL);
 }","{'deleted_lines': [], 'added_lines': ['    if (counter < 0)', '        goto error;', '', 'error:', '    xmlRegFreeAtom(atom);', '    return(NULL);']}",True,"In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40128,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"malloc-fail: Fix OOB read after xmlRegGetCounter

Found with libFuzzer, see #344.

(cherry picked from commit 1743c4c3fc58cf38ecce68db9de51d0f3651e033)

I also copied the error label from
e64653c0e7975594e27d7de2ed4be062c1e4ad03 to fix the build failure.

Bug: http://b/274231102
Test: TreeHugger
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e6ed17dfe8e36e5618a592a600720bd61e015cc)
Merged-In: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
Change-Id: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
",1ccf89b87a3969edd56956e2d447f896037c8be7,https://android.googlesource.com/platform/external/libxml2/+/1ccf89b87a3969edd56956e2d447f896037c8be7,xmlregexp.c,xmlFAGenerateTransitions,"static int
xmlFAGenerateTransitions(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr from,
xmlRegStatePtr to, xmlRegAtomPtr atom) {
xmlRegStatePtr end;
int nullable = 0;
if (atom == NULL) {
ERROR(""generate transition: atom == NULL"");
return(-1);
}
if (atom->type == XML_REGEXP_SUBREG) {
if (xmlRegAtomPush(ctxt, atom) < 0) {
return(-1);
}
if ((to != NULL) && (atom->stop != to) &&
(atom->quant != XML_REGEXP_QUANT_RANGE)) {
xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
#ifdef DV
} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
(atom->quant != XML_REGEXP_QUANT_ONCE)) {
to = xmlRegNewState(ctxt);
xmlRegStatePush(ctxt, to);
ctxt->state = to;
xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
#endif
}
switch (atom->quant) {
case XML_REGEXP_QUANT_OPT:
atom->quant = XML_REGEXP_QUANT_ONCE;
if (to == NULL) {
xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
ctxt->state);
} else {
xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
}
break;
case XML_REGEXP_QUANT_MULT:
atom->quant = XML_REGEXP_QUANT_ONCE;
xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
break;
case XML_REGEXP_QUANT_PLUS:
atom->quant = XML_REGEXP_QUANT_ONCE;
xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
break;
case XML_REGEXP_QUANT_RANGE: {
int counter;
xmlRegStatePtr inter, newstate;
if (to != NULL) {
newstate = to;
} else {
newstate = xmlRegNewState(ctxt);
xmlRegStatePush(ctxt, newstate);
}
if ((atom->min == 0) && (atom->start0 == NULL)) {
xmlRegAtomPtr copy;
copy = xmlRegCopyAtom(ctxt, atom);
if (copy == NULL)
return(-1);
copy->quant = XML_REGEXP_QUANT_ONCE;
copy->min = 0;
copy->max = 0;
if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
< 0)
return(-1);
inter = ctxt->state;
counter = xmlRegGetCounter(ctxt);
ctxt->counters[counter].min = atom->min - 1;
ctxt->counters[counter].max = atom->max - 1;
xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
atom->stop, counter);
xmlFAGenerateCountedTransition(ctxt, inter,
newstate, counter);
xmlFAGenerateEpsilonTransition(ctxt, atom->start,
newstate);
} else {
counter = xmlRegGetCounter(ctxt);
ctxt->counters[counter].min = atom->min - 1;
ctxt->counters[counter].max = atom->max - 1;
xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
atom->start, counter);
xmlFAGenerateCountedTransition(ctxt, atom->stop,
newstate, counter);
if (atom->min == 0)
xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
newstate);
}
atom->min = 0;
atom->max = 0;
atom->quant = XML_REGEXP_QUANT_ONCE;
ctxt->state = newstate;
}
default:
break;
}
return(0);
}
if ((atom->min == 0) && (atom->max == 0) &&
(atom->quant == XML_REGEXP_QUANT_RANGE)) {
if (to == NULL) {
to = xmlRegNewState(ctxt);
if (to != NULL)
xmlRegStatePush(ctxt, to);
else {
return(-1);
}
}
xmlFAGenerateEpsilonTransition(ctxt, from, to);
ctxt->state = to;
xmlRegFreeAtom(atom);
return(0);
}
if (to == NULL) {
to = xmlRegNewState(ctxt);
if (to != NULL)
xmlRegStatePush(ctxt, to);
else {
return(-1);
}
}
end = to;
if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
(atom->quant == XML_REGEXP_QUANT_PLUS)) {
xmlRegStatePtr tmp;
tmp = xmlRegNewState(ctxt);
if (tmp != NULL)
xmlRegStatePush(ctxt, tmp);
else {
return(-1);
}
xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
to = tmp;
}
if (xmlRegAtomPush(ctxt, atom) < 0) {
return(-1);
}
if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
(atom->min == 0) && (atom->max > 0)) {
nullable = 1;
atom->min = 1;
if (atom->max == 1)
atom->quant = XML_REGEXP_QUANT_OPT;
}
xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
ctxt->state = end;
switch (atom->quant) {
case XML_REGEXP_QUANT_OPT:
atom->quant = XML_REGEXP_QUANT_ONCE;
xmlFAGenerateEpsilonTransition(ctxt, from, to);
break;
case XML_REGEXP_QUANT_MULT:
atom->quant = XML_REGEXP_QUANT_ONCE;
xmlFAGenerateEpsilonTransition(ctxt, from, to);
xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
break;
case XML_REGEXP_QUANT_PLUS:
atom->quant = XML_REGEXP_QUANT_ONCE;
xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
break;
case XML_REGEXP_QUANT_RANGE:
if (nullable)
xmlFAGenerateEpsilonTransition(ctxt, from, to);
break;
default:
break;
}
return(0);
}","static int
xmlFAGenerateTransitions(xmlRegParserCtxtPtr VAR_0, xmlRegStatePtr VAR_1,
xmlRegStatePtr VAR_2, xmlRegAtomPtr VAR_3) {
xmlRegStatePtr VAR_4;
int VAR_5 = 0;
if (VAR_3 == NULL) {
ERROR(""generate transition: atom == NULL"");
return(-1);
}
if (VAR_3->type == VAR_6) {
if (xmlRegAtomPush(VAR_0, VAR_3) < 0) {
return(-1);
}
if ((VAR_2 != NULL) && (VAR_3->stop != VAR_2) &&
(VAR_3->quant != VAR_7)) {
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_2);
#ifdef VAR_8
} else if ((VAR_2 == NULL) && (VAR_3->quant != VAR_7) &&
(VAR_3->quant != VAR_9)) {
VAR_2 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_2);
VAR_0->state = VAR_2;
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_2);
#endif
}
switch (VAR_3->quant) {
case VAR_10:
VAR_3->quant = VAR_9;
if (VAR_2 == NULL) {
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, 0);
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop,
VAR_0->state);
} else {
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, VAR_2);
}
break;
case VAR_11:
VAR_3->quant = VAR_9;
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, VAR_3->stop);
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_3->start);
break;
case VAR_12:
VAR_3->quant = VAR_9;
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_3->start);
break;
case VAR_7: {
int VAR_13;
xmlRegStatePtr VAR_14, VAR_15;
if (VAR_2 != NULL) {
VAR_15 = VAR_2;
} else {
VAR_15 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_15);
}
if ((VAR_3->min == 0) && (VAR_3->start0 == NULL)) {
xmlRegAtomPtr VAR_16;
VAR_16 = xmlRegCopyAtom(VAR_0, VAR_3);
if (VAR_16 == NULL)
return(-1);
VAR_16->quant = VAR_9;
VAR_16->min = 0;
VAR_16->max = 0;
if (xmlFAGenerateTransitions(VAR_0, VAR_3->start, NULL, VAR_16)
< 0)
return(-1);
VAR_14 = VAR_0->state;
VAR_13 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_13].min = VAR_3->min - 1;
VAR_0->counters[VAR_13].max = VAR_3->max - 1;
xmlFAGenerateCountedEpsilonTransition(VAR_0, VAR_14,
VAR_3->stop, VAR_13);
xmlFAGenerateCountedTransition(VAR_0, VAR_14,
VAR_15, VAR_13);
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start,
VAR_15);
} else {
VAR_13 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_13].min = VAR_3->min - 1;
VAR_0->counters[VAR_13].max = VAR_3->max - 1;
xmlFAGenerateCountedEpsilonTransition(VAR_0, VAR_3->stop,
VAR_3->start, VAR_13);
xmlFAGenerateCountedTransition(VAR_0, VAR_3->stop,
VAR_15, VAR_13);
if (VAR_3->min == 0)
xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start0,
VAR_15);
}
VAR_3->min = 0;
VAR_3->max = 0;
VAR_3->quant = VAR_9;
VAR_0->state = VAR_15;
}
default:
break;
}
return(0);
}
if ((VAR_3->min == 0) && (VAR_3->max == 0) &&
(VAR_3->quant == VAR_7)) {
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
if (VAR_2 != NULL)
xmlRegStatePush(VAR_0, VAR_2);
else {
return(-1);
}
}
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
VAR_0->state = VAR_2;
xmlRegFreeAtom(VAR_3);
return(0);
}
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
if (VAR_2 != NULL)
xmlRegStatePush(VAR_0, VAR_2);
else {
return(-1);
}
}
VAR_4 = VAR_2;
if ((VAR_3->quant == VAR_11) ||
(VAR_3->quant == VAR_12)) {
xmlRegStatePtr VAR_17;
VAR_17 = xmlRegNewState(VAR_0);
if (VAR_17 != NULL)
xmlRegStatePush(VAR_0, VAR_17);
else {
return(-1);
}
xmlFAGenerateEpsilonTransition(VAR_0, VAR_17, VAR_2);
VAR_2 = VAR_17;
}
if (xmlRegAtomPush(VAR_0, VAR_3) < 0) {
return(-1);
}
if ((VAR_3->quant == VAR_7) &&
(VAR_3->min == 0) && (VAR_3->max > 0)) {
VAR_5 = 1;
VAR_3->min = 1;
if (VAR_3->max == 1)
VAR_3->quant = VAR_10;
}
xmlRegStateAddTrans(VAR_0, VAR_1, VAR_3, VAR_2, -1, -1);
VAR_0->state = VAR_4;
switch (VAR_3->quant) {
case VAR_10:
VAR_3->quant = VAR_9;
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
break;
case VAR_11:
VAR_3->quant = VAR_9;
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
xmlRegStateAddTrans(VAR_0, VAR_2, VAR_3, VAR_2, -1, -1);
break;
case VAR_12:
VAR_3->quant = VAR_9;
xmlRegStateAddTrans(VAR_0, VAR_2, VAR_3, VAR_2, -1, -1);
break;
case VAR_7:
if (VAR_5)
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
break;
default:
break;
}
return(0);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/before/1.json,"static int
xmlFAGenerateTransitions(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr from,
	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {
    xmlRegStatePtr end;
    int nullable = 0;

    if (atom == NULL) {
	ERROR(""generate transition: atom == NULL"");
	return(-1);
    }
    if (atom->type == XML_REGEXP_SUBREG) {
	/*
	 * this is a subexpression handling one should not need to
	 * create a new node except for XML_REGEXP_QUANT_RANGE.
	 */
	if (xmlRegAtomPush(ctxt, atom) < 0) {
	    return(-1);
	}
	if ((to != NULL) && (atom->stop != to) &&
	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
	    /*
	     * Generate an epsilon transition to link to the target
	     */
	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
#ifdef DV
	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
	    to = xmlRegNewState(ctxt);
	    xmlRegStatePush(ctxt, to);
	    ctxt->state = to;
	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
#endif
	}
	switch (atom->quant) {
	    case XML_REGEXP_QUANT_OPT:
		atom->quant = XML_REGEXP_QUANT_ONCE;
		/*
		 * transition done to the state after end of atom.
		 *      1. set transition from atom start to new state
		 *      2. set transition from atom end to this state.
		 */
                if (to == NULL) {
                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
                    xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
                                                   ctxt->state);
                } else {
                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
                }
		break;
	    case XML_REGEXP_QUANT_MULT:
		atom->quant = XML_REGEXP_QUANT_ONCE;
		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
		break;
	    case XML_REGEXP_QUANT_PLUS:
		atom->quant = XML_REGEXP_QUANT_ONCE;
		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
		break;
	    case XML_REGEXP_QUANT_RANGE: {
		int counter;
		xmlRegStatePtr inter, newstate;

		/*
		 * create the final state now if needed
		 */
		if (to != NULL) {
		    newstate = to;
		} else {
		    newstate = xmlRegNewState(ctxt);
		    xmlRegStatePush(ctxt, newstate);
		}

		/*
		 * The principle here is to use counted transition
		 * to avoid explosion in the number of states in the
		 * graph. This is clearly more complex but should not
		 * be exploitable at runtime.
		 */
		if ((atom->min == 0) && (atom->start0 == NULL)) {
		    xmlRegAtomPtr copy;
		    /*
		     * duplicate a transition based on atom to count next
		     * occurrences after 1. We cannot loop to atom->start
		     * directly because we need an epsilon transition to
		     * newstate.
		     */
		     /* ???? For some reason it seems we never reach that
		        case, I suppose this got optimized out before when
			building the automata */
		    copy = xmlRegCopyAtom(ctxt, atom);
		    if (copy == NULL)
		        return(-1);
		    copy->quant = XML_REGEXP_QUANT_ONCE;
		    copy->min = 0;
		    copy->max = 0;

		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
		        < 0)
			return(-1);
		    inter = ctxt->state;
		    counter = xmlRegGetCounter(ctxt);
                    if (counter < 0)
                        return(-1);
		    ctxt->counters[counter].min = atom->min - 1;
		    ctxt->counters[counter].max = atom->max - 1;
		    /* count the number of times we see it again */
		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
						   atom->stop, counter);
		    /* allow a way out based on the count */
		    xmlFAGenerateCountedTransition(ctxt, inter,
			                           newstate, counter);
		    /* and also allow a direct exit for 0 */
		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,
		                                   newstate);
		} else {
		    /*
		     * either we need the atom at least once or there
		     * is an atom->start0 allowing to easily plug the
		     * epsilon transition.
		     */
		    counter = xmlRegGetCounter(ctxt);
                    if (counter < 0)
                        return(-1);
		    ctxt->counters[counter].min = atom->min - 1;
		    ctxt->counters[counter].max = atom->max - 1;
		    /* count the number of times we see it again */
		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
						   atom->start, counter);
		    /* allow a way out based on the count */
		    xmlFAGenerateCountedTransition(ctxt, atom->stop,
			                           newstate, counter);
		    /* and if needed allow a direct exit for 0 */
		    if (atom->min == 0)
			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
						       newstate);

		}
		atom->min = 0;
		atom->max = 0;
		atom->quant = XML_REGEXP_QUANT_ONCE;
		ctxt->state = newstate;
	    }
	    default:
		break;
	}
	return(0);
    }
    if ((atom->min == 0) && (atom->max == 0) &&
               (atom->quant == XML_REGEXP_QUANT_RANGE)) {
        /*
	 * we can discard the atom and generate an epsilon transition instead
	 */
	if (to == NULL) {
	    to = xmlRegNewState(ctxt);
	    if (to != NULL)
		xmlRegStatePush(ctxt, to);
	    else {
		return(-1);
	    }
	}
	xmlFAGenerateEpsilonTransition(ctxt, from, to);
	ctxt->state = to;
	xmlRegFreeAtom(atom);
	return(0);
    }
    if (to == NULL) {
	to = xmlRegNewState(ctxt);
	if (to != NULL)
	    xmlRegStatePush(ctxt, to);
	else {
	    return(-1);
	}
    }
    end = to;
    if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
        (atom->quant == XML_REGEXP_QUANT_PLUS)) {
	/*
	 * Do not pollute the target state by adding transitions from
	 * it as it is likely to be the shared target of multiple branches.
	 * So isolate with an epsilon transition.
	 */
        xmlRegStatePtr tmp;

	tmp = xmlRegNewState(ctxt);
	if (tmp != NULL)
	    xmlRegStatePush(ctxt, tmp);
	else {
	    return(-1);
	}
	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
	to = tmp;
    }
    if (xmlRegAtomPush(ctxt, atom) < 0) {
	return(-1);
    }
    if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
        (atom->min == 0) && (atom->max > 0)) {
	nullable = 1;
	atom->min = 1;
        if (atom->max == 1)
	    atom->quant = XML_REGEXP_QUANT_OPT;
    }
    xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
    ctxt->state = end;
    switch (atom->quant) {
	case XML_REGEXP_QUANT_OPT:
	    atom->quant = XML_REGEXP_QUANT_ONCE;
	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
	    break;
	case XML_REGEXP_QUANT_MULT:
	    atom->quant = XML_REGEXP_QUANT_ONCE;
	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
	    break;
	case XML_REGEXP_QUANT_PLUS:
	    atom->quant = XML_REGEXP_QUANT_ONCE;
	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
	    break;
	case XML_REGEXP_QUANT_RANGE:
	    if (nullable)
		xmlFAGenerateEpsilonTransition(ctxt, from, to);
	    break;
	default:
	    break;
    }
    return(0);
}","static int
xmlFAGenerateTransitions(xmlRegParserCtxtPtr VAR_0, xmlRegStatePtr VAR_1,
	                 xmlRegStatePtr VAR_2, xmlRegAtomPtr VAR_3) {
    xmlRegStatePtr VAR_4;
    int VAR_5 = 0;

    if (VAR_3 == NULL) {
	ERROR(""generate transition: atom == NULL"");
	return(-1);
    }
    if (VAR_3->type == VAR_6) {
	/* COMMENT_0 */
                                                           
                                                        
    
	if (xmlRegAtomPush(VAR_0, VAR_3) < 0) {
	    return(-1);
	}
	if ((VAR_2 != NULL) && (VAR_3->stop != VAR_2) &&
	    (VAR_3->quant != VAR_7)) {
	    /* COMMENT_4 */
                                                            
        
	    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_2);
#ifdef VAR_8
	} else if ((VAR_2 == NULL) && (VAR_3->quant != VAR_7) &&
		   (VAR_3->quant != VAR_9)) {
	    VAR_2 = xmlRegNewState(VAR_0);
	    xmlRegStatePush(VAR_0, VAR_2);
	    VAR_0->state = VAR_2;
	    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_2);
#endif
	}
	switch (VAR_3->quant) {
	    case VAR_10:
		VAR_3->quant = VAR_9;
		/* COMMENT_7 */
                                                    
                                                        
                                                        
     
                if (VAR_2 == NULL) {
                    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, 0);
                    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop,
                                                   VAR_0->state);
                } else {
                    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, VAR_2);
                }
		break;
	    case VAR_11:
		VAR_3->quant = VAR_9;
		xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start, VAR_3->stop);
		xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_3->start);
		break;
	    case VAR_12:
		VAR_3->quant = VAR_9;
		xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->stop, VAR_3->start);
		break;
	    case VAR_7: {
		int VAR_13;
		xmlRegStatePtr VAR_14, VAR_15;

		/* COMMENT_12 */
                                         
     
		if (VAR_2 != NULL) {
		    VAR_15 = VAR_2;
		} else {
		    VAR_15 = xmlRegNewState(VAR_0);
		    xmlRegStatePush(VAR_0, VAR_15);
		}

		/* COMMENT_15 */
                                                    
                                                      
                                                       
                               
     
		if ((VAR_3->min == 0) && (VAR_3->start0 == NULL)) {
		    xmlRegAtomPtr VAR_16;
		    /* COMMENT_21 */
                                                           
                                                           
                                                          
                  
         
		     /* COMMENT_27 */
                                                            
                           
		    VAR_16 = xmlRegCopyAtom(VAR_0, VAR_3);
		    if (VAR_16 == NULL)
		        return(-1);
		    VAR_16->quant = VAR_9;
		    VAR_16->min = 0;
		    VAR_16->max = 0;

		    if (xmlFAGenerateTransitions(VAR_0, VAR_3->start, NULL, VAR_16)
		        < 0)
			return(-1);
		    VAR_14 = VAR_0->state;
		    VAR_13 = xmlRegGetCounter(VAR_0);
                    if (VAR_13 < 0)
                        return(-1);
		    VAR_0->counters[VAR_13].min = VAR_3->min - 1;
		    VAR_0->counters[VAR_13].max = VAR_3->max - 1;
		    /* COMMENT_30 */
		    xmlFAGenerateCountedEpsilonTransition(VAR_0, VAR_14,
						   VAR_3->stop, VAR_13);
		    /* COMMENT_31 */
		    xmlFAGenerateCountedTransition(VAR_0, VAR_14,
			                           VAR_15, VAR_13);
		    /* COMMENT_32 */
		    xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start,
		                                   VAR_15);
		} else {
		    /* COMMENT_33 */
                                                       
                                                       
                            
         
		    VAR_13 = xmlRegGetCounter(VAR_0);
                    if (VAR_13 < 0)
                        return(-1);
		    VAR_0->counters[VAR_13].min = VAR_3->min - 1;
		    VAR_0->counters[VAR_13].max = VAR_3->max - 1;
		    /* COMMENT_30 */
		    xmlFAGenerateCountedEpsilonTransition(VAR_0, VAR_3->stop,
						   VAR_3->start, VAR_13);
		    /* COMMENT_31 */
		    xmlFAGenerateCountedTransition(VAR_0, VAR_3->stop,
			                           VAR_15, VAR_13);
		    /* COMMENT_38 */
		    if (VAR_3->min == 0)
			xmlFAGenerateEpsilonTransition(VAR_0, VAR_3->start0,
						       VAR_15);

		}
		VAR_3->min = 0;
		VAR_3->max = 0;
		VAR_3->quant = VAR_9;
		VAR_0->state = VAR_15;
	    }
	    default:
		break;
	}
	return(0);
    }
    if ((VAR_3->min == 0) && (VAR_3->max == 0) &&
               (VAR_3->quant == VAR_7)) {
        /* COMMENT_39 */
                                                                      
    
	if (VAR_2 == NULL) {
	    VAR_2 = xmlRegNewState(VAR_0);
	    if (VAR_2 != NULL)
		xmlRegStatePush(VAR_0, VAR_2);
	    else {
		return(-1);
	    }
	}
	xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
	VAR_0->state = VAR_2;
	xmlRegFreeAtom(VAR_3);
	return(0);
    }
    if (VAR_2 == NULL) {
	VAR_2 = xmlRegNewState(VAR_0);
	if (VAR_2 != NULL)
	    xmlRegStatePush(VAR_0, VAR_2);
	else {
	    return(-1);
	}
    }
    VAR_4 = VAR_2;
    if ((VAR_3->quant == VAR_11) ||
        (VAR_3->quant == VAR_12)) {
	/* COMMENT_42 */
                                                              
                                                                    
                                          
    
        xmlRegStatePtr VAR_17;

	VAR_17 = xmlRegNewState(VAR_0);
	if (VAR_17 != NULL)
	    xmlRegStatePush(VAR_0, VAR_17);
	else {
	    return(-1);
	}
	xmlFAGenerateEpsilonTransition(VAR_0, VAR_17, VAR_2);
	VAR_2 = VAR_17;
    }
    if (xmlRegAtomPush(VAR_0, VAR_3) < 0) {
	return(-1);
    }
    if ((VAR_3->quant == VAR_7) &&
        (VAR_3->min == 0) && (VAR_3->max > 0)) {
	VAR_5 = 1;
	VAR_3->min = 1;
        if (VAR_3->max == 1)
	    VAR_3->quant = VAR_10;
    }
    xmlRegStateAddTrans(VAR_0, VAR_1, VAR_3, VAR_2, -1, -1);
    VAR_0->state = VAR_4;
    switch (VAR_3->quant) {
	case VAR_10:
	    VAR_3->quant = VAR_9;
	    xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
	    break;
	case VAR_11:
	    VAR_3->quant = VAR_9;
	    xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
	    xmlRegStateAddTrans(VAR_0, VAR_2, VAR_3, VAR_2, -1, -1);
	    break;
	case VAR_12:
	    VAR_3->quant = VAR_9;
	    xmlRegStateAddTrans(VAR_0, VAR_2, VAR_3, VAR_2, -1, -1);
	    break;
	case VAR_7:
	    if (VAR_5)
		xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
	    break;
	default:
	    break;
    }
    return(0);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -99,6 +99,8 @@
 			return(-1);
 		    inter = ctxt->state;
 		    counter = xmlRegGetCounter(ctxt);
+                    if (counter < 0)
+                        return(-1);
 		    ctxt->counters[counter].min = atom->min - 1;
 		    ctxt->counters[counter].max = atom->max - 1;
 		    /* count the number of times we see it again */
@@ -117,6 +119,8 @@
 		     * epsilon transition.
 		     */
 		    counter = xmlRegGetCounter(ctxt);
+                    if (counter < 0)
+                        return(-1);
 		    ctxt->counters[counter].min = atom->min - 1;
 		    ctxt->counters[counter].max = atom->max - 1;
 		    /* count the number of times we see it again */","{'deleted_lines': [], 'added_lines': ['                    if (counter < 0)', '                        return(-1);', '                    if (counter < 0)', '                        return(-1);']}",True,"In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40128,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"malloc-fail: Fix OOB read after xmlRegGetCounter

Found with libFuzzer, see #344.

(cherry picked from commit 1743c4c3fc58cf38ecce68db9de51d0f3651e033)

I also copied the error label from
e64653c0e7975594e27d7de2ed4be062c1e4ad03 to fix the build failure.

Bug: http://b/274231102
Test: TreeHugger
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e6ed17dfe8e36e5618a592a600720bd61e015cc)
Merged-In: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
Change-Id: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
",1ccf89b87a3969edd56956e2d447f896037c8be7,https://android.googlesource.com/platform/external/libxml2/+/1ccf89b87a3969edd56956e2d447f896037c8be7,xmlregexp.c,xmlAutomataNewOnceTrans2,"xmlAutomataStatePtr
xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
xmlAutomataStatePtr to, const xmlChar *token,
const xmlChar *token2,
int min, int max, void *data) {
xmlRegAtomPtr atom;
int counter;
if ((am == NULL) || (from == NULL) || (token == NULL))
return(NULL);
if (min < 1)
return(NULL);
if (max < min)
return(NULL);
atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
if (atom == NULL)
return(NULL);
if ((token2 == NULL) || (*token2 == 0)) {
atom->valuep = xmlStrdup(token);
} else {
int lenn, lenp;
xmlChar *str;
lenn = strlen((char *) token2);
lenp = strlen((char *) token);
str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
if (str == NULL) {
xmlRegFreeAtom(atom);
return(NULL);
}
memcpy(&str[0], token, lenp);
str[lenp] = '|';
memcpy(&str[lenp + 1], token2, lenn);
str[lenn + lenp + 1] = 0;
atom->valuep = str;
}
atom->data = data;
atom->quant = XML_REGEXP_QUANT_ONCEONLY;
atom->min = min;
atom->max = max;
counter = xmlRegGetCounter(am);
am->counters[counter].min = 1;
am->counters[counter].max = 1;
if (to == NULL) {
to = xmlRegNewState(am);
xmlRegStatePush(am, to);
}
xmlRegStateAddTrans(am, from, atom, to, counter, -1);
xmlRegAtomPush(am, atom);
am->state = to;
return(to);
}","xmlAutomataStatePtr
xmlAutomataNewOnceTrans2(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
const xmlChar *VAR_4,
int VAR_5, int VAR_6, void *VAR_7) {
xmlRegAtomPtr VAR_8;
int VAR_9;
if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
return(NULL);
if (VAR_5 < 1)
return(NULL);
if (VAR_6 < VAR_5)
return(NULL);
VAR_8 = xmlRegNewAtom(VAR_0, VAR_10);
if (VAR_8 == NULL)
return(NULL);
if ((VAR_4 == NULL) || (*VAR_4 == 0)) {
VAR_8->valuep = xmlStrdup(VAR_3);
} else {
int VAR_11, VAR_12;
xmlChar *VAR_13;
VAR_11 = strlen((char *) VAR_4);
VAR_12 = strlen((char *) VAR_3);
VAR_13 = (xmlChar *) xmlMallocAtomic(VAR_11 + VAR_12 + 2);
if (VAR_13 == NULL) {
xmlRegFreeAtom(VAR_8);
return(NULL);
}
memcpy(&VAR_13[0], VAR_3, VAR_12);
VAR_13[VAR_12] = '|';
memcpy(&VAR_13[VAR_12 + 1], VAR_4, VAR_11);
VAR_13[VAR_11 + VAR_12 + 1] = 0;
VAR_8->valuep = VAR_13;
}
VAR_8->data = VAR_7;
VAR_8->quant = VAR_14;
VAR_8->min = VAR_5;
VAR_8->max = VAR_6;
VAR_9 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_9].min = 1;
VAR_0->counters[VAR_9].max = 1;
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_2);
}
xmlRegStateAddTrans(VAR_0, VAR_1, VAR_8, VAR_2, VAR_9, -1);
xmlRegAtomPush(VAR_0, VAR_8);
VAR_0->state = VAR_2;
return(VAR_2);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/before/2.json,"xmlAutomataStatePtr
xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
			 xmlAutomataStatePtr to, const xmlChar *token,
			 const xmlChar *token2,
			 int min, int max, void *data) {
    xmlRegAtomPtr atom;
    int counter;

    if ((am == NULL) || (from == NULL) || (token == NULL))
	return(NULL);
    if (min < 1)
	return(NULL);
    if (max < min)
	return(NULL);
    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
    if (atom == NULL)
	return(NULL);
    if ((token2 == NULL) || (*token2 == 0)) {
	atom->valuep = xmlStrdup(token);
    } else {
	int lenn, lenp;
	xmlChar *str;

	lenn = strlen((char *) token2);
	lenp = strlen((char *) token);

	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
	if (str == NULL) {
	    xmlRegFreeAtom(atom);
	    return(NULL);
	}
	memcpy(&str[0], token, lenp);
	str[lenp] = '|';
	memcpy(&str[lenp + 1], token2, lenn);
	str[lenn + lenp + 1] = 0;

	atom->valuep = str;
    }
    atom->data = data;
    atom->quant = XML_REGEXP_QUANT_ONCEONLY;
    atom->min = min;
    atom->max = max;
    /*
     * associate a counter to the transition.
     */
    counter = xmlRegGetCounter(am);
    if (counter < 0)
        goto error;
    am->counters[counter].min = 1;
    am->counters[counter].max = 1;

    /* xmlFAGenerateTransitions(am, from, to, atom); */
    if (to == NULL) {
	to = xmlRegNewState(am);
	xmlRegStatePush(am, to);
    }
    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
    xmlRegAtomPush(am, atom);
    am->state = to;
    return(to);

error:
    xmlRegFreeAtom(atom);
    return(NULL);
}","xmlAutomataStatePtr
xmlAutomataNewOnceTrans2(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
			 xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
			 const xmlChar *VAR_4,
			 int VAR_5, int VAR_6, void *VAR_7) {
    xmlRegAtomPtr VAR_8;
    int VAR_9;

    if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
	return(NULL);
    if (VAR_5 < 1)
	return(NULL);
    if (VAR_6 < VAR_5)
	return(NULL);
    VAR_8 = xmlRegNewAtom(VAR_0, VAR_10);
    if (VAR_8 == NULL)
	return(NULL);
    if ((VAR_4 == NULL) || (*VAR_4 == 0)) {
	VAR_8->valuep = xmlStrdup(VAR_3);
    } else {
	int VAR_11, VAR_12;
	xmlChar *VAR_13;

	VAR_11 = strlen((char *) VAR_4);
	VAR_12 = strlen((char *) VAR_3);

	VAR_13 = (xmlChar *) xmlMallocAtomic(VAR_11 + VAR_12 + 2);
	if (VAR_13 == NULL) {
	    xmlRegFreeAtom(VAR_8);
	    return(NULL);
	}
	memcpy(&VAR_13[0], VAR_3, VAR_12);
	VAR_13[VAR_12] = '|';
	memcpy(&VAR_13[VAR_12 + 1], VAR_4, VAR_11);
	VAR_13[VAR_11 + VAR_12 + 1] = 0;

	VAR_8->valuep = VAR_13;
    }
    VAR_8->data = VAR_7;
    VAR_8->quant = VAR_14;
    VAR_8->min = VAR_5;
    VAR_8->max = VAR_6;
    /* COMMENT_0 */
                                             
       
    VAR_9 = xmlRegGetCounter(VAR_0);
    if (VAR_9 < 0)
        goto error;
    VAR_0->counters[VAR_9].min = 1;
    VAR_0->counters[VAR_9].max = 1;

    /* COMMENT_3 */
    if (VAR_2 == NULL) {
	VAR_2 = xmlRegNewState(VAR_0);
	xmlRegStatePush(VAR_0, VAR_2);
    }
    xmlRegStateAddTrans(VAR_0, VAR_1, VAR_8, VAR_2, VAR_9, -1);
    xmlRegAtomPush(VAR_0, VAR_8);
    VAR_0->state = VAR_2;
    return(VAR_2);

error:
    xmlRegFreeAtom(VAR_8);
    return(NULL);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -44,6 +44,8 @@
      * associate a counter to the transition.
      */
     counter = xmlRegGetCounter(am);
+    if (counter < 0)
+        goto error;
     am->counters[counter].min = 1;
     am->counters[counter].max = 1;
 
@@ -56,4 +58,8 @@
     xmlRegAtomPush(am, atom);
     am->state = to;
     return(to);
+
+error:
+    xmlRegFreeAtom(atom);
+    return(NULL);
 }","{'deleted_lines': [], 'added_lines': ['    if (counter < 0)', '        goto error;', '', 'error:', '    xmlRegFreeAtom(atom);', '    return(NULL);']}",True,"In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40128,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"malloc-fail: Fix OOB read after xmlRegGetCounter

Found with libFuzzer, see #344.

(cherry picked from commit 1743c4c3fc58cf38ecce68db9de51d0f3651e033)

I also copied the error label from
e64653c0e7975594e27d7de2ed4be062c1e4ad03 to fix the build failure.

Bug: http://b/274231102
Test: TreeHugger
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e6ed17dfe8e36e5618a592a600720bd61e015cc)
Merged-In: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
Change-Id: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
",1ccf89b87a3969edd56956e2d447f896037c8be7,https://android.googlesource.com/platform/external/libxml2/+/1ccf89b87a3969edd56956e2d447f896037c8be7,xmlregexp.c,xmlAutomataNewCountTrans,"xmlAutomataStatePtr
xmlAutomataNewCountTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
xmlAutomataStatePtr to, const xmlChar *token,
int min, int max, void *data) {
xmlRegAtomPtr atom;
int counter;
if ((am == NULL) || (from == NULL) || (token == NULL))
return(NULL);
if (min < 0)
return(NULL);
if ((max < min) || (max < 1))
return(NULL);
atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
if (atom == NULL)
return(NULL);
atom->valuep = xmlStrdup(token);
atom->data = data;
if (min == 0)
atom->min = 1;
else
atom->min = min;
atom->max = max;
counter = xmlRegGetCounter(am);
am->counters[counter].min = min;
am->counters[counter].max = max;
if (to == NULL) {
to = xmlRegNewState(am);
xmlRegStatePush(am, to);
}
xmlRegStateAddTrans(am, from, atom, to, counter, -1);
xmlRegAtomPush(am, atom);
am->state = to;
if (to == NULL)
to = am->state;
if (to == NULL)
return(NULL);
if (min == 0)
xmlFAGenerateEpsilonTransition(am, from, to);
return(to);
}","xmlAutomataStatePtr
xmlAutomataNewCountTrans(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
int VAR_4, int VAR_5, void *VAR_6) {
xmlRegAtomPtr VAR_7;
int VAR_8;
if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
return(NULL);
if (VAR_4 < 0)
return(NULL);
if ((VAR_5 < VAR_4) || (VAR_5 < 1))
return(NULL);
VAR_7 = xmlRegNewAtom(VAR_0, VAR_9);
if (VAR_7 == NULL)
return(NULL);
VAR_7->valuep = xmlStrdup(VAR_3);
VAR_7->data = VAR_6;
if (VAR_4 == 0)
VAR_7->min = 1;
else
VAR_7->min = VAR_4;
VAR_7->max = VAR_5;
VAR_8 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_8].min = VAR_4;
VAR_0->counters[VAR_8].max = VAR_5;
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_2);
}
xmlRegStateAddTrans(VAR_0, VAR_1, VAR_7, VAR_2, VAR_8, -1);
xmlRegAtomPush(VAR_0, VAR_7);
VAR_0->state = VAR_2;
if (VAR_2 == NULL)
VAR_2 = VAR_0->state;
if (VAR_2 == NULL)
return(NULL);
if (VAR_4 == 0)
xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
return(VAR_2);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/before/3.json,"xmlAutomataStatePtr
xmlAutomataNewCountTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
			 xmlAutomataStatePtr to, const xmlChar *token,
			 int min, int max, void *data) {
    xmlRegAtomPtr atom;
    int counter;

    if ((am == NULL) || (from == NULL) || (token == NULL))
	return(NULL);
    if (min < 0)
	return(NULL);
    if ((max < min) || (max < 1))
	return(NULL);
    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
    if (atom == NULL)
	return(NULL);
    atom->valuep = xmlStrdup(token);
    atom->data = data;
    if (min == 0)
	atom->min = 1;
    else
	atom->min = min;
    atom->max = max;

    /*
     * associate a counter to the transition.
     */
    counter = xmlRegGetCounter(am);
    if (counter < 0)
        goto error;
    am->counters[counter].min = min;
    am->counters[counter].max = max;

    /* xmlFAGenerateTransitions(am, from, to, atom); */
    if (to == NULL) {
        to = xmlRegNewState(am);
	xmlRegStatePush(am, to);
    }
    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
    xmlRegAtomPush(am, atom);
    am->state = to;

    if (to == NULL)
	to = am->state;
    if (to == NULL)
	return(NULL);
    if (min == 0)
	xmlFAGenerateEpsilonTransition(am, from, to);
    return(to);

error:
    xmlRegFreeAtom(atom);
    return(NULL);
}","xmlAutomataStatePtr
xmlAutomataNewCountTrans(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
			 xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
			 int VAR_4, int VAR_5, void *VAR_6) {
    xmlRegAtomPtr VAR_7;
    int VAR_8;

    if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
	return(NULL);
    if (VAR_4 < 0)
	return(NULL);
    if ((VAR_5 < VAR_4) || (VAR_5 < 1))
	return(NULL);
    VAR_7 = xmlRegNewAtom(VAR_0, VAR_9);
    if (VAR_7 == NULL)
	return(NULL);
    VAR_7->valuep = xmlStrdup(VAR_3);
    VAR_7->data = VAR_6;
    if (VAR_4 == 0)
	VAR_7->min = 1;
    else
	VAR_7->min = VAR_4;
    VAR_7->max = VAR_5;

    /* COMMENT_0 */
                                             
       
    VAR_8 = xmlRegGetCounter(VAR_0);
    if (VAR_8 < 0)
        goto error;
    VAR_0->counters[VAR_8].min = VAR_4;
    VAR_0->counters[VAR_8].max = VAR_5;

    /* COMMENT_3 */
    if (VAR_2 == NULL) {
        VAR_2 = xmlRegNewState(VAR_0);
	xmlRegStatePush(VAR_0, VAR_2);
    }
    xmlRegStateAddTrans(VAR_0, VAR_1, VAR_7, VAR_2, VAR_8, -1);
    xmlRegAtomPush(VAR_0, VAR_7);
    VAR_0->state = VAR_2;

    if (VAR_2 == NULL)
	VAR_2 = VAR_0->state;
    if (VAR_2 == NULL)
	return(NULL);
    if (VAR_4 == 0)
	xmlFAGenerateEpsilonTransition(VAR_0, VAR_1, VAR_2);
    return(VAR_2);

error:
    xmlRegFreeAtom(VAR_7);
    return(NULL);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -26,6 +26,8 @@
      * associate a counter to the transition.
      */
     counter = xmlRegGetCounter(am);
+    if (counter < 0)
+        goto error;
     am->counters[counter].min = min;
     am->counters[counter].max = max;
 
@@ -45,4 +47,8 @@
     if (min == 0)
 	xmlFAGenerateEpsilonTransition(am, from, to);
     return(to);
+
+error:
+    xmlRegFreeAtom(atom);
+    return(NULL);
 }","{'deleted_lines': [], 'added_lines': ['    if (counter < 0)', '        goto error;', '', 'error:', '    xmlRegFreeAtom(atom);', '    return(NULL);']}",True,"In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40128,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"malloc-fail: Fix OOB read after xmlRegGetCounter

Found with libFuzzer, see #344.

(cherry picked from commit 1743c4c3fc58cf38ecce68db9de51d0f3651e033)

I also copied the error label from
e64653c0e7975594e27d7de2ed4be062c1e4ad03 to fix the build failure.

Bug: http://b/274231102
Test: TreeHugger
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e6ed17dfe8e36e5618a592a600720bd61e015cc)
Merged-In: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
Change-Id: I3bad3e03092e17a761cb6e299aff848ebd35b6f4
",1ccf89b87a3969edd56956e2d447f896037c8be7,https://android.googlesource.com/platform/external/libxml2/+/1ccf89b87a3969edd56956e2d447f896037c8be7,xmlregexp.c,xmlAutomataNewOnceTrans,"xmlAutomataStatePtr
xmlAutomataNewOnceTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
xmlAutomataStatePtr to, const xmlChar *token,
int min, int max, void *data) {
xmlRegAtomPtr atom;
int counter;
if ((am == NULL) || (from == NULL) || (token == NULL))
return(NULL);
if (min < 1)
return(NULL);
if (max < min)
return(NULL);
atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
if (atom == NULL)
return(NULL);
atom->valuep = xmlStrdup(token);
atom->data = data;
atom->quant = XML_REGEXP_QUANT_ONCEONLY;
atom->min = min;
atom->max = max;
counter = xmlRegGetCounter(am);
am->counters[counter].min = 1;
am->counters[counter].max = 1;
if (to == NULL) {
to = xmlRegNewState(am);
xmlRegStatePush(am, to);
}
xmlRegStateAddTrans(am, from, atom, to, counter, -1);
xmlRegAtomPush(am, atom);
am->state = to;
return(to);
}","xmlAutomataStatePtr
xmlAutomataNewOnceTrans(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
int VAR_4, int VAR_5, void *VAR_6) {
xmlRegAtomPtr VAR_7;
int VAR_8;
if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
return(NULL);
if (VAR_4 < 1)
return(NULL);
if (VAR_5 < VAR_4)
return(NULL);
VAR_7 = xmlRegNewAtom(VAR_0, VAR_9);
if (VAR_7 == NULL)
return(NULL);
VAR_7->valuep = xmlStrdup(VAR_3);
VAR_7->data = VAR_6;
VAR_7->quant = VAR_10;
VAR_7->min = VAR_4;
VAR_7->max = VAR_5;
VAR_8 = xmlRegGetCounter(VAR_0);
VAR_0->counters[VAR_8].min = 1;
VAR_0->counters[VAR_8].max = 1;
if (VAR_2 == NULL) {
VAR_2 = xmlRegNewState(VAR_0);
xmlRegStatePush(VAR_0, VAR_2);
}
xmlRegStateAddTrans(VAR_0, VAR_1, VAR_7, VAR_2, VAR_8, -1);
xmlRegAtomPush(VAR_0, VAR_7);
VAR_0->state = VAR_2;
return(VAR_2);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/before/4.json,"xmlAutomataStatePtr
xmlAutomataNewOnceTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
			 xmlAutomataStatePtr to, const xmlChar *token,
			 int min, int max, void *data) {
    xmlRegAtomPtr atom;
    int counter;

    if ((am == NULL) || (from == NULL) || (token == NULL))
	return(NULL);
    if (min < 1)
	return(NULL);
    if (max < min)
	return(NULL);
    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
    if (atom == NULL)
	return(NULL);
    atom->valuep = xmlStrdup(token);
    atom->data = data;
    atom->quant = XML_REGEXP_QUANT_ONCEONLY;
    atom->min = min;
    atom->max = max;
    /*
     * associate a counter to the transition.
     */
    counter = xmlRegGetCounter(am);
    if (counter < 0)
        goto error;
    am->counters[counter].min = 1;
    am->counters[counter].max = 1;

    /* xmlFAGenerateTransitions(am, from, to, atom); */
    if (to == NULL) {
	to = xmlRegNewState(am);
	xmlRegStatePush(am, to);
    }
    xmlRegStateAddTrans(am, from, atom, to, counter, -1);
    xmlRegAtomPush(am, atom);
    am->state = to;
    return(to);

error:
    xmlRegFreeAtom(atom);
    return(NULL);
}","xmlAutomataStatePtr
xmlAutomataNewOnceTrans(xmlAutomataPtr VAR_0, xmlAutomataStatePtr VAR_1,
			 xmlAutomataStatePtr VAR_2, const xmlChar *VAR_3,
			 int VAR_4, int VAR_5, void *VAR_6) {
    xmlRegAtomPtr VAR_7;
    int VAR_8;

    if ((VAR_0 == NULL) || (VAR_1 == NULL) || (VAR_3 == NULL))
	return(NULL);
    if (VAR_4 < 1)
	return(NULL);
    if (VAR_5 < VAR_4)
	return(NULL);
    VAR_7 = xmlRegNewAtom(VAR_0, VAR_9);
    if (VAR_7 == NULL)
	return(NULL);
    VAR_7->valuep = xmlStrdup(VAR_3);
    VAR_7->data = VAR_6;
    VAR_7->quant = VAR_10;
    VAR_7->min = VAR_4;
    VAR_7->max = VAR_5;
    /* COMMENT_0 */
                                             
       
    VAR_8 = xmlRegGetCounter(VAR_0);
    if (VAR_8 < 0)
        goto error;
    VAR_0->counters[VAR_8].min = 1;
    VAR_0->counters[VAR_8].max = 1;

    /* COMMENT_3 */
    if (VAR_2 == NULL) {
	VAR_2 = xmlRegNewState(VAR_0);
	xmlRegStatePush(VAR_0, VAR_2);
    }
    xmlRegStateAddTrans(VAR_0, VAR_1, VAR_7, VAR_2, VAR_8, -1);
    xmlRegAtomPush(VAR_0, VAR_7);
    VAR_0->state = VAR_2;
    return(VAR_2);

error:
    xmlRegFreeAtom(VAR_7);
    return(NULL);
}",android/1ccf89b87a3969edd56956e2d447f896037c8be7/xmlregexp.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -23,6 +23,8 @@
      * associate a counter to the transition.
      */
     counter = xmlRegGetCounter(am);
+    if (counter < 0)
+        goto error;
     am->counters[counter].min = 1;
     am->counters[counter].max = 1;
 
@@ -35,4 +37,8 @@
     xmlRegAtomPush(am, atom);
     am->state = to;
     return(to);
+
+error:
+    xmlRegFreeAtom(atom);
+    return(NULL);
 }","{'deleted_lines': [], 'added_lines': ['    if (counter < 0)', '        goto error;', '', 'error:', '    xmlRegFreeAtom(atom);', '    return(NULL);']}",True,"In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-6176,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"I got the below warning when do fuzzing test:
BUG: KASAN: null-ptr-deref in scatterwalk_copychunks+0x320/0x470
Read of size 4 at addr 0000000000000008 by task kworker/u8:1/9

CPU: 0 PID: 9 Comm: kworker/u8:1 Tainted: G           OE
Hardware name: linux,dummy-virt (DT)
Workqueue: pencrypt_parallel padata_parallel_worker
Call trace:
 dump_backtrace+0x0/0x420
 show_stack+0x34/0x44
 dump_stack+0x1d0/0x248
 __kasan_report+0x138/0x140
 kasan_report+0x44/0x6c
 __asan_load4+0x94/0xd0
 scatterwalk_copychunks+0x320/0x470
 skcipher_next_slow+0x14c/0x290
 skcipher_walk_next+0x2fc/0x480
 skcipher_walk_first+0x9c/0x110
 skcipher_walk_aead_common+0x380/0x440
 skcipher_walk_aead_encrypt+0x54/0x70
 ccm_encrypt+0x13c/0x4d0
 crypto_aead_encrypt+0x7c/0xfc
 pcrypt_aead_enc+0x28/0x84
 padata_parallel_worker+0xd0/0x2dc
 process_one_work+0x49c/0xbdc
 worker_thread+0x124/0x880
 kthread+0x210/0x260
 ret_from_fork+0x10/0x18

This is because the value of rec_seq of tls_crypto_info configured by the
user program is too large, for example, 0xffffffffffffff. In addition, TLS
is asynchronously accelerated. When tls_do_encryption() returns
-EINPROGRESS and sk->sk_err is set to EBADMSG due to rec_seq overflow,
skmsg is released before the asynchronous encryption process ends. As a
result, the UAF problem occurs during the asynchronous processing of the
encryption module.

If the operation is asynchronous and the encryption module returns
EINPROGRESS, do not free the record information.

Fixes: 635d93981786 (""net/tls: free record only on encryption error"")
Signed-off-by: Liu Jian <liujian56@huawei.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Link: https://lore.kernel.org/r/20230909081434.2324940-1-liujian56@huawei.com
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
",cfaa80c91f6f99b9342b6557f0f0e1143e434066,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=cfaa80c91f6f99b9342b6557f0f0e1143e434066,net/tls/tls_sw.c,bpf_exec_tx_verdict,"static int bpf_exec_tx_verdict(struct sk_msg *msg, struct sock *sk,
bool full_record, u8 record_type,
ssize_t *copied, int flags)
{
struct tls_context *tls_ctx = tls_get_ctx(sk);
struct tls_sw_context_tx *ctx = tls_sw_ctx_tx(tls_ctx);
struct sk_msg msg_redir = { };
struct sk_psock *psock;
struct sock *sk_redir;
struct tls_rec *rec;
bool enospc, policy, redir_ingress;
int err = 0, send;
u32 delta = 0;
policy = !(flags & MSG_SENDPAGE_NOPOLICY);
psock = sk_psock_get(sk);
if (!psock || !policy) {
err = tls_push_record(sk, flags, record_type);
if (err && sk->sk_err == EBADMSG) {
*copied -= sk_msg_free(sk, msg);
tls_free_open_rec(sk);
err = -sk->sk_err;
}
if (psock)
sk_psock_put(sk, psock);
return err;
}
more_data:
enospc = sk_msg_full(msg);
if (psock->eval == __SK_NONE) {
delta = msg->sg.size;
psock->eval = sk_psock_msg_verdict(sk, psock, msg);
delta -= msg->sg.size;
}
if (msg->cork_bytes && msg->cork_bytes > msg->sg.size &&
!enospc && !full_record) {
err = -ENOSPC;
goto out_err;
}
msg->cork_bytes = 0;
send = msg->sg.size;
if (msg->apply_bytes && msg->apply_bytes < send)
send = msg->apply_bytes;
switch (psock->eval) {
case __SK_PASS:
err = tls_push_record(sk, flags, record_type);
if (err && sk->sk_err == EBADMSG) {
*copied -= sk_msg_free(sk, msg);
tls_free_open_rec(sk);
err = -sk->sk_err;
goto out_err;
}
break;
case __SK_REDIRECT:
redir_ingress = psock->redir_ingress;
sk_redir = psock->sk_redir;
memcpy(&msg_redir, msg, sizeof(*msg));
if (msg->apply_bytes < send)
msg->apply_bytes = 0;
else
msg->apply_bytes -= send;
sk_msg_return_zero(sk, msg, send);
msg->sg.size -= send;
release_sock(sk);
err = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,
&msg_redir, send, flags);
lock_sock(sk);
if (err < 0) {
*copied -= sk_msg_free_nocharge(sk, &msg_redir);
msg->sg.size = 0;
}
if (msg->sg.size == 0)
tls_free_open_rec(sk);
break;
case __SK_DROP:
default:
sk_msg_free_partial(sk, msg, send);
if (msg->apply_bytes < send)
msg->apply_bytes = 0;
else
msg->apply_bytes -= send;
if (msg->sg.size == 0)
tls_free_open_rec(sk);
*copied -= (send + delta);
err = -EACCES;
}
if (likely(!err)) {
bool reset_eval = !ctx->open_rec;
rec = ctx->open_rec;
if (rec) {
msg = &rec->msg_plaintext;
if (!msg->apply_bytes)
reset_eval = true;
}
if (reset_eval) {
psock->eval = __SK_NONE;
if (psock->sk_redir) {
sock_put(psock->sk_redir);
psock->sk_redir = NULL;
}
}
if (rec)
goto more_data;
}
out_err:
sk_psock_put(sk, psock);
return err;
}","static int bpf_exec_tx_verdict(struct sk_msg *VAR_0, struct sock *VAR_1,
bool VAR_2, u8 VAR_3,
ssize_t *VAR_4, int VAR_5)
{
struct tls_context *VAR_6 = tls_get_ctx(VAR_1);
struct tls_sw_context_tx *VAR_7 = tls_sw_ctx_tx(VAR_6);
struct sk_msg VAR_8 = { };
struct sk_psock *VAR_9;
struct sock *VAR_10;
struct tls_rec *VAR_11;
bool VAR_12, VAR_13, VAR_14;
int VAR_15 = 0, VAR_16;
u32 VAR_17 = 0;
VAR_13 = !(VAR_5 & VAR_18);
VAR_9 = sk_psock_get(VAR_1);
if (!VAR_9 || !VAR_13) {
VAR_15 = tls_push_record(VAR_1, VAR_5, VAR_3);
if (VAR_15 && VAR_1->sk_err == VAR_19) {
*VAR_4 -= sk_msg_free(VAR_1, VAR_0);
tls_free_open_rec(VAR_1);
VAR_15 = -VAR_1->sk_err;
}
if (VAR_9)
sk_psock_put(VAR_1, VAR_9);
return VAR_15;
}
more_data:
VAR_12 = sk_msg_full(VAR_0);
if (VAR_9->eval == VAR_20) {
VAR_17 = VAR_0->sg.size;
VAR_9->eval = sk_psock_msg_verdict(VAR_1, VAR_9, VAR_0);
VAR_17 -= VAR_0->sg.size;
}
if (VAR_0->cork_bytes && VAR_0->cork_bytes > VAR_0->sg.size &&
!VAR_12 && !VAR_2) {
VAR_15 = -VAR_21;
goto out_err;
}
VAR_0->cork_bytes = 0;
VAR_16 = VAR_0->sg.size;
if (VAR_0->apply_bytes && VAR_0->apply_bytes < VAR_16)
VAR_16 = VAR_0->apply_bytes;
switch (VAR_9->eval) {
case VAR_22:
VAR_15 = tls_push_record(VAR_1, VAR_5, VAR_3);
if (VAR_15 && VAR_1->sk_err == VAR_19) {
*VAR_4 -= sk_msg_free(VAR_1, VAR_0);
tls_free_open_rec(VAR_1);
VAR_15 = -VAR_1->sk_err;
goto out_err;
}
break;
case VAR_23:
VAR_14 = VAR_9->redir_ingress;
VAR_10 = VAR_9->sk_redir;
memcpy(&VAR_8, VAR_0, sizeof(*VAR_0));
if (VAR_0->apply_bytes < VAR_16)
VAR_0->apply_bytes = 0;
else
VAR_0->apply_bytes -= VAR_16;
sk_msg_return_zero(VAR_1, VAR_0, VAR_16);
VAR_0->sg.size -= VAR_16;
release_sock(VAR_1);
VAR_15 = tcp_bpf_sendmsg_redir(VAR_10, VAR_14,
&VAR_8, VAR_16, VAR_5);
lock_sock(VAR_1);
if (VAR_15 < 0) {
*VAR_4 -= sk_msg_free_nocharge(VAR_1, &VAR_8);
VAR_0->sg.size = 0;
}
if (VAR_0->sg.size == 0)
tls_free_open_rec(VAR_1);
break;
case VAR_24:
default:
sk_msg_free_partial(VAR_1, VAR_0, VAR_16);
if (VAR_0->apply_bytes < VAR_16)
VAR_0->apply_bytes = 0;
else
VAR_0->apply_bytes -= VAR_16;
if (VAR_0->sg.size == 0)
tls_free_open_rec(VAR_1);
*VAR_4 -= (VAR_16 + VAR_17);
VAR_15 = -VAR_25;
}
if (likely(!VAR_15)) {
bool VAR_26 = !VAR_7->open_rec;
VAR_11 = VAR_7->open_rec;
if (VAR_11) {
VAR_0 = &VAR_11->msg_plaintext;
if (!VAR_0->apply_bytes)
VAR_26 = true;
}
if (VAR_26) {
VAR_9->eval = VAR_20;
if (VAR_9->sk_redir) {
sock_put(VAR_9->sk_redir);
VAR_9->sk_redir = NULL;
}
}
if (VAR_11)
goto more_data;
}
out_err:
sk_psock_put(VAR_1, VAR_9);
return VAR_15;
}",torvalds/linux/cfaa80c91f6f99b9342b6557f0f0e1143e434066/tls_sw.c/vul/before/0.json,"static int bpf_exec_tx_verdict(struct sk_msg *msg, struct sock *sk,
			       bool full_record, u8 record_type,
			       ssize_t *copied, int flags)
{
	struct tls_context *tls_ctx = tls_get_ctx(sk);
	struct tls_sw_context_tx *ctx = tls_sw_ctx_tx(tls_ctx);
	struct sk_msg msg_redir = { };
	struct sk_psock *psock;
	struct sock *sk_redir;
	struct tls_rec *rec;
	bool enospc, policy, redir_ingress;
	int err = 0, send;
	u32 delta = 0;

	policy = !(flags & MSG_SENDPAGE_NOPOLICY);
	psock = sk_psock_get(sk);
	if (!psock || !policy) {
		err = tls_push_record(sk, flags, record_type);
		if (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {
			*copied -= sk_msg_free(sk, msg);
			tls_free_open_rec(sk);
			err = -sk->sk_err;
		}
		if (psock)
			sk_psock_put(sk, psock);
		return err;
	}
more_data:
	enospc = sk_msg_full(msg);
	if (psock->eval == __SK_NONE) {
		delta = msg->sg.size;
		psock->eval = sk_psock_msg_verdict(sk, psock, msg);
		delta -= msg->sg.size;
	}
	if (msg->cork_bytes && msg->cork_bytes > msg->sg.size &&
	    !enospc && !full_record) {
		err = -ENOSPC;
		goto out_err;
	}
	msg->cork_bytes = 0;
	send = msg->sg.size;
	if (msg->apply_bytes && msg->apply_bytes < send)
		send = msg->apply_bytes;

	switch (psock->eval) {
	case __SK_PASS:
		err = tls_push_record(sk, flags, record_type);
		if (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {
			*copied -= sk_msg_free(sk, msg);
			tls_free_open_rec(sk);
			err = -sk->sk_err;
			goto out_err;
		}
		break;
	case __SK_REDIRECT:
		redir_ingress = psock->redir_ingress;
		sk_redir = psock->sk_redir;
		memcpy(&msg_redir, msg, sizeof(*msg));
		if (msg->apply_bytes < send)
			msg->apply_bytes = 0;
		else
			msg->apply_bytes -= send;
		sk_msg_return_zero(sk, msg, send);
		msg->sg.size -= send;
		release_sock(sk);
		err = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,
					    &msg_redir, send, flags);
		lock_sock(sk);
		if (err < 0) {
			*copied -= sk_msg_free_nocharge(sk, &msg_redir);
			msg->sg.size = 0;
		}
		if (msg->sg.size == 0)
			tls_free_open_rec(sk);
		break;
	case __SK_DROP:
	default:
		sk_msg_free_partial(sk, msg, send);
		if (msg->apply_bytes < send)
			msg->apply_bytes = 0;
		else
			msg->apply_bytes -= send;
		if (msg->sg.size == 0)
			tls_free_open_rec(sk);
		*copied -= (send + delta);
		err = -EACCES;
	}

	if (likely(!err)) {
		bool reset_eval = !ctx->open_rec;

		rec = ctx->open_rec;
		if (rec) {
			msg = &rec->msg_plaintext;
			if (!msg->apply_bytes)
				reset_eval = true;
		}
		if (reset_eval) {
			psock->eval = __SK_NONE;
			if (psock->sk_redir) {
				sock_put(psock->sk_redir);
				psock->sk_redir = NULL;
			}
		}
		if (rec)
			goto more_data;
	}
 out_err:
	sk_psock_put(sk, psock);
	return err;
}","static int bpf_exec_tx_verdict(struct sk_msg *VAR_0, struct sock *VAR_1,
			       bool VAR_2, u8 VAR_3,
			       ssize_t *VAR_4, int VAR_5)
{
	struct tls_context *VAR_6 = tls_get_ctx(VAR_1);
	struct tls_sw_context_tx *VAR_7 = tls_sw_ctx_tx(VAR_6);
	struct sk_msg VAR_8 = { };
	struct sk_psock *VAR_9;
	struct sock *VAR_10;
	struct tls_rec *VAR_11;
	bool VAR_12, VAR_13, VAR_14;
	int VAR_15 = 0, VAR_16;
	u32 VAR_17 = 0;

	VAR_13 = !(VAR_5 & VAR_18);
	VAR_9 = sk_psock_get(VAR_1);
	if (!VAR_9 || !VAR_13) {
		VAR_15 = tls_push_record(VAR_1, VAR_5, VAR_3);
		if (VAR_15 && VAR_15 != -VAR_19 && VAR_1->sk_err == VAR_20) {
			*VAR_4 -= sk_msg_free(VAR_1, VAR_0);
			tls_free_open_rec(VAR_1);
			VAR_15 = -VAR_1->sk_err;
		}
		if (VAR_9)
			sk_psock_put(VAR_1, VAR_9);
		return VAR_15;
	}
more_data:
	VAR_12 = sk_msg_full(VAR_0);
	if (VAR_9->eval == VAR_21) {
		VAR_17 = VAR_0->sg.size;
		VAR_9->eval = sk_psock_msg_verdict(VAR_1, VAR_9, VAR_0);
		VAR_17 -= VAR_0->sg.size;
	}
	if (VAR_0->cork_bytes && VAR_0->cork_bytes > VAR_0->sg.size &&
	    !VAR_12 && !VAR_2) {
		VAR_15 = -VAR_22;
		goto out_err;
	}
	VAR_0->cork_bytes = 0;
	VAR_16 = VAR_0->sg.size;
	if (VAR_0->apply_bytes && VAR_0->apply_bytes < VAR_16)
		VAR_16 = VAR_0->apply_bytes;

	switch (VAR_9->eval) {
	case VAR_23:
		VAR_15 = tls_push_record(VAR_1, VAR_5, VAR_3);
		if (VAR_15 && VAR_15 != -VAR_19 && VAR_1->sk_err == VAR_20) {
			*VAR_4 -= sk_msg_free(VAR_1, VAR_0);
			tls_free_open_rec(VAR_1);
			VAR_15 = -VAR_1->sk_err;
			goto out_err;
		}
		break;
	case VAR_24:
		VAR_14 = VAR_9->redir_ingress;
		VAR_10 = VAR_9->sk_redir;
		memcpy(&VAR_8, VAR_0, sizeof(*VAR_0));
		if (VAR_0->apply_bytes < VAR_16)
			VAR_0->apply_bytes = 0;
		else
			VAR_0->apply_bytes -= VAR_16;
		sk_msg_return_zero(VAR_1, VAR_0, VAR_16);
		VAR_0->sg.size -= VAR_16;
		release_sock(VAR_1);
		VAR_15 = tcp_bpf_sendmsg_redir(VAR_10, VAR_14,
					    &VAR_8, VAR_16, VAR_5);
		lock_sock(VAR_1);
		if (VAR_15 < 0) {
			*VAR_4 -= sk_msg_free_nocharge(VAR_1, &VAR_8);
			VAR_0->sg.size = 0;
		}
		if (VAR_0->sg.size == 0)
			tls_free_open_rec(VAR_1);
		break;
	case VAR_25:
	default:
		sk_msg_free_partial(VAR_1, VAR_0, VAR_16);
		if (VAR_0->apply_bytes < VAR_16)
			VAR_0->apply_bytes = 0;
		else
			VAR_0->apply_bytes -= VAR_16;
		if (VAR_0->sg.size == 0)
			tls_free_open_rec(VAR_1);
		*VAR_4 -= (VAR_16 + VAR_17);
		VAR_15 = -VAR_26;
	}

	if (likely(!VAR_15)) {
		bool VAR_27 = !VAR_7->open_rec;

		VAR_11 = VAR_7->open_rec;
		if (VAR_11) {
			VAR_0 = &VAR_11->msg_plaintext;
			if (!VAR_0->apply_bytes)
				VAR_27 = true;
		}
		if (VAR_27) {
			VAR_9->eval = VAR_21;
			if (VAR_9->sk_redir) {
				sock_put(VAR_9->sk_redir);
				VAR_9->sk_redir = NULL;
			}
		}
		if (VAR_11)
			goto more_data;
	}
 out_err:
	sk_psock_put(VAR_1, VAR_9);
	return VAR_15;
}",torvalds/linux/cfaa80c91f6f99b9342b6557f0f0e1143e434066/tls_sw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 	psock = sk_psock_get(sk);
 	if (!psock || !policy) {
 		err = tls_push_record(sk, flags, record_type);
-		if (err && sk->sk_err == EBADMSG) {
+		if (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {
 			*copied -= sk_msg_free(sk, msg);
 			tls_free_open_rec(sk);
 			err = -sk->sk_err;
@@ -45,7 +45,7 @@
 	switch (psock->eval) {
 	case __SK_PASS:
 		err = tls_push_record(sk, flags, record_type);
-		if (err && sk->sk_err == EBADMSG) {
+		if (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {
 			*copied -= sk_msg_free(sk, msg);
 			tls_free_open_rec(sk);
 			err = -sk->sk_err;","{'deleted_lines': ['\t\tif (err && sk->sk_err == EBADMSG) {', '\t\tif (err && sk->sk_err == EBADMSG) {'], 'added_lines': ['\t\tif (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {', '\t\tif (err && err != -EINPROGRESS && sk->sk_err == EBADMSG) {']}",True,"A null pointer dereference flaw was found in the Linux kernel API for the cryptographic algorithm scatterwalk functionality. This issue occurs when a user constructs a malicious packet with specific socket configuration, which could allow a local user to crash the system or escalate their privileges on the system.",4.4,MEDIUM,1,valid,,5
CVE-2016-10164,"['CWE-190', 'CWE-787', 'CWE-119']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/lib/libXpm,"libXpm uses unsigned int to store sizes, which fits size_t on 32 bit
systems, but leads to issues on 64 bit systems.

On 64 bit systems, it is possible to overflow 32 bit integers while
parsing XPM extensions in a file.

At first, it looks like a rather unimportant detail, because nobody
will seriously open a 4 GB file. But unfortunately XPM has support for
gzip compression out of the box. An attacker can therefore craft a
compressed file which is merely 4 MB in size, which makes an attack
much for feasable.

Signed-off-by: Matthieu Herrb <matthieu@herrb.eu>
Reviewed-by: Matthieu Herrb <matthieu@herrb.eu>
",d1167418f0fd02a27f617ec5afd6db053afbe185,https://cgit.freedesktop.org/xorg/lib/libXpm/commit/?id=d1167418f0fd02a27f617ec5afd6db053afbe185,src/CrDatFrI.c,CountExtensions,"static void
CountExtensions(
XpmExtension*ext,
unsigned int num,
unsigned int*ext_size,
unsigned int*ext_nlines)
{
unsigned int x, y, a, size, nlines;
char **line;
size = 0;
nlines = 0;
for (x = 0; x < num; x++, ext++) {
nlines += ext->nlines + 1;
size += strlen(ext->name) + 8;
a = ext->nlines;
for (y = 0, line = ext->lines; y < a; y++, line++)
size += strlen(*line) + 1;
}
*ext_size = size + 10;
*ext_nlines = nlines + 1;
}","static void
CountExtensions(
XpmExtension*VAR_0,
unsigned int VAR_1,
unsigned int*VAR_2,
unsigned int*VAR_3)
{
unsigned int VAR_4, VAR_5, VAR_6, VAR_7, VAR_8;
char **VAR_9;
VAR_7 = 0;
VAR_8 = 0;
for (VAR_4 = 0; VAR_4 < VAR_1; VAR_4++, VAR_0++) {
VAR_8 += VAR_0->nlines + 1;
VAR_7 += strlen(VAR_0->name) + 8;
VAR_6 = VAR_0->nlines;
for (VAR_5 = 0, VAR_9 = VAR_0->lines; VAR_5 < VAR_6; VAR_5++, VAR_9++)
VAR_7 += strlen(*VAR_9) + 1;
}
*VAR_2 = VAR_7 + 10;
*VAR_3 = VAR_8 + 1;
}",xorg/lib/libXpm/d1167418f0fd02a27f617ec5afd6db053afbe185/CrDatFrI.c/vul/before/0.json,"static int
CountExtensions(
    XpmExtension	*ext,
    unsigned int	 num,
    unsigned int	*ext_size,
    unsigned int	*ext_nlines)
{
    size_t len;
    unsigned int x, y, a, size, nlines;
    char **line;

    size = 0;
    nlines = 0;
    for (x = 0; x < num; x++, ext++) {
	/* 1 for the name */
	if (ext->nlines == UINT_MAX || nlines > UINT_MAX - ext->nlines - 1)
	    return (1);
	nlines += ext->nlines + 1;
	/* 8 = 7 (for ""XPMEXT "") + 1 (for 0) */
	len = strlen(ext->name) + 8;
	if (len > UINT_MAX - size)
	    return (1);
	size += len;
	a = ext->nlines;
	for (y = 0, line = ext->lines; y < a; y++, line++) {
	    len = strlen(*line) + 1;
	    if (len > UINT_MAX - size)
		return (1);
	    size += len;
	}
    }
    if (size > UINT_MAX - 10 || nlines > UINT_MAX - 1)
	return (1);
    /* 10 and 1 are for the ending ""XPMENDEXT"" */
    *ext_size = size + 10;
    *ext_nlines = nlines + 1;
    return (0);
}","static int
CountExtensions(
    XpmExtension	*VAR_0,
    unsigned int	 VAR_1,
    unsigned int	*VAR_2,
    unsigned int	*VAR_3)
{
    size_t VAR_4;
    unsigned int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
    char **VAR_10;

    VAR_8 = 0;
    VAR_9 = 0;
    for (VAR_5 = 0; VAR_5 < VAR_1; VAR_5++, VAR_0++) {
	/* COMMENT_0 */
	if (VAR_0->nlines == VAR_11 || VAR_9 > VAR_11 - VAR_0->nlines - 1)
	    return (1);
	VAR_9 += VAR_0->nlines + 1;
	/* COMMENT_1 */
	VAR_4 = strlen(VAR_0->name) + 8;
	if (VAR_4 > VAR_11 - VAR_8)
	    return (1);
	VAR_8 += VAR_4;
	VAR_7 = VAR_0->nlines;
	for (VAR_6 = 0, VAR_10 = VAR_0->lines; VAR_6 < VAR_7; VAR_6++, VAR_10++) {
	    VAR_4 = strlen(*VAR_10) + 1;
	    if (VAR_4 > VAR_11 - VAR_8)
		return (1);
	    VAR_8 += VAR_4;
	}
    }
    if (VAR_8 > VAR_11 - 10 || VAR_9 > VAR_11 - 1)
	return (1);
    /* COMMENT_2 */
    *VAR_2 = VAR_8 + 10;
    *VAR_3 = VAR_9 + 1;
    return (0);
}",xorg/lib/libXpm/d1167418f0fd02a27f617ec5afd6db053afbe185/CrDatFrI.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,11 @@
-static void
+static int
 CountExtensions(
     XpmExtension	*ext,
     unsigned int	 num,
     unsigned int	*ext_size,
     unsigned int	*ext_nlines)
 {
+    size_t len;
     unsigned int x, y, a, size, nlines;
     char **line;
 
@@ -12,14 +13,26 @@
     nlines = 0;
     for (x = 0; x < num; x++, ext++) {
 	/* 1 for the name */
+	if (ext->nlines == UINT_MAX || nlines > UINT_MAX - ext->nlines - 1)
+	    return (1);
 	nlines += ext->nlines + 1;
 	/* 8 = 7 (for ""XPMEXT "") + 1 (for 0) */
-	size += strlen(ext->name) + 8;
+	len = strlen(ext->name) + 8;
+	if (len > UINT_MAX - size)
+	    return (1);
+	size += len;
 	a = ext->nlines;
-	for (y = 0, line = ext->lines; y < a; y++, line++)
-	    size += strlen(*line) + 1;
+	for (y = 0, line = ext->lines; y < a; y++, line++) {
+	    len = strlen(*line) + 1;
+	    if (len > UINT_MAX - size)
+		return (1);
+	    size += len;
+	}
     }
+    if (size > UINT_MAX - 10 || nlines > UINT_MAX - 1)
+	return (1);
     /* 10 and 1 are for the ending ""XPMENDEXT"" */
     *ext_size = size + 10;
     *ext_nlines = nlines + 1;
+    return (0);
 }","{'deleted_lines': ['static void', '\tsize += strlen(ext->name) + 8;', '\tfor (y = 0, line = ext->lines; y < a; y++, line++)', '\t    size += strlen(*line) + 1;'], 'added_lines': ['static int', '    size_t len;', '\tif (ext->nlines == UINT_MAX || nlines > UINT_MAX - ext->nlines - 1)', '\t    return (1);', '\tlen = strlen(ext->name) + 8;', '\tif (len > UINT_MAX - size)', '\t    return (1);', '\tsize += len;', '\tfor (y = 0, line = ext->lines; y < a; y++, line++) {', '\t    len = strlen(*line) + 1;', '\t    if (len > UINT_MAX - size)', '\t\treturn (1);', '\t    size += len;', '\t}', '    if (size > UINT_MAX - 10 || nlines > UINT_MAX - 1)', '\treturn (1);', '    return (0);']}",True,"Multiple integer overflows in libXpm before 3.5.12, when a program requests parsing XPM extensions on a 64-bit platform, allow remote attackers to cause a denial of service (out-of-bounds write) or execute arbitrary code via (1) the number of extensions or (2) their concatenated length in a crafted XPM file, which triggers a heap-based buffer overflow.",9.8,CRITICAL,3,valid,,5
CVE-2016-10164,"['CWE-190', 'CWE-787', 'CWE-119']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/lib/libXpm,"libXpm uses unsigned int to store sizes, which fits size_t on 32 bit
systems, but leads to issues on 64 bit systems.

On 64 bit systems, it is possible to overflow 32 bit integers while
parsing XPM extensions in a file.

At first, it looks like a rather unimportant detail, because nobody
will seriously open a 4 GB file. But unfortunately XPM has support for
gzip compression out of the box. An attacker can therefore craft a
compressed file which is merely 4 MB in size, which makes an attack
much for feasable.

Signed-off-by: Matthieu Herrb <matthieu@herrb.eu>
Reviewed-by: Matthieu Herrb <matthieu@herrb.eu>
",d1167418f0fd02a27f617ec5afd6db053afbe185,https://cgit.freedesktop.org/xorg/lib/libXpm/commit/?id=d1167418f0fd02a27f617ec5afd6db053afbe185,src/CrDatFrI.c,XpmCreateDataFromXpmImage,"int
XpmCreateDataFromXpmImage(
char***data_return,
XpmImage  *image,
XpmInfo  *info)
{
int ErrorStatus;
char buf[BUFSIZ];
char **header = NULL, **data, **sptr, **sptr2, *s;
unsigned int header_size, header_nlines;
unsigned int data_size, data_nlines;
unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
unsigned int offset, l, n;
*data_return = NULL;
extensions = info && (info->valuemask & XpmExtensions)
&& info->nextensions;
if (extensions)
CountExtensions(info->extensions, info->nextensions,
&ext_size, &ext_nlines);
header_nlines = 1 + image->ncolors; 
if(header_nlines <= image->ncolors ||
header_nlines >= UINT_MAX / sizeof(char *))
return(XpmNoMemory);
header_size = sizeof(char *) * header_nlines;
if (header_size >= UINT_MAX / sizeof(char *))
return (XpmNoMemory);
header = (char **) XpmCalloc(header_size, sizeof(char *)); 
if (!header)
return (XpmNoMemory);
s = buf;
#ifndef VOID_SPRINTF
s +=
#endif
sprintf(s, ""%d %d %d %d"", image->width, image->height,
image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
s += strlen(s);
#endif
if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
s +=
#endif
sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
s += strlen(s);
#endif
}
if (extensions) {
strcpy(s, "" XPMEXT"");
s += 7;
}
l = s - buf + 1;
*header = (char *) XpmMalloc(l);
if (!*header)
RETURN(XpmNoMemory);
header_size += l;
strcpy(*header, buf);
ErrorStatus = CreateColors(header + 1, &header_size,
image->colorTable, image->ncolors, image->cpp);
if (ErrorStatus != XpmSuccess)
RETURN(ErrorStatus);
offset = image->width * image->cpp + 1;
if(offset <= image->width || offset <= image->cpp)
RETURN(XpmNoMemory);
if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
RETURN(XpmNoMemory);
data_size = (image->height + ext_nlines) * sizeof(char *);
if (image->height > UINT_MAX / offset ||
image->height * offset > UINT_MAX - data_size)
RETURN(XpmNoMemory);
data_size += image->height * offset;
if( (header_size + ext_size) >= (UINT_MAX - data_size) )
RETURN(XpmNoMemory);
data_size += header_size + ext_size;
data = (char **) XpmMalloc(data_size);
if (!data)
RETURN(XpmNoMemory);
data_nlines = header_nlines + image->height + ext_nlines;
*data = (char *) (data + data_nlines);
n = image->ncolors;
for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
strcpy(*sptr, *sptr2);
*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
}
data[header_nlines] = (char *) data + header_size
+ (image->height + ext_nlines) * sizeof(char *);
CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
image->cpp, image->data, image->colorTable);
if (extensions)
CreateExtensions(data + header_nlines + image->height - 1,
data_size - header_nlines - image->height + 1, offset,
info->extensions, info->nextensions,
ext_nlines);
*data_return = data;
ErrorStatus = XpmSuccess;
exit:
if (header) {
for (l = 0; l < header_nlines; l++)
if (header[l])
XpmFree(header[l]);
XpmFree(header);
}
return(ErrorStatus);
}","int
XpmCreateDataFromXpmImage(
char***VAR_0,
XpmImage  *VAR_1,
XpmInfo  *VAR_2)
{
int VAR_3;
char VAR_4[VAR_5];
char **VAR_6 = NULL, **VAR_7, **VAR_8, **VAR_9, *VAR_10;
unsigned int VAR_11, VAR_12;
unsigned int VAR_13, VAR_14;
unsigned int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0;
unsigned int VAR_18, VAR_19, VAR_20;
*VAR_0 = NULL;
VAR_15 = VAR_2 && (VAR_2->valuemask & VAR_21)
&& VAR_2->nextensions;
if (VAR_15)
CountExtensions(VAR_2->extensions, VAR_2->nextensions,
&VAR_16, &VAR_17);
VAR_12 = 1 + VAR_1->ncolors; 
if(VAR_12 <= VAR_1->ncolors ||
VAR_12 >= VAR_22 / sizeof(char *))
return(VAR_23);
VAR_11 = sizeof(char *) * VAR_12;
if (VAR_11 >= VAR_22 / sizeof(char *))
return (VAR_23);
VAR_6 = (char **) XpmCalloc(VAR_11, sizeof(char *)); 
if (!VAR_6)
return (VAR_23);
VAR_10 = VAR_4;
#ifndef VAR_24
VAR_10 +=
#endif
sprintf(VAR_10, ""%d %d %d %d"", VAR_1->width, VAR_1->height,
VAR_1->ncolors, VAR_1->cpp);
#ifdef VAR_24
VAR_10 += strlen(VAR_10);
#endif
if (VAR_2 && (VAR_2->valuemask & VAR_25)) {
#ifndef VAR_24
VAR_10 +=
#endif
sprintf(VAR_10, "" %d %d"", VAR_2->x_hotspot, VAR_2->y_hotspot);
#ifdef VAR_24
VAR_10 += strlen(VAR_10);
#endif
}
if (VAR_15) {
strcpy(VAR_10, "" XPMEXT"");
VAR_10 += 7;
}
VAR_19 = VAR_10 - VAR_4 + 1;
*VAR_6 = (char *) XpmMalloc(VAR_19);
if (!*VAR_6)
RETURN(VAR_23);
VAR_11 += VAR_19;
strcpy(*VAR_6, VAR_4);
VAR_3 = CreateColors(VAR_6 + 1, &VAR_11,
VAR_1->colorTable, VAR_1->ncolors, VAR_1->cpp);
if (VAR_3 != VAR_26)
RETURN(VAR_3);
VAR_18 = VAR_1->width * VAR_1->cpp + 1;
if(VAR_18 <= VAR_1->width || VAR_18 <= VAR_1->cpp)
RETURN(VAR_23);
if( (VAR_1->height + VAR_17) >= VAR_22 / sizeof(char *))
RETURN(VAR_23);
VAR_13 = (VAR_1->height + VAR_17) * sizeof(char *);
if (VAR_1->height > VAR_22 / VAR_18 ||
VAR_1->height * VAR_18 > VAR_22 - VAR_13)
RETURN(VAR_23);
VAR_13 += VAR_1->height * VAR_18;
if( (VAR_11 + VAR_16) >= (VAR_22 - VAR_13) )
RETURN(VAR_23);
VAR_13 += VAR_11 + VAR_16;
VAR_7 = (char **) XpmMalloc(VAR_13);
if (!VAR_7)
RETURN(VAR_23);
VAR_14 = VAR_12 + VAR_1->height + VAR_17;
*VAR_7 = (char *) (VAR_7 + VAR_14);
VAR_20 = VAR_1->ncolors;
for (VAR_19 = 0, VAR_8 = VAR_7, VAR_9 = VAR_6; VAR_19 <= VAR_20 && VAR_8 && VAR_9; VAR_19++, VAR_8++, VAR_9++) {
strcpy(*VAR_8, *VAR_9);
*(VAR_8 + 1) = *VAR_8 + strlen(*VAR_9) + 1;
}
VAR_7[VAR_12] = (char *) VAR_7 + VAR_11
+ (VAR_1->height + VAR_17) * sizeof(char *);
CreatePixels(VAR_7 + VAR_12, VAR_13-VAR_12, VAR_1->width, VAR_1->height,
VAR_1->cpp, VAR_1->data, VAR_1->colorTable);
if (VAR_15)
CreateExtensions(VAR_7 + VAR_12 + VAR_1->height - 1,
VAR_13 - VAR_12 - VAR_1->height + 1, VAR_18,
VAR_2->extensions, VAR_2->nextensions,
VAR_17);
*VAR_0 = VAR_7;
VAR_3 = VAR_26;
exit:
if (VAR_6) {
for (VAR_19 = 0; VAR_19 < VAR_12; VAR_19++)
if (VAR_6[VAR_19])
XpmFree(VAR_6[VAR_19]);
XpmFree(VAR_6);
}
return(VAR_3);
}",xorg/lib/libXpm/d1167418f0fd02a27f617ec5afd6db053afbe185/CrDatFrI.c/vul/before/1.json,"int
XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;

    /* compute the number of extensions lines and size */
    if (extensions)
	if (CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines))
	    return(XpmNoMemory);

    /*
     * alloc a temporary array of char pointer for the header section which
     * is the hints line + the color table lines
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
	RETURN(XpmNoMemory);

    if (image->height > UINT_MAX - ext_nlines ||
	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
	RETURN(XpmNoMemory);
    data_size = (image->height + ext_nlines) * sizeof(char *);

    if (image->height > UINT_MAX / offset ||
        image->height * offset > UINT_MAX - data_size)
	RETURN(XpmNoMemory);
    data_size += image->height * offset;

    if (header_size > UINT_MAX - ext_size ||
	header_size + ext_size >= (UINT_MAX - data_size) )
	RETURN(XpmNoMemory);
    data_size += header_size + ext_size;

    data = (char **) XpmMalloc(data_size);
    if (!data)
	RETURN(XpmNoMemory);

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}","int
XpmCreateDataFromXpmImage(
    char	***VAR_0,
    XpmImage	  *VAR_1,
    XpmInfo	  *VAR_2)
{
    /* COMMENT_0 */
    int VAR_3;
    char VAR_4[VAR_5];
    char **VAR_6 = NULL, **VAR_7, **VAR_8, **VAR_9, *VAR_10;
    unsigned int VAR_11, VAR_12;
    unsigned int VAR_13, VAR_14;
    unsigned int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0;
    unsigned int VAR_18, VAR_19, VAR_20;

    *VAR_0 = NULL;

    VAR_15 = VAR_2 && (VAR_2->valuemask & VAR_21)
	&& VAR_2->nextensions;

    /* COMMENT_1 */
    if (VAR_15)
	if (CountExtensions(VAR_2->extensions, VAR_2->nextensions,
			&VAR_16, &VAR_17))
	    return(VAR_22);

    /* COMMENT_2 */
                                                                           
                                                
       
    VAR_12 = 1 + VAR_1->ncolors; /* COMMENT_6 */

    /* COMMENT_7 */
    if(VAR_12 <= VAR_1->ncolors ||
       VAR_12 >= VAR_23 / sizeof(char *))
    	return(VAR_22);

    VAR_11 = sizeof(char *) * VAR_12;
    if (VAR_11 >= VAR_23 / sizeof(char *))
	return (VAR_22);
    VAR_6 = (char **) XpmCalloc(VAR_11, sizeof(char *)); /* COMMENT_8 */
    if (!VAR_6)
	return (VAR_22);

    /* COMMENT_9 */
    VAR_10 = VAR_4;
#ifndef VAR_24
    VAR_10 +=
#endif
    sprintf(VAR_10, ""%d %d %d %d"", VAR_1->width, VAR_1->height,
	    VAR_1->ncolors, VAR_1->cpp);
#ifdef VAR_24
    VAR_10 += strlen(VAR_10);
#endif

    if (VAR_2 && (VAR_2->valuemask & VAR_25)) {
#ifndef VAR_24
	VAR_10 +=
#endif
	sprintf(VAR_10, "" %d %d"", VAR_2->x_hotspot, VAR_2->y_hotspot);
#ifdef VAR_24
	VAR_10 += strlen(VAR_10);
#endif
    }
    if (VAR_15) {
	strcpy(VAR_10, "" XPMEXT"");
	VAR_10 += 7;
    }
    VAR_19 = VAR_10 - VAR_4 + 1;
    *VAR_6 = (char *) XpmMalloc(VAR_19);
    if (!*VAR_6)
	RETURN(VAR_22);
    VAR_11 += VAR_19;
    strcpy(*VAR_6, VAR_4);

    /* COMMENT_10 */
    VAR_3 = CreateColors(VAR_6 + 1, &VAR_11,
			       VAR_1->colorTable, VAR_1->ncolors, VAR_1->cpp);

    if (VAR_3 != VAR_26)
	RETURN(VAR_3);

    /* COMMENT_11 */
    VAR_18 = VAR_1->width * VAR_1->cpp + 1;

    if(VAR_18 <= VAR_1->width || VAR_18 <= VAR_1->cpp)
	RETURN(VAR_22);

    if (VAR_1->height > VAR_23 - VAR_17 ||
	VAR_1->height + VAR_17 >= VAR_23 / sizeof(char *))
	RETURN(VAR_22);
    VAR_13 = (VAR_1->height + VAR_17) * sizeof(char *);

    if (VAR_1->height > VAR_23 / VAR_18 ||
        VAR_1->height * VAR_18 > VAR_23 - VAR_13)
	RETURN(VAR_22);
    VAR_13 += VAR_1->height * VAR_18;

    if (VAR_11 > VAR_23 - VAR_16 ||
	VAR_11 + VAR_16 >= (VAR_23 - VAR_13) )
	RETURN(VAR_22);
    VAR_13 += VAR_11 + VAR_16;

    VAR_7 = (char **) XpmMalloc(VAR_13);
    if (!VAR_7)
	RETURN(VAR_22);

    VAR_14 = VAR_12 + VAR_1->height + VAR_17;
    *VAR_7 = (char *) (VAR_7 + VAR_14);

    /* COMMENT_12 */
    VAR_20 = VAR_1->ncolors;
    for (VAR_19 = 0, VAR_8 = VAR_7, VAR_9 = VAR_6; VAR_19 <= VAR_20 && VAR_8 && VAR_9; VAR_19++, VAR_8++, VAR_9++) {
	strcpy(*VAR_8, *VAR_9);
	*(VAR_8 + 1) = *VAR_8 + strlen(*VAR_9) + 1;
    }

    /* COMMENT_13 */
    VAR_7[VAR_12] = (char *) VAR_7 + VAR_11
	+ (VAR_1->height + VAR_17) * sizeof(char *);

    CreatePixels(VAR_7 + VAR_12, VAR_13-VAR_12, VAR_1->width, VAR_1->height,
		 VAR_1->cpp, VAR_1->data, VAR_1->colorTable);

    /* COMMENT_14 */
    if (VAR_15)
	CreateExtensions(VAR_7 + VAR_12 + VAR_1->height - 1,
			 VAR_13 - VAR_12 - VAR_1->height + 1, VAR_18,
			 VAR_2->extensions, VAR_2->nextensions,
			 VAR_17);

    *VAR_0 = VAR_7;
    VAR_3 = VAR_26;

/* COMMENT_15 */
exit:
    if (VAR_6) {
	for (VAR_19 = 0; VAR_19 < VAR_12; VAR_19++)
	    if (VAR_6[VAR_19])
		XpmFree(VAR_6[VAR_19]);
		XpmFree(VAR_6);
    }
    return(VAR_3);
}",xorg/lib/libXpm/d1167418f0fd02a27f617ec5afd6db053afbe185/CrDatFrI.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -20,8 +20,9 @@
 
     /* compute the number of extensions lines and size */
     if (extensions)
-	CountExtensions(info->extensions, info->nextensions,
-			&ext_size, &ext_nlines);
+	if (CountExtensions(info->extensions, info->nextensions,
+			&ext_size, &ext_nlines))
+	    return(XpmNoMemory);
 
     /*
      * alloc a temporary array of char pointer for the header section which
@@ -85,7 +86,8 @@
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
-    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
+    if (image->height > UINT_MAX - ext_nlines ||
+	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
@@ -94,7 +96,8 @@
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
-    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
+    if (header_size > UINT_MAX - ext_size ||
+	header_size + ext_size >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 ","{'deleted_lines': ['\tCountExtensions(info->extensions, info->nextensions,', '\t\t\t&ext_size, &ext_nlines);', '    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))', '    if( (header_size + ext_size) >= (UINT_MAX - data_size) )'], 'added_lines': ['\tif (CountExtensions(info->extensions, info->nextensions,', '\t\t\t&ext_size, &ext_nlines))', '\t    return(XpmNoMemory);', '    if (image->height > UINT_MAX - ext_nlines ||', '\timage->height + ext_nlines >= UINT_MAX / sizeof(char *))', '    if (header_size > UINT_MAX - ext_size ||', '\theader_size + ext_size >= (UINT_MAX - data_size) )']}",True,"Multiple integer overflows in libXpm before 3.5.12, when a program requests parsing XPM extensions on a 64-bit platform, allow remote attackers to cause a denial of service (out-of-bounds write) or execute arbitrary code via (1) the number of extensions or (2) their concatenated length in a crafted XPM file, which triggers a heap-based buffer overflow.",9.8,CRITICAL,3,valid,,5
CVE-2021-31871,['CWE-190'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,klibc,"copyin_link() tries to allocate (unsigned int)c_filesize + 1 bytes.
If c_filesize == UINT_MAX, this works out as 0 bytes, resulting in a
null pointer and a subsequent SIGSEGV.

The previous commit made this impossible on 32-bit systems.

CVE-2021-31871

Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
",2e48a12ab1e30d43498c2d53e878a11a1b5102d5,https://git.kernel.org/pub/scm/libs/klibc/klibc.git/commit/?h=2e48a12ab1e30d43498c2d53e878a11a1b5102d5,usr/utils/cpio.c,copyin_link,"static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des)
{
char *link_name = NULL;
int res;
link_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1);
link_name[file_hdr->c_filesize] = '\0';
tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);
tape_skip_padding(in_file_des, file_hdr->c_filesize);
res = symlink(link_name, file_hdr->c_name);
if (res < 0) {
fprintf(stderr, ""%s: symlink %s: %s\n"",
progname, file_hdr->c_name, strerror(errno));
free(link_name);
return;
}
if ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0)
&& errno != EPERM) {
fprintf(stderr, ""%s: lchown %s: %s\n"",
progname, file_hdr->c_name, strerror(errno));
}
free(link_name);
}","static void copyin_link(struct new_cpio_header *VAR_0, int VAR_1)
{
char *VAR_2 = NULL;
int VAR_3;
VAR_2 = (char *)xmalloc((unsigned int)VAR_0->c_filesize + 1);
VAR_2[VAR_0->c_filesize] = '\0';
tape_buffered_read(VAR_2, VAR_1, VAR_0->c_filesize);
tape_skip_padding(VAR_1, VAR_0->c_filesize);
VAR_3 = symlink(VAR_2, VAR_0->c_name);
if (VAR_3 < 0) {
fprintf(VAR_4, ""%s: symlink %s: %s\n"",
VAR_5, VAR_0->c_name, strerror(VAR_6));
free(VAR_2);
return;
}
if ((lchown(VAR_0->c_name, VAR_0->c_uid, VAR_0->c_gid) < 0)
&& VAR_6 != VAR_7) {
fprintf(VAR_4, ""%s: lchown %s: %s\n"",
VAR_5, VAR_0->c_name, strerror(VAR_6));
}
free(VAR_2);
}",klibc/2e48a12ab1e30d43498c2d53e878a11a1b5102d5/cpio.c/vul/before/0.json,"static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des)
{
	char *link_name = NULL;	/* Name of hard and symbolic links.  */
	int res;		/* Result of various function calls.  */

	link_name = (char *)xmalloc(file_hdr->c_filesize + 1);
	link_name[file_hdr->c_filesize] = '\0';
	tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);
	tape_skip_padding(in_file_des, file_hdr->c_filesize);

	res = symlink(link_name, file_hdr->c_name);
	if (res < 0) {
		fprintf(stderr, ""%s: symlink %s: %s\n"",
			progname, file_hdr->c_name, strerror(errno));
		free(link_name);
		return;
	}
	if ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0)
	    && errno != EPERM) {
		fprintf(stderr, ""%s: lchown %s: %s\n"",
			progname, file_hdr->c_name, strerror(errno));
	}
	free(link_name);
}","static void copyin_link(struct new_cpio_header *VAR_0, int VAR_1)
{
	char *VAR_2 = NULL;	/* COMMENT_0 */
	int VAR_3;		/* COMMENT_1 */

	VAR_2 = (char *)xmalloc(VAR_0->c_filesize + 1);
	VAR_2[VAR_0->c_filesize] = '\0';
	tape_buffered_read(VAR_2, VAR_1, VAR_0->c_filesize);
	tape_skip_padding(VAR_1, VAR_0->c_filesize);

	VAR_3 = symlink(VAR_2, VAR_0->c_name);
	if (VAR_3 < 0) {
		fprintf(VAR_4, ""%s: symlink %s: %s\n"",
			VAR_5, VAR_0->c_name, strerror(VAR_6));
		free(VAR_2);
		return;
	}
	if ((lchown(VAR_0->c_name, VAR_0->c_uid, VAR_0->c_gid) < 0)
	    && VAR_6 != VAR_7) {
		fprintf(VAR_4, ""%s: lchown %s: %s\n"",
			VAR_5, VAR_0->c_name, strerror(VAR_6));
	}
	free(VAR_2);
}",klibc/2e48a12ab1e30d43498c2d53e878a11a1b5102d5/cpio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	char *link_name = NULL;	/* Name of hard and symbolic links.  */
 	int res;		/* Result of various function calls.  */
 
-	link_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1);
+	link_name = (char *)xmalloc(file_hdr->c_filesize + 1);
 	link_name[file_hdr->c_filesize] = '\0';
 	tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);
 	tape_skip_padding(in_file_des, file_hdr->c_filesize);","{'deleted_lines': ['\tlink_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1);'], 'added_lines': ['\tlink_name = (char *)xmalloc(file_hdr->c_filesize + 1);']}",True,An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.,7.5,HIGH,2,valid,,5
CVE-2021-3527,['CWE-770'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu-project/qemu,"usb/redir: avoid dynamic stack allocation (CVE-2021-3527)

Use autofree heap allocation instead.

Fixes: 4f4321c11ff (""usb: use iovecs in USBPacket"")
Reviewed-by: Philippe Mathieu-Daud <philmd@redhat.com>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
Tested-by: Philippe Mathieu-Daud <philmd@redhat.com>
Message-Id: <20210503132915.2335822-3-kraxel@redhat.com>
",7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,hw/usb/redirect.c,usbredir_handle_interrupt_out_data,"static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,
USBPacket *p, uint8_t ep)
{
struct usb_redir_interrupt_packet_header interrupt_packet;
uint8_t buf[p->iov.size];
DPRINTF(""interrupt-out ep %02X len %zd id %""PRIu64""\n"", ep,
p->iov.size, p->id);
interrupt_packet.endpoint  = ep;
interrupt_packet.length    = p->iov.size;
usb_packet_copy(p, buf, p->iov.size);
usbredir_log_data(dev, ""interrupt data out:"", buf, p->iov.size);
usbredirparser_send_interrupt_packet(dev->parser, p->id,
&interrupt_packet, buf, p->iov.size);
usbredirparser_do_write(dev->parser);
}","static void usbredir_handle_interrupt_out_data(USBRedirDevice *VAR_0,
USBPacket *VAR_1, uint8_t VAR_2)
{
struct usb_redir_interrupt_packet_header VAR_3;
uint8_t VAR_4[VAR_1->iov.size];
DPRINTF(""interrupt-out ep %02X len %zd id %""VAR_5""\n"", VAR_2,
VAR_1->iov.size, VAR_1->id);
VAR_3.endpoint  = VAR_2;
VAR_3.length    = VAR_1->iov.size;
usb_packet_copy(VAR_1, VAR_4, VAR_1->iov.size);
usbredir_log_data(VAR_0, ""interrupt data out:"", VAR_4, VAR_1->iov.size);
usbredirparser_send_interrupt_packet(VAR_0->parser, VAR_1->id,
&VAR_3, VAR_4, VAR_1->iov.size);
usbredirparser_do_write(VAR_0->parser);
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/before/0.json,"static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,
                                               USBPacket *p, uint8_t ep)
{
    struct usb_redir_interrupt_packet_header interrupt_packet;
    g_autofree uint8_t *buf = g_malloc(p->iov.size);

    DPRINTF(""interrupt-out ep %02X len %zd id %""PRIu64""\n"", ep,
            p->iov.size, p->id);

    interrupt_packet.endpoint  = ep;
    interrupt_packet.length    = p->iov.size;

    usb_packet_copy(p, buf, p->iov.size);
    usbredir_log_data(dev, ""interrupt data out:"", buf, p->iov.size);
    usbredirparser_send_interrupt_packet(dev->parser, p->id,
                                    &interrupt_packet, buf, p->iov.size);
    usbredirparser_do_write(dev->parser);
}","static void usbredir_handle_interrupt_out_data(USBRedirDevice *VAR_0,
                                               USBPacket *VAR_1, uint8_t VAR_2)
{
    struct usb_redir_interrupt_packet_header VAR_3;
    g_autofree uint8_t *VAR_4 = g_malloc(VAR_1->iov.size);

    DPRINTF(""interrupt-out ep %02X len %zd id %""VAR_5""\n"", VAR_2,
            VAR_1->iov.size, VAR_1->id);

    VAR_3.endpoint  = VAR_2;
    VAR_3.length    = VAR_1->iov.size;

    usb_packet_copy(VAR_1, VAR_4, VAR_1->iov.size);
    usbredir_log_data(VAR_0, ""interrupt data out:"", VAR_4, VAR_1->iov.size);
    usbredirparser_send_interrupt_packet(VAR_0->parser, VAR_1->id,
                                    &VAR_3, VAR_4, VAR_1->iov.size);
    usbredirparser_do_write(VAR_0->parser);
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
                                                USBPacket *p, uint8_t ep)
 {
     struct usb_redir_interrupt_packet_header interrupt_packet;
-    uint8_t buf[p->iov.size];
+    g_autofree uint8_t *buf = g_malloc(p->iov.size);
 
     DPRINTF(""interrupt-out ep %02X len %zd id %""PRIu64""\n"", ep,
             p->iov.size, p->id);","{'deleted_lines': ['    uint8_t buf[p->iov.size];'], 'added_lines': ['    g_autofree uint8_t *buf = g_malloc(p->iov.size);']}",True,"A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",5.5,MEDIUM,1,valid,,5
CVE-2021-3527,['CWE-770'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu-project/qemu,"usb/redir: avoid dynamic stack allocation (CVE-2021-3527)

Use autofree heap allocation instead.

Fixes: 4f4321c11ff (""usb: use iovecs in USBPacket"")
Reviewed-by: Philippe Mathieu-Daud <philmd@redhat.com>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
Tested-by: Philippe Mathieu-Daud <philmd@redhat.com>
Message-Id: <20210503132915.2335822-3-kraxel@redhat.com>
",7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,hw/usb/redirect.c,usbredir_handle_bulk_data,"static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,
uint8_t ep)
{
struct usb_redir_bulk_packet_header bulk_packet;
size_t size = usb_packet_size(p);
const int maxp = dev->endpoint[EP2I(ep)].max_packet_size;
if (usbredir_already_in_flight(dev, p->id)) {
p->status = USB_RET_ASYNC;
return;
}
if (dev->endpoint[EP2I(ep)].bulk_receiving_enabled) {
if (size != 0 && (size % maxp) == 0) {
usbredir_handle_buffered_bulk_in_data(dev, p, ep);
return;
}
WARNING(""bulk recv invalid size %zd ep %02x, disabling\n"", size, ep);
assert(dev->endpoint[EP2I(ep)].pending_async_packet == NULL);
usbredir_stop_bulk_receiving(dev, ep);
dev->endpoint[EP2I(ep)].bulk_receiving_enabled = 0;
}
DPRINTF(""bulk-out ep %02X stream %u len %zd id %""PRIu64""\n"",
ep, p->stream, size, p->id);
bulk_packet.endpoint  = ep;
bulk_packet.length    = size;
bulk_packet.stream_id = p->stream;
bulk_packet.length_high = size >> 16;
assert(bulk_packet.length_high == 0 ||
usbredirparser_peer_has_cap(dev->parser,
usb_redir_cap_32bits_bulk_length));
if (ep & USB_DIR_IN || size == 0) {
usbredirparser_send_bulk_packet(dev->parser, p->id,
&bulk_packet, NULL, 0);
} else {
uint8_t buf[size];
usb_packet_copy(p, buf, size);
usbredir_log_data(dev, ""bulk data out:"", buf, size);
usbredirparser_send_bulk_packet(dev->parser, p->id,
&bulk_packet, buf, size);
}
usbredirparser_do_write(dev->parser);
p->status = USB_RET_ASYNC;
}","static void usbredir_handle_bulk_data(USBRedirDevice *VAR_0, USBPacket *VAR_1,
uint8_t VAR_2)
{
struct usb_redir_bulk_packet_header VAR_3;
size_t VAR_4 = usb_packet_size(VAR_1);
const int VAR_5 = VAR_0->endpoint[EP2I(VAR_2)].max_packet_size;
if (usbredir_already_in_flight(VAR_0, VAR_1->id)) {
VAR_1->status = VAR_6;
return;
}
if (VAR_0->endpoint[EP2I(VAR_2)].bulk_receiving_enabled) {
if (VAR_4 != 0 && (VAR_4 % VAR_5) == 0) {
usbredir_handle_buffered_bulk_in_data(VAR_0, VAR_1, VAR_2);
return;
}
WARNING(""bulk recv invalid size %zd ep %02x, disabling\n"", VAR_4, VAR_2);
assert(VAR_0->endpoint[EP2I(VAR_2)].pending_async_packet == NULL);
usbredir_stop_bulk_receiving(VAR_0, VAR_2);
VAR_0->endpoint[EP2I(VAR_2)].bulk_receiving_enabled = 0;
}
DPRINTF(""bulk-out ep %02X stream %u len %zd id %""VAR_7""\n"",
VAR_2, VAR_1->stream, VAR_4, VAR_1->id);
VAR_3.endpoint  = VAR_2;
VAR_3.length    = VAR_4;
VAR_3.stream_id = VAR_1->stream;
VAR_3.length_high = VAR_4 >> 16;
assert(VAR_3.length_high == 0 ||
usbredirparser_peer_has_cap(VAR_0->parser,
VAR_8));
if (VAR_2 & VAR_9 || VAR_4 == 0) {
usbredirparser_send_bulk_packet(VAR_0->parser, VAR_1->id,
&VAR_3, NULL, 0);
} else {
uint8_t VAR_10[VAR_4];
usb_packet_copy(VAR_1, VAR_10, VAR_4);
usbredir_log_data(VAR_0, ""bulk data out:"", VAR_10, VAR_4);
usbredirparser_send_bulk_packet(VAR_0->parser, VAR_1->id,
&VAR_3, VAR_10, VAR_4);
}
usbredirparser_do_write(VAR_0->parser);
VAR_1->status = VAR_6;
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/before/1.json,"static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,
                                      uint8_t ep)
{
    struct usb_redir_bulk_packet_header bulk_packet;
    size_t size = usb_packet_size(p);
    const int maxp = dev->endpoint[EP2I(ep)].max_packet_size;

    if (usbredir_already_in_flight(dev, p->id)) {
        p->status = USB_RET_ASYNC;
        return;
    }

    if (dev->endpoint[EP2I(ep)].bulk_receiving_enabled) {
        if (size != 0 && (size % maxp) == 0) {
            usbredir_handle_buffered_bulk_in_data(dev, p, ep);
            return;
        }
        WARNING(""bulk recv invalid size %zd ep %02x, disabling\n"", size, ep);
        assert(dev->endpoint[EP2I(ep)].pending_async_packet == NULL);
        usbredir_stop_bulk_receiving(dev, ep);
        dev->endpoint[EP2I(ep)].bulk_receiving_enabled = 0;
    }

    DPRINTF(""bulk-out ep %02X stream %u len %zd id %""PRIu64""\n"",
            ep, p->stream, size, p->id);

    bulk_packet.endpoint  = ep;
    bulk_packet.length    = size;
    bulk_packet.stream_id = p->stream;
    bulk_packet.length_high = size >> 16;
    assert(bulk_packet.length_high == 0 ||
           usbredirparser_peer_has_cap(dev->parser,
                                       usb_redir_cap_32bits_bulk_length));

    if (ep & USB_DIR_IN || size == 0) {
        usbredirparser_send_bulk_packet(dev->parser, p->id,
                                        &bulk_packet, NULL, 0);
    } else {
        g_autofree uint8_t *buf = g_malloc(size);
        usb_packet_copy(p, buf, size);
        usbredir_log_data(dev, ""bulk data out:"", buf, size);
        usbredirparser_send_bulk_packet(dev->parser, p->id,
                                        &bulk_packet, buf, size);
    }
    usbredirparser_do_write(dev->parser);
    p->status = USB_RET_ASYNC;
}","static void usbredir_handle_bulk_data(USBRedirDevice *VAR_0, USBPacket *VAR_1,
                                      uint8_t VAR_2)
{
    struct usb_redir_bulk_packet_header VAR_3;
    size_t VAR_4 = usb_packet_size(VAR_1);
    const int VAR_5 = VAR_0->endpoint[EP2I(VAR_2)].max_packet_size;

    if (usbredir_already_in_flight(VAR_0, VAR_1->id)) {
        VAR_1->status = VAR_6;
        return;
    }

    if (VAR_0->endpoint[EP2I(VAR_2)].bulk_receiving_enabled) {
        if (VAR_4 != 0 && (VAR_4 % VAR_5) == 0) {
            usbredir_handle_buffered_bulk_in_data(VAR_0, VAR_1, VAR_2);
            return;
        }
        WARNING(""bulk recv invalid size %zd ep %02x, disabling\n"", VAR_4, VAR_2);
        assert(VAR_0->endpoint[EP2I(VAR_2)].pending_async_packet == NULL);
        usbredir_stop_bulk_receiving(VAR_0, VAR_2);
        VAR_0->endpoint[EP2I(VAR_2)].bulk_receiving_enabled = 0;
    }

    DPRINTF(""bulk-out ep %02X stream %u len %zd id %""VAR_7""\n"",
            VAR_2, VAR_1->stream, VAR_4, VAR_1->id);

    VAR_3.endpoint  = VAR_2;
    VAR_3.length    = VAR_4;
    VAR_3.stream_id = VAR_1->stream;
    VAR_3.length_high = VAR_4 >> 16;
    assert(VAR_3.length_high == 0 ||
           usbredirparser_peer_has_cap(VAR_0->parser,
                                       VAR_8));

    if (VAR_2 & VAR_9 || VAR_4 == 0) {
        usbredirparser_send_bulk_packet(VAR_0->parser, VAR_1->id,
                                        &VAR_3, NULL, 0);
    } else {
        g_autofree uint8_t *VAR_10 = g_malloc(VAR_4);
        usb_packet_copy(VAR_1, VAR_10, VAR_4);
        usbredir_log_data(VAR_0, ""bulk data out:"", VAR_10, VAR_4);
        usbredirparser_send_bulk_packet(VAR_0->parser, VAR_1->id,
                                        &VAR_3, VAR_10, VAR_4);
    }
    usbredirparser_do_write(VAR_0->parser);
    VAR_1->status = VAR_6;
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -36,7 +36,7 @@
         usbredirparser_send_bulk_packet(dev->parser, p->id,
                                         &bulk_packet, NULL, 0);
     } else {
-        uint8_t buf[size];
+        g_autofree uint8_t *buf = g_malloc(size);
         usb_packet_copy(p, buf, size);
         usbredir_log_data(dev, ""bulk data out:"", buf, size);
         usbredirparser_send_bulk_packet(dev->parser, p->id,","{'deleted_lines': ['        uint8_t buf[size];'], 'added_lines': ['        g_autofree uint8_t *buf = g_malloc(size);']}",True,"A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",5.5,MEDIUM,1,valid,,5
CVE-2021-3527,['CWE-770'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu-project/qemu,"usb/redir: avoid dynamic stack allocation (CVE-2021-3527)

Use autofree heap allocation instead.

Fixes: 4f4321c11ff (""usb: use iovecs in USBPacket"")
Reviewed-by: Philippe Mathieu-Daud <philmd@redhat.com>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
Tested-by: Philippe Mathieu-Daud <philmd@redhat.com>
Message-Id: <20210503132915.2335822-3-kraxel@redhat.com>
",7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986,hw/usb/redirect.c,usbredir_handle_iso_data,"static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p,
uint8_t ep)
{
int status, len;
if (!dev->endpoint[EP2I(ep)].iso_started &&
!dev->endpoint[EP2I(ep)].iso_error) {
struct usb_redir_start_iso_stream_header start_iso = {
.endpoint = ep,
};
int pkts_per_sec;
if (dev->dev.speed == USB_SPEED_HIGH) {
pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval;
} else {
pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval;
}
dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000;
start_iso.pkts_per_urb = pkts_per_sec / 100;
if (start_iso.pkts_per_urb < 1) {
start_iso.pkts_per_urb = 1;
} else if (start_iso.pkts_per_urb > 32) {
start_iso.pkts_per_urb = 32;
}
start_iso.no_urbs = DIV_ROUND_UP(
dev->endpoint[EP2I(ep)].bufpq_target_size,
start_iso.pkts_per_urb);
if (!(ep & USB_DIR_IN)) {
start_iso.no_urbs *= 2;
}
if (start_iso.no_urbs > 16) {
start_iso.no_urbs = 16;
}
usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso);
usbredirparser_do_write(dev->parser);
DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"",
pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep);
dev->endpoint[EP2I(ep)].iso_started = 1;
dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;
dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;
}
if (ep & USB_DIR_IN) {
struct buf_packet *isop;
if (dev->endpoint[EP2I(ep)].iso_started &&
!dev->endpoint[EP2I(ep)].bufpq_prefilled) {
if (dev->endpoint[EP2I(ep)].bufpq_size <
dev->endpoint[EP2I(ep)].bufpq_target_size) {
return;
}
dev->endpoint[EP2I(ep)].bufpq_prefilled = 1;
}
isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq);
if (isop == NULL) {
DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"",
ep, dev->endpoint[EP2I(ep)].iso_error);
dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;
status = dev->endpoint[EP2I(ep)].iso_error;
dev->endpoint[EP2I(ep)].iso_error = 0;
p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS;
return;
}
DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", ep,
isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size);
status = isop->status;
len = isop->len;
if (len > p->iov.size) {
ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"",
ep, len, (int)p->iov.size);
len = p->iov.size;
status = usb_redir_babble;
}
usb_packet_copy(p, isop->data, len);
bufp_free(dev, isop, ep);
usbredir_handle_status(dev, p, status);
} else {
if (dev->endpoint[EP2I(ep)].iso_started) {
struct usb_redir_iso_packet_header iso_packet = {
.endpoint = ep,
.length = p->iov.size
};
uint8_t buf[p->iov.size];
usb_packet_copy(p, buf, p->iov.size);
usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,
buf, p->iov.size);
usbredirparser_do_write(dev->parser);
}
status = dev->endpoint[EP2I(ep)].iso_error;
dev->endpoint[EP2I(ep)].iso_error = 0;
DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", ep, status,
p->iov.size);
usbredir_handle_status(dev, p, status);
}
}","static void usbredir_handle_iso_data(USBRedirDevice *VAR_0, USBPacket *VAR_1,
uint8_t VAR_2)
{
int VAR_3, VAR_4;
if (!VAR_0->endpoint[EP2I(VAR_2)].iso_started &&
!VAR_0->endpoint[EP2I(VAR_2)].iso_error) {
struct usb_redir_start_iso_stream_header VAR_5 = {
.endpoint = VAR_2,
};
int VAR_6;
if (VAR_0->dev.speed == VAR_7) {
VAR_6 = 8000 / VAR_0->endpoint[EP2I(VAR_2)].interval;
} else {
VAR_6 = 1000 / VAR_0->endpoint[EP2I(VAR_2)].interval;
}
VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size = (VAR_6 * 60) / 1000;
VAR_5.pkts_per_urb = VAR_6 / 100;
if (VAR_5.pkts_per_urb < 1) {
VAR_5.pkts_per_urb = 1;
} else if (VAR_5.pkts_per_urb > 32) {
VAR_5.pkts_per_urb = 32;
}
VAR_5.no_urbs = DIV_ROUND_UP(
VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size,
VAR_5.pkts_per_urb);
if (!(VAR_2 & VAR_8)) {
VAR_5.no_urbs *= 2;
}
if (VAR_5.no_urbs > 16) {
VAR_5.no_urbs = 16;
}
usbredirparser_send_start_iso_stream(VAR_0->parser, 0, &VAR_5);
usbredirparser_do_write(VAR_0->parser);
DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"",
VAR_6, VAR_5.pkts_per_urb, VAR_5.no_urbs, VAR_2);
VAR_0->endpoint[EP2I(VAR_2)].iso_started = 1;
VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 0;
VAR_0->endpoint[EP2I(VAR_2)].bufpq_dropping_packets = 0;
}
if (VAR_2 & VAR_8) {
struct buf_packet *VAR_9;
if (VAR_0->endpoint[EP2I(VAR_2)].iso_started &&
!VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled) {
if (VAR_0->endpoint[EP2I(VAR_2)].bufpq_size <
VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size) {
return;
}
VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 1;
}
VAR_9 = QTAILQ_FIRST(&VAR_0->endpoint[EP2I(VAR_2)].bufpq);
if (VAR_9 == NULL) {
DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"",
VAR_2, VAR_0->endpoint[EP2I(VAR_2)].iso_error);
VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 0;
VAR_3 = VAR_0->endpoint[EP2I(VAR_2)].iso_error;
VAR_0->endpoint[EP2I(VAR_2)].iso_error = 0;
VAR_1->status = VAR_3 ? VAR_10 : VAR_11;
return;
}
DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", VAR_2,
VAR_9->status, VAR_9->len, VAR_0->endpoint[EP2I(VAR_2)].bufpq_size);
VAR_3 = VAR_9->status;
VAR_4 = VAR_9->len;
if (VAR_4 > VAR_1->iov.size) {
ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"",
VAR_2, VAR_4, (int)VAR_1->iov.size);
VAR_4 = VAR_1->iov.size;
VAR_3 = VAR_12;
}
usb_packet_copy(VAR_1, VAR_9->data, VAR_4);
bufp_free(VAR_0, VAR_9, VAR_2);
usbredir_handle_status(VAR_0, VAR_1, VAR_3);
} else {
if (VAR_0->endpoint[EP2I(VAR_2)].iso_started) {
struct usb_redir_iso_packet_header VAR_13 = {
.endpoint = VAR_2,
.length = VAR_1->iov.size
};
uint8_t VAR_14[VAR_1->iov.size];
usb_packet_copy(VAR_1, VAR_14, VAR_1->iov.size);
usbredirparser_send_iso_packet(VAR_0->parser, 0, &VAR_13,
VAR_14, VAR_1->iov.size);
usbredirparser_do_write(VAR_0->parser);
}
VAR_3 = VAR_0->endpoint[EP2I(VAR_2)].iso_error;
VAR_0->endpoint[EP2I(VAR_2)].iso_error = 0;
DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", VAR_2, VAR_3,
VAR_1->iov.size);
usbredir_handle_status(VAR_0, VAR_1, VAR_3);
}
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/before/2.json,"static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p,
                                     uint8_t ep)
{
    int status, len;
    if (!dev->endpoint[EP2I(ep)].iso_started &&
            !dev->endpoint[EP2I(ep)].iso_error) {
        struct usb_redir_start_iso_stream_header start_iso = {
            .endpoint = ep,
        };
        int pkts_per_sec;

        if (dev->dev.speed == USB_SPEED_HIGH) {
            pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval;
        } else {
            pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval;
        }
        /* Testing has shown that we need circa 60 ms buffer */
        dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000;

        /* Aim for approx 100 interrupts / second on the client to
           balance latency and interrupt load */
        start_iso.pkts_per_urb = pkts_per_sec / 100;
        if (start_iso.pkts_per_urb < 1) {
            start_iso.pkts_per_urb = 1;
        } else if (start_iso.pkts_per_urb > 32) {
            start_iso.pkts_per_urb = 32;
        }

        start_iso.no_urbs = DIV_ROUND_UP(
                                     dev->endpoint[EP2I(ep)].bufpq_target_size,
                                     start_iso.pkts_per_urb);
        /* Output endpoints pre-fill only 1/2 of the packets, keeping the rest
           as overflow buffer. Also see the usbredir protocol documentation */
        if (!(ep & USB_DIR_IN)) {
            start_iso.no_urbs *= 2;
        }
        if (start_iso.no_urbs > 16) {
            start_iso.no_urbs = 16;
        }

        /* No id, we look at the ep when receiving a status back */
        usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso);
        usbredirparser_do_write(dev->parser);
        DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"",
                pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep);
        dev->endpoint[EP2I(ep)].iso_started = 1;
        dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;
        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;
    }

    if (ep & USB_DIR_IN) {
        struct buf_packet *isop;

        if (dev->endpoint[EP2I(ep)].iso_started &&
                !dev->endpoint[EP2I(ep)].bufpq_prefilled) {
            if (dev->endpoint[EP2I(ep)].bufpq_size <
                    dev->endpoint[EP2I(ep)].bufpq_target_size) {
                return;
            }
            dev->endpoint[EP2I(ep)].bufpq_prefilled = 1;
        }

        isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq);
        if (isop == NULL) {
            DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"",
                    ep, dev->endpoint[EP2I(ep)].iso_error);
            /* Re-fill the buffer */
            dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;
            /* Check iso_error for stream errors, otherwise its an underrun */
            status = dev->endpoint[EP2I(ep)].iso_error;
            dev->endpoint[EP2I(ep)].iso_error = 0;
            p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS;
            return;
        }
        DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", ep,
                 isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size);

        status = isop->status;
        len = isop->len;
        if (len > p->iov.size) {
            ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"",
                  ep, len, (int)p->iov.size);
            len = p->iov.size;
            status = usb_redir_babble;
        }
        usb_packet_copy(p, isop->data, len);
        bufp_free(dev, isop, ep);
        usbredir_handle_status(dev, p, status);
    } else {
        /* If the stream was not started because of a pending error don't
           send the packet to the usb-host */
        if (dev->endpoint[EP2I(ep)].iso_started) {
            struct usb_redir_iso_packet_header iso_packet = {
                .endpoint = ep,
                .length = p->iov.size
            };
            g_autofree uint8_t *buf = g_malloc(p->iov.size);
            /* No id, we look at the ep when receiving a status back */
            usb_packet_copy(p, buf, p->iov.size);
            usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,
                                           buf, p->iov.size);
            usbredirparser_do_write(dev->parser);
        }
        status = dev->endpoint[EP2I(ep)].iso_error;
        dev->endpoint[EP2I(ep)].iso_error = 0;
        DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", ep, status,
                 p->iov.size);
        usbredir_handle_status(dev, p, status);
    }
}","static void usbredir_handle_iso_data(USBRedirDevice *VAR_0, USBPacket *VAR_1,
                                     uint8_t VAR_2)
{
    int VAR_3, VAR_4;
    if (!VAR_0->endpoint[EP2I(VAR_2)].iso_started &&
            !VAR_0->endpoint[EP2I(VAR_2)].iso_error) {
        struct usb_redir_start_iso_stream_header VAR_5 = {
            .endpoint = VAR_2,
        };
        int VAR_6;

        if (VAR_0->dev.speed == VAR_7) {
            VAR_6 = 8000 / VAR_0->endpoint[EP2I(VAR_2)].interval;
        } else {
            VAR_6 = 1000 / VAR_0->endpoint[EP2I(VAR_2)].interval;
        }
        /* COMMENT_0 */
        VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size = (VAR_6 * 60) / 1000;

        /* COMMENT_1 */
                                                
        VAR_5.pkts_per_urb = VAR_6 / 100;
        if (VAR_5.pkts_per_urb < 1) {
            VAR_5.pkts_per_urb = 1;
        } else if (VAR_5.pkts_per_urb > 32) {
            VAR_5.pkts_per_urb = 32;
        }

        VAR_5.no_urbs = DIV_ROUND_UP(
                                     VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size,
                                     VAR_5.pkts_per_urb);
        /* COMMENT_3 */
                                                                              
        if (!(VAR_2 & VAR_8)) {
            VAR_5.no_urbs *= 2;
        }
        if (VAR_5.no_urbs > 16) {
            VAR_5.no_urbs = 16;
        }

        /* COMMENT_5 */
        usbredirparser_send_start_iso_stream(VAR_0->parser, 0, &VAR_5);
        usbredirparser_do_write(VAR_0->parser);
        DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"",
                VAR_6, VAR_5.pkts_per_urb, VAR_5.no_urbs, VAR_2);
        VAR_0->endpoint[EP2I(VAR_2)].iso_started = 1;
        VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 0;
        VAR_0->endpoint[EP2I(VAR_2)].bufpq_dropping_packets = 0;
    }

    if (VAR_2 & VAR_8) {
        struct buf_packet *VAR_9;

        if (VAR_0->endpoint[EP2I(VAR_2)].iso_started &&
                !VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled) {
            if (VAR_0->endpoint[EP2I(VAR_2)].bufpq_size <
                    VAR_0->endpoint[EP2I(VAR_2)].bufpq_target_size) {
                return;
            }
            VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 1;
        }

        VAR_9 = QTAILQ_FIRST(&VAR_0->endpoint[EP2I(VAR_2)].bufpq);
        if (VAR_9 == NULL) {
            DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"",
                    VAR_2, VAR_0->endpoint[EP2I(VAR_2)].iso_error);
            /* COMMENT_6 */
            VAR_0->endpoint[EP2I(VAR_2)].bufpq_prefilled = 0;
            /* COMMENT_7 */
            VAR_3 = VAR_0->endpoint[EP2I(VAR_2)].iso_error;
            VAR_0->endpoint[EP2I(VAR_2)].iso_error = 0;
            VAR_1->status = VAR_3 ? VAR_10 : VAR_11;
            return;
        }
        DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", VAR_2,
                 VAR_9->status, VAR_9->len, VAR_0->endpoint[EP2I(VAR_2)].bufpq_size);

        VAR_3 = VAR_9->status;
        VAR_4 = VAR_9->len;
        if (VAR_4 > VAR_1->iov.size) {
            ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"",
                  VAR_2, VAR_4, (int)VAR_1->iov.size);
            VAR_4 = VAR_1->iov.size;
            VAR_3 = VAR_12;
        }
        usb_packet_copy(VAR_1, VAR_9->data, VAR_4);
        bufp_free(VAR_0, VAR_9, VAR_2);
        usbredir_handle_status(VAR_0, VAR_1, VAR_3);
    } else {
        /* COMMENT_8 */
                                             
        if (VAR_0->endpoint[EP2I(VAR_2)].iso_started) {
            struct usb_redir_iso_packet_header VAR_13 = {
                .endpoint = VAR_2,
                .length = VAR_1->iov.size
            };
            g_autofree uint8_t *VAR_14 = g_malloc(VAR_1->iov.size);
            /* COMMENT_5 */
            usb_packet_copy(VAR_1, VAR_14, VAR_1->iov.size);
            usbredirparser_send_iso_packet(VAR_0->parser, 0, &VAR_13,
                                           VAR_14, VAR_1->iov.size);
            usbredirparser_do_write(VAR_0->parser);
        }
        VAR_3 = VAR_0->endpoint[EP2I(VAR_2)].iso_error;
        VAR_0->endpoint[EP2I(VAR_2)].iso_error = 0;
        DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", VAR_2, VAR_3,
                 VAR_1->iov.size);
        usbredir_handle_status(VAR_0, VAR_1, VAR_3);
    }
}",qemu-project/qemu/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986/redirect.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -94,7 +94,7 @@
                 .endpoint = ep,
                 .length = p->iov.size
             };
-            uint8_t buf[p->iov.size];
+            g_autofree uint8_t *buf = g_malloc(p->iov.size);
             /* No id, we look at the ep when receiving a status back */
             usb_packet_copy(p, buf, p->iov.size);
             usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,","{'deleted_lines': ['            uint8_t buf[p->iov.size];'], 'added_lines': ['            g_autofree uint8_t *buf = g_malloc(p->iov.size);']}",True,"A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",5.5,MEDIUM,1,valid,,5
CVE-2021-3527,['CWE-770'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu-project/qemu,"usb: limit combined packets to 1 MiB (CVE-2021-3527)

usb-host and usb-redirect try to batch bulk transfers by combining many
small usb packets into a single, large transfer request, to reduce the
overhead and improve performance.

This patch adds a size limit of 1 MiB for those combined packets to
restrict the host resources the guest can bind that way.

Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
Message-Id: <20210503132915.2335822-6-kraxel@redhat.com>
",05a40b172e4d691371534828078be47e7fff524c,https://gitlab.com/qemu-project/qemu/-/commit/05a40b172e4d691371534828078be47e7fff524c,hw/usb/combined-packet.c,usb_ep_combine_input_packets,"void usb_ep_combine_input_packets(USBEndpoint *ep)
{
USBPacket *p, *u, *next, *prev = NULL, *first = NULL;
USBPort *port = ep->dev->port;
int totalsize;
assert(ep->pipeline);
assert(ep->pid == USB_TOKEN_IN);
QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {
if (ep->halted) {
p->status = USB_RET_REMOVE_FROM_QUEUE;
port->ops->complete(port, p);
continue;
}
if (p->state == USB_PACKET_ASYNC) {
prev = p;
continue;
}
usb_packet_check_state(p, USB_PACKET_QUEUED);
if (prev && prev->short_not_ok) {
break;
}
if (first) {
if (first->combined == NULL) {
USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);
combined->first = first;
QTAILQ_INIT(&combined->packets);
qemu_iovec_init(&combined->iov, 2);
usb_combined_packet_add(combined, first);
}
usb_combined_packet_add(first->combined, p);
} else {
first = p;
}
totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;
if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||
next == NULL ||
(totalsize == (16 * KiB - 36) && p->int_req)) {
usb_device_handle_data(ep->dev, first);
assert(first->status == USB_RET_ASYNC);
if (first->combined) {
QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {
usb_packet_set_state(u, USB_PACKET_ASYNC);
}
} else {
usb_packet_set_state(first, USB_PACKET_ASYNC);
}
first = NULL;
prev = p;
}
}
}","void usb_ep_combine_input_packets(USBEndpoint *VAR_0)
{
USBPacket *VAR_1, *VAR_2, *VAR_3, *VAR_4 = NULL, *VAR_5 = NULL;
USBPort *VAR_6 = VAR_0->dev->port;
int VAR_7;
assert(VAR_0->pipeline);
assert(VAR_0->pid == VAR_8);
QTAILQ_FOREACH_SAFE(VAR_1, &VAR_0->queue, VAR_9, VAR_3) {
if (VAR_0->halted) {
VAR_1->status = VAR_10;
VAR_6->ops->complete(VAR_6, VAR_1);
continue;
}
if (VAR_1->state == VAR_11) {
VAR_4 = VAR_1;
continue;
}
usb_packet_check_state(VAR_1, VAR_12);
if (VAR_4 && VAR_4->short_not_ok) {
break;
}
if (VAR_5) {
if (VAR_5->combined == NULL) {
USBCombinedPacket *VAR_13 = g_new0(USBCombinedPacket, 1);
VAR_13->first = VAR_5;
QTAILQ_INIT(&VAR_13->packets);
qemu_iovec_init(&VAR_13->iov, 2);
usb_combined_packet_add(VAR_13, VAR_5);
}
usb_combined_packet_add(VAR_5->combined, VAR_1);
} else {
VAR_5 = VAR_1;
}
VAR_7 = (VAR_1->combined) ? VAR_1->combined->iov.size : VAR_1->iov.size;
if ((VAR_1->iov.size % VAR_0->max_packet_size) != 0 || !VAR_1->short_not_ok ||
VAR_3 == NULL ||
(VAR_7 == (16 * VAR_14 - 36) && VAR_1->int_req)) {
usb_device_handle_data(VAR_0->dev, VAR_5);
assert(VAR_5->status == VAR_15);
if (VAR_5->combined) {
QTAILQ_FOREACH(VAR_2, &VAR_5->combined->packets, VAR_16) {
usb_packet_set_state(VAR_2, VAR_11);
}
} else {
usb_packet_set_state(VAR_5, VAR_11);
}
VAR_5 = NULL;
VAR_4 = VAR_1;
}
}
}",qemu-project/qemu/05a40b172e4d691371534828078be47e7fff524c/combined-packet.c/vul/before/0.json,"void usb_ep_combine_input_packets(USBEndpoint *ep)
{
    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;
    USBPort *port = ep->dev->port;
    int totalsize;

    assert(ep->pipeline);
    assert(ep->pid == USB_TOKEN_IN);

    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {
        /* Empty the queue on a halt */
        if (ep->halted) {
            p->status = USB_RET_REMOVE_FROM_QUEUE;
            port->ops->complete(port, p);
            continue;
        }

        /* Skip packets already submitted to the device */
        if (p->state == USB_PACKET_ASYNC) {
            prev = p;
            continue;
        }
        usb_packet_check_state(p, USB_PACKET_QUEUED);

        /*
         * If the previous (combined) packet has the short_not_ok flag set
         * stop, as we must not submit packets to the device after a transfer
         * ending with short_not_ok packet.
         */
        if (prev && prev->short_not_ok) {
            break;
        }

        if (first) {
            if (first->combined == NULL) {
                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);

                combined->first = first;
                QTAILQ_INIT(&combined->packets);
                qemu_iovec_init(&combined->iov, 2);
                usb_combined_packet_add(combined, first);
            }
            usb_combined_packet_add(first->combined, p);
        } else {
            first = p;
        }

        /* Is this packet the last one of a (combined) transfer? */
        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;
        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||
                next == NULL ||
                /* Work around for Linux usbfs bulk splitting + migration */
                (totalsize == (16 * KiB - 36) && p->int_req) ||
                /* Next package may grow combined package over 1MiB */
                totalsize > 1 * MiB - ep->max_packet_size) {
            usb_device_handle_data(ep->dev, first);
            assert(first->status == USB_RET_ASYNC);
            if (first->combined) {
                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {
                    usb_packet_set_state(u, USB_PACKET_ASYNC);
                }
            } else {
                usb_packet_set_state(first, USB_PACKET_ASYNC);
            }
            first = NULL;
            prev = p;
        }
    }
}","void usb_ep_combine_input_packets(USBEndpoint *VAR_0)
{
    USBPacket *VAR_1, *VAR_2, *VAR_3, *VAR_4 = NULL, *VAR_5 = NULL;
    USBPort *VAR_6 = VAR_0->dev->port;
    int VAR_7;

    assert(VAR_0->pipeline);
    assert(VAR_0->pid == VAR_8);

    QTAILQ_FOREACH_SAFE(VAR_1, &VAR_0->queue, VAR_9, VAR_3) {
        /* COMMENT_0 */
        if (VAR_0->halted) {
            VAR_1->status = VAR_10;
            VAR_6->ops->complete(VAR_6, VAR_1);
            continue;
        }

        /* COMMENT_1 */
        if (VAR_1->state == VAR_11) {
            VAR_4 = VAR_1;
            continue;
        }
        usb_packet_check_state(VAR_1, VAR_12);

        /* COMMENT_2 */
                                                                          
                                                                             
                                           
           
        if (VAR_4 && VAR_4->short_not_ok) {
            break;
        }

        if (VAR_5) {
            if (VAR_5->combined == NULL) {
                USBCombinedPacket *VAR_13 = g_new0(USBCombinedPacket, 1);

                VAR_13->first = VAR_5;
                QTAILQ_INIT(&VAR_13->packets);
                qemu_iovec_init(&VAR_13->iov, 2);
                usb_combined_packet_add(VAR_13, VAR_5);
            }
            usb_combined_packet_add(VAR_5->combined, VAR_1);
        } else {
            VAR_5 = VAR_1;
        }

        /* COMMENT_7 */
        VAR_7 = (VAR_1->combined) ? VAR_1->combined->iov.size : VAR_1->iov.size;
        if ((VAR_1->iov.size % VAR_0->max_packet_size) != 0 || !VAR_1->short_not_ok ||
                VAR_3 == NULL ||
                /* COMMENT_8 */
                (VAR_7 == (16 * VAR_14 - 36) && VAR_1->int_req) ||
                /* COMMENT_9 */
                VAR_7 > 1 * VAR_15 - VAR_0->max_packet_size) {
            usb_device_handle_data(VAR_0->dev, VAR_5);
            assert(VAR_5->status == VAR_16);
            if (VAR_5->combined) {
                QTAILQ_FOREACH(VAR_2, &VAR_5->combined->packets, VAR_17) {
                    usb_packet_set_state(VAR_2, VAR_11);
                }
            } else {
                usb_packet_set_state(VAR_5, VAR_11);
            }
            VAR_5 = NULL;
            VAR_4 = VAR_1;
        }
    }
}",qemu-project/qemu/05a40b172e4d691371534828078be47e7fff524c/combined-packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,7 +50,9 @@
         if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||
                 next == NULL ||
                 /* Work around for Linux usbfs bulk splitting + migration */
-                (totalsize == (16 * KiB - 36) && p->int_req)) {
+                (totalsize == (16 * KiB - 36) && p->int_req) ||
+                /* Next package may grow combined package over 1MiB */
+                totalsize > 1 * MiB - ep->max_packet_size) {
             usb_device_handle_data(ep->dev, first);
             assert(first->status == USB_RET_ASYNC);
             if (first->combined) {","{'deleted_lines': ['                (totalsize == (16 * KiB - 36) && p->int_req)) {'], 'added_lines': ['                (totalsize == (16 * KiB - 36) && p->int_req) ||', '                /* Next package may grow combined package over 1MiB */', '                totalsize > 1 * MiB - ep->max_packet_size) {']}",True,"A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",5.5,MEDIUM,1,valid,,5
CVE-2018-25015,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"After commit cea0cc80a677 (""sctp: use the right sk after waking up from
wait_buf sleep""), it may change to lock another sk if the asoc has been
peeled off in sctp_wait_for_sndbuf.

However, the asoc's new sk could be already closed elsewhere, as it's in
the sendmsg context of the old sk that can't avoid the new sk's closing.
If the sk's last one refcnt is held by this asoc, later on after putting
this asoc, the new sk will be freed, while under it's own lock.

This patch is to revert that commit, but fix the old issue by returning
error under the old sk's lock.

Fixes: cea0cc80a677 (""sctp: use the right sk after waking up from wait_buf sleep"")
Reported-by: syzbot+ac6ea7baa4432811eb50@syzkaller.appspotmail.com
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",a0ff660058b88d12625a783ce9e5c1371c87951f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a0ff660058b88d12625a783ce9e5c1371c87951f,net/sctp/socket.c,sctp_wait_for_sndbuf,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
size_t msg_len, struct sock **orig_sk)
{
struct sock *sk = asoc->base.sk;
int err = 0;
long current_timeo = *timeo_p;
DEFINE_WAIT(wait);
pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
*timeo_p, msg_len);
sctp_association_hold(asoc);
for (;;) {
prepare_to_wait_exclusive(&asoc->wait, &wait,
TASK_INTERRUPTIBLE);
if (asoc->base.dead)
goto do_dead;
if (!*timeo_p)
goto do_nonblock;
if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING)
goto do_error;
if (signal_pending(current))
goto do_interrupted;
if (msg_len <= sctp_wspace(asoc))
break;
release_sock(sk);
current_timeo = schedule_timeout(current_timeo);
lock_sock(sk);
if (sk != asoc->base.sk) {
release_sock(sk);
sk = asoc->base.sk;
lock_sock(sk);
}
*timeo_p = current_timeo;
}
out:
*orig_sk = sk;
finish_wait(&asoc->wait, &wait);
sctp_association_put(asoc);
return err;
do_dead:
err = -ESRCH;
goto out;
do_error:
err = -EPIPE;
goto out;
do_interrupted:
err = sock_intr_errno(*timeo_p);
goto out;
do_nonblock:
err = -EAGAIN;
goto out;
}","static int sctp_wait_for_sndbuf(struct sctp_association *VAR_0, long *VAR_1,
size_t VAR_2, struct sock **VAR_3)
{
struct sock *VAR_4 = VAR_0->base.sk;
int VAR_5 = 0;
long VAR_6 = *VAR_1;
DEFINE_WAIT(VAR_7);
pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", VAR_8, VAR_0,
*VAR_1, VAR_2);
sctp_association_hold(VAR_0);
for (;;) {
prepare_to_wait_exclusive(&VAR_0->wait, &VAR_7,
VAR_9);
if (VAR_0->base.dead)
goto do_dead;
if (!*VAR_1)
goto do_nonblock;
if (VAR_4->sk_err || VAR_0->state >= VAR_10)
goto do_error;
if (signal_pending(VAR_11))
goto do_interrupted;
if (VAR_2 <= sctp_wspace(VAR_0))
break;
release_sock(VAR_4);
VAR_6 = schedule_timeout(VAR_6);
lock_sock(VAR_4);
if (VAR_4 != VAR_0->base.sk) {
release_sock(VAR_4);
VAR_4 = VAR_0->base.sk;
lock_sock(VAR_4);
}
*VAR_1 = VAR_6;
}
out:
*VAR_3 = VAR_4;
finish_wait(&VAR_0->wait, &VAR_7);
sctp_association_put(VAR_0);
return VAR_5;
do_dead:
VAR_5 = -VAR_12;
goto out;
do_error:
VAR_5 = -VAR_13;
goto out;
do_interrupted:
VAR_5 = sock_intr_errno(*VAR_1);
goto out;
do_nonblock:
VAR_5 = -VAR_14;
goto out;
}",torvalds/linux/a0ff660058b88d12625a783ce9e5c1371c87951f/socket.c/vul/before/0.json,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);
	int err = 0;

	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);

	/* Increment the association's refcnt.  */
	sctp_association_hold(asoc);

	/* Wait on the association specific sndbuf space. */
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (asoc->base.dead)
			goto do_dead;
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;

		/* Let another process have a go.  Since we are going
		 * to sleep anyway.
		 */
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		lock_sock(sk);
		if (sk != asoc->base.sk)
			goto do_error;

		*timeo_p = current_timeo;
	}

out:
	finish_wait(&asoc->wait, &wait);

	/* Release the association's refcnt.  */
	sctp_association_put(asoc);

	return err;

do_dead:
	err = -ESRCH;
	goto out;

do_error:
	err = -EPIPE;
	goto out;

do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;

do_nonblock:
	err = -EAGAIN;
	goto out;
}","static int sctp_wait_for_sndbuf(struct sctp_association *VAR_0, long *VAR_1,
				size_t VAR_2)
{
	struct sock *VAR_3 = VAR_0->base.sk;
	long VAR_4 = *VAR_1;
	DEFINE_WAIT(VAR_5);
	int VAR_6 = 0;

	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", VAR_7, VAR_0,
		 *VAR_1, VAR_2);

	/* COMMENT_0 */
	sctp_association_hold(VAR_0);

	/* COMMENT_1 */
	for (;;) {
		prepare_to_wait_exclusive(&VAR_0->wait, &VAR_5,
					  VAR_8);
		if (VAR_0->base.dead)
			goto do_dead;
		if (!*VAR_1)
			goto do_nonblock;
		if (VAR_3->sk_err || VAR_0->state >= VAR_9)
			goto do_error;
		if (signal_pending(VAR_10))
			goto do_interrupted;
		if (VAR_2 <= sctp_wspace(VAR_0))
			break;

		/* COMMENT_2 */
                     
     
		release_sock(VAR_3);
		VAR_4 = schedule_timeout(VAR_4);
		lock_sock(VAR_3);
		if (VAR_3 != VAR_0->base.sk)
			goto do_error;

		*VAR_1 = VAR_4;
	}

out:
	finish_wait(&VAR_0->wait, &VAR_5);

	/* COMMENT_5 */
	sctp_association_put(VAR_0);

	return VAR_6;

do_dead:
	VAR_6 = -VAR_11;
	goto out;

do_error:
	VAR_6 = -VAR_12;
	goto out;

do_interrupted:
	VAR_6 = sock_intr_errno(*VAR_1);
	goto out;

do_nonblock:
	VAR_6 = -VAR_13;
	goto out;
}",torvalds/linux/a0ff660058b88d12625a783ce9e5c1371c87951f/socket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,10 @@
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
-				size_t msg_len, struct sock **orig_sk)
+				size_t msg_len)
 {
 	struct sock *sk = asoc->base.sk;
-	int err = 0;
 	long current_timeo = *timeo_p;
 	DEFINE_WAIT(wait);
+	int err = 0;
 
 	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
 		 *timeo_p, msg_len);
@@ -33,17 +33,13 @@
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
-		if (sk != asoc->base.sk) {
-			release_sock(sk);
-			sk = asoc->base.sk;
-			lock_sock(sk);
-		}
+		if (sk != asoc->base.sk)
+			goto do_error;
 
 		*timeo_p = current_timeo;
 	}
 
 out:
-	*orig_sk = sk;
 	finish_wait(&asoc->wait, &wait);
 
 	/* Release the association's refcnt.  */","{'deleted_lines': ['\t\t\t\tsize_t msg_len, struct sock **orig_sk)', '\tint err = 0;', '\t\tif (sk != asoc->base.sk) {', '\t\t\trelease_sock(sk);', '\t\t\tsk = asoc->base.sk;', '\t\t\tlock_sock(sk);', '\t\t}', '\t*orig_sk = sk;'], 'added_lines': ['\t\t\t\tsize_t msg_len)', '\tint err = 0;', '\t\tif (sk != asoc->base.sk)', '\t\t\tgoto do_error;']}",True,"An issue was discovered in the Linux kernel before 4.14.16. There is a use-after-free in net/sctp/socket.c for a held lock after a peel off, aka CID-a0ff660058b8.",7.8,HIGH,2,valid,,5
CVE-2018-25015,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"After commit cea0cc80a677 (""sctp: use the right sk after waking up from
wait_buf sleep""), it may change to lock another sk if the asoc has been
peeled off in sctp_wait_for_sndbuf.

However, the asoc's new sk could be already closed elsewhere, as it's in
the sendmsg context of the old sk that can't avoid the new sk's closing.
If the sk's last one refcnt is held by this asoc, later on after putting
this asoc, the new sk will be freed, while under it's own lock.

This patch is to revert that commit, but fix the old issue by returning
error under the old sk's lock.

Fixes: cea0cc80a677 (""sctp: use the right sk after waking up from wait_buf sleep"")
Reported-by: syzbot+ac6ea7baa4432811eb50@syzkaller.appspotmail.com
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",a0ff660058b88d12625a783ce9e5c1371c87951f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a0ff660058b88d12625a783ce9e5c1371c87951f,net/sctp/socket.c,sctp_sendmsg,"static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)
{
struct net *net = sock_net(sk);
struct sctp_sock *sp;
struct sctp_endpoint *ep;
struct sctp_association *new_asoc = NULL, *asoc = NULL;
struct sctp_transport *transport, *chunk_tp;
struct sctp_chunk *chunk;
union sctp_addr to;
struct sockaddr *msg_name = NULL;
struct sctp_sndrcvinfo default_sinfo;
struct sctp_sndrcvinfo *sinfo;
struct sctp_initmsg *sinit;
sctp_assoc_t associd = 0;
struct sctp_cmsgs cmsgs = { NULL };
enum sctp_scope scope;
bool fill_sinfo_ttl = false, wait_connect = false;
struct sctp_datamsg *datamsg;
int msg_flags = msg->msg_flags;
__u16 sinfo_flags = 0;
long timeo;
int err;
err = 0;
sp = sctp_sk(sk);
ep = sp->ep;
pr_debug(""%s: sk:%p, msg:%p, msg_len:%zu ep:%p\n"", __func__, sk,
msg, msg_len, ep);
if (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)) {
err = -EPIPE;
goto out_nounlock;
}
err = sctp_msghdr_parse(msg, &cmsgs);
if (err) {
pr_debug(""%s: msghdr parse err:%x\n"", __func__, err);
goto out_nounlock;
}
if (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {
int msg_namelen = msg->msg_namelen;
err = sctp_verify_addr(sk, (union sctp_addr *)msg->msg_name,
msg_namelen);
if (err)
return err;
if (msg_namelen > sizeof(to))
msg_namelen = sizeof(to);
memcpy(&to, msg->msg_name, msg_namelen);
msg_name = msg->msg_name;
}
sinit = cmsgs.init;
if (cmsgs.sinfo != NULL) {
memset(&default_sinfo, 0, sizeof(default_sinfo));
default_sinfo.sinfo_stream = cmsgs.sinfo->snd_sid;
default_sinfo.sinfo_flags = cmsgs.sinfo->snd_flags;
default_sinfo.sinfo_ppid = cmsgs.sinfo->snd_ppid;
default_sinfo.sinfo_context = cmsgs.sinfo->snd_context;
default_sinfo.sinfo_assoc_id = cmsgs.sinfo->snd_assoc_id;
sinfo = &default_sinfo;
fill_sinfo_ttl = true;
} else {
sinfo = cmsgs.srinfo;
}
if (sinfo) {
sinfo_flags = sinfo->sinfo_flags;
associd = sinfo->sinfo_assoc_id;
}
pr_debug(""%s: msg_len:%zu, sinfo_flags:0x%x\n"", __func__,
msg_len, sinfo_flags);
if (sctp_style(sk, TCP) && (sinfo_flags & (SCTP_EOF | SCTP_ABORT))) {
err = -EINVAL;
goto out_nounlock;
}
if (((sinfo_flags & SCTP_EOF) && (msg_len > 0)) ||
(!(sinfo_flags & (SCTP_EOF|SCTP_ABORT)) && (msg_len == 0))) {
err = -EINVAL;
goto out_nounlock;
}
if ((sinfo_flags & SCTP_ADDR_OVER) && (!msg->msg_name)) {
err = -EINVAL;
goto out_nounlock;
}
transport = NULL;
pr_debug(""%s: about to look up association\n"", __func__);
lock_sock(sk);
if (msg_name) {
asoc = sctp_endpoint_lookup_assoc(ep, &to, &transport);
if (!asoc &&
((sctp_style(sk, TCP) &&
(sctp_sstate(sk, ESTABLISHED) ||
sctp_sstate(sk, CLOSING))) ||
sctp_endpoint_is_peeled_off(ep, &to))) {
err = -EADDRNOTAVAIL;
goto out_unlock;
}
} else {
asoc = sctp_id2assoc(sk, associd);
if (!asoc) {
err = -EPIPE;
goto out_unlock;
}
}
if (asoc) {
pr_debug(""%s: just looked up association:%p\n"", __func__, asoc);
if (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP)) {
err = -EPIPE;
goto out_unlock;
}
if (sinfo_flags & SCTP_EOF) {
pr_debug(""%s: shutting down association:%p\n"",
__func__, asoc);
sctp_primitive_SHUTDOWN(net, asoc, NULL);
err = 0;
goto out_unlock;
}
if (sinfo_flags & SCTP_ABORT) {
chunk = sctp_make_abort_user(asoc, msg, msg_len);
if (!chunk) {
err = -ENOMEM;
goto out_unlock;
}
pr_debug(""%s: aborting association:%p\n"",
__func__, asoc);
sctp_primitive_ABORT(net, asoc, chunk);
err = 0;
goto out_unlock;
}
}
if (!asoc) {
pr_debug(""%s: there is no association yet\n"", __func__);
if (sinfo_flags & (SCTP_EOF | SCTP_ABORT)) {
err = -EINVAL;
goto out_unlock;
}
if (sinfo) {
if (!sinit || !sinit->sinit_num_ostreams) {
if (sinfo->sinfo_stream >=
sp->initmsg.sinit_num_ostreams) {
err = -EINVAL;
goto out_unlock;
}
} else {
if (sinfo->sinfo_stream >=
sinit->sinit_num_ostreams) {
err = -EINVAL;
goto out_unlock;
}
}
}
if (!ep->base.bind_addr.port) {
if (sctp_autobind(sk)) {
err = -EAGAIN;
goto out_unlock;
}
} else {
if (ep->base.bind_addr.port < inet_prot_sock(net) &&
!ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {
err = -EACCES;
goto out_unlock;
}
}
scope = sctp_scope(&to);
new_asoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);
if (!new_asoc) {
err = -ENOMEM;
goto out_unlock;
}
asoc = new_asoc;
err = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);
if (err < 0) {
err = -ENOMEM;
goto out_free;
}
if (sinit) {
if (sinit->sinit_num_ostreams) {
__u16 outcnt = sinit->sinit_num_ostreams;
asoc->c.sinit_num_ostreams = outcnt;
err = sctp_stream_init(&asoc->stream, outcnt, 0,
GFP_KERNEL);
if (err)
goto out_free;
}
if (sinit->sinit_max_instreams) {
asoc->c.sinit_max_instreams =
sinit->sinit_max_instreams;
}
if (sinit->sinit_max_attempts) {
asoc->max_init_attempts
= sinit->sinit_max_attempts;
}
if (sinit->sinit_max_init_timeo) {
asoc->max_init_timeo =
msecs_to_jiffies(sinit->sinit_max_init_timeo);
}
}
transport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL, SCTP_UNKNOWN);
if (!transport) {
err = -ENOMEM;
goto out_free;
}
}
pr_debug(""%s: we have a valid association\n"", __func__);
if (!sinfo) {
memset(&default_sinfo, 0, sizeof(default_sinfo));
default_sinfo.sinfo_stream = asoc->default_stream;
default_sinfo.sinfo_flags = asoc->default_flags;
default_sinfo.sinfo_ppid = asoc->default_ppid;
default_sinfo.sinfo_context = asoc->default_context;
default_sinfo.sinfo_timetolive = asoc->default_timetolive;
default_sinfo.sinfo_assoc_id = sctp_assoc2id(asoc);
sinfo = &default_sinfo;
} else if (fill_sinfo_ttl) {
sinfo->sinfo_timetolive = asoc->default_timetolive;
}
if (msg_len > sk->sk_sndbuf) {
err = -EMSGSIZE;
goto out_free;
}
if (asoc->pmtu_pending)
sctp_assoc_pending_pmtu(asoc);
if (sctp_sk(sk)->disable_fragments && (msg_len > asoc->frag_point)) {
err = -EMSGSIZE;
goto out_free;
}
if (sinfo->sinfo_stream >= asoc->stream.outcnt) {
err = -EINVAL;
goto out_free;
}
if (unlikely(!asoc->stream.out[sinfo->sinfo_stream].ext)) {
err = sctp_stream_init_ext(&asoc->stream, sinfo->sinfo_stream);
if (err)
goto out_free;
}
if (sctp_wspace(asoc) < msg_len)
sctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));
timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);
if (!sctp_wspace(asoc)) {
err = sctp_wait_for_sndbuf(asoc, &timeo, msg_len, &sk);
if (err) {
if (err == -ESRCH) {
new_asoc = NULL;
err = -EPIPE;
}
goto out_free;
}
}
if ((sctp_style(sk, TCP) && msg_name) ||
(sinfo_flags & SCTP_ADDR_OVER)) {
chunk_tp = sctp_assoc_lookup_paddr(asoc, &to);
if (!chunk_tp) {
err = -EINVAL;
goto out_free;
}
} else
chunk_tp = NULL;
if (sctp_state(asoc, CLOSED)) {
err = sctp_primitive_ASSOCIATE(net, asoc, NULL);
if (err < 0)
goto out_free;
wait_connect = true;
pr_debug(""%s: we associated primitively\n"", __func__);
}
datamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);
if (IS_ERR(datamsg)) {
err = PTR_ERR(datamsg);
goto out_free;
}
asoc->force_delay = !!(msg->msg_flags & MSG_MORE);
list_for_each_entry(chunk, &datamsg->chunks, frag_list) {
sctp_chunk_hold(chunk);
sctp_set_owner_w(chunk);
chunk->transport = chunk_tp;
}
err = sctp_primitive_SEND(net, asoc, datamsg);
if (err) {
sctp_datamsg_free(datamsg);
goto out_free;
}
pr_debug(""%s: we sent primitively\n"", __func__);
sctp_datamsg_put(datamsg);
err = msg_len;
if (unlikely(wait_connect)) {
timeo = sock_sndtimeo(sk, msg_flags & MSG_DONTWAIT);
sctp_wait_for_connect(asoc, &timeo);
}
goto out_unlock;
out_free:
if (new_asoc)
sctp_association_free(asoc);
out_unlock:
release_sock(sk);
out_nounlock:
return sctp_error(sk, msg_flags, err);
#if 0
do_sock_err:
if (msg_len)
err = msg_len;
else
err = sock_error(sk);
goto out;
do_interrupted:
if (msg_len)
err = msg_len;
goto out;
#endif 
}","static int sctp_sendmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
struct net *net = sock_net(VAR_0);
struct sctp_sock *VAR_3;
struct sctp_endpoint *VAR_4;
struct sctp_association *VAR_5 = NULL, *VAR_6 = NULL;
struct sctp_transport *VAR_7, *VAR_8;
struct sctp_chunk *VAR_9;
union sctp_addr VAR_10;
struct sockaddr *VAR_11 = NULL;
struct sctp_sndrcvinfo VAR_12;
struct sctp_sndrcvinfo *VAR_13;
struct sctp_initmsg *VAR_14;
sctp_assoc_t VAR_15 = 0;
struct sctp_cmsgs VAR_16 = { NULL };
enum sctp_scope VAR_17;
bool VAR_18 = false, VAR_19 = false;
struct sctp_datamsg *VAR_20;
int VAR_21 = VAR_1->msg_flags;
__u16 VAR_22 = 0;
long VAR_23;
int VAR_24;
VAR_24 = 0;
VAR_3 = sctp_sk(VAR_0);
VAR_4 = VAR_3->ep;
pr_debug(""%s: sk:%p, msg:%p, msg_len:%zu ep:%p\n"", VAR_25, VAR_0,
VAR_1, VAR_2, VAR_4);
if (sctp_style(VAR_0, VAR_26) && sctp_sstate(VAR_0, VAR_27)) {
VAR_24 = -VAR_28;
goto out_nounlock;
}
VAR_24 = sctp_msghdr_parse(VAR_1, &VAR_16);
if (VAR_24) {
pr_debug(""%s: msghdr parse err:%x\n"", VAR_25, VAR_24);
goto out_nounlock;
}
if (!sctp_style(VAR_0, VAR_29) && VAR_1->msg_name) {
int VAR_30 = VAR_1->msg_namelen;
VAR_24 = sctp_verify_addr(VAR_0, (union sctp_addr *)VAR_1->msg_name,
VAR_30);
if (VAR_24)
return VAR_24;
if (VAR_30 > sizeof(VAR_10))
VAR_30 = sizeof(VAR_10);
memcpy(&VAR_10, VAR_1->msg_name, VAR_30);
VAR_11 = VAR_1->msg_name;
}
VAR_14 = VAR_16.init;
if (VAR_16.sinfo != NULL) {
memset(&VAR_12, 0, sizeof(VAR_12));
VAR_12.sinfo_stream = VAR_16.sinfo->snd_sid;
VAR_12.sinfo_flags = VAR_16.sinfo->snd_flags;
VAR_12.sinfo_ppid = VAR_16.sinfo->snd_ppid;
VAR_12.sinfo_context = VAR_16.sinfo->snd_context;
VAR_12.sinfo_assoc_id = VAR_16.sinfo->snd_assoc_id;
VAR_13 = &VAR_12;
VAR_18 = true;
} else {
VAR_13 = VAR_16.srinfo;
}
if (VAR_13) {
VAR_22 = VAR_13->sinfo_flags;
VAR_15 = VAR_13->sinfo_assoc_id;
}
pr_debug(""%s: msg_len:%zu, sinfo_flags:0x%x\n"", VAR_25,
VAR_2, VAR_22);
if (sctp_style(VAR_0, VAR_26) && (VAR_22 & (VAR_31 | VAR_32))) {
VAR_24 = -VAR_33;
goto out_nounlock;
}
if (((VAR_22 & VAR_31) && (VAR_2 > 0)) ||
(!(VAR_22 & (VAR_31|VAR_32)) && (VAR_2 == 0))) {
VAR_24 = -VAR_33;
goto out_nounlock;
}
if ((VAR_22 & VAR_34) && (!VAR_1->msg_name)) {
VAR_24 = -VAR_33;
goto out_nounlock;
}
VAR_7 = NULL;
pr_debug(""%s: about to look up association\n"", VAR_25);
lock_sock(VAR_0);
if (VAR_11) {
VAR_6 = sctp_endpoint_lookup_assoc(VAR_4, &VAR_10, &VAR_7);
if (!VAR_6 &&
((sctp_style(VAR_0, VAR_26) &&
(sctp_sstate(VAR_0, VAR_35) ||
sctp_sstate(VAR_0, VAR_36))) ||
sctp_endpoint_is_peeled_off(VAR_4, &VAR_10))) {
VAR_24 = -VAR_37;
goto out_unlock;
}
} else {
VAR_6 = sctp_id2assoc(VAR_0, VAR_15);
if (!VAR_6) {
VAR_24 = -VAR_28;
goto out_unlock;
}
}
if (VAR_6) {
pr_debug(""%s: just looked up association:%p\n"", VAR_25, VAR_6);
if (sctp_state(VAR_6, VAR_38) && sctp_style(VAR_0, VAR_26)) {
VAR_24 = -VAR_28;
goto out_unlock;
}
if (VAR_22 & VAR_31) {
pr_debug(""%s: shutting down association:%p\n"",
VAR_25, VAR_6);
sctp_primitive_SHUTDOWN(net, VAR_6, NULL);
VAR_24 = 0;
goto out_unlock;
}
if (VAR_22 & VAR_32) {
VAR_9 = sctp_make_abort_user(VAR_6, VAR_1, VAR_2);
if (!VAR_9) {
VAR_24 = -VAR_39;
goto out_unlock;
}
pr_debug(""%s: aborting association:%p\n"",
VAR_25, VAR_6);
sctp_primitive_ABORT(net, VAR_6, VAR_9);
VAR_24 = 0;
goto out_unlock;
}
}
if (!VAR_6) {
pr_debug(""%s: there is no association yet\n"", VAR_25);
if (VAR_22 & (VAR_31 | VAR_32)) {
VAR_24 = -VAR_33;
goto out_unlock;
}
if (VAR_13) {
if (!VAR_14 || !VAR_14->sinit_num_ostreams) {
if (VAR_13->sinfo_stream >=
VAR_3->initmsg.sinit_num_ostreams) {
VAR_24 = -VAR_33;
goto out_unlock;
}
} else {
if (VAR_13->sinfo_stream >=
VAR_14->sinit_num_ostreams) {
VAR_24 = -VAR_33;
goto out_unlock;
}
}
}
if (!VAR_4->base.bind_addr.port) {
if (sctp_autobind(VAR_0)) {
VAR_24 = -VAR_40;
goto out_unlock;
}
} else {
if (VAR_4->base.bind_addr.port < inet_prot_sock(net) &&
!ns_capable(net->user_ns, VAR_41)) {
VAR_24 = -VAR_42;
goto out_unlock;
}
}
VAR_17 = sctp_scope(&VAR_10);
VAR_5 = sctp_association_new(VAR_4, VAR_0, VAR_17, VAR_43);
if (!VAR_5) {
VAR_24 = -VAR_39;
goto out_unlock;
}
VAR_6 = VAR_5;
VAR_24 = sctp_assoc_set_bind_addr_from_ep(VAR_6, VAR_17, VAR_43);
if (VAR_24 < 0) {
VAR_24 = -VAR_39;
goto out_free;
}
if (VAR_14) {
if (VAR_14->sinit_num_ostreams) {
__u16 VAR_44 = VAR_14->sinit_num_ostreams;
VAR_6->c.sinit_num_ostreams = VAR_44;
VAR_24 = sctp_stream_init(&VAR_6->stream, VAR_44, 0,
VAR_43);
if (VAR_24)
goto out_free;
}
if (VAR_14->sinit_max_instreams) {
VAR_6->c.sinit_max_instreams =
VAR_14->sinit_max_instreams;
}
if (VAR_14->sinit_max_attempts) {
VAR_6->max_init_attempts
= VAR_14->sinit_max_attempts;
}
if (VAR_14->sinit_max_init_timeo) {
VAR_6->max_init_timeo =
msecs_to_jiffies(VAR_14->sinit_max_init_timeo);
}
}
VAR_7 = sctp_assoc_add_peer(VAR_6, &VAR_10, VAR_43, VAR_45);
if (!VAR_7) {
VAR_24 = -VAR_39;
goto out_free;
}
}
pr_debug(""%s: we have a valid association\n"", VAR_25);
if (!VAR_13) {
memset(&VAR_12, 0, sizeof(VAR_12));
VAR_12.sinfo_stream = VAR_6->default_stream;
VAR_12.sinfo_flags = VAR_6->default_flags;
VAR_12.sinfo_ppid = VAR_6->default_ppid;
VAR_12.sinfo_context = VAR_6->default_context;
VAR_12.sinfo_timetolive = VAR_6->default_timetolive;
VAR_12.sinfo_assoc_id = sctp_assoc2id(VAR_6);
VAR_13 = &VAR_12;
} else if (VAR_18) {
VAR_13->sinfo_timetolive = VAR_6->default_timetolive;
}
if (VAR_2 > VAR_0->sk_sndbuf) {
VAR_24 = -VAR_46;
goto out_free;
}
if (VAR_6->pmtu_pending)
sctp_assoc_pending_pmtu(VAR_6);
if (sctp_sk(VAR_0)->disable_fragments && (VAR_2 > VAR_6->frag_point)) {
VAR_24 = -VAR_46;
goto out_free;
}
if (VAR_13->sinfo_stream >= VAR_6->stream.outcnt) {
VAR_24 = -VAR_33;
goto out_free;
}
if (unlikely(!VAR_6->stream.out[VAR_13->sinfo_stream].ext)) {
VAR_24 = sctp_stream_init_ext(&VAR_6->stream, VAR_13->sinfo_stream);
if (VAR_24)
goto out_free;
}
if (sctp_wspace(VAR_6) < VAR_2)
sctp_prsctp_prune(VAR_6, VAR_13, VAR_2 - sctp_wspace(VAR_6));
VAR_23 = sock_sndtimeo(VAR_0, VAR_1->msg_flags & VAR_47);
if (!sctp_wspace(VAR_6)) {
VAR_24 = sctp_wait_for_sndbuf(VAR_6, &VAR_23, VAR_2, &VAR_0);
if (VAR_24) {
if (VAR_24 == -VAR_48) {
VAR_5 = NULL;
VAR_24 = -VAR_28;
}
goto out_free;
}
}
if ((sctp_style(VAR_0, VAR_26) && VAR_11) ||
(VAR_22 & VAR_34)) {
VAR_8 = sctp_assoc_lookup_paddr(VAR_6, &VAR_10);
if (!VAR_8) {
VAR_24 = -VAR_33;
goto out_free;
}
} else
VAR_8 = NULL;
if (sctp_state(VAR_6, VAR_38)) {
VAR_24 = sctp_primitive_ASSOCIATE(net, VAR_6, NULL);
if (VAR_24 < 0)
goto out_free;
VAR_19 = true;
pr_debug(""%s: we associated primitively\n"", VAR_25);
}
VAR_20 = sctp_datamsg_from_user(VAR_6, VAR_13, &VAR_1->msg_iter);
if (IS_ERR(VAR_20)) {
VAR_24 = PTR_ERR(VAR_20);
goto out_free;
}
VAR_6->force_delay = !!(VAR_1->msg_flags & VAR_49);
list_for_each_entry(VAR_9, &VAR_20->chunks, VAR_50) {
sctp_chunk_hold(VAR_9);
sctp_set_owner_w(VAR_9);
VAR_9->transport = VAR_8;
}
VAR_24 = sctp_primitive_SEND(net, VAR_6, VAR_20);
if (VAR_24) {
sctp_datamsg_free(VAR_20);
goto out_free;
}
pr_debug(""%s: we sent primitively\n"", VAR_25);
sctp_datamsg_put(VAR_20);
VAR_24 = VAR_2;
if (unlikely(VAR_19)) {
VAR_23 = sock_sndtimeo(VAR_0, VAR_21 & VAR_47);
sctp_wait_for_connect(VAR_6, &VAR_23);
}
goto out_unlock;
out_free:
if (VAR_5)
sctp_association_free(VAR_6);
out_unlock:
release_sock(VAR_0);
out_nounlock:
return sctp_error(VAR_0, VAR_21, VAR_24);
#if 0
do_sock_err:
if (VAR_2)
VAR_24 = VAR_2;
else
VAR_24 = sock_error(VAR_0);
goto out;
do_interrupted:
if (VAR_2)
VAR_24 = VAR_2;
goto out;
#endif 
}",torvalds/linux/a0ff660058b88d12625a783ce9e5c1371c87951f/socket.c/vul/before/1.json,"static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)
{
	struct net *net = sock_net(sk);
	struct sctp_sock *sp;
	struct sctp_endpoint *ep;
	struct sctp_association *new_asoc = NULL, *asoc = NULL;
	struct sctp_transport *transport, *chunk_tp;
	struct sctp_chunk *chunk;
	union sctp_addr to;
	struct sockaddr *msg_name = NULL;
	struct sctp_sndrcvinfo default_sinfo;
	struct sctp_sndrcvinfo *sinfo;
	struct sctp_initmsg *sinit;
	sctp_assoc_t associd = 0;
	struct sctp_cmsgs cmsgs = { NULL };
	enum sctp_scope scope;
	bool fill_sinfo_ttl = false, wait_connect = false;
	struct sctp_datamsg *datamsg;
	int msg_flags = msg->msg_flags;
	__u16 sinfo_flags = 0;
	long timeo;
	int err;

	err = 0;
	sp = sctp_sk(sk);
	ep = sp->ep;

	pr_debug(""%s: sk:%p, msg:%p, msg_len:%zu ep:%p\n"", __func__, sk,
		 msg, msg_len, ep);

	/* We cannot send a message over a TCP-style listening socket. */
	if (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)) {
		err = -EPIPE;
		goto out_nounlock;
	}

	/* Parse out the SCTP CMSGs.  */
	err = sctp_msghdr_parse(msg, &cmsgs);
	if (err) {
		pr_debug(""%s: msghdr parse err:%x\n"", __func__, err);
		goto out_nounlock;
	}

	/* Fetch the destination address for this packet.  This
	 * address only selects the association--it is not necessarily
	 * the address we will send to.
	 * For a peeled-off socket, msg_name is ignored.
	 */
	if (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {
		int msg_namelen = msg->msg_namelen;

		err = sctp_verify_addr(sk, (union sctp_addr *)msg->msg_name,
				       msg_namelen);
		if (err)
			return err;

		if (msg_namelen > sizeof(to))
			msg_namelen = sizeof(to);
		memcpy(&to, msg->msg_name, msg_namelen);
		msg_name = msg->msg_name;
	}

	sinit = cmsgs.init;
	if (cmsgs.sinfo != NULL) {
		memset(&default_sinfo, 0, sizeof(default_sinfo));
		default_sinfo.sinfo_stream = cmsgs.sinfo->snd_sid;
		default_sinfo.sinfo_flags = cmsgs.sinfo->snd_flags;
		default_sinfo.sinfo_ppid = cmsgs.sinfo->snd_ppid;
		default_sinfo.sinfo_context = cmsgs.sinfo->snd_context;
		default_sinfo.sinfo_assoc_id = cmsgs.sinfo->snd_assoc_id;

		sinfo = &default_sinfo;
		fill_sinfo_ttl = true;
	} else {
		sinfo = cmsgs.srinfo;
	}
	/* Did the user specify SNDINFO/SNDRCVINFO? */
	if (sinfo) {
		sinfo_flags = sinfo->sinfo_flags;
		associd = sinfo->sinfo_assoc_id;
	}

	pr_debug(""%s: msg_len:%zu, sinfo_flags:0x%x\n"", __func__,
		 msg_len, sinfo_flags);

	/* SCTP_EOF or SCTP_ABORT cannot be set on a TCP-style socket. */
	if (sctp_style(sk, TCP) && (sinfo_flags & (SCTP_EOF | SCTP_ABORT))) {
		err = -EINVAL;
		goto out_nounlock;
	}

	/* If SCTP_EOF is set, no data can be sent. Disallow sending zero
	 * length messages when SCTP_EOF|SCTP_ABORT is not set.
	 * If SCTP_ABORT is set, the message length could be non zero with
	 * the msg_iov set to the user abort reason.
	 */
	if (((sinfo_flags & SCTP_EOF) && (msg_len > 0)) ||
	    (!(sinfo_flags & (SCTP_EOF|SCTP_ABORT)) && (msg_len == 0))) {
		err = -EINVAL;
		goto out_nounlock;
	}

	/* If SCTP_ADDR_OVER is set, there must be an address
	 * specified in msg_name.
	 */
	if ((sinfo_flags & SCTP_ADDR_OVER) && (!msg->msg_name)) {
		err = -EINVAL;
		goto out_nounlock;
	}

	transport = NULL;

	pr_debug(""%s: about to look up association\n"", __func__);

	lock_sock(sk);

	/* If a msg_name has been specified, assume this is to be used.  */
	if (msg_name) {
		/* Look for a matching association on the endpoint. */
		asoc = sctp_endpoint_lookup_assoc(ep, &to, &transport);

		/* If we could not find a matching association on the
		 * endpoint, make sure that it is not a TCP-style
		 * socket that already has an association or there is
		 * no peeled-off association on another socket.
		 */
		if (!asoc &&
		    ((sctp_style(sk, TCP) &&
		      (sctp_sstate(sk, ESTABLISHED) ||
		       sctp_sstate(sk, CLOSING))) ||
		     sctp_endpoint_is_peeled_off(ep, &to))) {
			err = -EADDRNOTAVAIL;
			goto out_unlock;
		}
	} else {
		asoc = sctp_id2assoc(sk, associd);
		if (!asoc) {
			err = -EPIPE;
			goto out_unlock;
		}
	}

	if (asoc) {
		pr_debug(""%s: just looked up association:%p\n"", __func__, asoc);

		/* We cannot send a message on a TCP-style SCTP_SS_ESTABLISHED
		 * socket that has an association in CLOSED state. This can
		 * happen when an accepted socket has an association that is
		 * already CLOSED.
		 */
		if (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP)) {
			err = -EPIPE;
			goto out_unlock;
		}

		if (sinfo_flags & SCTP_EOF) {
			pr_debug(""%s: shutting down association:%p\n"",
				 __func__, asoc);

			sctp_primitive_SHUTDOWN(net, asoc, NULL);
			err = 0;
			goto out_unlock;
		}
		if (sinfo_flags & SCTP_ABORT) {

			chunk = sctp_make_abort_user(asoc, msg, msg_len);
			if (!chunk) {
				err = -ENOMEM;
				goto out_unlock;
			}

			pr_debug(""%s: aborting association:%p\n"",
				 __func__, asoc);

			sctp_primitive_ABORT(net, asoc, chunk);
			err = 0;
			goto out_unlock;
		}
	}

	/* Do we need to create the association?  */
	if (!asoc) {
		pr_debug(""%s: there is no association yet\n"", __func__);

		if (sinfo_flags & (SCTP_EOF | SCTP_ABORT)) {
			err = -EINVAL;
			goto out_unlock;
		}

		/* Check for invalid stream against the stream counts,
		 * either the default or the user specified stream counts.
		 */
		if (sinfo) {
			if (!sinit || !sinit->sinit_num_ostreams) {
				/* Check against the defaults. */
				if (sinfo->sinfo_stream >=
				    sp->initmsg.sinit_num_ostreams) {
					err = -EINVAL;
					goto out_unlock;
				}
			} else {
				/* Check against the requested.  */
				if (sinfo->sinfo_stream >=
				    sinit->sinit_num_ostreams) {
					err = -EINVAL;
					goto out_unlock;
				}
			}
		}

		/*
		 * API 3.1.2 bind() - UDP Style Syntax
		 * If a bind() or sctp_bindx() is not called prior to a
		 * sendmsg() call that initiates a new association, the
		 * system picks an ephemeral port and will choose an address
		 * set equivalent to binding with a wildcard address.
		 */
		if (!ep->base.bind_addr.port) {
			if (sctp_autobind(sk)) {
				err = -EAGAIN;
				goto out_unlock;
			}
		} else {
			/*
			 * If an unprivileged user inherits a one-to-many
			 * style socket with open associations on a privileged
			 * port, it MAY be permitted to accept new associations,
			 * but it SHOULD NOT be permitted to open new
			 * associations.
			 */
			if (ep->base.bind_addr.port < inet_prot_sock(net) &&
			    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {
				err = -EACCES;
				goto out_unlock;
			}
		}

		scope = sctp_scope(&to);
		new_asoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);
		if (!new_asoc) {
			err = -ENOMEM;
			goto out_unlock;
		}
		asoc = new_asoc;
		err = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);
		if (err < 0) {
			err = -ENOMEM;
			goto out_free;
		}

		/* If the SCTP_INIT ancillary data is specified, set all
		 * the association init values accordingly.
		 */
		if (sinit) {
			if (sinit->sinit_num_ostreams) {
				__u16 outcnt = sinit->sinit_num_ostreams;

				asoc->c.sinit_num_ostreams = outcnt;
				/* outcnt has been changed, so re-init stream */
				err = sctp_stream_init(&asoc->stream, outcnt, 0,
						       GFP_KERNEL);
				if (err)
					goto out_free;
			}
			if (sinit->sinit_max_instreams) {
				asoc->c.sinit_max_instreams =
					sinit->sinit_max_instreams;
			}
			if (sinit->sinit_max_attempts) {
				asoc->max_init_attempts
					= sinit->sinit_max_attempts;
			}
			if (sinit->sinit_max_init_timeo) {
				asoc->max_init_timeo =
				 msecs_to_jiffies(sinit->sinit_max_init_timeo);
			}
		}

		/* Prime the peer's transport structures.  */
		transport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL, SCTP_UNKNOWN);
		if (!transport) {
			err = -ENOMEM;
			goto out_free;
		}
	}

	/* ASSERT: we have a valid association at this point.  */
	pr_debug(""%s: we have a valid association\n"", __func__);

	if (!sinfo) {
		/* If the user didn't specify SNDINFO/SNDRCVINFO, make up
		 * one with some defaults.
		 */
		memset(&default_sinfo, 0, sizeof(default_sinfo));
		default_sinfo.sinfo_stream = asoc->default_stream;
		default_sinfo.sinfo_flags = asoc->default_flags;
		default_sinfo.sinfo_ppid = asoc->default_ppid;
		default_sinfo.sinfo_context = asoc->default_context;
		default_sinfo.sinfo_timetolive = asoc->default_timetolive;
		default_sinfo.sinfo_assoc_id = sctp_assoc2id(asoc);

		sinfo = &default_sinfo;
	} else if (fill_sinfo_ttl) {
		/* In case SNDINFO was specified, we still need to fill
		 * it with a default ttl from the assoc here.
		 */
		sinfo->sinfo_timetolive = asoc->default_timetolive;
	}

	/* API 7.1.7, the sndbuf size per association bounds the
	 * maximum size of data that can be sent in a single send call.
	 */
	if (msg_len > sk->sk_sndbuf) {
		err = -EMSGSIZE;
		goto out_free;
	}

	if (asoc->pmtu_pending)
		sctp_assoc_pending_pmtu(asoc);

	/* If fragmentation is disabled and the message length exceeds the
	 * association fragmentation point, return EMSGSIZE.  The I-D
	 * does not specify what this error is, but this looks like
	 * a great fit.
	 */
	if (sctp_sk(sk)->disable_fragments && (msg_len > asoc->frag_point)) {
		err = -EMSGSIZE;
		goto out_free;
	}

	/* Check for invalid stream. */
	if (sinfo->sinfo_stream >= asoc->stream.outcnt) {
		err = -EINVAL;
		goto out_free;
	}

	/* Allocate sctp_stream_out_ext if not already done */
	if (unlikely(!asoc->stream.out[sinfo->sinfo_stream].ext)) {
		err = sctp_stream_init_ext(&asoc->stream, sinfo->sinfo_stream);
		if (err)
			goto out_free;
	}

	if (sctp_wspace(asoc) < msg_len)
		sctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));

	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);
	if (!sctp_wspace(asoc)) {
		/* sk can be changed by peel off when waiting for buf. */
		err = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);
		if (err) {
			if (err == -ESRCH) {
				/* asoc is already dead. */
				new_asoc = NULL;
				err = -EPIPE;
			}
			goto out_free;
		}
	}

	/* If an address is passed with the sendto/sendmsg call, it is used
	 * to override the primary destination address in the TCP model, or
	 * when SCTP_ADDR_OVER flag is set in the UDP model.
	 */
	if ((sctp_style(sk, TCP) && msg_name) ||
	    (sinfo_flags & SCTP_ADDR_OVER)) {
		chunk_tp = sctp_assoc_lookup_paddr(asoc, &to);
		if (!chunk_tp) {
			err = -EINVAL;
			goto out_free;
		}
	} else
		chunk_tp = NULL;

	/* Auto-connect, if we aren't connected already. */
	if (sctp_state(asoc, CLOSED)) {
		err = sctp_primitive_ASSOCIATE(net, asoc, NULL);
		if (err < 0)
			goto out_free;

		wait_connect = true;
		pr_debug(""%s: we associated primitively\n"", __func__);
	}

	/* Break the message into multiple chunks of maximum size. */
	datamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);
	if (IS_ERR(datamsg)) {
		err = PTR_ERR(datamsg);
		goto out_free;
	}
	asoc->force_delay = !!(msg->msg_flags & MSG_MORE);

	/* Now send the (possibly) fragmented message. */
	list_for_each_entry(chunk, &datamsg->chunks, frag_list) {
		sctp_chunk_hold(chunk);

		/* Do accounting for the write space.  */
		sctp_set_owner_w(chunk);

		chunk->transport = chunk_tp;
	}

	/* Send it to the lower layers.  Note:  all chunks
	 * must either fail or succeed.   The lower layer
	 * works that way today.  Keep it that way or this
	 * breaks.
	 */
	err = sctp_primitive_SEND(net, asoc, datamsg);
	/* Did the lower layer accept the chunk? */
	if (err) {
		sctp_datamsg_free(datamsg);
		goto out_free;
	}

	pr_debug(""%s: we sent primitively\n"", __func__);

	sctp_datamsg_put(datamsg);
	err = msg_len;

	if (unlikely(wait_connect)) {
		timeo = sock_sndtimeo(sk, msg_flags & MSG_DONTWAIT);
		sctp_wait_for_connect(asoc, &timeo);
	}

	/* If we are already past ASSOCIATE, the lower
	 * layers are responsible for association cleanup.
	 */
	goto out_unlock;

out_free:
	if (new_asoc)
		sctp_association_free(asoc);
out_unlock:
	release_sock(sk);

out_nounlock:
	return sctp_error(sk, msg_flags, err);

#if 0
do_sock_err:
	if (msg_len)
		err = msg_len;
	else
		err = sock_error(sk);
	goto out;

do_interrupted:
	if (msg_len)
		err = msg_len;
	goto out;
#endif /* 0 */
}","static int sctp_sendmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
	struct net *net = sock_net(VAR_0);
	struct sctp_sock *VAR_3;
	struct sctp_endpoint *VAR_4;
	struct sctp_association *VAR_5 = NULL, *VAR_6 = NULL;
	struct sctp_transport *VAR_7, *VAR_8;
	struct sctp_chunk *VAR_9;
	union sctp_addr VAR_10;
	struct sockaddr *VAR_11 = NULL;
	struct sctp_sndrcvinfo VAR_12;
	struct sctp_sndrcvinfo *VAR_13;
	struct sctp_initmsg *VAR_14;
	sctp_assoc_t VAR_15 = 0;
	struct sctp_cmsgs VAR_16 = { NULL };
	enum sctp_scope VAR_17;
	bool VAR_18 = false, VAR_19 = false;
	struct sctp_datamsg *VAR_20;
	int VAR_21 = VAR_1->msg_flags;
	__u16 VAR_22 = 0;
	long VAR_23;
	int VAR_24;

	VAR_24 = 0;
	VAR_3 = sctp_sk(VAR_0);
	VAR_4 = VAR_3->ep;

	pr_debug(""%s: sk:%p, msg:%p, msg_len:%zu ep:%p\n"", VAR_25, VAR_0,
		 VAR_1, VAR_2, VAR_4);

	/* COMMENT_0 */
	if (sctp_style(VAR_0, VAR_26) && sctp_sstate(VAR_0, VAR_27)) {
		VAR_24 = -VAR_28;
		goto out_nounlock;
	}

	/* COMMENT_1 */
	VAR_24 = sctp_msghdr_parse(VAR_1, &VAR_16);
	if (VAR_24) {
		pr_debug(""%s: msghdr parse err:%x\n"", VAR_25, VAR_24);
		goto out_nounlock;
	}

	/* COMMENT_2 */
                                                               
                                
                                                 
    
	if (!sctp_style(VAR_0, VAR_29) && VAR_1->msg_name) {
		int VAR_30 = VAR_1->msg_namelen;

		VAR_24 = sctp_verify_addr(VAR_0, (union sctp_addr *)VAR_1->msg_name,
				       VAR_30);
		if (VAR_24)
			return VAR_24;

		if (VAR_30 > sizeof(VAR_10))
			VAR_30 = sizeof(VAR_10);
		memcpy(&VAR_10, VAR_1->msg_name, VAR_30);
		VAR_11 = VAR_1->msg_name;
	}

	VAR_14 = VAR_16.init;
	if (VAR_16.sinfo != NULL) {
		memset(&VAR_12, 0, sizeof(VAR_12));
		VAR_12.sinfo_stream = VAR_16.sinfo->snd_sid;
		VAR_12.sinfo_flags = VAR_16.sinfo->snd_flags;
		VAR_12.sinfo_ppid = VAR_16.sinfo->snd_ppid;
		VAR_12.sinfo_context = VAR_16.sinfo->snd_context;
		VAR_12.sinfo_assoc_id = VAR_16.sinfo->snd_assoc_id;

		VAR_13 = &VAR_12;
		VAR_18 = true;
	} else {
		VAR_13 = VAR_16.srinfo;
	}
	/* COMMENT_7 */
	if (VAR_13) {
		VAR_22 = VAR_13->sinfo_flags;
		VAR_15 = VAR_13->sinfo_assoc_id;
	}

	pr_debug(""%s: msg_len:%zu, sinfo_flags:0x%x\n"", VAR_25,
		 VAR_2, VAR_22);

	/* COMMENT_8 */
	if (sctp_style(VAR_0, VAR_26) && (VAR_22 & (VAR_31 | VAR_32))) {
		VAR_24 = -VAR_33;
		goto out_nounlock;
	}

	/* COMMENT_9 */
                                                        
                                                                   
                                             
    
	if (((VAR_22 & VAR_31) && (VAR_2 > 0)) ||
	    (!(VAR_22 & (VAR_31|VAR_32)) && (VAR_2 == 0))) {
		VAR_24 = -VAR_33;
		goto out_nounlock;
	}

	/* COMMENT_14 */
                          
    
	if ((VAR_22 & VAR_34) && (!VAR_1->msg_name)) {
		VAR_24 = -VAR_33;
		goto out_nounlock;
	}

	VAR_7 = NULL;

	pr_debug(""%s: about to look up association\n"", VAR_25);

	lock_sock(VAR_0);

	/* COMMENT_17 */
	if (VAR_11) {
		/* COMMENT_18 */
		VAR_6 = sctp_endpoint_lookup_assoc(VAR_4, &VAR_10, &VAR_7);

		/* COMMENT_19 */
                                                   
                                                       
                                                 
     
		if (!VAR_6 &&
		    ((sctp_style(VAR_0, VAR_26) &&
		      (sctp_sstate(VAR_0, VAR_35) ||
		       sctp_sstate(VAR_0, VAR_36))) ||
		     sctp_endpoint_is_peeled_off(VAR_4, &VAR_10))) {
			VAR_24 = -VAR_37;
			goto out_unlock;
		}
	} else {
		VAR_6 = sctp_id2assoc(VAR_0, VAR_15);
		if (!VAR_6) {
			VAR_24 = -VAR_28;
			goto out_unlock;
		}
	}

	if (VAR_6) {
		pr_debug(""%s: just looked up association:%p\n"", VAR_25, VAR_6);

		/* COMMENT_24 */
                                                             
                                                              
                    
     
		if (sctp_state(VAR_6, VAR_38) && sctp_style(VAR_0, VAR_26)) {
			VAR_24 = -VAR_28;
			goto out_unlock;
		}

		if (VAR_22 & VAR_31) {
			pr_debug(""%s: shutting down association:%p\n"",
				 VAR_25, VAR_6);

			sctp_primitive_SHUTDOWN(net, VAR_6, NULL);
			VAR_24 = 0;
			goto out_unlock;
		}
		if (VAR_22 & VAR_32) {

			VAR_9 = sctp_make_abort_user(VAR_6, VAR_1, VAR_2);
			if (!VAR_9) {
				VAR_24 = -VAR_39;
				goto out_unlock;
			}

			pr_debug(""%s: aborting association:%p\n"",
				 VAR_25, VAR_6);

			sctp_primitive_ABORT(net, VAR_6, VAR_9);
			VAR_24 = 0;
			goto out_unlock;
		}
	}

	/* COMMENT_29 */
	if (!VAR_6) {
		pr_debug(""%s: there is no association yet\n"", VAR_25);

		if (VAR_22 & (VAR_31 | VAR_32)) {
			VAR_24 = -VAR_33;
			goto out_unlock;
		}

		/* COMMENT_30 */
                                                            
     
		if (VAR_13) {
			if (!VAR_14 || !VAR_14->sinit_num_ostreams) {
				/* COMMENT_33 */
				if (VAR_13->sinfo_stream >=
				    VAR_3->initmsg.sinit_num_ostreams) {
					VAR_24 = -VAR_33;
					goto out_unlock;
				}
			} else {
				/* COMMENT_34 */
				if (VAR_13->sinfo_stream >=
				    VAR_14->sinit_num_ostreams) {
					VAR_24 = -VAR_33;
					goto out_unlock;
				}
			}
		}

		/* COMMENT_35 */
                                        
                                                         
                                                         
                                                              
                                                       
     
		if (!VAR_4->base.bind_addr.port) {
			if (sctp_autobind(VAR_0)) {
				VAR_24 = -VAR_40;
				goto out_unlock;
			}
		} else {
			/* COMMENT_42 */
                                                    
                                                         
                                                           
                                                
                   
      
			if (VAR_4->base.bind_addr.port < inet_prot_sock(net) &&
			    !ns_capable(net->user_ns, VAR_41)) {
				VAR_24 = -VAR_42;
				goto out_unlock;
			}
		}

		VAR_17 = sctp_scope(&VAR_10);
		VAR_5 = sctp_association_new(VAR_4, VAR_0, VAR_17, VAR_43);
		if (!VAR_5) {
			VAR_24 = -VAR_39;
			goto out_unlock;
		}
		VAR_6 = VAR_5;
		VAR_24 = sctp_assoc_set_bind_addr_from_ep(VAR_6, VAR_17, VAR_43);
		if (VAR_24 < 0) {
			VAR_24 = -VAR_39;
			goto out_free;
		}

		/* COMMENT_49 */
                                             
     
		if (VAR_14) {
			if (VAR_14->sinit_num_ostreams) {
				__u16 VAR_44 = VAR_14->sinit_num_ostreams;

				VAR_6->c.sinit_num_ostreams = VAR_44;
				/* COMMENT_52 */
				VAR_24 = sctp_stream_init(&VAR_6->stream, VAR_44, 0,
						       VAR_43);
				if (VAR_24)
					goto out_free;
			}
			if (VAR_14->sinit_max_instreams) {
				VAR_6->c.sinit_max_instreams =
					VAR_14->sinit_max_instreams;
			}
			if (VAR_14->sinit_max_attempts) {
				VAR_6->max_init_attempts
					= VAR_14->sinit_max_attempts;
			}
			if (VAR_14->sinit_max_init_timeo) {
				VAR_6->max_init_timeo =
				 msecs_to_jiffies(VAR_14->sinit_max_init_timeo);
			}
		}

		/* COMMENT_53 */
		VAR_7 = sctp_assoc_add_peer(VAR_6, &VAR_10, VAR_43, VAR_45);
		if (!VAR_7) {
			VAR_24 = -VAR_39;
			goto out_free;
		}
	}

	/* COMMENT_54 */
	pr_debug(""%s: we have a valid association\n"", VAR_25);

	if (!VAR_13) {
		/* COMMENT_55 */
                            
     
		memset(&VAR_12, 0, sizeof(VAR_12));
		VAR_12.sinfo_stream = VAR_6->default_stream;
		VAR_12.sinfo_flags = VAR_6->default_flags;
		VAR_12.sinfo_ppid = VAR_6->default_ppid;
		VAR_12.sinfo_context = VAR_6->default_context;
		VAR_12.sinfo_timetolive = VAR_6->default_timetolive;
		VAR_12.sinfo_assoc_id = sctp_assoc2id(VAR_6);

		VAR_13 = &VAR_12;
	} else if (VAR_18) {
		/* COMMENT_58 */
                                               
     
		VAR_13->sinfo_timetolive = VAR_6->default_timetolive;
	}

	/* COMMENT_61 */
                                                                
    
	if (VAR_2 > VAR_0->sk_sndbuf) {
		VAR_24 = -VAR_46;
		goto out_free;
	}

	if (VAR_6->pmtu_pending)
		sctp_assoc_pending_pmtu(VAR_6);

	/* COMMENT_64 */
                                                              
                                                            
                
    
	if (sctp_sk(VAR_0)->disable_fragments && (VAR_2 > VAR_6->frag_point)) {
		VAR_24 = -VAR_46;
		goto out_free;
	}

	/* COMMENT_69 */
	if (VAR_13->sinfo_stream >= VAR_6->stream.outcnt) {
		VAR_24 = -VAR_33;
		goto out_free;
	}

	/* COMMENT_70 */
	if (unlikely(!VAR_6->stream.out[VAR_13->sinfo_stream].ext)) {
		VAR_24 = sctp_stream_init_ext(&VAR_6->stream, VAR_13->sinfo_stream);
		if (VAR_24)
			goto out_free;
	}

	if (sctp_wspace(VAR_6) < VAR_2)
		sctp_prsctp_prune(VAR_6, VAR_13, VAR_2 - sctp_wspace(VAR_6));

	VAR_23 = sock_sndtimeo(VAR_0, VAR_1->msg_flags & VAR_47);
	if (!sctp_wspace(VAR_6)) {
		/* COMMENT_71 */
		VAR_24 = sctp_wait_for_sndbuf(VAR_6, &VAR_23, VAR_2);
		if (VAR_24) {
			if (VAR_24 == -VAR_48) {
				/* COMMENT_72 */
				VAR_5 = NULL;
				VAR_24 = -VAR_28;
			}
			goto out_free;
		}
	}

	/* COMMENT_73 */
                                                                    
                                                     
    
	if ((sctp_style(VAR_0, VAR_26) && VAR_11) ||
	    (VAR_22 & VAR_34)) {
		VAR_8 = sctp_assoc_lookup_paddr(VAR_6, &VAR_10);
		if (!VAR_8) {
			VAR_24 = -VAR_33;
			goto out_free;
		}
	} else
		VAR_8 = NULL;

	/* COMMENT_77 */
	if (sctp_state(VAR_6, VAR_38)) {
		VAR_24 = sctp_primitive_ASSOCIATE(net, VAR_6, NULL);
		if (VAR_24 < 0)
			goto out_free;

		VAR_19 = true;
		pr_debug(""%s: we associated primitively\n"", VAR_25);
	}

	/* COMMENT_78 */
	VAR_20 = sctp_datamsg_from_user(VAR_6, VAR_13, &VAR_1->msg_iter);
	if (IS_ERR(VAR_20)) {
		VAR_24 = PTR_ERR(VAR_20);
		goto out_free;
	}
	VAR_6->force_delay = !!(VAR_1->msg_flags & VAR_49);

	/* COMMENT_79 */
	list_for_each_entry(VAR_9, &VAR_20->chunks, VAR_50) {
		sctp_chunk_hold(VAR_9);

		/* COMMENT_80 */
		sctp_set_owner_w(VAR_9);

		VAR_9->transport = VAR_8;
	}

	/* COMMENT_81 */
                                                  
                                                   
           
    
	VAR_24 = sctp_primitive_SEND(net, VAR_6, VAR_20);
	/* COMMENT_86 */
	if (VAR_24) {
		sctp_datamsg_free(VAR_20);
		goto out_free;
	}

	pr_debug(""%s: we sent primitively\n"", VAR_25);

	sctp_datamsg_put(VAR_20);
	VAR_24 = VAR_2;

	if (unlikely(VAR_19)) {
		VAR_23 = sock_sndtimeo(VAR_0, VAR_21 & VAR_47);
		sctp_wait_for_connect(VAR_6, &VAR_23);
	}

	/* COMMENT_87 */
                                                   
    
	goto out_unlock;

out_free:
	if (VAR_5)
		sctp_association_free(VAR_6);
out_unlock:
	release_sock(VAR_0);

out_nounlock:
	return sctp_error(VAR_0, VAR_21, VAR_24);

#if 0
do_sock_err:
	if (VAR_2)
		VAR_24 = VAR_2;
	else
		VAR_24 = sock_error(VAR_0);
	goto out;

do_interrupted:
	if (VAR_2)
		VAR_24 = VAR_2;
	goto out;
#endif /* COMMENT_90 */
}",torvalds/linux/a0ff660058b88d12625a783ce9e5c1371c87951f/socket.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -347,7 +347,7 @@
 	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);
 	if (!sctp_wspace(asoc)) {
 		/* sk can be changed by peel off when waiting for buf. */
-		err = sctp_wait_for_sndbuf(asoc, &timeo, msg_len, &sk);
+		err = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);
 		if (err) {
 			if (err == -ESRCH) {
 				/* asoc is already dead. */","{'deleted_lines': ['\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len, &sk);'], 'added_lines': ['\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);']}",True,"An issue was discovered in the Linux kernel before 4.14.16. There is a use-after-free in net/sctp/socket.c for a held lock after a peel off, aka CID-a0ff660058b8.",7.8,HIGH,2,valid,,5
CVE-2014-125003,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
avcodec/jpeg2000dec: fix error detection in pix_fmt_match()

Fixes out of array accesses with CODEC_FLAG_EMU_EDGE

Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",8001e9f7d17e90b4b0898ba64e3b8bbd716c513c,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=8001e9f7d17e90b4b0898ba64e3b8bbd716c513c,libavcodec/jpeg2000dec.c,get_siz,"static int get_siz(Jpeg2000DecoderContext *s)
{
int i;
int ncomponents;
uint32_t log2_chroma_wh = 0;
const enum AVPixelFormat *possible_fmts = NULL;
int possible_fmts_nb = 0;
if (bytestream2_get_bytes_left(&s->g) < 36)
return AVERROR_INVALIDDATA;
s->avctx->profile = bytestream2_get_be16u(&s->g);     s->width          = bytestream2_get_be32u(&s->g);     s->height         = bytestream2_get_be32u(&s->g);     s->image_offset_x = bytestream2_get_be32u(&s->g);     s->image_offset_y = bytestream2_get_be32u(&s->g);     s->tile_width     = bytestream2_get_be32u(&s->g);     s->tile_height    = bytestream2_get_be32u(&s->g);     s->tile_offset_x  = bytestream2_get_be32u(&s->g);     s->tile_offset_y  = bytestream2_get_be32u(&s->g);     ncomponents       = bytestream2_get_be16u(&s->g); 
if (s->image_offset_x || s->image_offset_y) {
avpriv_request_sample(s->avctx, ""Support for image offsets"");
return AVERROR_PATCHWELCOME;
}
if (ncomponents <= 0) {
av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
s->ncomponents);
return AVERROR_INVALIDDATA;
}
if (ncomponents > 4) {
avpriv_request_sample(s->avctx, ""Support for %d components"",
s->ncomponents);
return AVERROR_PATCHWELCOME;
}
s->ncomponents = ncomponents;
if (s->tile_width <= 0 || s->tile_height <= 0) {
av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
s->tile_width, s->tile_height);
return AVERROR_INVALIDDATA;
}
if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)
return AVERROR_INVALIDDATA;
for (i = 0; i < s->ncomponents; i++) {         uint8_t x    = bytestream2_get_byteu(&s->g);
s->cbps[i]   = (x & 0x7f) + 1;
s->precision = FFMAX(s->cbps[i], s->precision);
s->sgnd[i]   = !!(x & 0x80);
s->cdx[i]    = bytestream2_get_byteu(&s->g);
s->cdy[i]    = bytestream2_get_byteu(&s->g);
if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
|| !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
return AVERROR_INVALIDDATA;
}
log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
}
s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
s->numXtiles = s->numYtiles = 0;
return AVERROR(EINVAL);
}
s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
if (!s->tile) {
s->numXtiles = s->numYtiles = 0;
return AVERROR(ENOMEM);
}
for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
Jpeg2000Tile *tile = s->tile + i;
tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
if (!tile->comp)
return AVERROR(ENOMEM);
}
s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
s->reduction_factor);
s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
s->reduction_factor);
if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
possible_fmts = xyz_pix_fmts;
possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
} else {
switch (s->colour_space) {
case 16:
possible_fmts = rgb_pix_fmts;
possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
break;
case 17:
possible_fmts = gray_pix_fmts;
possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
break;
case 18:
possible_fmts = yuv_pix_fmts;
possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
break;
default:
possible_fmts = all_pix_fmts;
possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
break;
}
}
for (i = 0; i < possible_fmts_nb; ++i) {
if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
s->avctx->pix_fmt = possible_fmts[i];
break;
}
}
if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {
av_log(s->avctx, AV_LOG_ERROR,
""Unknown pix_fmt, profile: %d, colour_space: %d, ""
""components: %d, precision: %d, ""
""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
s->avctx->profile, s->colour_space, ncomponents, s->precision,
ncomponents > 2 ? s->cdx[1] : 0,
ncomponents > 2 ? s->cdy[1] : 0,
ncomponents > 2 ? s->cdx[2] : 0,
ncomponents > 2 ? s->cdy[2] : 0);
}
s->avctx->bits_per_raw_sample = s->precision;
return 0;
}","static int get_siz(Jpeg2000DecoderContext *VAR_0)
{
int VAR_1;
int VAR_2;
uint32_t VAR_3 = 0;
const enum AVPixelFormat *VAR_4 = NULL;
int VAR_5 = 0;
if (bytestream2_get_bytes_left(&VAR_0->g) < 36)
return VAR_6;
VAR_0->avctx->profile = bytestream2_get_be16u(&VAR_0->g); 
VAR_0->width          = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->height         = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->image_offset_x = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->image_offset_y = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->tile_width     = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->tile_height    = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->tile_offset_x  = bytestream2_get_be32u(&VAR_0->g); 
VAR_0->tile_offset_y  = bytestream2_get_be32u(&VAR_0->g); 
VAR_2       = bytestream2_get_be16u(&VAR_0->g); 
if (VAR_0->image_offset_x || VAR_0->image_offset_y) {
avpriv_request_sample(VAR_0->avctx, ""Support for image offsets"");
return VAR_7;
}
if (VAR_2 <= 0) {
av_log(VAR_0->avctx, VAR_8, ""Invalid number of components: %d\n"",
VAR_0->ncomponents);
return VAR_6;
}
if (VAR_2 > 4) {
avpriv_request_sample(VAR_0->avctx, ""Support for %d components"",
VAR_0->ncomponents);
return VAR_7;
}
VAR_0->ncomponents = VAR_2;
if (VAR_0->tile_width <= 0 || VAR_0->tile_height <= 0) {
av_log(VAR_0->avctx, VAR_8, ""Invalid tile dimension %dx%d.\n"",
VAR_0->tile_width, VAR_0->tile_height);
return VAR_6;
}
if (bytestream2_get_bytes_left(&VAR_0->g) < 3 * VAR_0->ncomponents)
return VAR_6;
for (VAR_1 = 0; VAR_1 < VAR_0->ncomponents; VAR_1++) { 
uint8_t VAR_9    = bytestream2_get_byteu(&VAR_0->g);
VAR_0->cbps[VAR_1]   = (VAR_9 & 0x7f) + 1;
VAR_0->precision = FFMAX(VAR_0->cbps[VAR_1], VAR_0->precision);
VAR_0->sgnd[VAR_1]   = !!(VAR_9 & 0x80);
VAR_0->cdx[VAR_1]    = bytestream2_get_byteu(&VAR_0->g);
VAR_0->cdy[VAR_1]    = bytestream2_get_byteu(&VAR_0->g);
if (   !VAR_0->cdx[VAR_1] || VAR_0->cdx[VAR_1] == 3 || VAR_0->cdx[VAR_1] > 4
|| !VAR_0->cdy[VAR_1] || VAR_0->cdy[VAR_1] == 3 || VAR_0->cdy[VAR_1] > 4) {
av_log(VAR_0->avctx, VAR_8, ""Invalid sample separation %d/%d\n"", VAR_0->cdx[VAR_1], VAR_0->cdy[VAR_1]);
return VAR_6;
}
VAR_3 |= VAR_0->cdy[VAR_1] >> 1 << VAR_1 * 4 | VAR_0->cdx[VAR_1] >> 1 << VAR_1 * 4 + 2;
}
VAR_0->numXtiles = ff_jpeg2000_ceildiv(VAR_0->width  - VAR_0->tile_offset_x, VAR_0->tile_width);
VAR_0->numYtiles = ff_jpeg2000_ceildiv(VAR_0->height - VAR_0->tile_offset_y, VAR_0->tile_height);
if (VAR_0->numXtiles * (uint64_t)VAR_0->numYtiles > VAR_10/sizeof(*VAR_0->tile)) {
VAR_0->numXtiles = VAR_0->numYtiles = 0;
return AVERROR(VAR_11);
}
VAR_0->tile = av_mallocz_array(VAR_0->numXtiles * VAR_0->numYtiles, sizeof(*VAR_0->tile));
if (!VAR_0->tile) {
VAR_0->numXtiles = VAR_0->numYtiles = 0;
return AVERROR(VAR_12);
}
for (VAR_1 = 0; VAR_1 < VAR_0->numXtiles * VAR_0->numYtiles; VAR_1++) {
Jpeg2000Tile *VAR_13 = VAR_0->tile + VAR_1;
VAR_13->comp = av_mallocz(VAR_0->ncomponents * sizeof(*VAR_13->comp));
if (!VAR_13->comp)
return AVERROR(VAR_12);
}
VAR_0->avctx->width  = ff_jpeg2000_ceildivpow2(VAR_0->width  - VAR_0->image_offset_x,
VAR_0->reduction_factor);
VAR_0->avctx->height = ff_jpeg2000_ceildivpow2(VAR_0->height - VAR_0->image_offset_y,
VAR_0->reduction_factor);
if (VAR_0->avctx->profile == VAR_14 ||
VAR_0->avctx->profile == VAR_15) {
VAR_4 = VAR_16;
VAR_5 = FF_ARRAY_ELEMS(VAR_16);
} else {
switch (VAR_0->colour_space) {
case 16:
VAR_4 = VAR_17;
VAR_5 = FF_ARRAY_ELEMS(VAR_17);
break;
case 17:
VAR_4 = VAR_18;
VAR_5 = FF_ARRAY_ELEMS(VAR_18);
break;
case 18:
VAR_4 = VAR_19;
VAR_5 = FF_ARRAY_ELEMS(VAR_19);
break;
default:
VAR_4 = VAR_20;
VAR_5 = FF_ARRAY_ELEMS(VAR_20);
break;
}
}
for (VAR_1 = 0; VAR_1 < VAR_5; ++VAR_1) {
if (pix_fmt_match(VAR_4[VAR_1], VAR_2, VAR_0->precision, VAR_3, VAR_0->pal8)) {
VAR_0->avctx->pix_fmt = VAR_4[VAR_1];
break;
}
}
if (VAR_0->avctx->pix_fmt == VAR_21) {
av_log(VAR_0->avctx, VAR_8,
""Unknown pix_fmt, profile: %d, colour_space: %d, ""
""components: %d, precision: %d, ""
""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
VAR_0->avctx->profile, VAR_0->colour_space, VAR_2, VAR_0->precision,
VAR_2 > 2 ? VAR_0->cdx[1] : 0,
VAR_2 > 2 ? VAR_0->cdy[1] : 0,
VAR_2 > 2 ? VAR_0->cdx[2] : 0,
VAR_2 > 2 ? VAR_0->cdy[2] : 0);
}
VAR_0->avctx->bits_per_raw_sample = VAR_0->precision;
return 0;
}",ffmpeg/8001e9f7d17e90b4b0898ba64e3b8bbd716c513c/jpeg2000dec.c/vul/before/0.json,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;

    if (bytestream2_get_bytes_left(&s->g) < 36)
        return AVERROR_INVALIDDATA;

    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz

    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    }

    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
               s->ncomponents);
        return AVERROR_INVALIDDATA;
    }

    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              s->ncomponents);
        return AVERROR_PATCHWELCOME;
    }

    s->ncomponents = ncomponents;

    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
        return AVERROR_INVALIDDATA;
    }

    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)
        return AVERROR_INVALIDDATA;

    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
            return AVERROR_INVALIDDATA;
        }
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    }

    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);

    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    }

    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    }

    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;

        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    }

    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);

    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
        }
    }
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
        }
    }
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d, ""
               ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               ncomponents > 2 ? s->cdx[1] : 0,
               ncomponents > 2 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0);
        return AVERROR_PATCHWELCOME;
    }
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;
}","static int get_siz(Jpeg2000DecoderContext *VAR_0)
{
    int VAR_1;
    int VAR_2;
    uint32_t VAR_3 = 0;
    const enum AVPixelFormat *VAR_4 = NULL;
    int VAR_5 = 0;

    if (bytestream2_get_bytes_left(&VAR_0->g) < 36)
        return VAR_6;

    VAR_0->avctx->profile = bytestream2_get_be16u(&VAR_0->g); /* COMMENT_0 */
    VAR_0->width          = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_1 */
    VAR_0->height         = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_2 */
    VAR_0->image_offset_x = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_3 */
    VAR_0->image_offset_y = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_4 */
    VAR_0->tile_width     = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_5 */
    VAR_0->tile_height    = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_6 */
    VAR_0->tile_offset_x  = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_7 */
    VAR_0->tile_offset_y  = bytestream2_get_be32u(&VAR_0->g); /* COMMENT_8 */
    VAR_2       = bytestream2_get_be16u(&VAR_0->g); /* COMMENT_9 */

    if (VAR_0->image_offset_x || VAR_0->image_offset_y) {
        avpriv_request_sample(VAR_0->avctx, ""Support for image offsets"");
        return VAR_7;
    }

    if (VAR_2 <= 0) {
        av_log(VAR_0->avctx, VAR_8, ""Invalid number of components: %d\n"",
               VAR_0->ncomponents);
        return VAR_6;
    }

    if (VAR_2 > 4) {
        avpriv_request_sample(VAR_0->avctx, ""Support for %d components"",
                              VAR_0->ncomponents);
        return VAR_7;
    }

    VAR_0->ncomponents = VAR_2;

    if (VAR_0->tile_width <= 0 || VAR_0->tile_height <= 0) {
        av_log(VAR_0->avctx, VAR_8, ""Invalid tile dimension %dx%d.\n"",
               VAR_0->tile_width, VAR_0->tile_height);
        return VAR_6;
    }

    if (bytestream2_get_bytes_left(&VAR_0->g) < 3 * VAR_0->ncomponents)
        return VAR_6;

    for (VAR_1 = 0; VAR_1 < VAR_0->ncomponents; VAR_1++) { /* COMMENT_10 */
        uint8_t VAR_9    = bytestream2_get_byteu(&VAR_0->g);
        VAR_0->cbps[VAR_1]   = (VAR_9 & 0x7f) + 1;
        VAR_0->precision = FFMAX(VAR_0->cbps[VAR_1], VAR_0->precision);
        VAR_0->sgnd[VAR_1]   = !!(VAR_9 & 0x80);
        VAR_0->cdx[VAR_1]    = bytestream2_get_byteu(&VAR_0->g);
        VAR_0->cdy[VAR_1]    = bytestream2_get_byteu(&VAR_0->g);
        if (   !VAR_0->cdx[VAR_1] || VAR_0->cdx[VAR_1] == 3 || VAR_0->cdx[VAR_1] > 4
            || !VAR_0->cdy[VAR_1] || VAR_0->cdy[VAR_1] == 3 || VAR_0->cdy[VAR_1] > 4) {
            av_log(VAR_0->avctx, VAR_8, ""Invalid sample separation %d/%d\n"", VAR_0->cdx[VAR_1], VAR_0->cdy[VAR_1]);
            return VAR_6;
        }
        VAR_3 |= VAR_0->cdy[VAR_1] >> 1 << VAR_1 * 4 | VAR_0->cdx[VAR_1] >> 1 << VAR_1 * 4 + 2;
    }

    VAR_0->numXtiles = ff_jpeg2000_ceildiv(VAR_0->width  - VAR_0->tile_offset_x, VAR_0->tile_width);
    VAR_0->numYtiles = ff_jpeg2000_ceildiv(VAR_0->height - VAR_0->tile_offset_y, VAR_0->tile_height);

    if (VAR_0->numXtiles * (uint64_t)VAR_0->numYtiles > VAR_10/sizeof(*VAR_0->tile)) {
        VAR_0->numXtiles = VAR_0->numYtiles = 0;
        return AVERROR(VAR_11);
    }

    VAR_0->tile = av_mallocz_array(VAR_0->numXtiles * VAR_0->numYtiles, sizeof(*VAR_0->tile));
    if (!VAR_0->tile) {
        VAR_0->numXtiles = VAR_0->numYtiles = 0;
        return AVERROR(VAR_12);
    }

    for (VAR_1 = 0; VAR_1 < VAR_0->numXtiles * VAR_0->numYtiles; VAR_1++) {
        Jpeg2000Tile *VAR_13 = VAR_0->tile + VAR_1;

        VAR_13->comp = av_mallocz(VAR_0->ncomponents * sizeof(*VAR_13->comp));
        if (!VAR_13->comp)
            return AVERROR(VAR_12);
    }

    /* COMMENT_11 */
    VAR_0->avctx->width  = ff_jpeg2000_ceildivpow2(VAR_0->width  - VAR_0->image_offset_x,
                                               VAR_0->reduction_factor);
    VAR_0->avctx->height = ff_jpeg2000_ceildivpow2(VAR_0->height - VAR_0->image_offset_y,
                                               VAR_0->reduction_factor);

    if (VAR_0->avctx->profile == VAR_14 ||
        VAR_0->avctx->profile == VAR_15) {
        VAR_4 = VAR_16;
        VAR_5 = FF_ARRAY_ELEMS(VAR_16);
    } else {
        switch (VAR_0->colour_space) {
        case 16:
            VAR_4 = VAR_17;
            VAR_5 = FF_ARRAY_ELEMS(VAR_17);
            break;
        case 17:
            VAR_4 = VAR_18;
            VAR_5 = FF_ARRAY_ELEMS(VAR_18);
            break;
        case 18:
            VAR_4 = VAR_19;
            VAR_5 = FF_ARRAY_ELEMS(VAR_19);
            break;
        default:
            VAR_4 = VAR_20;
            VAR_5 = FF_ARRAY_ELEMS(VAR_20);
            break;
        }
    }
    for (VAR_1 = 0; VAR_1 < VAR_5; ++VAR_1) {
        if (pix_fmt_match(VAR_4[VAR_1], VAR_2, VAR_0->precision, VAR_3, VAR_0->pal8)) {
            VAR_0->avctx->pix_fmt = VAR_4[VAR_1];
            break;
        }
    }
    if (VAR_1 == VAR_5) {
        av_log(VAR_0->avctx, VAR_8,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d, ""
               ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
               VAR_0->avctx->profile, VAR_0->colour_space, VAR_2, VAR_0->precision,
               VAR_2 > 2 ? VAR_0->cdx[1] : 0,
               VAR_2 > 2 ? VAR_0->cdy[1] : 0,
               VAR_2 > 2 ? VAR_0->cdx[2] : 0,
               VAR_2 > 2 ? VAR_0->cdy[2] : 0);
        return VAR_7;
    }
    VAR_0->avctx->bits_per_raw_sample = VAR_0->precision;
    return 0;
}",ffmpeg/8001e9f7d17e90b4b0898ba64e3b8bbd716c513c/jpeg2000dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,7 +121,7 @@
             break;
         }
     }
-    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {
+    if (i == possible_fmts_nb) {
         av_log(s->avctx, AV_LOG_ERROR,
                ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
                ""components: %d, precision: %d, ""
@@ -131,6 +131,7 @@
                ncomponents > 2 ? s->cdy[1] : 0,
                ncomponents > 2 ? s->cdx[2] : 0,
                ncomponents > 2 ? s->cdy[2] : 0);
+        return AVERROR_PATCHWELCOME;
     }
     s->avctx->bits_per_raw_sample = s->precision;
     return 0;","{'deleted_lines': ['    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {'], 'added_lines': ['    if (i == possible_fmts_nb) {', '        return AVERROR_PATCHWELCOME;']}",True,A vulnerability was found in FFmpeg 2.0 and classified as problematic. This issue affects the function get_siz of the file libavcodec/jpeg2000dec.c. The manipulation leads to memory corruption. The attack may be initiated remotely. It is recommended to apply a patch to fix this issue.,5.5,MEDIUM,1,valid,,5
CVE-2014-125006,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
avcodec/h264: use subsample factors of the used pixel format

Fixes out of array read
Fixes: 1cb91c36c4e55463f14aacb9bdf55b38-asan_heap-oob_106cbce_5617_cov_11212800_h264_mmx_chroma_intra_lf.mp4
Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",8c55ff393340998faae887dfac19e7ef128e1e58,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=8c55ff393340998faae887dfac19e7ef128e1e58,libavcodec/h264.c,output_frame,"static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
AVFrame *src = &srcp->f;
int i;
int ret = av_frame_ref(dst, src);
if (ret < 0)
return ret;
av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);
if (!srcp->crop)
return 0;
for (i = 0; i < 3; i++) {
int hshift = (i > 0) ? h->chroma_x_shift : 0;
int vshift = (i > 0) ? h->chroma_y_shift : 0;
int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
(srcp->crop_top  >> vshift) * dst->linesize[i];
dst->data[i] += off;
}
return 0;
}","static int output_frame(H264Context *VAR_0, AVFrame *VAR_1, Picture *VAR_2)
{
AVFrame *VAR_3 = &VAR_2->f;
int VAR_4;
int VAR_5 = av_frame_ref(VAR_1, VAR_3);
if (VAR_5 < 0)
return VAR_5;
av_dict_set(&VAR_1->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(VAR_0), 0);
if (!VAR_2->crop)
return 0;
for (VAR_4 = 0; VAR_4 < 3; VAR_4++) {
int VAR_6 = (VAR_4 > 0) ? VAR_0->chroma_x_shift : 0;
int VAR_7 = (VAR_4 > 0) ? VAR_0->chroma_y_shift : 0;
int VAR_8    = ((VAR_2->crop_left >> VAR_6) << VAR_0->pixel_shift) +
(VAR_2->crop_top  >> VAR_7) * VAR_1->linesize[VAR_4];
VAR_1->data[VAR_4] += VAR_8;
}
return 0;
}",ffmpeg/8c55ff393340998faae887dfac19e7ef128e1e58/h264.c/vul/before/0.json,"static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcp->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}","static int output_frame(H264Context *VAR_0, AVFrame *VAR_1, Picture *VAR_2)
{
    AVFrame *VAR_3 = &VAR_2->f;
    const AVPixFmtDescriptor *VAR_4 = av_pix_fmt_desc_get(VAR_3->format);
    int VAR_5;
    int VAR_6 = av_frame_ref(VAR_1, VAR_3);
    if (VAR_6 < 0)
        return VAR_6;

    av_dict_set(&VAR_1->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(VAR_0), 0);

    if (!VAR_2->crop)
        return 0;

    for (VAR_5 = 0; VAR_5 < VAR_4->nb_components; VAR_5++) {
        int VAR_7 = (VAR_5 > 0) ? VAR_4->log2_chroma_w : 0;
        int VAR_8 = (VAR_5 > 0) ? VAR_4->log2_chroma_h : 0;
        int VAR_9    = ((VAR_2->crop_left >> VAR_7) << VAR_0->pixel_shift) +
                      (VAR_2->crop_top  >> VAR_8) * VAR_1->linesize[VAR_5];
        VAR_1->data[VAR_5] += VAR_9;
    }
    return 0;
}",ffmpeg/8c55ff393340998faae887dfac19e7ef128e1e58/h264.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
 {
     AVFrame *src = &srcp->f;
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
     int i;
     int ret = av_frame_ref(dst, src);
     if (ret < 0)
@@ -11,9 +12,9 @@
     if (!srcp->crop)
         return 0;
 
-    for (i = 0; i < 3; i++) {
-        int hshift = (i > 0) ? h->chroma_x_shift : 0;
-        int vshift = (i > 0) ? h->chroma_y_shift : 0;
+    for (i = 0; i < desc->nb_components; i++) {
+        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
+        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
         int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                       (srcp->crop_top  >> vshift) * dst->linesize[i];
         dst->data[i] += off;","{'deleted_lines': ['    for (i = 0; i < 3; i++) {', '        int hshift = (i > 0) ? h->chroma_x_shift : 0;', '        int vshift = (i > 0) ? h->chroma_y_shift : 0;'], 'added_lines': ['    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);', '    for (i = 0; i < desc->nb_components; i++) {', '        int hshift = (i > 0) ? desc->log2_chroma_w : 0;', '        int vshift = (i > 0) ? desc->log2_chroma_h : 0;']}",True,"A vulnerability, which was classified as problematic, has been found in FFmpeg 2.0. Affected by this issue is the function output_frame of the file libavcodec/h264.c. The manipulation leads to memory corruption. The attack may be launched remotely. It is recommended to apply a patch to fix this issue.",5.5,MEDIUM,1,valid,,5
CVE-2014-125010,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
avcodec/h264: more completely check the loop filter parameters

Fixes out of array read
Fixes: caa65cc01655505705129b677189f036-signal_sigsegv_fdcc43_2681_cov_3043376737_PPH422I5_Panasonic_A.264
Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",91253839e14cce9793ee93f184cef609ca8195d5,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=91253839e14cce9793ee93f184cef609ca8195d5,libavcodec/h264.c,decode_slice_header,"static int decode_slice_header(H264Context *h, H264Context *h0)
{
unsigned int first_mb_in_slice;
unsigned int pps_id;
int ret;
unsigned int slice_type, tmp, i, j;
int last_pic_structure, last_pic_droppable;
int must_reinit;
int needs_reinit = 0;
int field_pic_flag, bottom_field_flag;
h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;
h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;
first_mb_in_slice = get_ue_golomb_long(&h->gb);
if (first_mb_in_slice == 0) {         if (h0->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {
field_end(h, 1);
}
h0->current_slice = 0;
if (!h0->first_field) {
if (h->cur_pic_ptr && !h->droppable) {
ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
h->picture_structure == PICT_BOTTOM_FIELD);
}
h->cur_pic_ptr = NULL;
}
}
slice_type = get_ue_golomb_31(&h->gb);
if (slice_type > 9) {
av_log(h->avctx, AV_LOG_ERROR,
""slice type %d too large at %d %d\n"",
slice_type, h->mb_x, h->mb_y);
return AVERROR_INVALIDDATA;
}
if (slice_type > 4) {
slice_type -= 5;
h->slice_type_fixed = 1;
} else
h->slice_type_fixed = 0;
slice_type = golomb_to_pict_type[slice_type];
h->slice_type     = slice_type;
h->slice_type_nos = slice_type & 3;
if (h->nal_unit_type  == NAL_IDR_SLICE &&
h->slice_type_nos != AV_PICTURE_TYPE_I) {
av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n"");
return AVERROR_INVALIDDATA;
}
h->pict_type = h->slice_type;
pps_id = get_ue_golomb(&h->gb);
if (pps_id >= MAX_PPS_COUNT) {
av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);
return AVERROR_INVALIDDATA;
}
if (!h0->pps_buffers[pps_id]) {
av_log(h->avctx, AV_LOG_ERROR,
""non-existing PPS %u referenced\n"",
pps_id);
return AVERROR_INVALIDDATA;
}
if (h0->au_pps_id >= 0 && pps_id != h0->au_pps_id) {
av_log(h->avctx, AV_LOG_ERROR,
""PPS change from %d to %d forbidden\n"",
h0->au_pps_id, pps_id);
return AVERROR_INVALIDDATA;
}
h->pps = *h0->pps_buffers[pps_id];
if (!h0->sps_buffers[h->pps.sps_id]) {
av_log(h->avctx, AV_LOG_ERROR,
""non-existing SPS %u referenced\n"",
h->pps.sps_id);
return AVERROR_INVALIDDATA;
}
if (h->pps.sps_id != h->sps.sps_id ||
h->pps.sps_id != h->current_sps_id ||
h0->sps_buffers[h->pps.sps_id]->new) {
h->sps = *h0->sps_buffers[h->pps.sps_id];
if (h->mb_width  != h->sps.mb_width ||
h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||
h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||
h->cur_chroma_format_idc != h->sps.chroma_format_idc
)
needs_reinit = 1;
if (h->bit_depth_luma    != h->sps.bit_depth_luma ||
h->chroma_format_idc != h->sps.chroma_format_idc) {
h->bit_depth_luma    = h->sps.bit_depth_luma;
h->chroma_format_idc = h->sps.chroma_format_idc;
needs_reinit         = 1;
}
if ((ret = h264_set_parameter_from_sps(h)) < 0)
return ret;
}
h->avctx->profile = ff_h264_get_profile(&h->sps);
h->avctx->level   = h->sps.level_idc;
h->avctx->refs    = h->sps.ref_frame_count;
must_reinit = (h->context_initialized &&
(   16*h->sps.mb_width != h->avctx->coded_width
|| 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height
|| h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma
|| h->cur_chroma_format_idc != h->sps.chroma_format_idc
|| av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)
|| h->mb_width  != h->sps.mb_width
|| h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)
));
if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))
must_reinit = 1;
h->mb_width  = h->sps.mb_width;
h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);
h->mb_num    = h->mb_width * h->mb_height;
h->mb_stride = h->mb_width + 1;
h->b_stride = h->mb_width * 4;
h->chroma_y_shift = h->sps.chroma_format_idc <= 1; 
h->width  = 16 * h->mb_width;
h->height = 16 * h->mb_height;
ret = init_dimensions(h);
if (ret < 0)
return ret;
if (h->sps.video_signal_type_present_flag) {
h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG
: AVCOL_RANGE_MPEG;
if (h->sps.colour_description_present_flag) {
if (h->avctx->colorspace != h->sps.colorspace)
needs_reinit = 1;
h->avctx->color_primaries = h->sps.color_primaries;
h->avctx->color_trc       = h->sps.color_trc;
h->avctx->colorspace      = h->sps.colorspace;
}
}
if (h->context_initialized &&
(h->width  != h->avctx->coded_width   ||
h->height != h->avctx->coded_height  ||
must_reinit ||
needs_reinit)) {
if (h != h0) {
av_log(h->avctx, AV_LOG_ERROR, ""changing width/height on ""
""slice %d\n"", h0->current_slice + 1);
return AVERROR_INVALIDDATA;
}
flush_change(h);
if ((ret = get_pixel_format(h, 1)) < 0)
return ret;
h->avctx->pix_fmt = ret;
av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""
""pix_fmt: %s\n"", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));
if ((ret = h264_slice_header_init(h, 1)) < 0) {
av_log(h->avctx, AV_LOG_ERROR,
""h264_slice_header_init() failed\n"");
return ret;
}
}
if (!h->context_initialized) {
if (h != h0) {
av_log(h->avctx, AV_LOG_ERROR,
""Cannot (re-)initialize context during parallel decoding.\n"");
return AVERROR_PATCHWELCOME;
}
if ((ret = get_pixel_format(h, 1)) < 0)
return ret;
h->avctx->pix_fmt = ret;
if ((ret = h264_slice_header_init(h, 0)) < 0) {
av_log(h->avctx, AV_LOG_ERROR,
""h264_slice_header_init() failed\n"");
return ret;
}
}
if (h == h0 && h->dequant_coeff_pps != pps_id) {
h->dequant_coeff_pps = pps_id;
init_dequant_tables(h);
}
h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);
h->mb_mbaff        = 0;
h->mb_aff_frame    = 0;
last_pic_structure = h0->picture_structure;
last_pic_droppable = h0->droppable;
h->droppable       = h->nal_ref_idc == 0;
if (h->sps.frame_mbs_only_flag) {
h->picture_structure = PICT_FRAME;
} else {
if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {
av_log(h->avctx, AV_LOG_ERROR, ""This stream was generated by a broken encoder, invalid 8x8 inference\n"");
return -1;
}
field_pic_flag = get_bits1(&h->gb);
if (field_pic_flag) {
bottom_field_flag = get_bits1(&h->gb);
h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;
} else {
h->picture_structure = PICT_FRAME;
h->mb_aff_frame      = h->sps.mb_aff;
}
}
h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;
if (h0->current_slice != 0) {
if (last_pic_structure != h->picture_structure ||
last_pic_droppable != h->droppable) {
av_log(h->avctx, AV_LOG_ERROR,
""Changing field mode (%d -> %d) between slices is not allowed\n"",
last_pic_structure, h->picture_structure);
h->picture_structure = last_pic_structure;
h->droppable         = last_pic_droppable;
return AVERROR_INVALIDDATA;
} else if (!h0->cur_pic_ptr) {
av_log(h->avctx, AV_LOG_ERROR,
""unset cur_pic_ptr on slice %d\n"",
h0->current_slice + 1);
return AVERROR_INVALIDDATA;
}
} else {
if (h->frame_num != h->prev_frame_num) {
int unwrap_prev_frame_num = h->prev_frame_num;
int max_frame_num         = 1 << h->sps.log2_max_frame_num;
if (unwrap_prev_frame_num > h->frame_num)
unwrap_prev_frame_num -= max_frame_num;
if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {
unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;
if (unwrap_prev_frame_num < 0)
unwrap_prev_frame_num += max_frame_num;
h->prev_frame_num = unwrap_prev_frame_num;
}
}
if (h0->first_field) {
assert(h0->cur_pic_ptr);
assert(h0->cur_pic_ptr->f.buf[0]);
assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);
if (h0->cur_pic_ptr->tf.owner == h0->avctx) {
ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
last_pic_structure == PICT_BOTTOM_FIELD);
}
if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
if (last_pic_structure != PICT_FRAME) {
ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
last_pic_structure == PICT_TOP_FIELD);
}
} else {
if (h0->cur_pic_ptr->frame_num != h->frame_num) {
if (last_pic_structure != PICT_FRAME) {
ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
last_pic_structure == PICT_TOP_FIELD);
}
} else {
if (!((last_pic_structure   == PICT_TOP_FIELD &&
h->picture_structure == PICT_BOTTOM_FIELD) ||
(last_pic_structure   == PICT_BOTTOM_FIELD &&
h->picture_structure == PICT_TOP_FIELD))) {
av_log(h->avctx, AV_LOG_ERROR,
""Invalid field mode combination %d/%d\n"",
last_pic_structure, h->picture_structure);
h->picture_structure = last_pic_structure;
h->droppable         = last_pic_droppable;
return AVERROR_INVALIDDATA;
} else if (last_pic_droppable != h->droppable) {
avpriv_request_sample(h->avctx,
""Found reference and non-reference fields in the same frame, which"");
h->picture_structure = last_pic_structure;
h->droppable         = last_pic_droppable;
return AVERROR_PATCHWELCOME;
}
}
}
}
while (h->frame_num != h->prev_frame_num && !h0->first_field &&
h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {
Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",
h->frame_num, h->prev_frame_num);
if (!h->sps.gaps_in_frame_num_allowed_flag)
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)
h->last_pocs[i] = INT_MIN;
ret = h264_frame_start(h);
if (ret < 0) {
h0->first_field = 0;
return ret;
}
h->prev_frame_num++;
h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;
h->cur_pic_ptr->frame_num = h->prev_frame_num;
ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);
ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);
ret = ff_generate_sliding_window_mmcos(h, 1);
if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
return ret;
ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
return ret;
if (h->short_ref_count) {
if (prev) {
av_image_copy(h->short_ref[0]->f.data,
h->short_ref[0]->f.linesize,
(const uint8_t **)prev->f.data,
prev->f.linesize,
h->avctx->pix_fmt,
h->mb_width  * 16,
h->mb_height * 16);
h->short_ref[0]->poc = prev->poc + 2;
}
h->short_ref[0]->frame_num = h->prev_frame_num;
}
}
if (h0->first_field) {
assert(h0->cur_pic_ptr);
assert(h0->cur_pic_ptr->f.buf[0]);
assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);
if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
h0->cur_pic_ptr = NULL;
h0->first_field = FIELD_PICTURE(h);
} else {
if (h0->cur_pic_ptr->frame_num != h->frame_num) {
ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
h0->picture_structure==PICT_BOTTOM_FIELD);
h0->first_field = 1;
h0->cur_pic_ptr = NULL;
} else {
h0->first_field = 0;
}
}
} else {
h0->first_field = FIELD_PICTURE(h);
}
if (!FIELD_PICTURE(h) || h0->first_field) {
if (h264_frame_start(h) < 0) {
h0->first_field = 0;
return AVERROR_INVALIDDATA;
}
} else {
release_unused_pictures(h, 0);
}
if (FIELD_PICTURE(h)) {
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)
memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));
} else {
memset(h->slice_table, -1,
(h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
}
h0->last_slice_type = -1;
}
if (h != h0 && (ret = clone_slice(h, h0)) < 0)
return ret;
for (i = 0; i < h->slice_context_count; i++)
if (h->thread_context[i]) {
ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);
if (ret < 0)
return ret;
}
h->cur_pic_ptr->frame_num = h->frame_num; 
av_assert1(h->mb_num == h->mb_width * h->mb_height);
if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||
first_mb_in_slice >= h->mb_num) {
av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");
return AVERROR_INVALIDDATA;
}
h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;
h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<
FIELD_OR_MBAFF_PICTURE(h);
if (h->picture_structure == PICT_BOTTOM_FIELD)
h->resync_mb_y = h->mb_y = h->mb_y + 1;
av_assert1(h->mb_y < h->mb_height);
if (h->picture_structure == PICT_FRAME) {
h->curr_pic_num = h->frame_num;
h->max_pic_num  = 1 << h->sps.log2_max_frame_num;
} else {
h->curr_pic_num = 2 * h->frame_num + 1;
h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);
}
if (h->nal_unit_type == NAL_IDR_SLICE)
get_ue_golomb(&h->gb); 
if (h->sps.poc_type == 0) {
h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);
if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
h->delta_poc_bottom = get_se_golomb(&h->gb);
}
if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {
h->delta_poc[0] = get_se_golomb(&h->gb);
if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
h->delta_poc[1] = get_se_golomb(&h->gb);
}
ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);
if (h->pps.redundant_pic_cnt_present)
h->redundant_pic_count = get_ue_golomb(&h->gb);
ret = ff_set_ref_count(h);
if (ret < 0)
return ret;
if (slice_type != AV_PICTURE_TYPE_I &&
(h0->current_slice == 0 ||
slice_type != h0->last_slice_type ||
memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {
ff_h264_fill_default_ref_list(h);
}
if (h->slice_type_nos != AV_PICTURE_TYPE_I) {
ret = ff_h264_decode_ref_pic_list_reordering(h);
if (ret < 0) {
h->ref_count[1] = h->ref_count[0] = 0;
return ret;
}
}
if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||
(h->pps.weighted_bipred_idc == 1 &&
h->slice_type_nos == AV_PICTURE_TYPE_B))
ff_pred_weight_table(h);
else if (h->pps.weighted_bipred_idc == 2 &&
h->slice_type_nos == AV_PICTURE_TYPE_B) {
implicit_weight_table(h, -1);
} else {
h->use_weight = 0;
for (i = 0; i < 2; i++) {
h->luma_weight_flag[i]   = 0;
h->chroma_weight_flag[i] = 0;
}
}
if (h->nal_ref_idc) {
ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,
!(h->avctx->active_thread_type & FF_THREAD_FRAME) ||
h0->current_slice == 0);
if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
return AVERROR_INVALIDDATA;
}
if (FRAME_MBAFF(h)) {
ff_h264_fill_mbaff_ref_list(h);
if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {
implicit_weight_table(h, 0);
implicit_weight_table(h, 1);
}
}
if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)
ff_h264_direct_dist_scale_factor(h);
ff_h264_direct_ref_list_init(h);
if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {
tmp = get_ue_golomb_31(&h->gb);
if (tmp > 2) {
av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp);
return AVERROR_INVALIDDATA;
}
h->cabac_init_idc = tmp;
}
h->last_qscale_diff = 0;
tmp = h->pps.init_qp + get_se_golomb(&h->gb);
if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {
av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);
return AVERROR_INVALIDDATA;
}
h->qscale       = tmp;
h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);
h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);
if (h->slice_type == AV_PICTURE_TYPE_SP)
get_bits1(&h->gb); 
if (h->slice_type == AV_PICTURE_TYPE_SP ||
h->slice_type == AV_PICTURE_TYPE_SI)
get_se_golomb(&h->gb); 
h->deblocking_filter     = 1;
h->slice_alpha_c0_offset = 52;
h->slice_beta_offset     = 52;
if (h->pps.deblocking_filter_parameters_present) {
tmp = get_ue_golomb_31(&h->gb);
if (tmp > 2) {
av_log(h->avctx, AV_LOG_ERROR,
""deblocking_filter_idc %u out of range\n"", tmp);
return AVERROR_INVALIDDATA;
}
h->deblocking_filter = tmp;
if (h->deblocking_filter < 2)
h->deblocking_filter ^= 1;  
if (h->deblocking_filter) {
h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;
h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;
if (h->slice_alpha_c0_offset > 104U ||
h->slice_beta_offset     > 104U) {
av_log(h->avctx, AV_LOG_ERROR,
""deblocking filter parameters %d %d out of range\n"",
h->slice_alpha_c0_offset, h->slice_beta_offset);
return AVERROR_INVALIDDATA;
}
}
}
if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||
(h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&
h->slice_type_nos != AV_PICTURE_TYPE_I) ||
(h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&
h->slice_type_nos == AV_PICTURE_TYPE_B) ||
(h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&
h->nal_ref_idc == 0))
h->deblocking_filter = 0;
if (h->deblocking_filter == 1 && h0->max_contexts > 1) {
if (h->avctx->flags2 & CODEC_FLAG2_FAST) {
h->deblocking_filter = 2;
} else {
h0->max_contexts = 1;
if (!h0->single_decode_warning) {
av_log(h->avctx, AV_LOG_INFO,
""Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"");
h0->single_decode_warning = 1;
}
if (h != h0) {
av_log(h->avctx, AV_LOG_ERROR,
""Deblocking switched inside frame.\n"");
return 1;
}
}
}
h->qp_thresh = 15 + 52 -
FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -
FFMAX3(0,
h->pps.chroma_qp_index_offset[0],
h->pps.chroma_qp_index_offset[1]) +
6 * (h->sps.bit_depth_luma - 8);
h0->last_slice_type = slice_type;
memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));
h->slice_num        = ++h0->current_slice;
if (h->slice_num)
h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;
if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y
&& h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y
&& h->slice_num >= MAX_SLICES) {
av_log(h->avctx, AV_LOG_WARNING, ""Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n"", h->slice_num, MAX_SLICES);
}
for (j = 0; j < 2; j++) {
int id_list[16];
int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];
for (i = 0; i < 16; i++) {
id_list[i] = 60;
if (j < h->list_count && i < h->ref_count[j] &&
h->ref_list[j][i].f.buf[0]) {
int k;
AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;
for (k = 0; k < h->short_ref_count; k++)
if (h->short_ref[k]->f.buf[0]->buffer == buf) {
id_list[i] = k;
break;
}
for (k = 0; k < h->long_ref_count; k++)
if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {
id_list[i] = h->short_ref_count + k;
break;
}
}
}
ref2frm[0] =
ref2frm[1] = -1;
for (i = 0; i < 16; i++)
ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);
ref2frm[18 + 0] =
ref2frm[18 + 1] = -1;
for (i = 16; i < 48; i++)
ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +
(h->ref_list[j][i].reference & 3);
}
if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];
if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];
h->er.ref_count = h->ref_count[0];
h0->au_pps_id = pps_id;
h->sps.new =
h0->sps_buffers[h->pps.sps_id]->new = 0;
h->current_sps_id = h->pps.sps_id;
if (h->avctx->debug & FF_DEBUG_PICT_INFO) {
av_log(h->avctx, AV_LOG_DEBUG,
""slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n"",
h->slice_num,
(h->picture_structure == PICT_FRAME ? ""F"" : h->picture_structure == PICT_TOP_FIELD ? ""T"" : ""B""),
first_mb_in_slice,
av_get_picture_type_char(h->slice_type),
h->slice_type_fixed ? "" fix"" : """",
h->nal_unit_type == NAL_IDR_SLICE ? "" IDR"" : """",
pps_id, h->frame_num,
h->cur_pic_ptr->field_poc[0],
h->cur_pic_ptr->field_poc[1],
h->ref_count[0], h->ref_count[1],
h->qscale,
h->deblocking_filter,
h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,
h->use_weight,
h->use_weight == 1 && h->use_weight_chroma ? ""c"" : """",
h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"") : """");
}
return 0;
}","static int decode_slice_header(H264Context *VAR_0, H264Context *VAR_1)
{
unsigned int VAR_2;
unsigned int VAR_3;
int VAR_4;
unsigned int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
int VAR_11;
int VAR_12 = 0;
int VAR_13, VAR_14;
VAR_0->me.qpel_put = VAR_0->h264qpel.put_h264_qpel_pixels_tab;
VAR_0->me.qpel_avg = VAR_0->h264qpel.avg_h264_qpel_pixels_tab;
VAR_2 = get_ue_golomb_long(&VAR_0->gb);
if (VAR_2 == 0) { 
if (VAR_1->current_slice && VAR_0->cur_pic_ptr && FIELD_PICTURE(VAR_0)) {
field_end(VAR_0, 1);
}
VAR_1->current_slice = 0;
if (!VAR_1->first_field) {
if (VAR_0->cur_pic_ptr && !VAR_0->droppable) {
ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15,
VAR_0->picture_structure == VAR_16);
}
VAR_0->cur_pic_ptr = NULL;
}
}
VAR_5 = get_ue_golomb_31(&VAR_0->gb);
if (VAR_5 > 9) {
av_log(VAR_0->avctx, VAR_17,
""slice type %d too large at %d %d\n"",
VAR_5, VAR_0->mb_x, VAR_0->mb_y);
return VAR_18;
}
if (VAR_5 > 4) {
VAR_5 -= 5;
VAR_0->slice_type_fixed = 1;
} else
VAR_0->slice_type_fixed = 0;
VAR_5 = VAR_19[VAR_5];
VAR_0->slice_type     = VAR_5;
VAR_0->slice_type_nos = VAR_5 & 3;
if (VAR_0->nal_unit_type  == VAR_20 &&
VAR_0->slice_type_nos != VAR_21) {
av_log(VAR_0->avctx, VAR_17, ""A non-intra slice in an IDR NAL unit.\n"");
return VAR_18;
}
VAR_0->pict_type = VAR_0->slice_type;
VAR_3 = get_ue_golomb(&VAR_0->gb);
if (VAR_3 >= VAR_22) {
av_log(VAR_0->avctx, VAR_17, ""pps_id %u out of range\n"", VAR_3);
return VAR_18;
}
if (!VAR_1->pps_buffers[VAR_3]) {
av_log(VAR_0->avctx, VAR_17,
""non-existing PPS %u referenced\n"",
VAR_3);
return VAR_18;
}
if (VAR_1->au_pps_id >= 0 && VAR_3 != VAR_1->au_pps_id) {
av_log(VAR_0->avctx, VAR_17,
""PPS change from %d to %d forbidden\n"",
VAR_1->au_pps_id, VAR_3);
return VAR_18;
}
VAR_0->pps = *VAR_1->pps_buffers[VAR_3];
if (!VAR_1->sps_buffers[VAR_0->pps.sps_id]) {
av_log(VAR_0->avctx, VAR_17,
""non-existing SPS %u referenced\n"",
VAR_0->pps.sps_id);
return VAR_18;
}
if (VAR_0->pps.sps_id != VAR_0->sps.sps_id ||
VAR_0->pps.sps_id != VAR_0->current_sps_id ||
VAR_1->sps_buffers[VAR_0->pps.sps_id]->new) {
VAR_0->sps = *VAR_1->sps_buffers[VAR_0->pps.sps_id];
if (VAR_0->mb_width  != VAR_0->sps.mb_width ||
VAR_0->mb_height != VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag) ||
VAR_0->avctx->bits_per_raw_sample != VAR_0->sps.bit_depth_luma ||
VAR_0->cur_chroma_format_idc != VAR_0->sps.chroma_format_idc
)
VAR_12 = 1;
if (VAR_0->bit_depth_luma    != VAR_0->sps.bit_depth_luma ||
VAR_0->chroma_format_idc != VAR_0->sps.chroma_format_idc) {
VAR_0->bit_depth_luma    = VAR_0->sps.bit_depth_luma;
VAR_0->chroma_format_idc = VAR_0->sps.chroma_format_idc;
VAR_12         = 1;
}
if ((VAR_4 = h264_set_parameter_from_sps(VAR_0)) < 0)
return VAR_4;
}
VAR_0->avctx->profile = ff_h264_get_profile(&VAR_0->sps);
VAR_0->avctx->level   = VAR_0->sps.level_idc;
VAR_0->avctx->refs    = VAR_0->sps.ref_frame_count;
VAR_11 = (VAR_0->context_initialized &&
(   16*VAR_0->sps.mb_width != VAR_0->avctx->coded_width
|| 16*VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag) != VAR_0->avctx->coded_height
|| VAR_0->avctx->bits_per_raw_sample != VAR_0->sps.bit_depth_luma
|| VAR_0->cur_chroma_format_idc != VAR_0->sps.chroma_format_idc
|| av_cmp_q(VAR_0->sps.sar, VAR_0->avctx->sample_aspect_ratio)
|| VAR_0->mb_width  != VAR_0->sps.mb_width
|| VAR_0->mb_height != VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag)
));
if (VAR_1->avctx->pix_fmt != get_pixel_format(VAR_1, 0))
VAR_11 = 1;
VAR_0->mb_width  = VAR_0->sps.mb_width;
VAR_0->mb_height = VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag);
VAR_0->mb_num    = VAR_0->mb_width * VAR_0->mb_height;
VAR_0->mb_stride = VAR_0->mb_width + 1;
VAR_0->b_stride = VAR_0->mb_width * 4;
VAR_0->chroma_y_shift = VAR_0->sps.chroma_format_idc <= 1; 
VAR_0->width  = 16 * VAR_0->mb_width;
VAR_0->height = 16 * VAR_0->mb_height;
VAR_4 = init_dimensions(VAR_0);
if (VAR_4 < 0)
return VAR_4;
if (VAR_0->sps.video_signal_type_present_flag) {
VAR_0->avctx->color_range = VAR_0->sps.full_range>0 ? VAR_23
: VAR_24;
if (VAR_0->sps.colour_description_present_flag) {
if (VAR_0->avctx->colorspace != VAR_0->sps.colorspace)
VAR_12 = 1;
VAR_0->avctx->color_primaries = VAR_0->sps.color_primaries;
VAR_0->avctx->color_trc       = VAR_0->sps.color_trc;
VAR_0->avctx->colorspace      = VAR_0->sps.colorspace;
}
}
if (VAR_0->context_initialized &&
(VAR_0->width  != VAR_0->avctx->coded_width   ||
VAR_0->height != VAR_0->avctx->coded_height  ||
VAR_11 ||
VAR_12)) {
if (VAR_0 != VAR_1) {
av_log(VAR_0->avctx, VAR_17, ""changing width/height on ""
""slice %d\n"", VAR_1->current_slice + 1);
return VAR_18;
}
flush_change(VAR_0);
if ((VAR_4 = get_pixel_format(VAR_0, 1)) < 0)
return VAR_4;
VAR_0->avctx->pix_fmt = VAR_4;
av_log(VAR_0->avctx, VAR_25, ""Reinit context to %dx%d, ""
""pix_fmt: %s\n"", VAR_0->width, VAR_0->height, av_get_pix_fmt_name(VAR_0->avctx->pix_fmt));
if ((VAR_4 = h264_slice_header_init(VAR_0, 1)) < 0) {
av_log(VAR_0->avctx, VAR_17,
""h264_slice_header_init() failed\n"");
return VAR_4;
}
}
if (!VAR_0->context_initialized) {
if (VAR_0 != VAR_1) {
av_log(VAR_0->avctx, VAR_17,
""Cannot (re-)initialize context during parallel decoding.\n"");
return VAR_26;
}
if ((VAR_4 = get_pixel_format(VAR_0, 1)) < 0)
return VAR_4;
VAR_0->avctx->pix_fmt = VAR_4;
if ((VAR_4 = h264_slice_header_init(VAR_0, 0)) < 0) {
av_log(VAR_0->avctx, VAR_17,
""h264_slice_header_init() failed\n"");
return VAR_4;
}
}
if (VAR_0 == VAR_1 && VAR_0->dequant_coeff_pps != VAR_3) {
VAR_0->dequant_coeff_pps = VAR_3;
init_dequant_tables(VAR_0);
}
VAR_0->frame_num = get_bits(&VAR_0->gb, VAR_0->sps.log2_max_frame_num);
VAR_0->mb_mbaff        = 0;
VAR_0->mb_aff_frame    = 0;
VAR_9 = VAR_1->picture_structure;
VAR_10 = VAR_1->droppable;
VAR_0->droppable       = VAR_0->nal_ref_idc == 0;
if (VAR_0->sps.frame_mbs_only_flag) {
VAR_0->picture_structure = VAR_27;
} else {
if (!VAR_0->sps.direct_8x8_inference_flag && VAR_5 == VAR_28) {
av_log(VAR_0->avctx, VAR_17, ""This stream was generated by a broken encoder, invalid 8x8 inference\n"");
return -1;
}
VAR_13 = get_bits1(&VAR_0->gb);
if (VAR_13) {
VAR_14 = get_bits1(&VAR_0->gb);
VAR_0->picture_structure = VAR_29 + VAR_14;
} else {
VAR_0->picture_structure = VAR_27;
VAR_0->mb_aff_frame      = VAR_0->sps.mb_aff;
}
}
VAR_0->mb_field_decoding_flag = VAR_0->picture_structure != VAR_27;
if (VAR_1->current_slice != 0) {
if (VAR_9 != VAR_0->picture_structure ||
VAR_10 != VAR_0->droppable) {
av_log(VAR_0->avctx, VAR_17,
""Changing field mode (%d -> %d) between slices is not allowed\n"",
VAR_9, VAR_0->picture_structure);
VAR_0->picture_structure = VAR_9;
VAR_0->droppable         = VAR_10;
return VAR_18;
} else if (!VAR_1->cur_pic_ptr) {
av_log(VAR_0->avctx, VAR_17,
""unset cur_pic_ptr on slice %d\n"",
VAR_1->current_slice + 1);
return VAR_18;
}
} else {
if (VAR_0->frame_num != VAR_0->prev_frame_num) {
int VAR_30 = VAR_0->prev_frame_num;
int VAR_31         = 1 << VAR_0->sps.log2_max_frame_num;
if (VAR_30 > VAR_0->frame_num)
VAR_30 -= VAR_31;
if ((VAR_0->frame_num - VAR_30) > VAR_0->sps.ref_frame_count) {
VAR_30 = (VAR_0->frame_num - VAR_0->sps.ref_frame_count) - 1;
if (VAR_30 < 0)
VAR_30 += VAR_31;
VAR_0->prev_frame_num = VAR_30;
}
}
if (VAR_1->first_field) {
assert(VAR_1->cur_pic_ptr);
assert(VAR_1->cur_pic_ptr->f.buf[0]);
assert(VAR_1->cur_pic_ptr->reference != VAR_32);
if (VAR_1->cur_pic_ptr->tf.owner == VAR_1->avctx) {
ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
VAR_9 == VAR_16);
}
if (!FIELD_PICTURE(VAR_0) || VAR_0->picture_structure == VAR_9) {
if (VAR_9 != VAR_27) {
ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
VAR_9 == VAR_29);
}
} else {
if (VAR_1->cur_pic_ptr->frame_num != VAR_0->frame_num) {
if (VAR_9 != VAR_27) {
ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
VAR_9 == VAR_29);
}
} else {
if (!((VAR_9   == VAR_29 &&
VAR_0->picture_structure == VAR_16) ||
(VAR_9   == VAR_16 &&
VAR_0->picture_structure == VAR_29))) {
av_log(VAR_0->avctx, VAR_17,
""Invalid field mode combination %d/%d\n"",
VAR_9, VAR_0->picture_structure);
VAR_0->picture_structure = VAR_9;
VAR_0->droppable         = VAR_10;
return VAR_18;
} else if (VAR_10 != VAR_0->droppable) {
avpriv_request_sample(VAR_0->avctx,
""Found reference and non-reference fields in the same frame, which"");
VAR_0->picture_structure = VAR_9;
VAR_0->droppable         = VAR_10;
return VAR_26;
}
}
}
}
while (VAR_0->frame_num != VAR_0->prev_frame_num && !VAR_1->first_field &&
VAR_0->frame_num != (VAR_0->prev_frame_num + 1) % (1 << VAR_0->sps.log2_max_frame_num)) {
Picture *VAR_33 = VAR_0->short_ref_count ? VAR_0->short_ref[0] : NULL;
av_log(VAR_0->avctx, VAR_34, ""Frame num gap %d %d\n"",
VAR_0->frame_num, VAR_0->prev_frame_num);
if (!VAR_0->sps.gaps_in_frame_num_allowed_flag)
for(VAR_7=0; VAR_7<FF_ARRAY_ELEMS(VAR_0->last_pocs); VAR_7++)
VAR_0->last_pocs[VAR_7] = VAR_35;
VAR_4 = h264_frame_start(VAR_0);
if (VAR_4 < 0) {
VAR_1->first_field = 0;
return VAR_4;
}
VAR_0->prev_frame_num++;
VAR_0->prev_frame_num        %= 1 << VAR_0->sps.log2_max_frame_num;
VAR_0->cur_pic_ptr->frame_num = VAR_0->prev_frame_num;
ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15, 0);
ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15, 1);
VAR_4 = ff_generate_sliding_window_mmcos(VAR_0, 1);
if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
return VAR_4;
VAR_4 = ff_h264_execute_ref_pic_marking(VAR_0, VAR_0->mmco, VAR_0->mmco_index);
if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
return VAR_4;
if (VAR_0->short_ref_count) {
if (VAR_33) {
av_image_copy(VAR_0->short_ref[0]->f.data,
VAR_0->short_ref[0]->f.linesize,
(const uint8_t **)VAR_33->f.data,
VAR_33->f.linesize,
VAR_0->avctx->pix_fmt,
VAR_0->mb_width  * 16,
VAR_0->mb_height * 16);
VAR_0->short_ref[0]->poc = VAR_33->poc + 2;
}
VAR_0->short_ref[0]->frame_num = VAR_0->prev_frame_num;
}
}
if (VAR_1->first_field) {
assert(VAR_1->cur_pic_ptr);
assert(VAR_1->cur_pic_ptr->f.buf[0]);
assert(VAR_1->cur_pic_ptr->reference != VAR_32);
if (!FIELD_PICTURE(VAR_0) || VAR_0->picture_structure == VAR_9) {
VAR_1->cur_pic_ptr = NULL;
VAR_1->first_field = FIELD_PICTURE(VAR_0);
} else {
if (VAR_1->cur_pic_ptr->frame_num != VAR_0->frame_num) {
ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
VAR_1->picture_structure==VAR_16);
VAR_1->first_field = 1;
VAR_1->cur_pic_ptr = NULL;
} else {
VAR_1->first_field = 0;
}
}
} else {
VAR_1->first_field = FIELD_PICTURE(VAR_0);
}
if (!FIELD_PICTURE(VAR_0) || VAR_1->first_field) {
if (h264_frame_start(VAR_0) < 0) {
VAR_1->first_field = 0;
return VAR_18;
}
} else {
release_unused_pictures(VAR_0, 0);
}
if (FIELD_PICTURE(VAR_0)) {
for(VAR_7 = (VAR_0->picture_structure == VAR_16); VAR_7<VAR_0->mb_height; VAR_7++)
memset(VAR_0->slice_table + VAR_7*VAR_0->mb_stride, -1, (VAR_0->mb_stride - (VAR_7+1==VAR_0->mb_height)) * sizeof(*VAR_0->slice_table));
} else {
memset(VAR_0->slice_table, -1,
(VAR_0->mb_height * VAR_0->mb_stride - 1) * sizeof(*VAR_0->slice_table));
}
VAR_1->last_slice_type = -1;
}
if (VAR_0 != VAR_1 && (VAR_4 = clone_slice(VAR_0, VAR_1)) < 0)
return VAR_4;
for (VAR_7 = 0; VAR_7 < VAR_0->slice_context_count; VAR_7++)
if (VAR_0->thread_context[VAR_7]) {
VAR_4 = alloc_scratch_buffers(VAR_0->thread_context[VAR_7], VAR_0->linesize);
if (VAR_4 < 0)
return VAR_4;
}
VAR_0->cur_pic_ptr->frame_num = VAR_0->frame_num; 
av_assert1(VAR_0->mb_num == VAR_0->mb_width * VAR_0->mb_height);
if (VAR_2 << FIELD_OR_MBAFF_PICTURE(VAR_0) >= VAR_0->mb_num ||
VAR_2 >= VAR_0->mb_num) {
av_log(VAR_0->avctx, VAR_17, ""first_mb_in_slice overflow\n"");
return VAR_18;
}
VAR_0->resync_mb_x = VAR_0->mb_x =  VAR_2 % VAR_0->mb_width;
VAR_0->resync_mb_y = VAR_0->mb_y = (VAR_2 / VAR_0->mb_width) <<
FIELD_OR_MBAFF_PICTURE(VAR_0);
if (VAR_0->picture_structure == VAR_16)
VAR_0->resync_mb_y = VAR_0->mb_y = VAR_0->mb_y + 1;
av_assert1(VAR_0->mb_y < VAR_0->mb_height);
if (VAR_0->picture_structure == VAR_27) {
VAR_0->curr_pic_num = VAR_0->frame_num;
VAR_0->max_pic_num  = 1 << VAR_0->sps.log2_max_frame_num;
} else {
VAR_0->curr_pic_num = 2 * VAR_0->frame_num + 1;
VAR_0->max_pic_num  = 1 << (VAR_0->sps.log2_max_frame_num + 1);
}
if (VAR_0->nal_unit_type == VAR_20)
get_ue_golomb(&VAR_0->gb); 
if (VAR_0->sps.poc_type == 0) {
VAR_0->poc_lsb = get_bits(&VAR_0->gb, VAR_0->sps.log2_max_poc_lsb);
if (VAR_0->pps.pic_order_present == 1 && VAR_0->picture_structure == VAR_27)
VAR_0->delta_poc_bottom = get_se_golomb(&VAR_0->gb);
}
if (VAR_0->sps.poc_type == 1 && !VAR_0->sps.delta_pic_order_always_zero_flag) {
VAR_0->delta_poc[0] = get_se_golomb(&VAR_0->gb);
if (VAR_0->pps.pic_order_present == 1 && VAR_0->picture_structure == VAR_27)
VAR_0->delta_poc[1] = get_se_golomb(&VAR_0->gb);
}
ff_init_poc(VAR_0, VAR_0->cur_pic_ptr->field_poc, &VAR_0->cur_pic_ptr->poc);
if (VAR_0->pps.redundant_pic_cnt_present)
VAR_0->redundant_pic_count = get_ue_golomb(&VAR_0->gb);
VAR_4 = ff_set_ref_count(VAR_0);
if (VAR_4 < 0)
return VAR_4;
if (VAR_5 != VAR_21 &&
(VAR_1->current_slice == 0 ||
VAR_5 != VAR_1->last_slice_type ||
memcmp(VAR_1->last_ref_count, VAR_1->ref_count, sizeof(VAR_1->ref_count)))) {
ff_h264_fill_default_ref_list(VAR_0);
}
if (VAR_0->slice_type_nos != VAR_21) {
VAR_4 = ff_h264_decode_ref_pic_list_reordering(VAR_0);
if (VAR_4 < 0) {
VAR_0->ref_count[1] = VAR_0->ref_count[0] = 0;
return VAR_4;
}
}
if ((VAR_0->pps.weighted_pred && VAR_0->slice_type_nos == VAR_37) ||
(VAR_0->pps.weighted_bipred_idc == 1 &&
VAR_0->slice_type_nos == VAR_28))
ff_pred_weight_table(VAR_0);
else if (VAR_0->pps.weighted_bipred_idc == 2 &&
VAR_0->slice_type_nos == VAR_28) {
implicit_weight_table(VAR_0, -1);
} else {
VAR_0->use_weight = 0;
for (VAR_7 = 0; VAR_7 < 2; VAR_7++) {
VAR_0->luma_weight_flag[VAR_7]   = 0;
VAR_0->chroma_weight_flag[VAR_7] = 0;
}
}
if (VAR_0->nal_ref_idc) {
VAR_4 = ff_h264_decode_ref_pic_marking(VAR_1, &VAR_0->gb,
!(VAR_0->avctx->active_thread_type & VAR_38) ||
VAR_1->current_slice == 0);
if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
return VAR_18;
}
if (FRAME_MBAFF(VAR_0)) {
ff_h264_fill_mbaff_ref_list(VAR_0);
if (VAR_0->pps.weighted_bipred_idc == 2 && VAR_0->slice_type_nos == VAR_28) {
implicit_weight_table(VAR_0, 0);
implicit_weight_table(VAR_0, 1);
}
}
if (VAR_0->slice_type_nos == VAR_28 && !VAR_0->direct_spatial_mv_pred)
ff_h264_direct_dist_scale_factor(VAR_0);
ff_h264_direct_ref_list_init(VAR_0);
if (VAR_0->slice_type_nos != VAR_21 && VAR_0->pps.cabac) {
VAR_6 = get_ue_golomb_31(&VAR_0->gb);
if (VAR_6 > 2) {
av_log(VAR_0->avctx, VAR_17, ""cabac_init_idc %u overflow\n"", VAR_6);
return VAR_18;
}
VAR_0->cabac_init_idc = VAR_6;
}
VAR_0->last_qscale_diff = 0;
VAR_6 = VAR_0->pps.init_qp + get_se_golomb(&VAR_0->gb);
if (VAR_6 > 51 + 6 * (VAR_0->sps.bit_depth_luma - 8)) {
av_log(VAR_0->avctx, VAR_17, ""QP %u out of range\n"", VAR_6);
return VAR_18;
}
VAR_0->qscale       = VAR_6;
VAR_0->chroma_qp[0] = get_chroma_qp(VAR_0, 0, VAR_0->qscale);
VAR_0->chroma_qp[1] = get_chroma_qp(VAR_0, 1, VAR_0->qscale);
if (VAR_0->slice_type == VAR_39)
get_bits1(&VAR_0->gb); 
if (VAR_0->slice_type == VAR_39 ||
VAR_0->slice_type == VAR_40)
get_se_golomb(&VAR_0->gb); 
VAR_0->deblocking_filter     = 1;
VAR_0->slice_alpha_c0_offset = 52;
VAR_0->slice_beta_offset     = 52;
if (VAR_0->pps.deblocking_filter_parameters_present) {
VAR_6 = get_ue_golomb_31(&VAR_0->gb);
if (VAR_6 > 2) {
av_log(VAR_0->avctx, VAR_17,
""deblocking_filter_idc %u out of range\n"", VAR_6);
return VAR_18;
}
VAR_0->deblocking_filter = VAR_6;
if (VAR_0->deblocking_filter < 2)
VAR_0->deblocking_filter ^= 1;  
if (VAR_0->deblocking_filter) {
VAR_0->slice_alpha_c0_offset += get_se_golomb(&VAR_0->gb) << 1;
VAR_0->slice_beta_offset     += get_se_golomb(&VAR_0->gb) << 1;
if (VAR_0->slice_alpha_c0_offset > 104U ||
VAR_0->slice_beta_offset     > 104U) {
av_log(VAR_0->avctx, VAR_17,
""deblocking filter parameters %d %d out of range\n"",
VAR_0->slice_alpha_c0_offset, VAR_0->slice_beta_offset);
return VAR_18;
}
}
}
if (VAR_0->avctx->skip_loop_filter >= VAR_41 ||
(VAR_0->avctx->skip_loop_filter >= VAR_42 &&
VAR_0->slice_type_nos != VAR_21) ||
(VAR_0->avctx->skip_loop_filter >= VAR_43  &&
VAR_0->slice_type_nos == VAR_28) ||
(VAR_0->avctx->skip_loop_filter >= VAR_44 &&
VAR_0->nal_ref_idc == 0))
VAR_0->deblocking_filter = 0;
if (VAR_0->deblocking_filter == 1 && VAR_1->max_contexts > 1) {
if (VAR_0->avctx->flags2 & VAR_45) {
VAR_0->deblocking_filter = 2;
} else {
VAR_1->max_contexts = 1;
if (!VAR_1->single_decode_warning) {
av_log(VAR_0->avctx, VAR_25,
""Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"");
VAR_1->single_decode_warning = 1;
}
if (VAR_0 != VAR_1) {
av_log(VAR_0->avctx, VAR_17,
""Deblocking switched inside frame.\n"");
return 1;
}
}
}
VAR_0->qp_thresh = 15 + 52 -
FFMIN(VAR_0->slice_alpha_c0_offset, VAR_0->slice_beta_offset) -
FFMAX3(0,
VAR_0->pps.chroma_qp_index_offset[0],
VAR_0->pps.chroma_qp_index_offset[1]) +
6 * (VAR_0->sps.bit_depth_luma - 8);
VAR_1->last_slice_type = VAR_5;
memcpy(VAR_1->last_ref_count, VAR_1->ref_count, sizeof(VAR_1->last_ref_count));
VAR_0->slice_num        = ++VAR_1->current_slice;
if (VAR_0->slice_num)
VAR_1->slice_row[(VAR_0->slice_num-1)&(VAR_46-1)]= VAR_0->resync_mb_y;
if (   VAR_1->slice_row[VAR_0->slice_num&(VAR_46-1)] + 3 >= VAR_0->resync_mb_y
&& VAR_1->slice_row[VAR_0->slice_num&(VAR_46-1)] <= VAR_0->resync_mb_y
&& VAR_0->slice_num >= VAR_46) {
av_log(VAR_0->avctx, VAR_47, ""Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n"", VAR_0->slice_num, VAR_46);
}
for (VAR_8 = 0; VAR_8 < 2; VAR_8++) {
int VAR_48[16];
int *VAR_49 = VAR_0->ref2frm[VAR_0->slice_num & (VAR_46 - 1)][VAR_8];
for (VAR_7 = 0; VAR_7 < 16; VAR_7++) {
VAR_48[VAR_7] = 60;
if (VAR_8 < VAR_0->list_count && VAR_7 < VAR_0->ref_count[VAR_8] &&
VAR_0->ref_list[VAR_8][VAR_7].f.buf[0]) {
int VAR_50;
AVBuffer *VAR_51 = VAR_0->ref_list[VAR_8][VAR_7].f.buf[0]->buffer;
for (VAR_50 = 0; VAR_50 < VAR_0->short_ref_count; VAR_50++)
if (VAR_0->short_ref[VAR_50]->f.buf[0]->buffer == VAR_51) {
VAR_48[VAR_7] = VAR_50;
break;
}
for (VAR_50 = 0; VAR_50 < VAR_0->long_ref_count; VAR_50++)
if (VAR_0->long_ref[VAR_50] && VAR_0->long_ref[VAR_50]->f.buf[0]->buffer == VAR_51) {
VAR_48[VAR_7] = VAR_0->short_ref_count + VAR_50;
break;
}
}
}
VAR_49[0] =
VAR_49[1] = -1;
for (VAR_7 = 0; VAR_7 < 16; VAR_7++)
VAR_49[VAR_7 + 2] = 4 * VAR_48[VAR_7] + (VAR_0->ref_list[VAR_8][VAR_7].reference & 3);
VAR_49[18 + 0] =
VAR_49[18 + 1] = -1;
for (VAR_7 = 16; VAR_7 < 48; VAR_7++)
VAR_49[VAR_7 + 4] = 4 * VAR_48[(VAR_7 - 16) >> 1] +
(VAR_0->ref_list[VAR_8][VAR_7].reference & 3);
}
if (VAR_0->ref_count[0]) VAR_0->er.last_pic = &VAR_0->ref_list[0][0];
if (VAR_0->ref_count[1]) VAR_0->er.next_pic = &VAR_0->ref_list[1][0];
VAR_0->er.ref_count = VAR_0->ref_count[0];
VAR_1->au_pps_id = VAR_3;
VAR_0->sps.new =
VAR_1->sps_buffers[VAR_0->pps.sps_id]->new = 0;
VAR_0->current_sps_id = VAR_0->pps.sps_id;
if (VAR_0->avctx->debug & VAR_52) {
av_log(VAR_0->avctx, VAR_34,
""slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n"",
VAR_0->slice_num,
(VAR_0->picture_structure == VAR_27 ? ""F"" : VAR_0->picture_structure == VAR_29 ? ""T"" : ""B""),
VAR_2,
av_get_picture_type_char(VAR_0->slice_type),
VAR_0->slice_type_fixed ? "" fix"" : """",
VAR_0->nal_unit_type == VAR_20 ? "" IDR"" : """",
VAR_3, VAR_0->frame_num,
VAR_0->cur_pic_ptr->field_poc[0],
VAR_0->cur_pic_ptr->field_poc[1],
VAR_0->ref_count[0], VAR_0->ref_count[1],
VAR_0->qscale,
VAR_0->deblocking_filter,
VAR_0->slice_alpha_c0_offset / 2 - 26, VAR_0->slice_beta_offset / 2 - 26,
VAR_0->use_weight,
VAR_0->use_weight == 1 && VAR_0->use_weight_chroma ? ""c"" : """",
VAR_0->slice_type == VAR_28 ? (VAR_0->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"") : """");
}
return 0;
}",ffmpeg/91253839e14cce9793ee93f184cef609ca8195d5/h264.c/vul/before/0.json,"static int decode_slice_header(H264Context *h, H264Context *h0)
{
    unsigned int first_mb_in_slice;
    unsigned int pps_id;
    int ret;
    unsigned int slice_type, tmp, i, j;
    int last_pic_structure, last_pic_droppable;
    int must_reinit;
    int needs_reinit = 0;
    int field_pic_flag, bottom_field_flag;

    h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;
    h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;

    first_mb_in_slice = get_ue_golomb_long(&h->gb);

    if (first_mb_in_slice == 0) { // FIXME better field boundary detection
        if (h0->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {
            field_end(h, 1);
        }

        h0->current_slice = 0;
        if (!h0->first_field) {
            if (h->cur_pic_ptr && !h->droppable) {
                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
                                          h->picture_structure == PICT_BOTTOM_FIELD);
            }
            h->cur_pic_ptr = NULL;
        }
    }

    slice_type = get_ue_golomb_31(&h->gb);
    if (slice_type > 9) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""slice type %d too large at %d %d\n"",
               slice_type, h->mb_x, h->mb_y);
        return AVERROR_INVALIDDATA;
    }
    if (slice_type > 4) {
        slice_type -= 5;
        h->slice_type_fixed = 1;
    } else
        h->slice_type_fixed = 0;

    slice_type = golomb_to_pict_type[slice_type];
    h->slice_type     = slice_type;
    h->slice_type_nos = slice_type & 3;

    if (h->nal_unit_type  == NAL_IDR_SLICE &&
        h->slice_type_nos != AV_PICTURE_TYPE_I) {
        av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n"");
        return AVERROR_INVALIDDATA;
    }

    // to make a few old functions happy, it's wrong though
    h->pict_type = h->slice_type;

    pps_id = get_ue_golomb(&h->gb);
    if (pps_id >= MAX_PPS_COUNT) {
        av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (!h0->pps_buffers[pps_id]) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""non-existing PPS %u referenced\n"",
               pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (h0->au_pps_id >= 0 && pps_id != h0->au_pps_id) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""PPS change from %d to %d forbidden\n"",
               h0->au_pps_id, pps_id);
        return AVERROR_INVALIDDATA;
    }
    h->pps = *h0->pps_buffers[pps_id];

    if (!h0->sps_buffers[h->pps.sps_id]) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""non-existing SPS %u referenced\n"",
               h->pps.sps_id);
        return AVERROR_INVALIDDATA;
    }

    if (h->pps.sps_id != h->sps.sps_id ||
        h->pps.sps_id != h->current_sps_id ||
        h0->sps_buffers[h->pps.sps_id]->new) {

        h->sps = *h0->sps_buffers[h->pps.sps_id];

        if (h->mb_width  != h->sps.mb_width ||
            h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||
            h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||
            h->cur_chroma_format_idc != h->sps.chroma_format_idc
        )
            needs_reinit = 1;

        if (h->bit_depth_luma    != h->sps.bit_depth_luma ||
            h->chroma_format_idc != h->sps.chroma_format_idc) {
            h->bit_depth_luma    = h->sps.bit_depth_luma;
            h->chroma_format_idc = h->sps.chroma_format_idc;
            needs_reinit         = 1;
        }
        if ((ret = h264_set_parameter_from_sps(h)) < 0)
            return ret;
    }

    h->avctx->profile = ff_h264_get_profile(&h->sps);
    h->avctx->level   = h->sps.level_idc;
    h->avctx->refs    = h->sps.ref_frame_count;

    must_reinit = (h->context_initialized &&
                    (   16*h->sps.mb_width != h->avctx->coded_width
                     || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height
                     || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma
                     || h->cur_chroma_format_idc != h->sps.chroma_format_idc
                     || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)
                     || h->mb_width  != h->sps.mb_width
                     || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)
                    ));
    if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))
        must_reinit = 1;

    h->mb_width  = h->sps.mb_width;
    h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);
    h->mb_num    = h->mb_width * h->mb_height;
    h->mb_stride = h->mb_width + 1;

    h->b_stride = h->mb_width * 4;

    h->chroma_y_shift = h->sps.chroma_format_idc <= 1; // 400 uses yuv420p

    h->width  = 16 * h->mb_width;
    h->height = 16 * h->mb_height;

    ret = init_dimensions(h);
    if (ret < 0)
        return ret;

    if (h->sps.video_signal_type_present_flag) {
        h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG
                                                    : AVCOL_RANGE_MPEG;
        if (h->sps.colour_description_present_flag) {
            if (h->avctx->colorspace != h->sps.colorspace)
                needs_reinit = 1;
            h->avctx->color_primaries = h->sps.color_primaries;
            h->avctx->color_trc       = h->sps.color_trc;
            h->avctx->colorspace      = h->sps.colorspace;
        }
    }

    if (h->context_initialized &&
        (h->width  != h->avctx->coded_width   ||
         h->height != h->avctx->coded_height  ||
         must_reinit ||
         needs_reinit)) {
        if (h != h0) {
            av_log(h->avctx, AV_LOG_ERROR, ""changing width/height on ""
                   ""slice %d\n"", h0->current_slice + 1);
            return AVERROR_INVALIDDATA;
        }

        flush_change(h);

        if ((ret = get_pixel_format(h, 1)) < 0)
            return ret;
        h->avctx->pix_fmt = ret;

        av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""
               ""pix_fmt: %s\n"", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));

        if ((ret = h264_slice_header_init(h, 1)) < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""h264_slice_header_init() failed\n"");
            return ret;
        }
    }
    if (!h->context_initialized) {
        if (h != h0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""Cannot (re-)initialize context during parallel decoding.\n"");
            return AVERROR_PATCHWELCOME;
        }

        if ((ret = get_pixel_format(h, 1)) < 0)
            return ret;
        h->avctx->pix_fmt = ret;

        if ((ret = h264_slice_header_init(h, 0)) < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""h264_slice_header_init() failed\n"");
            return ret;
        }
    }

    if (h == h0 && h->dequant_coeff_pps != pps_id) {
        h->dequant_coeff_pps = pps_id;
        init_dequant_tables(h);
    }

    h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);

    h->mb_mbaff        = 0;
    h->mb_aff_frame    = 0;
    last_pic_structure = h0->picture_structure;
    last_pic_droppable = h0->droppable;
    h->droppable       = h->nal_ref_idc == 0;
    if (h->sps.frame_mbs_only_flag) {
        h->picture_structure = PICT_FRAME;
    } else {
        if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {
            av_log(h->avctx, AV_LOG_ERROR, ""This stream was generated by a broken encoder, invalid 8x8 inference\n"");
            return -1;
        }
        field_pic_flag = get_bits1(&h->gb);
        if (field_pic_flag) {
            bottom_field_flag = get_bits1(&h->gb);
            h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;
        } else {
            h->picture_structure = PICT_FRAME;
            h->mb_aff_frame      = h->sps.mb_aff;
        }
    }
    h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;

    if (h0->current_slice != 0) {
        if (last_pic_structure != h->picture_structure ||
            last_pic_droppable != h->droppable) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""Changing field mode (%d -> %d) between slices is not allowed\n"",
                   last_pic_structure, h->picture_structure);
            h->picture_structure = last_pic_structure;
            h->droppable         = last_pic_droppable;
            return AVERROR_INVALIDDATA;
        } else if (!h0->cur_pic_ptr) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""unset cur_pic_ptr on slice %d\n"",
                   h0->current_slice + 1);
            return AVERROR_INVALIDDATA;
        }
    } else {
        /* Shorten frame num gaps so we don't have to allocate reference
         * frames just to throw them away */
        if (h->frame_num != h->prev_frame_num) {
            int unwrap_prev_frame_num = h->prev_frame_num;
            int max_frame_num         = 1 << h->sps.log2_max_frame_num;

            if (unwrap_prev_frame_num > h->frame_num)
                unwrap_prev_frame_num -= max_frame_num;

            if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {
                unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;
                if (unwrap_prev_frame_num < 0)
                    unwrap_prev_frame_num += max_frame_num;

                h->prev_frame_num = unwrap_prev_frame_num;
            }
        }

        /* See if we have a decoded first field looking for a pair...
         * Here, we're using that to see if we should mark previously
         * decode frames as ""finished"".
         * We have to do that before the ""dummy"" in-between frame allocation,
         * since that can modify h->cur_pic_ptr. */
        if (h0->first_field) {
            assert(h0->cur_pic_ptr);
            assert(h0->cur_pic_ptr->f.buf[0]);
            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);

            /* Mark old field/frame as completed */
            if (h0->cur_pic_ptr->tf.owner == h0->avctx) {
                ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                          last_pic_structure == PICT_BOTTOM_FIELD);
            }

            /* figure out if we have a complementary field pair */
            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
                /* Previous field is unmatched. Don't display it, but let it
                 * remain for reference if marked as such. */
                if (last_pic_structure != PICT_FRAME) {
                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                              last_pic_structure == PICT_TOP_FIELD);
                }
            } else {
                if (h0->cur_pic_ptr->frame_num != h->frame_num) {
                    /* This and previous field were reference, but had
                     * different frame_nums. Consider this field first in
                     * pair. Throw away previous field except for reference
                     * purposes. */
                    if (last_pic_structure != PICT_FRAME) {
                        ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                                  last_pic_structure == PICT_TOP_FIELD);
                    }
                } else {
                    /* Second field in complementary pair */
                    if (!((last_pic_structure   == PICT_TOP_FIELD &&
                           h->picture_structure == PICT_BOTTOM_FIELD) ||
                          (last_pic_structure   == PICT_BOTTOM_FIELD &&
                           h->picture_structure == PICT_TOP_FIELD))) {
                        av_log(h->avctx, AV_LOG_ERROR,
                               ""Invalid field mode combination %d/%d\n"",
                               last_pic_structure, h->picture_structure);
                        h->picture_structure = last_pic_structure;
                        h->droppable         = last_pic_droppable;
                        return AVERROR_INVALIDDATA;
                    } else if (last_pic_droppable != h->droppable) {
                        avpriv_request_sample(h->avctx,
                                              ""Found reference and non-reference fields in the same frame, which"");
                        h->picture_structure = last_pic_structure;
                        h->droppable         = last_pic_droppable;
                        return AVERROR_PATCHWELCOME;
                    }
                }
            }
        }

        while (h->frame_num != h->prev_frame_num && !h0->first_field &&
               h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {
            Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
            av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",
                   h->frame_num, h->prev_frame_num);
            if (!h->sps.gaps_in_frame_num_allowed_flag)
                for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)
                    h->last_pocs[i] = INT_MIN;
            ret = h264_frame_start(h);
            if (ret < 0) {
                h0->first_field = 0;
                return ret;
            }

            h->prev_frame_num++;
            h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;
            h->cur_pic_ptr->frame_num = h->prev_frame_num;
            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);
            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);
            ret = ff_generate_sliding_window_mmcos(h, 1);
            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                return ret;
            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                return ret;
            /* Error concealment: If a ref is missing, copy the previous ref
             * in its place.
             * FIXME: Avoiding a memcpy would be nice, but ref handling makes
             * many assumptions about there being no actual duplicates.
             * FIXME: This does not copy padding for out-of-frame motion
             * vectors.  Given we are concealing a lost frame, this probably
             * is not noticeable by comparison, but it should be fixed. */
            if (h->short_ref_count) {
                if (prev) {
                    av_image_copy(h->short_ref[0]->f.data,
                                  h->short_ref[0]->f.linesize,
                                  (const uint8_t **)prev->f.data,
                                  prev->f.linesize,
                                  h->avctx->pix_fmt,
                                  h->mb_width  * 16,
                                  h->mb_height * 16);
                    h->short_ref[0]->poc = prev->poc + 2;
                }
                h->short_ref[0]->frame_num = h->prev_frame_num;
            }
        }

        /* See if we have a decoded first field looking for a pair...
         * We're using that to see whether to continue decoding in that
         * frame, or to allocate a new one. */
        if (h0->first_field) {
            assert(h0->cur_pic_ptr);
            assert(h0->cur_pic_ptr->f.buf[0]);
            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);

            /* figure out if we have a complementary field pair */
            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
                /* Previous field is unmatched. Don't display it, but let it
                 * remain for reference if marked as such. */
                h0->cur_pic_ptr = NULL;
                h0->first_field = FIELD_PICTURE(h);
            } else {
                if (h0->cur_pic_ptr->frame_num != h->frame_num) {
                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                              h0->picture_structure==PICT_BOTTOM_FIELD);
                    /* This and the previous field had different frame_nums.
                     * Consider this field first in pair. Throw away previous
                     * one except for reference purposes. */
                    h0->first_field = 1;
                    h0->cur_pic_ptr = NULL;
                } else {
                    /* Second field in complementary pair */
                    h0->first_field = 0;
                }
            }
        } else {
            /* Frame or first field in a potentially complementary pair */
            h0->first_field = FIELD_PICTURE(h);
        }

        if (!FIELD_PICTURE(h) || h0->first_field) {
            if (h264_frame_start(h) < 0) {
                h0->first_field = 0;
                return AVERROR_INVALIDDATA;
            }
        } else {
            release_unused_pictures(h, 0);
        }
        /* Some macroblocks can be accessed before they're available in case
        * of lost slices, MBAFF or threading. */
        if (FIELD_PICTURE(h)) {
            for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)
                memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));
        } else {
            memset(h->slice_table, -1,
                (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
        }
        h0->last_slice_type = -1;
    }
    if (h != h0 && (ret = clone_slice(h, h0)) < 0)
        return ret;

    /* can't be in alloc_tables because linesize isn't known there.
     * FIXME: redo bipred weight to not require extra buffer? */
    for (i = 0; i < h->slice_context_count; i++)
        if (h->thread_context[i]) {
            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);
            if (ret < 0)
                return ret;
        }

    h->cur_pic_ptr->frame_num = h->frame_num; // FIXME frame_num cleanup

    av_assert1(h->mb_num == h->mb_width * h->mb_height);
    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||
        first_mb_in_slice >= h->mb_num) {
        av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");
        return AVERROR_INVALIDDATA;
    }
    h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;
    h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<
                               FIELD_OR_MBAFF_PICTURE(h);
    if (h->picture_structure == PICT_BOTTOM_FIELD)
        h->resync_mb_y = h->mb_y = h->mb_y + 1;
    av_assert1(h->mb_y < h->mb_height);

    if (h->picture_structure == PICT_FRAME) {
        h->curr_pic_num = h->frame_num;
        h->max_pic_num  = 1 << h->sps.log2_max_frame_num;
    } else {
        h->curr_pic_num = 2 * h->frame_num + 1;
        h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);
    }

    if (h->nal_unit_type == NAL_IDR_SLICE)
        get_ue_golomb(&h->gb); /* idr_pic_id */

    if (h->sps.poc_type == 0) {
        h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);

        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
            h->delta_poc_bottom = get_se_golomb(&h->gb);
    }

    if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {
        h->delta_poc[0] = get_se_golomb(&h->gb);

        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
            h->delta_poc[1] = get_se_golomb(&h->gb);
    }

    ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);

    if (h->pps.redundant_pic_cnt_present)
        h->redundant_pic_count = get_ue_golomb(&h->gb);

    ret = ff_set_ref_count(h);
    if (ret < 0)
        return ret;

    if (slice_type != AV_PICTURE_TYPE_I &&
        (h0->current_slice == 0 ||
         slice_type != h0->last_slice_type ||
         memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {

        ff_h264_fill_default_ref_list(h);
    }

    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {
       ret = ff_h264_decode_ref_pic_list_reordering(h);
       if (ret < 0) {
           h->ref_count[1] = h->ref_count[0] = 0;
           return ret;
       }
    }

    if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||
        (h->pps.weighted_bipred_idc == 1 &&
         h->slice_type_nos == AV_PICTURE_TYPE_B))
        ff_pred_weight_table(h);
    else if (h->pps.weighted_bipred_idc == 2 &&
             h->slice_type_nos == AV_PICTURE_TYPE_B) {
        implicit_weight_table(h, -1);
    } else {
        h->use_weight = 0;
        for (i = 0; i < 2; i++) {
            h->luma_weight_flag[i]   = 0;
            h->chroma_weight_flag[i] = 0;
        }
    }

    // If frame-mt is enabled, only update mmco tables for the first slice
    // in a field. Subsequent slices can temporarily clobber h->mmco_index
    // or h->mmco, which will cause ref list mix-ups and decoding errors
    // further down the line. This may break decoding if the first slice is
    // corrupt, thus we only do this if frame-mt is enabled.
    if (h->nal_ref_idc) {
        ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,
                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||
                                             h0->current_slice == 0);
        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
            return AVERROR_INVALIDDATA;
    }

    if (FRAME_MBAFF(h)) {
        ff_h264_fill_mbaff_ref_list(h);

        if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {
            implicit_weight_table(h, 0);
            implicit_weight_table(h, 1);
        }
    }

    if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)
        ff_h264_direct_dist_scale_factor(h);
    ff_h264_direct_ref_list_init(h);

    if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {
        tmp = get_ue_golomb_31(&h->gb);
        if (tmp > 2) {
            av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp);
            return AVERROR_INVALIDDATA;
        }
        h->cabac_init_idc = tmp;
    }

    h->last_qscale_diff = 0;
    tmp = h->pps.init_qp + get_se_golomb(&h->gb);
    if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {
        av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);
        return AVERROR_INVALIDDATA;
    }
    h->qscale       = tmp;
    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);
    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);
    // FIXME qscale / qp ... stuff
    if (h->slice_type == AV_PICTURE_TYPE_SP)
        get_bits1(&h->gb); /* sp_for_switch_flag */
    if (h->slice_type == AV_PICTURE_TYPE_SP ||
        h->slice_type == AV_PICTURE_TYPE_SI)
        get_se_golomb(&h->gb); /* slice_qs_delta */

    h->deblocking_filter     = 1;
    h->slice_alpha_c0_offset = 52;
    h->slice_beta_offset     = 52;
    if (h->pps.deblocking_filter_parameters_present) {
        tmp = get_ue_golomb_31(&h->gb);
        if (tmp > 2) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""deblocking_filter_idc %u out of range\n"", tmp);
            return AVERROR_INVALIDDATA;
        }
        h->deblocking_filter = tmp;
        if (h->deblocking_filter < 2)
            h->deblocking_filter ^= 1;  // 1<->0

        if (h->deblocking_filter) {
            h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;
            h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;
            if (h->slice_alpha_c0_offset < 52 - 12 || h->slice_alpha_c0_offset > 52 + 12 ||
                h->slice_beta_offset     < 52 - 12 || h->slice_beta_offset     > 52 + 12) {
                av_log(h->avctx, AV_LOG_ERROR,
                       ""deblocking filter parameters %d %d out of range\n"",
                       h->slice_alpha_c0_offset, h->slice_beta_offset);
                return AVERROR_INVALIDDATA;
            }
        }
    }

    if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||
        (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&
         h->slice_type_nos != AV_PICTURE_TYPE_I) ||
        (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&
         h->slice_type_nos == AV_PICTURE_TYPE_B) ||
        (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&
         h->nal_ref_idc == 0))
        h->deblocking_filter = 0;

    if (h->deblocking_filter == 1 && h0->max_contexts > 1) {
        if (h->avctx->flags2 & CODEC_FLAG2_FAST) {
            /* Cheat slightly for speed:
             * Do not bother to deblock across slices. */
            h->deblocking_filter = 2;
        } else {
            h0->max_contexts = 1;
            if (!h0->single_decode_warning) {
                av_log(h->avctx, AV_LOG_INFO,
                       ""Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"");
                h0->single_decode_warning = 1;
            }
            if (h != h0) {
                av_log(h->avctx, AV_LOG_ERROR,
                       ""Deblocking switched inside frame.\n"");
                return 1;
            }
        }
    }
    h->qp_thresh = 15 + 52 -
                   FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -
                   FFMAX3(0,
                          h->pps.chroma_qp_index_offset[0],
                          h->pps.chroma_qp_index_offset[1]) +
                   6 * (h->sps.bit_depth_luma - 8);

    h0->last_slice_type = slice_type;
    memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));
    h->slice_num        = ++h0->current_slice;

    if (h->slice_num)
        h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;
    if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y
        && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y
        && h->slice_num >= MAX_SLICES) {
        //in case of ASO this check needs to be updated depending on how we decide to assign slice numbers in this case
        av_log(h->avctx, AV_LOG_WARNING, ""Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n"", h->slice_num, MAX_SLICES);
    }

    for (j = 0; j < 2; j++) {
        int id_list[16];
        int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];
        for (i = 0; i < 16; i++) {
            id_list[i] = 60;
            if (j < h->list_count && i < h->ref_count[j] &&
                h->ref_list[j][i].f.buf[0]) {
                int k;
                AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;
                for (k = 0; k < h->short_ref_count; k++)
                    if (h->short_ref[k]->f.buf[0]->buffer == buf) {
                        id_list[i] = k;
                        break;
                    }
                for (k = 0; k < h->long_ref_count; k++)
                    if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {
                        id_list[i] = h->short_ref_count + k;
                        break;
                    }
            }
        }

        ref2frm[0] =
        ref2frm[1] = -1;
        for (i = 0; i < 16; i++)
            ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);
        ref2frm[18 + 0] =
        ref2frm[18 + 1] = -1;
        for (i = 16; i < 48; i++)
            ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +
                             (h->ref_list[j][i].reference & 3);
    }

    if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];
    if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];
    h->er.ref_count = h->ref_count[0];
    h0->au_pps_id = pps_id;
    h->sps.new =
    h0->sps_buffers[h->pps.sps_id]->new = 0;
    h->current_sps_id = h->pps.sps_id;

    if (h->avctx->debug & FF_DEBUG_PICT_INFO) {
        av_log(h->avctx, AV_LOG_DEBUG,
               ""slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n"",
               h->slice_num,
               (h->picture_structure == PICT_FRAME ? ""F"" : h->picture_structure == PICT_TOP_FIELD ? ""T"" : ""B""),
               first_mb_in_slice,
               av_get_picture_type_char(h->slice_type),
               h->slice_type_fixed ? "" fix"" : """",
               h->nal_unit_type == NAL_IDR_SLICE ? "" IDR"" : """",
               pps_id, h->frame_num,
               h->cur_pic_ptr->field_poc[0],
               h->cur_pic_ptr->field_poc[1],
               h->ref_count[0], h->ref_count[1],
               h->qscale,
               h->deblocking_filter,
               h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,
               h->use_weight,
               h->use_weight == 1 && h->use_weight_chroma ? ""c"" : """",
               h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"") : """");
    }

    return 0;
}","static int decode_slice_header(H264Context *VAR_0, H264Context *VAR_1)
{
    unsigned int VAR_2;
    unsigned int VAR_3;
    int VAR_4;
    unsigned int VAR_5, VAR_6, VAR_7, VAR_8;
    int VAR_9, VAR_10;
    int VAR_11;
    int VAR_12 = 0;
    int VAR_13, VAR_14;

    VAR_0->me.qpel_put = VAR_0->h264qpel.put_h264_qpel_pixels_tab;
    VAR_0->me.qpel_avg = VAR_0->h264qpel.avg_h264_qpel_pixels_tab;

    VAR_2 = get_ue_golomb_long(&VAR_0->gb);

    if (VAR_2 == 0) { /* COMMENT_0 */
        if (VAR_1->current_slice && VAR_0->cur_pic_ptr && FIELD_PICTURE(VAR_0)) {
            field_end(VAR_0, 1);
        }

        VAR_1->current_slice = 0;
        if (!VAR_1->first_field) {
            if (VAR_0->cur_pic_ptr && !VAR_0->droppable) {
                ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15,
                                          VAR_0->picture_structure == VAR_16);
            }
            VAR_0->cur_pic_ptr = NULL;
        }
    }

    VAR_5 = get_ue_golomb_31(&VAR_0->gb);
    if (VAR_5 > 9) {
        av_log(VAR_0->avctx, VAR_17,
               ""slice type %d too large at %d %d\n"",
               VAR_5, VAR_0->mb_x, VAR_0->mb_y);
        return VAR_18;
    }
    if (VAR_5 > 4) {
        VAR_5 -= 5;
        VAR_0->slice_type_fixed = 1;
    } else
        VAR_0->slice_type_fixed = 0;

    VAR_5 = VAR_19[VAR_5];
    VAR_0->slice_type     = VAR_5;
    VAR_0->slice_type_nos = VAR_5 & 3;

    if (VAR_0->nal_unit_type  == VAR_20 &&
        VAR_0->slice_type_nos != VAR_21) {
        av_log(VAR_0->avctx, VAR_17, ""A non-intra slice in an IDR NAL unit.\n"");
        return VAR_18;
    }

    /* COMMENT_1 */
    VAR_0->pict_type = VAR_0->slice_type;

    VAR_3 = get_ue_golomb(&VAR_0->gb);
    if (VAR_3 >= VAR_22) {
        av_log(VAR_0->avctx, VAR_17, ""pps_id %u out of range\n"", VAR_3);
        return VAR_18;
    }
    if (!VAR_1->pps_buffers[VAR_3]) {
        av_log(VAR_0->avctx, VAR_17,
               ""non-existing PPS %u referenced\n"",
               VAR_3);
        return VAR_18;
    }
    if (VAR_1->au_pps_id >= 0 && VAR_3 != VAR_1->au_pps_id) {
        av_log(VAR_0->avctx, VAR_17,
               ""PPS change from %d to %d forbidden\n"",
               VAR_1->au_pps_id, VAR_3);
        return VAR_18;
    }
    VAR_0->pps = *VAR_1->pps_buffers[VAR_3];

    if (!VAR_1->sps_buffers[VAR_0->pps.sps_id]) {
        av_log(VAR_0->avctx, VAR_17,
               ""non-existing SPS %u referenced\n"",
               VAR_0->pps.sps_id);
        return VAR_18;
    }

    if (VAR_0->pps.sps_id != VAR_0->sps.sps_id ||
        VAR_0->pps.sps_id != VAR_0->current_sps_id ||
        VAR_1->sps_buffers[VAR_0->pps.sps_id]->new) {

        VAR_0->sps = *VAR_1->sps_buffers[VAR_0->pps.sps_id];

        if (VAR_0->mb_width  != VAR_0->sps.mb_width ||
            VAR_0->mb_height != VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag) ||
            VAR_0->avctx->bits_per_raw_sample != VAR_0->sps.bit_depth_luma ||
            VAR_0->cur_chroma_format_idc != VAR_0->sps.chroma_format_idc
        )
            VAR_12 = 1;

        if (VAR_0->bit_depth_luma    != VAR_0->sps.bit_depth_luma ||
            VAR_0->chroma_format_idc != VAR_0->sps.chroma_format_idc) {
            VAR_0->bit_depth_luma    = VAR_0->sps.bit_depth_luma;
            VAR_0->chroma_format_idc = VAR_0->sps.chroma_format_idc;
            VAR_12         = 1;
        }
        if ((VAR_4 = h264_set_parameter_from_sps(VAR_0)) < 0)
            return VAR_4;
    }

    VAR_0->avctx->profile = ff_h264_get_profile(&VAR_0->sps);
    VAR_0->avctx->level   = VAR_0->sps.level_idc;
    VAR_0->avctx->refs    = VAR_0->sps.ref_frame_count;

    VAR_11 = (VAR_0->context_initialized &&
                    (   16*VAR_0->sps.mb_width != VAR_0->avctx->coded_width
                     || 16*VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag) != VAR_0->avctx->coded_height
                     || VAR_0->avctx->bits_per_raw_sample != VAR_0->sps.bit_depth_luma
                     || VAR_0->cur_chroma_format_idc != VAR_0->sps.chroma_format_idc
                     || av_cmp_q(VAR_0->sps.sar, VAR_0->avctx->sample_aspect_ratio)
                     || VAR_0->mb_width  != VAR_0->sps.mb_width
                     || VAR_0->mb_height != VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag)
                    ));
    if (VAR_1->avctx->pix_fmt != get_pixel_format(VAR_1, 0))
        VAR_11 = 1;

    VAR_0->mb_width  = VAR_0->sps.mb_width;
    VAR_0->mb_height = VAR_0->sps.mb_height * (2 - VAR_0->sps.frame_mbs_only_flag);
    VAR_0->mb_num    = VAR_0->mb_width * VAR_0->mb_height;
    VAR_0->mb_stride = VAR_0->mb_width + 1;

    VAR_0->b_stride = VAR_0->mb_width * 4;

    VAR_0->chroma_y_shift = VAR_0->sps.chroma_format_idc <= 1; /* COMMENT_2 */

    VAR_0->width  = 16 * VAR_0->mb_width;
    VAR_0->height = 16 * VAR_0->mb_height;

    VAR_4 = init_dimensions(VAR_0);
    if (VAR_4 < 0)
        return VAR_4;

    if (VAR_0->sps.video_signal_type_present_flag) {
        VAR_0->avctx->color_range = VAR_0->sps.full_range>0 ? VAR_23
                                                    : VAR_24;
        if (VAR_0->sps.colour_description_present_flag) {
            if (VAR_0->avctx->colorspace != VAR_0->sps.colorspace)
                VAR_12 = 1;
            VAR_0->avctx->color_primaries = VAR_0->sps.color_primaries;
            VAR_0->avctx->color_trc       = VAR_0->sps.color_trc;
            VAR_0->avctx->colorspace      = VAR_0->sps.colorspace;
        }
    }

    if (VAR_0->context_initialized &&
        (VAR_0->width  != VAR_0->avctx->coded_width   ||
         VAR_0->height != VAR_0->avctx->coded_height  ||
         VAR_11 ||
         VAR_12)) {
        if (VAR_0 != VAR_1) {
            av_log(VAR_0->avctx, VAR_17, ""changing width/height on ""
                   ""slice %d\n"", VAR_1->current_slice + 1);
            return VAR_18;
        }

        flush_change(VAR_0);

        if ((VAR_4 = get_pixel_format(VAR_0, 1)) < 0)
            return VAR_4;
        VAR_0->avctx->pix_fmt = VAR_4;

        av_log(VAR_0->avctx, VAR_25, ""Reinit context to %dx%d, ""
               ""pix_fmt: %s\n"", VAR_0->width, VAR_0->height, av_get_pix_fmt_name(VAR_0->avctx->pix_fmt));

        if ((VAR_4 = h264_slice_header_init(VAR_0, 1)) < 0) {
            av_log(VAR_0->avctx, VAR_17,
                   ""h264_slice_header_init() failed\n"");
            return VAR_4;
        }
    }
    if (!VAR_0->context_initialized) {
        if (VAR_0 != VAR_1) {
            av_log(VAR_0->avctx, VAR_17,
                   ""Cannot (re-)initialize context during parallel decoding.\n"");
            return VAR_26;
        }

        if ((VAR_4 = get_pixel_format(VAR_0, 1)) < 0)
            return VAR_4;
        VAR_0->avctx->pix_fmt = VAR_4;

        if ((VAR_4 = h264_slice_header_init(VAR_0, 0)) < 0) {
            av_log(VAR_0->avctx, VAR_17,
                   ""h264_slice_header_init() failed\n"");
            return VAR_4;
        }
    }

    if (VAR_0 == VAR_1 && VAR_0->dequant_coeff_pps != VAR_3) {
        VAR_0->dequant_coeff_pps = VAR_3;
        init_dequant_tables(VAR_0);
    }

    VAR_0->frame_num = get_bits(&VAR_0->gb, VAR_0->sps.log2_max_frame_num);

    VAR_0->mb_mbaff        = 0;
    VAR_0->mb_aff_frame    = 0;
    VAR_9 = VAR_1->picture_structure;
    VAR_10 = VAR_1->droppable;
    VAR_0->droppable       = VAR_0->nal_ref_idc == 0;
    if (VAR_0->sps.frame_mbs_only_flag) {
        VAR_0->picture_structure = VAR_27;
    } else {
        if (!VAR_0->sps.direct_8x8_inference_flag && VAR_5 == VAR_28) {
            av_log(VAR_0->avctx, VAR_17, ""This stream was generated by a broken encoder, invalid 8x8 inference\n"");
            return -1;
        }
        VAR_13 = get_bits1(&VAR_0->gb);
        if (VAR_13) {
            VAR_14 = get_bits1(&VAR_0->gb);
            VAR_0->picture_structure = VAR_29 + VAR_14;
        } else {
            VAR_0->picture_structure = VAR_27;
            VAR_0->mb_aff_frame      = VAR_0->sps.mb_aff;
        }
    }
    VAR_0->mb_field_decoding_flag = VAR_0->picture_structure != VAR_27;

    if (VAR_1->current_slice != 0) {
        if (VAR_9 != VAR_0->picture_structure ||
            VAR_10 != VAR_0->droppable) {
            av_log(VAR_0->avctx, VAR_17,
                   ""Changing field mode (%d -> %d) between slices is not allowed\n"",
                   VAR_9, VAR_0->picture_structure);
            VAR_0->picture_structure = VAR_9;
            VAR_0->droppable         = VAR_10;
            return VAR_18;
        } else if (!VAR_1->cur_pic_ptr) {
            av_log(VAR_0->avctx, VAR_17,
                   ""unset cur_pic_ptr on slice %d\n"",
                   VAR_1->current_slice + 1);
            return VAR_18;
        }
    } else {
        /* COMMENT_3 */
                                            
        if (VAR_0->frame_num != VAR_0->prev_frame_num) {
            int VAR_30 = VAR_0->prev_frame_num;
            int VAR_31         = 1 << VAR_0->sps.log2_max_frame_num;

            if (VAR_30 > VAR_0->frame_num)
                VAR_30 -= VAR_31;

            if ((VAR_0->frame_num - VAR_30) > VAR_0->sps.ref_frame_count) {
                VAR_30 = (VAR_0->frame_num - VAR_0->sps.ref_frame_count) - 1;
                if (VAR_30 < 0)
                    VAR_30 += VAR_31;

                VAR_0->prev_frame_num = VAR_30;
            }
        }

        /* COMMENT_5 */
                                                                     
                                       
                                                                             
                                                   
        if (VAR_1->first_field) {
            assert(VAR_1->cur_pic_ptr);
            assert(VAR_1->cur_pic_ptr->f.buf[0]);
            assert(VAR_1->cur_pic_ptr->reference != VAR_32);

            /* COMMENT_10 */
            if (VAR_1->cur_pic_ptr->tf.owner == VAR_1->avctx) {
                ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
                                          VAR_9 == VAR_16);
            }

            /* COMMENT_11 */
            if (!FIELD_PICTURE(VAR_0) || VAR_0->picture_structure == VAR_9) {
                /* COMMENT_12 */
                                                             
                if (VAR_9 != VAR_27) {
                    ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
                                              VAR_9 == VAR_29);
                }
            } else {
                if (VAR_1->cur_pic_ptr->frame_num != VAR_0->frame_num) {
                    /* COMMENT_14 */
                                                                         
                                                                           
                                   
                    if (VAR_9 != VAR_27) {
                        ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
                                                  VAR_9 == VAR_29);
                    }
                } else {
                    /* COMMENT_18 */
                    if (!((VAR_9   == VAR_29 &&
                           VAR_0->picture_structure == VAR_16) ||
                          (VAR_9   == VAR_16 &&
                           VAR_0->picture_structure == VAR_29))) {
                        av_log(VAR_0->avctx, VAR_17,
                               ""Invalid field mode combination %d/%d\n"",
                               VAR_9, VAR_0->picture_structure);
                        VAR_0->picture_structure = VAR_9;
                        VAR_0->droppable         = VAR_10;
                        return VAR_18;
                    } else if (VAR_10 != VAR_0->droppable) {
                        avpriv_request_sample(VAR_0->avctx,
                                              ""Found reference and non-reference fields in the same frame, which"");
                        VAR_0->picture_structure = VAR_9;
                        VAR_0->droppable         = VAR_10;
                        return VAR_26;
                    }
                }
            }
        }

        while (VAR_0->frame_num != VAR_0->prev_frame_num && !VAR_1->first_field &&
               VAR_0->frame_num != (VAR_0->prev_frame_num + 1) % (1 << VAR_0->sps.log2_max_frame_num)) {
            Picture *VAR_33 = VAR_0->short_ref_count ? VAR_0->short_ref[0] : NULL;
            av_log(VAR_0->avctx, VAR_34, ""Frame num gap %d %d\n"",
                   VAR_0->frame_num, VAR_0->prev_frame_num);
            if (!VAR_0->sps.gaps_in_frame_num_allowed_flag)
                for(VAR_7=0; VAR_7<FF_ARRAY_ELEMS(VAR_0->last_pocs); VAR_7++)
                    VAR_0->last_pocs[VAR_7] = VAR_35;
            VAR_4 = h264_frame_start(VAR_0);
            if (VAR_4 < 0) {
                VAR_1->first_field = 0;
                return VAR_4;
            }

            VAR_0->prev_frame_num++;
            VAR_0->prev_frame_num        %= 1 << VAR_0->sps.log2_max_frame_num;
            VAR_0->cur_pic_ptr->frame_num = VAR_0->prev_frame_num;
            ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15, 0);
            ff_thread_report_progress(&VAR_0->cur_pic_ptr->tf, VAR_15, 1);
            VAR_4 = ff_generate_sliding_window_mmcos(VAR_0, 1);
            if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
                return VAR_4;
            VAR_4 = ff_h264_execute_ref_pic_marking(VAR_0, VAR_0->mmco, VAR_0->mmco_index);
            if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
                return VAR_4;
            /* COMMENT_19 */
                            
                                                                             
                                                                       
                                                                        
                                                                            
                                                                          
            if (VAR_0->short_ref_count) {
                if (VAR_33) {
                    av_image_copy(VAR_0->short_ref[0]->f.data,
                                  VAR_0->short_ref[0]->f.linesize,
                                  (const uint8_t **)VAR_33->f.data,
                                  VAR_33->f.linesize,
                                  VAR_0->avctx->pix_fmt,
                                  VAR_0->mb_width  * 16,
                                  VAR_0->mb_height * 16);
                    VAR_0->short_ref[0]->poc = VAR_33->poc + 2;
                }
                VAR_0->short_ref[0]->frame_num = VAR_0->prev_frame_num;
            }
        }

        /* COMMENT_26 */
                                                                       
                                              
        if (VAR_1->first_field) {
            assert(VAR_1->cur_pic_ptr);
            assert(VAR_1->cur_pic_ptr->f.buf[0]);
            assert(VAR_1->cur_pic_ptr->reference != VAR_32);

            /* COMMENT_11 */
            if (!FIELD_PICTURE(VAR_0) || VAR_0->picture_structure == VAR_9) {
                /* COMMENT_29 */
                                                             
                VAR_1->cur_pic_ptr = NULL;
                VAR_1->first_field = FIELD_PICTURE(VAR_0);
            } else {
                if (VAR_1->cur_pic_ptr->frame_num != VAR_0->frame_num) {
                    ff_thread_report_progress(&VAR_1->cur_pic_ptr->tf, VAR_15,
                                              VAR_1->picture_structure==VAR_16);
                    /* COMMENT_31 */
                                                                             
                                                            
                    VAR_1->first_field = 1;
                    VAR_1->cur_pic_ptr = NULL;
                } else {
                    /* COMMENT_18 */
                    VAR_1->first_field = 0;
                }
            }
        } else {
            /* COMMENT_34 */
            VAR_1->first_field = FIELD_PICTURE(VAR_0);
        }

        if (!FIELD_PICTURE(VAR_0) || VAR_1->first_field) {
            if (h264_frame_start(VAR_0) < 0) {
                VAR_1->first_field = 0;
                return VAR_18;
            }
        } else {
            release_unused_pictures(VAR_0, 0);
        }
        /* COMMENT_35 */
                                                
        if (FIELD_PICTURE(VAR_0)) {
            for(VAR_7 = (VAR_0->picture_structure == VAR_16); VAR_7<VAR_0->mb_height; VAR_7++)
                memset(VAR_0->slice_table + VAR_7*VAR_0->mb_stride, -1, (VAR_0->mb_stride - (VAR_7+1==VAR_0->mb_height)) * sizeof(*VAR_0->slice_table));
        } else {
            memset(VAR_0->slice_table, -1,
                (VAR_0->mb_height * VAR_0->mb_stride - 1) * sizeof(*VAR_0->slice_table));
        }
        VAR_1->last_slice_type = -1;
    }
    if (VAR_0 != VAR_1 && (VAR_4 = clone_slice(VAR_0, VAR_1)) < 0)
        return VAR_4;

    /* COMMENT_37 */
                                                                
    for (VAR_7 = 0; VAR_7 < VAR_0->slice_context_count; VAR_7++)
        if (VAR_0->thread_context[VAR_7]) {
            VAR_4 = alloc_scratch_buffers(VAR_0->thread_context[VAR_7], VAR_0->linesize);
            if (VAR_4 < 0)
                return VAR_4;
        }

    VAR_0->cur_pic_ptr->frame_num = VAR_0->frame_num; /* COMMENT_39 */

    av_assert1(VAR_0->mb_num == VAR_0->mb_width * VAR_0->mb_height);
    if (VAR_2 << FIELD_OR_MBAFF_PICTURE(VAR_0) >= VAR_0->mb_num ||
        VAR_2 >= VAR_0->mb_num) {
        av_log(VAR_0->avctx, VAR_17, ""first_mb_in_slice overflow\n"");
        return VAR_18;
    }
    VAR_0->resync_mb_x = VAR_0->mb_x =  VAR_2 % VAR_0->mb_width;
    VAR_0->resync_mb_y = VAR_0->mb_y = (VAR_2 / VAR_0->mb_width) <<
                               FIELD_OR_MBAFF_PICTURE(VAR_0);
    if (VAR_0->picture_structure == VAR_16)
        VAR_0->resync_mb_y = VAR_0->mb_y = VAR_0->mb_y + 1;
    av_assert1(VAR_0->mb_y < VAR_0->mb_height);

    if (VAR_0->picture_structure == VAR_27) {
        VAR_0->curr_pic_num = VAR_0->frame_num;
        VAR_0->max_pic_num  = 1 << VAR_0->sps.log2_max_frame_num;
    } else {
        VAR_0->curr_pic_num = 2 * VAR_0->frame_num + 1;
        VAR_0->max_pic_num  = 1 << (VAR_0->sps.log2_max_frame_num + 1);
    }

    if (VAR_0->nal_unit_type == VAR_20)
        get_ue_golomb(&VAR_0->gb); /* COMMENT_40 */

    if (VAR_0->sps.poc_type == 0) {
        VAR_0->poc_lsb = get_bits(&VAR_0->gb, VAR_0->sps.log2_max_poc_lsb);

        if (VAR_0->pps.pic_order_present == 1 && VAR_0->picture_structure == VAR_27)
            VAR_0->delta_poc_bottom = get_se_golomb(&VAR_0->gb);
    }

    if (VAR_0->sps.poc_type == 1 && !VAR_0->sps.delta_pic_order_always_zero_flag) {
        VAR_0->delta_poc[0] = get_se_golomb(&VAR_0->gb);

        if (VAR_0->pps.pic_order_present == 1 && VAR_0->picture_structure == VAR_27)
            VAR_0->delta_poc[1] = get_se_golomb(&VAR_0->gb);
    }

    ff_init_poc(VAR_0, VAR_0->cur_pic_ptr->field_poc, &VAR_0->cur_pic_ptr->poc);

    if (VAR_0->pps.redundant_pic_cnt_present)
        VAR_0->redundant_pic_count = get_ue_golomb(&VAR_0->gb);

    VAR_4 = ff_set_ref_count(VAR_0);
    if (VAR_4 < 0)
        return VAR_4;

    if (VAR_5 != VAR_21 &&
        (VAR_1->current_slice == 0 ||
         VAR_5 != VAR_1->last_slice_type ||
         memcmp(VAR_1->last_ref_count, VAR_1->ref_count, sizeof(VAR_1->ref_count)))) {

        ff_h264_fill_default_ref_list(VAR_0);
    }

    if (VAR_0->slice_type_nos != VAR_21) {
       VAR_4 = ff_h264_decode_ref_pic_list_reordering(VAR_0);
       if (VAR_4 < 0) {
           VAR_0->ref_count[1] = VAR_0->ref_count[0] = 0;
           return VAR_4;
       }
    }

    if ((VAR_0->pps.weighted_pred && VAR_0->slice_type_nos == VAR_37) ||
        (VAR_0->pps.weighted_bipred_idc == 1 &&
         VAR_0->slice_type_nos == VAR_28))
        ff_pred_weight_table(VAR_0);
    else if (VAR_0->pps.weighted_bipred_idc == 2 &&
             VAR_0->slice_type_nos == VAR_28) {
        implicit_weight_table(VAR_0, -1);
    } else {
        VAR_0->use_weight = 0;
        for (VAR_7 = 0; VAR_7 < 2; VAR_7++) {
            VAR_0->luma_weight_flag[VAR_7]   = 0;
            VAR_0->chroma_weight_flag[VAR_7] = 0;
        }
    }

    /* COMMENT_41 */
    /* COMMENT_42 */
    /* COMMENT_43 */
    /* COMMENT_44 */
    /* COMMENT_45 */
    if (VAR_0->nal_ref_idc) {
        VAR_4 = ff_h264_decode_ref_pic_marking(VAR_1, &VAR_0->gb,
                                             !(VAR_0->avctx->active_thread_type & VAR_38) ||
                                             VAR_1->current_slice == 0);
        if (VAR_4 < 0 && (VAR_0->avctx->err_recognition & VAR_36))
            return VAR_18;
    }

    if (FRAME_MBAFF(VAR_0)) {
        ff_h264_fill_mbaff_ref_list(VAR_0);

        if (VAR_0->pps.weighted_bipred_idc == 2 && VAR_0->slice_type_nos == VAR_28) {
            implicit_weight_table(VAR_0, 0);
            implicit_weight_table(VAR_0, 1);
        }
    }

    if (VAR_0->slice_type_nos == VAR_28 && !VAR_0->direct_spatial_mv_pred)
        ff_h264_direct_dist_scale_factor(VAR_0);
    ff_h264_direct_ref_list_init(VAR_0);

    if (VAR_0->slice_type_nos != VAR_21 && VAR_0->pps.cabac) {
        VAR_6 = get_ue_golomb_31(&VAR_0->gb);
        if (VAR_6 > 2) {
            av_log(VAR_0->avctx, VAR_17, ""cabac_init_idc %u overflow\n"", VAR_6);
            return VAR_18;
        }
        VAR_0->cabac_init_idc = VAR_6;
    }

    VAR_0->last_qscale_diff = 0;
    VAR_6 = VAR_0->pps.init_qp + get_se_golomb(&VAR_0->gb);
    if (VAR_6 > 51 + 6 * (VAR_0->sps.bit_depth_luma - 8)) {
        av_log(VAR_0->avctx, VAR_17, ""QP %u out of range\n"", VAR_6);
        return VAR_18;
    }
    VAR_0->qscale       = VAR_6;
    VAR_0->chroma_qp[0] = get_chroma_qp(VAR_0, 0, VAR_0->qscale);
    VAR_0->chroma_qp[1] = get_chroma_qp(VAR_0, 1, VAR_0->qscale);
    /* COMMENT_46 */
    if (VAR_0->slice_type == VAR_39)
        get_bits1(&VAR_0->gb); /* COMMENT_47 */
    if (VAR_0->slice_type == VAR_39 ||
        VAR_0->slice_type == VAR_40)
        get_se_golomb(&VAR_0->gb); /* COMMENT_48 */

    VAR_0->deblocking_filter     = 1;
    VAR_0->slice_alpha_c0_offset = 52;
    VAR_0->slice_beta_offset     = 52;
    if (VAR_0->pps.deblocking_filter_parameters_present) {
        VAR_6 = get_ue_golomb_31(&VAR_0->gb);
        if (VAR_6 > 2) {
            av_log(VAR_0->avctx, VAR_17,
                   ""deblocking_filter_idc %u out of range\n"", VAR_6);
            return VAR_18;
        }
        VAR_0->deblocking_filter = VAR_6;
        if (VAR_0->deblocking_filter < 2)
            VAR_0->deblocking_filter ^= 1;  /* COMMENT_49 */

        if (VAR_0->deblocking_filter) {
            VAR_0->slice_alpha_c0_offset += get_se_golomb(&VAR_0->gb) << 1;
            VAR_0->slice_beta_offset     += get_se_golomb(&VAR_0->gb) << 1;
            if (VAR_0->slice_alpha_c0_offset < 52 - 12 || VAR_0->slice_alpha_c0_offset > 52 + 12 ||
                VAR_0->slice_beta_offset     < 52 - 12 || VAR_0->slice_beta_offset     > 52 + 12) {
                av_log(VAR_0->avctx, VAR_17,
                       ""deblocking filter parameters %d %d out of range\n"",
                       VAR_0->slice_alpha_c0_offset, VAR_0->slice_beta_offset);
                return VAR_18;
            }
        }
    }

    if (VAR_0->avctx->skip_loop_filter >= VAR_41 ||
        (VAR_0->avctx->skip_loop_filter >= VAR_42 &&
         VAR_0->slice_type_nos != VAR_21) ||
        (VAR_0->avctx->skip_loop_filter >= VAR_43  &&
         VAR_0->slice_type_nos == VAR_28) ||
        (VAR_0->avctx->skip_loop_filter >= VAR_44 &&
         VAR_0->nal_ref_idc == 0))
        VAR_0->deblocking_filter = 0;

    if (VAR_0->deblocking_filter == 1 && VAR_1->max_contexts > 1) {
        if (VAR_0->avctx->flags2 & VAR_45) {
            /* COMMENT_50 */
                                                         
            VAR_0->deblocking_filter = 2;
        } else {
            VAR_1->max_contexts = 1;
            if (!VAR_1->single_decode_warning) {
                av_log(VAR_0->avctx, VAR_25,
                       ""Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"");
                VAR_1->single_decode_warning = 1;
            }
            if (VAR_0 != VAR_1) {
                av_log(VAR_0->avctx, VAR_17,
                       ""Deblocking switched inside frame.\n"");
                return 1;
            }
        }
    }
    VAR_0->qp_thresh = 15 + 52 -
                   FFMIN(VAR_0->slice_alpha_c0_offset, VAR_0->slice_beta_offset) -
                   FFMAX3(0,
                          VAR_0->pps.chroma_qp_index_offset[0],
                          VAR_0->pps.chroma_qp_index_offset[1]) +
                   6 * (VAR_0->sps.bit_depth_luma - 8);

    VAR_1->last_slice_type = VAR_5;
    memcpy(VAR_1->last_ref_count, VAR_1->ref_count, sizeof(VAR_1->last_ref_count));
    VAR_0->slice_num        = ++VAR_1->current_slice;

    if (VAR_0->slice_num)
        VAR_1->slice_row[(VAR_0->slice_num-1)&(VAR_46-1)]= VAR_0->resync_mb_y;
    if (   VAR_1->slice_row[VAR_0->slice_num&(VAR_46-1)] + 3 >= VAR_0->resync_mb_y
        && VAR_1->slice_row[VAR_0->slice_num&(VAR_46-1)] <= VAR_0->resync_mb_y
        && VAR_0->slice_num >= VAR_46) {
        /* COMMENT_52 */
        av_log(VAR_0->avctx, VAR_47, ""Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n"", VAR_0->slice_num, VAR_46);
    }

    for (VAR_8 = 0; VAR_8 < 2; VAR_8++) {
        int VAR_48[16];
        int *VAR_49 = VAR_0->ref2frm[VAR_0->slice_num & (VAR_46 - 1)][VAR_8];
        for (VAR_7 = 0; VAR_7 < 16; VAR_7++) {
            VAR_48[VAR_7] = 60;
            if (VAR_8 < VAR_0->list_count && VAR_7 < VAR_0->ref_count[VAR_8] &&
                VAR_0->ref_list[VAR_8][VAR_7].f.buf[0]) {
                int VAR_50;
                AVBuffer *VAR_51 = VAR_0->ref_list[VAR_8][VAR_7].f.buf[0]->buffer;
                for (VAR_50 = 0; VAR_50 < VAR_0->short_ref_count; VAR_50++)
                    if (VAR_0->short_ref[VAR_50]->f.buf[0]->buffer == VAR_51) {
                        VAR_48[VAR_7] = VAR_50;
                        break;
                    }
                for (VAR_50 = 0; VAR_50 < VAR_0->long_ref_count; VAR_50++)
                    if (VAR_0->long_ref[VAR_50] && VAR_0->long_ref[VAR_50]->f.buf[0]->buffer == VAR_51) {
                        VAR_48[VAR_7] = VAR_0->short_ref_count + VAR_50;
                        break;
                    }
            }
        }

        VAR_49[0] =
        VAR_49[1] = -1;
        for (VAR_7 = 0; VAR_7 < 16; VAR_7++)
            VAR_49[VAR_7 + 2] = 4 * VAR_48[VAR_7] + (VAR_0->ref_list[VAR_8][VAR_7].reference & 3);
        VAR_49[18 + 0] =
        VAR_49[18 + 1] = -1;
        for (VAR_7 = 16; VAR_7 < 48; VAR_7++)
            VAR_49[VAR_7 + 4] = 4 * VAR_48[(VAR_7 - 16) >> 1] +
                             (VAR_0->ref_list[VAR_8][VAR_7].reference & 3);
    }

    if (VAR_0->ref_count[0]) VAR_0->er.last_pic = &VAR_0->ref_list[0][0];
    if (VAR_0->ref_count[1]) VAR_0->er.next_pic = &VAR_0->ref_list[1][0];
    VAR_0->er.ref_count = VAR_0->ref_count[0];
    VAR_1->au_pps_id = VAR_3;
    VAR_0->sps.new =
    VAR_1->sps_buffers[VAR_0->pps.sps_id]->new = 0;
    VAR_0->current_sps_id = VAR_0->pps.sps_id;

    if (VAR_0->avctx->debug & VAR_52) {
        av_log(VAR_0->avctx, VAR_34,
               ""slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n"",
               VAR_0->slice_num,
               (VAR_0->picture_structure == VAR_27 ? ""F"" : VAR_0->picture_structure == VAR_29 ? ""T"" : ""B""),
               VAR_2,
               av_get_picture_type_char(VAR_0->slice_type),
               VAR_0->slice_type_fixed ? "" fix"" : """",
               VAR_0->nal_unit_type == VAR_20 ? "" IDR"" : """",
               VAR_3, VAR_0->frame_num,
               VAR_0->cur_pic_ptr->field_poc[0],
               VAR_0->cur_pic_ptr->field_poc[1],
               VAR_0->ref_count[0], VAR_0->ref_count[1],
               VAR_0->qscale,
               VAR_0->deblocking_filter,
               VAR_0->slice_alpha_c0_offset / 2 - 26, VAR_0->slice_beta_offset / 2 - 26,
               VAR_0->use_weight,
               VAR_0->use_weight == 1 && VAR_0->use_weight_chroma ? ""c"" : """",
               VAR_0->slice_type == VAR_28 ? (VAR_0->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"") : """");
    }

    return 0;
}",ffmpeg/91253839e14cce9793ee93f184cef609ca8195d5/h264.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -572,8 +572,8 @@
         if (h->deblocking_filter) {
             h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;
             h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;
-            if (h->slice_alpha_c0_offset > 104U ||
-                h->slice_beta_offset     > 104U) {
+            if (h->slice_alpha_c0_offset < 52 - 12 || h->slice_alpha_c0_offset > 52 + 12 ||
+                h->slice_beta_offset     < 52 - 12 || h->slice_beta_offset     > 52 + 12) {
                 av_log(h->avctx, AV_LOG_ERROR,
                        ""deblocking filter parameters %d %d out of range\n"",
                        h->slice_alpha_c0_offset, h->slice_beta_offset);","{'deleted_lines': ['            if (h->slice_alpha_c0_offset > 104U ||', '                h->slice_beta_offset     > 104U) {'], 'added_lines': ['            if (h->slice_alpha_c0_offset < 52 - 12 || h->slice_alpha_c0_offset > 52 + 12 ||', '                h->slice_beta_offset     < 52 - 12 || h->slice_beta_offset     > 52 + 12) {']}",True,A vulnerability was found in FFmpeg 2.0. It has been rated as critical. Affected by this issue is the function decode_slice_header of the file libavcodec/h64.c. The manipulation leads to memory corruption. The attack may be launched remotely. It is recommended to apply a patch to fix this issue.,5.5,MEDIUM,1,valid,,5
CVE-2014-125011,['CWE-681'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avcodec/ansi: fix integer overflow

Fixes out of array read
Fixes: 5f9698e86d92f19bb08d54ff0d57027f-signal_sigsegv_b30756_3795_cov_2693691257_ansi256.ans
Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",d42ec8433c687fcbccefa51a7716d81920218e4f,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=d42ec8433c687fcbccefa51a7716d81920218e4f,libavcodec/ansi.c,decode_frame,"static int decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt)
{
AnsiContext *s = avctx->priv_data;
uint8_t *buf = avpkt->data;
int buf_size = avpkt->size;
const uint8_t *buf_end   = buf+buf_size;
int ret, i, count;
if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)
return ret;
if (!avctx->frame_number) {
for (i=0; i<avctx->height; i++)
memset(s->frame->data[0]+ i*s->frame->linesize[0], 0, avctx->width);
memset(s->frame->data[1], 0, AVPALETTE_SIZE);
}
s->frame->pict_type           = AV_PICTURE_TYPE_I;
s->frame->palette_has_changed = 1;
set_palette((uint32_t *)s->frame->data[1]);
if (!s->first_frame) {
erase_screen(avctx);
s->first_frame = 1;
}
while(buf < buf_end) {
switch(s->state) {
case STATE_NORMAL:
switch (buf[0]) {
case 0x00:             case 0x07:             case 0x1A:                 
break;
case 0x08:                 s->x = FFMAX(s->x - 1, 0);
break;
case 0x09:                 i = s->x / FONT_WIDTH;
count = ((i + 8) & ~7) - i;
for (i = 0; i < count; i++)
draw_char(avctx, ' ');
break;
case 0x0A:                 hscroll(avctx);
case 0x0D:                 s->x = 0;
break;
case 0x0C:                 erase_screen(avctx);
break;
case 0x1B:                 s->state = STATE_ESCAPE;
break;
default:
draw_char(avctx, buf[0]);
}
break;
case STATE_ESCAPE:
if (buf[0] == '[') {
s->state   = STATE_CODE;
s->nb_args = 0;
s->args[0] = -1;
} else {
s->state = STATE_NORMAL;
draw_char(avctx, 0x1B);
continue;
}
break;
case STATE_CODE:
switch(buf[0]) {
case '0': case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':
if (s->nb_args < MAX_NB_ARGS)
s->args[s->nb_args] = FFMAX(s->args[s->nb_args], 0) * 10 + buf[0] - '0';
break;
case ';':
s->nb_args++;
if (s->nb_args < MAX_NB_ARGS)
s->args[s->nb_args] = 0;
break;
case 'M':
s->state = STATE_MUSIC_PREAMBLE;
break;
case '=': case '?':
break;
default:
if (s->nb_args > MAX_NB_ARGS)
av_log(avctx, AV_LOG_WARNING, ""args overflow (%i)\n"", s->nb_args);
if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] >= 0)
s->nb_args++;
if ((ret = execute_code(avctx, buf[0])) < 0)
return ret;
s->state = STATE_NORMAL;
}
break;
case STATE_MUSIC_PREAMBLE:
if (buf[0] == 0x0E || buf[0] == 0x1B)
s->state = STATE_NORMAL;
break;
}
buf++;
}
*got_frame = 1;
if ((ret = av_frame_ref(data, s->frame)) < 0)
return ret;
return buf_size;
}","static int decode_frame(AVCodecContext *VAR_0,
void *VAR_1, int *VAR_2,
AVPacket *VAR_3)
{
AnsiContext *VAR_4 = VAR_0->priv_data;
uint8_t *VAR_5 = VAR_3->data;
int VAR_6 = VAR_3->size;
const uint8_t *VAR_7   = VAR_5+VAR_6;
int VAR_8, VAR_9, VAR_10;
if ((VAR_8 = ff_reget_buffer(VAR_0, VAR_4->frame)) < 0)
return VAR_8;
if (!VAR_0->frame_number) {
for (VAR_9=0; VAR_9<VAR_0->height; VAR_9++)
memset(VAR_4->frame->data[0]+ VAR_9*VAR_4->frame->linesize[0], 0, VAR_0->width);
memset(VAR_4->frame->data[1], 0, VAR_11);
}
VAR_4->frame->pict_type           = VAR_12;
VAR_4->frame->palette_has_changed = 1;
set_palette((uint32_t *)VAR_4->frame->data[1]);
if (!VAR_4->first_frame) {
erase_screen(VAR_0);
VAR_4->first_frame = 1;
}
while(VAR_5 < VAR_7) {
switch(VAR_4->state) {
case VAR_13:
switch (VAR_5[0]) {
case 0x00: 
case 0x07: 
case 0x1A: 
break;
case 0x08: 
VAR_4->x = FFMAX(VAR_4->x - 1, 0);
break;
case 0x09: 
VAR_9 = VAR_4->x / VAR_14;
VAR_10 = ((VAR_9 + 8) & ~7) - VAR_9;
for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++)
draw_char(VAR_0, ' ');
break;
case 0x0A: 
hscroll(VAR_0);
case 0x0D: 
VAR_4->x = 0;
break;
case 0x0C: 
erase_screen(VAR_0);
break;
case 0x1B: 
VAR_4->state = VAR_15;
break;
default:
draw_char(VAR_0, VAR_5[0]);
}
break;
case VAR_15:
if (VAR_5[0] == '[') {
VAR_4->state   = VAR_16;
VAR_4->nb_args = 0;
VAR_4->args[0] = -1;
} else {
VAR_4->state = VAR_13;
draw_char(VAR_0, 0x1B);
continue;
}
break;
case VAR_16:
switch(VAR_5[0]) {
case '0': case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':
if (VAR_4->nb_args < VAR_17)
VAR_4->args[VAR_4->nb_args] = FFMAX(VAR_4->args[VAR_4->nb_args], 0) * 10 + VAR_5[0] - '0';
break;
case ';':
VAR_4->nb_args++;
if (VAR_4->nb_args < VAR_17)
VAR_4->args[VAR_4->nb_args] = 0;
break;
case 'M':
VAR_4->state = VAR_18;
break;
case '=': case '?':
break;
default:
if (VAR_4->nb_args > VAR_17)
av_log(VAR_0, VAR_19, ""args overflow (%i)\n"", VAR_4->nb_args);
if (VAR_4->nb_args < VAR_17 && VAR_4->args[VAR_4->nb_args] >= 0)
VAR_4->nb_args++;
if ((VAR_8 = execute_code(VAR_0, VAR_5[0])) < 0)
return VAR_8;
VAR_4->state = VAR_13;
}
break;
case VAR_18:
if (VAR_5[0] == 0x0E || VAR_5[0] == 0x1B)
VAR_4->state = VAR_13;
break;
}
VAR_5++;
}
*VAR_2 = 1;
if ((VAR_8 = av_frame_ref(VAR_1, VAR_4->frame)) < 0)
return VAR_8;
return VAR_6;
}",ffmpeg/d42ec8433c687fcbccefa51a7716d81920218e4f/ansi.c/vul/before/0.json,"static int decode_frame(AVCodecContext *avctx,
                            void *data, int *got_frame,
                            AVPacket *avpkt)
{
    AnsiContext *s = avctx->priv_data;
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    const uint8_t *buf_end   = buf+buf_size;
    int ret, i, count;

    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)
        return ret;
    if (!avctx->frame_number) {
        for (i=0; i<avctx->height; i++)
            memset(s->frame->data[0]+ i*s->frame->linesize[0], 0, avctx->width);
        memset(s->frame->data[1], 0, AVPALETTE_SIZE);
    }

    s->frame->pict_type           = AV_PICTURE_TYPE_I;
    s->frame->palette_has_changed = 1;
    set_palette((uint32_t *)s->frame->data[1]);
    if (!s->first_frame) {
        erase_screen(avctx);
        s->first_frame = 1;
    }

    while(buf < buf_end) {
        switch(s->state) {
        case STATE_NORMAL:
            switch (buf[0]) {
            case 0x00: //NUL
            case 0x07: //BEL
            case 0x1A: //SUB
                /* ignore */
                break;
            case 0x08: //BS
                s->x = FFMAX(s->x - 1, 0);
                break;
            case 0x09: //HT
                i = s->x / FONT_WIDTH;
                count = ((i + 8) & ~7) - i;
                for (i = 0; i < count; i++)
                    draw_char(avctx, ' ');
                break;
            case 0x0A: //LF
                hscroll(avctx);
            case 0x0D: //CR
                s->x = 0;
                break;
            case 0x0C: //FF
                erase_screen(avctx);
                break;
            case 0x1B: //ESC
                s->state = STATE_ESCAPE;
                break;
            default:
                draw_char(avctx, buf[0]);
            }
            break;
        case STATE_ESCAPE:
            if (buf[0] == '[') {
                s->state   = STATE_CODE;
                s->nb_args = 0;
                s->args[0] = -1;
            } else {
                s->state = STATE_NORMAL;
                draw_char(avctx, 0x1B);
                continue;
            }
            break;
        case STATE_CODE:
            switch(buf[0]) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] < 6553)
                    s->args[s->nb_args] = FFMAX(s->args[s->nb_args], 0) * 10 + buf[0] - '0';
                break;
            case ';':
                s->nb_args++;
                if (s->nb_args < MAX_NB_ARGS)
                    s->args[s->nb_args] = 0;
                break;
            case 'M':
                s->state = STATE_MUSIC_PREAMBLE;
                break;
            case '=': case '?':
                /* ignore */
                break;
            default:
                if (s->nb_args > MAX_NB_ARGS)
                    av_log(avctx, AV_LOG_WARNING, ""args overflow (%i)\n"", s->nb_args);
                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] >= 0)
                    s->nb_args++;
                if ((ret = execute_code(avctx, buf[0])) < 0)
                    return ret;
                s->state = STATE_NORMAL;
            }
            break;
        case STATE_MUSIC_PREAMBLE:
            if (buf[0] == 0x0E || buf[0] == 0x1B)
                s->state = STATE_NORMAL;
            /* ignore music data */
            break;
        }
        buf++;
    }

    *got_frame = 1;
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;
    return buf_size;
}","static int decode_frame(AVCodecContext *VAR_0,
                            void *VAR_1, int *VAR_2,
                            AVPacket *VAR_3)
{
    AnsiContext *VAR_4 = VAR_0->priv_data;
    uint8_t *VAR_5 = VAR_3->data;
    int VAR_6 = VAR_3->size;
    const uint8_t *VAR_7   = VAR_5+VAR_6;
    int VAR_8, VAR_9, VAR_10;

    if ((VAR_8 = ff_reget_buffer(VAR_0, VAR_4->frame)) < 0)
        return VAR_8;
    if (!VAR_0->frame_number) {
        for (VAR_9=0; VAR_9<VAR_0->height; VAR_9++)
            memset(VAR_4->frame->data[0]+ VAR_9*VAR_4->frame->linesize[0], 0, VAR_0->width);
        memset(VAR_4->frame->data[1], 0, VAR_11);
    }

    VAR_4->frame->pict_type           = VAR_12;
    VAR_4->frame->palette_has_changed = 1;
    set_palette((uint32_t *)VAR_4->frame->data[1]);
    if (!VAR_4->first_frame) {
        erase_screen(VAR_0);
        VAR_4->first_frame = 1;
    }

    while(VAR_5 < VAR_7) {
        switch(VAR_4->state) {
        case VAR_13:
            switch (VAR_5[0]) {
            case 0x00: /* COMMENT_0 */
            case 0x07: /* COMMENT_1 */
            case 0x1A: /* COMMENT_2 */
                /* COMMENT_3 */
                break;
            case 0x08: /* COMMENT_4 */
                VAR_4->x = FFMAX(VAR_4->x - 1, 0);
                break;
            case 0x09: /* COMMENT_5 */
                VAR_9 = VAR_4->x / VAR_14;
                VAR_10 = ((VAR_9 + 8) & ~7) - VAR_9;
                for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++)
                    draw_char(VAR_0, ' ');
                break;
            case 0x0A: /* COMMENT_6 */
                hscroll(VAR_0);
            case 0x0D: /* COMMENT_7 */
                VAR_4->x = 0;
                break;
            case 0x0C: /* COMMENT_8 */
                erase_screen(VAR_0);
                break;
            case 0x1B: /* COMMENT_9 */
                VAR_4->state = VAR_15;
                break;
            default:
                draw_char(VAR_0, VAR_5[0]);
            }
            break;
        case VAR_15:
            if (VAR_5[0] == '[') {
                VAR_4->state   = VAR_16;
                VAR_4->nb_args = 0;
                VAR_4->args[0] = -1;
            } else {
                VAR_4->state = VAR_13;
                draw_char(VAR_0, 0x1B);
                continue;
            }
            break;
        case VAR_16:
            switch(VAR_5[0]) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                if (VAR_4->nb_args < VAR_17 && VAR_4->args[VAR_4->nb_args] < 6553)
                    VAR_4->args[VAR_4->nb_args] = FFMAX(VAR_4->args[VAR_4->nb_args], 0) * 10 + VAR_5[0] - '0';
                break;
            case ';':
                VAR_4->nb_args++;
                if (VAR_4->nb_args < VAR_17)
                    VAR_4->args[VAR_4->nb_args] = 0;
                break;
            case 'M':
                VAR_4->state = VAR_18;
                break;
            case '=': case '?':
                /* COMMENT_3 */
                break;
            default:
                if (VAR_4->nb_args > VAR_17)
                    av_log(VAR_0, VAR_19, ""args overflow (%i)\n"", VAR_4->nb_args);
                if (VAR_4->nb_args < VAR_17 && VAR_4->args[VAR_4->nb_args] >= 0)
                    VAR_4->nb_args++;
                if ((VAR_8 = execute_code(VAR_0, VAR_5[0])) < 0)
                    return VAR_8;
                VAR_4->state = VAR_13;
            }
            break;
        case VAR_18:
            if (VAR_5[0] == 0x0E || VAR_5[0] == 0x1B)
                VAR_4->state = VAR_13;
            /* COMMENT_10 */
            break;
        }
        VAR_5++;
    }

    *VAR_2 = 1;
    if ((VAR_8 = av_frame_ref(VAR_1, VAR_4->frame)) < 0)
        return VAR_8;
    return VAR_6;
}",ffmpeg/d42ec8433c687fcbccefa51a7716d81920218e4f/ansi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,7 +72,7 @@
             switch(buf[0]) {
             case '0': case '1': case '2': case '3': case '4':
             case '5': case '6': case '7': case '8': case '9':
-                if (s->nb_args < MAX_NB_ARGS)
+                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] < 6553)
                     s->args[s->nb_args] = FFMAX(s->args[s->nb_args], 0) * 10 + buf[0] - '0';
                 break;
             case ';':","{'deleted_lines': ['                if (s->nb_args < MAX_NB_ARGS)'], 'added_lines': ['                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] < 6553)']}",True,A vulnerability was found in FFmpeg 2.0. It has been declared as problematic. Affected by this vulnerability is the function decode_frame of the file libavcodec/ansi.c. The manipulation leads to integer coercion error. The attack can be launched remotely. It is recommended to apply a patch to fix this issue.,7.8,HIGH,2,valid,,5
CVE-2023-28466,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"ctx->crypto_send.info is not protected by lock_sock in
do_tls_getsockopt_conf(). A race condition between do_tls_getsockopt_conf()
and error paths of do_tls_setsockopt_conf() may lead to a use-after-free
or null-deref.

More discussion:  https://lore.kernel.org/all/Y/ht6gQL+u6fj3dG@hog/

Fixes: 3c4d7559159b (""tls: kernel TLS support"")
Signed-off-by: Hangyu Hua <hbh25y@gmail.com>
Link: https://lore.kernel.org/r/20230228023344.9623-1-hbh25y@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,net/tls/tls_main.c,do_tls_getsockopt_no_pad,"static int do_tls_getsockopt_no_pad(struct sock *sk, char __user *optval,
int __user *optlen)
{
struct tls_context *ctx = tls_get_ctx(sk);
int value, len;
if (ctx->prot_info.version != TLS_1_3_VERSION)
return -EINVAL;
if (get_user(len, optlen))
return -EFAULT;
if (len < sizeof(value))
return -EINVAL;
lock_sock(sk);
value = -EINVAL;
if (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)
value = ctx->rx_no_pad;
release_sock(sk);
if (value < 0)
return value;
if (put_user(sizeof(value), optlen))
return -EFAULT;
if (copy_to_user(optval, &value, sizeof(value)))
return -EFAULT;
return 0;
}","static int do_tls_getsockopt_no_pad(struct sock *VAR_0, char __user *VAR_1,
int __user *VAR_2)
{
struct tls_context *VAR_3 = tls_get_ctx(VAR_0);
int VAR_4, VAR_5;
if (VAR_3->prot_info.version != VAR_6)
return -VAR_7;
if (get_user(VAR_5, VAR_2))
return -VAR_8;
if (VAR_5 < sizeof(VAR_4))
return -VAR_7;
lock_sock(VAR_0);
VAR_4 = -VAR_7;
if (VAR_3->rx_conf == VAR_9 || VAR_3->rx_conf == VAR_10)
VAR_4 = VAR_3->rx_no_pad;
release_sock(VAR_0);
if (VAR_4 < 0)
return VAR_4;
if (put_user(sizeof(VAR_4), VAR_2))
return -VAR_8;
if (copy_to_user(VAR_1, &VAR_4, sizeof(VAR_4)))
return -VAR_8;
return 0;
}",,"static int do_tls_getsockopt_no_pad(struct sock *sk, char __user *optval,
				    int __user *optlen)
{
	struct tls_context *ctx = tls_get_ctx(sk);
	int value, len;

	if (ctx->prot_info.version != TLS_1_3_VERSION)
		return -EINVAL;

	if (get_user(len, optlen))
		return -EFAULT;
	if (len < sizeof(value))
		return -EINVAL;

	value = -EINVAL;
	if (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)
		value = ctx->rx_no_pad;
	if (value < 0)
		return value;

	if (put_user(sizeof(value), optlen))
		return -EFAULT;
	if (copy_to_user(optval, &value, sizeof(value)))
		return -EFAULT;

	return 0;
}","static int do_tls_getsockopt_no_pad(struct sock *VAR_0, char __user *VAR_1,
				    int __user *VAR_2)
{
	struct tls_context *VAR_3 = tls_get_ctx(VAR_0);
	int VAR_4, VAR_5;

	if (VAR_3->prot_info.version != VAR_6)
		return -VAR_7;

	if (get_user(VAR_5, VAR_2))
		return -VAR_8;
	if (VAR_5 < sizeof(VAR_4))
		return -VAR_7;

	VAR_4 = -VAR_7;
	if (VAR_3->rx_conf == VAR_9 || VAR_3->rx_conf == VAR_10)
		VAR_4 = VAR_3->rx_no_pad;
	if (VAR_4 < 0)
		return VAR_4;

	if (put_user(sizeof(VAR_4), VAR_2))
		return -VAR_8;
	if (copy_to_user(VAR_1, &VAR_4, sizeof(VAR_4)))
		return -VAR_8;

	return 0;
}",,"--- func_before
+++ func_after
@@ -12,11 +12,9 @@
 	if (len < sizeof(value))
 		return -EINVAL;
 
-	lock_sock(sk);
 	value = -EINVAL;
 	if (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)
 		value = ctx->rx_no_pad;
-	release_sock(sk);
 	if (value < 0)
 		return value;
 ","{'deleted_lines': ['\tlock_sock(sk);', '\trelease_sock(sk);'], 'added_lines': []}",True,"do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",7.0,HIGH,2,valid,,5
CVE-2023-28466,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"ctx->crypto_send.info is not protected by lock_sock in
do_tls_getsockopt_conf(). A race condition between do_tls_getsockopt_conf()
and error paths of do_tls_setsockopt_conf() may lead to a use-after-free
or null-deref.

More discussion:  https://lore.kernel.org/all/Y/ht6gQL+u6fj3dG@hog/

Fixes: 3c4d7559159b (""tls: kernel TLS support"")
Signed-off-by: Hangyu Hua <hbh25y@gmail.com>
Link: https://lore.kernel.org/r/20230228023344.9623-1-hbh25y@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,net/tls/tls_main.c,do_tls_getsockopt,"static int do_tls_getsockopt(struct sock *sk, int optname,
char __user *optval, int __user *optlen)
{
int rc = 0;
switch (optname) {
case TLS_TX:
case TLS_RX:
rc = do_tls_getsockopt_conf(sk, optval, optlen,
optname == TLS_TX);
break;
case TLS_TX_ZEROCOPY_RO:
rc = do_tls_getsockopt_tx_zc(sk, optval, optlen);
break;
case TLS_RX_EXPECT_NO_PAD:
rc = do_tls_getsockopt_no_pad(sk, optval, optlen);
break;
default:
rc = -ENOPROTOOPT;
break;
}
return rc;
}","static int do_tls_getsockopt(struct sock *VAR_0, int VAR_1,
char __user *VAR_2, int __user *VAR_3)
{
int VAR_4 = 0;
switch (VAR_1) {
case VAR_5:
case VAR_6:
VAR_4 = do_tls_getsockopt_conf(VAR_0, VAR_2, VAR_3,
VAR_1 == VAR_5);
break;
case VAR_7:
VAR_4 = do_tls_getsockopt_tx_zc(VAR_0, VAR_2, VAR_3);
break;
case VAR_8:
VAR_4 = do_tls_getsockopt_no_pad(VAR_0, VAR_2, VAR_3);
break;
default:
VAR_4 = -VAR_9;
break;
}
return VAR_4;
}",,"static int do_tls_getsockopt(struct sock *sk, int optname,
			     char __user *optval, int __user *optlen)
{
	int rc = 0;

	lock_sock(sk);

	switch (optname) {
	case TLS_TX:
	case TLS_RX:
		rc = do_tls_getsockopt_conf(sk, optval, optlen,
					    optname == TLS_TX);
		break;
	case TLS_TX_ZEROCOPY_RO:
		rc = do_tls_getsockopt_tx_zc(sk, optval, optlen);
		break;
	case TLS_RX_EXPECT_NO_PAD:
		rc = do_tls_getsockopt_no_pad(sk, optval, optlen);
		break;
	default:
		rc = -ENOPROTOOPT;
		break;
	}

	release_sock(sk);

	return rc;
}","static int do_tls_getsockopt(struct sock *VAR_0, int VAR_1,
			     char __user *VAR_2, int __user *VAR_3)
{
	int VAR_4 = 0;

	lock_sock(VAR_0);

	switch (VAR_1) {
	case VAR_5:
	case VAR_6:
		VAR_4 = do_tls_getsockopt_conf(VAR_0, VAR_2, VAR_3,
					    VAR_1 == VAR_5);
		break;
	case VAR_7:
		VAR_4 = do_tls_getsockopt_tx_zc(VAR_0, VAR_2, VAR_3);
		break;
	case VAR_8:
		VAR_4 = do_tls_getsockopt_no_pad(VAR_0, VAR_2, VAR_3);
		break;
	default:
		VAR_4 = -VAR_9;
		break;
	}

	release_sock(VAR_0);

	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -2,6 +2,8 @@
 			     char __user *optval, int __user *optlen)
 {
 	int rc = 0;
+
+	lock_sock(sk);
 
 	switch (optname) {
 	case TLS_TX:
@@ -19,5 +21,8 @@
 		rc = -ENOPROTOOPT;
 		break;
 	}
+
+	release_sock(sk);
+
 	return rc;
 }","{'deleted_lines': [], 'added_lines': ['', '\tlock_sock(sk);', '', '\trelease_sock(sk);', '']}",True,"do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",7.0,HIGH,2,valid,,5
CVE-2023-28466,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"ctx->crypto_send.info is not protected by lock_sock in
do_tls_getsockopt_conf(). A race condition between do_tls_getsockopt_conf()
and error paths of do_tls_setsockopt_conf() may lead to a use-after-free
or null-deref.

More discussion:  https://lore.kernel.org/all/Y/ht6gQL+u6fj3dG@hog/

Fixes: 3c4d7559159b (""tls: kernel TLS support"")
Signed-off-by: Hangyu Hua <hbh25y@gmail.com>
Link: https://lore.kernel.org/r/20230228023344.9623-1-hbh25y@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962,net/tls/tls_main.c,do_tls_getsockopt_conf,"static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,
int __user *optlen, int tx)
{
int rc = 0;
struct tls_context *ctx = tls_get_ctx(sk);
struct tls_crypto_info *crypto_info;
struct cipher_context *cctx;
int len;
if (get_user(len, optlen))
return -EFAULT;
if (!optval || (len < sizeof(*crypto_info))) {
rc = -EINVAL;
goto out;
}
if (!ctx) {
rc = -EBUSY;
goto out;
}
if (tx) {
crypto_info = &ctx->crypto_send.info;
cctx = &ctx->tx;
} else {
crypto_info = &ctx->crypto_recv.info;
cctx = &ctx->rx;
}
if (!TLS_CRYPTO_INFO_READY(crypto_info)) {
rc = -EBUSY;
goto out;
}
if (len == sizeof(*crypto_info)) {
if (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))
rc = -EFAULT;
goto out;
}
switch (crypto_info->cipher_type) {
case TLS_CIPHER_AES_GCM_128: {
struct tls12_crypto_info_aes_gcm_128 *
crypto_info_aes_gcm_128 =
container_of(crypto_info,
struct tls12_crypto_info_aes_gcm_128,
info);
if (len != sizeof(*crypto_info_aes_gcm_128)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(crypto_info_aes_gcm_128->iv,
cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,
TLS_CIPHER_AES_GCM_128_IV_SIZE);
memcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,
TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval,
crypto_info_aes_gcm_128,
sizeof(*crypto_info_aes_gcm_128)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_AES_GCM_256: {
struct tls12_crypto_info_aes_gcm_256 *
crypto_info_aes_gcm_256 =
container_of(crypto_info,
struct tls12_crypto_info_aes_gcm_256,
info);
if (len != sizeof(*crypto_info_aes_gcm_256)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(crypto_info_aes_gcm_256->iv,
cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,
TLS_CIPHER_AES_GCM_256_IV_SIZE);
memcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,
TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval,
crypto_info_aes_gcm_256,
sizeof(*crypto_info_aes_gcm_256)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_AES_CCM_128: {
struct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =
container_of(crypto_info,
struct tls12_crypto_info_aes_ccm_128, info);
if (len != sizeof(*aes_ccm_128)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(aes_ccm_128->iv,
cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,
TLS_CIPHER_AES_CCM_128_IV_SIZE);
memcpy(aes_ccm_128->rec_seq, cctx->rec_seq,
TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_CHACHA20_POLY1305: {
struct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =
container_of(crypto_info,
struct tls12_crypto_info_chacha20_poly1305,
info);
if (len != sizeof(*chacha20_poly1305)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(chacha20_poly1305->iv,
cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,
TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
memcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,
TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval, chacha20_poly1305,
sizeof(*chacha20_poly1305)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_SM4_GCM: {
struct tls12_crypto_info_sm4_gcm *sm4_gcm_info =
container_of(crypto_info,
struct tls12_crypto_info_sm4_gcm, info);
if (len != sizeof(*sm4_gcm_info)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(sm4_gcm_info->iv,
cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,
TLS_CIPHER_SM4_GCM_IV_SIZE);
memcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,
TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_SM4_CCM: {
struct tls12_crypto_info_sm4_ccm *sm4_ccm_info =
container_of(crypto_info,
struct tls12_crypto_info_sm4_ccm, info);
if (len != sizeof(*sm4_ccm_info)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(sm4_ccm_info->iv,
cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,
TLS_CIPHER_SM4_CCM_IV_SIZE);
memcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,
TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_ARIA_GCM_128: {
struct tls12_crypto_info_aria_gcm_128 *
crypto_info_aria_gcm_128 =
container_of(crypto_info,
struct tls12_crypto_info_aria_gcm_128,
info);
if (len != sizeof(*crypto_info_aria_gcm_128)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(crypto_info_aria_gcm_128->iv,
cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,
TLS_CIPHER_ARIA_GCM_128_IV_SIZE);
memcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,
TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval,
crypto_info_aria_gcm_128,
sizeof(*crypto_info_aria_gcm_128)))
rc = -EFAULT;
break;
}
case TLS_CIPHER_ARIA_GCM_256: {
struct tls12_crypto_info_aria_gcm_256 *
crypto_info_aria_gcm_256 =
container_of(crypto_info,
struct tls12_crypto_info_aria_gcm_256,
info);
if (len != sizeof(*crypto_info_aria_gcm_256)) {
rc = -EINVAL;
goto out;
}
lock_sock(sk);
memcpy(crypto_info_aria_gcm_256->iv,
cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,
TLS_CIPHER_ARIA_GCM_256_IV_SIZE);
memcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,
TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);
release_sock(sk);
if (copy_to_user(optval,
crypto_info_aria_gcm_256,
sizeof(*crypto_info_aria_gcm_256)))
rc = -EFAULT;
break;
}
default:
rc = -EINVAL;
}
out:
return rc;
}","static int do_tls_getsockopt_conf(struct sock *VAR_0, char __user *VAR_1,
int __user *VAR_2, int VAR_3)
{
int VAR_4 = 0;
struct tls_context *VAR_5 = tls_get_ctx(VAR_0);
struct tls_crypto_info *VAR_6;
struct cipher_context *VAR_7;
int VAR_8;
if (get_user(VAR_8, VAR_2))
return -VAR_9;
if (!VAR_1 || (VAR_8 < sizeof(*VAR_6))) {
VAR_4 = -VAR_10;
goto out;
}
if (!VAR_5) {
VAR_4 = -VAR_11;
goto out;
}
if (VAR_3) {
VAR_6 = &VAR_5->crypto_send.info;
VAR_7 = &VAR_5->tx;
} else {
VAR_6 = &VAR_5->crypto_recv.info;
VAR_7 = &VAR_5->rx;
}
if (!TLS_CRYPTO_INFO_READY(VAR_6)) {
VAR_4 = -VAR_11;
goto out;
}
if (VAR_8 == sizeof(*VAR_6)) {
if (copy_to_user(VAR_1, VAR_6, sizeof(*VAR_6)))
VAR_4 = -VAR_9;
goto out;
}
switch (VAR_6->cipher_type) {
case VAR_12: {
struct tls12_crypto_info_aes_gcm_128 *
VAR_13 =
container_of(VAR_6,
struct tls12_crypto_info_aes_gcm_128,
VAR_14);
if (VAR_8 != sizeof(*VAR_13)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_13->iv,
VAR_7->iv + VAR_15,
VAR_16);
memcpy(VAR_13->rec_seq, VAR_7->rec_seq,
VAR_17);
release_sock(VAR_0);
if (copy_to_user(VAR_1,
VAR_13,
sizeof(*VAR_13)))
VAR_4 = -VAR_9;
break;
}
case VAR_18: {
struct tls12_crypto_info_aes_gcm_256 *
VAR_19 =
container_of(VAR_6,
struct tls12_crypto_info_aes_gcm_256,
VAR_14);
if (VAR_8 != sizeof(*VAR_19)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_19->iv,
VAR_7->iv + VAR_20,
VAR_21);
memcpy(VAR_19->rec_seq, VAR_7->rec_seq,
VAR_22);
release_sock(VAR_0);
if (copy_to_user(VAR_1,
VAR_19,
sizeof(*VAR_19)))
VAR_4 = -VAR_9;
break;
}
case VAR_23: {
struct tls12_crypto_info_aes_ccm_128 *VAR_24 =
container_of(VAR_6,
struct tls12_crypto_info_aes_ccm_128, VAR_14);
if (VAR_8 != sizeof(*VAR_24)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_24->iv,
VAR_7->iv + VAR_25,
VAR_26);
memcpy(VAR_24->rec_seq, VAR_7->rec_seq,
VAR_27);
release_sock(VAR_0);
if (copy_to_user(VAR_1, VAR_24, sizeof(*VAR_24)))
VAR_4 = -VAR_9;
break;
}
case VAR_28: {
struct tls12_crypto_info_chacha20_poly1305 *VAR_29 =
container_of(VAR_6,
struct tls12_crypto_info_chacha20_poly1305,
VAR_14);
if (VAR_8 != sizeof(*VAR_29)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_29->iv,
VAR_7->iv + VAR_30,
VAR_31);
memcpy(VAR_29->rec_seq, VAR_7->rec_seq,
VAR_32);
release_sock(VAR_0);
if (copy_to_user(VAR_1, VAR_29,
sizeof(*VAR_29)))
VAR_4 = -VAR_9;
break;
}
case VAR_33: {
struct tls12_crypto_info_sm4_gcm *VAR_34 =
container_of(VAR_6,
struct tls12_crypto_info_sm4_gcm, VAR_14);
if (VAR_8 != sizeof(*VAR_34)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_34->iv,
VAR_7->iv + VAR_35,
VAR_36);
memcpy(VAR_34->rec_seq, VAR_7->rec_seq,
VAR_37);
release_sock(VAR_0);
if (copy_to_user(VAR_1, VAR_34, sizeof(*VAR_34)))
VAR_4 = -VAR_9;
break;
}
case VAR_38: {
struct tls12_crypto_info_sm4_ccm *VAR_39 =
container_of(VAR_6,
struct tls12_crypto_info_sm4_ccm, VAR_14);
if (VAR_8 != sizeof(*VAR_39)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_39->iv,
VAR_7->iv + VAR_40,
VAR_41);
memcpy(VAR_39->rec_seq, VAR_7->rec_seq,
VAR_42);
release_sock(VAR_0);
if (copy_to_user(VAR_1, VAR_39, sizeof(*VAR_39)))
VAR_4 = -VAR_9;
break;
}
case VAR_43: {
struct tls12_crypto_info_aria_gcm_128 *
VAR_44 =
container_of(VAR_6,
struct tls12_crypto_info_aria_gcm_128,
VAR_14);
if (VAR_8 != sizeof(*VAR_44)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_44->iv,
VAR_7->iv + VAR_45,
VAR_46);
memcpy(VAR_44->rec_seq, VAR_7->rec_seq,
VAR_47);
release_sock(VAR_0);
if (copy_to_user(VAR_1,
VAR_44,
sizeof(*VAR_44)))
VAR_4 = -VAR_9;
break;
}
case VAR_48: {
struct tls12_crypto_info_aria_gcm_256 *
VAR_49 =
container_of(VAR_6,
struct tls12_crypto_info_aria_gcm_256,
VAR_14);
if (VAR_8 != sizeof(*VAR_49)) {
VAR_4 = -VAR_10;
goto out;
}
lock_sock(VAR_0);
memcpy(VAR_49->iv,
VAR_7->iv + VAR_50,
VAR_51);
memcpy(VAR_49->rec_seq, VAR_7->rec_seq,
VAR_52);
release_sock(VAR_0);
if (copy_to_user(VAR_1,
VAR_49,
sizeof(*VAR_49)))
VAR_4 = -VAR_9;
break;
}
default:
VAR_4 = -VAR_10;
}
out:
return VAR_4;
}",,"static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,
				  int __user *optlen, int tx)
{
	int rc = 0;
	struct tls_context *ctx = tls_get_ctx(sk);
	struct tls_crypto_info *crypto_info;
	struct cipher_context *cctx;
	int len;

	if (get_user(len, optlen))
		return -EFAULT;

	if (!optval || (len < sizeof(*crypto_info))) {
		rc = -EINVAL;
		goto out;
	}

	if (!ctx) {
		rc = -EBUSY;
		goto out;
	}

	/* get user crypto info */
	if (tx) {
		crypto_info = &ctx->crypto_send.info;
		cctx = &ctx->tx;
	} else {
		crypto_info = &ctx->crypto_recv.info;
		cctx = &ctx->rx;
	}

	if (!TLS_CRYPTO_INFO_READY(crypto_info)) {
		rc = -EBUSY;
		goto out;
	}

	if (len == sizeof(*crypto_info)) {
		if (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))
			rc = -EFAULT;
		goto out;
	}

	switch (crypto_info->cipher_type) {
	case TLS_CIPHER_AES_GCM_128: {
		struct tls12_crypto_info_aes_gcm_128 *
		  crypto_info_aes_gcm_128 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aes_gcm_128,
			       info);

		if (len != sizeof(*crypto_info_aes_gcm_128)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(crypto_info_aes_gcm_128->iv,
		       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,
		       TLS_CIPHER_AES_GCM_128_IV_SIZE);
		memcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);
		if (copy_to_user(optval,
				 crypto_info_aes_gcm_128,
				 sizeof(*crypto_info_aes_gcm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_AES_GCM_256: {
		struct tls12_crypto_info_aes_gcm_256 *
		  crypto_info_aes_gcm_256 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aes_gcm_256,
			       info);

		if (len != sizeof(*crypto_info_aes_gcm_256)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(crypto_info_aes_gcm_256->iv,
		       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,
		       TLS_CIPHER_AES_GCM_256_IV_SIZE);
		memcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);
		if (copy_to_user(optval,
				 crypto_info_aes_gcm_256,
				 sizeof(*crypto_info_aes_gcm_256)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_AES_CCM_128: {
		struct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =
			container_of(crypto_info,
				struct tls12_crypto_info_aes_ccm_128, info);

		if (len != sizeof(*aes_ccm_128)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(aes_ccm_128->iv,
		       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,
		       TLS_CIPHER_AES_CCM_128_IV_SIZE);
		memcpy(aes_ccm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
		if (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_CHACHA20_POLY1305: {
		struct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =
			container_of(crypto_info,
				struct tls12_crypto_info_chacha20_poly1305,
				info);

		if (len != sizeof(*chacha20_poly1305)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(chacha20_poly1305->iv,
		       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,
		       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
		memcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
		if (copy_to_user(optval, chacha20_poly1305,
				sizeof(*chacha20_poly1305)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_SM4_GCM: {
		struct tls12_crypto_info_sm4_gcm *sm4_gcm_info =
			container_of(crypto_info,
				struct tls12_crypto_info_sm4_gcm, info);

		if (len != sizeof(*sm4_gcm_info)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(sm4_gcm_info->iv,
		       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,
		       TLS_CIPHER_SM4_GCM_IV_SIZE);
		memcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);
		if (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_SM4_CCM: {
		struct tls12_crypto_info_sm4_ccm *sm4_ccm_info =
			container_of(crypto_info,
				struct tls12_crypto_info_sm4_ccm, info);

		if (len != sizeof(*sm4_ccm_info)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(sm4_ccm_info->iv,
		       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,
		       TLS_CIPHER_SM4_CCM_IV_SIZE);
		memcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);
		if (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_ARIA_GCM_128: {
		struct tls12_crypto_info_aria_gcm_128 *
		  crypto_info_aria_gcm_128 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aria_gcm_128,
			       info);

		if (len != sizeof(*crypto_info_aria_gcm_128)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(crypto_info_aria_gcm_128->iv,
		       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,
		       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);
		memcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);
		if (copy_to_user(optval,
				 crypto_info_aria_gcm_128,
				 sizeof(*crypto_info_aria_gcm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_ARIA_GCM_256: {
		struct tls12_crypto_info_aria_gcm_256 *
		  crypto_info_aria_gcm_256 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aria_gcm_256,
			       info);

		if (len != sizeof(*crypto_info_aria_gcm_256)) {
			rc = -EINVAL;
			goto out;
		}
		memcpy(crypto_info_aria_gcm_256->iv,
		       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,
		       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);
		memcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);
		if (copy_to_user(optval,
				 crypto_info_aria_gcm_256,
				 sizeof(*crypto_info_aria_gcm_256)))
			rc = -EFAULT;
		break;
	}
	default:
		rc = -EINVAL;
	}

out:
	return rc;
}","static int do_tls_getsockopt_conf(struct sock *VAR_0, char __user *VAR_1,
				  int __user *VAR_2, int VAR_3)
{
	int VAR_4 = 0;
	struct tls_context *VAR_5 = tls_get_ctx(VAR_0);
	struct tls_crypto_info *VAR_6;
	struct cipher_context *VAR_7;
	int VAR_8;

	if (get_user(VAR_8, VAR_2))
		return -VAR_9;

	if (!VAR_1 || (VAR_8 < sizeof(*VAR_6))) {
		VAR_4 = -VAR_10;
		goto out;
	}

	if (!VAR_5) {
		VAR_4 = -VAR_11;
		goto out;
	}

	/* COMMENT_0 */
	if (VAR_3) {
		VAR_6 = &VAR_5->crypto_send.info;
		VAR_7 = &VAR_5->tx;
	} else {
		VAR_6 = &VAR_5->crypto_recv.info;
		VAR_7 = &VAR_5->rx;
	}

	if (!TLS_CRYPTO_INFO_READY(VAR_6)) {
		VAR_4 = -VAR_11;
		goto out;
	}

	if (VAR_8 == sizeof(*VAR_6)) {
		if (copy_to_user(VAR_1, VAR_6, sizeof(*VAR_6)))
			VAR_4 = -VAR_9;
		goto out;
	}

	switch (VAR_6->cipher_type) {
	case VAR_12: {
		struct tls12_crypto_info_aes_gcm_128 *
		  VAR_13 =
		  container_of(VAR_6,
			       struct tls12_crypto_info_aes_gcm_128,
			       VAR_14);

		if (VAR_8 != sizeof(*VAR_13)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_13->iv,
		       VAR_7->iv + VAR_15,
		       VAR_16);
		memcpy(VAR_13->rec_seq, VAR_7->rec_seq,
		       VAR_17);
		if (copy_to_user(VAR_1,
				 VAR_13,
				 sizeof(*VAR_13)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_18: {
		struct tls12_crypto_info_aes_gcm_256 *
		  VAR_19 =
		  container_of(VAR_6,
			       struct tls12_crypto_info_aes_gcm_256,
			       VAR_14);

		if (VAR_8 != sizeof(*VAR_19)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_19->iv,
		       VAR_7->iv + VAR_20,
		       VAR_21);
		memcpy(VAR_19->rec_seq, VAR_7->rec_seq,
		       VAR_22);
		if (copy_to_user(VAR_1,
				 VAR_19,
				 sizeof(*VAR_19)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_23: {
		struct tls12_crypto_info_aes_ccm_128 *VAR_24 =
			container_of(VAR_6,
				struct tls12_crypto_info_aes_ccm_128, VAR_14);

		if (VAR_8 != sizeof(*VAR_24)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_24->iv,
		       VAR_7->iv + VAR_25,
		       VAR_26);
		memcpy(VAR_24->rec_seq, VAR_7->rec_seq,
		       VAR_27);
		if (copy_to_user(VAR_1, VAR_24, sizeof(*VAR_24)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_28: {
		struct tls12_crypto_info_chacha20_poly1305 *VAR_29 =
			container_of(VAR_6,
				struct tls12_crypto_info_chacha20_poly1305,
				VAR_14);

		if (VAR_8 != sizeof(*VAR_29)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_29->iv,
		       VAR_7->iv + VAR_30,
		       VAR_31);
		memcpy(VAR_29->rec_seq, VAR_7->rec_seq,
		       VAR_32);
		if (copy_to_user(VAR_1, VAR_29,
				sizeof(*VAR_29)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_33: {
		struct tls12_crypto_info_sm4_gcm *VAR_34 =
			container_of(VAR_6,
				struct tls12_crypto_info_sm4_gcm, VAR_14);

		if (VAR_8 != sizeof(*VAR_34)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_34->iv,
		       VAR_7->iv + VAR_35,
		       VAR_36);
		memcpy(VAR_34->rec_seq, VAR_7->rec_seq,
		       VAR_37);
		if (copy_to_user(VAR_1, VAR_34, sizeof(*VAR_34)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_38: {
		struct tls12_crypto_info_sm4_ccm *VAR_39 =
			container_of(VAR_6,
				struct tls12_crypto_info_sm4_ccm, VAR_14);

		if (VAR_8 != sizeof(*VAR_39)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_39->iv,
		       VAR_7->iv + VAR_40,
		       VAR_41);
		memcpy(VAR_39->rec_seq, VAR_7->rec_seq,
		       VAR_42);
		if (copy_to_user(VAR_1, VAR_39, sizeof(*VAR_39)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_43: {
		struct tls12_crypto_info_aria_gcm_128 *
		  VAR_44 =
		  container_of(VAR_6,
			       struct tls12_crypto_info_aria_gcm_128,
			       VAR_14);

		if (VAR_8 != sizeof(*VAR_44)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_44->iv,
		       VAR_7->iv + VAR_45,
		       VAR_46);
		memcpy(VAR_44->rec_seq, VAR_7->rec_seq,
		       VAR_47);
		if (copy_to_user(VAR_1,
				 VAR_44,
				 sizeof(*VAR_44)))
			VAR_4 = -VAR_9;
		break;
	}
	case VAR_48: {
		struct tls12_crypto_info_aria_gcm_256 *
		  VAR_49 =
		  container_of(VAR_6,
			       struct tls12_crypto_info_aria_gcm_256,
			       VAR_14);

		if (VAR_8 != sizeof(*VAR_49)) {
			VAR_4 = -VAR_10;
			goto out;
		}
		memcpy(VAR_49->iv,
		       VAR_7->iv + VAR_50,
		       VAR_51);
		memcpy(VAR_49->rec_seq, VAR_7->rec_seq,
		       VAR_52);
		if (copy_to_user(VAR_1,
				 VAR_49,
				 sizeof(*VAR_49)))
			VAR_4 = -VAR_9;
		break;
	}
	default:
		VAR_4 = -VAR_10;
	}

out:
	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -52,13 +52,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(crypto_info_aes_gcm_128->iv,
 		       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,
 		       TLS_CIPHER_AES_GCM_128_IV_SIZE);
 		memcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval,
 				 crypto_info_aes_gcm_128,
 				 sizeof(*crypto_info_aes_gcm_128)))
@@ -76,13 +74,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(crypto_info_aes_gcm_256->iv,
 		       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,
 		       TLS_CIPHER_AES_GCM_256_IV_SIZE);
 		memcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval,
 				 crypto_info_aes_gcm_256,
 				 sizeof(*crypto_info_aes_gcm_256)))
@@ -98,13 +94,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(aes_ccm_128->iv,
 		       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,
 		       TLS_CIPHER_AES_CCM_128_IV_SIZE);
 		memcpy(aes_ccm_128->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))
 			rc = -EFAULT;
 		break;
@@ -119,13 +113,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(chacha20_poly1305->iv,
 		       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,
 		       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
 		memcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval, chacha20_poly1305,
 				sizeof(*chacha20_poly1305)))
 			rc = -EFAULT;
@@ -140,13 +132,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(sm4_gcm_info->iv,
 		       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,
 		       TLS_CIPHER_SM4_GCM_IV_SIZE);
 		memcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))
 			rc = -EFAULT;
 		break;
@@ -160,13 +150,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(sm4_ccm_info->iv,
 		       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,
 		       TLS_CIPHER_SM4_CCM_IV_SIZE);
 		memcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))
 			rc = -EFAULT;
 		break;
@@ -182,13 +170,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(crypto_info_aria_gcm_128->iv,
 		       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,
 		       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);
 		memcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval,
 				 crypto_info_aria_gcm_128,
 				 sizeof(*crypto_info_aria_gcm_128)))
@@ -206,13 +192,11 @@
 			rc = -EINVAL;
 			goto out;
 		}
-		lock_sock(sk);
 		memcpy(crypto_info_aria_gcm_256->iv,
 		       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,
 		       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);
 		memcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,
 		       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);
-		release_sock(sk);
 		if (copy_to_user(optval,
 				 crypto_info_aria_gcm_256,
 				 sizeof(*crypto_info_aria_gcm_256)))","{'deleted_lines': ['\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);', '\t\tlock_sock(sk);', '\t\trelease_sock(sk);'], 'added_lines': []}",True,"do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",7.0,HIGH,2,valid,,5
CVE-2023-2235,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Events should only be added to a groups rb tree if they have not been
removed from their context by list_del_event(). Since remove_on_exec
made it possible to call list_del_event() on individual events before
they are detached from their group, perf_group_detach() should check each
sibling's attach_state before calling add_event_to_groups() on it.

Fixes: 2e498d0a74e5 (""perf: Add support for event removal on exec"")
Signed-off-by: Budimir Markovic <markovicbudimir@gmail.com>
Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/ZBFzvQV9tEqoHEtH@gentoo
",fd0815f632c24878e325821943edccc7fde947a2,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=fd0815f632c24878e325821943edccc7fde947a2,kernel/events/core.c,perf_group_detach,"static void perf_group_detach(struct perf_event *event)
{
struct perf_event *leader = event->group_leader;
struct perf_event *sibling, *tmp;
struct perf_event_context *ctx = event->ctx;
lockdep_assert_held(&ctx->lock);
if (!(event->attach_state & PERF_ATTACH_GROUP))
return;
event->attach_state &= ~PERF_ATTACH_GROUP;
perf_put_aux_event(event);
if (leader != event) {
list_del_init(&event->sibling_list);
event->group_leader->nr_siblings--;
goto out;
}
list_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) {
if (sibling->event_caps & PERF_EV_CAP_SIBLING)
perf_remove_sibling_event(sibling);
sibling->group_leader = sibling;
list_del_init(&sibling->sibling_list);
sibling->group_caps = event->group_caps;
if (!RB_EMPTY_NODE(&event->group_node)) {
add_event_to_groups(sibling, event->ctx);
if (sibling->state == PERF_EVENT_STATE_ACTIVE)
list_add_tail(&sibling->active_list, get_event_list(sibling));
}
WARN_ON_ONCE(sibling->ctx != event->ctx);
}
out:
for_each_sibling_event(tmp, leader)
perf_event__header_size(tmp);
perf_event__header_size(leader);
}","static void perf_group_detach(struct perf_event *VAR_0)
{
struct perf_event *VAR_1 = VAR_0->group_leader;
struct perf_event *VAR_2, *VAR_3;
struct perf_event_context *VAR_4 = VAR_0->ctx;
lockdep_assert_held(&VAR_4->lock);
if (!(VAR_0->attach_state & VAR_5))
return;
VAR_0->attach_state &= ~VAR_5;
perf_put_aux_event(VAR_0);
if (VAR_1 != VAR_0) {
list_del_init(&VAR_0->sibling_list);
VAR_0->group_leader->nr_siblings--;
goto out;
}
list_for_each_entry_safe(VAR_2, VAR_3, &VAR_0->sibling_list, VAR_6) {
if (VAR_2->event_caps & VAR_7)
perf_remove_sibling_event(VAR_2);
VAR_2->group_leader = VAR_2;
list_del_init(&VAR_2->sibling_list);
VAR_2->group_caps = VAR_0->group_caps;
if (!RB_EMPTY_NODE(&VAR_0->group_node)) {
add_event_to_groups(VAR_2, VAR_0->ctx);
if (VAR_2->state == VAR_8)
list_add_tail(&VAR_2->active_list, get_event_list(VAR_2));
}
WARN_ON_ONCE(VAR_2->ctx != VAR_0->ctx);
}
out:
for_each_sibling_event(VAR_3, VAR_1)
perf_event__header_size(VAR_3);
perf_event__header_size(VAR_1);
}",torvalds/linux/fd0815f632c24878e325821943edccc7fde947a2/core.c/vul/before/0.json,"static void perf_group_detach(struct perf_event *event)
{
	struct perf_event *leader = event->group_leader;
	struct perf_event *sibling, *tmp;
	struct perf_event_context *ctx = event->ctx;

	lockdep_assert_held(&ctx->lock);

	/*
	 * We can have double detach due to exit/hot-unplug + close.
	 */
	if (!(event->attach_state & PERF_ATTACH_GROUP))
		return;

	event->attach_state &= ~PERF_ATTACH_GROUP;

	perf_put_aux_event(event);

	/*
	 * If this is a sibling, remove it from its group.
	 */
	if (leader != event) {
		list_del_init(&event->sibling_list);
		event->group_leader->nr_siblings--;
		goto out;
	}

	/*
	 * If this was a group event with sibling events then
	 * upgrade the siblings to singleton events by adding them
	 * to whatever list we are on.
	 */
	list_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) {

		if (sibling->event_caps & PERF_EV_CAP_SIBLING)
			perf_remove_sibling_event(sibling);

		sibling->group_leader = sibling;
		list_del_init(&sibling->sibling_list);

		/* Inherit group flags from the previous leader */
		sibling->group_caps = event->group_caps;

		if (sibling->attach_state & PERF_ATTACH_CONTEXT) {
			add_event_to_groups(sibling, event->ctx);

			if (sibling->state == PERF_EVENT_STATE_ACTIVE)
				list_add_tail(&sibling->active_list, get_event_list(sibling));
		}

		WARN_ON_ONCE(sibling->ctx != event->ctx);
	}

out:
	for_each_sibling_event(tmp, leader)
		perf_event__header_size(tmp);

	perf_event__header_size(leader);
}","static void perf_group_detach(struct perf_event *VAR_0)
{
	struct perf_event *VAR_1 = VAR_0->group_leader;
	struct perf_event *VAR_2, *VAR_3;
	struct perf_event_context *VAR_4 = VAR_0->ctx;

	lockdep_assert_held(&VAR_4->lock);

	/* COMMENT_0 */
                                                             
    
	if (!(VAR_0->attach_state & VAR_5))
		return;

	VAR_0->attach_state &= ~VAR_5;

	perf_put_aux_event(VAR_0);

	/* COMMENT_3 */
                                                   
    
	if (VAR_1 != VAR_0) {
		list_del_init(&VAR_0->sibling_list);
		VAR_0->group_leader->nr_siblings--;
		goto out;
	}

	/* COMMENT_6 */
                                                      
                                                           
                               
    
	list_for_each_entry_safe(VAR_2, VAR_3, &VAR_0->sibling_list, VAR_6) {

		if (VAR_2->event_caps & VAR_7)
			perf_remove_sibling_event(VAR_2);

		VAR_2->group_leader = VAR_2;
		list_del_init(&VAR_2->sibling_list);

		/* COMMENT_11 */
		VAR_2->group_caps = VAR_0->group_caps;

		if (VAR_2->attach_state & VAR_8) {
			add_event_to_groups(VAR_2, VAR_0->ctx);

			if (VAR_2->state == VAR_9)
				list_add_tail(&VAR_2->active_list, get_event_list(VAR_2));
		}

		WARN_ON_ONCE(VAR_2->ctx != VAR_0->ctx);
	}

out:
	for_each_sibling_event(VAR_3, VAR_1)
		perf_event__header_size(VAR_3);

	perf_event__header_size(VAR_1);
}",torvalds/linux/fd0815f632c24878e325821943edccc7fde947a2/core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,7 +41,7 @@
 		/* Inherit group flags from the previous leader */
 		sibling->group_caps = event->group_caps;
 
-		if (!RB_EMPTY_NODE(&event->group_node)) {
+		if (sibling->attach_state & PERF_ATTACH_CONTEXT) {
 			add_event_to_groups(sibling, event->ctx);
 
 			if (sibling->state == PERF_EVENT_STATE_ACTIVE)","{'deleted_lines': ['\t\tif (!RB_EMPTY_NODE(&event->group_node)) {'], 'added_lines': ['\t\tif (sibling->attach_state & PERF_ATTACH_CONTEXT) {']}",True,"A use-after-free vulnerability in the Linux Kernel Performance Events system can be exploited to achieve local privilege escalation.

The perf_group_detach function did not check the event's siblings' attach_state before calling add_event_to_groups(), butremove_on_exec made it possible to call list_del_event() on before detaching from their group, making it possible to use a dangling pointer causing a use-after-free vulnerability.

We recommend upgrading past commit fd0815f632c24878e325821943edccc7fde947a2.

",7.8,HIGH,2,valid,,5
CVE-2023-2985,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"The current hfsplus_put_super first calls hfs_btree_close on
sbi->ext_tree, then invokes iput on sbi->hidden_dir, resulting in an
use-after-free issue in hfsplus_release_folio.

As shown in hfsplus_fill_super, the error handling code also calls iput
before hfs_btree_close.

To fix this error, we move all iput calls before hfsplus_btree_close.

Note that this patch is tested on Syzbot.

Link: https://lkml.kernel.org/r/20230226124948.3175736-1-mudongliangabcd@gmail.com
Reported-by: syzbot+57e3e98f7e3b80f64d56@syzkaller.appspotmail.com
Tested-by: Dongliang Mu <mudongliangabcd@gmail.com>
Signed-off-by: Dongliang Mu <mudongliangabcd@gmail.com>
Cc: Bart Van Assche <bvanassche@acm.org>
Cc: Jens Axboe <axboe@kernel.dk>
Cc: Muchun Song <songmuchun@bytedance.com>
Cc: Roman Gushchin <roman.gushchin@linux.dev>
Cc: ""Theodore Ts'o"" <tytso@mit.edu>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",07db5e247ab5858439b14dd7cc1fe538b9efcf32,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=07db5e247ab5858439b14dd7cc1fe538b9efcf32,fs/hfsplus/super.c,hfsplus_put_super,"static void hfsplus_put_super(struct super_block *sb)
{
struct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);
hfs_dbg(SUPER, ""hfsplus_put_super\n"");
cancel_delayed_work_sync(&sbi->sync_work);
if (!sb_rdonly(sb) && sbi->s_vhdr) {
struct hfsplus_vh *vhdr = sbi->s_vhdr;
vhdr->modify_date = hfsp_now2mt();
vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);
hfsplus_sync_fs(sb, 1);
}
hfs_btree_close(sbi->attr_tree);
hfs_btree_close(sbi->cat_tree);
hfs_btree_close(sbi->ext_tree);
iput(sbi->alloc_file);
iput(sbi->hidden_dir);
kfree(sbi->s_vhdr_buf);
kfree(sbi->s_backup_vhdr_buf);
unload_nls(sbi->nls);
kfree(sb->s_fs_info);
sb->s_fs_info = NULL;
}","static void hfsplus_put_super(struct super_block *VAR_0)
{
struct hfsplus_sb_info *VAR_1 = HFSPLUS_SB(VAR_0);
hfs_dbg(VAR_2, ""hfsplus_put_super\n"");
cancel_delayed_work_sync(&VAR_1->sync_work);
if (!sb_rdonly(VAR_0) && VAR_1->s_vhdr) {
struct hfsplus_vh *VAR_3 = VAR_1->s_vhdr;
VAR_3->modify_date = hfsp_now2mt();
VAR_3->attributes |= cpu_to_be32(VAR_4);
VAR_3->attributes &= cpu_to_be32(~VAR_5);
hfsplus_sync_fs(VAR_0, 1);
}
hfs_btree_close(VAR_1->attr_tree);
hfs_btree_close(VAR_1->cat_tree);
hfs_btree_close(VAR_1->ext_tree);
iput(VAR_1->alloc_file);
iput(VAR_1->hidden_dir);
kfree(VAR_1->s_vhdr_buf);
kfree(VAR_1->s_backup_vhdr_buf);
unload_nls(VAR_1->nls);
kfree(VAR_0->s_fs_info);
VAR_0->s_fs_info = NULL;
}",torvalds/linux/07db5e247ab5858439b14dd7cc1fe538b9efcf32/super.c/vul/before/0.json,"static void hfsplus_put_super(struct super_block *sb)
{
	struct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);

	hfs_dbg(SUPER, ""hfsplus_put_super\n"");

	cancel_delayed_work_sync(&sbi->sync_work);

	if (!sb_rdonly(sb) && sbi->s_vhdr) {
		struct hfsplus_vh *vhdr = sbi->s_vhdr;

		vhdr->modify_date = hfsp_now2mt();
		vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
		vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);

		hfsplus_sync_fs(sb, 1);
	}

	iput(sbi->alloc_file);
	iput(sbi->hidden_dir);
	hfs_btree_close(sbi->attr_tree);
	hfs_btree_close(sbi->cat_tree);
	hfs_btree_close(sbi->ext_tree);
	kfree(sbi->s_vhdr_buf);
	kfree(sbi->s_backup_vhdr_buf);
	unload_nls(sbi->nls);
	kfree(sb->s_fs_info);
	sb->s_fs_info = NULL;
}","static void hfsplus_put_super(struct super_block *VAR_0)
{
	struct hfsplus_sb_info *VAR_1 = HFSPLUS_SB(VAR_0);

	hfs_dbg(VAR_2, ""hfsplus_put_super\n"");

	cancel_delayed_work_sync(&VAR_1->sync_work);

	if (!sb_rdonly(VAR_0) && VAR_1->s_vhdr) {
		struct hfsplus_vh *VAR_3 = VAR_1->s_vhdr;

		VAR_3->modify_date = hfsp_now2mt();
		VAR_3->attributes |= cpu_to_be32(VAR_4);
		VAR_3->attributes &= cpu_to_be32(~VAR_5);

		hfsplus_sync_fs(VAR_0, 1);
	}

	iput(VAR_1->alloc_file);
	iput(VAR_1->hidden_dir);
	hfs_btree_close(VAR_1->attr_tree);
	hfs_btree_close(VAR_1->cat_tree);
	hfs_btree_close(VAR_1->ext_tree);
	kfree(VAR_1->s_vhdr_buf);
	kfree(VAR_1->s_backup_vhdr_buf);
	unload_nls(VAR_1->nls);
	kfree(VAR_0->s_fs_info);
	VAR_0->s_fs_info = NULL;
}",torvalds/linux/07db5e247ab5858439b14dd7cc1fe538b9efcf32/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,11 +16,11 @@
 		hfsplus_sync_fs(sb, 1);
 	}
 
+	iput(sbi->alloc_file);
+	iput(sbi->hidden_dir);
 	hfs_btree_close(sbi->attr_tree);
 	hfs_btree_close(sbi->cat_tree);
 	hfs_btree_close(sbi->ext_tree);
-	iput(sbi->alloc_file);
-	iput(sbi->hidden_dir);
 	kfree(sbi->s_vhdr_buf);
 	kfree(sbi->s_backup_vhdr_buf);
 	unload_nls(sbi->nls);","{'deleted_lines': ['\tiput(sbi->alloc_file);', '\tiput(sbi->hidden_dir);'], 'added_lines': ['\tiput(sbi->alloc_file);', '\tiput(sbi->hidden_dir);']}",True,A use after free flaw was found in hfsplus_put_super in fs/hfsplus/super.c in the Linux Kernel. This flaw could allow a local user to cause a denial of service problem.,5.5,MEDIUM,1,valid,,5
CVE-2019-19524,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"No timer must be left running when the device goes away.

Signed-off-by: Oliver Neukum <oneukum@suse.com>
Reported-and-tested-by: syzbot+b6c55daa701fc389e286@syzkaller.appspotmail.com
Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/1573726121.17351.3.camel@suse.com
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
",fa3a5a1880c91bb92594ad42dfe9eedad7996b86,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=fa3a5a1880c91bb92594ad42dfe9eedad7996b86,drivers/input/ff-memless.c,ml_ff_destroy,"static void ml_ff_destroy(struct ff_device *ff)
{
struct ml_device *ml = ff->private;
kfree(ml->private);
}","static void ml_ff_destroy(struct ff_device *VAR_0)
{
struct ml_device *VAR_1 = VAR_0->private;
kfree(VAR_1->private);
}",torvalds/linux/fa3a5a1880c91bb92594ad42dfe9eedad7996b86/ff-memless.c/vul/before/0.json,"static void ml_ff_destroy(struct ff_device *ff)
{
	struct ml_device *ml = ff->private;

	/*
	 * Even though we stop all playing effects when tearing down
	 * an input device (via input_device_flush() that calls into
	 * input_ff_flush() that stops and erases all effects), we
	 * do not actually stop the timer, and therefore we should
	 * do it here.
	 */
	del_timer_sync(&ml->timer);

	kfree(ml->private);
}","static void ml_ff_destroy(struct ff_device *VAR_0)
{
	struct ml_device *VAR_1 = VAR_0->private;

	/* COMMENT_0 */
                                                             
                                                             
                                                           
                                                           
               
    
	del_timer_sync(&VAR_1->timer);

	kfree(VAR_1->private);
}",torvalds/linux/fa3a5a1880c91bb92594ad42dfe9eedad7996b86/ff-memless.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,5 +2,14 @@
 {
 	struct ml_device *ml = ff->private;
 
+	/*
+	 * Even though we stop all playing effects when tearing down
+	 * an input device (via input_device_flush() that calls into
+	 * input_ff_flush() that stops and erases all effects), we
+	 * do not actually stop the timer, and therefore we should
+	 * do it here.
+	 */
+	del_timer_sync(&ml->timer);
+
 	kfree(ml->private);
 }","{'deleted_lines': [], 'added_lines': ['\t/*', '\t * Even though we stop all playing effects when tearing down', '\t * an input device (via input_device_flush() that calls into', '\t * input_ff_flush() that stops and erases all effects), we', '\t * do not actually stop the timer, and therefore we should', '\t * do it here.', '\t */', '\tdel_timer_sync(&ml->timer);', '']}",True,"In the Linux kernel before 5.3.12, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/input/ff-memless.c driver, aka CID-fa3a5a1880c9.",4.6,MEDIUM,1,valid,,5
CVE-2019-19528,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"A recent fix addressing a deadlock on disconnect introduced a new bug
by moving the present flag out of the critical section protected by the
driver-data mutex. This could lead to a racing release() freeing the
driver data before disconnect() is done with it.

Due to insufficient locking a related use-after-free could be triggered
also before the above mentioned commit. Specifically, the driver needs
to hold the driver-data mutex also while checking the opened flag at
disconnect().

Fixes: c468a8aa790e (""usb: iowarrior: fix deadlock on disconnect"")
Fixes: 946b960d13c1 (""USB: add driver for iowarrior devices."")
Cc: stable <stable@vger.kernel.org>	# 2.6.21
Reported-by: syzbot+0761012cebf7bdb38137@syzkaller.appspotmail.com
Signed-off-by: Johan Hovold <johan@kernel.org>
Link: https://lore.kernel.org/r/20191009104846.5925-2-johan@kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",edc4746f253d907d048de680a621e121517f484b,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=edc4746f253d907d048de680a621e121517f484b,drivers/usb/misc/iowarrior.c,iowarrior_disconnect,"static void iowarrior_disconnect(struct usb_interface *interface)
{
struct iowarrior *dev;
int minor;
dev = usb_get_intfdata(interface);
mutex_lock(&iowarrior_open_disc_lock);
usb_set_intfdata(interface, NULL);
dev->present = 0;
minor = dev->minor;
mutex_unlock(&iowarrior_open_disc_lock);
usb_deregister_dev(interface, &iowarrior_class);
mutex_lock(&dev->mutex);
mutex_unlock(&dev->mutex);
if (dev->opened) {
usb_kill_urb(dev->int_in_urb);
wake_up_interruptible(&dev->read_wait);
wake_up_interruptible(&dev->write_wait);
} else {
iowarrior_delete(dev);
}
dev_info(&interface->dev, ""I/O-Warror #%d now disconnected\n"",
minor - IOWARRIOR_MINOR_BASE);
}","static void iowarrior_disconnect(struct usb_interface *VAR_0)
{
struct iowarrior *VAR_1;
int VAR_2;
VAR_1 = usb_get_intfdata(VAR_0);
mutex_lock(&VAR_3);
usb_set_intfdata(VAR_0, NULL);
VAR_1->present = 0;
VAR_2 = VAR_1->minor;
mutex_unlock(&VAR_3);
usb_deregister_dev(VAR_0, &VAR_4);
mutex_lock(&VAR_1->mutex);
mutex_unlock(&VAR_1->mutex);
if (VAR_1->opened) {
usb_kill_urb(VAR_1->int_in_urb);
wake_up_interruptible(&VAR_1->read_wait);
wake_up_interruptible(&VAR_1->write_wait);
} else {
iowarrior_delete(VAR_1);
}
dev_info(&VAR_0->dev, ""I/O-Warror #%d now disconnected\n"",
VAR_2 - VAR_5);
}",torvalds/linux/edc4746f253d907d048de680a621e121517f484b/iowarrior.c/vul/before/0.json,"static void iowarrior_disconnect(struct usb_interface *interface)
{
	struct iowarrior *dev;
	int minor;

	dev = usb_get_intfdata(interface);
	mutex_lock(&iowarrior_open_disc_lock);
	usb_set_intfdata(interface, NULL);

	minor = dev->minor;
	mutex_unlock(&iowarrior_open_disc_lock);
	/* give back our minor - this will call close() locks need to be dropped at this point*/

	usb_deregister_dev(interface, &iowarrior_class);

	mutex_lock(&dev->mutex);

	/* prevent device read, write and ioctl */
	dev->present = 0;

	if (dev->opened) {
		/* There is a process that holds a filedescriptor to the device ,
		   so we only shutdown read-/write-ops going on.
		   Deleting the device is postponed until close() was called.
		 */
		usb_kill_urb(dev->int_in_urb);
		wake_up_interruptible(&dev->read_wait);
		wake_up_interruptible(&dev->write_wait);
		mutex_unlock(&dev->mutex);
	} else {
		/* no process is using the device, cleanup now */
		mutex_unlock(&dev->mutex);
		iowarrior_delete(dev);
	}

	dev_info(&interface->dev, ""I/O-Warror #%d now disconnected\n"",
		 minor - IOWARRIOR_MINOR_BASE);
}","static void iowarrior_disconnect(struct usb_interface *VAR_0)
{
	struct iowarrior *VAR_1;
	int VAR_2;

	VAR_1 = usb_get_intfdata(VAR_0);
	mutex_lock(&VAR_3);
	usb_set_intfdata(VAR_0, NULL);

	VAR_2 = VAR_1->minor;
	mutex_unlock(&VAR_3);
	/* COMMENT_0 */

	usb_deregister_dev(VAR_0, &VAR_4);

	mutex_lock(&VAR_1->mutex);

	/* COMMENT_1 */
	VAR_1->present = 0;

	if (VAR_1->opened) {
		/* COMMENT_2 */
                                                  
                                                               
     
		usb_kill_urb(VAR_1->int_in_urb);
		wake_up_interruptible(&VAR_1->read_wait);
		wake_up_interruptible(&VAR_1->write_wait);
		mutex_unlock(&VAR_1->mutex);
	} else {
		/* COMMENT_6 */
		mutex_unlock(&VAR_1->mutex);
		iowarrior_delete(VAR_1);
	}

	dev_info(&VAR_0->dev, ""I/O-Warror #%d now disconnected\n"",
		 VAR_2 - VAR_5);
}",torvalds/linux/edc4746f253d907d048de680a621e121517f484b/iowarrior.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,8 +6,6 @@
 	dev = usb_get_intfdata(interface);
 	mutex_lock(&iowarrior_open_disc_lock);
 	usb_set_intfdata(interface, NULL);
-	/* prevent device read, write and ioctl */
-	dev->present = 0;
 
 	minor = dev->minor;
 	mutex_unlock(&iowarrior_open_disc_lock);
@@ -18,8 +16,7 @@
 	mutex_lock(&dev->mutex);
 
 	/* prevent device read, write and ioctl */
-
-	mutex_unlock(&dev->mutex);
+	dev->present = 0;
 
 	if (dev->opened) {
 		/* There is a process that holds a filedescriptor to the device ,
@@ -29,8 +26,10 @@
 		usb_kill_urb(dev->int_in_urb);
 		wake_up_interruptible(&dev->read_wait);
 		wake_up_interruptible(&dev->write_wait);
+		mutex_unlock(&dev->mutex);
 	} else {
 		/* no process is using the device, cleanup now */
+		mutex_unlock(&dev->mutex);
 		iowarrior_delete(dev);
 	}
 ","{'deleted_lines': ['\t/* prevent device read, write and ioctl */', '\tdev->present = 0;', '', '\tmutex_unlock(&dev->mutex);'], 'added_lines': ['\tdev->present = 0;', '\t\tmutex_unlock(&dev->mutex);', '\t\tmutex_unlock(&dev->mutex);']}",True,"In the Linux kernel before 5.3.7, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/usb/misc/iowarrior.c driver, aka CID-edc4746f253d.",6.1,MEDIUM,1,valid,,5
CVE-2019-19528,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"We have to drop the mutex before we close() upon disconnect()
as close() needs the lock. This is safe to do by dropping the
mutex as intfdata is already set to NULL, so open() will fail.

Fixes: 03f36e885fc26 (""USB: open disconnect race in iowarrior"")
Reported-by: syzbot+a64a382964bf6c71a9c0@syzkaller.appspotmail.com
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Oliver Neukum <oneukum@suse.com>
Link: https://lore.kernel.org/r/20190808092728.23417-1-oneukum@suse.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",c468a8aa790e0dfe0a7f8a39db282d39c2c00b46,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c468a8aa790e0dfe0a7f8a39db282d39c2c00b46,drivers/usb/misc/iowarrior.c,iowarrior_disconnect,"static void iowarrior_disconnect(struct usb_interface *interface)
{
struct iowarrior *dev;
int minor;
dev = usb_get_intfdata(interface);
mutex_lock(&iowarrior_open_disc_lock);
usb_set_intfdata(interface, NULL);
minor = dev->minor;
usb_deregister_dev(interface, &iowarrior_class);
mutex_lock(&dev->mutex);
dev->present = 0;
mutex_unlock(&dev->mutex);
mutex_unlock(&iowarrior_open_disc_lock);
if (dev->opened) {
usb_kill_urb(dev->int_in_urb);
wake_up_interruptible(&dev->read_wait);
wake_up_interruptible(&dev->write_wait);
} else {
iowarrior_delete(dev);
}
dev_info(&interface->dev, ""I/O-Warror #%d now disconnected\n"",
minor - IOWARRIOR_MINOR_BASE);
}","static void iowarrior_disconnect(struct usb_interface *VAR_0)
{
struct iowarrior *VAR_1;
int VAR_2;
VAR_1 = usb_get_intfdata(VAR_0);
mutex_lock(&VAR_3);
usb_set_intfdata(VAR_0, NULL);
VAR_2 = VAR_1->minor;
usb_deregister_dev(VAR_0, &VAR_4);
mutex_lock(&VAR_1->mutex);
VAR_1->present = 0;
mutex_unlock(&VAR_1->mutex);
mutex_unlock(&VAR_3);
if (VAR_1->opened) {
usb_kill_urb(VAR_1->int_in_urb);
wake_up_interruptible(&VAR_1->read_wait);
wake_up_interruptible(&VAR_1->write_wait);
} else {
iowarrior_delete(VAR_1);
}
dev_info(&VAR_0->dev, ""I/O-Warror #%d now disconnected\n"",
VAR_2 - VAR_5);
}",torvalds/linux/c468a8aa790e0dfe0a7f8a39db282d39c2c00b46/iowarrior.c/vul/before/0.json,"static void iowarrior_disconnect(struct usb_interface *interface)
{
	struct iowarrior *dev;
	int minor;

	dev = usb_get_intfdata(interface);
	mutex_lock(&iowarrior_open_disc_lock);
	usb_set_intfdata(interface, NULL);
	/* prevent device read, write and ioctl */
	dev->present = 0;

	minor = dev->minor;
	mutex_unlock(&iowarrior_open_disc_lock);
	/* give back our minor - this will call close() locks need to be dropped at this point*/

	usb_deregister_dev(interface, &iowarrior_class);

	mutex_lock(&dev->mutex);

	/* prevent device read, write and ioctl */

	mutex_unlock(&dev->mutex);

	if (dev->opened) {
		/* There is a process that holds a filedescriptor to the device ,
		   so we only shutdown read-/write-ops going on.
		   Deleting the device is postponed until close() was called.
		 */
		usb_kill_urb(dev->int_in_urb);
		wake_up_interruptible(&dev->read_wait);
		wake_up_interruptible(&dev->write_wait);
	} else {
		/* no process is using the device, cleanup now */
		iowarrior_delete(dev);
	}

	dev_info(&interface->dev, ""I/O-Warror #%d now disconnected\n"",
		 minor - IOWARRIOR_MINOR_BASE);
}","static void iowarrior_disconnect(struct usb_interface *VAR_0)
{
	struct iowarrior *VAR_1;
	int VAR_2;

	VAR_1 = usb_get_intfdata(VAR_0);
	mutex_lock(&VAR_3);
	usb_set_intfdata(VAR_0, NULL);
	/* COMMENT_0 */
	VAR_1->present = 0;

	VAR_2 = VAR_1->minor;
	mutex_unlock(&VAR_3);
	/* COMMENT_1 */

	usb_deregister_dev(VAR_0, &VAR_4);

	mutex_lock(&VAR_1->mutex);

	/* COMMENT_0 */

	mutex_unlock(&VAR_1->mutex);

	if (VAR_1->opened) {
		/* COMMENT_2 */
                                                  
                                                               
     
		usb_kill_urb(VAR_1->int_in_urb);
		wake_up_interruptible(&VAR_1->read_wait);
		wake_up_interruptible(&VAR_1->write_wait);
	} else {
		/* COMMENT_6 */
		iowarrior_delete(VAR_1);
	}

	dev_info(&VAR_0->dev, ""I/O-Warror #%d now disconnected\n"",
		 VAR_2 - VAR_5);
}",torvalds/linux/c468a8aa790e0dfe0a7f8a39db282d39c2c00b46/iowarrior.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,19 +6,20 @@
 	dev = usb_get_intfdata(interface);
 	mutex_lock(&iowarrior_open_disc_lock);
 	usb_set_intfdata(interface, NULL);
+	/* prevent device read, write and ioctl */
+	dev->present = 0;
 
 	minor = dev->minor;
+	mutex_unlock(&iowarrior_open_disc_lock);
+	/* give back our minor - this will call close() locks need to be dropped at this point*/
 
-	/* give back our minor */
 	usb_deregister_dev(interface, &iowarrior_class);
 
 	mutex_lock(&dev->mutex);
 
 	/* prevent device read, write and ioctl */
-	dev->present = 0;
 
 	mutex_unlock(&dev->mutex);
-	mutex_unlock(&iowarrior_open_disc_lock);
 
 	if (dev->opened) {
 		/* There is a process that holds a filedescriptor to the device ,","{'deleted_lines': ['\t/* give back our minor */', '\tdev->present = 0;', '\tmutex_unlock(&iowarrior_open_disc_lock);'], 'added_lines': ['\t/* prevent device read, write and ioctl */', '\tdev->present = 0;', '\tmutex_unlock(&iowarrior_open_disc_lock);', '\t/* give back our minor - this will call close() locks need to be dropped at this point*/']}",True,"In the Linux kernel before 5.3.7, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/usb/misc/iowarrior.c driver, aka CID-edc4746f253d.",6.1,MEDIUM,1,valid,,5
CVE-2021-39922,['CWE-120'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"C12.22: Track our allocation sizes.

Add an allocated size element to the TOP_ELEMENT_CONTROL struct and use
it to make sure we're not trying to read past the end of a buffer in
canonify_unencrypted_header. Fixes #17636.
",b760c356c7050f75faa5421d6812ab312b8651a1,https://gitlab.com/wireshark/wireshark/-/commit/b760c356c7050f75faa5421d6812ab312b8651a1,epan/dissectors/packet-c1222.c,proto_register_c1222,"void proto_register_c1222(void) {
static hf_register_info hf[] = {
{ &hf_c1222_epsem_flags,
{ ""C12.22 EPSEM Flags"", ""c1222.epsem.flags"",
FT_UINT8, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_reserved,
{ ""C12.22 Reserved Flag"", ""c1222.epsem.flags.reserved"",
FT_BOOLEAN, 8,
NULL, C1222_EPSEM_FLAG_RESERVED,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_recovery,
{ ""C12.22 Recovery Flag"", ""c1222.epsem.flags.recovery"",
FT_BOOLEAN, 8,
NULL, C1222_EPSEM_FLAG_RECOVERY_SESSION,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_proxy,
{ ""C12.22 Proxy Service Used Flag"", ""c1222.epsem.flags.proxy"",
FT_BOOLEAN, 8,
NULL, C1222_EPSEM_FLAG_PROXY_SERVICE_USED,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_ed_class,
{ ""C12.22 ED Class Flag"", ""c1222.epsem.flags.ed_class"",
FT_BOOLEAN, 8,
NULL, C1222_EPSEM_FLAG_ED_CLASS_INCLUDED,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_security_modes,
{ ""C12.22 Security Mode Flags"", ""c1222.epsem.flags.security"",
FT_UINT8, BASE_HEX,
VALS(c1222_security_modes), C1222_EPSEM_FLAG_SECURITY_MODE,
NULL, HFILL }
},
{ &hf_c1222_epsem_flags_response_control,
{ ""C12.22 Response Control Flags"", ""c1222.epsem.flags.response_control"",
FT_UINT8, BASE_HEX,
VALS(c1222_response_control), C1222_EPSEM_FLAG_RESPONSE_CONTROL,
NULL, HFILL }
},
{ &hf_c1222_epsem_ed_class,
{ ""C12.22 EPSEM ED Class"", ""c1222.epsem.edclass"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_epsem_total,
{ ""C12.22 EPSEM"", ""c1222.epsem.data"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_epsem_mac,
{ ""C12.22 EPSEM MAC"", ""c1222.epsem.mac"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_cmd,
{ ""C12.22 Command"", ""c1222.cmd"",
FT_UINT8, BASE_HEX,
VALS(commandnames), 0x0,
NULL, HFILL }
},
{ &hf_c1222_err,
{ ""C12.22 Response"", ""c1222.err"",
FT_UINT8, BASE_HEX,
VALS(commandnames), 0x0,
NULL, HFILL }
},
{ &hf_c1222_logon_id,
{ ""C12.22 Logon User-Id"", ""c1222.logon.id"",
FT_UINT16, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_logon_user,
{ ""C12.22 Logon User"", ""c1222.logon.user"",
FT_STRING, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_security_password,
{ ""C12.22 Security Password"", ""c1222.security.password"",
FT_STRING, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_auth_len,
{ ""C12.22 Authenticate Request Length"", ""c1222.authenticate.len"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_auth_data,
{ ""C12.22 Authenticate Data"", ""c1222.authenticate.data"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_read_table,
{ ""C12.22 Table"", ""c1222.read.table"",
FT_UINT16, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_read_offset,
{ ""C12.22 Offset"", ""c1222.read.offset"",
FT_UINT24, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_read_count,
{ ""C12.22 Count"", ""c1222.read.count"",
FT_UINT16, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_table,
{ ""C12.22 Table"", ""c1222.write.table"",
FT_UINT16, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_offset,
{ ""C12.22 Offset"", ""c1222.write.offset"",
FT_UINT24, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_size,
{ ""C12.22 Table Size"", ""c1222.write.size"",
FT_UINT16, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_data,
{ ""C12.22 Table Data"", ""c1222.write.data"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_chksum,
{ ""C12.22 Table Data Checksum"", ""c1222.write.chksum"",
FT_UINT8, BASE_HEX,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_write_chksum_status,
{ ""C12.22 Table Data Checksum Status"", ""c1222.write.chksum.status"",
FT_UINT8, BASE_NONE,
VALS(proto_checksum_vals), 0x0,
NULL, HFILL }
},
{ &hf_c1222_procedure_response,
{ ""C12.22 Procedure Response"", ""c1222.procedure.response"",
FT_UINT16, BASE_DEC,
VALS(c1222_proc_response_control), C1222_PROCEDURE_RESPONSE,
NULL, HFILL }
},
{ &hf_c1222_procedure_mfg,
{ ""C12.22 Procedure Mfg"", ""c1222.procedure.mfg"",
FT_UINT16, BASE_DEC,
NULL, C1222_PROCEDURE_MFG,
NULL, HFILL }
},
{ &hf_c1222_procedure_num,
{ ""C12.22 Procedure Number"", ""c1222.procedure.num"",
FT_UINT16, BASE_DEC,
NULL, C1222_PROCEDURE_NUMBER,
NULL, HFILL }
},
{ &hf_c1222_procedure_sequence,
{ ""C12.22 Procedure Sequence Number"", ""c1222.procedure.sequence"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_neg_pkt_size,
{ ""C12.22 Negotiate Packet Size"", ""c1222.negotiate.pktsize"",
FT_UINT16, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_neg_nbr_pkts,
{ ""C12.22 Negotiate Number of Packets"", ""c1222.negotiate.numpkts"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_wait_secs,
{ ""C12.22 Wait Seconds"", ""c1222.wait.seconds"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_timing_setup_traffic,
{ ""C12.22 Timing Setup Channel Traffic Timeout"", ""c1222.timingsetup.traffic"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_timing_setup_inter_char,
{ ""C12.22 Timing Setup Intercharacter Timeout"", ""c1222.timingsetup.interchar"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_timing_setup_resp_to,
{ ""C12.22 Timing Setup Response Timeout"", ""c1222.timingsetup.respto"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_timing_setup_nbr_retries,
{ ""C12.22 Timing Setup Number of Retries"", ""c1222.timingsetup.nbrretries"",
FT_UINT8, BASE_DEC,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_data,
{ ""C12.22 data"", ""c1222.data"",
FT_BYTES, BASE_NONE,
NULL, 0x0,
NULL, HFILL }
},
{ &hf_c1222_epsem_crypto_good,
{ ""Crypto good"", ""c1222.crypto_good"",
FT_BOOLEAN, BASE_NONE,
NULL, 0x0,
""True: crypto ok; False: doesn't match or not checked"", HFILL }
},
{ &hf_c1222_epsem_crypto_bad,
{ ""Crypto bad"", ""c1222.crypto_bad"",
FT_BOOLEAN, BASE_NONE,
NULL, 0x0,
""True: crypto bad; False: crypto ok or not checked"", HFILL }
},
#line 1 ""./asn1/c1222/packet-c1222-hfarr.c""
{ &hf_c1222_MESSAGE_PDU,
{ ""MESSAGE"", ""c1222.MESSAGE_element"",
FT_NONE, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_aSO_context,
{ ""aSO-context"", ""c1222.aSO_context"",
FT_OID, BASE_NONE, NULL, 0,
""ASO_qualifier"", HFILL }},
{ &hf_c1222_called_AP_title,
{ ""called-AP-title"", ""c1222.called_AP_title"",
FT_UINT32, BASE_DEC, VALS(c1222_Called_AP_title_vals), 0,
NULL, HFILL }},
{ &hf_c1222_called_AP_invocation_id,
{ ""called-AP-invocation-id"", ""c1222.called_AP_invocation_id"",
FT_UINT32, BASE_DEC, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_calling_AP_title,
{ ""calling-AP-title"", ""c1222.calling_AP_title"",
FT_UINT32, BASE_DEC, VALS(c1222_Calling_AP_title_vals), 0,
NULL, HFILL }},
{ &hf_c1222_calling_AE_qualifier,
{ ""calling-AE-qualifier"", ""c1222.calling_AE_qualifier"",
FT_UINT32, BASE_DEC, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_calling_AP_invocation_id,
{ ""calling-AP-invocation-id"", ""c1222.calling_AP_invocation_id"",
FT_UINT32, BASE_DEC, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_mechanism_name,
{ ""mechanism-name"", ""c1222.mechanism_name"",
FT_OID, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_calling_authentication_value,
{ ""calling-authentication-value"", ""c1222.calling_authentication_value_element"",
FT_NONE, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_user_information,
{ ""user-information"", ""c1222.user_information_element"",
FT_NONE, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_called_ap_title_abs,
{ ""called-ap-title-abs"", ""c1222.called_ap_title_abs"",
FT_OID, BASE_NONE, NULL, 0,
""OBJECT_IDENTIFIER"", HFILL }},
{ &hf_c1222_called_ap_title_rel,
{ ""called-ap-title-rel"", ""c1222.called_ap_title_rel"",
FT_REL_OID, BASE_NONE, NULL, 0,
""RELATIVE_OID"", HFILL }},
{ &hf_c1222_calling_ap_title_abs,
{ ""calling-ap-title-abs"", ""c1222.calling_ap_title_abs"",
FT_OID, BASE_NONE, NULL, 0,
""OBJECT_IDENTIFIER"", HFILL }},
{ &hf_c1222_calling_ap_title_rel,
{ ""calling-ap-title-rel"", ""c1222.calling_ap_title_rel"",
FT_REL_OID, BASE_NONE, NULL, 0,
""RELATIVE_OID"", HFILL }},
{ &hf_c1222_calling_authentication_value_indirect,
{ ""calling-authentication-value-indirect"", ""c1222.calling_authentication_value_indirect"",
FT_INT32, BASE_DEC, NULL, 0,
""INTEGER"", HFILL }},
{ &hf_c1222_calling_authentication_value_encoding,
{ ""calling-authentication-value-encoding"", ""c1222.calling_authentication_value_encoding"",
FT_UINT32, BASE_DEC, VALS(c1222_Authentication_value_encoding_vals), 0,
""Authentication_value_encoding"", HFILL }},
{ &hf_c1222_calling_authentication_value_single_asn1,
{ ""calling-authentication-value-single-asn1"", ""c1222.calling_authentication_value_single_asn1"",
FT_UINT32, BASE_DEC, VALS(c1222_Calling_authentication_value_single_asn1_vals), 0,
NULL, HFILL }},
{ &hf_c1222_calling_authentication_value_octet_aligned,
{ ""calling-authentication-value-octet-aligned"", ""c1222.calling_authentication_value_octet_aligned"",
FT_BYTES, BASE_NONE, NULL, 0,
""OCTET_STRING"", HFILL }},
{ &hf_c1222_calling_authentication_value_c1222,
{ ""calling-authentication-value-c1222"", ""c1222.calling_authentication_value_c1222_element"",
FT_NONE, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_calling_authentication_value_c1221,
{ ""calling-authentication-value-c1221"", ""c1222.calling_authentication_value_c1221"",
FT_UINT32, BASE_DEC, VALS(c1222_Calling_authentication_value_c1221_U_vals), 0,
NULL, HFILL }},
{ &hf_c1222_key_id_element,
{ ""key-id-element"", ""c1222.key_id_element"",
FT_BYTES, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_iv_element,
{ ""iv-element"", ""c1222.iv_element"",
FT_BYTES, BASE_NONE, NULL, 0,
NULL, HFILL }},
{ &hf_c1222_c1221_auth_identification,
{ ""c1221-auth-identification"", ""c1222.c1221_auth_identification"",
FT_BYTES, BASE_NONE, NULL, 0,
""OCTET_STRING_SIZE_CONSTR001"", HFILL }},
{ &hf_c1222_c1221_auth_request,
{ ""c1221-auth-request"", ""c1222.c1221_auth_request"",
FT_BYTES, BASE_NONE, NULL, 0,
""OCTET_STRING_SIZE_1_255"", HFILL }},
{ &hf_c1222_c1221_auth_response,
{ ""c1221-auth-response"", ""c1222.c1221_auth_response"",
FT_BYTES, BASE_NONE, NULL, 0,
""OCTET_STRING_SIZE_CONSTR002"", HFILL }},
#line 1354 ""./asn1/c1222/packet-c1222-template.c""
};
static gint *ett[] = {
&ett_c1222,
&ett_c1222_epsem,
&ett_c1222_flags,
&ett_c1222_crypto,
&ett_c1222_cmd,
#line 1 ""./asn1/c1222/packet-c1222-ettarr.c""
&ett_c1222_MESSAGE_U,
&ett_c1222_Called_AP_title,
&ett_c1222_Calling_AP_title,
&ett_c1222_Calling_authentication_value_U,
&ett_c1222_Authentication_value_encoding,
&ett_c1222_Calling_authentication_value_single_asn1,
&ett_c1222_Calling_authentication_value_c1222_U,
&ett_c1222_Calling_authentication_value_c1221_U,
#line 1364 ""./asn1/c1222/packet-c1222-template.c""
};
static ei_register_info ei[] = {
{ &ei_c1222_command_truncated, { ""c1222.command_truncated"", PI_MALFORMED, PI_ERROR, ""C12.22 command truncated"", EXPFILL }},
{ &ei_c1222_bad_checksum, { ""c1222.bad_checksum"", PI_CHECKSUM, PI_ERROR, ""Bad checksum"", EXPFILL }},
{ &ei_c1222_epsem_missing, { ""c1222.epsem.missing"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM missing"", EXPFILL }},
{ &ei_c1222_epsem_failed_authentication, { ""c1222.epsem.failed_authentication"", PI_SECURITY, PI_ERROR, ""C12.22 EPSEM failed authentication"", EXPFILL }},
{ &ei_c1222_epsem_not_decryped, { ""c1222.epsem.not_decryped"", PI_UNDECODED, PI_WARN, ""C12.22 EPSEM could not be decrypted"", EXPFILL }},
{ &ei_c1222_ed_class_missing, { ""c1222.ed_class_missing"", PI_SECURITY, PI_ERROR, ""C12.22 ED Class missing"", EXPFILL }},
{ &ei_c1222_epsem_ber_length_error, { ""c1222.epsem.ber_length_error"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM BER length error"", EXPFILL }},
{ &ei_c1222_epsem_field_length_error, { ""c1222.epsem.field_length_error"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM field length error"", EXPFILL }},
{ &ei_c1222_mac_missing, { ""c1222.mac_missing"", PI_MALFORMED, PI_ERROR, ""C12.22 MAC missing"", EXPFILL }},
};
expert_module_t* expert_c1222;
module_t *c1222_module;
static uat_field_t c1222_uat_flds[] = {
UAT_FLD_HEX(c1222_users,keynum,""Key ID"",""Key identifier in hexadecimal""),
UAT_FLD_BUFFER(c1222_users, key, ""Key"", ""Encryption key as 16-byte hex string""),
UAT_END_FIELDS
};
proto_c1222 = proto_register_protocol(PNAME, PSNAME, PFNAME);
proto_register_field_array(proto_c1222, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
expert_c1222 = expert_register_protocol(proto_c1222);
expert_register_field_array(expert_c1222, ei, array_length(ei));
c1222_module = prefs_register_protocol(proto_c1222, proto_reg_handoff_c1222);
prefs_register_bool_preference(c1222_module, ""desegment"",
""Reassemble all C12.22 messages spanning multiple TCP segments"",
""Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments"",
&c1222_desegment);
prefs_register_string_preference(c1222_module, ""baseoid"", ""Base OID to use for relative OIDs"",
""Base object identifier for use in resolving relative object identifiers"",
&c1222_baseoid_str);
prefs_register_bool_preference(c1222_module, ""decrypt"",
""Verify crypto for all applicable C12.22 messages"",
""Whether the C12.22 dissector should verify the crypto for all relevant messages"",
&c1222_decrypt);
prefs_register_bool_preference(c1222_module, ""big_endian"",
""Interpret multibyte numbers as big endian"",
""Whether the C12.22 dissector should interpret procedure numbers as big-endian"",
&c1222_big_endian);
c1222_uat = uat_new(""Decryption Table"",
sizeof(c1222_uat_data_t),         
""c1222_decryption_table"",         
TRUE,                             
&c1222_uat_data,                  
&num_c1222_uat_data,              
UAT_AFFECTS_DISSECTION,           
NULL,                             
c1222_uat_data_copy_cb,           
c1222_uat_data_update_cb,         
c1222_uat_data_free_cb,           
NULL,                             
NULL,                             
c1222_uat_flds);                  
prefs_register_uat_preference(c1222_module,
""decryption_table"",
""Decryption Table"",
""Table of security parameters for decryption of C12.22 packets"",
c1222_uat);
}
void
proto_reg_handoff_c1222(void)
{
static gboolean initialized = FALSE;
guint8 *temp = NULL;
if( !initialized ) {
c1222_handle = create_dissector_handle(dissect_c1222, proto_c1222);
c1222_udp_handle = create_dissector_handle(dissect_c1222_common, proto_c1222);
dissector_add_uint_with_preference(""tcp.port"", C1222_PORT, c1222_handle);
dissector_add_uint_with_preference(""udp.port"", C1222_PORT, c1222_udp_handle);
initialized = TRUE;
}
if (c1222_baseoid_str && (c1222_baseoid_str[0] != '\0') &&
((c1222_baseoid_len = oid_string2encoded(NULL, c1222_baseoid_str, &temp)) != 0)) {
c1222_baseoid = (guint8 *)wmem_realloc(wmem_epan_scope(), c1222_baseoid, c1222_baseoid_len);
memcpy(c1222_baseoid, temp, c1222_baseoid_len);
wmem_free(NULL, temp);
} else if (c1222_baseoid) {
wmem_free(wmem_epan_scope(), c1222_baseoid);
c1222_baseoid = NULL;
c1222_baseoid_len = 0;
}
}","void proto_register_c1222(void) {
static hf_register_info VAR_0[] = {
{ &VAR_1,
{ ""C12.22 EPSEM Flags"", ""c1222.epsem.flags"",
VAR_2, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_5,
{ ""C12.22 Reserved Flag"", ""c1222.epsem.flags.reserved"",
VAR_6, 8,
NULL, VAR_7,
NULL, VAR_4 }
},
{ &VAR_8,
{ ""C12.22 Recovery Flag"", ""c1222.epsem.flags.recovery"",
VAR_6, 8,
NULL, VAR_9,
NULL, VAR_4 }
},
{ &VAR_10,
{ ""C12.22 Proxy Service Used Flag"", ""c1222.epsem.flags.proxy"",
VAR_6, 8,
NULL, VAR_11,
NULL, VAR_4 }
},
{ &VAR_12,
{ ""C12.22 ED Class Flag"", ""c1222.epsem.flags.ed_class"",
VAR_6, 8,
NULL, VAR_13,
NULL, VAR_4 }
},
{ &VAR_14,
{ ""C12.22 Security Mode Flags"", ""c1222.epsem.flags.security"",
VAR_2, VAR_3,
VALS(VAR_15), VAR_16,
NULL, VAR_4 }
},
{ &VAR_17,
{ ""C12.22 Response Control Flags"", ""c1222.epsem.flags.response_control"",
VAR_2, VAR_3,
VALS(VAR_18), VAR_19,
NULL, VAR_4 }
},
{ &VAR_20,
{ ""C12.22 EPSEM ED Class"", ""c1222.epsem.edclass"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_23,
{ ""C12.22 EPSEM"", ""c1222.epsem.data"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_24,
{ ""C12.22 EPSEM MAC"", ""c1222.epsem.mac"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_25,
{ ""C12.22 Command"", ""c1222.cmd"",
VAR_2, VAR_3,
VALS(VAR_26), 0x0,
NULL, VAR_4 }
},
{ &VAR_27,
{ ""C12.22 Response"", ""c1222.err"",
VAR_2, VAR_3,
VALS(VAR_26), 0x0,
NULL, VAR_4 }
},
{ &VAR_28,
{ ""C12.22 Logon User-Id"", ""c1222.logon.id"",
VAR_29, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_31,
{ ""C12.22 Logon User"", ""c1222.logon.user"",
VAR_32, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_33,
{ ""C12.22 Security Password"", ""c1222.security.password"",
VAR_32, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_34,
{ ""C12.22 Authenticate Request Length"", ""c1222.authenticate.len"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_35,
{ ""C12.22 Authenticate Data"", ""c1222.authenticate.data"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_36,
{ ""C12.22 Table"", ""c1222.read.table"",
VAR_29, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_37,
{ ""C12.22 Offset"", ""c1222.read.offset"",
VAR_38, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_39,
{ ""C12.22 Count"", ""c1222.read.count"",
VAR_29, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_40,
{ ""C12.22 Table"", ""c1222.write.table"",
VAR_29, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_41,
{ ""C12.22 Offset"", ""c1222.write.offset"",
VAR_38, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_42,
{ ""C12.22 Table Size"", ""c1222.write.size"",
VAR_29, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_43,
{ ""C12.22 Table Data"", ""c1222.write.data"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_44,
{ ""C12.22 Table Data Checksum"", ""c1222.write.chksum"",
VAR_2, VAR_3,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_45,
{ ""C12.22 Table Data Checksum Status"", ""c1222.write.chksum.status"",
VAR_2, VAR_22,
VALS(VAR_46), 0x0,
NULL, VAR_4 }
},
{ &VAR_47,
{ ""C12.22 Procedure Response"", ""c1222.procedure.response"",
VAR_29, VAR_30,
VALS(VAR_48), VAR_49,
NULL, VAR_4 }
},
{ &VAR_50,
{ ""C12.22 Procedure Mfg"", ""c1222.procedure.mfg"",
VAR_29, VAR_30,
NULL, VAR_51,
NULL, VAR_4 }
},
{ &VAR_52,
{ ""C12.22 Procedure Number"", ""c1222.procedure.num"",
VAR_29, VAR_30,
NULL, VAR_53,
NULL, VAR_4 }
},
{ &VAR_54,
{ ""C12.22 Procedure Sequence Number"", ""c1222.procedure.sequence"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_55,
{ ""C12.22 Negotiate Packet Size"", ""c1222.negotiate.pktsize"",
VAR_29, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_56,
{ ""C12.22 Negotiate Number of Packets"", ""c1222.negotiate.numpkts"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_57,
{ ""C12.22 Wait Seconds"", ""c1222.wait.seconds"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_58,
{ ""C12.22 Timing Setup Channel Traffic Timeout"", ""c1222.timingsetup.traffic"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_59,
{ ""C12.22 Timing Setup Intercharacter Timeout"", ""c1222.timingsetup.interchar"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_60,
{ ""C12.22 Timing Setup Response Timeout"", ""c1222.timingsetup.respto"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_61,
{ ""C12.22 Timing Setup Number of Retries"", ""c1222.timingsetup.nbrretries"",
VAR_2, VAR_30,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_62,
{ ""C12.22 data"", ""c1222.data"",
VAR_21, VAR_22,
NULL, 0x0,
NULL, VAR_4 }
},
{ &VAR_63,
{ ""Crypto good"", ""c1222.crypto_good"",
VAR_6, VAR_22,
NULL, 0x0,
""True: crypto ok; False: doesn't match or not checked"", VAR_4 }
},
{ &VAR_64,
{ ""Crypto bad"", ""c1222.crypto_bad"",
VAR_6, VAR_22,
NULL, 0x0,
""True: crypto bad; False: crypto ok or not checked"", VAR_4 }
},
#line 1 ""./asn1/c1222/packet-c1222-hfarr.c""
{ &VAR_65,
{ ""MESSAGE"", ""c1222.MESSAGE_element"",
VAR_66, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_67,
{ ""aSO-context"", ""c1222.aSO_context"",
VAR_68, VAR_22, NULL, 0,
""ASO_qualifier"", VAR_4 }},
{ &VAR_69,
{ ""called-AP-title"", ""c1222.called_AP_title"",
VAR_70, VAR_30, VALS(VAR_71), 0,
NULL, VAR_4 }},
{ &VAR_72,
{ ""called-AP-invocation-id"", ""c1222.called_AP_invocation_id"",
VAR_70, VAR_30, NULL, 0,
NULL, VAR_4 }},
{ &VAR_73,
{ ""calling-AP-title"", ""c1222.calling_AP_title"",
VAR_70, VAR_30, VALS(VAR_74), 0,
NULL, VAR_4 }},
{ &VAR_75,
{ ""calling-AE-qualifier"", ""c1222.calling_AE_qualifier"",
VAR_70, VAR_30, NULL, 0,
NULL, VAR_4 }},
{ &VAR_76,
{ ""calling-AP-invocation-id"", ""c1222.calling_AP_invocation_id"",
VAR_70, VAR_30, NULL, 0,
NULL, VAR_4 }},
{ &VAR_77,
{ ""mechanism-name"", ""c1222.mechanism_name"",
VAR_68, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_78,
{ ""calling-authentication-value"", ""c1222.calling_authentication_value_element"",
VAR_66, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_79,
{ ""user-information"", ""c1222.user_information_element"",
VAR_66, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_80,
{ ""called-ap-title-abs"", ""c1222.called_ap_title_abs"",
VAR_68, VAR_22, NULL, 0,
""OBJECT_IDENTIFIER"", VAR_4 }},
{ &VAR_81,
{ ""called-ap-title-rel"", ""c1222.called_ap_title_rel"",
VAR_82, VAR_22, NULL, 0,
""RELATIVE_OID"", VAR_4 }},
{ &VAR_83,
{ ""calling-ap-title-abs"", ""c1222.calling_ap_title_abs"",
VAR_68, VAR_22, NULL, 0,
""OBJECT_IDENTIFIER"", VAR_4 }},
{ &VAR_84,
{ ""calling-ap-title-rel"", ""c1222.calling_ap_title_rel"",
VAR_82, VAR_22, NULL, 0,
""RELATIVE_OID"", VAR_4 }},
{ &VAR_85,
{ ""calling-authentication-value-indirect"", ""c1222.calling_authentication_value_indirect"",
VAR_86, VAR_30, NULL, 0,
""INTEGER"", VAR_4 }},
{ &VAR_87,
{ ""calling-authentication-value-encoding"", ""c1222.calling_authentication_value_encoding"",
VAR_70, VAR_30, VALS(VAR_88), 0,
""Authentication_value_encoding"", VAR_4 }},
{ &VAR_89,
{ ""calling-authentication-value-single-asn1"", ""c1222.calling_authentication_value_single_asn1"",
VAR_70, VAR_30, VALS(VAR_90), 0,
NULL, VAR_4 }},
{ &VAR_91,
{ ""calling-authentication-value-octet-aligned"", ""c1222.calling_authentication_value_octet_aligned"",
VAR_21, VAR_22, NULL, 0,
""OCTET_STRING"", VAR_4 }},
{ &VAR_92,
{ ""calling-authentication-value-c1222"", ""c1222.calling_authentication_value_c1222_element"",
VAR_66, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_93,
{ ""calling-authentication-value-c1221"", ""c1222.calling_authentication_value_c1221"",
VAR_70, VAR_30, VALS(VAR_94), 0,
NULL, VAR_4 }},
{ &VAR_95,
{ ""key-id-element"", ""c1222.key_id_element"",
VAR_21, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_96,
{ ""iv-element"", ""c1222.iv_element"",
VAR_21, VAR_22, NULL, 0,
NULL, VAR_4 }},
{ &VAR_97,
{ ""c1221-auth-identification"", ""c1222.c1221_auth_identification"",
VAR_21, VAR_22, NULL, 0,
""OCTET_STRING_SIZE_CONSTR001"", VAR_4 }},
{ &VAR_98,
{ ""c1221-auth-request"", ""c1222.c1221_auth_request"",
VAR_21, VAR_22, NULL, 0,
""OCTET_STRING_SIZE_1_255"", VAR_4 }},
{ &VAR_99,
{ ""c1221-auth-response"", ""c1222.c1221_auth_response"",
VAR_21, VAR_22, NULL, 0,
""OCTET_STRING_SIZE_CONSTR002"", VAR_4 }},
#line 1354 ""./asn1/c1222/packet-c1222-template.c""
};
static gint *VAR_100[] = {
&VAR_101,
&VAR_102,
&VAR_103,
&VAR_104,
&VAR_105,
#line 1 ""./asn1/c1222/packet-c1222-ettarr.c""
&VAR_106,
&VAR_107,
&VAR_108,
&VAR_109,
&VAR_110,
&VAR_111,
&VAR_112,
&VAR_113,
#line 1364 ""./asn1/c1222/packet-c1222-template.c""
};
static ei_register_info VAR_114[] = {
{ &VAR_115, { ""c1222.command_truncated"", VAR_116, VAR_117, ""C12.22 command truncated"", VAR_118 }},
{ &VAR_119, { ""c1222.bad_checksum"", VAR_120, VAR_117, ""Bad checksum"", VAR_118 }},
{ &VAR_121, { ""c1222.epsem.missing"", VAR_116, VAR_117, ""C12.22 EPSEM missing"", VAR_118 }},
{ &VAR_122, { ""c1222.epsem.failed_authentication"", VAR_123, VAR_117, ""C12.22 EPSEM failed authentication"", VAR_118 }},
{ &VAR_124, { ""c1222.epsem.not_decryped"", VAR_125, VAR_126, ""C12.22 EPSEM could not be decrypted"", VAR_118 }},
{ &VAR_127, { ""c1222.ed_class_missing"", VAR_123, VAR_117, ""C12.22 ED Class missing"", VAR_118 }},
{ &VAR_128, { ""c1222.epsem.ber_length_error"", VAR_116, VAR_117, ""C12.22 EPSEM BER length error"", VAR_118 }},
{ &VAR_129, { ""c1222.epsem.field_length_error"", VAR_116, VAR_117, ""C12.22 EPSEM field length error"", VAR_118 }},
{ &VAR_130, { ""c1222.mac_missing"", VAR_116, VAR_117, ""C12.22 MAC missing"", VAR_118 }},
};
expert_module_t* VAR_131;
module_t *VAR_132;
static uat_field_t VAR_133[] = {
UAT_FLD_HEX(VAR_134,VAR_135,""Key ID"",""Key identifier in hexadecimal""),
UAT_FLD_BUFFER(VAR_134, VAR_136, ""Key"", ""Encryption key as 16-byte hex string""),
VAR_137
};
VAR_138 = proto_register_protocol(VAR_139, VAR_140, VAR_141);
proto_register_field_array(VAR_138, VAR_0, array_length(VAR_0));
proto_register_subtree_array(VAR_100, array_length(VAR_100));
VAR_131 = expert_register_protocol(VAR_138);
expert_register_field_array(VAR_131, VAR_114, array_length(VAR_114));
VAR_132 = prefs_register_protocol(VAR_138, VAR_142);
prefs_register_bool_preference(VAR_132, ""desegment"",
""Reassemble all C12.22 messages spanning multiple TCP segments"",
""Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments"",
&VAR_143);
prefs_register_string_preference(VAR_132, ""baseoid"", ""Base OID to use for relative OIDs"",
""Base object identifier for use in resolving relative object identifiers"",
&VAR_144);
prefs_register_bool_preference(VAR_132, ""decrypt"",
""Verify crypto for all applicable C12.22 messages"",
""Whether the C12.22 dissector should verify the crypto for all relevant messages"",
&VAR_145);
prefs_register_bool_preference(VAR_132, ""big_endian"",
""Interpret multibyte numbers as big endian"",
""Whether the C12.22 dissector should interpret procedure numbers as big-endian"",
&VAR_146);
VAR_147 = uat_new(""Decryption Table"",
sizeof(VAR_148),         
""c1222_decryption_table"",         
TRUE,                             
&VAR_149,                  
&VAR_150,              
VAR_151,           
NULL,                             
VAR_152,           
VAR_153,         
VAR_154,           
NULL,                             
NULL,                             
VAR_133);                  
prefs_register_uat_preference(VAR_132,
""decryption_table"",
""Decryption Table"",
""Table of security parameters for decryption of C12.22 packets"",
VAR_147);
}
void
proto_reg_handoff_c1222(void)
{
static gboolean VAR_155 = FALSE;
guint8 *VAR_156 = NULL;
if( !VAR_155 ) {
VAR_157 = create_dissector_handle(VAR_158, VAR_138);
VAR_159 = create_dissector_handle(VAR_160, VAR_138);
dissector_add_uint_with_preference(""tcp.port"", VAR_161, VAR_157);
dissector_add_uint_with_preference(""udp.port"", VAR_161, VAR_159);
VAR_155 = TRUE;
}
if (VAR_144 && (VAR_144[0] != '\0') &&
((VAR_162 = oid_string2encoded(NULL, VAR_144, &VAR_156)) != 0)) {
VAR_163 = (guint8 *)wmem_realloc(wmem_epan_scope(), VAR_163, VAR_162);
memcpy(VAR_163, VAR_156, VAR_162);
wmem_free(NULL, VAR_156);
} else if (VAR_163) {
wmem_free(wmem_epan_scope(), VAR_163);
VAR_163 = NULL;
VAR_162 = 0;
}
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222.c/vul/before/0.json,"void proto_register_c1222(void) {

  /* List of fields */
  static hf_register_info hf[] = {
   { &hf_c1222_epsem_flags,
    { ""C12.22 EPSEM Flags"", ""c1222.epsem.flags"",
    FT_UINT8, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_reserved,
    { ""C12.22 Reserved Flag"", ""c1222.epsem.flags.reserved"",
    FT_BOOLEAN, 8,
    NULL, C1222_EPSEM_FLAG_RESERVED,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_recovery,
    { ""C12.22 Recovery Flag"", ""c1222.epsem.flags.recovery"",
    FT_BOOLEAN, 8,
    NULL, C1222_EPSEM_FLAG_RECOVERY_SESSION,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_proxy,
    { ""C12.22 Proxy Service Used Flag"", ""c1222.epsem.flags.proxy"",
    FT_BOOLEAN, 8,
    NULL, C1222_EPSEM_FLAG_PROXY_SERVICE_USED,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_ed_class,
    { ""C12.22 ED Class Flag"", ""c1222.epsem.flags.ed_class"",
    FT_BOOLEAN, 8,
    NULL, C1222_EPSEM_FLAG_ED_CLASS_INCLUDED,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_security_modes,
    { ""C12.22 Security Mode Flags"", ""c1222.epsem.flags.security"",
    FT_UINT8, BASE_HEX,
    VALS(c1222_security_modes), C1222_EPSEM_FLAG_SECURITY_MODE,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_flags_response_control,
    { ""C12.22 Response Control Flags"", ""c1222.epsem.flags.response_control"",
    FT_UINT8, BASE_HEX,
    VALS(c1222_response_control), C1222_EPSEM_FLAG_RESPONSE_CONTROL,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_ed_class,
    { ""C12.22 EPSEM ED Class"", ""c1222.epsem.edclass"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_total,
    { ""C12.22 EPSEM"", ""c1222.epsem.data"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_mac,
    { ""C12.22 EPSEM MAC"", ""c1222.epsem.mac"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_cmd,
    { ""C12.22 Command"", ""c1222.cmd"",
    FT_UINT8, BASE_HEX,
    VALS(commandnames), 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_err,
    { ""C12.22 Response"", ""c1222.err"",
    FT_UINT8, BASE_HEX,
    VALS(commandnames), 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_logon_id,
    { ""C12.22 Logon User-Id"", ""c1222.logon.id"",
    FT_UINT16, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_logon_user,
    { ""C12.22 Logon User"", ""c1222.logon.user"",
    FT_STRING, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_security_password,
    { ""C12.22 Security Password"", ""c1222.security.password"",
    FT_STRING, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_auth_len,
    { ""C12.22 Authenticate Request Length"", ""c1222.authenticate.len"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_auth_data,
    { ""C12.22 Authenticate Data"", ""c1222.authenticate.data"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_read_table,
    { ""C12.22 Table"", ""c1222.read.table"",
    FT_UINT16, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_read_offset,
    { ""C12.22 Offset"", ""c1222.read.offset"",
    FT_UINT24, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_read_count,
    { ""C12.22 Count"", ""c1222.read.count"",
    FT_UINT16, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_table,
    { ""C12.22 Table"", ""c1222.write.table"",
    FT_UINT16, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_offset,
    { ""C12.22 Offset"", ""c1222.write.offset"",
    FT_UINT24, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_size,
    { ""C12.22 Table Size"", ""c1222.write.size"",
    FT_UINT16, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_data,
    { ""C12.22 Table Data"", ""c1222.write.data"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_chksum,
    { ""C12.22 Table Data Checksum"", ""c1222.write.chksum"",
    FT_UINT8, BASE_HEX,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_write_chksum_status,
    { ""C12.22 Table Data Checksum Status"", ""c1222.write.chksum.status"",
    FT_UINT8, BASE_NONE,
    VALS(proto_checksum_vals), 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_procedure_response,
    { ""C12.22 Procedure Response"", ""c1222.procedure.response"",
    FT_UINT16, BASE_DEC,
    VALS(c1222_proc_response_control), C1222_PROCEDURE_RESPONSE,
    NULL, HFILL }
   },
   { &hf_c1222_procedure_mfg,
    { ""C12.22 Procedure Mfg"", ""c1222.procedure.mfg"",
    FT_UINT16, BASE_DEC,
    NULL, C1222_PROCEDURE_MFG,
    NULL, HFILL }
   },
   { &hf_c1222_procedure_num,
    { ""C12.22 Procedure Number"", ""c1222.procedure.num"",
    FT_UINT16, BASE_DEC,
    NULL, C1222_PROCEDURE_NUMBER,
    NULL, HFILL }
   },
   { &hf_c1222_procedure_sequence,
    { ""C12.22 Procedure Sequence Number"", ""c1222.procedure.sequence"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_neg_pkt_size,
    { ""C12.22 Negotiate Packet Size"", ""c1222.negotiate.pktsize"",
    FT_UINT16, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_neg_nbr_pkts,
    { ""C12.22 Negotiate Number of Packets"", ""c1222.negotiate.numpkts"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_wait_secs,
    { ""C12.22 Wait Seconds"", ""c1222.wait.seconds"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_timing_setup_traffic,
    { ""C12.22 Timing Setup Channel Traffic Timeout"", ""c1222.timingsetup.traffic"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_timing_setup_inter_char,
    { ""C12.22 Timing Setup Intercharacter Timeout"", ""c1222.timingsetup.interchar"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_timing_setup_resp_to,
    { ""C12.22 Timing Setup Response Timeout"", ""c1222.timingsetup.respto"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_timing_setup_nbr_retries,
    { ""C12.22 Timing Setup Number of Retries"", ""c1222.timingsetup.nbrretries"",
    FT_UINT8, BASE_DEC,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_data,
    { ""C12.22 data"", ""c1222.data"",
    FT_BYTES, BASE_NONE,
    NULL, 0x0,
    NULL, HFILL }
   },
   { &hf_c1222_epsem_crypto_good,
    { ""Crypto good"", ""c1222.crypto_good"",
    FT_BOOLEAN, BASE_NONE,
    NULL, 0x0,
    ""True: crypto ok; False: doesn't match or not checked"", HFILL }
   },
   { &hf_c1222_epsem_crypto_bad,
    { ""Crypto bad"", ""c1222.crypto_bad"",
    FT_BOOLEAN, BASE_NONE,
    NULL, 0x0,
    ""True: crypto bad; False: crypto ok or not checked"", HFILL }
   },

/*--- Included file: packet-c1222-hfarr.c ---*/
#line 1 ""./asn1/c1222/packet-c1222-hfarr.c""
    { &hf_c1222_MESSAGE_PDU,
      { ""MESSAGE"", ""c1222.MESSAGE_element"",
        FT_NONE, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_aSO_context,
      { ""aSO-context"", ""c1222.aSO_context"",
        FT_OID, BASE_NONE, NULL, 0,
        ""ASO_qualifier"", HFILL }},
    { &hf_c1222_called_AP_title,
      { ""called-AP-title"", ""c1222.called_AP_title"",
        FT_UINT32, BASE_DEC, VALS(c1222_Called_AP_title_vals), 0,
        NULL, HFILL }},
    { &hf_c1222_called_AP_invocation_id,
      { ""called-AP-invocation-id"", ""c1222.called_AP_invocation_id"",
        FT_UINT32, BASE_DEC, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_calling_AP_title,
      { ""calling-AP-title"", ""c1222.calling_AP_title"",
        FT_UINT32, BASE_DEC, VALS(c1222_Calling_AP_title_vals), 0,
        NULL, HFILL }},
    { &hf_c1222_calling_AE_qualifier,
      { ""calling-AE-qualifier"", ""c1222.calling_AE_qualifier"",
        FT_UINT32, BASE_DEC, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_calling_AP_invocation_id,
      { ""calling-AP-invocation-id"", ""c1222.calling_AP_invocation_id"",
        FT_UINT32, BASE_DEC, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_mechanism_name,
      { ""mechanism-name"", ""c1222.mechanism_name"",
        FT_OID, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_calling_authentication_value,
      { ""calling-authentication-value"", ""c1222.calling_authentication_value_element"",
        FT_NONE, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_user_information,
      { ""user-information"", ""c1222.user_information_element"",
        FT_NONE, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_called_ap_title_abs,
      { ""called-ap-title-abs"", ""c1222.called_ap_title_abs"",
        FT_OID, BASE_NONE, NULL, 0,
        ""OBJECT_IDENTIFIER"", HFILL }},
    { &hf_c1222_called_ap_title_rel,
      { ""called-ap-title-rel"", ""c1222.called_ap_title_rel"",
        FT_REL_OID, BASE_NONE, NULL, 0,
        ""RELATIVE_OID"", HFILL }},
    { &hf_c1222_calling_ap_title_abs,
      { ""calling-ap-title-abs"", ""c1222.calling_ap_title_abs"",
        FT_OID, BASE_NONE, NULL, 0,
        ""OBJECT_IDENTIFIER"", HFILL }},
    { &hf_c1222_calling_ap_title_rel,
      { ""calling-ap-title-rel"", ""c1222.calling_ap_title_rel"",
        FT_REL_OID, BASE_NONE, NULL, 0,
        ""RELATIVE_OID"", HFILL }},
    { &hf_c1222_calling_authentication_value_indirect,
      { ""calling-authentication-value-indirect"", ""c1222.calling_authentication_value_indirect"",
        FT_INT32, BASE_DEC, NULL, 0,
        ""INTEGER"", HFILL }},
    { &hf_c1222_calling_authentication_value_encoding,
      { ""calling-authentication-value-encoding"", ""c1222.calling_authentication_value_encoding"",
        FT_UINT32, BASE_DEC, VALS(c1222_Authentication_value_encoding_vals), 0,
        ""Authentication_value_encoding"", HFILL }},
    { &hf_c1222_calling_authentication_value_single_asn1,
      { ""calling-authentication-value-single-asn1"", ""c1222.calling_authentication_value_single_asn1"",
        FT_UINT32, BASE_DEC, VALS(c1222_Calling_authentication_value_single_asn1_vals), 0,
        NULL, HFILL }},
    { &hf_c1222_calling_authentication_value_octet_aligned,
      { ""calling-authentication-value-octet-aligned"", ""c1222.calling_authentication_value_octet_aligned"",
        FT_BYTES, BASE_NONE, NULL, 0,
        ""OCTET_STRING"", HFILL }},
    { &hf_c1222_calling_authentication_value_c1222,
      { ""calling-authentication-value-c1222"", ""c1222.calling_authentication_value_c1222_element"",
        FT_NONE, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_calling_authentication_value_c1221,
      { ""calling-authentication-value-c1221"", ""c1222.calling_authentication_value_c1221"",
        FT_UINT32, BASE_DEC, VALS(c1222_Calling_authentication_value_c1221_U_vals), 0,
        NULL, HFILL }},
    { &hf_c1222_key_id_element,
      { ""key-id-element"", ""c1222.key_id_element"",
        FT_BYTES, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_iv_element,
      { ""iv-element"", ""c1222.iv_element"",
        FT_BYTES, BASE_NONE, NULL, 0,
        NULL, HFILL }},
    { &hf_c1222_c1221_auth_identification,
      { ""c1221-auth-identification"", ""c1222.c1221_auth_identification"",
        FT_BYTES, BASE_NONE, NULL, 0,
        ""OCTET_STRING_SIZE_CONSTR001"", HFILL }},
    { &hf_c1222_c1221_auth_request,
      { ""c1221-auth-request"", ""c1222.c1221_auth_request"",
        FT_BYTES, BASE_NONE, NULL, 0,
        ""OCTET_STRING_SIZE_1_255"", HFILL }},
    { &hf_c1222_c1221_auth_response,
      { ""c1221-auth-response"", ""c1222.c1221_auth_response"",
        FT_BYTES, BASE_NONE, NULL, 0,
        ""OCTET_STRING_SIZE_CONSTR002"", HFILL }},

/*--- End of included file: packet-c1222-hfarr.c ---*/
#line 1379 ""./asn1/c1222/packet-c1222-template.c""
  };

  /* List of subtrees */
  static gint *ett[] = {
                  &ett_c1222,
                  &ett_c1222_epsem,
                  &ett_c1222_flags,
                  &ett_c1222_crypto,
                  &ett_c1222_cmd,

/*--- Included file: packet-c1222-ettarr.c ---*/
#line 1 ""./asn1/c1222/packet-c1222-ettarr.c""
    &ett_c1222_MESSAGE_U,
    &ett_c1222_Called_AP_title,
    &ett_c1222_Calling_AP_title,
    &ett_c1222_Calling_authentication_value_U,
    &ett_c1222_Authentication_value_encoding,
    &ett_c1222_Calling_authentication_value_single_asn1,
    &ett_c1222_Calling_authentication_value_c1222_U,
    &ett_c1222_Calling_authentication_value_c1221_U,

/*--- End of included file: packet-c1222-ettarr.c ---*/
#line 1389 ""./asn1/c1222/packet-c1222-template.c""
  };

  static ei_register_info ei[] = {
    { &ei_c1222_command_truncated, { ""c1222.command_truncated"", PI_MALFORMED, PI_ERROR, ""C12.22 command truncated"", EXPFILL }},
    { &ei_c1222_bad_checksum, { ""c1222.bad_checksum"", PI_CHECKSUM, PI_ERROR, ""Bad checksum"", EXPFILL }},
    { &ei_c1222_epsem_missing, { ""c1222.epsem.missing"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM missing"", EXPFILL }},
    { &ei_c1222_epsem_failed_authentication, { ""c1222.epsem.failed_authentication"", PI_SECURITY, PI_ERROR, ""C12.22 EPSEM failed authentication"", EXPFILL }},
    { &ei_c1222_epsem_not_decryped, { ""c1222.epsem.not_decryped"", PI_UNDECODED, PI_WARN, ""C12.22 EPSEM could not be decrypted"", EXPFILL }},
    { &ei_c1222_ed_class_missing, { ""c1222.ed_class_missing"", PI_SECURITY, PI_ERROR, ""C12.22 ED Class missing"", EXPFILL }},
    { &ei_c1222_epsem_ber_length_error, { ""c1222.epsem.ber_length_error"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM BER length error"", EXPFILL }},
    { &ei_c1222_epsem_field_length_error, { ""c1222.epsem.field_length_error"", PI_MALFORMED, PI_ERROR, ""C12.22 EPSEM field length error"", EXPFILL }},
    { &ei_c1222_mac_missing, { ""c1222.mac_missing"", PI_MALFORMED, PI_ERROR, ""C12.22 MAC missing"", EXPFILL }},
  };

  expert_module_t* expert_c1222;
  module_t *c1222_module;

  static uat_field_t c1222_uat_flds[] = {
    UAT_FLD_HEX(c1222_users,keynum,""Key ID"",""Key identifier in hexadecimal""),
    UAT_FLD_BUFFER(c1222_users, key, ""Key"", ""Encryption key as 16-byte hex string""),
    UAT_END_FIELDS
  };

  /* Register protocol */
  proto_c1222 = proto_register_protocol(PNAME, PSNAME, PFNAME);
  /* Register fields and subtrees */
  proto_register_field_array(proto_c1222, hf, array_length(hf));
  proto_register_subtree_array(ett, array_length(ett));
  expert_c1222 = expert_register_protocol(proto_c1222);
  expert_register_field_array(expert_c1222, ei, array_length(ei));
  c1222_module = prefs_register_protocol(proto_c1222, proto_reg_handoff_c1222);
  prefs_register_bool_preference(c1222_module, ""desegment"",
        ""Reassemble all C12.22 messages spanning multiple TCP segments"",
        ""Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments"",
        &c1222_desegment);
  prefs_register_string_preference(c1222_module, ""baseoid"", ""Base OID to use for relative OIDs"",
        ""Base object identifier for use in resolving relative object identifiers"",
        &c1222_baseoid_str);
  prefs_register_bool_preference(c1222_module, ""decrypt"",
        ""Verify crypto for all applicable C12.22 messages"",
        ""Whether the C12.22 dissector should verify the crypto for all relevant messages"",
        &c1222_decrypt);
  prefs_register_bool_preference(c1222_module, ""big_endian"",
        ""Interpret multibyte numbers as big endian"",
        ""Whether the C12.22 dissector should interpret procedure numbers as big-endian"",
        &c1222_big_endian);

  c1222_uat = uat_new(""Decryption Table"",
      sizeof(c1222_uat_data_t),         /* record size */
      ""c1222_decryption_table"",         /* filename */
      TRUE,                             /* from_profile */
      &c1222_uat_data,                  /* data_ptr */
      &num_c1222_uat_data,              /* numitems_ptr */
      UAT_AFFECTS_DISSECTION,           /* affects dissection of packets, but not set of named fields */
      NULL,                             /* help */
      c1222_uat_data_copy_cb,           /* copy callback */
      c1222_uat_data_update_cb,         /* update callback */
      c1222_uat_data_free_cb,           /* free callback */
      NULL,                             /* post update callback */
      NULL,                             /* reset callback */
      c1222_uat_flds);                  /* UAT field definitions */

  prefs_register_uat_preference(c1222_module,
      ""decryption_table"",
      ""Decryption Table"",
      ""Table of security parameters for decryption of C12.22 packets"",
      c1222_uat);
}

/*--- proto_reg_handoff_c1222 ---------------------------------------*/
void
proto_reg_handoff_c1222(void)
{
  static gboolean initialized = FALSE;
  guint8 *temp = NULL;

  if( !initialized ) {
    c1222_handle = create_dissector_handle(dissect_c1222, proto_c1222);
    c1222_udp_handle = create_dissector_handle(dissect_c1222_common, proto_c1222);
    dissector_add_uint_with_preference(""tcp.port"", C1222_PORT, c1222_handle);
    dissector_add_uint_with_preference(""udp.port"", C1222_PORT, c1222_udp_handle);
    initialized = TRUE;
  }
  if (c1222_baseoid_str && (c1222_baseoid_str[0] != '\0') &&
      ((c1222_baseoid_len = oid_string2encoded(NULL, c1222_baseoid_str, &temp)) != 0)) {
    c1222_baseoid = (guint8 *)wmem_realloc(wmem_epan_scope(), c1222_baseoid, c1222_baseoid_len);
    memcpy(c1222_baseoid, temp, c1222_baseoid_len);
    wmem_free(NULL, temp);
  } else if (c1222_baseoid) {
      wmem_free(wmem_epan_scope(), c1222_baseoid);
      c1222_baseoid = NULL;
      c1222_baseoid_len = 0;
  }
}","void proto_register_c1222(void) {

  /* COMMENT_0 */
  static hf_register_info VAR_0[] = {
   { &VAR_1,
    { ""C12.22 EPSEM Flags"", ""c1222.epsem.flags"",
    VAR_2, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_5,
    { ""C12.22 Reserved Flag"", ""c1222.epsem.flags.reserved"",
    VAR_6, 8,
    NULL, VAR_7,
    NULL, VAR_4 }
   },
   { &VAR_8,
    { ""C12.22 Recovery Flag"", ""c1222.epsem.flags.recovery"",
    VAR_6, 8,
    NULL, VAR_9,
    NULL, VAR_4 }
   },
   { &VAR_10,
    { ""C12.22 Proxy Service Used Flag"", ""c1222.epsem.flags.proxy"",
    VAR_6, 8,
    NULL, VAR_11,
    NULL, VAR_4 }
   },
   { &VAR_12,
    { ""C12.22 ED Class Flag"", ""c1222.epsem.flags.ed_class"",
    VAR_6, 8,
    NULL, VAR_13,
    NULL, VAR_4 }
   },
   { &VAR_14,
    { ""C12.22 Security Mode Flags"", ""c1222.epsem.flags.security"",
    VAR_2, VAR_3,
    VALS(VAR_15), VAR_16,
    NULL, VAR_4 }
   },
   { &VAR_17,
    { ""C12.22 Response Control Flags"", ""c1222.epsem.flags.response_control"",
    VAR_2, VAR_3,
    VALS(VAR_18), VAR_19,
    NULL, VAR_4 }
   },
   { &VAR_20,
    { ""C12.22 EPSEM ED Class"", ""c1222.epsem.edclass"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_23,
    { ""C12.22 EPSEM"", ""c1222.epsem.data"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_24,
    { ""C12.22 EPSEM MAC"", ""c1222.epsem.mac"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_25,
    { ""C12.22 Command"", ""c1222.cmd"",
    VAR_2, VAR_3,
    VALS(VAR_26), 0x0,
    NULL, VAR_4 }
   },
   { &VAR_27,
    { ""C12.22 Response"", ""c1222.err"",
    VAR_2, VAR_3,
    VALS(VAR_26), 0x0,
    NULL, VAR_4 }
   },
   { &VAR_28,
    { ""C12.22 Logon User-Id"", ""c1222.logon.id"",
    VAR_29, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_31,
    { ""C12.22 Logon User"", ""c1222.logon.user"",
    VAR_32, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_33,
    { ""C12.22 Security Password"", ""c1222.security.password"",
    VAR_32, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_34,
    { ""C12.22 Authenticate Request Length"", ""c1222.authenticate.len"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_35,
    { ""C12.22 Authenticate Data"", ""c1222.authenticate.data"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_36,
    { ""C12.22 Table"", ""c1222.read.table"",
    VAR_29, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_37,
    { ""C12.22 Offset"", ""c1222.read.offset"",
    VAR_38, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_39,
    { ""C12.22 Count"", ""c1222.read.count"",
    VAR_29, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_40,
    { ""C12.22 Table"", ""c1222.write.table"",
    VAR_29, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_41,
    { ""C12.22 Offset"", ""c1222.write.offset"",
    VAR_38, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_42,
    { ""C12.22 Table Size"", ""c1222.write.size"",
    VAR_29, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_43,
    { ""C12.22 Table Data"", ""c1222.write.data"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_44,
    { ""C12.22 Table Data Checksum"", ""c1222.write.chksum"",
    VAR_2, VAR_3,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_45,
    { ""C12.22 Table Data Checksum Status"", ""c1222.write.chksum.status"",
    VAR_2, VAR_22,
    VALS(VAR_46), 0x0,
    NULL, VAR_4 }
   },
   { &VAR_47,
    { ""C12.22 Procedure Response"", ""c1222.procedure.response"",
    VAR_29, VAR_30,
    VALS(VAR_48), VAR_49,
    NULL, VAR_4 }
   },
   { &VAR_50,
    { ""C12.22 Procedure Mfg"", ""c1222.procedure.mfg"",
    VAR_29, VAR_30,
    NULL, VAR_51,
    NULL, VAR_4 }
   },
   { &VAR_52,
    { ""C12.22 Procedure Number"", ""c1222.procedure.num"",
    VAR_29, VAR_30,
    NULL, VAR_53,
    NULL, VAR_4 }
   },
   { &VAR_54,
    { ""C12.22 Procedure Sequence Number"", ""c1222.procedure.sequence"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_55,
    { ""C12.22 Negotiate Packet Size"", ""c1222.negotiate.pktsize"",
    VAR_29, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_56,
    { ""C12.22 Negotiate Number of Packets"", ""c1222.negotiate.numpkts"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_57,
    { ""C12.22 Wait Seconds"", ""c1222.wait.seconds"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_58,
    { ""C12.22 Timing Setup Channel Traffic Timeout"", ""c1222.timingsetup.traffic"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_59,
    { ""C12.22 Timing Setup Intercharacter Timeout"", ""c1222.timingsetup.interchar"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_60,
    { ""C12.22 Timing Setup Response Timeout"", ""c1222.timingsetup.respto"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_61,
    { ""C12.22 Timing Setup Number of Retries"", ""c1222.timingsetup.nbrretries"",
    VAR_2, VAR_30,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_62,
    { ""C12.22 data"", ""c1222.data"",
    VAR_21, VAR_22,
    NULL, 0x0,
    NULL, VAR_4 }
   },
   { &VAR_63,
    { ""Crypto good"", ""c1222.crypto_good"",
    VAR_6, VAR_22,
    NULL, 0x0,
    ""True: crypto ok; False: doesn't match or not checked"", VAR_4 }
   },
   { &VAR_64,
    { ""Crypto bad"", ""c1222.crypto_bad"",
    VAR_6, VAR_22,
    NULL, 0x0,
    ""True: crypto bad; False: crypto ok or not checked"", VAR_4 }
   },

/* COMMENT_1 */
#line 1 ""./asn1/c1222/packet-c1222-hfarr.c""
    { &VAR_65,
      { ""MESSAGE"", ""c1222.MESSAGE_element"",
        VAR_66, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_67,
      { ""aSO-context"", ""c1222.aSO_context"",
        VAR_68, VAR_22, NULL, 0,
        ""ASO_qualifier"", VAR_4 }},
    { &VAR_69,
      { ""called-AP-title"", ""c1222.called_AP_title"",
        VAR_70, VAR_30, VALS(VAR_71), 0,
        NULL, VAR_4 }},
    { &VAR_72,
      { ""called-AP-invocation-id"", ""c1222.called_AP_invocation_id"",
        VAR_70, VAR_30, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_73,
      { ""calling-AP-title"", ""c1222.calling_AP_title"",
        VAR_70, VAR_30, VALS(VAR_74), 0,
        NULL, VAR_4 }},
    { &VAR_75,
      { ""calling-AE-qualifier"", ""c1222.calling_AE_qualifier"",
        VAR_70, VAR_30, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_76,
      { ""calling-AP-invocation-id"", ""c1222.calling_AP_invocation_id"",
        VAR_70, VAR_30, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_77,
      { ""mechanism-name"", ""c1222.mechanism_name"",
        VAR_68, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_78,
      { ""calling-authentication-value"", ""c1222.calling_authentication_value_element"",
        VAR_66, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_79,
      { ""user-information"", ""c1222.user_information_element"",
        VAR_66, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_80,
      { ""called-ap-title-abs"", ""c1222.called_ap_title_abs"",
        VAR_68, VAR_22, NULL, 0,
        ""OBJECT_IDENTIFIER"", VAR_4 }},
    { &VAR_81,
      { ""called-ap-title-rel"", ""c1222.called_ap_title_rel"",
        VAR_82, VAR_22, NULL, 0,
        ""RELATIVE_OID"", VAR_4 }},
    { &VAR_83,
      { ""calling-ap-title-abs"", ""c1222.calling_ap_title_abs"",
        VAR_68, VAR_22, NULL, 0,
        ""OBJECT_IDENTIFIER"", VAR_4 }},
    { &VAR_84,
      { ""calling-ap-title-rel"", ""c1222.calling_ap_title_rel"",
        VAR_82, VAR_22, NULL, 0,
        ""RELATIVE_OID"", VAR_4 }},
    { &VAR_85,
      { ""calling-authentication-value-indirect"", ""c1222.calling_authentication_value_indirect"",
        VAR_86, VAR_30, NULL, 0,
        ""INTEGER"", VAR_4 }},
    { &VAR_87,
      { ""calling-authentication-value-encoding"", ""c1222.calling_authentication_value_encoding"",
        VAR_70, VAR_30, VALS(VAR_88), 0,
        ""Authentication_value_encoding"", VAR_4 }},
    { &VAR_89,
      { ""calling-authentication-value-single-asn1"", ""c1222.calling_authentication_value_single_asn1"",
        VAR_70, VAR_30, VALS(VAR_90), 0,
        NULL, VAR_4 }},
    { &VAR_91,
      { ""calling-authentication-value-octet-aligned"", ""c1222.calling_authentication_value_octet_aligned"",
        VAR_21, VAR_22, NULL, 0,
        ""OCTET_STRING"", VAR_4 }},
    { &VAR_92,
      { ""calling-authentication-value-c1222"", ""c1222.calling_authentication_value_c1222_element"",
        VAR_66, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_93,
      { ""calling-authentication-value-c1221"", ""c1222.calling_authentication_value_c1221"",
        VAR_70, VAR_30, VALS(VAR_94), 0,
        NULL, VAR_4 }},
    { &VAR_95,
      { ""key-id-element"", ""c1222.key_id_element"",
        VAR_21, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_96,
      { ""iv-element"", ""c1222.iv_element"",
        VAR_21, VAR_22, NULL, 0,
        NULL, VAR_4 }},
    { &VAR_97,
      { ""c1221-auth-identification"", ""c1222.c1221_auth_identification"",
        VAR_21, VAR_22, NULL, 0,
        ""OCTET_STRING_SIZE_CONSTR001"", VAR_4 }},
    { &VAR_98,
      { ""c1221-auth-request"", ""c1222.c1221_auth_request"",
        VAR_21, VAR_22, NULL, 0,
        ""OCTET_STRING_SIZE_1_255"", VAR_4 }},
    { &VAR_99,
      { ""c1221-auth-response"", ""c1222.c1221_auth_response"",
        VAR_21, VAR_22, NULL, 0,
        ""OCTET_STRING_SIZE_CONSTR002"", VAR_4 }},

/* COMMENT_2 */
#line 1379 ""./asn1/c1222/packet-c1222-template.c""
  };

  /* COMMENT_3 */
  static gint *VAR_100[] = {
                  &VAR_101,
                  &VAR_102,
                  &VAR_103,
                  &VAR_104,
                  &VAR_105,

/* COMMENT_4 */
#line 1 ""./asn1/c1222/packet-c1222-ettarr.c""
    &VAR_106,
    &VAR_107,
    &VAR_108,
    &VAR_109,
    &VAR_110,
    &VAR_111,
    &VAR_112,
    &VAR_113,

/* COMMENT_5 */
#line 1389 ""./asn1/c1222/packet-c1222-template.c""
  };

  static ei_register_info VAR_114[] = {
    { &VAR_115, { ""c1222.command_truncated"", VAR_116, VAR_117, ""C12.22 command truncated"", VAR_118 }},
    { &VAR_119, { ""c1222.bad_checksum"", VAR_120, VAR_117, ""Bad checksum"", VAR_118 }},
    { &VAR_121, { ""c1222.epsem.missing"", VAR_116, VAR_117, ""C12.22 EPSEM missing"", VAR_118 }},
    { &VAR_122, { ""c1222.epsem.failed_authentication"", VAR_123, VAR_117, ""C12.22 EPSEM failed authentication"", VAR_118 }},
    { &VAR_124, { ""c1222.epsem.not_decryped"", VAR_125, VAR_126, ""C12.22 EPSEM could not be decrypted"", VAR_118 }},
    { &VAR_127, { ""c1222.ed_class_missing"", VAR_123, VAR_117, ""C12.22 ED Class missing"", VAR_118 }},
    { &VAR_128, { ""c1222.epsem.ber_length_error"", VAR_116, VAR_117, ""C12.22 EPSEM BER length error"", VAR_118 }},
    { &VAR_129, { ""c1222.epsem.field_length_error"", VAR_116, VAR_117, ""C12.22 EPSEM field length error"", VAR_118 }},
    { &VAR_130, { ""c1222.mac_missing"", VAR_116, VAR_117, ""C12.22 MAC missing"", VAR_118 }},
  };

  expert_module_t* VAR_131;
  module_t *VAR_132;

  static uat_field_t VAR_133[] = {
    UAT_FLD_HEX(VAR_134,VAR_135,""Key ID"",""Key identifier in hexadecimal""),
    UAT_FLD_BUFFER(VAR_134, VAR_136, ""Key"", ""Encryption key as 16-byte hex string""),
    VAR_137
  };

  /* COMMENT_6 */
  VAR_138 = proto_register_protocol(VAR_139, VAR_140, VAR_141);
  /* COMMENT_7 */
  proto_register_field_array(VAR_138, VAR_0, array_length(VAR_0));
  proto_register_subtree_array(VAR_100, array_length(VAR_100));
  VAR_131 = expert_register_protocol(VAR_138);
  expert_register_field_array(VAR_131, VAR_114, array_length(VAR_114));
  VAR_132 = prefs_register_protocol(VAR_138, VAR_142);
  prefs_register_bool_preference(VAR_132, ""desegment"",
        ""Reassemble all C12.22 messages spanning multiple TCP segments"",
        ""Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments"",
        &VAR_143);
  prefs_register_string_preference(VAR_132, ""baseoid"", ""Base OID to use for relative OIDs"",
        ""Base object identifier for use in resolving relative object identifiers"",
        &VAR_144);
  prefs_register_bool_preference(VAR_132, ""decrypt"",
        ""Verify crypto for all applicable C12.22 messages"",
        ""Whether the C12.22 dissector should verify the crypto for all relevant messages"",
        &VAR_145);
  prefs_register_bool_preference(VAR_132, ""big_endian"",
        ""Interpret multibyte numbers as big endian"",
        ""Whether the C12.22 dissector should interpret procedure numbers as big-endian"",
        &VAR_146);

  VAR_147 = uat_new(""Decryption Table"",
      sizeof(VAR_148),         /* COMMENT_8 */
      ""c1222_decryption_table"",         /* COMMENT_9 */
      TRUE,                             /* COMMENT_10 */
      &VAR_149,                  /* COMMENT_11 */
      &VAR_150,              /* COMMENT_12 */
      VAR_151,           /* COMMENT_13 */
      NULL,                             /* COMMENT_14 */
      VAR_152,           /* COMMENT_15 */
      VAR_153,         /* COMMENT_16 */
      VAR_154,           /* COMMENT_17 */
      NULL,                             /* COMMENT_18 */
      NULL,                             /* COMMENT_19 */
      VAR_133);                  /* COMMENT_20 */

  prefs_register_uat_preference(VAR_132,
      ""decryption_table"",
      ""Decryption Table"",
      ""Table of security parameters for decryption of C12.22 packets"",
      VAR_147);
}

/* COMMENT_21 */
void
proto_reg_handoff_c1222(void)
{
  static gboolean VAR_155 = FALSE;
  guint8 *VAR_156 = NULL;

  if( !VAR_155 ) {
    VAR_157 = create_dissector_handle(VAR_158, VAR_138);
    VAR_159 = create_dissector_handle(VAR_160, VAR_138);
    dissector_add_uint_with_preference(""tcp.port"", VAR_161, VAR_157);
    dissector_add_uint_with_preference(""udp.port"", VAR_161, VAR_159);
    VAR_155 = TRUE;
  }
  if (VAR_144 && (VAR_144[0] != '\0') &&
      ((VAR_162 = oid_string2encoded(NULL, VAR_144, &VAR_156)) != 0)) {
    VAR_163 = (guint8 *)wmem_realloc(wmem_epan_scope(), VAR_163, VAR_162);
    memcpy(VAR_163, VAR_156, VAR_162);
    wmem_free(NULL, VAR_156);
  } else if (VAR_163) {
      wmem_free(wmem_epan_scope(), VAR_163);
      VAR_163 = NULL;
      VAR_162 = 0;
  }
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -347,7 +347,7 @@
         ""OCTET_STRING_SIZE_CONSTR002"", HFILL }},
 
 /*--- End of included file: packet-c1222-hfarr.c ---*/
-#line 1354 ""./asn1/c1222/packet-c1222-template.c""
+#line 1379 ""./asn1/c1222/packet-c1222-template.c""
   };
 
   /* List of subtrees */
@@ -370,7 +370,7 @@
     &ett_c1222_Calling_authentication_value_c1221_U,
 
 /*--- End of included file: packet-c1222-ettarr.c ---*/
-#line 1364 ""./asn1/c1222/packet-c1222-template.c""
+#line 1389 ""./asn1/c1222/packet-c1222-template.c""
   };
 
   static ei_register_info ei[] = {","{'deleted_lines': ['#line 1354 ""./asn1/c1222/packet-c1222-template.c""', '#line 1364 ""./asn1/c1222/packet-c1222-template.c""'], 'added_lines': ['#line 1379 ""./asn1/c1222/packet-c1222-template.c""', '#line 1389 ""./asn1/c1222/packet-c1222-template.c""']}",True,Buffer overflow in the C12.22 dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-39922,['CWE-120'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"C12.22: Track our allocation sizes.

Add an allocated size element to the TOP_ELEMENT_CONTROL struct and use
it to make sure we're not trying to read past the end of a buffer in
canonify_unencrypted_header. Fixes #17636.
",b760c356c7050f75faa5421d6812ab312b8651a1,https://gitlab.com/wireshark/wireshark/-/commit/b760c356c7050f75faa5421d6812ab312b8651a1,epan/dissectors/packet-c1222.c,canonify_unencrypted_header,"static gboolean
canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
{
const TOP_ELEMENT_CONTROL *t = canonifyTable;
guint32 len;
for (t = canonifyTable; t->element != NULL; t++)
{
len = *(t->length);
if (t->required && *(t->element) == NULL)
return FALSE;
if (*(t->element) != NULL) {
if (t->addtag) {
buff[(*offset)++] = t->tag;
(*offset) += encode_ber_len(&buff[*offset], len, 4);
}
if (t->truncate) {
len = 3+2*get_ber_len_size(len);
}
if (buffsize < *offset + len) {
return FALSE;
}
memcpy(&buff[*offset], *(t->element), len);
(*offset) += len;
if (t->addtag) {
*(t->element) = NULL;
}
}
}
return TRUE;
}","static gboolean
canonify_unencrypted_header(guchar *VAR_0, guint32 *VAR_1, guint32 VAR_2)
{
const TOP_ELEMENT_CONTROL *VAR_3 = VAR_4;
guint32 VAR_5;
for (VAR_3 = VAR_4; VAR_3->element != NULL; VAR_3++)
{
VAR_5 = *(VAR_3->length);
if (VAR_3->required && *(VAR_3->element) == NULL)
return FALSE;
if (*(VAR_3->element) != NULL) {
if (VAR_3->addtag) {
VAR_0[(*VAR_1)++] = VAR_3->tag;
(*VAR_1) += encode_ber_len(&VAR_0[*VAR_1], VAR_5, 4);
}
if (VAR_3->truncate) {
VAR_5 = 3+2*get_ber_len_size(VAR_5);
}
if (VAR_2 < *VAR_1 + VAR_5) {
return FALSE;
}
memcpy(&VAR_0[*VAR_1], *(VAR_3->element), VAR_5);
(*VAR_1) += VAR_5;
if (VAR_3->addtag) {
*(VAR_3->element) = NULL;
}
}
}
return TRUE;
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222.c/vul/before/1.json,"static gboolean
canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
{
  const TOP_ELEMENT_CONTROL *t = canonifyTable;
  guint32 len, allocated;

  for (t = canonifyTable; t->element != NULL; t++)
  {
    len = *(t->length);
    allocated = *(t->allocated);
    if (t->required && *(t->element) == NULL)
      return FALSE;
    if (*(t->element) != NULL) {
      if (t->addtag) {
        /* recreate original tag and length */
        buff[(*offset)++] = t->tag;
        (*offset) += encode_ber_len(&buff[*offset], len, 4);
      }
      if (t->truncate) {
        len = 3+2*get_ber_len_size(len);
      }
      /* bail out if the cannonization buffer is too small */
      /* this should never happen! */
      if (buffsize < *offset + len) {
        return FALSE;
      }
      /* bail out if our we're trying to read past the end of our element */
      /* the network is always hostile */
      if (allocated < len) {
        return FALSE;
      }
      memcpy(&buff[*offset], *(t->element), len);
      (*offset) += len;
      if (t->addtag) {
          *(t->element) = NULL;
      }
    }
  }
  return TRUE;
}","static gboolean
canonify_unencrypted_header(guchar *VAR_0, guint32 *VAR_1, guint32 VAR_2)
{
  const TOP_ELEMENT_CONTROL *VAR_3 = VAR_4;
  guint32 VAR_5, VAR_6;

  for (VAR_3 = VAR_4; VAR_3->element != NULL; VAR_3++)
  {
    VAR_5 = *(VAR_3->length);
    VAR_6 = *(VAR_3->allocated);
    if (VAR_3->required && *(VAR_3->element) == NULL)
      return FALSE;
    if (*(VAR_3->element) != NULL) {
      if (VAR_3->addtag) {
        /* COMMENT_0 */
        VAR_0[(*VAR_1)++] = VAR_3->tag;
        (*VAR_1) += encode_ber_len(&VAR_0[*VAR_1], VAR_5, 4);
      }
      if (VAR_3->truncate) {
        VAR_5 = 3+2*get_ber_len_size(VAR_5);
      }
      /* COMMENT_1 */
      /* COMMENT_2 */
      if (VAR_2 < *VAR_1 + VAR_5) {
        return FALSE;
      }
      /* COMMENT_3 */
      /* COMMENT_4 */
      if (VAR_6 < VAR_5) {
        return FALSE;
      }
      memcpy(&VAR_0[*VAR_1], *(VAR_3->element), VAR_5);
      (*VAR_1) += VAR_5;
      if (VAR_3->addtag) {
          *(VAR_3->element) = NULL;
      }
    }
  }
  return TRUE;
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,11 +2,12 @@
 canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
 {
   const TOP_ELEMENT_CONTROL *t = canonifyTable;
-  guint32 len;
+  guint32 len, allocated;
 
   for (t = canonifyTable; t->element != NULL; t++)
   {
     len = *(t->length);
+    allocated = *(t->allocated);
     if (t->required && *(t->element) == NULL)
       return FALSE;
     if (*(t->element) != NULL) {
@@ -23,6 +24,11 @@
       if (buffsize < *offset + len) {
         return FALSE;
       }
+      /* bail out if our we're trying to read past the end of our element */
+      /* the network is always hostile */
+      if (allocated < len) {
+        return FALSE;
+      }
       memcpy(&buff[*offset], *(t->element), len);
       (*offset) += len;
       if (t->addtag) {","{'deleted_lines': ['  guint32 len;'], 'added_lines': ['  guint32 len, allocated;', '    allocated = *(t->allocated);', ""      /* bail out if our we're trying to read past the end of our element */"", '      /* the network is always hostile */', '      if (allocated < len) {', '        return FALSE;', '      }']}",True,Buffer overflow in the C12.22 dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-39922,['CWE-120'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"C12.22: Track our allocation sizes.

Add an allocated size element to the TOP_ELEMENT_CONTROL struct and use
it to make sure we're not trying to read past the end of a buffer in
canonify_unencrypted_header. Fixes #17636.
",b760c356c7050f75faa5421d6812ab312b8651a1,https://gitlab.com/wireshark/wireshark/-/commit/b760c356c7050f75faa5421d6812ab312b8651a1,epan/dissectors/asn1/c1222/packet-c1222-template.c,canonify_unencrypted_header,"static gboolean
canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
{
const TOP_ELEMENT_CONTROL *t = canonifyTable;
guint32 len;
for (t = canonifyTable; t->element != NULL; t++)
{
len = *(t->length);
if (t->required && *(t->element) == NULL)
return FALSE;
if (*(t->element) != NULL) {
if (t->addtag) {
buff[(*offset)++] = t->tag;
(*offset) += encode_ber_len(&buff[*offset], len, 4);
}
if (t->truncate) {
len = 3+2*get_ber_len_size(len);
}
if (buffsize < *offset + len) {
return FALSE;
}
memcpy(&buff[*offset], *(t->element), len);
(*offset) += len;
if (t->addtag) {
*(t->element) = NULL;
}
}
}
return TRUE;
}","static gboolean
canonify_unencrypted_header(guchar *VAR_0, guint32 *VAR_1, guint32 VAR_2)
{
const TOP_ELEMENT_CONTROL *VAR_3 = VAR_4;
guint32 VAR_5;
for (VAR_3 = VAR_4; VAR_3->element != NULL; VAR_3++)
{
VAR_5 = *(VAR_3->length);
if (VAR_3->required && *(VAR_3->element) == NULL)
return FALSE;
if (*(VAR_3->element) != NULL) {
if (VAR_3->addtag) {
VAR_0[(*VAR_1)++] = VAR_3->tag;
(*VAR_1) += encode_ber_len(&VAR_0[*VAR_1], VAR_5, 4);
}
if (VAR_3->truncate) {
VAR_5 = 3+2*get_ber_len_size(VAR_5);
}
if (VAR_2 < *VAR_1 + VAR_5) {
return FALSE;
}
memcpy(&VAR_0[*VAR_1], *(VAR_3->element), VAR_5);
(*VAR_1) += VAR_5;
if (VAR_3->addtag) {
*(VAR_3->element) = NULL;
}
}
}
return TRUE;
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222-template.c/vul/before/0.json,"static gboolean
canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
{
  const TOP_ELEMENT_CONTROL *t = canonifyTable;
  guint32 len, allocated;

  for (t = canonifyTable; t->element != NULL; t++)
  {
    len = *(t->length);
    allocated = *(t->allocated);
    if (t->required && *(t->element) == NULL)
      return FALSE;
    if (*(t->element) != NULL) {
      if (t->addtag) {
        /* recreate original tag and length */
        buff[(*offset)++] = t->tag;
        (*offset) += encode_ber_len(&buff[*offset], len, 4);
      }
      if (t->truncate) {
        len = 3+2*get_ber_len_size(len);
      }
      /* bail out if the cannonization buffer is too small */
      /* this should never happen! */
      if (buffsize < *offset + len) {
        return FALSE;
      }
      /* bail out if our we're trying to read past the end of our element */
      /* the network is always hostile */
      if (allocated < len) {
        return FALSE;
      }
      memcpy(&buff[*offset], *(t->element), len);
      (*offset) += len;
      if (t->addtag) {
          *(t->element) = NULL;
      }
    }
  }
  return TRUE;
}","static gboolean
canonify_unencrypted_header(guchar *VAR_0, guint32 *VAR_1, guint32 VAR_2)
{
  const TOP_ELEMENT_CONTROL *VAR_3 = VAR_4;
  guint32 VAR_5, VAR_6;

  for (VAR_3 = VAR_4; VAR_3->element != NULL; VAR_3++)
  {
    VAR_5 = *(VAR_3->length);
    VAR_6 = *(VAR_3->allocated);
    if (VAR_3->required && *(VAR_3->element) == NULL)
      return FALSE;
    if (*(VAR_3->element) != NULL) {
      if (VAR_3->addtag) {
        /* COMMENT_0 */
        VAR_0[(*VAR_1)++] = VAR_3->tag;
        (*VAR_1) += encode_ber_len(&VAR_0[*VAR_1], VAR_5, 4);
      }
      if (VAR_3->truncate) {
        VAR_5 = 3+2*get_ber_len_size(VAR_5);
      }
      /* COMMENT_1 */
      /* COMMENT_2 */
      if (VAR_2 < *VAR_1 + VAR_5) {
        return FALSE;
      }
      /* COMMENT_3 */
      /* COMMENT_4 */
      if (VAR_6 < VAR_5) {
        return FALSE;
      }
      memcpy(&VAR_0[*VAR_1], *(VAR_3->element), VAR_5);
      (*VAR_1) += VAR_5;
      if (VAR_3->addtag) {
          *(VAR_3->element) = NULL;
      }
    }
  }
  return TRUE;
}",wireshark/b760c356c7050f75faa5421d6812ab312b8651a1/packet-c1222-template.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,11 +2,12 @@
 canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize)
 {
   const TOP_ELEMENT_CONTROL *t = canonifyTable;
-  guint32 len;
+  guint32 len, allocated;
 
   for (t = canonifyTable; t->element != NULL; t++)
   {
     len = *(t->length);
+    allocated = *(t->allocated);
     if (t->required && *(t->element) == NULL)
       return FALSE;
     if (*(t->element) != NULL) {
@@ -23,6 +24,11 @@
       if (buffsize < *offset + len) {
         return FALSE;
       }
+      /* bail out if our we're trying to read past the end of our element */
+      /* the network is always hostile */
+      if (allocated < len) {
+        return FALSE;
+      }
       memcpy(&buff[*offset], *(t->element), len);
       (*offset) += len;
       if (t->addtag) {","{'deleted_lines': ['  guint32 len;'], 'added_lines': ['  guint32 len, allocated;', '    allocated = *(t->allocated);', ""      /* bail out if our we're trying to read past the end of our element */"", '      /* the network is always hostile */', '      if (allocated < len) {', '        return FALSE;', '      }']}",True,Buffer overflow in the C12.22 dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-39926,['CWE-120'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"BT HCI_ISO: Don't overrun our reassembly buffer.

Fixes #17649.
",acaaad150b75a295184588c4127698a77493c9f0,https://gitlab.com/wireshark/wireshark/-/commit/acaaad150b75a295184588c4127698a77493c9f0,epan/dissectors/packet-bthci_iso.c,dissect_bthci_iso,"static gint
dissect_bthci_iso(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
proto_item               *bthci_iso_item;
proto_tree               *bthci_iso_tree;
proto_item               *sub_item;
guint16                   flags;
guint16                   pb_flag = FALSE;
guint16                   length;
gboolean                  fragmented = FALSE;
gint                      offset = 0;
tvbuff_t                 *next_tvb;
chandle_data_t           *chandle_data;
bluetooth_data_t         *bluetooth_data;
wmem_tree_key_t           key[6];
guint32                   k_connection_handle = 0;
guint32                   k_stream_handle;
guint32                   k_frame_number;
guint32                   k_interface_id;
guint32                   k_adapter_id;
guint32                   direction;
remote_bdaddr_t          *remote_bdaddr;
const gchar              *localhost_name;
guint8                   *localhost_bdaddr;
const gchar              *localhost_ether_addr;
gchar                    *localhost_addr_name;
gint                      localhost_length;
localhost_bdaddr_entry_t *localhost_bdaddr_entry;
localhost_name_entry_t   *localhost_name_entry;
chandle_session_t        *chandle_session;
wmem_tree_t              *subtree;
stream_connection_handle_pair_t *handle_pairs;
iso_data_info_t          iso_data_info;
if (data == NULL)
return 0;
bthci_iso_item = proto_tree_add_item(tree, proto_bthci_iso, tvb, offset, -1, ENC_NA);
bthci_iso_tree = proto_item_add_subtree(bthci_iso_item, ett_bthci_iso);
switch (pinfo->p2p_dir) {
case P2P_DIR_SENT:
col_set_str(pinfo->cinfo, COL_INFO, ""Sent "");
break;
case P2P_DIR_RECV:
col_set_str(pinfo->cinfo, COL_INFO, ""Rcvd "");
break;
default:
col_set_str(pinfo->cinfo, COL_INFO, ""UnknownDirection "");
break;
}
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""HCI_ISO"");
flags   = tvb_get_letohs(tvb, offset);
pb_flag = (flags >> 12) & 0x3;
iso_data_info.timestamp_present = (flags >> 14) & 0x1;
iso_data_info.handle = flags & 0xfff;
proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_chandle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_pb_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_ts_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
length = tvb_get_letohs(tvb, offset);
sub_item = proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_data_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (pb_flag != 0x2) {
fragmented = TRUE;
}
bluetooth_data = (bluetooth_data_t *) data;
DISSECTOR_ASSERT(bluetooth_data);
k_interface_id      = bluetooth_data->interface_id;
k_adapter_id        = bluetooth_data->adapter_id;
k_stream_handle     = flags & 0x0fff;
direction           = pinfo->p2p_dir;
k_frame_number      = pinfo->num;
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_stream_handle;
key[3].length = 0;
key[3].key    = NULL;
subtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->chandle_sessions, key);
chandle_session = (subtree) ? (chandle_session_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
if (!(chandle_session &&
chandle_session->connect_in_frame < pinfo->num &&
chandle_session->disconnect_in_frame > pinfo->num)){
chandle_session = NULL;
}
subtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->shandle_to_chandle, key);
handle_pairs = (subtree) ? (stream_connection_handle_pair_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
if (handle_pairs) {
k_connection_handle = handle_pairs->chandle;
key[2].key = &k_connection_handle;
}
key[3].length = 1;
key[3].key    = &k_frame_number;
key[4].length = 0;
key[4].key    = NULL;
remote_bdaddr = (remote_bdaddr_t *)wmem_tree_lookup32_array_le(bluetooth_data->chandle_to_bdaddr, key);
if (remote_bdaddr && remote_bdaddr->interface_id == bluetooth_data->interface_id &&
remote_bdaddr->adapter_id == bluetooth_data->adapter_id &&
remote_bdaddr->chandle == k_connection_handle) {
guint32         k_bd_addr_oui;
guint32         k_bd_addr_id;
guint32         bd_addr_oui;
guint32         bd_addr_id;
device_name_t  *device_name;
const gchar    *remote_name;
const gchar    *remote_ether_addr;
gchar          *remote_addr_name;
gint            remote_length;
bd_addr_oui = remote_bdaddr->bd_addr[0] << 16 | remote_bdaddr->bd_addr[1] << 8 | remote_bdaddr->bd_addr[2];
bd_addr_id  = remote_bdaddr->bd_addr[3] << 16 | remote_bdaddr->bd_addr[4] << 8 | remote_bdaddr->bd_addr[5];
k_bd_addr_oui  = bd_addr_oui;
k_bd_addr_id   = bd_addr_id;
k_frame_number = pinfo->num;
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_bd_addr_id;
key[3].length = 1;
key[3].key    = &k_bd_addr_oui;
key[4].length = 1;
key[4].key    = &k_frame_number;
key[5].length = 0;
key[5].key    = NULL;
device_name = (device_name_t *)wmem_tree_lookup32_array_le(bluetooth_data->bdaddr_to_name, key);
if (device_name && device_name->bd_addr_oui == bd_addr_oui && device_name->bd_addr_id == bd_addr_id)
remote_name = device_name->name;
else
remote_name = """";
remote_ether_addr = get_ether_name(remote_bdaddr->bd_addr);
remote_length = (gint)(strlen(remote_ether_addr) + 3 + strlen(remote_name) + 1);
remote_addr_name = (gchar *)wmem_alloc(pinfo->pool, remote_length);
g_snprintf(remote_addr_name, remote_length, ""%s (%s)"", remote_ether_addr, remote_name);
if (pinfo->p2p_dir == P2P_DIR_RECV) {
set_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(remote_name) + 1, remote_name);
set_address(&pinfo->dl_src, AT_ETHER, 6, remote_bdaddr->bd_addr);
set_address(&pinfo->src, AT_STRINGZ, (int)strlen(remote_addr_name) + 1, remote_addr_name);
} else if (pinfo->p2p_dir == P2P_DIR_SENT) {
set_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(remote_name) + 1, remote_name);
set_address(&pinfo->dl_dst, AT_ETHER, 6, remote_bdaddr->bd_addr);
set_address(&pinfo->dst, AT_STRINGZ, (int)strlen(remote_addr_name) + 1, remote_addr_name);
}
} else {
if (pinfo->p2p_dir == P2P_DIR_RECV) {
set_address(&pinfo->net_src, AT_STRINGZ, 1, """");
set_address(&pinfo->dl_src, AT_STRINGZ, 1, """");
set_address(&pinfo->src, AT_STRINGZ, 10, ""remote ()"");
} else if (pinfo->p2p_dir == P2P_DIR_SENT) {
set_address(&pinfo->net_dst, AT_STRINGZ, 1, """");
set_address(&pinfo->dl_dst, AT_STRINGZ, 1, """");
set_address(&pinfo->dst, AT_STRINGZ, 10, ""remote ()"");
}
}
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_frame_number;
key[3].length = 0;
key[3].key    = NULL;
localhost_bdaddr_entry = (localhost_bdaddr_entry_t *)wmem_tree_lookup32_array_le(bluetooth_data->localhost_bdaddr, key);
localhost_bdaddr = (guint8 *) wmem_alloc(pinfo->pool, 6);
if (localhost_bdaddr_entry && localhost_bdaddr_entry->interface_id == bluetooth_data->interface_id &&
localhost_bdaddr_entry->adapter_id == bluetooth_data->adapter_id) {
localhost_ether_addr = get_ether_name(localhost_bdaddr_entry->bd_addr);
memcpy(localhost_bdaddr, localhost_bdaddr_entry->bd_addr, 6);
} else {
localhost_ether_addr = ""localhost"";
memset(localhost_bdaddr, 0, 6);
}
localhost_name_entry = (localhost_name_entry_t *)wmem_tree_lookup32_array_le(bluetooth_data->localhost_name, key);
if (localhost_name_entry && localhost_name_entry->interface_id == bluetooth_data->interface_id &&
localhost_name_entry->adapter_id == bluetooth_data->adapter_id)
localhost_name = localhost_name_entry->name;
else
localhost_name = """";
localhost_length = (gint)(strlen(localhost_ether_addr) + 3 + strlen(localhost_name) + 1);
localhost_addr_name = (gchar *)wmem_alloc(pinfo->pool, localhost_length);
g_snprintf(localhost_addr_name, localhost_length, ""%s (%s)"", localhost_ether_addr, localhost_name);
if (pinfo->p2p_dir == P2P_DIR_RECV) {
set_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(localhost_name) + 1, localhost_name);
set_address(&pinfo->dl_dst, AT_ETHER, 6, localhost_bdaddr);
set_address(&pinfo->dst, AT_STRINGZ, (int)strlen(localhost_addr_name) + 1, localhost_addr_name);
} else if (pinfo->p2p_dir == P2P_DIR_SENT) {
set_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(localhost_name) + 1, localhost_name);
set_address(&pinfo->dl_src, AT_ETHER, 6, localhost_bdaddr);
set_address(&pinfo->src, AT_STRINGZ, (int)strlen(localhost_addr_name) + 1, localhost_addr_name);
}
key[0].length = 1;
key[0].key = &k_interface_id;
key[1].length = 1;
key[1].key = &k_adapter_id;
key[2].length = 1;
key[2].key = &k_stream_handle;
key[3].length = 1;
key[3].key = &direction;
key[4].length = 0;
key[4].key = NULL;
subtree = (wmem_tree_t *) wmem_tree_lookup32_array(chandle_tree, key);
chandle_data = (subtree) ? (chandle_data_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
if (!pinfo->fd->visited && !chandle_data) {
key[0].length = 1;
key[0].key = &k_interface_id;
key[1].length = 1;
key[1].key = &k_adapter_id;
key[2].length = 1;
key[2].key = &k_stream_handle;
key[3].length = 1;
key[3].key = &direction;
key[4].length = 1;
key[4].key = &k_frame_number;
key[5].length = 0;
key[5].key = NULL;
chandle_data = wmem_new(wmem_file_scope(), chandle_data_t);
chandle_data->start_fragments = wmem_tree_new(wmem_file_scope());
wmem_tree_insert32_array(chandle_tree, key, chandle_data);
} else if (pinfo->fd->visited && !chandle_data) {
DISSECTOR_ASSERT_HINT(0, ""Impossible: no previously session saved"");
}
if (!fragmented || (!iso_reassembly && !pb_flag)) {
if (length < tvb_captured_length_remaining(tvb, offset)) {
if (!fragmented)
expert_add_info(pinfo, sub_item, &ei_length_bad);
length = tvb_captured_length_remaining(tvb, offset);
}
next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_captured_length_remaining(tvb, offset), length);
call_dissector_with_data(bthci_iso_data_handle, next_tvb, pinfo, tree, &iso_data_info);
} else if (fragmented && iso_reassembly) {
multi_fragment_pdu_t *mfp = NULL;
gint                  len;
if (pb_flag == 0x00) { 
if (!pinfo->fd->visited) {
gint timestamp_size = 0;
mfp = (multi_fragment_pdu_t *) wmem_new(wmem_file_scope(), multi_fragment_pdu_t);
mfp->first_frame = pinfo->num;
mfp->last_frame  = 0;
mfp->tot_len     = 4;
len = tvb_captured_length_remaining(tvb, offset);
if (flags & 0x4000) { 
timestamp_size = 4;
}
mfp->tot_len += timestamp_size + (tvb_get_letohs(tvb, offset + 2 + timestamp_size) & 0xfff);
mfp->reassembled = (char *) wmem_alloc(wmem_file_scope(), mfp->tot_len);
if (len <= mfp->tot_len) {
tvb_memcpy(tvb, (guint8 *) mfp->reassembled, offset, len);
mfp->cur_off = len;
wmem_tree_insert32(chandle_data->start_fragments, pinfo->num, mfp);
}
} else {
mfp = (multi_fragment_pdu_t *)wmem_tree_lookup32(chandle_data->start_fragments, pinfo->num);
}
if (mfp != NULL && mfp->last_frame) {
proto_item *item;
item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_reassembled_in, tvb, 0, 0, mfp->last_frame);
proto_item_set_generated(item);
col_append_frame_number(pinfo, COL_INFO, "" [Reassembled in #%u]"", mfp->last_frame);
}
}
else if (pb_flag & 0x01) { 
mfp = (multi_fragment_pdu_t *)wmem_tree_lookup32_le(chandle_data->start_fragments, pinfo->num);
if (!pinfo->fd->visited) {
len = tvb_captured_length_remaining(tvb, offset);
if (mfp != NULL && !mfp->last_frame) {
tvb_memcpy(tvb, (guint8 *) mfp->reassembled + mfp->cur_off, offset, len);
mfp->cur_off += len;
if (pb_flag == 0x03)
mfp->last_frame = pinfo->num;
}
}
if (mfp) {
proto_item *item;
item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_continuation_to, tvb, 0, 0, mfp->first_frame);
proto_item_set_generated(item);
col_append_frame_number(pinfo, COL_INFO, "" [Continuation to #%u]"", mfp->first_frame);
if (mfp->last_frame && mfp->last_frame != pinfo->num) {
item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_reassembled_in, tvb, 0, 0, mfp->last_frame);
proto_item_set_generated(item);
col_append_frame_number(pinfo, COL_INFO, "" [Reassembled in #%u]"", mfp->last_frame);
}
if (pb_flag == 0x03) { 
next_tvb = tvb_new_child_real_data(tvb, (guint8 *) mfp->reassembled, mfp->tot_len, mfp->tot_len);
add_new_data_source(pinfo, next_tvb, ""Reassembled BTHCI ISO"");
call_dissector_with_data(bthci_iso_data_handle, next_tvb, pinfo, tree, &iso_data_info);
}
}
}
}
if (tvb_captured_length_remaining(tvb, offset) > 0) {
sub_item = proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_data, tvb, offset, -1, ENC_NA);
if (fragmented) {
proto_item_append_text(sub_item, "" Fragment"");
}
}
if (chandle_session) {
sub_item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_connect_in, tvb, 0, 0, chandle_session->connect_in_frame);
proto_item_set_generated(sub_item);
if (chandle_session->disconnect_in_frame < G_MAXUINT32) {
sub_item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_disconnect_in, tvb, 0, 0, chandle_session->disconnect_in_frame);
proto_item_set_generated(sub_item);
}
}
return tvb_reported_length(tvb);
}","static gint
dissect_bthci_iso(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
proto_item               *VAR_4;
proto_tree               *VAR_5;
proto_item               *VAR_6;
guint16                   VAR_7;
guint16                   VAR_8 = FALSE;
guint16                   VAR_9;
gboolean                  VAR_10 = FALSE;
gint                      VAR_11 = 0;
tvbuff_t                 *VAR_12;
chandle_data_t           *VAR_13;
bluetooth_data_t         *VAR_14;
wmem_tree_key_t           VAR_15[6];
guint32                   VAR_16 = 0;
guint32                   VAR_17;
guint32                   VAR_18;
guint32                   VAR_19;
guint32                   VAR_20;
guint32                   VAR_21;
remote_bdaddr_t          *VAR_22;
const gchar              *VAR_23;
guint8                   *VAR_24;
const gchar              *VAR_25;
gchar                    *VAR_26;
gint                      VAR_27;
localhost_bdaddr_entry_t *VAR_28;
localhost_name_entry_t   *VAR_29;
chandle_session_t        *VAR_30;
wmem_tree_t              *VAR_31;
stream_connection_handle_pair_t *VAR_32;
iso_data_info_t          VAR_33;
if (VAR_3 == NULL)
return 0;
VAR_4 = proto_tree_add_item(VAR_2, VAR_34, VAR_0, VAR_11, -1, VAR_35);
VAR_5 = proto_item_add_subtree(VAR_4, VAR_36);
switch (VAR_1->p2p_dir) {
case VAR_37:
col_set_str(VAR_1->cinfo, VAR_38, ""Sent "");
break;
case VAR_39:
col_set_str(VAR_1->cinfo, VAR_38, ""Rcvd "");
break;
default:
col_set_str(VAR_1->cinfo, VAR_38, ""UnknownDirection "");
break;
}
col_set_str(VAR_1->cinfo, VAR_40, ""HCI_ISO"");
VAR_7   = tvb_get_letohs(VAR_0, VAR_11);
VAR_8 = (VAR_7 >> 12) & 0x3;
VAR_33.timestamp_present = (VAR_7 >> 14) & 0x1;
VAR_33.handle = VAR_7 & 0xfff;
proto_tree_add_item(VAR_5, VAR_41, VAR_0, VAR_11, 2, VAR_42);
proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_11, 2, VAR_42);
proto_tree_add_item(VAR_5, VAR_44, VAR_0, VAR_11, 2, VAR_42);
proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_11, 2, VAR_42);
VAR_11 += 2;
VAR_9 = tvb_get_letohs(VAR_0, VAR_11);
VAR_6 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_11, 2, VAR_42);
VAR_11 += 2;
if (VAR_8 != 0x2) {
VAR_10 = TRUE;
}
VAR_14 = (bluetooth_data_t *) VAR_3;
DISSECTOR_ASSERT(VAR_14);
VAR_19      = VAR_14->interface_id;
VAR_20        = VAR_14->adapter_id;
VAR_17     = VAR_7 & 0x0fff;
VAR_21           = VAR_1->p2p_dir;
VAR_18      = VAR_1->num;
VAR_15[0].length = 1;
VAR_15[0].key    = &VAR_19;
VAR_15[1].length = 1;
VAR_15[1].key    = &VAR_20;
VAR_15[2].length = 1;
VAR_15[2].key    = &VAR_17;
VAR_15[3].length = 0;
VAR_15[3].key    = NULL;
VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_14->chandle_sessions, VAR_15);
VAR_30 = (VAR_31) ? (chandle_session_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
if (!(VAR_30 &&
VAR_30->connect_in_frame < VAR_1->num &&
VAR_30->disconnect_in_frame > VAR_1->num)){
VAR_30 = NULL;
}
VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_14->shandle_to_chandle, VAR_15);
VAR_32 = (VAR_31) ? (stream_connection_handle_pair_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
if (VAR_32) {
VAR_16 = VAR_32->chandle;
VAR_15[2].key = &VAR_16;
}
VAR_15[3].length = 1;
VAR_15[3].key    = &VAR_18;
VAR_15[4].length = 0;
VAR_15[4].key    = NULL;
VAR_22 = (remote_bdaddr_t *)wmem_tree_lookup32_array_le(VAR_14->chandle_to_bdaddr, VAR_15);
if (VAR_22 && VAR_22->interface_id == VAR_14->interface_id &&
VAR_22->adapter_id == VAR_14->adapter_id &&
VAR_22->chandle == VAR_16) {
guint32         VAR_47;
guint32         VAR_48;
guint32         VAR_49;
guint32         VAR_50;
device_name_t  *VAR_51;
const gchar    *VAR_52;
const gchar    *VAR_53;
gchar          *VAR_54;
gint            VAR_55;
VAR_49 = VAR_22->bd_addr[0] << 16 | VAR_22->bd_addr[1] << 8 | VAR_22->bd_addr[2];
VAR_50  = VAR_22->bd_addr[3] << 16 | VAR_22->bd_addr[4] << 8 | VAR_22->bd_addr[5];
VAR_47  = VAR_49;
VAR_48   = VAR_50;
VAR_18 = VAR_1->num;
VAR_15[0].length = 1;
VAR_15[0].key    = &VAR_19;
VAR_15[1].length = 1;
VAR_15[1].key    = &VAR_20;
VAR_15[2].length = 1;
VAR_15[2].key    = &VAR_48;
VAR_15[3].length = 1;
VAR_15[3].key    = &VAR_47;
VAR_15[4].length = 1;
VAR_15[4].key    = &VAR_18;
VAR_15[5].length = 0;
VAR_15[5].key    = NULL;
VAR_51 = (device_name_t *)wmem_tree_lookup32_array_le(VAR_14->bdaddr_to_name, VAR_15);
if (VAR_51 && VAR_51->bd_addr_oui == VAR_49 && VAR_51->bd_addr_id == VAR_50)
VAR_52 = VAR_51->name;
else
VAR_52 = """";
VAR_53 = get_ether_name(VAR_22->bd_addr);
VAR_55 = (gint)(strlen(VAR_53) + 3 + strlen(VAR_52) + 1);
VAR_54 = (gchar *)wmem_alloc(VAR_1->pool, VAR_55);
g_snprintf(VAR_54, VAR_55, ""%s (%s)"", VAR_53, VAR_52);
if (VAR_1->p2p_dir == VAR_39) {
set_address(&VAR_1->net_src, VAR_56, (int)strlen(VAR_52) + 1, VAR_52);
set_address(&VAR_1->dl_src, VAR_57, 6, VAR_22->bd_addr);
set_address(&VAR_1->src, VAR_56, (int)strlen(VAR_54) + 1, VAR_54);
} else if (VAR_1->p2p_dir == VAR_37) {
set_address(&VAR_1->net_dst, VAR_56, (int)strlen(VAR_52) + 1, VAR_52);
set_address(&VAR_1->dl_dst, VAR_57, 6, VAR_22->bd_addr);
set_address(&VAR_1->dst, VAR_56, (int)strlen(VAR_54) + 1, VAR_54);
}
} else {
if (VAR_1->p2p_dir == VAR_39) {
set_address(&VAR_1->net_src, VAR_56, 1, """");
set_address(&VAR_1->dl_src, VAR_56, 1, """");
set_address(&VAR_1->src, VAR_56, 10, ""remote ()"");
} else if (VAR_1->p2p_dir == VAR_37) {
set_address(&VAR_1->net_dst, VAR_56, 1, """");
set_address(&VAR_1->dl_dst, VAR_56, 1, """");
set_address(&VAR_1->dst, VAR_56, 10, ""remote ()"");
}
}
VAR_15[0].length = 1;
VAR_15[0].key    = &VAR_19;
VAR_15[1].length = 1;
VAR_15[1].key    = &VAR_20;
VAR_15[2].length = 1;
VAR_15[2].key    = &VAR_18;
VAR_15[3].length = 0;
VAR_15[3].key    = NULL;
VAR_28 = (localhost_bdaddr_entry_t *)wmem_tree_lookup32_array_le(VAR_14->localhost_bdaddr, VAR_15);
VAR_24 = (guint8 *) wmem_alloc(VAR_1->pool, 6);
if (VAR_28 && VAR_28->interface_id == VAR_14->interface_id &&
VAR_28->adapter_id == VAR_14->adapter_id) {
VAR_25 = get_ether_name(VAR_28->bd_addr);
memcpy(VAR_24, VAR_28->bd_addr, 6);
} else {
VAR_25 = ""localhost"";
memset(VAR_24, 0, 6);
}
VAR_29 = (localhost_name_entry_t *)wmem_tree_lookup32_array_le(VAR_14->localhost_name, VAR_15);
if (VAR_29 && VAR_29->interface_id == VAR_14->interface_id &&
VAR_29->adapter_id == VAR_14->adapter_id)
VAR_23 = VAR_29->name;
else
VAR_23 = """";
VAR_27 = (gint)(strlen(VAR_25) + 3 + strlen(VAR_23) + 1);
VAR_26 = (gchar *)wmem_alloc(VAR_1->pool, VAR_27);
g_snprintf(VAR_26, VAR_27, ""%s (%s)"", VAR_25, VAR_23);
if (VAR_1->p2p_dir == VAR_39) {
set_address(&VAR_1->net_dst, VAR_56, (int)strlen(VAR_23) + 1, VAR_23);
set_address(&VAR_1->dl_dst, VAR_57, 6, VAR_24);
set_address(&VAR_1->dst, VAR_56, (int)strlen(VAR_26) + 1, VAR_26);
} else if (VAR_1->p2p_dir == VAR_37) {
set_address(&VAR_1->net_src, VAR_56, (int)strlen(VAR_23) + 1, VAR_23);
set_address(&VAR_1->dl_src, VAR_57, 6, VAR_24);
set_address(&VAR_1->src, VAR_56, (int)strlen(VAR_26) + 1, VAR_26);
}
VAR_15[0].length = 1;
VAR_15[0].key = &VAR_19;
VAR_15[1].length = 1;
VAR_15[1].key = &VAR_20;
VAR_15[2].length = 1;
VAR_15[2].key = &VAR_17;
VAR_15[3].length = 1;
VAR_15[3].key = &VAR_21;
VAR_15[4].length = 0;
VAR_15[4].key = NULL;
VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_58, VAR_15);
VAR_13 = (VAR_31) ? (chandle_data_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
if (!VAR_1->fd->visited && !VAR_13) {
VAR_15[0].length = 1;
VAR_15[0].key = &VAR_19;
VAR_15[1].length = 1;
VAR_15[1].key = &VAR_20;
VAR_15[2].length = 1;
VAR_15[2].key = &VAR_17;
VAR_15[3].length = 1;
VAR_15[3].key = &VAR_21;
VAR_15[4].length = 1;
VAR_15[4].key = &VAR_18;
VAR_15[5].length = 0;
VAR_15[5].key = NULL;
VAR_13 = wmem_new(wmem_file_scope(), chandle_data_t);
VAR_13->start_fragments = wmem_tree_new(wmem_file_scope());
wmem_tree_insert32_array(VAR_58, VAR_15, VAR_13);
} else if (VAR_1->fd->visited && !VAR_13) {
DISSECTOR_ASSERT_HINT(0, ""Impossible: no previously session saved"");
}
if (!VAR_10 || (!VAR_59 && !VAR_8)) {
if (VAR_9 < tvb_captured_length_remaining(VAR_0, VAR_11)) {
if (!VAR_10)
expert_add_info(VAR_1, VAR_6, &VAR_60);
VAR_9 = tvb_captured_length_remaining(VAR_0, VAR_11);
}
VAR_12 = tvb_new_subset_length_caplen(VAR_0, VAR_11, tvb_captured_length_remaining(VAR_0, VAR_11), VAR_9);
call_dissector_with_data(VAR_61, VAR_12, VAR_1, VAR_2, &VAR_33);
} else if (VAR_10 && VAR_59) {
multi_fragment_pdu_t *VAR_62 = NULL;
gint                  VAR_63;
if (VAR_8 == 0x00) { 
if (!VAR_1->fd->visited) {
gint VAR_64 = 0;
VAR_62 = (multi_fragment_pdu_t *) wmem_new(wmem_file_scope(), multi_fragment_pdu_t);
VAR_62->first_frame = VAR_1->num;
VAR_62->last_frame  = 0;
VAR_62->tot_len     = 4;
VAR_63 = tvb_captured_length_remaining(VAR_0, VAR_11);
if (VAR_7 & 0x4000) { 
VAR_64 = 4;
}
VAR_62->tot_len += VAR_64 + (tvb_get_letohs(VAR_0, VAR_11 + 2 + VAR_64) & 0xfff);
VAR_62->reassembled = (char *) wmem_alloc(wmem_file_scope(), VAR_62->tot_len);
if (VAR_63 <= VAR_62->tot_len) {
tvb_memcpy(VAR_0, (guint8 *) VAR_62->reassembled, VAR_11, VAR_63);
VAR_62->cur_off = VAR_63;
wmem_tree_insert32(VAR_13->start_fragments, VAR_1->num, VAR_62);
}
} else {
VAR_62 = (multi_fragment_pdu_t *)wmem_tree_lookup32(VAR_13->start_fragments, VAR_1->num);
}
if (VAR_62 != NULL && VAR_62->last_frame) {
proto_item *VAR_65;
VAR_65 = proto_tree_add_uint(VAR_5, VAR_66, VAR_0, 0, 0, VAR_62->last_frame);
proto_item_set_generated(VAR_65);
col_append_frame_number(VAR_1, VAR_38, "" [Reassembled in #%u]"", VAR_62->last_frame);
}
}
else if (VAR_8 & 0x01) { 
VAR_62 = (multi_fragment_pdu_t *)wmem_tree_lookup32_le(VAR_13->start_fragments, VAR_1->num);
if (!VAR_1->fd->visited) {
VAR_63 = tvb_captured_length_remaining(VAR_0, VAR_11);
if (VAR_62 != NULL && !VAR_62->last_frame) {
tvb_memcpy(VAR_0, (guint8 *) VAR_62->reassembled + VAR_62->cur_off, VAR_11, VAR_63);
VAR_62->cur_off += VAR_63;
if (VAR_8 == 0x03)
VAR_62->last_frame = VAR_1->num;
}
}
if (VAR_62) {
proto_item *VAR_65;
VAR_65 = proto_tree_add_uint(VAR_5, VAR_67, VAR_0, 0, 0, VAR_62->first_frame);
proto_item_set_generated(VAR_65);
col_append_frame_number(VAR_1, VAR_38, "" [Continuation to #%u]"", VAR_62->first_frame);
if (VAR_62->last_frame && VAR_62->last_frame != VAR_1->num) {
VAR_65 = proto_tree_add_uint(VAR_5, VAR_66, VAR_0, 0, 0, VAR_62->last_frame);
proto_item_set_generated(VAR_65);
col_append_frame_number(VAR_1, VAR_38, "" [Reassembled in #%u]"", VAR_62->last_frame);
}
if (VAR_8 == 0x03) { 
VAR_12 = tvb_new_child_real_data(VAR_0, (guint8 *) VAR_62->reassembled, VAR_62->tot_len, VAR_62->tot_len);
add_new_data_source(VAR_1, VAR_12, ""Reassembled BTHCI ISO"");
call_dissector_with_data(VAR_61, VAR_12, VAR_1, VAR_2, &VAR_33);
}
}
}
}
if (tvb_captured_length_remaining(VAR_0, VAR_11) > 0) {
VAR_6 = proto_tree_add_item(VAR_5, VAR_68, VAR_0, VAR_11, -1, VAR_35);
if (VAR_10) {
proto_item_append_text(VAR_6, "" Fragment"");
}
}
if (VAR_30) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_69, VAR_0, 0, 0, VAR_30->connect_in_frame);
proto_item_set_generated(VAR_6);
if (VAR_30->disconnect_in_frame < VAR_70) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_71, VAR_0, 0, 0, VAR_30->disconnect_in_frame);
proto_item_set_generated(VAR_6);
}
}
return tvb_reported_length(VAR_0);
}",wireshark/acaaad150b75a295184588c4127698a77493c9f0/packet-bthci_iso.c/vul/before/0.json,"static gint
dissect_bthci_iso(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_item               *bthci_iso_item;
    proto_tree               *bthci_iso_tree;
    proto_item               *sub_item;
    guint16                   flags;
    guint16                   pb_flag = FALSE;
    guint16                   length;
    gboolean                  fragmented = FALSE;
    gint                      offset = 0;
    tvbuff_t                 *next_tvb;
    chandle_data_t           *chandle_data;
    bluetooth_data_t         *bluetooth_data;
    wmem_tree_key_t           key[6];
    guint32                   k_connection_handle = 0;
    guint32                   k_stream_handle;
    guint32                   k_frame_number;
    guint32                   k_interface_id;
    guint32                   k_adapter_id;
    guint32                   direction;
    remote_bdaddr_t          *remote_bdaddr;
    const gchar              *localhost_name;
    guint8                   *localhost_bdaddr;
    const gchar              *localhost_ether_addr;
    gchar                    *localhost_addr_name;
    gint                      localhost_length;
    localhost_bdaddr_entry_t *localhost_bdaddr_entry;
    localhost_name_entry_t   *localhost_name_entry;
    chandle_session_t        *chandle_session;
    wmem_tree_t              *subtree;
    stream_connection_handle_pair_t *handle_pairs;
    iso_data_info_t          iso_data_info;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;

    bthci_iso_item = proto_tree_add_item(tree, proto_bthci_iso, tvb, offset, -1, ENC_NA);
    bthci_iso_tree = proto_item_add_subtree(bthci_iso_item, ett_bthci_iso);

    switch (pinfo->p2p_dir) {
        case P2P_DIR_SENT:
            col_set_str(pinfo->cinfo, COL_INFO, ""Sent "");
            break;
        case P2P_DIR_RECV:
            col_set_str(pinfo->cinfo, COL_INFO, ""Rcvd "");
            break;
        default:
            col_set_str(pinfo->cinfo, COL_INFO, ""UnknownDirection "");
            break;
    }

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""HCI_ISO"");

    flags   = tvb_get_letohs(tvb, offset);
    pb_flag = (flags >> 12) & 0x3;
    iso_data_info.timestamp_present = (flags >> 14) & 0x1;
    iso_data_info.handle = flags & 0xfff;
    proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_chandle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_pb_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_ts_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    length = tvb_get_letohs(tvb, offset);
    sub_item = proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_data_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* determine if packet is fragmented */
    if (pb_flag != 0x2) {
        fragmented = TRUE;
    }

    bluetooth_data = (bluetooth_data_t *) data;
    DISSECTOR_ASSERT(bluetooth_data);

    k_interface_id      = bluetooth_data->interface_id;
    k_adapter_id        = bluetooth_data->adapter_id;
    k_stream_handle     = flags & 0x0fff;
    direction           = pinfo->p2p_dir;
    k_frame_number      = pinfo->num;

    key[0].length = 1;
    key[0].key    = &k_interface_id;
    key[1].length = 1;
    key[1].key    = &k_adapter_id;
    key[2].length = 1;
    key[2].key    = &k_stream_handle;
    key[3].length = 0;
    key[3].key    = NULL;

    subtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->chandle_sessions, key);
    chandle_session = (subtree) ? (chandle_session_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
    if (!(chandle_session &&
            chandle_session->connect_in_frame < pinfo->num &&
            chandle_session->disconnect_in_frame > pinfo->num)){
        chandle_session = NULL;
    }

    /* replace stream (CIS/BIS) handle with connection (ACL) handle */
    subtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->shandle_to_chandle, key);
    handle_pairs = (subtree) ? (stream_connection_handle_pair_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
    if (handle_pairs) {
        k_connection_handle = handle_pairs->chandle;
        key[2].key = &k_connection_handle;
    }

    key[3].length = 1;
    key[3].key    = &k_frame_number;
    key[4].length = 0;
    key[4].key    = NULL;

    /* remote bdaddr and name */
    remote_bdaddr = (remote_bdaddr_t *)wmem_tree_lookup32_array_le(bluetooth_data->chandle_to_bdaddr, key);
    /*
     * XXX - do this only if we found a handle pair, so that we have
     * a connection handle?
     */
    if (remote_bdaddr && remote_bdaddr->interface_id == bluetooth_data->interface_id &&
            remote_bdaddr->adapter_id == bluetooth_data->adapter_id &&
            remote_bdaddr->chandle == k_connection_handle) {
        guint32         k_bd_addr_oui;
        guint32         k_bd_addr_id;
        guint32         bd_addr_oui;
        guint32         bd_addr_id;
        device_name_t  *device_name;
        const gchar    *remote_name;
        const gchar    *remote_ether_addr;
        gchar          *remote_addr_name;
        gint            remote_length;

        bd_addr_oui = remote_bdaddr->bd_addr[0] << 16 | remote_bdaddr->bd_addr[1] << 8 | remote_bdaddr->bd_addr[2];
        bd_addr_id  = remote_bdaddr->bd_addr[3] << 16 | remote_bdaddr->bd_addr[4] << 8 | remote_bdaddr->bd_addr[5];

        k_bd_addr_oui  = bd_addr_oui;
        k_bd_addr_id   = bd_addr_id;
        k_frame_number = pinfo->num;

        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_bd_addr_id;
        key[3].length = 1;
        key[3].key    = &k_bd_addr_oui;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;

        device_name = (device_name_t *)wmem_tree_lookup32_array_le(bluetooth_data->bdaddr_to_name, key);
        if (device_name && device_name->bd_addr_oui == bd_addr_oui && device_name->bd_addr_id == bd_addr_id)
            remote_name = device_name->name;
        else
            remote_name = """";

        remote_ether_addr = get_ether_name(remote_bdaddr->bd_addr);
        remote_length = (gint)(strlen(remote_ether_addr) + 3 + strlen(remote_name) + 1);
        remote_addr_name = (gchar *)wmem_alloc(pinfo->pool, remote_length);

        g_snprintf(remote_addr_name, remote_length, ""%s (%s)"", remote_ether_addr, remote_name);

        if (pinfo->p2p_dir == P2P_DIR_RECV) {
            set_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(remote_name) + 1, remote_name);
            set_address(&pinfo->dl_src, AT_ETHER, 6, remote_bdaddr->bd_addr);
            set_address(&pinfo->src, AT_STRINGZ, (int)strlen(remote_addr_name) + 1, remote_addr_name);
        } else if (pinfo->p2p_dir == P2P_DIR_SENT) {
            set_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(remote_name) + 1, remote_name);
            set_address(&pinfo->dl_dst, AT_ETHER, 6, remote_bdaddr->bd_addr);
            set_address(&pinfo->dst, AT_STRINGZ, (int)strlen(remote_addr_name) + 1, remote_addr_name);
        }
    } else {
        if (pinfo->p2p_dir == P2P_DIR_RECV) {
            set_address(&pinfo->net_src, AT_STRINGZ, 1, """");
            set_address(&pinfo->dl_src, AT_STRINGZ, 1, """");
            set_address(&pinfo->src, AT_STRINGZ, 10, ""remote ()"");
        } else if (pinfo->p2p_dir == P2P_DIR_SENT) {
            set_address(&pinfo->net_dst, AT_STRINGZ, 1, """");
            set_address(&pinfo->dl_dst, AT_STRINGZ, 1, """");
            set_address(&pinfo->dst, AT_STRINGZ, 10, ""remote ()"");
        }
    }

    /* localhost bdaddr and name */
    key[0].length = 1;
    key[0].key    = &k_interface_id;
    key[1].length = 1;
    key[1].key    = &k_adapter_id;
    key[2].length = 1;
    key[2].key    = &k_frame_number;
    key[3].length = 0;
    key[3].key    = NULL;


    localhost_bdaddr_entry = (localhost_bdaddr_entry_t *)wmem_tree_lookup32_array_le(bluetooth_data->localhost_bdaddr, key);
    localhost_bdaddr = (guint8 *) wmem_alloc(pinfo->pool, 6);
    if (localhost_bdaddr_entry && localhost_bdaddr_entry->interface_id == bluetooth_data->interface_id &&
        localhost_bdaddr_entry->adapter_id == bluetooth_data->adapter_id) {

        localhost_ether_addr = get_ether_name(localhost_bdaddr_entry->bd_addr);
        memcpy(localhost_bdaddr, localhost_bdaddr_entry->bd_addr, 6);
    } else {
        localhost_ether_addr = ""localhost"";
        /* XXX - is this the right value to use? */
        memset(localhost_bdaddr, 0, 6);
    }

    localhost_name_entry = (localhost_name_entry_t *)wmem_tree_lookup32_array_le(bluetooth_data->localhost_name, key);
    if (localhost_name_entry && localhost_name_entry->interface_id == bluetooth_data->interface_id &&
            localhost_name_entry->adapter_id == bluetooth_data->adapter_id)
        localhost_name = localhost_name_entry->name;
    else
        localhost_name = """";

    localhost_length = (gint)(strlen(localhost_ether_addr) + 3 + strlen(localhost_name) + 1);
    localhost_addr_name = (gchar *)wmem_alloc(pinfo->pool, localhost_length);

    g_snprintf(localhost_addr_name, localhost_length, ""%s (%s)"", localhost_ether_addr, localhost_name);

    if (pinfo->p2p_dir == P2P_DIR_RECV) {
        set_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(localhost_name) + 1, localhost_name);
        set_address(&pinfo->dl_dst, AT_ETHER, 6, localhost_bdaddr);
        set_address(&pinfo->dst, AT_STRINGZ, (int)strlen(localhost_addr_name) + 1, localhost_addr_name);
    } else if (pinfo->p2p_dir == P2P_DIR_SENT) {
        set_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(localhost_name) + 1, localhost_name);
        set_address(&pinfo->dl_src, AT_ETHER, 6, localhost_bdaddr);
        set_address(&pinfo->src, AT_STRINGZ, (int)strlen(localhost_addr_name) + 1, localhost_addr_name);
    }

    /* find the chandle_data structure associated with this chandle */
    key[0].length = 1;
    key[0].key = &k_interface_id;
    key[1].length = 1;
    key[1].key = &k_adapter_id;
    key[2].length = 1;
    key[2].key = &k_stream_handle;
    key[3].length = 1;
    key[3].key = &direction;
    key[4].length = 0;
    key[4].key = NULL;

    subtree = (wmem_tree_t *) wmem_tree_lookup32_array(chandle_tree, key);
    chandle_data = (subtree) ? (chandle_data_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;
    if (!pinfo->fd->visited && !chandle_data) {
        key[0].length = 1;
        key[0].key = &k_interface_id;
        key[1].length = 1;
        key[1].key = &k_adapter_id;
        key[2].length = 1;
        key[2].key = &k_stream_handle;
        key[3].length = 1;
        key[3].key = &direction;
        key[4].length = 1;
        key[4].key = &k_frame_number;
        key[5].length = 0;
        key[5].key = NULL;

        chandle_data = wmem_new(wmem_file_scope(), chandle_data_t);
        chandle_data->start_fragments = wmem_tree_new(wmem_file_scope());

        wmem_tree_insert32_array(chandle_tree, key, chandle_data);
    } else if (pinfo->fd->visited && !chandle_data) {
        DISSECTOR_ASSERT_HINT(0, ""Impossible: no previously session saved"");
    }

    if (!fragmented || (!iso_reassembly && !pb_flag)) {
        /* call ISO data dissector for PDUs that are not fragmented
         * also for the first fragment if reassembly is disabled
         */
        if (length < tvb_captured_length_remaining(tvb, offset)) {
            if (!fragmented)
                expert_add_info(pinfo, sub_item, &ei_length_bad);
            /* Try to dissect as much as possible */
            length = tvb_captured_length_remaining(tvb, offset);
        }

        next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_captured_length_remaining(tvb, offset), length);
        call_dissector_with_data(bthci_iso_data_handle, next_tvb, pinfo, tree, &iso_data_info);
    } else if (fragmented && iso_reassembly) {
        multi_fragment_pdu_t *mfp = NULL;
        gint                  len;
        if (pb_flag == 0x00) { /* first fragment */
            if (!pinfo->fd->visited) {
                gint timestamp_size = 0;
                mfp = (multi_fragment_pdu_t *) wmem_new(wmem_file_scope(), multi_fragment_pdu_t);
                mfp->first_frame = pinfo->num;
                mfp->last_frame  = 0;
                mfp->tot_len     = 4;
                len = tvb_captured_length_remaining(tvb, offset);
                if (flags & 0x4000) { /* 4 byte timestamp is present */
                    timestamp_size = 4;
                }
                mfp->tot_len += timestamp_size + (tvb_get_letohs(tvb, offset + 2 + timestamp_size) & 0xfff);
                mfp->reassembled = (char *) wmem_alloc(wmem_file_scope(), mfp->tot_len);
                if (len <= mfp->tot_len) {
                    tvb_memcpy(tvb, (guint8 *) mfp->reassembled, offset, len);
                    mfp->cur_off = len;
                    wmem_tree_insert32(chandle_data->start_fragments, pinfo->num, mfp);
                }
            } else {
                mfp = (multi_fragment_pdu_t *)wmem_tree_lookup32(chandle_data->start_fragments, pinfo->num);
            }
            if (mfp != NULL && mfp->last_frame) {
                proto_item *item;

                item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_reassembled_in, tvb, 0, 0, mfp->last_frame);
                proto_item_set_generated(item);
                col_append_frame_number(pinfo, COL_INFO, "" [Reassembled in #%u]"", mfp->last_frame);
            }
        }
        else if (pb_flag & 0x01) { /* continuation/last fragment */
            mfp = (multi_fragment_pdu_t *)wmem_tree_lookup32_le(chandle_data->start_fragments, pinfo->num);
            if (!pinfo->fd->visited) {
                len = tvb_captured_length_remaining(tvb, offset);
                if (mfp != NULL && !mfp->last_frame) {
                    int avail = (int)mfp->tot_len - mfp->cur_off;
                    if (len > avail) {
                        expert_add_info(pinfo, sub_item, &ei_length_bad);
                        /* Try to reassemble as much as possible */
                        len = avail;
                    }
                    tvb_memcpy(tvb, (guint8 *) mfp->reassembled + mfp->cur_off, offset, len);
                    mfp->cur_off += len;
                    if (pb_flag == 0x03)
                        mfp->last_frame = pinfo->num;
                }
            }
            if (mfp) {
                proto_item *item;

                item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_continuation_to, tvb, 0, 0, mfp->first_frame);
                proto_item_set_generated(item);
                col_append_frame_number(pinfo, COL_INFO, "" [Continuation to #%u]"", mfp->first_frame);
                if (mfp->last_frame && mfp->last_frame != pinfo->num) {
                    item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_reassembled_in, tvb, 0, 0, mfp->last_frame);
                    proto_item_set_generated(item);
                    col_append_frame_number(pinfo, COL_INFO, "" [Reassembled in #%u]"", mfp->last_frame);
                }

                if (pb_flag == 0x03) { /* last fragment */
                    next_tvb = tvb_new_child_real_data(tvb, (guint8 *) mfp->reassembled, mfp->tot_len, mfp->tot_len);
                    add_new_data_source(pinfo, next_tvb, ""Reassembled BTHCI ISO"");

                    call_dissector_with_data(bthci_iso_data_handle, next_tvb, pinfo, tree, &iso_data_info);
                }
            }
        }
    }

    if (tvb_captured_length_remaining(tvb, offset) > 0) {
        sub_item = proto_tree_add_item(bthci_iso_tree, hf_bthci_iso_data, tvb, offset, -1, ENC_NA);
        if (fragmented) {
            proto_item_append_text(sub_item, "" Fragment"");
        }
    }

    if (chandle_session) {
        sub_item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_connect_in, tvb, 0, 0, chandle_session->connect_in_frame);
        proto_item_set_generated(sub_item);

        if (chandle_session->disconnect_in_frame < G_MAXUINT32) {
            sub_item = proto_tree_add_uint(bthci_iso_tree, hf_bthci_iso_disconnect_in, tvb, 0, 0, chandle_session->disconnect_in_frame);
            proto_item_set_generated(sub_item);
        }
    }

    return tvb_reported_length(tvb);
}","static gint
dissect_bthci_iso(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
    proto_item               *VAR_4;
    proto_tree               *VAR_5;
    proto_item               *VAR_6;
    guint16                   VAR_7;
    guint16                   VAR_8 = FALSE;
    guint16                   VAR_9;
    gboolean                  VAR_10 = FALSE;
    gint                      VAR_11 = 0;
    tvbuff_t                 *VAR_12;
    chandle_data_t           *VAR_13;
    bluetooth_data_t         *VAR_14;
    wmem_tree_key_t           VAR_15[6];
    guint32                   VAR_16 = 0;
    guint32                   VAR_17;
    guint32                   VAR_18;
    guint32                   VAR_19;
    guint32                   VAR_20;
    guint32                   VAR_21;
    remote_bdaddr_t          *VAR_22;
    const gchar              *VAR_23;
    guint8                   *VAR_24;
    const gchar              *VAR_25;
    gchar                    *VAR_26;
    gint                      VAR_27;
    localhost_bdaddr_entry_t *VAR_28;
    localhost_name_entry_t   *VAR_29;
    chandle_session_t        *VAR_30;
    wmem_tree_t              *VAR_31;
    stream_connection_handle_pair_t *VAR_32;
    iso_data_info_t          VAR_33;

    /* COMMENT_0 */
    if (VAR_3 == NULL)
        return 0;

    VAR_4 = proto_tree_add_item(VAR_2, VAR_34, VAR_0, VAR_11, -1, VAR_35);
    VAR_5 = proto_item_add_subtree(VAR_4, VAR_36);

    switch (VAR_1->p2p_dir) {
        case VAR_37:
            col_set_str(VAR_1->cinfo, VAR_38, ""Sent "");
            break;
        case VAR_39:
            col_set_str(VAR_1->cinfo, VAR_38, ""Rcvd "");
            break;
        default:
            col_set_str(VAR_1->cinfo, VAR_38, ""UnknownDirection "");
            break;
    }

    col_set_str(VAR_1->cinfo, VAR_40, ""HCI_ISO"");

    VAR_7   = tvb_get_letohs(VAR_0, VAR_11);
    VAR_8 = (VAR_7 >> 12) & 0x3;
    VAR_33.timestamp_present = (VAR_7 >> 14) & 0x1;
    VAR_33.handle = VAR_7 & 0xfff;
    proto_tree_add_item(VAR_5, VAR_41, VAR_0, VAR_11, 2, VAR_42);
    proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_11, 2, VAR_42);
    proto_tree_add_item(VAR_5, VAR_44, VAR_0, VAR_11, 2, VAR_42);
    proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_11, 2, VAR_42);
    VAR_11 += 2;

    VAR_9 = tvb_get_letohs(VAR_0, VAR_11);
    VAR_6 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_11, 2, VAR_42);
    VAR_11 += 2;

    /* COMMENT_1 */
    if (VAR_8 != 0x2) {
        VAR_10 = TRUE;
    }

    VAR_14 = (bluetooth_data_t *) VAR_3;
    DISSECTOR_ASSERT(VAR_14);

    VAR_19      = VAR_14->interface_id;
    VAR_20        = VAR_14->adapter_id;
    VAR_17     = VAR_7 & 0x0fff;
    VAR_21           = VAR_1->p2p_dir;
    VAR_18      = VAR_1->num;

    VAR_15[0].length = 1;
    VAR_15[0].key    = &VAR_19;
    VAR_15[1].length = 1;
    VAR_15[1].key    = &VAR_20;
    VAR_15[2].length = 1;
    VAR_15[2].key    = &VAR_17;
    VAR_15[3].length = 0;
    VAR_15[3].key    = NULL;

    VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_14->chandle_sessions, VAR_15);
    VAR_30 = (VAR_31) ? (chandle_session_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
    if (!(VAR_30 &&
            VAR_30->connect_in_frame < VAR_1->num &&
            VAR_30->disconnect_in_frame > VAR_1->num)){
        VAR_30 = NULL;
    }

    /* COMMENT_2 */
    VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_14->shandle_to_chandle, VAR_15);
    VAR_32 = (VAR_31) ? (stream_connection_handle_pair_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
    if (VAR_32) {
        VAR_16 = VAR_32->chandle;
        VAR_15[2].key = &VAR_16;
    }

    VAR_15[3].length = 1;
    VAR_15[3].key    = &VAR_18;
    VAR_15[4].length = 0;
    VAR_15[4].key    = NULL;

    /* COMMENT_3 */
    VAR_22 = (remote_bdaddr_t *)wmem_tree_lookup32_array_le(VAR_14->chandle_to_bdaddr, VAR_15);
    /* COMMENT_4 */
                                                                    
                           
       
    if (VAR_22 && VAR_22->interface_id == VAR_14->interface_id &&
            VAR_22->adapter_id == VAR_14->adapter_id &&
            VAR_22->chandle == VAR_16) {
        guint32         VAR_47;
        guint32         VAR_48;
        guint32         VAR_49;
        guint32         VAR_50;
        device_name_t  *VAR_51;
        const gchar    *VAR_52;
        const gchar    *VAR_53;
        gchar          *VAR_54;
        gint            VAR_55;

        VAR_49 = VAR_22->bd_addr[0] << 16 | VAR_22->bd_addr[1] << 8 | VAR_22->bd_addr[2];
        VAR_50  = VAR_22->bd_addr[3] << 16 | VAR_22->bd_addr[4] << 8 | VAR_22->bd_addr[5];

        VAR_47  = VAR_49;
        VAR_48   = VAR_50;
        VAR_18 = VAR_1->num;

        VAR_15[0].length = 1;
        VAR_15[0].key    = &VAR_19;
        VAR_15[1].length = 1;
        VAR_15[1].key    = &VAR_20;
        VAR_15[2].length = 1;
        VAR_15[2].key    = &VAR_48;
        VAR_15[3].length = 1;
        VAR_15[3].key    = &VAR_47;
        VAR_15[4].length = 1;
        VAR_15[4].key    = &VAR_18;
        VAR_15[5].length = 0;
        VAR_15[5].key    = NULL;

        VAR_51 = (device_name_t *)wmem_tree_lookup32_array_le(VAR_14->bdaddr_to_name, VAR_15);
        if (VAR_51 && VAR_51->bd_addr_oui == VAR_49 && VAR_51->bd_addr_id == VAR_50)
            VAR_52 = VAR_51->name;
        else
            VAR_52 = """";

        VAR_53 = get_ether_name(VAR_22->bd_addr);
        VAR_55 = (gint)(strlen(VAR_53) + 3 + strlen(VAR_52) + 1);
        VAR_54 = (gchar *)wmem_alloc(VAR_1->pool, VAR_55);

        g_snprintf(VAR_54, VAR_55, ""%s (%s)"", VAR_53, VAR_52);

        if (VAR_1->p2p_dir == VAR_39) {
            set_address(&VAR_1->net_src, VAR_56, (int)strlen(VAR_52) + 1, VAR_52);
            set_address(&VAR_1->dl_src, VAR_57, 6, VAR_22->bd_addr);
            set_address(&VAR_1->src, VAR_56, (int)strlen(VAR_54) + 1, VAR_54);
        } else if (VAR_1->p2p_dir == VAR_37) {
            set_address(&VAR_1->net_dst, VAR_56, (int)strlen(VAR_52) + 1, VAR_52);
            set_address(&VAR_1->dl_dst, VAR_57, 6, VAR_22->bd_addr);
            set_address(&VAR_1->dst, VAR_56, (int)strlen(VAR_54) + 1, VAR_54);
        }
    } else {
        if (VAR_1->p2p_dir == VAR_39) {
            set_address(&VAR_1->net_src, VAR_56, 1, """");
            set_address(&VAR_1->dl_src, VAR_56, 1, """");
            set_address(&VAR_1->src, VAR_56, 10, ""remote ()"");
        } else if (VAR_1->p2p_dir == VAR_37) {
            set_address(&VAR_1->net_dst, VAR_56, 1, """");
            set_address(&VAR_1->dl_dst, VAR_56, 1, """");
            set_address(&VAR_1->dst, VAR_56, 10, ""remote ()"");
        }
    }

    /* COMMENT_8 */
    VAR_15[0].length = 1;
    VAR_15[0].key    = &VAR_19;
    VAR_15[1].length = 1;
    VAR_15[1].key    = &VAR_20;
    VAR_15[2].length = 1;
    VAR_15[2].key    = &VAR_18;
    VAR_15[3].length = 0;
    VAR_15[3].key    = NULL;


    VAR_28 = (localhost_bdaddr_entry_t *)wmem_tree_lookup32_array_le(VAR_14->localhost_bdaddr, VAR_15);
    VAR_24 = (guint8 *) wmem_alloc(VAR_1->pool, 6);
    if (VAR_28 && VAR_28->interface_id == VAR_14->interface_id &&
        VAR_28->adapter_id == VAR_14->adapter_id) {

        VAR_25 = get_ether_name(VAR_28->bd_addr);
        memcpy(VAR_24, VAR_28->bd_addr, 6);
    } else {
        VAR_25 = ""localhost"";
        /* COMMENT_9 */
        memset(VAR_24, 0, 6);
    }

    VAR_29 = (localhost_name_entry_t *)wmem_tree_lookup32_array_le(VAR_14->localhost_name, VAR_15);
    if (VAR_29 && VAR_29->interface_id == VAR_14->interface_id &&
            VAR_29->adapter_id == VAR_14->adapter_id)
        VAR_23 = VAR_29->name;
    else
        VAR_23 = """";

    VAR_27 = (gint)(strlen(VAR_25) + 3 + strlen(VAR_23) + 1);
    VAR_26 = (gchar *)wmem_alloc(VAR_1->pool, VAR_27);

    g_snprintf(VAR_26, VAR_27, ""%s (%s)"", VAR_25, VAR_23);

    if (VAR_1->p2p_dir == VAR_39) {
        set_address(&VAR_1->net_dst, VAR_56, (int)strlen(VAR_23) + 1, VAR_23);
        set_address(&VAR_1->dl_dst, VAR_57, 6, VAR_24);
        set_address(&VAR_1->dst, VAR_56, (int)strlen(VAR_26) + 1, VAR_26);
    } else if (VAR_1->p2p_dir == VAR_37) {
        set_address(&VAR_1->net_src, VAR_56, (int)strlen(VAR_23) + 1, VAR_23);
        set_address(&VAR_1->dl_src, VAR_57, 6, VAR_24);
        set_address(&VAR_1->src, VAR_56, (int)strlen(VAR_26) + 1, VAR_26);
    }

    /* COMMENT_10 */
    VAR_15[0].length = 1;
    VAR_15[0].key = &VAR_19;
    VAR_15[1].length = 1;
    VAR_15[1].key = &VAR_20;
    VAR_15[2].length = 1;
    VAR_15[2].key = &VAR_17;
    VAR_15[3].length = 1;
    VAR_15[3].key = &VAR_21;
    VAR_15[4].length = 0;
    VAR_15[4].key = NULL;

    VAR_31 = (wmem_tree_t *) wmem_tree_lookup32_array(VAR_58, VAR_15);
    VAR_13 = (VAR_31) ? (chandle_data_t *) wmem_tree_lookup32_le(VAR_31, VAR_1->num) : NULL;
    if (!VAR_1->fd->visited && !VAR_13) {
        VAR_15[0].length = 1;
        VAR_15[0].key = &VAR_19;
        VAR_15[1].length = 1;
        VAR_15[1].key = &VAR_20;
        VAR_15[2].length = 1;
        VAR_15[2].key = &VAR_17;
        VAR_15[3].length = 1;
        VAR_15[3].key = &VAR_21;
        VAR_15[4].length = 1;
        VAR_15[4].key = &VAR_18;
        VAR_15[5].length = 0;
        VAR_15[5].key = NULL;

        VAR_13 = wmem_new(wmem_file_scope(), chandle_data_t);
        VAR_13->start_fragments = wmem_tree_new(wmem_file_scope());

        wmem_tree_insert32_array(VAR_58, VAR_15, VAR_13);
    } else if (VAR_1->fd->visited && !VAR_13) {
        DISSECTOR_ASSERT_HINT(0, ""Impossible: no previously session saved"");
    }

    if (!VAR_10 || (!VAR_59 && !VAR_8)) {
        /* COMMENT_11 */
                                                                
           
        if (VAR_9 < tvb_captured_length_remaining(VAR_0, VAR_11)) {
            if (!VAR_10)
                expert_add_info(VAR_1, VAR_6, &VAR_60);
            /* COMMENT_14 */
            VAR_9 = tvb_captured_length_remaining(VAR_0, VAR_11);
        }

        VAR_12 = tvb_new_subset_length_caplen(VAR_0, VAR_11, tvb_captured_length_remaining(VAR_0, VAR_11), VAR_9);
        call_dissector_with_data(VAR_61, VAR_12, VAR_1, VAR_2, &VAR_33);
    } else if (VAR_10 && VAR_59) {
        multi_fragment_pdu_t *VAR_62 = NULL;
        gint                  VAR_63;
        if (VAR_8 == 0x00) { /* COMMENT_15 */
            if (!VAR_1->fd->visited) {
                gint VAR_64 = 0;
                VAR_62 = (multi_fragment_pdu_t *) wmem_new(wmem_file_scope(), multi_fragment_pdu_t);
                VAR_62->first_frame = VAR_1->num;
                VAR_62->last_frame  = 0;
                VAR_62->tot_len     = 4;
                VAR_63 = tvb_captured_length_remaining(VAR_0, VAR_11);
                if (VAR_7 & 0x4000) { /* COMMENT_16 */
                    VAR_64 = 4;
                }
                VAR_62->tot_len += VAR_64 + (tvb_get_letohs(VAR_0, VAR_11 + 2 + VAR_64) & 0xfff);
                VAR_62->reassembled = (char *) wmem_alloc(wmem_file_scope(), VAR_62->tot_len);
                if (VAR_63 <= VAR_62->tot_len) {
                    tvb_memcpy(VAR_0, (guint8 *) VAR_62->reassembled, VAR_11, VAR_63);
                    VAR_62->cur_off = VAR_63;
                    wmem_tree_insert32(VAR_13->start_fragments, VAR_1->num, VAR_62);
                }
            } else {
                VAR_62 = (multi_fragment_pdu_t *)wmem_tree_lookup32(VAR_13->start_fragments, VAR_1->num);
            }
            if (VAR_62 != NULL && VAR_62->last_frame) {
                proto_item *VAR_65;

                VAR_65 = proto_tree_add_uint(VAR_5, VAR_66, VAR_0, 0, 0, VAR_62->last_frame);
                proto_item_set_generated(VAR_65);
                col_append_frame_number(VAR_1, VAR_38, "" [Reassembled in #%u]"", VAR_62->last_frame);
            }
        }
        else if (VAR_8 & 0x01) { /* COMMENT_17 */
            VAR_62 = (multi_fragment_pdu_t *)wmem_tree_lookup32_le(VAR_13->start_fragments, VAR_1->num);
            if (!VAR_1->fd->visited) {
                VAR_63 = tvb_captured_length_remaining(VAR_0, VAR_11);
                if (VAR_62 != NULL && !VAR_62->last_frame) {
                    int VAR_67 = (int)VAR_62->tot_len - VAR_62->cur_off;
                    if (VAR_63 > VAR_67) {
                        expert_add_info(VAR_1, VAR_6, &VAR_60);
                        /* COMMENT_18 */
                        VAR_63 = VAR_67;
                    }
                    tvb_memcpy(VAR_0, (guint8 *) VAR_62->reassembled + VAR_62->cur_off, VAR_11, VAR_63);
                    VAR_62->cur_off += VAR_63;
                    if (VAR_8 == 0x03)
                        VAR_62->last_frame = VAR_1->num;
                }
            }
            if (VAR_62) {
                proto_item *VAR_65;

                VAR_65 = proto_tree_add_uint(VAR_5, VAR_68, VAR_0, 0, 0, VAR_62->first_frame);
                proto_item_set_generated(VAR_65);
                col_append_frame_number(VAR_1, VAR_38, "" [Continuation to #%u]"", VAR_62->first_frame);
                if (VAR_62->last_frame && VAR_62->last_frame != VAR_1->num) {
                    VAR_65 = proto_tree_add_uint(VAR_5, VAR_66, VAR_0, 0, 0, VAR_62->last_frame);
                    proto_item_set_generated(VAR_65);
                    col_append_frame_number(VAR_1, VAR_38, "" [Reassembled in #%u]"", VAR_62->last_frame);
                }

                if (VAR_8 == 0x03) { /* COMMENT_19 */
                    VAR_12 = tvb_new_child_real_data(VAR_0, (guint8 *) VAR_62->reassembled, VAR_62->tot_len, VAR_62->tot_len);
                    add_new_data_source(VAR_1, VAR_12, ""Reassembled BTHCI ISO"");

                    call_dissector_with_data(VAR_61, VAR_12, VAR_1, VAR_2, &VAR_33);
                }
            }
        }
    }

    if (tvb_captured_length_remaining(VAR_0, VAR_11) > 0) {
        VAR_6 = proto_tree_add_item(VAR_5, VAR_69, VAR_0, VAR_11, -1, VAR_35);
        if (VAR_10) {
            proto_item_append_text(VAR_6, "" Fragment"");
        }
    }

    if (VAR_30) {
        VAR_6 = proto_tree_add_uint(VAR_5, VAR_70, VAR_0, 0, 0, VAR_30->connect_in_frame);
        proto_item_set_generated(VAR_6);

        if (VAR_30->disconnect_in_frame < VAR_71) {
            VAR_6 = proto_tree_add_uint(VAR_5, VAR_72, VAR_0, 0, 0, VAR_30->disconnect_in_frame);
            proto_item_set_generated(VAR_6);
        }
    }

    return tvb_reported_length(VAR_0);
}",wireshark/acaaad150b75a295184588c4127698a77493c9f0/packet-bthci_iso.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -315,6 +315,12 @@
             if (!pinfo->fd->visited) {
                 len = tvb_captured_length_remaining(tvb, offset);
                 if (mfp != NULL && !mfp->last_frame) {
+                    int avail = (int)mfp->tot_len - mfp->cur_off;
+                    if (len > avail) {
+                        expert_add_info(pinfo, sub_item, &ei_length_bad);
+                        /* Try to reassemble as much as possible */
+                        len = avail;
+                    }
                     tvb_memcpy(tvb, (guint8 *) mfp->reassembled + mfp->cur_off, offset, len);
                     mfp->cur_off += len;
                     if (pb_flag == 0x03)","{'deleted_lines': [], 'added_lines': ['                    int avail = (int)mfp->tot_len - mfp->cur_off;', '                    if (len > avail) {', '                        expert_add_info(pinfo, sub_item, &ei_length_bad);', '                        /* Try to reassemble as much as possible */', '                        len = avail;', '                    }']}",True,Buffer overflow in the Bluetooth HCI_ISO dissector in Wireshark 3.4.0 to 3.4.9 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-39926,['CWE-120'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"BT HCI_ISO: Don't overrun our reassembly buffer.

Fixes #17649.
",acaaad150b75a295184588c4127698a77493c9f0,https://gitlab.com/wireshark/wireshark/-/commit/acaaad150b75a295184588c4127698a77493c9f0,epan/dissectors/packet-bthci_iso.c,proto_register_bthci_iso,"void
proto_register_bthci_iso(void)
{
module_t         *bthci_iso_module;
expert_module_t  *bthci_iso_expert_module;
static hf_register_info hf[] = {
{ &hf_bthci_iso_chandle,
{ ""Connection Handle"",           ""bthci_iso.chandle"",
FT_UINT16, BASE_HEX, NULL, 0x0FFF,
NULL, HFILL }
},
{ &hf_bthci_iso_pb_flag,
{ ""PB Flag"",               ""bthci_iso.pb_flag"",
FT_UINT16, BASE_HEX, VALS(iso_pb_flag_vals), 0x3000,
""Packet Boundary Flag"", HFILL }
},
{ &hf_bthci_iso_ts_flag,
{ ""Timestamp present"",               ""bthci_iso.ts_flag"",
FT_BOOLEAN, 16, NULL, 0x4000,
NULL, HFILL }
},
{ &hf_bthci_iso_reserved,
{ ""Reserved"",                    ""bthci_iso.reserved"",
FT_UINT16, BASE_HEX, NULL, 0x8000,
NULL, HFILL }
},
{ &hf_bthci_iso_continuation_to,
{ ""This is a continuation to the PDU in frame"",    ""bthci_iso.continuation_to"",
FT_FRAMENUM, BASE_NONE, NULL, 0x0,
""This is a continuation to the PDU in frame #"", HFILL }
},
{ &hf_bthci_iso_reassembled_in,
{ ""This PDU is reassembled in frame"",              ""bthci_iso.reassembled_in"",
FT_FRAMENUM, BASE_NONE, NULL, 0x0,
""This PDU is reassembled in frame #"", HFILL }
},
{ &hf_bthci_iso_connect_in,
{ ""Connect in frame"",            ""bthci_iso.connect_in"",
FT_FRAMENUM, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_bthci_iso_disconnect_in,
{ ""Disconnect in frame"",         ""bthci_iso.disconnect_in"",
FT_FRAMENUM, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_bthci_iso_data_length,
{ ""Data Length"",           ""bthci_iso.data_length"",
FT_UINT16, BASE_DEC, NULL, 0x3FFF,
NULL, HFILL }
},
{ &hf_bthci_iso_data,
{ ""Data"",                        ""bthci_iso.data"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
};
static gint *ett[] = {
&ett_bthci_iso,
};
static ei_register_info ei[] = {
{ &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Length too short"", EXPFILL }},
};
proto_bthci_iso = proto_register_protocol(""Bluetooth HCI ISO Packet"", ""HCI_ISO"", ""bthci_iso"");
bthci_iso_handle = register_dissector(""bthci_iso"", dissect_bthci_iso, proto_bthci_iso);
proto_register_field_array(proto_bthci_iso, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
bthci_iso_expert_module = expert_register_protocol(proto_bthci_iso);
expert_register_field_array(bthci_iso_expert_module, ei, array_length(ei));
bthci_iso_module = prefs_register_protocol_subtree(""Bluetooth"", proto_bthci_iso, NULL);
prefs_register_bool_preference(bthci_iso_module, ""hci_iso_reassembly"",
""Reassemble ISO Fragments"",
""Whether the ISO dissector should reassemble fragmented PDUs"",
&iso_reassembly);
chandle_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());
}","void
proto_register_bthci_iso(void)
{
module_t         *VAR_0;
expert_module_t  *VAR_1;
static hf_register_info VAR_2[] = {
{ &VAR_3,
{ ""Connection Handle"",           ""bthci_iso.chandle"",
VAR_4, VAR_5, NULL, 0x0FFF,
NULL, VAR_6 }
},
{ &VAR_7,
{ ""PB Flag"",               ""bthci_iso.pb_flag"",
VAR_4, VAR_5, VALS(VAR_8), 0x3000,
""Packet Boundary Flag"", VAR_6 }
},
{ &VAR_9,
{ ""Timestamp present"",               ""bthci_iso.ts_flag"",
VAR_10, 16, NULL, 0x4000,
NULL, VAR_6 }
},
{ &VAR_11,
{ ""Reserved"",                    ""bthci_iso.reserved"",
VAR_4, VAR_5, NULL, 0x8000,
NULL, VAR_6 }
},
{ &VAR_12,
{ ""This is a continuation to the PDU in frame"",    ""bthci_iso.continuation_to"",
VAR_13, VAR_14, NULL, 0x0,
""This is a continuation to the PDU in frame #"", VAR_6 }
},
{ &VAR_15,
{ ""This PDU is reassembled in frame"",              ""bthci_iso.reassembled_in"",
VAR_13, VAR_14, NULL, 0x0,
""This PDU is reassembled in frame #"", VAR_6 }
},
{ &VAR_16,
{ ""Connect in frame"",            ""bthci_iso.connect_in"",
VAR_13, VAR_14, NULL, 0x0,
NULL, VAR_6 }
},
{ &VAR_17,
{ ""Disconnect in frame"",         ""bthci_iso.disconnect_in"",
VAR_13, VAR_14, NULL, 0x0,
NULL, VAR_6 }
},
{ &VAR_18,
{ ""Data Length"",           ""bthci_iso.data_length"",
VAR_4, VAR_19, NULL, 0x3FFF,
NULL, VAR_6 }
},
{ &VAR_20,
{ ""Data"",                        ""bthci_iso.data"",
VAR_21, VAR_14, NULL, 0x0,
NULL, VAR_6 }
},
};
static gint *VAR_22[] = {
&VAR_23,
};
static ei_register_info VAR_24[] = {
{ &VAR_25,      { ""bthci_iso.length.bad"",      VAR_26, VAR_27, ""Length too short"", VAR_28 }},
};
VAR_29 = proto_register_protocol(""Bluetooth HCI ISO Packet"", ""HCI_ISO"", ""bthci_iso"");
VAR_30 = register_dissector(""bthci_iso"", VAR_31, VAR_29);
proto_register_field_array(VAR_29, VAR_2, array_length(VAR_2));
proto_register_subtree_array(VAR_22, array_length(VAR_22));
VAR_1 = expert_register_protocol(VAR_29);
expert_register_field_array(VAR_1, VAR_24, array_length(VAR_24));
VAR_0 = prefs_register_protocol_subtree(""Bluetooth"", VAR_29, NULL);
prefs_register_bool_preference(VAR_0, ""hci_iso_reassembly"",
""Reassemble ISO Fragments"",
""Whether the ISO dissector should reassemble fragmented PDUs"",
&VAR_32);
VAR_33 = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());
}",wireshark/acaaad150b75a295184588c4127698a77493c9f0/packet-bthci_iso.c/vul/before/1.json,"void
proto_register_bthci_iso(void)
{
    module_t         *bthci_iso_module;
    expert_module_t  *bthci_iso_expert_module;
    static hf_register_info hf[] = {
        { &hf_bthci_iso_chandle,
          { ""Connection Handle"",           ""bthci_iso.chandle"",
            FT_UINT16, BASE_HEX, NULL, 0x0FFF,
            NULL, HFILL }
        },
        { &hf_bthci_iso_pb_flag,
          { ""PB Flag"",               ""bthci_iso.pb_flag"",
            FT_UINT16, BASE_HEX, VALS(iso_pb_flag_vals), 0x3000,
            ""Packet Boundary Flag"", HFILL }
        },
        { &hf_bthci_iso_ts_flag,
          { ""Timestamp present"",               ""bthci_iso.ts_flag"",
            FT_BOOLEAN, 16, NULL, 0x4000,
            NULL, HFILL }
        },
        { &hf_bthci_iso_reserved,
          { ""Reserved"",                    ""bthci_iso.reserved"",
            FT_UINT16, BASE_HEX, NULL, 0x8000,
            NULL, HFILL }
        },
        { &hf_bthci_iso_continuation_to,
          { ""This is a continuation to the PDU in frame"",    ""bthci_iso.continuation_to"",
            FT_FRAMENUM, BASE_NONE, NULL, 0x0,
            ""This is a continuation to the PDU in frame #"", HFILL }
        },
        { &hf_bthci_iso_reassembled_in,
          { ""This PDU is reassembled in frame"",              ""bthci_iso.reassembled_in"",
            FT_FRAMENUM, BASE_NONE, NULL, 0x0,
            ""This PDU is reassembled in frame #"", HFILL }
        },
        { &hf_bthci_iso_connect_in,
          { ""Connect in frame"",            ""bthci_iso.connect_in"",
            FT_FRAMENUM, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_bthci_iso_disconnect_in,
          { ""Disconnect in frame"",         ""bthci_iso.disconnect_in"",
            FT_FRAMENUM, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_bthci_iso_data_length,
          { ""Data Length"",           ""bthci_iso.data_length"",
            FT_UINT16, BASE_DEC, NULL, 0x3FFF,
            NULL, HFILL }
        },
        { &hf_bthci_iso_data,
          { ""Data"",                        ""bthci_iso.data"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
    };

    /* Setup protocol subtree array */
    static gint *ett[] = {
        &ett_bthci_iso,
    };

    static ei_register_info ei[] = {
        { &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Invalid length"", EXPFILL }},
    };

    /* Register the protocol name and description */
    proto_bthci_iso = proto_register_protocol(""Bluetooth HCI ISO Packet"", ""HCI_ISO"", ""bthci_iso"");
    bthci_iso_handle = register_dissector(""bthci_iso"", dissect_bthci_iso, proto_bthci_iso);

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_bthci_iso, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    bthci_iso_expert_module = expert_register_protocol(proto_bthci_iso);
    expert_register_field_array(bthci_iso_expert_module, ei, array_length(ei));

    /* Register configuration preferences */
    bthci_iso_module = prefs_register_protocol_subtree(""Bluetooth"", proto_bthci_iso, NULL);
    prefs_register_bool_preference(bthci_iso_module, ""hci_iso_reassembly"",
        ""Reassemble ISO Fragments"",
        ""Whether the ISO dissector should reassemble fragmented PDUs"",
        &iso_reassembly);

    chandle_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());
}","void
proto_register_bthci_iso(void)
{
    module_t         *VAR_0;
    expert_module_t  *VAR_1;
    static hf_register_info VAR_2[] = {
        { &VAR_3,
          { ""Connection Handle"",           ""bthci_iso.chandle"",
            VAR_4, VAR_5, NULL, 0x0FFF,
            NULL, VAR_6 }
        },
        { &VAR_7,
          { ""PB Flag"",               ""bthci_iso.pb_flag"",
            VAR_4, VAR_5, VALS(VAR_8), 0x3000,
            ""Packet Boundary Flag"", VAR_6 }
        },
        { &VAR_9,
          { ""Timestamp present"",               ""bthci_iso.ts_flag"",
            VAR_10, 16, NULL, 0x4000,
            NULL, VAR_6 }
        },
        { &VAR_11,
          { ""Reserved"",                    ""bthci_iso.reserved"",
            VAR_4, VAR_5, NULL, 0x8000,
            NULL, VAR_6 }
        },
        { &VAR_12,
          { ""This is a continuation to the PDU in frame"",    ""bthci_iso.continuation_to"",
            VAR_13, VAR_14, NULL, 0x0,
            ""This is a continuation to the PDU in frame #"", VAR_6 }
        },
        { &VAR_15,
          { ""This PDU is reassembled in frame"",              ""bthci_iso.reassembled_in"",
            VAR_13, VAR_14, NULL, 0x0,
            ""This PDU is reassembled in frame #"", VAR_6 }
        },
        { &VAR_16,
          { ""Connect in frame"",            ""bthci_iso.connect_in"",
            VAR_13, VAR_14, NULL, 0x0,
            NULL, VAR_6 }
        },
        { &VAR_17,
          { ""Disconnect in frame"",         ""bthci_iso.disconnect_in"",
            VAR_13, VAR_14, NULL, 0x0,
            NULL, VAR_6 }
        },
        { &VAR_18,
          { ""Data Length"",           ""bthci_iso.data_length"",
            VAR_4, VAR_19, NULL, 0x3FFF,
            NULL, VAR_6 }
        },
        { &VAR_20,
          { ""Data"",                        ""bthci_iso.data"",
            VAR_21, VAR_14, NULL, 0x0,
            NULL, VAR_6 }
        },
    };

    /* COMMENT_0 */
    static gint *VAR_22[] = {
        &VAR_23,
    };

    static ei_register_info VAR_24[] = {
        { &VAR_25,      { ""bthci_iso.length.bad"",      VAR_26, VAR_27, ""Invalid length"", VAR_28 }},
    };

    /* COMMENT_1 */
    VAR_29 = proto_register_protocol(""Bluetooth HCI ISO Packet"", ""HCI_ISO"", ""bthci_iso"");
    VAR_30 = register_dissector(""bthci_iso"", VAR_31, VAR_29);

    /* COMMENT_2 */
    proto_register_field_array(VAR_29, VAR_2, array_length(VAR_2));
    proto_register_subtree_array(VAR_22, array_length(VAR_22));

    VAR_1 = expert_register_protocol(VAR_29);
    expert_register_field_array(VAR_1, VAR_24, array_length(VAR_24));

    /* COMMENT_3 */
    VAR_0 = prefs_register_protocol_subtree(""Bluetooth"", VAR_29, NULL);
    prefs_register_bool_preference(VAR_0, ""hci_iso_reassembly"",
        ""Reassemble ISO Fragments"",
        ""Whether the ISO dissector should reassemble fragmented PDUs"",
        &VAR_32);

    VAR_33 = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());
}",wireshark/acaaad150b75a295184588c4127698a77493c9f0/packet-bthci_iso.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -62,7 +62,7 @@
     };
 
     static ei_register_info ei[] = {
-        { &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Length too short"", EXPFILL }},
+        { &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Invalid length"", EXPFILL }},
     };
 
     /* Register the protocol name and description */","{'deleted_lines': ['        { &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Length too short"", EXPFILL }},'], 'added_lines': ['        { &ei_length_bad,      { ""bthci_iso.length.bad"",      PI_MALFORMED, PI_WARN, ""Invalid length"", EXPFILL }},']}",True,Buffer overflow in the Bluetooth HCI_ISO dissector in Wireshark 3.4.0 to 3.4.9 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-45486,['CWE-327'],AV:A/AC:L/Au:S/C:P/I:N/A:N,0,torvalds/linux,"In commit 73f156a6e8c1 (""inetpeer: get rid of ip_id_count"")
I used a very small hash table that could be abused
by patient attackers to reveal sensitive information.

Switch to a dynamic sizing, depending on RAM size.

Typical big hosts will now use 128x more storage (2 MB)
to get a similar increase in security and reduction
of hash collisions.

As a bonus, use of alloc_large_system_hash() spreads
allocated memory among all NUMA nodes.

Fixes: 73f156a6e8c1 (""inetpeer: get rid of ip_id_count"")
Reported-by: Amit Klein <aksecurity@gmail.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Willy Tarreau <w@1wt.eu>
Signed-off-by: David S. Miller <davem@davemloft.net>
",aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/ipv4/route.c?h=aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,net/ipv4/route.c,ip_idents_reserve,"u32 ip_idents_reserve(u32 hash, int segs)
{
u32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;
atomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;
u32 old = READ_ONCE(*p_tstamp);
u32 now = (u32)jiffies;
u32 delta = 0;
if (old != now && cmpxchg(p_tstamp, old, now) == old)
delta = prandom_u32_max(now - old);
return atomic_add_return(segs + delta, p_id) - segs;
}","u32 ip_idents_reserve(u32 VAR_0, int VAR_1)
{
u32 *VAR_2 = VAR_3 + VAR_0 % VAR_4;
atomic_t *VAR_5 = VAR_6 + VAR_0 % VAR_4;
u32 VAR_7 = READ_ONCE(*VAR_2);
u32 VAR_8 = (u32)VAR_9;
u32 VAR_10 = 0;
if (VAR_7 != VAR_8 && cmpxchg(VAR_2, VAR_7, VAR_8) == VAR_7)
VAR_10 = prandom_u32_max(VAR_8 - VAR_7);
return atomic_add_return(VAR_1 + VAR_10, VAR_5) - VAR_1;
}",torvalds/linux/aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba/route.c/vul/before/0.json,"u32 ip_idents_reserve(u32 hash, int segs)
{
	u32 bucket, old, now = (u32)jiffies;
	atomic_t *p_id;
	u32 *p_tstamp;
	u32 delta = 0;

	bucket = hash & ip_idents_mask;
	p_tstamp = ip_tstamps + bucket;
	p_id = ip_idents + bucket;
	old = READ_ONCE(*p_tstamp);

	if (old != now && cmpxchg(p_tstamp, old, now) == old)
		delta = prandom_u32_max(now - old);

	/* If UBSAN reports an error there, please make sure your compiler
	 * supports -fno-strict-overflow before reporting it that was a bug
	 * in UBSAN, and it has been fixed in GCC-8.
	 */
	return atomic_add_return(segs + delta, p_id) - segs;
}","u32 ip_idents_reserve(u32 VAR_0, int VAR_1)
{
	u32 VAR_2, VAR_3, VAR_4 = (u32)VAR_5;
	atomic_t *VAR_6;
	u32 *VAR_7;
	u32 VAR_8 = 0;

	VAR_2 = VAR_0 & VAR_9;
	VAR_7 = VAR_10 + VAR_2;
	VAR_6 = VAR_11 + VAR_2;
	VAR_3 = READ_ONCE(*VAR_7);

	if (VAR_3 != VAR_4 && cmpxchg(VAR_7, VAR_3, VAR_4) == VAR_3)
		VAR_8 = prandom_u32_max(VAR_4 - VAR_3);

	/* COMMENT_0 */
                                                                    
                                             
    
	return atomic_add_return(VAR_1 + VAR_8, VAR_6) - VAR_1;
}",torvalds/linux/aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba/route.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,14 @@
 u32 ip_idents_reserve(u32 hash, int segs)
 {
-	u32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;
-	atomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;
-	u32 old = READ_ONCE(*p_tstamp);
-	u32 now = (u32)jiffies;
+	u32 bucket, old, now = (u32)jiffies;
+	atomic_t *p_id;
+	u32 *p_tstamp;
 	u32 delta = 0;
+
+	bucket = hash & ip_idents_mask;
+	p_tstamp = ip_tstamps + bucket;
+	p_id = ip_idents + bucket;
+	old = READ_ONCE(*p_tstamp);
 
 	if (old != now && cmpxchg(p_tstamp, old, now) == old)
 		delta = prandom_u32_max(now - old);","{'deleted_lines': ['\tu32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;', '\tatomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;', '\tu32 old = READ_ONCE(*p_tstamp);', '\tu32 now = (u32)jiffies;'], 'added_lines': ['\tu32 bucket, old, now = (u32)jiffies;', '\tatomic_t *p_id;', '\tu32 *p_tstamp;', '', '\tbucket = hash & ip_idents_mask;', '\tp_tstamp = ip_tstamps + bucket;', '\tp_id = ip_idents + bucket;', '\told = READ_ONCE(*p_tstamp);']}",True,"In the IPv4 implementation in the Linux kernel before 5.12.4, net/ipv4/route.c has an information leak because the hash table is very small.",3.5,LOW,0,valid,,5
CVE-2021-45486,['CWE-327'],AV:A/AC:L/Au:S/C:P/I:N/A:N,0,torvalds/linux,"In commit 73f156a6e8c1 (""inetpeer: get rid of ip_id_count"")
I used a very small hash table that could be abused
by patient attackers to reveal sensitive information.

Switch to a dynamic sizing, depending on RAM size.

Typical big hosts will now use 128x more storage (2 MB)
to get a similar increase in security and reduction
of hash collisions.

As a bonus, use of alloc_large_system_hash() spreads
allocated memory among all NUMA nodes.

Fixes: 73f156a6e8c1 (""inetpeer: get rid of ip_id_count"")
Reported-by: Amit Klein <aksecurity@gmail.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Willy Tarreau <w@1wt.eu>
Signed-off-by: David S. Miller <davem@davemloft.net>
",aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/ipv4/route.c?h=aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,net/ipv4/route.c,ip_rt_init,"int __init ip_rt_init(void)
{
int cpu;
ip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),
GFP_KERNEL);
if (!ip_idents)
panic(""IP: failed to allocate ip_idents\n"");
prandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));
ip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);
if (!ip_tstamps)
panic(""IP: failed to allocate ip_tstamps\n"");
for_each_possible_cpu(cpu) {
struct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);
INIT_LIST_HEAD(&ul->head);
spin_lock_init(&ul->lock);
}
#ifdef CONFIG_IP_ROUTE_CLASSID
ip_rt_acct = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));
if (!ip_rt_acct)
panic(""IP: failed to allocate ip_rt_acct\n"");
#endif
ipv4_dst_ops.kmem_cachep =
kmem_cache_create(""ip_dst_cache"", sizeof(struct rtable), 0,
SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
ipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;
if (dst_entries_init(&ipv4_dst_ops) < 0)
panic(""IP: failed to allocate ipv4_dst_ops counter\n"");
if (dst_entries_init(&ipv4_dst_blackhole_ops) < 0)
panic(""IP: failed to allocate ipv4_dst_blackhole_ops counter\n"");
ipv4_dst_ops.gc_thresh = ~0;
ip_rt_max_size = INT_MAX;
devinet_init();
ip_fib_init();
if (ip_rt_proc_init())
pr_err(""Unable to create route proc files\n"");
#ifdef CONFIG_XFRM
xfrm_init();
xfrm4_init();
#endif
rtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL,
RTNL_FLAG_DOIT_UNLOCKED);
#ifdef CONFIG_SYSCTL
register_pernet_subsys(&sysctl_route_ops);
#endif
register_pernet_subsys(&rt_genid_ops);
register_pernet_subsys(&ipv4_inetpeer_ops);
return 0;
}","int __init ip_rt_init(void)
{
int VAR_0;
VAR_1 = kmalloc_array(VAR_2, sizeof(*VAR_1),
VAR_3);
if (!VAR_1)
panic(""IP: failed to allocate ip_idents\n"");
prandom_bytes(VAR_1, VAR_2 * sizeof(*VAR_1));
VAR_4 = kcalloc(VAR_2, sizeof(*VAR_4), VAR_3);
if (!VAR_4)
panic(""IP: failed to allocate ip_tstamps\n"");
for_each_possible_cpu(VAR_0) {
struct uncached_list *VAR_5 = &per_cpu(VAR_6, VAR_0);
INIT_LIST_HEAD(&VAR_5->head);
spin_lock_init(&VAR_5->lock);
}
#ifdef VAR_7
VAR_8 = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));
if (!ip_rt_acct)
panic(""IP: failed to allocate ip_rt_acct\n"");
#endif
VAR_9.kmem_cachep =
kmem_cache_create(""ip_dst_cache"", sizeof(struct rtable), 0,
VAR_10|VAR_11, NULL);
VAR_12.kmem_cachep = VAR_9.kmem_cachep;
if (dst_entries_init(&VAR_9) < 0)
panic(""IP: failed to allocate ipv4_dst_ops counter\n"");
if (dst_entries_init(&VAR_12) < 0)
panic(""IP: failed to allocate ipv4_dst_blackhole_ops counter\n"");
VAR_9.gc_thresh = ~0;
VAR_13 = VAR_14;
devinet_init();
ip_fib_init();
if (ip_rt_proc_init())
pr_err(""Unable to create route proc files\n"");
#ifdef VAR_15
xfrm_init();
xfrm4_init();
#endif
rtnl_register(VAR_16, VAR_17, VAR_18, NULL,
VAR_19);
#ifdef VAR_20
register_pernet_subsys(&VAR_21);
#endif
register_pernet_subsys(&VAR_22);
register_pernet_subsys(&VAR_23);
return 0;
}",,"int __init ip_rt_init(void)
{
	void *idents_hash;
	int cpu;

	/* For modern hosts, this will use 2 MB of memory */
	idents_hash = alloc_large_system_hash(""IP idents"",
					      sizeof(*ip_idents) + sizeof(*ip_tstamps),
					      0,
					      16, /* one bucket per 64 KB */
					      HASH_ZERO,
					      NULL,
					      &ip_idents_mask,
					      2048,
					      256*1024);

	ip_idents = idents_hash;

	prandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));

	ip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);

	for_each_possible_cpu(cpu) {
		struct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);

		INIT_LIST_HEAD(&ul->head);
		spin_lock_init(&ul->lock);
	}
#ifdef CONFIG_IP_ROUTE_CLASSID
	ip_rt_acct = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));
	if (!ip_rt_acct)
		panic(""IP: failed to allocate ip_rt_acct\n"");
#endif

	ipv4_dst_ops.kmem_cachep =
		kmem_cache_create(""ip_dst_cache"", sizeof(struct rtable), 0,
				  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);

	ipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;

	if (dst_entries_init(&ipv4_dst_ops) < 0)
		panic(""IP: failed to allocate ipv4_dst_ops counter\n"");

	if (dst_entries_init(&ipv4_dst_blackhole_ops) < 0)
		panic(""IP: failed to allocate ipv4_dst_blackhole_ops counter\n"");

	ipv4_dst_ops.gc_thresh = ~0;
	ip_rt_max_size = INT_MAX;

	devinet_init();
	ip_fib_init();

	if (ip_rt_proc_init())
		pr_err(""Unable to create route proc files\n"");
#ifdef CONFIG_XFRM
	xfrm_init();
	xfrm4_init();
#endif
	rtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL,
		      RTNL_FLAG_DOIT_UNLOCKED);

#ifdef CONFIG_SYSCTL
	register_pernet_subsys(&sysctl_route_ops);
#endif
	register_pernet_subsys(&rt_genid_ops);
	register_pernet_subsys(&ipv4_inetpeer_ops);
	return 0;
}","int __init ip_rt_init(void)
{
	void *VAR_0;
	int VAR_1;

	/* COMMENT_0 */
	VAR_0 = alloc_large_system_hash(""IP idents"",
					      sizeof(*VAR_2) + sizeof(*VAR_3),
					      0,
					      16, /* COMMENT_1 */
					      VAR_4,
					      NULL,
					      &VAR_5,
					      2048,
					      256*1024);

	VAR_2 = VAR_0;

	prandom_bytes(VAR_2, (VAR_5 + 1) * sizeof(*VAR_2));

	VAR_3 = VAR_0 + (VAR_5 + 1) * sizeof(*VAR_2);

	for_each_possible_cpu(VAR_1) {
		struct uncached_list *VAR_6 = &per_cpu(VAR_7, VAR_1);

		INIT_LIST_HEAD(&VAR_6->head);
		spin_lock_init(&VAR_6->lock);
	}
#ifdef VAR_8
	VAR_9 = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));
	if (!ip_rt_acct)
		panic(""IP: failed to allocate ip_rt_acct\n"");
#endif

	VAR_10.kmem_cachep =
		kmem_cache_create(""ip_dst_cache"", sizeof(struct rtable), 0,
				  VAR_11|VAR_12, NULL);

	VAR_13.kmem_cachep = VAR_10.kmem_cachep;

	if (dst_entries_init(&VAR_10) < 0)
		panic(""IP: failed to allocate ipv4_dst_ops counter\n"");

	if (dst_entries_init(&VAR_13) < 0)
		panic(""IP: failed to allocate ipv4_dst_blackhole_ops counter\n"");

	VAR_10.gc_thresh = ~0;
	VAR_14 = VAR_15;

	devinet_init();
	ip_fib_init();

	if (ip_rt_proc_init())
		pr_err(""Unable to create route proc files\n"");
#ifdef VAR_16
	xfrm_init();
	xfrm4_init();
#endif
	rtnl_register(VAR_17, VAR_18, VAR_19, NULL,
		      VAR_20);

#ifdef VAR_21
	register_pernet_subsys(&VAR_22);
#endif
	register_pernet_subsys(&VAR_23);
	register_pernet_subsys(&VAR_24);
	return 0;
}",,"--- func_before
+++ func_after
@@ -1,17 +1,24 @@
 int __init ip_rt_init(void)
 {
+	void *idents_hash;
 	int cpu;
 
-	ip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),
-				  GFP_KERNEL);
-	if (!ip_idents)
-		panic(""IP: failed to allocate ip_idents\n"");
+	/* For modern hosts, this will use 2 MB of memory */
+	idents_hash = alloc_large_system_hash(""IP idents"",
+					      sizeof(*ip_idents) + sizeof(*ip_tstamps),
+					      0,
+					      16, /* one bucket per 64 KB */
+					      HASH_ZERO,
+					      NULL,
+					      &ip_idents_mask,
+					      2048,
+					      256*1024);
 
-	prandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));
+	ip_idents = idents_hash;
 
-	ip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);
-	if (!ip_tstamps)
-		panic(""IP: failed to allocate ip_tstamps\n"");
+	prandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));
+
+	ip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);
 
 	for_each_possible_cpu(cpu) {
 		struct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);","{'deleted_lines': ['\tip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),', '\t\t\t\t  GFP_KERNEL);', '\tif (!ip_idents)', '\t\tpanic(""IP: failed to allocate ip_idents\\n"");', '\tprandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));', '\tip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);', '\tif (!ip_tstamps)', '\t\tpanic(""IP: failed to allocate ip_tstamps\\n"");'], 'added_lines': ['\tvoid *idents_hash;', '\t/* For modern hosts, this will use 2 MB of memory */', '\tidents_hash = alloc_large_system_hash(""IP idents"",', '\t\t\t\t\t      sizeof(*ip_idents) + sizeof(*ip_tstamps),', '\t\t\t\t\t      0,', '\t\t\t\t\t      16, /* one bucket per 64 KB */', '\t\t\t\t\t      HASH_ZERO,', '\t\t\t\t\t      NULL,', '\t\t\t\t\t      &ip_idents_mask,', '\t\t\t\t\t      2048,', '\t\t\t\t\t      256*1024);', '\tip_idents = idents_hash;', '\tprandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));', '', '\tip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);']}",True,"In the IPv4 implementation in the Linux kernel before 5.12.4, net/ipv4/route.c has an information leak because the hash table is very small.",3.5,LOW,0,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,map_delete_elem,"static int map_delete_elem(union bpf_attr *attr)
{
void __user *ukey = u64_to_user_ptr(attr->key);
int ufd = attr->map_fd;
struct bpf_map *map;
struct fd f;
void *key;
int err;
if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
return -EINVAL;
f = fdget(ufd);
map = __bpf_map_get(f);
if (IS_ERR(map))
return PTR_ERR(map);
if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
err = -EPERM;
goto err_put;
}
key = __bpf_copy_key(ukey, map->key_size);
if (IS_ERR(key)) {
err = PTR_ERR(key);
goto err_put;
}
if (bpf_map_is_dev_bound(map)) {
err = bpf_map_offload_delete_elem(map, key);
goto out;
} else if (IS_FD_PROG_ARRAY(map) ||
map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
err = map->ops->map_delete_elem(map, key);
goto out;
}
bpf_disable_instrumentation();
rcu_read_lock();
err = map->ops->map_delete_elem(map, key);
rcu_read_unlock();
bpf_enable_instrumentation();
maybe_wait_bpf_programs(map);
out:
kvfree(key);
err_put:
fdput(f);
return err;
}","static int map_delete_elem(union bpf_attr *VAR_0)
{
void __user *VAR_1 = u64_to_user_ptr(VAR_0->key);
int VAR_2 = VAR_0->map_fd;
struct bpf_map *VAR_3;
struct fd VAR_4;
void *VAR_5;
int VAR_6;
if (CHECK_ATTR(VAR_7))
return -VAR_8;
VAR_4 = fdget(VAR_2);
VAR_3 = __bpf_map_get(VAR_4);
if (IS_ERR(VAR_3))
return PTR_ERR(VAR_3);
if (!(map_get_sys_perms(VAR_3, VAR_4) & VAR_9)) {
VAR_6 = -VAR_10;
goto err_put;
}
VAR_5 = __bpf_copy_key(VAR_1, VAR_3->key_size);
if (IS_ERR(VAR_5)) {
VAR_6 = PTR_ERR(VAR_5);
goto err_put;
}
if (bpf_map_is_dev_bound(VAR_3)) {
VAR_6 = bpf_map_offload_delete_elem(VAR_3, VAR_5);
goto out;
} else if (IS_FD_PROG_ARRAY(VAR_3) ||
VAR_3->map_type == VAR_11) {
VAR_6 = VAR_3->ops->map_delete_elem(VAR_3, VAR_5);
goto out;
}
bpf_disable_instrumentation();
rcu_read_lock();
VAR_6 = VAR_3->ops->map_delete_elem(VAR_3, VAR_5);
rcu_read_unlock();
bpf_enable_instrumentation();
maybe_wait_bpf_programs(VAR_3);
out:
kvfree(VAR_5);
err_put:
fdput(VAR_4);
return VAR_6;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/0.json,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	bpf_map_write_active_inc(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	bpf_map_write_active_dec(map);
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *VAR_0)
{
	void __user *VAR_1 = u64_to_user_ptr(VAR_0->key);
	int VAR_2 = VAR_0->map_fd;
	struct bpf_map *VAR_3;
	struct fd VAR_4;
	void *VAR_5;
	int VAR_6;

	if (CHECK_ATTR(VAR_7))
		return -VAR_8;

	VAR_4 = fdget(VAR_2);
	VAR_3 = __bpf_map_get(VAR_4);
	if (IS_ERR(VAR_3))
		return PTR_ERR(VAR_3);
	bpf_map_write_active_inc(VAR_3);
	if (!(map_get_sys_perms(VAR_3, VAR_4) & VAR_9)) {
		VAR_6 = -VAR_10;
		goto err_put;
	}

	VAR_5 = __bpf_copy_key(VAR_1, VAR_3->key_size);
	if (IS_ERR(VAR_5)) {
		VAR_6 = PTR_ERR(VAR_5);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(VAR_3)) {
		VAR_6 = bpf_map_offload_delete_elem(VAR_3, VAR_5);
		goto out;
	} else if (IS_FD_PROG_ARRAY(VAR_3) ||
		   VAR_3->map_type == VAR_11) {
		/* COMMENT_0 */
		VAR_6 = VAR_3->ops->map_delete_elem(VAR_3, VAR_5);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	VAR_6 = VAR_3->ops->map_delete_elem(VAR_3, VAR_5);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(VAR_3);
out:
	kvfree(VAR_5);
err_put:
	bpf_map_write_active_dec(VAR_3);
	fdput(VAR_4);
	return VAR_6;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return PTR_ERR(map);
+	bpf_map_write_active_inc(map);
 	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
 		err = -EPERM;
 		goto err_put;
@@ -44,6 +45,7 @@
 out:
 	kvfree(key);
 err_put:
+	bpf_map_write_active_dec(map);
 	fdput(f);
 	return err;
 }","{'deleted_lines': [], 'added_lines': ['\tbpf_map_write_active_inc(map);', '\tbpf_map_write_active_dec(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,bpf_map_mmap_open,"static void bpf_map_mmap_open(struct vm_area_struct *vma)
{
struct bpf_map *map = vma->vm_file->private_data;
if (vma->vm_flags & VM_MAYWRITE) {
mutex_lock(&map->freeze_mutex);
map->writecnt++;
mutex_unlock(&map->freeze_mutex);
}
}","static void bpf_map_mmap_open(struct vm_area_struct *VAR_0)
{
struct bpf_map *VAR_1 = VAR_0->vm_file->private_data;
if (VAR_0->vm_flags & VAR_2) {
mutex_lock(&VAR_1->freeze_mutex);
VAR_1->writecnt++;
mutex_unlock(&VAR_1->freeze_mutex);
}
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/1.json,"static void bpf_map_mmap_open(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;

	if (vma->vm_flags & VM_MAYWRITE)
		bpf_map_write_active_inc(map);
}","static void bpf_map_mmap_open(struct vm_area_struct *VAR_0)
{
	struct bpf_map *VAR_1 = VAR_0->vm_file->private_data;

	if (VAR_0->vm_flags & VAR_2)
		bpf_map_write_active_inc(VAR_1);
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,9 +2,6 @@
 {
 	struct bpf_map *map = vma->vm_file->private_data;
 
-	if (vma->vm_flags & VM_MAYWRITE) {
-		mutex_lock(&map->freeze_mutex);
-		map->writecnt++;
-		mutex_unlock(&map->freeze_mutex);
-	}
+	if (vma->vm_flags & VM_MAYWRITE)
+		bpf_map_write_active_inc(map);
 }","{'deleted_lines': ['\tif (vma->vm_flags & VM_MAYWRITE) {', '\t\tmutex_lock(&map->freeze_mutex);', '\t\tmap->writecnt++;', '\t\tmutex_unlock(&map->freeze_mutex);', '\t}'], 'added_lines': ['\tif (vma->vm_flags & VM_MAYWRITE)', '\t\tbpf_map_write_active_inc(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,bpf_map_mmap_close,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
struct bpf_map *map = vma->vm_file->private_data;
if (vma->vm_flags & VM_MAYWRITE) {
mutex_lock(&map->freeze_mutex);
map->writecnt--;
mutex_unlock(&map->freeze_mutex);
}
}","static void bpf_map_mmap_close(struct vm_area_struct *VAR_0)
{
struct bpf_map *VAR_1 = VAR_0->vm_file->private_data;
if (VAR_0->vm_flags & VAR_2) {
mutex_lock(&VAR_1->freeze_mutex);
VAR_1->writecnt--;
mutex_unlock(&VAR_1->freeze_mutex);
}
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/2.json,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;

	if (vma->vm_flags & VM_MAYWRITE)
		bpf_map_write_active_dec(map);
}","static void bpf_map_mmap_close(struct vm_area_struct *VAR_0)
{
	struct bpf_map *VAR_1 = VAR_0->vm_file->private_data;

	if (VAR_0->vm_flags & VAR_2)
		bpf_map_write_active_dec(VAR_1);
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,9 +2,6 @@
 {
 	struct bpf_map *map = vma->vm_file->private_data;
 
-	if (vma->vm_flags & VM_MAYWRITE) {
-		mutex_lock(&map->freeze_mutex);
-		map->writecnt--;
-		mutex_unlock(&map->freeze_mutex);
-	}
+	if (vma->vm_flags & VM_MAYWRITE)
+		bpf_map_write_active_dec(map);
 }","{'deleted_lines': ['\tif (vma->vm_flags & VM_MAYWRITE) {', '\t\tmutex_lock(&map->freeze_mutex);', '\t\tmap->writecnt--;', '\t\tmutex_unlock(&map->freeze_mutex);', '\t}'], 'added_lines': ['\tif (vma->vm_flags & VM_MAYWRITE)', '\t\tbpf_map_write_active_dec(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,bpf_map_mmap,"static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma)
{
struct bpf_map *map = filp->private_data;
int err;
if (!map->ops->map_mmap || map_value_has_spin_lock(map) ||
map_value_has_timer(map))
return -ENOTSUPP;
if (!(vma->vm_flags & VM_SHARED))
return -EINVAL;
mutex_lock(&map->freeze_mutex);
if (vma->vm_flags & VM_WRITE) {
if (map->frozen) {
err = -EPERM;
goto out;
}
if (map->map_flags & BPF_F_RDONLY_PROG) {
err = -EACCES;
goto out;
}
}
vma->vm_ops = &bpf_map_default_vmops;
vma->vm_private_data = map;
vma->vm_flags &= ~VM_MAYEXEC;
if (!(vma->vm_flags & VM_WRITE))
vma->vm_flags &= ~VM_MAYWRITE;
err = map->ops->map_mmap(map, vma);
if (err)
goto out;
if (vma->vm_flags & VM_MAYWRITE)
map->writecnt++;
out:
mutex_unlock(&map->freeze_mutex);
return err;
}","static int bpf_map_mmap(struct file *VAR_0, struct vm_area_struct *VAR_1)
{
struct bpf_map *VAR_2 = VAR_0->private_data;
int VAR_3;
if (!VAR_2->ops->map_mmap || map_value_has_spin_lock(VAR_2) ||
map_value_has_timer(VAR_2))
return -VAR_4;
if (!(VAR_1->vm_flags & VAR_5))
return -VAR_6;
mutex_lock(&VAR_2->freeze_mutex);
if (VAR_1->vm_flags & VAR_7) {
if (VAR_2->frozen) {
VAR_3 = -VAR_8;
goto out;
}
if (VAR_2->map_flags & VAR_9) {
VAR_3 = -VAR_10;
goto out;
}
}
VAR_1->vm_ops = &VAR_11;
VAR_1->vm_private_data = VAR_2;
VAR_1->vm_flags &= ~VAR_12;
if (!(VAR_1->vm_flags & VAR_7))
VAR_1->vm_flags &= ~VAR_13;
VAR_3 = VAR_2->ops->map_mmap(VAR_2, VAR_1);
if (VAR_3)
goto out;
if (VAR_1->vm_flags & VAR_13)
VAR_2->writecnt++;
out:
mutex_unlock(&VAR_2->freeze_mutex);
return VAR_3;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/3.json,"static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct bpf_map *map = filp->private_data;
	int err;

	if (!map->ops->map_mmap || map_value_has_spin_lock(map) ||
	    map_value_has_timer(map))
		return -ENOTSUPP;

	if (!(vma->vm_flags & VM_SHARED))
		return -EINVAL;

	mutex_lock(&map->freeze_mutex);

	if (vma->vm_flags & VM_WRITE) {
		if (map->frozen) {
			err = -EPERM;
			goto out;
		}
		/* map is meant to be read-only, so do not allow mapping as
		 * writable, because it's possible to leak a writable page
		 * reference and allows user-space to still modify it after
		 * freezing, while verifier will assume contents do not change
		 */
		if (map->map_flags & BPF_F_RDONLY_PROG) {
			err = -EACCES;
			goto out;
		}
	}

	/* set default open/close callbacks */
	vma->vm_ops = &bpf_map_default_vmops;
	vma->vm_private_data = map;
	vma->vm_flags &= ~VM_MAYEXEC;
	if (!(vma->vm_flags & VM_WRITE))
		/* disallow re-mapping with PROT_WRITE */
		vma->vm_flags &= ~VM_MAYWRITE;

	err = map->ops->map_mmap(map, vma);
	if (err)
		goto out;

	if (vma->vm_flags & VM_MAYWRITE)
		bpf_map_write_active_inc(map);
out:
	mutex_unlock(&map->freeze_mutex);
	return err;
}","static int bpf_map_mmap(struct file *VAR_0, struct vm_area_struct *VAR_1)
{
	struct bpf_map *VAR_2 = VAR_0->private_data;
	int VAR_3;

	if (!VAR_2->ops->map_mmap || map_value_has_spin_lock(VAR_2) ||
	    map_value_has_timer(VAR_2))
		return -VAR_4;

	if (!(VAR_1->vm_flags & VAR_5))
		return -VAR_6;

	mutex_lock(&VAR_2->freeze_mutex);

	if (VAR_1->vm_flags & VAR_7) {
		if (VAR_2->frozen) {
			VAR_3 = -VAR_8;
			goto out;
		}
		/* COMMENT_0 */
                                                            
                                                             
                                                                
     
		if (VAR_2->map_flags & VAR_9) {
			VAR_3 = -VAR_10;
			goto out;
		}
	}

	/* COMMENT_5 */
	VAR_1->vm_ops = &VAR_11;
	VAR_1->vm_private_data = VAR_2;
	VAR_1->vm_flags &= ~VAR_12;
	if (!(VAR_1->vm_flags & VAR_7))
		/* COMMENT_6 */
		VAR_1->vm_flags &= ~VAR_13;

	VAR_3 = VAR_2->ops->map_mmap(VAR_2, VAR_1);
	if (VAR_3)
		goto out;

	if (VAR_1->vm_flags & VAR_13)
		bpf_map_write_active_inc(VAR_2);
out:
	mutex_unlock(&VAR_2->freeze_mutex);
	return VAR_3;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -41,7 +41,7 @@
 		goto out;
 
 	if (vma->vm_flags & VM_MAYWRITE)
-		map->writecnt++;
+		bpf_map_write_active_inc(map);
 out:
 	mutex_unlock(&map->freeze_mutex);
 	return err;","{'deleted_lines': ['\t\tmap->writecnt++;'], 'added_lines': ['\t\tbpf_map_write_active_inc(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,map_update_elem,"static int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)
{
bpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);
bpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);
int ufd = attr->map_fd;
struct bpf_map *map;
void *key, *value;
u32 value_size;
struct fd f;
int err;
if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))
return -EINVAL;
f = fdget(ufd);
map = __bpf_map_get(f);
if (IS_ERR(map))
return PTR_ERR(map);
if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
err = -EPERM;
goto err_put;
}
if ((attr->flags & BPF_F_LOCK) &&
!map_value_has_spin_lock(map)) {
err = -EINVAL;
goto err_put;
}
key = ___bpf_copy_key(ukey, map->key_size);
if (IS_ERR(key)) {
err = PTR_ERR(key);
goto err_put;
}
value_size = bpf_map_value_size(map);
err = -ENOMEM;
value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
if (!value)
goto free_key;
err = -EFAULT;
if (copy_from_bpfptr(value, uvalue, value_size) != 0)
goto free_value;
err = bpf_map_update_value(map, f, key, value, attr->flags);
free_value:
kvfree(value);
free_key:
kvfree(key);
err_put:
fdput(f);
return err;
}","static int map_update_elem(union bpf_attr *VAR_0, bpfptr_t VAR_1)
{
bpfptr_t VAR_2 = make_bpfptr(VAR_0->key, VAR_1.is_kernel);
bpfptr_t VAR_3 = make_bpfptr(VAR_0->value, VAR_1.is_kernel);
int VAR_4 = VAR_0->map_fd;
struct bpf_map *VAR_5;
void *VAR_6, *VAR_7;
u32 VAR_8;
struct fd VAR_9;
int VAR_10;
if (CHECK_ATTR(VAR_11))
return -VAR_12;
VAR_9 = fdget(VAR_4);
VAR_5 = __bpf_map_get(VAR_9);
if (IS_ERR(VAR_5))
return PTR_ERR(VAR_5);
if (!(map_get_sys_perms(VAR_5, VAR_9) & VAR_13)) {
VAR_10 = -VAR_14;
goto err_put;
}
if ((VAR_0->flags & VAR_15) &&
!map_value_has_spin_lock(VAR_5)) {
VAR_10 = -VAR_12;
goto err_put;
}
VAR_6 = ___bpf_copy_key(VAR_2, VAR_5->key_size);
if (IS_ERR(VAR_6)) {
VAR_10 = PTR_ERR(VAR_6);
goto err_put;
}
VAR_8 = bpf_map_value_size(VAR_5);
VAR_10 = -VAR_16;
VAR_7 = kvmalloc(VAR_8, VAR_17 | VAR_18);
if (!VAR_7)
goto free_key;
VAR_10 = -VAR_19;
if (copy_from_bpfptr(VAR_7, VAR_3, VAR_8) != 0)
goto free_value;
VAR_10 = bpf_map_update_value(VAR_5, VAR_9, VAR_6, VAR_7, VAR_0->flags);
free_value:
kvfree(VAR_7);
free_key:
kvfree(VAR_6);
err_put:
fdput(VAR_9);
return VAR_10;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/4.json,"static int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)
{
	bpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);
	bpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	void *key, *value;
	u32 value_size;
	struct fd f;
	int err;

	if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	bpf_map_write_active_inc(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	if ((attr->flags & BPF_F_LOCK) &&
	    !map_value_has_spin_lock(map)) {
		err = -EINVAL;
		goto err_put;
	}

	key = ___bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	value_size = bpf_map_value_size(map);

	err = -ENOMEM;
	value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
	if (!value)
		goto free_key;

	err = -EFAULT;
	if (copy_from_bpfptr(value, uvalue, value_size) != 0)
		goto free_value;

	err = bpf_map_update_value(map, f, key, value, attr->flags);

free_value:
	kvfree(value);
free_key:
	kvfree(key);
err_put:
	bpf_map_write_active_dec(map);
	fdput(f);
	return err;
}","static int map_update_elem(union bpf_attr *VAR_0, bpfptr_t VAR_1)
{
	bpfptr_t VAR_2 = make_bpfptr(VAR_0->key, VAR_1.is_kernel);
	bpfptr_t VAR_3 = make_bpfptr(VAR_0->value, VAR_1.is_kernel);
	int VAR_4 = VAR_0->map_fd;
	struct bpf_map *VAR_5;
	void *VAR_6, *VAR_7;
	u32 VAR_8;
	struct fd VAR_9;
	int VAR_10;

	if (CHECK_ATTR(VAR_11))
		return -VAR_12;

	VAR_9 = fdget(VAR_4);
	VAR_5 = __bpf_map_get(VAR_9);
	if (IS_ERR(VAR_5))
		return PTR_ERR(VAR_5);
	bpf_map_write_active_inc(VAR_5);
	if (!(map_get_sys_perms(VAR_5, VAR_9) & VAR_13)) {
		VAR_10 = -VAR_14;
		goto err_put;
	}

	if ((VAR_0->flags & VAR_15) &&
	    !map_value_has_spin_lock(VAR_5)) {
		VAR_10 = -VAR_12;
		goto err_put;
	}

	VAR_6 = ___bpf_copy_key(VAR_2, VAR_5->key_size);
	if (IS_ERR(VAR_6)) {
		VAR_10 = PTR_ERR(VAR_6);
		goto err_put;
	}

	VAR_8 = bpf_map_value_size(VAR_5);

	VAR_10 = -VAR_16;
	VAR_7 = kvmalloc(VAR_8, VAR_17 | VAR_18);
	if (!VAR_7)
		goto free_key;

	VAR_10 = -VAR_19;
	if (copy_from_bpfptr(VAR_7, VAR_3, VAR_8) != 0)
		goto free_value;

	VAR_10 = bpf_map_update_value(VAR_5, VAR_9, VAR_6, VAR_7, VAR_0->flags);

free_value:
	kvfree(VAR_7);
free_key:
	kvfree(VAR_6);
err_put:
	bpf_map_write_active_dec(VAR_5);
	fdput(VAR_9);
	return VAR_10;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -16,6 +16,7 @@
 	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return PTR_ERR(map);
+	bpf_map_write_active_inc(map);
 	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
 		err = -EPERM;
 		goto err_put;
@@ -51,6 +52,7 @@
 free_key:
 	kvfree(key);
 err_put:
+	bpf_map_write_active_dec(map);
 	fdput(f);
 	return err;
 }","{'deleted_lines': [], 'added_lines': ['\tbpf_map_write_active_inc(map);', '\tbpf_map_write_active_dec(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,bpf_map_do_batch,"static int bpf_map_do_batch(const union bpf_attr *attr,
union bpf_attr __user *uattr,
int cmd)
{
struct bpf_map *map;
int err, ufd;
struct fd f;
if (CHECK_ATTR(BPF_MAP_BATCH))
return -EINVAL;
ufd = attr->batch.map_fd;
f = fdget(ufd);
map = __bpf_map_get(f);
if (IS_ERR(map))
return PTR_ERR(map);
if ((cmd == BPF_MAP_LOOKUP_BATCH ||
cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) &&
!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {
err = -EPERM;
goto err_put;
}
if (cmd != BPF_MAP_LOOKUP_BATCH &&
!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
err = -EPERM;
goto err_put;
}
if (cmd == BPF_MAP_LOOKUP_BATCH)
BPF_DO_BATCH(map->ops->map_lookup_batch);
else if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)
BPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);
else if (cmd == BPF_MAP_UPDATE_BATCH)
BPF_DO_BATCH(map->ops->map_update_batch);
else
BPF_DO_BATCH(map->ops->map_delete_batch);
err_put:
fdput(f);
return err;
}","static int bpf_map_do_batch(const union bpf_attr *VAR_0,
union bpf_attr __user *VAR_1,
int VAR_2)
{
struct bpf_map *VAR_3;
int VAR_4, VAR_5;
struct fd VAR_6;
if (CHECK_ATTR(VAR_7))
return -VAR_8;
VAR_5 = VAR_0->batch.map_fd;
VAR_6 = fdget(VAR_5);
VAR_3 = __bpf_map_get(VAR_6);
if (IS_ERR(VAR_3))
return PTR_ERR(VAR_3);
if ((VAR_2 == VAR_9 ||
VAR_2 == VAR_10) &&
!(map_get_sys_perms(VAR_3, VAR_6) & VAR_11)) {
VAR_4 = -VAR_12;
goto err_put;
}
if (VAR_2 != VAR_9 &&
!(map_get_sys_perms(VAR_3, VAR_6) & VAR_13)) {
VAR_4 = -VAR_12;
goto err_put;
}
if (VAR_2 == VAR_9)
BPF_DO_BATCH(VAR_3->ops->map_lookup_batch);
else if (VAR_2 == VAR_10)
BPF_DO_BATCH(VAR_3->ops->map_lookup_and_delete_batch);
else if (VAR_2 == VAR_14)
BPF_DO_BATCH(VAR_3->ops->map_update_batch);
else
BPF_DO_BATCH(VAR_3->ops->map_delete_batch);
err_put:
fdput(VAR_6);
return VAR_4;
}",,"static int bpf_map_do_batch(const union bpf_attr *attr,
			    union bpf_attr __user *uattr,
			    int cmd)
{
	bool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||
			 cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;
	bool has_write = cmd != BPF_MAP_LOOKUP_BATCH;
	struct bpf_map *map;
	int err, ufd;
	struct fd f;

	if (CHECK_ATTR(BPF_MAP_BATCH))
		return -EINVAL;

	ufd = attr->batch.map_fd;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (has_write)
		bpf_map_write_active_inc(map);
	if (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {
		err = -EPERM;
		goto err_put;
	}
	if (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	if (cmd == BPF_MAP_LOOKUP_BATCH)
		BPF_DO_BATCH(map->ops->map_lookup_batch);
	else if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)
		BPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);
	else if (cmd == BPF_MAP_UPDATE_BATCH)
		BPF_DO_BATCH(map->ops->map_update_batch);
	else
		BPF_DO_BATCH(map->ops->map_delete_batch);
err_put:
	if (has_write)
		bpf_map_write_active_dec(map);
	fdput(f);
	return err;
}","static int bpf_map_do_batch(const union bpf_attr *VAR_0,
			    union bpf_attr __user *VAR_1,
			    int VAR_2)
{
	bool VAR_3  = VAR_2 == VAR_4 ||
			 VAR_2 == VAR_5;
	bool VAR_6 = VAR_2 != VAR_4;
	struct bpf_map *VAR_7;
	int VAR_8, VAR_9;
	struct fd VAR_10;

	if (CHECK_ATTR(VAR_11))
		return -VAR_12;

	VAR_9 = VAR_0->batch.map_fd;
	VAR_10 = fdget(VAR_9);
	VAR_7 = __bpf_map_get(VAR_10);
	if (IS_ERR(VAR_7))
		return PTR_ERR(VAR_7);
	if (VAR_6)
		bpf_map_write_active_inc(VAR_7);
	if (VAR_3 && !(map_get_sys_perms(VAR_7, VAR_10) & VAR_13)) {
		VAR_8 = -VAR_14;
		goto err_put;
	}
	if (VAR_6 && !(map_get_sys_perms(VAR_7, VAR_10) & VAR_15)) {
		VAR_8 = -VAR_14;
		goto err_put;
	}

	if (VAR_2 == VAR_4)
		BPF_DO_BATCH(VAR_7->ops->map_lookup_batch);
	else if (VAR_2 == VAR_5)
		BPF_DO_BATCH(VAR_7->ops->map_lookup_and_delete_batch);
	else if (VAR_2 == VAR_16)
		BPF_DO_BATCH(VAR_7->ops->map_update_batch);
	else
		BPF_DO_BATCH(VAR_7->ops->map_delete_batch);
err_put:
	if (VAR_6)
		bpf_map_write_active_dec(VAR_7);
	fdput(VAR_10);
	return VAR_8;
}",,"--- func_before
+++ func_after
@@ -2,6 +2,9 @@
 			    union bpf_attr __user *uattr,
 			    int cmd)
 {
+	bool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||
+			 cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;
+	bool has_write = cmd != BPF_MAP_LOOKUP_BATCH;
 	struct bpf_map *map;
 	int err, ufd;
 	struct fd f;
@@ -14,16 +17,13 @@
 	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return PTR_ERR(map);
-
-	if ((cmd == BPF_MAP_LOOKUP_BATCH ||
-	     cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) &&
-	    !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {
+	if (has_write)
+		bpf_map_write_active_inc(map);
+	if (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {
 		err = -EPERM;
 		goto err_put;
 	}
-
-	if (cmd != BPF_MAP_LOOKUP_BATCH &&
-	    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
+	if (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
 		err = -EPERM;
 		goto err_put;
 	}
@@ -36,8 +36,9 @@
 		BPF_DO_BATCH(map->ops->map_update_batch);
 	else
 		BPF_DO_BATCH(map->ops->map_delete_batch);
-
 err_put:
+	if (has_write)
+		bpf_map_write_active_dec(map);
 	fdput(f);
 	return err;
 }","{'deleted_lines': ['', '\tif ((cmd == BPF_MAP_LOOKUP_BATCH ||', '\t     cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) &&', '\t    !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {', '', '\tif (cmd != BPF_MAP_LOOKUP_BATCH &&', '\t    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {', ''], 'added_lines': ['\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||', '\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;', '\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;', '\tif (has_write)', '\t\tbpf_map_write_active_inc(map);', '\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {', '\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {', '\tif (has_write)', '\t\tbpf_map_write_active_dec(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,map_lookup_and_delete_elem,"static int map_lookup_and_delete_elem(union bpf_attr *attr)
{
void __user *ukey = u64_to_user_ptr(attr->key);
void __user *uvalue = u64_to_user_ptr(attr->value);
int ufd = attr->map_fd;
struct bpf_map *map;
void *key, *value;
u32 value_size;
struct fd f;
int err;
if (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))
return -EINVAL;
if (attr->flags & ~BPF_F_LOCK)
return -EINVAL;
f = fdget(ufd);
map = __bpf_map_get(f);
if (IS_ERR(map))
return PTR_ERR(map);
if (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||
!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
err = -EPERM;
goto err_put;
}
if (attr->flags &&
(map->map_type == BPF_MAP_TYPE_QUEUE ||
map->map_type == BPF_MAP_TYPE_STACK)) {
err = -EINVAL;
goto err_put;
}
if ((attr->flags & BPF_F_LOCK) &&
!map_value_has_spin_lock(map)) {
err = -EINVAL;
goto err_put;
}
key = __bpf_copy_key(ukey, map->key_size);
if (IS_ERR(key)) {
err = PTR_ERR(key);
goto err_put;
}
value_size = bpf_map_value_size(map);
err = -ENOMEM;
value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
if (!value)
goto free_key;
err = -ENOTSUPP;
if (map->map_type == BPF_MAP_TYPE_QUEUE ||
map->map_type == BPF_MAP_TYPE_STACK) {
err = map->ops->map_pop_elem(map, value);
} else if (map->map_type == BPF_MAP_TYPE_HASH ||
map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
map->map_type == BPF_MAP_TYPE_LRU_HASH ||
map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
if (!bpf_map_is_dev_bound(map)) {
bpf_disable_instrumentation();
rcu_read_lock();
err = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);
rcu_read_unlock();
bpf_enable_instrumentation();
}
}
if (err)
goto free_value;
if (copy_to_user(uvalue, value, value_size) != 0) {
err = -EFAULT;
goto free_value;
}
err = 0;
free_value:
kvfree(value);
free_key:
kvfree(key);
err_put:
fdput(f);
return err;
}","static int map_lookup_and_delete_elem(union bpf_attr *VAR_0)
{
void __user *VAR_1 = u64_to_user_ptr(VAR_0->key);
void __user *VAR_2 = u64_to_user_ptr(VAR_0->value);
int VAR_3 = VAR_0->map_fd;
struct bpf_map *VAR_4;
void *VAR_5, *VAR_6;
u32 VAR_7;
struct fd VAR_8;
int VAR_9;
if (CHECK_ATTR(VAR_10))
return -VAR_11;
if (VAR_0->flags & ~VAR_12)
return -VAR_11;
VAR_8 = fdget(VAR_3);
VAR_4 = __bpf_map_get(VAR_8);
if (IS_ERR(VAR_4))
return PTR_ERR(VAR_4);
if (!(map_get_sys_perms(VAR_4, VAR_8) & VAR_13) ||
!(map_get_sys_perms(VAR_4, VAR_8) & VAR_14)) {
VAR_9 = -VAR_15;
goto err_put;
}
if (VAR_0->flags &&
(VAR_4->map_type == VAR_16 ||
VAR_4->map_type == VAR_17)) {
VAR_9 = -VAR_11;
goto err_put;
}
if ((VAR_0->flags & VAR_12) &&
!map_value_has_spin_lock(VAR_4)) {
VAR_9 = -VAR_11;
goto err_put;
}
VAR_5 = __bpf_copy_key(VAR_1, VAR_4->key_size);
if (IS_ERR(VAR_5)) {
VAR_9 = PTR_ERR(VAR_5);
goto err_put;
}
VAR_7 = bpf_map_value_size(VAR_4);
VAR_9 = -VAR_18;
VAR_6 = kvmalloc(VAR_7, VAR_19 | VAR_20);
if (!VAR_6)
goto free_key;
VAR_9 = -VAR_21;
if (VAR_4->map_type == VAR_16 ||
VAR_4->map_type == VAR_17) {
VAR_9 = VAR_4->ops->map_pop_elem(VAR_4, VAR_6);
} else if (VAR_4->map_type == VAR_22 ||
VAR_4->map_type == VAR_23 ||
VAR_4->map_type == VAR_24 ||
VAR_4->map_type == VAR_25) {
if (!bpf_map_is_dev_bound(VAR_4)) {
bpf_disable_instrumentation();
rcu_read_lock();
VAR_9 = VAR_4->ops->map_lookup_and_delete_elem(VAR_4, VAR_5, VAR_6, VAR_0->flags);
rcu_read_unlock();
bpf_enable_instrumentation();
}
}
if (VAR_9)
goto free_value;
if (copy_to_user(VAR_2, VAR_6, VAR_7) != 0) {
VAR_9 = -VAR_26;
goto free_value;
}
VAR_9 = 0;
free_value:
kvfree(VAR_6);
free_key:
kvfree(VAR_5);
err_put:
fdput(VAR_8);
return VAR_9;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/6.json,"static int map_lookup_and_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	void __user *uvalue = u64_to_user_ptr(attr->value);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	void *key, *value;
	u32 value_size;
	struct fd f;
	int err;

	if (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))
		return -EINVAL;

	if (attr->flags & ~BPF_F_LOCK)
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	bpf_map_write_active_inc(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||
	    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	if (attr->flags &&
	    (map->map_type == BPF_MAP_TYPE_QUEUE ||
	     map->map_type == BPF_MAP_TYPE_STACK)) {
		err = -EINVAL;
		goto err_put;
	}

	if ((attr->flags & BPF_F_LOCK) &&
	    !map_value_has_spin_lock(map)) {
		err = -EINVAL;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	value_size = bpf_map_value_size(map);

	err = -ENOMEM;
	value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
	if (!value)
		goto free_key;

	err = -ENOTSUPP;
	if (map->map_type == BPF_MAP_TYPE_QUEUE ||
	    map->map_type == BPF_MAP_TYPE_STACK) {
		err = map->ops->map_pop_elem(map, value);
	} else if (map->map_type == BPF_MAP_TYPE_HASH ||
		   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
		   map->map_type == BPF_MAP_TYPE_LRU_HASH ||
		   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
		if (!bpf_map_is_dev_bound(map)) {
			bpf_disable_instrumentation();
			rcu_read_lock();
			err = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);
			rcu_read_unlock();
			bpf_enable_instrumentation();
		}
	}

	if (err)
		goto free_value;

	if (copy_to_user(uvalue, value, value_size) != 0) {
		err = -EFAULT;
		goto free_value;
	}

	err = 0;

free_value:
	kvfree(value);
free_key:
	kvfree(key);
err_put:
	bpf_map_write_active_dec(map);
	fdput(f);
	return err;
}","static int map_lookup_and_delete_elem(union bpf_attr *VAR_0)
{
	void __user *VAR_1 = u64_to_user_ptr(VAR_0->key);
	void __user *VAR_2 = u64_to_user_ptr(VAR_0->value);
	int VAR_3 = VAR_0->map_fd;
	struct bpf_map *VAR_4;
	void *VAR_5, *VAR_6;
	u32 VAR_7;
	struct fd VAR_8;
	int VAR_9;

	if (CHECK_ATTR(VAR_10))
		return -VAR_11;

	if (VAR_0->flags & ~VAR_12)
		return -VAR_11;

	VAR_8 = fdget(VAR_3);
	VAR_4 = __bpf_map_get(VAR_8);
	if (IS_ERR(VAR_4))
		return PTR_ERR(VAR_4);
	bpf_map_write_active_inc(VAR_4);
	if (!(map_get_sys_perms(VAR_4, VAR_8) & VAR_13) ||
	    !(map_get_sys_perms(VAR_4, VAR_8) & VAR_14)) {
		VAR_9 = -VAR_15;
		goto err_put;
	}

	if (VAR_0->flags &&
	    (VAR_4->map_type == VAR_16 ||
	     VAR_4->map_type == VAR_17)) {
		VAR_9 = -VAR_11;
		goto err_put;
	}

	if ((VAR_0->flags & VAR_12) &&
	    !map_value_has_spin_lock(VAR_4)) {
		VAR_9 = -VAR_11;
		goto err_put;
	}

	VAR_5 = __bpf_copy_key(VAR_1, VAR_4->key_size);
	if (IS_ERR(VAR_5)) {
		VAR_9 = PTR_ERR(VAR_5);
		goto err_put;
	}

	VAR_7 = bpf_map_value_size(VAR_4);

	VAR_9 = -VAR_18;
	VAR_6 = kvmalloc(VAR_7, VAR_19 | VAR_20);
	if (!VAR_6)
		goto free_key;

	VAR_9 = -VAR_21;
	if (VAR_4->map_type == VAR_16 ||
	    VAR_4->map_type == VAR_17) {
		VAR_9 = VAR_4->ops->map_pop_elem(VAR_4, VAR_6);
	} else if (VAR_4->map_type == VAR_22 ||
		   VAR_4->map_type == VAR_23 ||
		   VAR_4->map_type == VAR_24 ||
		   VAR_4->map_type == VAR_25) {
		if (!bpf_map_is_dev_bound(VAR_4)) {
			bpf_disable_instrumentation();
			rcu_read_lock();
			VAR_9 = VAR_4->ops->map_lookup_and_delete_elem(VAR_4, VAR_5, VAR_6, VAR_0->flags);
			rcu_read_unlock();
			bpf_enable_instrumentation();
		}
	}

	if (VAR_9)
		goto free_value;

	if (copy_to_user(VAR_2, VAR_6, VAR_7) != 0) {
		VAR_9 = -VAR_26;
		goto free_value;
	}

	VAR_9 = 0;

free_value:
	kvfree(VAR_6);
free_key:
	kvfree(VAR_5);
err_put:
	bpf_map_write_active_dec(VAR_4);
	fdput(VAR_8);
	return VAR_9;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -19,6 +19,7 @@
 	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return PTR_ERR(map);
+	bpf_map_write_active_inc(map);
 	if (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||
 	    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
 		err = -EPERM;
@@ -83,6 +84,7 @@
 free_key:
 	kvfree(key);
 err_put:
+	bpf_map_write_active_dec(map);
 	fdput(f);
 	return err;
 }","{'deleted_lines': [], 'added_lines': ['\tbpf_map_write_active_inc(map);', '\tbpf_map_write_active_dec(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/syscall.c,map_freeze,"static int map_freeze(const union bpf_attr *attr)
{
int err = 0, ufd = attr->map_fd;
struct bpf_map *map;
struct fd f;
if (CHECK_ATTR(BPF_MAP_FREEZE))
return -EINVAL;
f = fdget(ufd);
map = __bpf_map_get(f);
if (IS_ERR(map))
return PTR_ERR(map);
if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||
map_value_has_timer(map)) {
fdput(f);
return -ENOTSUPP;
}
mutex_lock(&map->freeze_mutex);
if (map->writecnt) {
err = -EBUSY;
goto err_put;
}
if (READ_ONCE(map->frozen)) {
err = -EBUSY;
goto err_put;
}
if (!bpf_capable()) {
err = -EPERM;
goto err_put;
}
WRITE_ONCE(map->frozen, true);
err_put:
mutex_unlock(&map->freeze_mutex);
fdput(f);
return err;
}","static int map_freeze(const union bpf_attr *VAR_0)
{
int VAR_1 = 0, VAR_2 = VAR_0->map_fd;
struct bpf_map *VAR_3;
struct fd VAR_4;
if (CHECK_ATTR(VAR_5))
return -VAR_6;
VAR_4 = fdget(VAR_2);
VAR_3 = __bpf_map_get(VAR_4);
if (IS_ERR(VAR_3))
return PTR_ERR(VAR_3);
if (VAR_3->map_type == VAR_7 ||
map_value_has_timer(VAR_3)) {
fdput(VAR_4);
return -VAR_8;
}
mutex_lock(&VAR_3->freeze_mutex);
if (VAR_3->writecnt) {
VAR_1 = -VAR_9;
goto err_put;
}
if (READ_ONCE(VAR_3->frozen)) {
VAR_1 = -VAR_9;
goto err_put;
}
if (!bpf_capable()) {
VAR_1 = -VAR_10;
goto err_put;
}
WRITE_ONCE(VAR_3->frozen, true);
err_put:
mutex_unlock(&VAR_3->freeze_mutex);
fdput(VAR_4);
return VAR_1;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/7.json,"static int map_freeze(const union bpf_attr *attr)
{
	int err = 0, ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;

	if (CHECK_ATTR(BPF_MAP_FREEZE))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);

	if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||
	    map_value_has_timer(map)) {
		fdput(f);
		return -ENOTSUPP;
	}

	mutex_lock(&map->freeze_mutex);
	if (bpf_map_write_active(map)) {
		err = -EBUSY;
		goto err_put;
	}
	if (READ_ONCE(map->frozen)) {
		err = -EBUSY;
		goto err_put;
	}
	if (!bpf_capable()) {
		err = -EPERM;
		goto err_put;
	}

	WRITE_ONCE(map->frozen, true);
err_put:
	mutex_unlock(&map->freeze_mutex);
	fdput(f);
	return err;
}","static int map_freeze(const union bpf_attr *VAR_0)
{
	int VAR_1 = 0, VAR_2 = VAR_0->map_fd;
	struct bpf_map *VAR_3;
	struct fd VAR_4;

	if (CHECK_ATTR(VAR_5))
		return -VAR_6;

	VAR_4 = fdget(VAR_2);
	VAR_3 = __bpf_map_get(VAR_4);
	if (IS_ERR(VAR_3))
		return PTR_ERR(VAR_3);

	if (VAR_3->map_type == VAR_7 ||
	    map_value_has_timer(VAR_3)) {
		fdput(VAR_4);
		return -VAR_8;
	}

	mutex_lock(&VAR_3->freeze_mutex);
	if (bpf_map_write_active(VAR_3)) {
		VAR_1 = -VAR_9;
		goto err_put;
	}
	if (READ_ONCE(VAR_3->frozen)) {
		VAR_1 = -VAR_9;
		goto err_put;
	}
	if (!bpf_capable()) {
		VAR_1 = -VAR_10;
		goto err_put;
	}

	WRITE_ONCE(VAR_3->frozen, true);
err_put:
	mutex_unlock(&VAR_3->freeze_mutex);
	fdput(VAR_4);
	return VAR_1;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -19,8 +19,7 @@
 	}
 
 	mutex_lock(&map->freeze_mutex);
-
-	if (map->writecnt) {
+	if (bpf_map_write_active(map)) {
 		err = -EBUSY;
 		goto err_put;
 	}","{'deleted_lines': ['', '\tif (map->writecnt) {'], 'added_lines': ['\tif (bpf_map_write_active(map)) {']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-4001,['CWE-367'],AV:L/AC:M/Au:N/C:N/I:C/A:N,0,kernel/git/bpf/bpf,"Commit a23740ec43ba (""bpf: Track contents of read-only maps as scalars"") is
checking whether maps are read-only both from BPF program side and user space
side, and then, given their content is constant, reading out their data via
map->ops->map_direct_value_addr() which is then subsequently used as known
scalar value for the register, that is, it is marked as __mark_reg_known()
with the read value at verification time. Before a23740ec43ba, the register
content was marked as an unknown scalar so the verifier could not make any
assumptions about the map content.

The current implementation however is prone to a TOCTOU race, meaning, the
value read as known scalar for the register is not guaranteed to be exactly
the same at a later point when the program is executed, and as such, the
prior made assumptions of the verifier with regards to the program will be
invalid which can cause issues such as OOB access, etc.

While the BPF_F_RDONLY_PROG map flag is always fixed and required to be
specified at map creation time, the map->frozen property is initially set to
false for the map given the map value needs to be populated, e.g. for global
data sections. Once complete, the loader ""freezes"" the map from user space
such that no subsequent updates/deletes are possible anymore. For the rest
of the lifetime of the map, this freeze one-time trigger cannot be undone
anymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*
cmd calls which would update/delete map entries will be rejected with -EPERM
since map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also
means that pending update/delete map entries must still complete before this
guarantee is given. This corner case is not an issue for loaders since they
create and prepare such program private map in successive steps.

However, a malicious user is able to trigger this TOCTOU race in two different
ways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is
used to expand the competition interval, so that map_update_elem() can modify
the contents of the map after map_freeze() and bpf_prog_load() were executed.
This works, because userfaultfd halts the parallel thread which triggered a
map_update_elem() at the time where we copy key/value from the user buffer and
this already passed the FMODE_CAN_WRITE capability test given at that time the
map was not ""frozen"". Then, the main thread performs the map_freeze() and
bpf_prog_load(), and once that had completed successfully, the other thread
is woken up to complete the pending map_update_elem() which then changes the
map content. For ii) the idea of the batched update is similar, meaning, when
there are a large number of updates to be processed, it can increase the
competition interval between the two. It is therefore possible in practice to
modify the contents of the map after executing map_freeze() and bpf_prog_load().

One way to fix both i) and ii) at the same time is to expand the use of the
map's map->writecnt. The latter was introduced in fc9702273e2e (""bpf: Add mmap()
support for BPF_MAP_TYPE_ARRAY"") and further refined in 1f6cb19be2e2 (""bpf:
Prevent re-mmap()'ing BPF map as writable for initially r/o mapping"") with
the rationale to make a writable mmap()'ing of a map mutually exclusive with
read-only freezing. The counter indicates writable mmap() mappings and then
prevents/fails the freeze operation. Its semantics can be expanded beyond
just mmap() by generally indicating ongoing write phases. This would essentially
span any parallel regular and batched flavor of update/delete operation and
then also have map_freeze() fail with -EBUSY. For the check_mem_access() in
the verifier we expand upon the bpf_map_is_rdonly() check ensuring that all
last pending writes have completed via bpf_map_write_active() test. Once the
map->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0
only then we are really guaranteed to use the map's data as known constants.
For map->frozen being set and pending writes in process of still being completed
we fall back to marking that register as unknown scalar so we don't end up
making assumptions about it. With this, both TOCTOU reproducers from i) and
ii) are fixed.

Note that the map->writecnt has been converted into a atomic64 in the fix in
order to avoid a double freeze_mutex mutex_{un,}lock() pair when updating
map->writecnt in the various map update/delete BPF_* cmd flavors. Spanning
the freeze_mutex over entire map update/delete operations in syscall side
would not be possible due to then causing everything to be serialized.
Similarly, something like synchronize_rcu() after setting map->frozen to wait
for update/deletes to complete is not possible either since it would also
have to span the user copy which can sleep. On the libbpf side, this won't
break d66562fba1ce (""libbpf: Add BPF object skeleton support"") as the
anonymous mmap()-ed ""map initialization image"" is remapped as a BPF map-backed
mmap()-ed memory where for .rodata it's non-writable.

Fixes: a23740ec43ba (""bpf: Track contents of read-only maps as scalars"")
Reported-by: w1tcher.bupt@gmail.com
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",353050be4c19e102178ccc05988101887c25ae53,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53,kernel/bpf/verifier.c,bpf_map_is_rdonly,"static bool bpf_map_is_rdonly(const struct bpf_map *map)
{
return (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;
}","static bool bpf_map_is_rdonly(const struct bpf_map *VAR_0)
{
return (VAR_0->map_flags & VAR_1) && VAR_0->frozen;
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/verifier.c/vul/before/0.json,"static bool bpf_map_is_rdonly(const struct bpf_map *map)
{
	/* A map is considered read-only if the following condition are true:
	 *
	 * 1) BPF program side cannot change any of the map content. The
	 *    BPF_F_RDONLY_PROG flag is throughout the lifetime of a map
	 *    and was set at map creation time.
	 * 2) The map value(s) have been initialized from user space by a
	 *    loader and then ""frozen"", such that no new map update/delete
	 *    operations from syscall side are possible for the rest of
	 *    the map's lifetime from that point onwards.
	 * 3) Any parallel/pending map update/delete operations from syscall
	 *    side have been completed. Only after that point, it's safe to
	 *    assume that map value(s) are immutable.
	 */
	return (map->map_flags & BPF_F_RDONLY_PROG) &&
	       READ_ONCE(map->frozen) &&
	       !bpf_map_write_active(map);
}","static bool bpf_map_is_rdonly(const struct bpf_map *VAR_0)
{
	/* COMMENT_0 */
   
                                                                 
                                                                 
                                        
                                                                  
                                                                   
                                                                
                                                  
                                                                     
                                                                    
                                              
    
	return (VAR_0->map_flags & VAR_1) &&
	       READ_ONCE(VAR_0->frozen) &&
	       !bpf_map_write_active(VAR_0);
}",kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/verifier.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,19 @@
 static bool bpf_map_is_rdonly(const struct bpf_map *map)
 {
-	return (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;
+	/* A map is considered read-only if the following condition are true:
+	 *
+	 * 1) BPF program side cannot change any of the map content. The
+	 *    BPF_F_RDONLY_PROG flag is throughout the lifetime of a map
+	 *    and was set at map creation time.
+	 * 2) The map value(s) have been initialized from user space by a
+	 *    loader and then ""frozen"", such that no new map update/delete
+	 *    operations from syscall side are possible for the rest of
+	 *    the map's lifetime from that point onwards.
+	 * 3) Any parallel/pending map update/delete operations from syscall
+	 *    side have been completed. Only after that point, it's safe to
+	 *    assume that map value(s) are immutable.
+	 */
+	return (map->map_flags & BPF_F_RDONLY_PROG) &&
+	       READ_ONCE(map->frozen) &&
+	       !bpf_map_write_active(map);
 }","{'deleted_lines': ['\treturn (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;'], 'added_lines': ['\t/* A map is considered read-only if the following condition are true:', '\t *', '\t * 1) BPF program side cannot change any of the map content. The', '\t *    BPF_F_RDONLY_PROG flag is throughout the lifetime of a map', '\t *    and was set at map creation time.', '\t * 2) The map value(s) have been initialized from user space by a', '\t *    loader and then ""frozen"", such that no new map update/delete', '\t *    operations from syscall side are possible for the rest of', ""\t *    the map's lifetime from that point onwards."", '\t * 3) Any parallel/pending map update/delete operations from syscall', ""\t *    side have been completed. Only after that point, it's safe to"", '\t *    assume that map value(s) are immutable.', '\t */', '\treturn (map->map_flags & BPF_F_RDONLY_PROG) &&', '\t       READ_ONCE(map->frozen) &&', '\t       !bpf_map_write_active(map);']}",True,"A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.",4.1,MEDIUM,1,valid,,5
CVE-2021-22600,['CWE-415'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Packet sockets may switch ring versions. Avoid misinterpreting state
between versions, whose fields share a union. rx_owner_map is only
allocated with a packet ring (pg_vec) and both are swapped together.
If pg_vec is NULL, meaning no packet ring was allocated, then neither
was rx_owner_map. And the field may be old state from a tpacket_v3.

Fixes: 61fad6816fc1 (""net/packet: tpacket_rcv: avoid a producer race condition"")
Reported-by: Syzbot <syzbot+1ac0994a0a0c55151121@syzkaller.appspotmail.com>
Signed-off-by: Willem de Bruijn <willemb@google.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20211215143937.106178-1-willemdebruijn.kernel@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",ec6af094ea28f0f2dda1a6a33b14cd57e36a9755,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=ec6af094ea28f0f2dda1a6a33b14cd57e36a9755,net/packet/af_packet.c,packet_set_ring,"static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
int closing, int tx_ring)
{
struct pgv *pg_vec = NULL;
struct packet_sock *po = pkt_sk(sk);
unsigned long *rx_owner_map = NULL;
int was_running, order = 0;
struct packet_ring_buffer *rb;
struct sk_buff_head *rb_queue;
__be16 num;
int err;
struct tpacket_req *req = &req_u->req;
rb = tx_ring ? &po->tx_ring : &po->rx_ring;
rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;
err = -EBUSY;
if (!closing) {
if (atomic_read(&po->mapped))
goto out;
if (packet_read_pending(rb))
goto out;
}
if (req->tp_block_nr) {
unsigned int min_frame_size;
err = -EBUSY;
if (unlikely(rb->pg_vec))
goto out;
switch (po->tp_version) {
case TPACKET_V1:
po->tp_hdrlen = TPACKET_HDRLEN;
break;
case TPACKET_V2:
po->tp_hdrlen = TPACKET2_HDRLEN;
break;
case TPACKET_V3:
po->tp_hdrlen = TPACKET3_HDRLEN;
break;
}
err = -EINVAL;
if (unlikely((int)req->tp_block_size <= 0))
goto out;
if (unlikely(!PAGE_ALIGNED(req->tp_block_size)))
goto out;
min_frame_size = po->tp_hdrlen + po->tp_reserve;
if (po->tp_version >= TPACKET_V3 &&
req->tp_block_size <
BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size)
goto out;
if (unlikely(req->tp_frame_size < min_frame_size))
goto out;
if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
goto out;
rb->frames_per_block = req->tp_block_size / req->tp_frame_size;
if (unlikely(rb->frames_per_block == 0))
goto out;
if (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr))
goto out;
if (unlikely((rb->frames_per_block * req->tp_block_nr) !=
req->tp_frame_nr))
goto out;
err = -ENOMEM;
order = get_order(req->tp_block_size);
pg_vec = alloc_pg_vec(req, order);
if (unlikely(!pg_vec))
goto out;
switch (po->tp_version) {
case TPACKET_V3:
if (!tx_ring) {
init_prb_bdqc(po, rb, pg_vec, req_u);
} else {
struct tpacket_req3 *req3 = &req_u->req3;
if (req3->tp_retire_blk_tov ||
req3->tp_sizeof_priv ||
req3->tp_feature_req_word) {
err = -EINVAL;
goto out_free_pg_vec;
}
}
break;
default:
if (!tx_ring) {
rx_owner_map = bitmap_alloc(req->tp_frame_nr,
GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);
if (!rx_owner_map)
goto out_free_pg_vec;
}
break;
}
}
else {
err = -EINVAL;
if (unlikely(req->tp_frame_nr))
goto out;
}
spin_lock(&po->bind_lock);
was_running = po->running;
num = po->num;
if (was_running) {
WRITE_ONCE(po->num, 0);
__unregister_prot_hook(sk, false);
}
spin_unlock(&po->bind_lock);
synchronize_net();
err = -EBUSY;
mutex_lock(&po->pg_vec_lock);
if (closing || atomic_read(&po->mapped) == 0) {
err = 0;
spin_lock_bh(&rb_queue->lock);
swap(rb->pg_vec, pg_vec);
if (po->tp_version <= TPACKET_V2)
swap(rb->rx_owner_map, rx_owner_map);
rb->frame_max = (req->tp_frame_nr - 1);
rb->head = 0;
rb->frame_size = req->tp_frame_size;
spin_unlock_bh(&rb_queue->lock);
swap(rb->pg_vec_order, order);
swap(rb->pg_vec_len, req->tp_block_nr);
rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;
po->prot_hook.func = (po->rx_ring.pg_vec) ?
tpacket_rcv : packet_rcv;
skb_queue_purge(rb_queue);
if (atomic_read(&po->mapped))
pr_err(""packet_mmap: vma is busy: %d\n"",
atomic_read(&po->mapped));
}
mutex_unlock(&po->pg_vec_lock);
spin_lock(&po->bind_lock);
if (was_running) {
WRITE_ONCE(po->num, num);
register_prot_hook(sk);
}
spin_unlock(&po->bind_lock);
if (pg_vec && (po->tp_version > TPACKET_V2)) {
if (!tx_ring)
prb_shutdown_retire_blk_timer(po, rb_queue);
}
out_free_pg_vec:
bitmap_free(rx_owner_map);
if (pg_vec)
free_pg_vec(pg_vec, order, req->tp_block_nr);
out:
return err;
}","static int packet_set_ring(struct sock *VAR_0, union tpacket_req_u *VAR_1,
int VAR_2, int VAR_3)
{
struct pgv *VAR_4 = NULL;
struct packet_sock *VAR_5 = pkt_sk(VAR_0);
unsigned long *VAR_6 = NULL;
int VAR_7, VAR_8 = 0;
struct packet_ring_buffer *VAR_9;
struct sk_buff_head *VAR_10;
__be16 numVAR_11;
int VAR_12;
struct tpacket_req *VAR_13 = &VAR_1->req;
VAR_9 = VAR_3 ? &VAR_5->tx_ring : &VAR_5->rx_ring;
VAR_10 = VAR_3 ? &VAR_0->sk_write_queue : &VAR_0->sk_receive_queue;
VAR_12 = -VAR_14;
if (!VAR_2) {
if (atomic_read(&VAR_5->mapped))
goto out;
if (packet_read_pending(VAR_9))
goto out;
}
if (VAR_13->tp_block_nr) {
unsigned int VAR_15;
VAR_12 = -VAR_14;
if (unlikely(VAR_9->pg_vec))
goto out;
switch (VAR_5->tp_version) {
case VAR_16:
VAR_5->tp_hdrlen = VAR_17;
break;
case VAR_18:
VAR_5->tp_hdrlen = VAR_19;
break;
case VAR_20:
VAR_5->tp_hdrlen = VAR_21;
break;
}
VAR_12 = -VAR_22;
if (unlikely((int)VAR_13->tp_block_size <= 0))
goto out;
if (unlikely(!PAGE_ALIGNED(VAR_13->tp_block_size)))
goto out;
VAR_15 = VAR_5->tp_hdrlen + VAR_5->tp_reserve;
if (VAR_5->tp_version >= VAR_20 &&
VAR_13->tp_block_size <
BLK_PLUS_PRIV((u64)VAR_1->req3.tp_sizeof_priv) + VAR_15)
goto out;
if (unlikely(VAR_13->tp_frame_size < VAR_15))
goto out;
if (unlikely(VAR_13->tp_frame_size & (VAR_23 - 1)))
goto out;
VAR_9->frames_per_block = VAR_13->tp_block_size / VAR_13->tp_frame_size;
if (unlikely(VAR_9->frames_per_block == 0))
goto out;
if (unlikely(VAR_9->frames_per_block > VAR_24 / VAR_13->tp_block_nr))
goto out;
if (unlikely((VAR_9->frames_per_block * VAR_13->tp_block_nr) !=
VAR_13->tp_frame_nr))
goto out;
VAR_12 = -VAR_25;
VAR_8 = get_order(VAR_13->tp_block_size);
VAR_4 = alloc_pg_vec(VAR_13, VAR_8);
if (unlikely(!VAR_4))
goto out;
switch (VAR_5->tp_version) {
case VAR_20:
if (!VAR_3) {
init_prb_bdqc(VAR_5, VAR_9, VAR_4, VAR_1);
} else {
struct tpacket_req3 *VAR_26 = &VAR_1->req3;
if (VAR_26->tp_retire_blk_tov ||
VAR_26->tp_sizeof_priv ||
VAR_26->tp_feature_req_word) {
VAR_12 = -VAR_22;
goto out_free_pg_vec;
}
}
break;
default:
if (!VAR_3) {
VAR_6 = bitmap_alloc(VAR_13->tp_frame_nr,
VAR_27 | VAR_28 | VAR_29);
if (!VAR_6)
goto out_free_pg_vec;
}
break;
}
}
else {
VAR_12 = -VAR_22;
if (unlikely(VAR_13->tp_frame_nr))
goto out;
}
spin_lock(&VAR_5->bind_lock);
VAR_7 = VAR_5->running;
num = VAR_5->num;
if (VAR_7) {
WRITE_ONCE(VAR_5->num, 0);
__unregister_prot_hook(VAR_0, false);
}
spin_unlock(&VAR_5->bind_lock);
synchronize_net();
VAR_12 = -VAR_14;
mutex_lock(&VAR_5->pg_vec_lock);
if (VAR_2 || atomic_read(&VAR_5->mapped) == 0) {
VAR_12 = 0;
spin_lock_bh(&VAR_10->lock);
swap(VAR_9->pg_vec, VAR_4);
if (VAR_5->tp_version <= VAR_18)
swap(VAR_9->rx_owner_map, VAR_6);
VAR_9->frame_max = (VAR_13->tp_frame_nr - 1);
VAR_9->head = 0;
VAR_9->frame_size = VAR_13->tp_frame_size;
spin_unlock_bh(&VAR_10->lock);
swap(VAR_9->pg_vec_order, VAR_8);
swap(VAR_9->pg_vec_len, VAR_13->tp_block_nr);
VAR_9->pg_vec_pages = VAR_13->tp_block_size/VAR_30;
VAR_5->prot_hook.func = (VAR_5->rx_ring.pg_vec) ?
VAR_31 : VAR_32;
skb_queue_purge(VAR_10);
if (atomic_read(&VAR_5->mapped))
pr_err(""packet_mmap: vma is busy: %d\n"",
atomic_read(&VAR_5->mapped));
}
mutex_unlock(&VAR_5->pg_vec_lock);
spin_lock(&VAR_5->bind_lock);
if (VAR_7) {
WRITE_ONCE(VAR_5->num, num);
register_prot_hook(VAR_0);
}
spin_unlock(&VAR_5->bind_lock);
if (VAR_4 && (VAR_5->tp_version > VAR_18)) {
if (!VAR_3)
prb_shutdown_retire_blk_timer(VAR_5, VAR_10);
}
out_free_pg_vec:
bitmap_free(VAR_6);
if (VAR_4)
free_pg_vec(VAR_4, VAR_8, VAR_13->tp_block_nr);
out:
return VAR_12;
}",torvalds/linux/ec6af094ea28f0f2dda1a6a33b14cd57e36a9755/af_packet.c/vul/before/0.json,"static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
		int closing, int tx_ring)
{
	struct pgv *pg_vec = NULL;
	struct packet_sock *po = pkt_sk(sk);
	unsigned long *rx_owner_map = NULL;
	int was_running, order = 0;
	struct packet_ring_buffer *rb;
	struct sk_buff_head *rb_queue;
	__be16 num;
	int err;
	/* Added to avoid minimal code churn */
	struct tpacket_req *req = &req_u->req;

	rb = tx_ring ? &po->tx_ring : &po->rx_ring;
	rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;

	err = -EBUSY;
	if (!closing) {
		if (atomic_read(&po->mapped))
			goto out;
		if (packet_read_pending(rb))
			goto out;
	}

	if (req->tp_block_nr) {
		unsigned int min_frame_size;

		/* Sanity tests and some calculations */
		err = -EBUSY;
		if (unlikely(rb->pg_vec))
			goto out;

		switch (po->tp_version) {
		case TPACKET_V1:
			po->tp_hdrlen = TPACKET_HDRLEN;
			break;
		case TPACKET_V2:
			po->tp_hdrlen = TPACKET2_HDRLEN;
			break;
		case TPACKET_V3:
			po->tp_hdrlen = TPACKET3_HDRLEN;
			break;
		}

		err = -EINVAL;
		if (unlikely((int)req->tp_block_size <= 0))
			goto out;
		if (unlikely(!PAGE_ALIGNED(req->tp_block_size)))
			goto out;
		min_frame_size = po->tp_hdrlen + po->tp_reserve;
		if (po->tp_version >= TPACKET_V3 &&
		    req->tp_block_size <
		    BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size)
			goto out;
		if (unlikely(req->tp_frame_size < min_frame_size))
			goto out;
		if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
			goto out;

		rb->frames_per_block = req->tp_block_size / req->tp_frame_size;
		if (unlikely(rb->frames_per_block == 0))
			goto out;
		if (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr))
			goto out;
		if (unlikely((rb->frames_per_block * req->tp_block_nr) !=
					req->tp_frame_nr))
			goto out;

		err = -ENOMEM;
		order = get_order(req->tp_block_size);
		pg_vec = alloc_pg_vec(req, order);
		if (unlikely(!pg_vec))
			goto out;
		switch (po->tp_version) {
		case TPACKET_V3:
			/* Block transmit is not supported yet */
			if (!tx_ring) {
				init_prb_bdqc(po, rb, pg_vec, req_u);
			} else {
				struct tpacket_req3 *req3 = &req_u->req3;

				if (req3->tp_retire_blk_tov ||
				    req3->tp_sizeof_priv ||
				    req3->tp_feature_req_word) {
					err = -EINVAL;
					goto out_free_pg_vec;
				}
			}
			break;
		default:
			if (!tx_ring) {
				rx_owner_map = bitmap_alloc(req->tp_frame_nr,
					GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);
				if (!rx_owner_map)
					goto out_free_pg_vec;
			}
			break;
		}
	}
	/* Done */
	else {
		err = -EINVAL;
		if (unlikely(req->tp_frame_nr))
			goto out;
	}


	/* Detach socket from network */
	spin_lock(&po->bind_lock);
	was_running = po->running;
	num = po->num;
	if (was_running) {
		WRITE_ONCE(po->num, 0);
		__unregister_prot_hook(sk, false);
	}
	spin_unlock(&po->bind_lock);

	synchronize_net();

	err = -EBUSY;
	mutex_lock(&po->pg_vec_lock);
	if (closing || atomic_read(&po->mapped) == 0) {
		err = 0;
		spin_lock_bh(&rb_queue->lock);
		swap(rb->pg_vec, pg_vec);
		if (po->tp_version <= TPACKET_V2)
			swap(rb->rx_owner_map, rx_owner_map);
		rb->frame_max = (req->tp_frame_nr - 1);
		rb->head = 0;
		rb->frame_size = req->tp_frame_size;
		spin_unlock_bh(&rb_queue->lock);

		swap(rb->pg_vec_order, order);
		swap(rb->pg_vec_len, req->tp_block_nr);

		rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;
		po->prot_hook.func = (po->rx_ring.pg_vec) ?
						tpacket_rcv : packet_rcv;
		skb_queue_purge(rb_queue);
		if (atomic_read(&po->mapped))
			pr_err(""packet_mmap: vma is busy: %d\n"",
			       atomic_read(&po->mapped));
	}
	mutex_unlock(&po->pg_vec_lock);

	spin_lock(&po->bind_lock);
	if (was_running) {
		WRITE_ONCE(po->num, num);
		register_prot_hook(sk);
	}
	spin_unlock(&po->bind_lock);
	if (pg_vec && (po->tp_version > TPACKET_V2)) {
		/* Because we don't support block-based V3 on tx-ring */
		if (!tx_ring)
			prb_shutdown_retire_blk_timer(po, rb_queue);
	}

out_free_pg_vec:
	if (pg_vec) {
		bitmap_free(rx_owner_map);
		free_pg_vec(pg_vec, order, req->tp_block_nr);
	}
out:
	return err;
}","static int packet_set_ring(struct sock *VAR_0, union tpacket_req_u *VAR_1,
		int VAR_2, int VAR_3)
{
	struct pgv *VAR_4 = NULL;
	struct packet_sock *VAR_5 = pkt_sk(VAR_0);
	unsigned long *VAR_6 = NULL;
	int VAR_7, VAR_8 = 0;
	struct packet_ring_buffer *VAR_9;
	struct sk_buff_head *VAR_10;
	__be16 numVAR_11;
	int VAR_12;
	/* COMMENT_0 */
	struct tpacket_req *VAR_13 = &VAR_1->req;

	VAR_9 = VAR_3 ? &VAR_5->tx_ring : &VAR_5->rx_ring;
	VAR_10 = VAR_3 ? &VAR_0->sk_write_queue : &VAR_0->sk_receive_queue;

	VAR_12 = -VAR_14;
	if (!VAR_2) {
		if (atomic_read(&VAR_5->mapped))
			goto out;
		if (packet_read_pending(VAR_9))
			goto out;
	}

	if (VAR_13->tp_block_nr) {
		unsigned int VAR_15;

		/* COMMENT_1 */
		VAR_12 = -VAR_14;
		if (unlikely(VAR_9->pg_vec))
			goto out;

		switch (VAR_5->tp_version) {
		case VAR_16:
			VAR_5->tp_hdrlen = VAR_17;
			break;
		case VAR_18:
			VAR_5->tp_hdrlen = VAR_19;
			break;
		case VAR_20:
			VAR_5->tp_hdrlen = VAR_21;
			break;
		}

		VAR_12 = -VAR_22;
		if (unlikely((int)VAR_13->tp_block_size <= 0))
			goto out;
		if (unlikely(!PAGE_ALIGNED(VAR_13->tp_block_size)))
			goto out;
		VAR_15 = VAR_5->tp_hdrlen + VAR_5->tp_reserve;
		if (VAR_5->tp_version >= VAR_20 &&
		    VAR_13->tp_block_size <
		    BLK_PLUS_PRIV((u64)VAR_1->req3.tp_sizeof_priv) + VAR_15)
			goto out;
		if (unlikely(VAR_13->tp_frame_size < VAR_15))
			goto out;
		if (unlikely(VAR_13->tp_frame_size & (VAR_23 - 1)))
			goto out;

		VAR_9->frames_per_block = VAR_13->tp_block_size / VAR_13->tp_frame_size;
		if (unlikely(VAR_9->frames_per_block == 0))
			goto out;
		if (unlikely(VAR_9->frames_per_block > VAR_24 / VAR_13->tp_block_nr))
			goto out;
		if (unlikely((VAR_9->frames_per_block * VAR_13->tp_block_nr) !=
					VAR_13->tp_frame_nr))
			goto out;

		VAR_12 = -VAR_25;
		VAR_8 = get_order(VAR_13->tp_block_size);
		VAR_4 = alloc_pg_vec(VAR_13, VAR_8);
		if (unlikely(!VAR_4))
			goto out;
		switch (VAR_5->tp_version) {
		case VAR_20:
			/* COMMENT_2 */
			if (!VAR_3) {
				init_prb_bdqc(VAR_5, VAR_9, VAR_4, VAR_1);
			} else {
				struct tpacket_req3 *VAR_26 = &VAR_1->req3;

				if (VAR_26->tp_retire_blk_tov ||
				    VAR_26->tp_sizeof_priv ||
				    VAR_26->tp_feature_req_word) {
					VAR_12 = -VAR_22;
					goto out_free_pg_vec;
				}
			}
			break;
		default:
			if (!VAR_3) {
				VAR_6 = bitmap_alloc(VAR_13->tp_frame_nr,
					VAR_27 | VAR_28 | VAR_29);
				if (!VAR_6)
					goto out_free_pg_vec;
			}
			break;
		}
	}
	/* COMMENT_3 */
	else {
		VAR_12 = -VAR_22;
		if (unlikely(VAR_13->tp_frame_nr))
			goto out;
	}


	/* COMMENT_4 */
	spin_lock(&VAR_5->bind_lock);
	VAR_7 = VAR_5->running;
	num = VAR_5->num;
	if (VAR_7) {
		WRITE_ONCE(VAR_5->num, 0);
		__unregister_prot_hook(VAR_0, false);
	}
	spin_unlock(&VAR_5->bind_lock);

	synchronize_net();

	VAR_12 = -VAR_14;
	mutex_lock(&VAR_5->pg_vec_lock);
	if (VAR_2 || atomic_read(&VAR_5->mapped) == 0) {
		VAR_12 = 0;
		spin_lock_bh(&VAR_10->lock);
		swap(VAR_9->pg_vec, VAR_4);
		if (VAR_5->tp_version <= VAR_18)
			swap(VAR_9->rx_owner_map, VAR_6);
		VAR_9->frame_max = (VAR_13->tp_frame_nr - 1);
		VAR_9->head = 0;
		VAR_9->frame_size = VAR_13->tp_frame_size;
		spin_unlock_bh(&VAR_10->lock);

		swap(VAR_9->pg_vec_order, VAR_8);
		swap(VAR_9->pg_vec_len, VAR_13->tp_block_nr);

		VAR_9->pg_vec_pages = VAR_13->tp_block_size/VAR_30;
		VAR_5->prot_hook.func = (VAR_5->rx_ring.pg_vec) ?
						VAR_31 : VAR_32;
		skb_queue_purge(VAR_10);
		if (atomic_read(&VAR_5->mapped))
			pr_err(""packet_mmap: vma is busy: %d\n"",
			       atomic_read(&VAR_5->mapped));
	}
	mutex_unlock(&VAR_5->pg_vec_lock);

	spin_lock(&VAR_5->bind_lock);
	if (VAR_7) {
		WRITE_ONCE(VAR_5->num, num);
		register_prot_hook(VAR_0);
	}
	spin_unlock(&VAR_5->bind_lock);
	if (VAR_4 && (VAR_5->tp_version > VAR_18)) {
		/* COMMENT_5 */
		if (!VAR_3)
			prb_shutdown_retire_blk_timer(VAR_5, VAR_10);
	}

out_free_pg_vec:
	if (VAR_4) {
		bitmap_free(VAR_6);
		free_pg_vec(VAR_4, VAR_8, VAR_13->tp_block_nr);
	}
out:
	return VAR_12;
}",torvalds/linux/ec6af094ea28f0f2dda1a6a33b14cd57e36a9755/af_packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -157,9 +157,10 @@
 	}
 
 out_free_pg_vec:
-	bitmap_free(rx_owner_map);
-	if (pg_vec)
+	if (pg_vec) {
+		bitmap_free(rx_owner_map);
 		free_pg_vec(pg_vec, order, req->tp_block_nr);
+	}
 out:
 	return err;
 }","{'deleted_lines': ['\tbitmap_free(rx_owner_map);', '\tif (pg_vec)'], 'added_lines': ['\tif (pg_vec) {', '\t\tbitmap_free(rx_owner_map);', '\t}']}",True,A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755,7.0,HIGH,2,valid,,5
CVE-2023-40084,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix Heap-use-after-free in MDnsSdListener::Monitor::run

Use thread join to avoid thread exiting after instance
recycled.

Prior to implementing this patch, fuzzing would lead to a segmentation fault after approximately 500 rounds. With the addition of the patch, the fuzzing process can now be repeated for over 30,000 rounds.

Test: m, fuzzing
Fuzzing: mma mdns_service_fuzzer && adb sync data && adb shell /data/fuzz/arm64/mdns_service_fuzzer/mdns_service_fuzzer

Bug: 272382770
Ignore-AOSP-First: Security Issue
(cherry picked from commit 9c0c15f80cffb98b36284dd169a2e62e059dbbe3)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:75e5e2e1faec7aa2812fc6fba30d6fe80558bacd)
Merged-In: I5bc85451b4e6539bad45ceb672924a37952cc138
Change-Id: I5bc85451b4e6539bad45ceb672924a37952cc138
",1b8bddd96b2efd4074b6d4eee377b62077c031bd,https://android.googlesource.com/platform/system/netd/+/1b8bddd96b2efd4074b6d4eee377b62077c031bd,server/MDnsSdListener.cpp,MDnsSdListener::Monitor::run,"void MDnsSdListener::Monitor::run() {
int pollCount = 1;
mPollFds = (struct pollfd *)calloc(sizeof(struct pollfd), mPollSize);
mPollRefs = (DNSServiceRef **)calloc(sizeof(DNSServiceRef *), mPollSize);
LOG_ALWAYS_FATAL_IF((mPollFds == nullptr), ""initial calloc failed on mPollFds with a size of %d"",
((int)sizeof(struct pollfd)) * mPollSize);
LOG_ALWAYS_FATAL_IF((mPollRefs == nullptr), ""initial calloc failed on mPollRefs with a size of %d"",
((int)sizeof(DNSServiceRef *)) * mPollSize);
mPollFds[0].fd = mCtrlSocketPair[0];
mPollFds[0].events = POLLIN;
if (VDBG) ALOGD(""MDnsSdListener starting to monitor"");
while (1) {
if (VDBG) ALOGD(""Going to poll with pollCount %d"", pollCount);
int pollResults = poll(mPollFds, pollCount, 10000000);
if (VDBG) ALOGD(""pollResults=%d"", pollResults);
if (pollResults < 0) {
ALOGE(""Error in poll - got %d"", errno);
} else if (pollResults > 0) {
if (VDBG) ALOGD(""Monitor poll got data pollCount = %d, %d"", pollCount, pollResults);
for(int i = 1; i < pollCount; i++) {
if (mPollFds[i].revents != 0) {
if (VDBG) {
ALOGD(""Monitor found [%d].revents = %d - calling ProcessResults"",
i, mPollFds[i].revents);
}
std::lock_guard guard(mMutex);
DNSServiceProcessResult(*(mPollRefs[i]));
mPollFds[i].revents = 0;
}
}
if (VDBG) ALOGD(""controlSocket shows revent= %d"", mPollFds[0].revents);
switch (mPollFds[0].revents) {
case POLLIN: {
char readBuf[2];
read(mCtrlSocketPair[0], &readBuf, 1);
if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);
if (memcmp(RESCAN, readBuf, 1) == 0) {
pollCount = rescan();
}
}
}
mPollFds[0].revents = 0;
} else {
if (VDBG) ALOGD(""MDnsSdListener::Monitor poll timed out"");
}
}
free(mPollFds);
free(mPollRefs);
}","void MDnsSdListener::Monitor::run() {
int VAR_0 = 1;
VAR_1 = (struct pollfd *)calloc(sizeof(struct pollfd), VAR_2);
VAR_3 = (DNSServiceRef **)calloc(sizeof(DNSServiceRef *), VAR_2);
LOG_ALWAYS_FATAL_IF((VAR_1 == nullptr), ""initial calloc failed on mPollFds with a size of %d"",
((int)sizeof(struct pollfd)) * VAR_2);
LOG_ALWAYS_FATAL_IF((VAR_3 == nullptr), ""initial calloc failed on mPollRefs with a size of %d"",
((int)sizeof(DNSServiceRef *)) * VAR_2);
VAR_1[0].fd = VAR_4[0];
VAR_1[0].events = VAR_5;
if (VAR_6) ALOGD(""MDnsSdListener starting to monitor"");
while (1) {
if (VAR_6) ALOGD(""Going to poll with pollCount %d"", VAR_0);
int VAR_7 = poll(VAR_1, VAR_0, 10000000);
if (VAR_6) ALOGD(""pollResults=%d"", VAR_7);
if (VAR_7 < 0) {
ALOGE(""Error in poll - got %d"", VAR_8);
} else if (VAR_7 > 0) {
if (VAR_6) ALOGD(""Monitor poll got data pollCount = %d, %d"", VAR_0, VAR_7);
for(int VAR_9 = 1; VAR_9 < VAR_0; VAR_9++) {
if (VAR_1[VAR_9].revents != 0) {
if (VAR_6) {
ALOGD(""Monitor found [%d].revents = %d - calling ProcessResults"",
VAR_9, VAR_1[VAR_9].revents);
}
std::lock_guard guard(mMutex);
DNSServiceProcessResult(*(VAR_3[VAR_9]));
VAR_1[VAR_9].revents = 0;
}
}
if (VAR_6) ALOGD(""controlSocket shows revent= %d"", VAR_1[0].revents);
switch (VAR_1[0].revents) {
case VAR_5: {
char VAR_10[2];
read(VAR_4[0], &VAR_10, 1);
if (VAR_11) ALOGD(""MDnsSdListener::Monitor got %c"", VAR_10[0]);
if (memcmp(VAR_12, VAR_10, 1) == 0) {
VAR_0 = rescan();
}
}
}
VAR_1[0].revents = 0;
} else {
if (VAR_6) ALOGD(""MDnsSdListener::Monitor poll timed out"");
}
}
free(VAR_1);
free(VAR_3);
}",android/1b8bddd96b2efd4074b6d4eee377b62077c031bd/MDnsSdListener.cpp/vul/before/0.json,"void MDnsSdListener::Monitor::run() {
    int pollCount = 1;

    mPollFds = (struct pollfd *)calloc(sizeof(struct pollfd), mPollSize);
    mPollRefs = (DNSServiceRef **)calloc(sizeof(DNSServiceRef *), mPollSize);
    LOG_ALWAYS_FATAL_IF((mPollFds == nullptr), ""initial calloc failed on mPollFds with a size of %d"",
            ((int)sizeof(struct pollfd)) * mPollSize);
    LOG_ALWAYS_FATAL_IF((mPollRefs == nullptr), ""initial calloc failed on mPollRefs with a size of %d"",
            ((int)sizeof(DNSServiceRef *)) * mPollSize);

    mPollFds[0].fd = mCtrlSocketPair[0];
    mPollFds[0].events = POLLIN;

    if (VDBG) ALOGD(""MDnsSdListener starting to monitor"");
    while (1) {
        if (VDBG) ALOGD(""Going to poll with pollCount %d"", pollCount);
        int pollResults = poll(mPollFds, pollCount, 10000000);
        if (VDBG) ALOGD(""pollResults=%d"", pollResults);
        if (pollResults < 0) {
            ALOGE(""Error in poll - got %d"", errno);
        } else if (pollResults > 0) {
            if (VDBG) ALOGD(""Monitor poll got data pollCount = %d, %d"", pollCount, pollResults);
            for(int i = 1; i < pollCount; i++) {
                if (mPollFds[i].revents != 0) {
                    if (VDBG) {
                        ALOGD(""Monitor found [%d].revents = %d - calling ProcessResults"",
                                i, mPollFds[i].revents);
                    }
                    std::lock_guard guard(mMutex);
                    DNSServiceProcessResult(*(mPollRefs[i]));
                    mPollFds[i].revents = 0;
                }
            }
            if (VDBG) ALOGD(""controlSocket shows revent= %d"", mPollFds[0].revents);
            if (mPollFds[0].revents & POLLHUP) {
                free(mPollFds);
                free(mPollRefs);
                if (VDBG) ALOGD(""Monitor thread leaving."");
                return;
            }
            if (mPollFds[0].revents == POLLIN) {
                char readBuf[2];
                read(mCtrlSocketPair[0], &readBuf, 1);
                if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);
                if (memcmp(RESCAN, readBuf, 1) == 0) {
                    pollCount = rescan();
                }
            }
            mPollFds[0].revents = 0;
        } else {
            if (VDBG) ALOGD(""MDnsSdListener::Monitor poll timed out"");
        }
    }
    free(mPollFds);
    free(mPollRefs);
}","void MDnsSdListener::Monitor::run() {
    int VAR_0 = 1;

    VAR_1 = (struct pollfd *)calloc(sizeof(struct pollfd), VAR_2);
    VAR_3 = (DNSServiceRef **)calloc(sizeof(DNSServiceRef *), VAR_2);
    LOG_ALWAYS_FATAL_IF((VAR_1 == nullptr), ""initial calloc failed on mPollFds with a size of %d"",
            ((int)sizeof(struct pollfd)) * VAR_2);
    LOG_ALWAYS_FATAL_IF((VAR_3 == nullptr), ""initial calloc failed on mPollRefs with a size of %d"",
            ((int)sizeof(DNSServiceRef *)) * VAR_2);

    VAR_1[0].fd = VAR_4[0];
    VAR_1[0].events = VAR_5;

    if (VAR_6) ALOGD(""MDnsSdListener starting to monitor"");
    while (1) {
        if (VAR_6) ALOGD(""Going to poll with pollCount %d"", VAR_0);
        int VAR_7 = poll(VAR_1, VAR_0, 10000000);
        if (VAR_6) ALOGD(""pollResults=%d"", VAR_7);
        if (VAR_7 < 0) {
            ALOGE(""Error in poll - got %d"", VAR_8);
        } else if (VAR_7 > 0) {
            if (VAR_6) ALOGD(""Monitor poll got data pollCount = %d, %d"", VAR_0, VAR_7);
            for(int VAR_9 = 1; VAR_9 < VAR_0; VAR_9++) {
                if (VAR_1[VAR_9].revents != 0) {
                    if (VAR_6) {
                        ALOGD(""Monitor found [%d].revents = %d - calling ProcessResults"",
                                VAR_9, VAR_1[VAR_9].revents);
                    }
                    std::lock_guard guard(mMutex);
                    DNSServiceProcessResult(*(VAR_3[VAR_9]));
                    VAR_1[VAR_9].revents = 0;
                }
            }
            if (VAR_6) ALOGD(""controlSocket shows revent= %d"", VAR_1[0].revents);
            if (VAR_1[0].revents & VAR_10) {
                free(VAR_1);
                free(VAR_3);
                if (VAR_6) ALOGD(""Monitor thread leaving."");
                return;
            }
            if (VAR_1[0].revents == VAR_5) {
                char VAR_11[2];
                read(VAR_4[0], &VAR_11, 1);
                if (VAR_12) ALOGD(""MDnsSdListener::Monitor got %c"", VAR_11[0]);
                if (memcmp(VAR_13, VAR_11, 1) == 0) {
                    VAR_0 = rescan();
                }
            }
            VAR_1[0].revents = 0;
        } else {
            if (VAR_6) ALOGD(""MDnsSdListener::Monitor poll timed out"");
        }
    }
    free(VAR_1);
    free(VAR_3);
}",android/1b8bddd96b2efd4074b6d4eee377b62077c031bd/MDnsSdListener.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,14 +32,18 @@
                 }
             }
             if (VDBG) ALOGD(""controlSocket shows revent= %d"", mPollFds[0].revents);
-            switch (mPollFds[0].revents) {
-                case POLLIN: {
-                    char readBuf[2];
-                    read(mCtrlSocketPair[0], &readBuf, 1);
-                    if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);
-                    if (memcmp(RESCAN, readBuf, 1) == 0) {
-                        pollCount = rescan();
-                    }
+            if (mPollFds[0].revents & POLLHUP) {
+                free(mPollFds);
+                free(mPollRefs);
+                if (VDBG) ALOGD(""Monitor thread leaving."");
+                return;
+            }
+            if (mPollFds[0].revents == POLLIN) {
+                char readBuf[2];
+                read(mCtrlSocketPair[0], &readBuf, 1);
+                if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);
+                if (memcmp(RESCAN, readBuf, 1) == 0) {
+                    pollCount = rescan();
                 }
             }
             mPollFds[0].revents = 0;","{'deleted_lines': ['            switch (mPollFds[0].revents) {', '                case POLLIN: {', '                    char readBuf[2];', '                    read(mCtrlSocketPair[0], &readBuf, 1);', '                    if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);', '                    if (memcmp(RESCAN, readBuf, 1) == 0) {', '                        pollCount = rescan();', '                    }'], 'added_lines': ['            if (mPollFds[0].revents & POLLHUP) {', '                free(mPollFds);', '                free(mPollRefs);', '                if (VDBG) ALOGD(""Monitor thread leaving."");', '                return;', '            }', '            if (mPollFds[0].revents == POLLIN) {', '                char readBuf[2];', '                read(mCtrlSocketPair[0], &readBuf, 1);', '                if (DBG) ALOGD(""MDnsSdListener::Monitor got %c"", readBuf[0]);', '                if (memcmp(RESCAN, readBuf, 1) == 0) {', '                    pollCount = rescan();']}",True,"In run of MDnsSdListener.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40084,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix Heap-use-after-free in MDnsSdListener::Monitor::run

Use thread join to avoid thread exiting after instance
recycled.

Prior to implementing this patch, fuzzing would lead to a segmentation fault after approximately 500 rounds. With the addition of the patch, the fuzzing process can now be repeated for over 30,000 rounds.

Test: m, fuzzing
Fuzzing: mma mdns_service_fuzzer && adb sync data && adb shell /data/fuzz/arm64/mdns_service_fuzzer/mdns_service_fuzzer

Bug: 272382770
Ignore-AOSP-First: Security Issue
(cherry picked from commit 9c0c15f80cffb98b36284dd169a2e62e059dbbe3)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:75e5e2e1faec7aa2812fc6fba30d6fe80558bacd)
Merged-In: I5bc85451b4e6539bad45ceb672924a37952cc138
Change-Id: I5bc85451b4e6539bad45ceb672924a37952cc138
",1b8bddd96b2efd4074b6d4eee377b62077c031bd,https://android.googlesource.com/platform/system/netd/+/1b8bddd96b2efd4074b6d4eee377b62077c031bd,server/MDnsSdListener.cpp,MDnsSdListener::Monitor::Monitor,"MDnsSdListener::Monitor::Monitor() {
mHead = nullptr;
mLiveCount = 0;
mPollFds = nullptr;
mPollRefs = nullptr;
mPollSize = 10;
socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, mCtrlSocketPair);
const int rval = ::android::netdutils::threadLaunch(this);
if (rval != 0) {
ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-rval), -rval);
}
}","MDnsSdListener::Monitor::Monitor() {
VAR_0 = nullptr;
VAR_1 = 0;
VAR_2 = nullptr;
VAR_3 = nullptr;
VAR_4 = 10;
socketpair(VAR_5, VAR_6 | VAR_7, 0, VAR_8);
const int VAR_9 = ::android::netdutils::threadLaunch(this);
if (VAR_9 != 0) {
ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-VAR_9), -VAR_9);
}
}",android/1b8bddd96b2efd4074b6d4eee377b62077c031bd/MDnsSdListener.cpp/vul/before/1.json,"MDnsSdListener::Monitor::Monitor() {
    mHead = nullptr;
    mLiveCount = 0;
    mPollFds = nullptr;
    mPollRefs = nullptr;
    mPollSize = 10;
    socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, mCtrlSocketPair);

    mRescanThread = new std::thread(&Monitor::run, this);
    if (!mRescanThread->joinable()) ALOGE(""Unable to launch thread."");
}","MDnsSdListener::Monitor::Monitor() {
    VAR_0 = nullptr;
    VAR_1 = 0;
    VAR_2 = nullptr;
    VAR_3 = nullptr;
    VAR_4 = 10;
    socketpair(VAR_5, VAR_6 | VAR_7, 0, VAR_8);

    VAR_9 = new std::thread(&Monitor::run, this);
    if (!VAR_9->joinable()) ALOGE(""Unable to launch thread."");
}",android/1b8bddd96b2efd4074b6d4eee377b62077c031bd/MDnsSdListener.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,8 +6,6 @@
     mPollSize = 10;
     socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, mCtrlSocketPair);
 
-    const int rval = ::android::netdutils::threadLaunch(this);
-    if (rval != 0) {
-        ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-rval), -rval);
-    }
+    mRescanThread = new std::thread(&Monitor::run, this);
+    if (!mRescanThread->joinable()) ALOGE(""Unable to launch thread."");
 }","{'deleted_lines': ['    const int rval = ::android::netdutils::threadLaunch(this);', '    if (rval != 0) {', '        ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-rval), -rval);', '    }'], 'added_lines': ['    mRescanThread = new std::thread(&Monitor::run, this);', '    if (!mRescanThread->joinable()) ALOGE(""Unable to launch thread."");']}",True,"In run of MDnsSdListener.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2023-40096,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Correct attribution source for MMAP thread

Ensure that the package name, which is used for listening for appops
below getInputForAttr, is corrected for MMAP threads.

Bug: 268724205
Test: AudioRecordTest
Test: Oboetester MMAP record silenced when backgrounded - 6s
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:f59db5cb1be38abce4c3c4f553090e527a6d4513)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0230540dbcefd8c9d0e73a423ad95f3ad379c3a0)
Merged-In: Ia6fc1bff815bbbb2fee8bc1a60569a663a713e4b
Change-Id: Ia6fc1bff815bbbb2fee8bc1a60569a663a713e4b
",148aeea373febc959c429f2cabd8323508c38ad8,https://android.googlesource.com/platform/frameworks/av/+/148aeea373febc959c429f2cabd8323508c38ad8,services/audioflinger/Threads.cpp,AudioFlinger::MmapThread::start,"status_t AudioFlinger::MmapThread::start(const AudioClient& client,
const audio_attributes_t *attr,
audio_port_handle_t *handle)
{
ALOGV(""%s clientUid %d mStandby %d mPortId %d *handle %d"", __FUNCTION__,
client.attributionSource.uid, mStandby, mPortId, *handle);
if (mHalStream == 0) {
return NO_INIT;
}
status_t ret;
if (*handle == mPortId) {
ret = exitStandby();
if (ret == NO_ERROR) {
acquireWakeLock();
}
return ret;
}
audio_port_handle_t portId = AUDIO_PORT_HANDLE_NONE;
audio_io_handle_t io = mId;
if (isOutput()) {
audio_config_t config = AUDIO_CONFIG_INITIALIZER;
config.sample_rate = mSampleRate;
config.channel_mask = mChannelMask;
config.format = mFormat;
audio_stream_type_t stream = streamType();
audio_output_flags_t flags =
(audio_output_flags_t)(AUDIO_OUTPUT_FLAG_MMAP_NOIRQ | AUDIO_OUTPUT_FLAG_DIRECT);
audio_port_handle_t deviceId = mDeviceId;
std::vector<audio_io_handle_t> secondaryOutputs;
bool isSpatialized;
ret = AudioSystem::getOutputForAttr(&mAttr, &io,
mSessionId,
&stream,
client.attributionSource,
&config,
flags,
&deviceId,
&portId,
&secondaryOutputs,
&isSpatialized);
ALOGD_IF(!secondaryOutputs.empty(),
""MmapThread::start does not support secondary outputs, ignoring them"");
} else {
audio_config_base_t config;
config.sample_rate = mSampleRate;
config.channel_mask = mChannelMask;
config.format = mFormat;
audio_port_handle_t deviceId = mDeviceId;
ret = AudioSystem::getInputForAttr(&mAttr, &io,
RECORD_RIID_INVALID,
mSessionId,
client.attributionSource,
&config,
AUDIO_INPUT_FLAG_MMAP_NOIRQ,
&deviceId,
&portId);
}
if (ret != NO_ERROR || io != mId) {
ALOGE(""%s: error getting output or input from APM (error %d, io %d expected io %d)"",
__FUNCTION__, ret, io, mId);
return BAD_VALUE;
}
if (isOutput()) {
ret = AudioSystem::startOutput(portId);
} else {
{
Mutex::Autolock _l(mLock);
setClientSilencedState_l(portId, false );
}
ret = AudioSystem::startInput(portId);
}
Mutex::Autolock _l(mLock);
if (ret != NO_ERROR) {
ALOGE(""%s: error start rejected by AudioPolicyManager = %d"", __FUNCTION__, ret);
if (!mActiveTracks.isEmpty()) {
mLock.unlock();
if (isOutput()) {
AudioSystem::releaseOutput(portId);
} else {
AudioSystem::releaseInput(portId);
}
mLock.lock();
} else {
mHalStream->stop();
}
eraseClientSilencedState_l(portId);
return PERMISSION_DENIED;
}
sp<MmapTrack> track = new MmapTrack(this, attr == nullptr ? mAttr : *attr, mSampleRate, mFormat,
mChannelMask, mSessionId, isOutput(),
client.attributionSource,
IPCThreadState::self()->getCallingPid(), portId);
if (!isOutput()) {
track->setSilenced_l(isClientSilenced_l(portId));
}
if (isOutput()) {
mHalVolFloat = -1.0f;
} else if (!track->isSilenced_l()) {
for (const sp<MmapTrack> &t : mActiveTracks) {
if (t->isSilenced_l() && t->uid() != client.attributionSource.uid)
t->invalidate();
}
}
mActiveTracks.add(track);
sp<EffectChain> chain = getEffectChain_l(mSessionId);
if (chain != 0) {
chain->setStrategy(getStrategyForStream(streamType()));
chain->incTrackCnt();
chain->incActiveTrackCnt();
}
track->logBeginInterval(patchSinksToString(&mPatch));     *handle = portId;
broadcast_l();
ALOGV(""%s DONE handle %d stream %p"", __FUNCTION__, *handle, mHalStream.get());
return NO_ERROR;
}","status_t AudioFlinger::MmapThread::start(const AudioClient& VAR_0,
const audio_attributes_t *VAR_1,
audio_port_handle_t *VAR_2)
{
ALOGV(""%s clientUid %d mStandby %d mPortId %d *handle %d"", VAR_3,
VAR_0.attributionSource.uid, VAR_4, VAR_5, *VAR_2);
if (VAR_6 == 0) {
return VAR_7;
}
status_t VAR_8;
if (*VAR_2 == VAR_5) {
VAR_8 = exitStandby();
if (VAR_8 == VAR_9) {
acquireWakeLock();
}
return VAR_8;
}
audio_port_handle_t VAR_10 = VAR_11;
audio_io_handle_t VAR_12 = VAR_13;
if (isOutput()) {
audio_config_t VAR_14 = VAR_15;
VAR_14.sample_rate = VAR_16;
VAR_14.channel_mask = VAR_17;
VAR_14.format = VAR_18;
audio_stream_type_t VAR_19 = streamType();
audio_output_flags_t VAR_20 =
(audio_output_flags_t)(VAR_21 | VAR_22);
audio_port_handle_t VAR_23 = VAR_24;
std::vector<audio_io_handle_t> VAR_25;
bool VAR_26;
VAR_8 = AudioSystem::getOutputForAttr(&VAR_27, &VAR_12,
VAR_28,
&VAR_19,
VAR_0.attributionSource,
&VAR_14,
VAR_20,
&VAR_23,
&VAR_10,
&VAR_25,
&VAR_26);
ALOGD_IF(!VAR_25.empty(),
""MmapThread::start does not support secondary outputs, ignoring them"");
} else {
audio_config_base_t VAR_14;
VAR_14.sample_rate = VAR_16;
VAR_14.channel_mask = VAR_17;
VAR_14.format = VAR_18;
audio_port_handle_t VAR_23 = VAR_24;
VAR_8 = AudioSystem::getInputForAttr(&VAR_27, &VAR_12,
VAR_29,
VAR_28,
VAR_0.attributionSource,
&VAR_14,
VAR_30,
&VAR_23,
&VAR_10);
}
if (VAR_8 != VAR_9 || VAR_12 != VAR_13) {
ALOGE(""%s: error getting output or input from APM (error %d, io %d expected io %d)"",
VAR_3, VAR_8, VAR_12, VAR_13);
return VAR_31;
}
if (isOutput()) {
VAR_8 = AudioSystem::startOutput(VAR_10);
} else {
{
Mutex::Autolock _l(mLock);
setClientSilencedState_l(VAR_10, false );
}
VAR_8 = AudioSystem::startInput(VAR_10);
}
Mutex::Autolock _l(mLock);
if (VAR_8 != VAR_9) {
ALOGE(""%s: error start rejected by AudioPolicyManager = %d"", VAR_3, VAR_8);
if (!VAR_32.isEmpty()) {
mLock.unlock();
if (isOutput()) {
AudioSystem::releaseOutput(VAR_10);
} else {
AudioSystem::releaseInput(VAR_10);
}
mLock.lock();
} else {
VAR_6->stop();
}
eraseClientSilencedState_l(VAR_10);
return VAR_33;
}
sp<MmapTrack> VAR_34 = new MmapTrack(this, VAR_1 == nullptr ? VAR_27 : *VAR_1, VAR_16, VAR_18,
VAR_17, VAR_28, isOutput(),
VAR_0.attributionSource,
IPCThreadState::self()->getCallingPid(), VAR_10);
if (!isOutput()) {
VAR_34->setSilenced_l(isClientSilenced_l(VAR_10));
}
if (isOutput()) {
VAR_35 = -1.0f;
} else if (!VAR_34->isSilenced_l()) {
for (const sp<MmapTrack> &VAR_36 : VAR_32) {
if (VAR_36->isSilenced_l() && VAR_36->uid() != VAR_0.attributionSource.uid)
VAR_36->invalidate();
}
}
VAR_32.add(VAR_34);
sp<EffectChain> VAR_37 = getEffectChain_l(VAR_28);
if (VAR_37 != 0) {
VAR_37->setStrategy(getStrategyForStream(streamType()));
VAR_37->incTrackCnt();
VAR_37->incActiveTrackCnt();
}
VAR_34->logBeginInterval(patchSinksToString(&VAR_38)); 
*VAR_2 = VAR_10;
broadcast_l();
ALOGV(""%s DONE handle %d stream %p"", VAR_3, *VAR_2, VAR_6.get());
return VAR_9;
}",android/148aeea373febc959c429f2cabd8323508c38ad8/Threads.cpp/vul/before/0.json,"status_t AudioFlinger::MmapThread::start(const AudioClient& client,
                                         const audio_attributes_t *attr,
                                         audio_port_handle_t *handle)
{
    ALOGV(""%s clientUid %d mStandby %d mPortId %d *handle %d"", __FUNCTION__,
          client.attributionSource.uid, mStandby, mPortId, *handle);
    if (mHalStream == 0) {
        return NO_INIT;
    }

    status_t ret;

    if (*handle == mPortId) {
        // For the first track, reuse portId and session allocated when the stream was opened.
        ret = exitStandby();
        if (ret == NO_ERROR) {
            acquireWakeLock();
        }
        return ret;
    }

    audio_port_handle_t portId = AUDIO_PORT_HANDLE_NONE;

    audio_io_handle_t io = mId;
    AttributionSourceState adjAttributionSource = AudioFlinger::checkAttributionSourcePackage(
            client.attributionSource);

    if (isOutput()) {
        audio_config_t config = AUDIO_CONFIG_INITIALIZER;
        config.sample_rate = mSampleRate;
        config.channel_mask = mChannelMask;
        config.format = mFormat;
        audio_stream_type_t stream = streamType();
        audio_output_flags_t flags =
                (audio_output_flags_t)(AUDIO_OUTPUT_FLAG_MMAP_NOIRQ | AUDIO_OUTPUT_FLAG_DIRECT);
        audio_port_handle_t deviceId = mDeviceId;
        std::vector<audio_io_handle_t> secondaryOutputs;
        bool isSpatialized;
        ret = AudioSystem::getOutputForAttr(&mAttr, &io,
                                            mSessionId,
                                            &stream,
                                            adjAttributionSource,
                                            &config,
                                            flags,
                                            &deviceId,
                                            &portId,
                                            &secondaryOutputs,
                                            &isSpatialized);
        ALOGD_IF(!secondaryOutputs.empty(),
                 ""MmapThread::start does not support secondary outputs, ignoring them"");
    } else {
        audio_config_base_t config;
        config.sample_rate = mSampleRate;
        config.channel_mask = mChannelMask;
        config.format = mFormat;
        audio_port_handle_t deviceId = mDeviceId;
        ret = AudioSystem::getInputForAttr(&mAttr, &io,
                                              RECORD_RIID_INVALID,
                                              mSessionId,
                                              adjAttributionSource,
                                              &config,
                                              AUDIO_INPUT_FLAG_MMAP_NOIRQ,
                                              &deviceId,
                                              &portId);
    }
    // APM should not chose a different input or output stream for the same set of attributes
    // and audo configuration
    if (ret != NO_ERROR || io != mId) {
        ALOGE(""%s: error getting output or input from APM (error %d, io %d expected io %d)"",
              __FUNCTION__, ret, io, mId);
        return BAD_VALUE;
    }

    if (isOutput()) {
        ret = AudioSystem::startOutput(portId);
    } else {
        {
            // Add the track record before starting input so that the silent status for the
            // client can be cached.
            Mutex::Autolock _l(mLock);
            setClientSilencedState_l(portId, false /*silenced*/);
        }
        ret = AudioSystem::startInput(portId);
    }

    Mutex::Autolock _l(mLock);
    // abort if start is rejected by audio policy manager
    if (ret != NO_ERROR) {
        ALOGE(""%s: error start rejected by AudioPolicyManager = %d"", __FUNCTION__, ret);
        if (!mActiveTracks.isEmpty()) {
            mLock.unlock();
            if (isOutput()) {
                AudioSystem::releaseOutput(portId);
            } else {
                AudioSystem::releaseInput(portId);
            }
            mLock.lock();
        } else {
            mHalStream->stop();
        }
        eraseClientSilencedState_l(portId);
        return PERMISSION_DENIED;
    }

    // Given that MmapThread::mAttr is mutable, should a MmapTrack have attributes ?
    sp<MmapTrack> track = new MmapTrack(this, attr == nullptr ? mAttr : *attr, mSampleRate, mFormat,
                                        mChannelMask, mSessionId, isOutput(),
                                        client.attributionSource,
                                        IPCThreadState::self()->getCallingPid(), portId);
    if (!isOutput()) {
        track->setSilenced_l(isClientSilenced_l(portId));
    }

    if (isOutput()) {
        // force volume update when a new track is added
        mHalVolFloat = -1.0f;
    } else if (!track->isSilenced_l()) {
        for (const sp<MmapTrack> &t : mActiveTracks) {
            if (t->isSilenced_l() && t->uid() != client.attributionSource.uid)
                t->invalidate();
        }
    }


    mActiveTracks.add(track);
    sp<EffectChain> chain = getEffectChain_l(mSessionId);
    if (chain != 0) {
        chain->setStrategy(getStrategyForStream(streamType()));
        chain->incTrackCnt();
        chain->incActiveTrackCnt();
    }

    track->logBeginInterval(patchSinksToString(&mPatch)); // log to MediaMetrics
    *handle = portId;
    broadcast_l();

    ALOGV(""%s DONE handle %d stream %p"", __FUNCTION__, *handle, mHalStream.get());

    return NO_ERROR;
}","status_t AudioFlinger::MmapThread::start(const AudioClient& VAR_0,
                                         const audio_attributes_t *VAR_1,
                                         audio_port_handle_t *VAR_2)
{
    ALOGV(""%s clientUid %d mStandby %d mPortId %d *handle %d"", VAR_3,
          VAR_0.attributionSource.uid, VAR_4, VAR_5, *VAR_2);
    if (VAR_6 == 0) {
        return VAR_7;
    }

    status_t VAR_8;

    if (*VAR_2 == VAR_5) {
        /* COMMENT_0 */
        VAR_8 = exitStandby();
        if (VAR_8 == VAR_9) {
            acquireWakeLock();
        }
        return VAR_8;
    }

    audio_port_handle_t VAR_10 = VAR_11;

    audio_io_handle_t VAR_12 = VAR_13;
    AttributionSourceState VAR_14 = AudioFlinger::checkAttributionSourcePackage(
            VAR_0.attributionSource);

    if (isOutput()) {
        audio_config_t VAR_15 = VAR_16;
        VAR_15.sample_rate = VAR_17;
        VAR_15.channel_mask = VAR_18;
        VAR_15.format = VAR_19;
        audio_stream_type_t VAR_20 = streamType();
        audio_output_flags_t VAR_21 =
                (audio_output_flags_t)(VAR_22 | VAR_23);
        audio_port_handle_t VAR_24 = VAR_25;
        std::vector<audio_io_handle_t> VAR_26;
        bool VAR_27;
        VAR_8 = AudioSystem::getOutputForAttr(&VAR_28, &VAR_12,
                                            VAR_29,
                                            &VAR_20,
                                            VAR_14,
                                            &VAR_15,
                                            VAR_21,
                                            &VAR_24,
                                            &VAR_10,
                                            &VAR_26,
                                            &VAR_27);
        ALOGD_IF(!VAR_26.empty(),
                 ""MmapThread::start does not support secondary outputs, ignoring them"");
    } else {
        audio_config_base_t VAR_15;
        VAR_15.sample_rate = VAR_17;
        VAR_15.channel_mask = VAR_18;
        VAR_15.format = VAR_19;
        audio_port_handle_t VAR_24 = VAR_25;
        VAR_8 = AudioSystem::getInputForAttr(&VAR_28, &VAR_12,
                                              VAR_30,
                                              VAR_29,
                                              VAR_14,
                                              &VAR_15,
                                              VAR_31,
                                              &VAR_24,
                                              &VAR_10);
    }
    /* COMMENT_1 */
    /* COMMENT_2 */
    if (VAR_8 != VAR_9 || VAR_12 != VAR_13) {
        ALOGE(""%s: error getting output or input from APM (error %d, io %d expected io %d)"",
              VAR_3, VAR_8, VAR_12, VAR_13);
        return VAR_32;
    }

    if (isOutput()) {
        VAR_8 = AudioSystem::startOutput(VAR_10);
    } else {
        {
            /* COMMENT_3 */
            /* COMMENT_4 */
            Mutex::Autolock _l(mLock);
            setClientSilencedState_l(VAR_10, false /* COMMENT_5 */);
        }
        VAR_8 = AudioSystem::startInput(VAR_10);
    }

    Mutex::Autolock _l(mLock);
    /* COMMENT_6 */
    if (VAR_8 != VAR_9) {
        ALOGE(""%s: error start rejected by AudioPolicyManager = %d"", VAR_3, VAR_8);
        if (!VAR_33.isEmpty()) {
            mLock.unlock();
            if (isOutput()) {
                AudioSystem::releaseOutput(VAR_10);
            } else {
                AudioSystem::releaseInput(VAR_10);
            }
            mLock.lock();
        } else {
            VAR_6->stop();
        }
        eraseClientSilencedState_l(VAR_10);
        return VAR_34;
    }

    /* COMMENT_7 */
    sp<MmapTrack> VAR_35 = new MmapTrack(this, VAR_1 == nullptr ? VAR_28 : *VAR_1, VAR_17, VAR_19,
                                        VAR_18, VAR_29, isOutput(),
                                        VAR_0.attributionSource,
                                        IPCThreadState::self()->getCallingPid(), VAR_10);
    if (!isOutput()) {
        VAR_35->setSilenced_l(isClientSilenced_l(VAR_10));
    }

    if (isOutput()) {
        /* COMMENT_8 */
        VAR_36 = -1.0f;
    } else if (!VAR_35->isSilenced_l()) {
        for (const sp<MmapTrack> &VAR_37 : VAR_33) {
            if (VAR_37->isSilenced_l() && VAR_37->uid() != VAR_0.attributionSource.uid)
                VAR_37->invalidate();
        }
    }


    VAR_33.add(VAR_35);
    sp<EffectChain> VAR_38 = getEffectChain_l(VAR_29);
    if (VAR_38 != 0) {
        VAR_38->setStrategy(getStrategyForStream(streamType()));
        VAR_38->incTrackCnt();
        VAR_38->incActiveTrackCnt();
    }

    VAR_35->logBeginInterval(patchSinksToString(&VAR_39)); /* COMMENT_9 */
    *VAR_2 = VAR_10;
    broadcast_l();

    ALOGV(""%s DONE handle %d stream %p"", VAR_3, *VAR_2, VAR_6.get());

    return VAR_9;
}",android/148aeea373febc959c429f2cabd8323508c38ad8/Threads.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,9 @@
     audio_port_handle_t portId = AUDIO_PORT_HANDLE_NONE;
 
     audio_io_handle_t io = mId;
+    AttributionSourceState adjAttributionSource = AudioFlinger::checkAttributionSourcePackage(
+            client.attributionSource);
+
     if (isOutput()) {
         audio_config_t config = AUDIO_CONFIG_INITIALIZER;
         config.sample_rate = mSampleRate;
@@ -36,7 +39,7 @@
         ret = AudioSystem::getOutputForAttr(&mAttr, &io,
                                             mSessionId,
                                             &stream,
-                                            client.attributionSource,
+                                            adjAttributionSource,
                                             &config,
                                             flags,
                                             &deviceId,
@@ -54,7 +57,7 @@
         ret = AudioSystem::getInputForAttr(&mAttr, &io,
                                               RECORD_RIID_INVALID,
                                               mSessionId,
-                                              client.attributionSource,
+                                              adjAttributionSource,
                                               &config,
                                               AUDIO_INPUT_FLAG_MMAP_NOIRQ,
                                               &deviceId,","{'deleted_lines': ['                                            client.attributionSource,', '                                              client.attributionSource,'], 'added_lines': ['    AttributionSourceState adjAttributionSource = AudioFlinger::checkAttributionSourcePackage(', '            client.attributionSource);', '', '                                            adjAttributionSource,', '                                              adjAttributionSource,']}",True,"In OpRecordAudioMonitor::onFirstRef of AudioRecordClient.cpp, there is a possible way to record audio from the background due to a missing flag. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,valid,,5
CVE-2019-9503,['CWE-20'],AV:A/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"For USB there is no separate channel being used to pass events
from firmware to the host driver and as such are passed over the
data path. In order to detect mock event messages an additional
check is needed on event subtype. This check is added conditionally
using unlikely() keyword.

Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
Reviewed-by: Franky Lin <franky.lin@broadcom.com>
Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
",a4176ec356c73a46c07c181c6d04039fafa34a9f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a4176ec356c73a46c07c181c6d04039fafa34a9f,drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c,brcmf_rx_event,"void brcmf_rx_event(struct device *dev, struct sk_buff *skb)
{
struct brcmf_if *ifp;
struct brcmf_bus *bus_if = dev_get_drvdata(dev);
struct brcmf_pub *drvr = bus_if->drvr;
brcmf_dbg(EVENT, ""Enter: %s: rxp=%p\n"", dev_name(dev), skb);
if (brcmf_rx_hdrpull(drvr, skb, &ifp))
return;
brcmf_fweh_process_skb(ifp->drvr, skb);
brcmu_pkt_buf_free_skb(skb);
}","void brcmf_rx_event(struct device *VAR_0, struct sk_buff *VAR_1)
{
struct brcmf_if *VAR_2;
struct brcmf_bus *VAR_3 = dev_get_drvdata(VAR_0);
struct brcmf_pub *VAR_4 = VAR_3->drvr;
brcmf_dbg(VAR_5, ""Enter: %s: rxp=%p\n"", dev_name(VAR_0), VAR_1);
if (brcmf_rx_hdrpull(VAR_4, VAR_1, &VAR_2))
return;
brcmf_fweh_process_skb(VAR_2->drvr, VAR_1);
brcmu_pkt_buf_free_skb(VAR_1);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/core.c/vul/before/0.json,"void brcmf_rx_event(struct device *dev, struct sk_buff *skb)
{
	struct brcmf_if *ifp;
	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
	struct brcmf_pub *drvr = bus_if->drvr;

	brcmf_dbg(EVENT, ""Enter: %s: rxp=%p\n"", dev_name(dev), skb);

	if (brcmf_rx_hdrpull(drvr, skb, &ifp))
		return;

	brcmf_fweh_process_skb(ifp->drvr, skb, 0);
	brcmu_pkt_buf_free_skb(skb);
}","void brcmf_rx_event(struct device *VAR_0, struct sk_buff *VAR_1)
{
	struct brcmf_if *VAR_2;
	struct brcmf_bus *VAR_3 = dev_get_drvdata(VAR_0);
	struct brcmf_pub *VAR_4 = VAR_3->drvr;

	brcmf_dbg(VAR_5, ""Enter: %s: rxp=%p\n"", dev_name(VAR_0), VAR_1);

	if (brcmf_rx_hdrpull(VAR_4, VAR_1, &VAR_2))
		return;

	brcmf_fweh_process_skb(VAR_2->drvr, VAR_1, 0);
	brcmu_pkt_buf_free_skb(VAR_1);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,6 @@
 	if (brcmf_rx_hdrpull(drvr, skb, &ifp))
 		return;
 
-	brcmf_fweh_process_skb(ifp->drvr, skb);
+	brcmf_fweh_process_skb(ifp->drvr, skb, 0);
 	brcmu_pkt_buf_free_skb(skb);
 }","{'deleted_lines': ['\tbrcmf_fweh_process_skb(ifp->drvr, skb);'], 'added_lines': ['\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);']}",True,"The Broadcom brcmfmac WiFi driver prior to commit a4176ec356c73a46c07c181c6d04039fafa34a9f is vulnerable to a frame validation bypass. If the brcmfmac driver receives a firmware event frame from a remote source, the is_wlc_event_frame function will cause this frame to be discarded and unprocessed. If the driver receives the firmware event frame from the host, the appropriate handler is called. This frame validation can be bypassed if the bus used is USB (for instance by a wifi dongle). This can allow firmware event frames from a remote source to be processed. In the worst case scenario, by sending specially-crafted WiFi packets, a remote, unauthenticated attacker may be able to execute arbitrary code on a vulnerable system. More typically, this vulnerability will result in denial-of-service conditions.",8.3,HIGH,2,valid,,5
CVE-2019-9503,['CWE-20'],AV:A/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"For USB there is no separate channel being used to pass events
from firmware to the host driver and as such are passed over the
data path. In order to detect mock event messages an additional
check is needed on event subtype. This check is added conditionally
using unlikely() keyword.

Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
Reviewed-by: Franky Lin <franky.lin@broadcom.com>
Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
",a4176ec356c73a46c07c181c6d04039fafa34a9f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a4176ec356c73a46c07c181c6d04039fafa34a9f,drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c,brcmf_rx_frame,"void brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event)
{
struct brcmf_if *ifp;
struct brcmf_bus *bus_if = dev_get_drvdata(dev);
struct brcmf_pub *drvr = bus_if->drvr;
brcmf_dbg(DATA, ""Enter: %s: rxp=%p\n"", dev_name(dev), skb);
if (brcmf_rx_hdrpull(drvr, skb, &ifp))
return;
if (brcmf_proto_is_reorder_skb(skb)) {
brcmf_proto_rxreorder(ifp, skb);
} else {
if (handle_event)
brcmf_fweh_process_skb(ifp->drvr, skb);
brcmf_netif_rx(ifp, skb);
}
}","void brcmf_rx_frame(struct device *VAR_0, struct sk_buff *VAR_1, bool VAR_2)
{
struct brcmf_if *VAR_3;
struct brcmf_bus *VAR_4 = dev_get_drvdata(VAR_0);
struct brcmf_pub *VAR_5 = VAR_4->drvr;
brcmf_dbg(VAR_6, ""Enter: %s: rxp=%p\n"", dev_name(VAR_0), VAR_1);
if (brcmf_rx_hdrpull(VAR_5, VAR_1, &VAR_3))
return;
if (brcmf_proto_is_reorder_skb(VAR_1)) {
brcmf_proto_rxreorder(VAR_3, VAR_1);
} else {
if (VAR_2)
brcmf_fweh_process_skb(VAR_3->drvr, VAR_1);
brcmf_netif_rx(VAR_3, VAR_1);
}
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/core.c/vul/before/1.json,"void brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event)
{
	struct brcmf_if *ifp;
	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
	struct brcmf_pub *drvr = bus_if->drvr;

	brcmf_dbg(DATA, ""Enter: %s: rxp=%p\n"", dev_name(dev), skb);

	if (brcmf_rx_hdrpull(drvr, skb, &ifp))
		return;

	if (brcmf_proto_is_reorder_skb(skb)) {
		brcmf_proto_rxreorder(ifp, skb);
	} else {
		/* Process special event packets */
		if (handle_event)
			brcmf_fweh_process_skb(ifp->drvr, skb,
					       BCMILCP_SUBTYPE_VENDOR_LONG);

		brcmf_netif_rx(ifp, skb);
	}
}","void brcmf_rx_frame(struct device *VAR_0, struct sk_buff *VAR_1, bool VAR_2)
{
	struct brcmf_if *VAR_3;
	struct brcmf_bus *VAR_4 = dev_get_drvdata(VAR_0);
	struct brcmf_pub *VAR_5 = VAR_4->drvr;

	brcmf_dbg(VAR_6, ""Enter: %s: rxp=%p\n"", dev_name(VAR_0), VAR_1);

	if (brcmf_rx_hdrpull(VAR_5, VAR_1, &VAR_3))
		return;

	if (brcmf_proto_is_reorder_skb(VAR_1)) {
		brcmf_proto_rxreorder(VAR_3, VAR_1);
	} else {
		/* COMMENT_0 */
		if (VAR_2)
			brcmf_fweh_process_skb(VAR_3->drvr, VAR_1,
					       VAR_7);

		brcmf_netif_rx(VAR_3, VAR_1);
	}
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/core.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,7 +14,8 @@
 	} else {
 		/* Process special event packets */
 		if (handle_event)
-			brcmf_fweh_process_skb(ifp->drvr, skb);
+			brcmf_fweh_process_skb(ifp->drvr, skb,
+					       BCMILCP_SUBTYPE_VENDOR_LONG);
 
 		brcmf_netif_rx(ifp, skb);
 	}","{'deleted_lines': ['\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb);'], 'added_lines': ['\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb,', '\t\t\t\t\t       BCMILCP_SUBTYPE_VENDOR_LONG);']}",True,"The Broadcom brcmfmac WiFi driver prior to commit a4176ec356c73a46c07c181c6d04039fafa34a9f is vulnerable to a frame validation bypass. If the brcmfmac driver receives a firmware event frame from a remote source, the is_wlc_event_frame function will cause this frame to be discarded and unprocessed. If the driver receives the firmware event frame from the host, the appropriate handler is called. This frame validation can be bypassed if the bus used is USB (for instance by a wifi dongle). This can allow firmware event frames from a remote source to be processed. In the worst case scenario, by sending specially-crafted WiFi packets, a remote, unauthenticated attacker may be able to execute arbitrary code on a vulnerable system. More typically, this vulnerability will result in denial-of-service conditions.",8.3,HIGH,2,valid,,5
CVE-2019-9503,['CWE-20'],AV:A/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"For USB there is no separate channel being used to pass events
from firmware to the host driver and as such are passed over the
data path. In order to detect mock event messages an additional
check is needed on event subtype. This check is added conditionally
using unlikely() keyword.

Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
Reviewed-by: Franky Lin <franky.lin@broadcom.com>
Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
",a4176ec356c73a46c07c181c6d04039fafa34a9f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a4176ec356c73a46c07c181c6d04039fafa34a9f,drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h,brcmf_fweh_process_skb,"static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,
struct sk_buff *skb)
{
struct brcmf_event *event_packet;
u16 usr_stype;
if (skb->protocol != cpu_to_be16(ETH_P_LINK_CTL))
return;
if ((skb->len + ETH_HLEN) < sizeof(*event_packet))
return;
event_packet = (struct brcmf_event *)skb_mac_header(skb);
if (memcmp(BRCM_OUI, &event_packet->hdr.oui[0],
sizeof(event_packet->hdr.oui)))
return;
usr_stype = get_unaligned_be16(&event_packet->hdr.usr_subtype);
if (usr_stype != BCMILCP_BCM_SUBTYPE_EVENT)
return;
brcmf_fweh_process_event(drvr, event_packet, skb->len + ETH_HLEN);
}","static inline void brcmf_fweh_process_skb(struct brcmf_pub *VAR_0,
struct sk_buff *VAR_1)
{
struct brcmf_event *VAR_2;
u16 VAR_3;
if (VAR_1->protocol != cpu_to_be16(VAR_4))
return;
if ((VAR_1->len + VAR_5) < sizeof(*VAR_2))
return;
VAR_2 = (struct brcmf_event *)skb_mac_header(VAR_1);
if (memcmp(VAR_6, &VAR_2->hdr.oui[0],
sizeof(VAR_2->hdr.oui)))
return;
VAR_3 = get_unaligned_be16(&VAR_2->hdr.usr_subtype);
if (VAR_3 != VAR_7)
return;
brcmf_fweh_process_event(VAR_0, VAR_2, VAR_1->len + VAR_5);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/fweh.h/vul/before/0.json,"static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,
					  struct sk_buff *skb, u16 stype)
{
	struct brcmf_event *event_packet;
	u16 subtype, usr_stype;

	/* only process events when protocol matches */
	if (skb->protocol != cpu_to_be16(ETH_P_LINK_CTL))
		return;

	if ((skb->len + ETH_HLEN) < sizeof(*event_packet))
		return;

	event_packet = (struct brcmf_event *)skb_mac_header(skb);

	/* check subtype if needed */
	if (unlikely(stype)) {
		subtype = get_unaligned_be16(&event_packet->hdr.subtype);
		if (subtype != stype)
			return;
	}

	/* check for BRCM oui match */
	if (memcmp(BRCM_OUI, &event_packet->hdr.oui[0],
		   sizeof(event_packet->hdr.oui)))
		return;

	/* final match on usr_subtype */
	usr_stype = get_unaligned_be16(&event_packet->hdr.usr_subtype);
	if (usr_stype != BCMILCP_BCM_SUBTYPE_EVENT)
		return;

	brcmf_fweh_process_event(drvr, event_packet, skb->len + ETH_HLEN);
}","static inline void brcmf_fweh_process_skb(struct brcmf_pub *VAR_0,
					  struct sk_buff *VAR_1, u16 VAR_2)
{
	struct brcmf_event *VAR_3;
	u16 VAR_4, VAR_5;

	/* COMMENT_0 */
	if (VAR_1->protocol != cpu_to_be16(VAR_6))
		return;

	if ((VAR_1->len + VAR_7) < sizeof(*VAR_3))
		return;

	VAR_3 = (struct brcmf_event *)skb_mac_header(VAR_1);

	/* COMMENT_1 */
	if (unlikely(VAR_2)) {
		VAR_4 = get_unaligned_be16(&VAR_3->hdr.subtype);
		if (VAR_4 != VAR_2)
			return;
	}

	/* COMMENT_2 */
	if (memcmp(VAR_8, &VAR_3->hdr.oui[0],
		   sizeof(VAR_3->hdr.oui)))
		return;

	/* COMMENT_3 */
	VAR_5 = get_unaligned_be16(&VAR_3->hdr.usr_subtype);
	if (VAR_5 != VAR_9)
		return;

	brcmf_fweh_process_event(VAR_0, VAR_3, VAR_1->len + VAR_7);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/fweh.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,
-					  struct sk_buff *skb)
+					  struct sk_buff *skb, u16 stype)
 {
 	struct brcmf_event *event_packet;
-	u16 usr_stype;
+	u16 subtype, usr_stype;
 
 	/* only process events when protocol matches */
 	if (skb->protocol != cpu_to_be16(ETH_P_LINK_CTL))
@@ -11,8 +11,16 @@
 	if ((skb->len + ETH_HLEN) < sizeof(*event_packet))
 		return;
 
+	event_packet = (struct brcmf_event *)skb_mac_header(skb);
+
+	/* check subtype if needed */
+	if (unlikely(stype)) {
+		subtype = get_unaligned_be16(&event_packet->hdr.subtype);
+		if (subtype != stype)
+			return;
+	}
+
 	/* check for BRCM oui match */
-	event_packet = (struct brcmf_event *)skb_mac_header(skb);
 	if (memcmp(BRCM_OUI, &event_packet->hdr.oui[0],
 		   sizeof(event_packet->hdr.oui)))
 		return;","{'deleted_lines': ['\t\t\t\t\t  struct sk_buff *skb)', '\tu16 usr_stype;', '\tevent_packet = (struct brcmf_event *)skb_mac_header(skb);'], 'added_lines': ['\t\t\t\t\t  struct sk_buff *skb, u16 stype)', '\tu16 subtype, usr_stype;', '\tevent_packet = (struct brcmf_event *)skb_mac_header(skb);', '', '\t/* check subtype if needed */', '\tif (unlikely(stype)) {', '\t\tsubtype = get_unaligned_be16(&event_packet->hdr.subtype);', '\t\tif (subtype != stype)', '\t\t\treturn;', '\t}', '']}",True,"The Broadcom brcmfmac WiFi driver prior to commit a4176ec356c73a46c07c181c6d04039fafa34a9f is vulnerable to a frame validation bypass. If the brcmfmac driver receives a firmware event frame from a remote source, the is_wlc_event_frame function will cause this frame to be discarded and unprocessed. If the driver receives the firmware event frame from the host, the appropriate handler is called. This frame validation can be bypassed if the bus used is USB (for instance by a wifi dongle). This can allow firmware event frames from a remote source to be processed. In the worst case scenario, by sending specially-crafted WiFi packets, a remote, unauthenticated attacker may be able to execute arbitrary code on a vulnerable system. More typically, this vulnerability will result in denial-of-service conditions.",8.3,HIGH,2,valid,,5
CVE-2019-9503,['CWE-20'],AV:A/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"For USB there is no separate channel being used to pass events
from firmware to the host driver and as such are passed over the
data path. In order to detect mock event messages an additional
check is needed on event subtype. This check is added conditionally
using unlikely() keyword.

Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
Reviewed-by: Franky Lin <franky.lin@broadcom.com>
Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
",a4176ec356c73a46c07c181c6d04039fafa34a9f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a4176ec356c73a46c07c181c6d04039fafa34a9f,drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c,brcmf_msgbuf_process_event,"static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)
{
struct msgbuf_rx_event *event;
u32 idx;
u16 buflen;
struct sk_buff *skb;
struct brcmf_if *ifp;
event = (struct msgbuf_rx_event *)buf;
idx = le32_to_cpu(event->msg.request_id);
buflen = le16_to_cpu(event->event_data_len);
if (msgbuf->cur_eventbuf)
msgbuf->cur_eventbuf--;
brcmf_msgbuf_rxbuf_event_post(msgbuf);
skb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,
msgbuf->rx_pktids, idx);
if (!skb)
return;
if (msgbuf->rx_dataoffset)
skb_pull(skb, msgbuf->rx_dataoffset);
skb_trim(skb, buflen);
ifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);
if (!ifp || !ifp->ndev) {
brcmf_err(""Received pkt for invalid ifidx %d\n"",
event->msg.ifidx);
goto exit;
}
skb->protocol = eth_type_trans(skb, ifp->ndev);
brcmf_fweh_process_skb(ifp->drvr, skb);
exit:
brcmu_pkt_buf_free_skb(skb);
}","static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *VAR_0, void *VAR_1)
{
struct msgbuf_rx_event *VAR_2;
u32 VAR_3;
u16 VAR_4;
struct sk_buff *VAR_5;
struct brcmf_if *VAR_6;
VAR_2 = (struct msgbuf_rx_event *)VAR_1;
VAR_3 = le32_to_cpu(VAR_2->msg.request_id);
VAR_4 = le16_to_cpu(VAR_2->event_data_len);
if (VAR_0->cur_eventbuf)
VAR_0->cur_eventbuf--;
brcmf_msgbuf_rxbuf_event_post(VAR_0);
VAR_5 = brcmf_msgbuf_get_pktid(VAR_0->drvr->bus_if->dev,
VAR_0->rx_pktids, VAR_3);
if (!VAR_5)
return;
if (VAR_0->rx_dataoffset)
skb_pull(VAR_5, VAR_0->rx_dataoffset);
skb_trim(VAR_5, VAR_4);
VAR_6 = brcmf_get_ifp(VAR_0->drvr, VAR_2->msg.ifidx);
if (!VAR_6 || !VAR_6->ndev) {
brcmf_err(""Received pkt for invalid ifidx %d\n"",
VAR_2->msg.ifidx);
goto exit;
}
VAR_5->protocol = eth_type_trans(VAR_5, VAR_6->ndev);
brcmf_fweh_process_skb(VAR_6->drvr, VAR_5);
exit:
brcmu_pkt_buf_free_skb(VAR_5);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/msgbuf.c/vul/before/0.json,"static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)
{
	struct msgbuf_rx_event *event;
	u32 idx;
	u16 buflen;
	struct sk_buff *skb;
	struct brcmf_if *ifp;

	event = (struct msgbuf_rx_event *)buf;
	idx = le32_to_cpu(event->msg.request_id);
	buflen = le16_to_cpu(event->event_data_len);

	if (msgbuf->cur_eventbuf)
		msgbuf->cur_eventbuf--;
	brcmf_msgbuf_rxbuf_event_post(msgbuf);

	skb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,
				     msgbuf->rx_pktids, idx);
	if (!skb)
		return;

	if (msgbuf->rx_dataoffset)
		skb_pull(skb, msgbuf->rx_dataoffset);

	skb_trim(skb, buflen);

	ifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);
	if (!ifp || !ifp->ndev) {
		brcmf_err(""Received pkt for invalid ifidx %d\n"",
			  event->msg.ifidx);
		goto exit;
	}

	skb->protocol = eth_type_trans(skb, ifp->ndev);

	brcmf_fweh_process_skb(ifp->drvr, skb, 0);

exit:
	brcmu_pkt_buf_free_skb(skb);
}","static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *VAR_0, void *VAR_1)
{
	struct msgbuf_rx_event *VAR_2;
	u32 VAR_3;
	u16 VAR_4;
	struct sk_buff *VAR_5;
	struct brcmf_if *VAR_6;

	VAR_2 = (struct msgbuf_rx_event *)VAR_1;
	VAR_3 = le32_to_cpu(VAR_2->msg.request_id);
	VAR_4 = le16_to_cpu(VAR_2->event_data_len);

	if (VAR_0->cur_eventbuf)
		VAR_0->cur_eventbuf--;
	brcmf_msgbuf_rxbuf_event_post(VAR_0);

	VAR_5 = brcmf_msgbuf_get_pktid(VAR_0->drvr->bus_if->dev,
				     VAR_0->rx_pktids, VAR_3);
	if (!VAR_5)
		return;

	if (VAR_0->rx_dataoffset)
		skb_pull(VAR_5, VAR_0->rx_dataoffset);

	skb_trim(VAR_5, VAR_4);

	VAR_6 = brcmf_get_ifp(VAR_0->drvr, VAR_2->msg.ifidx);
	if (!VAR_6 || !VAR_6->ndev) {
		brcmf_err(""Received pkt for invalid ifidx %d\n"",
			  VAR_2->msg.ifidx);
		goto exit;
	}

	VAR_5->protocol = eth_type_trans(VAR_5, VAR_6->ndev);

	brcmf_fweh_process_skb(VAR_6->drvr, VAR_5, 0);

exit:
	brcmu_pkt_buf_free_skb(VAR_5);
}",torvalds/linux/a4176ec356c73a46c07c181c6d04039fafa34a9f/msgbuf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,7 +33,7 @@
 
 	skb->protocol = eth_type_trans(skb, ifp->ndev);
 
-	brcmf_fweh_process_skb(ifp->drvr, skb);
+	brcmf_fweh_process_skb(ifp->drvr, skb, 0);
 
 exit:
 	brcmu_pkt_buf_free_skb(skb);","{'deleted_lines': ['\tbrcmf_fweh_process_skb(ifp->drvr, skb);'], 'added_lines': ['\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);']}",True,"The Broadcom brcmfmac WiFi driver prior to commit a4176ec356c73a46c07c181c6d04039fafa34a9f is vulnerable to a frame validation bypass. If the brcmfmac driver receives a firmware event frame from a remote source, the is_wlc_event_frame function will cause this frame to be discarded and unprocessed. If the driver receives the firmware event frame from the host, the appropriate handler is called. This frame validation can be bypassed if the bus used is USB (for instance by a wifi dongle). This can allow firmware event frames from a remote source to be processed. In the worst case scenario, by sending specially-crafted WiFi packets, a remote, unauthenticated attacker may be able to execute arbitrary code on a vulnerable system. More typically, this vulnerability will result in denial-of-service conditions.",8.3,HIGH,2,valid,,5
CVE-2020-25643,['CWE-20'],AV:N/AC:M/Au:S/C:P/I:P/A:C,0,torvalds/linux,"There are a couple bugs here:
1) If opt[1] is zero then this results in a forever loop.  If the value
   is less than 2 then it is invalid.
2) It assumes that ""len"" is more than sizeof(valid_accm) or 6 which can
   result in memory corruption.

In the case of LCP_OPTION_ACCM, then  we should check ""opt[1]"" instead
of ""len"" because, if ""opt[1]"" is less than sizeof(valid_accm) then
""nak_len"" gets out of sync and it can lead to memory corruption in the
next iterations through the loop.  In case of LCP_OPTION_MAGIC, the
only valid value for opt[1] is 6, but the code is trying to log invalid
data so we should only discard the data when ""len"" is less than 6
because that leads to a read overflow.

Reported-by: ChenNan Of Chaitin Security Research Lab  <whutchennan@gmail.com>
Fixes: e022c2f07ae5 (""WAN: new synchronous PPP implementation for generic HDLC."")
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: David S. Miller <davem@davemloft.net>
",66d42ed8b25b64eb63111a2b8582c5afc8bf1105,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=66d42ed8b25b64eb63111a2b8582c5afc8bf1105,drivers/net/wan/hdlc_ppp.c,ppp_cp_parse_cr,"static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,
unsigned int req_len, const u8 *data)
{
static u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };
const u8 *opt;
u8 *out;
unsigned int len = req_len, nak_len = 0, rej_len = 0;
if (!(out = kmalloc(len, GFP_ATOMIC))) {
dev->stats.rx_dropped++;
return;
}
for (opt = data; len; len -= opt[1], opt += opt[1]) {
if (len < 2 || len < opt[1]) {
dev->stats.rx_errors++;
kfree(out);
return; 
}
if (pid == PID_LCP)
switch (opt[0]) {
case LCP_OPTION_MRU:
continue; 
case LCP_OPTION_ACCM: 
if (!memcmp(opt, valid_accm,
sizeof(valid_accm)))
continue;
if (!rej_len) { 
memcpy(out + nak_len, valid_accm,
sizeof(valid_accm));
nak_len += sizeof(valid_accm);
continue;
}
break;
case LCP_OPTION_MAGIC:
if (opt[1] != 6 || (!opt[2] && !opt[3] &&
!opt[4] && !opt[5]))
break; 
continue;
}
memcpy(out + rej_len, opt, opt[1]);
rej_len += opt[1];
}
if (rej_len)
ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);
else if (nak_len)
ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);
else
ppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);
kfree(out);
}","static void ppp_cp_parse_cr(struct net_device *VAR_0, u16 VAR_1, u8 VAR_2,
unsigned int VAR_3, const u8 *VAR_4)
{
static u8 const VAR_5[6] = { VAR_6, 6, 0, 0, 0, 0 };
const u8 *VAR_7;
u8 *VAR_8;
unsigned int VAR_9 = VAR_3, VAR_10 = 0, VAR_11 = 0;
if (!(VAR_8 = kmalloc(VAR_9, VAR_12))) {
VAR_0->stats.rx_dropped++;
return;
}
for (VAR_7 = VAR_4; VAR_9; VAR_9 -= VAR_7[1], VAR_7 += VAR_7[1]) {
if (VAR_9 < 2 || VAR_9 < VAR_7[1]) {
VAR_0->stats.rx_errors++;
kfree(VAR_8);
return; 
}
if (VAR_1 == VAR_13)
switch (VAR_7[0]) {
case VAR_14:
continue; 
case VAR_6: 
if (!memcmp(VAR_7, VAR_5,
sizeof(VAR_5)))
continue;
if (!VAR_11) { 
memcpy(VAR_8 + VAR_10, VAR_5,
sizeof(VAR_5));
VAR_10 += sizeof(VAR_5);
continue;
}
break;
case VAR_15:
if (VAR_7[1] != 6 || (!VAR_7[2] && !VAR_7[3] &&
!VAR_7[4] && !VAR_7[5]))
break; 
continue;
}
memcpy(VAR_8 + VAR_11, VAR_7, VAR_7[1]);
VAR_11 += VAR_7[1];
}
if (VAR_11)
ppp_cp_event(VAR_0, VAR_1, VAR_16, VAR_17, VAR_2, VAR_11, VAR_8);
else if (VAR_10)
ppp_cp_event(VAR_0, VAR_1, VAR_16, VAR_18, VAR_2, VAR_10, VAR_8);
else
ppp_cp_event(VAR_0, VAR_1, VAR_19, VAR_20, VAR_2, VAR_3, VAR_4);
kfree(VAR_8);
}",torvalds/linux/66d42ed8b25b64eb63111a2b8582c5afc8bf1105/hdlc_ppp.c/vul/before/0.json,"static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,
			    unsigned int req_len, const u8 *data)
{
	static u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };
	const u8 *opt;
	u8 *out;
	unsigned int len = req_len, nak_len = 0, rej_len = 0;

	if (!(out = kmalloc(len, GFP_ATOMIC))) {
		dev->stats.rx_dropped++;
		return;	/* out of memory, ignore CR packet */
	}

	for (opt = data; len; len -= opt[1], opt += opt[1]) {
		if (len < 2 || opt[1] < 2 || len < opt[1])
			goto err_out;

		if (pid == PID_LCP)
			switch (opt[0]) {
			case LCP_OPTION_MRU:
				continue; /* MRU always OK and > 1500 bytes? */

			case LCP_OPTION_ACCM: /* async control character map */
				if (opt[1] < sizeof(valid_accm))
					goto err_out;
				if (!memcmp(opt, valid_accm,
					    sizeof(valid_accm)))
					continue;
				if (!rej_len) { /* NAK it */
					memcpy(out + nak_len, valid_accm,
					       sizeof(valid_accm));
					nak_len += sizeof(valid_accm);
					continue;
				}
				break;
			case LCP_OPTION_MAGIC:
				if (len < 6)
					goto err_out;
				if (opt[1] != 6 || (!opt[2] && !opt[3] &&
						    !opt[4] && !opt[5]))
					break; /* reject invalid magic number */
				continue;
			}
		/* reject this option */
		memcpy(out + rej_len, opt, opt[1]);
		rej_len += opt[1];
	}

	if (rej_len)
		ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);
	else if (nak_len)
		ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);
	else
		ppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);

	kfree(out);
	return;

err_out:
	dev->stats.rx_errors++;
	kfree(out);
}","static void ppp_cp_parse_cr(struct net_device *VAR_0, u16 VAR_1, u8 VAR_2,
			    unsigned int VAR_3, const u8 *VAR_4)
{
	static u8 const VAR_5[6] = { VAR_6, 6, 0, 0, 0, 0 };
	const u8 *VAR_7;
	u8 *VAR_8;
	unsigned int VAR_9 = VAR_3, VAR_10 = 0, VAR_11 = 0;

	if (!(VAR_8 = kmalloc(VAR_9, VAR_12))) {
		VAR_0->stats.rx_dropped++;
		return;	/* COMMENT_0 */
	}

	for (VAR_7 = VAR_4; VAR_9; VAR_9 -= VAR_7[1], VAR_7 += VAR_7[1]) {
		if (VAR_9 < 2 || VAR_7[1] < 2 || VAR_9 < VAR_7[1])
			goto err_out;

		if (VAR_1 == VAR_13)
			switch (VAR_7[0]) {
			case VAR_14:
				continue; /* COMMENT_1 */

			case VAR_6: /* COMMENT_2 */
				if (VAR_7[1] < sizeof(VAR_5))
					goto err_out;
				if (!memcmp(VAR_7, VAR_5,
					    sizeof(VAR_5)))
					continue;
				if (!VAR_11) { /* COMMENT_3 */
					memcpy(VAR_8 + VAR_10, VAR_5,
					       sizeof(VAR_5));
					VAR_10 += sizeof(VAR_5);
					continue;
				}
				break;
			case VAR_15:
				if (VAR_9 < 6)
					goto err_out;
				if (VAR_7[1] != 6 || (!VAR_7[2] && !VAR_7[3] &&
						    !VAR_7[4] && !VAR_7[5]))
					break; /* COMMENT_4 */
				continue;
			}
		/* COMMENT_5 */
		memcpy(VAR_8 + VAR_11, VAR_7, VAR_7[1]);
		VAR_11 += VAR_7[1];
	}

	if (VAR_11)
		ppp_cp_event(VAR_0, VAR_1, VAR_16, VAR_17, VAR_2, VAR_11, VAR_8);
	else if (VAR_10)
		ppp_cp_event(VAR_0, VAR_1, VAR_16, VAR_18, VAR_2, VAR_10, VAR_8);
	else
		ppp_cp_event(VAR_0, VAR_1, VAR_19, VAR_20, VAR_2, VAR_3, VAR_4);

	kfree(VAR_8);
	return;

err_out:
	VAR_0->stats.rx_errors++;
	kfree(VAR_8);
}",torvalds/linux/66d42ed8b25b64eb63111a2b8582c5afc8bf1105/hdlc_ppp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,11 +12,8 @@
 	}
 
 	for (opt = data; len; len -= opt[1], opt += opt[1]) {
-		if (len < 2 || len < opt[1]) {
-			dev->stats.rx_errors++;
-			kfree(out);
-			return; /* bad packet, drop silently */
-		}
+		if (len < 2 || opt[1] < 2 || len < opt[1])
+			goto err_out;
 
 		if (pid == PID_LCP)
 			switch (opt[0]) {
@@ -24,6 +21,8 @@
 				continue; /* MRU always OK and > 1500 bytes? */
 
 			case LCP_OPTION_ACCM: /* async control character map */
+				if (opt[1] < sizeof(valid_accm))
+					goto err_out;
 				if (!memcmp(opt, valid_accm,
 					    sizeof(valid_accm)))
 					continue;
@@ -35,6 +34,8 @@
 				}
 				break;
 			case LCP_OPTION_MAGIC:
+				if (len < 6)
+					goto err_out;
 				if (opt[1] != 6 || (!opt[2] && !opt[3] &&
 						    !opt[4] && !opt[5]))
 					break; /* reject invalid magic number */
@@ -53,4 +54,9 @@
 		ppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);
 
 	kfree(out);
+	return;
+
+err_out:
+	dev->stats.rx_errors++;
+	kfree(out);
 }","{'deleted_lines': ['\t\tif (len < 2 || len < opt[1]) {', '\t\t\tdev->stats.rx_errors++;', '\t\t\tkfree(out);', '\t\t\treturn; /* bad packet, drop silently */', '\t\t}'], 'added_lines': ['\t\tif (len < 2 || opt[1] < 2 || len < opt[1])', '\t\t\tgoto err_out;', '\t\t\t\tif (opt[1] < sizeof(valid_accm))', '\t\t\t\t\tgoto err_out;', '\t\t\t\tif (len < 6)', '\t\t\t\t\tgoto err_out;', '\treturn;', '', 'err_out:', '\tdev->stats.rx_errors++;', '\tkfree(out);']}",True,A flaw was found in the HDLC_PPP module of the Linux kernel in versions before 5.9-rc7. Memory corruption and a read overflow is caused by improper input validation in the ppp_cp_parse_cr function which can cause the system to crash or cause a denial of service. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.,7.2,HIGH,2,valid,,5
CVE-2020-29372,['CWE-362'],AV:L/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"IORING_OP_MADVISE can end up basically doing mprotect() on the VM of
another process, which means that it can race with our crazy core dump
handling which accesses the VM state without holding the mmap_sem
(because it incorrectly thinks that it is the final user).

This is clearly a core dumping problem, but we've never fixed it the
right way, and instead have the notion of ""check that the mm is still
ok"" using mmget_still_valid() after getting the mmap_sem for writing in
any situation where we're not the original VM thread.

See commit 04f5866e41fb (""coredump: fix race condition between
mmget_not_zero()/get_task_mm() and core dumping"") for more background on
this whole mmget_still_valid() thing.  You might want to have a barf bag
handy when you do.

We're discussing just fixing this properly in the only remaining core
dumping routines.  But even if we do that, let's make do_madvise() do
the right thing, and then when we fix core dumping, we can remove all
these mmget_still_valid() checks.

Reported-and-tested-by: Jann Horn <jannh@google.com>
Fixes: c1ca757bd6f4 (""io_uring: add IORING_OP_MADVISE"")
Acked-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",bc0c4d1e176eeb614dc8734fc3ace34292771f11,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=bc0c4d1e176eeb614dc8734fc3ace34292771f11,mm/madvise.c,do_madvise,"int do_madvise(unsigned long start, size_t len_in, int behavior)
{
unsigned long end, tmp;
struct vm_area_struct *vma, *prev;
int unmapped_error = 0;
int error = -EINVAL;
int write;
size_t len;
struct blk_plug plug;
start = untagged_addr(start);
if (!madvise_behavior_valid(behavior))
return error;
if (!PAGE_ALIGNED(start))
return error;
len = PAGE_ALIGN(len_in);
if (len_in && !len)
return error;
end = start + len;
if (end < start)
return error;
error = 0;
if (end == start)
return error;
#ifdef CONFIG_MEMORY_FAILURE
if (behavior == MADV_HWPOISON || behavior == MADV_SOFT_OFFLINE)
return madvise_inject_error(behavior, start, start + len_in);
#endif
write = madvise_need_mmap_write(behavior);
if (write) {
if (down_write_killable(&current->mm->mmap_sem))
return -EINTR;
} else {
down_read(&current->mm->mmap_sem);
}
vma = find_vma_prev(current->mm, start, &prev);
if (vma && start > vma->vm_start)
prev = vma;
blk_start_plug(&plug);
for (;;) {
error = -ENOMEM;
if (!vma)
goto out;
if (start < vma->vm_start) {
unmapped_error = -ENOMEM;
start = vma->vm_start;
if (start >= end)
goto out;
}
tmp = vma->vm_end;
if (end < tmp)
tmp = end;
error = madvise_vma(vma, &prev, start, tmp, behavior);
if (error)
goto out;
start = tmp;
if (prev && start < prev->vm_end)
start = prev->vm_end;
error = unmapped_error;
if (start >= end)
goto out;
if (prev)
vma = prev->vm_next;
else
vma = find_vma(current->mm, start);
}
out:
blk_finish_plug(&plug);
if (write)
up_write(&current->mm->mmap_sem);
else
up_read(&current->mm->mmap_sem);
return error;
}","int do_madvise(unsigned long VAR_0, size_t VAR_1, int VAR_2)
{
unsigned long VAR_3, VAR_4;
struct vm_area_struct *VAR_5, *VAR_6;
int VAR_7 = 0;
int VAR_8 = -VAR_9;
int VAR_10;
size_t VAR_11;
struct blk_plug VAR_12;
VAR_0 = untagged_addr(VAR_0);
if (!madvise_behavior_valid(VAR_2))
return VAR_8;
if (!PAGE_ALIGNED(VAR_0))
return VAR_8;
VAR_11 = PAGE_ALIGN(VAR_1);
if (VAR_1 && !VAR_11)
return VAR_8;
VAR_3 = VAR_0 + VAR_11;
if (VAR_3 < VAR_0)
return VAR_8;
VAR_8 = 0;
if (VAR_3 == VAR_0)
return VAR_8;
#ifdef VAR_13
if (VAR_2 == VAR_14 || VAR_2 == VAR_15)
return madvise_inject_error(VAR_2, VAR_0, VAR_0 + VAR_1);
#endif
VAR_10 = madvise_need_mmap_write(VAR_2);
if (VAR_10) {
if (down_write_killable(&VAR_16->mm->mmap_sem))
return -VAR_17;
} else {
down_read(&VAR_16->mm->mmap_sem);
}
VAR_5 = find_vma_prev(VAR_16->mm, VAR_0, &VAR_6);
if (VAR_5 && VAR_0 > VAR_5->vm_start)
VAR_6 = VAR_5;
blk_start_plug(&VAR_12);
for (;;) {
VAR_8 = -VAR_18;
if (!VAR_5)
goto out;
if (VAR_0 < VAR_5->vm_start) {
VAR_7 = -VAR_18;
VAR_0 = VAR_5->vm_start;
if (VAR_0 >= VAR_3)
goto out;
}
VAR_4 = VAR_5->vm_end;
if (VAR_3 < VAR_4)
VAR_4 = VAR_3;
VAR_8 = madvise_vma(VAR_5, &VAR_6, VAR_0, VAR_4, VAR_2);
if (VAR_8)
goto out;
VAR_0 = VAR_4;
if (VAR_6 && VAR_0 < VAR_6->vm_end)
VAR_0 = VAR_6->vm_end;
VAR_8 = VAR_7;
if (VAR_0 >= VAR_3)
goto out;
if (VAR_6)
VAR_5 = VAR_6->vm_next;
else
VAR_5 = find_vma(VAR_16->mm, VAR_0);
}
out:
blk_finish_plug(&VAR_12);
if (VAR_10)
up_write(&VAR_16->mm->mmap_sem);
else
up_read(&VAR_16->mm->mmap_sem);
return VAR_8;
}",torvalds/linux/bc0c4d1e176eeb614dc8734fc3ace34292771f11/madvise.c/vul/before/0.json,"int do_madvise(unsigned long start, size_t len_in, int behavior)
{
	unsigned long end, tmp;
	struct vm_area_struct *vma, *prev;
	int unmapped_error = 0;
	int error = -EINVAL;
	int write;
	size_t len;
	struct blk_plug plug;

	start = untagged_addr(start);

	if (!madvise_behavior_valid(behavior))
		return error;

	if (!PAGE_ALIGNED(start))
		return error;
	len = PAGE_ALIGN(len_in);

	/* Check to see whether len was rounded up from small -ve to zero */
	if (len_in && !len)
		return error;

	end = start + len;
	if (end < start)
		return error;

	error = 0;
	if (end == start)
		return error;

#ifdef CONFIG_MEMORY_FAILURE
	if (behavior == MADV_HWPOISON || behavior == MADV_SOFT_OFFLINE)
		return madvise_inject_error(behavior, start, start + len_in);
#endif

	write = madvise_need_mmap_write(behavior);
	if (write) {
		if (down_write_killable(&current->mm->mmap_sem))
			return -EINTR;

		/*
		 * We may have stolen the mm from another process
		 * that is undergoing core dumping.
		 *
		 * Right now that's io_ring, in the future it may
		 * be remote process management and not ""current""
		 * at all.
		 *
		 * We need to fix core dumping to not do this,
		 * but for now we have the mmget_still_valid()
		 * model.
		 */
		if (!mmget_still_valid(current->mm)) {
			up_write(&current->mm->mmap_sem);
			return -EINTR;
		}
	} else {
		down_read(&current->mm->mmap_sem);
	}

	/*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - different from the way of handling in mlock etc.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
	if (vma && start > vma->vm_start)
		prev = vma;

	blk_start_plug(&plug);
	for (;;) {
		/* Still start < end. */
		error = -ENOMEM;
		if (!vma)
			goto out;

		/* Here start < (end|vma->vm_end). */
		if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
			if (start >= end)
				goto out;
		}

		/* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
		if (end < tmp)
			tmp = end;

		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = madvise_vma(vma, &prev, start, tmp, behavior);
		if (error)
			goto out;
		start = tmp;
		if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
		if (start >= end)
			goto out;
		if (prev)
			vma = prev->vm_next;
		else	/* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
	}
out:
	blk_finish_plug(&plug);
	if (write)
		up_write(&current->mm->mmap_sem);
	else
		up_read(&current->mm->mmap_sem);

	return error;
}","int do_madvise(unsigned long VAR_0, size_t VAR_1, int VAR_2)
{
	unsigned long VAR_3, VAR_4;
	struct vm_area_struct *VAR_5, *VAR_6;
	int VAR_7 = 0;
	int VAR_8 = -VAR_9;
	int VAR_10;
	size_t VAR_11;
	struct blk_plug VAR_12;

	VAR_0 = untagged_addr(VAR_0);

	if (!madvise_behavior_valid(VAR_2))
		return VAR_8;

	if (!PAGE_ALIGNED(VAR_0))
		return VAR_8;
	VAR_11 = PAGE_ALIGN(VAR_1);

	/* COMMENT_0 */
	if (VAR_1 && !VAR_11)
		return VAR_8;

	VAR_3 = VAR_0 + VAR_11;
	if (VAR_3 < VAR_0)
		return VAR_8;

	VAR_8 = 0;
	if (VAR_3 == VAR_0)
		return VAR_8;

#ifdef VAR_13
	if (VAR_2 == VAR_14 || VAR_2 == VAR_15)
		return madvise_inject_error(VAR_2, VAR_0, VAR_0 + VAR_1);
#endif

	VAR_10 = madvise_need_mmap_write(VAR_2);
	if (VAR_10) {
		if (down_write_killable(&VAR_16->mm->mmap_sem))
			return -VAR_17;

		/* COMMENT_1 */
                                                   
                                     
    
                                                   
                                                   
            
    
                                                
                                                
           
     
		if (!mmget_still_valid(VAR_16->mm)) {
			up_write(&VAR_16->mm->mmap_sem);
			return -VAR_17;
		}
	} else {
		down_read(&VAR_16->mm->mmap_sem);
	}

	/* COMMENT_12 */
                                                            
                                                            
                                                      
    
	VAR_5 = find_vma_prev(VAR_16->mm, VAR_0, &VAR_6);
	if (VAR_5 && VAR_0 > VAR_5->vm_start)
		VAR_6 = VAR_5;

	blk_start_plug(&VAR_12);
	for (;;) {
		/* COMMENT_17 */
		VAR_8 = -VAR_18;
		if (!VAR_5)
			goto out;

		/* COMMENT_18 */
		if (VAR_0 < VAR_5->vm_start) {
			VAR_7 = -VAR_18;
			VAR_0 = VAR_5->vm_start;
			if (VAR_0 >= VAR_3)
				goto out;
		}

		/* COMMENT_19 */
		VAR_4 = VAR_5->vm_end;
		if (VAR_3 < VAR_4)
			VAR_4 = VAR_3;

		/* COMMENT_20 */
		VAR_8 = madvise_vma(VAR_5, &VAR_6, VAR_0, VAR_4, VAR_2);
		if (VAR_8)
			goto out;
		VAR_0 = VAR_4;
		if (VAR_6 && VAR_0 < VAR_6->vm_end)
			VAR_0 = VAR_6->vm_end;
		VAR_8 = VAR_7;
		if (VAR_0 >= VAR_3)
			goto out;
		if (VAR_6)
			VAR_5 = VAR_6->vm_next;
		else	/* COMMENT_21 */
			VAR_5 = find_vma(VAR_16->mm, VAR_0);
	}
out:
	blk_finish_plug(&VAR_12);
	if (VAR_10)
		up_write(&VAR_16->mm->mmap_sem);
	else
		up_read(&VAR_16->mm->mmap_sem);

	return VAR_8;
}",torvalds/linux/bc0c4d1e176eeb614dc8734fc3ace34292771f11/madvise.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,6 +38,23 @@
 	if (write) {
 		if (down_write_killable(&current->mm->mmap_sem))
 			return -EINTR;
+
+		/*
+		 * We may have stolen the mm from another process
+		 * that is undergoing core dumping.
+		 *
+		 * Right now that's io_ring, in the future it may
+		 * be remote process management and not ""current""
+		 * at all.
+		 *
+		 * We need to fix core dumping to not do this,
+		 * but for now we have the mmget_still_valid()
+		 * model.
+		 */
+		if (!mmget_still_valid(current->mm)) {
+			up_write(&current->mm->mmap_sem);
+			return -EINTR;
+		}
 	} else {
 		down_read(&current->mm->mmap_sem);
 	}","{'deleted_lines': [], 'added_lines': ['', '\t\t/*', '\t\t * We may have stolen the mm from another process', '\t\t * that is undergoing core dumping.', '\t\t *', ""\t\t * Right now that's io_ring, in the future it may"", '\t\t * be remote process management and not ""current""', '\t\t * at all.', '\t\t *', '\t\t * We need to fix core dumping to not do this,', '\t\t * but for now we have the mmget_still_valid()', '\t\t * model.', '\t\t */', '\t\tif (!mmget_still_valid(current->mm)) {', '\t\t\tup_write(&current->mm->mmap_sem);', '\t\t\treturn -EINTR;', '\t\t}']}",True,"An issue was discovered in do_madvise in mm/madvise.c in the Linux kernel before 5.6.8. There is a race condition between coredump operations and the IORING_OP_MADVISE implementation, aka CID-bc0c4d1e176e.",4.7,MEDIUM,1,valid,,5
CVE-2020-29373,['CWE-22'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"This passes it in to io-wq, so it assumes the right fs_struct when
executing async work that may need to do lookups.

Cc: stable@vger.kernel.org # 5.3+
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",ff002b30181d30cdfbca316dadd099c3ca0d739c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ff002b30181d30cdfbca316dadd099c3ca0d739c,fs/io_uring.c,io_req_work_drop_env,"static inline void io_req_work_drop_env(struct io_kiocb *req)
{
if (req->work.mm) {
mmdrop(req->work.mm);
req->work.mm = NULL;
}
if (req->work.creds) {
put_cred(req->work.creds);
req->work.creds = NULL;
}
}","static inline void io_req_work_drop_env(struct io_kiocb *VAR_0)
{
if (VAR_0->work.mm) {
mmdrop(VAR_0->work.mm);
VAR_0->work.mm = NULL;
}
if (VAR_0->work.creds) {
put_cred(VAR_0->work.creds);
VAR_0->work.creds = NULL;
}
}",torvalds/linux/ff002b30181d30cdfbca316dadd099c3ca0d739c/io_uring.c/vul/before/0.json,"static inline void io_req_work_drop_env(struct io_kiocb *req)
{
	if (req->work.mm) {
		mmdrop(req->work.mm);
		req->work.mm = NULL;
	}
	if (req->work.creds) {
		put_cred(req->work.creds);
		req->work.creds = NULL;
	}
	if (req->work.fs) {
		struct fs_struct *fs = req->work.fs;

		spin_lock(&req->work.fs->lock);
		if (--fs->users)
			fs = NULL;
		spin_unlock(&req->work.fs->lock);
		if (fs)
			free_fs_struct(fs);
	}
}","static inline void io_req_work_drop_env(struct io_kiocb *VAR_0)
{
	if (VAR_0->work.mm) {
		mmdrop(VAR_0->work.mm);
		VAR_0->work.mm = NULL;
	}
	if (VAR_0->work.creds) {
		put_cred(VAR_0->work.creds);
		VAR_0->work.creds = NULL;
	}
	if (VAR_0->work.fs) {
		struct fs_struct *VAR_1 = VAR_0->work.fs;

		spin_lock(&VAR_0->work.fs->lock);
		if (--VAR_1->users)
			VAR_1 = NULL;
		spin_unlock(&VAR_0->work.fs->lock);
		if (VAR_1)
			free_fs_struct(VAR_1);
	}
}",torvalds/linux/ff002b30181d30cdfbca316dadd099c3ca0d739c/io_uring.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,4 +8,14 @@
 		put_cred(req->work.creds);
 		req->work.creds = NULL;
 	}
+	if (req->work.fs) {
+		struct fs_struct *fs = req->work.fs;
+
+		spin_lock(&req->work.fs->lock);
+		if (--fs->users)
+			fs = NULL;
+		spin_unlock(&req->work.fs->lock);
+		if (fs)
+			free_fs_struct(fs);
+	}
 }","{'deleted_lines': [], 'added_lines': ['\tif (req->work.fs) {', '\t\tstruct fs_struct *fs = req->work.fs;', '', '\t\tspin_lock(&req->work.fs->lock);', '\t\tif (--fs->users)', '\t\t\tfs = NULL;', '\t\tspin_unlock(&req->work.fs->lock);', '\t\tif (fs)', '\t\t\tfree_fs_struct(fs);', '\t}']}",True,"An issue was discovered in fs/io_uring.c in the Linux kernel before 5.6. It unsafely handles the root directory during path lookups, and thus a process inside a mount namespace can escape to unintended filesystem locations, aka CID-ff002b30181d.",6.5,MEDIUM,1,valid,,5
CVE-2020-29373,['CWE-22'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"This passes it in to io-wq, so it assumes the right fs_struct when
executing async work that may need to do lookups.

Cc: stable@vger.kernel.org # 5.3+
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",ff002b30181d30cdfbca316dadd099c3ca0d739c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ff002b30181d30cdfbca316dadd099c3ca0d739c,fs/io_uring.c,io_req_work_grab_env,"static inline void io_req_work_grab_env(struct io_kiocb *req,
const struct io_op_def *def)
{
if (!req->work.mm && def->needs_mm) {
mmgrab(current->mm);
req->work.mm = current->mm;
}
if (!req->work.creds)
req->work.creds = get_current_cred();
}","static inline void io_req_work_grab_env(struct io_kiocb *VAR_0,
const struct io_op_def *VAR_1)
{
if (!VAR_0->work.mm && VAR_1->needs_mm) {
mmgrab(VAR_2->mm);
VAR_0->work.mm = VAR_2->mm;
}
if (!VAR_0->work.creds)
VAR_0->work.creds = get_current_cred();
}",torvalds/linux/ff002b30181d30cdfbca316dadd099c3ca0d739c/io_uring.c/vul/before/1.json,"static inline void io_req_work_grab_env(struct io_kiocb *req,
					const struct io_op_def *def)
{
	if (!req->work.mm && def->needs_mm) {
		mmgrab(current->mm);
		req->work.mm = current->mm;
	}
	if (!req->work.creds)
		req->work.creds = get_current_cred();
	if (!req->work.fs && def->needs_fs) {
		spin_lock(&current->fs->lock);
		if (!current->fs->in_exec) {
			req->work.fs = current->fs;
			req->work.fs->users++;
		} else {
			req->work.flags |= IO_WQ_WORK_CANCEL;
		}
		spin_unlock(&current->fs->lock);
	}
}","static inline void io_req_work_grab_env(struct io_kiocb *VAR_0,
					const struct io_op_def *VAR_1)
{
	if (!VAR_0->work.mm && VAR_1->needs_mm) {
		mmgrab(VAR_2->mm);
		VAR_0->work.mm = VAR_2->mm;
	}
	if (!VAR_0->work.creds)
		VAR_0->work.creds = get_current_cred();
	if (!VAR_0->work.fs && VAR_1->needs_fs) {
		spin_lock(&VAR_2->fs->lock);
		if (!VAR_2->fs->in_exec) {
			VAR_0->work.fs = VAR_2->fs;
			VAR_0->work.fs->users++;
		} else {
			VAR_0->work.flags |= VAR_3;
		}
		spin_unlock(&VAR_2->fs->lock);
	}
}",torvalds/linux/ff002b30181d30cdfbca316dadd099c3ca0d739c/io_uring.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,4 +7,14 @@
 	}
 	if (!req->work.creds)
 		req->work.creds = get_current_cred();
+	if (!req->work.fs && def->needs_fs) {
+		spin_lock(&current->fs->lock);
+		if (!current->fs->in_exec) {
+			req->work.fs = current->fs;
+			req->work.fs->users++;
+		} else {
+			req->work.flags |= IO_WQ_WORK_CANCEL;
+		}
+		spin_unlock(&current->fs->lock);
+	}
 }","{'deleted_lines': [], 'added_lines': ['\tif (!req->work.fs && def->needs_fs) {', '\t\tspin_lock(&current->fs->lock);', '\t\tif (!current->fs->in_exec) {', '\t\t\treq->work.fs = current->fs;', '\t\t\treq->work.fs->users++;', '\t\t} else {', '\t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;', '\t\t}', '\t\tspin_unlock(&current->fs->lock);', '\t}']}",True,"An issue was discovered in fs/io_uring.c in the Linux kernel before 5.6. It unsafely handles the root directory during path lookups, and thus a process inside a mount namespace can escape to unintended filesystem locations, aka CID-ff002b30181d.",6.5,MEDIUM,1,valid,,5
CVE-2020-25704,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"As shown through runtime testing, the ""filename"" allocation is not
always freed in perf_event_parse_addr_filter().

There are three possible ways that this could happen:

 - It could be allocated twice on subsequent iterations through the loop,
 - or leaked on the success path,
 - or on the failure path.

Clean up the code flow to make it obvious that 'filename' is always
freed in the reallocation path and in the two return paths as well.

We rely on the fact that kfree(NULL) is NOP and filename is initialized
with NULL.

This fixes the leak. No other side effects expected.

[ Dan Carpenter: cleaned up the code flow & added a changelog. ]
[ Ingo Molnar: updated the changelog some more. ]

Fixes: 375637bc5249 (""perf/core: Introduce address range filtering"")
Signed-off-by: ""kiyin()"" <kiyin@tencent.com>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Cc: ""Srivatsa S. Bhat"" <srivatsa@csail.mit.edu>
Cc: Anthony Liguori <aliguori@amazon.com>
--
 kernel/events/core.c | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)
",7bdb157cdebbf95a1cd94ed2e01b338714075d00,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=7bdb157cdebbf95a1cd94ed2e01b338714075d00,kernel/events/core.c,perf_event_parse_addr_filter,"static int
perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
struct list_head *filters)
{
struct perf_addr_filter *filter = NULL;
char *start, *orig, *filename = NULL;
substring_t args[MAX_OPT_ARGS];
int state = IF_STATE_ACTION, token;
unsigned int kernel = 0;
int ret = -EINVAL;
orig = fstr = kstrdup(fstr, GFP_KERNEL);
if (!fstr)
return -ENOMEM;
while ((start = strsep(&fstr, "" ,\n"")) != NULL) {
static const enum perf_addr_filter_action_t actions[] = {
[IF_ACT_FILTER]= PERF_ADDR_FILTER_ACTION_FILTER,
[IF_ACT_START]= PERF_ADDR_FILTER_ACTION_START,
[IF_ACT_STOP]= PERF_ADDR_FILTER_ACTION_STOP,
};
ret = -EINVAL;
if (!*start)
continue;
if (state == IF_STATE_ACTION) {
filter = perf_addr_filter_new(event, filters);
if (!filter)
goto fail;
}
token = match_token(start, if_tokens, args);
switch (token) {
case IF_ACT_FILTER:
case IF_ACT_START:
case IF_ACT_STOP:
if (state != IF_STATE_ACTION)
goto fail;
filter->action = actions[token];
state = IF_STATE_SOURCE;
break;
case IF_SRC_KERNELADDR:
case IF_SRC_KERNEL:
kernel = 1;
fallthrough;
case IF_SRC_FILEADDR:
case IF_SRC_FILE:
if (state != IF_STATE_SOURCE)
goto fail;
*args[0].to = 0;
ret = kstrtoul(args[0].from, 0, &filter->offset);
if (ret)
goto fail;
if (token == IF_SRC_KERNEL || token == IF_SRC_FILE) {
*args[1].to = 0;
ret = kstrtoul(args[1].from, 0, &filter->size);
if (ret)
goto fail;
}
if (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {
int fpos = token == IF_SRC_FILE ? 2 : 1;
filename = match_strdup(&args[fpos]);
if (!filename) {
ret = -ENOMEM;
goto fail;
}
}
state = IF_STATE_END;
break;
default:
goto fail;
}
if (state == IF_STATE_END) {
ret = -EINVAL;
if (kernel && event->attr.exclude_kernel)
goto fail;
if (filter->action == PERF_ADDR_FILTER_ACTION_FILTER &&
!filter->size)
goto fail;
if (!kernel) {
if (!filename)
goto fail;
ret = -EOPNOTSUPP;
if (!event->ctx->task)
goto fail_free_name;
ret = kern_path(filename, LOOKUP_FOLLOW,
&filter->path);
if (ret)
goto fail_free_name;
kfree(filename);
filename = NULL;
ret = -EINVAL;
if (!filter->path.dentry ||
!S_ISREG(d_inode(filter->path.dentry)
->i_mode))
goto fail;
event->addr_filters.nr_file_filters++;
}
state = IF_STATE_ACTION;
filter = NULL;
}
}
if (state != IF_STATE_ACTION)
goto fail;
kfree(orig);
return 0;
fail_free_name:
kfree(filename);
fail:
free_filters_list(filters);
kfree(orig);
return ret;
}","static int
perf_event_parse_addr_filter(struct perf_event *VAR_0, char *VAR_1,
struct list_head *VAR_2)
{
struct perf_addr_filter *VAR_3 = NULL;
char *VAR_4, *VAR_5, *VAR_6 = NULL;
substring_t VAR_7[VAR_8];
int VAR_9 = VAR_10, VAR_11;
unsigned int VAR_12 = 0;
int VAR_13 = -VAR_14;
VAR_5 = VAR_1 = kstrdup(VAR_1, VAR_15);
if (!VAR_1)
return -VAR_16;
while ((VAR_4 = strsep(&VAR_1, "" ,\n"")) != NULL) {
static const enum perf_addr_filter_action_t VAR_17[] = {
[VAR_18]= VAR_19,
[VAR_20]= VAR_21,
[VAR_22]= VAR_23,
};
VAR_13 = -VAR_14;
if (!*VAR_4)
continue;
if (VAR_9 == VAR_10) {
VAR_3 = perf_addr_filter_new(VAR_0, VAR_2);
if (!VAR_3)
goto fail;
}
VAR_11 = match_token(VAR_4, VAR_24, VAR_7);
switch (VAR_11) {
case VAR_18:
case VAR_20:
case VAR_22:
if (VAR_9 != VAR_10)
goto fail;
VAR_3->action = VAR_17[VAR_11];
VAR_9 = VAR_25;
break;
case VAR_26:
case VAR_27:
VAR_12 = 1;
VAR_28;
case VAR_29:
case VAR_30:
if (VAR_9 != VAR_25)
goto fail;
*VAR_7[0].to = 0;
VAR_13 = kstrtoul(VAR_7[0].from, 0, &VAR_3->offset);
if (VAR_13)
goto fail;
if (VAR_11 == VAR_27 || VAR_11 == VAR_30) {
*VAR_7[1].to = 0;
VAR_13 = kstrtoul(VAR_7[1].from, 0, &VAR_3->size);
if (VAR_13)
goto fail;
}
if (VAR_11 == VAR_30 || VAR_11 == VAR_29) {
int VAR_31 = VAR_11 == VAR_30 ? 2 : 1;
VAR_6 = match_strdup(&VAR_7[VAR_31]);
if (!VAR_6) {
VAR_13 = -VAR_16;
goto fail;
}
}
VAR_9 = VAR_32;
break;
default:
goto fail;
}
if (VAR_9 == VAR_32) {
VAR_13 = -VAR_14;
if (VAR_12 && VAR_0->attr.exclude_kernel)
goto fail;
if (VAR_3->action == VAR_19 &&
!VAR_3->size)
goto fail;
if (!VAR_12) {
if (!VAR_6)
goto fail;
VAR_13 = -VAR_33;
if (!VAR_0->ctx->task)
goto fail_free_name;
VAR_13 = kern_path(VAR_6, VAR_34,
&VAR_3->path);
if (VAR_13)
goto fail_free_name;
kfree(VAR_6);
VAR_6 = NULL;
VAR_13 = -VAR_14;
if (!VAR_3->path.dentry ||
!S_ISREG(d_inode(VAR_3->path.dentry)
->i_mode))
goto fail;
VAR_0->addr_filters.nr_file_filters++;
}
VAR_9 = VAR_10;
VAR_3 = NULL;
}
}
if (VAR_9 != VAR_10)
goto fail;
kfree(VAR_5);
return 0;
fail_free_name:
kfree(VAR_6);
fail:
free_filters_list(VAR_2);
kfree(VAR_5);
return VAR_13;
}",torvalds/linux/7bdb157cdebbf95a1cd94ed2e01b338714075d00/core.c/vul/before/0.json,"static int
perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
			     struct list_head *filters)
{
	struct perf_addr_filter *filter = NULL;
	char *start, *orig, *filename = NULL;
	substring_t args[MAX_OPT_ARGS];
	int state = IF_STATE_ACTION, token;
	unsigned int kernel = 0;
	int ret = -EINVAL;

	orig = fstr = kstrdup(fstr, GFP_KERNEL);
	if (!fstr)
		return -ENOMEM;

	while ((start = strsep(&fstr, "" ,\n"")) != NULL) {
		static const enum perf_addr_filter_action_t actions[] = {
			[IF_ACT_FILTER]	= PERF_ADDR_FILTER_ACTION_FILTER,
			[IF_ACT_START]	= PERF_ADDR_FILTER_ACTION_START,
			[IF_ACT_STOP]	= PERF_ADDR_FILTER_ACTION_STOP,
		};
		ret = -EINVAL;

		if (!*start)
			continue;

		/* filter definition begins */
		if (state == IF_STATE_ACTION) {
			filter = perf_addr_filter_new(event, filters);
			if (!filter)
				goto fail;
		}

		token = match_token(start, if_tokens, args);
		switch (token) {
		case IF_ACT_FILTER:
		case IF_ACT_START:
		case IF_ACT_STOP:
			if (state != IF_STATE_ACTION)
				goto fail;

			filter->action = actions[token];
			state = IF_STATE_SOURCE;
			break;

		case IF_SRC_KERNELADDR:
		case IF_SRC_KERNEL:
			kernel = 1;
			fallthrough;

		case IF_SRC_FILEADDR:
		case IF_SRC_FILE:
			if (state != IF_STATE_SOURCE)
				goto fail;

			*args[0].to = 0;
			ret = kstrtoul(args[0].from, 0, &filter->offset);
			if (ret)
				goto fail;

			if (token == IF_SRC_KERNEL || token == IF_SRC_FILE) {
				*args[1].to = 0;
				ret = kstrtoul(args[1].from, 0, &filter->size);
				if (ret)
					goto fail;
			}

			if (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {
				int fpos = token == IF_SRC_FILE ? 2 : 1;

				kfree(filename);
				filename = match_strdup(&args[fpos]);
				if (!filename) {
					ret = -ENOMEM;
					goto fail;
				}
			}

			state = IF_STATE_END;
			break;

		default:
			goto fail;
		}

		/*
		 * Filter definition is fully parsed, validate and install it.
		 * Make sure that it doesn't contradict itself or the event's
		 * attribute.
		 */
		if (state == IF_STATE_END) {
			ret = -EINVAL;
			if (kernel && event->attr.exclude_kernel)
				goto fail;

			/*
			 * ACTION ""filter"" must have a non-zero length region
			 * specified.
			 */
			if (filter->action == PERF_ADDR_FILTER_ACTION_FILTER &&
			    !filter->size)
				goto fail;

			if (!kernel) {
				if (!filename)
					goto fail;

				/*
				 * For now, we only support file-based filters
				 * in per-task events; doing so for CPU-wide
				 * events requires additional context switching
				 * trickery, since same object code will be
				 * mapped at different virtual addresses in
				 * different processes.
				 */
				ret = -EOPNOTSUPP;
				if (!event->ctx->task)
					goto fail;

				/* look up the path and grab its inode */
				ret = kern_path(filename, LOOKUP_FOLLOW,
						&filter->path);
				if (ret)
					goto fail;

				ret = -EINVAL;
				if (!filter->path.dentry ||
				    !S_ISREG(d_inode(filter->path.dentry)
					     ->i_mode))
					goto fail;

				event->addr_filters.nr_file_filters++;
			}

			/* ready to consume more filters */
			state = IF_STATE_ACTION;
			filter = NULL;
		}
	}

	if (state != IF_STATE_ACTION)
		goto fail;

	kfree(filename);
	kfree(orig);

	return 0;

fail:
	kfree(filename);
	free_filters_list(filters);
	kfree(orig);

	return ret;
}","static int
perf_event_parse_addr_filter(struct perf_event *VAR_0, char *VAR_1,
			     struct list_head *VAR_2)
{
	struct perf_addr_filter *VAR_3 = NULL;
	char *VAR_4, *VAR_5, *VAR_6 = NULL;
	substring_t VAR_7[VAR_8];
	int VAR_9 = VAR_10, VAR_11;
	unsigned int VAR_12 = 0;
	int VAR_13 = -VAR_14;

	VAR_5 = VAR_1 = kstrdup(VAR_1, VAR_15);
	if (!VAR_1)
		return -VAR_16;

	while ((VAR_4 = strsep(&VAR_1, "" ,\n"")) != NULL) {
		static const enum perf_addr_filter_action_t VAR_17[] = {
			[VAR_18]	= VAR_19,
			[VAR_20]	= VAR_21,
			[VAR_22]	= VAR_23,
		};
		VAR_13 = -VAR_14;

		if (!*VAR_4)
			continue;

		/* COMMENT_0 */
		if (VAR_9 == VAR_10) {
			VAR_3 = perf_addr_filter_new(VAR_0, VAR_2);
			if (!VAR_3)
				goto fail;
		}

		VAR_11 = match_token(VAR_4, VAR_24, VAR_7);
		switch (VAR_11) {
		case VAR_18:
		case VAR_20:
		case VAR_22:
			if (VAR_9 != VAR_10)
				goto fail;

			VAR_3->action = VAR_17[VAR_11];
			VAR_9 = VAR_25;
			break;

		case VAR_26:
		case VAR_27:
			VAR_12 = 1;
			VAR_28;

		case VAR_29:
		case VAR_30:
			if (VAR_9 != VAR_25)
				goto fail;

			*VAR_7[0].to = 0;
			VAR_13 = kstrtoul(VAR_7[0].from, 0, &VAR_3->offset);
			if (VAR_13)
				goto fail;

			if (VAR_11 == VAR_27 || VAR_11 == VAR_30) {
				*VAR_7[1].to = 0;
				VAR_13 = kstrtoul(VAR_7[1].from, 0, &VAR_3->size);
				if (VAR_13)
					goto fail;
			}

			if (VAR_11 == VAR_30 || VAR_11 == VAR_29) {
				int VAR_31 = VAR_11 == VAR_30 ? 2 : 1;

				kfree(VAR_6);
				VAR_6 = match_strdup(&VAR_7[VAR_31]);
				if (!VAR_6) {
					VAR_13 = -VAR_16;
					goto fail;
				}
			}

			VAR_9 = VAR_32;
			break;

		default:
			goto fail;
		}

		/* COMMENT_1 */
                                                                
                                                               
               
     
		if (VAR_9 == VAR_32) {
			VAR_13 = -VAR_14;
			if (VAR_12 && VAR_0->attr.exclude_kernel)
				goto fail;

			/* COMMENT_6 */
                                                        
                
      
			if (VAR_3->action == VAR_19 &&
			    !VAR_3->size)
				goto fail;

			if (!VAR_12) {
				if (!VAR_6)
					goto fail;

				/* COMMENT_10 */
                                                  
                                                
                                                   
                                               
                                               
                           
       
				VAR_13 = -VAR_33;
				if (!VAR_0->ctx->task)
					goto fail;

				/* COMMENT_18 */
				VAR_13 = kern_path(VAR_6, VAR_34,
						&VAR_3->path);
				if (VAR_13)
					goto fail;

				VAR_13 = -VAR_14;
				if (!VAR_3->path.dentry ||
				    !S_ISREG(d_inode(VAR_3->path.dentry)
					     ->i_mode))
					goto fail;

				VAR_0->addr_filters.nr_file_filters++;
			}

			/* COMMENT_19 */
			VAR_9 = VAR_10;
			VAR_3 = NULL;
		}
	}

	if (VAR_9 != VAR_10)
		goto fail;

	kfree(VAR_6);
	kfree(VAR_5);

	return 0;

fail:
	kfree(VAR_6);
	free_filters_list(VAR_2);
	kfree(VAR_5);

	return VAR_13;
}",torvalds/linux/7bdb157cdebbf95a1cd94ed2e01b338714075d00/core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -68,6 +68,7 @@
 			if (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {
 				int fpos = token == IF_SRC_FILE ? 2 : 1;
 
+				kfree(filename);
 				filename = match_strdup(&args[fpos]);
 				if (!filename) {
 					ret = -ENOMEM;
@@ -114,16 +115,13 @@
 				 */
 				ret = -EOPNOTSUPP;
 				if (!event->ctx->task)
-					goto fail_free_name;
+					goto fail;
 
 				/* look up the path and grab its inode */
 				ret = kern_path(filename, LOOKUP_FOLLOW,
 						&filter->path);
 				if (ret)
-					goto fail_free_name;
-
-				kfree(filename);
-				filename = NULL;
+					goto fail;
 
 				ret = -EINVAL;
 				if (!filter->path.dentry ||
@@ -143,13 +141,13 @@
 	if (state != IF_STATE_ACTION)
 		goto fail;
 
+	kfree(filename);
 	kfree(orig);
 
 	return 0;
 
-fail_free_name:
+fail:
 	kfree(filename);
-fail:
 	free_filters_list(filters);
 	kfree(orig);
 ","{'deleted_lines': ['\t\t\t\t\tgoto fail_free_name;', '\t\t\t\t\tgoto fail_free_name;', '', '\t\t\t\tkfree(filename);', '\t\t\t\tfilename = NULL;', 'fail_free_name:', 'fail:'], 'added_lines': ['\t\t\t\tkfree(filename);', '\t\t\t\t\tgoto fail;', '\t\t\t\t\tgoto fail;', '\tkfree(filename);', 'fail:']}",True,A flaw memory leak in the Linux kernel performance monitoring subsystem was found in the way if using PERF_EVENT_IOC_SET_FILTER. A local user could use this flaw to starve the resources causing denial of service.,5.5,MEDIUM,1,valid,,5
CVE-2020-16591,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
PR25822, Invalid read in process_symbol_table

	PR 25822
	* readelf.c (get_num_dynamic_syms): Don't set num_of_syms when
	reading buckets or chains fails.
",001890e1f9269697f7e0212430a51479271bdab2,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=001890e1f9269697f7e0212430a51479271bdab2,binutils/readelf.c,get_num_dynamic_syms,"static unsigned long
get_num_dynamic_syms (Filedata * filedata)
{
unsigned long num_of_syms = 0;
if (!do_histogram && (!do_using_dynamic || do_dyn_syms))
return num_of_syms;
if (dynamic_info[DT_HASH])
{
unsigned char nb[8];
unsigned char nc[8];
unsigned int hash_ent_size = 4;
if ((filedata->file_header.e_machine == EM_ALPHA
|| filedata->file_header.e_machine == EM_S390
|| filedata->file_header.e_machine == EM_S390_OLD)
&& filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)
hash_ent_size = 8;
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, dynamic_info[DT_HASH],
sizeof nb + sizeof nc)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
goto no_hash;
}
if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)
{
error (_(""Failed to read in number of buckets\n""));
goto no_hash;
}
if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)
{
error (_(""Failed to read in number of chains\n""));
goto no_hash;
}
nbuckets = byte_get (nb, hash_ent_size);
nchains = byte_get (nc, hash_ent_size);
num_of_syms = nchains;
buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);
chains  = get_dynamic_data (filedata, nchains, hash_ent_size);
no_hash:
if (num_of_syms == 0)
{
if (buckets)
{
free (buckets);
buckets = NULL;
}
if (chains)
{
free (chains);
chains = NULL;
}
nbuckets = 0;
}
}
if (dynamic_info_DT_GNU_HASH)
{
unsigned char nb[16];
bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
bfd_vma buckets_vma;
unsigned long hn;
bfd_boolean gnu_hash_error = FALSE;
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,
sizeof nb)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
if (fread (nb, 16, 1, filedata->handle) != 1)
{
error (_(""Failed to read in number of buckets\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
ngnubuckets = byte_get (nb, 4);
gnusymidx = byte_get (nb + 4, 4);
bitmaskwords = byte_get (nb + 8, 4);
buckets_vma = dynamic_info_DT_GNU_HASH + 16;
if (is_32bit_elf)
buckets_vma += bitmaskwords * 4;
else
buckets_vma += bitmaskwords * 8;
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, buckets_vma, 4)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);
if (gnubuckets == NULL)
{
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
for (i = 0; i < ngnubuckets; i++)
if (gnubuckets[i] != 0)
{
if (gnubuckets[i] < gnusymidx)
{
gnu_hash_error = TRUE;
return FALSE;
}
if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
maxchain = gnubuckets[i];
}
if (maxchain == 0xffffffff)
{
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
maxchain -= gnusymidx;
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, buckets_vma
+ 4 * (ngnubuckets + maxchain), 4)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
do
{
if (fread (nb, 4, 1, filedata->handle) != 1)
{
error (_(""Failed to determine last chain length\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
if (maxchain + 1 == 0)
{
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
++maxchain;
}
while ((byte_get (nb, 4) & 1) == 0);
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
gnuchains = get_dynamic_data (filedata, maxchain, 4);
ngnuchains = maxchain;
if (gnuchains == NULL)
{
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
if (dynamic_info_DT_MIPS_XHASH)
{
if (fseek (filedata->handle,
(archive_file_offset
+ offset_from_vma (filedata, (buckets_vma
+ 4 * (ngnubuckets
+ maxchain)), 4)),
SEEK_SET))
{
error (_(""Unable to seek to start of dynamic information\n""));
gnu_hash_error = TRUE;
goto no_gnu_hash;
}
mipsxlat = get_dynamic_data (filedata, maxchain, 4);
}
for (hn = 0; hn < ngnubuckets; ++hn)
if (gnubuckets[hn] != 0)
{
bfd_vma si = gnubuckets[hn];
bfd_vma off = si - gnusymidx;
do
{
if (dynamic_info_DT_MIPS_XHASH)
{
if (mipsxlat[off] >= num_of_syms)
num_of_syms = mipsxlat[off] + 1;
}
else
{
if (si >= num_of_syms)
num_of_syms = si + 1;
}
si++;
}
while (off < ngnuchains && (gnuchains[off++] & 1) == 0);
}
no_gnu_hash:
if (gnu_hash_error)
{
if (mipsxlat)
{
free (mipsxlat);
mipsxlat = NULL;
}
if (gnuchains)
{
free (gnuchains);
gnuchains = NULL;
}
if (gnubuckets)
{
free (gnubuckets);
gnubuckets = NULL;
}
ngnubuckets = 0;
ngnuchains = 0;
}
}
return num_of_syms;
}","static unsigned long
get_num_dynamic_syms (Filedata * VAR_0)
{
unsigned long VAR_1 = 0;
if (!VAR_2 && (!VAR_3 || VAR_4))
return VAR_1;
if (VAR_5[VAR_6])
{
unsigned char VAR_7[8];
unsigned char VAR_8[8];
unsigned int VAR_9 = 4;
if ((VAR_0->file_header.e_machine == VAR_10
|| VAR_0->file_header.e_machine == VAR_11
|| VAR_0->file_header.e_machine == VAR_12)
&& VAR_0->file_header.e_ident[VAR_13] == VAR_14)
VAR_9 = 8;
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, VAR_5[VAR_6],
sizeof VAR_7 + sizeof VAR_8)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
goto no_hash;
}
if (fread (VAR_7, VAR_9, 1, VAR_0->handle) != 1)
{
error (_(""Failed to read in number of buckets\n""));
goto no_hash;
}
if (fread (VAR_8, VAR_9, 1, VAR_0->handle) != 1)
{
error (_(""Failed to read in number of chains\n""));
goto no_hash;
}
VAR_17 = byte_get (VAR_7, VAR_9);
VAR_18 = byte_get (VAR_8, VAR_9);
VAR_1 = VAR_18;
VAR_19 = get_dynamic_data (VAR_0, VAR_17, VAR_9);
VAR_20  = get_dynamic_data (VAR_0, VAR_18, VAR_9);
no_hash:
if (VAR_1 == 0)
{
if (VAR_19)
{
free (VAR_19);
VAR_19 = NULL;
}
if (VAR_20)
{
free (VAR_20);
VAR_20 = NULL;
}
VAR_17 = 0;
}
}
if (VAR_21)
{
unsigned char VAR_7[16];
bfd_vma VAR_22, VAR_23 = 0xffffffff, VAR_24;
bfd_vma VAR_25;
unsigned long VAR_26;
bfd_boolean VAR_27 = FALSE;
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, VAR_21,
sizeof VAR_7)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
if (fread (VAR_7, 16, 1, VAR_0->handle) != 1)
{
error (_(""Failed to read in number of buckets\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
VAR_28 = byte_get (VAR_7, 4);
VAR_29 = byte_get (VAR_7 + 4, 4);
VAR_24 = byte_get (VAR_7 + 8, 4);
VAR_25 = VAR_21 + 16;
if (VAR_30)
VAR_25 += VAR_24 * 4;
else
VAR_25 += VAR_24 * 8;
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, VAR_25, 4)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
VAR_31 = get_dynamic_data (VAR_0, VAR_28, 4);
if (VAR_31 == NULL)
{
VAR_27 = TRUE;
goto no_gnu_hash;
}
for (VAR_22 = 0; VAR_22 < VAR_28; VAR_22++)
if (VAR_31[VAR_22] != 0)
{
if (VAR_31[VAR_22] < VAR_29)
{
VAR_27 = TRUE;
return FALSE;
}
if (VAR_23 == 0xffffffff || VAR_31[VAR_22] > VAR_23)
VAR_23 = VAR_31[VAR_22];
}
if (VAR_23 == 0xffffffff)
{
VAR_27 = TRUE;
goto no_gnu_hash;
}
VAR_23 -= VAR_29;
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, VAR_25
+ 4 * (VAR_28 + VAR_23), 4)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
do
{
if (fread (VAR_7, 4, 1, VAR_0->handle) != 1)
{
error (_(""Failed to determine last chain length\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
if (VAR_23 + 1 == 0)
{
VAR_27 = TRUE;
goto no_gnu_hash;
}
++VAR_23;
}
while ((byte_get (VAR_7, 4) & 1) == 0);
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, VAR_25 + 4 * VAR_28, 4)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
VAR_32 = get_dynamic_data (VAR_0, VAR_23, 4);
VAR_33 = VAR_23;
if (VAR_32 == NULL)
{
VAR_27 = TRUE;
goto no_gnu_hash;
}
if (VAR_34)
{
if (fseek (VAR_0->handle,
(VAR_15
+ offset_from_vma (VAR_0, (VAR_25
+ 4 * (VAR_28
+ VAR_23)), 4)),
VAR_16))
{
error (_(""Unable to seek to start of dynamic information\n""));
VAR_27 = TRUE;
goto no_gnu_hash;
}
VAR_35 = get_dynamic_data (VAR_0, VAR_23, 4);
}
for (VAR_26 = 0; VAR_26 < VAR_28; ++VAR_26)
if (VAR_31[VAR_26] != 0)
{
bfd_vma VAR_36 = VAR_31[VAR_26];
bfd_vma VAR_37 = VAR_36 - VAR_29;
do
{
if (VAR_34)
{
if (VAR_35[VAR_37] >= VAR_1)
VAR_1 = VAR_35[VAR_37] + 1;
}
else
{
if (VAR_36 >= VAR_1)
VAR_1 = VAR_36 + 1;
}
VAR_36++;
}
while (VAR_37 < VAR_33 && (VAR_32[VAR_37++] & 1) == 0);
}
no_gnu_hash:
if (VAR_27)
{
if (VAR_35)
{
free (VAR_35);
VAR_35 = NULL;
}
if (VAR_32)
{
free (VAR_32);
VAR_32 = NULL;
}
if (VAR_31)
{
free (VAR_31);
VAR_31 = NULL;
}
VAR_28 = 0;
VAR_33 = 0;
}
}
return VAR_1;
}",binutils-gdb/001890e1f9269697f7e0212430a51479271bdab2/readelf.c/vul/before/0.json,"static unsigned long
get_num_dynamic_syms (Filedata * filedata)
{
  unsigned long num_of_syms = 0;

  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))
    return num_of_syms;

  if (dynamic_info[DT_HASH])
    {
      unsigned char nb[8];
      unsigned char nc[8];
      unsigned int hash_ent_size = 4;

      if ((filedata->file_header.e_machine == EM_ALPHA
	   || filedata->file_header.e_machine == EM_S390
	   || filedata->file_header.e_machine == EM_S390_OLD)
	  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)
	hash_ent_size = 8;

      if (fseek (filedata->handle,
		 (archive_file_offset
		  + offset_from_vma (filedata, dynamic_info[DT_HASH],
				     sizeof nb + sizeof nc)),
		 SEEK_SET))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  goto no_hash;
	}

      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)
	{
	  error (_(""Failed to read in number of buckets\n""));
	  goto no_hash;
	}

      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)
	{
	  error (_(""Failed to read in number of chains\n""));
	  goto no_hash;
	}

      nbuckets = byte_get (nb, hash_ent_size);
      nchains = byte_get (nc, hash_ent_size);

      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);
      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);

      if (buckets != NULL && chains != NULL)
	num_of_syms = nchains;

  no_hash:
      if (num_of_syms == 0)
	{
	  if (buckets)
	    {
	      free (buckets);
	      buckets = NULL;
	    }
	  if (chains)
	    {
	      free (chains);
	      chains = NULL;
	    }
	  nbuckets = 0;
	}
    }

  if (dynamic_info_DT_GNU_HASH)
    {
      unsigned char nb[16];
      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
      bfd_vma buckets_vma;
      unsigned long hn;
      bfd_boolean gnu_hash_error = FALSE;

      if (fseek (filedata->handle,
		 (archive_file_offset
		  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,
				     sizeof nb)),
		 SEEK_SET))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      if (fread (nb, 16, 1, filedata->handle) != 1)
	{
	  error (_(""Failed to read in number of buckets\n""));
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      ngnubuckets = byte_get (nb, 4);
      gnusymidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
	buckets_vma += bitmaskwords * 4;
      else
	buckets_vma += bitmaskwords * 8;

      if (fseek (filedata->handle,
		 (archive_file_offset
		  + offset_from_vma (filedata, buckets_vma, 4)),
		 SEEK_SET))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);

      if (gnubuckets == NULL)
	{
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      for (i = 0; i < ngnubuckets; i++)
	if (gnubuckets[i] != 0)
	  {
	    if (gnubuckets[i] < gnusymidx)
	      {
		gnu_hash_error = TRUE;
		return FALSE;
	      }

	    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
	      maxchain = gnubuckets[i];
	  }

      if (maxchain == 0xffffffff)
	{
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      maxchain -= gnusymidx;

      if (fseek (filedata->handle,
		 (archive_file_offset
		  + offset_from_vma (filedata, buckets_vma
					   + 4 * (ngnubuckets + maxchain), 4)),
		 SEEK_SET))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      do
	{
	  if (fread (nb, 4, 1, filedata->handle) != 1)
	    {
	      error (_(""Failed to determine last chain length\n""));
	  gnu_hash_error = TRUE;
	      goto no_gnu_hash;
	    }

	  if (maxchain + 1 == 0)
	    {
	      gnu_hash_error = TRUE;
	      goto no_gnu_hash;
	    }

	  ++maxchain;
	}
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek (filedata->handle,
		 (archive_file_offset
		  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),
		 SEEK_SET))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      gnuchains = get_dynamic_data (filedata, maxchain, 4);
      ngnuchains = maxchain;

      if (gnuchains == NULL)
	{
	  gnu_hash_error = TRUE;
	  goto no_gnu_hash;
	}

      if (dynamic_info_DT_MIPS_XHASH)
	{
	  if (fseek (filedata->handle,
		     (archive_file_offset
		      + offset_from_vma (filedata, (buckets_vma
						    + 4 * (ngnubuckets
							   + maxchain)), 4)),
		     SEEK_SET))
	    {
	      error (_(""Unable to seek to start of dynamic information\n""));
	      gnu_hash_error = TRUE;
	      goto no_gnu_hash;
	    }

	  mipsxlat = get_dynamic_data (filedata, maxchain, 4);
	}

      for (hn = 0; hn < ngnubuckets; ++hn)
	if (gnubuckets[hn] != 0)
	  {
	    bfd_vma si = gnubuckets[hn];
	    bfd_vma off = si - gnusymidx;

	    do
	      {
		if (dynamic_info_DT_MIPS_XHASH)
		  {
		    if (mipsxlat[off] >= num_of_syms)
		      num_of_syms = mipsxlat[off] + 1;
		  }
		else
		  {
		    if (si >= num_of_syms)
		      num_of_syms = si + 1;
		  }
		si++;
	      }
	    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);
	  }

  no_gnu_hash:
      if (gnu_hash_error)
	{
	  if (mipsxlat)
	    {
	      free (mipsxlat);
	      mipsxlat = NULL;
	    }
	  if (gnuchains)
	    {
	      free (gnuchains);
	      gnuchains = NULL;
	    }
	  if (gnubuckets)
	    {
	      free (gnubuckets);
	      gnubuckets = NULL;
	    }
	  ngnubuckets = 0;
	  ngnuchains = 0;
	}
    }

  return num_of_syms;
}","static unsigned long
get_num_dynamic_syms (Filedata * VAR_0)
{
  unsigned long VAR_1 = 0;

  if (!VAR_2 && (!VAR_3 || VAR_4))
    return VAR_1;

  if (VAR_5[VAR_6])
    {
      unsigned char VAR_7[8];
      unsigned char VAR_8[8];
      unsigned int VAR_9 = 4;

      if ((VAR_0->file_header.e_machine == VAR_10
	   || VAR_0->file_header.e_machine == VAR_11
	   || VAR_0->file_header.e_machine == VAR_12)
	  && VAR_0->file_header.e_ident[VAR_13] == VAR_14)
	VAR_9 = 8;

      if (fseek (VAR_0->handle,
		 (VAR_15
		  + offset_from_vma (VAR_0, VAR_5[VAR_6],
				     sizeof VAR_7 + sizeof VAR_8)),
		 VAR_16))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  goto no_hash;
	}

      if (fread (VAR_7, VAR_9, 1, VAR_0->handle) != 1)
	{
	  error (_(""Failed to read in number of buckets\n""));
	  goto no_hash;
	}

      if (fread (VAR_8, VAR_9, 1, VAR_0->handle) != 1)
	{
	  error (_(""Failed to read in number of chains\n""));
	  goto no_hash;
	}

      VAR_17 = byte_get (VAR_7, VAR_9);
      VAR_18 = byte_get (VAR_8, VAR_9);

      VAR_19 = get_dynamic_data (VAR_0, VAR_17, VAR_9);
      VAR_20  = get_dynamic_data (VAR_0, VAR_18, VAR_9);

      if (VAR_19 != NULL && VAR_20 != NULL)
	VAR_1 = VAR_18;

  no_hash:
      if (VAR_1 == 0)
	{
	  if (VAR_19)
	    {
	      free (VAR_19);
	      VAR_19 = NULL;
	    }
	  if (VAR_20)
	    {
	      free (VAR_20);
	      VAR_20 = NULL;
	    }
	  VAR_17 = 0;
	}
    }

  if (VAR_21)
    {
      unsigned char VAR_7[16];
      bfd_vma VAR_22, VAR_23 = 0xffffffff, VAR_24;
      bfd_vma VAR_25;
      unsigned long VAR_26;
      bfd_boolean VAR_27 = FALSE;

      if (fseek (VAR_0->handle,
		 (VAR_15
		  + offset_from_vma (VAR_0, VAR_21,
				     sizeof VAR_7)),
		 VAR_16))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      if (fread (VAR_7, 16, 1, VAR_0->handle) != 1)
	{
	  error (_(""Failed to read in number of buckets\n""));
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      VAR_28 = byte_get (VAR_7, 4);
      VAR_29 = byte_get (VAR_7 + 4, 4);
      VAR_24 = byte_get (VAR_7 + 8, 4);
      VAR_25 = VAR_21 + 16;
      if (VAR_30)
	VAR_25 += VAR_24 * 4;
      else
	VAR_25 += VAR_24 * 8;

      if (fseek (VAR_0->handle,
		 (VAR_15
		  + offset_from_vma (VAR_0, VAR_25, 4)),
		 VAR_16))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      VAR_31 = get_dynamic_data (VAR_0, VAR_28, 4);

      if (VAR_31 == NULL)
	{
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      for (VAR_22 = 0; VAR_22 < VAR_28; VAR_22++)
	if (VAR_31[VAR_22] != 0)
	  {
	    if (VAR_31[VAR_22] < VAR_29)
	      {
		VAR_27 = TRUE;
		return FALSE;
	      }

	    if (VAR_23 == 0xffffffff || VAR_31[VAR_22] > VAR_23)
	      VAR_23 = VAR_31[VAR_22];
	  }

      if (VAR_23 == 0xffffffff)
	{
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      VAR_23 -= VAR_29;

      if (fseek (VAR_0->handle,
		 (VAR_15
		  + offset_from_vma (VAR_0, VAR_25
					   + 4 * (VAR_28 + VAR_23), 4)),
		 VAR_16))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      do
	{
	  if (fread (VAR_7, 4, 1, VAR_0->handle) != 1)
	    {
	      error (_(""Failed to determine last chain length\n""));
	  VAR_27 = TRUE;
	      goto no_gnu_hash;
	    }

	  if (VAR_23 + 1 == 0)
	    {
	      VAR_27 = TRUE;
	      goto no_gnu_hash;
	    }

	  ++VAR_23;
	}
      while ((byte_get (VAR_7, 4) & 1) == 0);

      if (fseek (VAR_0->handle,
		 (VAR_15
		  + offset_from_vma (VAR_0, VAR_25 + 4 * VAR_28, 4)),
		 VAR_16))
	{
	  error (_(""Unable to seek to start of dynamic information\n""));
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      VAR_32 = get_dynamic_data (VAR_0, VAR_23, 4);
      VAR_33 = VAR_23;

      if (VAR_32 == NULL)
	{
	  VAR_27 = TRUE;
	  goto no_gnu_hash;
	}

      if (VAR_34)
	{
	  if (fseek (VAR_0->handle,
		     (VAR_15
		      + offset_from_vma (VAR_0, (VAR_25
						    + 4 * (VAR_28
							   + VAR_23)), 4)),
		     VAR_16))
	    {
	      error (_(""Unable to seek to start of dynamic information\n""));
	      VAR_27 = TRUE;
	      goto no_gnu_hash;
	    }

	  VAR_35 = get_dynamic_data (VAR_0, VAR_23, 4);
	}

      for (VAR_26 = 0; VAR_26 < VAR_28; ++VAR_26)
	if (VAR_31[VAR_26] != 0)
	  {
	    bfd_vma VAR_36 = VAR_31[VAR_26];
	    bfd_vma VAR_37 = VAR_36 - VAR_29;

	    do
	      {
		if (VAR_34)
		  {
		    if (VAR_35[VAR_37] >= VAR_1)
		      VAR_1 = VAR_35[VAR_37] + 1;
		  }
		else
		  {
		    if (VAR_36 >= VAR_1)
		      VAR_1 = VAR_36 + 1;
		  }
		VAR_36++;
	      }
	    while (VAR_37 < VAR_33 && (VAR_32[VAR_37++] & 1) == 0);
	  }

  no_gnu_hash:
      if (VAR_27)
	{
	  if (VAR_35)
	    {
	      free (VAR_35);
	      VAR_35 = NULL;
	    }
	  if (VAR_32)
	    {
	      free (VAR_32);
	      VAR_32 = NULL;
	    }
	  if (VAR_31)
	    {
	      free (VAR_31);
	      VAR_31 = NULL;
	    }
	  VAR_28 = 0;
	  VAR_33 = 0;
	}
    }

  return VAR_1;
}",binutils-gdb/001890e1f9269697f7e0212430a51479271bdab2/readelf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,10 +42,12 @@
 
       nbuckets = byte_get (nb, hash_ent_size);
       nchains = byte_get (nc, hash_ent_size);
-      num_of_syms = nchains;
 
       buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);
       chains  = get_dynamic_data (filedata, nchains, hash_ent_size);
+
+      if (buckets != NULL && chains != NULL)
+	num_of_syms = nchains;
 
   no_hash:
       if (num_of_syms == 0)","{'deleted_lines': ['      num_of_syms = nchains;'], 'added_lines': ['', '      if (buckets != NULL && chains != NULL)', '\tnum_of_syms = nchains;']}",True,"A Denial of Service vulnerability exists in the Binary File Descriptor (BFD) in GNU Binutils 2.35 due to an invalid read in process_symbol_table, as demonstrated in readeif.",5.5,MEDIUM,1,valid,,5
CVE-2020-27786,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The rawmidi core allows user to resize the runtime buffer via ioctl,
and this may lead to UAF when performed during concurrent reads or
writes: the read/write functions unlock the runtime lock temporarily
during copying form/to user-space, and that's the race window.

This patch fixes the hole by introducing a reference counter for the
runtime buffer read/write access and returns -EBUSY error when the
resize is performed concurrently against read/write.

Note that the ref count field is a simple integer instead of
refcount_t here, since the all contexts accessing the buffer is
basically protected with a spinlock, hence we need no expensive atomic
ops.  Also, note that this busy check is needed only against read /
write functions, and not in receive/transmit callbacks; the race can
happen only at the spinlock hole mentioned in the above, while the
whole function is protected for receive / transmit callbacks.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/CAFcO6XMWpUVK_yzzCpp8_XP7+=oUpQvuBeCbMffEDkpe8jWrfg@mail.gmail.com
Link: https://lore.kernel.org/r/s5heerw3r5z.wl-tiwai@suse.de
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,sound/core/rawmidi.c,snd_rawmidi_kernel_write1,"static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
const unsigned char __user *userbuf,
const unsigned char *kernelbuf,
long count)
{
unsigned long flags;
long count1, result;
struct snd_rawmidi_runtime *runtime = substream->runtime;
unsigned long appl_ptr;
if (!kernelbuf && !userbuf)
return -EINVAL;
if (snd_BUG_ON(!runtime->buffer))
return -EINVAL;
result = 0;
spin_lock_irqsave(&runtime->lock, flags);
if (substream->append) {
if ((long)runtime->avail < count) {
spin_unlock_irqrestore(&runtime->lock, flags);
return -EAGAIN;
}
}
while (count > 0 && runtime->avail > 0) {
count1 = runtime->buffer_size - runtime->appl_ptr;
if (count1 > count)
count1 = count;
if (count1 > (long)runtime->avail)
count1 = runtime->avail;
appl_ptr = runtime->appl_ptr;
runtime->appl_ptr += count1;
runtime->appl_ptr %= runtime->buffer_size;
runtime->avail -= count1;
if (kernelbuf)
memcpy(runtime->buffer + appl_ptr,
kernelbuf + result, count1);
else if (userbuf) {
spin_unlock_irqrestore(&runtime->lock, flags);
if (copy_from_user(runtime->buffer + appl_ptr,
userbuf + result, count1)) {
spin_lock_irqsave(&runtime->lock, flags);
result = result > 0 ? result : -EFAULT;
goto __end;
}
spin_lock_irqsave(&runtime->lock, flags);
}
result += count1;
count -= count1;
}
__end:
count1 = runtime->avail < runtime->buffer_size;
spin_unlock_irqrestore(&runtime->lock, flags);
if (count1)
snd_rawmidi_output_trigger(substream, 1);
return result;
}","static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *VAR_0,
const unsigned char __user *VAR_1,
const unsigned char *VAR_2,
long VAR_3)
{
unsigned long VAR_4;
long VAR_5, VAR_6;
struct snd_rawmidi_runtime *VAR_7 = VAR_0->runtime;
unsigned long VAR_8;
if (!VAR_2 && !VAR_1)
return -VAR_9;
if (snd_BUG_ON(!VAR_7->buffer))
return -VAR_9;
VAR_6 = 0;
spin_lock_irqsave(&VAR_7->lock, VAR_4);
if (VAR_0->append) {
if ((long)VAR_7->avail < VAR_3) {
spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
return -VAR_10;
}
}
while (VAR_3 > 0 && VAR_7->avail > 0) {
VAR_5 = VAR_7->buffer_size - VAR_7->appl_ptr;
if (VAR_5 > VAR_3)
VAR_5 = VAR_3;
if (VAR_5 > (long)VAR_7->avail)
VAR_5 = VAR_7->avail;
VAR_8 = VAR_7->appl_ptr;
VAR_7->appl_ptr += VAR_5;
VAR_7->appl_ptr %= VAR_7->buffer_size;
VAR_7->avail -= VAR_5;
if (VAR_2)
memcpy(VAR_7->buffer + VAR_8,
VAR_2 + VAR_6, VAR_5);
else if (VAR_1) {
spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
if (copy_from_user(VAR_7->buffer + VAR_8,
VAR_1 + VAR_6, VAR_5)) {
spin_lock_irqsave(&VAR_7->lock, VAR_4);
VAR_6 = VAR_6 > 0 ? VAR_6 : -VAR_11;
goto __end;
}
spin_lock_irqsave(&VAR_7->lock, VAR_4);
}
VAR_6 += VAR_5;
VAR_3 -= VAR_5;
}
__end:
VAR_5 = VAR_7->avail < VAR_7->buffer_size;
spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
if (VAR_5)
snd_rawmidi_output_trigger(VAR_0, 1);
return VAR_6;
}",,"static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
				      const unsigned char __user *userbuf,
				      const unsigned char *kernelbuf,
				      long count)
{
	unsigned long flags;
	long count1, result;
	struct snd_rawmidi_runtime *runtime = substream->runtime;
	unsigned long appl_ptr;

	if (!kernelbuf && !userbuf)
		return -EINVAL;
	if (snd_BUG_ON(!runtime->buffer))
		return -EINVAL;

	result = 0;
	spin_lock_irqsave(&runtime->lock, flags);
	if (substream->append) {
		if ((long)runtime->avail < count) {
			spin_unlock_irqrestore(&runtime->lock, flags);
			return -EAGAIN;
		}
	}
	snd_rawmidi_buffer_ref(runtime);
	while (count > 0 && runtime->avail > 0) {
		count1 = runtime->buffer_size - runtime->appl_ptr;
		if (count1 > count)
			count1 = count;
		if (count1 > (long)runtime->avail)
			count1 = runtime->avail;

		/* update runtime->appl_ptr before unlocking for userbuf */
		appl_ptr = runtime->appl_ptr;
		runtime->appl_ptr += count1;
		runtime->appl_ptr %= runtime->buffer_size;
		runtime->avail -= count1;

		if (kernelbuf)
			memcpy(runtime->buffer + appl_ptr,
			       kernelbuf + result, count1);
		else if (userbuf) {
			spin_unlock_irqrestore(&runtime->lock, flags);
			if (copy_from_user(runtime->buffer + appl_ptr,
					   userbuf + result, count1)) {
				spin_lock_irqsave(&runtime->lock, flags);
				result = result > 0 ? result : -EFAULT;
				goto __end;
			}
			spin_lock_irqsave(&runtime->lock, flags);
		}
		result += count1;
		count -= count1;
	}
      __end:
	count1 = runtime->avail < runtime->buffer_size;
	snd_rawmidi_buffer_unref(runtime);
	spin_unlock_irqrestore(&runtime->lock, flags);
	if (count1)
		snd_rawmidi_output_trigger(substream, 1);
	return result;
}","static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *VAR_0,
				      const unsigned char __user *VAR_1,
				      const unsigned char *VAR_2,
				      long VAR_3)
{
	unsigned long VAR_4;
	long VAR_5, VAR_6;
	struct snd_rawmidi_runtime *VAR_7 = VAR_0->runtime;
	unsigned long VAR_8;

	if (!VAR_2 && !VAR_1)
		return -VAR_9;
	if (snd_BUG_ON(!VAR_7->buffer))
		return -VAR_9;

	VAR_6 = 0;
	spin_lock_irqsave(&VAR_7->lock, VAR_4);
	if (VAR_0->append) {
		if ((long)VAR_7->avail < VAR_3) {
			spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
			return -VAR_10;
		}
	}
	snd_rawmidi_buffer_ref(VAR_7);
	while (VAR_3 > 0 && VAR_7->avail > 0) {
		VAR_5 = VAR_7->buffer_size - VAR_7->appl_ptr;
		if (VAR_5 > VAR_3)
			VAR_5 = VAR_3;
		if (VAR_5 > (long)VAR_7->avail)
			VAR_5 = VAR_7->avail;

		/* COMMENT_0 */
		VAR_8 = VAR_7->appl_ptr;
		VAR_7->appl_ptr += VAR_5;
		VAR_7->appl_ptr %= VAR_7->buffer_size;
		VAR_7->avail -= VAR_5;

		if (VAR_2)
			memcpy(VAR_7->buffer + VAR_8,
			       VAR_2 + VAR_6, VAR_5);
		else if (VAR_1) {
			spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
			if (copy_from_user(VAR_7->buffer + VAR_8,
					   VAR_1 + VAR_6, VAR_5)) {
				spin_lock_irqsave(&VAR_7->lock, VAR_4);
				VAR_6 = VAR_6 > 0 ? VAR_6 : -VAR_11;
				goto __end;
			}
			spin_lock_irqsave(&VAR_7->lock, VAR_4);
		}
		VAR_6 += VAR_5;
		VAR_3 -= VAR_5;
	}
      __end:
	VAR_5 = VAR_7->avail < VAR_7->buffer_size;
	snd_rawmidi_buffer_unref(VAR_7);
	spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
	if (VAR_5)
		snd_rawmidi_output_trigger(VAR_0, 1);
	return VAR_6;
}",,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
 			return -EAGAIN;
 		}
 	}
+	snd_rawmidi_buffer_ref(runtime);
 	while (count > 0 && runtime->avail > 0) {
 		count1 = runtime->buffer_size - runtime->appl_ptr;
 		if (count1 > count)
@@ -52,6 +53,7 @@
 	}
       __end:
 	count1 = runtime->avail < runtime->buffer_size;
+	snd_rawmidi_buffer_unref(runtime);
 	spin_unlock_irqrestore(&runtime->lock, flags);
 	if (count1)
 		snd_rawmidi_output_trigger(substream, 1);","{'deleted_lines': [], 'added_lines': ['\tsnd_rawmidi_buffer_ref(runtime);', '\tsnd_rawmidi_buffer_unref(runtime);']}",True,"A flaw was found in the Linux kernels implementation of MIDI, where an attacker with a local account and the permissions to issue ioctl commands to midi devices could trigger a use-after-free issue. A write to this specific memory while freed and before use causes the flow of execution to change and possibly allow for memory corruption or privilege escalation. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2020-27786,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The rawmidi core allows user to resize the runtime buffer via ioctl,
and this may lead to UAF when performed during concurrent reads or
writes: the read/write functions unlock the runtime lock temporarily
during copying form/to user-space, and that's the race window.

This patch fixes the hole by introducing a reference counter for the
runtime buffer read/write access and returns -EBUSY error when the
resize is performed concurrently against read/write.

Note that the ref count field is a simple integer instead of
refcount_t here, since the all contexts accessing the buffer is
basically protected with a spinlock, hence we need no expensive atomic
ops.  Also, note that this busy check is needed only against read /
write functions, and not in receive/transmit callbacks; the race can
happen only at the spinlock hole mentioned in the above, while the
whole function is protected for receive / transmit callbacks.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/CAFcO6XMWpUVK_yzzCpp8_XP7+=oUpQvuBeCbMffEDkpe8jWrfg@mail.gmail.com
Link: https://lore.kernel.org/r/s5heerw3r5z.wl-tiwai@suse.de
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,sound/core/rawmidi.c,snd_rawmidi_kernel_read1,"static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,
unsigned char __user *userbuf,
unsigned char *kernelbuf, long count)
{
unsigned long flags;
long result = 0, count1;
struct snd_rawmidi_runtime *runtime = substream->runtime;
unsigned long appl_ptr;
spin_lock_irqsave(&runtime->lock, flags);
while (count > 0 && runtime->avail) {
count1 = runtime->buffer_size - runtime->appl_ptr;
if (count1 > count)
count1 = count;
if (count1 > (int)runtime->avail)
count1 = runtime->avail;
appl_ptr = runtime->appl_ptr;
runtime->appl_ptr += count1;
runtime->appl_ptr %= runtime->buffer_size;
runtime->avail -= count1;
if (kernelbuf)
memcpy(kernelbuf + result, runtime->buffer + appl_ptr, count1);
if (userbuf) {
spin_unlock_irqrestore(&runtime->lock, flags);
if (copy_to_user(userbuf + result,
runtime->buffer + appl_ptr, count1)) {
return result > 0 ? result : -EFAULT;
}
spin_lock_irqsave(&runtime->lock, flags);
}
result += count1;
count -= count1;
}
spin_unlock_irqrestore(&runtime->lock, flags);
return result;
}","static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *VAR_0,
unsigned char __user *VAR_1,
unsigned char *VAR_2, long VAR_3)
{
unsigned long VAR_4;
long VAR_5 = 0, VAR_6;
struct snd_rawmidi_runtime *VAR_7 = VAR_0->runtime;
unsigned long VAR_8;
spin_lock_irqsave(&VAR_7->lock, VAR_4);
while (VAR_3 > 0 && VAR_7->avail) {
VAR_6 = VAR_7->buffer_size - VAR_7->appl_ptr;
if (VAR_6 > VAR_3)
VAR_6 = VAR_3;
if (VAR_6 > (int)VAR_7->avail)
VAR_6 = VAR_7->avail;
VAR_8 = VAR_7->appl_ptr;
VAR_7->appl_ptr += VAR_6;
VAR_7->appl_ptr %= VAR_7->buffer_size;
VAR_7->avail -= VAR_6;
if (VAR_2)
memcpy(VAR_2 + VAR_5, VAR_7->buffer + VAR_8, VAR_6);
if (VAR_1) {
spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
if (copy_to_user(VAR_1 + VAR_5,
VAR_7->buffer + VAR_8, VAR_6)) {
return VAR_5 > 0 ? VAR_5 : -VAR_9;
}
spin_lock_irqsave(&VAR_7->lock, VAR_4);
}
VAR_5 += VAR_6;
VAR_3 -= VAR_6;
}
spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
return VAR_5;
}",,"static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,
				     unsigned char __user *userbuf,
				     unsigned char *kernelbuf, long count)
{
	unsigned long flags;
	long result = 0, count1;
	struct snd_rawmidi_runtime *runtime = substream->runtime;
	unsigned long appl_ptr;
	int err = 0;

	spin_lock_irqsave(&runtime->lock, flags);
	snd_rawmidi_buffer_ref(runtime);
	while (count > 0 && runtime->avail) {
		count1 = runtime->buffer_size - runtime->appl_ptr;
		if (count1 > count)
			count1 = count;
		if (count1 > (int)runtime->avail)
			count1 = runtime->avail;

		/* update runtime->appl_ptr before unlocking for userbuf */
		appl_ptr = runtime->appl_ptr;
		runtime->appl_ptr += count1;
		runtime->appl_ptr %= runtime->buffer_size;
		runtime->avail -= count1;

		if (kernelbuf)
			memcpy(kernelbuf + result, runtime->buffer + appl_ptr, count1);
		if (userbuf) {
			spin_unlock_irqrestore(&runtime->lock, flags);
			if (copy_to_user(userbuf + result,
					 runtime->buffer + appl_ptr, count1))
				err = -EFAULT;
			spin_lock_irqsave(&runtime->lock, flags);
			if (err)
				goto out;
		}
		result += count1;
		count -= count1;
	}
 out:
	snd_rawmidi_buffer_unref(runtime);
	spin_unlock_irqrestore(&runtime->lock, flags);
	return result > 0 ? result : err;
}","static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *VAR_0,
				     unsigned char __user *VAR_1,
				     unsigned char *VAR_2, long VAR_3)
{
	unsigned long VAR_4;
	long VAR_5 = 0, VAR_6;
	struct snd_rawmidi_runtime *VAR_7 = VAR_0->runtime;
	unsigned long VAR_8;
	int VAR_9 = 0;

	spin_lock_irqsave(&VAR_7->lock, VAR_4);
	snd_rawmidi_buffer_ref(VAR_7);
	while (VAR_3 > 0 && VAR_7->avail) {
		VAR_6 = VAR_7->buffer_size - VAR_7->appl_ptr;
		if (VAR_6 > VAR_3)
			VAR_6 = VAR_3;
		if (VAR_6 > (int)VAR_7->avail)
			VAR_6 = VAR_7->avail;

		/* COMMENT_0 */
		VAR_8 = VAR_7->appl_ptr;
		VAR_7->appl_ptr += VAR_6;
		VAR_7->appl_ptr %= VAR_7->buffer_size;
		VAR_7->avail -= VAR_6;

		if (VAR_2)
			memcpy(VAR_2 + VAR_5, VAR_7->buffer + VAR_8, VAR_6);
		if (VAR_1) {
			spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
			if (copy_to_user(VAR_1 + VAR_5,
					 VAR_7->buffer + VAR_8, VAR_6))
				VAR_9 = -VAR_10;
			spin_lock_irqsave(&VAR_7->lock, VAR_4);
			if (VAR_9)
				goto out;
		}
		VAR_5 += VAR_6;
		VAR_3 -= VAR_6;
	}
 out:
	snd_rawmidi_buffer_unref(VAR_7);
	spin_unlock_irqrestore(&VAR_7->lock, VAR_4);
	return VAR_5 > 0 ? VAR_5 : VAR_9;
}",,"--- func_before
+++ func_after
@@ -6,8 +6,10 @@
 	long result = 0, count1;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 	unsigned long appl_ptr;
+	int err = 0;
 
 	spin_lock_irqsave(&runtime->lock, flags);
+	snd_rawmidi_buffer_ref(runtime);
 	while (count > 0 && runtime->avail) {
 		count1 = runtime->buffer_size - runtime->appl_ptr;
 		if (count1 > count)
@@ -26,14 +28,17 @@
 		if (userbuf) {
 			spin_unlock_irqrestore(&runtime->lock, flags);
 			if (copy_to_user(userbuf + result,
-					 runtime->buffer + appl_ptr, count1)) {
-				return result > 0 ? result : -EFAULT;
-			}
+					 runtime->buffer + appl_ptr, count1))
+				err = -EFAULT;
 			spin_lock_irqsave(&runtime->lock, flags);
+			if (err)
+				goto out;
 		}
 		result += count1;
 		count -= count1;
 	}
+ out:
+	snd_rawmidi_buffer_unref(runtime);
 	spin_unlock_irqrestore(&runtime->lock, flags);
-	return result;
+	return result > 0 ? result : err;
 }","{'deleted_lines': ['\t\t\t\t\t runtime->buffer + appl_ptr, count1)) {', '\t\t\t\treturn result > 0 ? result : -EFAULT;', '\t\t\t}', '\treturn result;'], 'added_lines': ['\tint err = 0;', '\tsnd_rawmidi_buffer_ref(runtime);', '\t\t\t\t\t runtime->buffer + appl_ptr, count1))', '\t\t\t\terr = -EFAULT;', '\t\t\tif (err)', '\t\t\t\tgoto out;', ' out:', '\tsnd_rawmidi_buffer_unref(runtime);', '\treturn result > 0 ? result : err;']}",True,"A flaw was found in the Linux kernels implementation of MIDI, where an attacker with a local account and the permissions to issue ioctl commands to midi devices could trigger a use-after-free issue. A write to this specific memory while freed and before use causes the flow of execution to change and possibly allow for memory corruption or privilege escalation. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2020-27786,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The rawmidi core allows user to resize the runtime buffer via ioctl,
and this may lead to UAF when performed during concurrent reads or
writes: the read/write functions unlock the runtime lock temporarily
during copying form/to user-space, and that's the race window.

This patch fixes the hole by introducing a reference counter for the
runtime buffer read/write access and returns -EBUSY error when the
resize is performed concurrently against read/write.

Note that the ref count field is a simple integer instead of
refcount_t here, since the all contexts accessing the buffer is
basically protected with a spinlock, hence we need no expensive atomic
ops.  Also, note that this busy check is needed only against read /
write functions, and not in receive/transmit callbacks; the race can
happen only at the spinlock hole mentioned in the above, while the
whole function is protected for receive / transmit callbacks.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/CAFcO6XMWpUVK_yzzCpp8_XP7+=oUpQvuBeCbMffEDkpe8jWrfg@mail.gmail.com
Link: https://lore.kernel.org/r/s5heerw3r5z.wl-tiwai@suse.de
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d,sound/core/rawmidi.c,resize_runtime_buffer,"static int resize_runtime_buffer(struct snd_rawmidi_runtime *runtime,
struct snd_rawmidi_params *params,
bool is_input)
{
char *newbuf, *oldbuf;
if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L)
return -EINVAL;
if (params->avail_min < 1 || params->avail_min > params->buffer_size)
return -EINVAL;
if (params->buffer_size != runtime->buffer_size) {
newbuf = kvzalloc(params->buffer_size, GFP_KERNEL);
if (!newbuf)
return -ENOMEM;
spin_lock_irq(&runtime->lock);
oldbuf = runtime->buffer;
runtime->buffer = newbuf;
runtime->buffer_size = params->buffer_size;
__reset_runtime_ptrs(runtime, is_input);
spin_unlock_irq(&runtime->lock);
kvfree(oldbuf);
}
runtime->avail_min = params->avail_min;
return 0;
}","static int resize_runtime_buffer(struct snd_rawmidi_runtime *VAR_0,
struct snd_rawmidi_params *VAR_1,
bool VAR_2)
{
char *VAR_3, *VAR_4;
if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L)
return -VAR_5;
if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size)
return -VAR_5;
if (VAR_1->buffer_size != VAR_0->buffer_size) {
VAR_3 = kvzalloc(VAR_1->buffer_size, VAR_6);
if (!VAR_3)
return -VAR_7;
spin_lock_irq(&VAR_0->lock);
VAR_4 = VAR_0->buffer;
VAR_0->buffer = VAR_3;
VAR_0->buffer_size = VAR_1->buffer_size;
__reset_runtime_ptrs(VAR_0, VAR_2);
spin_unlock_irq(&VAR_0->lock);
kvfree(VAR_4);
}
VAR_0->avail_min = VAR_1->avail_min;
return 0;
}",torvalds/linux/c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d/rawmidi.c/vul/before/2.json,"static int resize_runtime_buffer(struct snd_rawmidi_runtime *runtime,
				 struct snd_rawmidi_params *params,
				 bool is_input)
{
	char *newbuf, *oldbuf;

	if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L)
		return -EINVAL;
	if (params->avail_min < 1 || params->avail_min > params->buffer_size)
		return -EINVAL;
	if (params->buffer_size != runtime->buffer_size) {
		newbuf = kvzalloc(params->buffer_size, GFP_KERNEL);
		if (!newbuf)
			return -ENOMEM;
		spin_lock_irq(&runtime->lock);
		if (runtime->buffer_ref) {
			spin_unlock_irq(&runtime->lock);
			kvfree(newbuf);
			return -EBUSY;
		}
		oldbuf = runtime->buffer;
		runtime->buffer = newbuf;
		runtime->buffer_size = params->buffer_size;
		__reset_runtime_ptrs(runtime, is_input);
		spin_unlock_irq(&runtime->lock);
		kvfree(oldbuf);
	}
	runtime->avail_min = params->avail_min;
	return 0;
}","static int resize_runtime_buffer(struct snd_rawmidi_runtime *VAR_0,
				 struct snd_rawmidi_params *VAR_1,
				 bool VAR_2)
{
	char *VAR_3, *VAR_4;

	if (VAR_1->buffer_size < 32 || VAR_1->buffer_size > 1024L * 1024L)
		return -VAR_5;
	if (VAR_1->avail_min < 1 || VAR_1->avail_min > VAR_1->buffer_size)
		return -VAR_5;
	if (VAR_1->buffer_size != VAR_0->buffer_size) {
		VAR_3 = kvzalloc(VAR_1->buffer_size, VAR_6);
		if (!VAR_3)
			return -VAR_7;
		spin_lock_irq(&VAR_0->lock);
		if (VAR_0->buffer_ref) {
			spin_unlock_irq(&VAR_0->lock);
			kvfree(VAR_3);
			return -VAR_8;
		}
		VAR_4 = VAR_0->buffer;
		VAR_0->buffer = VAR_3;
		VAR_0->buffer_size = VAR_1->buffer_size;
		__reset_runtime_ptrs(VAR_0, VAR_2);
		spin_unlock_irq(&VAR_0->lock);
		kvfree(VAR_4);
	}
	VAR_0->avail_min = VAR_1->avail_min;
	return 0;
}",torvalds/linux/c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d/rawmidi.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -13,6 +13,11 @@
 		if (!newbuf)
 			return -ENOMEM;
 		spin_lock_irq(&runtime->lock);
+		if (runtime->buffer_ref) {
+			spin_unlock_irq(&runtime->lock);
+			kvfree(newbuf);
+			return -EBUSY;
+		}
 		oldbuf = runtime->buffer;
 		runtime->buffer = newbuf;
 		runtime->buffer_size = params->buffer_size;","{'deleted_lines': [], 'added_lines': ['\t\tif (runtime->buffer_ref) {', '\t\t\tspin_unlock_irq(&runtime->lock);', '\t\t\tkvfree(newbuf);', '\t\t\treturn -EBUSY;', '\t\t}']}",True,"A flaw was found in the Linux kernels implementation of MIDI, where an attacker with a local account and the permissions to issue ioctl commands to midi devices could trigger a use-after-free issue. A write to this specific memory while freed and before use causes the flow of execution to change and possibly allow for memory corruption or privilege escalation. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2021-22173,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"USB HID: Fix a memory leak.

Replace mismatched g_strdup() + g_free()s with
wmem_strdup_printf(wmem_packet_scope(), ...). Fixes #17124.
",26f0db01a7f7e6c69eee2f1c601444c64ca53e19,https://gitlab.com/wireshark/wireshark/-/commit/26f0db01a7f7e6c69eee2f1c601444c64ca53e19,epan/dissectors/packet-usb-hid.c,get_usage_page_item_string,"static gchar*
get_usage_page_item_string(guint32 usage_page, guint32 id)
{
const char *str = NULL;
switch (usage_page)
{
case GENERIC_DESKTOP_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);
break;
case SIMULATION_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);
break;
case VR_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);
break;
case SPORT_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);
break;
case GAME_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);
break;
case GENERIC_DEVICE_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);
break;
case KEYBOARD_KEYPAD_PAGE:
str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);
break;
case LED_PAGE:
str = try_val_to_str(id, usb_hid_led_usage_page_vals);
break;
case BUTTON_PAGE:
str = try_val_to_str(id, usb_hid_button_usage_page_vals);
if (!str)
str = ""Button %u"";
break;
case ORDINAL_PAGE:
str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);
break;
case TELEPHONY_PAGE:
str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);
break;
case CONSUMER_PAGE:
str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);
if (!str)
str = ""Instance %u"";
break;
case DIGITIZER_PAGE:
str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);
break;
case HAPTICS_PAGE:
str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);
if (id >= 0x1006 && id <= 0x1FFF)
str = ""Reserved for standard waveforms"";
if (id >= 0x2001 && id <= 0x2FFF)
str = ""Vendor Waveforms"";
break;
case PID_PAGE:
str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);
break;
case UNICODE_PAGE:
str = ""Character U+%04X"";
break;
case EYE_AND_HEAD_TRACKER_PAGE:
str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);
break;
case ALPHANUMERIC_DISPLAY_PAGE:
str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);
break;
case SENSOR_PAGE:
str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);
if (!str)
str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);
break;
case MEDICAL_INSTRUMENTS_PAGE:
str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);
break;
case BRAILLE_DISPLAY_PAGE:
str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);
break;
case LIGHTING_AND_ILLUMINATION_PAGE:
str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);
break;
case USB_MONITOR_PAGE:
str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);
break;
case USB_ENUMERATED_VALUES_PAGE:
str = ""ENUM_%u"";
break;
case VESA_VIRTUAL_CONTROLS_PAGE:
str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);
break;
case POWER_DEVICE_PAGE:
str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);
break;
case BATTERY_SYSTEM_PAGE:
str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);
break;
case BARCODE_SCANNER_PAGE:
str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);
break;
case WEIGHING_PAGE:
str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);
break;
case MSR_PAGE:
str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);
break;
case ARCADE_PAGE:
str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);
break;
case FIDO_ALLIANCE_PAGE:
str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);
break;
default:
if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)
str = ""Vendor"";
break;
}
if (!str)
str = ""Reserved"";
return g_strdup_printf(str, id);
}","static gchar*
get_usage_page_item_string(guint32 VAR_0, guint32 VAR_1)
{
const char *VAR_2 = NULL;
switch (VAR_0)
{
case VAR_3:
VAR_2 = try_val_to_str(VAR_1, VAR_4);
break;
case VAR_5:
VAR_2 = try_val_to_str(VAR_1, VAR_6);
break;
case VAR_7:
VAR_2 = try_val_to_str(VAR_1, VAR_8);
break;
case VAR_9:
VAR_2 = try_val_to_str(VAR_1, VAR_10);
break;
case VAR_11:
VAR_2 = try_val_to_str(VAR_1, VAR_12);
break;
case VAR_13:
VAR_2 = try_val_to_str(VAR_1, VAR_14);
break;
case VAR_15:
VAR_2 = try_val_to_str(VAR_1, VAR_16);
break;
case VAR_17:
VAR_2 = try_val_to_str(VAR_1, VAR_18);
break;
case VAR_19:
VAR_2 = try_val_to_str(VAR_1, VAR_20);
if (!VAR_2)
VAR_2 = ""Button %u"";
break;
case VAR_21:
VAR_2 = try_val_to_str(VAR_1, VAR_22);
break;
case VAR_23:
VAR_2 = try_val_to_str(VAR_1, VAR_24);
break;
case VAR_25:
VAR_2 = try_val_to_str(VAR_1, VAR_26);
if (!VAR_2)
VAR_2 = ""Instance %u"";
break;
case VAR_27:
VAR_2 = try_val_to_str(VAR_1, VAR_28);
break;
case VAR_29:
VAR_2 = try_val_to_str(VAR_1, VAR_30);
if (VAR_1 >= 0x1006 && VAR_1 <= 0x1FFF)
VAR_2 = ""Reserved for standard waveforms"";
if (VAR_1 >= 0x2001 && VAR_1 <= 0x2FFF)
VAR_2 = ""Vendor Waveforms"";
break;
case VAR_31:
VAR_2 = try_val_to_str(VAR_1, VAR_32);
break;
case VAR_33:
VAR_2 = ""Character U+%04X"";
break;
case VAR_34:
VAR_2 = try_val_to_str(VAR_1, VAR_35);
break;
case VAR_36:
VAR_2 = try_val_to_str(VAR_1, VAR_37);
break;
case VAR_38:
VAR_2 = try_val_to_str(VAR_1, VAR_39);
if (!VAR_2)
VAR_2 = try_rval_to_str(VAR_1, VAR_40);
break;
case VAR_41:
VAR_2 = try_val_to_str(VAR_1, VAR_42);
break;
case VAR_43:
VAR_2 = try_val_to_str(VAR_1, VAR_44);
break;
case VAR_45:
VAR_2 = try_val_to_str(VAR_1, VAR_46);
break;
case VAR_47:
VAR_2 = try_val_to_str(VAR_1, VAR_48);
break;
case VAR_49:
VAR_2 = ""ENUM_%u"";
break;
case VAR_50:
VAR_2 = try_val_to_str(VAR_1, VAR_51);
break;
case VAR_52:
VAR_2 = try_val_to_str(VAR_1, VAR_53);
break;
case VAR_54:
VAR_2 = try_val_to_str(VAR_1, VAR_55);
break;
case VAR_56:
VAR_2 = try_val_to_str(VAR_1, VAR_57);
break;
case VAR_58:
VAR_2 = try_val_to_str(VAR_1, VAR_59);
break;
case VAR_60:
VAR_2 = try_val_to_str(VAR_1, VAR_61);
break;
case VAR_62:
VAR_2 = try_val_to_str(VAR_1, VAR_63);
break;
case VAR_64:
VAR_2 = try_val_to_str(VAR_1, VAR_65);
break;
default:
if ((VAR_0 & VAR_66) == VAR_66)
VAR_2 = ""Vendor"";
break;
}
if (!VAR_2)
VAR_2 = ""Reserved"";
return g_strdup_printf(VAR_2, VAR_1);
}",wireshark/26f0db01a7f7e6c69eee2f1c601444c64ca53e19/packet-usb-hid.c/vul/before/0.json,"static gchar*
get_usage_page_item_string(guint32 usage_page, guint32 id)
{
    const char *str = NULL;

    switch (usage_page)
    {
    case GENERIC_DESKTOP_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);
        break;
    case SIMULATION_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);
        break;
    case VR_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);
        break;
    case SPORT_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);
        break;
    case GAME_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);
        break;
    case GENERIC_DEVICE_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);
        break;
    case KEYBOARD_KEYPAD_PAGE:
        str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);
        break;
    case LED_PAGE:
        str = try_val_to_str(id, usb_hid_led_usage_page_vals);
        break;
    case BUTTON_PAGE:
        str = try_val_to_str(id, usb_hid_button_usage_page_vals);
        if (!str)
            str = ""Button %u"";
        break;
    case ORDINAL_PAGE:
        str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);
        break;
    case TELEPHONY_PAGE:
        str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);
        break;
    case CONSUMER_PAGE:
        str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);
        if (!str)
            str = ""Instance %u"";
        break;
    case DIGITIZER_PAGE:
        str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);
        break;
    case HAPTICS_PAGE:
        str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);
        if (id >= 0x1006 && id <= 0x1FFF)
            str = ""Reserved for standard waveforms"";
        if (id >= 0x2001 && id <= 0x2FFF)
            str = ""Vendor Waveforms"";
        break;
    case PID_PAGE:
        str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);
        break;
    case UNICODE_PAGE:
        str = ""Character U+%04X"";
        break;
    case EYE_AND_HEAD_TRACKER_PAGE:
        str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);
        break;
    case ALPHANUMERIC_DISPLAY_PAGE:
        str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);
        break;
    case SENSOR_PAGE:
        str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);
        if (!str)
            str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);
        break;
    case MEDICAL_INSTRUMENTS_PAGE:
        str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);
        break;
    case BRAILLE_DISPLAY_PAGE:
        str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);
        break;
    case LIGHTING_AND_ILLUMINATION_PAGE:
        str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);
        break;
    case USB_MONITOR_PAGE:
        str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);
        break;
    case USB_ENUMERATED_VALUES_PAGE:
        str = ""ENUM_%u"";
        break;
    case VESA_VIRTUAL_CONTROLS_PAGE:
        str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);
        break;
    case POWER_DEVICE_PAGE:
        str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);
        break;
    case BATTERY_SYSTEM_PAGE:
        str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);
        break;
    case BARCODE_SCANNER_PAGE:
        str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);
        break;
    case WEIGHING_PAGE:
        str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);
        break;
    case MSR_PAGE:
        str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);
        break;
    case ARCADE_PAGE:
        str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);
        break;
    case FIDO_ALLIANCE_PAGE:
        str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);
        break;
    default:
        if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)
            str = ""Vendor"";
        break;
    }

    if (!str)
        str = ""Reserved"";

    return wmem_strdup_printf(wmem_packet_scope(), str, id);
}","static gchar*
get_usage_page_item_string(guint32 VAR_0, guint32 VAR_1)
{
    const char *VAR_2 = NULL;

    switch (VAR_0)
    {
    case VAR_3:
        VAR_2 = try_val_to_str(VAR_1, VAR_4);
        break;
    case VAR_5:
        VAR_2 = try_val_to_str(VAR_1, VAR_6);
        break;
    case VAR_7:
        VAR_2 = try_val_to_str(VAR_1, VAR_8);
        break;
    case VAR_9:
        VAR_2 = try_val_to_str(VAR_1, VAR_10);
        break;
    case VAR_11:
        VAR_2 = try_val_to_str(VAR_1, VAR_12);
        break;
    case VAR_13:
        VAR_2 = try_val_to_str(VAR_1, VAR_14);
        break;
    case VAR_15:
        VAR_2 = try_val_to_str(VAR_1, VAR_16);
        break;
    case VAR_17:
        VAR_2 = try_val_to_str(VAR_1, VAR_18);
        break;
    case VAR_19:
        VAR_2 = try_val_to_str(VAR_1, VAR_20);
        if (!VAR_2)
            VAR_2 = ""Button %u"";
        break;
    case VAR_21:
        VAR_2 = try_val_to_str(VAR_1, VAR_22);
        break;
    case VAR_23:
        VAR_2 = try_val_to_str(VAR_1, VAR_24);
        break;
    case VAR_25:
        VAR_2 = try_val_to_str(VAR_1, VAR_26);
        if (!VAR_2)
            VAR_2 = ""Instance %u"";
        break;
    case VAR_27:
        VAR_2 = try_val_to_str(VAR_1, VAR_28);
        break;
    case VAR_29:
        VAR_2 = try_val_to_str(VAR_1, VAR_30);
        if (VAR_1 >= 0x1006 && VAR_1 <= 0x1FFF)
            VAR_2 = ""Reserved for standard waveforms"";
        if (VAR_1 >= 0x2001 && VAR_1 <= 0x2FFF)
            VAR_2 = ""Vendor Waveforms"";
        break;
    case VAR_31:
        VAR_2 = try_val_to_str(VAR_1, VAR_32);
        break;
    case VAR_33:
        VAR_2 = ""Character U+%04X"";
        break;
    case VAR_34:
        VAR_2 = try_val_to_str(VAR_1, VAR_35);
        break;
    case VAR_36:
        VAR_2 = try_val_to_str(VAR_1, VAR_37);
        break;
    case VAR_38:
        VAR_2 = try_val_to_str(VAR_1, VAR_39);
        if (!VAR_2)
            VAR_2 = try_rval_to_str(VAR_1, VAR_40);
        break;
    case VAR_41:
        VAR_2 = try_val_to_str(VAR_1, VAR_42);
        break;
    case VAR_43:
        VAR_2 = try_val_to_str(VAR_1, VAR_44);
        break;
    case VAR_45:
        VAR_2 = try_val_to_str(VAR_1, VAR_46);
        break;
    case VAR_47:
        VAR_2 = try_val_to_str(VAR_1, VAR_48);
        break;
    case VAR_49:
        VAR_2 = ""ENUM_%u"";
        break;
    case VAR_50:
        VAR_2 = try_val_to_str(VAR_1, VAR_51);
        break;
    case VAR_52:
        VAR_2 = try_val_to_str(VAR_1, VAR_53);
        break;
    case VAR_54:
        VAR_2 = try_val_to_str(VAR_1, VAR_55);
        break;
    case VAR_56:
        VAR_2 = try_val_to_str(VAR_1, VAR_57);
        break;
    case VAR_58:
        VAR_2 = try_val_to_str(VAR_1, VAR_59);
        break;
    case VAR_60:
        VAR_2 = try_val_to_str(VAR_1, VAR_61);
        break;
    case VAR_62:
        VAR_2 = try_val_to_str(VAR_1, VAR_63);
        break;
    case VAR_64:
        VAR_2 = try_val_to_str(VAR_1, VAR_65);
        break;
    default:
        if ((VAR_0 & VAR_66) == VAR_66)
            VAR_2 = ""Vendor"";
        break;
    }

    if (!VAR_2)
        VAR_2 = ""Reserved"";

    return wmem_strdup_printf(wmem_packet_scope(), VAR_2, VAR_1);
}",wireshark/26f0db01a7f7e6c69eee2f1c601444c64ca53e19/packet-usb-hid.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,5 +120,5 @@
     if (!str)
         str = ""Reserved"";
 
-    return g_strdup_printf(str, id);
+    return wmem_strdup_printf(wmem_packet_scope(), str, id);
 }","{'deleted_lines': ['    return g_strdup_printf(str, id);'], 'added_lines': ['    return wmem_strdup_printf(wmem_packet_scope(), str, id);']}",True,Memory leak in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2021-22173,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"USB HID: Fix a memory leak.

Replace mismatched g_strdup() + g_free()s with
wmem_strdup_printf(wmem_packet_scope(), ...). Fixes #17124.
",26f0db01a7f7e6c69eee2f1c601444c64ca53e19,https://gitlab.com/wireshark/wireshark/-/commit/26f0db01a7f7e6c69eee2f1c601444c64ca53e19,epan/dissectors/packet-usb-hid.c,dissect_usb_hid_report_localitem_data,"static int
dissect_usb_hid_report_localitem_data(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, unsigned int bSize, unsigned int bTag, struct usb_hid_global_state *global)
{
guint32 id = 0xffff;
proto_item *ti = proto_tree_get_parent(tree);
gchar *str = NULL;
guint32 val;
switch (bTag) {
case USBHID_LOCALITEM_TAG_USAGE:
if (bSize > 2) {
proto_tree_add_item(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN);
} else {
if (bSize == 1)
id = tvb_get_guint8(tvb, offset);
else if (bSize == 2)
id = tvb_get_ntohs(tvb, offset);
str = get_usage_page_item_string(global->usage_page, id);
proto_tree_add_uint_format(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, id, ""Usage: %s (0x%02x)"", str, id);
proto_item_append_text(ti, "" (%s)"", str);
}
break;
case USBHID_LOCALITEM_TAG_USAGE_MIN:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_USAGE_MAX:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_DESIG_INDEX:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_DESIG_MIN:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_DESIG_MAX:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_STRING_INDEX:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_STRING_MIN:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_STRING_MAX:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
case USBHID_LOCALITEM_TAG_DELIMITER:
proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_delimiter, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
proto_item_append_text(ti, "" (0x%02x)"", val);
break;
default:
proto_tree_add_item(tree, hf_usb_hid_item_unk_data, tvb, offset, bSize, ENC_NA);
proto_item_append_text(ti, "" (Unknown)"");
break;
}
offset += bSize;
g_free(str);
return offset;
}","static int
dissect_usb_hid_report_localitem_data(packet_info *VAR_0 _U_, proto_tree *VAR_1, tvbuff_t *VAR_2, int VAR_3, unsigned int VAR_4, unsigned int VAR_5, struct usb_hid_global_state *VAR_6)
{
guint32 VAR_7 = 0xffff;
proto_item *VAR_8 = proto_tree_get_parent(VAR_1);
gchar *VAR_9 = NULL;
guint32 VAR_10;
switch (VAR_5) {
case VAR_11:
if (VAR_4 > 2) {
proto_tree_add_item(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_13);
} else {
if (VAR_4 == 1)
VAR_7 = tvb_get_guint8(VAR_2, VAR_3);
else if (VAR_4 == 2)
VAR_7 = tvb_get_ntohs(VAR_2, VAR_3);
VAR_9 = get_usage_page_item_string(VAR_6->usage_page, VAR_7);
proto_tree_add_uint_format(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_7, ""Usage: %s (0x%02x)"", VAR_9, VAR_7);
proto_item_append_text(VAR_8, "" (%s)"", VAR_9);
}
break;
case VAR_14:
proto_tree_add_item_ret_uint(VAR_1, VAR_15, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_16:
proto_tree_add_item_ret_uint(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_17:
proto_tree_add_item_ret_uint(VAR_1, VAR_18, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_19:
proto_tree_add_item_ret_uint(VAR_1, VAR_20, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_21:
proto_tree_add_item_ret_uint(VAR_1, VAR_22, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_23:
proto_tree_add_item_ret_uint(VAR_1, VAR_24, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_25:
proto_tree_add_item_ret_uint(VAR_1, VAR_26, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_27:
proto_tree_add_item_ret_uint(VAR_1, VAR_28, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
case VAR_29:
proto_tree_add_item_ret_uint(VAR_1, VAR_30, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
break;
default:
proto_tree_add_item(VAR_1, VAR_31, VAR_2, VAR_3, VAR_4, VAR_32);
proto_item_append_text(VAR_8, "" (Unknown)"");
break;
}
VAR_3 += VAR_4;
g_free(VAR_9);
return VAR_3;
}",,"static int
dissect_usb_hid_report_localitem_data(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, unsigned int bSize, unsigned int bTag, struct usb_hid_global_state *global)
{
    guint32 id = 0xffff;
    proto_item *ti = proto_tree_get_parent(tree);
    gchar *str = NULL;
    guint32 val;

    switch (bTag) {
        case USBHID_LOCALITEM_TAG_USAGE:
            if (bSize > 2) {
                /* Full page ID */
                proto_tree_add_item(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN);
            } else {
                /* Only lower few bits given, need to combine with last global ID */
                if (bSize == 1)
                    id = tvb_get_guint8(tvb, offset);
                else if (bSize == 2)
                    id = tvb_get_ntohs(tvb, offset);
                str = get_usage_page_item_string(global->usage_page, id);
                proto_tree_add_uint_format(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, id, ""Usage: %s (0x%02x)"", str, id);
                proto_item_append_text(ti, "" (%s)"", str);
            }
            break;
        case USBHID_LOCALITEM_TAG_USAGE_MIN:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_USAGE_MAX:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_DESIG_INDEX:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_DESIG_MIN:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_DESIG_MAX:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_STRING_INDEX:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_STRING_MIN:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_STRING_MAX:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        case USBHID_LOCALITEM_TAG_DELIMITER:
            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_delimiter, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);
            proto_item_append_text(ti, "" (0x%02x)"", val);
            break;
        default:
            proto_tree_add_item(tree, hf_usb_hid_item_unk_data, tvb, offset, bSize, ENC_NA);
            proto_item_append_text(ti, "" (Unknown)"");
            break;
    }
    offset += bSize;

    return offset;
}","static int
dissect_usb_hid_report_localitem_data(packet_info *VAR_0 _U_, proto_tree *VAR_1, tvbuff_t *VAR_2, int VAR_3, unsigned int VAR_4, unsigned int VAR_5, struct usb_hid_global_state *VAR_6)
{
    guint32 VAR_7 = 0xffff;
    proto_item *VAR_8 = proto_tree_get_parent(VAR_1);
    gchar *VAR_9 = NULL;
    guint32 VAR_10;

    switch (VAR_5) {
        case VAR_11:
            if (VAR_4 > 2) {
                /* COMMENT_0 */
                proto_tree_add_item(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_13);
            } else {
                /* COMMENT_1 */
                if (VAR_4 == 1)
                    VAR_7 = tvb_get_guint8(VAR_2, VAR_3);
                else if (VAR_4 == 2)
                    VAR_7 = tvb_get_ntohs(VAR_2, VAR_3);
                VAR_9 = get_usage_page_item_string(VAR_6->usage_page, VAR_7);
                proto_tree_add_uint_format(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_7, ""Usage: %s (0x%02x)"", VAR_9, VAR_7);
                proto_item_append_text(VAR_8, "" (%s)"", VAR_9);
            }
            break;
        case VAR_14:
            proto_tree_add_item_ret_uint(VAR_1, VAR_15, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_16:
            proto_tree_add_item_ret_uint(VAR_1, VAR_12, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_17:
            proto_tree_add_item_ret_uint(VAR_1, VAR_18, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_19:
            proto_tree_add_item_ret_uint(VAR_1, VAR_20, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_21:
            proto_tree_add_item_ret_uint(VAR_1, VAR_22, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_23:
            proto_tree_add_item_ret_uint(VAR_1, VAR_24, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_25:
            proto_tree_add_item_ret_uint(VAR_1, VAR_26, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_27:
            proto_tree_add_item_ret_uint(VAR_1, VAR_28, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        case VAR_29:
            proto_tree_add_item_ret_uint(VAR_1, VAR_30, VAR_2, VAR_3, VAR_4, VAR_13, &VAR_10);
            proto_item_append_text(VAR_8, "" (0x%02x)"", VAR_10);
            break;
        default:
            proto_tree_add_item(VAR_1, VAR_31, VAR_2, VAR_3, VAR_4, VAR_32);
            proto_item_append_text(VAR_8, "" (Unknown)"");
            break;
    }
    VAR_3 += VAR_4;

    return VAR_3;
}",,"--- func_before
+++ func_after
@@ -65,7 +65,5 @@
     }
     offset += bSize;
 
-    g_free(str);
-
     return offset;
 }","{'deleted_lines': ['    g_free(str);', ''], 'added_lines': []}",True,Memory leak in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,valid,,5
CVE-2020-35524,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libtiff,"tiff2pdf.c: properly calculate datasize when saving to JPEG YCbCr

fixes #220
",c6a12721b46f1a72974f91177890301730d7b330,https://gitlab.com/libtiff/libtiff/-/commit/c6a12721b46f1a72974f91177890301730d7b330,tools/tiff2pdf.c,t2p_read_tiff_size,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){
uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
unsigned char* jpt=NULL;
tstrip_t i=0;
tstrip_t stripcount=0;
#endif
uint64 k = 0;
if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef ZIP_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef OJPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_OJPEG){
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
stripcount=TIFFNumberOfStrips(input);
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
}
if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
if(t2p->tiff_dataoffset != 0){
if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
if((uint64)t2p->tiff_datasize < k) {
TIFFWarning(TIFF2PDF_MODULE, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(input));
t2p->pdf_ojpegiflength=t2p->tiff_datasize;
k = checkAdd64(k, t2p->tiff_datasize, t2p);
k = checkAdd64(k, 6, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
return;
}else {
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
}
}
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, 2048, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
#ifdef JPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_JPEG) {
uint32 count = 0;
if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
if(count > 4){
k += count;
k -= 2; 
}
} else {
k = 2; 
}
stripcount=TIFFNumberOfStrips(input);
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
k -=2; 
k +=2; 
}
k = checkAdd64(k, 2, t2p); 
k = checkAdd64(k, 6, t2p); 
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
(void) 0;
}
k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
}
if (k == 0) {
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){
uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
unsigned char* VAR_5=NULL;
tstrip_t VAR_6=0;
tstrip_t VAR_7=0;
#endif
uint64 VAR_8 = 0;
if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
if(VAR_0->pdf_compression == VAR_11 ){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_15
if(VAR_0->pdf_compression == VAR_16){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_4
if(VAR_0->tiff_compression == VAR_17){
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
VAR_7=TIFFNumberOfStrips(VAR_1);
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
}
if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
if(VAR_0->tiff_dataoffset != 0){
if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
if((uint64)VAR_0->tiff_datasize < VAR_8) {
TIFFWarning(VAR_13, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(VAR_1));
VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
return;
}else {
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
}
}
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
#ifdef VAR_3
if(VAR_0->tiff_compression == VAR_20) {
uint32 VAR_21 = 0;
if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
if(VAR_21 > 4){
VAR_8 += VAR_21;
VAR_8 -= 2; 
}
} else {
VAR_8 = 2; 
}
VAR_7=TIFFNumberOfStrips(VAR_1);
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
VAR_8 -=2; 
VAR_8 +=2; 
}
VAR_8 = checkAdd64(VAR_8, 2, VAR_0); 
VAR_8 = checkAdd64(VAR_8, 6, VAR_0); 
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
(void) 0;
}
VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
if(VAR_0->tiff_planar==VAR_23){
VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
}
if (VAR_8 == 0) {
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}",libtiff/c6a12721b46f1a72974f91177890301730d7b330/tiff2pdf.c/vul/before/0.json,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){

	uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
	unsigned char* jpt=NULL;
	tstrip_t i=0;
	tstrip_t stripcount=0;
#endif
        uint64 k = 0;

	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef ZIP_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef OJPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_OJPEG){
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			stripcount=TIFFNumberOfStrips(input);
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
			}
			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
				if(t2p->tiff_dataoffset != 0){
					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
						if((uint64)t2p->tiff_datasize < k) {
							TIFFWarning(TIFF2PDF_MODULE, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(input));
							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
							k = checkAdd64(k, t2p->tiff_datasize, t2p);
							k = checkAdd64(k, 6, t2p);
							k = checkAdd64(k, stripcount, t2p);
							k = checkAdd64(k, stripcount, t2p);
							t2p->tiff_datasize = (tsize_t) k;
							if ((uint64) t2p->tiff_datasize != k) {
								TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
								t2p->t2p_error = T2P_ERR_ERROR;
							}
							return;
						}
						return;
					}else {
						TIFFError(TIFF2PDF_MODULE, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(input));
							t2p->t2p_error = T2P_ERR_ERROR;
							return;
					}
				}
			}
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, 2048, t2p);
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
#ifdef JPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_JPEG) {
			uint32 count = 0;
			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
				if(count > 4){
					k += count;
					k -= 2; /* don't use EOI of header */
				}
			} else {
				k = 2; /* SOI for first strip */
			}
			stripcount=TIFFNumberOfStrips(input);
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
				k -=2; /* don't use EOI of strip */
				k +=2; /* add space for restart marker */
			}
			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
		(void) 0;
	}
	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
	} else {
		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
		}
	}
	if (k == 0) {
		/* Assume we had overflow inside TIFFScanlineSize */
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	t2p->tiff_datasize = (tsize_t) k;
	if ((uint64) t2p->tiff_datasize != k) {
		TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){

	uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
	unsigned char* VAR_5=NULL;
	tstrip_t VAR_6=0;
	tstrip_t VAR_7=0;
#endif
        uint64 VAR_8 = 0;

	if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
		if(VAR_0->pdf_compression == VAR_11 ){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_15
		if(VAR_0->pdf_compression == VAR_16){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_4
		if(VAR_0->tiff_compression == VAR_17){
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
			}
			if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
				if(VAR_0->tiff_dataoffset != 0){
					if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
						if((uint64)VAR_0->tiff_datasize < VAR_8) {
							TIFFWarning(VAR_13, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(VAR_1));
							VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
							VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
							VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_0->tiff_datasize = (tsize_t) VAR_8;
							if ((uint64) VAR_0->tiff_datasize != VAR_8) {
								TIFFError(VAR_13, ""Integer overflow"");
								VAR_0->t2p_error = VAR_14;
							}
							return;
						}
						return;
					}else {
						TIFFError(VAR_13, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(VAR_1));
							VAR_0->t2p_error = VAR_14;
							return;
					}
				}
			}
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
#ifdef VAR_3
		if(VAR_0->tiff_compression == VAR_20) {
			uint32 VAR_21 = 0;
			if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
				if(VAR_21 > 4){
					VAR_8 += VAR_21;
					VAR_8 -= 2; /* COMMENT_0 */
				}
			} else {
				VAR_8 = 2; /* COMMENT_1 */
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
				VAR_8 -=2; /* COMMENT_2 */
				VAR_8 +=2; /* COMMENT_3 */
			}
			VAR_8 = checkAdd64(VAR_8, 2, VAR_0); /* COMMENT_4 */
			VAR_8 = checkAdd64(VAR_8, 6, VAR_0); /* COMMENT_5 */
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
		(void) 0;
	}
	if(VAR_0->pdf_compression == VAR_23
	   && VAR_0->tiff_photometric == VAR_24) {
		VAR_8 = checkMultiply64(TIFFNumberOfStrips(VAR_1), TIFFStripSize(VAR_1), VAR_0);
	} else {
		VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
		if(VAR_0->tiff_planar==VAR_25){
			VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
		}
	}
	if (VAR_8 == 0) {
		/* COMMENT_6 */
		VAR_0->t2p_error = VAR_14;
	}

	VAR_0->tiff_datasize = (tsize_t) VAR_8;
	if ((uint64) VAR_0->tiff_datasize != VAR_8) {
		TIFFError(VAR_13, ""Integer overflow"");
		VAR_0->t2p_error = VAR_14;
	}

	return;
}",libtiff/c6a12721b46f1a72974f91177890301730d7b330/tiff2pdf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,9 +120,14 @@
 #endif
 		(void) 0;
 	}
-	k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
-	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
-		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
+	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
+	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
+		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
+	} else {
+		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
+		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
+			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
+		}
 	}
 	if (k == 0) {
 		/* Assume we had overflow inside TIFFScanlineSize */","{'deleted_lines': ['\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);', '\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){', '\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);'], 'added_lines': ['\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG', '\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {', '\t\tk = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);', '\t} else {', '\t\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);', '\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){', '\t\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);', '\t\t}']}",True,"A heap-based buffer overflow flaw was found in libtiff in the handling of TIFF images in libtiff's TIFF2PDF tool. A specially crafted TIFF file can lead to arbitrary code execution. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2020-35524,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libtiff,"Fix for building without JPEG support
",d74f56e3b7ea55c8a18a03bc247cd5fd0ca288b2,https://gitlab.com/libtiff/libtiff/-/commit/d74f56e3b7ea55c8a18a03bc247cd5fd0ca288b2,tools/tiff2pdf.c,t2p_read_tiff_size,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){
uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
unsigned char* jpt=NULL;
tstrip_t i=0;
tstrip_t stripcount=0;
#endif
uint64 k = 0;
if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef ZIP_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef OJPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_OJPEG){
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
stripcount=TIFFNumberOfStrips(input);
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
}
if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
if(t2p->tiff_dataoffset != 0){
if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
if((uint64)t2p->tiff_datasize < k) {
TIFFWarning(TIFF2PDF_MODULE, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(input));
t2p->pdf_ojpegiflength=t2p->tiff_datasize;
k = checkAdd64(k, t2p->tiff_datasize, t2p);
k = checkAdd64(k, 6, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
return;
}else {
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
}
}
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, 2048, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
#ifdef JPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_JPEG) {
uint32 count = 0;
if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
if(count > 4){
k += count;
k -= 2; 
}
} else {
k = 2; 
}
stripcount=TIFFNumberOfStrips(input);
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
k -=2; 
k +=2; 
}
k = checkAdd64(k, 2, t2p); 
k = checkAdd64(k, 6, t2p); 
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
(void) 0;
}
if(t2p->pdf_compression == T2P_COMPRESS_JPEG
&& t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
} else {
k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
}
}
if (k == 0) {
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){
uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
unsigned char* VAR_5=NULL;
tstrip_t VAR_6=0;
tstrip_t VAR_7=0;
#endif
uint64 VAR_8 = 0;
if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
if(VAR_0->pdf_compression == VAR_11 ){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_15
if(VAR_0->pdf_compression == VAR_16){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_4
if(VAR_0->tiff_compression == VAR_17){
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
VAR_7=TIFFNumberOfStrips(VAR_1);
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
}
if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
if(VAR_0->tiff_dataoffset != 0){
if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
if((uint64)VAR_0->tiff_datasize < VAR_8) {
TIFFWarning(VAR_13, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(VAR_1));
VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
return;
}else {
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
}
}
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
#ifdef VAR_3
if(VAR_0->tiff_compression == VAR_20) {
uint32 VAR_21 = 0;
if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
if(VAR_21 > 4){
VAR_8 += VAR_21;
VAR_8 -= 2; 
}
} else {
VAR_8 = 2; 
}
VAR_7=TIFFNumberOfStrips(VAR_1);
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
VAR_8 -=2; 
VAR_8 +=2; 
}
VAR_8 = checkAdd64(VAR_8, 2, VAR_0); 
VAR_8 = checkAdd64(VAR_8, 6, VAR_0); 
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
(void) 0;
}
if(VAR_0->pdf_compression == VAR_23
&& VAR_0->tiff_photometric == VAR_24) {
VAR_8 = checkMultiply64(TIFFNumberOfStrips(VAR_1), TIFFStripSize(VAR_1), VAR_0);
} else {
VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
if(VAR_0->tiff_planar==VAR_25){
VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
}
}
if (VAR_8 == 0) {
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}",libtiff/d74f56e3b7ea55c8a18a03bc247cd5fd0ca288b2/tiff2pdf.c/vul/before/0.json,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){

	uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
	unsigned char* jpt=NULL;
	tstrip_t i=0;
	tstrip_t stripcount=0;
#endif
        uint64 k = 0;

	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef ZIP_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef OJPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_OJPEG){
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			stripcount=TIFFNumberOfStrips(input);
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
			}
			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
				if(t2p->tiff_dataoffset != 0){
					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
						if((uint64)t2p->tiff_datasize < k) {
							TIFFWarning(TIFF2PDF_MODULE, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(input));
							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
							k = checkAdd64(k, t2p->tiff_datasize, t2p);
							k = checkAdd64(k, 6, t2p);
							k = checkAdd64(k, stripcount, t2p);
							k = checkAdd64(k, stripcount, t2p);
							t2p->tiff_datasize = (tsize_t) k;
							if ((uint64) t2p->tiff_datasize != k) {
								TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
								t2p->t2p_error = T2P_ERR_ERROR;
							}
							return;
						}
						return;
					}else {
						TIFFError(TIFF2PDF_MODULE, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(input));
							t2p->t2p_error = T2P_ERR_ERROR;
							return;
					}
				}
			}
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, 2048, t2p);
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
#ifdef JPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_JPEG) {
			uint32 count = 0;
			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
				if(count > 4){
					k += count;
					k -= 2; /* don't use EOI of header */
				}
			} else {
				k = 2; /* SOI for first strip */
			}
			stripcount=TIFFNumberOfStrips(input);
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
				k -=2; /* don't use EOI of strip */
				k +=2; /* add space for restart marker */
			}
			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
		(void) 0;
	}
#ifdef JPEG_SUPPORT
	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
	} else
#endif
	{
		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
		}
	}
	if (k == 0) {
		/* Assume we had overflow inside TIFFScanlineSize */
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	t2p->tiff_datasize = (tsize_t) k;
	if ((uint64) t2p->tiff_datasize != k) {
		TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){

	uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
	unsigned char* VAR_5=NULL;
	tstrip_t VAR_6=0;
	tstrip_t VAR_7=0;
#endif
        uint64 VAR_8 = 0;

	if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
		if(VAR_0->pdf_compression == VAR_11 ){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_15
		if(VAR_0->pdf_compression == VAR_16){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_4
		if(VAR_0->tiff_compression == VAR_17){
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
			}
			if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
				if(VAR_0->tiff_dataoffset != 0){
					if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
						if((uint64)VAR_0->tiff_datasize < VAR_8) {
							TIFFWarning(VAR_13, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(VAR_1));
							VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
							VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
							VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_0->tiff_datasize = (tsize_t) VAR_8;
							if ((uint64) VAR_0->tiff_datasize != VAR_8) {
								TIFFError(VAR_13, ""Integer overflow"");
								VAR_0->t2p_error = VAR_14;
							}
							return;
						}
						return;
					}else {
						TIFFError(VAR_13, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(VAR_1));
							VAR_0->t2p_error = VAR_14;
							return;
					}
				}
			}
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
#ifdef VAR_3
		if(VAR_0->tiff_compression == VAR_20) {
			uint32 VAR_21 = 0;
			if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
				if(VAR_21 > 4){
					VAR_8 += VAR_21;
					VAR_8 -= 2; /* COMMENT_0 */
				}
			} else {
				VAR_8 = 2; /* COMMENT_1 */
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
				VAR_8 -=2; /* COMMENT_2 */
				VAR_8 +=2; /* COMMENT_3 */
			}
			VAR_8 = checkAdd64(VAR_8, 2, VAR_0); /* COMMENT_4 */
			VAR_8 = checkAdd64(VAR_8, 6, VAR_0); /* COMMENT_5 */
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
		(void) 0;
	}
#ifdef VAR_3
	if(VAR_0->pdf_compression == VAR_23
	   && VAR_0->tiff_photometric == VAR_24) {
		VAR_8 = checkMultiply64(TIFFNumberOfStrips(VAR_1), TIFFStripSize(VAR_1), VAR_0);
	} else
#endif
	{
		VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
		if(VAR_0->tiff_planar==VAR_25){
			VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
		}
	}
	if (VAR_8 == 0) {
		/* COMMENT_6 */
		VAR_0->t2p_error = VAR_14;
	}

	VAR_0->tiff_datasize = (tsize_t) VAR_8;
	if ((uint64) VAR_0->tiff_datasize != VAR_8) {
		TIFFError(VAR_13, ""Integer overflow"");
		VAR_0->t2p_error = VAR_14;
	}

	return;
}",libtiff/d74f56e3b7ea55c8a18a03bc247cd5fd0ca288b2/tiff2pdf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,10 +120,13 @@
 #endif
 		(void) 0;
 	}
+#ifdef JPEG_SUPPORT
 	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
 	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
 		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
-	} else {
+	} else
+#endif
+	{
 		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
 		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
 			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);","{'deleted_lines': ['\t} else {'], 'added_lines': ['#ifdef JPEG_SUPPORT', '\t} else', '#endif', '\t{']}",True,"A heap-based buffer overflow flaw was found in libtiff in the handling of TIFF images in libtiff's TIFF2PDF tool. A specially crafted TIFF file can lead to arbitrary code execution. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2020-35524,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,rzkn/libtiff,"tiff2pdf.c: properly calculate datasize when saving to JPEG YCbCr

fixes #220
",7be2e452ddcf6d7abca88f41d3761e6edab72b22,https://gitlab.com/rzkn/libtiff/-/commit/7be2e452ddcf6d7abca88f41d3761e6edab72b22,tools/tiff2pdf.c,t2p_read_tiff_size,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){
uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
unsigned char* jpt=NULL;
tstrip_t i=0;
tstrip_t stripcount=0;
#endif
uint64 k = 0;
if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef ZIP_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize=(tmsize_t)sbc[0];
return;
}
#endif
#ifdef OJPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_OJPEG){
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
stripcount=TIFFNumberOfStrips(input);
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
}
if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
if(t2p->tiff_dataoffset != 0){
if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
if((uint64)t2p->tiff_datasize < k) {
TIFFWarning(TIFF2PDF_MODULE, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(input));
t2p->pdf_ojpegiflength=t2p->tiff_datasize;
k = checkAdd64(k, t2p->tiff_datasize, t2p);
k = checkAdd64(k, 6, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
return;
}else {
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
}
}
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, stripcount, t2p);
k = checkAdd64(k, 2048, t2p);
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
#ifdef JPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_JPEG) {
uint32 count = 0;
if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
if(count > 4){
k += count;
k -= 2; 
}
} else {
k = 2; 
}
stripcount=TIFFNumberOfStrips(input);
if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
TIFFError(TIFF2PDF_MODULE, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return;
}
for(i=0;i<stripcount;i++){
k = checkAdd64(k, sbc[i], t2p);
k -=2; 
k +=2; 
}
k = checkAdd64(k, 2, t2p); 
k = checkAdd64(k, 6, t2p); 
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}
#endif
(void) 0;
}
k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
}
if (k == 0) {
t2p->t2p_error = T2P_ERR_ERROR;
}
t2p->tiff_datasize = (tsize_t) k;
if ((uint64) t2p->tiff_datasize != k) {
TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
t2p->t2p_error = T2P_ERR_ERROR;
}
return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){
uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
unsigned char* VAR_5=NULL;
tstrip_t VAR_6=0;
tstrip_t VAR_7=0;
#endif
uint64 VAR_8 = 0;
if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
if(VAR_0->pdf_compression == VAR_11 ){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_15
if(VAR_0->pdf_compression == VAR_16){
TIFFGetField(VAR_1, VAR_12, &VAR_2);
if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
return;
}
#endif
#ifdef VAR_4
if(VAR_0->tiff_compression == VAR_17){
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
VAR_7=TIFFNumberOfStrips(VAR_1);
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
}
if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
if(VAR_0->tiff_dataoffset != 0){
if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
if((uint64)VAR_0->tiff_datasize < VAR_8) {
TIFFWarning(VAR_13, 
""Input file %s has short JPEG interchange file byte count"", 
TIFFFileName(VAR_1));
VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
return;
}else {
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
}
}
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
#ifdef VAR_3
if(VAR_0->tiff_compression == VAR_20) {
uint32 VAR_21 = 0;
if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
if(VAR_21 > 4){
VAR_8 += VAR_21;
VAR_8 -= 2; 
}
} else {
VAR_8 = 2; 
}
VAR_7=TIFFNumberOfStrips(VAR_1);
if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
TIFFError(VAR_13, 
""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_14;
return;
}
for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
VAR_8 -=2; 
VAR_8 +=2; 
}
VAR_8 = checkAdd64(VAR_8, 2, VAR_0); 
VAR_8 = checkAdd64(VAR_8, 6, VAR_0); 
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}
#endif
(void) 0;
}
VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
if(VAR_0->tiff_planar==VAR_23){
VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
}
if (VAR_8 == 0) {
VAR_0->t2p_error = VAR_14;
}
VAR_0->tiff_datasize = (tsize_t) VAR_8;
if ((uint64) VAR_0->tiff_datasize != VAR_8) {
TIFFError(VAR_13, ""Integer overflow"");
VAR_0->t2p_error = VAR_14;
}
return;
}",rzkn/libtiff/7be2e452ddcf6d7abca88f41d3761e6edab72b22/tiff2pdf.c/vul/before/0.json,"void t2p_read_tiff_size(T2P* t2p, TIFF* input){

	uint64* sbc=NULL;
#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
	unsigned char* jpt=NULL;
	tstrip_t i=0;
	tstrip_t stripcount=0;
#endif
        uint64 k = 0;

	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
#ifdef CCITT_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef ZIP_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
                TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
                t2p->t2p_error = T2P_ERR_ERROR;
            }
			t2p->tiff_datasize=(tmsize_t)sbc[0];
			return;
		}
#endif
#ifdef OJPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_OJPEG){
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			stripcount=TIFFNumberOfStrips(input);
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
			}
			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
				if(t2p->tiff_dataoffset != 0){
					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
						if((uint64)t2p->tiff_datasize < k) {
							TIFFWarning(TIFF2PDF_MODULE, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(input));
							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
							k = checkAdd64(k, t2p->tiff_datasize, t2p);
							k = checkAdd64(k, 6, t2p);
							k = checkAdd64(k, stripcount, t2p);
							k = checkAdd64(k, stripcount, t2p);
							t2p->tiff_datasize = (tsize_t) k;
							if ((uint64) t2p->tiff_datasize != k) {
								TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
								t2p->t2p_error = T2P_ERR_ERROR;
							}
							return;
						}
						return;
					}else {
						TIFFError(TIFF2PDF_MODULE, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(input));
							t2p->t2p_error = T2P_ERR_ERROR;
							return;
					}
				}
			}
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, stripcount, t2p);
			k = checkAdd64(k, 2048, t2p);
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
#ifdef JPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_JPEG) {
			uint32 count = 0;
			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
				if(count > 4){
					k += count;
					k -= 2; /* don't use EOI of header */
				}
			} else {
				k = 2; /* SOI for first strip */
			}
			stripcount=TIFFNumberOfStrips(input);
			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
				TIFFError(TIFF2PDF_MODULE, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return;
			}
			for(i=0;i<stripcount;i++){
				k = checkAdd64(k, sbc[i], t2p);
				k -=2; /* don't use EOI of strip */
				k +=2; /* add space for restart marker */
			}
			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
			t2p->tiff_datasize = (tsize_t) k;
			if ((uint64) t2p->tiff_datasize != k) {
				TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
				t2p->t2p_error = T2P_ERR_ERROR;
			}
			return;
		}
#endif
		(void) 0;
	}
#ifdef JPEG_SUPPORT
	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
	} else
#endif
	{
		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
		}
	}
	if (k == 0) {
		/* Assume we had overflow inside TIFFScanlineSize */
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	t2p->tiff_datasize = (tsize_t) k;
	if ((uint64) t2p->tiff_datasize != k) {
		TIFFError(TIFF2PDF_MODULE, ""Integer overflow"");
		t2p->t2p_error = T2P_ERR_ERROR;
	}

	return;
}","void t2p_read_tiff_size(T2P* VAR_0, TIFF* VAR_1){

	uint64* VAR_2=NULL;
#if defined(VAR_3) || defined (VAR_4)
	unsigned char* VAR_5=NULL;
	tstrip_t VAR_6=0;
	tstrip_t VAR_7=0;
#endif
        uint64 VAR_8 = 0;

	if(VAR_0->pdf_transcode == VAR_9){
#ifdef VAR_10
		if(VAR_0->pdf_compression == VAR_11 ){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_15
		if(VAR_0->pdf_compression == VAR_16){
			TIFFGetField(VAR_1, VAR_12, &VAR_2);
            if (VAR_2[0] != (uint64)(tmsize_t)VAR_2[0]) {
                TIFFError(VAR_13, ""Integer overflow"");
                VAR_0->t2p_error = VAR_14;
            }
			VAR_0->tiff_datasize=(tmsize_t)VAR_2[0];
			return;
		}
#endif
#ifdef VAR_4
		if(VAR_0->tiff_compression == VAR_17){
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
			}
			if(TIFFGetField(VAR_1, VAR_18, &(VAR_0->tiff_dataoffset))){
				if(VAR_0->tiff_dataoffset != 0){
					if(TIFFGetField(VAR_1, VAR_19, &(VAR_0->tiff_datasize))!=0){
						if((uint64)VAR_0->tiff_datasize < VAR_8) {
							TIFFWarning(VAR_13, 
								""Input file %s has short JPEG interchange file byte count"", 
								TIFFFileName(VAR_1));
							VAR_0->pdf_ojpegiflength=VAR_0->tiff_datasize;
							VAR_8 = checkAdd64(VAR_8, VAR_0->tiff_datasize, VAR_0);
							VAR_8 = checkAdd64(VAR_8, 6, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
							VAR_0->tiff_datasize = (tsize_t) VAR_8;
							if ((uint64) VAR_0->tiff_datasize != VAR_8) {
								TIFFError(VAR_13, ""Integer overflow"");
								VAR_0->t2p_error = VAR_14;
							}
							return;
						}
						return;
					}else {
						TIFFError(VAR_13, 
							""Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT"",
							TIFFFileName(VAR_1));
							VAR_0->t2p_error = VAR_14;
							return;
					}
				}
			}
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, VAR_7, VAR_0);
			VAR_8 = checkAdd64(VAR_8, 2048, VAR_0);
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
#ifdef VAR_3
		if(VAR_0->tiff_compression == VAR_20) {
			uint32 VAR_21 = 0;
			if(TIFFGetField(VAR_1, VAR_22, &VAR_21, &VAR_5) != 0 ){
				if(VAR_21 > 4){
					VAR_8 += VAR_21;
					VAR_8 -= 2; /* COMMENT_0 */
				}
			} else {
				VAR_8 = 2; /* COMMENT_1 */
			}
			VAR_7=TIFFNumberOfStrips(VAR_1);
			if(!TIFFGetField(VAR_1, VAR_12, &VAR_2)){
				TIFFError(VAR_13, 
					""Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS"",
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_14;
				return;
			}
			for(VAR_6=0;VAR_6<VAR_7;VAR_6++){
				VAR_8 = checkAdd64(VAR_8, VAR_2[VAR_6], VAR_0);
				VAR_8 -=2; /* COMMENT_2 */
				VAR_8 +=2; /* COMMENT_3 */
			}
			VAR_8 = checkAdd64(VAR_8, 2, VAR_0); /* COMMENT_4 */
			VAR_8 = checkAdd64(VAR_8, 6, VAR_0); /* COMMENT_5 */
			VAR_0->tiff_datasize = (tsize_t) VAR_8;
			if ((uint64) VAR_0->tiff_datasize != VAR_8) {
				TIFFError(VAR_13, ""Integer overflow"");
				VAR_0->t2p_error = VAR_14;
			}
			return;
		}
#endif
		(void) 0;
	}
#ifdef VAR_3
	if(VAR_0->pdf_compression == VAR_23
	   && VAR_0->tiff_photometric == VAR_24) {
		VAR_8 = checkMultiply64(TIFFNumberOfStrips(VAR_1), TIFFStripSize(VAR_1), VAR_0);
	} else
#endif
	{
		VAR_8 = checkMultiply64(TIFFScanlineSize(VAR_1), VAR_0->tiff_length, VAR_0);
		if(VAR_0->tiff_planar==VAR_25){
			VAR_8 = checkMultiply64(VAR_8, VAR_0->tiff_samplesperpixel, VAR_0);
		}
	}
	if (VAR_8 == 0) {
		/* COMMENT_6 */
		VAR_0->t2p_error = VAR_14;
	}

	VAR_0->tiff_datasize = (tsize_t) VAR_8;
	if ((uint64) VAR_0->tiff_datasize != VAR_8) {
		TIFFError(VAR_13, ""Integer overflow"");
		VAR_0->t2p_error = VAR_14;
	}

	return;
}",rzkn/libtiff/7be2e452ddcf6d7abca88f41d3761e6edab72b22/tiff2pdf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -120,9 +120,17 @@
 #endif
 		(void) 0;
 	}
-	k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
-	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
-		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
+#ifdef JPEG_SUPPORT
+	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
+	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {
+		k = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);
+	} else
+#endif
+	{
+		k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
+		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
+			k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
+		}
 	}
 	if (k == 0) {
 		/* Assume we had overflow inside TIFFScanlineSize */","{'deleted_lines': ['\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);', '\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){', '\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);'], 'added_lines': ['#ifdef JPEG_SUPPORT', '\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG', '\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR) {', '\t\tk = checkMultiply64(TIFFNumberOfStrips(input), TIFFStripSize(input), t2p);', '\t} else', '#endif', '\t{', '\t\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);', '\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){', '\t\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);', '\t\t}']}",True,"A heap-based buffer overflow flaw was found in libtiff in the handling of TIFF images in libtiff's TIFF2PDF tool. A specially crafted TIFF file can lead to arbitrary code execution. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",7.8,HIGH,2,valid,,5
CVE-2021-28375,['CWE-862'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Verify that user applications are not using the kernel RPC message
handle to restrict them from directly attaching to guest OS on the
remote subsystem. This is a port of CVE-2019-2308 fix.

Fixes: c68cfb718c8f (""misc: fastrpc: Add support for context Invoke method"")
Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Cc: Jonathan Marek <jonathan@marek.ca>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Link: https://lore.kernel.org/r/20210212192658.3476137-1-dmitry.baryshkov@linaro.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",20c40794eb85ea29852d7bc37c55713802a543d6,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=20c40794eb85ea29852d7bc37c55713802a543d6,drivers/misc/fastrpc.c,fastrpc_internal_invoke,"static int fastrpc_internal_invoke(struct fastrpc_user *fl,  u32 kernel,
u32 handle, u32 sc,
struct fastrpc_invoke_args *args)
{
struct fastrpc_invoke_ctx *ctx = NULL;
int err = 0;
if (!fl->sctx)
return -EINVAL;
if (!fl->cctx->rpdev)
return -EPIPE;
ctx = fastrpc_context_alloc(fl, kernel, sc, args);
if (IS_ERR(ctx))
return PTR_ERR(ctx);
if (ctx->nscalars) {
err = fastrpc_get_args(kernel, ctx);
if (err)
goto bail;
}
dma_wmb();
err = fastrpc_invoke_send(fl->sctx, ctx, kernel, handle);
if (err)
goto bail;
if (kernel) {
if (!wait_for_completion_timeout(&ctx->work, 10 * HZ))
err = -ETIMEDOUT;
} else {
err = wait_for_completion_interruptible(&ctx->work);
}
if (err)
goto bail;
err = ctx->retval;
if (err)
goto bail;
if (ctx->nscalars) {
dma_rmb();
err = fastrpc_put_args(ctx, kernel);
if (err)
goto bail;
}
bail:
if (err != -ERESTARTSYS && err != -ETIMEDOUT) {
spin_lock(&fl->lock);
list_del(&ctx->node);
spin_unlock(&fl->lock);
fastrpc_context_put(ctx);
}
if (err)
dev_dbg(fl->sctx->dev, ""Error: Invoke Failed %d\n"", err);
return err;
}","static int fastrpc_internal_invoke(struct fastrpc_user *VAR_0,  u32 VAR_1,
u32 VAR_2, u32 VAR_3,
struct fastrpc_invoke_args *VAR_4)
{
struct fastrpc_invoke_ctx *VAR_5 = NULL;
int VAR_6 = 0;
if (!VAR_0->sctx)
return -VAR_7;
if (!VAR_0->cctx->rpdev)
return -VAR_8;
VAR_5 = fastrpc_context_alloc(VAR_0, VAR_1, VAR_3, VAR_4);
if (IS_ERR(VAR_5))
return PTR_ERR(VAR_5);
if (VAR_5->nscalars) {
VAR_6 = fastrpc_get_args(VAR_1, VAR_5);
if (VAR_6)
goto bail;
}
dma_wmb();
VAR_6 = fastrpc_invoke_send(VAR_0->sctx, VAR_5, VAR_1, VAR_2);
if (VAR_6)
goto bail;
if (VAR_1) {
if (!wait_for_completion_timeout(&VAR_5->work, 10 * VAR_9))
VAR_6 = -VAR_10;
} else {
VAR_6 = wait_for_completion_interruptible(&VAR_5->work);
}
if (VAR_6)
goto bail;
VAR_6 = VAR_5->retval;
if (VAR_6)
goto bail;
if (VAR_5->nscalars) {
dma_rmb();
VAR_6 = fastrpc_put_args(VAR_5, VAR_1);
if (VAR_6)
goto bail;
}
bail:
if (VAR_6 != -VAR_11 && VAR_6 != -VAR_10) {
spin_lock(&VAR_0->lock);
list_del(&VAR_5->node);
spin_unlock(&VAR_0->lock);
fastrpc_context_put(VAR_5);
}
if (VAR_6)
dev_dbg(VAR_0->sctx->dev, ""Error: Invoke Failed %d\n"", VAR_6);
return VAR_6;
}",torvalds/linux/20c40794eb85ea29852d7bc37c55713802a543d6/fastrpc.c/vul/before/0.json,"static int fastrpc_internal_invoke(struct fastrpc_user *fl,  u32 kernel,
				   u32 handle, u32 sc,
				   struct fastrpc_invoke_args *args)
{
	struct fastrpc_invoke_ctx *ctx = NULL;
	int err = 0;

	if (!fl->sctx)
		return -EINVAL;

	if (!fl->cctx->rpdev)
		return -EPIPE;

	if (handle == FASTRPC_INIT_HANDLE && !kernel) {
		dev_warn_ratelimited(fl->sctx->dev, ""user app trying to send a kernel RPC message (%d)\n"",  handle);
		return -EPERM;
	}

	ctx = fastrpc_context_alloc(fl, kernel, sc, args);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	if (ctx->nscalars) {
		err = fastrpc_get_args(kernel, ctx);
		if (err)
			goto bail;
	}

	/* make sure that all CPU memory writes are seen by DSP */
	dma_wmb();
	/* Send invoke buffer to remote dsp */
	err = fastrpc_invoke_send(fl->sctx, ctx, kernel, handle);
	if (err)
		goto bail;

	if (kernel) {
		if (!wait_for_completion_timeout(&ctx->work, 10 * HZ))
			err = -ETIMEDOUT;
	} else {
		err = wait_for_completion_interruptible(&ctx->work);
	}

	if (err)
		goto bail;

	/* Check the response from remote dsp */
	err = ctx->retval;
	if (err)
		goto bail;

	if (ctx->nscalars) {
		/* make sure that all memory writes by DSP are seen by CPU */
		dma_rmb();
		/* populate all the output buffers with results */
		err = fastrpc_put_args(ctx, kernel);
		if (err)
			goto bail;
	}

bail:
	if (err != -ERESTARTSYS && err != -ETIMEDOUT) {
		/* We are done with this compute context */
		spin_lock(&fl->lock);
		list_del(&ctx->node);
		spin_unlock(&fl->lock);
		fastrpc_context_put(ctx);
	}
	if (err)
		dev_dbg(fl->sctx->dev, ""Error: Invoke Failed %d\n"", err);

	return err;
}","static int fastrpc_internal_invoke(struct fastrpc_user *VAR_0,  u32 VAR_1,
				   u32 VAR_2, u32 VAR_3,
				   struct fastrpc_invoke_args *VAR_4)
{
	struct fastrpc_invoke_ctx *VAR_5 = NULL;
	int VAR_6 = 0;

	if (!VAR_0->sctx)
		return -VAR_7;

	if (!VAR_0->cctx->rpdev)
		return -VAR_8;

	if (VAR_2 == VAR_9 && !VAR_1) {
		dev_warn_ratelimited(VAR_0->sctx->dev, ""user app trying to send a kernel RPC message (%d)\n"",  VAR_2);
		return -VAR_10;
	}

	VAR_5 = fastrpc_context_alloc(VAR_0, VAR_1, VAR_3, VAR_4);
	if (IS_ERR(VAR_5))
		return PTR_ERR(VAR_5);

	if (VAR_5->nscalars) {
		VAR_6 = fastrpc_get_args(VAR_1, VAR_5);
		if (VAR_6)
			goto bail;
	}

	/* COMMENT_0 */
	dma_wmb();
	/* COMMENT_1 */
	VAR_6 = fastrpc_invoke_send(VAR_0->sctx, VAR_5, VAR_1, VAR_2);
	if (VAR_6)
		goto bail;

	if (VAR_1) {
		if (!wait_for_completion_timeout(&VAR_5->work, 10 * VAR_11))
			VAR_6 = -VAR_12;
	} else {
		VAR_6 = wait_for_completion_interruptible(&VAR_5->work);
	}

	if (VAR_6)
		goto bail;

	/* COMMENT_2 */
	VAR_6 = VAR_5->retval;
	if (VAR_6)
		goto bail;

	if (VAR_5->nscalars) {
		/* COMMENT_3 */
		dma_rmb();
		/* COMMENT_4 */
		VAR_6 = fastrpc_put_args(VAR_5, VAR_1);
		if (VAR_6)
			goto bail;
	}

bail:
	if (VAR_6 != -VAR_13 && VAR_6 != -VAR_12) {
		/* COMMENT_5 */
		spin_lock(&VAR_0->lock);
		list_del(&VAR_5->node);
		spin_unlock(&VAR_0->lock);
		fastrpc_context_put(VAR_5);
	}
	if (VAR_6)
		dev_dbg(VAR_0->sctx->dev, ""Error: Invoke Failed %d\n"", VAR_6);

	return VAR_6;
}",torvalds/linux/20c40794eb85ea29852d7bc37c55713802a543d6/fastrpc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,11 @@
 
 	if (!fl->cctx->rpdev)
 		return -EPIPE;
+
+	if (handle == FASTRPC_INIT_HANDLE && !kernel) {
+		dev_warn_ratelimited(fl->sctx->dev, ""user app trying to send a kernel RPC message (%d)\n"",  handle);
+		return -EPERM;
+	}
 
 	ctx = fastrpc_context_alloc(fl, kernel, sc, args);
 	if (IS_ERR(ctx))","{'deleted_lines': [], 'added_lines': ['', '\tif (handle == FASTRPC_INIT_HANDLE && !kernel) {', '\t\tdev_warn_ratelimited(fl->sctx->dev, ""user app trying to send a kernel RPC message (%d)\\n"",  handle);', '\t\treturn -EPERM;', '\t}']}",True,"An issue was discovered in the Linux kernel through 5.11.6. fastrpc_internal_invoke in drivers/misc/fastrpc.c does not prevent user applications from sending kernel RPC messages, aka CID-20c40794eb85. This is a related issue to CVE-2019-2308.",7.8,HIGH,2,valid,,5
CVE-2020-36310,['CWE-835'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"When a nested page fault is taken from an address that does not have
a memslot associated to it, kvm_mmu_do_page_fault returns RET_PF_EMULATE
(via mmu_set_spte) and kvm_mmu_page_fault then invokes svm_need_emulation_on_page_fault.

The default answer there is to return false, but in this case this just
causes the page fault to be retried ad libitum.  Since this is not a
fast path, and the only other case where it is taken is an erratum,
just stick a kvm_vcpu_gfn_to_memslot check in there to detect the
common case where the erratum is not happening.

This fixes an infinite loop in the new set_memory_region_test.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
",e72436bc3a5206f95bb384e741154166ddb3202e,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=e72436bc3a5206f95bb384e741154166ddb3202e,arch/x86/kvm/svm/svm.c,svm_need_emulation_on_page_fault,"static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)
{
unsigned long cr4 = kvm_read_cr4(vcpu);
bool smep = cr4 & X86_CR4_SMEP;
bool smap = cr4 & X86_CR4_SMAP;
bool is_user = svm_get_cpl(vcpu) == 3;
if (smap && (!smep || is_user)) {
if (!sev_guest(vcpu->kvm))
return true;
pr_err_ratelimited(""KVM: SEV Guest triggered AMD Erratum 1096\n"");
kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
}
return false;
}","static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *VAR_0)
{
unsigned long VAR_1 = kvm_read_cr4(VAR_0);
bool VAR_2 = VAR_1 & VAR_3;
bool VAR_4 = VAR_1 & VAR_5;
bool VAR_6 = svm_get_cpl(VAR_0) == 3;
if (VAR_4 && (!VAR_2 || VAR_6)) {
if (!sev_guest(VAR_0->kvm))
return true;
pr_err_ratelimited(""KVM: SEV Guest triggered AMD Erratum 1096\n"");
kvm_make_request(VAR_7, VAR_0);
}
return false;
}",torvalds/linux/e72436bc3a5206f95bb384e741154166ddb3202e/svm.c/vul/before/0.json,"static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)
{
	unsigned long cr4 = kvm_read_cr4(vcpu);
	bool smep = cr4 & X86_CR4_SMEP;
	bool smap = cr4 & X86_CR4_SMAP;
	bool is_user = svm_get_cpl(vcpu) == 3;

	/*
	 * If RIP is invalid, go ahead with emulation which will cause an
	 * internal error exit.
	 */
	if (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))
		return true;

	/*
	 * Detect and workaround Errata 1096 Fam_17h_00_0Fh.
	 *
	 * Errata:
	 * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is
	 * possible that CPU microcode implementing DecodeAssist will fail
	 * to read bytes of instruction which caused #NPF. In this case,
	 * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly
	 * return 0 instead of the correct guest instruction bytes.
	 *
	 * This happens because CPU microcode reading instruction bytes
	 * uses a special opcode which attempts to read data using CPL=0
	 * priviledges. The microcode reads CS:RIP and if it hits a SMAP
	 * fault, it gives up and returns no instruction bytes.
	 *
	 * Detection:
	 * We reach here in case CPU supports DecodeAssist, raised #NPF and
	 * returned 0 in GuestIntrBytes field of the VMCB.
	 * First, errata can only be triggered in case vCPU CR4.SMAP=1.
	 * Second, if vCPU CR4.SMEP=1, errata could only be triggered
	 * in case vCPU CPL==3 (Because otherwise guest would have triggered
	 * a SMEP fault instead of #NPF).
	 * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.
	 * As most guests enable SMAP if they have also enabled SMEP, use above
	 * logic in order to attempt minimize false-positive of detecting errata
	 * while still preserving all cases semantic correctness.
	 *
	 * Workaround:
	 * To determine what instruction the guest was executing, the hypervisor
	 * will have to decode the instruction at the instruction pointer.
	 *
	 * In non SEV guest, hypervisor will be able to read the guest
	 * memory to decode the instruction pointer when insn_len is zero
	 * so we return true to indicate that decoding is possible.
	 *
	 * But in the SEV guest, the guest memory is encrypted with the
	 * guest specific key and hypervisor will not be able to decode the
	 * instruction pointer so we will not able to workaround it. Lets
	 * print the error and request to kill the guest.
	 */
	if (smap && (!smep || is_user)) {
		if (!sev_guest(vcpu->kvm))
			return true;

		pr_err_ratelimited(""KVM: SEV Guest triggered AMD Erratum 1096\n"");
		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
	}

	return false;
}","static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *VAR_0)
{
	unsigned long VAR_1 = kvm_read_cr4(VAR_0);
	bool VAR_2 = VAR_1 & VAR_3;
	bool VAR_4 = VAR_1 & VAR_5;
	bool VAR_6 = svm_get_cpl(VAR_0) == 3;

	/* COMMENT_0 */
                                                                  
                        
    
	if (!kvm_vcpu_gfn_to_memslot(VAR_0, kvm_rip_read(VAR_0) >> VAR_7))
		return true;

	/* COMMENT_4 */
                                                     
   
           
                                                                       
                                                                   
                                                                 
                                                                 
                                                            
   
                                                                
                                                                 
                                                                 
                                                        
   
              
                                                                    
                                                   
                                                                
                                                              
                                                                     
                                  
                                                                          
                                                                        
                                                                         
                                                          
   
               
                                                                         
                                                                   
   
                                                               
                                                                  
                                                            
   
                                                                
                                                                    
                                                                  
                                                  
    
	if (VAR_4 && (!VAR_2 || VAR_6)) {
		if (!sev_guest(VAR_0->kvm))
			return true;

		pr_err_ratelimited(""KVM: SEV Guest triggered AMD Erratum 1096\n"");
		kvm_make_request(VAR_8, VAR_0);
	}

	return false;
}",torvalds/linux/e72436bc3a5206f95bb384e741154166ddb3202e/svm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,13 @@
 	bool smep = cr4 & X86_CR4_SMEP;
 	bool smap = cr4 & X86_CR4_SMAP;
 	bool is_user = svm_get_cpl(vcpu) == 3;
+
+	/*
+	 * If RIP is invalid, go ahead with emulation which will cause an
+	 * internal error exit.
+	 */
+	if (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))
+		return true;
 
 	/*
 	 * Detect and workaround Errata 1096 Fam_17h_00_0Fh.","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * If RIP is invalid, go ahead with emulation which will cause an', '\t * internal error exit.', '\t */', '\tif (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))', '\t\treturn true;']}",True,"An issue was discovered in the Linux kernel before 5.8. arch/x86/kvm/svm/svm.c allows a set_memory_region_test infinite loop for certain nested page faults, aka CID-e72436bc3a52.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/xattr.c,fuse_xattr_set,"static int fuse_xattr_set(const struct xattr_handler *handler,
struct dentry *dentry, struct inode *inode,
const char *name, const void *value, size_t size,
int flags)
{
if (!value)
return fuse_removexattr(inode, name);
return fuse_setxattr(inode, name, value, size, flags);
}","static int fuse_xattr_set(const struct xattr_handler *VAR_0,
struct dentry *dentry, struct inode *inode,
const char *VAR_1, const void *VAR_2, size_t VAR_3,
int VAR_4)
{
if (!VAR_2)
return fuse_removexattr(inode, VAR_1);
return fuse_setxattr(inode, VAR_1, VAR_2, VAR_3, VAR_4);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/before/0.json,"static int fuse_xattr_set(const struct xattr_handler *handler,
			  struct dentry *dentry, struct inode *inode,
			  const char *name, const void *value, size_t size,
			  int flags)
{
	if (fuse_is_bad(inode))
		return -EIO;

	if (!value)
		return fuse_removexattr(inode, name);

	return fuse_setxattr(inode, name, value, size, flags);
}","static int fuse_xattr_set(const struct xattr_handler *VAR_0,
			  struct dentry *dentry, struct inode *inode,
			  const char *VAR_1, const void *VAR_2, size_t VAR_3,
			  int VAR_4)
{
	if (fuse_is_bad(inode))
		return -VAR_5;

	if (!VAR_2)
		return fuse_removexattr(inode, VAR_1);

	return fuse_setxattr(inode, VAR_1, VAR_2, VAR_3, VAR_4);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 			  const char *name, const void *value, size_t size,
 			  int flags)
 {
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	if (!value)
 		return fuse_removexattr(inode, name);
 ","{'deleted_lines': [], 'added_lines': ['\tif (fuse_is_bad(inode))', '\t\treturn -EIO;', '']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/xattr.c,fuse_listxattr,"ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
{
struct inode *inode = d_inode(entry);
struct fuse_mount *fm = get_fuse_mount(inode);
FUSE_ARGS(args);
struct fuse_getxattr_in inarg;
struct fuse_getxattr_out outarg;
ssize_t ret;
if (!fuse_allow_current_process(fm->fc))
return -EACCES;
if (fm->fc->no_listxattr)
return -EOPNOTSUPP;
memset(&inarg, 0, sizeof(inarg));
inarg.size = size;
args.opcode = FUSE_LISTXATTR;
args.nodeid = get_node_id(inode);
args.in_numargs = 1;
args.in_args[0].size = sizeof(inarg);
args.in_args[0].value = &inarg;
args.out_numargs = 1;
if (size) {
args.out_argvar = true;
args.out_args[0].size = size;
args.out_args[0].value = list;
} else {
args.out_args[0].size = sizeof(outarg);
args.out_args[0].value = &outarg;
}
ret = fuse_simple_request(fm, &args);
if (!ret && !size)
ret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX);
if (ret > 0 && size)
ret = fuse_verify_xattr_list(list, ret);
if (ret == -ENOSYS) {
fm->fc->no_listxattr = 1;
ret = -EOPNOTSUPP;
}
return ret;
}","ssize_t fuse_listxattr(struct dentry *VAR_0, char *VAR_1, size_t VAR_2)
{
struct inode *inode = d_inode(VAR_0);
struct fuse_mount *VAR_3 = get_fuse_mount(inode);
FUSE_ARGS(VAR_4);
struct fuse_getxattr_in VAR_5;
struct fuse_getxattr_out VAR_6;
ssize_t VAR_7;
if (!fuse_allow_current_process(VAR_3->fc))
return -VAR_8;
if (VAR_3->fc->no_listxattr)
return -VAR_9;
memset(&VAR_5, 0, sizeof(VAR_5));
VAR_5.size = VAR_2;
VAR_4.opcode = VAR_10;
VAR_4.nodeid = get_node_id(inode);
VAR_4.in_numargs = 1;
VAR_4.in_args[0].size = sizeof(VAR_5);
VAR_4.in_args[0].value = &VAR_5;
VAR_4.out_numargs = 1;
if (VAR_2) {
VAR_4.out_argvar = true;
VAR_4.out_args[0].size = VAR_2;
VAR_4.out_args[0].value = VAR_1;
} else {
VAR_4.out_args[0].size = sizeof(VAR_6);
VAR_4.out_args[0].value = &VAR_6;
}
VAR_7 = fuse_simple_request(VAR_3, &VAR_4);
if (!VAR_7 && !VAR_2)
VAR_7 = min_t(ssize_t, VAR_6.size, VAR_11);
if (VAR_7 > 0 && VAR_2)
VAR_7 = fuse_verify_xattr_list(VAR_1, VAR_7);
if (VAR_7 == -VAR_12) {
VAR_3->fc->no_listxattr = 1;
VAR_7 = -VAR_9;
}
return VAR_7;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/before/1.json,"ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
{
	struct inode *inode = d_inode(entry);
	struct fuse_mount *fm = get_fuse_mount(inode);
	FUSE_ARGS(args);
	struct fuse_getxattr_in inarg;
	struct fuse_getxattr_out outarg;
	ssize_t ret;

	if (fuse_is_bad(inode))
		return -EIO;

	if (!fuse_allow_current_process(fm->fc))
		return -EACCES;

	if (fm->fc->no_listxattr)
		return -EOPNOTSUPP;

	memset(&inarg, 0, sizeof(inarg));
	inarg.size = size;
	args.opcode = FUSE_LISTXATTR;
	args.nodeid = get_node_id(inode);
	args.in_numargs = 1;
	args.in_args[0].size = sizeof(inarg);
	args.in_args[0].value = &inarg;
	/* This is really two different operations rolled into one */
	args.out_numargs = 1;
	if (size) {
		args.out_argvar = true;
		args.out_args[0].size = size;
		args.out_args[0].value = list;
	} else {
		args.out_args[0].size = sizeof(outarg);
		args.out_args[0].value = &outarg;
	}
	ret = fuse_simple_request(fm, &args);
	if (!ret && !size)
		ret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX);
	if (ret > 0 && size)
		ret = fuse_verify_xattr_list(list, ret);
	if (ret == -ENOSYS) {
		fm->fc->no_listxattr = 1;
		ret = -EOPNOTSUPP;
	}
	return ret;
}","ssize_t fuse_listxattr(struct dentry *VAR_0, char *VAR_1, size_t VAR_2)
{
	struct inode *inode = d_inode(VAR_0);
	struct fuse_mount *VAR_3 = get_fuse_mount(inode);
	FUSE_ARGS(VAR_4);
	struct fuse_getxattr_in VAR_5;
	struct fuse_getxattr_out VAR_6;
	ssize_t VAR_7;

	if (fuse_is_bad(inode))
		return -VAR_8;

	if (!fuse_allow_current_process(VAR_3->fc))
		return -VAR_9;

	if (VAR_3->fc->no_listxattr)
		return -VAR_10;

	memset(&VAR_5, 0, sizeof(VAR_5));
	VAR_5.size = VAR_2;
	VAR_4.opcode = VAR_11;
	VAR_4.nodeid = get_node_id(inode);
	VAR_4.in_numargs = 1;
	VAR_4.in_args[0].size = sizeof(VAR_5);
	VAR_4.in_args[0].value = &VAR_5;
	/* COMMENT_0 */
	VAR_4.out_numargs = 1;
	if (VAR_2) {
		VAR_4.out_argvar = true;
		VAR_4.out_args[0].size = VAR_2;
		VAR_4.out_args[0].value = VAR_1;
	} else {
		VAR_4.out_args[0].size = sizeof(VAR_6);
		VAR_4.out_args[0].value = &VAR_6;
	}
	VAR_7 = fuse_simple_request(VAR_3, &VAR_4);
	if (!VAR_7 && !VAR_2)
		VAR_7 = min_t(ssize_t, VAR_6.size, VAR_12);
	if (VAR_7 > 0 && VAR_2)
		VAR_7 = fuse_verify_xattr_list(VAR_1, VAR_7);
	if (VAR_7 == -VAR_13) {
		VAR_3->fc->no_listxattr = 1;
		VAR_7 = -VAR_10;
	}
	return VAR_7;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
 	struct fuse_getxattr_in inarg;
 	struct fuse_getxattr_out outarg;
 	ssize_t ret;
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	if (!fuse_allow_current_process(fm->fc))
 		return -EACCES;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/xattr.c,fuse_xattr_get,"static int fuse_xattr_get(const struct xattr_handler *handler,
struct dentry *dentry, struct inode *inode,
const char *name, void *value, size_t size)
{
return fuse_getxattr(inode, name, value, size);
}","static int fuse_xattr_get(const struct xattr_handler *VAR_0,
struct dentry *dentry, struct inode *inode,
const char *VAR_1, void *VAR_2, size_t VAR_3)
{
return fuse_getxattr(inode, VAR_1, VAR_2, VAR_3);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/before/2.json,"static int fuse_xattr_get(const struct xattr_handler *handler,
			 struct dentry *dentry, struct inode *inode,
			 const char *name, void *value, size_t size)
{
	if (fuse_is_bad(inode))
		return -EIO;

	return fuse_getxattr(inode, name, value, size);
}","static int fuse_xattr_get(const struct xattr_handler *VAR_0,
			 struct dentry *dentry, struct inode *inode,
			 const char *VAR_1, void *VAR_2, size_t VAR_3)
{
	if (fuse_is_bad(inode))
		return -VAR_4;

	return fuse_getxattr(inode, VAR_1, VAR_2, VAR_3);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/xattr.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,5 +2,8 @@
 			 struct dentry *dentry, struct inode *inode,
 			 const char *name, void *value, size_t size)
 {
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	return fuse_getxattr(inode, name, value, size);
 }","{'deleted_lines': [], 'added_lines': ['\tif (fuse_is_bad(inode))', '\t\treturn -EIO;', '']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/readdir.c,fuse_direntplus_link,"static int fuse_direntplus_link(struct file *file,
struct fuse_direntplus *direntplus,
u64 attr_version)
{
struct fuse_entry_out *o = &direntplus->entry_out;
struct fuse_dirent *dirent = &direntplus->dirent;
struct dentry *parent = file->f_path.dentry;
struct qstr name = QSTR_INIT(dirent->name, dirent->namelen);
struct dentry *dentry;
struct dentry *alias;
struct inode *dir = d_inode(parent);
struct fuse_conn *fc;
struct inode *inode;
DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
if (!o->nodeid) {
return 0;
}
if (name.name[0] == '.') {
if (name.len == 1)
return 0;
if (name.name[1] == '.' && name.len == 2)
return 0;
}
if (invalid_nodeid(o->nodeid))
return -EIO;
if (fuse_invalid_attr(&o->attr))
return -EIO;
fc = get_fuse_conn(dir);
name.hash = full_name_hash(parent, name.name, name.len);
dentry = d_lookup(parent, &name);
if (!dentry) {
retry:
dentry = d_alloc_parallel(parent, &name, &wq);
if (IS_ERR(dentry))
return PTR_ERR(dentry);
}
if (!d_in_lookup(dentry)) {
struct fuse_inode *fi;
inode = d_inode(dentry);
if (!inode ||
get_node_id(inode) != o->nodeid ||
((o->attr.mode ^ inode->i_mode) & S_IFMT)) {
d_invalidate(dentry);
dput(dentry);
goto retry;
}
if (is_bad_inode(inode)) {
dput(dentry);
return -EIO;
}
fi = get_fuse_inode(inode);
spin_lock(&fi->lock);
fi->nlookup++;
spin_unlock(&fi->lock);
forget_all_cached_acls(inode);
fuse_change_attributes(inode, &o->attr,
entry_attr_timeout(o),
attr_version);
} else {
inode = fuse_iget(dir->i_sb, o->nodeid, o->generation,
&o->attr, entry_attr_timeout(o),
attr_version);
if (!inode)
inode = ERR_PTR(-ENOMEM);
alias = d_splice_alias(inode, dentry);
d_lookup_done(dentry);
if (alias) {
dput(dentry);
dentry = alias;
}
if (IS_ERR(dentry))
return PTR_ERR(dentry);
}
if (fc->readdirplus_auto)
set_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);
fuse_change_entry_timeout(dentry, o);
dput(dentry);
return 0;
}","static int fuse_direntplus_link(struct file *file,
struct fuse_direntplus *VAR_0,
u64 VAR_1)
{
struct fuse_entry_out *VAR_2 = &VAR_0->entry_out;
struct fuse_dirent *VAR_3 = &VAR_0->dirent;
struct dentry *VAR_4 = file->f_path.dentry;
struct qstr VAR_5 = QSTR_INIT(VAR_3->name, VAR_3->namelen);
struct dentry *dentry;
struct dentry *VAR_6;
struct inode *VAR_7 = d_inode(VAR_4);
struct fuse_conn *VAR_8;
struct inode *inode;
DECLARE_WAIT_QUEUE_HEAD_ONSTACK(VAR_9);
if (!VAR_2->nodeid) {
return 0;
}
if (VAR_5.name[0] == '.') {
if (VAR_5.len == 1)
return 0;
if (VAR_5.name[1] == '.' && VAR_5.len == 2)
return 0;
}
if (invalid_nodeid(VAR_2->nodeid))
return -VAR_10;
if (fuse_invalid_attr(&VAR_2->attr))
return -VAR_10;
VAR_8 = get_fuse_conn(VAR_7);
VAR_5.hash = full_name_hash(VAR_4, VAR_5.name, VAR_5.len);
dentry = d_lookup(VAR_4, &VAR_5);
if (!dentry) {
retry:
dentry = d_alloc_parallel(VAR_4, &VAR_5, &VAR_9);
if (IS_ERR(dentry))
return PTR_ERR(dentry);
}
if (!d_in_lookup(dentry)) {
struct fuse_inode *VAR_11;
inode = d_inode(dentry);
if (!inode ||
get_node_id(inode) != VAR_2->nodeid ||
((VAR_2->attr.mode ^ inode->i_mode) & VAR_12)) {
d_invalidate(dentry);
dput(dentry);
goto retry;
}
if (is_bad_inode(inode)) {
dput(dentry);
return -VAR_10;
}
VAR_11 = get_fuse_inode(inode);
spin_lock(&VAR_11->lock);
VAR_11->nlookup++;
spin_unlock(&VAR_11->lock);
forget_all_cached_acls(inode);
fuse_change_attributes(inode, &VAR_2->attr,
entry_attr_timeout(VAR_2),
VAR_1);
} else {
inode = fuse_iget(VAR_7->i_sb, VAR_2->nodeid, VAR_2->generation,
&VAR_2->attr, entry_attr_timeout(VAR_2),
VAR_1);
if (!inode)
inode = ERR_PTR(-VAR_13);
VAR_6 = d_splice_alias(inode, dentry);
d_lookup_done(dentry);
if (VAR_6) {
dput(dentry);
dentry = VAR_6;
}
if (IS_ERR(dentry))
return PTR_ERR(dentry);
}
if (VAR_8->readdirplus_auto)
set_bit(VAR_14, &get_fuse_inode(inode)->state);
fuse_change_entry_timeout(dentry, VAR_2);
dput(dentry);
return 0;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/readdir.c/vul/before/0.json,"static int fuse_direntplus_link(struct file *file,
				struct fuse_direntplus *direntplus,
				u64 attr_version)
{
	struct fuse_entry_out *o = &direntplus->entry_out;
	struct fuse_dirent *dirent = &direntplus->dirent;
	struct dentry *parent = file->f_path.dentry;
	struct qstr name = QSTR_INIT(dirent->name, dirent->namelen);
	struct dentry *dentry;
	struct dentry *alias;
	struct inode *dir = d_inode(parent);
	struct fuse_conn *fc;
	struct inode *inode;
	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);

	if (!o->nodeid) {
		/*
		 * Unlike in the case of fuse_lookup, zero nodeid does not mean
		 * ENOENT. Instead, it only means the userspace filesystem did
		 * not want to return attributes/handle for this entry.
		 *
		 * So do nothing.
		 */
		return 0;
	}

	if (name.name[0] == '.') {
		/*
		 * We could potentially refresh the attributes of the directory
		 * and its parent?
		 */
		if (name.len == 1)
			return 0;
		if (name.name[1] == '.' && name.len == 2)
			return 0;
	}

	if (invalid_nodeid(o->nodeid))
		return -EIO;
	if (fuse_invalid_attr(&o->attr))
		return -EIO;

	fc = get_fuse_conn(dir);

	name.hash = full_name_hash(parent, name.name, name.len);
	dentry = d_lookup(parent, &name);
	if (!dentry) {
retry:
		dentry = d_alloc_parallel(parent, &name, &wq);
		if (IS_ERR(dentry))
			return PTR_ERR(dentry);
	}
	if (!d_in_lookup(dentry)) {
		struct fuse_inode *fi;
		inode = d_inode(dentry);
		if (!inode ||
		    get_node_id(inode) != o->nodeid ||
		    ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {
			d_invalidate(dentry);
			dput(dentry);
			goto retry;
		}
		if (fuse_is_bad(inode)) {
			dput(dentry);
			return -EIO;
		}

		fi = get_fuse_inode(inode);
		spin_lock(&fi->lock);
		fi->nlookup++;
		spin_unlock(&fi->lock);

		forget_all_cached_acls(inode);
		fuse_change_attributes(inode, &o->attr,
				       entry_attr_timeout(o),
				       attr_version);
		/*
		 * The other branch comes via fuse_iget()
		 * which bumps nlookup inside
		 */
	} else {
		inode = fuse_iget(dir->i_sb, o->nodeid, o->generation,
				  &o->attr, entry_attr_timeout(o),
				  attr_version);
		if (!inode)
			inode = ERR_PTR(-ENOMEM);

		alias = d_splice_alias(inode, dentry);
		d_lookup_done(dentry);
		if (alias) {
			dput(dentry);
			dentry = alias;
		}
		if (IS_ERR(dentry))
			return PTR_ERR(dentry);
	}
	if (fc->readdirplus_auto)
		set_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);
	fuse_change_entry_timeout(dentry, o);

	dput(dentry);
	return 0;
}","static int fuse_direntplus_link(struct file *file,
				struct fuse_direntplus *VAR_0,
				u64 VAR_1)
{
	struct fuse_entry_out *VAR_2 = &VAR_0->entry_out;
	struct fuse_dirent *VAR_3 = &VAR_0->dirent;
	struct dentry *VAR_4 = file->f_path.dentry;
	struct qstr VAR_5 = QSTR_INIT(VAR_3->name, VAR_3->namelen);
	struct dentry *dentry;
	struct dentry *VAR_6;
	struct inode *VAR_7 = d_inode(VAR_4);
	struct fuse_conn *VAR_8;
	struct inode *inode;
	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(VAR_9);

	if (!VAR_2->nodeid) {
		/* COMMENT_0 */
                                                                 
                                                                
                                                         
    
                   
     
		return 0;
	}

	if (VAR_5.name[0] == '.') {
		/* COMMENT_7 */
                                                                 
                    
     
		if (VAR_5.len == 1)
			return 0;
		if (VAR_5.name[1] == '.' && VAR_5.len == 2)
			return 0;
	}

	if (invalid_nodeid(VAR_2->nodeid))
		return -VAR_10;
	if (fuse_invalid_attr(&VAR_2->attr))
		return -VAR_10;

	VAR_8 = get_fuse_conn(VAR_7);

	VAR_5.hash = full_name_hash(VAR_4, VAR_5.name, VAR_5.len);
	dentry = d_lookup(VAR_4, &VAR_5);
	if (!dentry) {
retry:
		dentry = d_alloc_parallel(VAR_4, &VAR_5, &VAR_9);
		if (IS_ERR(dentry))
			return PTR_ERR(dentry);
	}
	if (!d_in_lookup(dentry)) {
		struct fuse_inode *VAR_11;
		inode = d_inode(dentry);
		if (!inode ||
		    get_node_id(inode) != VAR_2->nodeid ||
		    ((VAR_2->attr.mode ^ inode->i_mode) & VAR_12)) {
			d_invalidate(dentry);
			dput(dentry);
			goto retry;
		}
		if (fuse_is_bad(inode)) {
			dput(dentry);
			return -VAR_10;
		}

		VAR_11 = get_fuse_inode(inode);
		spin_lock(&VAR_11->lock);
		VAR_11->nlookup++;
		spin_unlock(&VAR_11->lock);

		forget_all_cached_acls(inode);
		fuse_change_attributes(inode, &VAR_2->attr,
				       entry_attr_timeout(VAR_2),
				       VAR_1);
		/* COMMENT_11 */
                                           
                               
     
	} else {
		inode = fuse_iget(VAR_7->i_sb, VAR_2->nodeid, VAR_2->generation,
				  &VAR_2->attr, entry_attr_timeout(VAR_2),
				  VAR_1);
		if (!inode)
			inode = ERR_PTR(-VAR_13);

		VAR_6 = d_splice_alias(inode, dentry);
		d_lookup_done(dentry);
		if (VAR_6) {
			dput(dentry);
			dentry = VAR_6;
		}
		if (IS_ERR(dentry))
			return PTR_ERR(dentry);
	}
	if (VAR_8->readdirplus_auto)
		set_bit(VAR_14, &get_fuse_inode(inode)->state);
	fuse_change_entry_timeout(dentry, VAR_2);

	dput(dentry);
	return 0;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/readdir.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,7 +60,7 @@
 			dput(dentry);
 			goto retry;
 		}
-		if (is_bad_inode(inode)) {
+		if (fuse_is_bad(inode)) {
 			dput(dentry);
 			return -EIO;
 		}","{'deleted_lines': ['\t\tif (is_bad_inode(inode)) {'], 'added_lines': ['\t\tif (fuse_is_bad(inode)) {']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/readdir.c,fuse_readdir,"int fuse_readdir(struct file *file, struct dir_context *ctx)
{
struct fuse_file *ff = file->private_data;
struct inode *inode = file_inode(file);
int err;
if (is_bad_inode(inode))
return -EIO;
mutex_lock(&ff->readdir.lock);
err = UNCACHED;
if (ff->open_flags & FOPEN_CACHE_DIR)
err = fuse_readdir_cached(file, ctx);
if (err == UNCACHED)
err = fuse_readdir_uncached(file, ctx);
mutex_unlock(&ff->readdir.lock);
return err;
}","int fuse_readdir(struct file *file, struct dir_context *VAR_0)
{
struct fuse_file *VAR_1 = file->private_data;
struct inode *inode = file_inode(file);
int VAR_2;
if (is_bad_inode(inode))
return -VAR_3;
mutex_lock(&VAR_1->readdir.lock);
VAR_2 = VAR_4;
if (VAR_1->open_flags & VAR_5)
VAR_2 = fuse_readdir_cached(file, VAR_0);
if (VAR_2 == VAR_4)
VAR_2 = fuse_readdir_uncached(file, VAR_0);
mutex_unlock(&VAR_1->readdir.lock);
return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/readdir.c/vul/before/1.json,"int fuse_readdir(struct file *file, struct dir_context *ctx)
{
	struct fuse_file *ff = file->private_data;
	struct inode *inode = file_inode(file);
	int err;

	if (fuse_is_bad(inode))
		return -EIO;

	mutex_lock(&ff->readdir.lock);

	err = UNCACHED;
	if (ff->open_flags & FOPEN_CACHE_DIR)
		err = fuse_readdir_cached(file, ctx);
	if (err == UNCACHED)
		err = fuse_readdir_uncached(file, ctx);

	mutex_unlock(&ff->readdir.lock);

	return err;
}","int fuse_readdir(struct file *file, struct dir_context *VAR_0)
{
	struct fuse_file *VAR_1 = file->private_data;
	struct inode *inode = file_inode(file);
	int VAR_2;

	if (fuse_is_bad(inode))
		return -VAR_3;

	mutex_lock(&VAR_1->readdir.lock);

	VAR_2 = VAR_4;
	if (VAR_1->open_flags & VAR_5)
		VAR_2 = fuse_readdir_cached(file, VAR_0);
	if (VAR_2 == VAR_4)
		VAR_2 = fuse_readdir_uncached(file, VAR_0);

	mutex_unlock(&VAR_1->readdir.lock);

	return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/readdir.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	struct inode *inode = file_inode(file);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	mutex_lock(&ff->readdir.lock);","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_rename2,"static int fuse_rename2(struct inode *olddir, struct dentry *oldent,
struct inode *newdir, struct dentry *newent,
unsigned int flags)
{
struct fuse_conn *fc = get_fuse_conn(olddir);
int err;
if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
return -EINVAL;
if (flags) {
if (fc->no_rename2 || fc->minor < 23)
return -EINVAL;
err = fuse_rename_common(olddir, oldent, newdir, newent, flags,
FUSE_RENAME2,
sizeof(struct fuse_rename2_in));
if (err == -ENOSYS) {
fc->no_rename2 = 1;
err = -EINVAL;
}
} else {
err = fuse_rename_common(olddir, oldent, newdir, newent, 0,
FUSE_RENAME,
sizeof(struct fuse_rename_in));
}
return err;
}","static int fuse_rename2(struct inode *VAR_0, struct dentry *VAR_1,
struct inode *VAR_2, struct dentry *VAR_3,
unsigned int VAR_4)
{
struct fuse_conn *VAR_5 = get_fuse_conn(VAR_0);
int VAR_6;
if (VAR_4 & ~(VAR_7 | VAR_8 | VAR_9))
return -VAR_10;
if (VAR_4) {
if (VAR_5->no_rename2 || VAR_5->minor < 23)
return -VAR_10;
VAR_6 = fuse_rename_common(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_11,
sizeof(struct fuse_rename2_in));
if (VAR_6 == -VAR_12) {
VAR_5->no_rename2 = 1;
VAR_6 = -VAR_10;
}
} else {
VAR_6 = fuse_rename_common(VAR_0, VAR_1, VAR_2, VAR_3, 0,
VAR_13,
sizeof(struct fuse_rename_in));
}
return VAR_6;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/0.json,"static int fuse_rename2(struct inode *olddir, struct dentry *oldent,
			struct inode *newdir, struct dentry *newent,
			unsigned int flags)
{
	struct fuse_conn *fc = get_fuse_conn(olddir);
	int err;

	if (fuse_is_bad(olddir))
		return -EIO;

	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
		return -EINVAL;

	if (flags) {
		if (fc->no_rename2 || fc->minor < 23)
			return -EINVAL;

		err = fuse_rename_common(olddir, oldent, newdir, newent, flags,
					 FUSE_RENAME2,
					 sizeof(struct fuse_rename2_in));
		if (err == -ENOSYS) {
			fc->no_rename2 = 1;
			err = -EINVAL;
		}
	} else {
		err = fuse_rename_common(olddir, oldent, newdir, newent, 0,
					 FUSE_RENAME,
					 sizeof(struct fuse_rename_in));
	}

	return err;
}","static int fuse_rename2(struct inode *VAR_0, struct dentry *VAR_1,
			struct inode *VAR_2, struct dentry *VAR_3,
			unsigned int VAR_4)
{
	struct fuse_conn *VAR_5 = get_fuse_conn(VAR_0);
	int VAR_6;

	if (fuse_is_bad(VAR_0))
		return -VAR_7;

	if (VAR_4 & ~(VAR_8 | VAR_9 | VAR_10))
		return -VAR_11;

	if (VAR_4) {
		if (VAR_5->no_rename2 || VAR_5->minor < 23)
			return -VAR_11;

		VAR_6 = fuse_rename_common(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
					 VAR_12,
					 sizeof(struct fuse_rename2_in));
		if (VAR_6 == -VAR_13) {
			VAR_5->no_rename2 = 1;
			VAR_6 = -VAR_11;
		}
	} else {
		VAR_6 = fuse_rename_common(VAR_0, VAR_1, VAR_2, VAR_3, 0,
					 VAR_14,
					 sizeof(struct fuse_rename_in));
	}

	return VAR_6;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,9 @@
 {
 	struct fuse_conn *fc = get_fuse_conn(olddir);
 	int err;
+
+	if (fuse_is_bad(olddir))
+		return -EIO;
 
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		return -EINVAL;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(olddir))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_do_setattr,"int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
struct file *file)
{
struct inode *inode = d_inode(dentry);
struct fuse_mount *fm = get_fuse_mount(inode);
struct fuse_conn *fc = fm->fc;
struct fuse_inode *fi = get_fuse_inode(inode);
FUSE_ARGS(args);
struct fuse_setattr_in inarg;
struct fuse_attr_out outarg;
bool is_truncate = false;
bool is_wb = fc->writeback_cache;
loff_t oldsize;
int err;
bool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);
bool fault_blocked = false;
if (!fc->default_permissions)
attr->ia_valid |= ATTR_FORCE;
err = setattr_prepare(dentry, attr);
if (err)
return err;
if (attr->ia_valid & ATTR_SIZE) {
if (WARN_ON(!S_ISREG(inode->i_mode)))
return -EIO;
is_truncate = true;
}
if (FUSE_IS_DAX(inode) && is_truncate) {
down_write(&fi->i_mmap_sem);
fault_blocked = true;
err = fuse_dax_break_layouts(inode, 0, 0);
if (err) {
up_write(&fi->i_mmap_sem);
return err;
}
}
if (attr->ia_valid & ATTR_OPEN) {
WARN_ON(!(attr->ia_valid & ATTR_SIZE));
WARN_ON(attr->ia_size != 0);
if (fc->atomic_o_trunc) {
i_size_write(inode, 0);
truncate_pagecache(inode, 0);
goto out;
}
file = NULL;
}
if (is_wb && S_ISREG(inode->i_mode) &&
attr->ia_valid &
(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |
ATTR_TIMES_SET)) {
err = write_inode_now(inode, true);
if (err)
return err;
fuse_set_nowrite(inode);
fuse_release_nowrite(inode);
}
if (is_truncate) {
fuse_set_nowrite(inode);
set_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
if (trust_local_cmtime && attr->ia_size != inode->i_size)
attr->ia_valid |= ATTR_MTIME | ATTR_CTIME;
}
memset(&inarg, 0, sizeof(inarg));
memset(&outarg, 0, sizeof(outarg));
iattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);
if (file) {
struct fuse_file *ff = file->private_data;
inarg.valid |= FATTR_FH;
inarg.fh = ff->fh;
}
if (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&
attr->ia_valid & (ATTR_UID | ATTR_GID))
inarg.valid |= FATTR_KILL_SUIDGID;
if (attr->ia_valid & ATTR_SIZE) {
inarg.valid |= FATTR_LOCKOWNER;
inarg.lock_owner = fuse_lock_owner_id(fc, current->files);
if (fc->handle_killpriv_v2 && !capable(CAP_FSETID))
inarg.valid |= FATTR_KILL_SUIDGID;
}
fuse_setattr_fill(fc, &args, inode, &inarg, &outarg);
err = fuse_simple_request(fm, &args);
if (err) {
if (err == -EINTR)
fuse_invalidate_attr(inode);
goto error;
}
if (fuse_invalid_attr(&outarg.attr) ||
(inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
make_bad_inode(inode);
err = -EIO;
goto error;
}
spin_lock(&fi->lock);
if (trust_local_cmtime) {
if (attr->ia_valid & ATTR_MTIME)
inode->i_mtime = attr->ia_mtime;
if (attr->ia_valid & ATTR_CTIME)
inode->i_ctime = attr->ia_ctime;
}
fuse_change_attributes_common(inode, &outarg.attr,
attr_timeout(&outarg));
oldsize = inode->i_size;
if (!is_wb || is_truncate || !S_ISREG(inode->i_mode))
i_size_write(inode, outarg.attr.size);
if (is_truncate) {
__fuse_release_nowrite(inode);
}
spin_unlock(&fi->lock);
if ((is_truncate || !is_wb) &&
S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {
truncate_pagecache(inode, outarg.attr.size);
invalidate_inode_pages2(inode->i_mapping);
}
clear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
out:
if (fault_blocked)
up_write(&fi->i_mmap_sem);
return 0;
error:
if (is_truncate)
fuse_release_nowrite(inode);
clear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
if (fault_blocked)
up_write(&fi->i_mmap_sem);
return err;
}","int fuse_do_setattr(struct dentry *dentry, struct iattr *VAR_0,
struct file *file)
{
struct inode *inode = d_inode(dentry);
struct fuse_mount *VAR_1 = get_fuse_mount(inode);
struct fuse_conn *VAR_2 = VAR_1->fc;
struct fuse_inode *VAR_3 = get_fuse_inode(inode);
FUSE_ARGS(VAR_4);
struct fuse_setattr_in VAR_5;
struct fuse_attr_out VAR_6;
bool VAR_7 = false;
bool VAR_8 = VAR_2->writeback_cache;
loff_t VAR_9;
int VAR_10;
bool VAR_11 = VAR_8 && S_ISREG(inode->i_mode);
bool VAR_12 = false;
if (!VAR_2->default_permissions)
VAR_0->ia_valid |= VAR_13;
VAR_10 = setattr_prepare(dentry, VAR_0);
if (VAR_10)
return VAR_10;
if (VAR_0->ia_valid & VAR_14) {
if (WARN_ON(!S_ISREG(inode->i_mode)))
return -VAR_15;
VAR_7 = true;
}
if (FUSE_IS_DAX(inode) && VAR_7) {
down_write(&VAR_3->i_mmap_sem);
VAR_12 = true;
VAR_10 = fuse_dax_break_layouts(inode, 0, 0);
if (VAR_10) {
up_write(&VAR_3->i_mmap_sem);
return VAR_10;
}
}
if (VAR_0->ia_valid & VAR_16) {
WARN_ON(!(VAR_0->ia_valid & VAR_14));
WARN_ON(VAR_0->ia_size != 0);
if (VAR_2->atomic_o_trunc) {
i_size_write(inode, 0);
truncate_pagecache(inode, 0);
goto out;
}
file = NULL;
}
if (VAR_8 && S_ISREG(inode->i_mode) &&
VAR_0->ia_valid &
(VAR_17 | VAR_18 | VAR_19 | VAR_20 |
VAR_21)) {
VAR_10 = write_inode_now(inode, true);
if (VAR_10)
return VAR_10;
fuse_set_nowrite(inode);
fuse_release_nowrite(inode);
}
if (VAR_7) {
fuse_set_nowrite(inode);
set_bit(VAR_22, &VAR_3->state);
if (VAR_11 && VAR_0->ia_size != inode->i_size)
VAR_0->ia_valid |= VAR_23 | VAR_24;
}
memset(&VAR_5, 0, sizeof(VAR_5));
memset(&VAR_6, 0, sizeof(VAR_6));
iattr_to_fattr(VAR_2, VAR_0, &VAR_5, VAR_11);
if (file) {
struct fuse_file *VAR_25 = file->private_data;
VAR_5.valid |= VAR_26;
VAR_5.fh = VAR_25->fh;
}
if (VAR_2->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&
VAR_0->ia_valid & (VAR_18 | VAR_19))
VAR_5.valid |= VAR_27;
if (VAR_0->ia_valid & VAR_14) {
VAR_5.valid |= VAR_28;
VAR_5.lock_owner = fuse_lock_owner_id(VAR_2, VAR_29->files);
if (VAR_2->handle_killpriv_v2 && !capable(VAR_30))
VAR_5.valid |= VAR_27;
}
fuse_setattr_fill(VAR_2, &VAR_4, inode, &VAR_5, &VAR_6);
VAR_10 = fuse_simple_request(VAR_1, &VAR_4);
if (VAR_10) {
if (VAR_10 == -VAR_31)
fuse_invalidate_attr(inode);
goto error;
}
if (fuse_invalid_attr(&VAR_6.attr) ||
(inode->i_mode ^ VAR_6.attr.mode) & VAR_32) {
make_bad_inode(inode);
VAR_10 = -VAR_15;
goto error;
}
spin_lock(&VAR_3->lock);
if (VAR_11) {
if (VAR_0->ia_valid & VAR_23)
inode->i_mtime = VAR_0->ia_mtime;
if (VAR_0->ia_valid & VAR_24)
inode->i_ctime = VAR_0->ia_ctime;
}
fuse_change_attributes_common(inode, &VAR_6.attr,
attr_timeout(&VAR_6));
VAR_9 = inode->i_size;
if (!VAR_8 || VAR_7 || !S_ISREG(inode->i_mode))
i_size_write(inode, VAR_6.attr.size);
if (VAR_7) {
__fuse_release_nowrite(inode);
}
spin_unlock(&VAR_3->lock);
if ((VAR_7 || !VAR_8) &&
S_ISREG(inode->i_mode) && VAR_9 != VAR_6.attr.size) {
truncate_pagecache(inode, VAR_6.attr.size);
invalidate_inode_pages2(inode->i_mapping);
}
clear_bit(VAR_22, &VAR_3->state);
out:
if (VAR_12)
up_write(&VAR_3->i_mmap_sem);
return 0;
error:
if (VAR_7)
fuse_release_nowrite(inode);
clear_bit(VAR_22, &VAR_3->state);
if (VAR_12)
up_write(&VAR_3->i_mmap_sem);
return VAR_10;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/1.json,"int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
		    struct file *file)
{
	struct inode *inode = d_inode(dentry);
	struct fuse_mount *fm = get_fuse_mount(inode);
	struct fuse_conn *fc = fm->fc;
	struct fuse_inode *fi = get_fuse_inode(inode);
	FUSE_ARGS(args);
	struct fuse_setattr_in inarg;
	struct fuse_attr_out outarg;
	bool is_truncate = false;
	bool is_wb = fc->writeback_cache;
	loff_t oldsize;
	int err;
	bool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);
	bool fault_blocked = false;

	if (!fc->default_permissions)
		attr->ia_valid |= ATTR_FORCE;

	err = setattr_prepare(dentry, attr);
	if (err)
		return err;

	if (attr->ia_valid & ATTR_SIZE) {
		if (WARN_ON(!S_ISREG(inode->i_mode)))
			return -EIO;
		is_truncate = true;
	}

	if (FUSE_IS_DAX(inode) && is_truncate) {
		down_write(&fi->i_mmap_sem);
		fault_blocked = true;
		err = fuse_dax_break_layouts(inode, 0, 0);
		if (err) {
			up_write(&fi->i_mmap_sem);
			return err;
		}
	}

	if (attr->ia_valid & ATTR_OPEN) {
		/* This is coming from open(..., ... | O_TRUNC); */
		WARN_ON(!(attr->ia_valid & ATTR_SIZE));
		WARN_ON(attr->ia_size != 0);
		if (fc->atomic_o_trunc) {
			/*
			 * No need to send request to userspace, since actual
			 * truncation has already been done by OPEN.  But still
			 * need to truncate page cache.
			 */
			i_size_write(inode, 0);
			truncate_pagecache(inode, 0);
			goto out;
		}
		file = NULL;
	}

	/* Flush dirty data/metadata before non-truncate SETATTR */
	if (is_wb && S_ISREG(inode->i_mode) &&
	    attr->ia_valid &
			(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |
			 ATTR_TIMES_SET)) {
		err = write_inode_now(inode, true);
		if (err)
			return err;

		fuse_set_nowrite(inode);
		fuse_release_nowrite(inode);
	}

	if (is_truncate) {
		fuse_set_nowrite(inode);
		set_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
		if (trust_local_cmtime && attr->ia_size != inode->i_size)
			attr->ia_valid |= ATTR_MTIME | ATTR_CTIME;
	}

	memset(&inarg, 0, sizeof(inarg));
	memset(&outarg, 0, sizeof(outarg));
	iattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);
	if (file) {
		struct fuse_file *ff = file->private_data;
		inarg.valid |= FATTR_FH;
		inarg.fh = ff->fh;
	}

	/* Kill suid/sgid for non-directory chown unconditionally */
	if (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&
	    attr->ia_valid & (ATTR_UID | ATTR_GID))
		inarg.valid |= FATTR_KILL_SUIDGID;

	if (attr->ia_valid & ATTR_SIZE) {
		/* For mandatory locking in truncate */
		inarg.valid |= FATTR_LOCKOWNER;
		inarg.lock_owner = fuse_lock_owner_id(fc, current->files);

		/* Kill suid/sgid for truncate only if no CAP_FSETID */
		if (fc->handle_killpriv_v2 && !capable(CAP_FSETID))
			inarg.valid |= FATTR_KILL_SUIDGID;
	}
	fuse_setattr_fill(fc, &args, inode, &inarg, &outarg);
	err = fuse_simple_request(fm, &args);
	if (err) {
		if (err == -EINTR)
			fuse_invalidate_attr(inode);
		goto error;
	}

	if (fuse_invalid_attr(&outarg.attr) ||
	    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
		fuse_make_bad(inode);
		err = -EIO;
		goto error;
	}

	spin_lock(&fi->lock);
	/* the kernel maintains i_mtime locally */
	if (trust_local_cmtime) {
		if (attr->ia_valid & ATTR_MTIME)
			inode->i_mtime = attr->ia_mtime;
		if (attr->ia_valid & ATTR_CTIME)
			inode->i_ctime = attr->ia_ctime;
		/* FIXME: clear I_DIRTY_SYNC? */
	}

	fuse_change_attributes_common(inode, &outarg.attr,
				      attr_timeout(&outarg));
	oldsize = inode->i_size;
	/* see the comment in fuse_change_attributes() */
	if (!is_wb || is_truncate || !S_ISREG(inode->i_mode))
		i_size_write(inode, outarg.attr.size);

	if (is_truncate) {
		/* NOTE: this may release/reacquire fi->lock */
		__fuse_release_nowrite(inode);
	}
	spin_unlock(&fi->lock);

	/*
	 * Only call invalidate_inode_pages2() after removing
	 * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.
	 */
	if ((is_truncate || !is_wb) &&
	    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {
		truncate_pagecache(inode, outarg.attr.size);
		invalidate_inode_pages2(inode->i_mapping);
	}

	clear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
out:
	if (fault_blocked)
		up_write(&fi->i_mmap_sem);

	return 0;

error:
	if (is_truncate)
		fuse_release_nowrite(inode);

	clear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);

	if (fault_blocked)
		up_write(&fi->i_mmap_sem);
	return err;
}","int fuse_do_setattr(struct dentry *dentry, struct iattr *VAR_0,
		    struct file *file)
{
	struct inode *inode = d_inode(dentry);
	struct fuse_mount *VAR_1 = get_fuse_mount(inode);
	struct fuse_conn *VAR_2 = VAR_1->fc;
	struct fuse_inode *VAR_3 = get_fuse_inode(inode);
	FUSE_ARGS(VAR_4);
	struct fuse_setattr_in VAR_5;
	struct fuse_attr_out VAR_6;
	bool VAR_7 = false;
	bool VAR_8 = VAR_2->writeback_cache;
	loff_t VAR_9;
	int VAR_10;
	bool VAR_11 = VAR_8 && S_ISREG(inode->i_mode);
	bool VAR_12 = false;

	if (!VAR_2->default_permissions)
		VAR_0->ia_valid |= VAR_13;

	VAR_10 = setattr_prepare(dentry, VAR_0);
	if (VAR_10)
		return VAR_10;

	if (VAR_0->ia_valid & VAR_14) {
		if (WARN_ON(!S_ISREG(inode->i_mode)))
			return -VAR_15;
		VAR_7 = true;
	}

	if (FUSE_IS_DAX(inode) && VAR_7) {
		down_write(&VAR_3->i_mmap_sem);
		VAR_12 = true;
		VAR_10 = fuse_dax_break_layouts(inode, 0, 0);
		if (VAR_10) {
			up_write(&VAR_3->i_mmap_sem);
			return VAR_10;
		}
	}

	if (VAR_0->ia_valid & VAR_16) {
		/* COMMENT_0 */
		WARN_ON(!(VAR_0->ia_valid & VAR_14));
		WARN_ON(VAR_0->ia_size != 0);
		if (VAR_2->atomic_o_trunc) {
			/* COMMENT_1 */
                                                        
                                                          
                                  
      
			i_size_write(inode, 0);
			truncate_pagecache(inode, 0);
			goto out;
		}
		file = NULL;
	}

	/* COMMENT_6 */
	if (VAR_8 && S_ISREG(inode->i_mode) &&
	    VAR_0->ia_valid &
			(VAR_17 | VAR_18 | VAR_19 | VAR_20 |
			 VAR_21)) {
		VAR_10 = write_inode_now(inode, true);
		if (VAR_10)
			return VAR_10;

		fuse_set_nowrite(inode);
		fuse_release_nowrite(inode);
	}

	if (VAR_7) {
		fuse_set_nowrite(inode);
		set_bit(VAR_22, &VAR_3->state);
		if (VAR_11 && VAR_0->ia_size != inode->i_size)
			VAR_0->ia_valid |= VAR_23 | VAR_24;
	}

	memset(&VAR_5, 0, sizeof(VAR_5));
	memset(&VAR_6, 0, sizeof(VAR_6));
	iattr_to_fattr(VAR_2, VAR_0, &VAR_5, VAR_11);
	if (file) {
		struct fuse_file *VAR_25 = file->private_data;
		VAR_5.valid |= VAR_26;
		VAR_5.fh = VAR_25->fh;
	}

	/* COMMENT_7 */
	if (VAR_2->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&
	    VAR_0->ia_valid & (VAR_18 | VAR_19))
		VAR_5.valid |= VAR_27;

	if (VAR_0->ia_valid & VAR_14) {
		/* COMMENT_8 */
		VAR_5.valid |= VAR_28;
		VAR_5.lock_owner = fuse_lock_owner_id(VAR_2, VAR_29->files);

		/* COMMENT_9 */
		if (VAR_2->handle_killpriv_v2 && !capable(VAR_30))
			VAR_5.valid |= VAR_27;
	}
	fuse_setattr_fill(VAR_2, &VAR_4, inode, &VAR_5, &VAR_6);
	VAR_10 = fuse_simple_request(VAR_1, &VAR_4);
	if (VAR_10) {
		if (VAR_10 == -VAR_31)
			fuse_invalidate_attr(inode);
		goto error;
	}

	if (fuse_invalid_attr(&VAR_6.attr) ||
	    (inode->i_mode ^ VAR_6.attr.mode) & VAR_32) {
		fuse_make_bad(inode);
		VAR_10 = -VAR_15;
		goto error;
	}

	spin_lock(&VAR_3->lock);
	/* COMMENT_10 */
	if (VAR_11) {
		if (VAR_0->ia_valid & VAR_23)
			inode->i_mtime = VAR_0->ia_mtime;
		if (VAR_0->ia_valid & VAR_24)
			inode->i_ctime = VAR_0->ia_ctime;
		/* COMMENT_11 */
	}

	fuse_change_attributes_common(inode, &VAR_6.attr,
				      attr_timeout(&VAR_6));
	VAR_9 = inode->i_size;
	/* COMMENT_12 */
	if (!VAR_8 || VAR_7 || !S_ISREG(inode->i_mode))
		i_size_write(inode, VAR_6.attr.size);

	if (VAR_7) {
		/* COMMENT_13 */
		__fuse_release_nowrite(inode);
	}
	spin_unlock(&VAR_3->lock);

	/* COMMENT_14 */
                                                      
                                                               
    
	if ((VAR_7 || !VAR_8) &&
	    S_ISREG(inode->i_mode) && VAR_9 != VAR_6.attr.size) {
		truncate_pagecache(inode, VAR_6.attr.size);
		invalidate_inode_pages2(inode->i_mapping);
	}

	clear_bit(VAR_22, &VAR_3->state);
out:
	if (VAR_12)
		up_write(&VAR_3->i_mmap_sem);

	return 0;

error:
	if (VAR_7)
		fuse_release_nowrite(inode);

	clear_bit(VAR_22, &VAR_3->state);

	if (VAR_12)
		up_write(&VAR_3->i_mmap_sem);
	return VAR_10;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -108,7 +108,7 @@
 
 	if (fuse_invalid_attr(&outarg.attr) ||
 	    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
-		make_bad_inode(inode);
+		fuse_make_bad(inode);
 		err = -EIO;
 		goto error;
 	}","{'deleted_lines': ['\t\tmake_bad_inode(inode);'], 'added_lines': ['\t\tfuse_make_bad(inode);']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_rmdir,"static int fuse_rmdir(struct inode *dir, struct dentry *entry)
{
int err;
struct fuse_mount *fm = get_fuse_mount(dir);
FUSE_ARGS(args);
args.opcode = FUSE_RMDIR;
args.nodeid = get_node_id(dir);
args.in_numargs = 1;
args.in_args[0].size = entry->d_name.len + 1;
args.in_args[0].value = entry->d_name.name;
err = fuse_simple_request(fm, &args);
if (!err) {
clear_nlink(d_inode(entry));
fuse_dir_changed(dir);
fuse_invalidate_entry_cache(entry);
} else if (err == -EINTR)
fuse_invalidate_entry(entry);
return err;
}","static int fuse_rmdir(struct inode *VAR_0, struct dentry *VAR_1)
{
int VAR_2;
struct fuse_mount *VAR_3 = get_fuse_mount(VAR_0);
FUSE_ARGS(VAR_4);
VAR_4.opcode = VAR_5;
VAR_4.nodeid = get_node_id(VAR_0);
VAR_4.in_numargs = 1;
VAR_4.in_args[0].size = VAR_1->d_name.len + 1;
VAR_4.in_args[0].value = VAR_1->d_name.name;
VAR_2 = fuse_simple_request(VAR_3, &VAR_4);
if (!VAR_2) {
clear_nlink(d_inode(VAR_1));
fuse_dir_changed(VAR_0);
fuse_invalidate_entry_cache(VAR_1);
} else if (VAR_2 == -VAR_6)
fuse_invalidate_entry(VAR_1);
return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/2.json,"static int fuse_rmdir(struct inode *dir, struct dentry *entry)
{
	int err;
	struct fuse_mount *fm = get_fuse_mount(dir);
	FUSE_ARGS(args);

	if (fuse_is_bad(dir))
		return -EIO;

	args.opcode = FUSE_RMDIR;
	args.nodeid = get_node_id(dir);
	args.in_numargs = 1;
	args.in_args[0].size = entry->d_name.len + 1;
	args.in_args[0].value = entry->d_name.name;
	err = fuse_simple_request(fm, &args);
	if (!err) {
		clear_nlink(d_inode(entry));
		fuse_dir_changed(dir);
		fuse_invalidate_entry_cache(entry);
	} else if (err == -EINTR)
		fuse_invalidate_entry(entry);
	return err;
}","static int fuse_rmdir(struct inode *VAR_0, struct dentry *VAR_1)
{
	int VAR_2;
	struct fuse_mount *VAR_3 = get_fuse_mount(VAR_0);
	FUSE_ARGS(VAR_4);

	if (fuse_is_bad(VAR_0))
		return -VAR_5;

	VAR_4.opcode = VAR_6;
	VAR_4.nodeid = get_node_id(VAR_0);
	VAR_4.in_numargs = 1;
	VAR_4.in_args[0].size = VAR_1->d_name.len + 1;
	VAR_4.in_args[0].value = VAR_1->d_name.name;
	VAR_2 = fuse_simple_request(VAR_3, &VAR_4);
	if (!VAR_2) {
		clear_nlink(d_inode(VAR_1));
		fuse_dir_changed(VAR_0);
		fuse_invalidate_entry_cache(VAR_1);
	} else if (VAR_2 == -VAR_7)
		fuse_invalidate_entry(VAR_1);
	return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 	int err;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
+
+	if (fuse_is_bad(dir))
+		return -EIO;
 
 	args.opcode = FUSE_RMDIR;
 	args.nodeid = get_node_id(dir);","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(dir))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_unlink,"static int fuse_unlink(struct inode *dir, struct dentry *entry)
{
int err;
struct fuse_mount *fm = get_fuse_mount(dir);
FUSE_ARGS(args);
args.opcode = FUSE_UNLINK;
args.nodeid = get_node_id(dir);
args.in_numargs = 1;
args.in_args[0].size = entry->d_name.len + 1;
args.in_args[0].value = entry->d_name.name;
err = fuse_simple_request(fm, &args);
if (!err) {
struct inode *inode = d_inode(entry);
struct fuse_inode *fi = get_fuse_inode(inode);
spin_lock(&fi->lock);
fi->attr_version = atomic64_inc_return(&fm->fc->attr_version);
if (inode->i_nlink > 0)
drop_nlink(inode);
spin_unlock(&fi->lock);
fuse_invalidate_attr(inode);
fuse_dir_changed(dir);
fuse_invalidate_entry_cache(entry);
fuse_update_ctime(inode);
} else if (err == -EINTR)
fuse_invalidate_entry(entry);
return err;
}","static int fuse_unlink(struct inode *VAR_0, struct dentry *VAR_1)
{
int VAR_2;
struct fuse_mount *VAR_3 = get_fuse_mount(VAR_0);
FUSE_ARGS(VAR_4);
VAR_4.opcode = VAR_5;
VAR_4.nodeid = get_node_id(VAR_0);
VAR_4.in_numargs = 1;
VAR_4.in_args[0].size = VAR_1->d_name.len + 1;
VAR_4.in_args[0].value = VAR_1->d_name.name;
VAR_2 = fuse_simple_request(VAR_3, &VAR_4);
if (!VAR_2) {
struct inode *inode = d_inode(VAR_1);
struct fuse_inode *VAR_6 = get_fuse_inode(inode);
spin_lock(&VAR_6->lock);
VAR_6->attr_version = atomic64_inc_return(&VAR_3->fc->attr_version);
if (inode->i_nlink > 0)
drop_nlink(inode);
spin_unlock(&VAR_6->lock);
fuse_invalidate_attr(inode);
fuse_dir_changed(VAR_0);
fuse_invalidate_entry_cache(VAR_1);
fuse_update_ctime(inode);
} else if (VAR_2 == -VAR_7)
fuse_invalidate_entry(VAR_1);
return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/3.json,"static int fuse_unlink(struct inode *dir, struct dentry *entry)
{
	int err;
	struct fuse_mount *fm = get_fuse_mount(dir);
	FUSE_ARGS(args);

	if (fuse_is_bad(dir))
		return -EIO;

	args.opcode = FUSE_UNLINK;
	args.nodeid = get_node_id(dir);
	args.in_numargs = 1;
	args.in_args[0].size = entry->d_name.len + 1;
	args.in_args[0].value = entry->d_name.name;
	err = fuse_simple_request(fm, &args);
	if (!err) {
		struct inode *inode = d_inode(entry);
		struct fuse_inode *fi = get_fuse_inode(inode);

		spin_lock(&fi->lock);
		fi->attr_version = atomic64_inc_return(&fm->fc->attr_version);
		/*
		 * If i_nlink == 0 then unlink doesn't make sense, yet this can
		 * happen if userspace filesystem is careless.  It would be
		 * difficult to enforce correct nlink usage so just ignore this
		 * condition here
		 */
		if (inode->i_nlink > 0)
			drop_nlink(inode);
		spin_unlock(&fi->lock);
		fuse_invalidate_attr(inode);
		fuse_dir_changed(dir);
		fuse_invalidate_entry_cache(entry);
		fuse_update_ctime(inode);
	} else if (err == -EINTR)
		fuse_invalidate_entry(entry);
	return err;
}","static int fuse_unlink(struct inode *VAR_0, struct dentry *VAR_1)
{
	int VAR_2;
	struct fuse_mount *VAR_3 = get_fuse_mount(VAR_0);
	FUSE_ARGS(VAR_4);

	if (fuse_is_bad(VAR_0))
		return -VAR_5;

	VAR_4.opcode = VAR_6;
	VAR_4.nodeid = get_node_id(VAR_0);
	VAR_4.in_numargs = 1;
	VAR_4.in_args[0].size = VAR_1->d_name.len + 1;
	VAR_4.in_args[0].value = VAR_1->d_name.name;
	VAR_2 = fuse_simple_request(VAR_3, &VAR_4);
	if (!VAR_2) {
		struct inode *inode = d_inode(VAR_1);
		struct fuse_inode *VAR_7 = get_fuse_inode(inode);

		spin_lock(&VAR_7->lock);
		VAR_7->attr_version = atomic64_inc_return(&VAR_3->fc->attr_version);
		/* COMMENT_0 */
                                                                 
                                                             
                                                                 
                   
     
		if (inode->i_nlink > 0)
			drop_nlink(inode);
		spin_unlock(&VAR_7->lock);
		fuse_invalidate_attr(inode);
		fuse_dir_changed(VAR_0);
		fuse_invalidate_entry_cache(VAR_1);
		fuse_update_ctime(inode);
	} else if (VAR_2 == -VAR_8)
		fuse_invalidate_entry(VAR_1);
	return VAR_2;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 	int err;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
+
+	if (fuse_is_bad(dir))
+		return -EIO;
 
 	args.opcode = FUSE_UNLINK;
 	args.nodeid = get_node_id(dir);","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(dir))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_do_getattr,"static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
struct file *file)
{
int err;
struct fuse_getattr_in inarg;
struct fuse_attr_out outarg;
struct fuse_mount *fm = get_fuse_mount(inode);
FUSE_ARGS(args);
u64 attr_version;
attr_version = fuse_get_attr_version(fm->fc);
memset(&inarg, 0, sizeof(inarg));
memset(&outarg, 0, sizeof(outarg));
if (file && S_ISREG(inode->i_mode)) {
struct fuse_file *ff = file->private_data;
inarg.getattr_flags |= FUSE_GETATTR_FH;
inarg.fh = ff->fh;
}
args.opcode = FUSE_GETATTR;
args.nodeid = get_node_id(inode);
args.in_numargs = 1;
args.in_args[0].size = sizeof(inarg);
args.in_args[0].value = &inarg;
args.out_numargs = 1;
args.out_args[0].size = sizeof(outarg);
args.out_args[0].value = &outarg;
err = fuse_simple_request(fm, &args);
if (!err) {
if (fuse_invalid_attr(&outarg.attr) ||
(inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
make_bad_inode(inode);
err = -EIO;
} else {
fuse_change_attributes(inode, &outarg.attr,
attr_timeout(&outarg),
attr_version);
if (stat)
fuse_fillattr(inode, &outarg.attr, stat);
}
}
return err;
}","static int fuse_do_getattr(struct inode *inode, struct kstat *VAR_0,
struct file *file)
{
int VAR_1;
struct fuse_getattr_in VAR_2;
struct fuse_attr_out VAR_3;
struct fuse_mount *VAR_4 = get_fuse_mount(inode);
FUSE_ARGS(VAR_5);
u64 VAR_6;
VAR_6 = fuse_get_attr_version(VAR_4->fc);
memset(&VAR_2, 0, sizeof(VAR_2));
memset(&VAR_3, 0, sizeof(VAR_3));
if (file && S_ISREG(inode->i_mode)) {
struct fuse_file *VAR_7 = file->private_data;
VAR_2.getattr_flags |= VAR_8;
VAR_2.fh = VAR_7->fh;
}
VAR_5.opcode = VAR_9;
VAR_5.nodeid = get_node_id(inode);
VAR_5.in_numargs = 1;
VAR_5.in_args[0].size = sizeof(VAR_2);
VAR_5.in_args[0].value = &VAR_2;
VAR_5.out_numargs = 1;
VAR_5.out_args[0].size = sizeof(VAR_3);
VAR_5.out_args[0].value = &VAR_3;
VAR_1 = fuse_simple_request(VAR_4, &VAR_5);
if (!VAR_1) {
if (fuse_invalid_attr(&VAR_3.attr) ||
(inode->i_mode ^ VAR_3.attr.mode) & VAR_10) {
make_bad_inode(inode);
VAR_1 = -VAR_11;
} else {
fuse_change_attributes(inode, &VAR_3.attr,
attr_timeout(&VAR_3),
VAR_6);
if (VAR_0)
fuse_fillattr(inode, &VAR_3.attr, VAR_0);
}
}
return VAR_1;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/4.json,"static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
			   struct file *file)
{
	int err;
	struct fuse_getattr_in inarg;
	struct fuse_attr_out outarg;
	struct fuse_mount *fm = get_fuse_mount(inode);
	FUSE_ARGS(args);
	u64 attr_version;

	attr_version = fuse_get_attr_version(fm->fc);

	memset(&inarg, 0, sizeof(inarg));
	memset(&outarg, 0, sizeof(outarg));
	/* Directories have separate file-handle space */
	if (file && S_ISREG(inode->i_mode)) {
		struct fuse_file *ff = file->private_data;

		inarg.getattr_flags |= FUSE_GETATTR_FH;
		inarg.fh = ff->fh;
	}
	args.opcode = FUSE_GETATTR;
	args.nodeid = get_node_id(inode);
	args.in_numargs = 1;
	args.in_args[0].size = sizeof(inarg);
	args.in_args[0].value = &inarg;
	args.out_numargs = 1;
	args.out_args[0].size = sizeof(outarg);
	args.out_args[0].value = &outarg;
	err = fuse_simple_request(fm, &args);
	if (!err) {
		if (fuse_invalid_attr(&outarg.attr) ||
		    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
			fuse_make_bad(inode);
			err = -EIO;
		} else {
			fuse_change_attributes(inode, &outarg.attr,
					       attr_timeout(&outarg),
					       attr_version);
			if (stat)
				fuse_fillattr(inode, &outarg.attr, stat);
		}
	}
	return err;
}","static int fuse_do_getattr(struct inode *inode, struct kstat *VAR_0,
			   struct file *file)
{
	int VAR_1;
	struct fuse_getattr_in VAR_2;
	struct fuse_attr_out VAR_3;
	struct fuse_mount *VAR_4 = get_fuse_mount(inode);
	FUSE_ARGS(VAR_5);
	u64 VAR_6;

	VAR_6 = fuse_get_attr_version(VAR_4->fc);

	memset(&VAR_2, 0, sizeof(VAR_2));
	memset(&VAR_3, 0, sizeof(VAR_3));
	/* COMMENT_0 */
	if (file && S_ISREG(inode->i_mode)) {
		struct fuse_file *VAR_7 = file->private_data;

		VAR_2.getattr_flags |= VAR_8;
		VAR_2.fh = VAR_7->fh;
	}
	VAR_5.opcode = VAR_9;
	VAR_5.nodeid = get_node_id(inode);
	VAR_5.in_numargs = 1;
	VAR_5.in_args[0].size = sizeof(VAR_2);
	VAR_5.in_args[0].value = &VAR_2;
	VAR_5.out_numargs = 1;
	VAR_5.out_args[0].size = sizeof(VAR_3);
	VAR_5.out_args[0].value = &VAR_3;
	VAR_1 = fuse_simple_request(VAR_4, &VAR_5);
	if (!VAR_1) {
		if (fuse_invalid_attr(&VAR_3.attr) ||
		    (inode->i_mode ^ VAR_3.attr.mode) & VAR_10) {
			fuse_make_bad(inode);
			VAR_1 = -VAR_11;
		} else {
			fuse_change_attributes(inode, &VAR_3.attr,
					       attr_timeout(&VAR_3),
					       VAR_6);
			if (VAR_0)
				fuse_fillattr(inode, &VAR_3.attr, VAR_0);
		}
	}
	return VAR_1;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 	if (!err) {
 		if (fuse_invalid_attr(&outarg.attr) ||
 		    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
-			make_bad_inode(inode);
+			fuse_make_bad(inode);
 			err = -EIO;
 		} else {
 			fuse_change_attributes(inode, &outarg.attr,","{'deleted_lines': ['\t\t\tmake_bad_inode(inode);'], 'added_lines': ['\t\t\tfuse_make_bad(inode);']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_dir_fsync,"static int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,
int datasync)
{
struct inode *inode = file->f_mapping->host;
struct fuse_conn *fc = get_fuse_conn(inode);
int err;
if (is_bad_inode(inode))
return -EIO;
if (fc->no_fsyncdir)
return 0;
inode_lock(inode);
err = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNCDIR);
if (err == -ENOSYS) {
fc->no_fsyncdir = 1;
err = 0;
}
inode_unlock(inode);
return err;
}","static int fuse_dir_fsync(struct file *file, loff_t VAR_0, loff_t VAR_1,
int VAR_2)
{
struct inode *inode = file->f_mapping->host;
struct fuse_conn *VAR_3 = get_fuse_conn(inode);
int VAR_4;
if (is_bad_inode(inode))
return -VAR_5;
if (VAR_3->no_fsyncdir)
return 0;
inode_lock(inode);
VAR_4 = fuse_fsync_common(file, VAR_0, VAR_1, VAR_2, VAR_6);
if (VAR_4 == -VAR_7) {
VAR_3->no_fsyncdir = 1;
VAR_4 = 0;
}
inode_unlock(inode);
return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/5.json,"static int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,
			  int datasync)
{
	struct inode *inode = file->f_mapping->host;
	struct fuse_conn *fc = get_fuse_conn(inode);
	int err;

	if (fuse_is_bad(inode))
		return -EIO;

	if (fc->no_fsyncdir)
		return 0;

	inode_lock(inode);
	err = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNCDIR);
	if (err == -ENOSYS) {
		fc->no_fsyncdir = 1;
		err = 0;
	}
	inode_unlock(inode);

	return err;
}","static int fuse_dir_fsync(struct file *file, loff_t VAR_0, loff_t VAR_1,
			  int VAR_2)
{
	struct inode *inode = file->f_mapping->host;
	struct fuse_conn *VAR_3 = get_fuse_conn(inode);
	int VAR_4;

	if (fuse_is_bad(inode))
		return -VAR_5;

	if (VAR_3->no_fsyncdir)
		return 0;

	inode_lock(inode);
	VAR_4 = fuse_fsync_common(file, VAR_0, VAR_1, VAR_2, VAR_6);
	if (VAR_4 == -VAR_7) {
		VAR_3->no_fsyncdir = 1;
		VAR_4 = 0;
	}
	inode_unlock(inode);

	return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	if (fc->no_fsyncdir)","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,create_new_entry,"static int create_new_entry(struct fuse_mount *fm, struct fuse_args *args,
struct inode *dir, struct dentry *entry,
umode_t mode)
{
struct fuse_entry_out outarg;
struct inode *inode;
struct dentry *d;
int err;
struct fuse_forget_link *forget;
forget = fuse_alloc_forget();
if (!forget)
return -ENOMEM;
memset(&outarg, 0, sizeof(outarg));
args->nodeid = get_node_id(dir);
args->out_numargs = 1;
args->out_args[0].size = sizeof(outarg);
args->out_args[0].value = &outarg;
err = fuse_simple_request(fm, args);
if (err)
goto out_put_forget_req;
err = -EIO;
if (invalid_nodeid(outarg.nodeid) || fuse_invalid_attr(&outarg.attr))
goto out_put_forget_req;
if ((outarg.attr.mode ^ mode) & S_IFMT)
goto out_put_forget_req;
inode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,
&outarg.attr, entry_attr_timeout(&outarg), 0);
if (!inode) {
fuse_queue_forget(fm->fc, forget, outarg.nodeid, 1);
return -ENOMEM;
}
kfree(forget);
d_drop(entry);
d = d_splice_alias(inode, entry);
if (IS_ERR(d))
return PTR_ERR(d);
if (d) {
fuse_change_entry_timeout(d, &outarg);
dput(d);
} else {
fuse_change_entry_timeout(entry, &outarg);
}
fuse_dir_changed(dir);
return 0;
out_put_forget_req:
kfree(forget);
return err;
}","static int create_new_entry(struct fuse_mount *VAR_0, struct fuse_args *VAR_1,
struct inode *VAR_2, struct dentry *VAR_3,
umode_t VAR_4)
{
struct fuse_entry_out VAR_5;
struct inode *inode;
struct dentry *VAR_6;
int VAR_7;
struct fuse_forget_link *VAR_8;
VAR_8 = fuse_alloc_forget();
if (!VAR_8)
return -VAR_9;
memset(&VAR_5, 0, sizeof(VAR_5));
VAR_1->nodeid = get_node_id(VAR_2);
VAR_1->out_numargs = 1;
VAR_1->out_args[0].size = sizeof(VAR_5);
VAR_1->out_args[0].value = &VAR_5;
VAR_7 = fuse_simple_request(VAR_0, VAR_1);
if (VAR_7)
goto out_put_forget_req;
VAR_7 = -VAR_10;
if (invalid_nodeid(VAR_5.nodeid) || fuse_invalid_attr(&VAR_5.attr))
goto out_put_forget_req;
if ((VAR_5.attr.mode ^ VAR_4) & VAR_11)
goto out_put_forget_req;
inode = fuse_iget(VAR_2->i_sb, VAR_5.nodeid, VAR_5.generation,
&VAR_5.attr, entry_attr_timeout(&VAR_5), 0);
if (!inode) {
fuse_queue_forget(VAR_0->fc, VAR_8, VAR_5.nodeid, 1);
return -VAR_9;
}
kfree(VAR_8);
d_drop(VAR_3);
VAR_6 = d_splice_alias(inode, VAR_3);
if (IS_ERR(VAR_6))
return PTR_ERR(VAR_6);
if (VAR_6) {
fuse_change_entry_timeout(VAR_6, &VAR_5);
dput(VAR_6);
} else {
fuse_change_entry_timeout(VAR_3, &VAR_5);
}
fuse_dir_changed(VAR_2);
return 0;
out_put_forget_req:
kfree(VAR_8);
return VAR_7;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/6.json,"static int create_new_entry(struct fuse_mount *fm, struct fuse_args *args,
			    struct inode *dir, struct dentry *entry,
			    umode_t mode)
{
	struct fuse_entry_out outarg;
	struct inode *inode;
	struct dentry *d;
	int err;
	struct fuse_forget_link *forget;

	if (fuse_is_bad(dir))
		return -EIO;

	forget = fuse_alloc_forget();
	if (!forget)
		return -ENOMEM;

	memset(&outarg, 0, sizeof(outarg));
	args->nodeid = get_node_id(dir);
	args->out_numargs = 1;
	args->out_args[0].size = sizeof(outarg);
	args->out_args[0].value = &outarg;
	err = fuse_simple_request(fm, args);
	if (err)
		goto out_put_forget_req;

	err = -EIO;
	if (invalid_nodeid(outarg.nodeid) || fuse_invalid_attr(&outarg.attr))
		goto out_put_forget_req;

	if ((outarg.attr.mode ^ mode) & S_IFMT)
		goto out_put_forget_req;

	inode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,
			  &outarg.attr, entry_attr_timeout(&outarg), 0);
	if (!inode) {
		fuse_queue_forget(fm->fc, forget, outarg.nodeid, 1);
		return -ENOMEM;
	}
	kfree(forget);

	d_drop(entry);
	d = d_splice_alias(inode, entry);
	if (IS_ERR(d))
		return PTR_ERR(d);

	if (d) {
		fuse_change_entry_timeout(d, &outarg);
		dput(d);
	} else {
		fuse_change_entry_timeout(entry, &outarg);
	}
	fuse_dir_changed(dir);
	return 0;

 out_put_forget_req:
	kfree(forget);
	return err;
}","static int create_new_entry(struct fuse_mount *VAR_0, struct fuse_args *VAR_1,
			    struct inode *VAR_2, struct dentry *VAR_3,
			    umode_t VAR_4)
{
	struct fuse_entry_out VAR_5;
	struct inode *inode;
	struct dentry *VAR_6;
	int VAR_7;
	struct fuse_forget_link *VAR_8;

	if (fuse_is_bad(VAR_2))
		return -VAR_9;

	VAR_8 = fuse_alloc_forget();
	if (!VAR_8)
		return -VAR_10;

	memset(&VAR_5, 0, sizeof(VAR_5));
	VAR_1->nodeid = get_node_id(VAR_2);
	VAR_1->out_numargs = 1;
	VAR_1->out_args[0].size = sizeof(VAR_5);
	VAR_1->out_args[0].value = &VAR_5;
	VAR_7 = fuse_simple_request(VAR_0, VAR_1);
	if (VAR_7)
		goto out_put_forget_req;

	VAR_7 = -VAR_9;
	if (invalid_nodeid(VAR_5.nodeid) || fuse_invalid_attr(&VAR_5.attr))
		goto out_put_forget_req;

	if ((VAR_5.attr.mode ^ VAR_4) & VAR_11)
		goto out_put_forget_req;

	inode = fuse_iget(VAR_2->i_sb, VAR_5.nodeid, VAR_5.generation,
			  &VAR_5.attr, entry_attr_timeout(&VAR_5), 0);
	if (!inode) {
		fuse_queue_forget(VAR_0->fc, VAR_8, VAR_5.nodeid, 1);
		return -VAR_10;
	}
	kfree(VAR_8);

	d_drop(VAR_3);
	VAR_6 = d_splice_alias(inode, VAR_3);
	if (IS_ERR(VAR_6))
		return PTR_ERR(VAR_6);

	if (VAR_6) {
		fuse_change_entry_timeout(VAR_6, &VAR_5);
		dput(VAR_6);
	} else {
		fuse_change_entry_timeout(VAR_3, &VAR_5);
	}
	fuse_dir_changed(VAR_2);
	return 0;

 out_put_forget_req:
	kfree(VAR_8);
	return VAR_7;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -7,6 +7,9 @@
 	struct dentry *d;
 	int err;
 	struct fuse_forget_link *forget;
+
+	if (fuse_is_bad(dir))
+		return -EIO;
 
 	forget = fuse_alloc_forget();
 	if (!forget)","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(dir))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_getattr,"static int fuse_getattr(const struct path *path, struct kstat *stat,
u32 request_mask, unsigned int flags)
{
struct inode *inode = d_inode(path->dentry);
struct fuse_conn *fc = get_fuse_conn(inode);
if (!fuse_allow_current_process(fc)) {
if (!request_mask) {
stat->result_mask = 0;
stat->dev = inode->i_sb->s_dev;
return 0;
}
return -EACCES;
}
return fuse_update_get_attr(inode, NULL, stat, request_mask, flags);
}","static int fuse_getattr(const struct path *path, struct kstat *VAR_0,
u32 VAR_1, unsigned int VAR_2)
{
struct inode *inode = d_inode(path->dentry);
struct fuse_conn *VAR_3 = get_fuse_conn(inode);
if (!fuse_allow_current_process(VAR_3)) {
if (!VAR_1) {
VAR_0->result_mask = 0;
VAR_0->dev = inode->i_sb->s_dev;
return 0;
}
return -VAR_4;
}
return fuse_update_get_attr(inode, NULL, VAR_0, VAR_1, VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/7.json,"static int fuse_getattr(const struct path *path, struct kstat *stat,
			u32 request_mask, unsigned int flags)
{
	struct inode *inode = d_inode(path->dentry);
	struct fuse_conn *fc = get_fuse_conn(inode);

	if (fuse_is_bad(inode))
		return -EIO;

	if (!fuse_allow_current_process(fc)) {
		if (!request_mask) {
			/*
			 * If user explicitly requested *nothing* then don't
			 * error out, but return st_dev only.
			 */
			stat->result_mask = 0;
			stat->dev = inode->i_sb->s_dev;
			return 0;
		}
		return -EACCES;
	}

	return fuse_update_get_attr(inode, NULL, stat, request_mask, flags);
}","static int fuse_getattr(const struct path *path, struct kstat *VAR_0,
			u32 VAR_1, unsigned int VAR_2)
{
	struct inode *inode = d_inode(path->dentry);
	struct fuse_conn *VAR_3 = get_fuse_conn(inode);

	if (fuse_is_bad(inode))
		return -VAR_4;

	if (!fuse_allow_current_process(VAR_3)) {
		if (!VAR_1) {
			/* COMMENT_0 */
                                                       
                                        
      
			VAR_0->result_mask = 0;
			VAR_0->dev = inode->i_sb->s_dev;
			return 0;
		}
		return -VAR_5;
	}

	return fuse_update_get_attr(inode, NULL, VAR_0, VAR_1, VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 {
 	struct inode *inode = d_inode(path->dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	if (!fuse_allow_current_process(fc)) {
 		if (!request_mask) {","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_lookup,"static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
unsigned int flags)
{
int err;
struct fuse_entry_out outarg;
struct inode *inode;
struct dentry *newent;
bool outarg_valid = true;
bool locked;
locked = fuse_lock_inode(dir);
err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,
&outarg, &inode);
fuse_unlock_inode(dir, locked);
if (err == -ENOENT) {
outarg_valid = false;
err = 0;
}
if (err)
goto out_err;
err = -EIO;
if (inode && get_node_id(inode) == FUSE_ROOT_ID)
goto out_iput;
newent = d_splice_alias(inode, entry);
err = PTR_ERR(newent);
if (IS_ERR(newent))
goto out_err;
entry = newent ? newent : entry;
if (outarg_valid)
fuse_change_entry_timeout(entry, &outarg);
else
fuse_invalidate_entry_cache(entry);
if (inode)
fuse_advise_use_readdirplus(dir);
return newent;
out_iput:
iput(inode);
out_err:
return ERR_PTR(err);
}","static struct dentry *fuse_lookup(struct inode *VAR_0, struct dentry *VAR_1,
unsigned int VAR_2)
{
int VAR_3;
struct fuse_entry_out VAR_4;
struct inode *inode;
struct dentry *VAR_5;
bool VAR_6 = true;
bool VAR_7;
VAR_7 = fuse_lock_inode(VAR_0);
VAR_3 = fuse_lookup_name(VAR_0->i_sb, get_node_id(VAR_0), &VAR_1->d_name,
&VAR_4, &inode);
fuse_unlock_inode(VAR_0, VAR_7);
if (VAR_3 == -VAR_8) {
VAR_6 = false;
VAR_3 = 0;
}
if (VAR_3)
goto out_err;
VAR_3 = -VAR_9;
if (inode && get_node_id(inode) == VAR_10)
goto out_iput;
VAR_5 = d_splice_alias(inode, VAR_1);
VAR_3 = PTR_ERR(VAR_5);
if (IS_ERR(VAR_5))
goto out_err;
VAR_1 = VAR_5 ? VAR_5 : VAR_1;
if (VAR_6)
fuse_change_entry_timeout(VAR_1, &VAR_4);
else
fuse_invalidate_entry_cache(VAR_1);
if (inode)
fuse_advise_use_readdirplus(VAR_0);
return VAR_5;
out_iput:
iput(inode);
out_err:
return ERR_PTR(VAR_3);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/8.json,"static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
				  unsigned int flags)
{
	int err;
	struct fuse_entry_out outarg;
	struct inode *inode;
	struct dentry *newent;
	bool outarg_valid = true;
	bool locked;

	if (fuse_is_bad(dir))
		return ERR_PTR(-EIO);

	locked = fuse_lock_inode(dir);
	err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,
			       &outarg, &inode);
	fuse_unlock_inode(dir, locked);
	if (err == -ENOENT) {
		outarg_valid = false;
		err = 0;
	}
	if (err)
		goto out_err;

	err = -EIO;
	if (inode && get_node_id(inode) == FUSE_ROOT_ID)
		goto out_iput;

	newent = d_splice_alias(inode, entry);
	err = PTR_ERR(newent);
	if (IS_ERR(newent))
		goto out_err;

	entry = newent ? newent : entry;
	if (outarg_valid)
		fuse_change_entry_timeout(entry, &outarg);
	else
		fuse_invalidate_entry_cache(entry);

	if (inode)
		fuse_advise_use_readdirplus(dir);
	return newent;

 out_iput:
	iput(inode);
 out_err:
	return ERR_PTR(err);
}","static struct dentry *fuse_lookup(struct inode *VAR_0, struct dentry *VAR_1,
				  unsigned int VAR_2)
{
	int VAR_3;
	struct fuse_entry_out VAR_4;
	struct inode *inode;
	struct dentry *VAR_5;
	bool VAR_6 = true;
	bool VAR_7;

	if (fuse_is_bad(VAR_0))
		return ERR_PTR(-VAR_8);

	VAR_7 = fuse_lock_inode(VAR_0);
	VAR_3 = fuse_lookup_name(VAR_0->i_sb, get_node_id(VAR_0), &VAR_1->d_name,
			       &VAR_4, &inode);
	fuse_unlock_inode(VAR_0, VAR_7);
	if (VAR_3 == -VAR_9) {
		VAR_6 = false;
		VAR_3 = 0;
	}
	if (VAR_3)
		goto out_err;

	VAR_3 = -VAR_8;
	if (inode && get_node_id(inode) == VAR_10)
		goto out_iput;

	VAR_5 = d_splice_alias(inode, VAR_1);
	VAR_3 = PTR_ERR(VAR_5);
	if (IS_ERR(VAR_5))
		goto out_err;

	VAR_1 = VAR_5 ? VAR_5 : VAR_1;
	if (VAR_6)
		fuse_change_entry_timeout(VAR_1, &VAR_4);
	else
		fuse_invalidate_entry_cache(VAR_1);

	if (inode)
		fuse_advise_use_readdirplus(VAR_0);
	return VAR_5;

 out_iput:
	iput(inode);
 out_err:
	return ERR_PTR(VAR_3);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/8.json,"--- func_before
+++ func_after
@@ -7,6 +7,9 @@
 	struct dentry *newent;
 	bool outarg_valid = true;
 	bool locked;
+
+	if (fuse_is_bad(dir))
+		return ERR_PTR(-EIO);
 
 	locked = fuse_lock_inode(dir);
 	err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(dir))', '\t\treturn ERR_PTR(-EIO);']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_permission,"static int fuse_permission(struct inode *inode, int mask)
{
struct fuse_conn *fc = get_fuse_conn(inode);
bool refreshed = false;
int err = 0;
if (!fuse_allow_current_process(fc))
return -EACCES;
if (fc->default_permissions ||
((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {
struct fuse_inode *fi = get_fuse_inode(inode);
u32 perm_mask = STATX_MODE | STATX_UID | STATX_GID;
if (perm_mask & READ_ONCE(fi->inval_mask) ||
time_before64(fi->i_time, get_jiffies_64())) {
refreshed = true;
err = fuse_perm_getattr(inode, mask);
if (err)
return err;
}
}
if (fc->default_permissions) {
err = generic_permission(inode, mask);
if (err == -EACCES && !refreshed) {
err = fuse_perm_getattr(inode, mask);
if (!err)
err = generic_permission(inode, mask);
}
} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {
err = fuse_access(inode, mask);
} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {
if (!(inode->i_mode & S_IXUGO)) {
if (refreshed)
return -EACCES;
err = fuse_perm_getattr(inode, mask);
if (!err && !(inode->i_mode & S_IXUGO))
return -EACCES;
}
}
return err;
}","static int fuse_permission(struct inode *inode, int VAR_0)
{
struct fuse_conn *VAR_1 = get_fuse_conn(inode);
bool VAR_2 = false;
int VAR_3 = 0;
if (!fuse_allow_current_process(VAR_1))
return -VAR_4;
if (VAR_1->default_permissions ||
((VAR_0 & VAR_5) && S_ISREG(inode->i_mode))) {
struct fuse_inode *VAR_6 = get_fuse_inode(inode);
u32 VAR_7 = VAR_8 | VAR_9 | VAR_10;
if (VAR_7 & READ_ONCE(VAR_6->inval_mask) ||
time_before64(VAR_6->i_time, get_jiffies_64())) {
VAR_2 = true;
VAR_3 = fuse_perm_getattr(inode, VAR_0);
if (VAR_3)
return VAR_3;
}
}
if (VAR_1->default_permissions) {
VAR_3 = generic_permission(inode, VAR_0);
if (VAR_3 == -VAR_4 && !VAR_2) {
VAR_3 = fuse_perm_getattr(inode, VAR_0);
if (!VAR_3)
VAR_3 = generic_permission(inode, VAR_0);
}
} else if (VAR_0 & (VAR_11 | VAR_12)) {
VAR_3 = fuse_access(inode, VAR_0);
} else if ((VAR_0 & VAR_5) && S_ISREG(inode->i_mode)) {
if (!(inode->i_mode & VAR_13)) {
if (VAR_2)
return -VAR_4;
VAR_3 = fuse_perm_getattr(inode, VAR_0);
if (!VAR_3 && !(inode->i_mode & VAR_13))
return -VAR_4;
}
}
return VAR_3;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/9.json,"static int fuse_permission(struct inode *inode, int mask)
{
	struct fuse_conn *fc = get_fuse_conn(inode);
	bool refreshed = false;
	int err = 0;

	if (fuse_is_bad(inode))
		return -EIO;

	if (!fuse_allow_current_process(fc))
		return -EACCES;

	/*
	 * If attributes are needed, refresh them before proceeding
	 */
	if (fc->default_permissions ||
	    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {
		struct fuse_inode *fi = get_fuse_inode(inode);
		u32 perm_mask = STATX_MODE | STATX_UID | STATX_GID;

		if (perm_mask & READ_ONCE(fi->inval_mask) ||
		    time_before64(fi->i_time, get_jiffies_64())) {
			refreshed = true;

			err = fuse_perm_getattr(inode, mask);
			if (err)
				return err;
		}
	}

	if (fc->default_permissions) {
		err = generic_permission(inode, mask);

		/* If permission is denied, try to refresh file
		   attributes.  This is also needed, because the root
		   node will at first have no permissions */
		if (err == -EACCES && !refreshed) {
			err = fuse_perm_getattr(inode, mask);
			if (!err)
				err = generic_permission(inode, mask);
		}

		/* Note: the opposite of the above test does not
		   exist.  So if permissions are revoked this won't be
		   noticed immediately, only after the attribute
		   timeout has expired */
	} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {
		err = fuse_access(inode, mask);
	} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {
		if (!(inode->i_mode & S_IXUGO)) {
			if (refreshed)
				return -EACCES;

			err = fuse_perm_getattr(inode, mask);
			if (!err && !(inode->i_mode & S_IXUGO))
				return -EACCES;
		}
	}
	return err;
}","static int fuse_permission(struct inode *inode, int VAR_0)
{
	struct fuse_conn *VAR_1 = get_fuse_conn(inode);
	bool VAR_2 = false;
	int VAR_3 = 0;

	if (fuse_is_bad(inode))
		return -VAR_4;

	if (!fuse_allow_current_process(VAR_1))
		return -VAR_5;

	/* COMMENT_0 */
                                                            
    
	if (VAR_1->default_permissions ||
	    ((VAR_0 & VAR_6) && S_ISREG(inode->i_mode))) {
		struct fuse_inode *VAR_7 = get_fuse_inode(inode);
		u32 VAR_8 = VAR_9 | VAR_10 | VAR_11;

		if (VAR_8 & READ_ONCE(VAR_7->inval_mask) ||
		    time_before64(VAR_7->i_time, get_jiffies_64())) {
			VAR_2 = true;

			VAR_3 = fuse_perm_getattr(inode, VAR_0);
			if (VAR_3)
				return VAR_3;
		}
	}

	if (VAR_1->default_permissions) {
		VAR_3 = generic_permission(inode, VAR_0);

		/* COMMENT_3 */
                                                       
                                              
		if (VAR_3 == -VAR_5 && !VAR_2) {
			VAR_3 = fuse_perm_getattr(inode, VAR_0);
			if (!VAR_3)
				VAR_3 = generic_permission(inode, VAR_0);
		}

		/* COMMENT_6 */
                                                        
                                                  
                           
	} else if (VAR_0 & (VAR_12 | VAR_13)) {
		VAR_3 = fuse_access(inode, VAR_0);
	} else if ((VAR_0 & VAR_6) && S_ISREG(inode->i_mode)) {
		if (!(inode->i_mode & VAR_14)) {
			if (VAR_2)
				return -VAR_5;

			VAR_3 = fuse_perm_getattr(inode, VAR_0);
			if (!VAR_3 && !(inode->i_mode & VAR_14))
				return -VAR_5;
		}
	}
	return VAR_3;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/9.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	bool refreshed = false;
 	int err = 0;
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	if (!fuse_allow_current_process(fc))
 		return -EACCES;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_get_link,"static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
struct delayed_call *callback)
{
struct fuse_conn *fc = get_fuse_conn(inode);
struct page *page;
int err;
err = -EIO;
if (is_bad_inode(inode))
goto out_err;
if (fc->cache_symlinks)
return page_get_link(dentry, inode, callback);
err = -ECHILD;
if (!dentry)
goto out_err;
page = alloc_page(GFP_KERNEL);
err = -ENOMEM;
if (!page)
goto out_err;
err = fuse_readlink_page(inode, page);
if (err) {
__free_page(page);
goto out_err;
}
set_delayed_call(callback, page_put_link, page);
return page_address(page);
out_err:
return ERR_PTR(err);
}","static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
struct delayed_call *VAR_0)
{
struct fuse_conn *VAR_1 = get_fuse_conn(inode);
struct page *page;
int VAR_2;
VAR_2 = -VAR_3;
if (is_bad_inode(inode))
goto out_err;
if (VAR_1->cache_symlinks)
return page_get_link(dentry, inode, VAR_0);
VAR_2 = -VAR_4;
if (!dentry)
goto out_err;
page = alloc_page(VAR_5);
VAR_2 = -VAR_6;
if (!page)
goto out_err;
VAR_2 = fuse_readlink_page(inode, page);
if (VAR_2) {
__free_page(page);
goto out_err;
}
set_delayed_call(VAR_0, VAR_7, page);
return page_address(page);
out_err:
return ERR_PTR(VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/10.json,"static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
				 struct delayed_call *callback)
{
	struct fuse_conn *fc = get_fuse_conn(inode);
	struct page *page;
	int err;

	err = -EIO;
	if (fuse_is_bad(inode))
		goto out_err;

	if (fc->cache_symlinks)
		return page_get_link(dentry, inode, callback);

	err = -ECHILD;
	if (!dentry)
		goto out_err;

	page = alloc_page(GFP_KERNEL);
	err = -ENOMEM;
	if (!page)
		goto out_err;

	err = fuse_readlink_page(inode, page);
	if (err) {
		__free_page(page);
		goto out_err;
	}

	set_delayed_call(callback, page_put_link, page);

	return page_address(page);

out_err:
	return ERR_PTR(err);
}","static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
				 struct delayed_call *VAR_0)
{
	struct fuse_conn *VAR_1 = get_fuse_conn(inode);
	struct page *page;
	int VAR_2;

	VAR_2 = -VAR_3;
	if (fuse_is_bad(inode))
		goto out_err;

	if (VAR_1->cache_symlinks)
		return page_get_link(dentry, inode, VAR_0);

	VAR_2 = -VAR_4;
	if (!dentry)
		goto out_err;

	page = alloc_page(VAR_5);
	VAR_2 = -VAR_6;
	if (!page)
		goto out_err;

	VAR_2 = fuse_readlink_page(inode, page);
	if (VAR_2) {
		__free_page(page);
		goto out_err;
	}

	set_delayed_call(VAR_0, VAR_7, page);

	return page_address(page);

out_err:
	return ERR_PTR(VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/10.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	int err;
 
 	err = -EIO;
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		goto out_err;
 
 	if (fc->cache_symlinks)","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_setattr,"static int fuse_setattr(struct dentry *entry, struct iattr *attr)
{
struct inode *inode = d_inode(entry);
struct fuse_conn *fc = get_fuse_conn(inode);
struct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;
int ret;
if (!fuse_allow_current_process(get_fuse_conn(inode)))
return -EACCES;
if (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID)) {
attr->ia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |
ATTR_MODE);
if (!fc->handle_killpriv && !fc->handle_killpriv_v2) {
ret = fuse_do_getattr(inode, NULL, file);
if (ret)
return ret;
attr->ia_mode = inode->i_mode;
if (inode->i_mode & S_ISUID) {
attr->ia_valid |= ATTR_MODE;
attr->ia_mode &= ~S_ISUID;
}
if ((inode->i_mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
attr->ia_valid |= ATTR_MODE;
attr->ia_mode &= ~S_ISGID;
}
}
}
if (!attr->ia_valid)
return 0;
ret = fuse_do_setattr(entry, attr, file);
if (!ret) {
if (fc->posix_acl)
forget_all_cached_acls(inode);
if (d_is_dir(entry) && (attr->ia_valid & ATTR_MODE))
fuse_invalidate_entry_cache(entry);
}
return ret;
}","static int fuse_setattr(struct dentry *VAR_0, struct iattr *VAR_1)
{
struct inode *inode = d_inode(VAR_0);
struct fuse_conn *VAR_2 = get_fuse_conn(inode);
struct file *file = (VAR_1->ia_valid & VAR_3) ? VAR_1->ia_file : NULL;
int VAR_4;
if (!fuse_allow_current_process(get_fuse_conn(inode)))
return -VAR_5;
if (VAR_1->ia_valid & (VAR_6 | VAR_7)) {
VAR_1->ia_valid &= ~(VAR_6 | VAR_7 |
VAR_8);
if (!VAR_2->handle_killpriv && !VAR_2->handle_killpriv_v2) {
VAR_4 = fuse_do_getattr(inode, NULL, file);
if (VAR_4)
return VAR_4;
VAR_1->ia_mode = inode->i_mode;
if (inode->i_mode & VAR_9) {
VAR_1->ia_valid |= VAR_8;
VAR_1->ia_mode &= ~VAR_9;
}
if ((inode->i_mode & (VAR_10 | VAR_11)) == (VAR_10 | VAR_11)) {
VAR_1->ia_valid |= VAR_8;
VAR_1->ia_mode &= ~VAR_10;
}
}
}
if (!VAR_1->ia_valid)
return 0;
VAR_4 = fuse_do_setattr(VAR_0, VAR_1, file);
if (!VAR_4) {
if (VAR_2->posix_acl)
forget_all_cached_acls(inode);
if (d_is_dir(VAR_0) && (VAR_1->ia_valid & VAR_8))
fuse_invalidate_entry_cache(VAR_0);
}
return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/11.json,"static int fuse_setattr(struct dentry *entry, struct iattr *attr)
{
	struct inode *inode = d_inode(entry);
	struct fuse_conn *fc = get_fuse_conn(inode);
	struct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;
	int ret;

	if (fuse_is_bad(inode))
		return -EIO;

	if (!fuse_allow_current_process(get_fuse_conn(inode)))
		return -EACCES;

	if (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID)) {
		attr->ia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |
				    ATTR_MODE);

		/*
		 * The only sane way to reliably kill suid/sgid is to do it in
		 * the userspace filesystem
		 *
		 * This should be done on write(), truncate() and chown().
		 */
		if (!fc->handle_killpriv && !fc->handle_killpriv_v2) {
			/*
			 * ia_mode calculation may have used stale i_mode.
			 * Refresh and recalculate.
			 */
			ret = fuse_do_getattr(inode, NULL, file);
			if (ret)
				return ret;

			attr->ia_mode = inode->i_mode;
			if (inode->i_mode & S_ISUID) {
				attr->ia_valid |= ATTR_MODE;
				attr->ia_mode &= ~S_ISUID;
			}
			if ((inode->i_mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
				attr->ia_valid |= ATTR_MODE;
				attr->ia_mode &= ~S_ISGID;
			}
		}
	}
	if (!attr->ia_valid)
		return 0;

	ret = fuse_do_setattr(entry, attr, file);
	if (!ret) {
		/*
		 * If filesystem supports acls it may have updated acl xattrs in
		 * the filesystem, so forget cached acls for the inode.
		 */
		if (fc->posix_acl)
			forget_all_cached_acls(inode);

		/* Directory mode changed, may need to revalidate access */
		if (d_is_dir(entry) && (attr->ia_valid & ATTR_MODE))
			fuse_invalidate_entry_cache(entry);
	}
	return ret;
}","static int fuse_setattr(struct dentry *VAR_0, struct iattr *VAR_1)
{
	struct inode *inode = d_inode(VAR_0);
	struct fuse_conn *VAR_2 = get_fuse_conn(inode);
	struct file *file = (VAR_1->ia_valid & VAR_3) ? VAR_1->ia_file : NULL;
	int VAR_4;

	if (fuse_is_bad(inode))
		return -VAR_5;

	if (!fuse_allow_current_process(get_fuse_conn(inode)))
		return -VAR_6;

	if (VAR_1->ia_valid & (VAR_7 | VAR_8)) {
		VAR_1->ia_valid &= ~(VAR_7 | VAR_8 |
				    VAR_9);

		/* COMMENT_0 */
                                                                
                             
    
                                                            
     
		if (!VAR_2->handle_killpriv && !VAR_2->handle_killpriv_v2) {
			/* COMMENT_6 */
                                                     
                              
      
			VAR_4 = fuse_do_getattr(inode, NULL, file);
			if (VAR_4)
				return VAR_4;

			VAR_1->ia_mode = inode->i_mode;
			if (inode->i_mode & VAR_10) {
				VAR_1->ia_valid |= VAR_9;
				VAR_1->ia_mode &= ~VAR_10;
			}
			if ((inode->i_mode & (VAR_11 | VAR_12)) == (VAR_11 | VAR_12)) {
				VAR_1->ia_valid |= VAR_9;
				VAR_1->ia_mode &= ~VAR_11;
			}
		}
	}
	if (!VAR_1->ia_valid)
		return 0;

	VAR_4 = fuse_do_setattr(VAR_0, VAR_1, file);
	if (!VAR_4) {
		/* COMMENT_10 */
                                                                  
                                                         
     
		if (VAR_2->posix_acl)
			forget_all_cached_acls(inode);

		/* COMMENT_14 */
		if (d_is_dir(VAR_0) && (VAR_1->ia_valid & VAR_9))
			fuse_invalidate_entry_cache(VAR_0);
	}
	return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/11.json,"--- func_before
+++ func_after
@@ -4,6 +4,9 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;
 	int ret;
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return -EACCES;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_dentry_revalidate,"static int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)
{
struct inode *inode;
struct dentry *parent;
struct fuse_mount *fm;
struct fuse_inode *fi;
int ret;
inode = d_inode_rcu(entry);
if (inode && is_bad_inode(inode))
goto invalid;
else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
(flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {
struct fuse_entry_out outarg;
FUSE_ARGS(args);
struct fuse_forget_link *forget;
u64 attr_version;
if (!inode)
goto invalid;
ret = -ECHILD;
if (flags & LOOKUP_RCU)
goto out;
fm = get_fuse_mount(inode);
forget = fuse_alloc_forget();
ret = -ENOMEM;
if (!forget)
goto out;
attr_version = fuse_get_attr_version(fm->fc);
parent = dget_parent(entry);
fuse_lookup_init(fm->fc, &args, get_node_id(d_inode(parent)),
&entry->d_name, &outarg);
ret = fuse_simple_request(fm, &args);
dput(parent);
if (!ret && !outarg.nodeid)
ret = -ENOENT;
if (!ret) {
fi = get_fuse_inode(inode);
if (outarg.nodeid != get_node_id(inode) ||
(bool) IS_AUTOMOUNT(inode) != (bool) (outarg.attr.flags & FUSE_ATTR_SUBMOUNT)) {
fuse_queue_forget(fm->fc, forget,
outarg.nodeid, 1);
goto invalid;
}
spin_lock(&fi->lock);
fi->nlookup++;
spin_unlock(&fi->lock);
}
kfree(forget);
if (ret == -ENOMEM)
goto out;
if (ret || fuse_invalid_attr(&outarg.attr) ||
(outarg.attr.mode ^ inode->i_mode) & S_IFMT)
goto invalid;
forget_all_cached_acls(inode);
fuse_change_attributes(inode, &outarg.attr,
entry_attr_timeout(&outarg),
attr_version);
fuse_change_entry_timeout(entry, &outarg);
} else if (inode) {
fi = get_fuse_inode(inode);
if (flags & LOOKUP_RCU) {
if (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))
return -ECHILD;
} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {
parent = dget_parent(entry);
fuse_advise_use_readdirplus(d_inode(parent));
dput(parent);
}
}
ret = 1;
out:
return ret;
invalid:
ret = 0;
goto out;
}","static int fuse_dentry_revalidate(struct dentry *VAR_0, unsigned int VAR_1)
{
struct inode *inode;
struct dentry *VAR_2;
struct fuse_mount *VAR_3;
struct fuse_inode *VAR_4;
int VAR_5;
inode = d_inode_rcu(VAR_0);
if (inode && is_bad_inode(inode))
goto invalid;
else if (time_before64(fuse_dentry_time(VAR_0), get_jiffies_64()) ||
(VAR_1 & (VAR_6 | VAR_7))) {
struct fuse_entry_out VAR_8;
FUSE_ARGS(VAR_9);
struct fuse_forget_link *VAR_10;
u64 VAR_11;
if (!inode)
goto invalid;
VAR_5 = -VAR_12;
if (VAR_1 & VAR_13)
goto out;
VAR_3 = get_fuse_mount(inode);
VAR_10 = fuse_alloc_forget();
VAR_5 = -VAR_14;
if (!VAR_10)
goto out;
VAR_11 = fuse_get_attr_version(VAR_3->fc);
VAR_2 = dget_parent(VAR_0);
fuse_lookup_init(VAR_3->fc, &VAR_9, get_node_id(d_inode(VAR_2)),
&VAR_0->d_name, &VAR_8);
VAR_5 = fuse_simple_request(VAR_3, &VAR_9);
dput(VAR_2);
if (!VAR_5 && !VAR_8.nodeid)
VAR_5 = -VAR_15;
if (!VAR_5) {
VAR_4 = get_fuse_inode(inode);
if (VAR_8.nodeid != get_node_id(inode) ||
(bool) IS_AUTOMOUNT(inode) != (bool) (VAR_8.attr.flags & VAR_16)) {
fuse_queue_forget(VAR_3->fc, VAR_10,
VAR_8.nodeid, 1);
goto invalid;
}
spin_lock(&VAR_4->lock);
VAR_4->nlookup++;
spin_unlock(&VAR_4->lock);
}
kfree(VAR_10);
if (VAR_5 == -VAR_14)
goto out;
if (VAR_5 || fuse_invalid_attr(&VAR_8.attr) ||
(VAR_8.attr.mode ^ inode->i_mode) & VAR_17)
goto invalid;
forget_all_cached_acls(inode);
fuse_change_attributes(inode, &VAR_8.attr,
entry_attr_timeout(&VAR_8),
VAR_11);
fuse_change_entry_timeout(VAR_0, &VAR_8);
} else if (inode) {
VAR_4 = get_fuse_inode(inode);
if (VAR_1 & VAR_13) {
if (test_bit(VAR_18, &VAR_4->state))
return -VAR_12;
} else if (test_and_clear_bit(VAR_18, &VAR_4->state)) {
VAR_2 = dget_parent(VAR_0);
fuse_advise_use_readdirplus(d_inode(VAR_2));
dput(VAR_2);
}
}
VAR_5 = 1;
out:
return VAR_5;
invalid:
VAR_5 = 0;
goto out;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/12.json,"static int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)
{
	struct inode *inode;
	struct dentry *parent;
	struct fuse_mount *fm;
	struct fuse_inode *fi;
	int ret;

	inode = d_inode_rcu(entry);
	if (inode && fuse_is_bad(inode))
		goto invalid;
	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
		 (flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {
		struct fuse_entry_out outarg;
		FUSE_ARGS(args);
		struct fuse_forget_link *forget;
		u64 attr_version;

		/* For negative dentries, always do a fresh lookup */
		if (!inode)
			goto invalid;

		ret = -ECHILD;
		if (flags & LOOKUP_RCU)
			goto out;

		fm = get_fuse_mount(inode);

		forget = fuse_alloc_forget();
		ret = -ENOMEM;
		if (!forget)
			goto out;

		attr_version = fuse_get_attr_version(fm->fc);

		parent = dget_parent(entry);
		fuse_lookup_init(fm->fc, &args, get_node_id(d_inode(parent)),
				 &entry->d_name, &outarg);
		ret = fuse_simple_request(fm, &args);
		dput(parent);
		/* Zero nodeid is same as -ENOENT */
		if (!ret && !outarg.nodeid)
			ret = -ENOENT;
		if (!ret) {
			fi = get_fuse_inode(inode);
			if (outarg.nodeid != get_node_id(inode) ||
			    (bool) IS_AUTOMOUNT(inode) != (bool) (outarg.attr.flags & FUSE_ATTR_SUBMOUNT)) {
				fuse_queue_forget(fm->fc, forget,
						  outarg.nodeid, 1);
				goto invalid;
			}
			spin_lock(&fi->lock);
			fi->nlookup++;
			spin_unlock(&fi->lock);
		}
		kfree(forget);
		if (ret == -ENOMEM)
			goto out;
		if (ret || fuse_invalid_attr(&outarg.attr) ||
		    (outarg.attr.mode ^ inode->i_mode) & S_IFMT)
			goto invalid;

		forget_all_cached_acls(inode);
		fuse_change_attributes(inode, &outarg.attr,
				       entry_attr_timeout(&outarg),
				       attr_version);
		fuse_change_entry_timeout(entry, &outarg);
	} else if (inode) {
		fi = get_fuse_inode(inode);
		if (flags & LOOKUP_RCU) {
			if (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))
				return -ECHILD;
		} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {
			parent = dget_parent(entry);
			fuse_advise_use_readdirplus(d_inode(parent));
			dput(parent);
		}
	}
	ret = 1;
out:
	return ret;

invalid:
	ret = 0;
	goto out;
}","static int fuse_dentry_revalidate(struct dentry *VAR_0, unsigned int VAR_1)
{
	struct inode *inode;
	struct dentry *VAR_2;
	struct fuse_mount *VAR_3;
	struct fuse_inode *VAR_4;
	int VAR_5;

	inode = d_inode_rcu(VAR_0);
	if (inode && fuse_is_bad(inode))
		goto invalid;
	else if (time_before64(fuse_dentry_time(VAR_0), get_jiffies_64()) ||
		 (VAR_1 & (VAR_6 | VAR_7))) {
		struct fuse_entry_out VAR_8;
		FUSE_ARGS(VAR_9);
		struct fuse_forget_link *VAR_10;
		u64 VAR_11;

		/* COMMENT_0 */
		if (!inode)
			goto invalid;

		VAR_5 = -VAR_12;
		if (VAR_1 & VAR_13)
			goto out;

		VAR_3 = get_fuse_mount(inode);

		VAR_10 = fuse_alloc_forget();
		VAR_5 = -VAR_14;
		if (!VAR_10)
			goto out;

		VAR_11 = fuse_get_attr_version(VAR_3->fc);

		VAR_2 = dget_parent(VAR_0);
		fuse_lookup_init(VAR_3->fc, &VAR_9, get_node_id(d_inode(VAR_2)),
				 &VAR_0->d_name, &VAR_8);
		VAR_5 = fuse_simple_request(VAR_3, &VAR_9);
		dput(VAR_2);
		/* COMMENT_1 */
		if (!VAR_5 && !VAR_8.nodeid)
			VAR_5 = -VAR_15;
		if (!VAR_5) {
			VAR_4 = get_fuse_inode(inode);
			if (VAR_8.nodeid != get_node_id(inode) ||
			    (bool) IS_AUTOMOUNT(inode) != (bool) (VAR_8.attr.flags & VAR_16)) {
				fuse_queue_forget(VAR_3->fc, VAR_10,
						  VAR_8.nodeid, 1);
				goto invalid;
			}
			spin_lock(&VAR_4->lock);
			VAR_4->nlookup++;
			spin_unlock(&VAR_4->lock);
		}
		kfree(VAR_10);
		if (VAR_5 == -VAR_14)
			goto out;
		if (VAR_5 || fuse_invalid_attr(&VAR_8.attr) ||
		    (VAR_8.attr.mode ^ inode->i_mode) & VAR_17)
			goto invalid;

		forget_all_cached_acls(inode);
		fuse_change_attributes(inode, &VAR_8.attr,
				       entry_attr_timeout(&VAR_8),
				       VAR_11);
		fuse_change_entry_timeout(VAR_0, &VAR_8);
	} else if (inode) {
		VAR_4 = get_fuse_inode(inode);
		if (VAR_1 & VAR_13) {
			if (test_bit(VAR_18, &VAR_4->state))
				return -VAR_12;
		} else if (test_and_clear_bit(VAR_18, &VAR_4->state)) {
			VAR_2 = dget_parent(VAR_0);
			fuse_advise_use_readdirplus(d_inode(VAR_2));
			dput(VAR_2);
		}
	}
	VAR_5 = 1;
out:
	return VAR_5;

invalid:
	VAR_5 = 0;
	goto out;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/12.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	int ret;
 
 	inode = d_inode_rcu(entry);
-	if (inode && is_bad_inode(inode))
+	if (inode && fuse_is_bad(inode))
 		goto invalid;
 	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
 		 (flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {","{'deleted_lines': ['\tif (inode && is_bad_inode(inode))'], 'added_lines': ['\tif (inode && fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/dir.c,fuse_atomic_open,"static int fuse_atomic_open(struct inode *dir, struct dentry *entry,
struct file *file, unsigned flags,
umode_t mode)
{
int err;
struct fuse_conn *fc = get_fuse_conn(dir);
struct dentry *res = NULL;
if (d_in_lookup(entry)) {
res = fuse_lookup(dir, entry, 0);
if (IS_ERR(res))
return PTR_ERR(res);
if (res)
entry = res;
}
if (!(flags & O_CREAT) || d_really_is_positive(entry))
goto no_open;
file->f_mode |= FMODE_CREATED;
if (fc->no_create)
goto mknod;
err = fuse_create_open(dir, entry, file, flags, mode);
if (err == -ENOSYS) {
fc->no_create = 1;
goto mknod;
}
out_dput:
dput(res);
return err;
mknod:
err = fuse_mknod(dir, entry, mode, 0);
if (err)
goto out_dput;
no_open:
return finish_no_open(file, res);
}","static int fuse_atomic_open(struct inode *VAR_0, struct dentry *VAR_1,
struct file *file, unsigned VAR_2,
umode_t VAR_3)
{
int VAR_4;
struct fuse_conn *VAR_5 = get_fuse_conn(VAR_0);
struct dentry *VAR_6 = NULL;
if (d_in_lookup(VAR_1)) {
VAR_6 = fuse_lookup(VAR_0, VAR_1, 0);
if (IS_ERR(VAR_6))
return PTR_ERR(VAR_6);
if (VAR_6)
VAR_1 = VAR_6;
}
if (!(VAR_2 & VAR_7) || d_really_is_positive(VAR_1))
goto no_open;
file->f_mode |= VAR_8;
if (VAR_5->no_create)
goto mknod;
VAR_4 = fuse_create_open(VAR_0, VAR_1, file, VAR_2, VAR_3);
if (VAR_4 == -VAR_9) {
VAR_5->no_create = 1;
goto mknod;
}
out_dput:
dput(VAR_6);
return VAR_4;
mknod:
VAR_4 = fuse_mknod(VAR_0, VAR_1, VAR_3, 0);
if (VAR_4)
goto out_dput;
no_open:
return finish_no_open(file, VAR_6);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/before/13.json,"static int fuse_atomic_open(struct inode *dir, struct dentry *entry,
			    struct file *file, unsigned flags,
			    umode_t mode)
{
	int err;
	struct fuse_conn *fc = get_fuse_conn(dir);
	struct dentry *res = NULL;

	if (fuse_is_bad(dir))
		return -EIO;

	if (d_in_lookup(entry)) {
		res = fuse_lookup(dir, entry, 0);
		if (IS_ERR(res))
			return PTR_ERR(res);

		if (res)
			entry = res;
	}

	if (!(flags & O_CREAT) || d_really_is_positive(entry))
		goto no_open;

	/* Only creates */
	file->f_mode |= FMODE_CREATED;

	if (fc->no_create)
		goto mknod;

	err = fuse_create_open(dir, entry, file, flags, mode);
	if (err == -ENOSYS) {
		fc->no_create = 1;
		goto mknod;
	}
out_dput:
	dput(res);
	return err;

mknod:
	err = fuse_mknod(dir, entry, mode, 0);
	if (err)
		goto out_dput;
no_open:
	return finish_no_open(file, res);
}","static int fuse_atomic_open(struct inode *VAR_0, struct dentry *VAR_1,
			    struct file *file, unsigned VAR_2,
			    umode_t VAR_3)
{
	int VAR_4;
	struct fuse_conn *VAR_5 = get_fuse_conn(VAR_0);
	struct dentry *VAR_6 = NULL;

	if (fuse_is_bad(VAR_0))
		return -VAR_7;

	if (d_in_lookup(VAR_1)) {
		VAR_6 = fuse_lookup(VAR_0, VAR_1, 0);
		if (IS_ERR(VAR_6))
			return PTR_ERR(VAR_6);

		if (VAR_6)
			VAR_1 = VAR_6;
	}

	if (!(VAR_2 & VAR_8) || d_really_is_positive(VAR_1))
		goto no_open;

	/* COMMENT_0 */
	file->f_mode |= VAR_9;

	if (VAR_5->no_create)
		goto mknod;

	VAR_4 = fuse_create_open(VAR_0, VAR_1, file, VAR_2, VAR_3);
	if (VAR_4 == -VAR_10) {
		VAR_5->no_create = 1;
		goto mknod;
	}
out_dput:
	dput(VAR_6);
	return VAR_4;

mknod:
	VAR_4 = fuse_mknod(VAR_0, VAR_1, VAR_3, 0);
	if (VAR_4)
		goto out_dput;
no_open:
	return finish_no_open(file, VAR_6);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/dir.c/vul/after/13.json,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
 	int err;
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct dentry *res = NULL;
+
+	if (fuse_is_bad(dir))
+		return -EIO;
 
 	if (d_in_lookup(entry)) {
 		res = fuse_lookup(dir, entry, 0);","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(dir))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/inode.c,fuse_evict_inode,"static void fuse_evict_inode(struct inode *inode)
{
struct fuse_inode *fi = get_fuse_inode(inode);
truncate_inode_pages_final(&inode->i_data);
clear_inode(inode);
if (inode->i_sb->s_flags & SB_ACTIVE) {
struct fuse_conn *fc = get_fuse_conn(inode);
if (FUSE_IS_DAX(inode))
fuse_dax_inode_cleanup(inode);
if (fi->nlookup) {
fuse_queue_forget(fc, fi->forget, fi->nodeid,
fi->nlookup);
fi->forget = NULL;
}
}
if (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {
WARN_ON(!list_empty(&fi->write_files));
WARN_ON(!list_empty(&fi->queued_writes));
}
}","static void fuse_evict_inode(struct inode *inode)
{
struct fuse_inode *VAR_0 = get_fuse_inode(inode);
truncate_inode_pages_final(&inode->i_data);
clear_inode(inode);
if (inode->i_sb->s_flags & VAR_1) {
struct fuse_conn *VAR_2 = get_fuse_conn(inode);
if (FUSE_IS_DAX(inode))
fuse_dax_inode_cleanup(inode);
if (VAR_0->nlookup) {
fuse_queue_forget(VAR_2, VAR_0->forget, VAR_0->nodeid,
VAR_0->nlookup);
VAR_0->forget = NULL;
}
}
if (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {
WARN_ON(!list_empty(&VAR_0->write_files));
WARN_ON(!list_empty(&VAR_0->queued_writes));
}
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/inode.c/vul/before/0.json,"static void fuse_evict_inode(struct inode *inode)
{
	struct fuse_inode *fi = get_fuse_inode(inode);

	truncate_inode_pages_final(&inode->i_data);
	clear_inode(inode);
	if (inode->i_sb->s_flags & SB_ACTIVE) {
		struct fuse_conn *fc = get_fuse_conn(inode);

		if (FUSE_IS_DAX(inode))
			fuse_dax_inode_cleanup(inode);
		if (fi->nlookup) {
			fuse_queue_forget(fc, fi->forget, fi->nodeid,
					  fi->nlookup);
			fi->forget = NULL;
		}
	}
	if (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {
		WARN_ON(!list_empty(&fi->write_files));
		WARN_ON(!list_empty(&fi->queued_writes));
	}
}","static void fuse_evict_inode(struct inode *inode)
{
	struct fuse_inode *VAR_0 = get_fuse_inode(inode);

	truncate_inode_pages_final(&inode->i_data);
	clear_inode(inode);
	if (inode->i_sb->s_flags & VAR_1) {
		struct fuse_conn *VAR_2 = get_fuse_conn(inode);

		if (FUSE_IS_DAX(inode))
			fuse_dax_inode_cleanup(inode);
		if (VAR_0->nlookup) {
			fuse_queue_forget(VAR_2, VAR_0->forget, VAR_0->nodeid,
					  VAR_0->nlookup);
			VAR_0->forget = NULL;
		}
	}
	if (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {
		WARN_ON(!list_empty(&VAR_0->write_files));
		WARN_ON(!list_empty(&VAR_0->queued_writes));
	}
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
 			fi->forget = NULL;
 		}
 	}
-	if (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {
+	if (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {
 		WARN_ON(!list_empty(&fi->write_files));
 		WARN_ON(!list_empty(&fi->queued_writes));
 	}","{'deleted_lines': ['\tif (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {'], 'added_lines': ['\tif (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/inode.c,fuse_iget,"struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
int generation, struct fuse_attr *attr,
u64 attr_valid, u64 attr_version)
{
struct inode *inode;
struct fuse_inode *fi;
struct fuse_conn *fc = get_fuse_conn_super(sb);
if (fc->auto_submounts && (attr->flags & FUSE_ATTR_SUBMOUNT) &&
S_ISDIR(attr->mode)) {
inode = new_inode(sb);
if (!inode)
return NULL;
fuse_init_inode(inode, attr);
get_fuse_inode(inode)->nodeid = nodeid;
inode->i_flags |= S_AUTOMOUNT;
goto done;
}
retry:
inode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);
if (!inode)
return NULL;
if ((inode->i_state & I_NEW)) {
inode->i_flags |= S_NOATIME;
if (!fc->writeback_cache || !S_ISREG(attr->mode))
inode->i_flags |= S_NOCMTIME;
inode->i_generation = generation;
fuse_init_inode(inode, attr);
unlock_new_inode(inode);
} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {
make_bad_inode(inode);
iput(inode);
goto retry;
}
done:
fi = get_fuse_inode(inode);
spin_lock(&fi->lock);
fi->nlookup++;
spin_unlock(&fi->lock);
fuse_change_attributes(inode, attr, attr_valid, attr_version);
return inode;
}","struct inode *fuse_iget(struct super_block *VAR_0, u64 VAR_1,
int VAR_2, struct fuse_attr *VAR_3,
u64 VAR_4, u64 VAR_5)
{
struct inode *inode;
struct fuse_inode *VAR_6;
struct fuse_conn *VAR_7 = get_fuse_conn_super(VAR_0);
if (VAR_7->auto_submounts && (VAR_3->flags & VAR_8) &&
S_ISDIR(VAR_3->mode)) {
inode = new_inode(VAR_0);
if (!inode)
return NULL;
fuse_init_inode(inode, VAR_3);
get_fuse_inode(inode)->nodeid = VAR_1;
inode->i_flags |= VAR_9;
goto done;
}
retry:
inode = iget5_locked(VAR_0, VAR_1, VAR_10, VAR_11, &VAR_1);
if (!inode)
return NULL;
if ((inode->i_state & VAR_12)) {
inode->i_flags |= VAR_13;
if (!VAR_7->writeback_cache || !S_ISREG(VAR_3->mode))
inode->i_flags |= VAR_14;
inode->i_generation = VAR_2;
fuse_init_inode(inode, VAR_3);
unlock_new_inode(inode);
} else if ((inode->i_mode ^ VAR_3->mode) & VAR_15) {
make_bad_inode(inode);
iput(inode);
goto retry;
}
done:
VAR_6 = get_fuse_inode(inode);
spin_lock(&VAR_6->lock);
VAR_6->nlookup++;
spin_unlock(&VAR_6->lock);
fuse_change_attributes(inode, VAR_3, VAR_4, VAR_5);
return inode;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/inode.c/vul/before/1.json,"struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
			int generation, struct fuse_attr *attr,
			u64 attr_valid, u64 attr_version)
{
	struct inode *inode;
	struct fuse_inode *fi;
	struct fuse_conn *fc = get_fuse_conn_super(sb);

	/*
	 * Auto mount points get their node id from the submount root, which is
	 * not a unique identifier within this filesystem.
	 *
	 * To avoid conflicts, do not place submount points into the inode hash
	 * table.
	 */
	if (fc->auto_submounts && (attr->flags & FUSE_ATTR_SUBMOUNT) &&
	    S_ISDIR(attr->mode)) {
		inode = new_inode(sb);
		if (!inode)
			return NULL;

		fuse_init_inode(inode, attr);
		get_fuse_inode(inode)->nodeid = nodeid;
		inode->i_flags |= S_AUTOMOUNT;
		goto done;
	}

retry:
	inode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);
	if (!inode)
		return NULL;

	if ((inode->i_state & I_NEW)) {
		inode->i_flags |= S_NOATIME;
		if (!fc->writeback_cache || !S_ISREG(attr->mode))
			inode->i_flags |= S_NOCMTIME;
		inode->i_generation = generation;
		fuse_init_inode(inode, attr);
		unlock_new_inode(inode);
	} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {
		/* Inode has changed type, any I/O on the old should fail */
		fuse_make_bad(inode);
		iput(inode);
		goto retry;
	}
done:
	fi = get_fuse_inode(inode);
	spin_lock(&fi->lock);
	fi->nlookup++;
	spin_unlock(&fi->lock);
	fuse_change_attributes(inode, attr, attr_valid, attr_version);

	return inode;
}","struct inode *fuse_iget(struct super_block *VAR_0, u64 VAR_1,
			int VAR_2, struct fuse_attr *VAR_3,
			u64 VAR_4, u64 VAR_5)
{
	struct inode *inode;
	struct fuse_inode *VAR_6;
	struct fuse_conn *VAR_7 = get_fuse_conn_super(VAR_0);

	/* COMMENT_0 */
                                                                        
                                                   
   
                                                                        
          
    
	if (VAR_7->auto_submounts && (VAR_3->flags & VAR_8) &&
	    S_ISDIR(VAR_3->mode)) {
		inode = new_inode(VAR_0);
		if (!inode)
			return NULL;

		fuse_init_inode(inode, VAR_3);
		get_fuse_inode(inode)->nodeid = VAR_1;
		inode->i_flags |= VAR_9;
		goto done;
	}

retry:
	inode = iget5_locked(VAR_0, VAR_1, VAR_10, VAR_11, &VAR_1);
	if (!inode)
		return NULL;

	if ((inode->i_state & VAR_12)) {
		inode->i_flags |= VAR_13;
		if (!VAR_7->writeback_cache || !S_ISREG(VAR_3->mode))
			inode->i_flags |= VAR_14;
		inode->i_generation = VAR_2;
		fuse_init_inode(inode, VAR_3);
		unlock_new_inode(inode);
	} else if ((inode->i_mode ^ VAR_3->mode) & VAR_15) {
		/* COMMENT_7 */
		fuse_make_bad(inode);
		iput(inode);
		goto retry;
	}
done:
	VAR_6 = get_fuse_inode(inode);
	spin_lock(&VAR_6->lock);
	VAR_6->nlookup++;
	spin_unlock(&VAR_6->lock);
	fuse_change_attributes(inode, VAR_3, VAR_4, VAR_5);

	return inode;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/inode.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -39,7 +39,7 @@
 		unlock_new_inode(inode);
 	} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {
 		/* Inode has changed type, any I/O on the old should fail */
-		make_bad_inode(inode);
+		fuse_make_bad(inode);
 		iput(inode);
 		goto retry;
 	}","{'deleted_lines': ['\t\tmake_bad_inode(inode);'], 'added_lines': ['\t\tfuse_make_bad(inode);']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/acl.c,fuse_set_acl,"int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
struct fuse_conn *fc = get_fuse_conn(inode);
const char *name;
int ret;
if (!fc->posix_acl || fc->no_setxattr)
return -EOPNOTSUPP;
if (type == ACL_TYPE_ACCESS)
name = XATTR_NAME_POSIX_ACL_ACCESS;
else if (type == ACL_TYPE_DEFAULT)
name = XATTR_NAME_POSIX_ACL_DEFAULT;
else
return -EINVAL;
if (acl) {
size_t size = posix_acl_xattr_size(acl->a_count);
void *value;
if (size > PAGE_SIZE)
return -E2BIG;
value = kmalloc(size, GFP_KERNEL);
if (!value)
return -ENOMEM;
ret = posix_acl_to_xattr(fc->user_ns, acl, value, size);
if (ret < 0) {
kfree(value);
return ret;
}
ret = fuse_setxattr(inode, name, value, size, 0);
kfree(value);
} else {
ret = fuse_removexattr(inode, name);
}
forget_all_cached_acls(inode);
fuse_invalidate_attr(inode);
return ret;
}","int fuse_set_acl(struct inode *inode, struct posix_acl *VAR_0, int VAR_1)
{
struct fuse_conn *VAR_2 = get_fuse_conn(inode);
const char *VAR_3;
int VAR_4;
if (!VAR_2->posix_acl || VAR_2->no_setxattr)
return -VAR_5;
if (VAR_1 == VAR_6)
VAR_3 = VAR_7;
else if (VAR_1 == VAR_8)
VAR_3 = VAR_9;
else
return -VAR_10;
if (VAR_0) {
size_t VAR_11 = posix_acl_xattr_size(VAR_0->a_count);
void *VAR_12;
if (VAR_11 > VAR_13)
return -VAR_14;
VAR_12 = kmalloc(VAR_11, VAR_15);
if (!VAR_12)
return -VAR_16;
VAR_4 = posix_acl_to_xattr(VAR_2->user_ns, VAR_0, VAR_12, VAR_11);
if (VAR_4 < 0) {
kfree(VAR_12);
return VAR_4;
}
VAR_4 = fuse_setxattr(inode, VAR_3, VAR_12, VAR_11, 0);
kfree(VAR_12);
} else {
VAR_4 = fuse_removexattr(inode, VAR_3);
}
forget_all_cached_acls(inode);
fuse_invalidate_attr(inode);
return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/acl.c/vul/before/0.json,"int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	struct fuse_conn *fc = get_fuse_conn(inode);
	const char *name;
	int ret;

	if (fuse_is_bad(inode))
		return -EIO;

	if (!fc->posix_acl || fc->no_setxattr)
		return -EOPNOTSUPP;

	if (type == ACL_TYPE_ACCESS)
		name = XATTR_NAME_POSIX_ACL_ACCESS;
	else if (type == ACL_TYPE_DEFAULT)
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
	else
		return -EINVAL;

	if (acl) {
		/*
		 * Fuse userspace is responsible for updating access
		 * permissions in the inode, if needed. fuse_setxattr
		 * invalidates the inode attributes, which will force
		 * them to be refreshed the next time they are used,
		 * and it also updates i_ctime.
		 */
		size_t size = posix_acl_xattr_size(acl->a_count);
		void *value;

		if (size > PAGE_SIZE)
			return -E2BIG;

		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;

		ret = posix_acl_to_xattr(fc->user_ns, acl, value, size);
		if (ret < 0) {
			kfree(value);
			return ret;
		}

		ret = fuse_setxattr(inode, name, value, size, 0);
		kfree(value);
	} else {
		ret = fuse_removexattr(inode, name);
	}
	forget_all_cached_acls(inode);
	fuse_invalidate_attr(inode);

	return ret;
}","int fuse_set_acl(struct inode *inode, struct posix_acl *VAR_0, int VAR_1)
{
	struct fuse_conn *VAR_2 = get_fuse_conn(inode);
	const char *VAR_3;
	int VAR_4;

	if (fuse_is_bad(inode))
		return -VAR_5;

	if (!VAR_2->posix_acl || VAR_2->no_setxattr)
		return -VAR_6;

	if (VAR_1 == VAR_7)
		VAR_3 = VAR_8;
	else if (VAR_1 == VAR_9)
		VAR_3 = VAR_10;
	else
		return -VAR_11;

	if (VAR_0) {
		/* COMMENT_0 */
                                                      
                                                       
                                                       
                                                      
                                 
     
		size_t VAR_12 = posix_acl_xattr_size(VAR_0->a_count);
		void *VAR_13;

		if (VAR_12 > VAR_14)
			return -VAR_15;

		VAR_13 = kmalloc(VAR_12, VAR_16);
		if (!VAR_13)
			return -VAR_17;

		VAR_4 = posix_acl_to_xattr(VAR_2->user_ns, VAR_0, VAR_13, VAR_12);
		if (VAR_4 < 0) {
			kfree(VAR_13);
			return VAR_4;
		}

		VAR_4 = fuse_setxattr(inode, VAR_3, VAR_13, VAR_12, 0);
		kfree(VAR_13);
	} else {
		VAR_4 = fuse_removexattr(inode, VAR_3);
	}
	forget_all_cached_acls(inode);
	fuse_invalidate_attr(inode);

	return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/acl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,9 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	const char *name;
 	int ret;
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	if (!fc->posix_acl || fc->no_setxattr)
 		return -EOPNOTSUPP;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/acl.c,fuse_get_acl,"struct posix_acl *fuse_get_acl(struct inode *inode, int type)
{
struct fuse_conn *fc = get_fuse_conn(inode);
int size;
const char *name;
void *value = NULL;
struct posix_acl *acl;
if (!fc->posix_acl || fc->no_getxattr)
return NULL;
if (type == ACL_TYPE_ACCESS)
name = XATTR_NAME_POSIX_ACL_ACCESS;
else if (type == ACL_TYPE_DEFAULT)
name = XATTR_NAME_POSIX_ACL_DEFAULT;
else
return ERR_PTR(-EOPNOTSUPP);
value = kmalloc(PAGE_SIZE, GFP_KERNEL);
if (!value)
return ERR_PTR(-ENOMEM);
size = fuse_getxattr(inode, name, value, PAGE_SIZE);
if (size > 0)
acl = posix_acl_from_xattr(fc->user_ns, value, size);
else if ((size == 0) || (size == -ENODATA) ||
(size == -EOPNOTSUPP && fc->no_getxattr))
acl = NULL;
else if (size == -ERANGE)
acl = ERR_PTR(-E2BIG);
else
acl = ERR_PTR(size);
kfree(value);
return acl;
}","struct posix_acl *fuse_get_acl(struct inode *inode, int VAR_0)
{
struct fuse_conn *VAR_1 = get_fuse_conn(inode);
int VAR_2;
const char *VAR_3;
void *VAR_4 = NULL;
struct posix_acl *VAR_5;
if (!VAR_1->posix_acl || VAR_1->no_getxattr)
return NULL;
if (VAR_0 == VAR_6)
VAR_3 = VAR_7;
else if (VAR_0 == VAR_8)
VAR_3 = VAR_9;
else
return ERR_PTR(-VAR_10);
VAR_4 = kmalloc(VAR_11, VAR_12);
if (!VAR_4)
return ERR_PTR(-VAR_13);
VAR_2 = fuse_getxattr(inode, VAR_3, VAR_4, VAR_11);
if (VAR_2 > 0)
VAR_5 = posix_acl_from_xattr(VAR_1->user_ns, VAR_4, VAR_2);
else if ((VAR_2 == 0) || (VAR_2 == -VAR_14) ||
(VAR_2 == -VAR_10 && VAR_1->no_getxattr))
VAR_5 = NULL;
else if (VAR_2 == -VAR_15)
VAR_5 = ERR_PTR(-VAR_16);
else
VAR_5 = ERR_PTR(VAR_2);
kfree(VAR_4);
return VAR_5;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/acl.c/vul/before/1.json,"struct posix_acl *fuse_get_acl(struct inode *inode, int type)
{
	struct fuse_conn *fc = get_fuse_conn(inode);
	int size;
	const char *name;
	void *value = NULL;
	struct posix_acl *acl;

	if (fuse_is_bad(inode))
		return ERR_PTR(-EIO);

	if (!fc->posix_acl || fc->no_getxattr)
		return NULL;

	if (type == ACL_TYPE_ACCESS)
		name = XATTR_NAME_POSIX_ACL_ACCESS;
	else if (type == ACL_TYPE_DEFAULT)
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
	else
		return ERR_PTR(-EOPNOTSUPP);

	value = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!value)
		return ERR_PTR(-ENOMEM);
	size = fuse_getxattr(inode, name, value, PAGE_SIZE);
	if (size > 0)
		acl = posix_acl_from_xattr(fc->user_ns, value, size);
	else if ((size == 0) || (size == -ENODATA) ||
		 (size == -EOPNOTSUPP && fc->no_getxattr))
		acl = NULL;
	else if (size == -ERANGE)
		acl = ERR_PTR(-E2BIG);
	else
		acl = ERR_PTR(size);

	kfree(value);
	return acl;
}","struct posix_acl *fuse_get_acl(struct inode *inode, int VAR_0)
{
	struct fuse_conn *VAR_1 = get_fuse_conn(inode);
	int VAR_2;
	const char *VAR_3;
	void *VAR_4 = NULL;
	struct posix_acl *VAR_5;

	if (fuse_is_bad(inode))
		return ERR_PTR(-VAR_6);

	if (!VAR_1->posix_acl || VAR_1->no_getxattr)
		return NULL;

	if (VAR_0 == VAR_7)
		VAR_3 = VAR_8;
	else if (VAR_0 == VAR_9)
		VAR_3 = VAR_10;
	else
		return ERR_PTR(-VAR_11);

	VAR_4 = kmalloc(VAR_12, VAR_13);
	if (!VAR_4)
		return ERR_PTR(-VAR_14);
	VAR_2 = fuse_getxattr(inode, VAR_3, VAR_4, VAR_12);
	if (VAR_2 > 0)
		VAR_5 = posix_acl_from_xattr(VAR_1->user_ns, VAR_4, VAR_2);
	else if ((VAR_2 == 0) || (VAR_2 == -VAR_15) ||
		 (VAR_2 == -VAR_11 && VAR_1->no_getxattr))
		VAR_5 = NULL;
	else if (VAR_2 == -VAR_16)
		VAR_5 = ERR_PTR(-VAR_17);
	else
		VAR_5 = ERR_PTR(VAR_2);

	kfree(VAR_4);
	return VAR_5;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/acl.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
 	const char *name;
 	void *value = NULL;
 	struct posix_acl *acl;
+
+	if (fuse_is_bad(inode))
+		return ERR_PTR(-EIO);
 
 	if (!fc->posix_acl || fc->no_getxattr)
 		return NULL;","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn ERR_PTR(-EIO);']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_fsync,"static int fuse_fsync(struct file *file, loff_t start, loff_t end,
int datasync)
{
struct inode *inode = file->f_mapping->host;
struct fuse_conn *fc = get_fuse_conn(inode);
int err;
if (is_bad_inode(inode))
return -EIO;
inode_lock(inode);
err = file_write_and_wait_range(file, start, end);
if (err)
goto out;
fuse_sync_writes(inode);
err = file_check_and_advance_wb_err(file);
if (err)
goto out;
err = sync_inode_metadata(inode, 1);
if (err)
goto out;
if (fc->no_fsync)
goto out;
err = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNC);
if (err == -ENOSYS) {
fc->no_fsync = 1;
err = 0;
}
out:
inode_unlock(inode);
return err;
}","static int fuse_fsync(struct file *file, loff_t VAR_0, loff_t VAR_1,
int VAR_2)
{
struct inode *inode = file->f_mapping->host;
struct fuse_conn *VAR_3 = get_fuse_conn(inode);
int VAR_4;
if (is_bad_inode(inode))
return -VAR_5;
inode_lock(inode);
VAR_4 = file_write_and_wait_range(file, VAR_0, VAR_1);
if (VAR_4)
goto out;
fuse_sync_writes(inode);
VAR_4 = file_check_and_advance_wb_err(file);
if (VAR_4)
goto out;
VAR_4 = sync_inode_metadata(inode, 1);
if (VAR_4)
goto out;
if (VAR_3->no_fsync)
goto out;
VAR_4 = fuse_fsync_common(file, VAR_0, VAR_1, VAR_2, VAR_6);
if (VAR_4 == -VAR_7) {
VAR_3->no_fsync = 1;
VAR_4 = 0;
}
out:
inode_unlock(inode);
return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/0.json,"static int fuse_fsync(struct file *file, loff_t start, loff_t end,
		      int datasync)
{
	struct inode *inode = file->f_mapping->host;
	struct fuse_conn *fc = get_fuse_conn(inode);
	int err;

	if (fuse_is_bad(inode))
		return -EIO;

	inode_lock(inode);

	/*
	 * Start writeback against all dirty pages of the inode, then
	 * wait for all outstanding writes, before sending the FSYNC
	 * request.
	 */
	err = file_write_and_wait_range(file, start, end);
	if (err)
		goto out;

	fuse_sync_writes(inode);

	/*
	 * Due to implementation of fuse writeback
	 * file_write_and_wait_range() does not catch errors.
	 * We have to do this directly after fuse_sync_writes()
	 */
	err = file_check_and_advance_wb_err(file);
	if (err)
		goto out;

	err = sync_inode_metadata(inode, 1);
	if (err)
		goto out;

	if (fc->no_fsync)
		goto out;

	err = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNC);
	if (err == -ENOSYS) {
		fc->no_fsync = 1;
		err = 0;
	}
out:
	inode_unlock(inode);

	return err;
}","static int fuse_fsync(struct file *file, loff_t VAR_0, loff_t VAR_1,
		      int VAR_2)
{
	struct inode *inode = file->f_mapping->host;
	struct fuse_conn *VAR_3 = get_fuse_conn(inode);
	int VAR_4;

	if (fuse_is_bad(inode))
		return -VAR_5;

	inode_lock(inode);

	/* COMMENT_0 */
                                                              
                                                             
            
    
	VAR_4 = file_write_and_wait_range(file, VAR_0, VAR_1);
	if (VAR_4)
		goto out;

	fuse_sync_writes(inode);

	/* COMMENT_5 */
                                           
                                                      
                                                        
    
	VAR_4 = file_check_and_advance_wb_err(file);
	if (VAR_4)
		goto out;

	VAR_4 = sync_inode_metadata(inode, 1);
	if (VAR_4)
		goto out;

	if (VAR_3->no_fsync)
		goto out;

	VAR_4 = fuse_fsync_common(file, VAR_0, VAR_1, VAR_2, VAR_6);
	if (VAR_4 == -VAR_7) {
		VAR_3->no_fsync = 1;
		VAR_4 = 0;
	}
out:
	inode_unlock(inode);

	return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	inode_lock(inode);","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_flush,"static int fuse_flush(struct file *file, fl_owner_t id)
{
struct inode *inode = file_inode(file);
struct fuse_mount *fm = get_fuse_mount(inode);
struct fuse_file *ff = file->private_data;
struct fuse_flush_in inarg;
FUSE_ARGS(args);
int err;
if (is_bad_inode(inode))
return -EIO;
err = write_inode_now(inode, 1);
if (err)
return err;
inode_lock(inode);
fuse_sync_writes(inode);
inode_unlock(inode);
err = filemap_check_errors(file->f_mapping);
if (err)
return err;
err = 0;
if (fm->fc->no_flush)
goto inval_attr_out;
memset(&inarg, 0, sizeof(inarg));
inarg.fh = ff->fh;
inarg.lock_owner = fuse_lock_owner_id(fm->fc, id);
args.opcode = FUSE_FLUSH;
args.nodeid = get_node_id(inode);
args.in_numargs = 1;
args.in_args[0].size = sizeof(inarg);
args.in_args[0].value = &inarg;
args.force = true;
err = fuse_simple_request(fm, &args);
if (err == -ENOSYS) {
fm->fc->no_flush = 1;
err = 0;
}
inval_attr_out:
if (!err && fm->fc->writeback_cache)
fuse_invalidate_attr(inode);
return err;
}","static int fuse_flush(struct file *file, fl_owner_t VAR_0)
{
struct inode *inode = file_inode(file);
struct fuse_mount *VAR_1 = get_fuse_mount(inode);
struct fuse_file *VAR_2 = file->private_data;
struct fuse_flush_in VAR_3;
FUSE_ARGS(VAR_4);
int VAR_5;
if (is_bad_inode(inode))
return -VAR_6;
VAR_5 = write_inode_now(inode, 1);
if (VAR_5)
return VAR_5;
inode_lock(inode);
fuse_sync_writes(inode);
inode_unlock(inode);
VAR_5 = filemap_check_errors(file->f_mapping);
if (VAR_5)
return VAR_5;
VAR_5 = 0;
if (VAR_1->fc->no_flush)
goto inval_attr_out;
memset(&VAR_3, 0, sizeof(VAR_3));
VAR_3.fh = VAR_2->fh;
VAR_3.lock_owner = fuse_lock_owner_id(VAR_1->fc, VAR_0);
VAR_4.opcode = VAR_7;
VAR_4.nodeid = get_node_id(inode);
VAR_4.in_numargs = 1;
VAR_4.in_args[0].size = sizeof(VAR_3);
VAR_4.in_args[0].value = &VAR_3;
VAR_4.force = true;
VAR_5 = fuse_simple_request(VAR_1, &VAR_4);
if (VAR_5 == -VAR_8) {
VAR_1->fc->no_flush = 1;
VAR_5 = 0;
}
inval_attr_out:
if (!VAR_5 && VAR_1->fc->writeback_cache)
fuse_invalidate_attr(inode);
return VAR_5;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/1.json,"static int fuse_flush(struct file *file, fl_owner_t id)
{
	struct inode *inode = file_inode(file);
	struct fuse_mount *fm = get_fuse_mount(inode);
	struct fuse_file *ff = file->private_data;
	struct fuse_flush_in inarg;
	FUSE_ARGS(args);
	int err;

	if (fuse_is_bad(inode))
		return -EIO;

	err = write_inode_now(inode, 1);
	if (err)
		return err;

	inode_lock(inode);
	fuse_sync_writes(inode);
	inode_unlock(inode);

	err = filemap_check_errors(file->f_mapping);
	if (err)
		return err;

	err = 0;
	if (fm->fc->no_flush)
		goto inval_attr_out;

	memset(&inarg, 0, sizeof(inarg));
	inarg.fh = ff->fh;
	inarg.lock_owner = fuse_lock_owner_id(fm->fc, id);
	args.opcode = FUSE_FLUSH;
	args.nodeid = get_node_id(inode);
	args.in_numargs = 1;
	args.in_args[0].size = sizeof(inarg);
	args.in_args[0].value = &inarg;
	args.force = true;

	err = fuse_simple_request(fm, &args);
	if (err == -ENOSYS) {
		fm->fc->no_flush = 1;
		err = 0;
	}

inval_attr_out:
	/*
	 * In memory i_blocks is not maintained by fuse, if writeback cache is
	 * enabled, i_blocks from cached attr may not be accurate.
	 */
	if (!err && fm->fc->writeback_cache)
		fuse_invalidate_attr(inode);
	return err;
}","static int fuse_flush(struct file *file, fl_owner_t VAR_0)
{
	struct inode *inode = file_inode(file);
	struct fuse_mount *VAR_1 = get_fuse_mount(inode);
	struct fuse_file *VAR_2 = file->private_data;
	struct fuse_flush_in VAR_3;
	FUSE_ARGS(VAR_4);
	int VAR_5;

	if (fuse_is_bad(inode))
		return -VAR_6;

	VAR_5 = write_inode_now(inode, 1);
	if (VAR_5)
		return VAR_5;

	inode_lock(inode);
	fuse_sync_writes(inode);
	inode_unlock(inode);

	VAR_5 = filemap_check_errors(file->f_mapping);
	if (VAR_5)
		return VAR_5;

	VAR_5 = 0;
	if (VAR_1->fc->no_flush)
		goto inval_attr_out;

	memset(&VAR_3, 0, sizeof(VAR_3));
	VAR_3.fh = VAR_2->fh;
	VAR_3.lock_owner = fuse_lock_owner_id(VAR_1->fc, VAR_0);
	VAR_4.opcode = VAR_7;
	VAR_4.nodeid = get_node_id(inode);
	VAR_4.in_numargs = 1;
	VAR_4.in_args[0].size = sizeof(VAR_3);
	VAR_4.in_args[0].value = &VAR_3;
	VAR_4.force = true;

	VAR_5 = fuse_simple_request(VAR_1, &VAR_4);
	if (VAR_5 == -VAR_8) {
		VAR_1->fc->no_flush = 1;
		VAR_5 = 0;
	}

inval_attr_out:
	/* COMMENT_0 */
                                                                       
                                                           
    
	if (!VAR_5 && VAR_1->fc->writeback_cache)
		fuse_invalidate_attr(inode);
	return VAR_5;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	FUSE_ARGS(args);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	err = write_inode_now(inode, 1);","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_readahead,"static void fuse_readahead(struct readahead_control *rac)
{
struct inode *inode = rac->mapping->host;
struct fuse_conn *fc = get_fuse_conn(inode);
unsigned int i, max_pages, nr_pages = 0;
if (is_bad_inode(inode))
return;
max_pages = min_t(unsigned int, fc->max_pages,
fc->max_read / PAGE_SIZE);
for (;;) {
struct fuse_io_args *ia;
struct fuse_args_pages *ap;
nr_pages = readahead_count(rac) - nr_pages;
if (nr_pages > max_pages)
nr_pages = max_pages;
if (nr_pages == 0)
break;
ia = fuse_io_alloc(NULL, nr_pages);
if (!ia)
return;
ap = &ia->ap;
nr_pages = __readahead_batch(rac, ap->pages, nr_pages);
for (i = 0; i < nr_pages; i++) {
fuse_wait_on_page_writeback(inode,
readahead_index(rac) + i);
ap->descs[i].length = PAGE_SIZE;
}
ap->num_pages = nr_pages;
fuse_send_readpages(ia, rac->file);
}
}","static void fuse_readahead(struct readahead_control *VAR_0)
{
struct inode *inode = VAR_0->mapping->host;
struct fuse_conn *VAR_1 = get_fuse_conn(inode);
unsigned int VAR_2, VAR_3, VAR_4 = 0;
if (is_bad_inode(inode))
return;
VAR_3 = min_t(unsigned VAR_5, VAR_1->max_pages,
VAR_1->max_read / VAR_6);
for (;;) {
struct fuse_io_args *VAR_7;
struct fuse_args_pages *VAR_8;
VAR_4 = readahead_count(VAR_0) - VAR_4;
if (VAR_4 > VAR_3)
VAR_4 = VAR_3;
if (VAR_4 == 0)
break;
VAR_7 = fuse_io_alloc(NULL, VAR_4);
if (!VAR_7)
return;
VAR_8 = &VAR_7->ap;
VAR_4 = __readahead_batch(VAR_0, VAR_8->pages, VAR_4);
for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
fuse_wait_on_page_writeback(inode,
readahead_index(VAR_0) + VAR_2);
VAR_8->descs[VAR_2].length = VAR_6;
}
VAR_8->num_pages = VAR_4;
fuse_send_readpages(VAR_7, VAR_0->file);
}
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/2.json,"static void fuse_readahead(struct readahead_control *rac)
{
	struct inode *inode = rac->mapping->host;
	struct fuse_conn *fc = get_fuse_conn(inode);
	unsigned int i, max_pages, nr_pages = 0;

	if (fuse_is_bad(inode))
		return;

	max_pages = min_t(unsigned int, fc->max_pages,
			fc->max_read / PAGE_SIZE);

	for (;;) {
		struct fuse_io_args *ia;
		struct fuse_args_pages *ap;

		nr_pages = readahead_count(rac) - nr_pages;
		if (nr_pages > max_pages)
			nr_pages = max_pages;
		if (nr_pages == 0)
			break;
		ia = fuse_io_alloc(NULL, nr_pages);
		if (!ia)
			return;
		ap = &ia->ap;
		nr_pages = __readahead_batch(rac, ap->pages, nr_pages);
		for (i = 0; i < nr_pages; i++) {
			fuse_wait_on_page_writeback(inode,
						    readahead_index(rac) + i);
			ap->descs[i].length = PAGE_SIZE;
		}
		ap->num_pages = nr_pages;
		fuse_send_readpages(ia, rac->file);
	}
}","static void fuse_readahead(struct readahead_control *VAR_0)
{
	struct inode *inode = VAR_0->mapping->host;
	struct fuse_conn *VAR_1 = get_fuse_conn(inode);
	unsigned int VAR_2, VAR_3, VAR_4 = 0;

	if (fuse_is_bad(inode))
		return;

	VAR_3 = min_t(unsigned VAR_5, VAR_1->max_pages,
			VAR_1->max_read / VAR_6);

	for (;;) {
		struct fuse_io_args *VAR_7;
		struct fuse_args_pages *VAR_8;

		VAR_4 = readahead_count(VAR_0) - VAR_4;
		if (VAR_4 > VAR_3)
			VAR_4 = VAR_3;
		if (VAR_4 == 0)
			break;
		VAR_7 = fuse_io_alloc(NULL, VAR_4);
		if (!VAR_7)
			return;
		VAR_8 = &VAR_7->ap;
		VAR_4 = __readahead_batch(VAR_0, VAR_8->pages, VAR_4);
		for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
			fuse_wait_on_page_writeback(inode,
						    readahead_index(VAR_0) + VAR_2);
			VAR_8->descs[VAR_2].length = VAR_6;
		}
		VAR_8->num_pages = VAR_4;
		fuse_send_readpages(VAR_7, VAR_0->file);
	}
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	unsigned int i, max_pages, nr_pages = 0;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return;
 
 	max_pages = min_t(unsigned int, fc->max_pages,","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_writepages,"static int fuse_writepages(struct address_space *mapping,
struct writeback_control *wbc)
{
struct inode *inode = mapping->host;
struct fuse_conn *fc = get_fuse_conn(inode);
struct fuse_fill_wb_data data;
int err;
err = -EIO;
if (is_bad_inode(inode))
goto out;
data.inode = inode;
data.wpa = NULL;
data.ff = NULL;
err = -ENOMEM;
data.orig_pages = kcalloc(fc->max_pages,
sizeof(struct page *),
GFP_NOFS);
if (!data.orig_pages)
goto out;
err = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);
if (data.wpa) {
WARN_ON(!data.wpa->ia.ap.num_pages);
fuse_writepages_send(&data);
}
if (data.ff)
fuse_file_put(data.ff, false, false);
kfree(data.orig_pages);
out:
return err;
}","static int fuse_writepages(struct address_space *VAR_0,
struct writeback_control *VAR_1)
{
struct inode *inode = VAR_0->host;
struct fuse_conn *VAR_2 = get_fuse_conn(inode);
struct fuse_fill_wb_data VAR_3;
int VAR_4;
VAR_4 = -VAR_5;
if (is_bad_inode(inode))
goto out;
VAR_3.inode = inode;
VAR_3.wpa = NULL;
VAR_3.ff = NULL;
VAR_4 = -VAR_6;
VAR_3.orig_pages = kcalloc(VAR_2->max_pages,
sizeof(struct page *),
VAR_7);
if (!VAR_3.orig_pages)
goto out;
VAR_4 = write_cache_pages(VAR_0, VAR_1, VAR_8, &VAR_3);
if (VAR_3.wpa) {
WARN_ON(!VAR_3.wpa->ia.ap.num_pages);
fuse_writepages_send(&VAR_3);
}
if (VAR_3.ff)
fuse_file_put(VAR_3.ff, false, false);
kfree(VAR_3.orig_pages);
out:
return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/3.json,"static int fuse_writepages(struct address_space *mapping,
			   struct writeback_control *wbc)
{
	struct inode *inode = mapping->host;
	struct fuse_conn *fc = get_fuse_conn(inode);
	struct fuse_fill_wb_data data;
	int err;

	err = -EIO;
	if (fuse_is_bad(inode))
		goto out;

	data.inode = inode;
	data.wpa = NULL;
	data.ff = NULL;

	err = -ENOMEM;
	data.orig_pages = kcalloc(fc->max_pages,
				  sizeof(struct page *),
				  GFP_NOFS);
	if (!data.orig_pages)
		goto out;

	err = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);
	if (data.wpa) {
		WARN_ON(!data.wpa->ia.ap.num_pages);
		fuse_writepages_send(&data);
	}
	if (data.ff)
		fuse_file_put(data.ff, false, false);

	kfree(data.orig_pages);
out:
	return err;
}","static int fuse_writepages(struct address_space *VAR_0,
			   struct writeback_control *VAR_1)
{
	struct inode *inode = VAR_0->host;
	struct fuse_conn *VAR_2 = get_fuse_conn(inode);
	struct fuse_fill_wb_data VAR_3;
	int VAR_4;

	VAR_4 = -VAR_5;
	if (fuse_is_bad(inode))
		goto out;

	VAR_3.inode = inode;
	VAR_3.wpa = NULL;
	VAR_3.ff = NULL;

	VAR_4 = -VAR_6;
	VAR_3.orig_pages = kcalloc(VAR_2->max_pages,
				  sizeof(struct page *),
				  VAR_7);
	if (!VAR_3.orig_pages)
		goto out;

	VAR_4 = write_cache_pages(VAR_0, VAR_1, VAR_8, &VAR_3);
	if (VAR_3.wpa) {
		WARN_ON(!VAR_3.wpa->ia.ap.num_pages);
		fuse_writepages_send(&VAR_3);
	}
	if (VAR_3.ff)
		fuse_file_put(VAR_3.ff, false, false);

	kfree(VAR_3.orig_pages);
out:
	return VAR_4;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	int err;
 
 	err = -EIO;
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		goto out;
 
 	data.inode = inode;","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_open_common,"int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
{
struct fuse_mount *fm = get_fuse_mount(inode);
struct fuse_conn *fc = fm->fc;
int err;
bool is_wb_truncate = (file->f_flags & O_TRUNC) &&
fc->atomic_o_trunc &&
fc->writeback_cache;
bool dax_truncate = (file->f_flags & O_TRUNC) &&
fc->atomic_o_trunc && FUSE_IS_DAX(inode);
err = generic_file_open(inode, file);
if (err)
return err;
if (is_wb_truncate || dax_truncate) {
inode_lock(inode);
fuse_set_nowrite(inode);
}
if (dax_truncate) {
down_write(&get_fuse_inode(inode)->i_mmap_sem);
err = fuse_dax_break_layouts(inode, 0, 0);
if (err)
goto out;
}
err = fuse_do_open(fm, get_node_id(inode), file, isdir);
if (!err)
fuse_finish_open(inode, file);
out:
if (dax_truncate)
up_write(&get_fuse_inode(inode)->i_mmap_sem);
if (is_wb_truncate | dax_truncate) {
fuse_release_nowrite(inode);
inode_unlock(inode);
}
return err;
}","int fuse_open_common(struct inode *inode, struct file *file, bool VAR_0)
{
struct fuse_mount *VAR_1 = get_fuse_mount(inode);
struct fuse_conn *VAR_2 = VAR_1->fc;
int VAR_3;
bool VAR_4 = (file->f_flags & VAR_5) &&
VAR_2->atomic_o_trunc &&
VAR_2->writeback_cache;
bool VAR_6 = (file->f_flags & VAR_5) &&
VAR_2->atomic_o_trunc && FUSE_IS_DAX(inode);
VAR_3 = generic_file_open(inode, file);
if (VAR_3)
return VAR_3;
if (VAR_4 || VAR_6) {
inode_lock(inode);
fuse_set_nowrite(inode);
}
if (VAR_6) {
down_write(&get_fuse_inode(inode)->i_mmap_sem);
VAR_3 = fuse_dax_break_layouts(inode, 0, 0);
if (VAR_3)
goto out;
}
VAR_3 = fuse_do_open(VAR_1, get_node_id(inode), file, VAR_0);
if (!VAR_3)
fuse_finish_open(inode, file);
out:
if (VAR_6)
up_write(&get_fuse_inode(inode)->i_mmap_sem);
if (VAR_4 | VAR_6) {
fuse_release_nowrite(inode);
inode_unlock(inode);
}
return VAR_3;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/4.json,"int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
{
	struct fuse_mount *fm = get_fuse_mount(inode);
	struct fuse_conn *fc = fm->fc;
	int err;
	bool is_wb_truncate = (file->f_flags & O_TRUNC) &&
			  fc->atomic_o_trunc &&
			  fc->writeback_cache;
	bool dax_truncate = (file->f_flags & O_TRUNC) &&
			  fc->atomic_o_trunc && FUSE_IS_DAX(inode);

	if (fuse_is_bad(inode))
		return -EIO;

	err = generic_file_open(inode, file);
	if (err)
		return err;

	if (is_wb_truncate || dax_truncate) {
		inode_lock(inode);
		fuse_set_nowrite(inode);
	}

	if (dax_truncate) {
		down_write(&get_fuse_inode(inode)->i_mmap_sem);
		err = fuse_dax_break_layouts(inode, 0, 0);
		if (err)
			goto out;
	}

	err = fuse_do_open(fm, get_node_id(inode), file, isdir);
	if (!err)
		fuse_finish_open(inode, file);

out:
	if (dax_truncate)
		up_write(&get_fuse_inode(inode)->i_mmap_sem);

	if (is_wb_truncate | dax_truncate) {
		fuse_release_nowrite(inode);
		inode_unlock(inode);
	}

	return err;
}","int fuse_open_common(struct inode *inode, struct file *file, bool VAR_0)
{
	struct fuse_mount *VAR_1 = get_fuse_mount(inode);
	struct fuse_conn *VAR_2 = VAR_1->fc;
	int VAR_3;
	bool VAR_4 = (file->f_flags & VAR_5) &&
			  VAR_2->atomic_o_trunc &&
			  VAR_2->writeback_cache;
	bool VAR_6 = (file->f_flags & VAR_5) &&
			  VAR_2->atomic_o_trunc && FUSE_IS_DAX(inode);

	if (fuse_is_bad(inode))
		return -VAR_7;

	VAR_3 = generic_file_open(inode, file);
	if (VAR_3)
		return VAR_3;

	if (VAR_4 || VAR_6) {
		inode_lock(inode);
		fuse_set_nowrite(inode);
	}

	if (VAR_6) {
		down_write(&get_fuse_inode(inode)->i_mmap_sem);
		VAR_3 = fuse_dax_break_layouts(inode, 0, 0);
		if (VAR_3)
			goto out;
	}

	VAR_3 = fuse_do_open(VAR_1, get_node_id(inode), file, VAR_0);
	if (!VAR_3)
		fuse_finish_open(inode, file);

out:
	if (VAR_6)
		up_write(&get_fuse_inode(inode)->i_mmap_sem);

	if (VAR_4 | VAR_6) {
		fuse_release_nowrite(inode);
		inode_unlock(inode);
	}

	return VAR_3;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 			  fc->writeback_cache;
 	bool dax_truncate = (file->f_flags & O_TRUNC) &&
 			  fc->atomic_o_trunc && FUSE_IS_DAX(inode);
+
+	if (fuse_is_bad(inode))
+		return -EIO;
 
 	err = generic_file_open(inode, file);
 	if (err)","{'deleted_lines': [], 'added_lines': ['', '\tif (fuse_is_bad(inode))', '\t\treturn -EIO;']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_file_read_iter,"static ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
struct file *file = iocb->ki_filp;
struct fuse_file *ff = file->private_data;
struct inode *inode = file_inode(file);
if (is_bad_inode(inode))
return -EIO;
if (FUSE_IS_DAX(inode))
return fuse_dax_read_iter(iocb, to);
if (!(ff->open_flags & FOPEN_DIRECT_IO))
return fuse_cache_read_iter(iocb, to);
else
return fuse_direct_read_iter(iocb, to);
}","static ssize_t fuse_file_read_iter(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
struct file *file = VAR_0->ki_filp;
struct fuse_file *VAR_2 = file->private_data;
struct inode *inode = file_inode(file);
if (is_bad_inode(inode))
return -VAR_3;
if (FUSE_IS_DAX(inode))
return fuse_dax_read_iter(VAR_0, VAR_1);
if (!(VAR_2->open_flags & VAR_4))
return fuse_cache_read_iter(VAR_0, VAR_1);
else
return fuse_direct_read_iter(VAR_0, VAR_1);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/5.json,"static ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct fuse_file *ff = file->private_data;
	struct inode *inode = file_inode(file);

	if (fuse_is_bad(inode))
		return -EIO;

	if (FUSE_IS_DAX(inode))
		return fuse_dax_read_iter(iocb, to);

	if (!(ff->open_flags & FOPEN_DIRECT_IO))
		return fuse_cache_read_iter(iocb, to);
	else
		return fuse_direct_read_iter(iocb, to);
}","static ssize_t fuse_file_read_iter(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
	struct file *file = VAR_0->ki_filp;
	struct fuse_file *VAR_2 = file->private_data;
	struct inode *inode = file_inode(file);

	if (fuse_is_bad(inode))
		return -VAR_3;

	if (FUSE_IS_DAX(inode))
		return fuse_dax_read_iter(VAR_0, VAR_1);

	if (!(VAR_2->open_flags & VAR_4))
		return fuse_cache_read_iter(VAR_0, VAR_1);
	else
		return fuse_direct_read_iter(VAR_0, VAR_1);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	struct fuse_file *ff = file->private_data;
 	struct inode *inode = file_inode(file);
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	if (FUSE_IS_DAX(inode))","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_readpage,"static int fuse_readpage(struct file *file, struct page *page)
{
struct inode *inode = page->mapping->host;
int err;
err = -EIO;
if (is_bad_inode(inode))
goto out;
err = fuse_do_readpage(file, page);
fuse_invalidate_atime(inode);
out:
unlock_page(page);
return err;
}","static int fuse_readpage(struct file *file, struct page *page)
{
struct inode *inode = page->mapping->host;
int VAR_0;
VAR_0 = -VAR_1;
if (is_bad_inode(inode))
goto out;
VAR_0 = fuse_do_readpage(file, page);
fuse_invalidate_atime(inode);
out:
unlock_page(page);
return VAR_0;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/6.json,"static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;

	err = -EIO;
	if (fuse_is_bad(inode))
		goto out;

	err = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}","static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int VAR_0;

	VAR_0 = -VAR_1;
	if (fuse_is_bad(inode))
		goto out;

	VAR_0 = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return VAR_0;
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	int err;
 
 	err = -EIO;
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		goto out;
 
 	err = fuse_do_readpage(file, page);","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_file_write_iter,"static ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
struct file *file = iocb->ki_filp;
struct fuse_file *ff = file->private_data;
struct inode *inode = file_inode(file);
if (is_bad_inode(inode))
return -EIO;
if (FUSE_IS_DAX(inode))
return fuse_dax_write_iter(iocb, from);
if (!(ff->open_flags & FOPEN_DIRECT_IO))
return fuse_cache_write_iter(iocb, from);
else
return fuse_direct_write_iter(iocb, from);
}","static ssize_t fuse_file_write_iter(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
struct file *file = VAR_0->ki_filp;
struct fuse_file *VAR_2 = file->private_data;
struct inode *inode = file_inode(file);
if (is_bad_inode(inode))
return -VAR_3;
if (FUSE_IS_DAX(inode))
return fuse_dax_write_iter(VAR_0, VAR_1);
if (!(VAR_2->open_flags & VAR_4))
return fuse_cache_write_iter(VAR_0, VAR_1);
else
return fuse_direct_write_iter(VAR_0, VAR_1);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/7.json,"static ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct fuse_file *ff = file->private_data;
	struct inode *inode = file_inode(file);

	if (fuse_is_bad(inode))
		return -EIO;

	if (FUSE_IS_DAX(inode))
		return fuse_dax_write_iter(iocb, from);

	if (!(ff->open_flags & FOPEN_DIRECT_IO))
		return fuse_cache_write_iter(iocb, from);
	else
		return fuse_direct_write_iter(iocb, from);
}","static ssize_t fuse_file_write_iter(struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
	struct file *file = VAR_0->ki_filp;
	struct fuse_file *VAR_2 = file->private_data;
	struct inode *inode = file_inode(file);

	if (fuse_is_bad(inode))
		return -VAR_3;

	if (FUSE_IS_DAX(inode))
		return fuse_dax_write_iter(VAR_0, VAR_1);

	if (!(VAR_2->open_flags & VAR_4))
		return fuse_cache_write_iter(VAR_0, VAR_1);
	else
		return fuse_direct_write_iter(VAR_0, VAR_1);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	struct fuse_file *ff = file->private_data;
 	struct inode *inode = file_inode(file);
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	if (FUSE_IS_DAX(inode))","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2020-36322,['CWE-459'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>
",5d069dbe8aaf2a197142558b6fb2978189ba3454,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5d069dbe8aaf2a197142558b6fb2978189ba3454,fs/fuse/file.c,fuse_ioctl_common,"long fuse_ioctl_common(struct file *file, unsigned int cmd,
unsigned long arg, unsigned int flags)
{
struct inode *inode = file_inode(file);
struct fuse_conn *fc = get_fuse_conn(inode);
if (!fuse_allow_current_process(fc))
return -EACCES;
if (is_bad_inode(inode))
return -EIO;
return fuse_do_ioctl(file, cmd, arg, flags);
}","long fuse_ioctl_common(struct file *file, unsigned int VAR_0,
unsigned long VAR_1, unsigned int VAR_2)
{
struct inode *inode = file_inode(file);
struct fuse_conn *VAR_3 = get_fuse_conn(inode);
if (!fuse_allow_current_process(VAR_3))
return -VAR_4;
if (is_bad_inode(inode))
return -VAR_5;
return fuse_do_ioctl(file, VAR_0, VAR_1, VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/before/8.json,"long fuse_ioctl_common(struct file *file, unsigned int cmd,
		       unsigned long arg, unsigned int flags)
{
	struct inode *inode = file_inode(file);
	struct fuse_conn *fc = get_fuse_conn(inode);

	if (!fuse_allow_current_process(fc))
		return -EACCES;

	if (fuse_is_bad(inode))
		return -EIO;

	return fuse_do_ioctl(file, cmd, arg, flags);
}","long fuse_ioctl_common(struct file *file, unsigned int VAR_0,
		       unsigned long VAR_1, unsigned int VAR_2)
{
	struct inode *inode = file_inode(file);
	struct fuse_conn *VAR_3 = get_fuse_conn(inode);

	if (!fuse_allow_current_process(VAR_3))
		return -VAR_4;

	if (fuse_is_bad(inode))
		return -VAR_5;

	return fuse_do_ioctl(file, VAR_0, VAR_1, VAR_2);
}",torvalds/linux/5d069dbe8aaf2a197142558b6fb2978189ba3454/file.c/vul/after/8.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	if (!fuse_allow_current_process(fc))
 		return -EACCES;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	return fuse_do_ioctl(file, cmd, arg, flags);","{'deleted_lines': ['\tif (is_bad_inode(inode))'], 'added_lines': ['\tif (fuse_is_bad(inode))']}",True,"An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.",5.5,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,hyp_get_page_state,"static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte)
{
if (!kvm_pte_valid(pte))
return PKVM_NOPAGE;
return pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte));
}","static enum pkvm_page_state hyp_get_page_state(kvm_pte_t VAR_0)
{
if (!kvm_pte_valid(VAR_0))
return VAR_1;
return pkvm_getstate(kvm_pgtable_hyp_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/0.json,"static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte, u64 addr)
{
	if (!kvm_pte_valid(pte))
		return PKVM_NOPAGE;

	return pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte));
}","static enum pkvm_page_state hyp_get_page_state(kvm_pte_t VAR_0, u64 VAR_1)
{
	if (!kvm_pte_valid(VAR_0))
		return VAR_2;

	return pkvm_getstate(kvm_pgtable_hyp_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte)
+static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte, u64 addr)
 {
 	if (!kvm_pte_valid(pte))
 		return PKVM_NOPAGE;","{'deleted_lines': ['static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte)'], 'added_lines': ['static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte, u64 addr)']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,__check_page_state_visitor,"static int __check_page_state_visitor(u64 addr, u64 end, u32 level,
kvm_pte_t *ptep,
enum kvm_pgtable_walk_flags flag,
void * const arg)
{
struct check_walk_data *d = arg;
kvm_pte_t pte = *ptep;
if (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))
return -EINVAL;
return d->get_page_state(pte) == d->desired ? 0 : -EPERM;
}","static int __check_page_state_visitor(u64 VAR_0, u64 VAR_1, u32 VAR_2,
kvm_pte_t *VAR_3,
enum kvm_pgtable_walk_flags VAR_4,
void * const VAR_5)
{
struct check_walk_data *VAR_6 = VAR_5;
kvm_pte_t VAR_7 = *VAR_3;
if (kvm_pte_valid(VAR_7) && !addr_is_allowed_memory(kvm_pte_to_phys(VAR_7)))
return -VAR_8;
return VAR_6->get_page_state(VAR_7) == VAR_6->desired ? 0 : -VAR_9;
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/1.json,"static int __check_page_state_visitor(u64 addr, u64 end, u32 level,
				      kvm_pte_t *ptep,
				      enum kvm_pgtable_walk_flags flag,
				      void * const arg)
{
	struct check_walk_data *d = arg;
	kvm_pte_t pte = *ptep;

	if (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))
		return -EINVAL;

	return d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;
}","static int __check_page_state_visitor(u64 VAR_0, u64 VAR_1, u32 VAR_2,
				      kvm_pte_t *VAR_3,
				      enum kvm_pgtable_walk_flags VAR_4,
				      void * const VAR_5)
{
	struct check_walk_data *VAR_6 = VAR_5;
	kvm_pte_t VAR_7 = *VAR_3;

	if (kvm_pte_valid(VAR_7) && !addr_is_allowed_memory(kvm_pte_to_phys(VAR_7)))
		return -VAR_8;

	return VAR_6->get_page_state(VAR_7, VAR_0) == VAR_6->desired ? 0 : -VAR_9;
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,5 +9,5 @@
 	if (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))
 		return -EINVAL;
 
-	return d->get_page_state(pte) == d->desired ? 0 : -EPERM;
+	return d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;
 }","{'deleted_lines': ['\treturn d->get_page_state(pte) == d->desired ? 0 : -EPERM;'], 'added_lines': ['\treturn d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,host_get_page_state,"static enum pkvm_page_state host_get_page_state(kvm_pte_t pte)
{
if (!kvm_pte_valid(pte) && pte)
return PKVM_NOPAGE;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state host_get_page_state(kvm_pte_t VAR_0)
{
if (!kvm_pte_valid(VAR_0) && VAR_0)
return VAR_1;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/2.json,"static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)
{
	if (!kvm_pte_valid(pte) && pte)
		return PKVM_NOPAGE;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state host_get_page_state(kvm_pte_t VAR_0, u64 VAR_1)
{
	if (!kvm_pte_valid(VAR_0) && VAR_0)
		return VAR_2;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static enum pkvm_page_state host_get_page_state(kvm_pte_t pte)
+static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)
 {
 	if (!kvm_pte_valid(pte) && pte)
 		return PKVM_NOPAGE;","{'deleted_lines': ['static enum pkvm_page_state host_get_page_state(kvm_pte_t pte)'], 'added_lines': ['static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,__guest_request_page_transition,"static int __guest_request_page_transition(u64 *completer_addr,
const struct pkvm_mem_transition *tx,
enum pkvm_page_state desired)
{
struct kvm_vcpu *vcpu = tx->initiator.guest.vcpu;
struct kvm_protected_vcpu *pkvm = &vcpu->arch.pkvm;
struct kvm_shadow_vm *vm = pkvm->shadow_vm;
enum pkvm_page_state state;
phys_addr_t phys;
kvm_pte_t pte;
u32 level;
int ret;
if (tx->nr_pages != 1)
return -E2BIG;
ret = kvm_pgtable_get_leaf(&vm->pgt, tx->initiator.addr, &pte, &level);
if (ret)
return ret;
state = guest_get_page_state(pte);
if (state == PKVM_NOPAGE)
return -EFAULT;
if (state != desired)
return -EPERM;
if (level != KVM_PGTABLE_MAX_LEVELS - 1)
return -EINVAL;
phys = kvm_pte_to_phys(pte);
if (!addr_is_allowed_memory(phys))
return -EINVAL;
return __guest_get_completer_addr(completer_addr, phys, tx);
}","static int __guest_request_page_transition(u64 *VAR_0,
const struct pkvm_mem_transition *VAR_1,
enum pkvm_page_state VAR_2)
{
struct kvm_vcpu *VAR_3 = VAR_1->initiator.guest.vcpu;
struct kvm_protected_vcpu *VAR_4 = &VAR_3->arch.pkvm;
struct kvm_shadow_vm *VAR_5 = VAR_4->shadow_vm;
enum pkvm_page_state VAR_6;
phys_addr_t VAR_7;
kvm_pte_t VAR_8;
u32 VAR_9;
int VAR_10;
if (VAR_1->nr_pages != 1)
return -VAR_11;
VAR_10 = kvm_pgtable_get_leaf(&VAR_5->pgt, VAR_1->initiator.addr, &VAR_8, &VAR_9);
if (VAR_10)
return VAR_10;
VAR_6 = guest_get_page_state(VAR_8);
if (VAR_6 == VAR_12)
return -VAR_13;
if (VAR_6 != VAR_2)
return -VAR_14;
if (VAR_9 != VAR_15 - 1)
return -VAR_16;
VAR_7 = kvm_pte_to_phys(VAR_8);
if (!addr_is_allowed_memory(VAR_7))
return -VAR_16;
return __guest_get_completer_addr(VAR_0, VAR_7, VAR_1);
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/3.json,"static int __guest_request_page_transition(u64 *completer_addr,
					   const struct pkvm_mem_transition *tx,
					   enum pkvm_page_state desired)
{
	struct kvm_vcpu *vcpu = tx->initiator.guest.vcpu;
	struct kvm_protected_vcpu *pkvm = &vcpu->arch.pkvm;
	struct kvm_shadow_vm *vm = pkvm->shadow_vm;
	enum pkvm_page_state state;
	phys_addr_t phys;
	kvm_pte_t pte;
	u32 level;
	int ret;

	if (tx->nr_pages != 1)
		return -E2BIG;

	ret = kvm_pgtable_get_leaf(&vm->pgt, tx->initiator.addr, &pte, &level);
	if (ret)
		return ret;

	state = guest_get_page_state(pte, tx->initiator.addr);
	if (state == PKVM_NOPAGE)
		return -EFAULT;

	if (state != desired)
		return -EPERM;

	/*
	 * We only deal with page granular mappings in the guest for now as
	 * the pgtable code relies on being able to recreate page mappings
	 * lazily after zapping a block mapping, which doesn't work once the
	 * pages have been donated.
	 */
	if (level != KVM_PGTABLE_MAX_LEVELS - 1)
		return -EINVAL;

	phys = kvm_pte_to_phys(pte);
	if (!addr_is_allowed_memory(phys))
		return -EINVAL;

	return __guest_get_completer_addr(completer_addr, phys, tx);
}","static int __guest_request_page_transition(u64 *VAR_0,
					   const struct pkvm_mem_transition *VAR_1,
					   enum pkvm_page_state VAR_2)
{
	struct kvm_vcpu *VAR_3 = VAR_1->initiator.guest.vcpu;
	struct kvm_protected_vcpu *VAR_4 = &VAR_3->arch.pkvm;
	struct kvm_shadow_vm *VAR_5 = VAR_4->shadow_vm;
	enum pkvm_page_state VAR_6;
	phys_addr_t VAR_7;
	kvm_pte_t VAR_8;
	u32 VAR_9;
	int VAR_10;

	if (VAR_1->nr_pages != 1)
		return -VAR_11;

	VAR_10 = kvm_pgtable_get_leaf(&VAR_5->pgt, VAR_1->initiator.addr, &VAR_8, &VAR_9);
	if (VAR_10)
		return VAR_10;

	VAR_6 = guest_get_page_state(VAR_8, VAR_1->initiator.addr);
	if (VAR_6 == VAR_12)
		return -VAR_13;

	if (VAR_6 != VAR_2)
		return -VAR_14;

	/* COMMENT_0 */
                                                                    
                                                                   
                                                                     
                            
    
	if (VAR_9 != VAR_15 - 1)
		return -VAR_16;

	VAR_7 = kvm_pte_to_phys(VAR_8);
	if (!addr_is_allowed_memory(VAR_7))
		return -VAR_16;

	return __guest_get_completer_addr(VAR_0, VAR_7, VAR_1);
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
 	if (ret)
 		return ret;
 
-	state = guest_get_page_state(pte);
+	state = guest_get_page_state(pte, tx->initiator.addr);
 	if (state == PKVM_NOPAGE)
 		return -EFAULT;
 ","{'deleted_lines': ['\tstate = guest_get_page_state(pte);'], 'added_lines': ['\tstate = guest_get_page_state(pte, tx->initiator.addr);']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,guest_get_page_state,"static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte)
{
if (!kvm_pte_valid(pte))
return PKVM_NOPAGE;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state guest_get_page_state(kvm_pte_t VAR_0)
{
if (!kvm_pte_valid(VAR_0))
return VAR_1;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/4.json,"static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte, u64 addr)
{
	if (!kvm_pte_valid(pte))
		return PKVM_NOPAGE;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state guest_get_page_state(kvm_pte_t VAR_0, u64 VAR_1)
{
	if (!kvm_pte_valid(VAR_0))
		return VAR_2;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte)
+static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte, u64 addr)
 {
 	if (!kvm_pte_valid(pte))
 		return PKVM_NOPAGE;","{'deleted_lines': ['static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte)'], 'added_lines': ['static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte, u64 addr)']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Pass addr to get_page_state() helper

We will soon need to fetch part of the page state outside of invalid
PTE entries, so provide the input address to the get_page_state()
helper.

Bug: 264070847
Change-Id: I02e0c7538a15cad8e63591bfab67c6de125631fe
Signed-off-by: Quentin Perret <qperret@google.com>
Bug: 279739439
[willdeacon@: Dropped hunks modifying non-existent code]
Signed-off-by: Will Deacon <willdeacon@google.com>
",53625a846a7b4273982157d7a1db5947371757ef,https://android.googlesource.com/kernel/common/+/53625a846a7b4,arch/arm64/kvm/hyp/nvhe/mem_protect.c,__pkvm_host_reclaim_page,"int __pkvm_host_reclaim_page(u64 pfn)
{
u64 addr = hyp_pfn_to_phys(pfn);
struct hyp_page *page;
kvm_pte_t pte;
int ret;
host_lock_component();
ret = kvm_pgtable_get_leaf(&host_kvm.pgt, addr, &pte, NULL);
if (ret)
goto unlock;
if (host_get_page_state(pte) == PKVM_PAGE_OWNED)
goto unlock;
page = hyp_phys_to_page(addr);
if (!(page->flags & HOST_PAGE_PENDING_RECLAIM)) {
ret = -EPERM;
goto unlock;
}
if (page->flags & HOST_PAGE_NEED_POISONING) {
ret = hyp_zero_page(addr);
if (ret)
goto unlock;
page->flags &= ~HOST_PAGE_NEED_POISONING;
psci_mem_protect_dec();
}
ret = host_stage2_set_owner_locked(addr, PAGE_SIZE, pkvm_host_id);
if (ret)
goto unlock;
page->flags &= ~HOST_PAGE_PENDING_RECLAIM;
unlock:
host_unlock_component();
return ret;
}","int __pkvm_host_reclaim_page(u64 VAR_0)
{
u64 VAR_1 = hyp_pfn_to_phys(VAR_0);
struct hyp_page *VAR_2;
kvm_pte_t VAR_3;
int VAR_4;
host_lock_component();
VAR_4 = kvm_pgtable_get_leaf(&VAR_5.pgt, VAR_1, &VAR_3, NULL);
if (VAR_4)
goto unlock;
if (host_get_page_state(VAR_3) == VAR_6)
goto unlock;
VAR_2 = hyp_phys_to_page(VAR_1);
if (!(VAR_2->flags & VAR_7)) {
VAR_4 = -VAR_8;
goto unlock;
}
if (VAR_2->flags & VAR_9) {
VAR_4 = hyp_zero_page(VAR_1);
if (VAR_4)
goto unlock;
VAR_2->flags &= ~VAR_9;
psci_mem_protect_dec();
}
VAR_4 = host_stage2_set_owner_locked(VAR_1, VAR_10, VAR_11);
if (VAR_4)
goto unlock;
VAR_2->flags &= ~VAR_7;
unlock:
host_unlock_component();
return VAR_4;
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/before/5.json,"int __pkvm_host_reclaim_page(u64 pfn)
{
	u64 addr = hyp_pfn_to_phys(pfn);
	struct hyp_page *page;
	kvm_pte_t pte;
	int ret;

	host_lock_component();

	ret = kvm_pgtable_get_leaf(&host_kvm.pgt, addr, &pte, NULL);
	if (ret)
		goto unlock;

	if (host_get_page_state(pte, addr) == PKVM_PAGE_OWNED)
		goto unlock;

	page = hyp_phys_to_page(addr);
	if (!(page->flags & HOST_PAGE_PENDING_RECLAIM)) {
		ret = -EPERM;
		goto unlock;
	}

	if (page->flags & HOST_PAGE_NEED_POISONING) {
		ret = hyp_zero_page(addr);
		if (ret)
			goto unlock;
		page->flags &= ~HOST_PAGE_NEED_POISONING;
		psci_mem_protect_dec();
	}

	ret = host_stage2_set_owner_locked(addr, PAGE_SIZE, pkvm_host_id);
	if (ret)
		goto unlock;
	page->flags &= ~HOST_PAGE_PENDING_RECLAIM;

unlock:
	host_unlock_component();

	return ret;
}","int __pkvm_host_reclaim_page(u64 VAR_0)
{
	u64 VAR_1 = hyp_pfn_to_phys(VAR_0);
	struct hyp_page *VAR_2;
	kvm_pte_t VAR_3;
	int VAR_4;

	host_lock_component();

	VAR_4 = kvm_pgtable_get_leaf(&VAR_5.pgt, VAR_1, &VAR_3, NULL);
	if (VAR_4)
		goto unlock;

	if (host_get_page_state(VAR_3, VAR_1) == VAR_6)
		goto unlock;

	VAR_2 = hyp_phys_to_page(VAR_1);
	if (!(VAR_2->flags & VAR_7)) {
		VAR_4 = -VAR_8;
		goto unlock;
	}

	if (VAR_2->flags & VAR_9) {
		VAR_4 = hyp_zero_page(VAR_1);
		if (VAR_4)
			goto unlock;
		VAR_2->flags &= ~VAR_9;
		psci_mem_protect_dec();
	}

	VAR_4 = host_stage2_set_owner_locked(VAR_1, VAR_10, VAR_11);
	if (VAR_4)
		goto unlock;
	VAR_2->flags &= ~VAR_7;

unlock:
	host_unlock_component();

	return VAR_4;
}",android/53625a846a7b4273982157d7a1db5947371757ef/mem_protect.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -11,7 +11,7 @@
 	if (ret)
 		goto unlock;
 
-	if (host_get_page_state(pte) == PKVM_PAGE_OWNED)
+	if (host_get_page_state(pte, addr) == PKVM_PAGE_OWNED)
 		goto unlock;
 
 	page = hyp_phys_to_page(addr);","{'deleted_lines': ['\tif (host_get_page_state(pte) == PKVM_PAGE_OWNED)'], 'added_lines': ['\tif (host_get_page_state(pte, addr) == PKVM_PAGE_OWNED)']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Move addr_is_allowed_memory() check into host callback

Since host stage-2 mappings are created lazily, we cannot rely on the
pte in order to recover the target physical address when checking a
host-initiated memory transition.

Instead, move the addr_is_allowed_memory() check into the host callback
function where it is passed the physical address directly from the
walker.

Bug: 279739439
Signed-off-by: Will Deacon <willdeacon@google.com>
Change-Id: I84bdc43eded79f1f5e5a489dbc0874604491e5c8
",b35a06182451f71cc0543cfe36a3f21fad6f6f02,https://android.googlesource.com/kernel/common/+/b35a06182451f,arch/arm64/kvm/hyp/nvhe/mem_protect.c,__check_page_state_visitor,"static int __check_page_state_visitor(u64 addr, u64 end, u32 level,
kvm_pte_t *ptep,
enum kvm_pgtable_walk_flags flag,
void * const arg)
{
struct check_walk_data *d = arg;
kvm_pte_t pte = *ptep;
if (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))
return -EINVAL;
return d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;
}","static int __check_page_state_visitor(u64 VAR_0, u64 VAR_1, u32 VAR_2,
kvm_pte_t *VAR_3,
enum kvm_pgtable_walk_flags VAR_4,
void * const VAR_5)
{
struct check_walk_data *VAR_6 = VAR_5;
kvm_pte_t VAR_7 = *VAR_3;
if (kvm_pte_valid(VAR_7) && !addr_is_allowed_memory(kvm_pte_to_phys(VAR_7)))
return -VAR_8;
return VAR_6->get_page_state(VAR_7, VAR_0) == VAR_6->desired ? 0 : -VAR_9;
}",android/b35a06182451f71cc0543cfe36a3f21fad6f6f02/mem_protect.c/vul/before/0.json,"static int __check_page_state_visitor(u64 addr, u64 end, u32 level,
				      kvm_pte_t *ptep,
				      enum kvm_pgtable_walk_flags flag,
				      void * const arg)
{
	struct check_walk_data *d = arg;
	kvm_pte_t pte = *ptep;

	return d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;
}","static int __check_page_state_visitor(u64 VAR_0, u64 VAR_1, u32 VAR_2,
				      kvm_pte_t *VAR_3,
				      enum kvm_pgtable_walk_flags VAR_4,
				      void * const VAR_5)
{
	struct check_walk_data *VAR_6 = VAR_5;
	kvm_pte_t VAR_7 = *VAR_3;

	return VAR_6->get_page_state(VAR_7, VAR_0) == VAR_6->desired ? 0 : -VAR_8;
}",android/b35a06182451f71cc0543cfe36a3f21fad6f6f02/mem_protect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,8 +6,5 @@
 	struct check_walk_data *d = arg;
 	kvm_pte_t pte = *ptep;
 
-	if (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))
-		return -EINVAL;
-
 	return d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;
 }","{'deleted_lines': ['\tif (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))', '\t\treturn -EINVAL;', ''], 'added_lines': []}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2023-21264,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,android,"ANDROID: KVM: arm64: Move addr_is_allowed_memory() check into host callback

Since host stage-2 mappings are created lazily, we cannot rely on the
pte in order to recover the target physical address when checking a
host-initiated memory transition.

Instead, move the addr_is_allowed_memory() check into the host callback
function where it is passed the physical address directly from the
walker.

Bug: 279739439
Signed-off-by: Will Deacon <willdeacon@google.com>
Change-Id: I84bdc43eded79f1f5e5a489dbc0874604491e5c8
",b35a06182451f71cc0543cfe36a3f21fad6f6f02,https://android.googlesource.com/kernel/common/+/b35a06182451f,arch/arm64/kvm/hyp/nvhe/mem_protect.c,host_get_page_state,"static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)
{
if (!kvm_pte_valid(pte) && pte)
return PKVM_NOPAGE;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state host_get_page_state(kvm_pte_t VAR_0, u64 VAR_1)
{
if (!kvm_pte_valid(VAR_0) && VAR_0)
return VAR_2;
return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/b35a06182451f71cc0543cfe36a3f21fad6f6f02/mem_protect.c/vul/before/1.json,"static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)
{
	if (!addr_is_allowed_memory(addr))
		return PKVM_NOPAGE;

	if (!kvm_pte_valid(pte) && pte)
		return PKVM_NOPAGE;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));
}","static enum pkvm_page_state host_get_page_state(kvm_pte_t VAR_0, u64 VAR_1)
{
	if (!addr_is_allowed_memory(VAR_1))
		return VAR_2;

	if (!kvm_pte_valid(VAR_0) && VAR_0)
		return VAR_2;

	return pkvm_getstate(kvm_pgtable_stage2_pte_prot(VAR_0));
}",android/b35a06182451f71cc0543cfe36a3f21fad6f6f02/mem_protect.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 static enum pkvm_page_state host_get_page_state(kvm_pte_t pte, u64 addr)
 {
+	if (!addr_is_allowed_memory(addr))
+		return PKVM_NOPAGE;
+
 	if (!kvm_pte_valid(pte) && pte)
 		return PKVM_NOPAGE;
 ","{'deleted_lines': [], 'added_lines': ['\tif (!addr_is_allowed_memory(addr))', '\t\treturn PKVM_NOPAGE;', '']}",True,"In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

",6.7,MEDIUM,1,valid,,5
CVE-2022-37052,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,"Fixes #1278
",8677500399fc2548fa816b619580c2c07915a98c,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8677500399fc2548fa816b619580c2c07915a98c,poppler/PDFDoc.cc,PDFDoc::markDictionnary,"void PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
bool deleteSet = false;
if (!alreadyMarkedDicts) {
alreadyMarkedDicts = new std::set<Dict *>;
deleteSet = true;
}
if (alreadyMarkedDicts->find(dict) != alreadyMarkedDicts->end()) {
error(errSyntaxWarning, -1, ""PDFDoc::markDictionnary: Found recursive dicts"");
if (deleteSet) {
delete alreadyMarkedDicts;
}
return;
} else {
alreadyMarkedDicts->insert(dict);
}
for (int i = 0; i < dict->getLength(); i++) {
const char *key = dict->getKey(i);
if (strcmp(key, ""Annots"") != 0) {
Object obj1 = dict->getValNF(i).copy();
markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
} else {
Object annotsObj = dict->getValNF(i).copy();
if (!annotsObj.isNull()) {
markAnnotations(&annotsObj, xRef, countRef, 0, oldRefNum, newRefNum, alreadyMarkedDicts);
}
}
}
if (deleteSet) {
delete alreadyMarkedDicts;
}
}","void PDFDoc::markDictionnary(Dict *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
bool VAR_7 = false;
if (!VAR_6) {
VAR_6 = new std::set<Dict *>;
VAR_7 = true;
}
if (VAR_6->find(VAR_0) != VAR_6->end()) {
error(VAR_8, -1, ""PDFDoc::markDictionnary: Found recursive dicts"");
if (VAR_7) {
delete VAR_6;
}
return;
} else {
VAR_6->insert(VAR_0);
}
for (int VAR_9 = 0; VAR_9 < VAR_0->getLength(); VAR_9++) {
const char *VAR_10 = VAR_0->getKey(VAR_9);
if (strcmp(VAR_10, ""Annots"") != 0) {
Object VAR_11 = VAR_0->getValNF(VAR_9).copy();
markObject(&VAR_11, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
} else {
Object VAR_12 = VAR_0->getValNF(VAR_9).copy();
if (!VAR_12.isNull()) {
markAnnotations(&VAR_12, VAR_1, VAR_2, 0, VAR_4, VAR_5, VAR_6);
}
}
}
if (VAR_7) {
delete VAR_6;
}
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/before/0.json,"bool PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
    bool deleteSet = false;
    if (!alreadyMarkedDicts) {
        alreadyMarkedDicts = new std::set<Dict *>;
        deleteSet = true;
    }

    if (alreadyMarkedDicts->find(dict) != alreadyMarkedDicts->end()) {
        error(errSyntaxWarning, -1, ""PDFDoc::markDictionnary: Found recursive dicts"");
        if (deleteSet) {
            delete alreadyMarkedDicts;
        }
        return true;
    } else {
        alreadyMarkedDicts->insert(dict);
    }

    for (int i = 0; i < dict->getLength(); i++) {
        const char *key = dict->getKey(i);
        if (strcmp(key, ""Annots"") != 0) {
            Object obj1 = dict->getValNF(i).copy();
            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
            if (unlikely(!success)) {
                return false;
            }
        } else {
            Object annotsObj = dict->getValNF(i).copy();
            if (!annotsObj.isNull()) {
                markAnnotations(&annotsObj, xRef, countRef, 0, oldRefNum, newRefNum, alreadyMarkedDicts);
            }
        }
    }

    if (deleteSet) {
        delete alreadyMarkedDicts;
    }

    return true;
}","bool PDFDoc::markDictionnary(Dict *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
    bool VAR_7 = false;
    if (!VAR_6) {
        VAR_6 = new std::set<Dict *>;
        VAR_7 = true;
    }

    if (VAR_6->find(VAR_0) != VAR_6->end()) {
        error(VAR_8, -1, ""PDFDoc::markDictionnary: Found recursive dicts"");
        if (VAR_7) {
            delete VAR_6;
        }
        return true;
    } else {
        VAR_6->insert(VAR_0);
    }

    for (int VAR_9 = 0; VAR_9 < VAR_0->getLength(); VAR_9++) {
        const char *VAR_10 = VAR_0->getKey(VAR_9);
        if (strcmp(VAR_10, ""Annots"") != 0) {
            Object VAR_11 = VAR_0->getValNF(VAR_9).copy();
            const bool VAR_12 = markObject(&VAR_11, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
            if (unlikely(!VAR_12)) {
                return false;
            }
        } else {
            Object VAR_13 = VAR_0->getValNF(VAR_9).copy();
            if (!VAR_13.isNull()) {
                markAnnotations(&VAR_13, VAR_1, VAR_2, 0, VAR_4, VAR_5, VAR_6);
            }
        }
    }

    if (VAR_7) {
        delete VAR_6;
    }

    return true;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
+bool PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
 {
     bool deleteSet = false;
     if (!alreadyMarkedDicts) {
@@ -11,7 +11,7 @@
         if (deleteSet) {
             delete alreadyMarkedDicts;
         }
-        return;
+        return true;
     } else {
         alreadyMarkedDicts->insert(dict);
     }
@@ -20,7 +20,10 @@
         const char *key = dict->getKey(i);
         if (strcmp(key, ""Annots"") != 0) {
             Object obj1 = dict->getValNF(i).copy();
-            markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            if (unlikely(!success)) {
+                return false;
+            }
         } else {
             Object annotsObj = dict->getValNF(i).copy();
             if (!annotsObj.isNull()) {
@@ -32,4 +35,6 @@
     if (deleteSet) {
         delete alreadyMarkedDicts;
     }
+
+    return true;
 }","{'deleted_lines': ['void PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '        return;', '            markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);'], 'added_lines': ['bool PDFDoc::markDictionnary(Dict *dict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '        return true;', '            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '            if (unlikely(!success)) {', '                return false;', '            }', '', '    return true;']}",True,A reachable Object::getString assertion in Poppler 22.07.0 allows attackers to cause a denial of service due to a failure in markObject.,6.5,MEDIUM,1,valid,,5
CVE-2022-37052,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,"Fixes #1278
",8677500399fc2548fa816b619580c2c07915a98c,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8677500399fc2548fa816b619580c2c07915a98c,poppler/PDFDoc.cc,PDFDoc::markObject,"void PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
Array *array;
switch (obj->getType()) {
case objArray:
array = obj->getArray();
for (int i = 0; i < array->getLength(); i++) {
Object obj1 = array->getNF(i).copy();
markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
}
break;
case objDict:
markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
break;
case objStream: {
Stream *stream = obj->getStream();
markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
} break;
case objRef: {
if (obj->getRef().num + (int)numOffset >= xRef->getNumObjects() || xRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {
if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryFree) {
return;             }
xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);
if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryCompressed) {
xRef->getEntry(obj->getRef().num + numOffset)->type = xrefEntryCompressed;
}
}
if (obj->getRef().num + (int)numOffset >= countRef->getNumObjects() || countRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {
countRef->add(obj->getRef().num + numOffset, 1, 0, true);
} else {
XRefEntry *entry = countRef->getEntry(obj->getRef().num + numOffset);
entry->gen++;
if (entry->gen > 9) {
break;
}
}
Object obj1 = getXRef()->fetch(obj->getRef());
markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);
} break;
default:
break;
}
}","void PDFDoc::markObject(Object *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
Array *VAR_7;
switch (VAR_0->getType()) {
case VAR_8:
VAR_7 = VAR_0->getArray();
for (int VAR_9 = 0; VAR_9 < VAR_7->getLength(); VAR_9++) {
Object VAR_10 = VAR_7->getNF(VAR_9).copy();
markObject(&VAR_10, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
}
break;
case VAR_11:
markDictionnary(VAR_0->getDict(), VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
break;
case VAR_12: {
Stream *VAR_13 = VAR_0->getStream();
markDictionnary(VAR_13->getDict(), VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
} break;
case VAR_14: {
if (VAR_0->getRef().num + (int)VAR_3 >= VAR_1->getNumObjects() || VAR_1->getEntry(VAR_0->getRef().num + VAR_3)->type == VAR_15) {
if (getXRef()->getEntry(VAR_0->getRef().num)->type == VAR_15) {
return; 
}
VAR_1->add(VAR_0->getRef().num + VAR_3, VAR_0->getRef().gen, 0, true);
if (getXRef()->getEntry(VAR_0->getRef().num)->type == VAR_16) {
VAR_1->getEntry(VAR_0->getRef().num + VAR_3)->type = VAR_16;
}
}
if (VAR_0->getRef().num + (int)VAR_3 >= VAR_2->getNumObjects() || VAR_2->getEntry(VAR_0->getRef().num + VAR_3)->type == VAR_15) {
VAR_2->add(VAR_0->getRef().num + VAR_3, 1, 0, true);
} else {
XRefEntry *VAR_17 = VAR_2->getEntry(VAR_0->getRef().num + VAR_3);
VAR_17->gen++;
if (VAR_17->gen > 9) {
break;
}
}
Object VAR_10 = getXRef()->fetch(VAR_0->getRef());
markObject(&VAR_10, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);
} break;
default:
break;
}
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/before/1.json,"bool PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
    Array *array;

    switch (obj->getType()) {
    case objArray:
        array = obj->getArray();
        for (int i = 0; i < array->getLength(); i++) {
            Object obj1 = array->getNF(i).copy();
            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
            if (unlikely(!success)) {
                return false;
            }
        }
        break;
    case objDict: {
        const bool success = markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
        if (unlikely(!success)) {
            return false;
        }
    } break;
    case objStream: {
        Stream *stream = obj->getStream();
        const bool success = markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
        if (unlikely(!success)) {
            return false;
        }
    } break;
    case objRef: {
        if (obj->getRef().num + (int)numOffset >= xRef->getNumObjects() || xRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {
            if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryFree) {
                return true; // already marked as free => should be replaced
            }
            const bool success = xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);
            if (unlikely(!success)) {
                return false;
            }
            if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryCompressed) {
                xRef->getEntry(obj->getRef().num + numOffset)->type = xrefEntryCompressed;
            }
        }
        if (obj->getRef().num + (int)numOffset >= countRef->getNumObjects() || countRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {
            countRef->add(obj->getRef().num + numOffset, 1, 0, true);
        } else {
            XRefEntry *entry = countRef->getEntry(obj->getRef().num + numOffset);
            entry->gen++;
            if (entry->gen > 9) {
                break;
            }
        }
        Object obj1 = getXRef()->fetch(obj->getRef());
        const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);
        if (unlikely(!success)) {
            return false;
        }
    } break;
    default:
        break;
    }

    return true;
}","bool PDFDoc::markObject(Object *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
    Array *VAR_7;

    switch (VAR_0->getType()) {
    case VAR_8:
        VAR_7 = VAR_0->getArray();
        for (int VAR_9 = 0; VAR_9 < VAR_7->getLength(); VAR_9++) {
            Object VAR_10 = VAR_7->getNF(VAR_9).copy();
            const bool VAR_11 = markObject(&VAR_10, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
            if (unlikely(!VAR_11)) {
                return false;
            }
        }
        break;
    case VAR_12: {
        const bool VAR_11 = markDictionnary(VAR_0->getDict(), VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
        if (unlikely(!VAR_11)) {
            return false;
        }
    } break;
    case VAR_13: {
        Stream *VAR_14 = VAR_0->getStream();
        const bool VAR_11 = markDictionnary(VAR_14->getDict(), VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
        if (unlikely(!VAR_11)) {
            return false;
        }
    } break;
    case VAR_15: {
        if (VAR_0->getRef().num + (int)VAR_3 >= VAR_1->getNumObjects() || VAR_1->getEntry(VAR_0->getRef().num + VAR_3)->type == VAR_16) {
            if (getXRef()->getEntry(VAR_0->getRef().num)->type == VAR_16) {
                return true; /* COMMENT_0 */
            }
            const bool VAR_11 = VAR_1->add(VAR_0->getRef().num + VAR_3, VAR_0->getRef().gen, 0, true);
            if (unlikely(!VAR_11)) {
                return false;
            }
            if (getXRef()->getEntry(VAR_0->getRef().num)->type == VAR_17) {
                VAR_1->getEntry(VAR_0->getRef().num + VAR_3)->type = VAR_17;
            }
        }
        if (VAR_0->getRef().num + (int)VAR_3 >= VAR_2->getNumObjects() || VAR_2->getEntry(VAR_0->getRef().num + VAR_3)->type == VAR_16) {
            VAR_2->add(VAR_0->getRef().num + VAR_3, 1, 0, true);
        } else {
            XRefEntry *VAR_18 = VAR_2->getEntry(VAR_0->getRef().num + VAR_3);
            VAR_18->gen++;
            if (VAR_18->gen > 9) {
                break;
            }
        }
        Object VAR_10 = getXRef()->fetch(VAR_0->getRef());
        const bool VAR_11 = markObject(&VAR_10, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);
        if (unlikely(!VAR_11)) {
            return false;
        }
    } break;
    default:
        break;
    }

    return true;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
+bool PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
 {
     Array *array;
 
@@ -7,22 +7,34 @@
         array = obj->getArray();
         for (int i = 0; i < array->getLength(); i++) {
             Object obj1 = array->getNF(i).copy();
-            markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            if (unlikely(!success)) {
+                return false;
+            }
         }
         break;
-    case objDict:
-        markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
-        break;
+    case objDict: {
+        const bool success = markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+        if (unlikely(!success)) {
+            return false;
+        }
+    } break;
     case objStream: {
         Stream *stream = obj->getStream();
-        markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+        const bool success = markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+        if (unlikely(!success)) {
+            return false;
+        }
     } break;
     case objRef: {
         if (obj->getRef().num + (int)numOffset >= xRef->getNumObjects() || xRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {
             if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryFree) {
-                return; // already marked as free => should be replaced
+                return true; // already marked as free => should be replaced
             }
-            xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);
+            const bool success = xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);
+            if (unlikely(!success)) {
+                return false;
+            }
             if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryCompressed) {
                 xRef->getEntry(obj->getRef().num + numOffset)->type = xrefEntryCompressed;
             }
@@ -37,9 +49,14 @@
             }
         }
         Object obj1 = getXRef()->fetch(obj->getRef());
-        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);
+        const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);
+        if (unlikely(!success)) {
+            return false;
+        }
     } break;
     default:
         break;
     }
+
+    return true;
 }","{'deleted_lines': ['void PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '            markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '    case objDict:', '        markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '        break;', '        markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '                return; // already marked as free => should be replaced', '            xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);', '        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);'], 'added_lines': ['bool PDFDoc::markObject(Object *obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '            const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '            if (unlikely(!success)) {', '                return false;', '            }', '    case objDict: {', '        const bool success = markDictionnary(obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '        if (unlikely(!success)) {', '            return false;', '        }', '    } break;', '        const bool success = markDictionnary(stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '        if (unlikely(!success)) {', '            return false;', '        }', '                return true; // already marked as free => should be replaced', '            const bool success = xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);', '            if (unlikely(!success)) {', '                return false;', '            }', '        const bool success = markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);', '        if (unlikely(!success)) {', '            return false;', '        }', '', '    return true;']}",True,A reachable Object::getString assertion in Poppler 22.07.0 allows attackers to cause a denial of service due to a failure in markObject.,6.5,MEDIUM,1,valid,,5
CVE-2022-37052,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,"Fixes #1278
",8677500399fc2548fa816b619580c2c07915a98c,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8677500399fc2548fa816b619580c2c07915a98c,poppler/PDFDoc.cc,PDFDoc::savePageAs,"int PDFDoc::savePageAs(const GooString &name, int pageNo)
{
FILE *f;
OutStream *outStr;
XRef *yRef, *countRef;
if (file && file->modificationTimeChangedSinceOpen()) {
return errFileChangedSinceOpen;
}
int rootNum = getXRef()->getNumObjects() + 1;
xref->scanSpecialFlags();
unsigned char *fileKey;
CryptAlgorithm encAlgorithm;
int keyLength;
xref->getEncryptionParameters(&fileKey, &encAlgorithm, &keyLength);
if (pageNo < 1 || pageNo > getNumPages() || !getCatalog()->getPage(pageNo)) {
error(errInternal, -1, ""Illegal pageNo: {0:d}({1:d})"", pageNo, getNumPages());
return errOpenFile;
}
const PDFRectangle *cropBox = nullptr;
if (getCatalog()->getPage(pageNo)->isCropped()) {
cropBox = getCatalog()->getPage(pageNo)->getCropBox();
}
replacePageDict(pageNo, getCatalog()->getPage(pageNo)->getRotate(), getCatalog()->getPage(pageNo)->getMediaBox(), cropBox);
Ref *refPage = getCatalog()->getPageRef(pageNo);
Object page = getXRef()->fetch(*refPage);
if (!(f = openFile(name.c_str(), ""wb""))) {
error(errIO, -1, ""Couldn't open file '{0:t}'"", &name);
return errOpenFile;
}
outStr = new FileOutStream(f, 0);
yRef = new XRef(getXRef()->getTrailerDict());
if (secHdlr != nullptr && !secHdlr->isUnencrypted()) {
yRef->setEncryption(secHdlr->getPermissionFlags(), secHdlr->getOwnerPasswordOk(), fileKey, keyLength, secHdlr->getEncVersion(), secHdlr->getEncRevision(), encAlgorithm);
}
countRef = new XRef();
Object *trailerObj = getXRef()->getTrailerDict();
if (trailerObj->isDict()) {
markPageObjects(trailerObj->getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
}
yRef->add(0, 65535, 0, false);
writeHeader(outStr, getPDFMajorVersion(), getPDFMinorVersion());
Object infoObj = getXRef()->getDocInfo();
if (infoObj.isDict()) {
Dict *infoDict = infoObj.getDict();
markPageObjects(infoDict, yRef, countRef, 0, refPage->num, rootNum + 2);
if (trailerObj->isDict()) {
Dict *trailerDict = trailerObj->getDict();
const Object &ref = trailerDict->lookupNF(""Info"");
if (ref.isRef()) {
yRef->add(ref.getRef(), 0, true);
if (getXRef()->getEntry(ref.getRef().num)->type == xrefEntryCompressed) {
yRef->getEntry(ref.getRef().num)->type = xrefEntryCompressed;
}
}
}
}
Object catObj = getXRef()->getCatalog();
if (!catObj.isDict()) {
fclose(f);
delete yRef;
delete countRef;
delete outStr;
error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary"");
return errOpenFile;
}
Dict *catDict = catObj.getDict();
Object pagesObj = catDict->lookup(""Pages"");
Object afObj = catDict->lookupNF(""AcroForm"").copy();
if (!afObj.isNull()) {
markAcroForm(&afObj, yRef, countRef, 0, refPage->num, rootNum + 2);
}
Dict *pagesDict = pagesObj.getDict();
Object resourcesObj = pagesDict->lookup(""Resources"");
if (resourcesObj.isDict()) {
markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
}
markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2);
Dict *pageDict = page.getDict();
if (resourcesObj.isNull() && !pageDict->hasKey(""Resources"")) {
Object *resourceDictObject = getCatalog()->getPage(pageNo)->getResourceDictObject();
if (resourceDictObject->isDict()) {
resourcesObj = resourceDictObject->copy();
markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
}
}
markPageObjects(pageDict, yRef, countRef, 0, refPage->num, rootNum + 2);
Object annotsObj = pageDict->lookupNF(""Annots"").copy();
if (!annotsObj.isNull()) {
markAnnotations(&annotsObj, yRef, countRef, 0, refPage->num, rootNum + 2);
}
yRef->markUnencrypted();
writePageObjects(outStr, yRef, 0);
yRef->add(rootNum, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum);
outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
for (int j = 0; j < catDict->getLength(); j++) {
const char *key = catDict->getKey(j);
if (strcmp(key, ""Type"") != 0 && strcmp(key, ""Catalog"") != 0 && strcmp(key, ""Pages"") != 0) {
if (j > 0) {
outStr->printf("" "");
}
Object value = catDict->getValNF(j).copy();
outStr->printf(""/%s "", key);
writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
}
}
outStr->printf("">>\nendobj\n"");
yRef->add(rootNum + 1, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum + 1);
outStr->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", rootNum + 2);
if (resourcesObj.isDict()) {
outStr->printf(""/Resources "");
writeObject(&resourcesObj, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
}
outStr->printf("">>\n"");
outStr->printf(""endobj\n"");
yRef->add(rootNum + 2, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum + 2);
outStr->printf(""<< "");
for (int n = 0; n < pageDict->getLength(); n++) {
if (n > 0) {
outStr->printf("" "");
}
const char *key = pageDict->getKey(n);
Object value = pageDict->getValNF(n).copy();
if (strcmp(key, ""Parent"") == 0) {
outStr->printf(""/Parent %d 0 R"", rootNum + 1);
} else {
outStr->printf(""/%s "", key);
writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
}
}
outStr->printf("" >>\nendobj\n"");
Goffset uxrefOffset = outStr->getPos();
Ref ref;
ref.num = rootNum;
ref.gen = 0;
Object trailerDict = createTrailerDict(rootNum + 3, false, 0, &ref, getXRef(), name.c_str(), uxrefOffset);
writeXRefTableTrailer(std::move(trailerDict), yRef, false , uxrefOffset, outStr, getXRef());
outStr->close();
fclose(f);
delete yRef;
delete countRef;
delete outStr;
return errNone;
}","int PDFDoc::savePageAs(const GooString &VAR_0, int VAR_1)
{
FILE *VAR_2;
OutStream *VAR_3;
XRef *VAR_4, *VAR_5;
if (VAR_6 && VAR_6->modificationTimeChangedSinceOpen()) {
return VAR_7;
}
int VAR_8 = getXRef()->getNumObjects() + 1;
VAR_9->scanSpecialFlags();
unsigned char *VAR_10;
CryptAlgorithm VAR_11;
int VAR_12;
VAR_9->getEncryptionParameters(&VAR_10, &VAR_11, &VAR_12);
if (VAR_1 < 1 || VAR_1 > getNumPages() || !getCatalog()->getPage(VAR_1)) {
error(VAR_13, -1, ""Illegal pageNo: {0:d}({1:d})"", VAR_1, getNumPages());
return VAR_14;
}
const PDFRectangle *VAR_15 = nullptr;
if (getCatalog()->getPage(VAR_1)->isCropped()) {
VAR_15 = getCatalog()->getPage(VAR_1)->getCropBox();
}
replacePageDict(VAR_1, getCatalog()->getPage(VAR_1)->getRotate(), getCatalog()->getPage(VAR_1)->getMediaBox(), VAR_15);
Ref *VAR_16 = getCatalog()->getPageRef(VAR_1);
Object VAR_17 = getXRef()->fetch(*VAR_16);
if (!(VAR_2 = openFile(VAR_0.c_str(), ""wb""))) {
error(VAR_18, -1, ""Couldn't open file '{0:t}'"", &VAR_0);
return VAR_14;
}
VAR_3 = new FileOutStream(VAR_2, 0);
VAR_4 = new XRef(getXRef()->getTrailerDict());
if (VAR_19 != nullptr && !VAR_19->isUnencrypted()) {
VAR_4->setEncryption(VAR_19->getPermissionFlags(), VAR_19->getOwnerPasswordOk(), VAR_10, VAR_12, VAR_19->getEncVersion(), VAR_19->getEncRevision(), VAR_11);
}
VAR_5 = new XRef();
Object *VAR_20 = getXRef()->getTrailerDict();
if (VAR_20->isDict()) {
markPageObjects(VAR_20->getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
}
VAR_4->add(0, 65535, 0, false);
writeHeader(VAR_3, getPDFMajorVersion(), getPDFMinorVersion());
Object VAR_21 = getXRef()->getDocInfo();
if (VAR_21.isDict()) {
Dict *VAR_22 = VAR_21.getDict();
markPageObjects(VAR_22, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
if (VAR_20->isDict()) {
Dict *VAR_23 = VAR_20->getDict();
const Object &VAR_24 = VAR_23->lookupNF(""Info"");
if (VAR_24.isRef()) {
VAR_4->add(VAR_24.getRef(), 0, true);
if (getXRef()->getEntry(VAR_24.getRef().num)->type == VAR_25) {
VAR_4->getEntry(VAR_24.getRef().num)->type = VAR_25;
}
}
}
}
Object VAR_26 = getXRef()->getCatalog();
if (!VAR_26.isDict()) {
fclose(VAR_2);
delete VAR_4;
delete VAR_5;
delete VAR_3;
error(VAR_27, -1, ""XRef's Catalog is not a dictionary"");
return VAR_14;
}
Dict *VAR_28 = VAR_26.getDict();
Object VAR_29 = VAR_28->lookup(""Pages"");
Object VAR_30 = VAR_28->lookupNF(""AcroForm"").copy();
if (!VAR_30.isNull()) {
markAcroForm(&VAR_30, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
}
Dict *VAR_31 = VAR_29.getDict();
Object VAR_32 = VAR_31->lookup(""Resources"");
if (VAR_32.isDict()) {
markPageObjects(VAR_32.getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
}
markPageObjects(VAR_28, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
Dict *VAR_33 = VAR_17.getDict();
if (VAR_32.isNull() && !VAR_33->hasKey(""Resources"")) {
Object *VAR_34 = getCatalog()->getPage(VAR_1)->getResourceDictObject();
if (VAR_34->isDict()) {
VAR_32 = VAR_34->copy();
markPageObjects(VAR_32.getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
}
}
markPageObjects(VAR_33, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
Object VAR_35 = VAR_33->lookupNF(""Annots"").copy();
if (!VAR_35.isNull()) {
markAnnotations(&VAR_35, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
}
VAR_4->markUnencrypted();
writePageObjects(VAR_3, VAR_4, 0);
VAR_4->add(VAR_8, 0, VAR_3->getPos(), true);
VAR_3->printf(""%d 0 obj\n"", VAR_8);
VAR_3->printf(""<< /Type /Catalog /Pages %d 0 R"", VAR_8 + 1);
for (int VAR_36 = 0; VAR_36 < VAR_28->getLength(); VAR_36++) {
const char *VAR_37 = VAR_28->getKey(VAR_36);
if (strcmp(VAR_37, ""Type"") != 0 && strcmp(VAR_37, ""Catalog"") != 0 && strcmp(VAR_37, ""Pages"") != 0) {
if (VAR_36 > 0) {
VAR_3->printf("" "");
}
Object VAR_38 = VAR_28->getValNF(VAR_36).copy();
VAR_3->printf(""/%s "", VAR_37);
writeObject(&VAR_38, VAR_3, getXRef(), 0, nullptr, VAR_39, 0, 0, 0);
}
}
VAR_3->printf("">>\nendobj\n"");
VAR_4->add(VAR_8 + 1, 0, VAR_3->getPos(), true);
VAR_3->printf(""%d 0 obj\n"", VAR_8 + 1);
VAR_3->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", VAR_8 + 2);
if (VAR_32.isDict()) {
VAR_3->printf(""/Resources "");
writeObject(&VAR_32, VAR_3, getXRef(), 0, nullptr, VAR_39, 0, 0, 0);
}
VAR_3->printf("">>\n"");
VAR_3->printf(""endobj\n"");
VAR_4->add(VAR_8 + 2, 0, VAR_3->getPos(), true);
VAR_3->printf(""%d 0 obj\n"", VAR_8 + 2);
VAR_3->printf(""<< "");
for (int VAR_40 = 0; VAR_40 < VAR_33->getLength(); VAR_40++) {
if (VAR_40 > 0) {
VAR_3->printf("" "");
}
const char *VAR_37 = VAR_33->getKey(VAR_40);
Object VAR_38 = VAR_33->getValNF(VAR_40).copy();
if (strcmp(VAR_37, ""Parent"") == 0) {
VAR_3->printf(""/Parent %d 0 R"", VAR_8 + 1);
} else {
VAR_3->printf(""/%s "", VAR_37);
writeObject(&VAR_38, VAR_3, getXRef(), 0, nullptr, VAR_39, 0, 0, 0);
}
}
VAR_3->printf("" >>\nendobj\n"");
Goffset VAR_41 = VAR_3->getPos();
Ref VAR_24;
VAR_24.num = VAR_8;
VAR_24.gen = 0;
Object VAR_23 = createTrailerDict(VAR_8 + 3, false, 0, &VAR_24, getXRef(), VAR_0.c_str(), VAR_41);
writeXRefTableTrailer(std::move(VAR_23), VAR_4, false , VAR_41, VAR_3, getXRef());
VAR_3->close();
fclose(VAR_2);
delete VAR_4;
delete VAR_5;
delete VAR_3;
return VAR_42;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/before/2.json,"int PDFDoc::savePageAs(const GooString &name, int pageNo)
{
    FILE *f;
    OutStream *outStr;
    XRef *yRef, *countRef;

    if (file && file->modificationTimeChangedSinceOpen()) {
        return errFileChangedSinceOpen;
    }

    int rootNum = getXRef()->getNumObjects() + 1;

    // Make sure that special flags are set, because we are going to read
    // all objects, including Unencrypted ones.
    xref->scanSpecialFlags();

    unsigned char *fileKey;
    CryptAlgorithm encAlgorithm;
    int keyLength;
    xref->getEncryptionParameters(&fileKey, &encAlgorithm, &keyLength);

    if (pageNo < 1 || pageNo > getNumPages() || !getCatalog()->getPage(pageNo)) {
        error(errInternal, -1, ""Illegal pageNo: {0:d}({1:d})"", pageNo, getNumPages());
        return errOpenFile;
    }
    const PDFRectangle *cropBox = nullptr;
    if (getCatalog()->getPage(pageNo)->isCropped()) {
        cropBox = getCatalog()->getPage(pageNo)->getCropBox();
    }
    replacePageDict(pageNo, getCatalog()->getPage(pageNo)->getRotate(), getCatalog()->getPage(pageNo)->getMediaBox(), cropBox);
    Ref *refPage = getCatalog()->getPageRef(pageNo);
    Object page = getXRef()->fetch(*refPage);

    if (!(f = openFile(name.c_str(), ""wb""))) {
        error(errIO, -1, ""Couldn't open file '{0:t}'"", &name);
        return errOpenFile;
    }
    outStr = new FileOutStream(f, 0);

    yRef = new XRef(getXRef()->getTrailerDict());

    if (secHdlr != nullptr && !secHdlr->isUnencrypted()) {
        yRef->setEncryption(secHdlr->getPermissionFlags(), secHdlr->getOwnerPasswordOk(), fileKey, keyLength, secHdlr->getEncVersion(), secHdlr->getEncRevision(), encAlgorithm);
    }
    countRef = new XRef();
    Object *trailerObj = getXRef()->getTrailerDict();
    if (trailerObj->isDict()) {
        markPageObjects(trailerObj->getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
    }
    yRef->add(0, 65535, 0, false);
    writeHeader(outStr, getPDFMajorVersion(), getPDFMinorVersion());

    // get and mark info dict
    Object infoObj = getXRef()->getDocInfo();
    if (infoObj.isDict()) {
        Dict *infoDict = infoObj.getDict();
        markPageObjects(infoDict, yRef, countRef, 0, refPage->num, rootNum + 2);
        if (trailerObj->isDict()) {
            Dict *trailerDict = trailerObj->getDict();
            const Object &ref = trailerDict->lookupNF(""Info"");
            if (ref.isRef()) {
                yRef->add(ref.getRef(), 0, true);
                if (getXRef()->getEntry(ref.getRef().num)->type == xrefEntryCompressed) {
                    yRef->getEntry(ref.getRef().num)->type = xrefEntryCompressed;
                }
            }
        }
    }

    // get and mark output intents etc.
    Object catObj = getXRef()->getCatalog();
    if (!catObj.isDict()) {
        fclose(f);
        delete yRef;
        delete countRef;
        delete outStr;
        error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary"");
        return errOpenFile;
    }
    Dict *catDict = catObj.getDict();
    Object pagesObj = catDict->lookup(""Pages"");
    Object afObj = catDict->lookupNF(""AcroForm"").copy();
    if (!afObj.isNull()) {
        markAcroForm(&afObj, yRef, countRef, 0, refPage->num, rootNum + 2);
    }
    Dict *pagesDict = pagesObj.getDict();
    Object resourcesObj = pagesDict->lookup(""Resources"");
    if (resourcesObj.isDict()) {
        markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
    }
    if (!markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2)) {
        fclose(f);
        delete yRef;
        delete countRef;
        delete outStr;
        error(errSyntaxError, -1, ""markPageObjects failed"");
        return errDamaged;
    }

    Dict *pageDict = page.getDict();
    if (resourcesObj.isNull() && !pageDict->hasKey(""Resources"")) {
        Object *resourceDictObject = getCatalog()->getPage(pageNo)->getResourceDictObject();
        if (resourceDictObject->isDict()) {
            resourcesObj = resourceDictObject->copy();
            markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
        }
    }
    markPageObjects(pageDict, yRef, countRef, 0, refPage->num, rootNum + 2);
    Object annotsObj = pageDict->lookupNF(""Annots"").copy();
    if (!annotsObj.isNull()) {
        markAnnotations(&annotsObj, yRef, countRef, 0, refPage->num, rootNum + 2);
    }
    yRef->markUnencrypted();
    writePageObjects(outStr, yRef, 0);

    yRef->add(rootNum, 0, outStr->getPos(), true);
    outStr->printf(""%d 0 obj\n"", rootNum);
    outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
    for (int j = 0; j < catDict->getLength(); j++) {
        const char *key = catDict->getKey(j);
        if (strcmp(key, ""Type"") != 0 && strcmp(key, ""Catalog"") != 0 && strcmp(key, ""Pages"") != 0) {
            if (j > 0) {
                outStr->printf("" "");
            }
            Object value = catDict->getValNF(j).copy();
            outStr->printf(""/%s "", key);
            writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
        }
    }
    outStr->printf("">>\nendobj\n"");

    yRef->add(rootNum + 1, 0, outStr->getPos(), true);
    outStr->printf(""%d 0 obj\n"", rootNum + 1);
    outStr->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", rootNum + 2);
    if (resourcesObj.isDict()) {
        outStr->printf(""/Resources "");
        writeObject(&resourcesObj, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
    }
    outStr->printf("">>\n"");
    outStr->printf(""endobj\n"");

    yRef->add(rootNum + 2, 0, outStr->getPos(), true);
    outStr->printf(""%d 0 obj\n"", rootNum + 2);
    outStr->printf(""<< "");
    for (int n = 0; n < pageDict->getLength(); n++) {
        if (n > 0) {
            outStr->printf("" "");
        }
        const char *key = pageDict->getKey(n);
        Object value = pageDict->getValNF(n).copy();
        if (strcmp(key, ""Parent"") == 0) {
            outStr->printf(""/Parent %d 0 R"", rootNum + 1);
        } else {
            outStr->printf(""/%s "", key);
            writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0);
        }
    }
    outStr->printf("" >>\nendobj\n"");

    Goffset uxrefOffset = outStr->getPos();
    Ref ref;
    ref.num = rootNum;
    ref.gen = 0;
    Object trailerDict = createTrailerDict(rootNum + 3, false, 0, &ref, getXRef(), name.c_str(), uxrefOffset);
    writeXRefTableTrailer(std::move(trailerDict), yRef, false /* do not write unnecessary entries */, uxrefOffset, outStr, getXRef());

    outStr->close();
    fclose(f);
    delete yRef;
    delete countRef;
    delete outStr;

    return errNone;
}","int PDFDoc::savePageAs(const GooString &VAR_0, int VAR_1)
{
    FILE *VAR_2;
    OutStream *VAR_3;
    XRef *VAR_4, *VAR_5;

    if (VAR_6 && VAR_6->modificationTimeChangedSinceOpen()) {
        return VAR_7;
    }

    int VAR_8 = getXRef()->getNumObjects() + 1;

    /* COMMENT_0 */
    /* COMMENT_1 */
    VAR_9->scanSpecialFlags();

    unsigned char *VAR_10;
    CryptAlgorithm VAR_11;
    int VAR_12;
    VAR_9->getEncryptionParameters(&VAR_10, &VAR_11, &VAR_12);

    if (VAR_1 < 1 || VAR_1 > getNumPages() || !getCatalog()->getPage(VAR_1)) {
        error(VAR_13, -1, ""Illegal pageNo: {0:d}({1:d})"", VAR_1, getNumPages());
        return VAR_14;
    }
    const PDFRectangle *VAR_15 = nullptr;
    if (getCatalog()->getPage(VAR_1)->isCropped()) {
        VAR_15 = getCatalog()->getPage(VAR_1)->getCropBox();
    }
    replacePageDict(VAR_1, getCatalog()->getPage(VAR_1)->getRotate(), getCatalog()->getPage(VAR_1)->getMediaBox(), VAR_15);
    Ref *VAR_16 = getCatalog()->getPageRef(VAR_1);
    Object VAR_17 = getXRef()->fetch(*VAR_16);

    if (!(VAR_2 = openFile(VAR_0.c_str(), ""wb""))) {
        error(VAR_18, -1, ""Couldn't open file '{0:t}'"", &VAR_0);
        return VAR_14;
    }
    VAR_3 = new FileOutStream(VAR_2, 0);

    VAR_4 = new XRef(getXRef()->getTrailerDict());

    if (VAR_19 != nullptr && !VAR_19->isUnencrypted()) {
        VAR_4->setEncryption(VAR_19->getPermissionFlags(), VAR_19->getOwnerPasswordOk(), VAR_10, VAR_12, VAR_19->getEncVersion(), VAR_19->getEncRevision(), VAR_11);
    }
    VAR_5 = new XRef();
    Object *VAR_20 = getXRef()->getTrailerDict();
    if (VAR_20->isDict()) {
        markPageObjects(VAR_20->getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
    }
    VAR_4->add(0, 65535, 0, false);
    writeHeader(VAR_3, getPDFMajorVersion(), getPDFMinorVersion());

    /* COMMENT_2 */
    Object VAR_21 = getXRef()->getDocInfo();
    if (VAR_21.isDict()) {
        Dict *VAR_22 = VAR_21.getDict();
        markPageObjects(VAR_22, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
        if (VAR_20->isDict()) {
            Dict *VAR_23 = VAR_20->getDict();
            const Object &VAR_24 = VAR_23->lookupNF(""Info"");
            if (VAR_24.isRef()) {
                VAR_4->add(VAR_24.getRef(), 0, true);
                if (getXRef()->getEntry(VAR_24.getRef().num)->type == VAR_25) {
                    VAR_4->getEntry(VAR_24.getRef().num)->type = VAR_25;
                }
            }
        }
    }

    /* COMMENT_3 */
    Object VAR_26 = getXRef()->getCatalog();
    if (!VAR_26.isDict()) {
        fclose(VAR_2);
        delete VAR_4;
        delete VAR_5;
        delete VAR_3;
        error(VAR_27, -1, ""XRef's Catalog is not a dictionary"");
        return VAR_14;
    }
    Dict *VAR_28 = VAR_26.getDict();
    Object VAR_29 = VAR_28->lookup(""Pages"");
    Object VAR_30 = VAR_28->lookupNF(""AcroForm"").copy();
    if (!VAR_30.isNull()) {
        markAcroForm(&VAR_30, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
    }
    Dict *VAR_31 = VAR_29.getDict();
    Object VAR_32 = VAR_31->lookup(""Resources"");
    if (VAR_32.isDict()) {
        markPageObjects(VAR_32.getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
    }
    if (!markPageObjects(VAR_28, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2)) {
        fclose(VAR_2);
        delete VAR_4;
        delete VAR_5;
        delete VAR_3;
        error(VAR_27, -1, ""markPageObjects failed"");
        return VAR_33;
    }

    Dict *VAR_34 = VAR_17.getDict();
    if (VAR_32.isNull() && !VAR_34->hasKey(""Resources"")) {
        Object *VAR_35 = getCatalog()->getPage(VAR_1)->getResourceDictObject();
        if (VAR_35->isDict()) {
            VAR_32 = VAR_35->copy();
            markPageObjects(VAR_32.getDict(), VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
        }
    }
    markPageObjects(VAR_34, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
    Object VAR_36 = VAR_34->lookupNF(""Annots"").copy();
    if (!VAR_36.isNull()) {
        markAnnotations(&VAR_36, VAR_4, VAR_5, 0, VAR_16->num, VAR_8 + 2);
    }
    VAR_4->markUnencrypted();
    writePageObjects(VAR_3, VAR_4, 0);

    VAR_4->add(VAR_8, 0, VAR_3->getPos(), true);
    VAR_3->printf(""%d 0 obj\n"", VAR_8);
    VAR_3->printf(""<< /Type /Catalog /Pages %d 0 R"", VAR_8 + 1);
    for (int VAR_37 = 0; VAR_37 < VAR_28->getLength(); VAR_37++) {
        const char *VAR_38 = VAR_28->getKey(VAR_37);
        if (strcmp(VAR_38, ""Type"") != 0 && strcmp(VAR_38, ""Catalog"") != 0 && strcmp(VAR_38, ""Pages"") != 0) {
            if (VAR_37 > 0) {
                VAR_3->printf("" "");
            }
            Object VAR_39 = VAR_28->getValNF(VAR_37).copy();
            VAR_3->printf(""/%s "", VAR_38);
            writeObject(&VAR_39, VAR_3, getXRef(), 0, nullptr, VAR_40, 0, 0, 0);
        }
    }
    VAR_3->printf("">>\nendobj\n"");

    VAR_4->add(VAR_8 + 1, 0, VAR_3->getPos(), true);
    VAR_3->printf(""%d 0 obj\n"", VAR_8 + 1);
    VAR_3->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", VAR_8 + 2);
    if (VAR_32.isDict()) {
        VAR_3->printf(""/Resources "");
        writeObject(&VAR_32, VAR_3, getXRef(), 0, nullptr, VAR_40, 0, 0, 0);
    }
    VAR_3->printf("">>\n"");
    VAR_3->printf(""endobj\n"");

    VAR_4->add(VAR_8 + 2, 0, VAR_3->getPos(), true);
    VAR_3->printf(""%d 0 obj\n"", VAR_8 + 2);
    VAR_3->printf(""<< "");
    for (int VAR_41 = 0; VAR_41 < VAR_34->getLength(); VAR_41++) {
        if (VAR_41 > 0) {
            VAR_3->printf("" "");
        }
        const char *VAR_38 = VAR_34->getKey(VAR_41);
        Object VAR_39 = VAR_34->getValNF(VAR_41).copy();
        if (strcmp(VAR_38, ""Parent"") == 0) {
            VAR_3->printf(""/Parent %d 0 R"", VAR_8 + 1);
        } else {
            VAR_3->printf(""/%s "", VAR_38);
            writeObject(&VAR_39, VAR_3, getXRef(), 0, nullptr, VAR_40, 0, 0, 0);
        }
    }
    VAR_3->printf("" >>\nendobj\n"");

    Goffset VAR_42 = VAR_3->getPos();
    Ref VAR_24;
    VAR_24.num = VAR_8;
    VAR_24.gen = 0;
    Object VAR_23 = createTrailerDict(VAR_8 + 3, false, 0, &VAR_24, getXRef(), VAR_0.c_str(), VAR_42);
    writeXRefTableTrailer(std::move(VAR_23), VAR_4, false /* COMMENT_4 */, VAR_42, VAR_3, getXRef());

    VAR_3->close();
    fclose(VAR_2);
    delete VAR_4;
    delete VAR_5;
    delete VAR_3;

    return VAR_43;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -88,7 +88,14 @@
     if (resourcesObj.isDict()) {
         markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2);
     }
-    markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2);
+    if (!markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2)) {
+        fclose(f);
+        delete yRef;
+        delete countRef;
+        delete outStr;
+        error(errSyntaxError, -1, ""markPageObjects failed"");
+        return errDamaged;
+    }
 
     Dict *pageDict = page.getDict();
     if (resourcesObj.isNull() && !pageDict->hasKey(""Resources"")) {","{'deleted_lines': ['    markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2);'], 'added_lines': ['    if (!markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2)) {', '        fclose(f);', '        delete yRef;', '        delete countRef;', '        delete outStr;', '        error(errSyntaxError, -1, ""markPageObjects failed"");', '        return errDamaged;', '    }']}",True,A reachable Object::getString assertion in Poppler 22.07.0 allows attackers to cause a denial of service due to a failure in markObject.,6.5,MEDIUM,1,valid,,5
CVE-2022-37052,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,"Fixes #1278
",8677500399fc2548fa816b619580c2c07915a98c,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8677500399fc2548fa816b619580c2c07915a98c,poppler/PDFDoc.cc,PDFDoc::markPageObjects,"void PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
pageDict->remove(""OpenAction"");
pageDict->remove(""Outlines"");
pageDict->remove(""StructTreeRoot"");
for (int n = 0; n < pageDict->getLength(); n++) {
const char *key = pageDict->getKey(n);
Object value = pageDict->getValNF(n).copy();
if (strcmp(key, ""Parent"") != 0 && strcmp(key, ""Pages"") != 0 && strcmp(key, ""AcroForm"") != 0 && strcmp(key, ""Annots"") != 0 && strcmp(key, ""P"") != 0 && strcmp(key, ""Root"") != 0) {
markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
}
}
}","void PDFDoc::markPageObjects(Dict *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
VAR_0->remove(""OpenAction"");
VAR_0->remove(""Outlines"");
VAR_0->remove(""StructTreeRoot"");
for (int VAR_7 = 0; VAR_7 < VAR_0->getLength(); VAR_7++) {
const char *VAR_8 = VAR_0->getKey(VAR_7);
Object VAR_9 = VAR_0->getValNF(VAR_7).copy();
if (strcmp(VAR_8, ""Parent"") != 0 && strcmp(VAR_8, ""Pages"") != 0 && strcmp(VAR_8, ""AcroForm"") != 0 && strcmp(VAR_8, ""Annots"") != 0 && strcmp(VAR_8, ""P"") != 0 && strcmp(VAR_8, ""Root"") != 0) {
markObject(&VAR_9, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
}
}
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/before/3.json,"bool PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
{
    pageDict->remove(""OpenAction"");
    pageDict->remove(""Outlines"");
    pageDict->remove(""StructTreeRoot"");

    for (int n = 0; n < pageDict->getLength(); n++) {
        const char *key = pageDict->getKey(n);
        Object value = pageDict->getValNF(n).copy();
        if (strcmp(key, ""Parent"") != 0 && strcmp(key, ""Pages"") != 0 && strcmp(key, ""AcroForm"") != 0 && strcmp(key, ""Annots"") != 0 && strcmp(key, ""P"") != 0 && strcmp(key, ""Root"") != 0) {
            const bool success = markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
            if (unlikely(!success)) {
                return false;
            }
        }
    }
    return true;
}","bool PDFDoc::markPageObjects(Dict *VAR_0, XRef *VAR_1, XRef *VAR_2, unsigned int VAR_3, int VAR_4, int VAR_5, std::set<Dict *> *VAR_6)
{
    VAR_0->remove(""OpenAction"");
    VAR_0->remove(""Outlines"");
    VAR_0->remove(""StructTreeRoot"");

    for (int VAR_7 = 0; VAR_7 < VAR_0->getLength(); VAR_7++) {
        const char *VAR_8 = VAR_0->getKey(VAR_7);
        Object VAR_9 = VAR_0->getValNF(VAR_7).copy();
        if (strcmp(VAR_8, ""Parent"") != 0 && strcmp(VAR_8, ""Pages"") != 0 && strcmp(VAR_8, ""AcroForm"") != 0 && strcmp(VAR_8, ""Annots"") != 0 && strcmp(VAR_8, ""P"") != 0 && strcmp(VAR_8, ""Root"") != 0) {
            const bool VAR_10 = markObject(&VAR_9, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);
            if (unlikely(!VAR_10)) {
                return false;
            }
        }
    }
    return true;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/PDFDoc.cc/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
+bool PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)
 {
     pageDict->remove(""OpenAction"");
     pageDict->remove(""Outlines"");
@@ -8,7 +8,11 @@
         const char *key = pageDict->getKey(n);
         Object value = pageDict->getValNF(n).copy();
         if (strcmp(key, ""Parent"") != 0 && strcmp(key, ""Pages"") != 0 && strcmp(key, ""AcroForm"") != 0 && strcmp(key, ""Annots"") != 0 && strcmp(key, ""P"") != 0 && strcmp(key, ""Root"") != 0) {
-            markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            const bool success = markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);
+            if (unlikely(!success)) {
+                return false;
+            }
         }
     }
+    return true;
 }","{'deleted_lines': ['void PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '            markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);'], 'added_lines': ['bool PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts)', '            const bool success = markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);', '            if (unlikely(!success)) {', '                return false;', '            }', '    return true;']}",True,A reachable Object::getString assertion in Poppler 22.07.0 allows attackers to cause a denial of service due to a failure in markObject.,6.5,MEDIUM,1,valid,,5
CVE-2022-37052,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,"Fixes #1278
",8677500399fc2548fa816b619580c2c07915a98c,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8677500399fc2548fa816b619580c2c07915a98c,poppler/XRef.cc,XRef::add,"void XRef::add(int num, int gen, Goffset offs, bool used)
{
xrefLocker();
if (num >= size) {
if (num >= capacity) {
entries = (XRefEntry *)greallocn(entries, num + 1, sizeof(XRefEntry));
capacity = num + 1;
}
for (int i = size; i < num + 1; ++i) {
entries[i].offset = -1;
entries[i].type = xrefEntryFree;
new (&entries[i].obj) Object(objNull);
entries[i].flags = 0;
entries[i].gen = 0;
}
size = num + 1;
}
XRefEntry *e = getEntry(num);
e->gen = gen;
e->obj.setToNull();
e->flags = 0;
if (used) {
e->type = xrefEntryUncompressed;
e->offset = offs;
} else {
e->type = xrefEntryFree;
e->offset = 0;
}
}","void XRef::add(int VAR_0, int VAR_1, Goffset VAR_2, bool VAR_3)
{
xrefLocker();
if (VAR_0 >= VAR_4) {
if (VAR_0 >= VAR_5) {
VAR_6 = (XRefEntry *)greallocn(VAR_6, VAR_0 + 1, sizeof(XRefEntry));
VAR_5 = VAR_0 + 1;
}
for (int VAR_7 = VAR_4; VAR_7 < VAR_0 + 1; ++VAR_7) {
VAR_6[VAR_7].offset = -1;
VAR_6[VAR_7].type = VAR_8;
new (&VAR_6[VAR_7].obj) Object(VAR_9);
VAR_6[VAR_7].flags = 0;
VAR_6[VAR_7].gen = 0;
}
VAR_4 = VAR_0 + 1;
}
XRefEntry *VAR_10 = getEntry(VAR_0);
VAR_10->gen = VAR_1;
VAR_10->obj.setToNull();
VAR_10->flags = 0;
if (VAR_3) {
VAR_10->type = VAR_11;
VAR_10->offset = VAR_2;
} else {
VAR_10->type = VAR_8;
VAR_10->offset = 0;
}
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/XRef.cc/vul/before/0.json,"bool XRef::add(int num, int gen, Goffset offs, bool used)
{
    xrefLocker();
    if (num >= size) {
        if (num >= capacity) {
            entries = (XRefEntry *)greallocn_checkoverflow(entries, num + 1, sizeof(XRefEntry));
            if (unlikely(entries == nullptr)) {
                size = 0;
                capacity = 0;
                return false;
            }

            capacity = num + 1;
        }
        for (int i = size; i < num + 1; ++i) {
            entries[i].offset = -1;
            entries[i].type = xrefEntryFree;
            new (&entries[i].obj) Object(objNull);
            entries[i].flags = 0;
            entries[i].gen = 0;
        }
        size = num + 1;
    }
    XRefEntry *e = getEntry(num);
    e->gen = gen;
    e->obj.setToNull();
    e->flags = 0;
    if (used) {
        e->type = xrefEntryUncompressed;
        e->offset = offs;
    } else {
        e->type = xrefEntryFree;
        e->offset = 0;
    }
    return true;
}","bool XRef::add(int VAR_0, int VAR_1, Goffset VAR_2, bool VAR_3)
{
    xrefLocker();
    if (VAR_0 >= VAR_4) {
        if (VAR_0 >= VAR_5) {
            VAR_6 = (XRefEntry *)greallocn_checkoverflow(VAR_6, VAR_0 + 1, sizeof(XRefEntry));
            if (unlikely(VAR_6 == nullptr)) {
                VAR_4 = 0;
                VAR_5 = 0;
                return false;
            }

            VAR_5 = VAR_0 + 1;
        }
        for (int VAR_7 = VAR_4; VAR_7 < VAR_0 + 1; ++VAR_7) {
            VAR_6[VAR_7].offset = -1;
            VAR_6[VAR_7].type = VAR_8;
            new (&VAR_6[VAR_7].obj) Object(VAR_9);
            VAR_6[VAR_7].flags = 0;
            VAR_6[VAR_7].gen = 0;
        }
        VAR_4 = VAR_0 + 1;
    }
    XRefEntry *VAR_10 = getEntry(VAR_0);
    VAR_10->gen = VAR_1;
    VAR_10->obj.setToNull();
    VAR_10->flags = 0;
    if (VAR_3) {
        VAR_10->type = VAR_11;
        VAR_10->offset = VAR_2;
    } else {
        VAR_10->type = VAR_8;
        VAR_10->offset = 0;
    }
    return true;
}",poppler/8677500399fc2548fa816b619580c2c07915a98c/XRef.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,15 @@
-void XRef::add(int num, int gen, Goffset offs, bool used)
+bool XRef::add(int num, int gen, Goffset offs, bool used)
 {
     xrefLocker();
     if (num >= size) {
         if (num >= capacity) {
-            entries = (XRefEntry *)greallocn(entries, num + 1, sizeof(XRefEntry));
+            entries = (XRefEntry *)greallocn_checkoverflow(entries, num + 1, sizeof(XRefEntry));
+            if (unlikely(entries == nullptr)) {
+                size = 0;
+                capacity = 0;
+                return false;
+            }
+
             capacity = num + 1;
         }
         for (int i = size; i < num + 1; ++i) {
@@ -26,4 +32,5 @@
         e->type = xrefEntryFree;
         e->offset = 0;
     }
+    return true;
 }","{'deleted_lines': ['void XRef::add(int num, int gen, Goffset offs, bool used)', '            entries = (XRefEntry *)greallocn(entries, num + 1, sizeof(XRefEntry));'], 'added_lines': ['bool XRef::add(int num, int gen, Goffset offs, bool used)', '            entries = (XRefEntry *)greallocn_checkoverflow(entries, num + 1, sizeof(XRefEntry));', '            if (unlikely(entries == nullptr)) {', '                size = 0;', '                capacity = 0;', '                return false;', '            }', '', '    return true;']}",True,A reachable Object::getString assertion in Poppler 22.07.0 allows attackers to cause a denial of service due to a failure in markObject.,6.5,MEDIUM,1,valid,,5
CVE-2022-38349,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,,4564a002bcb6094cc460bc0d5ddff9423fe6dd28,https://cgit.freedesktop.org/poppler/poppler/commit/?id=4564a002bcb6094cc460bc0d5ddff9423fe6dd28,poppler/PDFDoc.cc,PDFDoc::replacePageDict,"void PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)
{
Ref *refPage = getCatalog()->getPageRef(pageNo);
Object page = getXRef()->fetch(*refPage);
Dict *pageDict = page.getDict();
pageDict->remove(""MediaBoxssdf"");
pageDict->remove(""MediaBox"");
pageDict->remove(""CropBox"");
pageDict->remove(""ArtBox"");
pageDict->remove(""BleedBox"");
pageDict->remove(""TrimBox"");
pageDict->remove(""Rotate"");
Array *mediaBoxArray = new Array(getXRef());
mediaBoxArray->add(Object(mediaBox->x1));
mediaBoxArray->add(Object(mediaBox->y1));
mediaBoxArray->add(Object(mediaBox->x2));
mediaBoxArray->add(Object(mediaBox->y2));
Object mediaBoxObject(mediaBoxArray);
Object trimBoxObject = mediaBoxObject.copy();
pageDict->add(""MediaBox"", std::move(mediaBoxObject));
if (cropBox != nullptr) {
Array *cropBoxArray = new Array(getXRef());
cropBoxArray->add(Object(cropBox->x1));
cropBoxArray->add(Object(cropBox->y1));
cropBoxArray->add(Object(cropBox->x2));
cropBoxArray->add(Object(cropBox->y2));
Object cropBoxObject(cropBoxArray);
trimBoxObject = cropBoxObject.copy();
pageDict->add(""CropBox"", std::move(cropBoxObject));
}
pageDict->add(""TrimBox"", std::move(trimBoxObject));
pageDict->add(""Rotate"", Object(rotate));
getXRef()->setModifiedObject(&page, *refPage);
}","void PDFDoc::replacePageDict(int VAR_0, int VAR_1, const PDFRectangle *VAR_2, const PDFRectangle *VAR_3)
{
Ref *VAR_4 = getCatalog()->getPageRef(VAR_0);
Object VAR_5 = getXRef()->fetch(*VAR_4);
Dict *VAR_6 = VAR_5.getDict();
VAR_6->remove(""MediaBoxssdf"");
VAR_6->remove(""MediaBox"");
VAR_6->remove(""CropBox"");
VAR_6->remove(""ArtBox"");
VAR_6->remove(""BleedBox"");
VAR_6->remove(""TrimBox"");
VAR_6->remove(""Rotate"");
Array *VAR_7 = new Array(getXRef());
VAR_7->add(Object(VAR_2->x1));
VAR_7->add(Object(VAR_2->y1));
VAR_7->add(Object(VAR_2->x2));
VAR_7->add(Object(VAR_2->y2));
Object mediaBoxObject(mediaBoxArray);
Object VAR_8 = VAR_9.copy();
VAR_6->add(""MediaBox"", std::move(VAR_9));
if (VAR_3 != nullptr) {
Array *VAR_10 = new Array(getXRef());
VAR_10->add(Object(VAR_3->x1));
VAR_10->add(Object(VAR_3->y1));
VAR_10->add(Object(VAR_3->x2));
VAR_10->add(Object(VAR_3->y2));
Object cropBoxObject(cropBoxArray);
VAR_8 = VAR_11.copy();
VAR_6->add(""CropBox"", std::move(VAR_11));
}
VAR_6->add(""TrimBox"", std::move(VAR_8));
VAR_6->add(""Rotate"", Object(VAR_1));
getXRef()->setModifiedObject(&VAR_5, *VAR_4);
}",poppler/4564a002bcb6094cc460bc0d5ddff9423fe6dd28/PDFDoc.cc/vul/before/0.json,"bool PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)
{
    Ref *refPage = getCatalog()->getPageRef(pageNo);
    Object page = getXRef()->fetch(*refPage);
    if (!page.isDict()) {
        return false;
    }
    Dict *pageDict = page.getDict();
    pageDict->remove(""MediaBoxssdf"");
    pageDict->remove(""MediaBox"");
    pageDict->remove(""CropBox"");
    pageDict->remove(""ArtBox"");
    pageDict->remove(""BleedBox"");
    pageDict->remove(""TrimBox"");
    pageDict->remove(""Rotate"");
    Array *mediaBoxArray = new Array(getXRef());
    mediaBoxArray->add(Object(mediaBox->x1));
    mediaBoxArray->add(Object(mediaBox->y1));
    mediaBoxArray->add(Object(mediaBox->x2));
    mediaBoxArray->add(Object(mediaBox->y2));
    Object mediaBoxObject(mediaBoxArray);
    Object trimBoxObject = mediaBoxObject.copy();
    pageDict->add(""MediaBox"", std::move(mediaBoxObject));
    if (cropBox != nullptr) {
        Array *cropBoxArray = new Array(getXRef());
        cropBoxArray->add(Object(cropBox->x1));
        cropBoxArray->add(Object(cropBox->y1));
        cropBoxArray->add(Object(cropBox->x2));
        cropBoxArray->add(Object(cropBox->y2));
        Object cropBoxObject(cropBoxArray);
        trimBoxObject = cropBoxObject.copy();
        pageDict->add(""CropBox"", std::move(cropBoxObject));
    }
    pageDict->add(""TrimBox"", std::move(trimBoxObject));
    pageDict->add(""Rotate"", Object(rotate));
    getXRef()->setModifiedObject(&page, *refPage);
    return true;
}","bool PDFDoc::replacePageDict(int VAR_0, int VAR_1, const PDFRectangle *VAR_2, const PDFRectangle *VAR_3)
{
    Ref *VAR_4 = getCatalog()->getPageRef(VAR_0);
    Object VAR_5 = getXRef()->fetch(*VAR_4);
    if (!VAR_5.isDict()) {
        return false;
    }
    Dict *VAR_6 = VAR_5.getDict();
    VAR_6->remove(""MediaBoxssdf"");
    VAR_6->remove(""MediaBox"");
    VAR_6->remove(""CropBox"");
    VAR_6->remove(""ArtBox"");
    VAR_6->remove(""BleedBox"");
    VAR_6->remove(""TrimBox"");
    VAR_6->remove(""Rotate"");
    Array *VAR_7 = new Array(getXRef());
    VAR_7->add(Object(VAR_2->x1));
    VAR_7->add(Object(VAR_2->y1));
    VAR_7->add(Object(VAR_2->x2));
    VAR_7->add(Object(VAR_2->y2));
    Object mediaBoxObject(mediaBoxArray);
    Object VAR_8 = VAR_9.copy();
    VAR_6->add(""MediaBox"", std::move(VAR_9));
    if (VAR_3 != nullptr) {
        Array *VAR_10 = new Array(getXRef());
        VAR_10->add(Object(VAR_3->x1));
        VAR_10->add(Object(VAR_3->y1));
        VAR_10->add(Object(VAR_3->x2));
        VAR_10->add(Object(VAR_3->y2));
        Object cropBoxObject(cropBoxArray);
        VAR_8 = VAR_11.copy();
        VAR_6->add(""CropBox"", std::move(VAR_11));
    }
    VAR_6->add(""TrimBox"", std::move(VAR_8));
    VAR_6->add(""Rotate"", Object(VAR_1));
    getXRef()->setModifiedObject(&VAR_5, *VAR_4);
    return true;
}",poppler/4564a002bcb6094cc460bc0d5ddff9423fe6dd28/PDFDoc.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,10 @@
-void PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)
+bool PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)
 {
     Ref *refPage = getCatalog()->getPageRef(pageNo);
     Object page = getXRef()->fetch(*refPage);
+    if (!page.isDict()) {
+        return false;
+    }
     Dict *pageDict = page.getDict();
     pageDict->remove(""MediaBoxssdf"");
     pageDict->remove(""MediaBox"");
@@ -31,4 +34,5 @@
     pageDict->add(""TrimBox"", std::move(trimBoxObject));
     pageDict->add(""Rotate"", Object(rotate));
     getXRef()->setModifiedObject(&page, *refPage);
+    return true;
 }","{'deleted_lines': ['void PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)'], 'added_lines': ['bool PDFDoc::replacePageDict(int pageNo, int rotate, const PDFRectangle *mediaBox, const PDFRectangle *cropBox)', '    if (!page.isDict()) {', '        return false;', '    }', '    return true;']}",True,"An issue was discovered in Poppler 22.08.0. There is a reachable assertion in Object.h, will lead to denial of service because PDFDoc::replacePageDict in PDFDoc.cc lacks a stream check before saving an embedded file.",6.5,MEDIUM,1,valid,,5
CVE-2022-38349,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,poppler,,4564a002bcb6094cc460bc0d5ddff9423fe6dd28,https://cgit.freedesktop.org/poppler/poppler/commit/?id=4564a002bcb6094cc460bc0d5ddff9423fe6dd28,utils/pdfunite.cc,main,"int main(int argc, char *argv[])
{
int objectsCount = 0;
unsigned int numOffset = 0;
std::vector<Object> pages;
std::vector<unsigned int> offsets;
XRef *yRef, *countRef;
FILE *f;
OutStream *outStr;
int i;
int j, rootNum;
std::vector<PDFDoc *> docs;
int majorVersion = 0;
int minorVersion = 0;
char *fileName = argv[argc - 1];
const bool ok = parseArgs(argDesc, &argc, argv);
if (!ok || argc < 3 || printVersion || printHelp) {
fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION);
fprintf(stderr, ""%s\n"", popplerCopyright);
fprintf(stderr, ""%s\n"", xpdfCopyright);
if (!printVersion) {
printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", argDesc);
}
if (printVersion || printHelp) {
return 0;
}
return 99;
}
globalParams = std::make_unique<GlobalParams>();
for (i = 1; i < argc - 1; i++) {
PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));
if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {
docs.push_back(doc);
if (doc->getPDFMajorVersion() > majorVersion) {
majorVersion = doc->getPDFMajorVersion();
minorVersion = doc->getPDFMinorVersion();
} else if (doc->getPDFMajorVersion() == majorVersion) {
if (doc->getPDFMinorVersion() > minorVersion) {
minorVersion = doc->getPDFMinorVersion();
}
}
} else if (doc->isOk()) {
if (doc->isEncrypted()) {
error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]);
return -1;
} else if (!doc->getXRef()->getCatalog().isDict()) {
error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary ('{0:s}')"", argv[i]);
return -1;
}
} else {
error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]);
return -1;
}
}
if (!(f = fopen(fileName, ""wb""))) {
error(errIO, -1, ""Could not open file '{0:s}'"", fileName);
return -1;
}
outStr = new FileOutStream(f, 0);
yRef = new XRef();
countRef = new XRef();
yRef->add(0, 65535, 0, false);
PDFDoc::writeHeader(outStr, majorVersion, minorVersion);
Object intents;
Object names;
Object afObj;
Object ocObj;
if (docs.size() >= 1) {
Object catObj = docs[0]->getXRef()->getCatalog();
if (!catObj.isDict()) {
fclose(f);
delete yRef;
delete countRef;
delete outStr;
error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary."");
return -1;
}
Dict *catDict = catObj.getDict();
intents = catDict->lookup(""OutputIntents"");
afObj = catDict->lookupNF(""AcroForm"").copy();
Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
if (!afObj.isNull() && refPage) {
docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
}
ocObj = catDict->lookupNF(""OCProperties"").copy();
if (!ocObj.isNull() && ocObj.isDict() && refPage) {
docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
}
names = catDict->lookup(""Names"");
if (!names.isNull() && names.isDict() && refPage) {
docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
}
if (intents.isArray() && intents.arrayGetLength() > 0) {
for (i = 1; i < (int)docs.size(); i++) {
Object pagecatObj = docs[i]->getXRef()->getCatalog();
Dict *pagecatDict = pagecatObj.getDict();
Object pageintents = pagecatDict->lookup(""OutputIntents"");
if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {
for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
Object intent = intents.arrayGet(j, 0);
if (intent.isDict()) {
Object idf = intent.dictLookup(""OutputConditionIdentifier"");
if (idf.isString()) {
const GooString *gidf = idf.getString();
bool removeIntent = true;
for (int k = 0; k < pageintents.arrayGetLength(); k++) {
Object pgintent = pageintents.arrayGet(k, 0);
if (pgintent.isDict()) {
Object pgidf = pgintent.dictLookup(""OutputConditionIdentifier"");
if (pgidf.isString()) {
const GooString *gpgidf = pgidf.getString();
if (gpgidf->cmp(gidf) == 0) {
removeIntent = false;
break;
}
}
}
}
if (removeIntent) {
intents.arrayRemove(j);
error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", gidf->c_str(), docs[i]->getFileName()->c_str());
}
} else {
intents.arrayRemove(j);
error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
}
} else {
intents.arrayRemove(j);
}
}
} else {
error(errSyntaxWarning, -1, ""Output intents differs, remove them all"");
break;
}
}
}
if (intents.isArray() && intents.arrayGetLength() > 0) {
for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
Object intent = intents.arrayGet(j, 0);
if (intent.isDict()) {
docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);
} else {
intents.arrayRemove(j);
}
}
}
}
for (i = 0; i < (int)docs.size(); i++) {
for (j = 1; j <= docs[i]->getNumPages(); j++) {
if (!docs[i]->getCatalog()->getPage(j)) {
continue;
}
const PDFRectangle *cropBox = nullptr;
if (docs[i]->getCatalog()->getPage(j)->isCropped()) {
cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
}
docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);
Ref *refPage = docs[i]->getCatalog()->getPageRef(j);
Object page = docs[i]->getXRef()->fetch(*refPage);
Dict *pageDict = page.getDict();
Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();
if (resDict->isDict()) {
pageDict->set(""Resources"", resDict->copy());
}
pages.push_back(std::move(page));
offsets.push_back(numOffset);
docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);
Object annotsObj = pageDict->lookupNF(""Annots"").copy();
if (!annotsObj.isNull()) {
docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);
}
}
Object pageCatObj = docs[i]->getXRef()->getCatalog();
if (!pageCatObj.isDict()) {
fclose(f);
delete yRef;
delete countRef;
delete outStr;
error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary."");
return -1;
}
Dict *pageCatDict = pageCatObj.getDict();
Object pageNames = pageCatDict->lookup(""Names"");
if (!pageNames.isNull() && pageNames.isDict()) {
if (!names.isDict()) {
names = Object(new Dict(yRef));
}
doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);
}
Object pageForm = pageCatDict->lookup(""AcroForm"");
if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {
if (afObj.isNull()) {
afObj = pageCatDict->lookupNF(""AcroForm"").copy();
} else if (afObj.isDict()) {
doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);
}
}
objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);
numOffset = yRef->getNumObjects() + 1;
}
rootNum = yRef->getNumObjects() + 1;
yRef->add(rootNum, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum);
outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
if (intents.isArray() && intents.arrayGetLength() > 0) {
outStr->printf("" /OutputIntents ["");
for (j = 0; j < intents.arrayGetLength(); j++) {
Object intent = intents.arrayGet(j, 0);
if (intent.isDict()) {
PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
}
}
outStr->printf(""]"");
}
if (!afObj.isNull()) {
outStr->printf("" /AcroForm "");
PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
}
if (!ocObj.isNull() && ocObj.isDict()) {
outStr->printf("" /OCProperties "");
PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
}
if (!names.isNull() && names.isDict()) {
outStr->printf("" /Names "");
PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
}
outStr->printf("">>\nendobj\n"");
objectsCount++;
yRef->add(rootNum + 1, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum + 1);
outStr->printf(""<< /Type /Pages /Kids ["");
for (j = 0; j < (int)pages.size(); j++) {
outStr->printf("" %d 0 R"", rootNum + j + 2);
}
outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size());
objectsCount++;
for (i = 0; i < (int)pages.size(); i++) {
yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);
outStr->printf(""%d 0 obj\n"", rootNum + i + 2);
outStr->printf(""<< "");
Dict *pageDict = pages[i].getDict();
for (j = 0; j < pageDict->getLength(); j++) {
if (j > 0) {
outStr->printf("" "");
}
const char *key = pageDict->getKey(j);
Object value = pageDict->getValNF(j).copy();
if (strcmp(key, ""Parent"") == 0) {
outStr->printf(""/Parent %d 0 R"", rootNum + 1);
} else {
outStr->printf(""/%s "", key);
PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);
}
}
outStr->printf("" >>\nendobj\n"");
objectsCount++;
}
Goffset uxrefOffset = outStr->getPos();
Ref ref;
ref.num = rootNum;
ref.gen = 0;
Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());
PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true,                                                                                                         uxrefOffset, outStr, yRef);
outStr->close();
delete outStr;
fclose(f);
delete yRef;
delete countRef;
for (i = 0; i < (int)docs.size(); i++) {
delete docs[i];
}
return 0;
}","int main(int VAR_0, char *VAR_1[])
{
int VAR_2 = 0;
unsigned int VAR_3 = 0;
std::vector<Object> VAR_4;
std::vector<unsigned int> VAR_5;
XRef *VAR_6, *VAR_7;
FILE *VAR_8;
OutStream *VAR_9;
int VAR_10;
int VAR_11, VAR_12;
std::vector<PDFDoc *> VAR_13;
int VAR_14 = 0;
int VAR_15 = 0;
char *VAR_16 = VAR_1[VAR_0 - 1];
const bool VAR_17 = parseArgs(VAR_18, &VAR_0, VAR_1);
if (!VAR_17 || VAR_0 < 3 || VAR_19 || VAR_20) {
fprintf(VAR_21, ""pdfunite version %s\n"", VAR_22);
fprintf(VAR_21, ""%s\n"", VAR_23);
fprintf(VAR_21, ""%s\n"", VAR_24);
if (!VAR_19) {
printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", VAR_18);
}
if (VAR_19 || VAR_20) {
return 0;
}
return 99;
}
VAR_25 = std::VAR_26<GlobalParams>();
for (VAR_10 = 1; VAR_10 < VAR_0 - 1; VAR_10++) {
PDFDoc *VAR_27 = new PDFDoc(std::VAR_26<GooString>(VAR_1[VAR_10]));
if (VAR_27->isOk() && !VAR_27->isEncrypted() && VAR_27->getXRef()->getCatalog().isDict()) {
VAR_13.push_back(VAR_27);
if (VAR_27->getPDFMajorVersion() > VAR_14) {
VAR_14 = VAR_27->getPDFMajorVersion();
VAR_15 = VAR_27->getPDFMinorVersion();
} else if (VAR_27->getPDFMajorVersion() == VAR_14) {
if (VAR_27->getPDFMinorVersion() > VAR_15) {
VAR_15 = VAR_27->getPDFMinorVersion();
}
}
} else if (VAR_27->isOk()) {
if (VAR_27->isEncrypted()) {
error(VAR_28, -1, ""Could not merge encrypted files ('{0:s}')"", VAR_1[VAR_10]);
return -1;
} else if (!VAR_27->getXRef()->getCatalog().isDict()) {
error(VAR_29, -1, ""XRef's Catalog is not a dictionary ('{0:s}')"", VAR_1[VAR_10]);
return -1;
}
} else {
error(VAR_29, -1, ""Could not merge damaged documents ('{0:s}')"", VAR_1[VAR_10]);
return -1;
}
}
if (!(VAR_8 = fopen(VAR_16, ""wb""))) {
error(VAR_30, -1, ""Could not open file '{0:s}'"", VAR_16);
return -1;
}
VAR_9 = new FileOutStream(VAR_8, 0);
VAR_6 = new XRef();
VAR_7 = new XRef();
VAR_6->add(0, 65535, 0, false);
PDFDoc::writeHeader(VAR_9, VAR_14, VAR_15);
Object VAR_31;
Object VAR_32;
Object VAR_33;
Object VAR_34;
if (VAR_13.size() >= 1) {
Object VAR_35 = VAR_13[0]->getXRef()->getCatalog();
if (!VAR_35.isDict()) {
fclose(VAR_8);
delete VAR_6;
delete VAR_7;
delete VAR_9;
error(VAR_29, -1, ""XRef's Catalog is not a dictionary."");
return -1;
}
Dict *VAR_36 = VAR_35.getDict();
VAR_31 = VAR_36->lookup(""OutputIntents"");
VAR_33 = VAR_36->lookupNF(""AcroForm"").copy();
Ref *VAR_37 = VAR_13[0]->getCatalog()->getPageRef(1);
if (!VAR_33.isNull() && VAR_37) {
VAR_13[0]->markAcroForm(&VAR_33, VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
}
VAR_34 = VAR_36->lookupNF(""OCProperties"").copy();
if (!VAR_34.isNull() && VAR_34.isDict() && VAR_37) {
VAR_13[0]->markPageObjects(VAR_34.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
}
VAR_32 = VAR_36->lookup(""Names"");
if (!VAR_32.isNull() && VAR_32.isDict() && VAR_37) {
VAR_13[0]->markPageObjects(VAR_32.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
}
if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
for (VAR_10 = 1; VAR_10 < (int)VAR_13.size(); VAR_10++) {
Object VAR_38 = VAR_13[VAR_10]->getXRef()->getCatalog();
Dict *VAR_39 = VAR_38.getDict();
Object VAR_40 = VAR_39->lookup(""OutputIntents"");
if (VAR_40.isArray() && VAR_40.arrayGetLength() > 0) {
for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {
Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
if (VAR_41.isDict()) {
Object VAR_42 = VAR_41.dictLookup(""OutputConditionIdentifier"");
if (VAR_42.isString()) {
const GooString *VAR_43 = VAR_42.getString();
bool VAR_44 = true;
for (int VAR_45 = 0; VAR_45 < VAR_40.arrayGetLength(); VAR_45++) {
Object VAR_46 = VAR_40.arrayGet(VAR_45, 0);
if (VAR_46.isDict()) {
Object VAR_47 = VAR_46.dictLookup(""OutputConditionIdentifier"");
if (VAR_47.isString()) {
const GooString *VAR_48 = VAR_47.getString();
if (VAR_48->cmp(VAR_43) == 0) {
VAR_44 = false;
break;
}
}
}
}
if (VAR_44) {
VAR_31.arrayRemove(VAR_11);
error(VAR_49, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", VAR_43->c_str(), VAR_13[VAR_10]->getFileName()->c_str());
}
} else {
VAR_31.arrayRemove(VAR_11);
error(VAR_49, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
}
} else {
VAR_31.arrayRemove(VAR_11);
}
}
} else {
error(VAR_49, -1, ""Output intents differs, remove them all"");
break;
}
}
}
if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {
Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
if (VAR_41.isDict()) {
VAR_13[0]->markPageObjects(VAR_41.getDict(), VAR_6, VAR_7, VAR_3, 0, 0);
} else {
VAR_31.arrayRemove(VAR_11);
}
}
}
}
for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {
for (VAR_11 = 1; VAR_11 <= VAR_13[VAR_10]->getNumPages(); VAR_11++) {
if (!VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)) {
continue;
}
const PDFRectangle *VAR_50 = nullptr;
if (VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->isCropped()) {
VAR_50 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getCropBox();
}
VAR_13[VAR_10]->replacePageDict(VAR_11, VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getRotate(), VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getMediaBox(), VAR_50);
Ref *VAR_37 = VAR_13[VAR_10]->getCatalog()->getPageRef(VAR_11);
Object VAR_51 = VAR_13[VAR_10]->getXRef()->fetch(*VAR_37);
Dict *VAR_52 = VAR_51.getDict();
Object *VAR_53 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getResourceDictObject();
if (VAR_53->isDict()) {
VAR_52->set(""Resources"", VAR_53->copy());
}
VAR_4.push_back(std::move(VAR_51));
VAR_5.push_back(VAR_3);
VAR_13[VAR_10]->markPageObjects(VAR_52, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);
Object VAR_54 = VAR_52->lookupNF(""Annots"").copy();
if (!VAR_54.isNull()) {
VAR_13[VAR_10]->markAnnotations(&VAR_54, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);
}
}
Object VAR_55 = VAR_13[VAR_10]->getXRef()->getCatalog();
if (!VAR_55.isDict()) {
fclose(VAR_8);
delete VAR_6;
delete VAR_7;
delete VAR_9;
error(VAR_29, -1, ""XRef's Catalog is not a dictionary."");
return -1;
}
Dict *VAR_56 = VAR_55.getDict();
Object VAR_57 = VAR_56->lookup(""Names"");
if (!VAR_57.isNull() && VAR_57.isDict()) {
if (!VAR_32.isDict()) {
VAR_32 = Object(new Dict(VAR_6));
}
doMergeNameDict(VAR_13[VAR_10], VAR_6, VAR_7, 0, 0, VAR_32.getDict(), VAR_57.getDict(), VAR_3);
}
Object VAR_58 = VAR_56->lookup(""AcroForm"");
if (VAR_10 > 0 && !VAR_58.isNull() && VAR_58.isDict()) {
if (VAR_33.isNull()) {
VAR_33 = VAR_56->lookupNF(""AcroForm"").copy();
} else if (VAR_33.isDict()) {
doMergeFormDict(VAR_33.getDict(), VAR_58.getDict(), VAR_3);
}
}
VAR_2 += VAR_13[VAR_10]->writePageObjects(VAR_9, VAR_6, VAR_3, true);
VAR_3 = VAR_6->getNumObjects() + 1;
}
VAR_12 = VAR_6->getNumObjects() + 1;
VAR_6->add(VAR_12, 0, VAR_9->getPos(), true);
VAR_9->printf(""%d 0 obj\n"", VAR_12);
VAR_9->printf(""<< /Type /Catalog /Pages %d 0 R"", VAR_12 + 1);
if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
VAR_9->printf("" /OutputIntents ["");
for (VAR_11 = 0; VAR_11 < VAR_31.arrayGetLength(); VAR_11++) {
Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
if (VAR_41.isDict()) {
PDFDoc::writeObject(&VAR_41, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
}
}
VAR_9->printf(""]"");
}
if (!VAR_33.isNull()) {
VAR_9->printf("" /AcroForm "");
PDFDoc::writeObject(&VAR_33, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
}
if (!VAR_34.isNull() && VAR_34.isDict()) {
VAR_9->printf("" /OCProperties "");
PDFDoc::writeObject(&VAR_34, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
}
if (!VAR_32.isNull() && VAR_32.isDict()) {
VAR_9->printf("" /Names "");
PDFDoc::writeObject(&VAR_32, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
}
VAR_9->printf("">>\nendobj\n"");
VAR_2++;
VAR_6->add(VAR_12 + 1, 0, VAR_9->getPos(), true);
VAR_9->printf(""%d 0 obj\n"", VAR_12 + 1);
VAR_9->printf(""<< /Type /Pages /Kids ["");
for (VAR_11 = 0; VAR_11 < (int)VAR_4.size(); VAR_11++) {
VAR_9->printf("" %d 0 R"", VAR_12 + VAR_11 + 2);
}
VAR_9->printf("" ] /Count %zd >>\nendobj\n"", VAR_4.size());
VAR_2++;
for (VAR_10 = 0; VAR_10 < (int)VAR_4.size(); VAR_10++) {
VAR_6->add(VAR_12 + VAR_10 + 2, 0, VAR_9->getPos(), true);
VAR_9->printf(""%d 0 obj\n"", VAR_12 + VAR_10 + 2);
VAR_9->printf(""<< "");
Dict *VAR_52 = VAR_4[VAR_10].getDict();
for (VAR_11 = 0; VAR_11 < VAR_52->getLength(); VAR_11++) {
if (VAR_11 > 0) {
VAR_9->printf("" "");
}
const char *VAR_60 = VAR_52->getKey(VAR_11);
Object VAR_61 = VAR_52->getValNF(VAR_11).copy();
if (strcmp(VAR_60, ""Parent"") == 0) {
VAR_9->printf(""/Parent %d 0 R"", VAR_12 + 1);
} else {
VAR_9->printf(""/%s "", VAR_60);
PDFDoc::writeObject(&VAR_61, VAR_9, VAR_6, VAR_5[VAR_10], nullptr, VAR_59, 0, 0, 0);
}
}
VAR_9->printf("" >>\nendobj\n"");
VAR_2++;
}
Goffset VAR_62 = VAR_9->getPos();
Ref VAR_63;
VAR_63.num = VAR_12;
VAR_63.gen = 0;
Object VAR_64 = PDFDoc::createTrailerDict(VAR_2, false, 0, &VAR_63, VAR_6, VAR_16, VAR_9->getPos());
PDFDoc::writeXRefTableTrailer(std::move(VAR_64), VAR_6, true, 
VAR_62, VAR_9, VAR_6);
VAR_9->close();
delete VAR_9;
fclose(VAR_8);
delete VAR_6;
delete VAR_7;
for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {
delete VAR_13[VAR_10];
}
return 0;
}",poppler/4564a002bcb6094cc460bc0d5ddff9423fe6dd28/pdfunite.cc/vul/before/0.json,"int main(int argc, char *argv[])
///////////////////////////////////////////////////////////////////////////
// Merge PDF files given by arguments 1 to argc-2 and write the result
// to the file specified by argument argc-1.
///////////////////////////////////////////////////////////////////////////
{
    int objectsCount = 0;
    unsigned int numOffset = 0;
    std::vector<Object> pages;
    std::vector<unsigned int> offsets;
    XRef *yRef, *countRef;
    FILE *f;
    OutStream *outStr;
    int i;
    int j, rootNum;
    std::vector<PDFDoc *> docs;
    int majorVersion = 0;
    int minorVersion = 0;
    char *fileName = argv[argc - 1];

    const bool ok = parseArgs(argDesc, &argc, argv);
    if (!ok || argc < 3 || printVersion || printHelp) {
        fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION);
        fprintf(stderr, ""%s\n"", popplerCopyright);
        fprintf(stderr, ""%s\n"", xpdfCopyright);
        if (!printVersion) {
            printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", argDesc);
        }
        if (printVersion || printHelp) {
            return 0;
        }
        return 99;
    }
    globalParams = std::make_unique<GlobalParams>();

    for (i = 1; i < argc - 1; i++) {
        PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));
        if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {
            docs.push_back(doc);
            if (doc->getPDFMajorVersion() > majorVersion) {
                majorVersion = doc->getPDFMajorVersion();
                minorVersion = doc->getPDFMinorVersion();
            } else if (doc->getPDFMajorVersion() == majorVersion) {
                if (doc->getPDFMinorVersion() > minorVersion) {
                    minorVersion = doc->getPDFMinorVersion();
                }
            }
        } else if (doc->isOk()) {
            if (doc->isEncrypted()) {
                error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]);
                return -1;
            } else if (!doc->getXRef()->getCatalog().isDict()) {
                error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary ('{0:s}')"", argv[i]);
                return -1;
            }
        } else {
            error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]);
            return -1;
        }
    }

    if (!(f = fopen(fileName, ""wb""))) {
        error(errIO, -1, ""Could not open file '{0:s}'"", fileName);
        return -1;
    }
    outStr = new FileOutStream(f, 0);

    yRef = new XRef();
    countRef = new XRef();
    yRef->add(0, 65535, 0, false);
    PDFDoc::writeHeader(outStr, majorVersion, minorVersion);

    // handle OutputIntents, AcroForm, OCProperties & Names
    Object intents;
    Object names;
    Object afObj;
    Object ocObj;
    if (docs.size() >= 1) {
        Object catObj = docs[0]->getXRef()->getCatalog();
        if (!catObj.isDict()) {
            fclose(f);
            delete yRef;
            delete countRef;
            delete outStr;
            error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary."");
            return -1;
        }
        Dict *catDict = catObj.getDict();
        intents = catDict->lookup(""OutputIntents"");
        afObj = catDict->lookupNF(""AcroForm"").copy();
        Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
        if (!afObj.isNull() && refPage) {
            docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
        }
        ocObj = catDict->lookupNF(""OCProperties"").copy();
        if (!ocObj.isNull() && ocObj.isDict() && refPage) {
            docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
        }
        names = catDict->lookup(""Names"");
        if (!names.isNull() && names.isDict() && refPage) {
            docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
        }
        if (intents.isArray() && intents.arrayGetLength() > 0) {
            for (i = 1; i < (int)docs.size(); i++) {
                Object pagecatObj = docs[i]->getXRef()->getCatalog();
                Dict *pagecatDict = pagecatObj.getDict();
                Object pageintents = pagecatDict->lookup(""OutputIntents"");
                if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {
                    for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
                        Object intent = intents.arrayGet(j, 0);
                        if (intent.isDict()) {
                            Object idf = intent.dictLookup(""OutputConditionIdentifier"");
                            if (idf.isString()) {
                                const GooString *gidf = idf.getString();
                                bool removeIntent = true;
                                for (int k = 0; k < pageintents.arrayGetLength(); k++) {
                                    Object pgintent = pageintents.arrayGet(k, 0);
                                    if (pgintent.isDict()) {
                                        Object pgidf = pgintent.dictLookup(""OutputConditionIdentifier"");
                                        if (pgidf.isString()) {
                                            const GooString *gpgidf = pgidf.getString();
                                            if (gpgidf->cmp(gidf) == 0) {
                                                removeIntent = false;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (removeIntent) {
                                    intents.arrayRemove(j);
                                    error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", gidf->c_str(), docs[i]->getFileName()->c_str());
                                }
                            } else {
                                intents.arrayRemove(j);
                                error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
                            }
                        } else {
                            intents.arrayRemove(j);
                        }
                    }
                } else {
                    error(errSyntaxWarning, -1, ""Output intents differs, remove them all"");
                    break;
                }
            }
        }
        if (intents.isArray() && intents.arrayGetLength() > 0) {
            for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
                Object intent = intents.arrayGet(j, 0);
                if (intent.isDict()) {
                    docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);
                } else {
                    intents.arrayRemove(j);
                }
            }
        }
    }

    for (i = 0; i < (int)docs.size(); i++) {
        for (j = 1; j <= docs[i]->getNumPages(); j++) {
            if (!docs[i]->getCatalog()->getPage(j)) {
                continue;
            }

            const PDFRectangle *cropBox = nullptr;
            if (docs[i]->getCatalog()->getPage(j)->isCropped()) {
                cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
            }
            if (!docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox)) {
                fclose(f);
                delete yRef;
                delete countRef;
                delete outStr;
                error(errSyntaxError, -1, ""PDFDoc::replacePageDict failed."");
                return -1;
            }
            Ref *refPage = docs[i]->getCatalog()->getPageRef(j);
            Object page = docs[i]->getXRef()->fetch(*refPage);
            Dict *pageDict = page.getDict();
            Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();
            if (resDict->isDict()) {
                pageDict->set(""Resources"", resDict->copy());
            }
            pages.push_back(std::move(page));
            offsets.push_back(numOffset);
            docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);
            Object annotsObj = pageDict->lookupNF(""Annots"").copy();
            if (!annotsObj.isNull()) {
                docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);
            }
        }
        Object pageCatObj = docs[i]->getXRef()->getCatalog();
        if (!pageCatObj.isDict()) {
            fclose(f);
            delete yRef;
            delete countRef;
            delete outStr;
            error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary."");
            return -1;
        }
        Dict *pageCatDict = pageCatObj.getDict();
        Object pageNames = pageCatDict->lookup(""Names"");
        if (!pageNames.isNull() && pageNames.isDict()) {
            if (!names.isDict()) {
                names = Object(new Dict(yRef));
            }
            doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);
        }
        Object pageForm = pageCatDict->lookup(""AcroForm"");
        if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {
            if (afObj.isNull()) {
                afObj = pageCatDict->lookupNF(""AcroForm"").copy();
            } else if (afObj.isDict()) {
                doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);
            }
        }
        objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);
        numOffset = yRef->getNumObjects() + 1;
    }

    rootNum = yRef->getNumObjects() + 1;
    yRef->add(rootNum, 0, outStr->getPos(), true);
    outStr->printf(""%d 0 obj\n"", rootNum);
    outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
    // insert OutputIntents
    if (intents.isArray() && intents.arrayGetLength() > 0) {
        outStr->printf("" /OutputIntents ["");
        for (j = 0; j < intents.arrayGetLength(); j++) {
            Object intent = intents.arrayGet(j, 0);
            if (intent.isDict()) {
                PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
            }
        }
        outStr->printf(""]"");
    }
    // insert AcroForm
    if (!afObj.isNull()) {
        outStr->printf("" /AcroForm "");
        PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
    }
    // insert OCProperties
    if (!ocObj.isNull() && ocObj.isDict()) {
        outStr->printf("" /OCProperties "");
        PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
    }
    // insert Names
    if (!names.isNull() && names.isDict()) {
        outStr->printf("" /Names "");
        PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);
    }
    outStr->printf("">>\nendobj\n"");
    objectsCount++;

    yRef->add(rootNum + 1, 0, outStr->getPos(), true);
    outStr->printf(""%d 0 obj\n"", rootNum + 1);
    outStr->printf(""<< /Type /Pages /Kids ["");
    for (j = 0; j < (int)pages.size(); j++) {
        outStr->printf("" %d 0 R"", rootNum + j + 2);
    }
    outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size());
    objectsCount++;

    for (i = 0; i < (int)pages.size(); i++) {
        yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);
        outStr->printf(""%d 0 obj\n"", rootNum + i + 2);
        outStr->printf(""<< "");
        Dict *pageDict = pages[i].getDict();
        for (j = 0; j < pageDict->getLength(); j++) {
            if (j > 0) {
                outStr->printf("" "");
            }
            const char *key = pageDict->getKey(j);
            Object value = pageDict->getValNF(j).copy();
            if (strcmp(key, ""Parent"") == 0) {
                outStr->printf(""/Parent %d 0 R"", rootNum + 1);
            } else {
                outStr->printf(""/%s "", key);
                PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);
            }
        }
        outStr->printf("" >>\nendobj\n"");
        objectsCount++;
    }
    Goffset uxrefOffset = outStr->getPos();
    Ref ref;
    ref.num = rootNum;
    ref.gen = 0;
    Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());
    PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: ""For a file that has never been incrementally updated, the cross-reference section shall
                                                                      // contain only one subsection, whose object numbering begins at 0.""
                                  uxrefOffset, outStr, yRef);

    outStr->close();
    delete outStr;
    fclose(f);
    delete yRef;
    delete countRef;
    for (i = 0; i < (int)docs.size(); i++) {
        delete docs[i];
    }
    return 0;
}","int main(int VAR_0, char *VAR_1[])
/* COMMENT_0 */
/* COMMENT_1 */
/* COMMENT_2 */
/* COMMENT_0 */
{
    int VAR_2 = 0;
    unsigned int VAR_3 = 0;
    std::vector<Object> VAR_4;
    std::vector<unsigned int> VAR_5;
    XRef *VAR_6, *VAR_7;
    FILE *VAR_8;
    OutStream *VAR_9;
    int VAR_10;
    int VAR_11, VAR_12;
    std::vector<PDFDoc *> VAR_13;
    int VAR_14 = 0;
    int VAR_15 = 0;
    char *VAR_16 = VAR_1[VAR_0 - 1];

    const bool VAR_17 = parseArgs(VAR_18, &VAR_0, VAR_1);
    if (!VAR_17 || VAR_0 < 3 || VAR_19 || VAR_20) {
        fprintf(VAR_21, ""pdfunite version %s\n"", VAR_22);
        fprintf(VAR_21, ""%s\n"", VAR_23);
        fprintf(VAR_21, ""%s\n"", VAR_24);
        if (!VAR_19) {
            printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", VAR_18);
        }
        if (VAR_19 || VAR_20) {
            return 0;
        }
        return 99;
    }
    VAR_25 = std::VAR_26<GlobalParams>();

    for (VAR_10 = 1; VAR_10 < VAR_0 - 1; VAR_10++) {
        PDFDoc *VAR_27 = new PDFDoc(std::VAR_26<GooString>(VAR_1[VAR_10]));
        if (VAR_27->isOk() && !VAR_27->isEncrypted() && VAR_27->getXRef()->getCatalog().isDict()) {
            VAR_13.push_back(VAR_27);
            if (VAR_27->getPDFMajorVersion() > VAR_14) {
                VAR_14 = VAR_27->getPDFMajorVersion();
                VAR_15 = VAR_27->getPDFMinorVersion();
            } else if (VAR_27->getPDFMajorVersion() == VAR_14) {
                if (VAR_27->getPDFMinorVersion() > VAR_15) {
                    VAR_15 = VAR_27->getPDFMinorVersion();
                }
            }
        } else if (VAR_27->isOk()) {
            if (VAR_27->isEncrypted()) {
                error(VAR_28, -1, ""Could not merge encrypted files ('{0:s}')"", VAR_1[VAR_10]);
                return -1;
            } else if (!VAR_27->getXRef()->getCatalog().isDict()) {
                error(VAR_29, -1, ""XRef's Catalog is not a dictionary ('{0:s}')"", VAR_1[VAR_10]);
                return -1;
            }
        } else {
            error(VAR_29, -1, ""Could not merge damaged documents ('{0:s}')"", VAR_1[VAR_10]);
            return -1;
        }
    }

    if (!(VAR_8 = fopen(VAR_16, ""wb""))) {
        error(VAR_30, -1, ""Could not open file '{0:s}'"", VAR_16);
        return -1;
    }
    VAR_9 = new FileOutStream(VAR_8, 0);

    VAR_6 = new XRef();
    VAR_7 = new XRef();
    VAR_6->add(0, 65535, 0, false);
    PDFDoc::writeHeader(VAR_9, VAR_14, VAR_15);

    /* COMMENT_3 */
    Object VAR_31;
    Object VAR_32;
    Object VAR_33;
    Object VAR_34;
    if (VAR_13.size() >= 1) {
        Object VAR_35 = VAR_13[0]->getXRef()->getCatalog();
        if (!VAR_35.isDict()) {
            fclose(VAR_8);
            delete VAR_6;
            delete VAR_7;
            delete VAR_9;
            error(VAR_29, -1, ""XRef's Catalog is not a dictionary."");
            return -1;
        }
        Dict *VAR_36 = VAR_35.getDict();
        VAR_31 = VAR_36->lookup(""OutputIntents"");
        VAR_33 = VAR_36->lookupNF(""AcroForm"").copy();
        Ref *VAR_37 = VAR_13[0]->getCatalog()->getPageRef(1);
        if (!VAR_33.isNull() && VAR_37) {
            VAR_13[0]->markAcroForm(&VAR_33, VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
        }
        VAR_34 = VAR_36->lookupNF(""OCProperties"").copy();
        if (!VAR_34.isNull() && VAR_34.isDict() && VAR_37) {
            VAR_13[0]->markPageObjects(VAR_34.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
        }
        VAR_32 = VAR_36->lookup(""Names"");
        if (!VAR_32.isNull() && VAR_32.isDict() && VAR_37) {
            VAR_13[0]->markPageObjects(VAR_32.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);
        }
        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
            for (VAR_10 = 1; VAR_10 < (int)VAR_13.size(); VAR_10++) {
                Object VAR_38 = VAR_13[VAR_10]->getXRef()->getCatalog();
                Dict *VAR_39 = VAR_38.getDict();
                Object VAR_40 = VAR_39->lookup(""OutputIntents"");
                if (VAR_40.isArray() && VAR_40.arrayGetLength() > 0) {
                    for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {
                        Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
                        if (VAR_41.isDict()) {
                            Object VAR_42 = VAR_41.dictLookup(""OutputConditionIdentifier"");
                            if (VAR_42.isString()) {
                                const GooString *VAR_43 = VAR_42.getString();
                                bool VAR_44 = true;
                                for (int VAR_45 = 0; VAR_45 < VAR_40.arrayGetLength(); VAR_45++) {
                                    Object VAR_46 = VAR_40.arrayGet(VAR_45, 0);
                                    if (VAR_46.isDict()) {
                                        Object VAR_47 = VAR_46.dictLookup(""OutputConditionIdentifier"");
                                        if (VAR_47.isString()) {
                                            const GooString *VAR_48 = VAR_47.getString();
                                            if (VAR_48->cmp(VAR_43) == 0) {
                                                VAR_44 = false;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (VAR_44) {
                                    VAR_31.arrayRemove(VAR_11);
                                    error(VAR_49, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", VAR_43->c_str(), VAR_13[VAR_10]->getFileName()->c_str());
                                }
                            } else {
                                VAR_31.arrayRemove(VAR_11);
                                error(VAR_49, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
                            }
                        } else {
                            VAR_31.arrayRemove(VAR_11);
                        }
                    }
                } else {
                    error(VAR_49, -1, ""Output intents differs, remove them all"");
                    break;
                }
            }
        }
        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
            for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {
                Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
                if (VAR_41.isDict()) {
                    VAR_13[0]->markPageObjects(VAR_41.getDict(), VAR_6, VAR_7, VAR_3, 0, 0);
                } else {
                    VAR_31.arrayRemove(VAR_11);
                }
            }
        }
    }

    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {
        for (VAR_11 = 1; VAR_11 <= VAR_13[VAR_10]->getNumPages(); VAR_11++) {
            if (!VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)) {
                continue;
            }

            const PDFRectangle *VAR_50 = nullptr;
            if (VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->isCropped()) {
                VAR_50 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getCropBox();
            }
            if (!VAR_13[VAR_10]->replacePageDict(VAR_11, VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getRotate(), VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getMediaBox(), VAR_50)) {
                fclose(VAR_8);
                delete VAR_6;
                delete VAR_7;
                delete VAR_9;
                error(VAR_29, -1, ""PDFDoc::replacePageDict failed."");
                return -1;
            }
            Ref *VAR_37 = VAR_13[VAR_10]->getCatalog()->getPageRef(VAR_11);
            Object VAR_51 = VAR_13[VAR_10]->getXRef()->fetch(*VAR_37);
            Dict *VAR_52 = VAR_51.getDict();
            Object *VAR_53 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getResourceDictObject();
            if (VAR_53->isDict()) {
                VAR_52->set(""Resources"", VAR_53->copy());
            }
            VAR_4.push_back(std::move(VAR_51));
            VAR_5.push_back(VAR_3);
            VAR_13[VAR_10]->markPageObjects(VAR_52, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);
            Object VAR_54 = VAR_52->lookupNF(""Annots"").copy();
            if (!VAR_54.isNull()) {
                VAR_13[VAR_10]->markAnnotations(&VAR_54, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);
            }
        }
        Object VAR_55 = VAR_13[VAR_10]->getXRef()->getCatalog();
        if (!VAR_55.isDict()) {
            fclose(VAR_8);
            delete VAR_6;
            delete VAR_7;
            delete VAR_9;
            error(VAR_29, -1, ""XRef's Catalog is not a dictionary."");
            return -1;
        }
        Dict *VAR_56 = VAR_55.getDict();
        Object VAR_57 = VAR_56->lookup(""Names"");
        if (!VAR_57.isNull() && VAR_57.isDict()) {
            if (!VAR_32.isDict()) {
                VAR_32 = Object(new Dict(VAR_6));
            }
            doMergeNameDict(VAR_13[VAR_10], VAR_6, VAR_7, 0, 0, VAR_32.getDict(), VAR_57.getDict(), VAR_3);
        }
        Object VAR_58 = VAR_56->lookup(""AcroForm"");
        if (VAR_10 > 0 && !VAR_58.isNull() && VAR_58.isDict()) {
            if (VAR_33.isNull()) {
                VAR_33 = VAR_56->lookupNF(""AcroForm"").copy();
            } else if (VAR_33.isDict()) {
                doMergeFormDict(VAR_33.getDict(), VAR_58.getDict(), VAR_3);
            }
        }
        VAR_2 += VAR_13[VAR_10]->writePageObjects(VAR_9, VAR_6, VAR_3, true);
        VAR_3 = VAR_6->getNumObjects() + 1;
    }

    VAR_12 = VAR_6->getNumObjects() + 1;
    VAR_6->add(VAR_12, 0, VAR_9->getPos(), true);
    VAR_9->printf(""%d 0 obj\n"", VAR_12);
    VAR_9->printf(""<< /Type /Catalog /Pages %d 0 R"", VAR_12 + 1);
    /* COMMENT_4 */
    if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {
        VAR_9->printf("" /OutputIntents ["");
        for (VAR_11 = 0; VAR_11 < VAR_31.arrayGetLength(); VAR_11++) {
            Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);
            if (VAR_41.isDict()) {
                PDFDoc::writeObject(&VAR_41, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
            }
        }
        VAR_9->printf(""]"");
    }
    /* COMMENT_5 */
    if (!VAR_33.isNull()) {
        VAR_9->printf("" /AcroForm "");
        PDFDoc::writeObject(&VAR_33, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
    }
    /* COMMENT_6 */
    if (!VAR_34.isNull() && VAR_34.isDict()) {
        VAR_9->printf("" /OCProperties "");
        PDFDoc::writeObject(&VAR_34, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
    }
    /* COMMENT_7 */
    if (!VAR_32.isNull() && VAR_32.isDict()) {
        VAR_9->printf("" /Names "");
        PDFDoc::writeObject(&VAR_32, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);
    }
    VAR_9->printf("">>\nendobj\n"");
    VAR_2++;

    VAR_6->add(VAR_12 + 1, 0, VAR_9->getPos(), true);
    VAR_9->printf(""%d 0 obj\n"", VAR_12 + 1);
    VAR_9->printf(""<< /Type /Pages /Kids ["");
    for (VAR_11 = 0; VAR_11 < (int)VAR_4.size(); VAR_11++) {
        VAR_9->printf("" %d 0 R"", VAR_12 + VAR_11 + 2);
    }
    VAR_9->printf("" ] /Count %zd >>\nendobj\n"", VAR_4.size());
    VAR_2++;

    for (VAR_10 = 0; VAR_10 < (int)VAR_4.size(); VAR_10++) {
        VAR_6->add(VAR_12 + VAR_10 + 2, 0, VAR_9->getPos(), true);
        VAR_9->printf(""%d 0 obj\n"", VAR_12 + VAR_10 + 2);
        VAR_9->printf(""<< "");
        Dict *VAR_52 = VAR_4[VAR_10].getDict();
        for (VAR_11 = 0; VAR_11 < VAR_52->getLength(); VAR_11++) {
            if (VAR_11 > 0) {
                VAR_9->printf("" "");
            }
            const char *VAR_60 = VAR_52->getKey(VAR_11);
            Object VAR_61 = VAR_52->getValNF(VAR_11).copy();
            if (strcmp(VAR_60, ""Parent"") == 0) {
                VAR_9->printf(""/Parent %d 0 R"", VAR_12 + 1);
            } else {
                VAR_9->printf(""/%s "", VAR_60);
                PDFDoc::writeObject(&VAR_61, VAR_9, VAR_6, VAR_5[VAR_10], nullptr, VAR_59, 0, 0, 0);
            }
        }
        VAR_9->printf("" >>\nendobj\n"");
        VAR_2++;
    }
    Goffset VAR_62 = VAR_9->getPos();
    Ref VAR_63;
    VAR_63.num = VAR_12;
    VAR_63.gen = 0;
    Object VAR_64 = PDFDoc::createTrailerDict(VAR_2, false, 0, &VAR_63, VAR_6, VAR_16, VAR_9->getPos());
    PDFDoc::writeXRefTableTrailer(std::move(VAR_64), VAR_6, true, /* COMMENT_8 */
                                                                      /* COMMENT_9 */
                                  VAR_62, VAR_9, VAR_6);

    VAR_9->close();
    delete VAR_9;
    fclose(VAR_8);
    delete VAR_6;
    delete VAR_7;
    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {
        delete VAR_13[VAR_10];
    }
    return 0;
}",poppler/4564a002bcb6094cc460bc0d5ddff9423fe6dd28/pdfunite.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -166,7 +166,14 @@
             if (docs[i]->getCatalog()->getPage(j)->isCropped()) {
                 cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
             }
-            docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);
+            if (!docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox)) {
+                fclose(f);
+                delete yRef;
+                delete countRef;
+                delete outStr;
+                error(errSyntaxError, -1, ""PDFDoc::replacePageDict failed."");
+                return -1;
+            }
             Ref *refPage = docs[i]->getCatalog()->getPageRef(j);
             Object page = docs[i]->getXRef()->fetch(*refPage);
             Dict *pageDict = page.getDict();","{'deleted_lines': ['            docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);'], 'added_lines': ['            if (!docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox)) {', '                fclose(f);', '                delete yRef;', '                delete countRef;', '                delete outStr;', '                error(errSyntaxError, -1, ""PDFDoc::replacePageDict failed."");', '                return -1;', '            }']}",True,"An issue was discovered in Poppler 22.08.0. There is a reachable assertion in Object.h, will lead to denial of service because PDFDoc::replacePageDict in PDFDoc.cc lacks a stream check before saving an embedded file.",6.5,MEDIUM,1,valid,,5
CVE-2022-3106,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"The return value of kmalloc() needs to be checked.
To avoid use in efx_nic_update_stats() in case of the failure of alloc.

Fixes: b593b6f1b492 (""sfc_ef100: statistics gathering"")
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Reported-by: kernel test robot <lkp@intel.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",407ecd1bd726f240123f704620d46e285ff30dd9,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.19-rc2&h=407ecd1bd726f240123f704620d46e285ff30dd9,drivers/net/ethernet/sfc/ef100_nic.c,ef100_update_stats,"static size_t ef100_update_stats(struct efx_nic *efx,
u64 *full_stats,
struct rtnl_link_stats64 *core_stats)
{
__le64 *mc_stats = kmalloc(array_size(efx->num_mac_stats, sizeof(__le64)), GFP_ATOMIC);
struct ef100_nic_data *nic_data = efx->nic_data;
DECLARE_BITMAP(mask, EF100_STAT_COUNT) = {};
u64 *stats = nic_data->stats;
ef100_common_stat_mask(mask);
ef100_ethtool_stat_mask(mask);
efx_nic_copy_stats(efx, mc_stats);
efx_nic_update_stats(ef100_stat_desc, EF100_STAT_COUNT, mask,
stats, mc_stats, false);
kfree(mc_stats);
return ef100_update_stats_common(efx, full_stats, core_stats);
}","static size_t ef100_update_stats(struct efx_nic *VAR_0,
u64 *VAR_1,
struct rtnl_link_stats64 *VAR_2)
{
__le64 *VAR_3 = kmalloc(array_size(VAR_0->num_mac_stats, sizeof(__le64)), VAR_4);
struct ef100_nic_data *VAR_5 = VAR_0->nic_data;
DECLARE_BITMAP(VAR_6, VAR_7) = {};
u64 *VAR_8 = VAR_5->stats;
ef100_common_stat_mask(VAR_6);
ef100_ethtool_stat_mask(VAR_6);
efx_nic_copy_stats(VAR_0, VAR_3);
efx_nic_update_stats(VAR_9, VAR_7, VAR_6,
VAR_8, VAR_3, false);
kfree(VAR_3);
return ef100_update_stats_common(VAR_0, VAR_1, VAR_2);
}",torvalds/linux/407ecd1bd726f240123f704620d46e285ff30dd9/ef100_nic.c/vul/before/0.json,"static size_t ef100_update_stats(struct efx_nic *efx,
				 u64 *full_stats,
				 struct rtnl_link_stats64 *core_stats)
{
	__le64 *mc_stats = kmalloc(array_size(efx->num_mac_stats, sizeof(__le64)), GFP_ATOMIC);
	struct ef100_nic_data *nic_data = efx->nic_data;
	DECLARE_BITMAP(mask, EF100_STAT_COUNT) = {};
	u64 *stats = nic_data->stats;

	ef100_common_stat_mask(mask);
	ef100_ethtool_stat_mask(mask);

	if (!mc_stats)
		return 0;

	efx_nic_copy_stats(efx, mc_stats);
	efx_nic_update_stats(ef100_stat_desc, EF100_STAT_COUNT, mask,
			     stats, mc_stats, false);

	kfree(mc_stats);

	return ef100_update_stats_common(efx, full_stats, core_stats);
}","static size_t ef100_update_stats(struct efx_nic *VAR_0,
				 u64 *VAR_1,
				 struct rtnl_link_stats64 *VAR_2)
{
	__le64 *VAR_3 = kmalloc(array_size(VAR_0->num_mac_stats, sizeof(__le64)), VAR_4);
	struct ef100_nic_data *VAR_5 = VAR_0->nic_data;
	DECLARE_BITMAP(VAR_6, VAR_7) = {};
	u64 *VAR_8 = VAR_5->stats;

	ef100_common_stat_mask(VAR_6);
	ef100_ethtool_stat_mask(VAR_6);

	if (!VAR_3)
		return 0;

	efx_nic_copy_stats(VAR_0, VAR_3);
	efx_nic_update_stats(VAR_9, VAR_7, VAR_6,
			     VAR_8, VAR_3, false);

	kfree(VAR_3);

	return ef100_update_stats_common(VAR_0, VAR_1, VAR_2);
}",torvalds/linux/407ecd1bd726f240123f704620d46e285ff30dd9/ef100_nic.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,9 @@
 	ef100_common_stat_mask(mask);
 	ef100_ethtool_stat_mask(mask);
 
+	if (!mc_stats)
+		return 0;
+
 	efx_nic_copy_stats(efx, mc_stats);
 	efx_nic_update_stats(ef100_stat_desc, EF100_STAT_COUNT, mask,
 			     stats, mc_stats, false);","{'deleted_lines': [], 'added_lines': ['\tif (!mc_stats)', '\t\treturn 0;', '']}",True,An issue was discovered in the Linux kernel through 5.16-rc6. ef100_update_stats in drivers/net/ethernet/sfc/ef100_nic.c lacks check of the return value of kmalloc().,5.5,MEDIUM,1,valid,,5
CVE-2022-3113,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"The return value of devm_kzalloc() needs to be checked.
To avoid use of null pointer in case of thefailure of alloc.

Fixes: 46233e91fa24 (""media: mtk-vcodec: move firmware implementations into their own files"")
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Reviewed-by: Tzung-Bi Shih <tzungbi@google.com>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
",e25a89f743b18c029bfbe5e1663ae0c7190912b0,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.19-rc2&h=e25a89f743b18c029bfbe5e1663ae0c7190912b0,drivers/media/platform/mtk-vcodec/mtk_vcodec_fw_vpu.c,mtk_vcodec_fw_vpu_init,"struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *dev,
enum mtk_vcodec_fw_use fw_use)
{
struct platform_device *fw_pdev;
struct mtk_vcodec_fw *fw;
enum rst_id rst_id;
switch (fw_use) {
case ENCODER:
rst_id = VPU_RST_ENC;
break;
case DECODER:
default:
rst_id = VPU_RST_DEC;
break;
}
fw_pdev = vpu_get_plat_device(dev->plat_dev);
if (!fw_pdev) {
mtk_v4l2_err(""firmware device is not ready"");
return ERR_PTR(-EINVAL);
}
vpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id);
fw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL);
fw->type = VPU;
fw->ops = &mtk_vcodec_vpu_msg;
fw->pdev = fw_pdev;
return fw;
}","struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *VAR_0,
enum mtk_vcodec_fw_use VAR_1)
{
struct platform_device *VAR_2;
struct mtk_vcodec_fw *VAR_3;
enum rst_id rst_id;
switch (VAR_1) {
case VAR_4:
rst_id = VAR_5;
break;
case VAR_6:
default:
rst_id = VAR_7;
break;
}
VAR_2 = vpu_get_plat_device(VAR_0->plat_dev);
if (!VAR_2) {
mtk_v4l2_err(""firmware device is not ready"");
return ERR_PTR(-VAR_8);
}
vpu_wdt_reg_handler(VAR_2, VAR_9, VAR_0, rst_id);
VAR_3 = devm_kzalloc(&VAR_0->plat_dev->dev, sizeof(*VAR_3), VAR_10);
VAR_3->type = VAR_11;
VAR_3->ops = &VAR_12;
VAR_3->pdev = VAR_2;
return VAR_3;
}",torvalds/linux/e25a89f743b18c029bfbe5e1663ae0c7190912b0/mtk_vcodec_fw_vpu.c/vul/before/0.json,"struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *dev,
					     enum mtk_vcodec_fw_use fw_use)
{
	struct platform_device *fw_pdev;
	struct mtk_vcodec_fw *fw;
	enum rst_id rst_id;

	switch (fw_use) {
	case ENCODER:
		rst_id = VPU_RST_ENC;
		break;
	case DECODER:
	default:
		rst_id = VPU_RST_DEC;
		break;
	}

	fw_pdev = vpu_get_plat_device(dev->plat_dev);
	if (!fw_pdev) {
		mtk_v4l2_err(""firmware device is not ready"");
		return ERR_PTR(-EINVAL);
	}
	vpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id);

	fw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL);
	if (!fw)
		return ERR_PTR(-ENOMEM);
	fw->type = VPU;
	fw->ops = &mtk_vcodec_vpu_msg;
	fw->pdev = fw_pdev;

	return fw;
}","struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *VAR_0,
					     enum mtk_vcodec_fw_use VAR_1)
{
	struct platform_device *VAR_2;
	struct mtk_vcodec_fw *VAR_3;
	enum rst_id rst_id;

	switch (VAR_1) {
	case VAR_4:
		rst_id = VAR_5;
		break;
	case VAR_6:
	default:
		rst_id = VAR_7;
		break;
	}

	VAR_2 = vpu_get_plat_device(VAR_0->plat_dev);
	if (!VAR_2) {
		mtk_v4l2_err(""firmware device is not ready"");
		return ERR_PTR(-VAR_8);
	}
	vpu_wdt_reg_handler(VAR_2, VAR_9, VAR_0, rst_id);

	VAR_3 = devm_kzalloc(&VAR_0->plat_dev->dev, sizeof(*VAR_3), VAR_10);
	if (!VAR_3)
		return ERR_PTR(-VAR_11);
	VAR_3->type = VAR_12;
	VAR_3->ops = &VAR_13;
	VAR_3->pdev = VAR_2;

	return VAR_3;
}",torvalds/linux/e25a89f743b18c029bfbe5e1663ae0c7190912b0/mtk_vcodec_fw_vpu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,6 +23,8 @@
 	vpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id);
 
 	fw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL);
+	if (!fw)
+		return ERR_PTR(-ENOMEM);
 	fw->type = VPU;
 	fw->ops = &mtk_vcodec_vpu_msg;
 	fw->pdev = fw_pdev;","{'deleted_lines': [], 'added_lines': ['\tif (!fw)', '\t\treturn ERR_PTR(-ENOMEM);']}",True,An issue was discovered in the Linux kernel through 5.16-rc6. mtk_vcodec_fw_vpu_init in drivers/media/platform/mtk-vcodec/mtk_vcodec_fw_vpu.c lacks check of the return value of devm_kzalloc() and will cause the null pointer dereference.,5.5,MEDIUM,1,valid,,5
CVE-2017-18235,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,exempi,"- In VPXChunk::width() and VPXChunk::height() ensure val isn't 0.
",9e76a7782a54a242f18d609e7ba32bf1c430a5e4,https://cgit.freedesktop.org/exempi/commit/?id=9e76a7782a54a242f18d609e7ba32bf1c430a5e4,XMPFiles/source/FormatSupport/WEBP_Support.cpp,VP8XChunk::width,"void VP8XChunk::width(XMP_Uns32 val)
{
PutLE24(&this->data[4], val - 1);
}","void VP8XChunk::width(XMP_Uns32 VAR_0)
{
PutLE24(&this->data[4], VAR_0 - 1);
}",exempi/9e76a7782a54a242f18d609e7ba32bf1c430a5e4/WEBP_Support.cpp/vul/before/0.json,"void VP8XChunk::width(XMP_Uns32 val)
{
    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);
}","void VP8XChunk::width(XMP_Uns32 VAR_0)
{
    PutLE24(&this->data[4], VAR_0 > 0 ? VAR_0 - 1 : 0);
}",exempi/9e76a7782a54a242f18d609e7ba32bf1c430a5e4/WEBP_Support.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
 void VP8XChunk::width(XMP_Uns32 val)
 {
-    PutLE24(&this->data[4], val - 1);
+    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);
 }","{'deleted_lines': ['    PutLE24(&this->data[4], val - 1);'], 'added_lines': ['    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);']}",True,"An issue was discovered in Exempi before 2.4.3. The VPXChunk class in XMPFiles/source/FormatSupport/WEBP_Support.cpp does not ensure nonzero widths and heights, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted .webp file.",5.5,MEDIUM,1,valid,,5
CVE-2017-18235,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,exempi,"- In VPXChunk::width() and VPXChunk::height() ensure val isn't 0.
",9e76a7782a54a242f18d609e7ba32bf1c430a5e4,https://cgit.freedesktop.org/exempi/commit/?id=9e76a7782a54a242f18d609e7ba32bf1c430a5e4,XMPFiles/source/FormatSupport/WEBP_Support.cpp,VP8XChunk::height,"void VP8XChunk::height(XMP_Uns32 val)
{
PutLE24(&this->data[7], val - 1);
}","void VP8XChunk::height(XMP_Uns32 VAR_0)
{
PutLE24(&this->data[7], VAR_0 - 1);
}",exempi/9e76a7782a54a242f18d609e7ba32bf1c430a5e4/WEBP_Support.cpp/vul/before/1.json,"void VP8XChunk::height(XMP_Uns32 val)
{
    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);
}","void VP8XChunk::height(XMP_Uns32 VAR_0)
{
    PutLE24(&this->data[7], VAR_0 > 0 ? VAR_0 - 1 : 0);
}",exempi/9e76a7782a54a242f18d609e7ba32bf1c430a5e4/WEBP_Support.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
 void VP8XChunk::height(XMP_Uns32 val)
 {
-    PutLE24(&this->data[7], val - 1);
+    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);
 }","{'deleted_lines': ['    PutLE24(&this->data[7], val - 1);'], 'added_lines': ['    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);']}",True,"An issue was discovered in Exempi before 2.4.3. The VPXChunk class in XMPFiles/source/FormatSupport/WEBP_Support.cpp does not ensure nonzero widths and heights, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted .webp file.",5.5,MEDIUM,1,valid,,5
CVE-2018-1094,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,kernel/git/tytso/ext4,"If some metadata block, such as an allocation bitmap, overlaps the
superblock, it's very likely that if the file system is mounted
read/write, the results will not be pretty.  So disallow r/w mounts
for file systems corrupted in this particular way.

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@vger.kernel.org
",18db4b4e6fc31eda838dd1c1296d67dbcb3dc957,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=18db4b4e6fc31eda838dd1c1296d67dbcb3dc957,fs/ext4/super.c,ext4_check_descriptors,"static int ext4_check_descriptors(struct super_block *sb,
ext4_fsblk_t sb_block,
ext4_group_t *first_not_zeroed)
{
struct ext4_sb_info *sbi = EXT4_SB(sb);
ext4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);
ext4_fsblk_t last_block;
ext4_fsblk_t block_bitmap;
ext4_fsblk_t inode_bitmap;
ext4_fsblk_t inode_table;
int flexbg_flag = 0;
ext4_group_t i, grp = sbi->s_groups_count;
if (ext4_has_feature_flex_bg(sb))
flexbg_flag = 1;
ext4_debug(""Checking group descriptors"");
for (i = 0; i < sbi->s_groups_count; i++) {
struct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);
if (i == sbi->s_groups_count - 1 || flexbg_flag)
last_block = ext4_blocks_count(sbi->s_es) - 1;
else
last_block = first_block +
(EXT4_BLOCKS_PER_GROUP(sb) - 1);
if ((grp == sbi->s_groups_count) &&
!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
grp = i;
block_bitmap = ext4_block_bitmap(sb, gdp);
if (block_bitmap == sb_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Block bitmap for group %u overlaps ""
""superblock"", i);
}
if (block_bitmap < first_block || block_bitmap > last_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Block bitmap for group %u not in group ""
""(block %llu)!"", i, block_bitmap);
return 0;
}
inode_bitmap = ext4_inode_bitmap(sb, gdp);
if (inode_bitmap == sb_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Inode bitmap for group %u overlaps ""
""superblock"", i);
}
if (inode_bitmap < first_block || inode_bitmap > last_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Inode bitmap for group %u not in group ""
""(block %llu)!"", i, inode_bitmap);
return 0;
}
inode_table = ext4_inode_table(sb, gdp);
if (inode_table == sb_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Inode table for group %u overlaps ""
""superblock"", i);
}
if (inode_table < first_block ||
inode_table + sbi->s_itb_per_group - 1 > last_block) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Inode table for group %u not in group ""
""(block %llu)!"", i, inode_table);
return 0;
}
ext4_lock_group(sb, i);
if (!ext4_group_desc_csum_verify(sb, i, gdp)) {
ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
""Checksum for group %u failed (%u!=%u)"",
i, le16_to_cpu(ext4_group_desc_csum(sb, i,
gdp)), le16_to_cpu(gdp->bg_checksum));
if (!sb_rdonly(sb)) {
ext4_unlock_group(sb, i);
return 0;
}
}
ext4_unlock_group(sb, i);
if (!flexbg_flag)
first_block += EXT4_BLOCKS_PER_GROUP(sb);
}
if (NULL != first_not_zeroed)
*first_not_zeroed = grp;
return 1;
}","static int ext4_check_descriptors(struct super_block *VAR_0,
ext4_fsblk_t VAR_1,
ext4_group_t *VAR_2)
{
struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
ext4_fsblk_t VAR_4 = le32_to_cpu(VAR_3->s_es->s_first_data_block);
ext4_fsblk_t VAR_5;
ext4_fsblk_t VAR_6;
ext4_fsblk_t VAR_7;
ext4_fsblk_t VAR_8;
int VAR_9 = 0;
ext4_group_t VAR_10, VAR_11 = VAR_3->s_groups_count;
if (ext4_has_feature_flex_bg(VAR_0))
VAR_9 = 1;
ext4_debug(""Checking group descriptors"");
for (VAR_10 = 0; VAR_10 < VAR_3->s_groups_count; VAR_10++) {
struct ext4_group_desc *VAR_12 = ext4_get_group_desc(VAR_0, VAR_10, NULL);
if (VAR_10 == VAR_3->s_groups_count - 1 || VAR_9)
VAR_5 = ext4_blocks_count(VAR_3->s_es) - 1;
else
VAR_5 = VAR_4 +
(EXT4_BLOCKS_PER_GROUP(VAR_0) - 1);
if ((VAR_11 == VAR_3->s_groups_count) &&
!(VAR_12->bg_flags & cpu_to_le16(VAR_13)))
VAR_11 = VAR_10;
VAR_6 = ext4_block_bitmap(VAR_0, VAR_12);
if (VAR_6 == VAR_1) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Block bitmap for group %u overlaps ""
""superblock"", VAR_10);
}
if (VAR_6 < VAR_4 || VAR_6 > VAR_5) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Block bitmap for group %u not in group ""
""(block %llu)!"", VAR_10, VAR_6);
return 0;
}
VAR_7 = ext4_inode_bitmap(VAR_0, VAR_12);
if (VAR_7 == VAR_1) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Inode bitmap for group %u overlaps ""
""superblock"", VAR_10);
}
if (VAR_7 < VAR_4 || VAR_7 > VAR_5) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Inode bitmap for group %u not in group ""
""(block %llu)!"", VAR_10, VAR_7);
return 0;
}
VAR_8 = ext4_inode_table(VAR_0, VAR_12);
if (VAR_8 == VAR_1) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Inode table for group %u overlaps ""
""superblock"", VAR_10);
}
if (VAR_8 < VAR_4 ||
VAR_8 + VAR_3->s_itb_per_group - 1 > VAR_5) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Inode table for group %u not in group ""
""(block %llu)!"", VAR_10, VAR_8);
return 0;
}
ext4_lock_group(VAR_0, VAR_10);
if (!ext4_group_desc_csum_verify(VAR_0, VAR_10, VAR_12)) {
ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
""Checksum for group %u failed (%u!=%u)"",
VAR_10, le16_to_cpu(ext4_group_desc_csum(VAR_0, VAR_10,
VAR_12)), le16_to_cpu(VAR_12->bg_checksum));
if (!sb_rdonly(VAR_0)) {
ext4_unlock_group(VAR_0, VAR_10);
return 0;
}
}
ext4_unlock_group(VAR_0, VAR_10);
if (!VAR_9)
VAR_4 += EXT4_BLOCKS_PER_GROUP(VAR_0);
}
if (NULL != VAR_2)
*VAR_2 = VAR_11;
return 1;
}",kernel/git/tytso/ext4/18db4b4e6fc31eda838dd1c1296d67dbcb3dc957/super.c/vul/before/0.json,"static int ext4_check_descriptors(struct super_block *sb,
				  ext4_fsblk_t sb_block,
				  ext4_group_t *first_not_zeroed)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);
	ext4_fsblk_t last_block;
	ext4_fsblk_t block_bitmap;
	ext4_fsblk_t inode_bitmap;
	ext4_fsblk_t inode_table;
	int flexbg_flag = 0;
	ext4_group_t i, grp = sbi->s_groups_count;

	if (ext4_has_feature_flex_bg(sb))
		flexbg_flag = 1;

	ext4_debug(""Checking group descriptors"");

	for (i = 0; i < sbi->s_groups_count; i++) {
		struct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);

		if (i == sbi->s_groups_count - 1 || flexbg_flag)
			last_block = ext4_blocks_count(sbi->s_es) - 1;
		else
			last_block = first_block +
				(EXT4_BLOCKS_PER_GROUP(sb) - 1);

		if ((grp == sbi->s_groups_count) &&
		   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
			grp = i;

		block_bitmap = ext4_block_bitmap(sb, gdp);
		if (block_bitmap == sb_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
				 ""Block bitmap for group %u overlaps ""
				 ""superblock"", i);
			if (!sb_rdonly(sb))
				return 0;
		}
		if (block_bitmap < first_block || block_bitmap > last_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
			       ""Block bitmap for group %u not in group ""
			       ""(block %llu)!"", i, block_bitmap);
			return 0;
		}
		inode_bitmap = ext4_inode_bitmap(sb, gdp);
		if (inode_bitmap == sb_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
				 ""Inode bitmap for group %u overlaps ""
				 ""superblock"", i);
			if (!sb_rdonly(sb))
				return 0;
		}
		if (inode_bitmap < first_block || inode_bitmap > last_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
			       ""Inode bitmap for group %u not in group ""
			       ""(block %llu)!"", i, inode_bitmap);
			return 0;
		}
		inode_table = ext4_inode_table(sb, gdp);
		if (inode_table == sb_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
				 ""Inode table for group %u overlaps ""
				 ""superblock"", i);
			if (!sb_rdonly(sb))
				return 0;
		}
		if (inode_table < first_block ||
		    inode_table + sbi->s_itb_per_group - 1 > last_block) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
			       ""Inode table for group %u not in group ""
			       ""(block %llu)!"", i, inode_table);
			return 0;
		}
		ext4_lock_group(sb, i);
		if (!ext4_group_desc_csum_verify(sb, i, gdp)) {
			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
				 ""Checksum for group %u failed (%u!=%u)"",
				 i, le16_to_cpu(ext4_group_desc_csum(sb, i,
				     gdp)), le16_to_cpu(gdp->bg_checksum));
			if (!sb_rdonly(sb)) {
				ext4_unlock_group(sb, i);
				return 0;
			}
		}
		ext4_unlock_group(sb, i);
		if (!flexbg_flag)
			first_block += EXT4_BLOCKS_PER_GROUP(sb);
	}
	if (NULL != first_not_zeroed)
		*first_not_zeroed = grp;
	return 1;
}","static int ext4_check_descriptors(struct super_block *VAR_0,
				  ext4_fsblk_t VAR_1,
				  ext4_group_t *VAR_2)
{
	struct ext4_sb_info *VAR_3 = EXT4_SB(VAR_0);
	ext4_fsblk_t VAR_4 = le32_to_cpu(VAR_3->s_es->s_first_data_block);
	ext4_fsblk_t VAR_5;
	ext4_fsblk_t VAR_6;
	ext4_fsblk_t VAR_7;
	ext4_fsblk_t VAR_8;
	int VAR_9 = 0;
	ext4_group_t VAR_10, VAR_11 = VAR_3->s_groups_count;

	if (ext4_has_feature_flex_bg(VAR_0))
		VAR_9 = 1;

	ext4_debug(""Checking group descriptors"");

	for (VAR_10 = 0; VAR_10 < VAR_3->s_groups_count; VAR_10++) {
		struct ext4_group_desc *VAR_12 = ext4_get_group_desc(VAR_0, VAR_10, NULL);

		if (VAR_10 == VAR_3->s_groups_count - 1 || VAR_9)
			VAR_5 = ext4_blocks_count(VAR_3->s_es) - 1;
		else
			VAR_5 = VAR_4 +
				(EXT4_BLOCKS_PER_GROUP(VAR_0) - 1);

		if ((VAR_11 == VAR_3->s_groups_count) &&
		   !(VAR_12->bg_flags & cpu_to_le16(VAR_13)))
			VAR_11 = VAR_10;

		VAR_6 = ext4_block_bitmap(VAR_0, VAR_12);
		if (VAR_6 == VAR_1) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
				 ""Block bitmap for group %u overlaps ""
				 ""superblock"", VAR_10);
			if (!sb_rdonly(VAR_0))
				return 0;
		}
		if (VAR_6 < VAR_4 || VAR_6 > VAR_5) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
			       ""Block bitmap for group %u not in group ""
			       ""(block %llu)!"", VAR_10, VAR_6);
			return 0;
		}
		VAR_7 = ext4_inode_bitmap(VAR_0, VAR_12);
		if (VAR_7 == VAR_1) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
				 ""Inode bitmap for group %u overlaps ""
				 ""superblock"", VAR_10);
			if (!sb_rdonly(VAR_0))
				return 0;
		}
		if (VAR_7 < VAR_4 || VAR_7 > VAR_5) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
			       ""Inode bitmap for group %u not in group ""
			       ""(block %llu)!"", VAR_10, VAR_7);
			return 0;
		}
		VAR_8 = ext4_inode_table(VAR_0, VAR_12);
		if (VAR_8 == VAR_1) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
				 ""Inode table for group %u overlaps ""
				 ""superblock"", VAR_10);
			if (!sb_rdonly(VAR_0))
				return 0;
		}
		if (VAR_8 < VAR_4 ||
		    VAR_8 + VAR_3->s_itb_per_group - 1 > VAR_5) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
			       ""Inode table for group %u not in group ""
			       ""(block %llu)!"", VAR_10, VAR_8);
			return 0;
		}
		ext4_lock_group(VAR_0, VAR_10);
		if (!ext4_group_desc_csum_verify(VAR_0, VAR_10, VAR_12)) {
			ext4_msg(VAR_0, VAR_14, ""ext4_check_descriptors: ""
				 ""Checksum for group %u failed (%u!=%u)"",
				 VAR_10, le16_to_cpu(ext4_group_desc_csum(VAR_0, VAR_10,
				     VAR_12)), le16_to_cpu(VAR_12->bg_checksum));
			if (!sb_rdonly(VAR_0)) {
				ext4_unlock_group(VAR_0, VAR_10);
				return 0;
			}
		}
		ext4_unlock_group(VAR_0, VAR_10);
		if (!VAR_9)
			VAR_4 += EXT4_BLOCKS_PER_GROUP(VAR_0);
	}
	if (NULL != VAR_2)
		*VAR_2 = VAR_11;
	return 1;
}",kernel/git/tytso/ext4/18db4b4e6fc31eda838dd1c1296d67dbcb3dc957/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,6 +34,8 @@
 			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
 				 ""Block bitmap for group %u overlaps ""
 				 ""superblock"", i);
+			if (!sb_rdonly(sb))
+				return 0;
 		}
 		if (block_bitmap < first_block || block_bitmap > last_block) {
 			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
@@ -46,6 +48,8 @@
 			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
 				 ""Inode bitmap for group %u overlaps ""
 				 ""superblock"", i);
+			if (!sb_rdonly(sb))
+				return 0;
 		}
 		if (inode_bitmap < first_block || inode_bitmap > last_block) {
 			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
@@ -58,6 +62,8 @@
 			ext4_msg(sb, KERN_ERR, ""ext4_check_descriptors: ""
 				 ""Inode table for group %u overlaps ""
 				 ""superblock"", i);
+			if (!sb_rdonly(sb))
+				return 0;
 		}
 		if (inode_table < first_block ||
 		    inode_table + sbi->s_itb_per_group - 1 > last_block) {","{'deleted_lines': [], 'added_lines': ['\t\t\tif (!sb_rdonly(sb))', '\t\t\t\treturn 0;', '\t\t\tif (!sb_rdonly(sb))', '\t\t\t\treturn 0;', '\t\t\tif (!sb_rdonly(sb))', '\t\t\t\treturn 0;']}",True,"The ext4_fill_super function in fs/ext4/super.c in the Linux kernel through 4.15.15 does not always initialize the crc32c checksum driver, which allows attackers to cause a denial of service (ext4_xattr_inode_hash NULL pointer dereference and system crash) via a crafted ext4 image.",5.5,MEDIUM,1,valid,,5
CVE-2022-2380,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,kernel/git/deller/linux-fbdev,"Zheyu Ma reported this crash in the sm712fb driver when reading
three bytes from the framebuffer:

 BUG: unable to handle page fault for address: ffffc90001ffffff
 RIP: 0010:smtcfb_read+0x230/0x3e0
 Call Trace:
  vfs_read+0x198/0xa00
  ? do_sys_openat2+0x27d/0x350
  ? __fget_light+0x54/0x340
  ksys_read+0xce/0x190
  do_syscall_64+0x43/0x90

Fix it by removing the open-coded endianess fixup-code and
by moving the pointer post decrement out the fb_readl() function.

Reported-by: Zheyu Ma <zheyuma97@gmail.com>
Signed-off-by: Helge Deller <deller@gmx.de>
Tested-by: Zheyu Ma <zheyuma97@gmail.com>
Cc: stable@vger.kernel.org
",bd771cf5c4254511cc4abb88f3dab3bd58bdf8e8,https://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev.git/commit/?h=for-next&h=bd771cf5c4254511cc4abb88f3dab3bd58bdf8e8,drivers/video/fbdev/sm712fb.c,smtcfb_read,"static ssize_t smtcfb_read(struct fb_info *info, char __user *buf,
size_t count, loff_t *ppos)
{
unsigned long p = *ppos;
u32 *buffer, *dst;
u32 __iomem *src;
int c, i, cnt = 0, err = 0;
unsigned long total_size;
if (!info || !info->screen_base)
return -ENODEV;
if (info->state != FBINFO_STATE_RUNNING)
return -EPERM;
total_size = info->screen_size;
if (total_size == 0)
total_size = info->fix.smem_len;
if (p >= total_size)
return 0;
if (count >= total_size)
count = total_size;
if (count + p > total_size)
count = total_size - p;
buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
if (!buffer)
return -ENOMEM;
src = (u32 __iomem *)(info->screen_base + p);
if (info->fbops->fb_sync)
info->fbops->fb_sync(info);
while (count) {
c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
dst = buffer;
for (i = c >> 2; i--;) {
*dst = fb_readl(src++);
*dst = big_swap(*dst);
dst++;
}
if (c & 3) {
u8 *dst8 = (u8 *)dst;
u8 __iomem *src8 = (u8 __iomem *)src;
for (i = c & 3; i--;) {
if (i & 1) {
*dst8++ = fb_readb(++src8);
} else {
*dst8++ = fb_readb(--src8);
src8 += 2;
}
}
src = (u32 __iomem *)src8;
}
if (copy_to_user(buf, buffer, c)) {
err = -EFAULT;
break;
}
*ppos += c;
buf += c;
cnt += c;
count -= c;
}
kfree(buffer);
return (err) ? err : cnt;
}","static ssize_t smtcfb_read(struct fb_info *VAR_0, char __user *VAR_1,
size_t VAR_2, loff_t *VAR_3)
{
unsigned long VAR_4 = *VAR_3;
u32 *VAR_5, *VAR_6;
u32 VAR_7 *VAR_8;
int VAR_9, VAR_10, VAR_11 = 0, VAR_12 = 0;
unsigned long VAR_13;
if (!VAR_0 || !VAR_0->screen_base)
return -VAR_14;
if (VAR_0->state != VAR_15)
return -VAR_16;
VAR_13 = VAR_0->screen_size;
if (VAR_13 == 0)
VAR_13 = VAR_0->fix.smem_len;
if (VAR_4 >= VAR_13)
return 0;
if (VAR_2 >= VAR_13)
VAR_2 = VAR_13;
if (VAR_2 + VAR_4 > VAR_13)
VAR_2 = VAR_13 - VAR_4;
VAR_5 = kmalloc((VAR_2 > VAR_17) ? VAR_17 : VAR_2, VAR_18);
if (!VAR_5)
return -VAR_19;
VAR_8 = (u32 __iomem *)(VAR_0->screen_base + VAR_4);
if (VAR_0->fbops->fb_sync)
VAR_0->fbops->fb_sync(VAR_0);
while (VAR_2) {
VAR_9 = (VAR_2 > VAR_17) ? VAR_17 : VAR_2;
VAR_6 = VAR_5;
for (VAR_10 = VAR_9 >> 2; VAR_10--;) {
*VAR_6 = fb_readl(VAR_8++);
*VAR_6 = big_swap(*VAR_6);
VAR_6++;
}
if (VAR_9 & 3) {
u8 *VAR_20 = (u8 *)VAR_6;
u8 __iomem *VAR_21 = (u8 __iomem *)VAR_8;
for (VAR_10 = VAR_9 & 3; VAR_10--;) {
if (VAR_10 & 1) {
*VAR_20++ = fb_readb(++VAR_21);
} else {
*VAR_20++ = fb_readb(--VAR_21);
VAR_21 += 2;
}
}
VAR_8 = (u32 __iomem *)VAR_21;
}
if (copy_to_user(VAR_1, VAR_5, VAR_9)) {
VAR_12 = -VAR_22;
break;
}
*VAR_3 += VAR_9;
VAR_1 += VAR_9;
VAR_11 += VAR_9;
VAR_2 -= VAR_9;
}
kfree(VAR_5);
return (VAR_12) ? VAR_12 : VAR_11;
}",,"static ssize_t smtcfb_read(struct fb_info *info, char __user *buf,
			   size_t count, loff_t *ppos)
{
	unsigned long p = *ppos;

	u32 *buffer, *dst;
	u32 __iomem *src;
	int c, i, cnt = 0, err = 0;
	unsigned long total_size;

	if (!info || !info->screen_base)
		return -ENODEV;

	if (info->state != FBINFO_STATE_RUNNING)
		return -EPERM;

	total_size = info->screen_size;

	if (total_size == 0)
		total_size = info->fix.smem_len;

	if (p >= total_size)
		return 0;

	if (count >= total_size)
		count = total_size;

	if (count + p > total_size)
		count = total_size - p;

	buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!buffer)
		return -ENOMEM;

	src = (u32 __iomem *)(info->screen_base + p);

	if (info->fbops->fb_sync)
		info->fbops->fb_sync(info);

	while (count) {
		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
		dst = buffer;
		for (i = (c + 3) >> 2; i--;) {
			u32 val;

			val = fb_readl(src);
			*dst = big_swap(val);
			src++;
			dst++;
		}

		if (copy_to_user(buf, buffer, c)) {
			err = -EFAULT;
			break;
		}
		*ppos += c;
		buf += c;
		cnt += c;
		count -= c;
	}

	kfree(buffer);

	return (err) ? err : cnt;
}","static ssize_t smtcfb_read(struct fb_info *VAR_0, char __user *VAR_1,
			   size_t VAR_2, loff_t *VAR_3)
{
	unsigned long VAR_4 = *VAR_3;

	u32 *VAR_5, *VAR_6;
	u32 VAR_7 *VAR_8;
	int VAR_9, VAR_10, VAR_11 = 0, VAR_12 = 0;
	unsigned long VAR_13;

	if (!VAR_0 || !VAR_0->screen_base)
		return -VAR_14;

	if (VAR_0->state != VAR_15)
		return -VAR_16;

	VAR_13 = VAR_0->screen_size;

	if (VAR_13 == 0)
		VAR_13 = VAR_0->fix.smem_len;

	if (VAR_4 >= VAR_13)
		return 0;

	if (VAR_2 >= VAR_13)
		VAR_2 = VAR_13;

	if (VAR_2 + VAR_4 > VAR_13)
		VAR_2 = VAR_13 - VAR_4;

	VAR_5 = kmalloc(VAR_17, VAR_18);
	if (!VAR_5)
		return -VAR_19;

	VAR_8 = (u32 __iomem *)(VAR_0->screen_base + VAR_4);

	if (VAR_0->fbops->fb_sync)
		VAR_0->fbops->fb_sync(VAR_0);

	while (VAR_2) {
		VAR_9 = (VAR_2 > VAR_17) ? VAR_17 : VAR_2;
		VAR_6 = VAR_5;
		for (VAR_10 = (VAR_9 + 3) >> 2; VAR_10--;) {
			u32 VAR_20;

			VAR_20 = fb_readl(VAR_8);
			*VAR_6 = big_swap(VAR_20);
			VAR_8++;
			VAR_6++;
		}

		if (copy_to_user(VAR_1, VAR_5, VAR_9)) {
			VAR_12 = -VAR_21;
			break;
		}
		*VAR_3 += VAR_9;
		VAR_1 += VAR_9;
		VAR_11 += VAR_9;
		VAR_2 -= VAR_9;
	}

	kfree(VAR_5);

	return (VAR_12) ? VAR_12 : VAR_11;
}",,"--- func_before
+++ func_after
@@ -28,7 +28,7 @@
 	if (count + p > total_size)
 		count = total_size - p;
 
-	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
+	buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!buffer)
 		return -ENOMEM;
 
@@ -40,24 +40,13 @@
 	while (count) {
 		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
 		dst = buffer;
-		for (i = c >> 2; i--;) {
-			*dst = fb_readl(src++);
-			*dst = big_swap(*dst);
+		for (i = (c + 3) >> 2; i--;) {
+			u32 val;
+
+			val = fb_readl(src);
+			*dst = big_swap(val);
+			src++;
 			dst++;
-		}
-		if (c & 3) {
-			u8 *dst8 = (u8 *)dst;
-			u8 __iomem *src8 = (u8 __iomem *)src;
-
-			for (i = c & 3; i--;) {
-				if (i & 1) {
-					*dst8++ = fb_readb(++src8);
-				} else {
-					*dst8++ = fb_readb(--src8);
-					src8 += 2;
-				}
-			}
-			src = (u32 __iomem *)src8;
 		}
 
 		if (copy_to_user(buf, buffer, c)) {","{'deleted_lines': ['\tbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);', '\t\tfor (i = c >> 2; i--;) {', '\t\t\t*dst = fb_readl(src++);', '\t\t\t*dst = big_swap(*dst);', '\t\t}', '\t\tif (c & 3) {', '\t\t\tu8 *dst8 = (u8 *)dst;', '\t\t\tu8 __iomem *src8 = (u8 __iomem *)src;', '', '\t\t\tfor (i = c & 3; i--;) {', '\t\t\t\tif (i & 1) {', '\t\t\t\t\t*dst8++ = fb_readb(++src8);', '\t\t\t\t} else {', '\t\t\t\t\t*dst8++ = fb_readb(--src8);', '\t\t\t\t\tsrc8 += 2;', '\t\t\t\t}', '\t\t\t}', '\t\t\tsrc = (u32 __iomem *)src8;'], 'added_lines': ['\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);', '\t\tfor (i = (c + 3) >> 2; i--;) {', '\t\t\tu32 val;', '', '\t\t\tval = fb_readl(src);', '\t\t\t*dst = big_swap(val);', '\t\t\tsrc++;']}",True,The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.,5.5,MEDIUM,1,valid,,5
CVE-2022-1920,"['CWE-190', 'CWE-787']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gstreamer,"blocksize + WAVPACK4_HEADER_SIZE might overflow gsize, which then
results in allocating a very small buffer. Into that buffer blocksize
data is memcpy'd later which then causes out of bound writes and can
potentially lead to anything from crashes to remote code execution.

Thanks to Adam Doupe for analyzing and reporting the issue.

CVE: CVE-2022-1920

https://gstreamer.freedesktop.org/security/sa-2022-0004.html

Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/1226

Part-of: <https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/2612>
",cf887f1b8e228bff6e19829e6d03995d70ad739d,https://cgit.freedesktop.org/gstreamer/gstreamer/commit/?id=cf887f1b8e228bff6e19829e6d03995d70ad739d,subprojects/gst-plugins-good/gst/matroska/matroska-demux.c,gst_matroska_demux_add_wvpk_header,"static GstFlowReturn
gst_matroska_demux_add_wvpk_header (GstElement * element,
GstMatroskaTrackContext * stream, GstBuffer ** buf)
{
GstMatroskaTrackAudioContext *audiocontext =
(GstMatroskaTrackAudioContext *) stream;
GstBuffer *newbuf = NULL;
GstMapInfo map, outmap;
guint8 *buf_data, *data;
Wavpack4Header wvh;
wvh.ck_id[0] = 'w';
wvh.ck_id[1] = 'v';
wvh.ck_id[2] = 'p';
wvh.ck_id[3] = 'k';
wvh.version = GST_READ_UINT16_LE (stream->codec_priv);
wvh.track_no = 0;
wvh.index_no = 0;
wvh.total_samples = -1;
wvh.block_index = audiocontext->wvpk_block_index;
if (audiocontext->channels <= 2) {
guint32 block_samples, tmp;
gsize size = gst_buffer_get_size (*buf);
if (size < 4) {
GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
gst_buffer_unmap (*buf, &map);
return GST_FLOW_ERROR;
}
gst_buffer_extract (*buf, 0, &tmp, sizeof (guint32));
block_samples = GUINT32_FROM_LE (tmp);
wvh.ck_size = size + WAVPACK4_HEADER_SIZE - 20;
newbuf = gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE - 12, NULL);
gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);
data = outmap.data;
data[0] = 'w';
data[1] = 'v';
data[2] = 'p';
data[3] = 'k';
GST_WRITE_UINT32_LE (data + 4, wvh.ck_size);
GST_WRITE_UINT16_LE (data + 8, wvh.version);
GST_WRITE_UINT8 (data + 10, wvh.track_no);
GST_WRITE_UINT8 (data + 11, wvh.index_no);
GST_WRITE_UINT32_LE (data + 12, wvh.total_samples);
GST_WRITE_UINT32_LE (data + 16, wvh.block_index);
gst_buffer_unmap (newbuf, &outmap);
gst_buffer_copy_into (newbuf, *buf, GST_BUFFER_COPY_TIMESTAMPS |
GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY, 0, size);
gst_buffer_unref (*buf);
*buf = newbuf;
audiocontext->wvpk_block_index += block_samples;
} else {
guint8 *outdata = NULL;
gsize buf_size, size;
guint32 block_samples, flags, crc, blocksize;
GstAdapter *adapter;
adapter = gst_adapter_new ();
gst_buffer_map (*buf, &map, GST_MAP_READ);
buf_data = map.data;
buf_size = map.size;
if (buf_size < 4) {
GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
gst_buffer_unmap (*buf, &map);
g_object_unref (adapter);
return GST_FLOW_ERROR;
}
data = buf_data;
size = buf_size;
block_samples = GST_READ_UINT32_LE (data);
data += 4;
size -= 4;
while (size > 12) {
flags = GST_READ_UINT32_LE (data);
data += 4;
size -= 4;
crc = GST_READ_UINT32_LE (data);
data += 4;
size -= 4;
blocksize = GST_READ_UINT32_LE (data);
data += 4;
size -= 4;
if (blocksize == 0 || size < blocksize) {
GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
gst_buffer_unmap (*buf, &map);
g_object_unref (adapter);
return GST_FLOW_ERROR;
}
g_assert (newbuf == NULL);
newbuf =
gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE + blocksize,
NULL);
gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);
outdata = outmap.data;
outdata[0] = 'w';
outdata[1] = 'v';
outdata[2] = 'p';
outdata[3] = 'k';
outdata += 4;
GST_WRITE_UINT32_LE (outdata, blocksize + WAVPACK4_HEADER_SIZE - 8);
GST_WRITE_UINT16_LE (outdata + 4, wvh.version);
GST_WRITE_UINT8 (outdata + 6, wvh.track_no);
GST_WRITE_UINT8 (outdata + 7, wvh.index_no);
GST_WRITE_UINT32_LE (outdata + 8, wvh.total_samples);
GST_WRITE_UINT32_LE (outdata + 12, wvh.block_index);
GST_WRITE_UINT32_LE (outdata + 16, block_samples);
GST_WRITE_UINT32_LE (outdata + 20, flags);
GST_WRITE_UINT32_LE (outdata + 24, crc);
outdata += 28;
memcpy (outdata, data, blocksize);
gst_buffer_unmap (newbuf, &outmap);
gst_adapter_push (adapter, newbuf);
newbuf = NULL;
data += blocksize;
size -= blocksize;
}
gst_buffer_unmap (*buf, &map);
newbuf = gst_adapter_take_buffer (adapter, gst_adapter_available (adapter));
g_object_unref (adapter);
gst_buffer_copy_into (newbuf, *buf,
GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);
gst_buffer_unref (*buf);
*buf = newbuf;
audiocontext->wvpk_block_index += block_samples;
}
return GST_FLOW_OK;
}","static GstFlowReturn
gst_matroska_demux_add_wvpk_header (GstElement * VAR_0,
GstMatroskaTrackContext * VAR_1, GstBuffer ** VAR_2)
{
GstMatroskaTrackAudioContext *VAR_3 =
(GstMatroskaTrackAudioContext *) VAR_1;
GstBuffer *VAR_4 = NULL;
GstMapInfo VAR_5, VAR_6;
guint8 *VAR_7, *VAR_8;
Wavpack4Header VAR_9;
VAR_9.ck_id[0] = 'w';
VAR_9.ck_id[1] = 'v';
VAR_9.ck_id[2] = 'p';
VAR_9.ck_id[3] = 'k';
VAR_9.version = GST_READ_UINT16_LE (VAR_1->codec_priv);
VAR_9.track_no = 0;
VAR_9.index_no = 0;
VAR_9.total_samples = -1;
VAR_9.block_index = VAR_3->wvpk_block_index;
if (VAR_3->channels <= 2) {
guint32 VAR_10, VAR_11;
gsize VAR_12 = gst_buffer_get_size (*VAR_2);
if (VAR_12 < 4) {
GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
gst_buffer_unmap (*VAR_2, &VAR_5);
return VAR_13;
}
gst_buffer_extract (*VAR_2, 0, &VAR_11, sizeof (guint32));
VAR_10 = GUINT32_FROM_LE (VAR_11);
VAR_9.ck_size = VAR_12 + VAR_14 - 20;
VAR_4 = gst_buffer_new_allocate (NULL, VAR_14 - 12, NULL);
gst_buffer_map (VAR_4, &VAR_6, VAR_15);
VAR_8 = VAR_6.data;
VAR_8[0] = 'w';
VAR_8[1] = 'v';
VAR_8[2] = 'p';
VAR_8[3] = 'k';
GST_WRITE_UINT32_LE (VAR_8 + 4, VAR_9.ck_size);
GST_WRITE_UINT16_LE (VAR_8 + 8, VAR_9.version);
GST_WRITE_UINT8 (VAR_8 + 10, VAR_9.track_no);
GST_WRITE_UINT8 (VAR_8 + 11, VAR_9.index_no);
GST_WRITE_UINT32_LE (VAR_8 + 12, VAR_9.total_samples);
GST_WRITE_UINT32_LE (VAR_8 + 16, VAR_9.block_index);
gst_buffer_unmap (VAR_4, &VAR_6);
gst_buffer_copy_into (VAR_4, *VAR_2, VAR_16 |
VAR_17 | VAR_18, 0, VAR_12);
gst_buffer_unref (*VAR_2);
*VAR_2 = VAR_4;
VAR_3->wvpk_block_index += VAR_10;
} else {
guint8 *VAR_19 = NULL;
gsize VAR_20, VAR_12;
guint32 VAR_10, VAR_21, VAR_22, VAR_23;
GstAdapter *VAR_24;
VAR_24 = gst_adapter_new ();
gst_buffer_map (*VAR_2, &VAR_5, VAR_25);
VAR_7 = VAR_5.data;
VAR_20 = VAR_5.size;
if (VAR_20 < 4) {
GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
gst_buffer_unmap (*VAR_2, &VAR_5);
g_object_unref (VAR_24);
return VAR_13;
}
VAR_8 = VAR_7;
VAR_12 = VAR_20;
VAR_10 = GST_READ_UINT32_LE (VAR_8);
VAR_8 += 4;
VAR_12 -= 4;
while (VAR_12 > 12) {
VAR_21 = GST_READ_UINT32_LE (VAR_8);
VAR_8 += 4;
VAR_12 -= 4;
VAR_22 = GST_READ_UINT32_LE (VAR_8);
VAR_8 += 4;
VAR_12 -= 4;
VAR_23 = GST_READ_UINT32_LE (VAR_8);
VAR_8 += 4;
VAR_12 -= 4;
if (VAR_23 == 0 || VAR_12 < VAR_23) {
GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
gst_buffer_unmap (*VAR_2, &VAR_5);
g_object_unref (VAR_24);
return VAR_13;
}
g_assert (VAR_4 == NULL);
VAR_4 =
gst_buffer_new_allocate (NULL, VAR_14 + VAR_23,
NULL);
gst_buffer_map (VAR_4, &VAR_6, VAR_15);
VAR_19 = VAR_6.data;
VAR_19[0] = 'w';
VAR_19[1] = 'v';
VAR_19[2] = 'p';
VAR_19[3] = 'k';
VAR_19 += 4;
GST_WRITE_UINT32_LE (VAR_19, VAR_23 + VAR_14 - 8);
GST_WRITE_UINT16_LE (VAR_19 + 4, VAR_9.version);
GST_WRITE_UINT8 (VAR_19 + 6, VAR_9.track_no);
GST_WRITE_UINT8 (VAR_19 + 7, VAR_9.index_no);
GST_WRITE_UINT32_LE (VAR_19 + 8, VAR_9.total_samples);
GST_WRITE_UINT32_LE (VAR_19 + 12, VAR_9.block_index);
GST_WRITE_UINT32_LE (VAR_19 + 16, VAR_10);
GST_WRITE_UINT32_LE (VAR_19 + 20, VAR_21);
GST_WRITE_UINT32_LE (VAR_19 + 24, VAR_22);
VAR_19 += 28;
memcpy (VAR_19, VAR_8, VAR_23);
gst_buffer_unmap (VAR_4, &VAR_6);
gst_adapter_push (VAR_24, VAR_4);
VAR_4 = NULL;
VAR_8 += VAR_23;
VAR_12 -= VAR_23;
}
gst_buffer_unmap (*VAR_2, &VAR_5);
VAR_4 = gst_adapter_take_buffer (VAR_24, gst_adapter_available (VAR_24));
g_object_unref (VAR_24);
gst_buffer_copy_into (VAR_4, *VAR_2,
VAR_16 | VAR_17, 0, -1);
gst_buffer_unref (*VAR_2);
*VAR_2 = VAR_4;
VAR_3->wvpk_block_index += VAR_10;
}
return VAR_26;
}",gstreamer/cf887f1b8e228bff6e19829e6d03995d70ad739d/matroska-demux.c/vul/before/0.json,"static GstFlowReturn
gst_matroska_demux_add_wvpk_header (GstElement * element,
    GstMatroskaTrackContext * stream, GstBuffer ** buf)
{
  GstMatroskaTrackAudioContext *audiocontext =
      (GstMatroskaTrackAudioContext *) stream;
  GstBuffer *newbuf = NULL;
  GstMapInfo map, outmap;
  guint8 *buf_data, *data;
  Wavpack4Header wvh;

  wvh.ck_id[0] = 'w';
  wvh.ck_id[1] = 'v';
  wvh.ck_id[2] = 'p';
  wvh.ck_id[3] = 'k';

  wvh.version = GST_READ_UINT16_LE (stream->codec_priv);
  wvh.track_no = 0;
  wvh.index_no = 0;
  wvh.total_samples = -1;
  wvh.block_index = audiocontext->wvpk_block_index;

  if (audiocontext->channels <= 2) {
    guint32 block_samples, tmp;
    gsize size = gst_buffer_get_size (*buf);

    if (size < 4) {
      GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
      gst_buffer_unmap (*buf, &map);
      return GST_FLOW_ERROR;
    }

    gst_buffer_extract (*buf, 0, &tmp, sizeof (guint32));
    block_samples = GUINT32_FROM_LE (tmp);
    /* we need to reconstruct the header of the wavpack block */

    /* -20 because ck_size is the size of the wavpack block -8
     * and lace_size is the size of the wavpack block + 12
     * (the three guint32 of the header that already are in the buffer) */
    wvh.ck_size = size + WAVPACK4_HEADER_SIZE - 20;

    /* block_samples, flags and crc are already in the buffer */
    newbuf = gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE - 12, NULL);

    gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);
    data = outmap.data;
    data[0] = 'w';
    data[1] = 'v';
    data[2] = 'p';
    data[3] = 'k';
    GST_WRITE_UINT32_LE (data + 4, wvh.ck_size);
    GST_WRITE_UINT16_LE (data + 8, wvh.version);
    GST_WRITE_UINT8 (data + 10, wvh.track_no);
    GST_WRITE_UINT8 (data + 11, wvh.index_no);
    GST_WRITE_UINT32_LE (data + 12, wvh.total_samples);
    GST_WRITE_UINT32_LE (data + 16, wvh.block_index);
    gst_buffer_unmap (newbuf, &outmap);

    /* Append data from buf: */
    gst_buffer_copy_into (newbuf, *buf, GST_BUFFER_COPY_TIMESTAMPS |
        GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY, 0, size);

    gst_buffer_unref (*buf);
    *buf = newbuf;
    audiocontext->wvpk_block_index += block_samples;
  } else {
    guint8 *outdata = NULL;
    gsize buf_size, size;
    guint32 block_samples, flags, crc;
    gsize blocksize;
    GstAdapter *adapter;

    adapter = gst_adapter_new ();

    gst_buffer_map (*buf, &map, GST_MAP_READ);
    buf_data = map.data;
    buf_size = map.size;

    if (buf_size < 4) {
      GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
      gst_buffer_unmap (*buf, &map);
      g_object_unref (adapter);
      return GST_FLOW_ERROR;
    }

    data = buf_data;
    size = buf_size;

    block_samples = GST_READ_UINT32_LE (data);
    data += 4;
    size -= 4;

    while (size > 12) {
      flags = GST_READ_UINT32_LE (data);
      data += 4;
      size -= 4;
      crc = GST_READ_UINT32_LE (data);
      data += 4;
      size -= 4;
      blocksize = GST_READ_UINT32_LE (data);
      data += 4;
      size -= 4;

      if (blocksize == 0 || size < blocksize) {
        GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
        gst_buffer_unmap (*buf, &map);
        g_object_unref (adapter);
        return GST_FLOW_ERROR;
      }

      if (blocksize > G_MAXSIZE - WAVPACK4_HEADER_SIZE) {
        GST_ERROR_OBJECT (element, ""Too big wavpack buffer"");
        gst_buffer_unmap (*buf, &map);
        g_object_unref (adapter);
        return GST_FLOW_ERROR;
      }

      g_assert (newbuf == NULL);

      newbuf =
          gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE + blocksize,
          NULL);
      gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);
      outdata = outmap.data;

      outdata[0] = 'w';
      outdata[1] = 'v';
      outdata[2] = 'p';
      outdata[3] = 'k';
      outdata += 4;

      GST_WRITE_UINT32_LE (outdata, blocksize + WAVPACK4_HEADER_SIZE - 8);
      GST_WRITE_UINT16_LE (outdata + 4, wvh.version);
      GST_WRITE_UINT8 (outdata + 6, wvh.track_no);
      GST_WRITE_UINT8 (outdata + 7, wvh.index_no);
      GST_WRITE_UINT32_LE (outdata + 8, wvh.total_samples);
      GST_WRITE_UINT32_LE (outdata + 12, wvh.block_index);
      GST_WRITE_UINT32_LE (outdata + 16, block_samples);
      GST_WRITE_UINT32_LE (outdata + 20, flags);
      GST_WRITE_UINT32_LE (outdata + 24, crc);
      outdata += 28;

      memcpy (outdata, data, blocksize);

      gst_buffer_unmap (newbuf, &outmap);
      gst_adapter_push (adapter, newbuf);
      newbuf = NULL;

      data += blocksize;
      size -= blocksize;
    }
    gst_buffer_unmap (*buf, &map);

    newbuf = gst_adapter_take_buffer (adapter, gst_adapter_available (adapter));
    g_object_unref (adapter);

    gst_buffer_copy_into (newbuf, *buf,
        GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);
    gst_buffer_unref (*buf);
    *buf = newbuf;

    audiocontext->wvpk_block_index += block_samples;
  }

  return GST_FLOW_OK;
}","static GstFlowReturn
gst_matroska_demux_add_wvpk_header (GstElement * VAR_0,
    GstMatroskaTrackContext * VAR_1, GstBuffer ** VAR_2)
{
  GstMatroskaTrackAudioContext *VAR_3 =
      (GstMatroskaTrackAudioContext *) VAR_1;
  GstBuffer *VAR_4 = NULL;
  GstMapInfo VAR_5, VAR_6;
  guint8 *VAR_7, *VAR_8;
  Wavpack4Header VAR_9;

  VAR_9.ck_id[0] = 'w';
  VAR_9.ck_id[1] = 'v';
  VAR_9.ck_id[2] = 'p';
  VAR_9.ck_id[3] = 'k';

  VAR_9.version = GST_READ_UINT16_LE (VAR_1->codec_priv);
  VAR_9.track_no = 0;
  VAR_9.index_no = 0;
  VAR_9.total_samples = -1;
  VAR_9.block_index = VAR_3->wvpk_block_index;

  if (VAR_3->channels <= 2) {
    guint32 VAR_10, VAR_11;
    gsize VAR_12 = gst_buffer_get_size (*VAR_2);

    if (VAR_12 < 4) {
      GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
      gst_buffer_unmap (*VAR_2, &VAR_5);
      return VAR_13;
    }

    gst_buffer_extract (*VAR_2, 0, &VAR_11, sizeof (guint32));
    VAR_10 = GUINT32_FROM_LE (VAR_11);
    /* COMMENT_0 */

    /* COMMENT_1 */
                                                          
                                                                          
    VAR_9.ck_size = VAR_12 + VAR_14 - 20;

    /* COMMENT_4 */
    VAR_4 = gst_buffer_new_allocate (NULL, VAR_14 - 12, NULL);

    gst_buffer_map (VAR_4, &VAR_6, VAR_15);
    VAR_8 = VAR_6.data;
    VAR_8[0] = 'w';
    VAR_8[1] = 'v';
    VAR_8[2] = 'p';
    VAR_8[3] = 'k';
    GST_WRITE_UINT32_LE (VAR_8 + 4, VAR_9.ck_size);
    GST_WRITE_UINT16_LE (VAR_8 + 8, VAR_9.version);
    GST_WRITE_UINT8 (VAR_8 + 10, VAR_9.track_no);
    GST_WRITE_UINT8 (VAR_8 + 11, VAR_9.index_no);
    GST_WRITE_UINT32_LE (VAR_8 + 12, VAR_9.total_samples);
    GST_WRITE_UINT32_LE (VAR_8 + 16, VAR_9.block_index);
    gst_buffer_unmap (VAR_4, &VAR_6);

    /* COMMENT_5 */
    gst_buffer_copy_into (VAR_4, *VAR_2, VAR_16 |
        VAR_17 | VAR_18, 0, VAR_12);

    gst_buffer_unref (*VAR_2);
    *VAR_2 = VAR_4;
    VAR_3->wvpk_block_index += VAR_10;
  } else {
    guint8 *VAR_19 = NULL;
    gsize VAR_20, VAR_12;
    guint32 VAR_10, VAR_21, VAR_22;
    gsize VAR_23;
    GstAdapter *VAR_24;

    VAR_24 = gst_adapter_new ();

    gst_buffer_map (*VAR_2, &VAR_5, VAR_25);
    VAR_7 = VAR_5.data;
    VAR_20 = VAR_5.size;

    if (VAR_20 < 4) {
      GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
      gst_buffer_unmap (*VAR_2, &VAR_5);
      g_object_unref (VAR_24);
      return VAR_13;
    }

    VAR_8 = VAR_7;
    VAR_12 = VAR_20;

    VAR_10 = GST_READ_UINT32_LE (VAR_8);
    VAR_8 += 4;
    VAR_12 -= 4;

    while (VAR_12 > 12) {
      VAR_21 = GST_READ_UINT32_LE (VAR_8);
      VAR_8 += 4;
      VAR_12 -= 4;
      VAR_22 = GST_READ_UINT32_LE (VAR_8);
      VAR_8 += 4;
      VAR_12 -= 4;
      VAR_23 = GST_READ_UINT32_LE (VAR_8);
      VAR_8 += 4;
      VAR_12 -= 4;

      if (VAR_23 == 0 || VAR_12 < VAR_23) {
        GST_ERROR_OBJECT (VAR_0, ""Too small wavpack buffer"");
        gst_buffer_unmap (*VAR_2, &VAR_5);
        g_object_unref (VAR_24);
        return VAR_13;
      }

      if (VAR_23 > VAR_26 - VAR_14) {
        GST_ERROR_OBJECT (VAR_0, ""Too big wavpack buffer"");
        gst_buffer_unmap (*VAR_2, &VAR_5);
        g_object_unref (VAR_24);
        return VAR_13;
      }

      g_assert (VAR_4 == NULL);

      VAR_4 =
          gst_buffer_new_allocate (NULL, VAR_14 + VAR_23,
          NULL);
      gst_buffer_map (VAR_4, &VAR_6, VAR_15);
      VAR_19 = VAR_6.data;

      VAR_19[0] = 'w';
      VAR_19[1] = 'v';
      VAR_19[2] = 'p';
      VAR_19[3] = 'k';
      VAR_19 += 4;

      GST_WRITE_UINT32_LE (VAR_19, VAR_23 + VAR_14 - 8);
      GST_WRITE_UINT16_LE (VAR_19 + 4, VAR_9.version);
      GST_WRITE_UINT8 (VAR_19 + 6, VAR_9.track_no);
      GST_WRITE_UINT8 (VAR_19 + 7, VAR_9.index_no);
      GST_WRITE_UINT32_LE (VAR_19 + 8, VAR_9.total_samples);
      GST_WRITE_UINT32_LE (VAR_19 + 12, VAR_9.block_index);
      GST_WRITE_UINT32_LE (VAR_19 + 16, VAR_10);
      GST_WRITE_UINT32_LE (VAR_19 + 20, VAR_21);
      GST_WRITE_UINT32_LE (VAR_19 + 24, VAR_22);
      VAR_19 += 28;

      memcpy (VAR_19, VAR_8, VAR_23);

      gst_buffer_unmap (VAR_4, &VAR_6);
      gst_adapter_push (VAR_24, VAR_4);
      VAR_4 = NULL;

      VAR_8 += VAR_23;
      VAR_12 -= VAR_23;
    }
    gst_buffer_unmap (*VAR_2, &VAR_5);

    VAR_4 = gst_adapter_take_buffer (VAR_24, gst_adapter_available (VAR_24));
    g_object_unref (VAR_24);

    gst_buffer_copy_into (VAR_4, *VAR_2,
        VAR_16 | VAR_17, 0, -1);
    gst_buffer_unref (*VAR_2);
    *VAR_2 = VAR_4;

    VAR_3->wvpk_block_index += VAR_10;
  }

  return VAR_27;
}",gstreamer/cf887f1b8e228bff6e19829e6d03995d70ad739d/matroska-demux.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,7 +66,8 @@
   } else {
     guint8 *outdata = NULL;
     gsize buf_size, size;
-    guint32 block_samples, flags, crc, blocksize;
+    guint32 block_samples, flags, crc;
+    gsize blocksize;
     GstAdapter *adapter;
 
     adapter = gst_adapter_new ();
@@ -102,6 +103,13 @@
 
       if (blocksize == 0 || size < blocksize) {
         GST_ERROR_OBJECT (element, ""Too small wavpack buffer"");
+        gst_buffer_unmap (*buf, &map);
+        g_object_unref (adapter);
+        return GST_FLOW_ERROR;
+      }
+
+      if (blocksize > G_MAXSIZE - WAVPACK4_HEADER_SIZE) {
+        GST_ERROR_OBJECT (element, ""Too big wavpack buffer"");
         gst_buffer_unmap (*buf, &map);
         g_object_unref (adapter);
         return GST_FLOW_ERROR;","{'deleted_lines': ['    guint32 block_samples, flags, crc, blocksize;'], 'added_lines': ['    guint32 block_samples, flags, crc;', '    gsize blocksize;', '        gst_buffer_unmap (*buf, &map);', '        g_object_unref (adapter);', '        return GST_FLOW_ERROR;', '      }', '', '      if (blocksize > G_MAXSIZE - WAVPACK4_HEADER_SIZE) {', '        GST_ERROR_OBJECT (element, ""Too big wavpack buffer"");']}",True,Integer overflow in matroskademux element in gst_matroska_demux_add_wvpk_header function which allows a heap overwrite while parsing matroska files. Potential for arbitrary code execution through heap overwrite.,7.8,HIGH,2,valid,,5
CVE-2020-6095,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gstreamer/gst-rtsp-server,"When using the basic authentication scheme, we wouldn't validate that
the authorization field of the credentials is not NULL and pass it on
to g_hash_table_lookup(). g_str_hash() however is not NULL-safe and will
dereference the NULL pointer and crash.
A specially crafted (read: invalid) RTSP header can cause this to
happen.

As a solution, check for the authorization to be not NULL before
continuing processing it and if it is simply fail authentication.

This fixes CVE-2020-6095 and TALOS-2020-1018.

Discovered by Peter Wang of Cisco ASIG.
",44ccca3086dd81081d72ca0b21d0ecdde962fb1a,https://cgit.freedesktop.org/gstreamer/gst-rtsp-server/commit/?id=44ccca3086dd81081d72ca0b21d0ecdde962fb1a,gst/rtsp-server/rtsp-auth.c,default_authenticate,"static gboolean
default_authenticate (GstRTSPAuth * auth, GstRTSPContext * ctx)
{
GstRTSPAuthPrivate *priv = auth->priv;
GstRTSPAuthCredential **credentials, **credential;
GST_DEBUG_OBJECT (auth, ""authenticate"");
g_mutex_lock (&priv->lock);
ctx->token = priv->default_token;
g_mutex_unlock (&priv->lock);
credentials =
gst_rtsp_message_parse_auth_credentials (ctx->request,
GST_RTSP_HDR_AUTHORIZATION);
if (!credentials)
goto no_auth;
credential = credentials;
while (*credential) {
if ((*credential)->scheme == GST_RTSP_AUTH_BASIC) {
GstRTSPToken *token;
GST_DEBUG_OBJECT (auth, ""check Basic auth"");
g_mutex_lock (&priv->lock);
if ((token =
g_hash_table_lookup (priv->basic,
(*credential)->authorization))) {
GST_DEBUG_OBJECT (auth, ""setting token %p"", token);
ctx->token = token;
g_mutex_unlock (&priv->lock);
break;
}
g_mutex_unlock (&priv->lock);
} else if ((*credential)->scheme == GST_RTSP_AUTH_DIGEST) {
if (default_digest_auth (auth, ctx, (*credential)->params))
break;
}
credential++;
}
gst_rtsp_auth_credentials_free (credentials);
return TRUE;
no_auth:
{
GST_DEBUG_OBJECT (auth, ""no authorization header found"");
return TRUE;
}
}","static gboolean
default_authenticate (GstRTSPAuth * VAR_0, GstRTSPContext * VAR_1)
{
GstRTSPAuthPrivate *VAR_2 = VAR_0->priv;
GstRTSPAuthCredential **VAR_3, **VAR_4;
GST_DEBUG_OBJECT (VAR_0, ""authenticate"");
g_mutex_lock (&VAR_2->lock);
VAR_1->token = VAR_2->default_token;
g_mutex_unlock (&VAR_2->lock);
VAR_3 =
gst_rtsp_message_parse_auth_credentials (VAR_1->request,
VAR_5);
if (!VAR_3)
goto no_auth;
VAR_4 = VAR_3;
while (*VAR_4) {
if ((*VAR_4)->scheme == VAR_6) {
GstRTSPToken *VAR_7;
GST_DEBUG_OBJECT (VAR_0, ""check Basic auth"");
g_mutex_lock (&VAR_2->lock);
if ((VAR_7 =
g_hash_table_lookup (VAR_2->basic,
(*VAR_4)->authorization))) {
GST_DEBUG_OBJECT (VAR_0, ""setting token %p"", VAR_7);
VAR_1->token = VAR_7;
g_mutex_unlock (&VAR_2->lock);
break;
}
g_mutex_unlock (&VAR_2->lock);
} else if ((*VAR_4)->scheme == VAR_8) {
if (default_digest_auth (VAR_0, VAR_1, (*VAR_4)->params))
break;
}
VAR_4++;
}
gst_rtsp_auth_credentials_free (VAR_3);
return TRUE;
no_auth:
{
GST_DEBUG_OBJECT (VAR_0, ""no authorization header found"");
return TRUE;
}
}",gstreamer/gst-rtsp-server/44ccca3086dd81081d72ca0b21d0ecdde962fb1a/rtsp-auth.c/vul/before/0.json,"static gboolean
default_authenticate (GstRTSPAuth * auth, GstRTSPContext * ctx)
{
  GstRTSPAuthPrivate *priv = auth->priv;
  GstRTSPAuthCredential **credentials, **credential;

  GST_DEBUG_OBJECT (auth, ""authenticate"");

  g_mutex_lock (&priv->lock);
  /* FIXME, need to ref but we have no way to unref when the ctx is
   * popped */
  ctx->token = priv->default_token;
  g_mutex_unlock (&priv->lock);

  credentials =
      gst_rtsp_message_parse_auth_credentials (ctx->request,
      GST_RTSP_HDR_AUTHORIZATION);
  if (!credentials)
    goto no_auth;

  /* parse type */
  credential = credentials;
  while (*credential) {
    if ((*credential)->scheme == GST_RTSP_AUTH_BASIC) {
      GstRTSPToken *token;

      GST_DEBUG_OBJECT (auth, ""check Basic auth"");
      g_mutex_lock (&priv->lock);
      if ((*credential)->authorization && (token =
              g_hash_table_lookup (priv->basic,
                  (*credential)->authorization))) {
        GST_DEBUG_OBJECT (auth, ""setting token %p"", token);
        ctx->token = token;
        g_mutex_unlock (&priv->lock);
        break;
      }
      g_mutex_unlock (&priv->lock);
    } else if ((*credential)->scheme == GST_RTSP_AUTH_DIGEST) {
      if (default_digest_auth (auth, ctx, (*credential)->params))
        break;
    }

    credential++;
  }

  gst_rtsp_auth_credentials_free (credentials);
  return TRUE;

no_auth:
  {
    GST_DEBUG_OBJECT (auth, ""no authorization header found"");
    return TRUE;
  }
}","static gboolean
default_authenticate (GstRTSPAuth * VAR_0, GstRTSPContext * VAR_1)
{
  GstRTSPAuthPrivate *VAR_2 = VAR_0->priv;
  GstRTSPAuthCredential **VAR_3, **VAR_4;

  GST_DEBUG_OBJECT (VAR_0, ""authenticate"");

  g_mutex_lock (&VAR_2->lock);
  /* COMMENT_0 */
              
  VAR_1->token = VAR_2->default_token;
  g_mutex_unlock (&VAR_2->lock);

  VAR_3 =
      gst_rtsp_message_parse_auth_credentials (VAR_1->request,
      VAR_5);
  if (!VAR_3)
    goto no_auth;

  /* COMMENT_2 */
  VAR_4 = VAR_3;
  while (*VAR_4) {
    if ((*VAR_4)->scheme == VAR_6) {
      GstRTSPToken *VAR_7;

      GST_DEBUG_OBJECT (VAR_0, ""check Basic auth"");
      g_mutex_lock (&VAR_2->lock);
      if ((*VAR_4)->authorization && (VAR_7 =
              g_hash_table_lookup (VAR_2->basic,
                  (*VAR_4)->authorization))) {
        GST_DEBUG_OBJECT (VAR_0, ""setting token %p"", VAR_7);
        VAR_1->token = VAR_7;
        g_mutex_unlock (&VAR_2->lock);
        break;
      }
      g_mutex_unlock (&VAR_2->lock);
    } else if ((*VAR_4)->scheme == VAR_8) {
      if (default_digest_auth (VAR_0, VAR_1, (*VAR_4)->params))
        break;
    }

    VAR_4++;
  }

  gst_rtsp_auth_credentials_free (VAR_3);
  return TRUE;

no_auth:
  {
    GST_DEBUG_OBJECT (VAR_0, ""no authorization header found"");
    return TRUE;
  }
}",gstreamer/gst-rtsp-server/44ccca3086dd81081d72ca0b21d0ecdde962fb1a/rtsp-auth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,7 @@
 
       GST_DEBUG_OBJECT (auth, ""check Basic auth"");
       g_mutex_lock (&priv->lock);
-      if ((token =
+      if ((*credential)->authorization && (token =
               g_hash_table_lookup (priv->basic,
                   (*credential)->authorization))) {
         GST_DEBUG_OBJECT (auth, ""setting token %p"", token);","{'deleted_lines': ['      if ((token ='], 'added_lines': ['      if ((*credential)->authorization && (token =']}",True,An exploitable denial of service vulnerability exists in the GstRTSPAuth functionality of GStreamer/gst-rtsp-server 1.14.5. A specially crafted RTSP setup request can cause a null pointer deference resulting in denial-of-service. An attacker can send a malicious packet to trigger this vulnerability.,7.5,HIGH,2,valid,,5
CVE-2019-20795,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,iproute2,"Follow the following steps:
 # ip netns add net1
 # export MALLOC_MMAP_THRESHOLD_=0
 # ip netns list
then Segmentation fault (core dumped) will occur.

In get_netnsid_from_name func, answer is freed before
rta_getattr_u32(tb[NETNSA_NSID]), where tb[] refers to answer`s
content. If we set MALLOC_MMAP_THRESHOLD_=0, mmap will be adoped to
malloc memory, which will be freed immediately after calling free
func.  So reading tb[NETNSA_NSID] will access the released memory
after free(answer).

Here, we will call get_netnsid_from_name(tb[NETNSA_NSID]) before free(answer).

Fixes: 86bf43c7c2f (""lib/libnetlink: update rtnl_talk to support malloc buff at run time"")
Reported-by: Huiying Kou <kouhuiying@huawei.com>
Signed-off-by: Zhiqiang Liu <liuzhiqiang26@huawei.com>
Acked-by: Phil Sutter <phil@nwl.cc>
Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
",9bf2c538a0eb10d66e2365a655bf6c52f5ba3d10,https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?h=9bf2c538a0eb10d66e2365a655bf6c52f5ba3d10,ip/ipnetns.c,get_netnsid_from_name,"int get_netnsid_from_name(const char *name)
{
struct {
struct nlmsghdr n;
struct rtgenmsg g;
char            buf[1024];
} req = {
.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),
.n.nlmsg_flags = NLM_F_REQUEST,
.n.nlmsg_type = RTM_GETNSID,
.g.rtgen_family = AF_UNSPEC,
};
struct nlmsghdr *answer;
struct rtattr *tb[NETNSA_MAX + 1];
struct rtgenmsg *rthdr;
int len, fd;
netns_nsid_socket_init();
fd = netns_get_fd(name);
if (fd < 0)
return fd;
addattr32(&req.n, 1024, NETNSA_FD, fd);
if (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {
close(fd);
return -2;
}
close(fd);
if (answer->nlmsg_type == NLMSG_ERROR)
goto err_out;
rthdr = NLMSG_DATA(answer);
len = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));
if (len < 0)
goto err_out;
parse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);
if (tb[NETNSA_NSID]) {
free(answer);
return rta_getattr_u32(tb[NETNSA_NSID]);
}
err_out:
free(answer);
return -1;
}","int get_netnsid_from_name(const char *VAR_0)
{
struct {
struct nlmsghdr n;
struct rtgenmsg g;
char            buf[1024];
} VAR_1 = {
.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),
.n.nlmsg_flags = VAR_2,
.n.nlmsg_type = VAR_3,
.g.rtgen_family = VAR_4,
};
struct nlmsghdr *VAR_5;
struct rtattr *VAR_6[VAR_7 + 1];
struct rtgenmsg *VAR_8;
int VAR_9, VAR_10;
netns_nsid_socket_init();
VAR_10 = netns_get_fd(VAR_0);
if (VAR_10 < 0)
return VAR_10;
addattr32(&VAR_1.n, 1024, VAR_11, VAR_10);
if (rtnl_talk(&VAR_12, &VAR_1.n, &VAR_5) < 0) {
close(VAR_10);
return -2;
}
close(VAR_10);
if (VAR_5->nlmsg_type == VAR_13)
goto err_out;
VAR_8 = NLMSG_DATA(VAR_5);
VAR_9 = VAR_5->nlmsg_len - NLMSG_SPACE(sizeof(*VAR_8));
if (VAR_9 < 0)
goto err_out;
parse_rtattr(VAR_6, VAR_7, NETNS_RTA(VAR_8), VAR_9);
if (VAR_6[VAR_14]) {
free(VAR_5);
return rta_getattr_u32(VAR_6[VAR_14]);
}
err_out:
free(VAR_5);
return -1;
}",iproute2/9bf2c538a0eb10d66e2365a655bf6c52f5ba3d10/ipnetns.c/vul/before/0.json,"int get_netnsid_from_name(const char *name)
{
	struct {
		struct nlmsghdr n;
		struct rtgenmsg g;
		char            buf[1024];
	} req = {
		.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),
		.n.nlmsg_flags = NLM_F_REQUEST,
		.n.nlmsg_type = RTM_GETNSID,
		.g.rtgen_family = AF_UNSPEC,
	};
	struct nlmsghdr *answer;
	struct rtattr *tb[NETNSA_MAX + 1];
	struct rtgenmsg *rthdr;
	int len, fd, ret = -1;

	netns_nsid_socket_init();

	fd = netns_get_fd(name);
	if (fd < 0)
		return fd;

	addattr32(&req.n, 1024, NETNSA_FD, fd);
	if (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {
		close(fd);
		return -2;
	}
	close(fd);

	/* Validate message and parse attributes */
	if (answer->nlmsg_type == NLMSG_ERROR)
		goto out;

	rthdr = NLMSG_DATA(answer);
	len = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));
	if (len < 0)
		goto out;

	parse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);

	if (tb[NETNSA_NSID]) {
		ret = rta_getattr_u32(tb[NETNSA_NSID]);
	}

out:
	free(answer);
	return ret;
}","int get_netnsid_from_name(const char *VAR_0)
{
	struct {
		struct nlmsghdr n;
		struct rtgenmsg g;
		char            buf[1024];
	} VAR_1 = {
		.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),
		.n.nlmsg_flags = VAR_2,
		.n.nlmsg_type = VAR_3,
		.g.rtgen_family = VAR_4,
	};
	struct nlmsghdr *VAR_5;
	struct rtattr *VAR_6[VAR_7 + 1];
	struct rtgenmsg *VAR_8;
	int VAR_9, VAR_10, VAR_11 = -1;

	netns_nsid_socket_init();

	VAR_10 = netns_get_fd(VAR_0);
	if (VAR_10 < 0)
		return VAR_10;

	addattr32(&VAR_1.n, 1024, VAR_12, VAR_10);
	if (rtnl_talk(&VAR_13, &VAR_1.n, &VAR_5) < 0) {
		close(VAR_10);
		return -2;
	}
	close(VAR_10);

	/* COMMENT_0 */
	if (VAR_5->nlmsg_type == VAR_14)
		goto out;

	VAR_8 = NLMSG_DATA(VAR_5);
	VAR_9 = VAR_5->nlmsg_len - NLMSG_SPACE(sizeof(*VAR_8));
	if (VAR_9 < 0)
		goto out;

	parse_rtattr(VAR_6, VAR_7, NETNS_RTA(VAR_8), VAR_9);

	if (VAR_6[VAR_15]) {
		VAR_11 = rta_getattr_u32(VAR_6[VAR_15]);
	}

out:
	free(VAR_5);
	return VAR_11;
}",iproute2/9bf2c538a0eb10d66e2365a655bf6c52f5ba3d10/ipnetns.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
 	struct nlmsghdr *answer;
 	struct rtattr *tb[NETNSA_MAX + 1];
 	struct rtgenmsg *rthdr;
-	int len, fd;
+	int len, fd, ret = -1;
 
 	netns_nsid_socket_init();
 
@@ -30,21 +30,20 @@
 
 	/* Validate message and parse attributes */
 	if (answer->nlmsg_type == NLMSG_ERROR)
-		goto err_out;
+		goto out;
 
 	rthdr = NLMSG_DATA(answer);
 	len = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));
 	if (len < 0)
-		goto err_out;
+		goto out;
 
 	parse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);
 
 	if (tb[NETNSA_NSID]) {
-		free(answer);
-		return rta_getattr_u32(tb[NETNSA_NSID]);
+		ret = rta_getattr_u32(tb[NETNSA_NSID]);
 	}
 
-err_out:
+out:
 	free(answer);
-	return -1;
+	return ret;
 }","{'deleted_lines': ['\tint len, fd;', '\t\tgoto err_out;', '\t\tgoto err_out;', '\t\tfree(answer);', '\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);', 'err_out:', '\treturn -1;'], 'added_lines': ['\tint len, fd, ret = -1;', '\t\tgoto out;', '\t\tgoto out;', '\t\tret = rta_getattr_u32(tb[NETNSA_NSID]);', 'out:', '\treturn ret;']}",True,"iproute2 before 5.1.0 has a use-after-free in get_netnsid_from_name in ip/ipnetns.c. NOTE: security relevance may be limited to certain uses of setuid that, although not a default, are sometimes a configuration option offered to end users. Even when setuid is used, other factors (such as C library configuration) may block exploitability.",4.4,MEDIUM,1,valid,,5
CVE-2020-12769,['CWE-662'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"dw_spi_irq() and dw_spi_transfer_one concurrent calls.

I find a panic in dw_writer(): txw = *(u8 *)(dws->tx), when dw->tx==null,
dw->len==4, and dw->tx_end==1.

When tpm driver's message overtime dw_spi_irq() and dw_spi_transfer_one
may concurrent visit dw_spi, so I think dw_spi structure lack of protection.

Otherwise dw_spi_transfer_one set dw rx/tx buffer and then open irq,
store dw rx/tx instructions and other cores handle irq load dw rx/tx
instructions may out of order.

	[ 1025.321302] Call trace:
	...
	[ 1025.321319]  __crash_kexec+0x98/0x148
	[ 1025.321323]  panic+0x17c/0x314
	[ 1025.321329]  die+0x29c/0x2e8
	[ 1025.321334]  die_kernel_fault+0x68/0x78
	[ 1025.321337]  __do_kernel_fault+0x90/0xb0
	[ 1025.321346]  do_page_fault+0x88/0x500
	[ 1025.321347]  do_translation_fault+0xa8/0xb8
	[ 1025.321349]  do_mem_abort+0x68/0x118
	[ 1025.321351]  el1_da+0x20/0x8c
	[ 1025.321362]  dw_writer+0xc8/0xd0
	[ 1025.321364]  interrupt_transfer+0x60/0x110
	[ 1025.321365]  dw_spi_irq+0x48/0x70
	...

Signed-off-by: wuxu.wu <wuxu.wu@huawei.com>
Link: https://lore.kernel.org/r/1577849981-31489-1-git-send-email-wuxu.wu@huawei.com
Signed-off-by: Mark Brown <broonie@kernel.org>
",19b61392c5a852b4e8a0bf35aecb969983c5932d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=19b61392c5a852b4e8a0bf35aecb969983c5932d,drivers/spi/spi-dw.c,dw_reader,"static void dw_reader(struct dw_spi *dws)
{
u32 max = rx_max(dws);
u16 rxw;
while (max--) {
rxw = dw_read_io_reg(dws, DW_SPI_DR);
if (dws->rx_end - dws->len) {
if (dws->n_bytes == 1)
*(u8 *)(dws->rx) = rxw;
else
*(u16 *)(dws->rx) = rxw;
}
dws->rx += dws->n_bytes;
}
}","static void dw_reader(struct dw_spi *VAR_0)
{
u32 VAR_1 = rx_max(VAR_0);
u16 VAR_2;
while (VAR_1--) {
VAR_2 = dw_read_io_reg(VAR_0, VAR_3);
if (VAR_0->rx_end - VAR_0->len) {
if (VAR_0->n_bytes == 1)
*(u8 *)(VAR_0->rx) = VAR_2;
else
*(u16 *)(VAR_0->rx) = VAR_2;
}
VAR_0->rx += VAR_0->n_bytes;
}
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/before/0.json,"static void dw_reader(struct dw_spi *dws)
{
	u32 max;
	u16 rxw;

	spin_lock(&dws->buf_lock);
	max = rx_max(dws);
	while (max--) {
		rxw = dw_read_io_reg(dws, DW_SPI_DR);
		/* Care rx only if the transfer's original ""rx"" is not null */
		if (dws->rx_end - dws->len) {
			if (dws->n_bytes == 1)
				*(u8 *)(dws->rx) = rxw;
			else
				*(u16 *)(dws->rx) = rxw;
		}
		dws->rx += dws->n_bytes;
	}
	spin_unlock(&dws->buf_lock);
}","static void dw_reader(struct dw_spi *VAR_0)
{
	u32 VAR_1;
	u16 VAR_2;

	spin_lock(&VAR_0->buf_lock);
	VAR_1 = rx_max(VAR_0);
	while (VAR_1--) {
		VAR_2 = dw_read_io_reg(VAR_0, VAR_3);
		/* COMMENT_0 */
		if (VAR_0->rx_end - VAR_0->len) {
			if (VAR_0->n_bytes == 1)
				*(u8 *)(VAR_0->rx) = VAR_2;
			else
				*(u16 *)(VAR_0->rx) = VAR_2;
		}
		VAR_0->rx += VAR_0->n_bytes;
	}
	spin_unlock(&VAR_0->buf_lock);
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,10 @@
 static void dw_reader(struct dw_spi *dws)
 {
-	u32 max = rx_max(dws);
+	u32 max;
 	u16 rxw;
 
+	spin_lock(&dws->buf_lock);
+	max = rx_max(dws);
 	while (max--) {
 		rxw = dw_read_io_reg(dws, DW_SPI_DR);
 		/* Care rx only if the transfer's original ""rx"" is not null */
@@ -14,4 +16,5 @@
 		}
 		dws->rx += dws->n_bytes;
 	}
+	spin_unlock(&dws->buf_lock);
 }","{'deleted_lines': ['\tu32 max = rx_max(dws);'], 'added_lines': ['\tu32 max;', '\tspin_lock(&dws->buf_lock);', '\tmax = rx_max(dws);', '\tspin_unlock(&dws->buf_lock);']}",True,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",5.5,MEDIUM,1,valid,,5
CVE-2020-12769,['CWE-662'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"dw_spi_irq() and dw_spi_transfer_one concurrent calls.

I find a panic in dw_writer(): txw = *(u8 *)(dws->tx), when dw->tx==null,
dw->len==4, and dw->tx_end==1.

When tpm driver's message overtime dw_spi_irq() and dw_spi_transfer_one
may concurrent visit dw_spi, so I think dw_spi structure lack of protection.

Otherwise dw_spi_transfer_one set dw rx/tx buffer and then open irq,
store dw rx/tx instructions and other cores handle irq load dw rx/tx
instructions may out of order.

	[ 1025.321302] Call trace:
	...
	[ 1025.321319]  __crash_kexec+0x98/0x148
	[ 1025.321323]  panic+0x17c/0x314
	[ 1025.321329]  die+0x29c/0x2e8
	[ 1025.321334]  die_kernel_fault+0x68/0x78
	[ 1025.321337]  __do_kernel_fault+0x90/0xb0
	[ 1025.321346]  do_page_fault+0x88/0x500
	[ 1025.321347]  do_translation_fault+0xa8/0xb8
	[ 1025.321349]  do_mem_abort+0x68/0x118
	[ 1025.321351]  el1_da+0x20/0x8c
	[ 1025.321362]  dw_writer+0xc8/0xd0
	[ 1025.321364]  interrupt_transfer+0x60/0x110
	[ 1025.321365]  dw_spi_irq+0x48/0x70
	...

Signed-off-by: wuxu.wu <wuxu.wu@huawei.com>
Link: https://lore.kernel.org/r/1577849981-31489-1-git-send-email-wuxu.wu@huawei.com
Signed-off-by: Mark Brown <broonie@kernel.org>
",19b61392c5a852b4e8a0bf35aecb969983c5932d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=19b61392c5a852b4e8a0bf35aecb969983c5932d,drivers/spi/spi-dw.c,dw_spi_add_host,"int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
{
struct spi_controller *master;
int ret;
BUG_ON(dws == NULL);
master = spi_alloc_master(dev, 0);
if (!master)
return -ENOMEM;
dws->master = master;
dws->type = SSI_MOTO_SPI;
dws->dma_inited = 0;
dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
spi_controller_set_devdata(master, dws);
ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev),
master);
if (ret < 0) {
dev_err(dev, ""can not get IRQ\n"");
goto err_free_master;
}
master->use_gpio_descriptors = true;
master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;
master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16);
master->bus_num = dws->bus_num;
master->num_chipselect = dws->num_cs;
master->setup = dw_spi_setup;
master->cleanup = dw_spi_cleanup;
master->set_cs = dw_spi_set_cs;
master->transfer_one = dw_spi_transfer_one;
master->handle_err = dw_spi_handle_err;
master->max_speed_hz = dws->max_freq;
master->dev.of_node = dev->of_node;
master->dev.fwnode = dev->fwnode;
master->flags = SPI_MASTER_GPIO_SS;
master->auto_runtime_pm = true;
if (dws->set_cs)
master->set_cs = dws->set_cs;
spi_hw_init(dev, dws);
if (dws->dma_ops && dws->dma_ops->dma_init) {
ret = dws->dma_ops->dma_init(dws);
if (ret) {
dev_warn(dev, ""DMA init failed\n"");
dws->dma_inited = 0;
} else {
master->can_dma = dws->dma_ops->can_dma;
}
}
ret = devm_spi_register_controller(dev, master);
if (ret) {
dev_err(&master->dev, ""problem registering spi master\n"");
goto err_dma_exit;
}
dw_spi_debugfs_init(dws);
return 0;
err_dma_exit:
if (dws->dma_ops && dws->dma_ops->dma_exit)
dws->dma_ops->dma_exit(dws);
spi_enable_chip(dws, 0);
free_irq(dws->irq, master);
err_free_master:
spi_controller_put(master);
return ret;
}","int dw_spi_add_host(struct device *VAR_0, struct dw_spi *VAR_1)
{
struct spi_controller *VAR_2;
int VAR_3;
BUG_ON(VAR_1 == NULL);
VAR_2 = spi_alloc_master(VAR_0, 0);
if (!VAR_2)
return -VAR_4;
VAR_1->master = VAR_2;
VAR_1->type = VAR_5;
VAR_1->dma_inited = 0;
VAR_1->dma_addr = (VAR_6)(VAR_1->paddr + VAR_7);
spi_controller_set_devdata(VAR_2, VAR_1);
VAR_3 = request_irq(VAR_1->irq, VAR_8, VAR_9, dev_name(VAR_0),
VAR_2);
if (VAR_3 < 0) {
dev_err(VAR_0, ""can not get IRQ\n"");
goto err_free_master;
}
VAR_2->use_gpio_descriptors = true;
VAR_2->mode_bits = VAR_10 | VAR_11 | VAR_12;
VAR_2->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16);
VAR_2->bus_num = VAR_1->bus_num;
VAR_2->num_chipselect = VAR_1->num_cs;
VAR_2->setup = VAR_13;
VAR_2->cleanup = VAR_14;
VAR_2->set_cs = VAR_15;
VAR_2->transfer_one = VAR_16;
VAR_2->handle_err = VAR_17;
VAR_2->max_speed_hz = VAR_1->max_freq;
VAR_2->dev.of_node = VAR_0->of_node;
VAR_2->dev.fwnode = VAR_0->fwnode;
VAR_2->flags = VAR_18;
VAR_2->auto_runtime_pm = true;
if (VAR_1->set_cs)
VAR_2->set_cs = VAR_1->set_cs;
spi_hw_init(VAR_0, VAR_1);
if (VAR_1->dma_ops && VAR_1->dma_ops->dma_init) {
VAR_3 = VAR_1->dma_ops->dma_init(VAR_1);
if (VAR_3) {
dev_warn(VAR_0, ""DMA init failed\n"");
VAR_1->dma_inited = 0;
} else {
VAR_2->can_dma = VAR_1->dma_ops->can_dma;
}
}
VAR_3 = devm_spi_register_controller(VAR_0, VAR_2);
if (VAR_3) {
dev_err(&VAR_2->dev, ""problem registering spi master\n"");
goto err_dma_exit;
}
dw_spi_debugfs_init(VAR_1);
return 0;
err_dma_exit:
if (VAR_1->dma_ops && VAR_1->dma_ops->dma_exit)
VAR_1->dma_ops->dma_exit(VAR_1);
spi_enable_chip(VAR_1, 0);
free_irq(VAR_1->irq, VAR_2);
err_free_master:
spi_controller_put(VAR_2);
return VAR_3;
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/before/1.json,"int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
{
	struct spi_controller *master;
	int ret;

	BUG_ON(dws == NULL);

	master = spi_alloc_master(dev, 0);
	if (!master)
		return -ENOMEM;

	dws->master = master;
	dws->type = SSI_MOTO_SPI;
	dws->dma_inited = 0;
	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
	spin_lock_init(&dws->buf_lock);

	spi_controller_set_devdata(master, dws);

	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev),
			  master);
	if (ret < 0) {
		dev_err(dev, ""can not get IRQ\n"");
		goto err_free_master;
	}

	master->use_gpio_descriptors = true;
	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;
	master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16);
	master->bus_num = dws->bus_num;
	master->num_chipselect = dws->num_cs;
	master->setup = dw_spi_setup;
	master->cleanup = dw_spi_cleanup;
	master->set_cs = dw_spi_set_cs;
	master->transfer_one = dw_spi_transfer_one;
	master->handle_err = dw_spi_handle_err;
	master->max_speed_hz = dws->max_freq;
	master->dev.of_node = dev->of_node;
	master->dev.fwnode = dev->fwnode;
	master->flags = SPI_MASTER_GPIO_SS;
	master->auto_runtime_pm = true;

	if (dws->set_cs)
		master->set_cs = dws->set_cs;

	/* Basic HW init */
	spi_hw_init(dev, dws);

	if (dws->dma_ops && dws->dma_ops->dma_init) {
		ret = dws->dma_ops->dma_init(dws);
		if (ret) {
			dev_warn(dev, ""DMA init failed\n"");
			dws->dma_inited = 0;
		} else {
			master->can_dma = dws->dma_ops->can_dma;
		}
	}

	ret = devm_spi_register_controller(dev, master);
	if (ret) {
		dev_err(&master->dev, ""problem registering spi master\n"");
		goto err_dma_exit;
	}

	dw_spi_debugfs_init(dws);
	return 0;

err_dma_exit:
	if (dws->dma_ops && dws->dma_ops->dma_exit)
		dws->dma_ops->dma_exit(dws);
	spi_enable_chip(dws, 0);
	free_irq(dws->irq, master);
err_free_master:
	spi_controller_put(master);
	return ret;
}","int dw_spi_add_host(struct device *VAR_0, struct dw_spi *VAR_1)
{
	struct spi_controller *VAR_2;
	int VAR_3;

	BUG_ON(VAR_1 == NULL);

	VAR_2 = spi_alloc_master(VAR_0, 0);
	if (!VAR_2)
		return -VAR_4;

	VAR_1->master = VAR_2;
	VAR_1->type = VAR_5;
	VAR_1->dma_inited = 0;
	VAR_1->dma_addr = (VAR_6)(VAR_1->paddr + VAR_7);
	spin_lock_init(&VAR_1->buf_lock);

	spi_controller_set_devdata(VAR_2, VAR_1);

	VAR_3 = request_irq(VAR_1->irq, VAR_8, VAR_9, dev_name(VAR_0),
			  VAR_2);
	if (VAR_3 < 0) {
		dev_err(VAR_0, ""can not get IRQ\n"");
		goto err_free_master;
	}

	VAR_2->use_gpio_descriptors = true;
	VAR_2->mode_bits = VAR_10 | VAR_11 | VAR_12;
	VAR_2->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16);
	VAR_2->bus_num = VAR_1->bus_num;
	VAR_2->num_chipselect = VAR_1->num_cs;
	VAR_2->setup = VAR_13;
	VAR_2->cleanup = VAR_14;
	VAR_2->set_cs = VAR_15;
	VAR_2->transfer_one = VAR_16;
	VAR_2->handle_err = VAR_17;
	VAR_2->max_speed_hz = VAR_1->max_freq;
	VAR_2->dev.of_node = VAR_0->of_node;
	VAR_2->dev.fwnode = VAR_0->fwnode;
	VAR_2->flags = VAR_18;
	VAR_2->auto_runtime_pm = true;

	if (VAR_1->set_cs)
		VAR_2->set_cs = VAR_1->set_cs;

	/* COMMENT_0 */
	spi_hw_init(VAR_0, VAR_1);

	if (VAR_1->dma_ops && VAR_1->dma_ops->dma_init) {
		VAR_3 = VAR_1->dma_ops->dma_init(VAR_1);
		if (VAR_3) {
			dev_warn(VAR_0, ""DMA init failed\n"");
			VAR_1->dma_inited = 0;
		} else {
			VAR_2->can_dma = VAR_1->dma_ops->can_dma;
		}
	}

	VAR_3 = devm_spi_register_controller(VAR_0, VAR_2);
	if (VAR_3) {
		dev_err(&VAR_2->dev, ""problem registering spi master\n"");
		goto err_dma_exit;
	}

	dw_spi_debugfs_init(VAR_1);
	return 0;

err_dma_exit:
	if (VAR_1->dma_ops && VAR_1->dma_ops->dma_exit)
		VAR_1->dma_ops->dma_exit(VAR_1);
	spi_enable_chip(VAR_1, 0);
	free_irq(VAR_1->irq, VAR_2);
err_free_master:
	spi_controller_put(VAR_2);
	return VAR_3;
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -13,6 +13,7 @@
 	dws->type = SSI_MOTO_SPI;
 	dws->dma_inited = 0;
 	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
+	spin_lock_init(&dws->buf_lock);
 
 	spi_controller_set_devdata(master, dws);
 ","{'deleted_lines': [], 'added_lines': ['\tspin_lock_init(&dws->buf_lock);']}",True,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",5.5,MEDIUM,1,valid,,5
CVE-2020-12769,['CWE-662'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"dw_spi_irq() and dw_spi_transfer_one concurrent calls.

I find a panic in dw_writer(): txw = *(u8 *)(dws->tx), when dw->tx==null,
dw->len==4, and dw->tx_end==1.

When tpm driver's message overtime dw_spi_irq() and dw_spi_transfer_one
may concurrent visit dw_spi, so I think dw_spi structure lack of protection.

Otherwise dw_spi_transfer_one set dw rx/tx buffer and then open irq,
store dw rx/tx instructions and other cores handle irq load dw rx/tx
instructions may out of order.

	[ 1025.321302] Call trace:
	...
	[ 1025.321319]  __crash_kexec+0x98/0x148
	[ 1025.321323]  panic+0x17c/0x314
	[ 1025.321329]  die+0x29c/0x2e8
	[ 1025.321334]  die_kernel_fault+0x68/0x78
	[ 1025.321337]  __do_kernel_fault+0x90/0xb0
	[ 1025.321346]  do_page_fault+0x88/0x500
	[ 1025.321347]  do_translation_fault+0xa8/0xb8
	[ 1025.321349]  do_mem_abort+0x68/0x118
	[ 1025.321351]  el1_da+0x20/0x8c
	[ 1025.321362]  dw_writer+0xc8/0xd0
	[ 1025.321364]  interrupt_transfer+0x60/0x110
	[ 1025.321365]  dw_spi_irq+0x48/0x70
	...

Signed-off-by: wuxu.wu <wuxu.wu@huawei.com>
Link: https://lore.kernel.org/r/1577849981-31489-1-git-send-email-wuxu.wu@huawei.com
Signed-off-by: Mark Brown <broonie@kernel.org>
",19b61392c5a852b4e8a0bf35aecb969983c5932d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=19b61392c5a852b4e8a0bf35aecb969983c5932d,drivers/spi/spi-dw.c,dw_writer,"static void dw_writer(struct dw_spi *dws)
{
u32 max = tx_max(dws);
u16 txw = 0;
while (max--) {
if (dws->tx_end - dws->len) {
if (dws->n_bytes == 1)
txw = *(u8 *)(dws->tx);
else
txw = *(u16 *)(dws->tx);
}
dw_write_io_reg(dws, DW_SPI_DR, txw);
dws->tx += dws->n_bytes;
}
}","static void dw_writer(struct dw_spi *VAR_0)
{
u32 VAR_1 = tx_max(VAR_0);
u16 VAR_2 = 0;
while (VAR_1--) {
if (VAR_0->tx_end - VAR_0->len) {
if (VAR_0->n_bytes == 1)
VAR_2 = *(u8 *)(VAR_0->tx);
else
VAR_2 = *(u16 *)(VAR_0->tx);
}
dw_write_io_reg(VAR_0, VAR_3, VAR_2);
VAR_0->tx += VAR_0->n_bytes;
}
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/before/2.json,"static void dw_writer(struct dw_spi *dws)
{
	u32 max;
	u16 txw = 0;

	spin_lock(&dws->buf_lock);
	max = tx_max(dws);
	while (max--) {
		/* Set the tx word if the transfer's original ""tx"" is not null */
		if (dws->tx_end - dws->len) {
			if (dws->n_bytes == 1)
				txw = *(u8 *)(dws->tx);
			else
				txw = *(u16 *)(dws->tx);
		}
		dw_write_io_reg(dws, DW_SPI_DR, txw);
		dws->tx += dws->n_bytes;
	}
	spin_unlock(&dws->buf_lock);
}","static void dw_writer(struct dw_spi *VAR_0)
{
	u32 VAR_1;
	u16 VAR_2 = 0;

	spin_lock(&VAR_0->buf_lock);
	VAR_1 = tx_max(VAR_0);
	while (VAR_1--) {
		/* COMMENT_0 */
		if (VAR_0->tx_end - VAR_0->len) {
			if (VAR_0->n_bytes == 1)
				VAR_2 = *(u8 *)(VAR_0->tx);
			else
				VAR_2 = *(u16 *)(VAR_0->tx);
		}
		dw_write_io_reg(VAR_0, VAR_3, VAR_2);
		VAR_0->tx += VAR_0->n_bytes;
	}
	spin_unlock(&VAR_0->buf_lock);
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,8 +1,10 @@
 static void dw_writer(struct dw_spi *dws)
 {
-	u32 max = tx_max(dws);
+	u32 max;
 	u16 txw = 0;
 
+	spin_lock(&dws->buf_lock);
+	max = tx_max(dws);
 	while (max--) {
 		/* Set the tx word if the transfer's original ""tx"" is not null */
 		if (dws->tx_end - dws->len) {
@@ -14,4 +16,5 @@
 		dw_write_io_reg(dws, DW_SPI_DR, txw);
 		dws->tx += dws->n_bytes;
 	}
+	spin_unlock(&dws->buf_lock);
 }","{'deleted_lines': ['\tu32 max = tx_max(dws);'], 'added_lines': ['\tu32 max;', '\tspin_lock(&dws->buf_lock);', '\tmax = tx_max(dws);', '\tspin_unlock(&dws->buf_lock);']}",True,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",5.5,MEDIUM,1,valid,,5
CVE-2020-12769,['CWE-662'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"dw_spi_irq() and dw_spi_transfer_one concurrent calls.

I find a panic in dw_writer(): txw = *(u8 *)(dws->tx), when dw->tx==null,
dw->len==4, and dw->tx_end==1.

When tpm driver's message overtime dw_spi_irq() and dw_spi_transfer_one
may concurrent visit dw_spi, so I think dw_spi structure lack of protection.

Otherwise dw_spi_transfer_one set dw rx/tx buffer and then open irq,
store dw rx/tx instructions and other cores handle irq load dw rx/tx
instructions may out of order.

	[ 1025.321302] Call trace:
	...
	[ 1025.321319]  __crash_kexec+0x98/0x148
	[ 1025.321323]  panic+0x17c/0x314
	[ 1025.321329]  die+0x29c/0x2e8
	[ 1025.321334]  die_kernel_fault+0x68/0x78
	[ 1025.321337]  __do_kernel_fault+0x90/0xb0
	[ 1025.321346]  do_page_fault+0x88/0x500
	[ 1025.321347]  do_translation_fault+0xa8/0xb8
	[ 1025.321349]  do_mem_abort+0x68/0x118
	[ 1025.321351]  el1_da+0x20/0x8c
	[ 1025.321362]  dw_writer+0xc8/0xd0
	[ 1025.321364]  interrupt_transfer+0x60/0x110
	[ 1025.321365]  dw_spi_irq+0x48/0x70
	...

Signed-off-by: wuxu.wu <wuxu.wu@huawei.com>
Link: https://lore.kernel.org/r/1577849981-31489-1-git-send-email-wuxu.wu@huawei.com
Signed-off-by: Mark Brown <broonie@kernel.org>
",19b61392c5a852b4e8a0bf35aecb969983c5932d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=19b61392c5a852b4e8a0bf35aecb969983c5932d,drivers/spi/spi-dw.c,dw_spi_transfer_one,"static int dw_spi_transfer_one(struct spi_controller *master,
struct spi_device *spi, struct spi_transfer *transfer)
{
struct dw_spi *dws = spi_controller_get_devdata(master);
struct chip_data *chip = spi_get_ctldata(spi);
u8 imask = 0;
u16 txlevel = 0;
u32 cr0;
int ret;
dws->dma_mapped = 0;
dws->tx = (void *)transfer->tx_buf;
dws->tx_end = dws->tx + transfer->len;
dws->rx = transfer->rx_buf;
dws->rx_end = dws->rx + transfer->len;
dws->len = transfer->len;
spi_enable_chip(dws, 0);
if (transfer->speed_hz != dws->current_freq) {
if (transfer->speed_hz != chip->speed_hz) {
chip->clk_div = (DIV_ROUND_UP(dws->max_freq, transfer->speed_hz) + 1) & 0xfffe;
chip->speed_hz = transfer->speed_hz;
}
dws->current_freq = transfer->speed_hz;
spi_set_clk(dws, chip->clk_div);
}
dws->n_bytes = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);
dws->dma_width = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);
cr0 = (transfer->bits_per_word - 1)
| (chip->type << SPI_FRF_OFFSET)
| ((((spi->mode & SPI_CPOL) ? 1 : 0) << SPI_SCOL_OFFSET) |
(((spi->mode & SPI_CPHA) ? 1 : 0) << SPI_SCPH_OFFSET))
| (chip->tmode << SPI_TMOD_OFFSET);
if (chip->cs_control) {
if (dws->rx && dws->tx)
chip->tmode = SPI_TMOD_TR;
else if (dws->rx)
chip->tmode = SPI_TMOD_RO;
else
chip->tmode = SPI_TMOD_TO;
cr0 &= ~SPI_TMOD_MASK;
cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
}
dw_writel(dws, DW_SPI_CTRL0, cr0);
if (master->can_dma && master->can_dma(master, spi, transfer))
dws->dma_mapped = master->cur_msg_mapped;
spi_mask_intr(dws, 0xff);
if (dws->dma_mapped) {
ret = dws->dma_ops->dma_setup(dws, transfer);
if (ret < 0) {
spi_enable_chip(dws, 1);
return ret;
}
} else if (!chip->poll_mode) {
txlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);
dw_writel(dws, DW_SPI_TXFLTR, txlevel);
imask |= SPI_INT_TXEI | SPI_INT_TXOI |
SPI_INT_RXUI | SPI_INT_RXOI;
spi_umask_intr(dws, imask);
dws->transfer_handler = interrupt_transfer;
}
spi_enable_chip(dws, 1);
if (dws->dma_mapped) {
ret = dws->dma_ops->dma_transfer(dws, transfer);
if (ret < 0)
return ret;
}
if (chip->poll_mode)
return poll_transfer(dws);
return 1;
}","static int dw_spi_transfer_one(struct spi_controller *VAR_0,
struct spi_device *VAR_1, struct spi_transfer *VAR_2)
{
struct dw_spi *VAR_3 = spi_controller_get_devdata(VAR_0);
struct chip_data *VAR_4 = spi_get_ctldata(VAR_1);
u8 VAR_5 = 0;
u16 VAR_6 = 0;
u32 VAR_7;
int VAR_8;
VAR_3->dma_mapped = 0;
VAR_3->tx = (void *)VAR_2->tx_buf;
VAR_3->tx_end = VAR_3->tx + VAR_2->len;
VAR_3->rx = VAR_2->rx_buf;
VAR_3->rx_end = VAR_3->rx + VAR_2->len;
VAR_3->len = VAR_2->len;
spi_enable_chip(VAR_3, 0);
if (VAR_2->speed_hz != VAR_3->current_freq) {
if (VAR_2->speed_hz != VAR_4->speed_hz) {
VAR_4->clk_div = (DIV_ROUND_UP(VAR_3->max_freq, VAR_2->speed_hz) + 1) & 0xfffe;
VAR_4->speed_hz = VAR_2->speed_hz;
}
VAR_3->current_freq = VAR_2->speed_hz;
spi_set_clk(VAR_3, VAR_4->clk_div);
}
VAR_3->n_bytes = DIV_ROUND_UP(VAR_2->bits_per_word, VAR_9);
VAR_3->dma_width = DIV_ROUND_UP(VAR_2->bits_per_word, VAR_9);
VAR_7 = (VAR_2->bits_per_word - 1)
| (VAR_4->type << VAR_10)
| ((((VAR_1->mode & VAR_11) ? 1 : 0) << VAR_12) |
(((VAR_1->mode & VAR_13) ? 1 : 0) << VAR_14))
| (VAR_4->tmode << VAR_15);
if (VAR_4->cs_control) {
if (VAR_3->rx && VAR_3->tx)
VAR_4->tmode = VAR_16;
else if (VAR_3->rx)
VAR_4->tmode = VAR_17;
else
VAR_4->tmode = VAR_18;
VAR_7 &= ~VAR_19;
VAR_7 |= (VAR_4->tmode << VAR_15);
}
dw_writel(VAR_3, VAR_20, VAR_7);
if (VAR_0->can_dma && VAR_0->can_dma(VAR_0, VAR_1, VAR_2))
VAR_3->dma_mapped = VAR_0->cur_msg_mapped;
spi_mask_intr(VAR_3, 0xff);
if (VAR_3->dma_mapped) {
VAR_8 = VAR_3->dma_ops->dma_setup(VAR_3, VAR_2);
if (VAR_8 < 0) {
spi_enable_chip(VAR_3, 1);
return VAR_8;
}
} else if (!VAR_4->poll_mode) {
VAR_6 = min_t(u16, VAR_3->fifo_len / 2, VAR_3->len / VAR_3->n_bytes);
dw_writel(VAR_3, VAR_21, VAR_6);
VAR_5 |= VAR_22 | VAR_23 |
VAR_24 | VAR_25;
spi_umask_intr(VAR_3, VAR_5);
VAR_3->transfer_handler = VAR_26;
}
spi_enable_chip(VAR_3, 1);
if (VAR_3->dma_mapped) {
VAR_8 = VAR_3->dma_ops->dma_transfer(VAR_3, VAR_2);
if (VAR_8 < 0)
return VAR_8;
}
if (VAR_4->poll_mode)
return poll_transfer(VAR_3);
return 1;
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/before/3.json,"static int dw_spi_transfer_one(struct spi_controller *master,
		struct spi_device *spi, struct spi_transfer *transfer)
{
	struct dw_spi *dws = spi_controller_get_devdata(master);
	struct chip_data *chip = spi_get_ctldata(spi);
	unsigned long flags;
	u8 imask = 0;
	u16 txlevel = 0;
	u32 cr0;
	int ret;

	dws->dma_mapped = 0;
	spin_lock_irqsave(&dws->buf_lock, flags);
	dws->tx = (void *)transfer->tx_buf;
	dws->tx_end = dws->tx + transfer->len;
	dws->rx = transfer->rx_buf;
	dws->rx_end = dws->rx + transfer->len;
	dws->len = transfer->len;
	spin_unlock_irqrestore(&dws->buf_lock, flags);

	spi_enable_chip(dws, 0);

	/* Handle per transfer options for bpw and speed */
	if (transfer->speed_hz != dws->current_freq) {
		if (transfer->speed_hz != chip->speed_hz) {
			/* clk_div doesn't support odd number */
			chip->clk_div = (DIV_ROUND_UP(dws->max_freq, transfer->speed_hz) + 1) & 0xfffe;
			chip->speed_hz = transfer->speed_hz;
		}
		dws->current_freq = transfer->speed_hz;
		spi_set_clk(dws, chip->clk_div);
	}

	dws->n_bytes = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);
	dws->dma_width = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);

	/* Default SPI mode is SCPOL = 0, SCPH = 0 */
	cr0 = (transfer->bits_per_word - 1)
		| (chip->type << SPI_FRF_OFFSET)
		| ((((spi->mode & SPI_CPOL) ? 1 : 0) << SPI_SCOL_OFFSET) |
			(((spi->mode & SPI_CPHA) ? 1 : 0) << SPI_SCPH_OFFSET))
		| (chip->tmode << SPI_TMOD_OFFSET);

	/*
	 * Adjust transfer mode if necessary. Requires platform dependent
	 * chipselect mechanism.
	 */
	if (chip->cs_control) {
		if (dws->rx && dws->tx)
			chip->tmode = SPI_TMOD_TR;
		else if (dws->rx)
			chip->tmode = SPI_TMOD_RO;
		else
			chip->tmode = SPI_TMOD_TO;

		cr0 &= ~SPI_TMOD_MASK;
		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
	}

	dw_writel(dws, DW_SPI_CTRL0, cr0);

	/* Check if current transfer is a DMA transaction */
	if (master->can_dma && master->can_dma(master, spi, transfer))
		dws->dma_mapped = master->cur_msg_mapped;

	/* For poll mode just disable all interrupts */
	spi_mask_intr(dws, 0xff);

	/*
	 * Interrupt mode
	 * we only need set the TXEI IRQ, as TX/RX always happen syncronizely
	 */
	if (dws->dma_mapped) {
		ret = dws->dma_ops->dma_setup(dws, transfer);
		if (ret < 0) {
			spi_enable_chip(dws, 1);
			return ret;
		}
	} else if (!chip->poll_mode) {
		txlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);
		dw_writel(dws, DW_SPI_TXFLTR, txlevel);

		/* Set the interrupt mask */
		imask |= SPI_INT_TXEI | SPI_INT_TXOI |
			 SPI_INT_RXUI | SPI_INT_RXOI;
		spi_umask_intr(dws, imask);

		dws->transfer_handler = interrupt_transfer;
	}

	spi_enable_chip(dws, 1);

	if (dws->dma_mapped) {
		ret = dws->dma_ops->dma_transfer(dws, transfer);
		if (ret < 0)
			return ret;
	}

	if (chip->poll_mode)
		return poll_transfer(dws);

	return 1;
}","static int dw_spi_transfer_one(struct spi_controller *VAR_0,
		struct spi_device *VAR_1, struct spi_transfer *VAR_2)
{
	struct dw_spi *VAR_3 = spi_controller_get_devdata(VAR_0);
	struct chip_data *VAR_4 = spi_get_ctldata(VAR_1);
	unsigned long VAR_5;
	u8 VAR_6 = 0;
	u16 VAR_7 = 0;
	u32 VAR_8;
	int VAR_9;

	VAR_3->dma_mapped = 0;
	spin_lock_irqsave(&VAR_3->buf_lock, VAR_5);
	VAR_3->tx = (void *)VAR_2->tx_buf;
	VAR_3->tx_end = VAR_3->tx + VAR_2->len;
	VAR_3->rx = VAR_2->rx_buf;
	VAR_3->rx_end = VAR_3->rx + VAR_2->len;
	VAR_3->len = VAR_2->len;
	spin_unlock_irqrestore(&VAR_3->buf_lock, VAR_5);

	spi_enable_chip(VAR_3, 0);

	/* COMMENT_0 */
	if (VAR_2->speed_hz != VAR_3->current_freq) {
		if (VAR_2->speed_hz != VAR_4->speed_hz) {
			/* COMMENT_1 */
			VAR_4->clk_div = (DIV_ROUND_UP(VAR_3->max_freq, VAR_2->speed_hz) + 1) & 0xfffe;
			VAR_4->speed_hz = VAR_2->speed_hz;
		}
		VAR_3->current_freq = VAR_2->speed_hz;
		spi_set_clk(VAR_3, VAR_4->clk_div);
	}

	VAR_3->n_bytes = DIV_ROUND_UP(VAR_2->bits_per_word, VAR_10);
	VAR_3->dma_width = DIV_ROUND_UP(VAR_2->bits_per_word, VAR_10);

	/* COMMENT_2 */
	VAR_8 = (VAR_2->bits_per_word - 1)
		| (VAR_4->type << VAR_11)
		| ((((VAR_1->mode & VAR_12) ? 1 : 0) << VAR_13) |
			(((VAR_1->mode & VAR_14) ? 1 : 0) << VAR_15))
		| (VAR_4->tmode << VAR_16);

	/* COMMENT_3 */
                                                                  
                         
    
	if (VAR_4->cs_control) {
		if (VAR_3->rx && VAR_3->tx)
			VAR_4->tmode = VAR_17;
		else if (VAR_3->rx)
			VAR_4->tmode = VAR_18;
		else
			VAR_4->tmode = VAR_19;

		VAR_8 &= ~VAR_20;
		VAR_8 |= (VAR_4->tmode << VAR_16);
	}

	dw_writel(VAR_3, VAR_21, VAR_8);

	/* COMMENT_7 */
	if (VAR_0->can_dma && VAR_0->can_dma(VAR_0, VAR_1, VAR_2))
		VAR_3->dma_mapped = VAR_0->cur_msg_mapped;

	/* COMMENT_8 */
	spi_mask_intr(VAR_3, 0xff);

	/* COMMENT_9 */
                  
                                                                      
    
	if (VAR_3->dma_mapped) {
		VAR_9 = VAR_3->dma_ops->dma_setup(VAR_3, VAR_2);
		if (VAR_9 < 0) {
			spi_enable_chip(VAR_3, 1);
			return VAR_9;
		}
	} else if (!VAR_4->poll_mode) {
		VAR_7 = min_t(u16, VAR_3->fifo_len / 2, VAR_3->len / VAR_3->n_bytes);
		dw_writel(VAR_3, VAR_22, VAR_7);

		/* COMMENT_13 */
		VAR_6 |= VAR_23 | VAR_24 |
			 VAR_25 | VAR_26;
		spi_umask_intr(VAR_3, VAR_6);

		VAR_3->transfer_handler = VAR_27;
	}

	spi_enable_chip(VAR_3, 1);

	if (VAR_3->dma_mapped) {
		VAR_9 = VAR_3->dma_ops->dma_transfer(VAR_3, VAR_2);
		if (VAR_9 < 0)
			return VAR_9;
	}

	if (VAR_4->poll_mode)
		return poll_transfer(VAR_3);

	return 1;
}",torvalds/linux/19b61392c5a852b4e8a0bf35aecb969983c5932d/spi-dw.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,18 +3,20 @@
 {
 	struct dw_spi *dws = spi_controller_get_devdata(master);
 	struct chip_data *chip = spi_get_ctldata(spi);
+	unsigned long flags;
 	u8 imask = 0;
 	u16 txlevel = 0;
 	u32 cr0;
 	int ret;
 
 	dws->dma_mapped = 0;
-
+	spin_lock_irqsave(&dws->buf_lock, flags);
 	dws->tx = (void *)transfer->tx_buf;
 	dws->tx_end = dws->tx + transfer->len;
 	dws->rx = transfer->rx_buf;
 	dws->rx_end = dws->rx + transfer->len;
 	dws->len = transfer->len;
+	spin_unlock_irqrestore(&dws->buf_lock, flags);
 
 	spi_enable_chip(dws, 0);
 ","{'deleted_lines': [''], 'added_lines': ['\tunsigned long flags;', '\tspin_lock_irqsave(&dws->buf_lock, flags);', '\tspin_unlock_irqrestore(&dws->buf_lock, flags);']}",True,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",5.5,MEDIUM,1,valid,,5
CVE-2020-10757,"['CWE-843', 'CWE-119']",AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The original code in mm/mremap.c checks huge pmd by:

		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {

However, a DAX mapped nvdimm is mapped as huge page (by default) but it
is not transparent huge page (_PAGE_PSE | PAGE_DEVMAP).  This commit
changes the condition to include the case.

This addresses CVE-2020-10757.

Fixes: 5c7fb56e5e3f (""mm, dax: dax-pmd vs thp-pmd vs hugetlbfs-pmd"")
Cc: <stable@vger.kernel.org>
Reported-by: Fan Yang <Fan_Yang@sjtu.edu.cn>
Signed-off-by: Fan Yang <Fan_Yang@sjtu.edu.cn>
Tested-by: Fan Yang <Fan_Yang@sjtu.edu.cn>
Tested-by: Dan Williams <dan.j.williams@intel.com>
Reviewed-by: Dan Williams <dan.j.williams@intel.com>
Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",5bfea2d9b17f1034a68147a8b03b9789af5700f9,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5bfea2d9b17f1034a68147a8b03b9789af5700f9,mm/mremap.c,move_page_tables,"unsigned long move_page_tables(struct vm_area_struct *vma,
unsigned long old_addr, struct vm_area_struct *new_vma,
unsigned long new_addr, unsigned long len,
bool need_rmap_locks)
{
unsigned long extent, next, old_end;
struct mmu_notifier_range range;
pmd_t *old_pmd, *new_pmd;
old_end = old_addr + len;
flush_cache_range(vma, old_addr, old_end);
mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,
old_addr, old_end);
mmu_notifier_invalidate_range_start(&range);
for (; old_addr < old_end; old_addr += extent, new_addr += extent) {
cond_resched();
next = (old_addr + PMD_SIZE) & PMD_MASK;
extent = next - old_addr;
if (extent > old_end - old_addr)
extent = old_end - old_addr;
old_pmd = get_old_pmd(vma->vm_mm, old_addr);
if (!old_pmd)
continue;
new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);
if (!new_pmd)
break;
if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {
if (extent == HPAGE_PMD_SIZE) {
bool moved;
if (need_rmap_locks)
take_rmap_locks(vma);
moved = move_huge_pmd(vma, old_addr, new_addr,
old_end, old_pmd, new_pmd);
if (need_rmap_locks)
drop_rmap_locks(vma);
if (moved)
continue;
}
split_huge_pmd(vma, old_pmd, old_addr);
if (pmd_trans_unstable(old_pmd))
continue;
} else if (extent == PMD_SIZE) {
#ifdef CONFIG_HAVE_MOVE_PMD
bool moved;
if (need_rmap_locks)
take_rmap_locks(vma);
moved = move_normal_pmd(vma, old_addr, new_addr,
old_end, old_pmd, new_pmd);
if (need_rmap_locks)
drop_rmap_locks(vma);
if (moved)
continue;
#endif
}
if (pte_alloc(new_vma->vm_mm, new_pmd))
break;
next = (new_addr + PMD_SIZE) & PMD_MASK;
if (extent > next - new_addr)
extent = next - new_addr;
move_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,
new_pmd, new_addr, need_rmap_locks);
}
mmu_notifier_invalidate_range_end(&range);
return len + old_addr - old_end;
}","unsigned long move_page_tables(struct vm_area_struct *VAR_0,
unsigned long VAR_1, struct vm_area_struct *VAR_2,
unsigned long VAR_3, unsigned long VAR_4,
bool VAR_5)
{
unsigned long VAR_6, VAR_7, VAR_8;
struct mmu_notifier_range VAR_9;
pmd_t *VAR_10, *VAR_11;
VAR_8 = VAR_1 + VAR_4;
flush_cache_range(VAR_0, VAR_1, VAR_8);
mmu_notifier_range_init(&VAR_9, VAR_12, 0, VAR_0, VAR_0->vm_mm,
VAR_1, VAR_8);
mmu_notifier_invalidate_range_start(&VAR_9);
for (; VAR_1 < VAR_8; VAR_1 += VAR_6, VAR_3 += VAR_6) {
cond_resched();
VAR_7 = (VAR_1 + VAR_13) & VAR_14;
VAR_6 = VAR_7 - VAR_1;
if (VAR_6 > VAR_8 - VAR_1)
VAR_6 = VAR_8 - VAR_1;
VAR_10 = get_old_pmd(VAR_0->vm_mm, VAR_1);
if (!VAR_10)
continue;
VAR_11 = alloc_new_pmd(VAR_0->vm_mm, VAR_0, VAR_3);
if (!VAR_11)
break;
if (is_swap_pmd(*VAR_10) || pmd_trans_huge(*VAR_10)) {
if (VAR_6 == VAR_15) {
bool VAR_16;
if (VAR_5)
take_rmap_locks(VAR_0);
VAR_16 = move_huge_pmd(VAR_0, VAR_1, VAR_3,
VAR_8, VAR_10, VAR_11);
if (VAR_5)
drop_rmap_locks(VAR_0);
if (VAR_16)
continue;
}
split_huge_pmd(VAR_0, VAR_10, VAR_1);
if (pmd_trans_unstable(VAR_10))
continue;
} else if (VAR_6 == VAR_13) {
#ifdef VAR_17
bool VAR_16;
if (VAR_5)
take_rmap_locks(VAR_0);
VAR_16 = move_normal_pmd(VAR_0, VAR_1, VAR_3,
VAR_8, VAR_10, VAR_11);
if (VAR_5)
drop_rmap_locks(VAR_0);
if (VAR_16)
continue;
#endif
}
if (pte_alloc(VAR_2->vm_mm, VAR_11))
break;
VAR_7 = (VAR_3 + VAR_13) & VAR_14;
if (VAR_6 > VAR_7 - VAR_3)
VAR_6 = VAR_7 - VAR_3;
move_ptes(VAR_0, VAR_10, VAR_1, VAR_1 + VAR_6, VAR_2,
VAR_11, VAR_3, VAR_5);
}
mmu_notifier_invalidate_range_end(&VAR_9);
return VAR_4 + VAR_1 - VAR_8;
}",torvalds/linux/5bfea2d9b17f1034a68147a8b03b9789af5700f9/mremap.c/vul/before/0.json,"unsigned long move_page_tables(struct vm_area_struct *vma,
		unsigned long old_addr, struct vm_area_struct *new_vma,
		unsigned long new_addr, unsigned long len,
		bool need_rmap_locks)
{
	unsigned long extent, next, old_end;
	struct mmu_notifier_range range;
	pmd_t *old_pmd, *new_pmd;

	old_end = old_addr + len;
	flush_cache_range(vma, old_addr, old_end);

	mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,
				old_addr, old_end);
	mmu_notifier_invalidate_range_start(&range);

	for (; old_addr < old_end; old_addr += extent, new_addr += extent) {
		cond_resched();
		next = (old_addr + PMD_SIZE) & PMD_MASK;
		/* even if next overflowed, extent below will be ok */
		extent = next - old_addr;
		if (extent > old_end - old_addr)
			extent = old_end - old_addr;
		old_pmd = get_old_pmd(vma->vm_mm, old_addr);
		if (!old_pmd)
			continue;
		new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);
		if (!new_pmd)
			break;
		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {
			if (extent == HPAGE_PMD_SIZE) {
				bool moved;
				/* See comment in move_ptes() */
				if (need_rmap_locks)
					take_rmap_locks(vma);
				moved = move_huge_pmd(vma, old_addr, new_addr,
						    old_end, old_pmd, new_pmd);
				if (need_rmap_locks)
					drop_rmap_locks(vma);
				if (moved)
					continue;
			}
			split_huge_pmd(vma, old_pmd, old_addr);
			if (pmd_trans_unstable(old_pmd))
				continue;
		} else if (extent == PMD_SIZE) {
#ifdef CONFIG_HAVE_MOVE_PMD
			/*
			 * If the extent is PMD-sized, try to speed the move by
			 * moving at the PMD level if possible.
			 */
			bool moved;

			if (need_rmap_locks)
				take_rmap_locks(vma);
			moved = move_normal_pmd(vma, old_addr, new_addr,
					old_end, old_pmd, new_pmd);
			if (need_rmap_locks)
				drop_rmap_locks(vma);
			if (moved)
				continue;
#endif
		}

		if (pte_alloc(new_vma->vm_mm, new_pmd))
			break;
		next = (new_addr + PMD_SIZE) & PMD_MASK;
		if (extent > next - new_addr)
			extent = next - new_addr;
		move_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,
			  new_pmd, new_addr, need_rmap_locks);
	}

	mmu_notifier_invalidate_range_end(&range);

	return len + old_addr - old_end;	/* how much done */
}","unsigned long move_page_tables(struct vm_area_struct *VAR_0,
		unsigned long VAR_1, struct vm_area_struct *VAR_2,
		unsigned long VAR_3, unsigned long VAR_4,
		bool VAR_5)
{
	unsigned long VAR_6, VAR_7, VAR_8;
	struct mmu_notifier_range VAR_9;
	pmd_t *VAR_10, *VAR_11;

	VAR_8 = VAR_1 + VAR_4;
	flush_cache_range(VAR_0, VAR_1, VAR_8);

	mmu_notifier_range_init(&VAR_9, VAR_12, 0, VAR_0, VAR_0->vm_mm,
				VAR_1, VAR_8);
	mmu_notifier_invalidate_range_start(&VAR_9);

	for (; VAR_1 < VAR_8; VAR_1 += VAR_6, VAR_3 += VAR_6) {
		cond_resched();
		VAR_7 = (VAR_1 + VAR_13) & VAR_14;
		/* COMMENT_0 */
		VAR_6 = VAR_7 - VAR_1;
		if (VAR_6 > VAR_8 - VAR_1)
			VAR_6 = VAR_8 - VAR_1;
		VAR_10 = get_old_pmd(VAR_0->vm_mm, VAR_1);
		if (!VAR_10)
			continue;
		VAR_11 = alloc_new_pmd(VAR_0->vm_mm, VAR_0, VAR_3);
		if (!VAR_11)
			break;
		if (is_swap_pmd(*VAR_10) || pmd_trans_huge(*VAR_10) || pmd_devmap(*VAR_10)) {
			if (VAR_6 == VAR_15) {
				bool VAR_16;
				/* COMMENT_1 */
				if (VAR_5)
					take_rmap_locks(VAR_0);
				VAR_16 = move_huge_pmd(VAR_0, VAR_1, VAR_3,
						    VAR_8, VAR_10, VAR_11);
				if (VAR_5)
					drop_rmap_locks(VAR_0);
				if (VAR_16)
					continue;
			}
			split_huge_pmd(VAR_0, VAR_10, VAR_1);
			if (pmd_trans_unstable(VAR_10))
				continue;
		} else if (VAR_6 == VAR_13) {
#ifdef VAR_17
			/* COMMENT_2 */
                                                          
                                          
      
			bool VAR_16;

			if (VAR_5)
				take_rmap_locks(VAR_0);
			VAR_16 = move_normal_pmd(VAR_0, VAR_1, VAR_3,
					VAR_8, VAR_10, VAR_11);
			if (VAR_5)
				drop_rmap_locks(VAR_0);
			if (VAR_16)
				continue;
#endif
		}

		if (pte_alloc(VAR_2->vm_mm, VAR_11))
			break;
		VAR_7 = (VAR_3 + VAR_13) & VAR_14;
		if (VAR_6 > VAR_7 - VAR_3)
			VAR_6 = VAR_7 - VAR_3;
		move_ptes(VAR_0, VAR_10, VAR_1, VAR_1 + VAR_6, VAR_2,
			  VAR_11, VAR_3, VAR_5);
	}

	mmu_notifier_invalidate_range_end(&VAR_9);

	return VAR_4 + VAR_1 - VAR_8;	/* COMMENT_6 */
}",torvalds/linux/5bfea2d9b17f1034a68147a8b03b9789af5700f9/mremap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
 		new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);
 		if (!new_pmd)
 			break;
-		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {
+		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {
 			if (extent == HPAGE_PMD_SIZE) {
 				bool moved;
 				/* See comment in move_ptes() */","{'deleted_lines': ['\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {'], 'added_lines': ['\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {']}",True,A flaw was found in the Linux Kernel in versions after 4.5-rc1 in the way mremap handled DAX Huge Pages. This flaw allows a local attacker with access to a DAX enabled storage to escalate their privileges on the system.,7.8,HIGH,2,valid,,5
